tor returned in a 
**		conference query confirm.  This holds information about the
**		conferences that exists at the queried node.
*/
typedef struct
{
	GCCConferenceName		conference_name;
	GCCNumericString		conference_name_modifier;	/* optional */
	LPWSTR					conference_descriptor;		/* optional */
	BOOL				conference_is_locked;
	BOOL				password_in_the_clear_required;
	UINT    			number_of_network_addresses;
	GCCNetworkAddress **	network_address_list;		/* optional */
}
    GCCConferenceDescriptor, *PGCCConferenceDescriptor, GCCConfDescriptor, *PGCCConfDescriptor;

/*
**	ConferencePrivileges
**		This structure defines the list of privileges that can be assigned to
**		a particular conference. 
*/
typedef struct
{
	BOOL		terminate_is_allowed;
	BOOL		eject_user_is_allowed;
	BOOL		add_is_allowed;
	BOOL		lock_unlock_is_allowed;
	BOOL		transfer_is_allowed;
}
    GCCConferencePrivileges, *PGCCConferencePrivileges, GCCConfPrivileges, *PGCCConfPrivileges;

/************************************************************************
*																		*
*					User Application Related Typedefs					*
*																		*
*************************************************************************/

/*
**	GCCSessionKey
**		This is a unique identifier for an application that is
**		using GCC.  See the T.124 for the specifics on what an application
**		key should look like.  A session id of zero indicates that it is
**		not being used.
*/
typedef struct tagT120SessionKey
{
	GCCObjectKey		application_protocol_key;
	GCCSessionID		session_id;
}
    T120SessionKey, GCCSessionKey, *PGCCSessionKey;


/*
**	CapabilityType
**		T.124 supports three different rules when collapsing the capabilities
**		list.  "Logical" keeps a count of the Application Protocol Entities 
**		(APEs) that have that capability, "Unsigned Minimum" collapses to the 
**		minimum value and "Unsigned	Maximum" collapses to the maximum value.		
*/
typedef AppletCapabilityType            GCCCapabilityType, GCCCapType, *PGCCCapabilityType, *PGCCCapType;
#define GCC_UNKNOWN_CAP_TYPE            APPLET_UNKNOWN_CAP_TYPE
#define GCC_LOGICAL_CAPABILITY          APPLET_LOGICAL_CAPABILITY
#define GCC_UNSIGNED_MINIMUM_CAPABILITY APPLET_UNSIGNED_MINIMUM_CAPABILITY
#define GCC_UNSIGNED_MAXIMUM_CAPABILITY APPLET_UNSIGNED_MAXIMUM_CAPABILITY

typedef AppletCapIDType             T120CapabilityIDType, T120CapIDType, GCCCapabilityIDType, GCCCapIDType, *PGCCCapabilityIDType, *PGCCCapIDType;
#define GCC_STANDARD_CAPABILITY     APPLET_STANDARD_CAPABILITY
#define GCC_NON_STANDARD_CAPABILITY APPLET_NONSTD_CAPABILITY


/*
**	CapabilityID
**		T.124 supports both standard and non-standard capabilities.  This
**		structure is used to differentiate between the two.		
*/
typedef struct tagT120CapID
{
    GCCCapabilityIDType	capability_id_type;
    GCCObjectKey		non_standard_capability;
    ULONG               standard_capability;
}
    T120CapID, GCCCapabilityID, GCCCapID, *PGCCCapabilityID, *PGCCCapID;

/* 
**	CapabilityClass
**		This structure defines the class of capability and holds the associated
**		value. Note that Logical is not necessary.  Information associated with 
**		logical is stored in number_of_entities in the GCCApplicationCapability 
**		structure.
*/

typedef AppletCapabilityClass       T120CapClass, GCCCapabilityClass, GCCCapClass, *PGCCCapabilityClass, *PGCCCapClass;


/* 
**	GCCApplicationCapability
**		This structure holds all the data associated with a single T.124 
**		defined application capability.
*/
typedef struct tagT120AppCap
{
	GCCCapabilityID			capability_id;
	GCCCapabilityClass		capability_class;
    ULONG                   number_of_entities;
}
    T120AppCap, GCCApplicationCapability, GCCAppCap, *PGCCApplicationCapability, *PGCCAppCap;

/* 
**	GCCNonCollapsingCapability
*/
typedef struct tagT120NonCollCap
{
	GCCCapabilityID			capability_id;
	LPOSTR                  application_data;	/* optional */
}
    T120NonCollCap, GCCNonCollapsingCapability, GCCNonCollCap, *PGCCNonCollapsingCapability, *PGCCNonCollCap;

/* 
**	GCCApplicationRecord
**		This structure holds all the data associated with a single T.124 
**		application record.  See the T.124 specification for what parameters
**		are optional.
*/
typedef struct tagT120AppRecord
{
	GCCNodeID					node_id;
	GCCEntityID 				entity_id;
	BOOL    					is_enrolled_actively;
	BOOL    					is_conducting_capable;
	MCSChannelType				startup_channel_type; 
	UserID  					application_user_id;  			/* optional */
	ULONG       				number_of_non_collapsed_caps;
	GCCNonCollapsingCapability 
					**	non_collapsed_caps_list;		/* optional */
}
    T120AppRecord, GCCApplicationRecord, GCCAppRecord, *PGCCApplicationRecord, *PGCCAppRecord;

/* 
**	GCCApplicationRoster
**		This structure holds all the data associated with a single T.124 
**		application roster.  This includes the collapsed capabilites and
**		the complete list of application records associated with an Application
**		Protocol Entity (APE).
*/
typedef struct tagT120AppRoster
{
	GCCSessionKey		session_key;
	BOOL 				application_roster_was_changed;
	ULONG         		instance_number;
	BOOL 				nodes_were_added;
	BOOL 				nodes_were_removed;
	BOOL 				capabilities_were_changed;
	ULONG         		number_of_records;
	GCCApplicationRecord 	**	application_record_list;
	ULONG				number_of_capabilities;
	GCCApplicationCapability **	capabilities_list;	/* optional */		
}
    T120AppRoster, GCCApplicationRoster, GCCAppRoster, *PGCCApplicationRoster, *PGCCAppRoster;

/*
**	GCCRegistryKey
**		This key is used to identify a specific resource used
**		by an application. This may be a particular channel or token needed
**		for control purposes.
*/
typedef struct tagT120RegistryKey
{
	GCCSessionKey		session_key;
	OSTR        		resource_id;	/* Max length is 64 */
}
    T120RegistryKey, GCCRegistryKey, *PGCCRegistryKey;

/*
**	RegistryItemType
**		This enum is used to specify what type of registry item is contained
**		at the specified slot in the registry.
*/
typedef AppletRegistryItemType  GCCRegistryItemType, *PGCCRegistryItemType;
#define GCC_REGISTRY_CHANNEL_ID APPLET_REGISTRY_CHANNEL_ID
#define GCC_REGISTRY_TOKEN_ID   APPLET_REGISTRY_TOKEN_ID
#define GCC_REGISTRY_PARAMETER  APPLET_REGISTRY_PARAMETER
#define GCC_REGISTRY_NONE       APPLET_REGISTRY_NONE

/*
**	GCCRegistryItem
**		This structure is used to hold a single registry item.  Note that the
**		union supports all three registry types supported by GCC.
*/
typedef struct
{
	GCCRegistryItemType	item_type;
	// the following three fields were in a union
    ChannelID			channel_id;
	TokenID				token_id;
	OSTR         		parameter;		/* Max length is 64 */
}
    T120RegistryItem, GCCRegistryItem, *PGCCRegistryItem;

/*
**	GCCRegistryEntryOwner
**
*/
typedef struct
{
	BOOL		    entry_is_owned;
	GCCNodeID		owner_node_id;
	GCCEntityID 	owner_entity_id;
}
    T120RegistryEntryOwner, GCCRegistryEntryOwner, *PGCCRegistryEntryOwner;

/*
**	GCCModificationRights
**		This enum is used when specifing what kind of rights a node has to
**		alter the contents of a registry "parameter".
*/
typedef	AppletModificationRights    GCCModificationRights, *PGCCModificationRights;
#define GCC_OWNER_RIGHTS                        APPLET_OWNER_RIGHTS
#define GCC_SESSION_RIGHTS                      APPLET_SESSION_RIGHTS
#define GCC_PUBLIC_RIGHTS                       APPLET_PUBLIC_RIGHTS
#define GCC_NO_MODIFICATION_RIGHTS_SPECIFIED    APPLET_NO_MODIFICATION_RIGHTS_SPECIFIED

/*
**	GCCAppProtocolEntity
**		This structure is used to identify a protocol entity at a remote node
**		when invoke is used.
*/
typedef	struct tagT120APE
{
	GCCSessionKey				session_key;
	MCSChannelType				startup_channel_type;
	BOOL					    must_be_invoked;
	ULONG         				number_of_expected_capabilities;
	GCCApplicationCapability **	expected_capabilities_list;
}
    T120APE, GCCAppProtocolEntity, GCCApe, *PGCCAppProtocolEntity, *PGCCApe;


/*
**	GCCMessageType
**		This section defines the messages that can be sent to the application
**		through the callback facility.  These messages correspond to the 
**		indications and confirms that are defined within T.124.
*/
typedef T120MessageType     GCCMessageType, *PGCCMessageType;

#endif // __GCC_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\remdsk\rds\h\debspew.h ===
/*
 * debspew.h - Debug macros and their retail translations.
 *
 * Taken from URL code by ChrisPi 9-11-95
 *
 */

#ifndef _DEBSPEW_H_
#define _DEBSPEW_H_

#ifdef __cplusplus
extern "C" {
#endif /* __cplusplus */

#include <tchar.h>
#include <limits.h>
#include <shlobj.h>

#include "stock.h"
#include "olestock.h"

#ifdef DEBUG
#include "resstr.h"
#endif /* DEBUG */

#include "valid.h"


#define DATA_SEG_READ_ONLY       ".text"
#define DATA_SEG_PER_INSTANCE    ".data"
#define DATA_SEG_SHARED          ".shared"


/* parameter validation macros */

/*
 * call as:
 *
 * bPTwinOK = IS_VALID_READ_PTR(ptwin, CTWIN);
 *
 * bHTwinOK = IS_VALID_HANDLE(htwin, TWIN);
 */

#ifdef DEBUG

#define IS_VALID_READ_PTR(ptr, type) \
   (IsBadReadPtr((ptr), sizeof(type)) ? \
    (ERROR_OUT(("invalid %s read pointer - %#08lx", (PCSTR)"P"#type, (ptr))), FALSE) : \
    TRUE)

#define IS_VALID_WRITE_PTR(ptr, type) \
   (IsBadWritePtr((PVOID)(ptr), sizeof(type)) ? \
    (ERROR_OUT(("invalid %s write pointer - %#08lx", (PCSTR)"P"#type, (ptr))), FALSE) : \
    TRUE)

#define IS_VALID_STRING_PTR_A(ptr, type) \
   (IsBadStringPtrA((ptr), (UINT)-1) ? \
    (ERROR_OUT(("invalid %s pointer - %#08lx", (PCSTR)"P"#type, (ptr))), FALSE) : \
    TRUE)

#define IS_VALID_STRING_PTR_W(ptr, type) \
   (IsBadStringPtrW((ptr), (UINT)-1) ? \
    (ERROR_OUT(("invalid %s pointer - %#08lx", (PCSTR)"P"#type, (ptr))), FALSE) : \
    TRUE)

#if defined(UNICODE)
#define IS_VALID_STRING_PTR IS_VALID_STRING_PTR_W
#else // defined(UNICODE)
#define IS_VALID_STRING_PTR IS_VALID_STRING_PTR_A
#endif // defined(UNICODE)


#define IS_VALID_CODE_PTR(ptr, type) \
   (IsBadCodePtr((FARPROC)(ptr)) ? \
    (ERROR_OUT(("invalid %s code pointer - %#08lx", (PCSTR)#type, (ptr))), FALSE) : \
    TRUE)

#define IS_VALID_READ_BUFFER_PTR(ptr, type, len) \
   (IsBadReadPtr((ptr), len) ? \
    (ERROR_OUT(("invalid %s read pointer - %#08lx", (PCSTR)"P"#type, (ptr))), FALSE) : \
    TRUE)

#define IS_VALID_WRITE_BUFFER_PTR(ptr, type, len) \
   (IsBadWritePtr((ptr), len) ? \
    (ERROR_OUT(("invalid %s write pointer - %#08lx", (PCSTR)"P"#type, (ptr))), FALSE) : \
    TRUE)

#define FLAGS_ARE_VALID(dwFlags, dwAllFlags) \
   (((dwFlags) & (~(dwAllFlags))) ? \
    (ERROR_OUT(("invalid flags set - %#08lx", ((dwFlags) & (~(dwAllFlags))))), FALSE) : \
    TRUE)

#else

#define IS_VALID_READ_PTR(ptr, type) \
   (! IsBadReadPtr((ptr), sizeof(type)))

#define IS_VALID_WRITE_PTR(ptr, type) \
   (! IsBadWritePtr((PVOID)(ptr), sizeof(type)))

#define IS_VALID_STRING_PTR(ptr, type) \
   (! IsBadStringPtr((ptr), (UINT)-1))

#define IS_VALID_CODE_PTR(ptr, type) \
   (! IsBadCodePtr((FARPROC)(ptr)))

#define IS_VALID_READ_BUFFER_PTR(ptr, type, len) \
   (! IsBadReadPtr((ptr), len))

#define IS_VALID_WRITE_BUFFER_PTR(ptr, type, len) \
   (! IsBadWritePtr((ptr), len))

#define FLAGS_ARE_VALID(dwFlags, dwAllFlags) \
   (((dwFlags) & (~(dwAllFlags))) ? FALSE : TRUE)

#endif

/* handle validation macros */

#ifdef DEBUG

#define IS_VALID_HANDLE(hnd, type) \
   (IsValidH##type(hnd) ? \
    TRUE : \
    (ERROR_OUT(("invalid H" #type " - %#08lx", (hnd))), FALSE))

#else

#define IS_VALID_HANDLE(hnd, type) \
   (IsValidH##type(hnd))

#endif

/* structure validation macros */

#ifdef VSTF

#ifdef DEBUG

#define IS_VALID_STRUCT_PTR(ptr, type) \
   (IsValidP##type(ptr) ? \
    TRUE : \
    (ERROR_OUT(("invalid %s pointer - %#08lx", (PCSTR)"P"#type, (ptr))), FALSE))

#else

#define IS_VALID_STRUCT_PTR(ptr, type) \
   (IsValidP##type(ptr))

#endif

#else

#define IS_VALID_STRUCT_PTR(ptr, type) \
   (! IsBadReadPtr((ptr), sizeof(type)))

#endif

/* OLE interface validation macro */

#define IS_VALID_INTERFACE_PTR(ptr, iface) \
   IS_VALID_STRUCT_PTR(ptr, C##iface)



#ifdef DEBUG

#define CALLTRACE_OUT(s) DbgZPrintFunction s

#define DebugEntry(szFunctionName) \
   (CALLTRACE_OUT((#szFunctionName "() entered.")))

#define DebugExit(szFunctionName, szResult) \
   (CALLTRACE_OUT(("%s() exiting, returning %s.", #szFunctionName, szResult)))

#define DebugExitBOOL(szFunctionName, bool) \
   DebugExit(szFunctionName, GetBOOLString(bool))

#define DebugExitCOMPARISONRESULT(szFunctionName, cr) \
   DebugExit(szFunctionName, GetCOMPARISONRESULTString(cr))

#define DebugExitDWORD(szFunctionName, dw) \
   DebugExitULONG(szFunctionName, dw)

#define DebugExitHRESULT(szFunctionName, hr) \
   DebugExit(szFunctionName, GetHRESULTString(hr))

#define DebugExitINT(szFunctionName, n) \
   DebugExit(szFunctionName, GetINTString(n))

#define DebugExitINT_PTR(szFunctionName, n) \
   DebugExit(szFunctionName, GetINT_PTRString(n))

#define DebugExitULONG(szFunctionName, ul) \
   DebugExit(szFunctionName, GetULONGString(ul))

#define DebugExitVOID(szFunctionName) \
   (CALLTRACE_OUT(("%s() exiting.", #szFunctionName)))

#define DebugExitPVOID(szFunctionName, ptr) \
   DebugExit(szFunctionName, GetPVOIDString(ptr))

#else

#define DebugEntry(szFunctionName)
#define DebugExit(szFunctionName, szResult)
#define DebugExitBOOL(szFunctionName, bool)
#define DebugExitCOMPARISONRESULT(szFunctionName, cr)
#define DebugExitDWORD(szFunctionName, dw)
#define DebugExitHRESULT(szFunctionName, hr)
#define DebugExitINT(szFunctionName, n)
#define DebugExitINT_PTR(szFunctionName, n)
#define DebugExitULONG(szFunctionName, ul)
#define DebugExitVOID(szFunctionName)
#define DebugExitPVOID(szFunctionName, ptr)

#endif


/* Types
 ********/

/* g_dwSpewFlags flags */

typedef enum _spewflags
{
   SPEW_FL_SPEW_PREFIX        = 0x0001,

   SPEW_FL_SPEW_LOCATION      = 0x0002,

   ALL_SPEW_FLAGS             = (SPEW_FL_SPEW_PREFIX |
                                 SPEW_FL_SPEW_LOCATION)
}
SPEWFLAGS;

/* g_uSpewSev values */

typedef enum _spewsev
{
   SPEW_TRACE,

   SPEW_CALLTRACE,

   SPEW_WARNING,

   SPEW_ERROR,

   SPEW_FATAL
}
SPEWSEV;


/* Prototypes
 *************/

/* debspew.c */

#ifdef DEBUG

extern BOOL   SetDebugModuleIniSwitches(void);
extern BOOL   InitDebugModule(PCSTR);
extern void   ExitDebugModule(void);
extern void   SpewOut(PCSTR pcszFormat, ...);
extern DWORD  GetDebugOutputFlags(VOID);
extern VOID   SetDebugOutputFlags(DWORD dw);

#else // DEBUG

#define SetDebugModuleIniSwitches()
#define InitDebugModule(str)
#define ExitDebugModule()
//#define SpewOut(fmt, ...)
#define GetDebugOutputFlags()
#define SetDebugOutputFlags(dw)

#endif // DEBUG


/* Global Variables
 *******************/

#ifdef DEBUG

/* dbg.cpp */
extern HDBGZONE ghDbgZone;

/* debspew.c */

extern DWORD g_dwSpewFlags;
extern UINT g_uSpewSev;
extern UINT g_uSpewLine;
extern PCSTR g_pcszSpewFile;
extern WINDOWPLACEMENT g_wpSpew;

/* defined by client */

extern PCSTR g_pcszSpewModule;

#endif



/*
 * EVAL() may only be used as a logical expression.
 *
 * E.g.,
 *
 * if (EVAL(exp))
 *    bResult = TRUE;
 */

#ifdef DEBUG

#define EVAL(exp) \
   ((exp) || \
    (ERROR_OUT(("evaluation failed '%s'", (PCSTR)#exp)), 0))

#else

#define EVAL(exp) \
   ((exp) != 0)

#endif   /* DEBUG */


#ifdef __cplusplus
}
#endif /* __cplusplus */



#endif /* _DEBSPEW_H_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\remdsk\rds\h\fnobjs.h ===
#ifndef __FnObjs_h__
#define __FnObjs_h__


class IsEqLPTSTR
{
private:

	LPCTSTR m_pcsz;

public:
	IsEqLPTSTR( LPCTSTR pcsz ) : m_pcsz( pcsz ) { ; }
    bool operator() ( LPCTSTR pcsz ) 
	{
		return ( 0 == lstrcmp( pcsz, m_pcsz ) );
    }

};


template< class T > 
class IsEq
{

	const T& m_rT;
public:
	IsEq( const T& rT ) : m_rT( rT ) { ; }

    bool operator() ( const T& rT ) 
	{
		return rT == m_rT;
    }
};


#endif // __FnObjs_h__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\remdsk\rds\h\cstring.hpp ===
#ifndef _CSTRING_HPP_
#define _CSTRING_HPP_

// These two header files contain definitions that used to be in this file.
// To allow source files which include this file to continue to work 
// unmodified, we include them here.
#include <strutil.h>
#include <custring.h>

#define REMAFXAPI
#define REMAFX_DATADEF
#define REMAFX_DATA
#define REMAFX_CDECL
#define REM_AFX_INLINE inline

// BUGBUG - How are these used?
#ifndef PUBLIC_CODE
#define PUBLIC_CODE
#define PUBLIC_DATA
#define PRIVATE_CODE             PUBLIC_CODE
#define PRIVATE_DATA             PUBLIC_DATA
#endif


struct CSTRINGData
{
	long nRefs;     // reference count
	int nDataLength;
	int nAllocLength;
	// TCHAR data[nAllocLength]

	TCHAR* data()
		{ return (TCHAR*)(this+1); }
};

class CSTRING
{
public:
// Constructors
	CSTRING();
	CSTRING(const CSTRING& stringSrc);
	CSTRING(TCHAR ch, int nRepeat = 1);
	CSTRING(LPCSTR lpsz);
	CSTRING(LPCWSTR lpsz);
	CSTRING(LPCTSTR lpch, int nLength);
	CSTRING(const unsigned char* psz);

// Attributes & Operations
	// as an array of characters
	int GetLength() const;
	BOOL IsEmpty() const;
	void Empty();                       // free up the data

	TCHAR GetAt(int nIndex) const;      // 0 based
	TCHAR operator[](int nIndex) const; // same as GetAt
	void SetAt(int nIndex, TCHAR ch);
	operator LPCTSTR() const;           // as a C string

	// overloaded assignment
	const CSTRING& operator=(const CSTRING& stringSrc);
	const CSTRING& operator=(TCHAR ch);
#ifdef _UNICODE
	const CSTRING& operator=(char ch);
	const CSTRING& operator=(LPCSTR lpsz);
#else
	const CSTRING& operator=(LPCWSTR lpsz);
#endif
	const CSTRING& operator=(const unsigned char* psz);
	const CSTRING& operator=(LPCTSTR lpsz);

	// string concatenation
	const CSTRING& operator+=(const CSTRING& string);
	const CSTRING& operator+=(TCHAR ch);
#ifdef _UNICODE
	const CSTRING& operator+=(char ch);
#endif
	const CSTRING& operator+=(LPCTSTR lpsz);

	friend CSTRING REMAFXAPI operator+(const CSTRING& string1,
			const CSTRING& string2);
	friend CSTRING REMAFXAPI operator+(const CSTRING& string, TCHAR ch);
	friend CSTRING REMAFXAPI operator+(TCHAR ch, const CSTRING& string);
#ifdef _UNICODE
	friend CSTRING REMAFXAPI operator+(const CSTRING& string, char ch);
	friend CSTRING REMAFXAPI operator+(char ch, const CSTRING& string);
#endif
	friend CSTRING REMAFXAPI operator+(const CSTRING& string, LPCTSTR lpsz);
	friend CSTRING REMAFXAPI operator+(LPCTSTR lpsz, const CSTRING& string);

	void Append (LPCTSTR lpszSrcData, int nSrcLen);

	// string comparison
	int Compare(LPCTSTR lpsz) const;		// straight character
	int CompareNoCase(LPCTSTR lpsz) const;	// ignore case
	BOOL FEqual (const CSTRING& s2) const;	// length-sensitive comparison
	int Collate(LPCTSTR lpsz) const;		// NLS aware

	// simple sub-string extraction
	CSTRING Mid(int nFirst, int nCount) const;
	CSTRING Mid(int nFirst) const;
	CSTRING Left(int nCount) const;
	CSTRING Right(int nCount) const;

	CSTRING SpanIncluding(LPCTSTR lpszCharSet) const;
	CSTRING SpanExcluding(LPCTSTR lpszCharSet) const;

	// upper/lower/reverse conversion
	void MakeUpper();
	void MakeLower();

	// trimming whitespace (either side)
	void TrimRight();
	void TrimLeft();

	// searching (return starting index, or -1 if not found)
	// look for a single character match
	int Find(TCHAR ch) const;               // like "C" strchr

	// simple formatting
	void REMAFX_CDECL Format(LPCTSTR lpszFormat, ...);
	void REMAFX_CDECL Format(UINT nFormatID, ...);

	// formatting for localization (uses FormatMessage API)
	void REMAFX_CDECL FormatMessage(LPCTSTR lpszFormat, ...);
	void REMAFX_CDECL FormatMessage(UINT nFormatID, ...);

	// Windows support
	BOOL LoadString(HINSTANCE hInstance, UINT nID);	// load from string resource
													// 255 chars max
#ifndef _UNICODE
	// ANSI <-> OEM support (convert string in place)
	void AnsiToUnicode();
	void AnsiToOem();
	void OemToAnsi();
#endif

#ifndef _AFX_NO_BSTR_SUPPORT
	// OLE BSTR support (use for OLE automation)
	BSTR AllocSysString() const;
	BSTR SetSysString(BSTR* pbstr) const;
#endif

	// Access to string implementation buffer as "C" character array
	LPTSTR GetBuffer(int nMinBufLength);
	void ReleaseBuffer(int nNewLength = -1);
	LPTSTR GetBufferSetLength(int nNewLength);
	void FreeExtra();

	// Use LockBuffer/UnlockBuffer to turn refcounting off
	LPTSTR LockBuffer();
	void UnlockBuffer();

// Implementation
public:
	~CSTRING();
	int GetAllocLength() const;

protected:
	LPTSTR m_pchData;   // pointer to ref counted string data

	// implementation helpers
	CSTRINGData* GetData() const;
	void Init();
	void AllocCopy(CSTRING& dest, int nCopyLen, int nCopyIndex, int nExtraLen) const;
	void AllocBuffer(int nLen);
	void AssignCopy(int nSrcLen, LPCTSTR lpszSrcData);
	void ConcatCopy(int nSrc1Len, LPCTSTR lpszSrc1Data, int nSrc2Len, LPCTSTR lpszSrc2Data);
	void ConcatInPlace(int nSrcLen, LPCTSTR lpszSrcData);
	void FormatV(LPCTSTR lpszFormat, va_list argList);
	void CopyBeforeWrite();
	void AllocBeforeWrite(int nLen);
	void Release();
	static void PASCAL Release(CSTRINGData* pData);
	static int PASCAL SafeStrlen(LPCTSTR lpsz);
};

// conversion helpers
int REMAFX_CDECL _wcstombsz(char* mbstr, const wchar_t* wcstr, size_t count);
int REMAFX_CDECL _mbstowcsz(wchar_t* wcstr, const char* mbstr, size_t count);

// Globals
extern REMAFX_DATA TCHAR AFXChNil;
const CSTRING& REMAFXAPI AFXGetEmptyString();
#define AFXEmptyString AFXGetEmptyString()

// inlines
REM_AFX_INLINE CSTRINGData* CSTRING::GetData() const
	{ ASSERT(m_pchData != NULL); return ((CSTRINGData*)m_pchData)-1; }
REM_AFX_INLINE void CSTRING::Init()
	{ m_pchData = AFXEmptyString.m_pchData; }
REM_AFX_INLINE CSTRING::CSTRING(const unsigned char* lpsz)
	{ Init(); *this = (LPCSTR)lpsz; }
REM_AFX_INLINE const CSTRING& CSTRING::operator=(const unsigned char* lpsz)
	{ *this = (LPCSTR)lpsz; return *this; }
#ifdef _UNICODE
REM_AFX_INLINE const CSTRING& CSTRING::operator+=(char ch)
	{ *this += (TCHAR)ch; return *this; }
REM_AFX_INLINE const CSTRING& CSTRING::operator=(char ch)
	{ *this = (TCHAR)ch; return *this; }
REM_AFX_INLINE CSTRING REMAFXAPI operator+(const CSTRING& string, char ch)
	{ return string + (TCHAR)ch; }
REM_AFX_INLINE CSTRING REMAFXAPI operator+(char ch, const CSTRING& string)
	{ return (TCHAR)ch + string; }
#endif

REM_AFX_INLINE int CSTRING::GetLength() const
	{ return GetData()->nDataLength; }
REM_AFX_INLINE int CSTRING::GetAllocLength() const
	{ return GetData()->nAllocLength; }
REM_AFX_INLINE BOOL CSTRING::IsEmpty() const
	{ return GetData()->nDataLength == 0; }
REM_AFX_INLINE CSTRING::operator LPCTSTR() const
	{ return m_pchData; }
REM_AFX_INLINE int PASCAL CSTRING::SafeStrlen(LPCTSTR lpsz)
	{ return (lpsz == NULL) ? 0 : lstrlen(lpsz); }
REM_AFX_INLINE void CSTRING::Append (LPCTSTR lpszSrcData, int nSrcLen)
	{ ConcatInPlace(nSrcLen, lpszSrcData); }

REM_AFX_INLINE BOOL REMAFXAPI operator==(const CSTRING& s1, const CSTRING& s2)
	{ return s1.FEqual(s2); }
REM_AFX_INLINE BOOL REMAFXAPI operator==(const CSTRING& s1, LPCTSTR s2)
	{ return s1.Compare(s2) == 0; }
REM_AFX_INLINE BOOL REMAFXAPI operator==(LPCTSTR s1, const CSTRING& s2)
	{ return s2.Compare(s1) == 0; }
REM_AFX_INLINE BOOL REMAFXAPI operator!=(const CSTRING& s1, const CSTRING& s2)
	{ return s1.FEqual(s2) == FALSE; }
REM_AFX_INLINE BOOL REMAFXAPI operator!=(const CSTRING& s1, LPCTSTR s2)
	{ return s1.Compare(s2) != 0; }
REM_AFX_INLINE BOOL REMAFXAPI operator!=(LPCTSTR s1, const CSTRING& s2)
	{ return s2.Compare(s1) != 0; }

// Commented out for Unicode because Win95 doesn't support lstrcmpW
#ifndef UNICODE
REM_AFX_INLINE int CSTRING::Compare(LPCTSTR lpsz) const
	{ return lstrcmp(m_pchData, lpsz); }    // MBCS/Unicode aware
#endif // UNICODE

#endif // ndef CSTRING_HPP
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\remdsk\rds\h\ias.h ===
#ifndef _IAS_H_
#define _IAS_H_




typedef UINT IAS_GCC_ID;



// GetPersonStatus()

#define IAS_SHARING_NOTHING             0x0000
#define IAS_SHARING_DESKTOP             0x0001

typedef enum
{
    IAS_VERSION_10 = 1,
}
IAS_VERSION;

typedef struct
{
    UINT                cbSize;

    BOOL                InShare;            // Participating in share
    IAS_VERSION         Version;            // AS protocol version
    UINT                AreSharing;         // What person is sharing (IAS_SHARING_)
    BOOL                Controllable;       // Is person controllable
    IAS_GCC_ID          InControlOfPending; // Whom we are waiting to control
    IAS_GCC_ID          InControlOf;        // Whom is controlled by person
    IAS_GCC_ID          ControlledByPending;// Whom we are waiting to be controlled by
    IAS_GCC_ID          ControlledBy;       // Who is controlling person
}
IAS_PERSON_STATUS;




// lonchanc
// In general, S_OK means success, E_*** means failure
// For boolean values, S_OK means TRUE, S_FALSE means FALSE, and E_*** means failure.

#undef  INTERFACE
#define INTERFACE IAppSharing

// lonchanc: the idea of this IAppSharing is per call interface
DECLARE_INTERFACE_(IAppSharing, IUnknown)
{
    STDMETHOD(QueryInterface)(THIS_  REFIID, void **) PURE;
    STDMETHOD_(ULONG, AddRef)(THIS) PURE;
    STDMETHOD_(ULONG, Release)(THIS) PURE;

    //
    // INFORMATION
    //
    STDMETHOD_(BOOL, IsSharingAvailable)(THIS) PURE;
    STDMETHOD_(BOOL, CanShareNow)(THIS) PURE;
    STDMETHOD_(BOOL, IsInShare)(THIS) PURE;
    STDMETHOD_(BOOL, IsSharing)(THIS) PURE;
    STDMETHOD_(BOOL, CanAllowControl)(THIS) PURE;
    STDMETHOD_(BOOL, IsControllable)(THIS) PURE;
    STDMETHOD(GetPersonStatus)(THIS_ IAS_GCC_ID Person, IAS_PERSON_STATUS *pStatus) PURE;

    //
    // SHARING
    //
	STDMETHOD(ShareDesktop)(THIS) PURE;
	STDMETHOD(UnshareDesktop)(THIS) PURE;

    //
    // CONTROL
    //

    // On host
    STDMETHOD(AllowControl)(THIS_ BOOL fAllowed) PURE;

    // From person controlling to person controlled
    STDMETHOD(TakeControl)(THIS_ IAS_GCC_ID PersonOf) PURE;
    STDMETHOD(CancelTakeControl)(THIS_ IAS_GCC_ID PersonOf) PURE;
    STDMETHOD(ReleaseControl)(THIS_ IAS_GCC_ID PersonOf) PURE;
    STDMETHOD(PassControl)(THIS_ IAS_GCC_ID PersonOf, IAS_GCC_ID PersonTo) PURE;

    // From person controlled
    STDMETHOD(GiveControl)(THIS_ IAS_GCC_ID PersonTo) PURE;
    STDMETHOD(CancelGiveControl)(THIS_ IAS_GCC_ID PersonTo) PURE;
    STDMETHOD(RevokeControl)(THIS_ IAS_GCC_ID PersonFrom) PURE;
};



// IAppSharingNotify interface
DECLARE_INTERFACE_(IAppSharingNotify, IUnknown)
{
    STDMETHOD(QueryInterface)(THIS_ REFIID, void**) PURE;
    STDMETHOD_(ULONG, AddRef)(THIS) PURE;
    STDMETHOD_(ULONG, Release)(THIS) PURE;

    STDMETHOD(OnReadyToShare)(THIS_ BOOL fReady) PURE;
    STDMETHOD(OnShareStarted)(THIS) PURE;
    STDMETHOD(OnSharingStarted)(THIS) PURE;
    STDMETHOD(OnShareEnded)(THIS) PURE;
    STDMETHOD(OnPersonJoined)(THIS_ IAS_GCC_ID gccID) PURE;
    STDMETHOD(OnPersonLeft)(THIS_ IAS_GCC_ID gccID) PURE;

    STDMETHOD(OnStartInControl)(THIS_ IAS_GCC_ID gccOf) PURE;
    STDMETHOD(OnStopInControl)(THIS_ IAS_GCC_ID gccOf) PURE;

    STDMETHOD(OnControllable)(THIS_ BOOL fControllable) PURE;
    STDMETHOD(OnStartControlled)(THIS_ IAS_GCC_ID gccBy) PURE;
    STDMETHOD(OnStopControlled)(THIS_ IAS_GCC_ID gccBy) PURE;
};


//
// AS flags:
//
#define     AS_SERVICE          0x0001          // Is this service context?
#define     AS_UNATTENDED       0x0002          // Is this unattended (no end user)?

HRESULT WINAPI CreateASObject(IAppSharingNotify * pNotify, UINT flags, IAppSharing** ppAS);

#endif // _IAS_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\remdsk\rds\h\it120xprt.h ===
#ifndef _IT120_TRANSPORT_H_
#define _IT120_TRANSPORT_H_


#include <basetyps.h>
#include <t120type.h>


#define T120_CONNECTION_ID_LENGTH       64


typedef enum tagPLUGXPRT_PROTOCOL
{
    PLUGXPRT_PROTOCOL_X224          = 0,
}
    PLUGXPRT_PROTOCOL;


typedef enum tagPLUGXPRT_RESULT
{
    PLUGXPRT_RESULT_SUCCESSFUL      = 0,
    PLUGXPRT_RESULT_READ_FAILED     = 1,
    PLUGXPRT_RESULT_WRITE_FAILED    = 2,
    PLUGXPRT_RESULT_FAILED          = 3,
    PLUGXPRT_RESULT_ABANDONED       = 4,
}
    PLUGXPRT_RESULT;


typedef enum tagPLUGXPRT_STATE
{
    PLUGXPRT_UNKNOWN_STATE      = 0,
    PLUGXPRT_CONNECTING         = 1,
    PLUGXPRT_CONNECTED          = 2,
    PLUGXPRT_DISCONNECTING      = 3,
    PLUGXPRT_DISCONNECTED       = 4,
}
    PLUGXPRT_STATE;


typedef struct tagPLUGXPRT_MESSAGE
{
    PLUGXPRT_STATE          eState;
    LPVOID                  pContext;
    LPSTR                   pszConnID;
    PLUGXPRT_PROTOCOL       eProtocol;
    PLUGXPRT_RESULT         eResult;
}
    PLUGXPRT_MESSAGE;


typedef void (CALLBACK *LPFN_PLUGXPRT_CB) (PLUGXPRT_MESSAGE *);


#undef  INTERFACE
#define INTERFACE IT120PluggableTransport
DECLARE_INTERFACE(IT120PluggableTransport)
{
    STDMETHOD_(void, ReleaseInterface) (THIS) PURE;

    STDMETHOD_(T120Error, CreateConnection) (THIS_
                    char                szConnID[], /* out */
                    PLUGXPRT_CALL_TYPE  eCaller, // caller vs callee
                    HANDLE              hCommLink,
                    HANDLE              hevtDataAvailable,
                    HANDLE              hevtWriteReady,
                    HANDLE              hevtConnectionClosed,
                    PLUGXPRT_FRAMING    eFraming,
                    PLUGXPRT_PARAMETERS *pParams) PURE;

    STDMETHOD_(T120Error, UpdateConnection) (THIS_
                    LPSTR               pszConnID,
                    HANDLE              hCommLink) PURE;

    STDMETHOD_(T120Error, CloseConnection) (THIS_ LPSTR pszConnID) PURE; 

    STDMETHOD_(T120Error, EnableWinsock) (THIS) PURE; 

    STDMETHOD_(T120Error, DisableWinsock) (THIS) PURE; 

    STDMETHOD_(void, Advise) (THIS_ LPFN_PLUGXPRT_CB, LPVOID pContext) PURE;

    STDMETHOD_(void, UnAdvise) (THIS) PURE;

    STDMETHOD_(void, ResetConnCounter) (THIS) PURE;
};


#ifdef __cplusplus
extern "C" {
#endif

T120Error WINAPI T120_CreatePluggableTransport(IT120PluggableTransport **);

#ifdef __cplusplus
}
#endif


#endif // _IT120_TRANSPORT_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\remdsk\rds\h\igccapp.h ===
#ifndef _IGCCAPP_H_
#define _IGCCAPP_H_

#include <basetyps.h>
#include "gcc.h"

#define GCCAPI_(_type_) virtual _type_   __stdcall
#define GCCAPI          GCCAPI_(GCCError)


typedef struct
{
    GCCSessionKey           *pSessionKey;
    BOOL                    fEnrollActively;
    UserID                  nUserID;
    BOOL                    fConductingCapable;
    MCSChannelType          nStartupChannelType;
    ULONG                   cNonCollapsedCaps;
    GCCNonCollCap           **apNonCollapsedCaps;
    ULONG                   cCollapsedCaps;
    GCCAppCap               **apCollapsedCaps;
    BOOL                    fEnroll;
}
    GCCEnrollRequest, *PGCCEnrollRequest;


typedef struct
{
    ULONG                   cNodes;
    GCCNodeID               *aNodeIDs;
}
    GCCSimpleNodeList, *PGCCSimpleNodeList;


typedef struct
{
    ULONG                   cApes;
    GCCAppProtocolEntity    **apApes;
}
    GCCAppProtEntityList, *PGCCAppProtEntityList;


typedef struct
{
    GCCConfID               nConfID;
    ULONG                   cRosters;
    GCCAppRoster            **apAppRosters;
    GCCResult               nResult;
    LPVOID                  pReserved;          // do not touch
}
    GCCAppRosterInquireConfirm, *PGCCAppRosterInquireConfirm;


typedef struct
{
    GCCConfID               nConfID;
    GCCConfName             ConfName;
    LPSTR                   pszConfModifier;
    LPWSTR                  pwszConfDescriptor;
    GCCConfRoster           *pConfRoster;
    GCCResult               nResult;
}
    GCCConfRosterInquireConfirm, *PGCCConfRosterInquireConfirm;


typedef struct
{
    GCCConfID               nConfID;
    BOOL                    fPermissionGranted;
}
    GCCAppPermissionToEnrollInd, *PGCCAppPermissionToEnrollInd;


typedef struct
{
    GCCConfID               nConfID;
    // GCCSessionKey           *pSessionKey;
    GCCSessionID            sidMyself;
    GCCEntityID             eidMyself;
    GCCNodeID               nidMyself;
    GCCResult               nResult;
    GCCRequestTag           nReqTag;
}
    GCCAppEnrollConfirm, *PGCCAppEnrollConfirm;

typedef struct
{
    GCCConfID               nConfID;
    // GCCAppProtEntityList    *pApeList;
    GCCResult               nResult;
    GCCRequestTag           nReqTag;
}
    GCCAppInvokeConfirm, *PGCCAppInvokeConfirm;

typedef struct
{
    GCCConfID               nConfID;
    GCCAppProtEntityList    ApeList;
    GCCNodeID               nidInvoker;
}
    GCCAppInvokeInd, *PGCCAppInvokeInd;


typedef struct
{
    GCCConfID               nConfID;
    ULONG                   cRosters;
    GCCAppRoster            **apAppRosters;
    LPVOID                  pReserved;          // do not touch
}
    GCCAppRosterReportInd, *PGCCAppRosterReportInd;


typedef struct
{
    GCCConfID               nConfID;
    GCCRegistryKey          *pRegKey;
    GCCRegistryItem         *pRegItem;
    GCCRegistryEntryOwner   EntryOwner;
    GCCModificationRights   eRights;
    GCCResult               nResult;
    BOOL                    fDeliveryEnabled;   // for monitor confirm only
}
    GCCRegistryConfirm, *PGCCRegistryConfirm;


typedef struct
{
    GCCConfID               nConfID;
    ULONG                   nFirstHandle;
    ULONG                   cHandles;
    GCCResult               nResult;
}
    GCCRegAllocateHandleConfirm, *PGCCRegAllocateHandleConfirm;


typedef struct
{
    GCCConfID               nConfID;
    BOOL                    fConducted;
    GCCNodeID               nidConductor;
    BOOL                    fGranted;
    GCCResult               nResult;
}
    GCCConductorInquireConfirm, *PGCCConductorInquireConfirm;


typedef struct
{
    GCCConfID               nConfID;
    BOOL                    fThisNodeIsGranted;
    GCCSimpleNodeList       Granted;
    GCCSimpleNodeList       Waiting;
    LPVOID                  pReserved;      // do not touch
}
    GCCConductorPermitGrantInd, *PGCCConductorPermitGrantInd;


typedef struct
{
    GCCConfID               nConfID;
    GCCNodeID               nidConductor;
}
    GCCConductorAssignInd, *PGCCConductorAssignInd;


typedef struct
{
    GCCConfID               nConfID;
}
    GCCConductorReleaseInd, *PConductorReleaseInd;


/*
 *  GCCAppSapMsg
 *      This structure defines the callback message that is passed from GCC to
 *      a user application when an indication or confirm occurs.
 */

typedef struct
{
    GCCMessageType      eMsgType;
    LPVOID              pAppData;
    LPVOID              reserved1; // reserved
    GCCConfID           nConfID; // reserved

    union
    {
        GCCAppPermissionToEnrollInd         AppPermissionToEnrollInd;
        GCCAppEnrollConfirm                 AppEnrollConfirm;

        GCCAppRosterInquireConfirm          AppRosterInquireConfirm;
        GCCAppRosterReportInd               AppRosterReportInd;

        GCCConfRosterInquireConfirm         ConfRosterInquireConfirm;

        GCCAppInvokeConfirm                 AppInvokeConfirm;
        GCCAppInvokeInd                     AppInvokeInd;

        GCCRegistryConfirm                  RegistryConfirm;
        GCCRegAllocateHandleConfirm         RegAllocHandleConfirm;

        GCCConductorInquireConfirm          ConductorInquireConfirm;
        GCCConductorPermitGrantInd          ConductorPermitGrantInd;
        GCCConductorAssignInd               ConductorAssignInd;
        GCCConductorReleaseInd              ConductorReleaseInd;
    };
}
    GCCAppSapMsg, *PGCCAppSapMsg;


typedef void (CALLBACK *LPFN_APP_SAP_CB) (GCCAppSapMsg *);



#undef  INTERFACE
#define INTERFACE IGCCAppSap
DECLARE_INTERFACE(IGCCAppSap)
{
    STDMETHOD_(void, ReleaseInterface) (THIS) PURE;

    /* application roster services */

    STDMETHOD_(GCCError, AppEnroll) (THIS_
                IN      GCCConfID,
                IN      GCCEnrollRequest *,
                OUT     PGCCRequestTag)
                PURE;

    STDMETHOD_(GCCError, AppInvoke) (THIS_
                IN      GCCConfID,
                IN      GCCAppProtEntityList *,
                IN      GCCSimpleNodeList *,
                OUT     PGCCRequestTag)
                PURE;

    // to acquire one or all full-refresh app roster.
    // can be called by both app sap and control sap.
    STDMETHOD_(GCCError, AppRosterInquire) (THIS_
                IN      GCCConfID,
                IN      GCCSessionKey *,
                OUT     GCCAppSapMsg **)
                PURE;

    STDMETHOD_(void, FreeAppSapMsg) (THIS_
                IN      GCCAppSapMsg *)
                PURE;

    /* conference roster service */

    STDMETHOD_(BOOL, IsThisNodeTopProvider) (THIS_
                IN      GCCConfID)
                PURE;

    STDMETHOD_(GCCNodeID, GetTopProvider) (THIS_
                IN      GCCConfID)
                PURE;

    // to acquire a full-refresh conf roster.
    STDMETHOD_(GCCError, ConfRosterInquire) (THIS_
                IN      GCCConfID,
                OUT     GCCAppSapMsg **)
                PURE;

    /* registry services */

    STDMETHOD_(GCCError, RegisterChannel) (THIS_
                IN      GCCConfID,
                IN      GCCRegistryKey *,
                IN      ChannelID)
                PURE;

    STDMETHOD_(GCCError, RegistryAssignToken) (THIS_
                IN      GCCConfID,
                IN      GCCRegistryKey *)
                PURE;

    STDMETHOD_(GCCError, RegistrySetParameter) (THIS_
                IN      GCCConfID,
                IN      GCCRegistryKey *,
                IN      LPOSTR,
                IN      GCCModificationRights)
                PURE;

    STDMETHOD_(GCCError, RegistryRetrieveEntry) (THIS_
                IN      GCCConfID,
                IN      GCCRegistryKey *)
                PURE;

    STDMETHOD_(GCCError, RegistryDeleteEntry) (THIS_
                IN      GCCConfID,
                IN      GCCRegistryKey *)
                PURE;

    STDMETHOD_(GCCError, RegistryMonitor) (THIS_
                IN      GCCConfID,
                IN      BOOL fEnableDelivery,
                IN      GCCRegistryKey *)
                PURE;

    STDMETHOD_(GCCError, RegistryAllocateHandle) (THIS_
                IN      GCCConfID,
                IN      ULONG cHandles)
                PURE;

    /* conductorship services */

    STDMETHOD_(GCCError, ConductorInquire) (THIS_
                IN      GCCConfID)
                PURE;
};



//
// GCC Application Service Access Point exports
//

#ifdef __cplusplus
extern "C" {
#endif

GCCError WINAPI GCC_CreateAppSap(
                        OUT     IGCCAppSap **,
                        IN      LPVOID, // user defined data
                        IN      LPFN_APP_SAP_CB);
#ifdef __cplusplus
}
#endif


#endif // _IGCCAPP_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\remdsk\rds\h\imcsapp.h ===
#ifndef _IMCSAPP_H_
#define _IMCSAPP_H_

#include <basetyps.h>
#include "mcatmcs.h"


#define MCSAPI_(_type_) virtual _type_   __stdcall
#define MCSAPI          MCSAPI_(MCSError)

#define	ATTACHMENT_DISCONNECT_IN_DATA_LOSS		0x1
#define ATTACHMENT_MCS_FREES_DATA_IND_BUFFER	0x2


#undef  INTERFACE
#define INTERFACE IMCSSap
DECLARE_INTERFACE(IMCSSap)
{
    STDMETHOD_(MCSError, ReleaseInterface) (THIS) PURE;

    /* memory calls */

    STDMETHOD_(MCSError, GetBuffer) (THIS_
                IN      UINT,
                OUT     PVoid *)
                PURE;

    STDMETHOD_(Void, FreeBuffer) (THIS_
                IN      PVoid)
                PURE;

    // channel request calls
    STDMETHOD_(MCSError, ChannelJoin) (THIS_
                IN      ChannelID)
                PURE;

    STDMETHOD_(MCSError, ChannelLeave) (THIS_
                IN      ChannelID)
                PURE;

    STDMETHOD_(MCSError, ChannelConvene) (THIS)
                PURE;

    STDMETHOD_(MCSError, ChannelDisband) (THIS_
                IN      ChannelID)
                PURE;

    STDMETHOD_(MCSError, ChannelAdmit) (THIS_
                IN      ChannelID,
                IN		PUserID,
				IN		UINT)
                PURE;

    /* send data services */

    STDMETHOD_(MCSError, SendData) (THIS_
                IN      DataRequestType,
                IN      ChannelID,
                IN      Priority,
                IN		unsigned char *,
                IN		ULong,
                IN		SendDataFlags)
                PURE;

	/*	token services */
    STDMETHOD_(MCSError, TokenGrab) (THIS_
                IN      TokenID)
                PURE;

    STDMETHOD_(MCSError, TokenInhibit) (THIS_
                IN      TokenID)
                PURE;

    STDMETHOD_(MCSError, TokenGive) (THIS_
                IN      TokenID,
                IN		UserID)
                PURE;

    STDMETHOD_(MCSError, TokenGiveResponse) (THIS_
                IN      TokenID,
                IN		Result)
                PURE;

    STDMETHOD_(MCSError, TokenPlease) (THIS_
                IN      TokenID)
                PURE;
                
    STDMETHOD_(MCSError, TokenRelease) (THIS_
                IN      TokenID)
                PURE;

    STDMETHOD_(MCSError, TokenTest) (THIS_
                IN      TokenID)
                PURE;
};

typedef IMCSSap * 		PIMCSSap;


//
// GCC Application Service Access Point exports
//

#ifdef __cplusplus
extern "C" {
#endif

MCSError WINAPI MCS_AttachRequest(
                        OUT     IMCSSap **,
                        IN		DomainSelector,
                        IN		UINT,
                        IN      MCSCallBack,
                        IN		PVoid,
                        IN		UINT);
#ifdef __cplusplus
}
#endif


#endif // _IMCSAPP_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\remdsk\rds\h\it120app.h ===
#ifndef _IT120APPSAP_H_
#define _IT120APPSAP_H_

#include <basetyps.h>
#include "gcc.h"
#include "igccapp.h"
#include "imcsapp.h"


typedef void (CALLBACK *LPFN_APPLET_SESSION_CB) (struct T120AppletSessionMsg *);
typedef void (CALLBACK *LPFN_APPLET_CB) (struct T120AppletMsg *);


/* ------ registry request ------ */

typedef struct tagT120RegistryParameter
{
    LPOSTR                      postrValue;
    AppletModificationRights    eModifyRights;
}
    T120RegistryParameter;

typedef struct tagT120RegistryRequest
{
    AppletRegistryCommand   eCommand;
    GCCRegistryKey         *pRegistryKey;
    union
    {
        // register channel
        T120ChannelID           nChannelID;
        // set parameter
        T120RegistryParameter   Param;
        // monitor
        BOOL                    fEnableDelivery;
        // allocate handle
        ULONG                   cHandles;
    };
}
    T120RegistryRequest;


/* ------ channel request ------ */

typedef struct tagT120ChannelRequest
{
    AppletChannelCommand    eCommand;
    T120ChannelID           nChannelID;
    ULONG                   cUsers;
    T120UserID             *aUsers;
}
    T120ChannelRequest;


/* ------ token request ------ */

typedef struct tagT120TokenRequest
{
    AppletTokenCommand      eCommand;
    T120TokenID             nTokenID;
    T120UserID              uidGiveTo;
    T120Result              eGiveResponse;
}
    T120TokenRequest;


/* ------ join conference ------ */

typedef struct tagT120ResourceRequest
{
    AppletResourceAllocCommand  eCommand;
    BOOL                        fImmediateNotification;
    T120ChannelID               nChannelID;
    T120TokenID                 nTokenID;
    GCCRegistryKey              RegKey;
}
    T120ResourceRequest;

typedef struct tagT120JoinSessionRequest
{
    // attach user flags
    DWORD                   dwAttachmentFlags;
    // session specific
    GCCSessionKey           SessionKey;
    // applet enroll
    BOOL                    fConductingCapable;
    AppletChannelType       nStartupChannelType;
    ULONG                   cNonCollapsedCaps;
    GCCNonCollCap         **apNonCollapsedCaps;
    ULONG                   cCollapsedCaps;
    GCCAppCap             **apCollapsedCaps;
    // static and dynamic channels
    ULONG                   cStaticChannels;
    T120ChannelID          *aStaticChannels;
    ULONG                   cResourceReqs;
    T120ResourceRequest    *aResourceReqs;
}
    T120JoinSessionRequest;



#undef  INTERFACE
#define INTERFACE IT120AppletSession
DECLARE_INTERFACE(IT120AppletSession)
{
    STDMETHOD_(void, ReleaseInterface) (THIS) PURE;

    STDMETHOD_(void, Advise) (THIS_
                IN      LPFN_APPLET_SESSION_CB pfnCallback,
                IN      LPVOID  pAppletContext,
                IN      LPVOID  pSessionContext) PURE;

    STDMETHOD_(void, Unadvise) (THIS) PURE;

    /* ------ basic info ------ */

    STDMETHOD_(T120ConfID, GetConfID) (THIS) PURE;

    STDMETHOD_(BOOL, IsThisNodeTopProvider) (THIS) PURE;

    STDMETHOD_(T120NodeID, GetTopProvider) (THIS) PURE;

    /* ------ join/leave ------ */

    STDMETHOD_(T120Error, Join) (THIS_
                IN      T120JoinSessionRequest *) PURE;

    STDMETHOD_(void, Leave) (THIS) PURE;

    /* ------ send data ------ */

    STDMETHOD_(T120Error, AllocateSendDataBuffer) (THIS_
                IN      ULONG,
                OUT     void **) PURE;

    STDMETHOD_(void, FreeSendDataBuffer) (THIS_
                IN      void *) PURE;

    STDMETHOD_(T120Error, SendData) (THIS_
                IN      DataRequestType,
                IN      T120ChannelID,
                IN      T120Priority,
                IN		LPBYTE,
                IN		ULONG,
                IN		SendDataFlags) PURE;

    /* ------ inquiry ------ */

    STDMETHOD_(T120Error, InvokeApplet) (THIS_
                IN      GCCAppProtEntityList *,
                IN      GCCSimpleNodeList *,
                OUT     T120RequestTag *) PURE;

    STDMETHOD_(T120Error, InquireRoster) (THIS_
                IN      GCCSessionKey *) PURE;

    /* ------ registry services ------ */

    STDMETHOD_(T120Error, RegistryRequest) (THIS_
                IN      T120RegistryRequest *) PURE;

    /* ------ channel services ------ */

    STDMETHOD_(T120Error, ChannelRequest) (THIS_
                IN      T120ChannelRequest *) PURE;

    /* ------ token services ------ */

    STDMETHOD_(T120Error, TokenRequest) (THIS_
                IN      T120TokenRequest *) PURE;
};


//
// T120 Applet Session Callback
//

typedef struct tagT120JoinSessionConfirm
{
    T120Result              eResult;
    T120Error               eError;
    IT120AppletSession     *pIAppletSession;
    T120UserID              uidMyself;
    T120SessionID           sidMyself;
    T120EntityID            eidMyself;
    T120NodeID              nidMyself;
    // the following two are the same as those in the request structure
    ULONG                   cResourceReqs;
    T120ResourceRequest    *aResourceReqs;
}
    T120JoinSessionConfirm;


typedef struct tagT120ChannelConfirm
{
    T120ChannelID           nChannelID;
    T120Result              eResult;
}
    T120ChannelConfirm;


typedef struct tagT120ChannelInd
{
    T120ChannelID           nChannelID;
    union
    {
        T120Reason          eReason;
        T120UserID          nManagerID;
    };
}
    T120ChannelInd;


typedef struct tagT120TokenConfirm
{
    T120TokenID             nTokenID;
    union
    {
        T120TokenStatus     eTokenStatus;
        T120Result          eResult;
    };
}
    T120TokenConfirm;


typedef struct tagT120TokenInd
{
    T120TokenID             nTokenID;
    union
    {
        T120Reason          eReason;
        T120UserID          nUserID;
    };
}
    T120TokenInd;


typedef struct tagT120DetachUserInd
{
    T120UserID              nUserID;
    T120Reason              eReason;
}
    T120DetachUserInd;


// internal use
typedef struct tagT120AttachUserConfirm
{
    T120UserID              nUserID;
    T120Result              eResult;
}
    T120AttachUserConfirm;


/*
 *  GCCAppSapMsg
 *      This structure defines the callback message that is passed from GCC to
 *      a user application when an indication or confirm occurs.
 */

typedef struct T120AppletSessionMsg
{
    T120MessageType     eMsgType;
    LPVOID              pAppletContext;
    LPVOID              pSessionContext;
    T120ConfID          nConfID;

    union
    {
        T120JoinSessionConfirm              JoinSessionConfirm;
        T120DetachUserInd                   DetachUserInd;

        GCCAppRosterInquireConfirm          AppRosterInquireConfirm;
        GCCAppRosterReportInd               AppRosterReportInd;

        GCCConfRosterInquireConfirm         ConfRosterInquireConfirm;

        GCCAppInvokeConfirm                 AppInvokeConfirm;
        GCCAppInvokeInd                     AppInvokeInd;

        GCCRegistryConfirm                  RegistryConfirm;
        GCCRegAllocateHandleConfirm         RegAllocHandleConfirm;

        SendDataIndicationPDU               SendDataInd;

        T120ChannelConfirm                  ChannelConfirm;
        T120ChannelInd                      ChannelInd;
        T120TokenConfirm                    TokenConfirm;
        T120TokenInd                        TokenInd;

        // will be removed in the future after converting all applets
        GCCAppEnrollConfirm                 AppEnrollConfirm;
        T120AttachUserConfirm               AttachUserConfirm;
    };
}
    T120AppletSessionMsg;



typedef struct T120AppletMsg
{
    T120MessageType     eMsgType;
    LPVOID              pAppletContext;
    LPVOID              Reserved1;
    T120ConfID          nConfID;

    union
    {
        GCCAppPermissionToEnrollInd         PermitToEnrollInd;
        T120JoinSessionConfirm              AutoJoinSessionInd;
    };
}
    T120AppletMsg;


#undef  INTERFACE
#define INTERFACE IT120AppletNotify
DECLARE_INTERFACE(IT120AppletNotify)
{
    STDMETHOD_(void, PermitToJoinSessionIndication) (THIS_
                    IN      T120ConfID,
                    IN      BOOL fPermissionGranted) PURE;

    STDMETHOD_(void, AutoJoinSessionIndication) (THIS_
                    IN      T120JoinSessionConfirm *) PURE;
};


#undef  INTERFACE
#define INTERFACE IT120Applet
DECLARE_INTERFACE(IT120Applet)
{
    STDMETHOD_(void, ReleaseInterface) (THIS) PURE;

    STDMETHOD_(void, Advise) (THIS_
                    IN      LPFN_APPLET_CB pfnCallback,
                    IN      LPVOID         pAppletContext) PURE;

    STDMETHOD_(void, Unadvise) (THIS) PURE;

    /* ------ Auto Join ------ */

    STDMETHOD_(T120Error, RegisterAutoJoin) (THIS_
                    IN      T120JoinSessionRequest *) PURE;

    STDMETHOD_(void, UnregisterAutoJoin) (THIS) PURE;

    /* ------ Session ------ */

    STDMETHOD_(T120Error, CreateSession) (THIS_
                    OUT     IT120AppletSession **,
                    IN      T120ConfID) PURE;
};


//
// T120 Applet SAP Exports
//

#ifdef __cplusplus
extern "C" {
#endif

T120Error WINAPI T120_CreateAppletSAP(IT120Applet **);
void      WINAPI T120_GetNodeName(LPSTR, UINT);

#ifdef __cplusplus
}
#endif


#endif // _IT120APPSAP_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\remdsk\rds\h\inodecnt.h ===
#ifndef _INODECNT_H_
#define _INODECNT_H_

typedef void * REQUEST_HANDLE;
typedef REQUEST_HANDLE * PREQUEST_HANDLE;
typedef void * ROSTER_DATA_HANDLE;

typedef struct NC_ROSTER_NODE_ENTRY
{
    PWSTR               pwszNodeName;
    UINT                uNodeID;
    UINT                uSuperiorNodeID;
    BOOL                fMCU;
    ROSTER_DATA_HANDLE  hUserData;
} NC_ROSTER_NODE_ENTRY, * PNC_ROSTER_NODE_ENTRY;

typedef struct NC_ROSTER
{
    UINT                    uNumNodes;
    PWSTR                   pwszConferenceName;
    UINT                    uConferenceID;
    UINT                    uLocalNodeID;
    NC_ROSTER_NODE_ENTRY    nodes[1];
} NC_ROSTER, * PNC_ROSTER;



#undef  INTERFACE
#define INTERFACE IDataConference

DECLARE_INTERFACE(IDataConference)
{
    STDMETHOD_(void, ReleaseInterface)( THIS ) PURE;

    STDMETHOD_(UINT, GetConferenceID) ( THIS ) PURE;

    STDMETHOD(Leave)                  ( THIS ) PURE;

    STDMETHOD(EjectUser)              ( THIS_
                                        UINT                uNodeID) PURE;

    STDMETHOD(Invite)                 ( THIS_
                                        LPCSTR              pcszAddress,
                                        PREQUEST_HANDLE     phRequest) PURE;

    STDMETHOD(InviteResponse)         ( THIS_
                                        BOOL                fResponse) PURE;

    STDMETHOD(JoinResponse)           ( THIS_
                                        BOOL                fResponse) PURE;

    STDMETHOD(LaunchGuid)             ( THIS_
                                        const GUID*         pcGUID,
                                        UINT                auNodeIDs[],
                                        UINT                cNodes) PURE;

    STDMETHOD_(BOOL, IsSecure) ( THIS_) PURE;

    STDMETHOD(GetLocalAddressList)    ( THIS_
                                        LPWSTR              pwszBuffer,
                                        UINT                cchBuffer) PURE;
    STDMETHOD(CancelInvite)           ( THIS_
                                        REQUEST_HANDLE      hRequest) PURE;
    STDMETHOD(SetSecurity)              ( THIS_
                                          BOOL                fSecure) PURE;

    STDMETHOD(GetCred)                ( THIS_
                                        PBYTE*              ppbCred,
                                        DWORD*              pcbCred) PURE;

    STDMETHOD_(UINT, GetParentNodeID) ( THIS ) PURE;
};

typedef IDataConference * CONF_HANDLE;
typedef CONF_HANDLE     * PCONF_HANDLE;



#undef  INTERFACE
#define INTERFACE INodeControllerEvents

DECLARE_INTERFACE(INodeControllerEvents)
{
    STDMETHOD(OnConferenceStarted)(     THIS_
                                        CONF_HANDLE         hConference,
                                        HRESULT             hResult) PURE;
    STDMETHOD(OnConferenceEnded)(       THIS_
                                        CONF_HANDLE         hConference) PURE;
    STDMETHOD(OnRosterChanged)(         THIS_
                                        CONF_HANDLE         hConference,
                                        PNC_ROSTER          pRoster) PURE;
    STDMETHOD(OnIncomingInviteRequest)( THIS_
                                        CONF_HANDLE         hConference,
                                        PCWSTR              pcwszNodeName,
                                        BOOL                fSecure) PURE;
    STDMETHOD(OnIncomingJoinRequest)(   THIS_
                                        CONF_HANDLE         hConference,
                                        PCWSTR              pcwszNodeName) PURE;
    STDMETHOD(OnQueryRemoteResult)(     THIS_
                                        PVOID               pvCallerContext,
                                        HRESULT             hResult,
                                        BOOL                fMCU,
                                        PWSTR*              ppwszConferenceNames,
                                        PWSTR*              ppwszConfDescriptors) PURE;
    STDMETHOD(OnInviteResult)(          THIS_
                                        CONF_HANDLE         hConference,
                                        REQUEST_HANDLE      hRequest,
                                        UINT                uNodeID,
                                        HRESULT             hResult) PURE;
};



#undef  INTERFACE
#define INTERFACE INodeController

DECLARE_INTERFACE(INodeController)
{
    STDMETHOD_(void, ReleaseInterface)( THIS_) PURE;

    STDMETHOD(QueryRemote)(             THIS_
                                        LPVOID              pCallerContext,
                                        LPCSTR              pcszAddress,
                                        BOOL                fSecure,
                                        BOOL                fIsConferenceActive) PURE;

    STDMETHOD(CancelQueryRemote)(       THIS_
                                        LPVOID              pCallerContext) PURE;

    STDMETHOD(CreateConference)(        THIS_
                                        LPCWSTR             pcwszConferenceName,
                                        LPCWSTR             pcwszPassword,
                                        PBYTE               pbHashedPassword,
                                        DWORD               cbHashedPassword,
                                        BOOL                fSecure,
                                        PCONF_HANDLE        phConference) PURE;

    STDMETHOD(JoinConference)(          THIS_
                                        LPCWSTR             pcwszConferenceName,
                                        LPCWSTR             pcwszPassword,
                                        LPCSTR              pcszAddress,
                                        BOOL                fSecure,
                                        PCONF_HANDLE        phConference) PURE;

    STDMETHOD_(UINT, GetPluggableConnID) (THIS_
                                         LPCSTR pcszNodeAddress) PURE;
};

HRESULT WINAPI T120_CreateNodeController(INodeController **, INodeControllerEvents *,
    BSTR szUserName, DWORD_PTR pCredentials, DWORD flags);
BOOL WINAPI T120_GetSecurityInfoFromGCCID(DWORD dwGCCID, PBYTE pInfo, PDWORD pcbInfo);

//
// Return codes
//

#define NC_ERR_FAC 0xfe00
#define NC_E(e)    (0x81000000UL | NC_ERR_FAC | (ULONG) (e))

enum UI_RC_ERRORS
{
    UI_RC_ALREADY_IN_CONFERENCE =                NC_E(0x01),
    UI_RC_CONFERENCE_ALREADY_EXISTS,
    UI_RC_INVALID_PASSWORD,
    UI_RC_NO_CONFERENCE_NAME,
    UI_RC_T120_FAILURE,
    UI_RC_UNKNOWN_CONFERENCE,
    UI_RC_BAD_TRANSPORT_NAME,
    UI_RC_USER_REJECTED,

    LAST_RC_GCC_MAPPED_ERROR = UI_RC_USER_REJECTED,

    UI_RC_T120_ALREADY_INITIALIZED,
    UI_RC_BAD_ADDRESS,
    UI_RC_NO_ADDRESS,
    UI_RC_NO_SUCH_CONFERENCE,
    UI_RC_CONFERENCE_CREATE_FAILED,
    UI_RC_BAD_PARAMETER,
    UI_RC_OUT_OF_MEMORY,
    UI_RC_CALL_GOING_DOWN,
    UI_RC_CALL_FAILED,
    UI_NO_SUCH_CONFERENCE,
    UI_RC_CONFERENCE_GOING_DOWN,
    UI_RC_INVALID_REQUEST,
    UI_RC_USER_DISCONNECTED,
    UI_RC_EXITING_CORE_UI,
    UI_RC_NO_NODE_NAME,
    UI_RC_INVALID_TRANSPORT_SETTINGS,
    UI_RC_REGISTER_CPI_FAILURE,
    UI_RC_CMP_FAILURE,
    UI_RC_TRANSPORT_DISABLED,
    UI_RC_TRANSPORT_FAILED,
    UI_RC_NOT_SUPPORTED,
    UI_RC_NOT_SUPPORTED_IN_BACKLEVEL,
    UI_RC_CONFERENCE_NOT_READY,
    UI_RC_NO_SUCH_USER_DATA,
    UI_RC_INTERNAL_ERROR,
    UI_RC_VERSION_REMOTE_INCOMPATIBLE,
    UI_RC_VERSION_LOCAL_INCOMPATIBLE,
    UI_RC_VERSION_REMOTE_EXPIRED,
    UI_RC_VERSION_LOCAL_UPGRADE_RECOMMENDED,
    UI_RC_VERSION_REMOTE_UPGRADE_RECOMMENDED,
    UI_RC_VERSION_REMOTE_OLDER,
    UI_RC_VERSION_REMOTE_NEWER,
    UI_RC_BACKLEVEL_LOADED,
    UI_RC_NULL_MODEM_CONNECTION,
    UI_RC_CANCELED,
    UI_RC_T120_REMOTE_NO_SECURITY,
    UI_RC_T120_REMOTE_DOWNLEVEL_SECURITY,
    UI_RC_T120_REMOTE_REQUIRE_SECURITY,
    UI_RC_T120_SECURITY_FAILED,
	UI_RC_T120_AUTHENTICATION_FAILED,
    UI_RC_NO_WINSOCK,

    //
    // Internal return codes
    //
    UI_RC_START_PRIMARY =                  NC_E(0x81),
    UI_RC_START_ALTERNATE =                NC_E(0x82)
};

#endif // _INODECNT_H_


=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\remdsk\rds\h\it120nc.h ===
#ifndef _IGCCControlSAP_H_
#define _IGCCControlSAP_H_

#include <basetyps.h>
#include "gcc.h"
#include "igccapp.h"

/*
 *    These structures are used to hold the information included for the
 *    various callback messages.  In the case where these structures are used for 
 *    callbacks, the address of the structure is passed as the only parameter.
 */

typedef struct
{
    PGCCConferenceName          conference_name;
    GCCNumericString            conference_modifier;
    BOOL                        use_password_in_the_clear;
    BOOL                        conference_is_locked;
    BOOL                        conference_is_listed;
    BOOL                        conference_is_conductible;
    GCCTerminationMethod        termination_method;
    PGCCConferencePrivileges    conduct_privilege_list;
    PGCCConferencePrivileges    conduct_mode_privilege_list;
    PGCCConferencePrivileges    non_conduct_privilege_list;
    LPWSTR                      pwszConfDescriptor;
    LPWSTR                      pwszCallerID;
    TransportAddress            calling_address;
    TransportAddress            called_address;
    PDomainParameters           domain_parameters;
    UINT                        number_of_network_addresses;
    PGCCNetworkAddress         *network_address_list;
    PConnectionHandle           connection_handle;
}
    GCCConfCreateReqCore;

typedef struct
{
    GCCConfCreateReqCore        Core;
    PGCCPassword                convener_password;
    PGCCPassword                password;
    BOOL                        fSecure;
    UINT                        number_of_user_data_members;
    PGCCUserData               *user_data_list;
}
    GCCConfCreateRequest;


/*********************************************************************
 *                                                                   *
 *            NODE CONTROLLER CALLBACK INFO STRUCTURES               *
 *                                                                   *
 *********************************************************************/

typedef struct
{
    GCCConfID                   conference_id;
    GCCResult                   result;
}
    SimpleConfirmMsg;

/*
 *    GCC_CREATE_INDICATION
 *
 *    Union Choice:
 *        CreateIndicationMessage
 *            This is a pointer to a structure that contains all necessary
 *            information about the new conference that is about to be created.
 */
typedef struct
{
    GCCConferenceName           conference_name;
    GCCConferenceID             conference_id;
    GCCPassword                *convener_password;              /* optional */
    GCCPassword                *password;                       /* optional */
    BOOL                        conference_is_locked;
    BOOL                        conference_is_listed;
    BOOL                        conference_is_conductible;
    GCCTerminationMethod        termination_method;
    GCCConferencePrivileges    *conductor_privilege_list;       /* optional */
    GCCConferencePrivileges    *conducted_mode_privilege_list;  /* optional */
    GCCConferencePrivileges    *non_conducted_privilege_list;   /* optional */
    LPWSTR                      conference_descriptor;          /* optional */
    LPWSTR                      caller_identifier;              /* optional */
    TransportAddress            calling_address;                /* optional */
    TransportAddress            called_address;                 /* optional */
    DomainParameters           *domain_parameters;              /* optional */
    UINT                        number_of_user_data_members;
    GCCUserData               **user_data_list;                 /* optional */
    ConnectionHandle            connection_handle;
}
    CreateIndicationMessage, *PCreateIndicationMessage;

/*
 *    GCC_CREATE_CONFIRM
 *
 *    Union Choice:
 *        CreateConfirmMessage
 *            This is a pointer to a structure that contains all necessary
 *            information about the result of a conference create request.
 *            The connection handle and physical handle will be zero on a
 *            local create.
 */
typedef struct
{
    GCCConferenceName           conference_name;
    GCCNumericString            conference_modifier;            /* optional */
    GCCConferenceID             conference_id;
    DomainParameters           *domain_parameters;              /* optional */
    UINT                        number_of_user_data_members;
    GCCUserData               **user_data_list;                 /* optional */
    GCCResult                   result;
    ConnectionHandle            connection_handle;              /* optional */
}
    CreateConfirmMessage, *PCreateConfirmMessage;

/*
 *    GCC_QUERY_INDICATION
 *
 *    Union Choice:
 *        QueryIndicationMessage
 *            This is a pointer to a structure that contains all necessary
 *            information about the conference query.
 */
typedef struct
{
    GCCResponseTag              query_response_tag;
    GCCNodeType                 node_type;
    GCCAsymmetryIndicator      *asymmetry_indicator;
    TransportAddress            calling_address;                /* optional */
    TransportAddress            called_address;                 /* optional */
    UINT                        number_of_user_data_members;
    GCCUserData               **user_data_list;                 /* optional */
    ConnectionHandle            connection_handle;
}
    QueryIndicationMessage, *PQueryIndicationMessage;

/*
 *    GCC_QUERY_CONFIRM
 *
 *    Union Choice:
 *        QueryConfirmMessage
 *            This is a pointer to a structure that contains all necessary
 *            information about the result of a conference query request.
 */
typedef struct
{
    GCCNodeType                 node_type;
    GCCAsymmetryIndicator      *asymmetry_indicator;            /* optional */
    UINT                        number_of_descriptors;
    GCCConferenceDescriptor   **conference_descriptor_list;     /* optional*/
    UINT                        number_of_user_data_members;
    GCCUserData               **user_data_list;                 /* optional */
    GCCResult                   result;
    ConnectionHandle            connection_handle;
}
    QueryConfirmMessage, *PQueryConfirmMessage;
    

/*
 *    GCC_JOIN_INDICATION
 *
 *    Union Choice:
 *        JoinIndicationMessage
 *            This is a pointer to a structure that contains all necessary
 *            information about the join request.
 */
typedef struct
{
    GCCResponseTag              join_response_tag;
    GCCConferenceID             conference_id;
    GCCPassword                *convener_password;              /* optional */
    GCCChallengeRequestResponse*password_challenge;             /* optional */
    LPWSTR                      caller_identifier;              /* optional */
    TransportAddress            calling_address;                /* optional */
    TransportAddress            called_address;                 /* optional */
    UINT                        number_of_user_data_members;
    GCCUserData               **user_data_list;                 /* optional */
    BOOL                        node_is_intermediate;
    ConnectionHandle            connection_handle;
}
    JoinIndicationMessage, *PJoinIndicationMessage;

/*
 *    GCC_JOIN_CONFIRM
 *
 *    Union Choice:
 *        JoinConfirmMessage
 *            This is a pointer to a structure that contains all necessary
 *            information about the join confirm.
 */
typedef struct
{
    GCCConferenceName           conference_name;
    GCCNumericString            called_node_modifier;           /* optional */
    GCCNumericString            calling_node_modifier;          /* optional */
    GCCConferenceID             conference_id;
    GCCChallengeRequestResponse*password_challenge;             /* optional */
    DomainParameters           *domain_parameters;
    BOOL                        clear_password_required;
    BOOL                        conference_is_locked;
    BOOL                        conference_is_listed;
    BOOL                        conference_is_conductible;
    GCCTerminationMethod        termination_method;
    GCCConferencePrivileges    *conductor_privilege_list;       /* optional */
    GCCConferencePrivileges    *conducted_mode_privilege_list;  /* optional */
    GCCConferencePrivileges    *non_conducted_privilege_list;   /* optional */
    LPWSTR                      conference_descriptor;          /* optional */
    UINT                        number_of_user_data_members;
    GCCUserData               **user_data_list;                 /* optional */
    GCCResult                   result;
    ConnectionHandle            connection_handle;
    PBYTE                       pb_remote_cred;
    DWORD                       cb_remote_cred;
}
    JoinConfirmMessage, *PJoinConfirmMessage;

/*
 *    GCC_INVITE_INDICATION
 *
 *    Union Choice:
 *        InviteIndicationMessage
 *            This is a pointer to a structure that contains all necessary
 *            information about the invite indication.
 */
typedef struct
{
    GCCConferenceID             conference_id;
    GCCConferenceName           conference_name;
    LPWSTR                      caller_identifier;              /* optional */
    TransportAddress            calling_address;                /* optional */
    TransportAddress            called_address;                 /* optional */
    BOOL                        fSecure;
    DomainParameters           *domain_parameters;              /* optional */
    BOOL                        clear_password_required;
    BOOL                        conference_is_locked;
    BOOL                        conference_is_listed;
    BOOL                        conference_is_conductible;
    GCCTerminationMethod        termination_method;
    GCCConferencePrivileges    *conductor_privilege_list;       /* optional */
    GCCConferencePrivileges    *conducted_mode_privilege_list;  /* optional */
    GCCConferencePrivileges    *non_conducted_privilege_list;   /* optional */
    LPWSTR                      conference_descriptor;          /* optional */
    UINT                        number_of_user_data_members;
    GCCUserData               **user_data_list;                 /* optional */
    ConnectionHandle            connection_handle;
}
    InviteIndicationMessage, *PInviteIndicationMessage;

/*
 *    GCC_INVITE_CONFIRM
 *
 *    Union Choice:
 *        InviteConfirmMessage
 *            This is a pointer to a structure that contains all necessary
 *            information about the invite confirm.
 */
typedef struct
{
    GCCConferenceID             conference_id;
    UINT                        number_of_user_data_members;
    GCCUserData               **user_data_list;                 /* optional */
    GCCResult                   result;
    ConnectionHandle            connection_handle;
}
    InviteConfirmMessage, *PInviteConfirmMessage;

/*
 *    GCC_ADD_INDICATION
 *
 *    Union Choice:
 *        AddIndicationMessage
 */
typedef struct
{
    GCCResponseTag              add_response_tag;
    GCCConferenceID             conference_id;
    UINT                        number_of_network_addresses;
    GCCNetworkAddress         **network_address_list;
    UserID                      requesting_node_id;
    UINT                        number_of_user_data_members;
    GCCUserData               **user_data_list;                 /* optional */
}
    AddIndicationMessage, *PAddIndicationMessage;

/*
 *    GCC_ADD_CONFIRM
 *
 *    Union Choice:
 *        AddConfirmMessage
 */
typedef struct
{
    GCCConferenceID             conference_id;
    UINT                        number_of_network_addresses;
    GCCNetworkAddress         **network_address_list;
    UINT                        number_of_user_data_members;
    GCCUserData               **user_data_list;                 /* optional */
    GCCResult                   result;
}
    AddConfirmMessage, *PAddConfirmMessage;

/*
 *    GCC_LOCK_INDICATION
 *
 *    Union Choice:
 *        LockIndicationMessage
 */
typedef struct
{
    GCCConferenceID             conference_id;
    UserID                      requesting_node_id;
}
    LockIndicationMessage, *PLockIndicationMessage;

/*
 *    GCC_UNLOCK_INDICATION
 *
 *    Union Choice:
 *        UnlockIndicationMessage
 */
typedef struct
{
    GCCConferenceID             conference_id;
    UserID                      requesting_node_id;
}
    UnlockIndicationMessage, *PUnlockIndicationMessage;

/*
 *    GCC_DISCONNECT_INDICATION
 *
 *    Union Choice:
 *        DisconnectIndicationMessage
 */
typedef struct
{
    GCCConferenceID             conference_id;
    GCCReason                   reason;
    UserID                      disconnected_node_id;
}
    DisconnectIndicationMessage, *PDisconnectIndicationMessage;

/*
 *    GCC_DISCONNECT_CONFIRM
 *
 *    Union Choice:
 *        PDisconnectConfirmMessage
 */
typedef SimpleConfirmMsg    DisconnectConfirmMessage, *PDisconnectConfirmMessage;

/*
 *    GCC_TERMINATE_INDICATION
 *
 *    Union Choice:
 *        TerminateIndicationMessage
 */
typedef struct
{
    GCCConferenceID             conference_id;
    UserID                      requesting_node_id;
    GCCReason                   reason;
}
    TerminateIndicationMessage, *PTerminateIndicationMessage;

/*
 *    GCC_TERMINATE_CONFIRM
 *
 *    Union Choice:
 *        TerminateConfirmMessage
 */
typedef SimpleConfirmMsg    TerminateConfirmMessage, *PTerminateConfirmMessage;

/*
 *    GCC_CONNECTION_BROKEN_INDICATION
 *
 *    Union Choice:
 *        ConnectionBrokenIndicationMessage
 *
 *    Caveat: 
 *        This is a non-standard indication.
 */
typedef struct
{
    ConnectionHandle            connection_handle;
}
    ConnectionBrokenIndicationMessage, *PConnectionBrokenIndicationMessage;


/*
 *    GCC_EJECT_USER_INDICATION
 *
 *    Union Choice:
 *        EjectUserIndicationMessage
 */
typedef struct
{
    GCCConferenceID             conference_id;
    UserID                      ejected_node_id;
    GCCReason                   reason;
}
    EjectUserIndicationMessage, *PEjectUserIndicationMessage;

/*
 *    GCC_PERMIT_TO_ANNOUNCE_PRESENCE
 *
 *    Union Choice:
 *        PermitToAnnouncePresenceMessage
 */
typedef struct
{
    GCCConferenceID             conference_id;
    UserID                      node_id;
}
    PermitToAnnouncePresenceMessage, *PPermitToAnnouncePresenceMessage;

/*
 *    GCC_ANNOUNCE_PRESENCE_CONFIRM
 *
 *    Union Choice:
 *        AnnouncePresenceConfirmMessage
 */
typedef SimpleConfirmMsg    AnnouncePresenceConfirmMessage, *PAnnouncePresenceConfirmMessage;

/*
 *    GCC_ROSTER_REPORT_INDICATION
 *
 *    Union Choice:
 *        ConfRosterReportIndicationMessage
 */
typedef struct
{
    GCCConferenceID             conference_id;
    GCCConferenceRoster        *conference_roster;
}
    ConfRosterReportIndicationMessage, *PConfRosterReportIndicationMessage;

/*
 *    GCC_CONDUCT_GIVE_INDICATION
 *
 *    Union Choice:
 *        ConductorGiveIndicationMessage
 */
typedef struct
{        
    GCCConferenceID             conference_id;
}
    ConductGiveIndicationMessage, *PConductGiveIndicationMessage;

/*
 *    GCC_TIME_INQUIRE_INDICATION
 *
 *    Union Choice:
 *        TimeInquireIndicationMessage
 */
typedef struct
{
    GCCConferenceID             conference_id;
    BOOL                        time_is_conference_wide;
    UserID                      requesting_node_id;
}
    TimeInquireIndicationMessage, *PTimeInquireIndicationMessage;

/*
 *    GCC_STATUS_INDICATION
 *
 *    Union Choice:
 *        GCCStatusMessage
 *            This callback is used to relay GCC status to the node controller
 */
typedef    enum
{
    GCC_STATUS_PACKET_RESOURCE_FAILURE      = 0,
    GCC_STATUS_PACKET_LENGTH_EXCEEDED       = 1,
    GCC_STATUS_CTL_SAP_RESOURCE_ERROR       = 2,
    GCC_STATUS_APP_SAP_RESOURCE_ERROR       = 3, /*    parameter = Sap Handle */
    GCC_STATUS_CONF_RESOURCE_ERROR          = 4, /*    parameter = Conference ID */
    GCC_STATUS_INCOMPATIBLE_PROTOCOL        = 5, /*    parameter = Physical Handle */
    GCC_STATUS_JOIN_FAILED_BAD_CONF_NAME    = 6, /* parameter = Physical Handle */
    GCC_STATUS_JOIN_FAILED_BAD_CONVENER     = 7, /* parameter = Physical Handle */
    GCC_STATUS_JOIN_FAILED_LOCKED           = 8  /* parameter = Physical Handle */
}
    GCCStatusMessageType;

typedef struct
{
    GCCStatusMessageType        status_message_type;
    UINT                        parameter;
}
    GCCStatusIndicationMessage, *PGCCStatusIndicationMessage;

/*
 *    GCC_SUB_INITIALIZED_INDICATION
 *
 *    Union Chice:
 *        SubInitializedIndicationMessage
 */
typedef struct
{
    ConnectionHandle            connection_handle;
    UserID                      subordinate_node_id;
}
    SubInitializedIndicationMessage, *PSubInitializedIndicationMessage;



#ifdef JASPER // ------------------------------------------------
/*
 *    GCC_LOCK_CONFIRM
 *
 *    Union Choice:
 *        LockConfirmMessage
 */
typedef SimpleConfirmMsg    LockConfirmMessage, *PLockConfirmMessage;

/*
 *    GCC_UNLOCK_CONFIRM
 *
 *    Union Choice:
 *        UnlockConfirmMessage
 */
typedef SimpleConfirmMsg    UnlockConfirmMessage, *PUnlockConfirmMessage;

/*
 *    GCC_LOCK_REPORT_INDICATION
 *
 *    Union Choice:
 *        LockReportIndicationMessage
 */
typedef struct
{
    GCCConferenceID             conference_id;
    BOOL                        conference_is_locked;
}
    LockReportIndicationMessage, *PLockReportIndicationMessage;

/*
 *    GCC_EJECT_USER_CONFIRM
 *
 *    Union Choice:
 *        EjectUserConfirmMessage
 */
typedef struct
{
    GCCConferenceID              conference_id;
    GCCResult                    result;
    UserID                       ejected_node_id;
}
    EjectUserConfirmMessage, *PEjectUserConfirmMessage;

/*
 *    GCC_TRANSFER_INDICATION
 *
 *    Union Choice:
 *        TransferIndicationMessage
 */
typedef struct
{
    GCCConferenceID             conference_id;
    GCCConferenceName           destination_conference_name;
    GCCNumericString            destination_conference_modifier;/* optional */
    UINT                        number_of_destination_addresses;
    GCCNetworkAddress         **destination_address_list;
    GCCPassword                *password;                       /* optional */
}
    TransferIndicationMessage, *PTransferIndicationMessage;

/*
 *    GCC_TRANSFER_CONFIRM
 *
 *    Union Choice:
 *        TransferConfirmMessage
 */
typedef struct
{
    GCCConferenceID             conference_id;
    GCCConferenceName           destination_conference_name;
    GCCNumericString            destination_conference_modifier;/* optional */
    UINT                        number_of_destination_nodes;
    UserID                     *destination_node_list;
    GCCResult                   result;
}
    TransferConfirmMessage, *PTransferConfirmMessage;

/*
 *    GCC_CONDUCT_ASSIGN_CONFIRM
 *
 *    Union Choice:
 *        ConductAssignConfirmMessage
 */
typedef SimpleConfirmMsg    ConductAssignConfirmMessage, *PConductAssignConfirmMessage;

/*
 *    GCC_CONDUCT_RELEASE_CONFIRM
 *
 *    Union Choice:
 *        ConductorReleaseConfirmMessage
 */
typedef SimpleConfirmMsg    ConductReleaseConfirmMessage, *PConductReleaseConfirmMessage; 

/*
 *    GCC_CONDUCT_PLEASE_INDICATION
 *
 *    Union Choice:
 *        ConductorPleaseIndicationMessage
 */
typedef struct
{
    GCCConferenceID             conference_id;
    UserID                      requester_node_id;
}
    ConductPleaseIndicationMessage, *PConductPleaseIndicationMessage; 

/*
 *    GCC_CONDUCT_PLEASE_CONFIRM
 *
 *    Union Choice:
 *        ConductPleaseConfirmMessage
 */
typedef SimpleConfirmMsg    ConductPleaseConfirmMessage, *PConductPleaseConfirmMessage;

/*
 *    GCC_CONDUCT_GIVE_CONFIRM
 *
 *    Union Choice:
 *        ConductorGiveConfirmMessage
 */
typedef struct
{
    GCCConferenceID             conference_id;
    GCCResult                   result;
    UserID                      recipient_node_id;
}
    ConductGiveConfirmMessage, *PConductGiveConfirmMessage;

/*
 *    GCC_CONDUCT_ASK_INDICATION
 *
 *    Union Choice:
 *        ConductPermitAskIndicationMessage
 */
typedef struct
{
    GCCConferenceID             conference_id;
    BOOL                        permission_is_granted;
    UserID                      requester_node_id;
}
    ConductPermitAskIndicationMessage, *PConductPermitAskIndicationMessage; 

/*
 *    GCC_CONDUCT_ASK_CONFIRM
 *
 *    Union Choice:
 *        ConductPermitAskConfirmMessage
 */
typedef struct
{
    GCCConferenceID             conference_id;
    GCCResult                   result;
    BOOL                        permission_is_granted;
}
    ConductPermitAskConfirmMessage, *PConductPermitAskConfirmMessage;

/*
 *    GCC_CONDUCT_GRANT_CONFIRM
 *
 *    Union Choice:
 *        ConductPermissionGrantConfirmMessage
 */
typedef SimpleConfirmMsg    ConductPermitGrantConfirmMessage, *PConductPermitGrantConfirmMessage;

/*
 *    GCC_TIME_REMAINING_INDICATION
 *
 *    Union Choice:
 *        TimeRemainingIndicationMessage
 */
typedef struct
{
    GCCConferenceID             conference_id;
    UINT                        time_remaining;
    UserID                      node_id;
    UserID                      source_node_id;
}
    TimeRemainingIndicationMessage, *PTimeRemainingIndicationMessage;

/*
 *    GCC_TIME_REMAINING_CONFIRM
 *
 *    Union Choice:
 *        TimeRemainingConfirmMessage
 */
typedef SimpleConfirmMsg    TimeRemainingConfirmMessage, *PTimeRemainingConfirmMessage;

/*
 *    GCC_TIME_INQUIRE_CONFIRM
 *
 *    Union Choice:
 *        TimeInquireConfirmMessage
 */
typedef SimpleConfirmMsg    TimeInquireConfirmMessage, *PTimeInquireConfirmMessage;

/*
 *    GCC_CONFERENCE_EXTEND_INDICATION
 *
 *    Union Choice:
 *        ConferenceExtendIndicationMessage
 */
typedef struct
{
    GCCConferenceID             conference_id;
    UINT                        extension_time;
    BOOL                        time_is_conference_wide;
    UserID                      requesting_node_id;
}
    ConferenceExtendIndicationMessage, *PConferenceExtendIndicationMessage;

/*
 *    GCC_CONFERENCE_EXTEND_CONFIRM
 *
 *    Union Choice:
 *        ConferenceExtendConfirmMessage
 */
typedef struct
{
    GCCConferenceID             conference_id;
    UINT                        extension_time;
    GCCResult                   result;
}
    ConferenceExtendConfirmMessage, *PConferenceExtendConfirmMessage;

/*
 *    GCC_ASSISTANCE_INDICATION
 *
 *    Union Choice:
 *        ConferenceAssistIndicationMessage
 */
typedef struct
{
    GCCConferenceID             conference_id;
    UINT                        number_of_user_data_members;
    GCCUserData               **user_data_list;
    UserID                      source_node_id;
}
    ConferenceAssistIndicationMessage, *PConferenceAssistIndicationMessage;

/*
 *    GCC_ASSISTANCE_CONFIRM
 *
 *    Union Choice:
 *        ConferenceAssistConfirmMessage
 */
typedef SimpleConfirmMsg    ConferenceAssistConfirmMessage, *PConferenceAssistConfirmMessage;

/*
 *    GCC_TEXT_MESSAGE_INDICATION
 *
 *    Union Choice:
 *        TextMessageIndicationMessage
 */
typedef struct
{
    GCCConferenceID             conference_id;
    LPWSTR                      text_message;
    UserID                      source_node_id;
}
    TextMessageIndicationMessage, *PTextMessageIndicationMessage;

/*
 *    GCC_TEXT_MESSAGE_CONFIRM
 *
 *    Union Choice:
 *        TextMessageConfirmMessage
 */
typedef SimpleConfirmMsg    TextMessageConfirmMessage, *PTextMessageConfirmMessage;
#endif // JASPER // ------------------------------------------------


/*********************************************************************
 *                                                                   *
 *            USER APPLICATION CALLBACK INFO STRUCTURES              *
 *                                                                   *
 *********************************************************************/

/*
 *    GCC_APP_ROSTER_REPORT_INDICATION
 *
 *    Union Choice:
 *        AppRosterReportIndicationMessage
 */
typedef struct
{
    GCCConferenceID             conference_id;
    ULONG                       number_of_rosters;
    GCCApplicationRoster      **application_roster_list;
}
    AppRosterReportIndicationMessage, *PAppRosterReportIndicationMessage;

/*********************************************************************
 *                                                                     *
 *                SHARED CALLBACK INFO STRUCTURES                         *
 *        (Note that this doesn't include all the shared callbacks)    *
 *                                                                     *
 *********************************************************************/

/*
 *    GCC_ROSTER_INQUIRE_CONFIRM
 *
 *    Union Choice:
 *        ConfRosterInquireConfirmMessage
 */
typedef struct
{
    GCCConferenceID             conference_id;
    GCCConferenceName           conference_name;
    GCCNumericString            conference_modifier;
    LPWSTR                      conference_descriptor;
    GCCConferenceRoster        *conference_roster;
    GCCResult                   result;
}
    ConfRosterInquireConfirmMessage, *PConfRosterInquireConfirmMessage;

/*
 *    GCC_APPLICATION_INVOKE_INDICATION
 *
 *    Union Choice:
 *        ApplicationInvokeIndicationMessage
 */
typedef struct
{
    GCCConferenceID             conference_id;
    ULONG                       number_of_app_protocol_entities;
    GCCAppProtocolEntity      **app_protocol_entity_list;
    UserID                      invoking_node_id;
}
    ApplicationInvokeIndicationMessage, *PApplicationInvokeIndicationMessage;

/*
 *    GCC_APPLICATION_INVOKE_CONFIRM
 *
 *    Union Choice:
 *        ApplicationInvokeConfirmMessage
 */
typedef struct
{
    GCCConferenceID             conference_id;
    ULONG                       number_of_app_protocol_entities;
    GCCAppProtocolEntity      **app_protocol_entity_list;
    GCCResult                   result;
}
    ApplicationInvokeConfirmMessage, *PApplicationInvokeConfirmMessage;
 


#ifdef JASPER // ------------------------------------------------
/*
 *    GCC_APP_ROSTER_INQUIRE_CONFIRM
 *
 *    Union Choice:
 *        AppRosterInquireConfirmMessage
 */
typedef struct
{
    GCCConferenceID             conference_id;
    ULONG                       number_of_rosters;
    GCCApplicationRoster      **application_roster_list;
    GCCResult                   result;
}
    AppRosterInquireConfirmMessage, *PAppRosterInquireConfirmMessage;

/*
 *    GCC_CONDUCT_INQUIRE_CONFIRM
 *
 *    Union Choice:
 *        ConductorInquireConfirmMessage
 */
typedef struct
{
    GCCConferenceID             conference_id;
    BOOL                        mode_is_conducted;
    UserID                      conductor_node_id;
    BOOL                        permission_is_granted;
    GCCResult                   result;
}
    ConductInquireConfirmMessage, *PConductInquireConfirmMessage;

/*
 *    GCC_CONDUCT_ASSIGN_INDICATION
 *
 *    Union Choice:
 *        ConductAssignIndicationMessage
 */
typedef struct
{
    GCCConferenceID             conference_id;
    UserID                      node_id;
}
    ConductAssignIndicationMessage, *PConductAssignIndicationMessage; 

/*
 *    GCC_CONDUCT_RELEASE_INDICATION
 *
 *    Union Choice:
 *        ConductReleaseIndicationMessage
 */
typedef struct
{
    GCCConferenceID             conference_id;
}
    ConductReleaseIndicationMessage, *PConductReleaseIndicationMessage;

/*
 *    GCC_CONDUCT_GRANT_INDICATION
 *
 *    Union Choice:
 *        ConductPermitGrantIndicationMessage
 */
typedef struct
{
    GCCConferenceID             conference_id;
    UINT                        number_granted;
    UserID                     *granted_node_list;
    UINT                        number_waiting;
    UserID                     *waiting_node_list;
    BOOL                        permission_is_granted;
}
    ConductPermitGrantIndicationMessage, *PConductPermitGrantIndicationMessage; 
#endif // JASPER  // ------------------------------------------------


/*
 *    GCCMessage
 *        This structure defines the message that is passed from GCC to either
 *        the node controller or a user application when an indication or
 *        confirm occurs.
 */

typedef    struct
{
    GCCMessageType              message_type;
    LPVOID                      user_defined;

    // GCCNC relies on easy access to conference ID.
    GCCConfID                   nConfID;

    union
    {
        CreateIndicationMessage                 create_indication;
        CreateConfirmMessage                    create_confirm;
        QueryIndicationMessage                  query_indication;
        QueryConfirmMessage                     query_confirm;
        JoinIndicationMessage                   join_indication;
        JoinConfirmMessage                      join_confirm;
        InviteIndicationMessage                 invite_indication;
        InviteConfirmMessage                    invite_confirm;
        AddIndicationMessage                    add_indication;
        AddConfirmMessage                       add_confirm;
        LockIndicationMessage                   lock_indication;
        UnlockIndicationMessage                 unlock_indication;
        DisconnectIndicationMessage             disconnect_indication;
        DisconnectConfirmMessage                disconnect_confirm;
        TerminateIndicationMessage              terminate_indication;
        TerminateConfirmMessage                 terminate_confirm;
        ConnectionBrokenIndicationMessage       connection_broken_indication;
        EjectUserIndicationMessage              eject_user_indication;    
        ApplicationInvokeIndicationMessage      application_invoke_indication;
        ApplicationInvokeConfirmMessage         application_invoke_confirm;
        SubInitializedIndicationMessage         conf_sub_initialized_indication;
        PermitToAnnouncePresenceMessage         permit_to_announce_presence;
        AnnouncePresenceConfirmMessage          announce_presence_confirm;
        ConfRosterReportIndicationMessage       conf_roster_report_indication;
        ConductGiveIndicationMessage            conduct_give_indication;
        TimeInquireIndicationMessage            time_inquire_indication;
        GCCStatusIndicationMessage              status_indication;
        AppRosterReportIndicationMessage        app_roster_report_indication;
        ConfRosterInquireConfirmMessage         conf_roster_inquire_confirm;
#ifdef TSTATUS_INDICATION
        TransportStatus                         transport_status;
#endif // TSTATUS_INDICATION

#ifdef JASPER // ------------------------------------------------
        TextMessageIndicationMessage            text_message_indication;
        TimeRemainingIndicationMessage          time_remaining_indication;
        AppRosterInquireConfirmMessage          app_roster_inquire_confirm;
        ConferenceAssistConfirmMessage          conference_assist_confirm;
        ConferenceAssistIndicationMessage       conference_assist_indication;
        ConductPermitAskConfirmMessage          conduct_permit_ask_confirm;
        ConductPermitAskIndicationMessage       conduct_permit_ask_indication; 
        ConductAssignConfirmMessage             conduct_assign_confirm;
        ConductAssignIndicationMessage          conduct_assign_indication; 
        ConductGiveConfirmMessage               conduct_give_confirm;
        ConductPermitGrantConfirmMessage        conduct_permit_grant_confirm;
        ConductPermitGrantIndicationMessage     conduct_permit_grant_indication; 
        ConductInquireConfirmMessage            conduct_inquire_confirm;
        ConductPleaseConfirmMessage             conduct_please_confirm;
        ConductPleaseIndicationMessage          conduct_please_indication;
        ConductReleaseConfirmMessage            conduct_release_confirm; 
        ConductReleaseIndicationMessage         conduct_release_indication; 
        ConferenceExtendConfirmMessage          conference_extend_confirm;
        ConferenceExtendIndicationMessage       conference_extend_indication;
        EjectUserConfirmMessage                 eject_user_confirm;
        LockConfirmMessage                      lock_confirm;
        LockReportIndicationMessage             lock_report_indication;
        TextMessageConfirmMessage               text_message_confirm;
        TimeInquireConfirmMessage               time_inquire_confirm;
        TimeRemainingConfirmMessage             time_remaining_confirm;
        TransferConfirmMessage                  transfer_confirm;
        TransferIndicationMessage               transfer_indication;
        UnlockConfirmMessage                    unlock_confirm;
#endif // JASPER // ------------------------------------------------

        // easy acess to conf id and gcc result
        SimpleConfirmMsg        simple_confirm;
    } u;
}
    GCCMessage, *PGCCMessage, T120Message, *PT120Message;


// node controller callback entry
typedef void (CALLBACK *LPFN_T120_CONTROL_SAP_CB) (T120Message *);


#undef  INTERFACE
#define INTERFACE IT120ControlSAP
DECLARE_INTERFACE(IT120ControlSAP)
{
    STDMETHOD_(void, ReleaseInterface) (THIS) PURE;

    /*
     *  GCCError    ConfCreateRequest()
     *        This routine is a request to create a new conference. Both 
     *        the local node and the node to which the create conference 
     *        request is directed to, join the conference automatically.  
     */
    STDMETHOD_(GCCError, ConfCreateRequest) (THIS_
                    GCCConfCreateRequest *,
                    GCCConfID *) PURE;

    /*    
     *  GCCError    ConfCreateResponse()
     *        This procedure is a remote node controller's response to a con-
     *        ference creation request by the convener. 
     */

    STDMETHOD_(GCCError, ConfCreateResponse) (THIS_
                    GCCNumericString            conference_modifier,
                    GCCConfID,
                    BOOL                        use_password_in_the_clear,
                    DomainParameters           *domain_parameters,
                    UINT                        number_of_network_addresses,
                    GCCNetworkAddress         **local_network_address_list,
                    UINT                        number_of_user_data_members,
                    GCCUserData               **user_data_list,
                    GCCResult) PURE;

    /*
     *  GCCError    ConfQueryRequest()
     *        This routine is a request to query a node for information about the
     *        conferences that exist at that node.
     */
    STDMETHOD_(GCCError, ConfQueryRequest) (THIS_
                    GCCNodeType                 node_type,
                    GCCAsymmetryIndicator      *asymmetry_indicator,
                    TransportAddress            calling_address,
                    TransportAddress            called_address,
                    BOOL                        fSecure,
                    UINT                        number_of_user_data_members,
                    GCCUserData               **user_data_list,
                    ConnectionHandle           *connection_handle) PURE;

    STDMETHOD_(void, CancelConfQueryRequest) (THIS_
                    ConnectionHandle) PURE;

    /*
     *  GCCError    ConfQueryResponse()
     *        This routine is called in response to a conference query request.
     */
    STDMETHOD_(GCCError, ConfQueryResponse) (THIS_
                    GCCResponseTag              query_response_tag,
                    GCCNodeType                 node_type,
                    GCCAsymmetryIndicator      *asymmetry_indicator,
                    UINT                        number_of_user_data_members,
                    GCCUserData               **user_data_list,
                    GCCResult) PURE;

    /*
     *  GCCError    AnnouncePresenceRequest()
     *        This routine is invoked by node controller when a node joins a 
     *        conference, to announce the presence of the new node to all
     *        other nodes of the conference. This should be followed by a
     *        GCCConferenceReport indication by the GCC to all nodes.
     */
    STDMETHOD_(GCCError, AnnouncePresenceRequest) (THIS_
                    GCCConfID,
                    GCCNodeType                 node_type,
                    GCCNodeProperties           node_properties,
                    LPWSTR                      pwszNodeName,
                    UINT                        number_of_participants,
                    LPWSTR                     *ppwszParticipantNameList,
                    LPWSTR                      pwszSiteInfo,
                    UINT                        number_of_network_addresses,
                    GCCNetworkAddress         **network_address_list,
                    LPOSTR                      alternative_node_id,
                    UINT                        number_of_user_data_members,
                    GCCUserData               **user_data_list) PURE;

    /*
     *  GCCError    ConfJoinRequest()
     *        This routine is invoked by node controller to cause the local
     *        node to join an existing conference.    
     */
    STDMETHOD_(GCCError, ConfJoinRequest) (THIS_
                    GCCConferenceName          *conference_name,
                    GCCNumericString            called_node_modifier,
                    GCCNumericString            calling_node_modifier,
                    GCCPassword                *convener_password,
                    GCCChallengeRequestResponse*password_challenge,
                    LPWSTR                      pwszCallerID,
                    TransportAddress            calling_address,
                    TransportAddress            called_address,
                    BOOL                        fSecure,
                    DomainParameters           *domain_parameters,
                    UINT                        number_of_network_addresses,
                    GCCNetworkAddress         **local_network_address_list,
                    UINT                        number_of_user_data_members,
                    GCCUserData               **user_data_list,
                    ConnectionHandle           *connection_handle,
                    GCCConfID                  *pnConfID) PURE;

    /*
     *  GCCError    ConfJoinResponse()
     *        This routine is remote node controller's response to conference join 
     *        request by the local node controller.
     */
    STDMETHOD_(GCCError, ConfJoinResponse) (THIS_
                    GCCResponseTag              join_response_tag,
                    GCCChallengeRequestResponse*password_challenge,
                    UINT                        number_of_user_data_members,
                    GCCUserData               **user_data_list,
                    GCCResult) PURE;

    /*
     *  GCCError    ConfInviteRequest()
     *        This routine is invoked by node controller to invite a node  
     *        to join a conference.
     */
    STDMETHOD_(GCCError, ConfInviteRequest) (THIS_
                    GCCConfID,
                    LPWSTR                      pwszCallerID,
                    TransportAddress            calling_address,
                    TransportAddress            called_address,
                    BOOL                        fSecure,
                    UINT                        number_of_user_data_members,
                    GCCUserData               **user_data_list,
                    ConnectionHandle           *connection_handle) PURE;

    STDMETHOD_(void, CancelInviteRequest) (THIS_
                    GCCConfID,
                    ConnectionHandle) PURE;

    /*
     *  GCCError    ConfInviteResponse()
     *        This routine is invoked by node controller to respond to an
     *        invite indication.
     */
    STDMETHOD_(GCCError, ConfInviteResponse) (THIS_
                    GCCConfID,
                    GCCNumericString            conference_modifier,
                    BOOL                        fSecure,
                    DomainParameters           *domain_parameters,
                    UINT                        number_of_network_addresses,
                    GCCNetworkAddress         **local_network_address_list,
                    UINT                        number_of_user_data_members,
                    GCCUserData               **user_data_list,
                    GCCResult) PURE;

    /*
     *  GCCError    ConfAddResponse()
     */
    STDMETHOD_(GCCError, ConfAddResponse) (THIS_
                    GCCResponseTag              app_response_tag,
                    GCCConfID,
                    UserID                      requesting_node,
                    UINT                        number_of_user_data_members,
                    GCCUserData               **user_data_list,
                    GCCResult) PURE;

    /*
     *  GCCError    ConfLockResponse()
     *        This routine is invoked by node controller to respond to a
     *        lock indication.
     */
    STDMETHOD_(GCCError, ConfLockResponse) (THIS_
                    GCCConfID,
                    UserID                      requesting_node,
                    GCCResult) PURE;

    /*
     *  GCCError    ConfDisconnectRequest()
     *        This routine is used by a node controller to disconnect itself
     *        from a specified conference. GccConferenceDisconnectIndication
     *        sent to all other nodes of the conference. This is for client 
     *        initiated case.
     */
    STDMETHOD_(GCCError, ConfDisconnectRequest) (THIS_
                    GCCConfID) PURE;

    /*
     *  GCCError    ConfEjectUserRequest()
     */
    STDMETHOD_(GCCError, ConfEjectUserRequest) (THIS_
                    GCCConfID,
                    UserID                      ejected_node_id,
                    GCCReason) PURE;

    /*
     *  GCCError    AppletInvokeRequest()
     */
    STDMETHOD_(GCCError, AppletInvokeRequest) (THIS_
                    GCCConfID,
                    UINT                        number_of_app_protcol_entities,
                    GCCAppProtocolEntity      **app_protocol_entity_list,
                    UINT                        number_of_destination_nodes,
                    UserID                     *list_of_destination_nodes) PURE;

    /*
     *  GCCError    ConfRosterInqRequest()
     *        This routine is invoked to request a conference roster.  It can be
     *        called by either the Node Controller or the client application.
     */
    STDMETHOD_(GCCError, ConfRosterInqRequest) (THIS_
                    GCCConfID) PURE;

    /*
     *  GCCError    ConductorGiveResponse()
     */
    STDMETHOD_(GCCError, ConductorGiveResponse) (THIS_
                    GCCConfID,
                    GCCResult) PURE;

    /*
     *  GCCError    ConfTimeRemainingRequest()
     */
    STDMETHOD_(GCCError, ConfTimeRemainingRequest) (THIS_
                    GCCConfID,
                    UINT                        time_remaining,
                    UserID                      node_id) PURE;


    STDMETHOD_(GCCError, GetParentNodeID) (THIS_
                    GCCConfID,
                    GCCNodeID *) PURE;

#ifdef JASPER // ------------------------------------------------
    /*
     *  GCCError    ConfAddRequest()
     */
    STDMETHOD_(GCCError, ConfAddRequest) (THIS_
                    GCCConfID,
                    UINT                        number_of_network_addresses,
                    GCCNetworkAddress         **network_address_list,
                    UserID                      adding_node,
                    UINT                         number_of_user_data_members,
                    GCCUserData               **user_data_list) PURE;

    /*
     *  GCCError    ConfLockRequest()
     *        This routine is invoked by node controller to lock a conference.
     */
    STDMETHOD_(GCCError, ConfLockRequest) (THIS_
                    GCCConfID) PURE;

    /*
     *  GCCError    ConfUnlockRequest()
     *        This routine is invoked by node controller to unlock a conference.
     */
    STDMETHOD_(GCCError, ConfUnlockRequest) (THIS_
                    GCCConfID) PURE;

    /*
     *  GCCError    ConfUnlockResponse()
     *        This routine is invoked by node controller to respond to an
     *        unlock indication.
     */
    STDMETHOD_(GCCError, ConfUnlockResponse) (
                    GCCConfID,
                    UserID                      requesting_node,
                    GCCResult) PURE;

    /*
     *  GCCError    ConfTerminateRequest()
     */
    STDMETHOD_(GCCError, ConfTerminateRequest) (THIS_
                    GCCConfID,
                    GCCReason) PURE;

    /*
     *  GCCError    ConfTransferRequest()
     */
    STDMETHOD_(GCCError, ConfTransferRequest) (THIS_
                    GCCConfID,
                    GCCConferenceName          *destination_conference_name,
                    GCCNumericString            destination_conference_modifier,
                    UINT                        number_of_destination_addresses,
                    GCCNetworkAddress         **destination_address_list,
                    UINT                        number_of_destination_nodes,
                    UserID                     *destination_node_list,
                    GCCPassword                *password) PURE;

    /*
     *  GCCError    ConductorAssignRequest()
     */
    STDMETHOD_(GCCError, ConductorAssignRequest) (THIS_
                    GCCConfID) PURE;

    /*
     *  GCCError    ConductorReleaseRequest()
     */
    STDMETHOD_(GCCError, ConductorReleaseRequest) (THIS_
                    GCCConfID) PURE;

    /*
     *  GCCError    ConductorPleaseRequest()
     */
    STDMETHOD_(GCCError, ConductorPleaseRequest) (THIS_
                    GCCConfID) PURE;

    /*
     *  GCCError    ConductorGiveRequest()
     */
    STDMETHOD_(GCCError, ConductorGiveRequest) (THIS_
                    GCCConfID,
                    UserID                      recipient_user_id) PURE;

    /*
     *  GCCError    ConductorPermitAskRequest()
     */
    STDMETHOD_(GCCError, ConductorPermitAskRequest) (THIS_
                            GCCConfID,
                            BOOL                grant_permission) PURE;

    /*
     *  GCCError    ConductorPermitGrantRequest()
     */
    STDMETHOD_(GCCError, ConductorPermitGrantRequest) (THIS_
                    GCCConfID,
                    UINT                        number_granted,
                    UserID                     *granted_node_list,
                    UINT                        number_waiting,
                    UserID                     *waiting_node_list) PURE;

    /*
     *  GCCError    ConductorInquireRequest()
     */
    STDMETHOD_(GCCError, ConductorInquireRequest) (THIS_
                    GCCConfID) PURE;

    /*
     *  GCCError    ConfTimeInquireRequest()
     */
    STDMETHOD_(GCCError, ConfTimeInquireRequest) (THIS_
                    GCCConfID,
                    BOOL                        time_is_conference_wide) PURE;

    /*
     *  GCCError    ConfExtendRequest()
     */
    STDMETHOD_(GCCError, ConfExtendRequest) (THIS_
                    GCCConfID,
                    UINT                        extension_time,
                    BOOL                        time_is_conference_wide) PURE;

    /*
     *  GCCError    ConfAssistanceRequest()
     */
    STDMETHOD_(GCCError, ConfAssistanceRequest) (THIS_
                    GCCConfID,
                    UINT                        number_of_user_data_members,
                    GCCUserData               **user_data_list) PURE;

    /*
     *  GCCError    TextMessageRequest()
     */
    STDMETHOD_(GCCError, TextMessageRequest) (THIS_
                    GCCConfID,
                    LPWSTR                      pwszTextMsg,
                    UserID                      destination_node) PURE;
#endif // JASPER // ------------------------------------------------

};



//
// GCC Application Service Access Point exports
//

#ifdef __cplusplus
extern "C" {
#endif

GCCError WINAPI T120_CreateControlSAP(
                        OUT     IT120ControlSAP **,
                        IN      LPVOID, // user defined data
                        IN      LPFN_T120_CONTROL_SAP_CB);

#ifdef __cplusplus
}
#endif

#endif // _IGCCControlSAP_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\remdsk\rds\h\lst.h ===
#ifndef __lst_h__
#define __lst_h__

#ifndef ASSERT
    #define ASSERT( x ) 
#endif // #ifndef ASSERT

#include <functional>


// lst bidirectional linked-list template class
// Here are some examples of the usage:
//
//    lst< int > MyList;
//
//    for( int i = 0; i < 10; i++ ) {        
//        MyList . push_front( i );
//    }
//
//   
//    lst< int > TestList;
//    TestList . insert( TestList . begin(), MyList . begin(), MyList . end() ); 
//
//    const lst< int > cList = MyList;
//
//    lst< int >::const_iterator I = cList . begin();
//    while( I != cList . end() ) {
//        int Num = *I;
//        I++;
//    }
//
//
//  the const_iterator is used to iterate through a const List
// 
//  

template< class T, class Operator_Eq = std::equal_to<T> >
class lst {

private: // Data types and typedefs

    typedef T value_type;
    typedef value_type* pointer;
    typedef value_type& reference;
    typedef const value_type& const_reference;
    typedef lst< value_type > self;
	Operator_Eq _FnEq;

    class node {
    public:
      node( node* pP, node* pN, const_reference t ) : pNext( pN ), pPrev( pP ), data( t ) { ; }
      node( void ) : pNext( NULL ), pPrev( NULL ) { ; }
      node* pNext;
      node* pPrev;
      value_type data;
    };            

public:
        // iterator class for iterating through the list
    class iterator {
    friend lst;        
    private:
        typedef iterator self;
        node* pNode;

        iterator( node* pN ) : pNode( pN ) { ; }

    public:
        iterator( void ) : pNode( NULL ) { ; }
        ~iterator( void ) { ; }

        iterator( self& r ) { *this = r; }
        
        iterator& operator=( iterator& r ) { pNode = r . pNode; return *this; }
        bool operator==( const self& r ) const { return pNode == r . pNode; }
        operator!=( const self& r ) const { return pNode != r . pNode; }
        reference operator*() { return pNode -> data; }
        self& operator++() { 
            pNode = pNode -> pNext;
            return *this;
        }
        
        self operator++( int ) { 
            self tmp = *this;
            ++*this;
            return tmp;
        }
        
        self& operator--() { 
            pNode = pNode -> pPrev;
            return *this;
        }
        
        self operator--(int) { 
            self tmp = *this;
            --*this;
            return tmp;
        }

    };

        // const_iterator class for iterating through a const list
    class const_iterator {
    friend lst;        

    private:

        typedef const_iterator self;
        const node* pNode;
        const_iterator( const node* pN ) : pNode( pN ) { ; }

    public:
        const_iterator( void ) : pNode( NULL ) { ; }
        ~const_iterator( void ) { ; }

        const_iterator( const self& r ) { *this = r; }
        
        const_iterator& operator=( const const_iterator& r ) { pNode = r . pNode; return *this;}
        bool operator==( const self& r ) const { return pNode == r . pNode; }
        operator!=( const self& r ) const { return pNode != r . pNode; }
        const_reference operator*() const { return pNode -> data; }

        self& operator++() { 
            pNode = pNode -> pNext;
            return *this;
        }
        
        self operator++( int ) { 
            self tmp = *this;
            ++*this;
            return tmp;
        }
        
        self& operator--() { 
            pNode = pNode -> pPrev;
            return *this;
        }
        
        self operator--(int) { 
            self tmp = *this;
            --*this;
            return tmp;
        }

    };


    // Data
    node*   m_pNode;
    size_t  m_nItems;

public: 
        // construction / destruction
    lst( void ) {
      empty_initialize();
    };

    lst( const self& rList ) { empty_initialize(); *this = rList; }
    ~lst( void ) { clear(); delete m_pNode; m_pNode = NULL; }

    bool operator==( const self& rList ) const {
        if( size() != rList . size() ) { return false; }

        self::const_iterator IThis = begin();
        self::const_iterator IThat = rList . begin();

        while( IThis != end() ) {
            if( !_FnEq( *IThis, *IThat ) ) {
                return false;
            }
            ++IThat;
            ++IThis;
         }

         return true;
    }        
    
        // Member Fns
    self& operator=( const self& rList ) {
        clear();
        insert( begin(), rList . begin(), rList . end() );
        return *this;
    }

    void empty_initialize( void ) {
      m_pNode = new node;
      m_pNode -> pNext = m_pNode;
      m_pNode -> pPrev = m_pNode;
      m_nItems = 0;
    }

    void clear( void ) {
      node* pCur = m_pNode -> pNext;
      while( pCur != m_pNode ) {
        node* pTmp = pCur;
        pCur = pCur -> pNext;
        --m_nItems;
        delete pTmp;
        pTmp = NULL;
      }
      m_pNode -> pNext = m_pNode;
      m_pNode -> pPrev = m_pNode;

    }

        // Return the size of the list
    size_t size( void ) const             { return m_nItems; }
    bool empty( void ) const              { return 0 == size(); }

        // Return an iterator to the position after the last element in the list
        // N.B. ---- Don't dereference end()!!!!!!
        // N.B. ---- end()++ is undefined!!!!!!
    iterator end( void )                  { return iterator( m_pNode ); }
    const_iterator end( void ) const      { return const_iterator( m_pNode ); }

        // Return an iterator to the position of the first element of the list
        // You may dereference begin()
    iterator begin( void )                { return iterator( m_pNode -> pNext ); }
    const_iterator begin( void ) const    { return const_iterator( m_pNode -> pNext ); }

        // Returns a reference to the first element in the list
    reference front( void )               { return *begin(); }
    const_reference front( void ) const   { return *begin(); }

        // Returns a reference to the last element in the list
    reference back( void )                { return *(--end()); }
    const_reference back( void ) const    { return *(--end()); }
    
        // add an object to the front of the list
    void push_front( const_reference x )  { insert(begin(), x); }

        // add an object to the end of the list
    void push_back( const_reference x )   { insert(end(), x); }

        // Insert an item before the item that position points to
    void insert( iterator position, const_reference r ) {
      node* pTmp = new node( position . pNode -> pPrev, position . pNode, r );
      ( position . pNode -> pPrev ) -> pNext = pTmp;
      position . pNode -> pPrev = pTmp;
      ++m_nItems;
    }

        // Insert items first through last to the list at position position
    void insert( iterator position, iterator first, iterator last ) {
        for ( ; first != last; ++first) {
            insert(position, *first);
        }
    }

        // Insert items first through last to the list at position position
    void insert( iterator position, const_iterator first, const_iterator last ) {
        for ( ; first != last; ++first) {
            insert(position, *first);
        }
    }

        // Pop the first element from the list
    void pop_front( void )              { erase(begin()); }
    

        // Pop the last element from the list
    void pop_back( void ) {
        iterator tmp = end();
        erase(--tmp);
    }

    
        // erase the item at position pos in the list
    void erase( iterator pos ) {
        ASSERT( pos != end() );
        ( pos . pNode -> pPrev ) -> pNext = pos . pNode -> pNext;
        ( pos . pNode -> pNext ) -> pPrev = pos . pNode -> pPrev;
        --m_nItems;
        delete pos . pNode;
        pos . pNode = NULL;
        
    }

       // erase the items in the range first through last
    void erase( iterator first, iterator last ) {
        while (first != last) erase(first++);
    }

  
    const_iterator find( const_reference x ) const {
        return find( begin(), end(), x );
    }

    iterator find( const_reference x ) {
        return find( begin(), end(), x );
    }

    iterator find( iterator first, iterator last, const_reference x ) {
        while( first != last ) {
            if( _FnEq(*first, x) ) {
                return first;
            }
            first++;
        }
        return end();
    }

    const_iterator find( const_iterator first, const_iterator last, const_reference x ) const {
        while( first != last ) {
            if( _FnEq(*first, x) ) {
                return first;
            }
            first++;
        }
        return end();
    }

};

template< class T, class F >
lst< T >::iterator find( lst< T >& rLst, F& f ) {
    lst< T >::iterator I = rLst . begin();
    while( rLst . end() != I ) {
        if( f( *I ) ) {
            return I;
        }
        ++I;
    }
    return I;
}

template< class T, class F >
void for_each( lst< T >& rLst, F& f ) {
    lst< T >::iterator I = rLst . begin();
    while( rLst . end() != I ) {
        f( *I );
        ++I;
    }
}

#endif //__lst_h__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\remdsk\rds\h\nmasn1.h ===
/* Copyright (C) Boris Nikolaus, Germany, 1996-1997. All rights reserved. */
/* Copyright (C) Microsoft Corporation 1997-1998, All rights reserved. */

#ifndef __NM_ASN1_H__
#define __NM_ASN1_H__

#include <msper.h>

#endif // __NM_ASN1_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\remdsk\rds\h\nmapptyp.h ===
#if ! defined(_NM_APPLET_TYPE_H_) && ! defined(__iapplet_h__)
#define _NM_APPLET_TYPE_H_

//
// GCC/MCS Base Types
//

typedef USHORT          AppletSessionID;
typedef USHORT          AppletChannelID;
typedef AppletChannelID AppletUserID;
typedef AppletUserID    AppletNodeID;
typedef USHORT          AppletTokenID;
typedef USHORT          AppletEntityID;

typedef ULONG           AppletConfID;

typedef UINT            AppletRequestTag;


//
// GCC Registry
//

typedef enum tagAppletRegistryCommand
{
    APPLET_REGISTER_CHANNEL  = 0,
    APPLET_ASSIGN_TOKEN      = 1,
    APPLET_SET_PARAMETER     = 2,
    APPLET_RETRIEVE_ENTRY    = 3,
    APPLET_DELETE_ENTRY      = 4,
    APPLET_ALLOCATE_HANDLE   = 5,
    APPLET_MONITOR           = 6, // nyi in SDK
}
    AppletRegistryCommand;


typedef enum tagAppletRegistryItemType
{
    APPLET_REGISTRY_CHANNEL_ID  = 1,
    APPLET_REGISTRY_TOKEN_ID    = 2,
    APPLET_REGISTRY_PARAMETER   = 3,
    APPLET_REGISTRY_NONE        = 4,
}
    AppletRegistryItemType;


typedef enum tagAppletModificationRights
{
    APPLET_OWNER_RIGHTS                     = 0,
    APPLET_SESSION_RIGHTS                   = 1,
    APPLET_PUBLIC_RIGHTS                    = 2,
    APPLET_NO_MODIFICATION_RIGHTS_SPECIFIED = 3,
}
    AppletModificationRights;


//
// MCS Channel
//

typedef enum tagAppletChannelCommand
{
    APPLET_JOIN_CHANNEL         = 0,
    APPLET_LEAVE_CHANNEL        = 1,
    APPLET_CONVENE_CHANNEL      = 2,
    APPLET_DISBAND_CHANNEL      = 3,
    APPLET_ADMIT_CHANNEL        = 4,
    APPLET_EXPEL_CHANNEL        = 5,	// indication only
}
    AppletChannelCommand;


typedef enum tagAppletChannelType
{
    APPLET_STATIC_CHANNEL               = 0,
    APPLET_DYNAMIC_MULTICAST_CHANNEL    = 1,
    APPLET_DYNAMIC_PRIVATE_CHANNEL      = 2,
    APPLET_DYNAMIC_USER_ID_CHANNEL      = 3,
    APPLET_NO_CHANNEL_TYPE_SPECIFIED    = 4
}
    AppletChannelType;


//
// MCS Token
//

typedef enum tagAppletTokenCommand
{
    APPLET_GRAB_TOKEN          = 0,
    APPLET_INHIBIT_TOKEN       = 1,
    APPLET_GIVE_TOKEN          = 2,
    APPLET_PLEASE_TOKEN        = 3,
    APPLET_RELEASE_TOKEN       = 4,
    APPLET_TEST_TOKEN          = 5,
    APPLET_GIVE_TOKEN_RESPONSE = 6,
}
    AppletTokenCommand;


typedef enum tagAppletTokenStatus
{
    APPLET_TOKEN_NOT_IN_USE         = 0,
    APPLET_TOKEN_SELF_GRABBED       = 1,
    APPLET_TOKEN_OTHER_GRABBED      = 2,
    APPLET_TOKEN_SELF_INHIBITED     = 3,
    APPLET_TOKEN_OTHER_INHIBITED    = 4,
    APPLET_TOKEN_SELF_RECIPIENT     = 5,
    APPLET_TOKEN_SELF_GIVING        = 6,
    APPLET_TOKEN_OTHER_GIVING       = 7,
}
    AppletTokenStatus;


//
// GCC Capability
//

typedef enum tagAppletCapabilityType
{
    APPLET_UNKNOWN_CAP_TYPE             = 0, // for non-collapsing caps
    APPLET_LOGICAL_CAPABILITY           = 1,
    APPLET_UNSIGNED_MINIMUM_CAPABILITY  = 2,
    APPLET_UNSIGNED_MAXIMUM_CAPABILITY  = 3,
}
    AppletCapabilityType;


typedef struct tagAppletCapabilityClass
{
    AppletCapabilityType    eType;
    ULONG                   nMinOrMax;
}
    AppletCapabilityClass;


typedef enum tagAppletCapIDType
{
	APPLET_STANDARD_CAPABILITY  = 0,
	APPLET_NONSTD_CAPABILITY	= 1,
}
    AppletCapIDType;


//
// GCC/MCS Resource Allocation Command
//

typedef enum tagAppletResourceAllocCommand
{
    APPLET_JOIN_DYNAMIC_CHANNEL     = 0, // compete among all members
    APPLET_GRAB_TOKEN_REQUEST		= 1, // nyi in SDK
}
    AppletResourceAllocCommand;

//
// Send Data
//

typedef enum tagAppletPriority
{
    APPLET_TOP_PRIORITY     = 0,
    APPLET_HIGH_PRIORITY    = 1,
    APPLET_MEDIUM_PRIORITY  = 2,
    APPLET_LOW_PRIORITY     = 3,
}
    AppletPriority;


//
// Key Type
//

typedef enum tagAppletKeyType
{
	APPLET_OBJECT_KEY		= 1,
	APPLET_H221_NONSTD_KEY	= 2,
}
	AppletKeyType;


//
// Error Code
//

enum tagAppletErrorCode
{
    APPLET_E_NO_SERVICE       		= 0x82000001,
    APPLET_E_SERVICE_FAIL      		= 0x82000002,
    APPLET_E_ALREADY_REGISTERED  	= 0x82000003,
    APPLET_E_NOT_REGISTERED      	= 0x82000004,
    APPLET_E_INVALID_CONFERENCE  	= 0x82000005,
    APPLET_E_INVALID_COOKIE      	= 0x82000006,
    APPLET_E_ALREADY_JOIN        	= 0x82000007,
    APPLET_E_NOT_JOINED          	= 0x82000008,
    APPLET_E_INVALID_JOIN_REQUEST	= 0x82000009,
    APPLET_E_ENTRY_ALREADY_EXISTS   = 0x8200000a,
    APPLET_E_ENTRY_DOES_NOT_EXIST   = 0x8200000b,
    APPLET_E_NOT_OWNER              = 0x8200000c,
    APPLET_E_NOT_ADVISED            = 0x8200000d,
    APPLET_E_ALREADY_ADVISED        = 0x8200000e,
};


//
// Reason Code
//

typedef enum tagAppletReason
{
    APPLET_R_UNSPECIFIED            = 0,
    APPLET_R_CONFERENCE_GONE        = 1,
    APPLET_R_USER_REJECTED          = 2,
    APPLET_R_RESOURCE_PURGED        = 3,
}
    AppletReason;


#endif // _NM_APPLET_BASE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\remdsk\rds\h\nmmkcert.h ===
#ifndef _NMMKCERT_
#define _NMMKCERT_

// Flags
#define NMMKCERT_F_DELETEOLDCERT        0x00000001
#define NMMKCERT_F_LOCAL_MACHINE        0x00000002
#define NMMKCERT_F_CLEANUP_ONLY         0x00000004

// NetMeeting certificate store
#define SZNMSTORE       "_RDSTR"
#define WSZNMSTORE      L"_RDSTR"

// Magic constant in user properties
#define NMMKCERT_MAGIC    0x2389ABD0

// RDN name of issuing root cert...
#define SZ_NMROOTNAME TEXT("Remote Desktop Root")

// When issuer obtained using these flags
#ifndef CERT_NAME_STR_REVERSE_FLAG
#define CERT_NAME_STR_REVERSE_FLAG      0x02000000
#endif // CERT_NAME_STR_REVERSE_FLAG

#define CERT_FORMAT_FLAGS (CERT_SIMPLE_NAME_STR|CERT_NAME_STR_NO_PLUS_FLAG|\
    CERT_NAME_STR_REVERSE_FLAG)

// Library Name
#define SZ_NMMKCERTLIB TEXT("RDMKCERT.DLL")

// Prototype typedef
typedef DWORD (WINAPI *PFN_NMMAKECERT)(LPCSTR, LPCSTR, LPCSTR, LPCSTR, LPCSTR, DWORD);

// Loadlibrary constant
#define SZ_NMMAKECERTFUNC "RDMakeCert"

// Static prototype
extern
DWORD
WINAPI
NmMakeCert (
    LPCSTR szFirstName,
    LPCSTR szLastName,
    LPCSTR szEmailName,
    LPCSTR szCity,
    LPCSTR szCountry,
    DWORD dwFlags );

extern
void
CALLBACK
NmMakeCertCleanup (
    HWND hwnd,
    HINSTANCE hinst,
    LPSTR lpszCmdLine,
    int nCmdShow );

#endif // _NMMKCERT_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\remdsk\rds\h\memtrack.h ===
//
// MEMTRACK.H
// Standard NetMeeting memory leak tracking.
//
// In retail:
//      new/MemAlloc    become      LocalAlloc()
//      MemReAlloc      becomes     LocalReAlloc()
//      delete/MemFree  become      LocalFree()
//
// In debug:
//      allocations are tracked, with module/file/line number
//      leaked blocks are spewed when the module unloads
//
// 
// USAGE:
// (1) Include this header and link to NMUTIL
// (2) If your component requires zero-initialized memory, define 
//      _MEM_ZEROINIT (for both debug and retail) in your SOURCES file
// (3) In your DllMain, on DLL_PROCESS_ATTACH call DBG_INIT_MEMORY_TRACKING,
//     and on DLL_PROCESS_DETACH call DBG_CHECK_MEMORY_TRACKING
// (4) In DEBUG, you can make a call to DbgMemTrackDumpCurrent() to dump
//      the currently allocated memory list from code.
//


#ifndef _MEMTRACK_H
#define _MEMTRACK_H

#ifdef __cplusplus
extern "C" {
#endif

//
// MEMORY ALLOCATIONS/TRACKING
//
//
// GUI message boxes kill us when we hit an assert or error, because they
// have a message pump that causes messages to get dispatched, making it
// very difficult for us to debug problems when they occur.  Therefore
// we redefine ERROR_OUT and ASSERT
//
#ifdef DEBUG


#undef assert
#define assert(x)           ASSERT(x)


void    WINAPI DbgMemTrackDumpCurrent(void);
void    WINAPI DbgMemTrackFinalCheck(void);

LPVOID  WINAPI DbgMemAlloc(UINT cbSize, LPVOID caller, LPSTR pszFileName, UINT nLineNumber);
void    WINAPI DbgMemFree(LPVOID ptr);
LPVOID  WINAPI DbgMemReAlloc(LPVOID ptr, UINT cbSize, UINT uFlags, LPSTR pszFileName, UINT nLineNumber);


#define DBG_CHECK_MEMORY_TRACKING(hInst)     DbgMemTrackFinalCheck()  
 
#define MemAlloc(cbSize)            DbgMemAlloc(cbSize, NULL, __FILE__, __LINE__)

#ifdef _MEM_ZEROINIT
#define MemReAlloc(pObj, cbSize)    DbgMemReAlloc((pObj), (cbSize), LMEM_MOVEABLE | LMEM_ZEROINIT, __FILE__, __LINE__)
#else
#define MemReAlloc(pObj, cbSize)    DbgMemReAlloc((pObj), (cbSize), LMEM_MOVEABLE, __FILE__, __LINE__)
#endif //_MEM_ZEROINIT

#define MemFree(pObj)               DbgMemFree(pObj)

void    WINAPI DbgSaveFileLine(LPSTR pszFileName, UINT nLineNumber);
#define DBG_SAVE_FILE_LINE          DbgSaveFileLine(__FILE__, __LINE__);


// RETAIL
#else

#define DBG_CHECK_MEMORY_TRACKING(hInst)   

#ifdef _MEM_ZEROINIT
#define MemAlloc(cbSize)            LocalAlloc(LPTR, (cbSize))
#define MemReAlloc(pObj, cbSize)    LocalReAlloc((pObj), (cbSize), LMEM_MOVEABLE | LMEM_ZEROINIT)
#else
#define MemAlloc(cbSize)            LocalAlloc(LMEM_FIXED, (cbSize))
#define MemReAlloc(pObj, cbSize)    LocalReAlloc((pObj), (cbSize), LMEM_MOVEABLE)
#endif // _MEM_ZEROINIT

#define MemFree(pObj)               LocalFree(pObj)

#define DBG_SAVE_FILE_LINE

#endif // DEBUG


void WINAPI DbgInitMemTrack(HINSTANCE hDllInst, BOOL fZeroOut);
#ifdef _MEM_ZEROINIT
#define DBG_INIT_MEMORY_TRACKING(hInst)     DbgInitMemTrack(hInst, TRUE)
#else
#define DBG_INIT_MEMORY_TRACKING(hInst)     DbgInitMemTrack(hInst, FALSE)
#endif //_MEM_ZEROINIT



#define MEMALLOC(cb)                MemAlloc(cb)
#define MEMREALLOC(p, cb)           MemReAlloc(p, cb)
#define MEMFREE(p)                  MemFree(p)


#ifdef __cplusplus
}
#endif




#endif // #ifndef _MEMTRACK_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\remdsk\rds\h\mcatmcs.h ===
/*
 *	mcatmcs.h
 *
 *	Copyright (c) 1993 - 1995 by DataBeam Corporation, Lexington, KY
 *
 *	Abstract:
 *		This is the interface file for the MCS DLL.  This file defines all
 *		macros, types, and functions needed to use the MCS DLL, allowing MCS
 *		services to be accessed from user applications.
 *
 *		Basically, an application requests services from MCS by making direct
 *		calls into the DLL (this includes T.122 requests and responses).  MCS
 *		sends information back to the application through a callback (this
 *		includes T.122 indications and confirms).  The callback 
 *		for a particular user attachment is specified in the call
 *		MCS_AttachRequest.
 *
 *		Note that this is a "C" language interface in order to prevent any "C++"
 *		naming conflicts between different compiler manufacturers.  Therefore,
 *		if this file is included in a module that is being compiled with a "C++"
 *		compiler, it is necessary to use the following syntax:
 *
 *		extern "C"
 *		{
 *		#include "mcatmcs.h"
 *		}
 *
 *		This disables C++ name mangling on the API entry points defined within
 *		this file.
 *
 *	Author:
 *		James P. Galvin, Jr.
 */
#ifndef	__MCATMCS_H__
#define	__MCATMCS_H__

#include "databeam.h"
#include "mcspdu.h"
#include <t120type.h>

/*
 *	The following definitions are used to identify various parameters within
 *	MCS, and are part of the MCS protocol definition.
 *
 *	Priority
 *		MCS specifies the use of up to four levels of priority.  An application
 *		should NOT use TOP_PRIORITY (this level is reserved for MCS traffic).
 *	Segmentation
 *		This type is used when specifying whether a given data indication is the
 *		first or last one in a user data block (or both or neither).
 *	TokenStatus
 *		This type is returned when testing the current state of a token.
 *	Reason
 *		When MCS issues an indication to a user application, it often includes a
 *		reason parameter informing the user of why the activity is occurring.
 *	Result
 *		When a user makes a request of MCS, MCS often responds with a result,
 *		letting the user know whether or not the request succeeded.
 */

typedef PDUPriority				Priority;
typedef	PDUSegmentation			Segmentation;

typedef	Priority  *				PPriority;
typedef	Segmentation  *			PSegmentation;

#define	SEGMENTATION_BEGIN			0x80
#define	SEGMENTATION_END			0x40


/*
 *	The following type is used to indicate what merge state the local provider
 *	is in.  Note that this is a local implementation feature that is not part
 *	of the standard MCS definition.
 *
 *	Whenever the former Top Provider of a domain enters the domain merge state,
 *	it indicates this to all applications locally attached to that domain by
 *	sending an MCS_MERGE_DOMAIN_INDICATION.  This type (MergeStatus) is the
 *	parameter to that call.  It will be called twice, the first time indicating
 *	that the domain is entering the merge state.  The second time indicates that
 *	the domain merger is complete.
 *
 *	All T.122 primitives (requests and responses) will be rejected during the
 *	time that the domain merger is in progress.  It is the repsonsibility of
 *	the user application to re-try the primitive once the merge is complete.
 */
typedef	unsigned short			MergeStatus;
typedef	MergeStatus  *			PMergeStatus;

#define	MERGE_DOMAIN_IN_PROGRESS	0
#define	MERGE_DOMAIN_COMPLETE		1

/*
 *	This type is the signature of an MCS call back function.  MCS uses this
 *	function to let the application know when an event occurs.
 *
 *	Note that an MCS callback routine needs to return a value to MCS.  This
 *	value should either be MCS_NO_ERROR if the callback was successfully
 *	processed, or MCS_CALLBACK_NOT_PROCESSED if the callback was not processed.
 *	In the latter case, MCS will hold on to the information contained in the
 *	callback message, so that it can try issuing the same callback during the
 *	next time slice.  It will keep retrying until the user application accepts
 *	the callback message (by returning MCS_NO_ERROR).  This is how flow control
 *	works for information flowing upward from MCS to the application.
 */
typedef	void (CALLBACK *MCSCallBack) (UINT, LPARAM, LPVOID);

/*
typedef	struct
{
	ChannelID			channel_id;
	Priority			priority;
	UserID				sender_id;
	Segmentation		segmentation;
	unsigned char  *	user_data;
	unsigned long		user_data_length;
} SendData;
*/
typedef SendDataRequestPDU				SendData;
typedef	SendData  *						PSendData;

// This constant defines the maximum MCS PDU size for applications
#define MAX_MCS_DATA_SIZE	4096

/*
 *	This section defines the messages that can be sent to the application
 *	through the callback facility.  These messages correspond to the indications
 *	and confirms that are defined within T.122.
 */
typedef T120MessageType  MCSMessageType;


/*
 *	The following declaration defines the flags that can be set when 
 *	calling MCSSendDataRequest.
 */
typedef enum {
	APP_ALLOCATION,
	MCS_ALLOCATION
} SendDataFlags, *PSendDataFlags;


/*
 *	The following type defines whether the SendDataRequest
 *	is a normal send or a uniform send.
 */
typedef enum {
	NORMAL_SEND_DATA,
	UNIFORM_SEND_DATA
} DataRequestType, *PDataRequestType;

typedef enum
{
	TOP_PRIORITY_MASK		=0x0001,
	HIGH_PRIORITY_MASK		=0x0002,
	LOW_MEDIUM_MASK			=0x0004,
	LOW_PRIORITY_MASK		=0x0008,
	UNIFORM_SEND_DATA_MASK	=0x0010,
	NORMAL_SEND_DATA_MASK	=0x0020,
	MCS_ALLOCATION_MASK		=0x0040,
	APP_ALLOCATION_MASK		=0x0080
} MCSSenDataMasks;



#endif // __MCATMCS_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\remdsk\rds\h\mcspdu.h ===
#ifndef _MCSPDU_Module_H_
#define _MCSPDU_Module_H_

#include "msper.h"

#ifdef __cplusplus
extern "C" {
#endif

typedef struct SetOfUserIDs * PSetOfUserIDs;

typedef struct SetOfPDUChannelAttributes * PSetOfPDUChannelAttributes;

typedef struct SetOfChannelIDs * PSetOfChannelIDs;

typedef struct SetOfPDUTokenAttributes * PSetOfPDUTokenAttributes;

typedef struct SetOfTokenIDs * PSetOfTokenIDs;

typedef ASN1uint16_t ChannelID;

typedef ChannelID StaticChannelID;

typedef ChannelID DynamicChannelID;

typedef DynamicChannelID UserID;

typedef DynamicChannelID PrivateChannelID;

typedef DynamicChannelID AssignedChannelID;

typedef ASN1uint16_t TokenID;

typedef enum PDUTokenStatus {
    not_in_use = 0,
    self_grabbed = 1,
    other_grabbed = 2,
    self_inhibited = 3,
    other_inhibited = 4,
    self_recipient = 5,
    self_giving = 6,
    other_giving = 7,
} PDUTokenStatus;

typedef enum PDUPriority {
    TOP_PRIORITY = 0,
    HIGH_PRIORITY = 1,
    MEDIUM_PRIORITY = 2,
    LOW_PRIORITY = 3,
} PDUPriority;

typedef ASN1uint8_t PDUSegmentation;
// #define begin 0x80
// #define end 0x40

typedef enum PDUReason {
    rn_domain_disconnected = 0,
    rn_provider_initiated = 1,
    rn_token_purged = 2,
    rn_user_requested = 3,
    rn_channel_purged = 4,
} PDUReason;

typedef enum PDUResult {
    rt_successful = 0,
    rt_domain_merging = 1,
    rt_domain_not_hierarchical = 2,
    rt_no_such_channel = 3,
    rt_no_such_domain = 4,
    rt_no_such_user = 5,
    rt_not_admitted = 6,
    rt_other_user_id = 7,
    rt_parameters_unacceptable = 8,
    rt_token_not_available = 9,
    rt_token_not_possessed = 10,
    rt_too_many_channels = 11,
    rt_too_many_tokens = 12,
    rt_too_many_users = 13,
    rt_unspecified_failure = 14,
    rt_user_rejected = 15,
} PDUResult;

typedef enum Diagnostic {
    dc_inconsistent_merge = 0,
    dc_forbidden_pdu_downward = 1,
    dc_forbidden_pdu_upward = 2,
    dc_invalid_ber_encoding = 3,
    dc_invalid_per_encoding = 4,
    dc_misrouted_user = 5,
    dc_unrequested_confirm = 6,
    dc_wrong_transport_priority = 7,
    dc_channel_id_conflict = 8,
    dc_token_id_conflict = 9,
    dc_not_user_id_channel = 10,
    dc_too_many_channels = 11,
    dc_too_many_tokens = 12,
    dc_too_many_users = 13,
} Diagnostic;

typedef struct Given {
    TokenID token_id;
    UserID recipient;
} Given;

typedef struct Ungivable {
    TokenID token_id;
    UserID grabber;
} Ungivable;

typedef struct Giving {
    TokenID token_id;
    UserID grabber;
    UserID recipient;
} Giving;

typedef struct Inhibited {
    TokenID token_id;
    PSetOfUserIDs inhibitors;
} Inhibited;

typedef struct Grabbed {
    TokenID token_id;
    UserID grabber;
} Grabbed;

typedef struct ChannelAttributesAssigned {
    AssignedChannelID channel_id;
} ChannelAttributesAssigned;

typedef struct ChannelAttributesPrivate {
    ASN1bool_t joined;
    PrivateChannelID channel_id;
    UserID manager;
    PSetOfUserIDs admitted;
} ChannelAttributesPrivate;

typedef struct ChannelAttributesUserID {
    ASN1bool_t joined;
    UserID user_id;
} ChannelAttributesUserID;

typedef struct ChannelAttributesStatic {
    StaticChannelID channel_id;
} ChannelAttributesStatic;

typedef struct PDUDomainParameters {
    ASN1uint32_t max_channel_ids;
    ASN1uint32_t max_user_ids;
    ASN1uint32_t max_token_ids;
    ASN1uint32_t number_priorities;
    ASN1uint32_t min_throughput;
    ASN1uint32_t max_height;
    ASN1uint32_t max_mcspdu_size;
    ASN1uint32_t protocol_version;
} PDUDomainParameters;

typedef struct ConnectInitialPDU {
    ASN1octetstring_t calling_domain_selector;
    ASN1octetstring_t called_domain_selector;
    ASN1bool_t upward_flag;
    PDUDomainParameters target_parameters;
    PDUDomainParameters minimum_parameters;
    PDUDomainParameters maximum_parameters;
    ASN1octetstring_t user_data;
} ConnectInitialPDU;

typedef struct ConnectResponsePDU {
    PDUResult result;
    ASN1uint32_t called_connect_id;
    PDUDomainParameters domain_parameters;
    ASN1octetstring_t user_data;
} ConnectResponsePDU;

typedef struct ConnectAdditionalPDU {
    ASN1uint32_t called_connect_id;
    PDUPriority data_priority;
} ConnectAdditionalPDU;

typedef struct ConnectResultPDU {
    PDUResult result;
} ConnectResultPDU;

typedef struct PlumbDomainIndicationPDU {
    ASN1uint32_t height_limit;
} PlumbDomainIndicationPDU;

typedef struct ErectDomainRequestPDU {
    ASN1uint32_t sub_height;
    ASN1uint32_t sub_interval;
} ErectDomainRequestPDU;

typedef struct PDUChannelAttributes {
    ASN1choice_t choice;
    union {
#	define channel_attributes_static_chosen 1
	ChannelAttributesStatic channel_attributes_static;
#	define channel_attributes_user_id_chosen 2
	ChannelAttributesUserID channel_attributes_user_id;
#	define channel_attributes_private_chosen 3
	ChannelAttributesPrivate channel_attributes_private;
#	define channel_attributes_assigned_chosen 4
	ChannelAttributesAssigned channel_attributes_assigned;
    } u;
} PDUChannelAttributes;

typedef struct MergeChannelsPDU {
    PSetOfPDUChannelAttributes merge_channels;
    PSetOfChannelIDs purge_channel_ids;
} MergeChannelsPDU;

typedef	MergeChannelsPDU			MergeChannelsRequestPDU;
typedef	MergeChannelsPDU			MergeChannelsConfirmPDU;

typedef struct PurgeChannelIndicationPDU {
    PSetOfUserIDs detach_user_ids;
    PSetOfChannelIDs purge_channel_ids;
} PurgeChannelIndicationPDU;

typedef struct PDUTokenAttributes {
    ASN1choice_t choice;
    union {
#	define grabbed_chosen 1
	Grabbed grabbed;
#	define inhibited_chosen 2
	Inhibited inhibited;
#	define giving_chosen 3
	Giving giving;
#	define ungivable_chosen 4
	Ungivable ungivable;
#	define given_chosen 5
	Given given;
    } u;
} PDUTokenAttributes;

typedef struct SetOfUserIDs {
    PSetOfUserIDs next;
    UserID value;
} SetOfUserIDs_Element;

typedef struct SetOfPDUChannelAttributes {
    PSetOfPDUChannelAttributes next;
    PDUChannelAttributes value;
} SetOfPDUChannelAttributes_Element;

typedef struct SetOfChannelIDs {
    PSetOfChannelIDs next;
    ChannelID value;
} SetOfChannelIDs_Element;

typedef struct SetOfPDUTokenAttributes {
    PSetOfPDUTokenAttributes next;
    PDUTokenAttributes value;
} SetOfPDUTokenAttributes_Element;

typedef struct SetOfTokenIDs {
    PSetOfTokenIDs next;
    TokenID value;
} SetOfTokenIDs_Element;

typedef struct MergeTokensPDU {
    PSetOfPDUTokenAttributes merge_tokens;
    PSetOfTokenIDs purge_token_ids;
} MergeTokensPDU;

typedef MergeTokensPDU			MergeTokensRequestPDU;
typedef MergeTokensPDU			MergeTokensConfirmPDU;

typedef struct PurgeTokenIndicationPDU {
    PSetOfTokenIDs purge_token_ids;
} PurgeTokenIndicationPDU;

typedef struct DisconnectProviderUltimatumPDU {
    PDUReason reason;
} DisconnectProviderUltimatumPDU;

typedef struct RejectUltimatumPDU {
    Diagnostic diagnostic;
    ASN1octetstring_t initial_octets;
} RejectUltimatumPDU;

typedef struct AttachUserRequestPDU {
    char placeholder;
} AttachUserRequestPDU;

typedef struct AttachUserConfirmPDU {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    PDUResult result;
#   define initiator_present 0x80
    UserID initiator;
} AttachUserConfirmPDU;

typedef struct DetachUserRequestPDU {
    PDUReason reason;
    PSetOfUserIDs user_ids;
} DetachUserPDU;

typedef DetachUserPDU		DetachUserRequestPDU;
typedef DetachUserPDU		DetachUserIndicationPDU;

typedef struct ChannelJoinRequestPDU {
    UserID initiator;
    ChannelID channel_id;
} ChannelJoinRequestPDU;

typedef struct ChannelJoinConfirmPDU {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    PDUResult result;
    UserID initiator;
    ChannelID requested;
#   define join_channel_id_present 0x80
    ChannelID join_channel_id;
} ChannelJoinConfirmPDU;

typedef struct ChannelLeaveRequestPDU {
    PSetOfChannelIDs channel_ids;
} ChannelLeaveRequestPDU;

typedef struct ChannelConveneRequestPDU {
    UserID initiator;
} ChannelConveneRequestPDU;

typedef struct ChannelConveneConfirmPDU {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    PDUResult result;
    UserID initiator;
#   define convene_channel_id_present 0x80
    PrivateChannelID convene_channel_id;
} ChannelConveneConfirmPDU;

typedef struct ChannelDisbandRequestPDU {
    UserID initiator;
    PrivateChannelID channel_id;
} ChannelDisbandRequestPDU;

typedef struct ChannelDisbandIndicationPDU {
    PrivateChannelID channel_id;
} ChannelDisbandIndicationPDU;

typedef struct ChannelAdmitRequestPDU {
    UserID initiator;
    PrivateChannelID channel_id;
    PSetOfUserIDs user_ids;
} ChannelAdmitExpelPDU;

typedef ChannelAdmitExpelPDU		ChannelAdmitRequestPDU;
typedef ChannelAdmitExpelPDU		ChannelAdmitIndicationPDU;
typedef ChannelAdmitExpelPDU		ChannelExpelRequestPDU;

typedef struct ChannelExpelIndicationPDU {
    PrivateChannelID channel_id;
    PSetOfUserIDs user_ids;
} ChannelExpelIndicationPDU;

typedef struct SendDataRequestPDU {
    UserID initiator;
    ChannelID channel_id;
    PDUPriority data_priority;
    PDUSegmentation segmentation;
    ASN1octetstring_t user_data;
} SendDataRequestPDU;

typedef struct SendDataIndicationPDU {
    UserID initiator;
    ChannelID channel_id;
    PDUPriority data_priority;
    PDUSegmentation segmentation;
    ASN1octetstring_t user_data;
} SendDataIndicationPDU;

typedef struct UniformSendDataRequestPDU {
    UserID initiator;
    ChannelID channel_id;
    PDUPriority data_priority;
    PDUSegmentation segmentation;
    ASN1octetstring_t user_data;
} UniformSendDataRequestPDU;

typedef struct UniformSendDataIndicationPDU {
    UserID initiator;
    ChannelID channel_id;
    PDUPriority data_priority;
    PDUSegmentation segmentation;
    ASN1octetstring_t user_data;
} UniformSendDataIndicationPDU;

typedef struct TokenGrabRequestPDU {
    UserID initiator;
    TokenID token_id;
} TokenGrabRequestPDU;

typedef struct TokenGrabConfirmPDU {
    PDUResult result;
    UserID initiator;
    TokenID token_id;
    PDUTokenStatus token_status;
} TokenGrabConfirmPDU;

typedef struct TokenInhibitRequestPDU {
    UserID initiator;
    TokenID token_id;
} TokenInhibitRequestPDU;

typedef struct TokenInhibitConfirmPDU {
    PDUResult result;
    UserID initiator;
    TokenID token_id;
    PDUTokenStatus token_status;
} TokenInhibitConfirmPDU;

typedef struct TokenGiveRequestPDU {
    UserID initiator;
    TokenID token_id;
    UserID recipient;
} TokenGiveRequestPDU;

typedef struct TokenGiveIndicationPDU {
    UserID initiator;
    TokenID token_id;
    UserID recipient;
} TokenGiveIndicationPDU;

typedef struct TokenGiveResponsePDU {
    PDUResult result;
    UserID recipient;
    TokenID token_id;
} TokenGiveResponsePDU;

typedef struct TokenGiveConfirmPDU {
    PDUResult result;
    UserID initiator;
    TokenID token_id;
    PDUTokenStatus token_status;
} TokenGiveConfirmPDU;

typedef struct TokenPleaseRequestPDU {
    UserID initiator;
    TokenID token_id;
} TokenPleaseRequestPDU;

typedef struct TokenPleaseIndicationPDU {
    UserID initiator;
    TokenID token_id;
} TokenPleaseIndicationPDU;

typedef struct TokenReleaseRequestPDU {
    UserID initiator;
    TokenID token_id;
} TokenReleaseRequestPDU;

typedef struct TokenReleaseConfirmPDU {
    PDUResult result;
    UserID initiator;
    TokenID token_id;
    PDUTokenStatus token_status;
} TokenReleaseConfirmPDU;

typedef struct TokenTestRequestPDU {
    UserID initiator;
    TokenID token_id;
} TokenTestRequestPDU;

typedef struct TokenTestConfirmPDU {
    UserID initiator;
    TokenID token_id;
    PDUTokenStatus token_status;
} TokenTestConfirmPDU;

typedef struct ConnectMCSPDU {
    ASN1choice_t choice;
    union {
#	define connect_initial_chosen 1
	ConnectInitialPDU connect_initial;
#	define connect_response_chosen 2
	ConnectResponsePDU connect_response;
#	define connect_additional_chosen 3
	ConnectAdditionalPDU connect_additional;
#	define connect_result_chosen 4
	ConnectResultPDU connect_result;
    } u;
} ConnectMCSPDU;
#define ConnectMCSPDU_PDU 0
#define SIZE_MCSPDU_Module_PDU_0 sizeof(ConnectMCSPDU)

typedef struct DomainMCSPDU {
    ASN1choice_t choice;
    union {
#	define plumb_domain_indication_chosen 1
	PlumbDomainIndicationPDU plumb_domain_indication;
#	define erect_domain_request_chosen 2
	ErectDomainRequestPDU erect_domain_request;
#	define merge_channels_request_chosen 3
	MergeChannelsRequestPDU merge_channels_request;
#	define merge_channels_confirm_chosen 4
	MergeChannelsConfirmPDU merge_channels_confirm;
#	define purge_channel_indication_chosen 5
	PurgeChannelIndicationPDU purge_channel_indication;
#	define merge_tokens_request_chosen 6
	MergeTokensRequestPDU merge_tokens_request;
#	define merge_tokens_confirm_chosen 7
	MergeTokensConfirmPDU merge_tokens_confirm;
#	define purge_token_indication_chosen 8
	PurgeTokenIndicationPDU purge_token_indication;
#	define disconnect_provider_ultimatum_chosen 9
	DisconnectProviderUltimatumPDU disconnect_provider_ultimatum;
#	define reject_user_ultimatum_chosen 10
	RejectUltimatumPDU reject_user_ultimatum;
#	define attach_user_request_chosen 11
	AttachUserRequestPDU attach_user_request;
#	define attach_user_confirm_chosen 12
	AttachUserConfirmPDU attach_user_confirm;
#	define detach_user_request_chosen 13
	DetachUserRequestPDU detach_user_request;
#	define detach_user_indication_chosen 14
	DetachUserIndicationPDU detach_user_indication;
#	define channel_join_request_chosen 15
	ChannelJoinRequestPDU channel_join_request;
#	define channel_join_confirm_chosen 16
	ChannelJoinConfirmPDU channel_join_confirm;
#	define channel_leave_request_chosen 17
	ChannelLeaveRequestPDU channel_leave_request;
#	define channel_convene_request_chosen 18
	ChannelConveneRequestPDU channel_convene_request;
#	define channel_convene_confirm_chosen 19
	ChannelConveneConfirmPDU channel_convene_confirm;
#	define channel_disband_request_chosen 20
	ChannelDisbandRequestPDU channel_disband_request;
#	define channel_disband_indication_chosen 21
	ChannelDisbandIndicationPDU channel_disband_indication;
#	define channel_admit_request_chosen 22
	ChannelAdmitRequestPDU channel_admit_request;
#	define channel_admit_indication_chosen 23
	ChannelAdmitIndicationPDU channel_admit_indication;
#	define channel_expel_request_chosen 24
	ChannelExpelRequestPDU channel_expel_request;
#	define channel_expel_indication_chosen 25
	ChannelExpelIndicationPDU channel_expel_indication;
#	define send_data_request_chosen 26
	SendDataRequestPDU send_data_request;
#	define send_data_indication_chosen 27
	SendDataIndicationPDU send_data_indication;
#	define uniform_send_data_request_chosen 28
	UniformSendDataRequestPDU uniform_send_data_request;
#	define uniform_send_data_indication_chosen 29
	UniformSendDataIndicationPDU uniform_send_data_indication;
#	define token_grab_request_chosen 30
	TokenGrabRequestPDU token_grab_request;
#	define token_grab_confirm_chosen 31
	TokenGrabConfirmPDU token_grab_confirm;
#	define token_inhibit_request_chosen 32
	TokenInhibitRequestPDU token_inhibit_request;
#	define token_inhibit_confirm_chosen 33
	TokenInhibitConfirmPDU token_inhibit_confirm;
#	define token_give_request_chosen 34
	TokenGiveRequestPDU token_give_request;
#	define token_give_indication_chosen 35
	TokenGiveIndicationPDU token_give_indication;
#	define token_give_response_chosen 36
	TokenGiveResponsePDU token_give_response;
#	define token_give_confirm_chosen 37
	TokenGiveConfirmPDU token_give_confirm;
#	define token_please_request_chosen 38
	TokenPleaseRequestPDU token_please_request;
#	define token_please_indication_chosen 39
	TokenPleaseIndicationPDU token_please_indication;
#	define token_release_request_chosen 40
	TokenReleaseRequestPDU token_release_request;
#	define token_release_confirm_chosen 41
	TokenReleaseConfirmPDU token_release_confirm;
#	define token_test_request_chosen 42
	TokenTestRequestPDU token_test_request;
#	define token_test_confirm_chosen 43
	TokenTestConfirmPDU token_test_confirm;
    } u;
} DomainMCSPDU;
#define DomainMCSPDU_PDU 1
#define SIZE_MCSPDU_Module_PDU_1 sizeof(DomainMCSPDU)

extern ASN1module_t MCSPDU_Module;
extern void ASN1CALL MCSPDU_Module_Startup(void);
extern void ASN1CALL MCSPDU_Module_Cleanup(void);

/* Prototypes of element functions for SEQUENCE OF and SET OF constructs */
    extern int ASN1CALL ASN1Enc_SetOfUserIDs_ElmFn(ASN1encoding_t enc, PSetOfUserIDs val);
    extern int ASN1CALL ASN1Dec_SetOfUserIDs_ElmFn(ASN1decoding_t dec, PSetOfUserIDs val);
    extern void ASN1CALL ASN1Free_SetOfUserIDs_ElmFn(PSetOfUserIDs val);
    extern int ASN1CALL ASN1Enc_SetOfPDUChannelAttributes_ElmFn(ASN1encoding_t enc, PSetOfPDUChannelAttributes val);
    extern int ASN1CALL ASN1Dec_SetOfPDUChannelAttributes_ElmFn(ASN1decoding_t dec, PSetOfPDUChannelAttributes val);
    extern void ASN1CALL ASN1Free_SetOfPDUChannelAttributes_ElmFn(PSetOfPDUChannelAttributes val);
    extern int ASN1CALL ASN1Enc_SetOfChannelIDs_ElmFn(ASN1encoding_t enc, PSetOfChannelIDs val);
    extern int ASN1CALL ASN1Dec_SetOfChannelIDs_ElmFn(ASN1decoding_t dec, PSetOfChannelIDs val);
    extern void ASN1CALL ASN1Free_SetOfChannelIDs_ElmFn(PSetOfChannelIDs val);
    extern int ASN1CALL ASN1Enc_SetOfPDUTokenAttributes_ElmFn(ASN1encoding_t enc, PSetOfPDUTokenAttributes val);
    extern int ASN1CALL ASN1Dec_SetOfPDUTokenAttributes_ElmFn(ASN1decoding_t dec, PSetOfPDUTokenAttributes val);
    extern void ASN1CALL ASN1Free_SetOfPDUTokenAttributes_ElmFn(PSetOfPDUTokenAttributes val);
    extern int ASN1CALL ASN1Enc_SetOfTokenIDs_ElmFn(ASN1encoding_t enc, PSetOfTokenIDs val);
    extern int ASN1CALL ASN1Dec_SetOfTokenIDs_ElmFn(ASN1decoding_t dec, PSetOfTokenIDs val);
    extern void ASN1CALL ASN1Free_SetOfTokenIDs_ElmFn(PSetOfTokenIDs val);

#ifdef __cplusplus
} /* extern "C" */
#endif

#endif /* _MCSPDU_Module_H_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\remdsk\rds\h\mlzdbg.h ===
#ifndef _Multi_Level_Zone_Debug_H_
#define _Multi_Level_Zone_Debug_H_

#include <confdbg.h>
#include <debspew.h>

#define ZONE_FLAG(z)    (1 << (z))

#if defined(_DEBUG) && defined(MULTI_LEVEL_ZONES)

#define DEFAULT_ZONES       "Warning",    "Trace",     "Function",
#define BASE_ZONE_INDEX     (ZONE_FUNCTION + 1)


#undef TRACE_OUT
#define TRACE_OUT(s)        MLZ_TraceZoneEnabled(MLZ_FILE_ZONE) ? (MLZ_TraceOut s) : 0

#undef WARNING_OUT
#define WARNING_OUT(s)      MLZ_WarningOut s

#undef DebugEntry
#define DebugEntry(fn)          MLZ_EntryOut(MLZ_FILE_ZONE, #fn)

#undef DebugExitVOID
#define DebugExitVOID(fn)       MLZ_ExitOut(MLZ_FILE_ZONE, #fn, RCTYPE_VOID,    (DWORD) 0)

#undef DebugExitBOOL
#define DebugExitBOOL(fn,f)     MLZ_ExitOut(MLZ_FILE_ZONE, #fn, RCTYPE_BOOL,    (DWORD) f)

#undef DebugExitDWORD
#define DebugExitDWORD(fn,dw)   MLZ_ExitOut(MLZ_FILE_ZONE, #fn, RCTYPE_DWORD,   (DWORD) dw)

#undef DebugExitHRESULT
#define DebugExitHRESULT(fn,hr) MLZ_ExitOut(MLZ_FILE_ZONE, #fn, RCTYPE_HRESULT, (DWORD) hr)

#undef DebugExitINT
#define DebugExitINT(fn,n)      MLZ_ExitOut(MLZ_FILE_ZONE, #fn, RCTYPE_INT,     (DWORD) n)

#undef DebugExitULONG
#define DebugExitULONG(fn,ul)   MLZ_ExitOut(MLZ_FILE_ZONE, #fn, RCTYPE_ULONG,   (DWORD) ul)

#undef DebugExitPTR
#define DebugExitPTR(fn,lp)     MLZ_ExitOut(MLZ_FILE_ZONE, #fn, RCTYPE_PTR,   (DWORD_PTR) lp)


#ifdef __cplusplus
extern "C" {
#endif // __cplusplus

typedef enum
{
    RCTYPE_VOID     = 0,
    RCTYPE_BOOL     = 1,
    RCTYPE_DWORD    = 2,
    RCTYPE_HRESULT  = 3,
    RCTYPE_INT      = 4,
    RCTYPE_ULONG    = 5,
    RCTYPE_PTR      = 6
}
    RCTYPE;

void WINAPI  MLZ_DbgInit(PSTR *apszZones, UINT cZones);
void WINAPI  MLZ_DbgDeInit(void);
void WINAPIV MLZ_WarningOut(PSTR pszFormat, ...);
BOOL WINAPI  MLZ_TraceZoneEnabled(int iZone);
void WINAPIV MLZ_TraceOut(PSTR pszFormat, ...);
void WINAPI  MLZ_EntryOut(int iZone, PSTR pszFunName);
void WINAPI  MLZ_ExitOut(int iZone, PSTR pszFunName, RCTYPE eRetCodeType, DWORD_PTR dwRetCode);

#ifdef __cplusplus
}
#endif // __cplusplus

#else
#define DebugExitPTR(fn,lp)

#endif // _DEBUG && MULTI_ZONE_OUT

#endif // _Multi_Level_Zone_Debug_H_


=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\remdsk\rds\h\oblist.h ===
#ifndef _OBLIST_H_
#define _OBLIST_H_

// class COBNODE;
#define POSITION COBNODE*

struct COBNODE
{
	POSITION	pNext;
	void*		pItem;
};

class COBLIST
{
protected:
	POSITION m_pHead;
	POSITION m_pTail;
    virtual BOOL Compare(void* pItemToCompare, void* pComparator) 
        {return(pItemToCompare == pComparator);};
public:
	COBLIST() : m_pHead(NULL), m_pTail(NULL) { };
	
	POSITION	    GetHeadPosition() { return(m_pHead); };
	POSITION	    GetTailPosition() { return(m_pTail); };
	virtual void *  RemoveAt(POSITION rPos);
	virtual void *	ReplaceAt(POSITION rPos, void* pNewItem)
	{
		void *pvoid = rPos->pItem;
		rPos->pItem = pNewItem;
		return(pvoid);
	}

	POSITION	    AddTail(void* pItem);
	BOOL		    IsEmpty() { return(!m_pHead); };
	void *		    GetTail();
	void *		    GetNext(POSITION& rPos);
    void *          SafeGetFromPosition(POSITION rPos);
    POSITION        GetPosition(void* pItem);
    POSITION        Lookup(void* pComparator);
    void            EmptyList();
    virtual         ~COBLIST();
#ifdef DEBUG
	void *		    GetHead();
	void *		    RemoveHead();
	// void *		RemoveTail(); // inefficient
	void *		    GetFromPosition(POSITION rPos);
#else
	void *		    GetHead(){return GetFromPosition(GetHeadPosition());};
	void *		    RemoveHead() { return RemoveAt(m_pHead); };
	// void *		RemoveTail() { return RemoveAt(m_pTail); }; // inefficient
	void *		    GetFromPosition(POSITION rPos){return(rPos->pItem);};
#endif
};

#endif // ndef _OBLIST_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\remdsk\rds\h\referenc.h ===
#ifndef	_REFERENC_H_
#define	_REFERENC_H_

class REFCOUNT
{
public:
	REFCOUNT();
	virtual ~REFCOUNT();
	DWORD AddRef();
	DWORD Release();
	DWORD Delete();
	void OnStack() {bOnStack = TRUE;};
private:
	DWORD		 NumRefs;

	// Give 2 bits since BOOL is signed
	BOOL		 bMarkedForDelete : 2;
	BOOL		 bOnStack : 2;
};

class REFERENCE
{
public:
	REFERENCE(REFCOUNT * _pRefCount) : pRefCount(_pRefCount) {pRefCount->AddRef();};
	~REFERENCE() {pRefCount->Release();};

private:
	REFCOUNT * pRefCount;
};

#endif // ! _REFERENC_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\remdsk\rds\h\refcount.hpp ===
/*
 * refcount.hpp - RefCount class description.
 *
 * Taken from URL code by ChrisPi 9-11-95
 *
 */

#ifndef _REFCOUNT_HPP_
#define _REFCOUNT_HPP_

/* Types
 ********/

// RefCount destructor callback function

typedef void (*OBJECTDESTROYEDPROC)(void);


/* Classes
 **********/

class RefCount
{
private:
   ULONG m_ulcRef;
   OBJECTDESTROYEDPROC m_ObjectDestroyed;

public:
   RefCount(OBJECTDESTROYEDPROC ObjectDestroyed);
   // Virtual destructor defers to destructor of derived class.
   virtual ~RefCount(void);

   // IUnknown methods

   ULONG STDMETHODCALLTYPE AddRef(void);
   ULONG STDMETHODCALLTYPE Release(void);

   // friends

#ifdef DEBUG

   friend BOOL IsValidPCRefCount(const RefCount *pcrefcnt);

#endif

};
DECLARE_STANDARD_TYPES(RefCount);

#endif // _REFCOUNT_HPP_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\remdsk\rds\h\resstr.h ===
/*
 * resstr.h - Common return code to string translation routines description.
 *
 * Taken from URL code by ChrisPi 9-11-95
 *
 */

#ifndef _RESSTR_H_
#define _RESSTR_H_

/* Prototypes
 *************/

/* resstr.c */

#ifdef DEBUG

extern PCSTR  GetINTString(int);
extern PCSTR  GetINT_PTRString(INT_PTR);
extern PCSTR  GetULONGString(ULONG);
extern PCSTR  GetBOOLString(BOOL);
extern PCSTR  GetPVOIDString(PVOID);
extern PCSTR  GetClipboardFormatNameString(UINT);
extern PCSTR  GetCOMPARISONRESULTString(COMPARISONRESULT);
extern PCSTR  GetHRESULTString(HRESULT);

#endif   /* DEBUG */

#endif /* _RESSTR_H_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\remdsk\rds\h\olestock.h ===
/*
 * olestock.h - Stock OLE header file.
 *
 * Taken from URL code by ChrisPi 9-11-95
 *
 */

#ifndef _OLESTOCK_H_
#define _OLESTOCK_H_

#ifdef __cplusplus
extern "C" {                        /* Assume C declarations for C++. */
#endif   /* __cplusplus */


/* Types
 ********/

/* IDs */

DECLARE_STANDARD_TYPES(GUID);
DECLARE_STANDARD_TYPES(CLSID);
DECLARE_STANDARD_TYPES(IID);

typedef FARPROC *Interface;
DECLARE_STANDARD_TYPES(Interface);

/* interfaces */

DECLARE_STANDARD_TYPES(IAdviseSink);
DECLARE_STANDARD_TYPES(IBindCtx);
DECLARE_STANDARD_TYPES(IClassFactory);
DECLARE_STANDARD_TYPES(IDataObject);
DECLARE_STANDARD_TYPES(IDropSource);
DECLARE_STANDARD_TYPES(IDropTarget);
DECLARE_STANDARD_TYPES(IEnumFORMATETC);
DECLARE_STANDARD_TYPES(IEnumSTATDATA);
DECLARE_STANDARD_TYPES(IMalloc);
DECLARE_STANDARD_TYPES(IMoniker);
DECLARE_STANDARD_TYPES(IPersist);
DECLARE_STANDARD_TYPES(IPersistFile);
DECLARE_STANDARD_TYPES(IPersistStorage);
DECLARE_STANDARD_TYPES(IPersistStream);
DECLARE_STANDARD_TYPES(IStorage);
DECLARE_STANDARD_TYPES(IStream);
DECLARE_STANDARD_TYPES(IUnknown);

/* structures */

DECLARE_STANDARD_TYPES(DVTARGETDEVICE);
DECLARE_STANDARD_TYPES(FORMATETC);
DECLARE_STANDARD_TYPES(STGMEDIUM);

/* advise flags */

typedef enum advise_flags
{
   ALL_ADVISE_FLAGS   = (ADVF_NODATA |
                         ADVF_PRIMEFIRST |
                         ADVF_ONLYONCE |
                         ADVF_DATAONSTOP |
                         ADVFCACHE_NOHANDLER |
                         ADVFCACHE_FORCEBUILTIN |
                         ADVFCACHE_ONSAVE)
}
ADVISE_FLAGS;

/* data transfer direction flags */

typedef enum datadir_flags
{
   ALL_DATADIR_FLAGS   = (DATADIR_GET |
                          DATADIR_SET)
}
DATADIR_FLAGS;

/* drop effects */

typedef enum drop_effects
{
   ALL_DROPEFFECT_FLAGS   = (DROPEFFECT_NONE |
                             DROPEFFECT_COPY |
                             DROPEFFECT_MOVE |
                             DROPEFFECT_LINK |
                             DROPEFFECT_SCROLL)
}
DROP_EFFECTS;

/* mouse message key states */

typedef enum mk_flags
{
   ALL_KEYSTATE_FLAGS      = (MK_LBUTTON |
                              MK_RBUTTON |
                              MK_SHIFT |
                              MK_CONTROL |
                              MK_MBUTTON)
}
MK_FLAGS;

/* medium types */

typedef enum tymeds
{
   ALL_TYMED_FLAGS         = (TYMED_HGLOBAL |
                              TYMED_FILE |
                              TYMED_ISTREAM |
                              TYMED_ISTORAGE |
                              TYMED_GDI |
                              TYMED_MFPICT |
                              TYMED_ENHMF)
}
TYMEDS;


#ifdef __cplusplus
}                                   /* End of extern "C" {. */
#endif   /* __cplusplus */

#endif /* _OLESTOCK_H_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\remdsk\rds\h\service.h ===
#define REMOTE_CONTROL_NAME             TEXT("service")
#define REMOTE_CONTROL_DISPLAY_NAME     TEXT("Sample Remote Desktop Sharing Service")

#define SZRDSGROUP  "Salem RDS Users"

// Remote Control Conference Descriptor
#define RDS_CONFERENCE_DESCRIPTOR  L"0x83b9dac69a45d111873500f8752571"


// {38C25034-B467-43ae-80DF-912438185428}
DEFINE_GUID(GUID_SAMPLEDATA,
0x38c25034, 0xb467, 0x43ae, 0x80, 0xdf, 0x91, 0x24, 0x38, 0x18, 0x54, 0x28);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\remdsk\rds\h\os2.h ===
// Dummy file to prevent dependancy errors.
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\remdsk\rds\h\pmwinp.h ===
// Dummy file to prevent dependancy errors.
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\remdsk\rds\h\regentry.h ===
/***************************************************************************/
/**                  Microsoft Windows                                    **/
/**            Copyright(c) Microsoft Corp., 1995-1996                    **/
/***************************************************************************/


/****************************************************************************

regentry.h

Oct. 95		LenS

Wrapper for registry access

Construct a RegEntry object by specifying the subkey (under
HKEY_CURRENT_USER by default, but can be overridden.)

All member functions (except the destructor) set an internal
error state which can be retrieved with GetError().
Zero indicates no error.

RegEntry works only with strings and DWORDS which are both set
using the overloaded function SetValue()

	SetValue("valuename", "string");
	SetValue("valuename", 42);
	
Values are retrieved with GetString() and GetNumber().  
GetNumber() allows you to specificy a default if the valuename doesn't
exist.
GetString() returns a pointer to a string internal to RegEntry that is 
invalidated when another fuction is called on the same RegEntry object
(e.g. its destructor) so, if you want to use the string beyond this
time, then you must copy it out of the RegEntry object first.

DeleteValue() removes the valuename and value pair.

Registry flushes are automatic when RegEntry is destroys or moves to
another key.

****************************************************************************/

#ifndef	REGENTRY_INC
#define	REGENTRY_INC

class RegEntry
{
	public:
		RegEntry(	LPCTSTR pszSubKey,
					HKEY hkey = HKEY_CURRENT_USER,
					BOOL fCreate = TRUE,
					REGSAM samDesired = 0
					);
		~RegEntry();
		
		long	GetError()	{ return m_error;}
		VOID	ClearError() {m_error = ERROR_SUCCESS;}
		long	SetValue(LPCTSTR pszValueName, LPCTSTR string);
		long	SetValue(LPCTSTR pszValueName, unsigned long dwNumber);
		long	SetValue(LPCTSTR pszValue, void* pData, DWORD cbLength);
		LPTSTR	GetString(LPCTSTR pszValueName);
		DWORD	GetBinary(LPCTSTR pszValueName, void** ppvData);
		long	GetNumber(LPCTSTR pszValueName, long dwDefault = 0);
		ULONG	GetNumberIniStyle(LPCTSTR pszValueName, ULONG dwDefault = 0);
		long	DeleteValue(LPCTSTR pszValueName);
		long	FlushKey();
        VOID    MoveToSubKey(LPCTSTR pszSubKeyName);
        HKEY    GetKey()    { return m_hkey; }

	private:
		VOID	ChangeKey(HKEY hNewKey);
		VOID	UpdateWrittenStatus();
		VOID	ResizeValueBuffer(DWORD length);

		HKEY	m_hkey;
		long	m_error;
        BOOL    m_fhkeyValid;
		LPBYTE  m_pbValueBuffer;
        DWORD   m_cbValueBuffer;
		BOOL	m_fValuesWritten;
		TCHAR	m_szNULL;
};

inline long 
RegEntry::FlushKey()
{
    if (m_fhkeyValid) {
		m_error = ::RegFlushKey(m_hkey);
    }
	return m_error;
}


class RegEnumValues
{
	public:
		RegEnumValues(RegEntry *pRegEntry);
		~RegEnumValues();
		long	Next();
		LPTSTR 	GetName()       {return m_pchName;}
        DWORD   GetType()       {return m_dwType;}
        LPBYTE  GetData()       {return m_pbValue;}
        DWORD   GetDataLength() {return m_dwDataLength;}
		DWORD	GetCount()      {return m_cEntries;}

	private:
        RegEntry * m_pRegEntry;
		DWORD   m_iEnum;
        DWORD   m_cEntries;
		LPTSTR  m_pchName;
		LPBYTE  m_pbValue;
        DWORD   m_dwType;
        DWORD   m_dwDataLength;
        DWORD   m_cMaxValueName;
        DWORD   m_cMaxData;
        LONG    m_error;
};

class RegEnumSubKeys
{
	public:
		RegEnumSubKeys(RegEntry *pRegEntry);
		~RegEnumSubKeys();
		long    Next();
		LPTSTR 	GetName()       {return m_pchName;}
		DWORD	GetCount()      {return m_cEntries;}

	protected:
        RegEntry * m_pRegEntry;
		DWORD   m_iEnum;
        DWORD   m_cEntries;
		LPTSTR  m_pchName;
        DWORD   m_cMaxKeyName;
        LONG    m_error;
};

#endif // REGENTRY_INC
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\remdsk\rds\h\stock.h ===
/*
 * stock.h - Stock header file.
 *
 * Taken from URL code by ChrisPi 9-11-95
 *
 */

#ifndef _STOCK_H_
#define _STOCK_H_

/* Constants
 ************/

#define ASTERISK                 '*'
#define BACKSLASH                '/'
#define COLON                    ':'
#define COMMA                    ','
#define EQUAL                    '='
#define PERIOD                   '.'
#define POUND                    '#'
#define QMARK                    '?'
#define QUOTE                    '\''
#define QUOTES                   '"'
#define SLASH                    '\\'
#define SPACE                    ' '
#define TAB                      '\t'

/* linkage */

#ifdef __cplusplus
#define INLINE                   inline
#else
#define INLINE                   __inline
#endif


/* Win32 HRESULTs */

#define E_FILE_NOT_FOUND         MAKE_SCODE(SEVERITY_ERROR, FACILITY_WIN32, ERROR_FILE_NOT_FOUND)
#define E_PATH_NOT_FOUND         MAKE_SCODE(SEVERITY_ERROR, FACILITY_WIN32, ERROR_PATH_NOT_FOUND)

/* file-related flag combinations */

#define ALL_FILE_ACCESS_FLAGS          (GENERIC_READ |\
                                        GENERIC_WRITE)

#define ALL_FILE_SHARING_FLAGS         (FILE_SHARE_READ |\
                                        FILE_SHARE_WRITE)

#define ALL_FILE_ATTRIBUTES            (FILE_ATTRIBUTE_READONLY |\
                                        FILE_ATTRIBUTE_HIDDEN |\
                                        FILE_ATTRIBUTE_SYSTEM |\
                                        FILE_ATTRIBUTE_DIRECTORY |\
                                        FILE_ATTRIBUTE_ARCHIVE |\
                                        FILE_ATTRIBUTE_NORMAL |\
                                        FILE_ATTRIBUTE_TEMPORARY |\
                                        FILE_ATTRIBUTE_ATOMIC_WRITE |\
                                        FILE_ATTRIBUTE_XACTION_WRITE)

#define ALL_FILE_FLAGS                 (FILE_FLAG_WRITE_THROUGH |\
                                        FILE_FLAG_OVERLAPPED |\
                                        FILE_FLAG_NO_BUFFERING |\
                                        FILE_FLAG_RANDOM_ACCESS |\
                                        FILE_FLAG_SEQUENTIAL_SCAN |\
                                        FILE_FLAG_DELETE_ON_CLOSE |\
                                        FILE_FLAG_BACKUP_SEMANTICS |\
                                        FILE_FLAG_POSIX_SEMANTICS)

#define ALL_FILE_ATTRIBUTES_AND_FLAGS  (ALL_FILE_ATTRIBUTES |\
                                        ALL_FILE_FLAGS)


/* Macros
 *********/

#ifndef DECLARE_STANDARD_TYPES

/*
 * For a type "FOO", define the standard derived types PFOO, CFOO, and PCFOO.
 */

#define DECLARE_STANDARD_TYPES(type)      typedef type *P##type; \
                                          typedef const type C##type; \
                                          typedef const type *PC##type;

#endif

/* character manipulation */

#define IS_SLASH(ch)                      ((ch) == SLASH || (ch) == BACKSLASH)

/* bit flag manipulation */

#define SET_FLAG(dwAllFlags, dwFlag)      ((dwAllFlags) |= (dwFlag))

/* ChrisPi: DCL also defines this - override their definition */
#ifdef CLEAR_FLAG
#undef CLEAR_FLAG
#endif /* CLEAR_FLAG */

#define CLEAR_FLAG(dwAllFlags, dwFlag)    ((dwAllFlags) &= (~dwFlag))

#define IS_FLAG_SET(dwAllFlags, dwFlag)   ((BOOL)((dwAllFlags) & (dwFlag)))
#define IS_FLAG_CLEAR(dwAllFlags, dwFlag) (! (IS_FLAG_SET(dwAllFlags, dwFlag)))

/* array element count */

#define ARRAY_ELEMENTS(rg)                (sizeof(rg) / sizeof((rg)[0]))
#define CCHMAX(rg)                        ARRAY_ELEMENTS(rg)

/* clearing bytes */
#define ClearStruct(lpv)     ZeroMemory((LPVOID) (lpv), sizeof(*(lpv)))
#define InitStruct(lpv)      {ClearStruct(lpv); (* (LPDWORD)(lpv)) = sizeof(*(lpv));}


/* string safety */

#define CHECK_STRING(psz)                 ((psz) ? (psz) : "(null)")

/* file attribute manipulation */

#define IS_ATTR_DIR(attr)                 (IS_FLAG_SET((attr), FILE_ATTRIBUTE_DIRECTORY))
#define IS_ATTR_VOLUME(attr)              (IS_FLAG_SET((attr), FILE_ATTRIBUTE_VOLUME))

/* stuff a point value packed in an LPARAM into a POINT */

#define LPARAM_TO_POINT(lparam, pt)       ((pt).x = (short)LOWORD(lparam), \
                                           (pt).y = (short)HIWORD(lparam))


/* Types
 ********/

typedef const void *PCVOID;
typedef const INT CINT;
typedef const INT *PCINT;
typedef const UINT CUINT;
typedef const UINT *PCUINT;
typedef const LONG CULONG;
typedef const LONG *PCULONG;
typedef const BYTE CBYTE;
typedef const BYTE *PCBYTE;
typedef const WORD CWORD;
typedef const WORD *PCWORD;
typedef const DWORD CDWORD;
typedef const DWORD *PCDWORD;
typedef const CRITICAL_SECTION CCRITICAL_SECTION;
typedef const CRITICAL_SECTION *PCCRITICAL_SECTION;
typedef const FILETIME CFILETIME;
typedef const FILETIME *PCFILETIME;
typedef const BITMAPINFO CBITMAPINFO;
typedef const BITMAPINFO *PCBITMAPINFO;
typedef const POINT CPOINT;
typedef const POINT *PCPOINT;
typedef const POINTL CPOINTL;
typedef const POINTL *PCPOINTL;
typedef const SECURITY_ATTRIBUTES CSECURITY_ATTRIBUTES;
typedef const SECURITY_ATTRIBUTES *PCSECURITY_ATTRIBUTES;
typedef const WIN32_FIND_DATA CWIN32_FIND_DATA;
typedef const WIN32_FIND_DATA *PCWIN32_FIND_DATA;

DECLARE_STANDARD_TYPES(HGLOBAL);
DECLARE_STANDARD_TYPES(HICON);
DECLARE_STANDARD_TYPES(HMENU);
DECLARE_STANDARD_TYPES(HWND);
DECLARE_STANDARD_TYPES(NMHDR);


#ifndef _COMPARISONRESULT_DEFINED_

/* comparison result */

typedef enum _comparisonresult
{
   CR_FIRST_SMALLER = -1,
   CR_EQUAL = 0,
   CR_FIRST_LARGER = +1
}
COMPARISONRESULT;
DECLARE_STANDARD_TYPES(COMPARISONRESULT);

#define _COMPARISONRESULT_DEFINED_

#endif

#endif /* _STOCK_H_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\remdsk\rds\h\standrd.h ===
#ifndef __standrd_h__
#define __standrd_h__


// Useful macros

#ifndef TRACENOTIMPL
    #define TRACENOTIMPL(funcname)   TRACE_OUT((_T("%s not implemented.\n"), funcname)); hr = E_NOTIMPL
#endif 

#define CONSTANT( x ) enum{ x }

#define CASERET(x) case x: return _T(#x)

#define ClearStruct(lpv)     ZeroMemory((LPVOID) (lpv), sizeof(*(lpv)))

#ifndef STRING_RESOURCE_MODULE
    # define STRING_RESOURCE_MODULE _Module.GetModuleInstance()
#endif

typedef struct _tagCol {
	UINT  dwWidth;
	LPTSTR lpsz;
} COL;
typedef COL * LPCOL;


inline LPTSTR CopyLPCTSTR( LPCTSTR sz )
{
    LPTSTR newString = new TCHAR[ lstrlen( sz ) + 1 ];
    if( !lstrcpy( newString, sz ) )
    {
        // Somethnig fialide
        delete [] newString;
        newString = NULL;
    }

    return newString;
}

#ifndef CchMax
    #define CchMax(pcsz)        (sizeof(pcsz) / sizeof((pcsz)[0]))
#endif // CchMax

#define MAX_RESOURCE_STRING_LEN 256


/*  C O N V E R T  S Z  C H  */
/*-------------------------------------------------------------------------
    %%Function: ConvertSzCh

    Replace every instance of chSrc to chDest in the string
-------------------------------------------------------------------------*/
inline VOID ConvertSzCh(LPTSTR psz, TCHAR chSrc, TCHAR chDest)
{
	while (_T('\0') != *psz)
	{
		if (chSrc == *psz)
		{
			*psz = chDest;
			psz++;
		}
		else
		{
			psz = CharNext(psz);
		}
	}
}


inline VOID ConvertSzCh(LPTSTR psz, TCHAR chSrc = _T('|'), TCHAR chDest = _T('\0'));


inline HRESULT NmCtlLoadString(UINT id, LPTSTR lpsz, UINT cch)
{
    HRESULT hr = S_OK;

    if( NULL != STRING_RESOURCE_MODULE )
    {
        if( NULL != lpsz )
        {
	        if (0 == ::LoadString(STRING_RESOURCE_MODULE, id, lpsz, cch))
	        {
		        ERROR_OUT(("*** Resource %d does not exist", id));
		        *lpsz = _T('\0');
		        hr = HRESULT_FROM_WIN32( ::GetLastError() );
	        }


        }
        else
        {
            ERROR_OUT(("LoadString passed an empty buffer"));
            hr = E_INVALIDARG;
        }
    }
    else
    {
        ERROR_OUT(("LoadString could not find the module"));
        hr = E_UNEXPECTED;
    }

	return hr;
}


///////////////////////////////////////////////////////////////////////////////////////////////////////////
// this works if you have a member variable CComBSTR m_bstrProp ( substitute Prop for the Prop param )
// Example:
//
// CComBSTR m_bstrName;
//
//
// DECLARE_CCOMBSTR_PROPPUT( Name, DISPID_PROP_NAME );
// DECLARE_CCOMBSTR_PROPGET( Name );
//
#define DECLARE_CCOMBSTR_PROPPUT( Prop, PROP_DISPID ) \
    STDMETHOD(put_##Prop)( BSTR newVal )  \
    {\
        HRESULT hr = S_OK;\
        if( S_OK == __ATL_PROP_NOTIFY_EVENT_CLASS::FireOnRequestEdit(GetUnknown(), PROP_DISPID) )\
        {\
            m_bstr##Prop = newVal;\
            hr = __ATL_PROP_NOTIFY_EVENT_CLASS::FireOnChanged(GetUnknown(), PROP_DISPID);\
        }\
        return hr;                \
    }


#define DECLARE_CCOMBSTR_PROPGET( Prop ) \
    STDMETHOD(get_##Prop)( BSTR *pVal )  \
    {\
        if( pVal )\
        {\
            *pVal = m_bstr##Prop.Copy();\
        }\
        else\
        {\
            return E_POINTER;\
        }\
        return S_OK;\
    }



///////////////////////////////////////////////////////////////////////////////////////////////////////////
// this works if you have a member variable <class with iterator> m_aryProp ( substitute Prop for the Prop param )
// Example:
//
// lst<IUnknown*> m_AryName;
//
//
// DECLARE_SAFEARRAY_UNK_PROPPUT( Name, DISPID_PROP_NAME );
// DECLARE_SAFEARRAY_UNK_PROPGET( Name );
//

#define DECLARE_SAFEARRAY_UNK_PROPPUT( Prop, PROP_DISPID ) \
    STDMETHOD(put_##Prop)( SAFEARRAY newVal )  \
    {\
        HRESULT hr = S_OK;\
        if( S_OK == __ATL_PROP_NOTIFY_EVENT_CLASS::FireOnRequestEdit(GetUnknown(), PROP_DISPID) )\
        {\
            lst<IUnknown*>::iterator I = m_ary##Prop.begin();\
            while( I != m_ary##Prop.end() )\
            {\
                (*I)->Release();\
                ++I;\
            }\
            m_ary##Prop.erase(m_ary##Prop.begin(), m_ary##Prop.end());\
            IUnknown** ppUnkArray;\
            SafeArrayAccessData( &newVal, reinterpret_cast<void**>(&ppUnkArray) );\
            for (UINT x = 0; x < newVal.rgsabound->cElements; x++)\
	        {\
                IUnknown* pUnk = ppUnkArray[x];\
                pUnk->AddRef();\
                m_ary##Prop.push_back( pUnk );\
	        }\
            SafeArrayUnaccessData(&newVal);\
            hr = __ATL_PROP_NOTIFY_EVENT_CLASS::FireOnChanged(GetUnknown(), PROP_DISPID);\
        }\
        return hr;                \
    }


#define DECLARE_SAFEARRAY_UNK_PROPGET( Prop ) \
    STDMETHOD(get_##Prop)( SAFEARRAY *pVal )  \
    {\
        if( pVal )\
        {\
            int nItems = m_ary##Prop.size();\
            SAFEARRAYBOUND bounds = { nItems, 0 };\
            pVal = SafeArrayCreate( VT_UNKNOWN, 1, &bounds );\
            IUnknown** ppUnkArray;\
            SafeArrayAccessData( pVal, reinterpret_cast<void**>(&ppUnkArray) );\
            lst<IUnknown*>::iterator I = m_ary##Prop.begin();\
            for( int i = 0; I != m_ary##Prop.end(); ++I, ++i )\
            {\
                ppUnkArray[i] = (*I);\
            }\
            SafeArrayUnaccessData(pVal);\
        }\
        else\
        {\
            return E_POINTER;\
        }\
        return S_OK;\
    }
///////////////////////////////////////////////////////////////////////////////////////////////////////
// The following DECLARE_PROPXXX macros define functions if you have a member variable that supports
// an issignment operator ( cleaning up memory if need be....
#define DECLARE_PROPPUT( Type, lVal, Prop, PROP_DISPID ) \
    STDMETHOD(put_##Prop)( Type newVal )  \
    {\
        HRESULT hr = S_OK;\
        if( S_OK == __ATL_PROP_NOTIFY_EVENT_CLASS::FireOnRequestEdit(GetUnknown(), PROP_DISPID) )\
        {\
            lVal = newVal;\
            hr = __ATL_PROP_NOTIFY_EVENT_CLASS::FireOnChanged(GetUnknown(), PROP_DISPID);\
        }\
        return hr;                \
    }


#define DECLARE_PROPGET( Type, rVal, Prop ) \
    STDMETHOD(get_##Prop)( Type* pVal )\
    {\
        if( pVal )\
        {\
            *pVal = rVal;\
        }\
        else\
        {\
            return E_POINTER;\
        }\
        return S_OK;\
    }

inline HRESULT GetTextBoxHeight( HWND hwnd, int* pcy )
{

    HRESULT hr = S_OK;
    HDC hdc = NULL;
    HFONT hSysFont = NULL;
    HFONT hOldFont = NULL;
    TEXTMETRIC tm;

    int HeightOfCurrentFont = 0;
    int HeightOfSystemFont = 0;

    if( pcy )
    {
        if( IsWindow( hwnd ) )
        {
           //get the DC for the  control
           hdc = GetDC(hwnd);

           //get the metrics for the system font
           hSysFont = reinterpret_cast<HFONT>(GetStockObject(SYSTEM_FONT));
           hOldFont = reinterpret_cast<HFONT>(SelectObject(hdc, hSysFont));
           GetTextMetrics(hdc, &tm);
           HeightOfSystemFont = tm.tmHeight;

           //select the original font back into the DC and release the DC
           SelectObject(hdc, hOldFont);
           DeleteObject(hSysFont);
           
           GetTextMetrics(hdc, &tm);
           
		   ReleaseDC(hwnd, hdc);
		   
		   HeightOfCurrentFont = tm.tmHeight;

           *pcy = HeightOfCurrentFont + 
                  ( min( HeightOfSystemFont, HeightOfCurrentFont ) >> 1 ) + 
                  (GetSystemMetrics(SM_CYEDGE) * 2);
        }
        else
        {
            hr = E_INVALIDARG;
        }
    }
    else
    {
        hr = E_POINTER;
    }

    return hr;
}

#define RES_CH_MAX 256

inline TCHAR* Res2THelper( UINT uID, TCHAR* psz, int cch )
{
    if( LoadString( STRING_RESOURCE_MODULE, uID, psz, cch ) )
    {
        return psz;
    }

    return _T("");
}

#ifndef RES2T
#define RES2T(uID) ( Res2THelper( uID, static_cast<TCHAR*>(_alloca( RES_CH_MAX )), RES_CH_MAX ) )
#endif

inline LPCTSTR CommDlgLastErrorToa( DWORD dwErr )
{
    switch( dwErr )
    {
        CASERET ( CDERR_DIALOGFAILURE   ); 
        CASERET ( CDERR_GENERALCODES     );
        CASERET ( CDERR_STRUCTSIZE       );
        CASERET ( CDERR_INITIALIZATION   );
        CASERET ( CDERR_NOTEMPLATE       );
        CASERET ( CDERR_NOHINSTANCE      );
        CASERET ( CDERR_LOADSTRFAILURE   );
        CASERET ( CDERR_FINDRESFAILURE   );
        CASERET ( CDERR_LOADRESFAILURE   );
        CASERET ( CDERR_LOCKRESFAILURE   );
        CASERET ( CDERR_MEMALLOCFAILURE  );
        CASERET ( CDERR_MEMLOCKFAILURE   );
        CASERET ( CDERR_NOHOOK           );
        CASERET ( CDERR_REGISTERMSGFAIL  );

        CASERET ( PDERR_PRINTERCODES     );
        CASERET ( PDERR_SETUPFAILURE     );
        CASERET ( PDERR_PARSEFAILURE     );
        CASERET ( PDERR_RETDEFFAILURE    );
        CASERET ( PDERR_LOADDRVFAILURE   );
        CASERET ( PDERR_GETDEVMODEFAIL   );
        CASERET ( PDERR_INITFAILURE      );
        CASERET ( PDERR_NODEVICES        );
        CASERET ( PDERR_NODEFAULTPRN     );
        CASERET ( PDERR_DNDMMISMATCH     );
        CASERET ( PDERR_CREATEICFAILURE  );
        CASERET ( PDERR_PRINTERNOTFOUND  );
        CASERET ( PDERR_DEFAULTDIFFERENT );

        CASERET ( CFERR_CHOOSEFONTCODES  );
        CASERET ( CFERR_NOFONTS          );
        CASERET ( CFERR_MAXLESSTHANMIN   );

        CASERET ( FNERR_FILENAMECODES    );
        CASERET ( FNERR_SUBCLASSFAILURE  );
        CASERET ( FNERR_INVALIDFILENAME  );
        CASERET ( FNERR_BUFFERTOOSMALL   );

        CASERET ( FRERR_FINDREPLACECODES );
        CASERET ( FRERR_BUFFERLENGTHZERO );

        CASERET ( CCERR_CHOOSECOLORCODES );
    }

    return _T("NOERROR");
}

inline void DumpCommDlgLastError()
{
    ATLTRACE(_T("CommDlgExtendedError == %s"), CommDlgLastErrorToa( CommDlgExtendedError() ));
}

inline int _Points_From_LogFontHeight( int height, HWND hwnd )
{
	HDC hdc = ::GetDC( hwnd );
	if( NULL != hdc )
	{
		int iRet = MulDiv( -height, 72, GetDeviceCaps( hdc, LOGPIXELSY ) );
		::ReleaseDC( hwnd, hdc );
		return iRet;
	}

	return 0;
}


#endif // __standrd_h__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\remdsk\rds\h\strutil.h ===
#ifndef _STRUTIL_H_
#define _STRUTIL_H_

#include <stock.h>
#include <wincrypt.h>


INLINE BOOL
IsEmptyStringA(LPCSTR pcsz)
{
	return (NULL == pcsz) || ('\0' == *pcsz);
}

INLINE BOOL
IsEmptyStringW(LPCWSTR pcwsz)
{
	return (NULL == pcwsz) || (L'\0' == *pcwsz);
}

#if defined(UNICODE)
#define IsEmptyString IsEmptyStringW
#else // defined(UNICODE)
#define IsEmptyString IsEmptyStringA
#endif // defined(UNICODE)


#define IS_EMPTY_STRING(s)	  (IsEmptyString(s))
#define FEmptySz(psz)         (IsEmptyString(psz))

#define SetEmptySz(psz)       (*(psz) = _T('\0'))

	
// global helper functions for Unicode support in a DBCS environment

int      UnicodeCompare(PCWSTR s, PCWSTR t);
PWSTR    NewUnicodeString(PCWSTR wszText);
BOOL     UnicodeIsNumber(PCWSTR wszText);
PWSTR    DBCSToUnicode(UINT uCodePage, PCSTR szText);
PSTR     UnicodeToDBCS(UINT uCodePage, PCWSTR wszText);

INLINE PWSTR AnsiToUnicode(PCSTR szText)
{
	return DBCSToUnicode(CP_ACP, szText);
}

INLINE PWSTR OEMToUnicode(PCSTR szText)
{
	return DBCSToUnicode(CP_OEMCP, szText);
}

INLINE PSTR UnicodeToAnsi(PCWSTR wszText)
{
	return UnicodeToDBCS(CP_ACP, wszText);
}

INLINE PSTR UnicodeToOEM(PCWSTR wszText)
{
	return UnicodeToDBCS(CP_OEMCP, wszText);
}


// Functions to convert between Quad Words (expressed as ULARGE_INTEGERs)
// and ANSI strings.
BOOL  HexStringToQWordA(LPCSTR pcszString, ULARGE_INTEGER* pqw);
int  QWordToHexStringA(ULARGE_INTEGER qw, LPSTR pszString);

// Function to convert from a hex string to a DWORD.
DWORD    DwFromHex(LPCTSTR pchHex);

// CCHMAX_HEX_ULARGE_INTEGER - defines the minimum string buffer size needed
// for the second parameter of QWordToHexStringA().
#define CCHMAX_HEX_ULARGE_INTEGER 17 // 16 characters + n.t.

#define CCH_HEX_DWORD		8
#define CCH_HEX_QWORD		16
#define BITS_PER_HEX_CHAR	4


// Other Random string functions
VOID     GuidToSz(GUID * pguid, LPTSTR lpchDest);
/* sizeof(GUID)*2 + 7 (includes NULL terminator) characters (see GuidToSz) */
#define LENGTH_SZGUID_FORMATTED 39


int WINAPI RtStrToInt(LPCTSTR lpSrc);       // atoi()
#define ATOI					RtStrToInt

#ifdef __cplusplus
extern "C"{
#endif
UINT     DecimalStringToUINT(LPCTSTR pcszString);
#ifdef __cplusplus
}
#endif

#ifdef __cplusplus
extern "C"{
#endif
LPCTSTR  _StrChr(LPCTSTR psz, TCHAR c);
int      _StrCmpN(LPCTSTR psz1, LPCTSTR psz2, UINT maxChars);
#ifdef __cplusplus
}
#endif
LPCTSTR  _StrStr(LPCTSTR pcsz1, LPCTSTR pcsz2);
LPCWSTR  _StrStrW(LPCWSTR pcsz1, LPCWSTR pcsz2);

LPSTR	 _StrPbrkA(LPCSTR pcszString, LPCSTR pcszSearch);
LPWSTR	 _StrPbrkW(LPCWSTR pcszString, LPCWSTR pcszSearch);

#if defined(UNICODE)
#define _StrPbrk _StrPbrkW
#else // defined(UNICODE)
#define _StrPbrk _StrPbrkA
#endif // defined(UNICODE)

LPTSTR   SzFindLastCh(LPTSTR lpsz, TCHAR ch);
UINT     TrimSz(PTCHAR psz);

// Local LStrLenW function is unnecessary, since Windows 95 supports
// lstrlenW natively
#define LStrLenW lstrlenW

// Map LStrCpyW to its Win32 equivalent for Unicode builds
#if defined UNICODE
#define LStrCpyW lstrcpyW
#define LStrCpyNW lstrcpyn
#else // defined UNICODE
LPWSTR   LStrCpyW(LPWSTR pszDest, LPWSTR pszSrc);
LPWSTR   LStrCpyNW(LPWSTR pszDest, LPCWSTR pszSrc, INT iMaxLength);
#endif // defined UNICODE

LPWSTR  _StrLwrW(LPWSTR pwszSrc);

#ifdef __cplusplus
class CHash
{
public:
	CHash();
	~CHash();
	DWORD GetHashedData(PBYTE pbData, DWORD cbData, void ** ppvHashedData);

private:
	HCRYPTPROV      m_hProv;
	HCRYPTHASH      m_hHash;
	PBYTE			m_pbHashedData;
	DWORD			m_cbHashedData;
	BOOL			m_fReady;
};
#endif
	
DWORD  HashPasswd(PBYTE pbPasswd, DWORD cbPasswd, void **ppvData);

#endif // ndef STRUTIL_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\remdsk\rds\h\t120type.h ===
#ifndef _T120_TYPE_H_
#define  _T120_TYPE_H_

#include <nmapptyp.h>

/*
 *	This is a list of types that are used extensively throughout MCS.  For
 *	each type there is also a pointer to that type defined, which has a "P"
 *	prefix.  These types are described as follows:
 *
 *	DomainSelector - This is a string of bytes that acts as the name of a given
 *		domain.  It is used when creating a new domain, as well as in accessing
 *		that domain after creation.  The length of the string is specified with
 *		a separate parameter, and the string CAN contain embedded zeroes.
 *	ConnectionHandle - When a user application connects two domains using
 *		MCSConnectProviderRequest, a ConnectionHandle is assigned to that MCS
 *		connection.  This allows more direct access to it for further services.
 *	ConnectID - This type is used only during MCS connection establishment.
 *		It identifies a particular transport connection for the purpose of
 *		adding multiple data priorities on the same MCS connection.
 *	ChannelID - This type identifies an MCS channel.  There are four different
 *		types of channels that are part of this type: user ID; static; private;
 *		and assigned.
 *	UserID - This is a special channel that identifies a particular user in an
 *		MCS domain.  Only that user can join the channel, so this is referred
 *		to as a single-cast channel.  All other channels are multi-cast, meaning
 *		that any number of users can join them at once.
 *	TokenID - This is an MCS object that is used to resolve resource conflicts.
 *		If an application has a particular resource or service that can only
 *		be used by one user at a time, that user can request exclusive ownership
 *		of a token.
 */
// ushort
typedef AppletSessionID     T120SessionID, GCCSessionID, *PGCCSessionID;
typedef	AppletChannelID     T120ChannelID, ChannelID, *PChannelID;
typedef	AppletUserID        T120UserID, UserID, *PUserID, GCCUserID, *PGCCUserID;
typedef	AppletTokenID       T120TokenID, TokenID, *PTokenID;
typedef AppletNodeID        T120NodeID, GCCNodeID, *PGCCNodeID;
typedef AppletEntityID      T120EntityID, GCCEntityID, *PGCCEntityID;
// ulong
typedef AppletConfID        T120ConfID, GCCConferenceID, GCCConfID, *PGCCConferenceID, *PGCCConfID;
// uint
typedef AppletRequestTag    T120RequestTag, GCCRequestTag, *PGCCRequestTag;
typedef AppletRequestTag    T120ResponseTag, GCCResponseTag, *PGCCResponseTag;
// enum
typedef AppletPriority      T120Priority;


typedef	LPBYTE          DomainSelector, *PDomainSelector;
typedef	USHORT          ConnectionHandle, *PConnectionHandle;
typedef	USHORT          ConnectID, *PConnectID;


#define GCC_INVALID_EID     0   // invalid entity id
#define GCC_INVALID_UID     0   // invalid user id
#define GCC_INVALID_NID     0   // invalid node id
#define GCC_INVALID_CID     0   // invalid conference id
#define GCC_INVALID_TID     0   // invalid token id
#define GCC_INVALID_TAG     0   // invalid request id




/*
 *	This section defines the valid return values from GCC function calls.  Do
 *	not confuse this return value with the Result and Reason values defined
 *	by T.124 (which are discussed later).  These values are returned directly
 *	from the call to the API entry point, letting you know whether or not the
 *	request for service was successfully invoked.  The Result and Reason
 *	codes are issued as part of an indication or confirm which occurs
 *	asynchronously to the call that causes it.
 *
 *	All GCC function calls return type GCCError.  Its valid values are as
 *	follows:
 *
 *	GCC_NO_ERROR
 *		This means that the request was successfully invoked.  It does NOT
 *		mean that the service has been successfully completed.  Remember that
 *		all GCC calls are non-blocking.  This means that each request call
 *		begins the process, and if necessary, a subsequent indication or
 *		confirm will result.  By convention, if ANY GCC call returns a value
 *		other than this, something went wrong.  Note that this value should
 *		also be returned to GCC during a callback if the application processes
 *		the callback successfully.
 *
 *	GCC_NOT_INITIALIZED
 *		The application has attempted to use GCC services before GCC has been
 *		initialized.  It is necessary for the node controller (or whatever
 *		application is serving as the node controller), to initialize GCC before
 *		it is called upon to perform any services.
 *
 *	GCC_ALREADY_INITIALIZED
 *		The application has attempted to initialize GCC when it is already
 *		initialized.
 *
 *	GCC_ALLOCATION_FAILURE
 *		This indicates a fatal resource error inside GCC.  It usually results
 *		in the automatic termination of the affected conference.
 *
 *	GCC_NO_SUCH_APPLICATION	
 *		This indicates that the Application SAP handle passed in was invalid.
 *
 *	GCC_INVALID_CONFERENCE
 *		This indicates that an illegal conference ID was passed in.
 *
 *	GCC_CONFERENCE_ALREADY_EXISTS
 *		The Conference specified in the request or response is already in
 *		existence.
 *
 *	GCC_NO_TRANSPORT_STACKS
 *		This indicates that MCS failed to load the TCP transport stack during
 *		initialization.  This is now an error.  MCS exits when this happens and
 *		can not be used any more, since NetMeeting is now a TCP-only
 *		product.
 *
 *	GCC_INVALID_ADDRESS_PREFIX
 *		The called address parameter in a request such as 
 *		GCCConferenceCreateRequest does not	contain a recognized prefix.  MCS 
 *		relies on the prefix to know which transport stack to invoke.
 *
 *	GCC_INVALID_TRANSPORT
 *		The dynamic load of a transport stack failed either because the DLL
 *		could not be found, or because it did not export at least one entry
 *		point that MCS requires.
 *
 *	GCC_FAILURE_CREATING_PACKET
 *		This is a FATAL error which means that for some reason the 
 *		communications packet generated due to a request could not be created.
 *		This typically flags a problem with the ASN.1 toolkit.
 *
 *	GCC_QUERY_REQUEST_OUTSTANDING
 *		This error indicates that all the domains that set aside for querying
 *		are used up by other outstanding query request.
 *
 *	GCC_INVALID_QUERY_TAG
 *		The query response tag specified in the query response is not valid.
 *
 *	GCC_FAILURE_CREATING_DOMAIN
 *		Many requests such as GCCConferenceCreateRequest require that an MCS
 *		domain be created.  If the request to MCS fails this will be returned.
 *
 *	GCC_CONFERENCE_NOT_ESTABLISHED
 *		If a request is made to a conference before it is established, this
 *		error value will be returned.
 *
 *	GCC_INVALID_PASSWORD
 *		The password passed in the request is not valid.  This usually means
 *		that a numeric string needs to be specified.
 *		
 *	GCC_INVALID_MCS_USER_ID
 *		All MCS User IDs must have a value greater than 1000.
 *
 *	GCC_INVALID_JOIN_RESPONSE_TAG
 *		The join response tag specified in the join response is not valid.
 *	
 *	GCC_TRANSPORT_NOT_READY
 *		Request was made to a transport before it was ready to process it.
 *
 *	GCC_DOMAIN_PARAMETERS_UNACCEPTABLE
 *		The specified domain parameters do not fit within the range allowable
 *		by GCC and MCS.
 *
 *	GCC_APP_NOT_ENROLLED
 *		Occurs if a request is made by an Application Protocol Entity to a
 *		conference before the "APE" is enrolled.
 *
 *	GCC_NO_GIVE_RESPONSE_PENDING
 *		This will occur if a conductor Give Request is issued before a 
 *		previously pending conductor Give Response has been processed.
 *
 *	GCC_BAD_NETWORK_ADDRESS_TYPE
 *		An illegal network address type was passed in.  Valid types are	
 *		GCC_AGGREGATED_CHANNEL_ADDRESS, GCC_TRANSPORT_CONNECTION_ADDRESS and
 *		GCC_NONSTANDARD_NETWORK_ADDRESS.
 *
 *	GCC_BAD_OBJECT_KEY
 *		The object key passed in is invalid.
 *
 *	GCC_INVALID_CONFERENCE_NAME
 *		The conference name passed in is not a valid conference name.
 *
 *	GCC_INVALID_CONFERENCE_MODIFIER
 *		The conference modifier passed in is not a valid conference name.
 *
 *	GCC_BAD_SESSION_KEY
 *		The session key passed in was not valid.
 *				  
 *	GCC_BAD_CAPABILITY_ID
 *		The capability ID passed into the request is not valid.
 *
 *	GCC_BAD_REGISTRY_KEY
 *		The registry key passed into the request is not valid.
 *
 *	GCC_BAD_NUMBER_OF_APES
 *		Zero was passed in for the number of APEs in the invoke request. Zero
 *		is illegal here.
 *
 *	GCC_BAD_NUMBER_OF_HANDLES
 *		A number < 1 or	> 1024 was passed into the allocate handle request.
 *		  
 *	GCC_ALREADY_REGISTERED
 *		The user application attempting to register itself has already 
 *		registered.
 *			  
 *	GCC_APPLICATION_NOT_REGISTERED	  
 *		The user application attempting to make a request to GCC has not 
 *		registered itself with GCC.
 *
 *	GCC_BAD_CONNECTION_HANDLE_POINTER
 *		A NULL connection handle pointer was passed in.
 * 
 *	GCC_INVALID_NODE_TYPE
 *		A node type value other than GCC_TERMINAL, GCC_MULTIPORT_TERMINAL or
 *		GCC_MCU was passed in.
 *
 *	GCC_INVALID_ASYMMETRY_INDICATOR
 *		An asymetry type other than GCC_ASYMMETRY_CALLER, GCC_ASYMMETRY_CALLED
 *		or GCC_ASYMMETRY_UNKNOWN was passed into the request.
 *	
 *	GCC_INVALID_NODE_PROPERTIES
 *		A node property other than GCC_PERIPHERAL_DEVICE, GCC_MANAGEMENT_DEVICE,
 *		GCC_PERIPHERAL_AND_MANAGEMENT_DEVICE or	
 *		GCC_NEITHER_PERIPHERAL_NOR_MANAGEMENT was passed into the request.
 *		
 *	GCC_BAD_USER_DATA
 *		The user data list passed into the request was not valid.
 *				  
 *	GCC_BAD_NETWORK_ADDRESS
 *		There was something wrong with the actual network address portion of
 *		the passed in network address.
 *
 *	GCC_INVALID_ADD_RESPONSE_TAG
 *		The add response tag passed in the response does not match any add
 *		response tag passed back in the add indication.
 *			  
 *	GCC_BAD_ADDING_NODE
 *		You can not request that the adding node be the node where the add
 *		request is being issued.
 *				  
 *	GCC_FAILURE_ATTACHING_TO_MCS
 *		Request failed because GCC could not create a user attachment to MCS.
 *	  
 *	GCC_INVALID_TRANSPORT_ADDRESS	  
 *		The transport address specified in the request (usually the called
 *		address) is not valid.  This will occur when the transport stack
 *		detects an illegal transport address.
 *
 *	GCC_INVALID_PARAMETER
 *		This indicates an illegal parameter is passed into the GCC function
 *		call.
 *
 *	GCC_COMMAND_NOT_SUPPORTED
 *		This indicates that the user application has attempted to invoke an
 *		GCC service that is not yet supported.
 *
 *	GCC_UNSUPPORTED_ERROR
 *		An error was returned from a request to MCS that is not recognized 
 *		by GCC.
 *
 *	GCC_TRANSMIT_BUFFER_FULL
 *		Request can not be processed because the transmit buffer is full.
 *		This usually indicates a problem with the shared memory portal in the
 *		Win32 client.
 *		
 *	GCC_INVALID_CHANNEL
 *		The channel ID passed into the request is not a valid MCS channel ID
 *		(zero is not valid).
 *
 *	GCC_INVALID_MODIFICATION_RIGHTS
 *		The modification rights passed in in not one of the enumerated types
 *		supported.
 *
 *	GCC_INVALID_REGISTRY_ITEM
 *		The registry item passed in is not one of the valid enumerated types.
 *
 *	GCC_INVALID_NODE_NAME
 *		The node name passed in is not valid.  Typically this means that it
 *		is to long.
 *
 *	GCC_INVALID_PARTICIPANT_NAME
 *		The participant name passed in is not valid.  Typically this means that 
 *		it is to long.
 *		
 *	GCC_INVALID_SITE_INFORMATION
 *		The site information passed in is not valid.  Typically this means that 
 *		it is to long.
 *
 *	GCC_INVALID_NON_COLLAPSED_CAP
 *		The non-collapsed capability passed in is not valid.  Typically this 
 *		means that it is to long.
 *
 *	GCC_INVALID_ALTERNATIVE_NODE_ID
 *		Alternative node IDs can only be two characters long.
 */


/*
 *	This section defines the valid return values from MCS function calls.  Do
 *	not confuse this return value with the Result and Reason values defined
 *	by T.125 (which are discussed later).  These values are returned directly
 *	from the call to the API entry point, letting you know whether or not the
 *	request for service was successfully invoked.  The Result and Reason
 *	codes are issued as part of an indication or confirm which occurs
 *	asynchronously to the call that causes it.
 *
 *	All MCS function calls return type MCSError.  Its valid values are as
 *	follows:
 *
 *	MCS_NO_ERROR
 *		This means that the request was successfully invoked.  It does NOT
 *		mean that the service has been successfully completed.  Remember that
 *		all MCS calls are non-blocking.  This means that each request call
 *		begins the process, and if necessary, a subsequent indication or
 *		confirm will result.  By convention, if ANY MCS call returns a value
 *		other than this, something went wrong.  Note that this value should
 *		also be returned to MCS during a callback if the application processes
 *		the callback successfully.
 *	MCS_COMMAND_NOT_SUPPORTED
 *		This indicates that the user application has attempted to invoke an
 *		MCS service that is not yet supported.  Note that this return value
 *		will NEVER be returned from the release version of MCS, and is left
 *		defined only for backward compatibility.  It WILL be removed in a future
 *		version of MCS.
 *	MCS_NOT_INITIALIZED
 *		The application has attempted to use MCS services before MCS has been
 *		initialized.  It is necessary for the node controller (or whatever
 *		application is serving as the node controller), to initialize MCS before
 *		it is called upon to perform any services.
 *	MCS_ALREADY_INITIALIZED
 *		The application has attempted to initialize MCS when it is already
 *		initialized.
 *	MCS_NO_TRANSPORT_STACKS
 *		This indicates that MCS did not load the TCP transport stack during
 *		initialization.  This is now considered an error.  MCS can not
 *		be used in a local only manner.  We no longer load other ransport stacks can also be loaded
 *		after initialization using the call MCSLoadTransport.  Note that when
 *		getting this return code during initialization, it IS necessary for the
 *		node controller to cleanly shut down MCS.
 *	MCS_DOMAIN_ALREADY_EXISTS
 *		The application has attempted to create a domain that already exists.
 *	MCS_NO_SUCH_DOMAIN
 *		The application has attempted to use a domain that has not yet been
 *		created.
 *	MCS_USER_NOT_ATTACHED
 *		This indicates that the application has issued an MCS_AttachRequest,
 *		and then tried to use the returned handle before receiving an
 *		MCS_ATTACH_USER_CONFIRM (which essentially validates the handle).
 *	MCS_NO_SUCH_USER
 *		An MCS primitive has been invoked with an unknown user handle.
 *	MCS_TRANSMIT_BUFFER_FULL
 *		This indicates that the call failed due to an MCS resource shortage.
 *		This will typically occur when there is a LOT of traffic through the
 *		MCS layer.  It simply means that MCS could not process the request at
 *		this time.  It is the responsibility of the application to retry at a
 *		later time.
 *	MCS_NO_SUCH_CONNECTION
 *		An MCS primitive has been invoked with an unknown connection handle.
 *	MCS_DOMAIN_NOT_HIERARCHICAL
 *		An attempt has been made to create an upward connection from a local
 *		domain that already has an upward connection.
 *	MCS_INVALID_ADDRESS_PREFIX
 *		The called address parameter of MCSConnectProviderRequest does not
 *		contain a recognized prefix.  MCS relies on the prefix to know which
 *		transport stack to invoke.
 *	MCS_ALLOCATION_FAILURE
 *		The request could not be successfully invoked due to a memory allocation
 *		failure.
 *	MCS_INVALID_PARAMETER
 *		One of the parameters to the request is invalid.
 *	MCS_CALLBACK_NOT_PROCESSED
 *		This value should be returned to MCS during a callback if the
 *		application cannot process the callback at that time.  This provides
 *		a form of flow control between the application and MCS.  When MCS
 *		receives this return value during a callback, it will retry the same
 *		callback again during the next time slice.  Note that the user
 *		application can refuse a callback as many times as it wishes, but the
 *		programmer should be aware that this will cause MCS to "back up".
 *		Eventually this back pressure will cause MCS to refuse data from the
 *		transport layer (and so on).  Information should always be processed
 *		in a timely manner in order to insure smooth operation.
 *	MCS_DOMAIN_MERGING
 *		This value indicates that the call failed because of a domain merger
 *		that is in progress.  This will happen at the former Top Provider of
 *		the lower domain while it is still merging into the upper domain.
 *	MCS_TRANSPORT_NOT_READY
 *		This is returned from MCSConnectProviderRequest when the transport
 *		stack could not create the connection because it was not ready for the
 *		request.  This will usually happen if the request follows too closely
 *		behind the initialization of the transport stack (while it is still
 *		actively initializing).
 *	MCS_DOMAIN_PARAMETERS_UNACCEPTABLE
 *		This is returned from MCSConnectProviderResponse when the inbound
 *		connection could not be accepted because of no overlap in acceptable
 *		domain parameters.  Each MCS provider has a set of minimum and maximum
 *		domain parameters for each domain.  When a connection is to be created,
 *		the negotiated values will fall within the overlap of the two sets.
 *		If there is no overlap, then the connection cannot be accepted.  Note
 *		that this error does NOT refer to the acceptability of the domain
 *		parameters passed into the MCSConnectProviderResponse call.
 */

typedef	enum tagT120Error
{
	// the first values have to remain unmodified, because they match
	// MCS error values.
	T120_NO_ERROR			            = 0,

	T120_COMMAND_NOT_SUPPORTED,
	T120_NOT_INITIALIZED,
	T120_ALREADY_INITIALIZED,
	T120_NO_TRANSPORT_STACKS,
	T120_INVALID_ADDRESS_PREFIX,
	T120_ALLOCATION_FAILURE,
	T120_INVALID_PARAMETER,
	T120_TRANSPORT_NOT_READY,
	T120_DOMAIN_PARAMETERS_UNACCEPTABLE,
	T120_SECURITY_FAILED,
	
	// the following values can be modified in their orders
	GCC_NO_SUCH_APPLICATION             = 100,
	GCC_INVALID_CONFERENCE,
	GCC_CONFERENCE_ALREADY_EXISTS,
	GCC_INVALID_TRANSPORT,
	GCC_FAILURE_CREATING_PACKET,
	GCC_QUERY_REQUEST_OUTSTANDING,
	GCC_INVALID_QUERY_TAG,
	GCC_FAILURE_CREATING_DOMAIN,
	GCC_CONFERENCE_NOT_ESTABLISHED,
	GCC_INVALID_PASSWORD,
	GCC_INVALID_MCS_USER_ID,
	GCC_INVALID_JOIN_RESPONSE_TAG,
	GCC_APP_NOT_ENROLLED,
	GCC_NO_GIVE_RESPONSE_PENDING,
	GCC_BAD_NETWORK_ADDRESS_TYPE,
	GCC_BAD_OBJECT_KEY,	    
	GCC_INVALID_CONFERENCE_NAME,
	GCC_INVALID_CONFERENCE_MODIFIER,
	GCC_BAD_SESSION_KEY,
	GCC_BAD_CAPABILITY_ID,
	GCC_BAD_REGISTRY_KEY,
	GCC_BAD_NUMBER_OF_APES,
	GCC_BAD_NUMBER_OF_HANDLES,
	GCC_ALREADY_REGISTERED,
	GCC_APPLICATION_NOT_REGISTERED,
	GCC_BAD_CONNECTION_HANDLE_POINTER,
	GCC_INVALID_NODE_TYPE,
	GCC_INVALID_ASYMMETRY_INDICATOR,
	GCC_INVALID_NODE_PROPERTIES,
	GCC_BAD_USER_DATA,
	GCC_BAD_NETWORK_ADDRESS,
	GCC_INVALID_ADD_RESPONSE_TAG,
	GCC_BAD_ADDING_NODE,
	GCC_FAILURE_ATTACHING_TO_MCS,
	GCC_INVALID_TRANSPORT_ADDRESS,
	GCC_UNSUPPORTED_ERROR,
	GCC_TRANSMIT_BUFFER_FULL,
	GCC_INVALID_CHANNEL,
	GCC_INVALID_MODIFICATION_RIGHTS,
	GCC_INVALID_REGISTRY_ITEM,
	GCC_INVALID_NODE_NAME,
	GCC_INVALID_PARTICIPANT_NAME,
	GCC_INVALID_SITE_INFORMATION,
	GCC_INVALID_NON_COLLAPSED_CAP,
	GCC_INVALID_ALTERNATIVE_NODE_ID,
	GCC_INSUFFICIENT_PRIVILEGE,
	GCC_APPLET_EXITING,
	GCC_APPLET_CANCEL_EXIT,
	GCC_NYI,
	T120_POLICY_PROHIBIT,

	// the following values can be modified in their orders
	MCS_DOMAIN_ALREADY_EXISTS           = 200,
	MCS_NO_SUCH_DOMAIN,
	MCS_USER_NOT_ATTACHED,
	MCS_NO_SUCH_USER,
	MCS_TRANSMIT_BUFFER_FULL,
	MCS_NO_SUCH_CONNECTION,
	MCS_DOMAIN_NOT_HIERARCHICAL,
	MCS_CALLBACK_NOT_PROCESSED,
	MCS_DOMAIN_MERGING,
	MCS_DOMAIN_NOT_REGISTERED,
	MCS_SIZE_TOO_BIG,
	MCS_BUFFER_NOT_ALLOCATED,
	MCS_MORE_CALLBACKS,

    T12_ERROR_CHECK_T120_RESULT         = 299,
	INVALID_T120_ERROR                  = 300,
}
    T120Error, GCCError, *PGCCError, MCSError, *PMCSError;

#define GCC_NO_ERROR    T120_NO_ERROR
#define MCS_NO_ERROR    T120_NO_ERROR

#define GCC_COMMAND_NOT_SUPPORTED           T120_COMMAND_NOT_SUPPORTED
#define GCC_NOT_INITIALIZED                 T120_NOT_INITIALIZED
#define GCC_ALREADY_INITIALIZED             T120_ALREADY_INITIALIZED
#define GCC_NO_TRANSPORT_STACKS             T120_NO_TRANSPORT_STACKS
#define GCC_INVALID_ADDRESS_PREFIX          T120_INVALID_ADDRESS_PREFIX
#define GCC_ALLOCATION_FAILURE              T120_ALLOCATION_FAILURE
#define GCC_INVALID_PARAMETER               T120_INVALID_PARAMETER
#define GCC_TRANSPORT_NOT_READY             T120_TRANSPORT_NOT_READY
#define GCC_DOMAIN_PARAMETERS_UNACCEPTABLE  T120_DOMAIN_PARAMETERS_UNACCEPTABLE
#define GCC_SECURITY_FAILED                 T120_SECURITY_FAILED

#define MCS_COMMAND_NOT_SUPPORTED           T120_COMMAND_NOT_SUPPORTED
#define MCS_NOT_INITIALIZED                 T120_NOT_INITIALIZED
#define MCS_ALREADY_INITIALIZED             T120_ALREADY_INITIALIZED
#define MCS_NO_TRANSPORT_STACKS             T120_NO_TRANSPORT_STACKS
#define MCS_INVALID_ADDRESS_PREFIX          T120_INVALID_ADDRESS_PREFIX
#define MCS_ALLOCATION_FAILURE              T120_ALLOCATION_FAILURE
#define MCS_INVALID_PARAMETER               T120_INVALID_PARAMETER
#define MCS_TRANSPORT_NOT_READY             T120_TRANSPORT_NOT_READY
#define MCS_DOMAIN_PARAMETERS_UNACCEPTABLE  T120_DOMAIN_PARAMETERS_UNACCEPTABLE
#define MCS_SECURITY_FAILED                 T120_SECURITY_FAILED


//
// Token Status
//

typedef AppletTokenStatus       T120TokenStatus, TokenStatus;
#define TOKEN_NOT_IN_USE        APPLET_TOKEN_NOT_IN_USE
#define TOKEN_SELF_GRABBED      APPLET_TOKEN_SELF_GRABBED
#define TOKEN_OTHER_GRABBED     APPLET_TOKEN_OTHER_GRABBED
#define TOKEN_SELF_INHIBITED    APPLET_TOKEN_SELF_INHIBITED
#define TOKEN_OTHER_INHIBITED   APPLET_TOKEN_OTHER_INHIBITED
#define TOKEN_SELF_RECIPIENT    APPLET_TOKEN_SELF_RECIPIENT
#define TOKEN_SELF_GIVING       APPLET_TOKEN_SELF_GIVING
#define TOKEN_OTHER_GIVING      APPLET_TOKEN_OTHER_GIVING


/*
**	MCSReason
**      The order is important because they are in the same order of those
**      defined in mcspdu.h.
**  GCCReason
**		When GCC issues an indication to a user application, it often includes a
**		reason parameter informing the user of why the activity is occurring.
*/
typedef	enum
{
    REASON_DOMAIN_DISCONNECTED 		            = 0,
    REASON_PROVIDER_INITIATED 		            = 1,
    REASON_TOKEN_PURGED 			            = 2,
    REASON_USER_REQUESTED 			            = 3,
    REASON_CHANNEL_PURGED 			            = 4,
    REASON_REMOTE_NO_SECURITY			        = 5,
    REASON_REMOTE_DOWNLEVEL_SECURITY		    = 6,
    REASON_REMOTE_REQUIRE_SECURITY		        = 7,
	REASON_AUTHENTICATION_FAILED				= 8,

	GCC_REASON_USER_INITIATED					= 100,
	GCC_REASON_UNKNOWN							= 101,
	GCC_REASON_NORMAL_TERMINATION				= 102,
	GCC_REASON_TIMED_TERMINATION				= 103,
	GCC_REASON_NO_MORE_PARTICIPANTS				= 104,
	GCC_REASON_ERROR_TERMINATION				= 105,
	GCC_REASON_ERROR_LOW_RESOURCES				= 106,
	GCC_REASON_MCS_RESOURCE_FAILURE				= 107,
	GCC_REASON_PARENT_DISCONNECTED				= 108,
	GCC_REASON_CONDUCTOR_RELEASE				= 109,
	GCC_REASON_SYSTEM_RELEASE					= 110,
	GCC_REASON_NODE_EJECTED						= 111,
	GCC_REASON_HIGHER_NODE_DISCONNECTED 		= 112,
	GCC_REASON_HIGHER_NODE_EJECTED				= 113,
	GCC_REASON_DOMAIN_PARAMETERS_UNACCEPTABLE	= 114,
	INVALID_GCC_REASON,
}
    T120Reason, Reason, *PReason, GCCReason, *PGCCReason;

/*
**	MCSResult
**      The order is important because they are in the same order of those
**      defined in mcspdu.h.
**	GCCResult
**		When a user makes a request of GCC, GCC often responds with a result,
**		letting the user know whether or not the request succeeded.
*/
typedef	enum
{
    T120_RESULT_SUCCESSFUL              = 0,

    RESULT_DOMAIN_MERGING               = 1,
    RESULT_DOMAIN_NOT_HIERARCHICAL      = 2,
    RESULT_NO_SUCH_CHANNEL              = 3,
    RESULT_NO_SUCH_DOMAIN               = 4,
    RESULT_NO_SUCH_USER                 = 5,
    RESULT_NOT_ADMITTED                 = 6,
    RESULT_OTHER_USER_ID                = 7,
    RESULT_PARAMETERS_UNACCEPTABLE      = 8,
    RESULT_TOKEN_NOT_AVAILABLE          = 9,
    RESULT_TOKEN_NOT_POSSESSED          = 10,
    RESULT_TOO_MANY_CHANNELS            = 11,
    RESULT_TOO_MANY_TOKENS              = 12,
    RESULT_TOO_MANY_USERS               = 13,
    RESULT_UNSPECIFIED_FAILURE          = 14,
    RESULT_USER_REJECTED                = 15,
    RESULT_REMOTE_NO_SECURITY           = 16,
    RESULT_REMOTE_DOWNLEVEL_SECURITY    = 17,
    RESULT_REMOTE_REQUIRE_SECURITY      = 18,
	RESULT_AUTHENTICATION_FAILED		= 19,

	GCC_RESULT_RESOURCES_UNAVAILABLE   			= 101,
	GCC_RESULT_INVALID_CONFERENCE	   			= 102,
	GCC_RESULT_INVALID_PASSWORD		   			= 103,
	GCC_RESULT_INVALID_CONVENER_PASSWORD		= 104,
	GCC_RESULT_SYMMETRY_BROKEN		   			= 105,
	GCC_RESULT_UNSPECIFIED_FAILURE	   			= 106,
	GCC_RESULT_NOT_CONVENER_NODE	   			= 107,
	GCC_RESULT_REGISTRY_FULL		   			= 108,
	GCC_RESULT_INDEX_ALREADY_OWNED 	   			= 109,
	GCC_RESULT_INCONSISTENT_TYPE 	   			= 110,
	GCC_RESULT_NO_HANDLES_AVAILABLE	   			= 111,
	GCC_RESULT_CONNECT_PROVIDER_FAILED 			= 112,
	GCC_RESULT_CONFERENCE_NOT_READY    			= 113,
	GCC_RESULT_USER_REJECTED		   			= 114,
	GCC_RESULT_ENTRY_DOES_NOT_EXIST    			= 115,
	GCC_RESULT_NOT_CONDUCTIBLE	   	   			= 116,
	GCC_RESULT_NOT_THE_CONDUCTOR	   			= 117,
	GCC_RESULT_NOT_IN_CONDUCTED_MODE   			= 118,
	GCC_RESULT_IN_CONDUCTED_MODE	   			= 119,
	GCC_RESULT_ALREADY_CONDUCTOR	   			= 120,
	GCC_RESULT_CHALLENGE_RESPONSE_REQUIRED		= 121,
	GCC_RESULT_INVALID_CHALLENGE_RESPONSE		= 122,
	GCC_RESULT_INVALID_REQUESTER				= 123,
	GCC_RESULT_ENTRY_ALREADY_EXISTS				= 124,	
	GCC_RESULT_INVALID_NODE						= 125,
	GCC_RESULT_INVALID_SESSION_KEY				= 126,
	GCC_RESULT_INVALID_CAPABILITY_ID			= 127,
	GCC_RESULT_INVALID_NUMBER_OF_HANDLES		= 128,	
	GCC_RESULT_CONDUCTOR_GIVE_IS_PENDING		= 129,
	GCC_RESULT_INCOMPATIBLE_PROTOCOL			= 130,
	GCC_RESULT_CONFERENCE_ALREADY_LOCKED		= 131,
	GCC_RESULT_CONFERENCE_ALREADY_UNLOCKED		= 132,
	GCC_RESULT_INVALID_NETWORK_TYPE				= 133,
	GCC_RESULT_INVALID_NETWORK_ADDRESS			= 134,
	GCC_RESULT_ADDED_NODE_BUSY					= 135,
	GCC_RESULT_NETWORK_BUSY						= 136,
	GCC_RESULT_NO_PORTS_AVAILABLE				= 137,
	GCC_RESULT_CONNECTION_UNSUCCESSFUL			= 138,
	GCC_RESULT_LOCKED_NOT_SUPPORTED    			= 139,
	GCC_RESULT_UNLOCK_NOT_SUPPORTED				= 140,
	GCC_RESULT_ADD_NOT_SUPPORTED				= 141,
	GCC_RESULT_DOMAIN_PARAMETERS_UNACCEPTABLE	= 142,
	GCC_RESULT_CANCELED                         = 143,
	GCC_RESULT_CONNECT_PROVIDER_REMOTE_NO_SECURITY          = 144,
	GCC_RESULT_CONNECT_PROVIDER_REMOTE_DOWNLEVEL_SECURITY   = 145,
	GCC_RESULT_CONNECT_PROVIDER_REMOTE_REQUIRE_SECURITY     = 146,
	GCC_RESULT_CONNECT_PROVIDER_AUTHENTICATION_FAILED		= 147,

	T120_RESULT_CHECK_T120_ERROR                = 148,
	INVALID_GCC_RESULT,
}
    T120Result, Result, *PResult, GCCResult, *PGCCResult;

#define RESULT_SUCCESSFUL           T120_RESULT_SUCCESSFUL
#define GCC_RESULT_SUCCESSFUL       T120_RESULT_SUCCESSFUL



//
//  T120 Messages (Control SAP and Applet SAP)
//

typedef enum
{
    /******************* NODE CONTROLLER CALLBACKS ***********************/
    
    /* Conference Create, Terminate related calls */
    GCC_CREATE_INDICATION                   = 0,
    GCC_CREATE_CONFIRM                      = 1,
    GCC_QUERY_INDICATION                    = 2,
    GCC_QUERY_CONFIRM                       = 3,
    GCC_JOIN_INDICATION                     = 4,
    GCC_JOIN_CONFIRM                        = 5,
    GCC_INVITE_INDICATION                   = 6,
    GCC_INVITE_CONFIRM                      = 7,
    GCC_ADD_INDICATION                      = 8,
    GCC_ADD_CONFIRM                         = 9,
    GCC_LOCK_INDICATION                     = 10,
    GCC_LOCK_CONFIRM                        = 11,
    GCC_UNLOCK_INDICATION                   = 12,
    GCC_UNLOCK_CONFIRM                      = 13,
    GCC_LOCK_REPORT_INDICATION              = 14,
    GCC_DISCONNECT_INDICATION               = 15,
    GCC_DISCONNECT_CONFIRM                  = 16,
    GCC_TERMINATE_INDICATION                = 17,
    GCC_TERMINATE_CONFIRM                   = 18,
    GCC_EJECT_USER_INDICATION               = 19,
    GCC_EJECT_USER_CONFIRM                  = 20,
    GCC_TRANSFER_INDICATION                 = 21,
    GCC_TRANSFER_CONFIRM                    = 22,
    GCC_APPLICATION_INVOKE_INDICATION       = 23,        /* SHARED CALLBACK */
    GCC_APPLICATION_INVOKE_CONFIRM          = 24,        /* SHARED CALLBACK */
    GCC_SUB_INITIALIZED_INDICATION          = 25,

    /* Conference Roster related callbacks */
    GCC_ANNOUNCE_PRESENCE_CONFIRM           = 26,
    GCC_ROSTER_REPORT_INDICATION            = 27,        /* SHARED CALLBACK */
    GCC_ROSTER_INQUIRE_CONFIRM              = 28,        /* SHARED CALLBACK */

    /* Conductorship related callbacks */
    GCC_CONDUCT_ASSIGN_INDICATION           = 29,        /* SHARED CALLBACK */
    GCC_CONDUCT_ASSIGN_CONFIRM              = 30,
    GCC_CONDUCT_RELEASE_INDICATION          = 31,        /* SHARED CALLBACK */
    GCC_CONDUCT_RELEASE_CONFIRM             = 32,
    GCC_CONDUCT_PLEASE_INDICATION           = 33,
    GCC_CONDUCT_PLEASE_CONFIRM              = 34,
    GCC_CONDUCT_GIVE_INDICATION             = 35,
    GCC_CONDUCT_GIVE_CONFIRM                = 36,
    GCC_CONDUCT_INQUIRE_CONFIRM             = 37,        /* SHARED CALLBACK */
    GCC_CONDUCT_ASK_INDICATION              = 38,
    GCC_CONDUCT_ASK_CONFIRM                 = 39,
    GCC_CONDUCT_GRANT_INDICATION            = 40,        /* SHARED CALLBACK */
    GCC_CONDUCT_GRANT_CONFIRM               = 41,

    /* Miscellaneous Node Controller callbacks */
    GCC_TIME_REMAINING_INDICATION           = 42,
    GCC_TIME_REMAINING_CONFIRM              = 43,
    GCC_TIME_INQUIRE_INDICATION             = 44,
    GCC_TIME_INQUIRE_CONFIRM                = 45,
    GCC_CONFERENCE_EXTEND_INDICATION        = 46,
    GCC_CONFERENCE_EXTEND_CONFIRM           = 47,
    GCC_ASSISTANCE_INDICATION               = 48,
    GCC_ASSISTANCE_CONFIRM                  = 49,
    GCC_TEXT_MESSAGE_INDICATION             = 50,
    GCC_TEXT_MESSAGE_CONFIRM                = 51,

    /***************** USER APPLICATION CALLBACKS *******************/

    /* Application Roster related callbacks */
    GCC_PERMIT_TO_ENROLL_INDICATION         = 52,
    GCC_ENROLL_CONFIRM                      = 53,
    GCC_APP_ROSTER_REPORT_INDICATION        = 54,        /* SHARED CALLBACK */
    GCC_APP_ROSTER_INQUIRE_CONFIRM          = 55,        /* SHARED CALLBACK */

    /* Application Registry related callbacks */
    GCC_REGISTER_CHANNEL_CONFIRM            = 56,
    GCC_ASSIGN_TOKEN_CONFIRM                = 57,
    GCC_RETRIEVE_ENTRY_CONFIRM              = 58,
    GCC_DELETE_ENTRY_CONFIRM                = 59,
    GCC_SET_PARAMETER_CONFIRM               = 60,
    GCC_MONITOR_INDICATION                  = 61,
    GCC_MONITOR_CONFIRM                     = 62,
    GCC_ALLOCATE_HANDLE_CONFIRM             = 63,

    /****************** NON-Standard Primitives **********************/

    GCC_PERMIT_TO_ANNOUNCE_PRESENCE         = 100,    /*    Node Controller Callback */    
    GCC_CONNECTION_BROKEN_INDICATION        = 101,    /*    Node Controller Callback */
    GCC_FATAL_ERROR_SAP_REMOVED             = 102,    /*    Application Callback     */
    GCC_STATUS_INDICATION                   = 103,    /*    Node Controller Callback */
    GCC_TRANSPORT_STATUS_INDICATION         = 104,    /*    Node Controller Callback */

    T120_JOIN_SESSION_CONFIRM               = 120,

    /******************* MCS CALLBACKS ***********************/

    MCS_CONNECT_PROVIDER_INDICATION         = 200,
    MCS_CONNECT_PROVIDER_CONFIRM            = 201,
    MCS_DISCONNECT_PROVIDER_INDICATION      = 202,
    MCS_ATTACH_USER_CONFIRM                 = 203,
    MCS_DETACH_USER_INDICATION              = 204,
    MCS_CHANNEL_JOIN_CONFIRM                = 205,
    MCS_CHANNEL_LEAVE_INDICATION            = 206,
    MCS_CHANNEL_CONVENE_CONFIRM             = 207,
    MCS_CHANNEL_DISBAND_INDICATION          = 208,
    MCS_CHANNEL_ADMIT_INDICATION            = 209,
    MCS_CHANNEL_EXPEL_INDICATION            = 210,
    MCS_SEND_DATA_INDICATION                = 211,
    MCS_UNIFORM_SEND_DATA_INDICATION        = 212,
    MCS_TOKEN_GRAB_CONFIRM                  = 213,
    MCS_TOKEN_INHIBIT_CONFIRM               = 214,
    MCS_TOKEN_GIVE_INDICATION               = 215,
    MCS_TOKEN_GIVE_CONFIRM                  = 216,
    MCS_TOKEN_PLEASE_INDICATION             = 217,
    MCS_TOKEN_RELEASE_CONFIRM               = 218,
    MCS_TOKEN_TEST_CONFIRM                  = 219,
    MCS_TOKEN_RELEASE_INDICATION            = 220,
    MCS_TRANSMIT_BUFFER_AVAILABLE_INDICATION= 221,
    MCS_LAST_USER_MESSAGE                   = 222,

    /******************* Non-standard MCS CALLBACKS ***********************/
    
    MCS_TRANSPORT_STATUS_INDICATION         = 301,
}
    T120MessageType;



/*
 *	MCS_CONNECT_PROVIDER_INDICATION
 *
 *	Parameter:
 *		PConnectProviderIndication
 *			This is a pointer to a structure that contains all necessary
 *			information about an incoming connection.
 *
 *	Functional Description:
 *		This indication is sent to the node controller when an incoming
 *		connection is detected.  The node controller should respond by calling
 *		MCSConnectProviderResponse indicating whether or not the connection
 *		is to be accepted.
 */

/*
 *	MCS_CONNECT_PROVIDER_CONFIRM
 *
 *	Parameter:
 *		PConnectProviderConfirm
 *			This is a pointer to a structure that contains all necessary
 *			information about an outgoing connection.
 *
 *	Functional Description:
 *		This confirm is sent to the node controller in response to a previous
 *		call to MCSConnectProviderRequest.  It informs the node controller
 *		of when the new connection is available for use, or that the
 *		connection could not be established (or that it was rejected by the
 *		remote site).
 */

/*
 *	MCS_DISCONNECT_PROVIDER_INDICATION
 *
 *	Parameter:
 *		PDisconnectProviderIndication
 *			This is a pointer to a structure that contains all necessary
 *			information about a connection that has been lost.
 *
 *	Functional Description:
 *		This indication is sent to the node controller whenever a connection
 *		is lost.  This essentially tells the node controller that the contained
 *		connection handle is no longer valid.
 */

/*
 *	MCS_ATTACH_USER_CONFIRM
 *
 *	Parameter:
 *		(LOWUSHORT) UserID
 *			If the result is success, then this is the newly assigned user ID.
 *			If the result is failure, then this field is undefined.
 *		(HIGHUSHORT) Result
 *			This is the result of the attach user request.
 *
 *	Functional Description:
 *		This confirm is sent to a user application in response to a previous
 *		call to MCS_AttachRequest.  It contains the result of that service
 *		request.  If successful, it also contains the user ID that has been
 *		assigned to that attachment.
 */

/*
 *	MCS_DETACH_USER_INDICATION
 *
 *	Parameter:
 *		(LOWUSHORT) UserID
 *			This is the user ID of the user that is detaching.
 *		(HIGHUSHORT) Reason
 *			This is the reason for the detachment.
 *
 *	Functional Description:
 *		This indication is sent to the user application whenever a user detaches
 *		from the domain.  This is sent to ALL remaining users in the domain
 *		automatically.  Note that if the user ID contained in this indication
 *		is the same as that of the application receiving it, the application is
 *		essentially being told that it has been kicked out of the conference.
 *		The user handle and user ID are no longer valid in this case.  It is the
 *		responsibility of the application to recognize when this occurs.
 */

/*
 *	MCS_CHANNEL_JOIN_CONFIRM
 *
 *	Parameter:
 *		(LOWUSHORT) ChannelID
 *			This is the channel that has been joined.
 *		(HIGHUSHORT) Result
 *			This is the result of the join request.
 *
 *	Functional Description:
 *		This confirm is sent to a user application in response to a previous
 *		call to MCSChannelJoinRequest.  It lets the application know if the
 *		join was successful for a particular channel.  Furthermore, if the
 *		join request was for channel 0 (zero), then the ID of the assigned
 *		channel is contained in this confirm.
 */

/*
 *	MCS_CHANNEL_LEAVE_INDICATION
 *
 *	Parameter:
 *		(LOWUSHORT) ChannelID
 *			This is the channel that has been left or is being told to leave.
 *		(HIGHUSHORT) Reason
 *			This is the reason for the leave.
 *
 *	Functional Description:
 *		This indication is sent to a user application when a domain merger has
 *		caused a channel to be purged from the lower domain.  This informs the
 *		the user that it is no longer joined to the channel.
 */

/*
 *	MCS_CHANNEL_CONVENE_CONFIRM
 *
 *	Parameter:
 *		(LOWUSHORT) ChannelID
 *			This is the private channel that is being convened.
 *		(HIGHUSHORT) Result
 *			This is the result of the convene request.
 *
 *	Functional Description:
 *		This confirm is sent to a user application in response to a previous
 *		call to MCSChannelConveneRequest.  It lets the application know whether
 *		or not the convene request was successful, and if so, what the channel
 *		number is.
 */

/*
 *	MCS_CHANNEL_DISBAND_INDICATION
 *
 *	Parameter:
 *		(LOWUSHORT) ChannelID
 *			This is the private channel that is being disbanded.
 *		(HIGHUSHORT) Reason
 *			This is the reason for the disband.
 *
 *	Functional Description:
 *		This indication is sent to a user application when a private channel
 *		that it convened is disbanded by MCS.  This is sent to only the channel
 *		manager (all other members of the private channel will receive an
 *		MCS_CHANNEL_EXPEL_INDICATION).
 */

/*
 *	MCS_CHANNEL_ADMIT_INDICATION
 *
 *	Parameter:
 *		(LOWUSHORT) ChannelID
 *			This is the private channel that the user is being admitted to.
 *		(HIGHUSHORT) UserID
 *			This is the User ID of the manager of this private channel.
 *
 *	Functional Description:
 *		This indication is sent to a user application when it is admitted to
 *		a private channel (its User ID is added to the authorized user list).
 *		This lets the user know that it is now allowed to use the private
 *		channel.
 */

/*
 *	MCS_CHANNEL_EXPEL_INDICATION
 *
 *	Parameter:
 *		(LOWUSHORT) ChannelID
 *			This is the private channel that the user is being expelled from.
 *		(HIGHUSHORT) Reason
 *			This is the reason for the expel.
 *
 *	Functional Description:
 *		This indication is sent to a user application when it is expelled from
 *		a private channel (its User ID is removed from the authorized user
 *		list).  This lets the user know that it is no longer allowed to use
 *		the private channel.
 */

/*
 *	MCS_SEND_DATA_INDICATION
 *
 *	Parameter:
 *		PSendData
 *			This is a pointer to a SendData structure that contains all
 *			information about the data received.
 *
 *	Functional Description:
 *		This indication is sent to a user application when data is received
 *		by the local MCS provider on a channel to which the user is joined.
 */

/*
 *	MCS_UNIFORM_SEND_DATA_INDICATION
 *
 *	Parameter:
 *		PSendData
 *			This is a pointer to a SendData structure that contains all
 *			information about the data received.
 *
 *	Functional Description:
 *		This indication is sent to a user application when data is received
 *		by the local MCS provider on a channel to which the user is joined.
 */

/*
 *	MCS_TOKEN_GRAB_CONFIRM
 *
 *	Parameter:
 *		(LOWUSHORT) TokenID
 *			This is the ID of the token that the user application has attempted
 *			to grab.
 *		(HIGHUSHORT) Result
 *			This is the result of the token grab operation.  This will be
 *			RESULT_SUCCESSFUL if the token was grabbed.
 *
 *	Functional Description:
 *		This confirm is sent to a user application in response to a previous
 *		call to MCSTokenGrabRequest.  It lets the application know if the grab
 *		request was successful or not.
 */

/*
 *	MCS_TOKEN_INHIBIT_CONFIRM
 *
 *	Parameter:
 *		(LOWUSHORT) TokenID
 *			This is the ID of the token that the user application has attempted
 *			to inhibit.
 *		(HIGHUSHORT) Result
 *			This is the result of the token inhibit operation.  This will be
 *			RESULT_SUCCESSFUL if the token was inhibited.
 *
 *	Functional Description:
 *		This confirm is sent to a user application in response to a previous
 *		call to MCSTokenInhibitRequest.  It lets the application know if the
 *		inhibit request was successful or not.
 */

/*
 *	MCS_TOKEN_GIVE_INDICATION
 *
 *	Parameter:
 *		(LOWUSHORT) TokenID
 *			This is the ID of the token being offered to another user.
 *		(HIGHUSHORT) UserID
 *			This is the User ID of the user that is attempting to give the
 *			token away.
 *
 *	Functional Description:
 *		This indication is sent to a user application when another user in the
 *		domain attempts to give a token to it.  The user application should
 *		respond by calling MCSTokenGiveResponse indicating whether or not the
 *		token was accepted.
 */

/*
 *	MCS_TOKEN_GIVE_CONFIRM
 *
 *	Parameter:
 *		(LOWUSHORT) TokenID
 *			This is the ID of the token being offered to another user.
 *		(HIGHUSHORT) Result
 *			This is the result of the token give operation.  This will be
 *			RESULT_SUCCESSFUL if the token was accepted.
 *
 *	Functional Description:
 *		This confirm is sent to a user application in response to a previous
 *		call to MCSTokenGiveRequest (which in turn will cause another user to
 *		call MCSTokenGiveResponse).  The result code will inform the user
 *		as to whether or not the token was accepted.
 */

/*
 *	MCS_TOKEN_PLEASE_INDICATION
 *
 *	Parameter:
 *		(LOWUSHORT) TokenID
 *			This is the ID of the token that the user application would like to
 *			gain possesion of.
 *		(HIGHUSHORT) UserID
 *			This is the User ID of the user that is asking to receive ownership
 *			of a token.
 *
 *	Functional Description:
 *		This indication is sent to all owners (grabbers or inhibitors) of a
 *		token when a user issues an MCSTokenPleaseRequest.  This allows a user
 *		to "ask" for possession of a token without having to know exactly
 *		who currently owns it (MCS will route this indication appropriately).
 */

/*
 *	MCS_TOKEN_RELEASE_CONFIRM
 *
 *	Parameter:
 *		(LOWUSHORT) TokenID
 *			This is the ID of the token that the user application has attempted
 *			to release.
 *		(HIGHUSHORT) Result
 *			This is the result of the token release operation.  This will be
 *			RESULT_SUCCESSFUL if the token was released.
 *
 *	Functional Description:
 *		This confirm is sent to a user application in response to a previous
 *		call to MCSTokenReleaseRequest.  It lets the application know if the
 *		release request was successful or not.
 */

/*
 *	MCS_TOKEN_TEST_CONFIRM
 *
 *	Parameter:
 *		(LOWUSHORT) TokenID
 *			This is the ID of the token that the user application is testing.
 *		(HIGHUSHORT) TokenStatus
 *			This is the status of that token.
 *
 *	Functional Description:
 *		This confirm is sent to a user application in response to a previous
 *		call to MCSTokenTestRequest.  It lets the application know the current
 *		state of the specified token.
 */

/*
 *	MCS_TOKEN_RELEASE_INDICATION
 *
 *	Parameter:
 *		(LOWUSHORT) TokenID
 *			This is the ID of the token that is being taken away from its
 *			current owner.
 *		(HIGHUSHORT) Reason
 *			This is the reason that the token is being taken away from its
 *			owner.
 *
 *	Functional Description:
 *		This indication is sent to a user application when a domain merger has
 *		caused a token to be purged from the lower domain.  This tells the
 *		user that a token that it used to own has been taken away.
 */

/*
 *	MCS_MERGE_DOMAIN_INDICATION
 *
 *	Parameter:
 *		(LOWUSHORT) MergeStatus
 *			The is the status of the merge.  This informs the applications of
 *			whether the merge is just starting, or whether it is complete.
 *
 *	Functional Description:
 *		This indication is sent to the application when a provider begins
 *		merging its information base upward.  It informs the application that
 *		all domain activity is temporarily suspended.  It is sent again when the
 *		merge operation is complete, letting the application know that domain
 *		activity is once again valid.
 */

/*
 *  MCS_TRANSPORT_STATUS_INDICATION
 *
 *	This primitive is non-standard, and is issed through MCS by a transport
 *	stack when a state change occurs.  MCS merely passes the information
 *	through to the node controller.  This primitive will NOT be received by
 *	any user attachment.
 */


#endif // _T120_TYPE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\remdsk\rds\h\utf8str.h ===
#ifndef _UTF8STR_H_
#define _UTF8STR_H_

class CUTF8String
{
public:
	CUTF8String(LPCWSTR pcwszUnicode) :
		m_pwszUnicode	((LPWSTR) pcwszUnicode),
		m_pszUTF8		(NULL),
		m_eAlloc		(ALLOC_NONE),
		m_hr			(S_OK) { };
	CUTF8String(LPCSTR pcszUTF8) :
		m_pszUTF8		((LPSTR) pcszUTF8),
		m_pwszUnicode	(NULL),
		m_eAlloc		(ALLOC_NONE),
		m_hr			(S_OK) { };
	~CUTF8String();

	VOID AssignString(LPCSTR pcszUTF8) {
									delete m_pwszUnicode;
									m_pwszUnicode = NULL;
									m_eAlloc = ALLOC_NONE;
									m_hr = S_OK;
									m_pszUTF8 = (LPSTR) pcszUTF8; };

	VOID AssignString(LPCWSTR pcwszUnicode) {
									delete m_pszUTF8;
									m_pszUTF8 = NULL;
									m_eAlloc = ALLOC_NONE;
									m_hr = S_OK;
									m_pwszUnicode = (LPWSTR) pcwszUnicode; };

	operator LPWSTR();
	operator LPSTR();

	HRESULT GetError() { return m_hr; };
protected:
	VOID EncodeUTF8();
	VOID DecodeUTF8();

	HRESULT	m_hr;
	LPWSTR	m_pwszUnicode;
	LPSTR	m_pszUTF8;
	enum
	{
		ALLOC_NONE,
		ALLOC_UNICODE,
		ALLOC_UTF8,
	} m_eAlloc;
};

#endif // ! _UTF8STR_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\remdsk\rds\h\valid.h ===
/*
 * valid.h - Validation functions description.
 *
 * Taken from URL code by ChrisPi 9-11-95
 *
 */

#ifndef _VALID_H_
#define _VALID_H_

/* Prototypes
 *************/

/* valid.c */

extern BOOL IsValidHWND(HWND);

#ifdef DEBUG

extern BOOL IsValidFileCreationMode(DWORD);
extern BOOL IsValidHANDLE(HANDLE);
extern BOOL IsValidHEVENT(HANDLE);
extern BOOL IsValidHFILE(HANDLE);
extern BOOL IsValidHGLOBAL(HGLOBAL);
extern BOOL IsValidHMENU(HMENU);
extern BOOL IsValidHICON(HICON);
extern BOOL IsValidHINSTANCE(HINSTANCE);
extern BOOL IsValidHKEY(HKEY);
extern BOOL IsValidHMODULE(HMODULE);
extern BOOL IsValidHPROCESS(HANDLE);
extern BOOL IsValidHTEMPLATEFILE(HANDLE);
extern BOOL IsValidIconIndex(HRESULT, LPCTSTR, UINT, int);
extern BOOL IsValidPCFILETIME(PCFILETIME);
extern BOOL IsValidPCPOINT(PCPOINT);
extern BOOL IsValidPCPOINTL(PCPOINTL);
extern BOOL IsValidPCSECURITY_ATTRIBUTES(PCSECURITY_ATTRIBUTES);
extern BOOL IsValidPCWIN32_FIND_DATA(PCWIN32_FIND_DATA);
extern BOOL IsValidPathResult(HRESULT, LPCTSTR, UINT);
extern BOOL IsValidExtension(LPCTSTR);
extern BOOL IsValidRegistryValueType(DWORD);
extern BOOL IsValidShowCmd(int);
extern BOOL IsValidHotkey(WORD);

extern BOOL IsValidPath(LPCTSTR);
#if defined(UNICODE)
extern BOOL IsValidPathA(PCSTR);
#else // defined(UNICODE)
#define IsValidPathA IsValidPath
#endif // defined(UNICODE)

#ifdef _COMPARISONRESULT_DEFINED_

extern BOOL IsValidCOMPARISONRESULT(COMPARISONRESULT);

#endif   /* _COMPARISONRESULT_DEFINED_ */

#endif   /* DEBUG */

#endif /* _VALID_H_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\remdsk\rds\h\t120.h ===
/*
 *    t120.h
 *
 *    Copyright (c) 1994, 1995 by DataBeam Corporation, Lexington, KY
 *
 *    Abstract:
 *        This is the interface file for the communications infrastructure of
 *        T120.
 *
 *        Note that this is a "C" language interface in order to prevent any "C++"
 *        naming conflicts between different compiler manufacturers.  Therefore,
 *        if this file is included in a module that is being compiled with a "C++"
 *        compiler, it is necessary to use the following syntax:
 *
 *        extern "C"
 *        {
 *            #include "t120.h"
 *        }
 *
 *        This disables C++ name mangling on the API entry points defined within
 *        this file.
 *
 *    Author:
 *        blp
 *
 *    Caveats:
 *        none
 */
#ifndef __T120_H__
#define __T120_H__


/*
 *    These macros are used to pack 2 16-bit values into a 32-bit variable, and
 *    get them out again.
 */
#ifndef LOWUSHORT
    #define LOWUSHORT(ul)    (LOWORD(ul))
#endif

#ifndef HIGHUSHORT
    #define HIGHUSHORT(ul)    (HIWORD(ul))
#endif


#include "t120type.h"
#include "mcatmcs.h"
#include "gcc.h"

#endif // __T120_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\remdsk\rds\h\version.h ===
/****************************************************************************
 *                                                                          *
 *      VERSION.H        -- Version information for internal builds         *
 *                                                                          *
 *      This file is only modified by the official builder to update the         *
 *      VERSION, VER_PRODUCTVERSION and VER_PRODUCTVERSION_STR values            *
 *                                                                          *
 ****************************************************************************/

#if defined(WIN32) && !defined(SKIP_WINVER)
#include <winver.h>
#endif // defined(WIN32) && !defined(SKIP_WINVER)

/*--------------------------------------------------------------*/
/* the following entry should be phased out in favor of         */
/* VER_PRODUCTVERSION_STR, but is used in the shell today.      */
/*--------------------------------------------------------------*/

/*--------------------------------------------------------------*/
/* the following values should be modified by the official      */
/* builder for each build                                       */
/*--------------------------------------------------------------*/
#ifndef WIN32
#define VERSION                     "4.4.3385"
#endif
#define VER_PRODUCTVERSION_STR      "4.4.3385\0"
#define VER_PRODUCTVERSION           4,4,0,3385
#define VER_PRODUCTVERSION_REGSTR   "4,4,0,3385"
#define VERSIONBUILD_STR                  "3385"
#define VERSIONBUILD                       3385
#define VER_PRODUCTVERSION_DW       (0x04040000 | 3385)
#define VER_PRODUCTVERSION_W        (0x0400)
#define VER_PRODUCTVERSION_DW_REG   04,00,04,00,00,00,39,0D
#define VER_PRODUCTVERSION_DWSTR    L"04040D39"


/*--------------------------------------------------------------*/
/* the following section defines values used in the version     */
/* data structure for all files, and which do not change.       */
/*--------------------------------------------------------------*/


/* default is nodebug */
#ifndef DEBUG
#define VER_DEBUG                   0
#else
#define VER_DEBUG                   VS_FF_DEBUG
#endif

/* default is privatebuild */
#ifndef OFFICIAL
#define VER_PRIVATEBUILD            VS_FF_PRIVATEBUILD
#else
#define VER_PRIVATEBUILD            0
#endif

/* default is prerelease */
#ifndef FINAL
#define VER_PRERELEASE              VS_FF_PRERELEASE
#else
#define VER_PRERELEASE              0
#endif

#define VER_FILEFLAGSMASK           VS_FFI_FILEFLAGSMASK
#define VER_FILEFLAGS               (VER_PRIVATEBUILD|VER_PRERELEASE|VER_DEBUG)


/* Allow these to be re-defined */

#ifndef VER_FILEOS
#ifdef WIN32
#define VER_FILEOS                  VOS__WINDOWS32
#else // WIN32
#define VER_FILEOS                  VOS_DOS_WINDOWS16
#endif // WIN32
#endif // ! VER_FILEOS

#ifndef VER_COMPANYNAME_STR
#define VER_COMPANYNAME_STR         "Microsoft Corporation"
#endif

#ifndef VER_PRODUCTNAME_STR
#define VER_PRODUCTNAME_STR         "Windows\256 NetMeeting\256"
#endif

#ifndef VER_PRODUCTRELEASE_STR
#define VER_PRODUCTRELEASE_STR      "3.01"
#endif

#ifndef VER_LEGALTRADEMARKS_STR
#define VER_LEGALTRADEMARKS_STR     \
"Microsoft\256 , Windows\256 and NetMeeting\256 are registered trademarks of Microsoft Corporation in the U.S. and/or other countries."
#endif

#ifndef VER_COPYRIGHT_STR
#define VER_COPYRIGHT_STR       \
"Copyright \251 Microsoft Corporation 1996-1999"
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\remdsk\rds\nmutil\bstring.cpp ===
/*
 * BSTRING.CPP
 *
 * Implementation of the member functions of the BSTRING C++ class.  See
 * BSTRING.H for the class declaration and the implementation of the inline
 * member functions.
 *
 * Author:
 *		dannygl, 29 Oct 96
 */

#include "precomp.h"
#include <bstring.h>

// We don't support construction from an ANSI string in the Unicode build.
#if !defined(UNICODE)

BSTRING::BSTRING(LPCSTR lpcString)
{
    // Initialize the member pointer to NULL
    m_bstr = NULL;
    if (NULL == lpcString)
        return;

    // Compute the length of the required BSTR, including the null
    int cWC;

    cWC =  MultiByteToWideChar(CP_ACP, 0, lpcString, -1, NULL, 0);
    if (cWC <= 0)
    {
        return;
    };

    // Allocate the BSTR, including the null
    m_bstr = SysAllocStringLen(NULL, cWC - 1); // SysAllocStringLen adds another 1

    ASSERT(NULL != m_bstr);

    if (NULL == m_bstr)
    {
        return;
    }

    // Copy the string
    MultiByteToWideChar(CP_ACP, 0, lpcString, -1, (LPWSTR) m_bstr, cWC);

    // Verify that the string is null terminated
    ASSERT(0 == m_bstr[cWC - 1]);
}

#endif // !defined(UNICODE)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\remdsk\rds\nmutil\custring.cpp ===
// CUSTRING.CPP
//
// Implementation of the CUSTRING class, a lightweight class used to convert
// strings seamlessly between ANSI and Unicode.
//
// Derived from STRCORE.CPP.

#include "precomp.h"
#include <cstring.hpp>

#ifdef _DEBUG
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif


CUSTRING::CUSTRING(PCWSTR wszText) : 
	wszData((PWSTR)wszText), 
	szData(NULL), 
	bUnicodeNew(FALSE),
	bAnsiNew(FALSE)
{
	// AssignString;
}

CUSTRING::CUSTRING(PCSTR szText) : 
	szData((PSTR)szText), 
	wszData(NULL), 
	bUnicodeNew(FALSE),
	bAnsiNew(FALSE)
{
	// AssignString;
}

CUSTRING::~CUSTRING()
{
	if (bUnicodeNew) {
		delete wszData;
	}
	if (bAnsiNew) {
		delete szData;
	}
}

CUSTRING::operator PWSTR()
{ 
	if (szData && !wszData) {
		wszData = AnsiToUnicode(szData);
		bUnicodeNew = TRUE;
	}
	return wszData;
}

CUSTRING::operator PSTR()
{ 
	if (wszData && !szData) {
		szData = UnicodeToAnsi(wszData);
		bAnsiNew = TRUE;
	}
	return szData;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\remdsk\rds\nmutil\cstring.cpp ===
// CSTRING.CPP
//
// Based on the original MFC source file.

//
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) 1992-1995 Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#include "precomp.h"
#include <cstring.hpp>

#ifdef AFX_CORE1_SEG
#pragma code_seg(AFX_CORE1_SEG)
#endif

#ifdef _DEBUG
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// static class data, special inlines

// afxChNil is left for backward compatibility
REMAFX_DATADEF TCHAR AFXChNil = '\0';

// For an empty string, m_pchData will point here
// (note: avoids special case of checking for NULL m_pchData)
// empty string data (and locked)
static int RGInitData[] = { -1, 0, 0, 0 };
static REMAFX_DATADEF CSTRINGData* AFXDataNil = (CSTRINGData*)&RGInitData;
static LPCTSTR AFXPchNil = (LPCTSTR)(((BYTE*)&RGInitData)+sizeof(CSTRINGData));
// special function to make AFXEmptyString work even during initialization
const CSTRING& REMAFXAPI AFXGetEmptyString()
	{ return *(CSTRING*)&AFXPchNil; }


//////////////////////////////////////////////////////////////////////////////
// Construction/Destruction

CSTRING::CSTRING()
{
	Init();
}

CSTRING::CSTRING(const CSTRING& stringSrc)
{
	ASSERT(stringSrc.GetData()->nRefs != 0);
	if (stringSrc.GetData()->nRefs >= 0)
	{
		ASSERT(stringSrc.GetData() != AFXDataNil);
		m_pchData = stringSrc.m_pchData;
		InterlockedIncrement(&GetData()->nRefs);
	}
	else
	{
		Init();
		*this = stringSrc.m_pchData;
	}
}

CSTRING::CSTRING(LPCTSTR lpch, int nLength)
{
	Init();

	if (nLength != 0)
	{
//		ASSERT(AfxIsValidAddress(lpch, nLength, FALSE));
		AllocBuffer(nLength);
		memcpy(m_pchData, lpch, nLength*sizeof(TCHAR));
	}
}

void CSTRING::AllocBuffer(int nLen)
// always allocate one extra character for '\0' termination
// assumes [optimistically] that data length will equal allocation length
{
	ASSERT(nLen >= 0);
	ASSERT(nLen <= INT_MAX-1);    // max size (enough room for 1 extra)

	if (nLen == 0)
		Init();
	else
	{
		CSTRINGData* pData =
			(CSTRINGData*)new BYTE[sizeof(CSTRINGData) + (nLen+1)*sizeof(TCHAR)];
		pData->nRefs = 1;
		pData->data()[nLen] = '\0';
		pData->nDataLength = nLen;
		pData->nAllocLength = nLen;
		m_pchData = pData->data();
	}
}

void CSTRING::Release()
{
	if (GetData() != AFXDataNil)
	{
		ASSERT(GetData()->nRefs != 0);
		if (InterlockedDecrement(&GetData()->nRefs) <= 0)
			delete[] (BYTE*)GetData();
		Init();
	}
}

void PASCAL CSTRING::Release(CSTRINGData* pData)
{
	if (pData != AFXDataNil)
	{
		ASSERT(pData->nRefs != 0);
		if (InterlockedDecrement(&pData->nRefs) <= 0)
			delete[] (BYTE*)pData;
	}
}

void CSTRING::Empty()
{
	if (GetData()->nRefs >= 0)
		Release();
	else
		*this = &AFXChNil;
	ASSERT(GetData()->nDataLength == 0);
	ASSERT(GetData()->nRefs < 0 || GetData()->nAllocLength == 0);
}


void CSTRING::CopyBeforeWrite()
{
	if (GetData()->nRefs > 1)
	{
		CSTRINGData* pData = GetData();
		Release();
		AllocBuffer(pData->nDataLength);
		memcpy(m_pchData, pData->data(), (pData->nDataLength+1)*sizeof(TCHAR));
	}
	ASSERT(GetData()->nRefs <= 1);
}

void CSTRING::AllocBeforeWrite(int nLen)
{
	if (GetData()->nRefs > 1 || nLen > GetData()->nAllocLength)
	{
		Release();
		AllocBuffer(nLen);
	}
	ASSERT(GetData()->nRefs <= 1);
}

CSTRING::~CSTRING()
//  free any attached data
{
	if (GetData() != AFXDataNil)
	{
		if (InterlockedDecrement(&GetData()->nRefs) <= 0)
			delete[] (BYTE*)GetData();
	}
}

//////////////////////////////////////////////////////////////////////////////
// Helpers for the rest of the implementation

void CSTRING::AllocCopy(CSTRING& dest, int nCopyLen, int nCopyIndex,
	 int nExtraLen) const
{
	// will clone the data attached to this string
	// allocating 'nExtraLen' characters
	// Places results in uninitialized string 'dest'
	// Will copy the part or all of original data to start of new string

	int nNewLen = nCopyLen + nExtraLen;
	if (nNewLen == 0)
	{
		dest.Init();
	}
	else
	{
		dest.AllocBuffer(nNewLen);
		memcpy(dest.m_pchData, m_pchData+nCopyIndex, nCopyLen*sizeof(TCHAR));
	}
}

//////////////////////////////////////////////////////////////////////////////
// More sophisticated construction

CSTRING::CSTRING(LPCTSTR lpsz)
{
	Init();
//	if (lpsz != NULL && HIWORD(lpsz) == NULL)
//	{
//		UINT nID = LOWORD((DWORD)lpsz);
//		if (!LoadString(nID)) {
//			;// TRACE1("Warning: implicit LoadString(%u) failed\n", nID);
//		}
//	}
//	else
	{
		int nLen = SafeStrlen(lpsz);
		if (nLen != 0)
		{
			AllocBuffer(nLen);
			memcpy(m_pchData, lpsz, nLen*sizeof(TCHAR));
		}
	}
}

/////////////////////////////////////////////////////////////////////////////
// Special conversion constructors

#ifdef _UNICODE
CSTRING::CSTRING(LPCSTR lpsz)
{
	Init();
	int nSrcLen = lpsz != NULL ? lstrlenA(lpsz) : 0;
	if (nSrcLen != 0)
	{
		AllocBuffer(nSrcLen);
		_mbstowcsz(m_pchData, lpsz, nSrcLen+1);
		ReleaseBuffer();
	}
}
#else //_UNICODE
CSTRING::CSTRING(LPCWSTR lpsz)
{
	Init();
	int nSrcLen = lpsz != NULL ? LStrLenW(lpsz) : 0;
	if (nSrcLen != 0)
	{
		AllocBuffer(nSrcLen*2);
		_wcstombsz(m_pchData, lpsz, (nSrcLen*2)+1);
		ReleaseBuffer();
	}
}
#endif //!_UNICODE

//////////////////////////////////////////////////////////////////////////////
// Diagnostic support

//#ifdef _DEBUG
//CDumpContext& REMAFXAPI operator<<(CDumpContext& dc, const CSTRING& string)
//{
//	dc << string.m_pchData;
//	return dc;
//}
//#endif //_DEBUG

//////////////////////////////////////////////////////////////////////////////
// Assignment operators
//  All assign a new value to the string
//      (a) first see if the buffer is big enough
//      (b) if enough room, copy on top of old buffer, set size and type
//      (c) otherwise free old string data, and create a new one
//
//  All routines return the new string (but as a 'const CSTRING&') so that
//      assigning it again will cause a copy, eg: s1 = s2 = "hi there".
//

void CSTRING::AssignCopy(int nSrcLen, LPCTSTR lpszSrcData)
{
	AllocBeforeWrite(nSrcLen);
	memcpy(m_pchData, lpszSrcData, nSrcLen*sizeof(TCHAR));
	GetData()->nDataLength = nSrcLen;
	m_pchData[nSrcLen] = '\0';
}

const CSTRING& CSTRING::operator=(const CSTRING& stringSrc)
{
	if (m_pchData != stringSrc.m_pchData)
	{
		if ((GetData()->nRefs < 0 && GetData() != AFXDataNil) ||
			stringSrc.GetData()->nRefs < 0)
		{
			// actual copy necessary since one of the strings is locked
			AssignCopy(stringSrc.GetData()->nDataLength, stringSrc.m_pchData);
		}
		else
		{
			// can just copy references around
			Release();
			ASSERT(stringSrc.GetData() != AFXDataNil);
			m_pchData = stringSrc.m_pchData;
			InterlockedIncrement(&GetData()->nRefs);
		}
	}
	return *this;
}

const CSTRING& CSTRING::operator=(LPCTSTR lpsz)
{
//lts	ASSERT(lpsz == NULL || AfxIsValidString(lpsz, FALSE));
	AssignCopy(SafeStrlen(lpsz), lpsz);
	return *this;
}

/////////////////////////////////////////////////////////////////////////////
// Special conversion assignment

#ifdef _UNICODE
const CSTRING& CSTRING::operator=(LPCSTR lpsz)
{
	int nSrcLen = lpsz != NULL ? lstrlenA(lpsz) : 0;
	AllocBeforeWrite(nSrcLen);
	_mbstowcsz(m_pchData, lpsz, nSrcLen+1);
	ReleaseBuffer();
	return *this;
}
#else //!_UNICODE
const CSTRING& CSTRING::operator=(LPCWSTR lpsz)
{
	int nSrcLen = lpsz != NULL ? LStrLenW(lpsz) : 0;
	AllocBeforeWrite(nSrcLen*2);
	_wcstombsz(m_pchData, lpsz, (nSrcLen*2)+1);
	ReleaseBuffer();
	return *this;
}
#endif  //!_UNICODE

//////////////////////////////////////////////////////////////////////////////
// concatenation

// NOTE: "operator+" is done as friend functions for simplicity
//      There are three variants:
//          CSTRING + CSTRING
// and for ? = TCHAR, LPCTSTR
//          CSTRING + ?
//          ? + CSTRING

void CSTRING::ConcatCopy(int nSrc1Len, LPCTSTR lpszSrc1Data,
	int nSrc2Len, LPCTSTR lpszSrc2Data)
{
  // -- master concatenation routine
  // Concatenate two sources
  // -- assume that 'this' is a new CSTRING object

	int nNewLen = nSrc1Len + nSrc2Len;
	if (nNewLen != 0)
	{
		AllocBuffer(nNewLen);
		memcpy(m_pchData, lpszSrc1Data, nSrc1Len*sizeof(TCHAR));
		memcpy(m_pchData+nSrc1Len, lpszSrc2Data, nSrc2Len*sizeof(TCHAR));
	}
}

CSTRING REMAFXAPI operator+(const CSTRING& string1, const CSTRING& string2)
{
	CSTRING s;
	s.ConcatCopy(string1.GetData()->nDataLength, string1.m_pchData,
		string2.GetData()->nDataLength, string2.m_pchData);
	return s;
}

CSTRING REMAFXAPI operator+(const CSTRING& string, LPCTSTR lpsz)
{
//	ASSERT(lpsz == NULL || AfxIsValidString(lpsz, FALSE));
	CSTRING s;
	s.ConcatCopy(string.GetData()->nDataLength, string.m_pchData,
		CSTRING::SafeStrlen(lpsz), lpsz);
	return s;
}

CSTRING REMAFXAPI operator+(LPCTSTR lpsz, const CSTRING& string)
{
//	ASSERT(lpsz == NULL || AfxIsValidString(lpsz, FALSE));
	CSTRING s;
	s.ConcatCopy(CSTRING::SafeStrlen(lpsz), lpsz, string.GetData()->nDataLength,
		string.m_pchData);
	return s;
}

//////////////////////////////////////////////////////////////////////////////
// concatenate in place

void CSTRING::ConcatInPlace(int nSrcLen, LPCTSTR lpszSrcData)
{
	//  -- the main routine for += operators

	// if the buffer is too small, or we have a width mis-match, just
	//   allocate a new buffer (slow but sure)
	if (GetData()->nRefs > 1 || GetData()->nDataLength + nSrcLen > GetData()->nAllocLength)
	{
		// we have to grow the buffer, use the ConcatCopy routine
		CSTRINGData* pOldData = GetData();
		ConcatCopy(GetData()->nDataLength, m_pchData, nSrcLen, lpszSrcData);
		ASSERT(pOldData != NULL);
		CSTRING::Release(pOldData);
	}
	else
	{
		// fast concatenation when buffer big enough
		memcpy(m_pchData+GetData()->nDataLength, lpszSrcData, nSrcLen*sizeof(TCHAR));
		GetData()->nDataLength += nSrcLen;
		ASSERT(GetData()->nDataLength <= GetData()->nAllocLength);
		m_pchData[GetData()->nDataLength] = '\0';
	}
}

const CSTRING& CSTRING::operator+=(LPCTSTR lpsz)
{
//	ASSERT(lpsz == NULL || AfxIsValidString(lpsz, FALSE));
	ConcatInPlace(SafeStrlen(lpsz), lpsz);
	return *this;
}

const CSTRING& CSTRING::operator+=(TCHAR ch)
{
	ConcatInPlace(1, &ch);
	return *this;
}

const CSTRING& CSTRING::operator+=(const CSTRING& string)
{
	ConcatInPlace(string.GetData()->nDataLength, string.m_pchData);
	return *this;
}

/*
 * Length-sensitive comparison
 *
 *	NOTE: FEqual returns TRUE if the 2 CSTRINGS have the same length and contain
 *		  the same characters, and FALSE, otherwise.
 */

BOOL CSTRING::FEqual (const CSTRING &s2) const
{
	int						 length;

	// Compare the lengths first
	length = GetData()->nDataLength;
	if (length != s2.GetData()->nDataLength)
		return FALSE;

#ifdef _UNICODE
	// adjust the length in bytes
	length *= sizeof (TCHAR);
#endif

	/*
	 *	Now, compare the strings themselves
	 *	We use memcmp and not lstrcmp because the stings may
	 *	have embedded null characters.
	 */
	if (memcmp ((const void *) m_pchData, (const void *) s2.m_pchData, length))
		return FALSE;
	else
		return TRUE;
}

///////////////////////////////////////////////////////////////////////////////
// Advanced direct buffer access

LPTSTR CSTRING::GetBuffer(int nMinBufLength)
{
	ASSERT(nMinBufLength >= 0);

	if (GetData()->nRefs > 1 || nMinBufLength > GetData()->nAllocLength)
	{
		// we have to grow the buffer
		CSTRINGData* pOldData = GetData();
		int nOldLen = GetData()->nDataLength;   // AllocBuffer will tromp it
		if (nMinBufLength < nOldLen)
			nMinBufLength = nOldLen;
		AllocBuffer(nMinBufLength);
		memcpy(m_pchData, pOldData->data(), (nOldLen+1)*sizeof(TCHAR));
		GetData()->nDataLength = nOldLen;
		CSTRING::Release(pOldData);
	}
	ASSERT(GetData()->nRefs <= 1);

	// return a pointer to the character storage for this string
	ASSERT(m_pchData != NULL);
	return m_pchData;
}

void CSTRING::ReleaseBuffer(int nNewLength)
{
	CopyBeforeWrite();  // just in case GetBuffer was not called

	if (nNewLength == -1)
		nNewLength = lstrlen(m_pchData); // zero terminated

	ASSERT(nNewLength <= GetData()->nAllocLength);
	GetData()->nDataLength = nNewLength;
	m_pchData[nNewLength] = '\0';
}

LPTSTR CSTRING::GetBufferSetLength(int nNewLength)
{
	ASSERT(nNewLength >= 0);

	GetBuffer(nNewLength);
	GetData()->nDataLength = nNewLength;
	m_pchData[nNewLength] = '\0';
	return m_pchData;
}

void CSTRING::FreeExtra()
{
	ASSERT(GetData()->nDataLength <= GetData()->nAllocLength);
	if (GetData()->nDataLength != GetData()->nAllocLength)
	{
		CSTRINGData* pOldData = GetData();
		AllocBuffer(GetData()->nDataLength);
		memcpy(m_pchData, pOldData->data(), pOldData->nDataLength*sizeof(TCHAR));
		ASSERT(m_pchData[GetData()->nDataLength] == '\0');
		CSTRING::Release(pOldData);
	}
	ASSERT(GetData() != NULL);
}

LPTSTR CSTRING::LockBuffer()
{
	LPTSTR lpsz = GetBuffer(0);
	GetData()->nRefs = -1;
	return lpsz;
}

void CSTRING::UnlockBuffer()
{
	ASSERT(GetData()->nRefs == -1);
	if (GetData() != AFXDataNil)
		GetData()->nRefs = 1;
}

///////////////////////////////////////////////////////////////////////////////
// Commonly used routines (rarely used routines in STREX.CPP)


// find position of the first character match  (or -1 on failure)
int CSTRING::Find(TCHAR ch) const
{
	for (TCHAR * pch = m_pchData; _T('\0') != *pch; pch = CharNext(pch))
	{
		if (ch == *pch)
			return ((int)(pch - m_pchData) / sizeof(TCHAR));
	}
	return -1;
}

CSTRING CSTRING::Left(int nCount) const
{
        if (nCount < 0)
                nCount = 0;
        else if (nCount > GetData()->nDataLength)
                nCount = GetData()->nDataLength;

        CSTRING dest;
        AllocCopy(dest, nCount, 0, 0);
		return dest;
}

CSTRING CSTRING::Mid(int nFirst) const
{
	return Mid(nFirst, GetData()->nDataLength - nFirst);
}

CSTRING CSTRING::Mid(int nFirst, int nCount) const
{
	// out-of-bounds requests return sensible things
	if (nFirst < 0)
		nFirst = 0;
	if (nCount < 0)
		nCount = 0;

	if (nFirst + nCount > GetData()->nDataLength)
		nCount = GetData()->nDataLength - nFirst;
	if (nFirst > GetData()->nDataLength)
		nCount = 0;

	CSTRING dest;
	AllocCopy(dest, nCount, nFirst, 0);
	return dest;
}

void CSTRING::MakeUpper()
{
	CopyBeforeWrite();
	::CharUpper(m_pchData);
}

void CSTRING::MakeLower()
{
	CopyBeforeWrite();
	::CharLower(m_pchData);
}

void CSTRING::SetAt(int nIndex, TCHAR ch)
{
	ASSERT(nIndex >= 0);
	ASSERT(nIndex < GetData()->nDataLength);

	CopyBeforeWrite();
	m_pchData[nIndex] = ch;
}

#ifndef _UNICODE
void CSTRING::AnsiToOem()
{
	CopyBeforeWrite();
	::AnsiToOem(m_pchData, m_pchData);
}
#endif

///////////////////////////////////////////////////////////////////////////////
// CSTRING conversion helpers (these use the current system locale)

int REMAFX_CDECL _wcstombsz(char* mbstr, const wchar_t* wcstr, size_t count)
{
	if (count == 0 && mbstr != NULL)
		return 0;

	int result = ::WideCharToMultiByte(CP_ACP, 0, wcstr, -1,
		mbstr, count, NULL, NULL);
	ASSERT(mbstr == NULL || result <= (int)count);
	if (result > 0)
		mbstr[result-1] = 0;
	return result;
}

int REMAFX_CDECL _mbstowcsz(wchar_t* wcstr, const char* mbstr, size_t count)
{
	if (count == 0 && wcstr != NULL)
		return 0;

	int result = ::MultiByteToWideChar(CP_ACP, 0, mbstr, -1,
		wcstr, count);
	ASSERT(wcstr == NULL || result <= (int)count);
	if (result > 0)
		wcstr[result-1] = 0;
	return result;
}

LPWSTR REMAFXAPI AfxA2WHelper(LPWSTR lpw, LPCSTR lpa, int nChars)
{
	if (lpa == NULL)
		return NULL;
	ASSERT(lpw != NULL);
	// verify that no illegal character present
	// since lpw was allocated based on the size of lpa
	// don't worry about the number of chars
	lpw[0] = '\0';
//lts	VERIFY(MultiByteToWideChar(CP_ACP, 0, lpa, -1, lpw, nChars));
	MultiByteToWideChar(CP_ACP, 0, lpa, -1, lpw, nChars);
	return lpw;
}

LPSTR REMAFXAPI AfxW2AHelper(LPSTR lpa, LPCWSTR lpw, int nChars)
{
	if (lpw == NULL)
		return NULL;
	ASSERT(lpa != NULL);
	// verify that no illegal character present
	// since lpa was allocated based on the size of lpw
	// don't worry about the number of chars
	lpa[0] = '\0';
//lts	VERIFY(WideCharToMultiByte(CP_ACP, 0, lpw, -1, lpa, nChars, NULL, NULL));
	WideCharToMultiByte(CP_ACP, 0, lpw, -1, lpa, nChars, NULL, NULL);
	return lpa;
}

///////////////////////////////////////////////////////////////////////////////
BOOL CSTRING::LoadString(HINSTANCE hInstance, UINT nID)
{
	// try buffer size of 256, then larger size until entire string is retrieved
	int nSize = -1;
	int nLen;
	do
	{
		nSize += 256;
		nLen = ::LoadString(hInstance, nID, GetBuffer(nSize), nSize+1);
	} while (nLen == nSize);
	ReleaseBuffer();

	return nLen > 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\remdsk\rds\nmutil\hash.cpp ===
// HASH.CPP
//
// Hash utility functions for use in NetMeeting components.

#include "precomp.h"
#include "nb30.h"
#include <regentry.h>
#include <confreg.h>
#include <strutil.h>

CHash::CHash() : m_hProv(0), m_hHash(0), m_pbHashedData(NULL), m_cbHashedData(0), m_fReady(FALSE)
{
	if (!CryptAcquireContext(&m_hProv, NULL, MS_DEF_PROV, PROV_RSA_FULL, CRYPT_MACHINE_KEYSET)) 
	{
		// Create new if can not get default 
		if (!CryptAcquireContext(&m_hProv, NULL, MS_DEF_PROV, PROV_RSA_FULL, CRYPT_NEWKEYSET | CRYPT_MACHINE_KEYSET)) 
		{
			goto ErrorExit;	
		}
	}

	m_fReady = TRUE;
	return;
ErrorExit:
	m_fReady = FALSE;
}


CHash::~CHash()
{
	if (m_pbHashedData) delete []m_pbHashedData;
	CryptAcquireContext(&m_hProv, NULL, MS_DEF_PROV, PROV_RSA_FULL, CRYPT_DELETEKEYSET | CRYPT_MACHINE_KEYSET);
	if (m_hHash) CryptDestroyHash(m_hHash);
	if (m_hProv) CryptReleaseContext(m_hProv, 0);
}

DWORD CHash::GetHashedData(PBYTE pbData, DWORD cbData, void ** ppvHashedData)
{
	ASSERT(NULL != ppvHashedData);
	ASSERT(NULL != pbData);
	DWORD dwCount;
	RegEntry re(WINDOWS_KEY, HKEY_LOCAL_MACHINE);

	if (FALSE == m_fReady)
	{
		goto ErrorExit;
	}
	if (0 == cbData) {
		goto ErrorExit;
	}
	if (m_hHash) CryptDestroyHash(m_hHash);
	if (!CryptCreateHash(m_hProv, CALG_MD5, 0, 0, &m_hHash))
	{
		ERROR_OUT(("CHash::GetHashData() - Error creating crypt hash object."));
		goto ErrorExit;
	}
	if (!CryptHashData(m_hHash, pbData, cbData, 0))
	{
		ERROR_OUT(("CHash::GetHashData() - Error hashing data."));
		goto ErrorExit;
	}

	if (!CryptHashData(m_hHash, (PBYTE) re.GetString(REGVAL_REGISTERED_USER),
			lstrlen(re.GetString(REGVAL_REGISTERED_USER)), 0))
	{
		ERROR_OUT(("CHash::GetHashData() - Error hashing extra data."));
		goto ErrorExit;
	}

	NCB ncb;
	BYTE buf[sizeof(NCB) + 256];

	ZeroMemory ( &ncb, sizeof(ncb));
	ncb.ncb_command = NCBASTAT;
	ncb.ncb_buffer = buf;
	ncb.ncb_length = sizeof(buf);
	memcpy ( (PBYTE)ncb.ncb_callname, (PBYTE)"*              ", NCBNAMSZ );

	if ( NRC_GOODRET == Netbios(&ncb) )
	{
		//
		// NOTE: the buffer filled by the Netbios ASTAT command starts
		// with a 6-byte encoded adapter address: just use the raw
		// buffer rather than casting back to PBYTE
		//

		if (!CryptHashData(m_hHash, buf, 6, 0 ))
		{
			ERROR_OUT(("CHash::GetHashData() - Error hashing ncb data."));
			goto ErrorExit;
		}
	}
	else
	{
		WARNING_OUT(("CHash::GetHashData: Netbios failed %x", ncb.ncb_retcode));
	}
	
	dwCount = sizeof(DWORD);
	if (!CryptGetHashParam(m_hHash, HP_HASHSIZE, (BYTE *)&m_cbHashedData, &dwCount, 0)) 
	{
		goto ErrorExit;
	}
	if (m_pbHashedData) delete [] m_pbHashedData;
	if (NULL == (m_pbHashedData = new BYTE[m_cbHashedData]))
	{
		goto ErrorExit;
	}
	if (!CryptGetHashParam(m_hHash, HP_HASHVAL, m_pbHashedData, &m_cbHashedData, 0)) {
		goto ErrorExit;
	}
	*ppvHashedData = m_pbHashedData;
	return m_cbHashedData;
ErrorExit:
	return 0;     // Hash data failed 
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\remdsk\rds\nmutil\dbg.cpp ===
/* dbg.cpp */

#include "precomp.h"
#include <cstring.hpp>
#include <regentry.h>
#include <confreg.h>
#include <confdbg.h>


#ifdef NM_DEBUG  /* Almost the whole file */

// Special Debugbreak macro
#if defined (_M_IX86)
#define _DbgBreak()  __asm { int 3 }
#else
#define _DbgBreak() DebugBreak()
#endif

// Special Mutex Macros
#define ACQMUTEX(hMutex)	WaitForSingleObject(hMutex, INFINITE)
#define RELMUTEX(hMutex)	ReleaseMutex(hMutex)

// Constant for GlobalAddAtom
const int CCHMAX_ATOM = 255;

// Local Variables
static PNMDBG    _gpDbg = NULL;            // Shared data in mmf after zone info
static HANDLE    _ghMutexFile = NULL;      // Mutex for writing to file
static PZONEINFO _gprgZoneInfo = NULL;     // the address in which the zone is mapped,points to an array of zones
static HANDLE    _ghDbgZoneMap = NULL;     // the handle of the memory mapped file for zones
static HANDLE    _ghDbgZoneMutex = NULL;   // Mutex for accessing Zone information
static long      _gLockCount = 0;

VOID DbgCurrentTime(PCHAR psz);


/*  _  D B G  P R I N T F  */
/*-------------------------------------------------------------------------
    %%Function: _DbgPrintf

    The main, low level, debug output routine.
-------------------------------------------------------------------------*/
static VOID WINAPI _DbgPrintf(LPCSTR pszFile, PCSTR pszPrefix, PCSTR pszFormat, va_list ap)
{
	CHAR  szOutput[1024];
	PCHAR pszOutput = szOutput;
	UINT  cch;

	if (NULL == _gprgZoneInfo)
		return;

	if (DBG_FMTTIME_NONE != _gpDbg->uShowTime)
	{
		DbgCurrentTime(pszOutput);
		pszOutput += lstrlenA(pszOutput);
	}

	if (_gpDbg->fShowThreadId)
	{
		wsprintfA(pszOutput, "[%04X] ", GetCurrentThreadId());
		pszOutput += lstrlenA(pszOutput);
	}

	wvsprintfA(pszOutput, pszFormat, ap);


	// Append carriage return, if necessary
	// WARNING: This code is not DBCS-safe.
	cch = lstrlenA(szOutput);
	if (szOutput[cch-1] == '\n')
	{
		if (szOutput[cch-2] != '\r')
		{
			lstrcpyA(&szOutput[cch-1], "\r\n");
			cch++;
		}
	}
	else
	{
		lstrcpyA(&szOutput[cch], "\r\n");
		cch += 2;
	}


	// Output to debug handler
	if (_gpDbg->fOutputDebugString)
	{
		OutputDebugStringA(szOutput);
	}


	// Output to File
	if (_gpDbg->fFileOutput || (NULL != pszFile))
	{
		HANDLE hFile;
		DWORD dw;

		// Lock access to file
		ACQMUTEX(_ghMutexFile);

		if (NULL == pszFile)
			pszFile = _gpDbg->szFile;

		// open a log file for appending. create if does not exist
		hFile = CreateFileA(pszFile, GENERIC_WRITE, 0, NULL,
			OPEN_ALWAYS, FILE_ATTRIBUTE_NORMAL, (HANDLE)NULL);
		if (hFile != INVALID_HANDLE_VALUE)
		{
			// seek to end of file
			dw = SetFilePointer(hFile, 0, NULL, FILE_END);

#ifdef TEST /* Test/Retail version truncates at 40K */
			if (dw > 0x040000)
			{
				CloseHandle(hFile);
				hFile = CreateFileA(pszFile, GENERIC_WRITE, 0, NULL,
					TRUNCATE_EXISTING, FILE_ATTRIBUTE_NORMAL, (HANDLE)NULL);
			}										
			if (INVALID_HANDLE_VALUE != hFile)
#endif
			{
				WriteFile(hFile, szOutput, lstrlenA(szOutput), &dw, NULL);
				CloseHandle(hFile);
			}
		}

		// Unlock access to file
		RELMUTEX(_ghMutexFile);
	}

	// Output to viewer.  This is at the end of the function because
	// we potentially truncate szOutput.
	if ((_gpDbg->fWinOutput) && (NULL != _gpDbg->hwndCtrl))
	{
		// Make sure that the string doesn't exceed the maximum atom size.
		// WARNING: This code is not DBCS-safe.
		static const CHAR szTruncatedSuffix[] = "...\r\n";
		static const int cchTruncatedSuffix = ARRAY_ELEMENTS(szTruncatedSuffix) - 1;

		if (CCHMAX_ATOM < cch)
		{
			lstrcpyA(&szOutput[CCHMAX_ATOM - cchTruncatedSuffix], szTruncatedSuffix);
		}

		ATOM aDbgAtom = GlobalAddAtomA(szOutput);

		if (aDbgAtom)
		{
			if (!PostMessage(_gpDbg->hwndCtrl, _gpDbg->msgDisplay, (WPARAM)aDbgAtom, 0L))
			{
				// Unable to post Message, so free the atom
				GlobalDeleteAtom(aDbgAtom);
			}
		}
	}

}


PSTR WINAPI DbgZPrintf(HDBGZONE hZone, UINT iZone, PSTR pszFormat,...)
{
	CHAR sz[MAXSIZE_OF_MODULENAME+MAXSIZE_OF_ZONENAME+1];
	PCHAR psz;
	va_list v1;
	va_start(v1, pszFormat);

	if ((NULL != hZone) && (iZone < MAXNUM_OF_ZONES))
	{
	    wsprintfA(sz, "%hs:%hs", ((PZONEINFO) hZone)->pszModule, ((PZONEINFO) hZone)->szZoneNames[iZone]);
	    psz = sz;
	}
	else
	{
		psz = NULL;
	}


	if ((NULL != hZone) && ('\0' != ((PZONEINFO) hZone)->szFile[0]))
	{
		// Use the private module output filename, if specified
		_DbgPrintf(((PZONEINFO) hZone)->szFile, psz, pszFormat, v1);
	}
	else
	{
		_DbgPrintf(NULL, psz, pszFormat, v1);
	}
	
	va_end(v1);
	return pszFormat;
}


PSTR WINAPI DbgZVPrintf(HDBGZONE hZone, UINT iZone, PSTR pszFormat, va_list ap)
{
	CHAR sz[MAXSIZE_OF_MODULENAME+MAXSIZE_OF_ZONENAME+1];
	PCHAR psz;

	if ((NULL != hZone) && (iZone < MAXNUM_OF_ZONES))
	{
	    wsprintfA(sz, "%hs:%hs", ((PZONEINFO) hZone)->pszModule, ((PZONEINFO) hZone)->szZoneNames[iZone]);
	    psz = sz;
	}
	else
	{
		psz = NULL;
	}


	if ((NULL != hZone) && ('\0' != ((PZONEINFO) hZone)->szFile[0]))
	{
		// Use the private module output filename, if specified
		_DbgPrintf(((PZONEINFO) hZone)->szFile, psz, pszFormat, ap);
	}
	else
	{
		_DbgPrintf(NULL, psz, pszFormat, ap);
	}
	
	return pszFormat;
}


VOID WINAPI DbgPrintf(PCSTR pszPrefix, PCSTR pszFormat, va_list ap)
{
	_DbgPrintf(NULL, pszPrefix, pszFormat, ap);
}


VOID  DbgInitEx(HDBGZONE * phDbgZone, PCHAR * psz, UINT cZones, long ulZoneDefault)
{
	UINT i;
	HDBGZONE hDbgZone;
	DBGZONEINFO dbgZoneParm;

	//DbgMsg("Module %s (%d zones)", *psz, cZones);

	InterlockedIncrement( &_gLockCount );

	InitDbgZone();

	if (cZones > MAXNUM_OF_ZONES)
		cZones = MAXNUM_OF_ZONES;


	ZeroMemory(&dbgZoneParm, sizeof(dbgZoneParm));
	
	// First string is the module name
	lstrcpynA(dbgZoneParm.pszModule, *psz, CCHMAX(dbgZoneParm.pszModule));

	// Copy the zone names
	for (i = 0; i < cZones; i++)
	{
		lstrcpynA(dbgZoneParm.szZoneNames[i], psz[1+i], CCHMAX(dbgZoneParm.szZoneNames[0]));
	}

	// Get the detault zone settings
	dbgZoneParm.ulZoneMask = ulZoneDefault;

	hDbgZone = NmDbgCreateZone(dbgZoneParm.pszModule);
	if (NULL == hDbgZone)
	{
		OutputDebugStringA("DbgInit: Failed to create zones!\r\n");
		return;
	}

	NmDbgSetZone(hDbgZone, &dbgZoneParm);
	*phDbgZone = hDbgZone;
}


VOID  DbgDeInit(HDBGZONE * phDbgZone)
{
	if (NULL == phDbgZone)
		return;

	if (NULL == *phDbgZone)
		return;

	//DbgMsg("Freeing Zone [%s]",((PZONEINFO)(*phDbgZone))->pszModule);

	NmDbgDeleteZone("", *phDbgZone);
	*phDbgZone = NULL;

    if( 0 == InterlockedDecrement( &_gLockCount ) )
    {
        UnMapDebugZoneArea();

        if( _ghMutexFile )
        {
            CloseHandle( _ghMutexFile );
            _ghMutexFile = NULL;
        }

        if( _ghDbgZoneMutex )
        {
            CloseHandle( _ghDbgZoneMutex );
            _ghDbgZoneMutex = NULL;
        }
    }
}




//////////////////////////////////////////////////////////////////////////////////
// from dbgzone.cpp



/***************************************************************************

	Name      :	NmDbgCreateZones

	Purpose   :	A module calls this to allocate/initialize the zone area for debugging
				purposes.

	Parameters:	pszName - the name of the module

	Returns   :	

	Comment   :	

***************************************************************************/
HDBGZONE WINAPI NmDbgCreateZone(LPSTR pszName)
{

	PZONEINFO pZoneInfo=NULL;

 	if (!(pZoneInfo = FindZoneForModule(pszName)))
	 	pZoneInfo = AllocZoneForModule(pszName);
	return ((HDBGZONE)pZoneInfo);
}


/***************************************************************************

	Name      :	NmDbgDeleteZones

	Purpose   :	

	Parameters:	

	Returns   :	

	Comment   :	

***************************************************************************/
void WINAPI NmDbgDeleteZone(LPSTR pszName, HDBGZONE hDbgZone)
{
	//decrement reference count
	PZONEINFO pZoneInfo = (PZONEINFO)hDbgZone;

    ASSERT( _ghDbgZoneMutex );

	ACQMUTEX(_ghDbgZoneMutex);

	if (pZoneInfo)
	{
		pZoneInfo->ulRefCnt--;
		if (pZoneInfo->ulRefCnt == 0)
		{
			pZoneInfo->bInUse = FALSE;
			pZoneInfo->ulSignature = 0;
		}
	}

	RELMUTEX(_ghDbgZoneMutex);
}



/***************************************************************************

	Name      :	NmDbgSetZones

	Purpose   :	

	Parameters:	

	Returns   :	

	Comment   :	

***************************************************************************/
BOOL WINAPI NmDbgSetZone(HDBGZONE hDbgZone, PDBGZONEINFO pZoneParam)
{
	PZONEINFO pZoneInfo = (PZONEINFO)hDbgZone;

	if (!pZoneInfo)
		return FALSE;
	
	if (lstrcmpA(pZoneInfo->pszModule,pZoneParam->pszModule))
		return FALSE;

	pZoneInfo->ulZoneMask = pZoneParam->ulZoneMask;
	CopyMemory(pZoneInfo->szZoneNames, pZoneParam->szZoneNames,
		(sizeof(CHAR) * MAXNUM_OF_ZONES * MAXSIZE_OF_ZONENAME));
	return(TRUE);
}



/***************************************************************************

	Name      :	NmDbgGetZoneParams

	Purpose   :	

	Parameters:	

	Returns   :	

	Comment   :	

***************************************************************************/
BOOL WINAPI NmDbgGetAllZoneParams(PDBGZONEINFO *plpZoneParam,LPUINT puCnt)
{
	UINT		ui;
	PZONEINFO	pCurZone;

	if ((NULL == plpZoneParam) || (NULL == puCnt))
		return FALSE;
		
	ACQMUTEX(_ghDbgZoneMutex);

	*puCnt = 0;
	for (pCurZone = _gprgZoneInfo, ui=0;
		ui<MAXNUM_OF_MODULES && pCurZone!=NULL;
		ui++,pCurZone++)
	{
	 	if ((pCurZone->bInUse) && (pCurZone->ulSignature == ZONEINFO_SIGN))
		{
			(*puCnt)++;
		}
	}

	*plpZoneParam = _gprgZoneInfo;
	
	RELMUTEX(_ghDbgZoneMutex);
	return TRUE;
}


BOOL WINAPI NmDbgFreeZoneParams(PDBGZONEINFO pZoneParam)
{
	return TRUE;
}


PZONEINFO  FindZoneForModule(LPCSTR pszModule)
{
	int i;
	PZONEINFO pCurZone;

	for (pCurZone = _gprgZoneInfo,i=0;i<MAXNUM_OF_MODULES && pCurZone!=NULL;i++,pCurZone++)
	{
	 	if ((pCurZone->bInUse) && (pCurZone->ulSignature == ZONEINFO_SIGN)
			&& (!lstrcmpA(pCurZone->pszModule,pszModule)))
		{
			ACQMUTEX(_ghDbgZoneMutex);		
			pCurZone->ulRefCnt++;
			RELMUTEX(_ghDbgZoneMutex);
			return pCurZone;
		}
	}
	return NULL;

}




/***************************************************************************

	Name      :	AllocZoneForModule

	Purpose   :	Allocates the

	Parameters:	

	Returns   :	

	Comment   :	

***************************************************************************/
PZONEINFO  AllocZoneForModule(LPCSTR pszModule)
{
	int i;
	PZONEINFO pCurZone;
	PZONEINFO pZoneForMod=NULL;

	ACQMUTEX(_ghDbgZoneMutex);
	for (pCurZone = _gprgZoneInfo,i=0;
		(i<MAXNUM_OF_MODULES && pCurZone!=NULL);
		i++,pCurZone++)
	{
	 	if (!(pCurZone->bInUse))
		{
			pCurZone->bInUse = TRUE;
			pCurZone->ulSignature = ZONEINFO_SIGN;
			pCurZone->ulRefCnt = 1;
			lstrcpyA(pCurZone->pszModule, pszModule);
			pZoneForMod = pCurZone;
			break;
		}
	}
	
	RELMUTEX(_ghDbgZoneMutex);
	return(pZoneForMod);

}


VOID  SetDbgFlags(void)
{
	PTSTR psz;

	_gpDbg->fOutputDebugString  = TRUE;
	_gpDbg->fWinOutput          = FALSE;
	_gpDbg->fFileOutput         = FALSE;

	_gpDbg->uShowTime           = DBG_FMTTIME_NONE;
	_gpDbg->fShowThreadId       = FALSE;
	_gpDbg->fShowModule         = FALSE;

	{
		UINT cchFile;

		cchFile = GetWindowsDirectoryA(_gpDbg->szFile, CCHMAX(_gpDbg->szFile));
		_gpDbg->szFile[cchFile++] = '\\';
		lstrcpyA(_gpDbg->szFile + cchFile, CUSTRING(TEXT("rddbg.txt")));
	}
}


VOID InitZoneMmf(PZONEINFO prgZoneInfo)
{
	ZeroMemory(prgZoneInfo, CBMMFDBG);

	SetDbgFlags();
}


PZONEINFO  MapDebugZoneArea(void)
{
	PZONEINFO prgZoneInfo;
	BOOL	  fCreated;
	SECURITY_DESCRIPTOR     sd;
	SECURITY_ATTRIBUTES     sa;

	// Obtain a true NULL security descriptor (so if running as a service, user processes can access it)
	
	InitializeSecurityDescriptor(&sd, SECURITY_DESCRIPTOR_REVISION);
	SetSecurityDescriptorDacl(&sd, TRUE, NULL, FALSE);  // NULL DACL = wide open

	FillMemory(&sa, sizeof(sa), 0);
	sa.nLength = sizeof(sa);
	sa.lpSecurityDescriptor = &sd;

	//create a memory mapped object that is backed by paging file	
	_ghDbgZoneMap = CreateFileMapping(INVALID_HANDLE_VALUE, &sa, PAGE_READWRITE,
		0, CBMMFDBG, SZ_DBG_MAPPED_ZONE);
	if (NULL == _ghDbgZoneMap)
		return NULL;

	fCreated = (0 == GetLastError());
   	prgZoneInfo = (PZONEINFO) MapViewOfFile(_ghDbgZoneMap, FILE_MAP_READ|FILE_MAP_WRITE, 0,0,0);
   	if (NULL != prgZoneInfo)
   	{
   		// Grab pointer to shared data area
   		_gpDbg = (PNMDBG) (((PBYTE) prgZoneInfo) + (MAXNUM_OF_MODULES * sizeof(ZONEINFO)));
   		if (fCreated)
   			InitZoneMmf(prgZoneInfo);
	}

	return prgZoneInfo;
}


VOID  UnMapDebugZoneArea(void)
{
	if (_gprgZoneInfo)
	{
		UnmapViewOfFile(_gprgZoneInfo);
		_gprgZoneInfo = NULL;
	}

    if (_ghDbgZoneMap)
    {
        CloseHandle(_ghDbgZoneMap);
        _ghDbgZoneMap = NULL;
    }
}


VOID  InitDbgZone(void)
{
	if (NULL != _gprgZoneInfo)
		return; // already initialized

	_gprgZoneInfo = MapDebugZoneArea();

	// Create log file data
	SECURITY_DESCRIPTOR     sd;
	SECURITY_ATTRIBUTES     sa;

	// Obtain a true NULL security descriptor (so if running as a service, user processes can access it)
	
	InitializeSecurityDescriptor(&sd, SECURITY_DESCRIPTOR_REVISION);
	SetSecurityDescriptorDacl(&sd, TRUE, NULL, FALSE);  // NULL DACL = wide open

	FillMemory(&sa, sizeof(sa), 0);
	sa.nLength = sizeof(sa);
	sa.lpSecurityDescriptor = &sd;

	_ghMutexFile = CreateMutex(&sa, FALSE, SZ_DBG_FILE_MUTEX);
	_ghDbgZoneMutex = CreateMutex(&sa, FALSE, SZ_DBG_ZONE_MUTEX);

	if (_gpDbg->fFileOutput)
	{
		HANDLE  hFile;
    	DWORD dw;
    	CHAR sz[MAX_PATH];
		SYSTEMTIME  systime;


    	hFile = CreateFileA(_gpDbg->szFile,
    		GENERIC_WRITE | GENERIC_WRITE, 0, &sa,
    		CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);

    	if (INVALID_HANDLE_VALUE == hFile)
		{
			_gpDbg->fFileOutput = FALSE;
			return;
		}

		GetLocalTime(&systime);

		wsprintfA(sz,
	     	"\r\n======== TRACE Started: %hu/%hu/%hu (%hu:%hu)\r\n",
	     	systime.wMonth, systime.wDay, systime.wYear, systime.wHour, systime.wMinute);

		SetFilePointer(hFile, 0, NULL, FILE_END);
		WriteFile(hFile, sz, lstrlenA(sz), &dw, NULL);

		CloseHandle(hFile);
	}
}


///////////////////////////////////////
// Routines for controlling debug output

BOOL WINAPI NmDbgRegisterCtl(HWND hwnd, UINT uDisplayMsg)
{
	if ((NULL == _gpDbg) || (NULL != _gpDbg->hwndCtrl))
		return FALSE;

	_gpDbg->msgDisplay = uDisplayMsg;
	_gpDbg->hwndCtrl = hwnd;
	return TRUE;
}

BOOL WINAPI NmDbgDeregisterCtl(HWND hwnd)
{
	if ((NULL == _gpDbg) || (hwnd != _gpDbg->hwndCtrl))
		return FALSE;

	_gpDbg->hwndCtrl = NULL;
	_gpDbg->msgDisplay = 0;
	return TRUE;
}

BOOL WINAPI NmDbgSetLoggingOptions(HWND hwnd, UINT uOptions)
{
	return FALSE;
}

PNMDBG WINAPI GetPNmDbg(void)
{
	return _gpDbg;
}

VOID WINAPI NmDbgSetZoneFileName(HDBGZONE hZone, LPCSTR pszFile)
{
	PSTR pszZoneFile;

	if (IsBadWritePtr((PVOID) hZone, sizeof(ZONEINFO)))
		return;

	if (((PZONEINFO) hZone)->ulSignature != ZONEINFO_SIGN)
		return;

	pszZoneFile =  &(((PZONEINFO) hZone)->szFile[0]);

	if (NULL == pszFile)
	{
    	*pszZoneFile = '\0';
    }
    else
    {
    	lstrcpynA(pszZoneFile, pszFile, CCHMAX(((PZONEINFO) hZone)->szFile));
    }
}

/*  D B G  C U R R E N T  T I M E  */
/*-------------------------------------------------------------------------
    %%Function: DbgCurrentTime

    Format the current time
-------------------------------------------------------------------------*/
VOID DbgCurrentTime(PCHAR psz)
{
	if (DBG_FMTTIME_TICK == _gpDbg->uShowTime)
	{
		wsprintfA(psz, "[%04X] ", GetTickCount());
	}
	else
	{
		SYSTEMTIME sysTime;
		GetLocalTime(&sysTime);

		switch (_gpDbg->uShowTime)
			{
		default:
		case DBG_FMTTIME_FULL:
			wsprintfA(psz, "[%04d/%02d/%02d %02d:%02d:%02d.%03d] ",
				sysTime.wYear, sysTime.wMonth, sysTime.wDay,
				sysTime.wHour, sysTime.wMinute, sysTime.wSecond, sysTime.wMilliseconds);
			break;
		case DBG_FMTTIME_DAY:
			wsprintfA(psz, "[%02d:%02d:%02d.%03d] ",
				sysTime.wHour, sysTime.wMinute, sysTime.wSecond, sysTime.wMilliseconds);
			break;
			}
	}
}




/*  P S Z  P R I N T F  */
/*-------------------------------------------------------------------------
    %%Function: PszPrintf

	Utility function to wsprintf a string for debug.
-------------------------------------------------------------------------*/
PSTR PszPrintf(PCSTR pszFormat,...)
{
	PSTR psz = (PSTR) LocalAlloc(LMEM_FIXED, MAX_PATH);
	if (NULL != psz)
	{
	    va_list v1;
		va_start(v1, pszFormat);
	    wvsprintfA(psz, pszFormat, v1);
		va_end(v1);
	}
	return psz;
}


/*  D E B U G  T R A P  F N  */
/*-------------------------------------------------------------------------
    %%Function: DebugTrapFn
-------------------------------------------------------------------------*/
VOID  DebugTrapFn(VOID)
{
	_DbgBreak();
}


VOID DebugPrintfTraceMem(LPCSTR pszFormat,...)
{
    // DO NOTHING
	va_list arglist;

	va_start(arglist, pszFormat);
	va_end(arglist);
}



#endif /* NM_DEBUG - almost the whole file */
/*************************************************************************/


const int RPF_UNKNOWN  = 0;
const int RPF_ENABLED  = 1;
const int RPF_DISABLED = 2;

static int gRpf = RPF_UNKNOWN;
static TCHAR gszRetailOutputFilename[MAX_PATH];    // retail trace filename


/*  F  E N A B L E D  R E T A I L  P R I N T F  */
/*-------------------------------------------------------------------------
    %%Function: FEnabledRetailPrintf

    Return TRUE if retail output is enabled.
-------------------------------------------------------------------------*/
BOOL FEnabledRetailPrintf(VOID)
{
	if (RPF_UNKNOWN == gRpf)
	{
		gRpf = RPF_DISABLED;

		if (RPF_ENABLED != gRpf)
		{
			gRpf = RPF_DISABLED;
		}
		else
		{
			lstrcat(gszRetailOutputFilename, TEXT("rdlog.txt"));
		}

	}

	return (RPF_ENABLED == gRpf);
}


/*  R E T A I L  P R I N T F  T R A C E  */
/*-------------------------------------------------------------------------
    %%Function: RetailPrintfTrace

    Print retail information to a file
-------------------------------------------------------------------------*/
VOID WINAPI RetailPrintfTrace(LPCSTR pszFormat,...)
{
	HANDLE  hFile;
	va_list v1;
	CHAR    szOutput[1024];

	if (!FEnabledRetailPrintf())
		return;  // Retail output is disabled

	va_start(v1, pszFormat);


#ifdef DEBUG
	// Also use normal output mechanism for debug builds
	_DbgPrintf(NULL, "Retail:PrintfTrace", pszFormat, v1);
#endif

	wvsprintfA(szOutput, pszFormat, v1);

	// Always append the CRLF
	ASSERT(lstrlenA(szOutput) < (CCHMAX(szOutput)-2));
	lstrcatA(szOutput, "\r\n");


	// open a log file for appending. create if does not exist
	hFile = CreateFile(gszRetailOutputFilename, GENERIC_WRITE,
		0, NULL, OPEN_ALWAYS, FILE_ATTRIBUTE_NORMAL, (HANDLE)NULL);
	if (hFile != INVALID_HANDLE_VALUE)
	{
		// seek to end of file
		DWORD dw = SetFilePointer(hFile, 0, NULL, FILE_END);
		WriteFile(hFile, szOutput, lstrlenA(szOutput), &dw, NULL);
		CloseHandle(hFile);
	}
	
	va_end(v1);
}

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\remdsk\rds\nmutil\memory.cpp ===
//
// File: memory.cpp
//
// Debug memory tracking per-module

#include "precomp.h"


static BOOL   s_fZeroInit = FALSE;




#if defined(DEBUG)

#define DBG_NAME_LENGTH     16
typedef struct tagMemTag
{
    DWORD       dwSignature;
    BOOL        fActive;
    LPVOID      callerAddress;
    CHAR        szFileName[DBG_NAME_LENGTH];
    UINT        nLineNumber;
    UINT        cbSize;
    struct tagMemTag *next;
}
MEM_TAG;

static MEM_TAG *s_pDbgActiveMemPool = NULL;
#define CLEAN_BYTE  ((BYTE) 0xCD)

static UINT   s_cDbgActiveMemAlloc = 0;
static UINT   s_cbDbgActiveMem = 0;
const DWORD MEM_TAG_SIGNATURE = 0x12345678UL;

static CRITICAL_SECTION s_DbgCritSect;
static char  s_szDbgModuleName[DBG_NAME_LENGTH] = { 0 };
static void _GetFileName(LPSTR pszTarget, LPSTR pszSrc);
static void _DbgGetFileLine(LPSTR *, UINT *);

#define DBG_MEM_TRACK_DUMP_ALL      ((UINT) -1)





//
// DbgMemTrackReverseList()
//
void WINAPI DbgMemTrackReverseList(void)
{
    EnterCriticalSection(&s_DbgCritSect);
    if (NULL != s_pDbgActiveMemPool && NULL != s_pDbgActiveMemPool->next)
    {
        MEM_TAG *p, *q, *r;;

        for (q = (p = s_pDbgActiveMemPool)->next, r = q; // make sure r is not null in the beginning
             NULL != r;
             p = q, q = r)
        {
            r = q->next;
            q->next = p;
        }

        s_pDbgActiveMemPool->next = NULL;
        s_pDbgActiveMemPool = p;
    }
    LeaveCriticalSection(&s_DbgCritSect);
}


//
// DbgMemTrackDumpCurrent()
//
void WINAPI DbgMemTrackDumpCurrent(void)
{
    MEM_TAG *p;
    int i;
    char szBuf[128];

    EnterCriticalSection(&s_DbgCritSect);
    for (p = s_pDbgActiveMemPool, i = 0; p; p = p->next, i++)
    {
        if (p->callerAddress)
        {
            // No file/line, just caller
            wsprintfA(szBuf, "%s: mem leak [%u]: caller address=0x%p, size=%u, ptr=0x%p\r\n",
                s_szDbgModuleName, i,
                p->callerAddress, p->cbSize, (p+1));
        }
        else
        {
            // File & line number
            wsprintfA(szBuf, "%s: mem leak [%u]: file=%s, line=%u, size=%u, ptr=0x%p\r\n",
                s_szDbgModuleName, i,
                p->szFileName, p->nLineNumber, p->cbSize, (p+1));
        }
        OutputDebugStringA(szBuf);
    }
    LeaveCriticalSection(&s_DbgCritSect);
}


//
// DbgMemTrackFinalCheck()
//
// Dumps any left-around (leaked) memory blocks.  Call this on
// DLL_PROCESS_DETACH from your .DLL or at the end of WinMain of your .EXE
//
void WINAPI DbgMemTrackFinalCheck(void)
{
    DbgMemTrackReverseList();
    DbgMemTrackDumpCurrent();
    if (NULL != s_pDbgActiveMemPool ||
        NULL != s_cDbgActiveMemAlloc ||
        NULL != s_cbDbgActiveMem)
    {
        DebugBreak();
    }

    DeleteCriticalSection(&s_DbgCritSect);
}


//
// _GetFileName()
//
static void _GetFileName(LPSTR pszTarget, LPSTR pszSrc)
{
    LPSTR psz = pszSrc;
    while (*psz != '\0')
    {
        if (*psz++ == '\\')
        {
            pszSrc = psz;
        }
    }
    lstrcpynA(pszTarget, pszSrc, DBG_NAME_LENGTH);
}


//
// DbgMemAlloc()
//
// Debug memory allocation
//
LPVOID WINAPI DbgMemAlloc
(
    UINT    cbSize,
    LPVOID  callerAddress,
    LPSTR   pszFileName,
    UINT    nLineNumber
)
{
    MEM_TAG *p;
    UINT cbToAlloc;

    cbToAlloc = sizeof(MEM_TAG) + cbSize;

    EnterCriticalSection(&s_DbgCritSect);

    p = (MEM_TAG *) LocalAlloc(LPTR, cbToAlloc);
    if (p != NULL)
    {
        p->dwSignature = MEM_TAG_SIGNATURE;
        p->fActive = TRUE;
        p->callerAddress = callerAddress;

        if (pszFileName)
        {
            _GetFileName(p->szFileName, pszFileName);
            p->nLineNumber = nLineNumber;
        }

        p->cbSize = cbSize;
        p->next = s_pDbgActiveMemPool;
        s_pDbgActiveMemPool = p;
        s_cDbgActiveMemAlloc++;
        s_cbDbgActiveMem += p->cbSize;
        p++;

        //
        // If no zero-init, fill with clean byte
        //
        if (!s_fZeroInit)
        {
            FillMemory(p, cbSize, CLEAN_BYTE);
        }
    }

    LeaveCriticalSection(&s_DbgCritSect);

    return (LPVOID) p;
}


//
// DbgMemFree()
//
// Debug memory free
//
void WINAPI DbgMemFree(LPVOID ptr)
{
    if (ptr != NULL)
    {
        MEM_TAG *p = (MEM_TAG *) ptr;
        p--;
        if (! IsBadWritePtr(p, sizeof(MEM_TAG)) &&
            (p->dwSignature == MEM_TAG_SIGNATURE))
        {
            if (! p->fActive)
            {
                //
                // This memory has been freed already.
                //
                ERROR_OUT(("DbgMemFree called with invalid pointer 0x%08x", p));
                return;
            }

            MEM_TAG *q, *q0;
            EnterCriticalSection(&s_DbgCritSect);
            for (q = s_pDbgActiveMemPool; q != NULL; q = (q0 = q)->next)
            {
                if (q == p)
                {
                    if (q == s_pDbgActiveMemPool)
                    {
                        s_pDbgActiveMemPool = p->next;
                    }
                    else
                    {
                        q0->next = p->next;
                    }
                    s_cDbgActiveMemAlloc--;
                    s_cbDbgActiveMem -= p->cbSize;
                    p->fActive = FALSE;

                    //
                    // Fill app pointer data with CLEAN_BYTE, to see if
                    // anybody tries later to access it after it's been
                    // freed.
                    //
                    FillMemory(p+1, p->cbSize, CLEAN_BYTE);
                    break;
                }
            }
            LeaveCriticalSection(&s_DbgCritSect);
        }
        else
        {
            ERROR_OUT(("DbgMemFree called with invalid pointer 0x%08x", p));
            return;
        }

        LocalFree(p);
    }
}


//
// DbgMemReAlloc()
//
// Debug memory reallocate
//
LPVOID WINAPI DbgMemReAlloc(LPVOID ptr, UINT cbSize, UINT uFlags, LPSTR pszFileName, UINT nLineNumber)
{
    MEM_TAG *p;
    void *q;

    if (ptr == NULL)
        return DbgMemAlloc(cbSize, 0, pszFileName, nLineNumber);

    p = (MEM_TAG *) ptr;
    p--;

    if (IsBadWritePtr(p, sizeof(MEM_TAG)) ||
        p->dwSignature != MEM_TAG_SIGNATURE)
    {
        DebugBreak();
        return LocalReAlloc(ptr, cbSize, uFlags);
    }

    q = DbgMemAlloc(cbSize, 0, pszFileName, nLineNumber);
    if (q != NULL)
    {
        CopyMemory(q, ptr, p->cbSize);
        DbgMemFree(ptr);
    }

    return q;
}


typedef struct
{
    DWORD    dwThreadID;
    LPSTR    pszFileName;
    UINT    nLineNumber;
}
DBG_THREAD_FILE_LINE;

#define DBG_MAX_THREADS     32
static DBG_THREAD_FILE_LINE s_aThreadFileLine[DBG_MAX_THREADS] = { 0 };

void WINAPI DbgSaveFileLine(LPSTR pszFileName, UINT nLineNumber)
{
    DWORD dwThreadID = GetCurrentThreadId();

    EnterCriticalSection(&s_DbgCritSect);
    UINT c = DBG_MAX_THREADS;
    DBG_THREAD_FILE_LINE *p;
    for (p = s_aThreadFileLine; c--; p++)
    {
        if (p->dwThreadID == 0)
        {
            p->dwThreadID = dwThreadID;
            p->pszFileName = pszFileName;
            p->nLineNumber = nLineNumber;
            break;
        }
        else
        if (p->dwThreadID == dwThreadID)
        {
            p->pszFileName = pszFileName;
            p->nLineNumber = nLineNumber;
            break;
        }
    }
    LeaveCriticalSection(&s_DbgCritSect);
}

void WINAPI DbgGetFileLine(LPSTR *ppszFileName, UINT *pnLineNumber)
{
    *ppszFileName = NULL;
    *pnLineNumber = 0;

    DWORD dwThreadID = GetCurrentThreadId();

    EnterCriticalSection(&s_DbgCritSect);
    UINT c = DBG_MAX_THREADS;
    DBG_THREAD_FILE_LINE *p;
    for (p = s_aThreadFileLine; c--; p++)
    {
        if (p->dwThreadID == 0)
        {
            break;
        }
        else if (p->dwThreadID == dwThreadID)
        {
            *ppszFileName = p->pszFileName;
            *pnLineNumber = p->nLineNumber;
            p->pszFileName = NULL;
            p->nLineNumber = 0;
            break;
        }
    }
    LeaveCriticalSection(&s_DbgCritSect);
}



LPVOID __cdecl ::operator new(size_t uObjSize)
{
    LPVOID  callerAddress;
    LPSTR   pszFileName;
    UINT    nLineNumber;

    DbgGetFileLine(&pszFileName, &nLineNumber);

    if (pszFileName)
    {
        callerAddress = NULL;
    }
    else
    {
#ifdef _X86_
        LPVOID * lpParams;

        //
        // LAURABU HACK:  This doesn't work for alpha.  But it's not bad
        // for normal debugging.  We're going to grab the return address
        // of whomever called new()
        //
        lpParams = (LPVOID *)&uObjSize;
        callerAddress = *(lpParams - 1);
#else
        callerAddress = NULL;
#endif // _X86_
    }

    return(DbgMemAlloc(uObjSize, callerAddress, pszFileName, nLineNumber));
}

#else       // RETAIL


LPVOID __cdecl ::operator new(size_t uObjSize)
{
    if (s_fZeroInit)
    {
        return(LocalAlloc(LPTR, uObjSize));
    }
    else
    {
        return(LocalAlloc(LMEM_FIXED, uObjSize));
    }
}

#endif // defined(DEBUG)



//
// delete() is the same for both debug and retail
//
void __cdecl  ::operator delete(LPVOID pObj)
{
    MemFree(pObj);
}


//
// DbgInitMemTrack()
//
// Initialize debug memory tracking.  Call this on DLL_PROCESS_ATTACH in
// your .DLL or at beginning of WinMain of your .EXE
//
void WINAPI DbgInitMemTrack(HINSTANCE hDllInst, BOOL fZeroInit)
{
    s_fZeroInit = fZeroInit;

#if defined(DEBUG)
    InitializeCriticalSection(&s_DbgCritSect);

    char szPath[MAX_PATH];
    if (0 != GetModuleFileNameA(hDllInst, szPath, MAX_PATH))
    {
        _GetFileName(s_szDbgModuleName, szPath);
        LPSTR psz = s_szDbgModuleName;
        while (*psz != '\0')
        {
            if (*psz == '.')
            {
                *psz = '\0';
                break;
            }
            psz++;
        }
    }
    else
    {
        lstrcpyA(s_szDbgModuleName, "unknown");
    }
#endif // DEBUG
}

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\remdsk\rds\nmutil\oblist.cpp ===
// ChrisPi: This is a quick attempt to create a list class that uses the
// same member functions and parameters as MFC's CObList.  Only the members
// used in DCL's master objects are implemented.

#include "precomp.h"
#include <oblist.h>

#ifdef DEBUG
VOID* COBLIST::GetHead()
{
	ASSERT(m_pHead);

	return m_pHead->pItem;
}
#endif // ifdef DEBUG
   
VOID* COBLIST::GetTail()
{
	ASSERT(m_pTail);

	return m_pTail->pItem;
}

VOID* COBLIST::GetNext(POSITION& rPos)
{
	ASSERT(rPos);
	
	VOID* pReturn = rPos->pItem;
	rPos = rPos->pNext;

	return pReturn;
}

VOID* COBLIST::RemoveAt(POSITION Pos)
{
	VOID* pReturn = NULL;

	if (m_pHead)
	{
		if (m_pHead == Pos)
		{
			// Removing the first element in the list
			
			m_pHead = Pos->pNext;
			pReturn = Pos->pItem;
			delete Pos;

			if (NULL == m_pHead)
			{
				// Removing the only element!
				m_pTail = NULL;
			}
		}
		else
		{
			POSITION pCur = m_pHead;

			while (pCur && pCur->pNext)
			{
				if (pCur->pNext == Pos)
				{
					// Removing 
					
					pCur->pNext = Pos->pNext;
					if (m_pTail == Pos)
					{
						m_pTail = pCur;
					}
					pReturn = Pos->pItem;
					delete Pos;
				}

				pCur = pCur->pNext;
			}
		}
	}

	return pReturn;
}

POSITION COBLIST::AddTail(VOID* pItem)
{
	POSITION posRet = NULL;

	if (m_pTail)
	{
		if (m_pTail->pNext = new COBNODE)
		{
			m_pTail = m_pTail->pNext;
			m_pTail->pItem = pItem;
			m_pTail->pNext = NULL;
		}
	}
	else
	{
		ASSERT(!m_pHead);
		if (m_pHead = new COBNODE)
		{
			m_pTail = m_pHead;
			m_pTail->pItem = pItem;
			m_pTail->pNext = NULL;
		}
	}

	return m_pTail;
}

void COBLIST::EmptyList()
{
    while (!IsEmpty()) {
        RemoveAt(GetHeadPosition());
    }
}

COBLIST::~COBLIST()
{
    ASSERT(IsEmpty());
}

#ifdef DEBUG

#if 0
VOID* COBLIST::RemoveTail()
{
	ASSERT(m_pHead);
	ASSERT(m_pTail);
	
	return RemoveAt(m_pTail);
}
#endif

VOID* COBLIST::RemoveHead()
{
	ASSERT(m_pHead);
	ASSERT(m_pTail);
	
	return RemoveAt(m_pHead);
}

void * COBLIST::GetFromPosition(POSITION Pos)
{
    void * Result = SafeGetFromPosition(Pos);
	ASSERT(Result);
	return Result;
}
#endif /* if DEBUG */

POSITION COBLIST::GetPosition(void* _pItem)
{
    // For potential efficiency of lookup (if we switched to 
    // a doubly linked list), users should really store the POSITION
    // of an item. For those that don't, this method is provided.

    POSITION    Position = m_pHead;

    while (Position) {
        if (Position->pItem == _pItem) {
            break;
        }
		GetNext(Position);
    }
    return Position;
}

POSITION COBLIST::Lookup(void* pComparator)
{
    POSITION    Position = m_pHead;

    while (Position) {
        if (Compare(Position->pItem, pComparator)) {
            break;
        }
		GetNext(Position);
    }
    return Position;
}

void * COBLIST::SafeGetFromPosition(POSITION Pos)
{
	// Safe way to validate that an entry is still in the list,
	// which ensures bugs that would reference deleted memory,
	// reference a NULL pointer instead
	// (e.g. an event handler fires late/twice).
	// Note that versioning on entries would provide an additional 
	// safeguard against re-use of a position.
	// Walk	list to find entry.

	POSITION PosWork = m_pHead;
	
	while (PosWork) {
		if (PosWork == Pos) {
			return Pos->pItem;
		}
		GetNext(PosWork);
	}
	return NULL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\remdsk\rds\nmutil\precomp.h ===
#ifndef _PRECOMP_H_
#define _PRECOMP_H_

#include <windows.h>
#include <tchar.h>
#include <limits.h>
#include <shlobj.h>
#include <wincrypt.h>

#include "memtrack.h"

#ifdef __cplusplus
extern "C" {
#endif /* __cplusplus */

#include "stock.h"
#include "olestock.h"

#ifdef DEBUG
#include "resstr.h"
#endif /* DEBUG */

#include "confdbg.h"
#include "debspew.h"
#include "valid.h"


#ifdef __cplusplus
}
#endif /* __cplusplus */


#endif /* _PRECOMP_H_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\remdsk\rds\nmutil\hextostr.cpp ===
// HEXTOSTR.CPP
//
// Utility functions to convert hexadecimal numbers into equivalent string
// representations.
//
// Note:  These functions are in their own file, rather than in STRUTIL.CPP,
// because they use a const array.  The current implementation of the linker
// pulls this array into binaries if they use any function in the source file,
// not just the functions which reference this array.

#include "precomp.h"
#include <strutil.h>


const CHAR rgchHexNumMap[] =
{
	'0', '1', '2', '3', '4', '5', '6', '7',
	'8', '9', 'A', 'B', 'C', 'D', 'E', 'F'
};

//
// QWordToHexString()
//
// Converts a ULARGE_INTEGER to an ANSI string (not prefixed with 0x or 0X)
//
// NOTE: pszString must point to a buffer of at least CCHMAX_ULARGE_INTEGER chars
//
// Returns the number of characters written (not including the NULL terminator)

int  QWordToHexStringA(ULARGE_INTEGER qw, LPSTR pszString)
{
	ASSERT(!IsBadWritePtr(pszString, sizeof(*pszString)*CCHMAX_HEX_ULARGE_INTEGER));

	LPSTR pszCurrent = pszString;
	DWORD dwQwParts[] = {qw.HighPart, qw.LowPart};
	int i;

	// Walk the QWORD four bits at a time, mapping them to the appropriate
	// char and storing them in the caller-supplied buffer.

	// We loop through the QWORD twice, working on each DWORD separately
	for (i = 0; i < ARRAY_ELEMENTS(dwQwParts); i++)
	{
		DWORD dwQwPart = dwQwParts[i];

		// Optimization:  We only need to look at this DWORD part if it's
		// non-zero or we've already put chars in our buffer.
		if (dwQwPart || pszCurrent != pszString)
		{
			// <j> is the zero-based index of the low bit of the four-bit
			// range on which we're operating.
			int j;
			DWORD dwMask;

			for (j = BITS_PER_HEX_CHAR * (CCH_HEX_DWORD - 1),
					dwMask = 0xFL << j;
				 j >= 0;
				 j -= BITS_PER_HEX_CHAR,
					dwMask >>= BITS_PER_HEX_CHAR)
			{
				DWORD iDigit = (dwQwPart & dwMask) >> j;

				ASSERT(0 <= iDigit && 0xF >= iDigit);

				// We use this test to skip leading zeros
				if (pszCurrent != pszString || iDigit)
				{
					*pszCurrent++ = rgchHexNumMap[iDigit];
				}
			}
		}
	}

	// If the number was zero, we need to set it explicitly
	if (pszCurrent == pszString)
	{
		*pszCurrent++ = '0';
	}

	// Null terminate the string
	*pszCurrent = '\0';

	// Return the number of chars, not counting the null terminator
	return (int)(pszCurrent - pszString);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\remdsk\rds\nmutil\mlzdbg.cpp ===
#include "precomp.h"

#if defined(_DEBUG) && ! defined(_UNICODE)

#define MULTI_LEVEL_ZONES
#include <mlzdbg.h>

HDBGZONE g_hDbgZones;

void WINAPI MLZ_DbgInit(PSTR *apszZones, UINT cZones)
{
    // if registry is empty, set warning flag as default
    DbgInitEx(&g_hDbgZones, apszZones, cZones, ZONE_WARNING_FLAG);

    // if the warning flag is not set, then set it as default
    if (g_hDbgZones != NULL)
    {
        ((PZONEINFO) g_hDbgZones)->ulZoneMask |= ZONE_WARNING_FLAG;
    }
}

void WINAPI MLZ_DbgDeInit(void)
{
    DbgDeInit(&g_hDbgZones);
}

void WINAPIV MLZ_WarningOut(PSTR pszFormat, ...)
{
	if (g_hDbgZones != NULL &&
        IS_ZONE_ENABLED(g_hDbgZones, ZONE_WARNING_FLAG))
	{
		va_list args;
		va_start(args, pszFormat);
		DbgPrintf(NULL, pszFormat, args);
		va_end(args);
	}
}

BOOL WINAPI MLZ_TraceZoneEnabled(int iZone)
{
	return (g_hDbgZones != NULL &&
            IS_ZONE_ENABLED(g_hDbgZones, ZONE_TRACE_FLAG) &&
	        IS_ZONE_ENABLED(g_hDbgZones, ZONE_FLAG(iZone)));
}

void WINAPIV MLZ_TraceOut(PSTR pszFormat, ...)
{
	va_list args;
	va_start(args, pszFormat);
	DbgPrintf(NULL, pszFormat, args);
	va_end(args);
}

void WINAPI MLZ_EntryOut(int iZone, PSTR pszFunName)
{
	if (g_hDbgZones != NULL &&
        IS_ZONE_ENABLED(g_hDbgZones, ZONE_FUNCTION_FLAG) &&
	    IS_ZONE_ENABLED(g_hDbgZones, ZONE_FLAG(iZone)))
	{
        MLZ_TraceOut("%s() entered.", pszFunName);
    }
}

void WINAPI MLZ_ExitOut(int iZone, PSTR pszFunName, RCTYPE eRetCodeType, DWORD_PTR dwRetCode)
{
	if (g_hDbgZones != NULL &&
        IS_ZONE_ENABLED(g_hDbgZones, ZONE_FUNCTION_FLAG) &&
	    IS_ZONE_ENABLED(g_hDbgZones, ZONE_FLAG(iZone)))
	{
        PSTR pszRetCode;
        char szFormat[64];

        lstrcpyA(&szFormat[0], "%s() exiting...");
        pszRetCode = &szFormat[0] + lstrlenA(&szFormat[0]);

        if (eRetCodeType != RCTYPE_VOID)
        {
            lstrcpyA(pszRetCode, " rc=");
            pszRetCode += lstrlenA(pszRetCode);

    	    switch (eRetCodeType)
    	    {
    	    case RCTYPE_BOOL:
    	        lstrcpyA(pszRetCode, dwRetCode ? "TRUE" : "FALSE");
    	        break;
    	    case RCTYPE_DWORD:
    	    case RCTYPE_HRESULT:
    	        wsprintf(pszRetCode, "0x%lx", (DWORD)dwRetCode);
    	        break;
    	    case RCTYPE_INT:
    	        wsprintf(pszRetCode, "%ld", (LONG) dwRetCode);
    	        break;
    	    case RCTYPE_ULONG:
    	        wsprintf(pszRetCode, "%lu", (ULONG) dwRetCode);
    	        break;
    	    case RCTYPE_PTR:
    	        wsprintf(pszRetCode, "%p", dwRetCode);
    	        break;
    	    default:
    	        ASSERT(0);
    	        break;
    	    }
        }
        MLZ_TraceOut(&szFormat[0], pszFunName);
    }
}

#endif // _DEBUG && ! _UNICODE


=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\remdsk\rds\nmutil\debspew.cpp ===
// File: DebSpew.cpp

#include "precomp.h"
#include <confreg.h>
#include <RegEntry.h>


#ifdef DEBUG /* THE WHOLE FILE! */

#if defined (_M_IX86)
#define _DbgBreak()  __asm { int 3 }
#else
#define _DbgBreak() DebugBreak()
#endif

/* Types
 ********/

PCSTR g_pcszSpewModule = NULL;

/* debug flags */

typedef enum _debugdebugflags
{
   DEBUG_DFL_ENABLE_TRACE_MESSAGES  = 0x0001,

   DEBUG_DFL_LOG_TRACE_MESSAGES     = 0x0002,

   DEBUG_DFL_ENABLE_CALL_TRACING    = 0x0008,

   ALL_DEBUG_DFLAGS                 = (DEBUG_DFL_ENABLE_TRACE_MESSAGES |
                                       DEBUG_DFL_LOG_TRACE_MESSAGES |
                                       DEBUG_DFL_ENABLE_CALL_TRACING)
}
DEBUGDEBUGFLAGS;


/* Global Variables
 *******************/


#pragma data_seg(DATA_SEG_PER_INSTANCE)

/* parameters used by SpewOut() */

DWORD g_dwSpewFlags = 0;
UINT g_uSpewSev = 0;
UINT g_uSpewLine = 0;
PCSTR g_pcszSpewFile = NULL;

HDBGZONE  ghDbgZone = NULL;


/* debug flags */

DWORD s_dwDebugModuleFlags = 0;

#pragma data_seg()



/***************************** Private Functions *****************************/

/* Module Prototypes
 ********************/

BOOL IsValidSpewSev(UINT);


/*
** IsValidSpewSev()
**
**
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
BOOL IsValidSpewSev(UINT uSpewSev)
{
   BOOL bResult;

   switch (uSpewSev)
   {
      case SPEW_TRACE:
      case SPEW_CALLTRACE:
      case SPEW_WARNING:
      case SPEW_ERROR:
      case SPEW_FATAL:
         bResult = TRUE;
         break;

      default:
         ERROR_OUT(("IsValidSpewSev(): Invalid debug spew severity %u.",
                    uSpewSev));
         bResult = FALSE;
         break;
   }

   return(bResult);
}


/****************************** Public Functions *****************************/


DWORD  GetDebugOutputFlags(VOID)
{
	return s_dwDebugModuleFlags;
}

VOID  SetDebugOutputFlags(DWORD dw)
{
	ASSERT(FLAGS_ARE_VALID(dw, ALL_DEBUG_DFLAGS));
	s_dwDebugModuleFlags = dw;
}


/*
** InitDebugModule()
**
**
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
BOOL  InitDebugModule(PCSTR pcszSpewModule)
{
	s_dwDebugModuleFlags = 0;

    g_pcszSpewModule = pcszSpewModule;

	if (NULL == ghDbgZone)
	{
		PSTR rgsz[4];
		rgsz[0] = (PSTR) pcszSpewModule;

		ASSERT(0 == ZONE_WARNING);
		rgsz[1+ZONE_WARNING]  = "Warning";

		ASSERT(1 == ZONE_TRACE);
		rgsz[1+ZONE_TRACE]    = "Trace";

		ASSERT(2 == ZONE_FUNCTION);
		rgsz[1+ZONE_FUNCTION] = "Function";

		// Initialize standard debug settings with warning enabled by default
		DbgInitEx(&ghDbgZone, rgsz, 3, 0x01);
	}

	return TRUE;
}


/*
** ExitDebugModule()
**
**
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
void  ExitDebugModule(void)
{
	g_pcszSpewModule = NULL;
	DBGDEINIT(&ghDbgZone);
}




/*  _  D B G  Z  P R I N T  M S G  */
/*-------------------------------------------------------------------------
    %%Function: _DbgZPrintMsg

-------------------------------------------------------------------------*/
static VOID _DbgZPrintMsg(UINT iZone, PSTR pszFormat, va_list arglist)
{
	PCSTR pcszSpewPrefix;
	char  szModule[128];

    if (g_pcszSpewModule)
    {
    	switch (iZone)
	 	{
        	case ZONE_TRACE:
		        pcszSpewPrefix = "Trace";
        		break;
        	case ZONE_FUNCTION:
		        pcszSpewPrefix = "Func ";
        		break;
        	case ZONE_WARNING:
		        pcszSpewPrefix = "Warn ";
        		break;
        	default:
		        pcszSpewPrefix = "?????";
        		break;
		}

    	wsprintfA(szModule, "%s:%s", g_pcszSpewModule, pcszSpewPrefix);
    }
    else
    {
        // No module nonsense, empty prefix
        wsprintfA(szModule, "%s", "");
    }

	DbgPrintf(szModule, pszFormat, arglist);
}


VOID WINAPI DbgZPrintError(PSTR pszFormat,...)
{
    va_list v1;
    va_start(v1, pszFormat);

    _DbgZPrintMsg(ZONE_WARNING, pszFormat, v1);
    va_end(v1);

    _DbgBreak();
}


VOID WINAPI DbgZPrintWarning(PSTR pszFormat,...)
{
	if (GETZONEMASK(ghDbgZone) & ZONE_WARNING_FLAG)
	{
		va_list v1;
		va_start(v1, pszFormat);
		
		_DbgZPrintMsg(ZONE_WARNING, pszFormat, v1);
		va_end(v1);
	}
}

VOID WINAPI DbgZPrintTrace(PSTR pszFormat,...)
{
	if (GETZONEMASK(ghDbgZone) & ZONE_TRACE_FLAG)
	{
		va_list v1;
		va_start(v1, pszFormat);
		_DbgZPrintMsg(ZONE_TRACE, pszFormat, v1);
		va_end(v1);
	}
}

VOID WINAPI DbgZPrintFunction(PSTR pszFormat,...)
{
	if (GETZONEMASK(ghDbgZone) & ZONE_FUNCTION_FLAG)
	{
		va_list v1;
		va_start(v1, pszFormat);
		_DbgZPrintMsg(ZONE_FUNCTION, pszFormat, v1);
		va_end(v1);
	}
}



#endif   /* DEBUG */


=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\remdsk\rds\nmutil\purecall.cpp ===
#include "precomp.h"

// Handle errors referencing an object's virtual function table.
// This should never happen!

int _cdecl _purecall(void)
{
	ASSERT(FALSE);
	return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\remdsk\rds\nmutil\sources.inc ===
# SOURCES.INC
#
# Common portions of SOURCES files used in both the Ansi and Unicode
# subdirectories of NMUTIL.
#
# The SOURCES_SUBDIR variable must be defined in the including SOURCES
# file for this INC file to work.

!ifndef SOURCES_SUBDIR
!error Your .\sources. file must define the SOURCES_SUBDIR= macro
!endif

!include $(DEVROOT)\common.inc

MAJORCOMP=common
MINORCOMP=$(SOURCES_SUBDIR)

TARGETNAME=$(SOURCES_SUBDIR)
TARGETPATH=$(_OBJ_DIR)
TARGETTYPE=LIBRARY

C_DEFINES=$(C_DEFINES) -DOS_WIN95
ASM_DEFINES=$(ASM_DEFINES)

386_STDCALL=1

# Always enable intrinsics
USER_C_FLAGS=/Oi

#
# MIDL-generated header file
#

USER_INCLUDES=uls2.h

#
# Parameters for MIDL
#

IDL_TYPE=ole
PASS0_HEADERDIR = $(ROOT)\nmutil\$(SOURCES_SUBDIR)
MIDL_UUIDDIR = $(ROOT)\nmutil\$(SOURCES_SUBDIR)

#
# List of sources
#

SOURCES=..\bstring.cpp  \
        ..\cstring.cpp  \
        ..\custring.cpp \
        ..\dbg.cpp      \
        ..\debspew.cpp  \
        ..\memory.cpp   \
        ..\oblist.cpp   \
        ..\purecall.cpp \
        ..\referenc.cpp \
        ..\regentry.cpp \
        ..\resstr.cpp   \
        ..\strutil.cpp  \
        ..\strtohex.cpp \
        ..\hextostr.cpp \
        ..\utf8str.cpp  \
        ..\valid.cpp    \
        ..\mlzdbg.cpp   \
        ..\hash.cpp

#
# Precompiled specs
#

PRECOMPILED_INCLUDE = ..\precomp.h
PRECOMPILED_PCH = precomp.pch
PRECOMPILED_OBJ = precomp.obj
PRECOMPILED_CXX = 1

CONDITIONAL_INCLUDES = \
subwtype.h	\
macocidl.h	\
macwin32.h	\
rpcerr.h	\
rpcmac.h	\
winwlm.h	\
macname1.h	\
macname2.h	\
macpub.h	\
macapi.h
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\remdsk\rds\nmutil\referenc.cpp ===
#include "precomp.h"
#include "referenc.h"

REFCOUNT::REFCOUNT() :
	NumRefs(0),
	bMarkedForDelete(FALSE),
	bOnStack(FALSE)
{
}

REFCOUNT::~REFCOUNT()
{
	// Objects being destroyed should have no
	// outstanding references to them and should
	// have been explicitly deleted.

	ASSERT(NumRefs == 0);
	ASSERT(bOnStack || bMarkedForDelete);
}

DWORD REFCOUNT::AddRef()
{
	NumRefs++;
	return(NumRefs);
}

DWORD REFCOUNT::Release()
{
	ASSERT(NumRefs);

    DWORD   CurrentNumRefs = --NumRefs; // Save because object may be deleted

	if(!CurrentNumRefs) {
		if(bMarkedForDelete) {
            if (!bOnStack) {
			    delete this;
            }
		}
	}
    return CurrentNumRefs;
}

DWORD REFCOUNT::Delete()
{
    DWORD   CurrentNumRefs = NumRefs; // Save because object may be deleted
	REFERENCE	r(this);

	bMarkedForDelete = TRUE;
    return(CurrentNumRefs);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\remdsk\rds\nmutil\regentry.cpp ===
/*****************************************************************/
/**				  Microsoft Windows for Workgroups				**/
/**			  Copyright (C) Microsoft Corp., 1995-1996			**/
/*****************************************************************/

/*
	regentry.cpp
	registry access classes

	This file contains classes which enable
    convenient access the registry for entries.

	FILE HISTORY:
		lens	10/15/95	Created
		ChrisPi	6/21/96		Added GetBinary(), SetValue() for binary
*/

#include "precomp.h"
#include <regentry.h>
#include <strutil.h>

RegEntry::RegEntry(LPCTSTR pszSubKey, HKEY hkey, BOOL fCreate, REGSAM samDesired)
 : m_pbValueBuffer(NULL),
   m_cbValueBuffer(0),
   m_fValuesWritten(FALSE),
   m_szNULL('\0')
{
	// Open with desired access if it is specified explicitly; otherwise, use
	// the default access.
	if (samDesired) {
		if (fCreate) {
			DWORD dwDisposition;

			m_error = ::RegCreateKeyEx(hkey, 
									pszSubKey, 
									0, 
									NULL, 
									REG_OPTION_NON_VOLATILE,
									samDesired, 
									NULL, 
									&m_hkey, 
									&dwDisposition);
		}
		else {
			m_error = ::RegOpenKeyEx(hkey, pszSubKey, 0, samDesired, &m_hkey);
		}
	}
	else {
		if (fCreate) {
			m_error = ::RegCreateKey(hkey, pszSubKey, &m_hkey);
		}
		else {
			m_error = ::RegOpenKey(hkey, pszSubKey, &m_hkey);
		}
	}

	m_fhkeyValid = (m_error == ERROR_SUCCESS);
}


RegEntry::~RegEntry()
{
	ChangeKey(NULL);
	delete [] m_pbValueBuffer;
}


VOID RegEntry::ChangeKey(HKEY hNewKey)
{
	// hNewKey assumed to be valid or never used
	// (as in destructor).

	if (m_fValuesWritten) {
		FlushKey();		
	}
    if (m_fhkeyValid) {
        ::RegCloseKey(m_hkey); 
    }
	m_hkey = hNewKey;	
}

VOID RegEntry::UpdateWrittenStatus()
{
	if (m_error == ERROR_SUCCESS) {
		m_fValuesWritten = TRUE;
	}
}

long RegEntry::SetValue(LPCTSTR pszValue, LPCTSTR string)
{
    if (m_fhkeyValid) {
    	m_error = ::RegSetValueEx(m_hkey, pszValue, 0, REG_SZ,
    				(LPBYTE)string, (lstrlen(string)+1) * sizeof(*string));
		UpdateWrittenStatus();
    }
	return m_error;
}

long RegEntry::SetValue(LPCTSTR pszValue, unsigned long dwNumber)
{
    if (m_fhkeyValid) {
    	m_error = ::RegSetValueEx(m_hkey, pszValue, 0, REG_BINARY,
    				(LPBYTE)&dwNumber, sizeof(dwNumber));
		UpdateWrittenStatus();
    }
	return m_error;
}

long RegEntry::SetValue(LPCTSTR pszValue,
						void* pData,
						DWORD cbLength)
{
    if (m_fhkeyValid) {
    	m_error = ::RegSetValueEx(	m_hkey,
								pszValue,
								0,
								REG_BINARY,
    							(LPBYTE) pData,
								cbLength);
		UpdateWrittenStatus();
    }
	return m_error;
}

long RegEntry::DeleteValue(LPCTSTR pszValue)
{
    if (m_fhkeyValid) {
    	m_error = ::RegDeleteValue(m_hkey, pszValue);
		UpdateWrittenStatus();
	}
	return m_error;
}

long RegEntry::GetNumber(LPCTSTR pszValue, long dwDefault)
{
 	DWORD 	dwType = REG_BINARY;
 	long	dwNumber = 0L;
 	DWORD	dwSize = sizeof(dwNumber);

    if (m_fhkeyValid) {
    	m_error = ::RegQueryValueEx(m_hkey, pszValue, 0, &dwType, (LPBYTE)&dwNumber,
    				&dwSize);
	}
	
	// If the call succeeded, make sure that the returned data matches our
	// expectations.
	ASSERT(m_error != ERROR_SUCCESS || 
			(REG_BINARY == dwType && sizeof(dwNumber) == dwSize) ||
			REG_DWORD == dwType);

	if (m_error != ERROR_SUCCESS)
		dwNumber = dwDefault;
	
	return dwNumber;
}


// The GetNumberIniStyle method performs the same function as GetNumber,
// but in a style compatible with the old GetPrivateProfileInt API.
// Specfically it means:
// - If the value is stored in the registry as a string, it attempts to
//   convert it to an integer.
// - If the value is negative, it returns 0.

ULONG RegEntry::GetNumberIniStyle(LPCTSTR pszValueName, ULONG dwDefault)
{
	DWORD 	dwType = REG_BINARY;
 	ULONG	dwNumber = 0L;
    DWORD   cbLength = m_cbValueBuffer;

    if (m_fhkeyValid) {
    	m_error = ::RegQueryValueEx(m_hkey, 
								pszValueName, 
								0, 
								&dwType, 
								m_pbValueBuffer,
								&cbLength);

		// Try again with a larger buffer if the first one is too small,
		// or if there wasn't already a buffer allocated.
		if ((ERROR_SUCCESS == m_error && NULL == m_pbValueBuffer)
			|| ERROR_MORE_DATA == m_error) {
			
			ASSERT(cbLength > m_cbValueBuffer);

			ResizeValueBuffer(cbLength);

        	m_error = RegQueryValueEx( m_hkey,
									  pszValueName,
									  0,
									  &dwType,
									  m_pbValueBuffer,
									  &cbLength );
		}

		if (ERROR_SUCCESS == m_error) {
			switch(dwType) {
				case REG_DWORD:
				case REG_BINARY:
					ASSERT(sizeof(dwNumber) == cbLength);

					dwNumber = * (LPDWORD) m_pbValueBuffer;
					break;

				case REG_SZ:
				{
					LONG lNumber = RtStrToInt((LPCTSTR) m_pbValueBuffer);

					// Convert negative numbers to zero, to match 
					// GetPrivateProfileInt's behavior.
					dwNumber = lNumber < 0 ? 0 : lNumber;
				}

					break;

				default:
					ERROR_OUT(("Invalid value type (%lu) returned by RegQueryValueEx()",
								dwType));
					break;
			}
		}
	}

	if (m_error != ERROR_SUCCESS) {
		dwNumber = dwDefault;
	}
	
	return dwNumber;
}


LPTSTR RegEntry::GetString(LPCTSTR pszValueName)
{
	DWORD 	dwType = REG_SZ;
    DWORD   length = m_cbValueBuffer;

    if (m_fhkeyValid) {
        m_error = ::RegQueryValueEx( m_hkey,
                                  pszValueName,
                                  0,
                                  &dwType,
                                  m_pbValueBuffer,
                                  &length );
		// Try again with a larger buffer if the first one is too small,
		// or if there wasn't already a buffer allocated.
		if ((ERROR_SUCCESS == m_error && NULL == m_pbValueBuffer)
			|| ERROR_MORE_DATA == m_error) {
			
			ASSERT(length > m_cbValueBuffer);

			ResizeValueBuffer(length);

        	m_error = ::RegQueryValueEx( m_hkey,
									  pszValueName,
									  0,
									  &dwType,
									  m_pbValueBuffer,
									  &length );
		}
		if (m_error == ERROR_SUCCESS) {
			if ((dwType != REG_SZ) && (dwType != REG_EXPAND_SZ)) {
				m_error = ERROR_INVALID_PARAMETER;
			}
		}
	}
    if ((m_error != ERROR_SUCCESS) || (length == 0)) {
		return &m_szNULL;
    }
	return (LPTSTR) m_pbValueBuffer;
}

DWORD RegEntry::GetBinary(	LPCTSTR pszValueName,
							void** ppvData)
{
	ASSERT(ppvData);
	DWORD 	dwType = REG_BINARY;
    DWORD   length = m_cbValueBuffer;

    if (m_fhkeyValid) {
        m_error = ::RegQueryValueEx( m_hkey,
                                  pszValueName,
                                  0,
                                  &dwType,
                                  m_pbValueBuffer,
                                  &length );
		// Try again with a larger buffer if the first one is too small,
		// or if there wasn't already a buffer allocated.
		if ((ERROR_SUCCESS == m_error && NULL == m_pbValueBuffer)
			|| ERROR_MORE_DATA == m_error) {
			
			ASSERT(length > m_cbValueBuffer);

			ResizeValueBuffer(length);

        	m_error = ::RegQueryValueEx( m_hkey,
									  pszValueName,
									  0,
									  &dwType,
									  m_pbValueBuffer,
									  &length );
		}
		if (m_error == ERROR_SUCCESS) {
			if (dwType != REG_BINARY) {
				m_error = ERROR_INVALID_PARAMETER;
			}
		}
	}
    if ((m_error != ERROR_SUCCESS) || (length == 0)) {
		*ppvData = NULL;
		length = 0;
    }
	else
	{
		*ppvData = m_pbValueBuffer;
	}
	return length;
}

// BUGBUG - Use LocalReAlloc instead of new/delete?
VOID RegEntry::ResizeValueBuffer(DWORD length)
{
	LPBYTE pbNewBuffer;

    if ((m_error == ERROR_SUCCESS || m_error == ERROR_MORE_DATA)
		&& (length > m_cbValueBuffer)) {
        pbNewBuffer = new BYTE[length];
        if (pbNewBuffer) {
			delete [] m_pbValueBuffer;
			m_pbValueBuffer = pbNewBuffer;
			m_cbValueBuffer = length;
		}
		else {
            m_error = ERROR_NOT_ENOUGH_MEMORY;
        }
	}
}

// BUGBUG - Support other OpenKey switches from constructor
VOID RegEntry::MoveToSubKey(LPCTSTR pszSubKeyName)
{
    HKEY	_hNewKey;

    if (m_fhkeyValid) {
        m_error = ::RegOpenKey ( m_hkey,
                              pszSubKeyName,
                              &_hNewKey );
        if (m_error == ERROR_SUCCESS) {
			ChangeKey(_hNewKey);
        }
    }
}

RegEnumValues::RegEnumValues(RegEntry *pReqRegEntry)
 : m_pRegEntry(pReqRegEntry),
   m_iEnum(0),
   m_pchName(NULL),
   m_pbValue(NULL)
{
    m_error = m_pRegEntry->GetError();
    if (m_error == ERROR_SUCCESS) {
        m_error = ::RegQueryInfoKey (m_pRegEntry->GetKey(), // Key
                                   NULL,                // Buffer for class string
                                   NULL,                // Size of class string buffer
                                   NULL,                // Reserved
                                   NULL,                // Number of subkeys
                                   NULL,                // Longest subkey name
                                   NULL,                // Longest class string
                                   &m_cEntries,         // Number of value entries
                                   &m_cMaxValueName,    // Longest value name
                                   &m_cMaxData,         // Longest value data
                                   NULL,                // Security descriptor
                                   NULL );              // Last write time
    }
    if (m_error == ERROR_SUCCESS) {
        if (m_cEntries != 0) {
            m_cMaxValueName++;	// REG_SZ needs one more for null
            m_cMaxData++;		// REG_SZ needs one more for null
            m_pchName = new TCHAR[m_cMaxValueName];
            if (!m_pchName) {
                m_error = ERROR_NOT_ENOUGH_MEMORY;
            }
            else {
                if (m_cMaxData) {
                    m_pbValue = new BYTE[m_cMaxData];
                    if (!m_pbValue) {
                        m_error = ERROR_NOT_ENOUGH_MEMORY;
                    }
                }
            }
        }
    }
}

RegEnumValues::~RegEnumValues()
{
    delete m_pchName;
    delete m_pbValue;
}

long RegEnumValues::Next()
{
    if (m_error != ERROR_SUCCESS) {
        return m_error;
    }
    if (m_cEntries == m_iEnum) {
        return ERROR_NO_MORE_ITEMS;
    }

    DWORD   cchName = m_cMaxValueName;

    m_dwDataLength = m_cMaxData;
    m_error = ::RegEnumValue ( m_pRegEntry->GetKey(), // Key
                            m_iEnum,               // Index of value
                            m_pchName,             // Address of buffer for value name
                            &cchName,            // Address for size of buffer
                            NULL,                // Reserved
                            &m_dwType,             // Data type
                            m_pbValue,             // Address of buffer for value data
                            &m_dwDataLength );     // Address for size of data
    m_iEnum++;
    return m_error;
}

RegEnumSubKeys::RegEnumSubKeys(RegEntry *pReqRegEntry)
 : m_pRegEntry(pReqRegEntry),
   m_iEnum(0),
   m_pchName(NULL)
{
    m_error = m_pRegEntry->GetError();
    if (m_error == ERROR_SUCCESS) {
        m_error = ::RegQueryInfoKey ( m_pRegEntry->GetKey(), // Key
                                   NULL,                // Buffer for class string
                                   NULL,                // Size of class string buffer
                                   NULL,                // Reserved
                                   &m_cEntries,           // Number of subkeys
                                   &m_cMaxKeyName,        // Longest subkey name
                                   NULL,                // Longest class string
                                   NULL,                // Number of value entries
                                   NULL,                // Longest value name
                                   NULL,                // Longest value data
                                   NULL,                // Security descriptor
                                   NULL );              // Last write time
    }
    if (m_error == ERROR_SUCCESS) {
        if (m_cEntries != 0) {
            m_cMaxKeyName = m_cMaxKeyName + 1; // needs one more for null
            m_pchName = new TCHAR[m_cMaxKeyName];
            if (!m_pchName) {
                m_error = ERROR_NOT_ENOUGH_MEMORY;
            }
        }
    }
}

RegEnumSubKeys::~RegEnumSubKeys()
{
    delete m_pchName;
}

long RegEnumSubKeys::Next()
{
    if (m_error != ERROR_SUCCESS) {
        return m_error;
    }
    if (m_cEntries == m_iEnum) {
        return ERROR_NO_MORE_ITEMS;
    }

    DWORD   cchName = m_cMaxKeyName;

    m_error = ::RegEnumKey ( m_pRegEntry->GetKey(), // Key
                          m_iEnum,               // Index of value
                          m_pchName,             // Address of buffer for subkey name
                          cchName);            // Size of buffer
    m_iEnum++;
    return m_error;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\remdsk\rds\nmutil\resstr.cpp ===
/*
 * resstr.c - Return code to string translation routines.
 *
 * Taken from URL code
 *
 * Created: ChrisPi 9-11-95
 *
 */


/* Headers
 **********/

#include "precomp.h"

/* Macros
 *********/

/*
 * macro for simplifying result to string translation, assumes result string
 * pointer pcsz
 */

#define STRING_CASE(val)               case val: pcsz = #val; break


/****************************** Public Functions *****************************/


#ifdef DEBUG

PCSTR GetINTString(int n)
{
   static char s_rgchINT[] = "-2147483646";

   wsprintfA(s_rgchINT, "%d", n);

   ASSERT(IS_VALID_STRING_PTR_A(s_rgchINT, CSTR));

   return(s_rgchINT);
}


PCSTR GetINT_PTRString(INT_PTR n)
{
   static char s_rgchINT[] = "-2147483646xxxxxxxxxx";

   wsprintfA(s_rgchINT, "%Id", n);

   ASSERT(IS_VALID_STRING_PTR_A(s_rgchINT, CSTR));

   return(s_rgchINT);
}


PCSTR GetULONGString(ULONG ul)
{
   static char s_rgchULONG[] = "4294967295";

   wsprintfA(s_rgchULONG, "%lx", ul);

   ASSERT(IS_VALID_STRING_PTR_A(s_rgchULONG, CSTR));

   return(s_rgchULONG);
}


PCSTR GetBOOLString(BOOL bResult)
{
   PCSTR pcsz;

   pcsz = bResult ? "TRUE" : "FALSE";

   ASSERT(IS_VALID_STRING_PTR_A(pcsz, CSTR));

   return(pcsz);
}


PCSTR GetPVOIDString(PVOID ptr)
{
   static char s_rgchPVOID[] = "0xffff0000ffff0000";

   wsprintfA(s_rgchPVOID, "0x%p", ptr);

   ASSERT(IS_VALID_STRING_PTR_A(s_rgchPVOID, CSTR));

   return(s_rgchPVOID);
}

PCSTR GetClipboardFormatNameString(UINT ucf)
{
   PCSTR pcsz;
   static char s_szCFName[MAX_PATH];

   switch (ucf)
   {
      STRING_CASE(CF_TEXT);
      STRING_CASE(CF_BITMAP);
      STRING_CASE(CF_METAFILEPICT);
      STRING_CASE(CF_SYLK);
      STRING_CASE(CF_DIF);
      STRING_CASE(CF_TIFF);
      STRING_CASE(CF_OEMTEXT);
      STRING_CASE(CF_DIB);
      STRING_CASE(CF_PALETTE);
      STRING_CASE(CF_PENDATA);
      STRING_CASE(CF_RIFF);
      STRING_CASE(CF_WAVE);
      STRING_CASE(CF_UNICODETEXT);
      STRING_CASE(CF_ENHMETAFILE);
      STRING_CASE(CF_HDROP);
      STRING_CASE(CF_LOCALE);
      STRING_CASE(CF_MAX);
      STRING_CASE(CF_OWNERDISPLAY);
      STRING_CASE(CF_DSPTEXT);
      STRING_CASE(CF_DSPBITMAP);
      STRING_CASE(CF_DSPMETAFILEPICT);
      STRING_CASE(CF_DSPENHMETAFILE);

      default:
         if (! GetClipboardFormatNameA(ucf, s_szCFName, sizeof(s_szCFName)))
            lstrcpyA(s_szCFName, "UNKNOWN CLIPBOARD FORMAT");
         pcsz = s_szCFName;
         break;
   }

   ASSERT(IS_VALID_STRING_PTR_A(pcsz, CSTR));

   return(pcsz);
}


PCSTR GetCOMPARISONRESULTString(COMPARISONRESULT cr)
{
   PCSTR pcsz;

   switch (cr)
   {
      STRING_CASE(CR_FIRST_SMALLER);
      STRING_CASE(CR_FIRST_LARGER);
      STRING_CASE(CR_EQUAL);

      default:
         ERROR_OUT(("GetCOMPARISONRESULTString() called on unknown COMPARISONRESULT %d.",
                    cr));
         pcsz = "UNKNOWN COMPARISONRESULT";
         break;
   }

   ASSERT(IS_VALID_STRING_PTR_A(pcsz, CSTR));

   return(pcsz);
}

PCSTR GetHRESULTString(HRESULT hr)
{
   PCSTR pcsz;
   static char s_rgchHRESULT[] = "0x12345678";

   switch (hr)
   {
      STRING_CASE(S_OK);
      STRING_CASE(S_FALSE);

      STRING_CASE(DRAGDROP_S_CANCEL);
      STRING_CASE(DRAGDROP_S_DROP);
      STRING_CASE(DRAGDROP_S_USEDEFAULTCURSORS);

      STRING_CASE(E_UNEXPECTED);
      STRING_CASE(E_NOTIMPL);
      STRING_CASE(E_OUTOFMEMORY);
      STRING_CASE(E_INVALIDARG);
      STRING_CASE(E_NOINTERFACE);
      STRING_CASE(E_POINTER);
      STRING_CASE(E_HANDLE);
      STRING_CASE(E_ABORT);
      STRING_CASE(E_FAIL);
      STRING_CASE(E_ACCESSDENIED);

      STRING_CASE(CLASS_E_NOAGGREGATION);

      STRING_CASE(CO_E_NOTINITIALIZED);
      STRING_CASE(CO_E_ALREADYINITIALIZED);
      STRING_CASE(CO_E_INIT_ONLY_SINGLE_THREADED);

      STRING_CASE(DV_E_DVASPECT);
      STRING_CASE(DV_E_LINDEX);
      STRING_CASE(DV_E_TYMED);
      STRING_CASE(DV_E_FORMATETC);

#ifdef __INTSHCUT_H__

      STRING_CASE(E_FLAGS);

      STRING_CASE(URL_E_INVALID_SYNTAX);
      STRING_CASE(URL_E_UNREGISTERED_PROTOCOL);

      STRING_CASE(IS_E_EXEC_FAILED);

      STRING_CASE(E_FILE_NOT_FOUND);
      STRING_CASE(E_PATH_NOT_FOUND);

#endif

		//  ULS error codes
		//
      default:
         wsprintfA(s_rgchHRESULT, "%#lx", hr);
         pcsz = s_rgchHRESULT;
         break;
   }

   ASSERT(IS_VALID_STRING_PTR_A(pcsz, CSTR));

   return(pcsz);
}

#endif   /* DEBUG */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\remdsk\rds\nmutil\strutil.cpp ===
// STRUTIL.CPP
//
// Assorted string utility functions for use in NetMeeting components.
// Derived from STRCORE.CPP.

#include "precomp.h"
#include <cstring.hpp>

// global helper functions for Unicode support in a DBCS environment

int  UnicodeCompare(PCWSTR s, PCWSTR t)
{ 
	// Treat NULL pointers like empty strings
	// at the bottom of the collating order.

	if (IsEmptyStringW(t)) {
		if (IsEmptyStringW(s)) {
			return 0;
		}
		else {
			return 1;
		}
	}

	// Done with empty string cases, 
	// so now do real compare.

	for ( ; *s == *t; s++, t++) {
		if (!*s) {
			return 0;
		}
	}
	return (*s > *t) ? 1 : -1;
}

PWSTR  NewUnicodeString(PCWSTR _wszText)
{
	PWSTR wszText = NULL;
	UINT nChar;

	if (_wszText) {
		nChar = lstrlenW(_wszText) + 1;
		wszText = new WCHAR[nChar];
		if (wszText) {
			CopyMemory((void *)wszText, 
						_wszText, 
						nChar * sizeof(WCHAR));
		}
	}
	return wszText;
}

PWSTR  DBCSToUnicode(UINT uCodePage, PCSTR szText)
{
	int		nChar;
	PWSTR	wszText = NULL;

	if (szText) {
		nChar = MultiByteToWideChar(uCodePage,
									0,		// character-type options
									szText,
									-1,		// NULL terminated string
									NULL,	// return buffer (not used)
									0);		// getting length of Unicode string
		if (nChar) {
			wszText = new WCHAR[nChar];
			if (wszText) {
				nChar = MultiByteToWideChar(uCodePage,
											0,			// character-type options
											szText,
											-1,			// NULL terminated string
											wszText,	// return buffer
											nChar);		// length of return buffer
				if (!nChar) {
					delete wszText;
					wszText = NULL;
				}
			}
		}
	}
	return wszText;
}

PSTR  UnicodeToDBCS(UINT uCodePage, PCWSTR wszText)
{
	int		nChar;
	PSTR	szText = NULL;

	if (wszText) {
		nChar = WideCharToMultiByte(uCodePage,
									0,		// character-type options
									wszText,
									-1,		// NULL terminated string
									NULL,	// return buffer (not used)
									0,		// getting length of DBCS string
									NULL,
									NULL);
		if (nChar) {
			szText = new CHAR[nChar];
			if (szText) {
				nChar = WideCharToMultiByte(uCodePage,
											0,			// character-type options
											wszText,
											-1,			// NULL terminated string
											szText,		// return buffer
											nChar,		// length of return buffer
											NULL,
											NULL);
				if (!nChar) {
					delete szText;
					szText = NULL;
				}
			}
		}
	}
	return szText;
}


BOOL  UnicodeIsNumber(PCWSTR wszText)
{
	// If there are no characters, then treat it as not being a number.

	if (!wszText || !*wszText) {
		return FALSE;
	}

	// If any characters are not digits, then return FALSE.

	do {
		if ((*wszText < L'0') || (*wszText > L'9')) {
			return FALSE;
		}
	} while(*++wszText);

	// Got here so all characters are digits.

	return TRUE;
}


/*  G U I D  T O  S Z */
/*----------------------------------------------------------------------------
    %%Function: GuidToSz

	Convert the guid to a special hex string.
	Assumes lpchDest has space for at least sizeof(GUID)*2 +6 chars.
	LENGTH_SZGUID_FORMATTED is 30 and includes space for the null terminator.

	Note the difference between this and UuidToString (or StringFromGUID2)

	GUID Format: {12345678-1234-1234-1234567890123456}
----------------------------------------------------------------------------*/
VOID  GuidToSz(GUID * pguid, LPTSTR lpchDest)
{
	ASSERT(NULL != pguid);
	ASSERT(NULL != lpchDest);

	wsprintf(lpchDest, TEXT("{%08X-%04X-%04X-%02X%02X-"),
		pguid->Data1, pguid->Data2, pguid->Data3, pguid->Data4[0], pguid->Data4[1]);
	lpchDest += 1+8+1+4+1+4+1+2+2+1;

	for (int i = 2; i < 8; i++)
	{
		wsprintf(lpchDest, TEXT("%02X"), pguid->Data4[i]);
		lpchDest += 2;
	}
	lstrcpy(lpchDest, TEXT("}") );
}


/*  S Z  F I N D  L A S T  C H */
/*----------------------------------------------------------------------------
    %%Function: SzFindLastCh

	Returns a pointer to the ch within the lpsz or NULL if not found
----------------------------------------------------------------------------*/
LPTSTR  SzFindLastCh(LPTSTR lpsz, TCHAR ch)
{
	LPTSTR lpchRet;

	for (lpchRet = NULL; *lpsz; lpsz = CharNext(lpsz))
	{
		if (ch == *lpsz)
			lpchRet = lpsz;
	}

	return lpchRet;
}



/*  T R I M  S Z  */
/*-------------------------------------------------------------------------
    %%Function: TrimSz

    Trim the whitespace around string.
    Returns the number of characters in the string.
    (chars/bytes in ANSI and DBCS, WCHARs/words in UNICODE)
-------------------------------------------------------------------------*/
UINT  TrimSz(PTCHAR psz)
{
    UINT   ich;        // character index into rgwCharType
    PTCHAR pchFirst;
    PTCHAR pchLast;
    PTCHAR pchCurr;
    WORD   rgwCharType[MAX_PATH];

	if ((NULL == psz) || (0 == lstrlen(psz)))
	{
		return 0;
	}

	if (!GetStringTypeEx(LOCALE_SYSTEM_DEFAULT, CT_CTYPE1, psz, -1, rgwCharType))
	{
		WARNING_OUT(("TrimSz: Problem with GetStringTypeEx"));
		return 0;
	}

	// search for first non-space
	pchFirst = psz;
	ich = 0;
	while (_T('\0') != *pchFirst)
	{
		if (!(C1_SPACE & rgwCharType[ich]))
			break;
		pchFirst = CharNext(pchFirst);
		ich++;
	}

	if (_T('\0') == *pchFirst)
	{
		// The entire string is empty!
		*psz = _T('\0');
		return 0;
	}
	
	// search for last non-space
	pchCurr = pchFirst;
	pchLast = pchCurr;
	while (_T('\0') != *pchCurr)
	{
		if (!(C1_SPACE & rgwCharType[ich]))
		{
			pchLast = pchCurr;
		}
		pchCurr = CharNext(pchCurr);
		ich++;
	}

	ASSERT(_T('\0') != *pchLast);
	// Null terminate the string
	pchLast = CharNext(pchLast);
	*pchLast = _T('\0');

	// Update the original string
	lstrcpy(psz, pchFirst);

	// Return the new length
	return lstrlen(psz);
}


// Implement lstrcpyW when not on a Unicode platform

#if !defined(UNICODE)
/*  L  S T R  C P Y  W  */
/*-------------------------------------------------------------------------
    %%Function: LStrCpyW
    
-------------------------------------------------------------------------*/
LPWSTR  LStrCpyW(LPWSTR pszDest, LPWSTR pszSrc)
{
	ASSERT(NULL != pszDest);
	ASSERT(NULL != pszSrc);

	if ((NULL != pszDest) && (NULL != pszSrc))
	{
		LPWSTR pszT = pszDest;
		while (0 != (*pszT++ = *pszSrc++))
			;

	}
	return pszDest;
}


/*  L  S T R  C P Y N W  */
/*-------------------------------------------------------------------------
    %%Function: LStrCpyNW
    
-------------------------------------------------------------------------*/
LPWSTR  LStrCpyNW(LPWSTR pszDest, LPCWSTR pszSrc, INT iMaxLength)
{
	ASSERT(NULL != pszDest);
	ASSERT(NULL != pszSrc);

	if ((NULL != pszDest) && (NULL != pszSrc))
	{
		LPWSTR pszT = pszDest;
		while ((--iMaxLength > 0) && 
				(0 != (*pszT++ = *pszSrc++)))
		{
			/*EXPLICIT */ ;
		}

		if (0 == iMaxLength)
		{
			*pszT = L'\0';
		}
	}
	return pszDest;
}

#endif // !defined(UNICODE)

/*  _ S T R C H R  */
/*-------------------------------------------------------------------------
    %%Function: _StrChr
    
-------------------------------------------------------------------------*/
LPCTSTR  _StrChr ( LPCTSTR pcsz, TCHAR c )
{
    LPCTSTR pcszFound = NULL;

    if (pcsz)
    {
        while (*pcsz)
        {
            if (*pcsz == c)
            {
                pcszFound = pcsz;
                break;
            }

            pcsz = CharNext(pcsz);
        }
    }

    return pcszFound;
}


/*  _ S T R C M P N  */
/*-------------------------------------------------------------------------
    %%Function: _StrCmpN
    This does a case-sensitive compare of two strings, pcsz1 and pcsz2, of
    at most cchMax characters.  If we reach the end of either string, we
    also stop, and the strings match if the other string is also at its end.

    This function is NOT DBCS safe.
    
-------------------------------------------------------------------------*/
int  _StrCmpN(LPCTSTR pcsz1, LPCTSTR pcsz2, UINT cchMax)
{
    UINT ich;

    for (ich = 0; ich < cchMax; ich++)
    {
        if (*pcsz1 != *pcsz2)
        {
            // No match.
            return((*pcsz1 > *pcsz2) ? 1 : -1);
        }

        //
        // Are we at the end (if we're here, both strings are at the
        // end.  If only one is, the above compare code kicks in.
        //
        if ('\0' == *pcsz1)
            return 0;

        pcsz1++;
        pcsz2++;
    }

    // If we get here, cchMax characters matched, so success.
    return 0;
}

/*  _ S T R S T R  */
/*-------------------------------------------------------------------------
    %%Function: _StrStr
    
-------------------------------------------------------------------------*/
// BUGBUG - This function is *not* DBCS-safe
LPCTSTR  _StrStr (LPCTSTR pcsz1, LPCTSTR pcsz2)
{
	PTSTR pszcp = (PTSTR) pcsz1;
	PTSTR pszs1, pszs2;

	if ( !*pcsz2 )
		return pcsz1;

	while (*pszcp)
	{
		pszs1 = pszcp;
		pszs2 = (PTSTR) pcsz2;

		while ( *pszs1 && *pszs2 && !(*pszs1-*pszs2) )
			pszs1++, pszs2++;

		if (!*pszs2)
			return pszcp;

		pszcp++;
	}

	return NULL;
}

/*  _ S T R S T R  */
/*-------------------------------------------------------------------------
    %%Function: _StrStr
    
-------------------------------------------------------------------------*/
// BUGBUG - This function is *not* DBCS-safe
LPCWSTR _StrStrW(LPCWSTR pcsz1, LPCWSTR pcsz2)
{
	PWSTR pszcp = (PWSTR) pcsz1;

	while (*pszcp)
	{
		PWSTR psz1 = pszcp;
		PWSTR psz2 = (PWSTR) pcsz2;

		while ( *psz1 && *psz2 && !(*psz1-*psz2) )
		{
			psz1++;
			psz2++;
		}

		if (!*psz2)
			return pszcp;

		pszcp++;
	}

	return NULL;
}

/*  _ S T R P B R K  */
/*-------------------------------------------------------------------------
    %%Function: _StrPbrkA, _StrPbrkW

    Private, DBCS-safe version of CRT strpbrk function.  Like strchr but 
	accepts more than one character for which to search.  The ANSI version 
	does not support searching for DBCS chars.

	In the Unicode version, we do a nested search.  In the ANSI version,
	we build up a table of chars and use this to scan the string.
-------------------------------------------------------------------------*/
LPSTR  _StrPbrkA(LPCSTR pcszString, LPCSTR pcszSearch)
{
	ASSERT(NULL != pcszString && NULL != pcszSearch);

	BYTE rgbSearch[(UCHAR_MAX + 1) / CHAR_BIT];

	ZeroMemory(rgbSearch, sizeof(rgbSearch));

	// Scan the search string
	while ('\0' != *pcszSearch)
	{
		ASSERT(!IsDBCSLeadByte(*pcszSearch));

		// Set the appropriate bit in the appropriate byte
		rgbSearch[*pcszSearch / CHAR_BIT] |= (1 << (*pcszSearch % CHAR_BIT));

		pcszSearch++;
	}

	// Scan the source string, compare to the bits in the search array
	while ('\0' != *pcszString)
	{
		if (rgbSearch[*pcszString / CHAR_BIT] & (1 << (*pcszString % CHAR_BIT)))
		{
			// We have a match
			return (LPSTR) pcszString;
		}

		pcszString = CharNextA(pcszString);
	}

	// If we get here, there was no match
	return NULL;
}


LPWSTR  _StrPbrkW(LPCWSTR pcszString, LPCWSTR pcszSearch)
{
	ASSERT(NULL != pcszString && NULL != pcszSearch);

	// Scan the string, matching each character against those in the search string
	while (L'\0' != *pcszString)
	{
		LPCWSTR pcszCurrent = pcszSearch;

		while (L'\0' != *pcszCurrent)
		{
			if (*pcszString == *pcszCurrent)
			{
				// We have a match
				return (LPWSTR) pcszString;
			}

			// pcszCurrent = CharNextW(pcszCurrent);
			pcszCurrent++;
		}

		// pcszString = CharNextW(pcszString);
		pcszString++;
	}

	// If we get here, there was no match
	return NULL;
}


// BUGBUG - Are DecimalStringToUINT and StrToInt the same?

/*  D E C I M A L  S T R I N G  T O  U  I  N  T  */
/*-------------------------------------------------------------------------
    %%Function: DecimalStringToUINT
    
-------------------------------------------------------------------------*/
UINT  DecimalStringToUINT(LPCTSTR pcszString)
{
	ASSERT(pcszString);
	UINT uRet = 0;
	LPTSTR pszStr = (LPTSTR) pcszString;
	while (_T('\0') != pszStr[0])
	{
		ASSERT((pszStr[0] >= _T('0')) &&
				(pszStr[0] <= _T('9')));
		uRet = (10 * uRet) + (BYTE) (pszStr[0] - _T('0'));
		pszStr++; // NOTE: DBCS characters are not allowed!
	}
	return uRet;
}


/****************************************************************************
    
	FUNCTION:	StrToInt

    PURPOSE:	The atoi equivalent, to avoid using the C runtime lib

	PARAMETERS: lpSrc - pointer to a source string to convert to integer

	RETURNS:	0 for failure, the integer otherwise
				(what if the string was converted to 0 ?)

****************************************************************************/
int WINAPI RtStrToInt(LPCTSTR lpSrc)       // atoi()
{
    int n = 0;
    BOOL bNeg = FALSE;

    if (*lpSrc == _T('-')) {
        bNeg = TRUE;
        lpSrc++;
    }

    while (((*lpSrc) >= _T('0') && (*lpSrc) <= _T('9')))
    {
        n *= 10;
        n += *lpSrc - _T('0');
        lpSrc++;
    }
    return bNeg ? -n : n;
}

/*  _ S T R L W R W  */
/*-------------------------------------------------------------------------
    %%Function: _StrLwrW
    
-------------------------------------------------------------------------*/
// BUGBUG - This function does *not* handle all UNICODE character sets

LPWSTR  _StrLwrW(LPWSTR pwszSrc)
{
	for (PWSTR pwszCur = pwszSrc; (L'\0' != *pwszCur); pwszCur++)
	{
		if ( (*pwszCur >= L'A') && (*pwszCur <= L'Z') )
		{
			*pwszCur = *pwszCur - L'A' + L'a';
		}
	}
	return pwszSrc;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\remdsk\rds\nmutil\utf8str.cpp ===
#include "precomp.h"
#include "utf8str.h"

CUTF8String::~CUTF8String()
{
	if (ALLOC_UNICODE & m_eAlloc)
	{
		delete m_pwszUnicode;
	}
	else if (ALLOC_UTF8 & m_eAlloc)
	{
		delete m_pszUTF8;
	}
}

CUTF8String::operator LPWSTR()
{ 
	if ((NULL == m_pwszUnicode) && (NULL != m_pszUTF8))
	{
		DecodeUTF8();
	}
	return m_pwszUnicode;
}

CUTF8String::operator LPSTR()
{ 
	if ((NULL == m_pszUTF8) && (NULL != m_pwszUnicode))
	{
		EncodeUTF8();
	}
	return m_pszUTF8;
}

VOID CUTF8String::EncodeUTF8()
{
	DebugEntry(CUTF8String::EncodeUTF8);
	m_hr = S_OK;
	ASSERT(NULL != m_pwszUnicode);
	int cchUTF8 = 1; // always include a NULL terminator

	// First make a pass to see how many characters we will be converting.
	LPWSTR pwsz = m_pwszUnicode;
	while (L'\0' != *pwsz)
	{
		WCHAR wch = *pwsz++;
		if (wch < 0x80)
		{
			cchUTF8 += 1;
		}
		else if (wch < 0x800)
		{
			cchUTF8 += 2;
		}
		else
		{
			cchUTF8 += 3;
		}
	}

	ASSERT(NULL == m_pszUTF8);
	m_pszUTF8 = new CHAR[cchUTF8];
	if (NULL != m_pszUTF8)
	{
		ASSERT(ALLOC_NONE == m_eAlloc);
		m_eAlloc = ALLOC_UTF8;
		// Start encoding here:
		const BYTE cUtf8FirstSignal[4] = {0x00, 0x00, 0xC0, 0xE0};
		const BYTE cMask   = 0xBF;
		const BYTE cSignal = 0x80;
		LPSTR pszStop = m_pszUTF8 + cchUTF8;
		LPSTR pszDst = m_pszUTF8;
		pwsz = m_pwszUnicode;
		while (pszDst < pszStop)
		{
			WCHAR wch = *pwsz++;
#ifdef DEBUG
			if (L'\0' == wch)
			{
				ASSERT(pszDst == pszStop - 1);
			}
#endif // DEBUG
			int cchTotal;
			if (wch < 0x80)
			{
				cchTotal = 1;
			}
			else if (wch < 0x800)
			{
				cchTotal = 2;
			}
			else
			{
				cchTotal = 3;
			}

			pszDst += cchTotal;
			switch (cchTotal)
			{
				case 3:
					*--pszDst = (wch | cSignal) & cMask;
					wch >>= 6;
					// FALL THROUGH
				case 2:
					*--pszDst = (wch | cSignal) & cMask;
					wch >>= 6;
					// FALL THROUGH
				case 1:
					*--pszDst = (wch | cUtf8FirstSignal[cchTotal]);
			}
			pszDst += cchTotal;
		}
		m_hr = S_OK;
	}
	else
	{
		m_hr = E_OUTOFMEMORY;
	}
	DebugExitVOID(CUTF8String::EncodeUTF8);
}

VOID CUTF8String::DecodeUTF8()
{
	DebugEntry(CUTF8String::DecodeUTF8);
	m_hr = S_OK;
	ASSERT(NULL != m_pszUTF8);
	int cchUnicode = 1; // always include a NULL terminator

	LPSTR psz = m_pszUTF8;
	// First determine the destination size (cchUnicode)
	while ('\0' != *psz)
	{
		int cbChar = 0;
		BYTE bFirst = (BYTE) *psz;
		while (bFirst & 0x80)
		{
			cbChar++;
			ASSERT(cbChar < 8);
			bFirst <<= 1;
		}

		cbChar = max(1, cbChar);
		psz += cbChar;
		cchUnicode++;
	}

	ASSERT(NULL == m_pwszUnicode);
	m_pwszUnicode = new WCHAR[cchUnicode];
	if (NULL != m_pwszUnicode)
	{
		ASSERT(ALLOC_NONE == m_eAlloc);
		m_eAlloc = ALLOC_UNICODE;
		// Start decoding here:
		LPWSTR pwszStop = m_pwszUnicode + cchUnicode;
		LPWSTR pwszDst = m_pwszUnicode;
		psz = m_pszUTF8;
		while (pwszDst < pwszStop)
		{
			int cbChar = 0;
			BYTE bFirst = (BYTE) *psz;
			while (bFirst & 0x80)
			{
				cbChar++;
				ASSERT(cbChar < 8);
				bFirst <<= 1;
			}

			BOOL fValid = TRUE;
			WCHAR wch = L'\0';
			switch (cbChar)
			{
				case 6: psz++; // FALLTHROUGH               // we don't handle
				case 5: psz++; // FALLTHROUGH               // UCS-4; skip first
				case 4: psz++; // FALLTHROUGH               // three bytes
				case 3:
					wch = WCHAR(*psz++ & 0x0f) << 12;      // 0x0800 - 0xffff
					fValid = fValid && ((*psz & 0xc0) == 0x80);
					// FALLTHROUGH
				case 2:
					wch |= WCHAR(*psz++ & 0x3f) << 6;       // 0x0080 - 0x07ff
					fValid = fValid && ((*psz & 0xc0) == 0x80);
					wch |= WCHAR(*psz++ & 0x3f);
					break;

				case 0:
					wch = WCHAR(*psz++);                    // 0x0000 - 0x007f
					break;

				default:
					ERROR_OUT(("CUTF8String::DecodeUTF8 found invalid UTF-8 lead byte"));
					wch = L'?';
					psz += cbChar;
					break;
			}

			if (FALSE == fValid)
			{
				ERROR_OUT(("CUTF8String::DecodeUTF8 found bad UTF-8 sequence"));
				*pwszDst = L'\0';
				m_hr = E_FAIL;
				break;
			}
#ifdef DEBUG
			cchUnicode--;
#endif // DEBUG

			*pwszDst++ = wch;
		}
		ASSERT(0 == cchUnicode);
	}
	else
	{
		m_hr = E_OUTOFMEMORY;
	}
	DebugExitVOID(CUTF8String::DecodeUTF8);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\remdsk\rds\nmutil\valid.cpp ===
/*
 * valid.c - Validation functions module.
 *
 * Taken from URL code 
 *
 * Created: ChrisPi 9-11-95
 *
 */


/* Headers
 **********/

#include "precomp.h"


/****************************** Public Functions *****************************/


BOOL IsValidHWND(HWND hwnd)
{
   /* Ask User if this is a valid window. */

   return(IsWindow(hwnd));
}


#ifdef DEBUG

BOOL IsValidHANDLE(HANDLE hnd)
{
   return(EVAL(hnd != INVALID_HANDLE_VALUE));
}


BOOL IsValidHEVENT(HANDLE hevent)
{
   return(IsValidHANDLE(hevent));
}


BOOL IsValidHFILE(HANDLE hf)
{
   return(IsValidHANDLE(hf));
}


BOOL IsValidHGLOBAL(HGLOBAL hg)
{
   return(IsValidHANDLE(hg));
}


BOOL IsValidHMENU(HMENU hmenu)
{
   return(IsValidHANDLE(hmenu));
}


BOOL IsValidHINSTANCE(HINSTANCE hinst)
{
   return(IsValidHANDLE(hinst));
}


BOOL IsValidHICON(HICON hicon)
{
   return(IsValidHANDLE(hicon));
}


BOOL IsValidHKEY(HKEY hkey)
{
   return(IsValidHANDLE(hkey));
}


BOOL IsValidHMODULE(HMODULE hmod)
{
   return(IsValidHANDLE(hmod));
}


BOOL IsValidHPROCESS(HANDLE hprocess)
{
   return(IsValidHANDLE(hprocess));
}


BOOL IsValidPCSECURITY_ATTRIBUTES(PCSECURITY_ATTRIBUTES pcsa)
{
   /* BUGBUG: Fill me in. */

   return(IS_VALID_READ_PTR(pcsa, CSECURITY_ATTRIBUTES));
}


BOOL IsValidFileCreationMode(DWORD dwMode)
{
   BOOL bResult;

   switch (dwMode)
   {
      case CREATE_NEW:
      case CREATE_ALWAYS:
      case OPEN_EXISTING:
      case OPEN_ALWAYS:
      case TRUNCATE_EXISTING:
         bResult = TRUE;
         break;

      default:
         bResult = FALSE;
         ERROR_OUT(("IsValidFileCreationMode(): Invalid file creation mode %#lx.",
                    dwMode));
         break;
   }

   return(bResult);
}


BOOL IsValidHTEMPLATEFILE(HANDLE htf)
{
   return(IsValidHANDLE(htf));
}


BOOL IsValidPCFILETIME(PCFILETIME pcft)
{
   /* dwLowDateTime may be any value. */
   /* dwHighDateTime may be any value. */

   return(IS_VALID_READ_PTR(pcft, CFILETIME));
}


BOOL IsValidPCPOINT(PCPOINT pcpt)
{

   /* x may be any value. */
   /* y may be any value. */

   return(IS_VALID_READ_PTR(pcpt, CPOINT));
}


BOOL IsValidPCPOINTL(PCPOINTL pcptl)
{

   /* x may be any value. */
   /* y may be any value. */

   return(IS_VALID_READ_PTR(pcptl, CPOINTL));
}


BOOL IsValidPCWIN32_FIND_DATA(PCWIN32_FIND_DATA pcwfd)
{
   /* BUGBUG: Fill me in. */

   return(IS_VALID_READ_PTR(pcwfd, CWIN32_FIND_DATA));
}


BOOL IsValidShowCmd(int nShow)
{
   BOOL bResult;

   switch (nShow)
   {
      case SW_HIDE:
      case SW_SHOWNORMAL:
      case SW_SHOWMINIMIZED:
      case SW_SHOWMAXIMIZED:
      case SW_SHOWNOACTIVATE:
      case SW_SHOW:
      case SW_MINIMIZE:
      case SW_SHOWMINNOACTIVE:
      case SW_SHOWNA:
      case SW_RESTORE:
      case SW_SHOWDEFAULT:
         bResult = TRUE;
         break;

      default:
         bResult = FALSE;
         ERROR_OUT(("IsValidShowCmd(): Invalid show command %d.",
                    nShow));
         break;
   }

   return(bResult);
}


BOOL IsValidPath(LPCTSTR pcszPath)
{
   /* BUGBUG: Beef up path validation. */

   return(IS_VALID_STRING_PTR(pcszPath, CSTR) &&
          EVAL((UINT)lstrlen(pcszPath) < MAX_PATH));
}

#if defined(UNICODE)
BOOL IsValidPathA(PCSTR pcszPath)
{
   /* BUGBUG: Beef up path validation. */

   return(IS_VALID_STRING_PTR_A(pcszPath, CSTR) &&
          EVAL((UINT)lstrlenA(pcszPath) < MAX_PATH));
}
#endif // defined(UNICODE)

BOOL IsValidPathResult(HRESULT hr, LPCTSTR pcszPath,
                                   UINT ucbPathBufLen)
{
   return((hr == S_OK &&
           EVAL(IsValidPath(pcszPath)) &&
           EVAL((UINT)lstrlen(pcszPath) < ucbPathBufLen)) ||
          (hr != S_OK &&
           EVAL(! ucbPathBufLen ||
                ! pcszPath ||
                ! *pcszPath)));
}


BOOL IsValidExtension(LPCTSTR pcszExt)
{
   return(IS_VALID_STRING_PTR(pcszExt, CSTR) &&
          EVAL(lstrlen(pcszExt) < MAX_PATH) &&
          EVAL(*pcszExt == PERIOD));
}


BOOL IsValidIconIndex(HRESULT hr, LPCTSTR pcszIconFile,
                                  UINT ucbIconFileBufLen, int niIcon)
{
   return(EVAL(IsValidPathResult(hr, pcszIconFile, ucbIconFileBufLen)) &&
          EVAL(hr == S_OK ||
               ! niIcon));
}


BOOL IsValidRegistryValueType(DWORD dwType)
{
   BOOL bResult;

   switch (dwType)
   {
      case REG_NONE:
      case REG_SZ:
      case REG_EXPAND_SZ:
      case REG_BINARY:
      case REG_DWORD:
      case REG_DWORD_BIG_ENDIAN:
      case REG_LINK:
      case REG_MULTI_SZ:
      case REG_RESOURCE_LIST:
      case REG_FULL_RESOURCE_DESCRIPTOR:
      case REG_RESOURCE_REQUIREMENTS_LIST:
         bResult = TRUE;
         break;

      default:
         bResult = FALSE;
         ERROR_OUT(("IsValidRegistryValueType(): Invalid registry value type %lu.",
                    dwType));
         break;
   }

   return(bResult);
}


BOOL IsValidHotkey(WORD wHotkey)
{
   /* BUGBUG: Beef up hotkey validation. */

   return(wHotkey != 0);
}


#ifdef _COMPARISONRESULT_DEFINED_

BOOL IsValidCOMPARISONRESULT(COMPARISONRESULT cr)
{
   BOOL bResult;

   switch (cr)
   {
      case CR_FIRST_SMALLER:
      case CR_EQUAL:
      case CR_FIRST_LARGER:
         bResult = TRUE;
         break;

      default:
         WARNING_OUT(("IsValidCOMPARISONRESULT(): Unknown COMPARISONRESULT %d.",
                      cr));
         bResult = FALSE;
         break;
   }

   return(bResult);
}

#endif   /* _COMPARISONRESULT_DEFINED_ */

#endif   /* DEBUG */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\remdsk\rds\nmutil\strtohex.cpp ===
// STRTOHEX.CPP
//
// Utility functions to convert string representations of hexadecimal numbers
// into the numbers themselves.
//
// Note:  These functions are in their own file, rather than in STRUTIL.CPP, 
// because they use a const array.  The current implementation of the linker
// pulls this array into binaries if they use any function in the source file,
// not just the functions which reference this array.

#include "precomp.h"
#include <strutil.h>


// This array maps ASCII chars in the range '0' - 'f' to their hex equivalent.
// INVALID_CHAR_ID is used to mark slots that don't correspond to a valid
// hex char.
const BYTE INVALID_CHAR_ID = (BYTE) -1;

const BYTE rgbHexCharMap[] =
{	
	// ASCII 0x30 - 0x3f
	0, 1, 2, 3, 
	4, 5, 6, 7, 
	8, 9, INVALID_CHAR_ID, INVALID_CHAR_ID,
	INVALID_CHAR_ID, INVALID_CHAR_ID, INVALID_CHAR_ID, INVALID_CHAR_ID,
	// ASCII 0x40 - 0x4f
	INVALID_CHAR_ID, 0xA, 0xB, 0xC, 
	0xD, 0xE, 0xF, INVALID_CHAR_ID, 
	INVALID_CHAR_ID, INVALID_CHAR_ID, INVALID_CHAR_ID, INVALID_CHAR_ID,
	INVALID_CHAR_ID, INVALID_CHAR_ID, INVALID_CHAR_ID, INVALID_CHAR_ID,
	// ASCII 0x50 - 0x5f
	INVALID_CHAR_ID, INVALID_CHAR_ID, INVALID_CHAR_ID, INVALID_CHAR_ID,
	INVALID_CHAR_ID, INVALID_CHAR_ID, INVALID_CHAR_ID, INVALID_CHAR_ID,
	INVALID_CHAR_ID, INVALID_CHAR_ID, INVALID_CHAR_ID, INVALID_CHAR_ID,
	INVALID_CHAR_ID, INVALID_CHAR_ID, INVALID_CHAR_ID, INVALID_CHAR_ID,
	// ASCII 0x60 - 0x67
	INVALID_CHAR_ID, 0xa, 0xb, 0xc, 
	0xd, 0xe, 0xf, INVALID_CHAR_ID
};

const int cbHexCharMap = ARRAY_ELEMENTS(rgbHexCharMap);


//
// HexStringToQWordA()
//
// Converts a hex ANSI string (without 0x or 0X prefix) to a ULARGE_INTEGER
//
// NOTE: The a-f characters can be lowercase or uppercase
//
// Returns TRUE if successful (the string contained all valid characters)
// Returns FALSE otherwise
//

BOOL  HexStringToQWordA(LPCSTR pcszString, ULARGE_INTEGER* pqw)
{
	BOOL bRet;
	ASSERT(pcszString);
	ASSERT(pqw);
	pqw->QuadPart = 0ui64;
	int cchStr = lstrlenA(pcszString);
	if (cchStr <= CCH_HEX_QWORD)
	{
		bRet = TRUE;
		PDWORD pdwCur = (cchStr < CCH_HEX_DWORD) ? &(pqw->LowPart) : &(pqw->HighPart);
		for (int i = 0; i < cchStr; i++)
		{
			// NOTE: DBCS characters are not allowed
			ASSERT(! IsDBCSLeadByte(pcszString[i]));

			if (CCH_HEX_DWORD == (cchStr - i))
			{
				pdwCur = &(pqw->LowPart);
			}
			DWORD dwDigit = (DWORD) INVALID_CHAR_ID;
			int iDigit = pcszString[i] - '0';

			if (iDigit >= 0 && iDigit < cbHexCharMap)
			{
				dwDigit = (DWORD) rgbHexCharMap[iDigit];
			}

			if (INVALID_CHAR_ID != dwDigit)
			{
				*pdwCur = ((*pdwCur) << BITS_PER_HEX_CHAR) + dwDigit;
			}
			else
			{
				bRet = FALSE;
				break;
			}
		}
	}
	else
	{
		bRet = FALSE;
	}
	return bRet;
}


/*  D W  F R O M  H E X  */
/*-------------------------------------------------------------------------
    %%Function: DwFromHex

    Return the DWORD from the hex string.
-------------------------------------------------------------------------*/
DWORD DwFromHex(LPCTSTR pchHex)
{
	TCHAR ch;
	DWORD dw = 0;

	while (_T('\0') != (ch = *pchHex++))
	{

		DWORD dwDigit = (DWORD) INVALID_CHAR_ID;
		int iDigit = ch - _T('0');

		if (iDigit >= 0 && iDigit < cbHexCharMap)
		{
			dwDigit = (DWORD) rgbHexCharMap[iDigit];
		}

		if (INVALID_CHAR_ID != dwDigit)
		{
			dw = (dw << 4) + dwDigit;
		}
		else
			break;
	}

	return dw;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\remdsk\rds\samples\client\client.h ===
//
// CLIENT.H
//


BOOL InitClient(void);
void TermClient(void);
BOOL CALLBACK ClientDlgProc(HWND, UINT, WPARAM, LPARAM);
BOOL PlaceCall(void);
void HangupCall(void);
BOOL ActivatePrivateChannel(void);
void DeactivatePrivateChannel(void);
void SendPrivateData(void);


class CMgrNotify :  public RefCount,
                    public CNotify,
                    public INmManagerNotify,
                    public IAppSharingNotify
{
public:
	CMgrNotify();
	~CMgrNotify();

        // IUnknown methods
	STDMETHODIMP_(ULONG) AddRef(void);
	STDMETHODIMP_(ULONG) Release(void);
	STDMETHODIMP QueryInterface(REFIID riid, PVOID *ppvObj);

 	// ICNotify methods
	STDMETHODIMP Connect (IUnknown *pUnk);
	STDMETHODIMP Disconnect(void);

	// INmManagerNotify
	STDMETHODIMP NmUI(CONFN confn);
	STDMETHODIMP ConferenceCreated(INmConference *pConference);
	STDMETHODIMP CallCreated(INmCall *pNmCall);

    // IAppSharingNotify
    STDMETHODIMP OnReadyToShare(BOOL fReady);
    STDMETHODIMP OnShareStarted();
    STDMETHODIMP OnSharingStarted();
    STDMETHODIMP OnShareEnded();
    STDMETHODIMP OnPersonJoined(IAS_GCC_ID gccID);
    STDMETHODIMP OnPersonLeft(IAS_GCC_ID gccID);
    STDMETHODIMP OnStartInControl(IAS_GCC_ID gccInControlOf);
    STDMETHODIMP OnStopInControl(IAS_GCC_ID gccInControlOf);
    STDMETHODIMP OnControllable(BOOL fControllable);
    STDMETHODIMP OnStartControlled(IAS_GCC_ID gccControlledBy);
    STDMETHODIMP OnStopControlled(IAS_GCC_ID gccControlledBy);
};



class CConfNotify : public RefCount,
                    public CNotify,
                    public INmConferenceNotify
{
public:
	CConfNotify();
	~CConfNotify();

	// IUnknown methods
	STDMETHODIMP_(ULONG) AddRef(void);
    STDMETHODIMP_(ULONG) Release(void);
	STDMETHODIMP QueryInterface(REFIID riid, PVOID *ppvObj);

	// ICNotify methods
	STDMETHODIMP Connect (IUnknown *pUnk);
	STDMETHODIMP Disconnect(void);

	// INmConferenceNotify
	STDMETHODIMP NmUI(CONFN uNotify);
	STDMETHODIMP StateChanged(NM_CONFERENCE_STATE uState);
	STDMETHODIMP MemberChanged(NM_MEMBER_NOTIFY uNotify, INmMember *pfMember);

};





class CCallNotify : public INmCallNotify
{
private:
	INmCall * m_pCall;
	BOOL      m_fIncoming;
	LPTSTR    m_pszName;
	NM_CALL_STATE m_State;
	BOOL      m_fSelectedConference;

	POSITION  m_pos;           // position in g_pCallList
	DWORD     m_dwTick;        // tick count at call start
	ULONG     m_cRef;
	DWORD     m_dwCookie;

public:
	CCallNotify(INmCall * pCall);
	~CCallNotify();

	// IUnknown methods
	STDMETHODIMP_(ULONG) AddRef(void);
	STDMETHODIMP_(ULONG) Release(void);
	STDMETHODIMP QueryInterface(REFIID riid, PVOID *ppv);

	// INmCallNotify methods
	STDMETHODIMP NmUI(CONFN uNotify);
	STDMETHODIMP StateChanged(NM_CALL_STATE uState);
	STDMETHODIMP Failed(ULONG uError);
	STDMETHODIMP Accepted(INmConference *pConference);
	STDMETHODIMP CallError(UINT cns);
	STDMETHODIMP RemoteConference(BOOL fMCU, BSTR *pwszConfNames, BSTR *pbstrConfToJoin);
	STDMETHODIMP RemotePassword(BSTR bstrConference, BSTR *pbstrPassword, BYTE *pb, DWORD cb);

	// Internal methods
	VOID    Update(void);
	VOID	RemoveCall(void);
};



class CNmDataNotify : public RefCount,
                    public CNotify,
                    public INmChannelDataNotify
{
public:
	// IUnknown methods
	STDMETHODIMP_(ULONG) AddRef(void);
    STDMETHODIMP_(ULONG) Release(void);
	STDMETHODIMP QueryInterface(REFIID riid, PVOID *ppvObj);

	// ICNotify methods
	STDMETHODIMP Connect (IUnknown *pUnk);
	STDMETHODIMP Disconnect(void);

	// INmChannelDataNotify
	STDMETHODIMP NmUI(CONFN uNotify);
	STDMETHODIMP MemberChanged(NM_MEMBER_NOTIFY uNotify, INmMember *pfMember);
    STDMETHODIMP DataSent(INmMember * pMember, ULONG uSize, LPBYTE pvBuffer);
    STDMETHODIMP DataReceived(INmMember * pMember, ULONG uSize, LPBYTE pvBuffer,
        ULONG dwFlags);
    STDMETHODIMP AllocateHandleConfirm(ULONG handle_value, ULONG chandles);
};




extern HINSTANCE        g_hInst;
extern HWND             g_hwndMain;
extern INmManager *     g_pMgr;
extern IAppSharing *    g_pAS;
extern CMgrNotify *     g_pMgrNotify;
extern INmConference *  g_pConf;
extern CConfNotify *    g_pConfNotify;
extern UINT             g_cPeopleInConf;
extern INmChannelData * g_pPrivateChannel;
extern CNmDataNotify *  g_pDataNotify;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\remdsk\rds\nmutil\i386\seh.c ===
/*****************************************************************************
 *
 *  Seh.c
 *
 *  Copyright (c) 1996 Microsoft Corporation.  All Rights Reserved.
 *
 *  Abstract:
 *
 *      Structured exception handling.
 *
 *****************************************************************************/
#ifdef _M_IX86
#include <windows.h>
#include <sehcall.h>

typedef void *PV;

/*****************************************************************************
 *
 *      SEHFRAME
 *
 *      Special stack frame used by lightweight structured exception
 *      handling.
 *
 *****************************************************************************/

typedef struct SEHFRAME {

    PV      pvSEH;              /* Link to previous frame   */
    FARPROC Handler;            /* MyExceptionFilter        */
    FARPROC sehTarget;          /* Where to jump on error   */
    INEXCEPTION InException;    /* In-exception handler     */

} SEHFRAME, *PSEHFRAME;

/***************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   BOOL | _MyExceptionFilter |
 *
 *          My tiny exception filter.
 *
 *  @parm   LPEXCEPTION_RECORD | pExceptionRecord |
 *
 *          Exception record describing why we were called.
 *
 *  @parm   PV | EstablisherFrame |
 *
 *          The exception frame (pNext, pHandler)
 *          on the stack which is being handled.  This is used so that
 *          the handler can access its local variables and knows how
 *          far to smash the stack if the exception is being eaten.
 *
 *  @parm   PCONTEXT | pContextRecord |
 *
 *          Client context at time of exception.
 *
 *  @parm   PV | DispatcherContext |
 *
 *          Not used.  Which is good, because I don't know what it means.
 *
 ***************************************************************************/

#define EXCEPTION_UNWINDING     0x00000002
#define EXCEPTION_EXIT_UNWIND   0x00000004

WINBASEAPI void WINAPI
RtlUnwind(PV TargetFrame, PV TargetIp, PEXCEPTION_RECORD per, PV ReturnValue);

EXCEPTION_DISPOSITION
__cdecl
_MyExceptionFilter(
    LPEXCEPTION_RECORD pExceptionRecord,
    PV EstablisherFrame,
    PCONTEXT pContextRecord,
    PV DispatcherContext
)
{
    DispatcherContext;
    pContextRecord;

    /* Don't interfere with an unwind */
    if ((pExceptionRecord->ExceptionFlags &
            (EXCEPTION_UNWINDING | EXCEPTION_EXIT_UNWIND)) == 0) {
        PSEHFRAME pseh = EstablisherFrame;
        BOOL fRc = pseh->InException(pExceptionRecord, pContextRecord);

        /*
         *  RtlUnwind will tell all exception frames that may have
         *  been created underneath us that they are about to be
         *  blown away and should do their __finally handling.
         *
         *  On return, the nested frames have been unlinked.
         */
        RtlUnwind(EstablisherFrame, 0, 0, 0);

        /*
         *  And jump back to the caller.  It is the caller's
         *  responsibility to restore nonvolatile registers!
         *
         *  We also assume that the caller has nothing on the
         *  stack beneath the exception record!
         *
         *  And the handler address is right after the exception
         *  record!
         */
        __asm {
            mov     eax, fRc;               /* Get return value */
            mov     esp, EstablisherFrame;  /* Restore ESP */
//            jmp     [esp].sehTarget;        /* Back to CallWithSEH */

//We should be doing the above, but it faults VC4.2. Gotta love it.

            jmp     DWORD ptr [esp+8]
        }

    }

    /*
     *  We are unwinding.  Don't interfere.
     */
    return EXCEPTION_CONTINUE_SEARCH;
}

/***************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   DWORD | CallWithSEH |
 *
 *          Call the function with an exception frame active.
 *
 *          If the procedure raises an exception, then call
 *          InException and propagate whatever InException returns.
 *
 ***************************************************************************/

#pragma warning(disable:4035)           /* no return value (duh) */

__declspec(naked) DWORD WINAPI
CallWithSEH(EXCEPTPROC pfn, PV pv, INEXCEPTION InException)
{
    __asm {

        /* Function prologue */
        push    ebp;
        mov     ebp, esp;                       /* To keep C compiler happy */
        push    ebx;
        push    edi;
        push    esi;

        /*
         *  Build a SEHFRAME.
         */
        push    InException;                    /* What to handle */
        push    offset Exit;                    /* Where to go on error */

        xor     edx, edx;                       /* Keep zero handy */
        push    offset _MyExceptionFilter;      /* My handler */
        push    dword ptr fs:[edx];             /* Build frame */
        mov     fs:[edx], esp;                  /* Link in */
    }

        pfn(pv);                                /* Call the victim */

    __asm {
        /*
         *  The validation layer jumps here (all registers in a random
         *  state except for ESP) if something went wrong.
         *
         *  We don't need to restore nonvolatile registers now;
         *  that will be done as part of the procedure exit.
         */
Exit:;

        xor     edx, edx;                       /* Keep zero handy */
        pop     dword ptr fs:[edx];             /* Remove frame */

        /*
         *  Discard MyExceptionFilter, Exit, and InException.
         */
        add     esp, 12;

        pop     esi;
        pop     edi;
        pop     ebx;
        pop     ebp;
        ret     12;
    }

}

#pragma warning(default:4035)

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\remdsk\rds\samples\client\client.cpp ===
#include "precomp.h"

#include <initguid.h>
#include <service.h>
#include <nmmkcert.h>

//
// CLIENT.CPP
// Created 4/19/2000 LauraBu
//
// Sample client-side app for remote desktop sharing
//      - Calls an address
//      - Views the callee's shared desktop
//      - Takes control automatically or allows user to do it
//


// Globals
HINSTANCE           g_hInst;
HWND                g_hwndMain;
INmManager *        g_pMgr = NULL;
CMgrNotify *        g_pMgrNotify = NULL;
INmConference *     g_pConf = NULL;
CConfNotify *       g_pConfNotify = NULL;
IAppSharing *       g_pAS = NULL;
INmCall *           g_pCall = NULL;
CCallNotify *       g_pCallNotify = NULL;
INmChannelData *    g_pPrivateChannel = NULL;
CNmDataNotify *     g_pDataNotify = NULL;


#ifdef DEBUG
enum
{
    ZONE_CORE   = BASE_ZONE_INDEX,
};

#define MLZ_FILE_ZONE   ZONE_CORE

static PTCHAR c_apszDbgZones[] =
{
    TEXT("Client"),
    DEFAULT_ZONES
    TEXT("Core"),
};
#endif // DEBUG

//
// Main entry point
//
void __cdecl main(int argc, char **argv)
{
    MSG msg;

#ifdef _DEBUG
    MLZ_DbgInit((PSTR *)&c_apszDbgZones[0],
        (sizeof(c_apszDbgZones) / sizeof(c_apszDbgZones[0])) - 1);
#endif

    g_hInst = ::GetModuleHandle(NULL);

    if (!InitClient())
    {
        goto Cleanup;
    }

    // Main message loop
    while (GetMessage(&msg, NULL, 0, 0))
    {
        if (!g_hwndMain || !IsDialogMessage(g_hwndMain, &msg))
        {
            TranslateMessage(&msg);
            DispatchMessage(&msg);
        }
    }

Cleanup:
    TermClient();

#ifdef DEBUG
    MLZ_DbgDeInit();
#endif // DEBUG

    ExitProcess(0);
}



//
// InitClient()
//
// Create the demo modeless dialog and initialize T.120 etc.
//
BOOL InitClient(void)
{
    HRESULT hr;
    HCERTSTORE      hStore;
    PCCERT_CONTEXT  pCertContext = NULL;

    CoInitialize(NULL);

    //
    // Init common controls
    //
        // Ensure the common controls are loaded
        INITCOMMONCONTROLSEX icc;
        icc.dwSize = sizeof(icc);
        icc.dwICC = ICC_WIN95_CLASSES | ICC_COOL_CLASSES | ICC_USEREX_CLASSES;
        InitCommonControlsEx(&icc);

    //
    // Initialize the calling/conf stuff
    //

    //
    // Get NmManager object from RDCALL
    //
    hr = CreateNmManager(&g_pMgr);
    if (FAILED(hr))
    {
        ERROR_OUT(("CreateNmManager failed with error 0x%08x", hr));
        return FALSE;
    }


    //
    // Register our notification objects with NmManager so we can
    //      find out about calls and create conferences
    //
    g_pMgrNotify = new CMgrNotify();
    if (!g_pMgrNotify)
    {
        ERROR_OUT(("new CMgrNotify() failed"));
        return FALSE;
    }

    hr = g_pMgrNotify->Connect(g_pMgr);
    if (FAILED(hr))
    {
        ERROR_OUT(("Connect to INmManager failed with error 0x%08x", hr));
        return FALSE;
    }

    //
    // Set up our credentials
    //

    //
    // SALEM BUGBUG
    // Currently am using the NetMeeting certificate.  You will want to
    // provide your own cert/credentials for real.
    //

    hStore = CertOpenStore(CERT_STORE_PROV_SYSTEM,
        X509_ASN_ENCODING, 0, CERT_SYSTEM_STORE_CURRENT_USER,
        WSZNMSTORE);

    if ( NULL != hStore )
    {
        // Check the store for any certificate
        pCertContext = CertFindCertificateInStore(hStore,
            X509_ASN_ENCODING, 0, CERT_FIND_ANY, NULL, NULL);

        CertCloseStore( hStore, 0);
    }

    if ( NULL == pCertContext )
    {
        ERROR_OUT(("No server context cert found!"));
    }

    //
    // Initialize calling with our name, properties
    //
    TCHAR szComputerName[MAX_PATH+1];
    DWORD dwComputerNameLength = sizeof(szComputerName) / sizeof(szComputerName[0]);

    if (!GetComputerName(szComputerName, &dwComputerNameLength))
    {
        ERROR_OUT(("GetComputerName failed"));
        lstrcpy(szComputerName, "<UNKNOWN>");
    }

    hr = g_pMgr->Initialize(BSTRING(szComputerName), (DWORD_PTR)pCertContext,
        DEFAULT_LISTEN_PORT, NMMANAGER_CLIENT);

    if (pCertContext)
    {
        CertFreeCertificateContext(pCertContext);
    }


    if (FAILED(hr))
    {
        ERROR_OUT(("INmManager Initialize failed with error 0x%08x", hr));
        return FALSE;
    }


    //hr = ::CreateASObject(g_pMgrNotify, 0, &g_pAS);
    //if (FAILED(hr))
    //{
    //    ERROR_OUT(("CreateASObject failed with error 0x%08x", hr));
    //    return FALSE;
    //}

    //
    // Put up the dialog
    //
    if (CreateDialogParam(g_hInst, MAKEINTRESOURCE(IDD_CLIENTUI),
        NULL, ClientDlgProc, 0) == NULL)
    {
        ERROR_OUT(("CreateDialog of IDD_SERVERUI failed"));
        return FALSE;
    }

    ShowWindow(g_hwndMain, SW_SHOW);
    UpdateWindow(g_hwndMain);

    return TRUE;
}


//
// TermClient()
//
// Destroy the font demo modeless dialog and shutdown
//
void TermClient(void)
{
    //
    // Release the AppSharing interface
    //
    if (g_pAS)
    {
        g_pAS->Release();
        g_pAS = NULL;
    }

    //
    // Cleanup private channel
    //
    DeactivatePrivateChannel();

    HangupCall();

    //
    // 4.  Disconnect from NmManager to stop getting notifications
    //
    if (g_pMgrNotify)
    {
        g_pMgrNotify->Disconnect();
        g_pMgrNotify->Release();
        g_pMgrNotify = NULL;
    }


    //
    // 5.  Let go of the NmManager interface
    //
    if (g_pMgr)
    {
        g_pMgr->Release();
        g_pMgr = NULL;
    }

    if (g_hwndMain)
    {
        DestroyWindow(g_hwndMain);
        g_hwndMain = NULL;
    }

    CoUninitialize();
}



//
// ClientDlgProc()
//
// Client demo modeless dialog handler
//
BOOL CALLBACK ClientDlgProc
(
    HWND    hwnd,
    UINT    uMsg,
    WPARAM  wParam,
    LPARAM  lParam
)
{
    BOOL    rc = TRUE;

    switch (uMsg)
    {
        case WM_INITDIALOG:
        {
            g_hwndMain = hwnd;
            ::SendDlgItemMessage(hwnd, IDC_ADDRESS, EM_LIMITTEXT, MAX_PATH, 0);
            ::EnableWindow(::GetDlgItem(hwnd, IDC_CALL), FALSE);
            ::EnableWindow(::GetDlgItem(hwnd, IDC_HANGUP), FALSE);
            break;
        }

        case WM_CLOSE:
        {
            DestroyWindow(hwnd);
            break;
        }

        case WM_DESTROY:
        {
            g_hwndMain = NULL;
            PostQuitMessage(0);
            break;
        }

        case WM_COMMAND:
        {
            switch (GET_WM_COMMAND_ID(wParam, lParam))
            {
                case IDC_CALL:
                {
                    PlaceCall();
                    break;
                }

                case IDC_HANGUP:
                {
                    DeactivatePrivateChannel();
                    HangupCall();
                    break;
                }

                case IDC_SENDBUTTON:
                {
                    SendPrivateData();
                    break;
                }

                case IDC_ADDRESS:
                {
                    switch (GET_WM_COMMAND_CMD(wParam, lParam))
                    {
                        case EN_CHANGE:
                        case EN_UPDATE:
                        {
                            ::EnableWindow(::GetDlgItem(hwnd, IDC_CALL),
                                (::SendDlgItemMessage(hwnd, IDC_ADDRESS,
                                WM_GETTEXTLENGTH, 0, 0) != 0));
                            break;
                        }
                    }
                    break;
                }

                default:
                    break;
            }
            break;
        }

        default:
        {
            rc = FALSE;
            break;
        }
    }

    return rc;
}



//
// PlaceCall()
//
BOOL PlaceCall(void)
{
    TCHAR   szAddress[MAX_PATH];
    TCHAR   szConference[MAX_PATH];
    INmCall *   pCall = NULL;
    HRESULT hr;
    UINT    flags;

    ::GetDlgItemText(g_hwndMain, IDC_ADDRESS, szAddress, CCHMAX(szAddress));
    if (!szAddress[0])
    {
        ERROR_OUT(("PlaceCall - no address to call"));
        return FALSE;
    }

    ::LoadString(g_hInst, IDS_CONFERENCE_TITLE, szConference, CCHMAX(szConference));


    //
    // Now place outgoing call to server
    //
    flags = CRPCF_JOIN | CRPCF_NO_UI;
    if (IsDlgButtonChecked(g_hwndMain, IDC_SECURITY))
        flags |= CRPCF_SECURE;

    hr = g_pMgr->Call(
            &g_pCall,
            flags,
            NM_ADDR_MACHINENAME,
            BSTRING(szAddress),
            BSTRING(szConference),
            NULL);
    if (FAILED(hr))
    {
        ERROR_OUT(("PlaceCall - INmManager() Call failed with error 0x%08x", hr));
        return FALSE;
    }

    //hr = ::CreateASObject(g_pMgrNotify, 0, &g_pAS);
    //if (FAILED(hr))
    //{
    //    ERROR_OUT(("CreateASObject failed with error 0x%08x", hr));
    //    return FALSE;
    //}

    ASSERT(g_pCall);
    ::EnableWindow(::GetDlgItem(g_hwndMain, IDC_ADDRESS), FALSE);
    ::EnableWindow(::GetDlgItem(g_hwndMain, IDC_CALL), FALSE);
    ::EnableWindow(::GetDlgItem(g_hwndMain, IDC_HANGUP), TRUE);

    return TRUE;
}


void HangupCall(void)
{
    if (g_pAS)
    {
        g_pAS->Release();
        g_pAS = NULL;
    }

    if (g_pConf)
    {
        g_pConf->Leave();
    }

    if (g_pCallNotify)
    {
        g_pCallNotify->RemoveCall();
        g_pCallNotify->Release();
        g_pCallNotify = NULL;
    }

    if (g_pCall)
    {
        g_pCall->Release();
        g_pCall = NULL;
    }

    //
    // Disconnect from the conference if there is one currently,
    //  to stop getting notifications
    //
    if (g_pConfNotify)
    {
        g_pConfNotify->Disconnect();
        g_pConfNotify->Release();
        g_pConfNotify = NULL;
    }

    //
    // Release the NmConference interface
    //
    if (g_pConf)
    {
        g_pConf->Release();
        g_pConf = NULL;
    }

    if (g_hwndMain)
    {
        ::EnableWindow(::GetDlgItem(g_hwndMain, IDC_CALL),
            (::SendDlgItemMessage(g_hwndMain, IDC_ADDRESS, WM_GETTEXTLENGTH, 0, 0) != 0));
        ::EnableWindow(::GetDlgItem(g_hwndMain, IDC_ADDRESS), TRUE);
        ::EnableWindow(::GetDlgItem(g_hwndMain, IDC_HANGUP), FALSE);
    }
}



//
// ActivatePrivateChannel()
//
BOOL ActivatePrivateChannel(void)
{
    HRESULT hr;

    ASSERT(g_pConf);

    hr = g_pConf->CreateDataChannel(&g_pPrivateChannel,
        GUID_SAMPLEDATA);
    if (!SUCCEEDED(hr))
    {
        ERROR_OUT(("CreateDataChannel failed with error 0x%08x", hr));
        return FALSE;
    }

    g_pDataNotify = new CNmDataNotify();
    if (!g_pDataNotify)
    {
        ERROR_OUT(("new CNmDataNotify failed"));
        return FALSE;
    }

    hr = g_pDataNotify->Connect(g_pPrivateChannel);
    if (FAILED(hr))
    {
        ERROR_OUT(("Connect to g_pPrivateChannel failed with error 0x%08x", hr));
        return FALSE;
    }

    return S_OK;
}

//
// DeactivatePrivateChannel()
//
void DeactivatePrivateChannel(void)
{
    if (g_pDataNotify)
    {
        g_pDataNotify->Disconnect();
        g_pDataNotify->Release();
        g_pDataNotify = NULL;
    }

    if (g_pPrivateChannel)
    {
        g_pPrivateChannel->Release();
        g_pPrivateChannel = NULL;
    }
}



CMgrNotify::CMgrNotify() : RefCount(), CNotify()
{
    TRACE_OUT(("CMgrNotify created"));
}

CMgrNotify::~CMgrNotify()
{
    TRACE_OUT(("CMgrNotify destroyed"));
}


///////////////////////////
//  CMgrNotify:IUnknown

ULONG STDMETHODCALLTYPE CMgrNotify::AddRef(void)
{
    return RefCount::AddRef();
}


ULONG STDMETHODCALLTYPE CMgrNotify::Release(void)
{
    return RefCount::Release();
}

HRESULT STDMETHODCALLTYPE CMgrNotify::QueryInterface(REFIID riid, PVOID *ppvObject)
{
    HRESULT hr = S_OK;

    TRACE_OUT(("CMgrNotify QI'd"));

    if (riid == IID_IUnknown || riid == IID_INmManagerNotify)
    {
        *ppvObject = (INmManagerNotify *)this;
    }
    else
    {
        hr = E_NOINTERFACE;
        *ppvObject = NULL;
    }

    if (S_OK == hr)
    {
        AddRef();
    }

    return hr;
}



////////////////////////////
//  CMgrNotify:ICNotify

HRESULT STDMETHODCALLTYPE CMgrNotify::Connect(IUnknown *pUnk)
{
    TRACE_OUT(("CMgrNotify::Connect\n") );
    return CNotify::Connect(pUnk, IID_INmManagerNotify, (INmManagerNotify *)this);
}

HRESULT STDMETHODCALLTYPE CMgrNotify::Disconnect(void)
{
    TRACE_OUT(("CMgrNotify::Disconnect\n") );
    return CNotify::Disconnect();
}



//////////////////////////////////
//  CMgrNotify:INmManagerNotify

HRESULT STDMETHODCALLTYPE CMgrNotify::NmUI(CONFN confn)
{
    TRACE_OUT(("CMgrNotify::NmUI\n") );
    return S_OK;
}

HRESULT STDMETHODCALLTYPE CMgrNotify::CallCreated(INmCall *pNmCall)
{
    TRACE_OUT(("CMgrNotify::CallCreated...\n") );
    if (g_pCallNotify)
    {
        ERROR_OUT(("CMgrNotify - CallCreated, have call already 0x%08x", g_pCallNotify));
        return E_FAIL;
    }

    g_pCallNotify = new CCallNotify(pNmCall);

    TRACE_OUT(("CMgrNotify::CallCreated"));
    return S_OK;
}



HRESULT STDMETHODCALLTYPE CMgrNotify::ConferenceCreated(INmConference *pConference)
{
    HRESULT hr;

    TRACE_OUT(("CMgrNotify::ConferenceCreated\n") );

    //
    // Hold onto this object
    //
    ASSERT(pConference);
    g_pConf = pConference;
    g_pConf->AddRef();

    ASSERT(NULL == g_pConfNotify);
    g_pConfNotify = new CConfNotify();
    if (NULL == g_pConfNotify)
    {
        ERROR_OUT(("CMgrNotify::ConferenceCreated - failed to new CConfNotify"));
        return E_OUTOFMEMORY;
    }

    hr = g_pConfNotify->Connect(g_pConf);
    if (FAILED(hr))
    {
        ERROR_OUT(("CMgrNotify::ConferenceCreated - failed to connect"));
        g_pConfNotify->Release();
        g_pConfNotify = NULL;
    }

    return S_OK;
}

// CMgrNotify::IAppSharingNotify
HRESULT STDMETHODCALLTYPE CMgrNotify::OnReadyToShare(BOOL fReady)
{
    TRACE_OUT(("CMgrNotify::OnReadyToShare\n"));

    return S_OK;
}

HRESULT STDMETHODCALLTYPE CMgrNotify::OnShareStarted()
{
    TRACE_OUT(("CMgrNotify::OnShareStarted\n"));
    return S_OK;
}

HRESULT STDMETHODCALLTYPE CMgrNotify::OnSharingStarted()
{
    TRACE_OUT(("CMgrNotify::OnSharingStarted\n"));
    return S_OK;
}

HRESULT STDMETHODCALLTYPE CMgrNotify::OnShareEnded()
{
    TRACE_OUT(("CMgrNotify::OnShareEnded\n"));

    return S_OK;
}

HRESULT STDMETHODCALLTYPE CMgrNotify::OnPersonJoined(IAS_GCC_ID gccID)
{
    TRACE_OUT(("CMgrNotify::OnPersonJoined\n"));

    return S_OK;
}

HRESULT STDMETHODCALLTYPE CMgrNotify::OnPersonLeft(IAS_GCC_ID gccID)
{
    TRACE_OUT(("CMgrNotify::OnPersonLeft\n"));

    return S_OK;
}

HRESULT STDMETHODCALLTYPE CMgrNotify::OnStartInControl(IAS_GCC_ID gccID)
{
    TRACE_OUT(("CMgrNotify::OnStartInControl\n"));

    return S_OK;
}

HRESULT STDMETHODCALLTYPE CMgrNotify::OnStopInControl(IAS_GCC_ID gccID)
{
    TRACE_OUT(("CMgrNotify::OnStopInControl\n"));
    return S_OK;
}



HRESULT STDMETHODCALLTYPE CMgrNotify::OnControllable(BOOL fControllable)
{
    TRACE_OUT(("CMgrNotify::OnControllable\n"));

    if (fControllable && g_pAS)
    {
        // Give control to the other dude autoomatically, if the
        // option is on.
    }
    return S_OK;
}

HRESULT STDMETHODCALLTYPE CMgrNotify::OnStartControlled(IAS_GCC_ID gccID)
{
    TRACE_OUT(("CMgrNotify::OnStartControlled\n"));
    return S_OK;
}

HRESULT STDMETHODCALLTYPE CMgrNotify::OnStopControlled(IAS_GCC_ID gccID)
{
    TRACE_OUT(("CMgrNotify::OnStopControlled\n"));
    return S_OK;
}




CCallNotify::CCallNotify(INmCall * pNmCall) :
        m_pCall  (pNmCall),
        m_pszName  (NULL),
        m_fSelectedConference (FALSE),
        m_pos      (NULL),
        m_cRef     (1),
        m_dwCookie (0)
{
        HRESULT hr;

        TRACE_OUT(("CCallNotify: Created %08X (INmCall=%08X)\n", this, pNmCall) );

        ASSERT(NULL != m_pCall);
        m_pCall->AddRef();

        // Get the display name
        BSTR  bstr;
        hr = m_pCall->GetAddress(&bstr);
        if (SUCCEEDED(hr))
        {
                hr = BSTR_to_LPTSTR(&m_pszName, bstr);
                SysFreeString(bstr);
        }
        if (FEmptySz(m_pszName))
        {
                // Default to "another person" if no name available in the call data
                m_pszName = TEXT("Somebody");
        }

        // These should never change
        m_fIncoming = (m_pCall->IsIncoming() == S_OK);
        m_dwTick = ::GetTickCount();

        Update();

        NmAdvise(m_pCall, this, IID_INmCallNotify, &m_dwCookie);
}

VOID CCallNotify::RemoveCall(void)
{
        NmUnadvise(m_pCall, IID_INmCallNotify, m_dwCookie);
}

CCallNotify::~CCallNotify()
{
    delete m_pszName;

    ASSERT(NULL != m_pCall);
    m_pCall->Release();

    ASSERT(g_pCallNotify == this);
    g_pCallNotify = NULL;
}

// IUnknown methods
STDMETHODIMP_(ULONG) CCallNotify::AddRef(void)
{
        return ++m_cRef;
}

STDMETHODIMP_(ULONG) CCallNotify::Release(void)
{
        ASSERT(m_cRef > 0);
        if (m_cRef > 0)
        {
                m_cRef--;
        }

        ULONG cRef = m_cRef;

        if (0 == cRef)
        {
                delete this;
        }

        return cRef;
}

STDMETHODIMP CCallNotify::QueryInterface(REFIID riid, PVOID *ppv)
{
        HRESULT hr = S_OK;

        if ((riid == IID_INmCallNotify) || (riid == IID_IUnknown))
        {
                *ppv = (INmCallNotify *)this;
        }
        else
        {
                hr = E_NOINTERFACE;
                *ppv = NULL;
        }

        if (S_OK == hr)
        {
                AddRef();
        }

        return hr;
}

// INmCallNotify methods
STDMETHODIMP CCallNotify::NmUI(CONFN uNotify)
{
        return S_OK;
}

STDMETHODIMP CCallNotify::StateChanged(NM_CALL_STATE uState)
{
    TRACE_OUT(("CCallNotify::StateChanged\n"));

    // REVIEW: This check should be done outside of this routine
    if (uState == m_State)
    {
            // Don't bother the UI when nothing changes!
            return S_OK;
    }

    Update();

    return S_OK;
}

STDMETHODIMP CCallNotify::Failed(ULONG uError)
{
        return S_OK;
}

STDMETHODIMP CCallNotify::Accepted(INmConference *pConference)
{
        return S_OK;
}

// INmCallNotify2 methods
STDMETHODIMP CCallNotify::CallError(UINT cns)
{
        return S_OK;
}


STDMETHODIMP CCallNotify::RemoteConference(BOOL fMCU, BSTR *pwszConfNames, BSTR *pbstrConfToJoin)
{
        return S_OK;
}

STDMETHODIMP CCallNotify::RemotePassword(BSTR bstrConference, BSTR *pbstrPassword, BYTE *pb, DWORD cb)
{
        return S_OK;
}

/*  U P D A T E  */
/*-------------------------------------------------------------------------
    %%Function: Update

    Update the cached information about the call
-------------------------------------------------------------------------*/
VOID CCallNotify::Update(void)
{
    HRESULT hr;

        m_pCall->GetState(&m_State);
        // TRACE_OUT(("CCall: New State=%0d for call=%08X", m_State, this));

        switch (m_State)
        {
        case NM_CALL_ACCEPTED:
                // Create AS object here...
                hr = ::CreateASObject(g_pMgrNotify, 0, &g_pAS);
                if (FAILED(hr))
                {
                    ERROR_OUT(("CreateASObject failed with error 0x%08x", hr));
                }
                break;

        case NM_CALL_INVALID:
        case NM_CALL_REJECTED:
        case NM_CALL_CANCELED:

                RemoveCall();
                Release();
                break;

        case NM_CALL_RING:
                m_pCall->Accept();
                break;

        default:
                ERROR_OUT(("CCall::Update: Unknown state %08X", m_State));

        //case NM_CALL_INVALID:
        case NM_CALL_INIT:
        case NM_CALL_SEARCH:
        case NM_CALL_WAIT:
                break;
        }

}


//////////////////////////////////////////////////////////////////////////
//  C  C N F  N O T I F Y

CConfNotify::CConfNotify() : RefCount(), CNotify()
{
    TRACE_OUT(("CConfNotify created"));
}

CConfNotify::~CConfNotify()
{
    TRACE_OUT(("CConfNotify destroyed"));
}


///////////////////////////
//  CConfNotify:IUknown

ULONG STDMETHODCALLTYPE CConfNotify::AddRef(void)
{
    TRACE_OUT(("CConfNotify::AddRef"));
    return RefCount::AddRef();
}


ULONG STDMETHODCALLTYPE CConfNotify::Release(void)
{
    TRACE_OUT(("CConfNotify::Release"));
    return RefCount::Release();
}


HRESULT STDMETHODCALLTYPE CConfNotify::QueryInterface(REFIID riid, PVOID *ppvObject)
{
    HRESULT hr = S_OK;

    TRACE_OUT(("CConfNotify::QueryInterface"));

    if (riid == IID_IUnknown)
    {
        TRACE_OUT(("CConfNotify::QueryInterface IID_IUnknown"));
        *ppvObject = (IUnknown *)this;
    }
    else if (riid == IID_INmConferenceNotify)
    {
        TRACE_OUT(("CConfNotify::QueryInterface IID_INmConferenceNotify"));
        *ppvObject = (INmConferenceNotify *)this;
    }
    else
    {
        WARNING_OUT(("CConfNotify::QueryInterface bogus"));
        hr = E_NOINTERFACE;
        *ppvObject = NULL;
    }

    if (S_OK == hr)
    {
        AddRef();
    }

    return hr;
}



////////////////////////////
//  CConfNotify:ICNotify

HRESULT STDMETHODCALLTYPE CConfNotify::Connect(IUnknown *pUnk)
{
    TRACE_OUT(("CConfNotify::Connect"));
    return CNotify::Connect(pUnk,IID_INmConferenceNotify,(IUnknown *)this);
}

HRESULT STDMETHODCALLTYPE CConfNotify::Disconnect(void)
{
    TRACE_OUT(("CConfNotify::Disconnect"));
    return CNotify::Disconnect();
}


//////////////////////////////////
//  CConfNotify:IConfNotify

HRESULT STDMETHODCALLTYPE CConfNotify::NmUI(CONFN uNotify)
{
    TRACE_OUT(("CConfNotify::NmUI"));
    TRACE_OUT(("NmUI called."));
    return S_OK;
}

HRESULT STDMETHODCALLTYPE CConfNotify::StateChanged(NM_CONFERENCE_STATE uState)
{
    TRACE_OUT(("CConfNotify::StateChanged"));

    if (NULL == g_pConf)
        return S_OK; // weird

    switch (uState)
    {
    case NM_CONFERENCE_ACTIVE:
        break;

    case NM_CONFERENCE_INITIALIZING:
        break; // can't do anything just yet

    case NM_CONFERENCE_WAITING:
        break;

    case NM_CONFERENCE_IDLE:
        if (g_hwndMain)
        {
            ::PostMessage(g_hwndMain, WM_COMMAND, IDC_HANGUP, 0);
        }
        break;
    }

    return S_OK;
}


HRESULT STDMETHODCALLTYPE CConfNotify::MemberChanged(NM_MEMBER_NOTIFY uNotify, INmMember *pMember)
{
    HRESULT hr;

    switch (uNotify)
    {
        case NM_MEMBER_ADDED:
        {
            TRACE_OUT(("CConfNotify::MemberChanged() Member added"));

            //
            // Add to our roster
            //
            ULONG   id = 0;
            BSTR    bstrName;

            pMember->GetID(&id);

            hr = pMember->GetName(&bstrName);
            if (FAILED(hr))
            {
                ERROR_OUT(("GetName of member failed"));
            }
            else
            {
                CSTRING string(bstrName);
                TCHAR   szName[MAX_PATH];

                wsprintf(szName, "%s - %d", (LPCSTR)string, id);

                ::SendDlgItemMessage(g_hwndMain, IDC_ROSTER, LB_ADDSTRING,
                    (WPARAM)-1, (LPARAM)szName);

                SysFreeString(bstrName);
            }

            //
            // Create our private data channel when we've been added
            // to the conference.
            //

            if (pMember->IsSelf() == S_OK)
            {
                ActivatePrivateChannel();
            }
            break;
        }

        case NM_MEMBER_REMOVED:
        {
            TRACE_OUT(("CConfNotify::MemberChanged() Member removed"));

            //
            // Remove our private data channel when we're leaving
            // the conference.
            //
            if (pMember->IsSelf() == S_OK)
            {
                DeactivatePrivateChannel();
            }

            //
            // Remove from our roster
            //
            ULONG   id = 0;
            BSTR    bstrName;

            pMember->GetID(&id);

            hr = pMember->GetName(&bstrName);
            if (FAILED(hr))
            {
                ERROR_OUT(("GetName of member failed"));
            }
            else
            {
                CSTRING string(bstrName);
                TCHAR   szName[MAX_PATH];
                int     iItem;

                wsprintf(szName, "%s - %d", (LPCSTR)string, id);

                iItem = ::SendDlgItemMessage(g_hwndMain, IDC_ROSTER,
                    LB_FINDSTRING, 0, (LPARAM)szName);
                if (iItem != -1)
                {
                    ::SendDlgItemMessage(g_hwndMain, IDC_ROSTER, LB_DELETESTRING,
                        iItem, 0);
                }

                SysFreeString(bstrName);
            }

            break;
        }

        case NM_MEMBER_UPDATED:
        {
            TRACE_OUT(("CConfNotify::MemberChanged() Member updated"));
            break;
        }

        default:
            break;
    }

    return hr;
}


//
// SendPrivateData()
//
void SendPrivateData(void)
{
    LPSTR   szData = NULL;
    UINT    cbData;
    HRESULT hr;

    if (!g_pPrivateChannel)
    {
        //hueiwangERROR_OUT(("Can't send private data - no channel object"));
        return;
    }

    cbData = ::SendDlgItemMessage(g_hwndMain, IDC_PRIVATESEND,
        WM_GETTEXTLENGTH, 0, 0);

    if (!cbData)
    {
        WARNING_OUT(("SendPrivateData - nothing to send"));
        return;
    }

    cbData++;
    szData = new char[cbData];
    if (!szData)
    {
        ERROR_OUT(("SendPrivateData - unable to allocate buffer"));
        return;
    }

    szData[cbData-1] = 0;
    ::SendDlgItemMessage(g_hwndMain, IDC_PRIVATESEND, WM_GETTEXT,
        cbData, (LPARAM)szData);

    //
    // Now send the data
    //
    hr = g_pPrivateChannel->SendData(NULL, cbData, (LPBYTE)szData,
        DATA_MEDIUM_PRIORITY | DATA_NORMAL_SEND);
    if (FAILED(hr))
    {
        ERROR_OUT(("SendPrivateData - SendData failed"));
    }

    delete szData;
}



//
// CNmDataNotify
//
ULONG STDMETHODCALLTYPE CNmDataNotify::AddRef(void)
{
    TRACE_OUT(("CNmDataNotify::AddRef"));
    return RefCount::AddRef();
}


ULONG STDMETHODCALLTYPE CNmDataNotify::Release(void)
{
    TRACE_OUT(("CNmDataNotify::Release"));
    return RefCount::Release();
}


HRESULT STDMETHODCALLTYPE CNmDataNotify::QueryInterface(REFIID riid, PVOID *ppvObject)
{
    HRESULT hr = S_OK;

    TRACE_OUT(("CNmDataNotify::QueryInterface"));

    if (riid == IID_IUnknown)
    {
        TRACE_OUT(("CNmDataNotify::QueryInterface IID_IUnknown"));
        *ppvObject = (IUnknown *)this;
    }
    else if (riid == IID_INmChannelDataNotify)
    {
        TRACE_OUT(("CNmDataNotify::QueryInterface IID_INmChannelDataNotify"));
        *ppvObject = (INmChannelDataNotify *)this;
    }
    else
    {
        WARNING_OUT(("CNmDataNotify::QueryInterface bogus"));
        hr = E_NOINTERFACE;
        *ppvObject = NULL;
    }

    if (S_OK == hr)
    {
        AddRef();
    }

    return hr;
}



////////////////////////////
//  CNmDataNotify:ICNotify

HRESULT STDMETHODCALLTYPE CNmDataNotify::Connect(IUnknown *pUnk)
{
    TRACE_OUT(("CNmDataNotify::Connect"));
    return CNotify::Connect(pUnk,IID_INmChannelDataNotify,(IUnknown *)this);
}

HRESULT STDMETHODCALLTYPE CNmDataNotify::Disconnect(void)
{
    TRACE_OUT(("CNmDataNotify::Disconnect"));
    return CNotify::Disconnect();
}


HRESULT STDMETHODCALLTYPE CNmDataNotify::NmUI(CONFN uNotify)
{
    TRACE_OUT(("CNmDataNotify::NmUI"));
    return S_OK;
}


HRESULT STDMETHODCALLTYPE CNmDataNotify::MemberChanged(NM_MEMBER_NOTIFY uNotify, INmMember *pMember)
{
    TRACE_OUT(("CNmDataNotify::MemberChanged"));
    return S_OK;
}


HRESULT STDMETHODCALLTYPE CNmDataNotify::DataSent
(
    INmMember *     pMember,
    ULONG           uSize,
    LPBYTE          pvBuffer
)
{
    TRACE_OUT(("CNmDataNotify::DataSent"));
    return S_OK;
}


HRESULT STDMETHODCALLTYPE CNmDataNotify::DataReceived
(
    INmMember *     pMember,
    ULONG           uSize,
    LPBYTE          pvBuffer,
    ULONG           dwFlags
)
{
    HRESULT         hr;

    TRACE_OUT(("CNmDataNotify::DataReceived"));

    //
    // Get the member's name, and add the data + name to the received
    // edit field.
    //
    if (pMember)
    {
        BSTR            bstrName;

        hr = pMember->GetName(&bstrName);
        if (SUCCEEDED(hr))
        {
            UINT            cch;
            char            szName[MAX_PATH];

            cch = SysStringLen(bstrName);
            WideCharToMultiByte(CP_ACP, 0, bstrName, -1, szName, cch+1, NULL, NULL);
            SysFreeString(bstrName);

            lstrcat(szName, ":  ");

            ::SendDlgItemMessage(g_hwndMain, IDC_PRIVATERECV, EM_REPLACESEL,
                    FALSE, (LPARAM)szName);
        }
    }

    //
    // Add data to the end of the edit field
    //
    ::SendDlgItemMessage(g_hwndMain, IDC_PRIVATERECV, EM_REPLACESEL,
        FALSE, (LPARAM)pvBuffer);

    //
    // Add carriage return to end of edit field
    //
    ::SendDlgItemMessage(g_hwndMain, IDC_PRIVATERECV, EM_REPLACESEL,
        FALSE, (LPARAM)"\r\n");

    return S_OK;
}


HRESULT STDMETHODCALLTYPE CNmDataNotify::AllocateHandleConfirm
(
    ULONG           handle_value,
    ULONG           chandles
)
{
    TRACE_OUT(("CNmDataNotify::AllocateHandleConfirm"));
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\remdsk\rds\samples\client\dbg.cpp ===
#include "precomp.h"
#pragma hdrstop

#ifdef DEBUG /*** THIS WHOLE FILE ***/

unsigned long g_BreakAlloc = (unsigned long)-1;

/*  U P D A T E  C R T  D B G  S E T T I N G S  */
/*-------------------------------------------------------------------------
    %%Function: UpdateCrtDbgSettings

    Update the C runtime debug memory settings
-------------------------------------------------------------------------*/
VOID UpdateCrtDbgSettings(void)
{
#if 0
	// This depends on the use of the debug c runtime library
	int tmpFlag = _CrtSetDbgFlag(_CRTDBG_REPORT_FLAG);

	// Always enable memory leak checking debug spew
	// tmpFlag |= _CRTDBG_LEAK_CHECK_DF;

	// Release memory just like the retail version
	tmpFlag &= ~_CRTDBG_DELAY_FREE_MEM_DF;

	// Don't bother checking the entire heap
	tmpFlag &= ~_CRTDBG_CHECK_ALWAYS_DF;
	
	_CrtSetDbgFlag(tmpFlag);
#endif // 0
}

#if 0
int _cdecl MyAllocHook ( int allocType, void *userData,
			size_t size, int blockType,
			long requestNumber, const char *filename, int lineNumber )
{
	char buf[256];
	wsprintf(buf, "%s {%d}: %d bytes on line %d file %s\n\r",
					allocType == _HOOK_ALLOC ? "ALLOC" :
					( allocType == _HOOK_REALLOC ? "REALLOC" : "FREE" ),
					requestNumber,
					size, lineNumber, filename );
	OutputDebugString(buf);
	return TRUE;
}
#endif // 0 

/*  I N I T  D E B U G  M E M O R Y  O P T I O N S  */
/*-------------------------------------------------------------------------
    %%Function: InitDebugMemoryOptions

    Initilize the runtime memory
-------------------------------------------------------------------------*/
BOOL InitDebugMemoryOptions(void)
{
#if 0
	// _asm int 3; chance to set _crtBreakAlloc - use debugger or uncomment
	_CrtSetBreakAlloc(g_BreakAlloc);

	UpdateCrtDbgSettings();

	_CrtSetReportMode(_CRT_ERROR, _CRTDBG_MODE_WNDW); // create a message box on errors

	{	//  To track down memory leaks, set cAlloc to the allocation number
		LONG cAlloc = 0; // Allocation number
		if (0 != cAlloc)
			_CrtSetBreakAlloc(cAlloc);
	}

	#ifdef MNMSRVC_SETALLOCHOOK
	_CrtSetAllocHook ( MyAllocHook );
	#endif // MNMSRVC_SETALLOCHOOK
#endif // 0
	return TRUE;
}

VOID DumpMemoryLeaksAndBreak(void)
{
#if 0
	if ( _CrtDumpMemoryLeaks() )
	{
		// _asm int 3; Uncomment to break after leak spew
	}
#endif // 0
}

#endif /* DEBUG - whole file */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\remdsk\rds\nmutil\i386\procid.asm ===
;*  Procdi.asm - Processor Identification routines
;*
;*      (C) Copyright Microsoft Corp., 1995
;*
;*      Processor ID
;*
;*  Origin:
;*
;*  Change history:
;*
;*  Date       Who        Description
;*  ---------  ---------  -------------------------------------------------
;*  12-Oct-95  MikeG      Created
;*

.386p
.387

.model  flat


;************************** Include Files ************************

;    include winbase.inc
;    include winerror.inc
;    include kernel32.inc
;    include segs.inc
;    include regstr.inc
;******************** Data Declerations **************************

.data
_DATA SEGMENT
CPU_ID  macro
        db      0fh, 0a2h
        endm

NONE            equ     0
PRESENT         equ     1
Nx586           equ     5
UNKNOWN         equ     0


_nxcpu          db      NONE                    ;default to none
_cputype        db      UNKNOWN                 ;default to unknown
_cpuid_flag     db      NONE                    ;default to no CPUID
_vendor_id      db      "************"
_cpu_signature  dd      0
_features_ecx   dd      0
_features_edx   dd      0
_features_ebx   dd      0
NexGen_id       db      "NexGenDriven"



;*********************** Prototypes ******************************


;************************** Code *********************************

.code

_TEXT	SEGMENT
;==========================================================================
; _get_nxcpu_type
;       This routine identifies NexGen's processor type in following steps:
;
;       if (no AC flag) {       //current Nx586 does not support AC flag
;               set ZF=1;
;               execute DIV to result a none zero value;
;               if (ZF=0) {     //ZF is changed
;                       not a NexGen processor;
;                       exit;
;               } else {        //Nx586 does not change ZF on DIV instruction
;                       if (ID bit not writeable) {
;                               CPU is Nx586 with no CPUID support
;                       } else {                //Nx586 with CPUID support
;                               execute CPUID instruction;
;                               save CPU information;
;                       }
;               }
;       } else {
;               if (ID bit not writeable) {
;                       not a NexGen processor;
;               } else {        //NexGen future processors support CPUID
;                       execute CPUID instruction;
;                       save CPU information;
;               }
;       }
;
;==========================================================================
get_nxcpu_type proc  C cdecl:DWORD
        push    ebx
        push    esi
        push    edi
        mov     byte ptr _nxcpu,PRESENT ; default to present

; test AC bit on EFLAGS register
        mov     bx,sp           ; save the current stack pointer
        and     sp,not 3        ; align the stack to avoid AC fault
        pushfd                  ;
        pop     eax             ; get the original EFLAGS
        mov     ecx,eax         ; save original flag
        xor     eax,40000h      ; flip AC bit in EFLAGS
        push    eax             ; save for EFLAGS
        popfd                   ; copy it to EFLAGS
        pushfd                  ;
        pop     eax             ; get the new EFLAGS value
        mov     sp,bx           ; restore stack pointer
        xor     eax,ecx         ; if the AC bit is unchanged
        je      test_zf         ;       goto second step
        jmp     nx_future_cpu

test_zf:
; test ZF on DIV instruction
        mov     ax,5555h        ; init AX with a non-zero value
        xor     dx,dx           ; set ZF=1
        mov     cx,2
        div     cx              ; Nx586 processor does not modify ZF on DIV
        jnz     not_nx_cpu      ; not a NexGen processor if ZF=0 (modified)

test_cpuid:
; test if CPUID instruction is available
; new Nx586 or future CPU supports CPUID instruction
        pushfd                  ; get EFLAGs
        pop     eax
        mov     ecx,eax         ; save it
        xor     eax,200000h     ; modify ID bit
        push    eax
        popfd                   ; save it in new EFLAGS
        pushfd                  ; get new EFLAGS
        pop     eax             ;
        xor     eax,ecx         ; is ID bit changed?
        jnz     cpuid_present   ; yes

        mov     byte ptr _cputype,Nx586 ; no, current Nx586
	mov	eax,1		; set return code == true
        jz      cpuid_exit      ; stop testing

nx_future_cpu:
; all NexGen's future processors feature a CPUID instruction
        mov     eax,ecx         ; get original EFLAGS
        xor     eax,200000h     ; modify ID bit
        push    eax
        popfd                   ; save it in new EFLAGS
        pushfd                  ; get new EFLAGS
        pop     eax             ;
        xor     eax,ecx         ; is ID bit changed?
        jz      not_nx_cpu      ; no, not a NexGen processor

cpuid_present:
; execute CPUID instruction to get vendor name, stepping and feature info
        xor     eax,eax
        CPU_ID
        mov     dword ptr _vendor_id,ebx
        mov     dword ptr _vendor_id[+4],edx
        mov     dword ptr _vendor_id[+8],ecx

        mov     bx,ds
        mov     es,bx
        mov     esi,offset _vendor_id
        mov     edi,offset NexGen_id
        mov     cx,12
        cld
        repe    cmpsb           ; compare vendor ID string
        jne     not_nx_cpu

        mov     byte ptr _cpuid_flag,PRESENT
        cmp     eax,1           ; check highest level
        jl      cpuid_exit

        mov     eax,1
        CPU_ID
        mov     _cpu_signature,eax
        mov     _features_ecx,ecx
        mov     _features_edx,edx
        mov     _features_ebx,ebx
        shr     eax,8
        and     al,0fh
        mov     _cputype,al
        jmp     cpuid_exit
not_nx_cpu:
        mov     byte ptr _nxcpu,NONE
        xor     eax,eax
cpuid_exit:
        pop     edi
        pop     esi
        pop     ebx
        ret
get_nxcpu_type endp

;**************************************************************************
;       Function:       int is_cyrix ()
;
;       Purpose:        Determine if Cyrix CPU is present
;       Technique:      Cyrix CPUs do not change flags where flags change
;                        in an undefined manner on other CPUs
;       Inputs:         none
;       Output:         ax == 1 Cyrix present, 0 if not
;**************************************************************************
is_cyrix proc C __cdecl:WORD
           .486
           push  bx
           xor   ax, ax         ; clear ax
           sahf                 ; clear flags, bit 1 is always 1 in flags
           mov   ax, 5
           mov   bx, 2
           div   bl             ; do an operation that does not change flags
           lahf                 ; get flags
           cmp   ah, 2          ; check for change in flags
           jne   not_cyrix      ; flags changed not Cyrix
           mov   ax, 1          ; TRUE Cyrix CPU
           jmp   done

not_cyrix:
           mov  ax, 0           ; FALSE NON-Cyrix CPU
done:
           pop  bx
           ret
is_cyrix   endp
_TEXT ends
      end
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\remdsk\rds\samples\client\clutil.h ===
//****************************************************************************
//  Module:     NMCHAT.EXE
//  File:       CLUTIL.H
//  Content:    
//              
//
//  Copyright (c) Microsoft Corporation 1997
//
// THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF 
// ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO 
// THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A 
// PARTICULAR PURPOSE.
//****************************************************************************

#ifndef _CL_UTIL_H_
#define _CL_UTIL_H_


// Reference Count
class RefCount
{
private:
   LONG m_cRef;

public:
   RefCount();
   // Virtual destructor defers to destructor of derived class.
   virtual ~RefCount();

   // IUnknown methods

   ULONG STDMETHODCALLTYPE AddRef(void);
   ULONG STDMETHODCALLTYPE Release(void);
};



//////////////////////
// Notification Sink
class CNotify
{
private:
    DWORD  m_dwCookie;
	IUnknown * m_pUnk;
    IConnectionPoint           * m_pcnp;
    IConnectionPointContainer  * m_pcnpcnt;
public:
    CNotify(void);
    ~CNotify();

    HRESULT Connect(IUnknown *pUnk, REFIID riid, IUnknown *pUnkN);
    HRESULT Disconnect(void);

    IUnknown * GetPunk() {return m_pUnk;}
};


///////////
// OBLIST

#define POSITION COBNODE*

struct COBNODE
{
	POSITION	pNext;
	void*		pItem;
};

class COBLIST
{
protected:
	POSITION m_pHead;
	POSITION m_pTail;
	int      m_cItem;
    virtual BOOL Compare(void* pItemToCompare, void* pComparator) 
                       { return(pItemToCompare == pComparator); }
public:
	COBLIST() : m_pHead(NULL), m_pTail(NULL), m_cItem(0) { }
    virtual         ~COBLIST();
	
	virtual void *  RemoveAt(POSITION rPos);
    void            EmptyList();
	POSITION	    AddTail(void* pItem);
	void *		    GetNext(POSITION& rPos);
    void *          SafeGetFromPosition(POSITION rPos);
    POSITION        GetPosition(void* pItem);
    POSITION        Lookup(void* pComparator);
	POSITION	    GetHeadPosition()  { return (m_pHead); }
	POSITION	    GetTailPosition()  { return (m_pTail); }
	BOOL		    IsEmpty()          { return (!m_pHead); }
	int             GetItemCount()     { return (m_cItem); }
#ifdef DEBUG
	void *		    GetHead();
	void *		    GetTail();
	void *		    RemoveHead();
	void *	        RemoveTail();
	void *		    GetFromPosition(POSITION rPos);
#else
	void *		    GetHead()          { return GetFromPosition(GetHeadPosition());}
	void *          GetTail()          { return m_pTail->pItem;}
	void *		    RemoveHead()       { return RemoveAt(m_pHead); }
	void *	        RemoveTail()       { return RemoveAt(m_pTail); }
	void *		    GetFromPosition(POSITION rPos){return(rPos->pItem);}
#endif
};

// Utility Functions
POSITION AddNode(PVOID pv, COBLIST ** ppList);
PVOID RemoveNode(POSITION * pPos, COBLIST *pList);



////////////
// BSTRING

class BSTRING
{
private:
	BSTR   m_bstr;

public:
	// Constructors
	BSTRING() {m_bstr = NULL;}

	inline BSTRING(LPCWSTR lpcwString);

#if !defined(UNICODE)
	// We don't support construction from an ANSI string in the Unicode build.
	BSTRING(LPCSTR lpcString);
#endif // !defined(UNICODE)

	// Destructor
	inline ~BSTRING();

	// Cast to BSTR
	operator BSTR() {return m_bstr;}
	inline LPBSTR GetLPBSTR(void);
};


BSTRING::BSTRING(LPCWSTR lpcwString)
{
	if (NULL != lpcwString)
	{
		m_bstr = SysAllocString(lpcwString);
		//ASSERT(NULL != m_bstr);
	}
	else
	{
		m_bstr = NULL;
	}
}

BSTRING::~BSTRING()
{
	if (NULL != m_bstr)
	{
		SysFreeString(m_bstr);
	}
}

inline LPBSTR BSTRING::GetLPBSTR(void)
{
	//ASSERT(NULL == m_bstr);

	return &m_bstr;
}

class BTSTR
{
private:
	LPTSTR m_psz;

public:
	BTSTR(BSTR bstr);
	~BTSTR();

	// Cast to BSTR
	operator LPTSTR() {return (NULL == m_psz) ? TEXT("<null>") : m_psz;}
};

LPTSTR PszFromBstr(BSTR bst);


HRESULT BSTR_to_LPTSTR(LPTSTR *ppsz, BSTR bstr);

HRESULT NmAdvise(IUnknown* pUnkCP, IUnknown* pUnk, const IID& iid, LPDWORD pdw);
HRESULT NmUnadvise(IUnknown* pUnkCP, const IID& iid, DWORD dw);


#endif  // _CL_UTIL_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\remdsk\rds\samples\client\precomp.h ===
#ifdef DEBUG
#define _CRTDBG_MAP_ALLOC
#endif

#include <windows.h>
#include <windowsx.h>
#include <stdio.h> 
#include <stdlib.h> 
#include <shellapi.h>
#include <process.h> 
#include <tchar.h> 
#include <stock.h>

#define MULTI_LEVEL_ZONES
#include <mlzdbg.h>
#include <memtrack.h>
#include <strutil.h>
#include <cstring.hpp>
#include <ias.h>
#include <confguid.h>

#include "imsconf3.h"
#include "resource.h"
#include "clutil.h"
#include "client.h"

#include "objidl.h"
#include "oleidl.h"
#include "ocidl.h"
#include "oaidl.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\remdsk\rds\samples\client\clutil.cpp ===
//****************************************************************************
//  Module:     NMCHAT.EXE
//  File:       CLUTIL.CPP
//  Content:    
//              
//
//  Copyright (c) Microsoft Corporation 1997
//
// THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF 
// ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO 
// THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A 
// PARTICULAR PURPOSE.
//****************************************************************************

#include "precomp.h"


///////////////////////////////////////////////////////////////////////////
// RefCount

/*  R E F  C O U N T  */
/*-------------------------------------------------------------------------
    %%Function: RefCount
    
-------------------------------------------------------------------------*/
RefCount::RefCount(void)
{
	m_cRef = 1;
}


RefCount::~RefCount(void)
{
}


ULONG STDMETHODCALLTYPE RefCount::AddRef(void)
{
   ASSERT(m_cRef >= 0);

   InterlockedIncrement(&m_cRef);

   return (ULONG) m_cRef;
}


ULONG STDMETHODCALLTYPE RefCount::Release(void)
{
	if (0 == InterlockedDecrement(&m_cRef))
	{
		delete this;
		return 0;
	}

	ASSERT(m_cRef > 0);
	return (ULONG) m_cRef;
}



///////////////////////////////////////////////////////////////////////////
// CNotify

/*  C  N O T I F Y  */
/*-------------------------------------------------------------------------
    %%Function: CNotify
    
-------------------------------------------------------------------------*/
CNotify::CNotify() :
	m_pcnpcnt(NULL),
    m_pcnp(NULL),
    m_dwCookie(0),
    m_pUnk(NULL)
{
}

CNotify::~CNotify()
{
	Disconnect(); // Make sure we're disconnected
}


/*  C O N N E C T  */
/*-------------------------------------------------------------------------
    %%Function: Connect

-------------------------------------------------------------------------*/
HRESULT CNotify::Connect(IUnknown *pUnk, REFIID riid, IUnknown *pUnkN)
{
	HRESULT hr;

	ASSERT(0 == m_dwCookie);

	// Get the connection container
	hr = pUnk->QueryInterface(IID_IConnectionPointContainer, (void **)&m_pcnpcnt);
	if (SUCCEEDED(hr))
	{
		// Find an appropriate connection point
		hr = m_pcnpcnt->FindConnectionPoint(riid, &m_pcnp);
		if (SUCCEEDED(hr))
		{
			ASSERT(NULL != m_pcnp);
			// Connect the sink object
			hr = m_pcnp->Advise((IUnknown *)pUnkN, &m_dwCookie);
		}
	}

	if (FAILED(hr))
	{
		ERROR_OUT(("MNMSRVC: CNotify::Connect failed: %x", hr));
		m_dwCookie = 0;
	}
	else
	{
    	m_pUnk = pUnk; // keep around for caller
    }

	return hr;
}



/*  D I S C O N N E C T  */
/*-------------------------------------------------------------------------
    %%Function: Disconnect
    
-------------------------------------------------------------------------*/
HRESULT CNotify::Disconnect (void)
{
    if (0 != m_dwCookie)
    {
        // Disconnect the sink object
        m_pcnp->Unadvise(m_dwCookie);
        m_dwCookie = 0;

        m_pcnp->Release();
        m_pcnp = NULL;

        m_pcnpcnt->Release();
        m_pcnpcnt = NULL;

        m_pUnk = NULL;
    }

    return S_OK;
}



///////////////////////////////////////////////////////////////////////////
// COBLIST


COBLIST::~COBLIST()
{
    ASSERT(IsEmpty());
}


#ifdef DEBUG
VOID* COBLIST::GetHead()
{
	ASSERT(m_pHead);

	return m_pHead->pItem;
}
   
VOID* COBLIST::GetTail()
{
	ASSERT(m_pTail);

	return m_pTail->pItem;
}
#endif /* DEBUG */

VOID* COBLIST::GetNext(POSITION& rPos)
{
	ASSERT(rPos);
	
	VOID* pReturn = rPos->pItem;
	rPos = rPos->pNext;

	return pReturn;
}

VOID* COBLIST::RemoveAt(POSITION Pos)
{
	VOID* pReturn = NULL;

	if (m_pHead)
	{
		if (m_pHead == Pos)
		{
			// Removing the first element in the list
			
			m_pHead = Pos->pNext;
			pReturn = Pos->pItem;
			delete Pos;
			m_cItem--;
			ASSERT(0 <= m_cItem);

			if (NULL == m_pHead)
			{
				// Removing the only element!
				m_pTail = NULL;
			}
		}
		else
		{
			POSITION pCur = m_pHead;

			while (pCur && pCur->pNext)
			{
				if (pCur->pNext == Pos)
				{
					// Removing 
					
					pCur->pNext = Pos->pNext;
					if (m_pTail == Pos)
					{
						m_pTail = pCur;
					}
					pReturn = Pos->pItem;
					delete Pos;

					m_cItem--;
					ASSERT(0 <= m_cItem);
				}

				pCur = pCur->pNext;
			}
		}
	}

	return pReturn;
}

POSITION COBLIST::AddTail(VOID* pItem)
{
	POSITION posRet = NULL;

	if (m_pTail)
	{
		if (m_pTail->pNext = new COBNODE)
		{
			m_pTail = m_pTail->pNext;
			m_pTail->pItem = pItem;
			m_pTail->pNext = NULL;
			m_cItem++;
		}
	}
	else
	{
		ASSERT(!m_pHead);
		if (m_pHead = new COBNODE)
		{
			m_pTail = m_pHead;
			m_pTail->pItem = pItem;
			m_pTail->pNext = NULL;
			m_cItem++;
		}
	}

	return m_pTail;
}

void COBLIST::EmptyList()
{
    while (!IsEmpty()) {
        RemoveAt(GetHeadPosition());
    }
}


#ifdef DEBUG
VOID* COBLIST::RemoveTail()
{
	ASSERT(m_pHead);
	ASSERT(m_pTail);
	
	return RemoveAt(m_pTail);
}

VOID* COBLIST::RemoveHead()
{
	ASSERT(m_pHead);
	ASSERT(m_pTail);
	
	return RemoveAt(m_pHead);
}

void * COBLIST::GetFromPosition(POSITION Pos)
{
    void * Result = SafeGetFromPosition(Pos);
	ASSERT(Result);
	return Result;
}
#endif /* DEBUG */

POSITION COBLIST::GetPosition(void* _pItem)
{
    POSITION    Position = m_pHead;

    while (Position) {
        if (Position->pItem == _pItem) {
            break;
        }
		GetNext(Position);
    }
    return Position;
}

POSITION COBLIST::Lookup(void* pComparator)
{
    POSITION    Position = m_pHead;

    while (Position) {
        if (Compare(Position->pItem, pComparator)) {
            break;
        }
		GetNext(Position);
    }
    return Position;
}

void * COBLIST::SafeGetFromPosition(POSITION Pos)
{
	// Safe way to validate that an entry is still in the list,
	// which ensures bugs that would reference deleted memory,
	// reference a NULL pointer instead
	// (e.g. an event handler fires late/twice).
	// Note that versioning on entries would provide an additional 
	// safeguard against re-use of a position.
	// Walk	list to find entry.

	POSITION PosWork = m_pHead;
	
	while (PosWork) {
		if (PosWork == Pos) {
			return Pos->pItem;
		}
		GetNext(PosWork);
	}
	return NULL;
}

/////////////////////////////
// COBLIST Utility routines

/*  A D D  N O D E  */
/*-------------------------------------------------------------------------
    %%Function: AddNode

    Add a node to a list.
    Initializes the ObList, if necessary.
    Returns the position in the list or NULL if there was a problem.
-------------------------------------------------------------------------*/
POSITION AddNode(PVOID pv, COBLIST ** ppList)
{
	ASSERT(NULL != ppList);
	if (NULL == *ppList)
	{
		*ppList = new COBLIST();
		if (NULL == *ppList)
			return NULL;
	}

	return (*ppList)->AddTail(pv);
}


/*  R E M O V E  N O D E  */
/*-------------------------------------------------------------------------
    %%Function: RemoveNode

    Remove a node from a list.
    Sets pPos to NULL
-------------------------------------------------------------------------*/
PVOID RemoveNode(POSITION * pPos, COBLIST *pList)
{
	if ((NULL == pList) || (NULL == pPos))
		return NULL;

	PVOID pv = pList->RemoveAt(*pPos);
	*pPos = NULL;
	return pv;
}


////////////////////////////////////////////////////////////////////////////
// BSTRING

// We don't support construction from an ANSI string in the Unicode build.
#if !defined(UNICODE)

BSTRING::BSTRING(LPCSTR lpcString)
{
	m_bstr = NULL;

	// Compute the length of the required BSTR, including the null
	int cWC =  MultiByteToWideChar(CP_ACP, 0, lpcString, -1, NULL, 0);
	if (cWC <= 0)
		return;

	// Allocate the BSTR, including the null
	m_bstr = SysAllocStringLen(NULL, cWC - 1); // SysAllocStringLen adds another 1

	ASSERT(NULL != m_bstr);
	if (NULL == m_bstr)
	{
		return;
	}

	// Copy the string
	MultiByteToWideChar(CP_ACP, 0, lpcString, -1, (LPWSTR) m_bstr, cWC);

	// Verify that the string is null terminated
	ASSERT(0 == m_bstr[cWC - 1]);
}

#endif // !defined(UNICODE)


///////////////////////////
// BTSTR

BTSTR::BTSTR(BSTR bstr)
{
	m_psz = PszFromBstr(bstr);
}

BTSTR::~BTSTR()
{
	if (NULL != m_psz)
		LocalFree(m_psz);
}

LPTSTR PszFromBstr(BSTR bstr)
{
	if (NULL == bstr)
		return NULL;
	int cch =  WideCharToMultiByte(CP_ACP, 0, (LPWSTR)bstr, -1, NULL, 0, NULL, NULL);
	if (cch <= 0)
		return NULL;

	LPTSTR psz = (LPTSTR)LocalAlloc(LMEM_FIXED, sizeof(TCHAR) * (cch+1) );
	if (NULL == psz)
		return NULL;

	WideCharToMultiByte(CP_ACP, 0, (LPWSTR)bstr, -1, psz, cch+1, NULL, NULL);
	return psz;
}


/*  B  S  T  R _ T O _  L  P  T  S  T  R  */
/*-------------------------------------------------------------------------
    %%Function: BSTR_to_LPTSTR
    
-------------------------------------------------------------------------*/
HRESULT BSTR_to_LPTSTR(LPTSTR *ppsz, BSTR bstr)
{
#ifndef UNICODE
	// compute the length of the required BSTR
	int cch =  WideCharToMultiByte(CP_ACP, 0, (LPWSTR)bstr, -1, NULL, 0, NULL, NULL);
	if (cch <= 0)
	{
		ERROR_OUT(("WideCharToMultiByte failed"));
		return E_FAIL;
	}

	// cch is the number of BYTES required, including the null terminator
	*ppsz = (LPTSTR) new char[cch];
	if (*ppsz == NULL)
	{
		ERROR_OUT(("WideCharToMultiByte out of memory"));
		return E_OUTOFMEMORY;
	}

	WideCharToMultiByte(CP_ACP, 0, (LPWSTR)bstr, -1, *ppsz, cch, NULL, NULL);
	return S_OK;
#else
	return E_NOTIMPL;
#endif // UNICODE
}

/////////////////////////////////////////////////////////////////////////////
// Connection Point Helpers

HRESULT NmAdvise(IUnknown* pUnkCP, IUnknown* pUnk, const IID& iid, LPDWORD pdw)
{
	IConnectionPointContainer *pCPC;
	IConnectionPoint *pCP;
	HRESULT hRes = pUnkCP->QueryInterface(IID_IConnectionPointContainer, (void**)&pCPC);
	if (SUCCEEDED(hRes))
	{
		hRes = pCPC->FindConnectionPoint(iid, &pCP);
		pCPC->Release();
	}
	if (SUCCEEDED(hRes))
	{
		hRes = pCP->Advise(pUnk, pdw);
		pCP->Release();
	}
	return hRes;
}

HRESULT NmUnadvise(IUnknown* pUnkCP, const IID& iid, DWORD dw)
{
	IConnectionPointContainer *pCPC;
	IConnectionPoint *pCP;
	HRESULT hRes = pUnkCP->QueryInterface(IID_IConnectionPointContainer, (void**)&pCPC);
	if (SUCCEEDED(hRes))
	{
		hRes = pCPC->FindConnectionPoint(iid, &pCP);
		pCPC->Release();
	}
	if (SUCCEEDED(hRes))
	{
		hRes = pCP->Unadvise(dw);
		pCP->Release();
	}
	return hRes;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\remdsk\rds\samples\server\clutil.h ===
//****************************************************************************
//  Module:     NMCHAT.EXE
//  File:       CLUTIL.H
//  Content:    
//              
//
//  Copyright (c) Microsoft Corporation 1997
//
// THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF 
// ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO 
// THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A 
// PARTICULAR PURPOSE.
//****************************************************************************

#ifndef _CL_UTIL_H_
#define _CL_UTIL_H_


// Reference Count
class RefCount
{
private:
   LONG m_cRef;

public:
   RefCount();
   // Virtual destructor defers to destructor of derived class.
   virtual ~RefCount();

   // IUnknown methods

   ULONG STDMETHODCALLTYPE AddRef(void);
   ULONG STDMETHODCALLTYPE Release(void);
};



//////////////////////
// Notification Sink
class CNotify
{
private:
    DWORD  m_dwCookie;
	IUnknown * m_pUnk;
    IConnectionPoint           * m_pcnp;
    IConnectionPointContainer  * m_pcnpcnt;
public:
    CNotify(void);
    ~CNotify();

    HRESULT Connect(IUnknown *pUnk, REFIID riid, IUnknown *pUnkN);
    HRESULT Disconnect(void);

    IUnknown * GetPunk() {return m_pUnk;}
};


///////////
// OBLIST

#define POSITION COBNODE*

struct COBNODE
{
	POSITION	pNext;
	void*		pItem;
};

class COBLIST
{
protected:
	POSITION m_pHead;
	POSITION m_pTail;
	int      m_cItem;
    virtual BOOL Compare(void* pItemToCompare, void* pComparator) 
                       { return(pItemToCompare == pComparator); }
public:
	COBLIST() : m_pHead(NULL), m_pTail(NULL), m_cItem(0) { }
    virtual         ~COBLIST();
	
	virtual void *  RemoveAt(POSITION rPos);
    void            EmptyList();
	POSITION	    AddTail(void* pItem);
	void *		    GetNext(POSITION& rPos);
    void *          SafeGetFromPosition(POSITION rPos);
    POSITION        GetPosition(void* pItem);
    POSITION        Lookup(void* pComparator);
	POSITION	    GetHeadPosition()  { return (m_pHead); }
	POSITION	    GetTailPosition()  { return (m_pTail); }
	BOOL		    IsEmpty()          { return (!m_pHead); }
	int             GetItemCount()     { return (m_cItem); }
#ifdef DEBUG
	void *		    GetHead();
	void *		    GetTail();
	void *		    RemoveHead();
	void *	        RemoveTail();
	void *		    GetFromPosition(POSITION rPos);
#else
	void *		    GetHead()          { return GetFromPosition(GetHeadPosition());}
	void *          GetTail()          { return m_pTail->pItem;}
	void *		    RemoveHead()       { return RemoveAt(m_pHead); }
	void *	        RemoveTail()       { return RemoveAt(m_pTail); }
	void *		    GetFromPosition(POSITION rPos){return(rPos->pItem);}
#endif
};

// Utility Functions
POSITION AddNode(PVOID pv, COBLIST ** ppList);
PVOID RemoveNode(POSITION * pPos, COBLIST *pList);



////////////
// BSTRING

class BSTRING
{
private:
	BSTR   m_bstr;

public:
	// Constructors
	BSTRING() {m_bstr = NULL;}

	inline BSTRING(LPCWSTR lpcwString);

#if !defined(UNICODE)
	// We don't support construction from an ANSI string in the Unicode build.
	BSTRING(LPCSTR lpcString);
#endif // !defined(UNICODE)

	// Destructor
	inline ~BSTRING();

	// Cast to BSTR
	operator BSTR() {return m_bstr;}
	inline LPBSTR GetLPBSTR(void);
};


BSTRING::BSTRING(LPCWSTR lpcwString)
{
	if (NULL != lpcwString)
	{
		m_bstr = SysAllocString(lpcwString);
		//ASSERT(NULL != m_bstr);
	}
	else
	{
		m_bstr = NULL;
	}
}

BSTRING::~BSTRING()
{
	if (NULL != m_bstr)
	{
		SysFreeString(m_bstr);
	}
}

inline LPBSTR BSTRING::GetLPBSTR(void)
{
	//ASSERT(NULL == m_bstr);

	return &m_bstr;
}

class BTSTR
{
private:
	LPTSTR m_psz;

public:
	BTSTR(BSTR bstr);
	~BTSTR();

	// Cast to BSTR
	operator LPTSTR() {return (NULL == m_psz) ? TEXT("<null>") : m_psz;}
};

LPTSTR PszFromBstr(BSTR bst);


HRESULT BSTR_to_LPTSTR(LPTSTR *ppsz, BSTR bstr);

HRESULT NmAdvise(IUnknown* pUnkCP, IUnknown* pUnk, const IID& iid, LPDWORD pdw);
HRESULT NmUnadvise(IUnknown* pUnkCP, const IID& iid, DWORD dw);


#endif  // _CL_UTIL_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\remdsk\rds\samples\server\dbg.cpp ===
#include "precomp.h"
#pragma hdrstop

#ifdef DEBUG /*** THIS WHOLE FILE ***/

unsigned long g_BreakAlloc = (unsigned long)-1;

/*  U P D A T E  C R T  D B G  S E T T I N G S  */
/*-------------------------------------------------------------------------
    %%Function: UpdateCrtDbgSettings

    Update the C runtime debug memory settings
-------------------------------------------------------------------------*/
VOID UpdateCrtDbgSettings(void)
{
#if 0
	// This depends on the use of the debug c runtime library
	int tmpFlag = _CrtSetDbgFlag(_CRTDBG_REPORT_FLAG);

	// Always enable memory leak checking debug spew
	// tmpFlag |= _CRTDBG_LEAK_CHECK_DF;

	// Release memory just like the retail version
	tmpFlag &= ~_CRTDBG_DELAY_FREE_MEM_DF;

	// Don't bother checking the entire heap
	tmpFlag &= ~_CRTDBG_CHECK_ALWAYS_DF;
	
	_CrtSetDbgFlag(tmpFlag);
#endif // 0
}

#if 0
int _cdecl MyAllocHook ( int allocType, void *userData,
			size_t size, int blockType,
			long requestNumber, const char *filename, int lineNumber )
{
	char buf[256];
	wsprintf(buf, "%s {%d}: %d bytes on line %d file %s\n\r",
					allocType == _HOOK_ALLOC ? "ALLOC" :
					( allocType == _HOOK_REALLOC ? "REALLOC" : "FREE" ),
					requestNumber,
					size, lineNumber, filename );
	OutputDebugString(buf);
	return TRUE;
}
#endif // 0 

/*  I N I T  D E B U G  M E M O R Y  O P T I O N S  */
/*-------------------------------------------------------------------------
    %%Function: InitDebugMemoryOptions

    Initilize the runtime memory
-------------------------------------------------------------------------*/
BOOL InitDebugMemoryOptions(void)
{
#if 0
	// _asm int 3; chance to set _crtBreakAlloc - use debugger or uncomment
	_CrtSetBreakAlloc(g_BreakAlloc);

	UpdateCrtDbgSettings();

	_CrtSetReportMode(_CRT_ERROR, _CRTDBG_MODE_WNDW); // create a message box on errors

	{	//  To track down memory leaks, set cAlloc to the allocation number
		LONG cAlloc = 0; // Allocation number
		if (0 != cAlloc)
			_CrtSetBreakAlloc(cAlloc);
	}

	#ifdef MNMSRVC_SETALLOCHOOK
	_CrtSetAllocHook ( MyAllocHook );
	#endif // MNMSRVC_SETALLOCHOOK
#endif // 0
	return TRUE;
}

VOID DumpMemoryLeaksAndBreak(void)
{
#if 0
	if ( _CrtDumpMemoryLeaks() )
	{
		// _asm int 3; Uncomment to break after leak spew
	}
#endif // 0
}

#endif /* DEBUG - whole file */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\remdsk\rds\samples\rdcert\precomp.h ===
#include <windows.h>
#include <windowsx.h>
#include <stdio.h>
#include <stdlib.h>

#include <lmcons.h>
#include <nmmkcert.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\remdsk\rds\samples\client\resource.h ===
#define IDD_CLIENTUI            10
#define IDC_ADDRESS             10
#define IDC_CALL                11
#define IDC_HANGUP              12
#define IDC_SECURITY            13
#define IDC_PRIVATESEND         14
#define IDC_PRIVATERECV         15
#define IDC_SENDBUTTON          16
#define IDC_ROSTER              17

#define IDS_CONFERENCE_TITLE    100
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\remdsk\rds\samples\rdcert\rdcert.cpp ===
//
// RDCERT.CPP
// Created 4/19/2000 MadanA
//
// Sample program that install the remote desktop certificate.
//      - no argment installs the certificate
//      - /C clears the remote desktop certificate from store.
//      - /? display this message.
//

#include "precomp.h"

//
// Main entry point
//
void
__cdecl
main(
    int argc,
    char **argv
    )
{
    BOOL bCleanup = FALSE;
    DWORD dwError = ERROR_SUCCESS;

    CHAR achUserName[UNLEN + 1];
    CHAR achComputerName[MAX_COMPUTERNAME_LENGTH + 1];

    LPSTR szUserName = NULL;
    LPSTR szDomainName = NULL;
    LPSTR szComputerName = NULL;

    DWORD dwNameLen;

    //
    // parse command line parameters.
    //

    if ( argc > 1 ) {

        if( argc > 2 ) {

            //
            // we expect only one paramter.
            //

            goto Usage;
        }

        if( argv[1][0] != '/') {

            //
            // option should start with /
            //

            goto Usage;
        }

        switch ( argv[1][1] ) {
            case 'c':
            case 'C':
                bCleanup = TRUE;
                break;

            case '?':
            default:
                goto Usage;
        }
    }

    if( bCleanup ) {
        NmMakeCertCleanup( NULL, NULL, NULL, 0);
        goto Cleanup;
    }

    dwNameLen = sizeof(achUserName);
    if( GetUserNameA((LPSTR)achUserName, &dwNameLen) ) {
        szUserName = (LPSTR)achUserName;
    }
    else {
        printf("GetUserNameA failed, %d.\n", GetLastError());
    }

    dwNameLen = sizeof(achComputerName);
    if( GetComputerNameA((LPSTR)achComputerName, &dwNameLen) ) {
        szComputerName = (LPSTR)achComputerName;
    }
    else {
        printf("GetComputerNameA failed, %d.\n", GetLastError());
    }


    dwError =
        NmMakeCert(
            szUserName,
            szDomainName,
            szComputerName,
            NULL,
            NULL,
            0 );

    if( dwError != 1 ) {
        printf("NmMakeCert failed, %d.\n", dwError);
        goto Cleanup;

    }

    dwError = ERROR_SUCCESS;
    goto Cleanup;

Usage:

    printf("\n");
    printf("rdcert [/c]\n");
    printf("\n");
    printf("Install/Uninstall Remote Desktop Certificate.\n");
    printf("\t noargument - Install Remote Desktop Certificate.\n");
    printf("\t /c - Uninstall already installed Remote Desktop Certificate.\n");
    printf("\t /? - print this information.");
    printf("\n");

Cleanup:

    if( dwError == ERROR_SUCCESS ) {
        printf("The command completed successfully.\n");
    }
    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\remdsk\rds\samples\server\resource.h ===
#define IDD_SERVERUI            10
#define IDC_ACTIVATE            10
#define IDC_DEACTIVATE          11
#define IDC_ROSTER              12
#define IDC_UNATTENDED          13
#define IDC_SECURITY            14
#define IDC_LOADAS              15
#define IDC_UNLOADAS            16
#define IDC_PRIVATESEND         17
#define IDC_PRIVATERECV         18
#define IDC_SENDBUTTON          19

#define IDS_ACTIVATE            100
#define IDS_DEACTIVATE          101
#define IDS_CONFERENCE_TITLE    102
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\remdsk\rds\samples\server\precomp.h ===
#ifdef DEBUG
#define _CRTDBG_MAP_ALLOC
#endif

#include <windows.h>
#include <windowsx.h>
#include <stdio.h> 
#include <stdlib.h> 
#include <shellapi.h>
#include <process.h> 
#include <tchar.h> 
#include <stock.h>

#define MULTI_LEVEL_ZONES
#include <mlzdbg.h>
#include <memtrack.h>
#include <strutil.h>
#include <cstring.hpp>
#include <ias.h>

#include "imsconf3.h"
#include "resource.h"
#include "clutil.h"
#include "server.h"

#include "objidl.h"
#include "oleidl.h"
#include "ocidl.h"
#include "oaidl.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\remdsk\rds\samples\server\clutil.cpp ===
//****************************************************************************
//  Module:     NMCHAT.EXE
//  File:       CLUTIL.CPP
//  Content:    
//              
//
//  Copyright (c) Microsoft Corporation 1997
//
// THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF 
// ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO 
// THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A 
// PARTICULAR PURPOSE.
//****************************************************************************

#include "precomp.h"


///////////////////////////////////////////////////////////////////////////
// RefCount

/*  R E F  C O U N T  */
/*-------------------------------------------------------------------------
    %%Function: RefCount
    
-------------------------------------------------------------------------*/
RefCount::RefCount(void)
{
	m_cRef = 1;
}


RefCount::~RefCount(void)
{
}


ULONG STDMETHODCALLTYPE RefCount::AddRef(void)
{
   ASSERT(m_cRef >= 0);

   InterlockedIncrement(&m_cRef);

   return (ULONG) m_cRef;
}


ULONG STDMETHODCALLTYPE RefCount::Release(void)
{
	if (0 == InterlockedDecrement(&m_cRef))
	{
		delete this;
		return 0;
	}

	ASSERT(m_cRef > 0);
	return (ULONG) m_cRef;
}



///////////////////////////////////////////////////////////////////////////
// CNotify

/*  C  N O T I F Y  */
/*-------------------------------------------------------------------------
    %%Function: CNotify
    
-------------------------------------------------------------------------*/
CNotify::CNotify() :
	m_pcnpcnt(NULL),
    m_pcnp(NULL),
    m_dwCookie(0),
    m_pUnk(NULL)
{
}

CNotify::~CNotify()
{
	Disconnect(); // Make sure we're disconnected
}


/*  C O N N E C T  */
/*-------------------------------------------------------------------------
    %%Function: Connect

-------------------------------------------------------------------------*/
HRESULT CNotify::Connect(IUnknown *pUnk, REFIID riid, IUnknown *pUnkN)
{
	HRESULT hr;

	ASSERT(0 == m_dwCookie);

	// Get the connection container
	hr = pUnk->QueryInterface(IID_IConnectionPointContainer, (void **)&m_pcnpcnt);
	if (SUCCEEDED(hr))
	{
		// Find an appropriate connection point
		hr = m_pcnpcnt->FindConnectionPoint(riid, &m_pcnp);
		if (SUCCEEDED(hr))
		{
			ASSERT(NULL != m_pcnp);
			// Connect the sink object
			hr = m_pcnp->Advise((IUnknown *)pUnkN, &m_dwCookie);
		}
	}

	if (FAILED(hr))
	{
		ERROR_OUT(("MNMSRVC: CNotify::Connect failed: %x", hr));
		m_dwCookie = 0;
	}
	else
	{
    	m_pUnk = pUnk; // keep around for caller
    }

	return hr;
}



/*  D I S C O N N E C T  */
/*-------------------------------------------------------------------------
    %%Function: Disconnect
    
-------------------------------------------------------------------------*/
HRESULT CNotify::Disconnect (void)
{
    if (0 != m_dwCookie)
    {
        // Disconnect the sink object
        m_pcnp->Unadvise(m_dwCookie);
        m_dwCookie = 0;

        m_pcnp->Release();
        m_pcnp = NULL;

        m_pcnpcnt->Release();
        m_pcnpcnt = NULL;

        m_pUnk = NULL;
    }

    return S_OK;
}



///////////////////////////////////////////////////////////////////////////
// COBLIST


COBLIST::~COBLIST()
{
    ASSERT(IsEmpty());
}


#ifdef DEBUG
VOID* COBLIST::GetHead()
{
	ASSERT(m_pHead);

	return m_pHead->pItem;
}
   
VOID* COBLIST::GetTail()
{
	ASSERT(m_pTail);

	return m_pTail->pItem;
}
#endif /* DEBUG */

VOID* COBLIST::GetNext(POSITION& rPos)
{
	ASSERT(rPos);
	
	VOID* pReturn = rPos->pItem;
	rPos = rPos->pNext;

	return pReturn;
}

VOID* COBLIST::RemoveAt(POSITION Pos)
{
	VOID* pReturn = NULL;

	if (m_pHead)
	{
		if (m_pHead == Pos)
		{
			// Removing the first element in the list
			
			m_pHead = Pos->pNext;
			pReturn = Pos->pItem;
			delete Pos;
			m_cItem--;
			ASSERT(0 <= m_cItem);

			if (NULL == m_pHead)
			{
				// Removing the only element!
				m_pTail = NULL;
			}
		}
		else
		{
			POSITION pCur = m_pHead;

			while (pCur && pCur->pNext)
			{
				if (pCur->pNext == Pos)
				{
					// Removing 
					
					pCur->pNext = Pos->pNext;
					if (m_pTail == Pos)
					{
						m_pTail = pCur;
					}
					pReturn = Pos->pItem;
					delete Pos;

					m_cItem--;
					ASSERT(0 <= m_cItem);
				}

				pCur = pCur->pNext;
			}
		}
	}

	return pReturn;
}

POSITION COBLIST::AddTail(VOID* pItem)
{
	POSITION posRet = NULL;

	if (m_pTail)
	{
		if (m_pTail->pNext = new COBNODE)
		{
			m_pTail = m_pTail->pNext;
			m_pTail->pItem = pItem;
			m_pTail->pNext = NULL;
			m_cItem++;
		}
	}
	else
	{
		ASSERT(!m_pHead);
		if (m_pHead = new COBNODE)
		{
			m_pTail = m_pHead;
			m_pTail->pItem = pItem;
			m_pTail->pNext = NULL;
			m_cItem++;
		}
	}

	return m_pTail;
}

void COBLIST::EmptyList()
{
    while (!IsEmpty()) {
        RemoveAt(GetHeadPosition());
    }
}


#ifdef DEBUG
VOID* COBLIST::RemoveTail()
{
	ASSERT(m_pHead);
	ASSERT(m_pTail);
	
	return RemoveAt(m_pTail);
}

VOID* COBLIST::RemoveHead()
{
	ASSERT(m_pHead);
	ASSERT(m_pTail);
	
	return RemoveAt(m_pHead);
}

void * COBLIST::GetFromPosition(POSITION Pos)
{
    void * Result = SafeGetFromPosition(Pos);
	ASSERT(Result);
	return Result;
}
#endif /* DEBUG */

POSITION COBLIST::GetPosition(void* _pItem)
{
    POSITION    Position = m_pHead;

    while (Position) {
        if (Position->pItem == _pItem) {
            break;
        }
		GetNext(Position);
    }
    return Position;
}

POSITION COBLIST::Lookup(void* pComparator)
{
    POSITION    Position = m_pHead;

    while (Position) {
        if (Compare(Position->pItem, pComparator)) {
            break;
        }
		GetNext(Position);
    }
    return Position;
}

void * COBLIST::SafeGetFromPosition(POSITION Pos)
{
	// Safe way to validate that an entry is still in the list,
	// which ensures bugs that would reference deleted memory,
	// reference a NULL pointer instead
	// (e.g. an event handler fires late/twice).
	// Note that versioning on entries would provide an additional 
	// safeguard against re-use of a position.
	// Walk	list to find entry.

	POSITION PosWork = m_pHead;
	
	while (PosWork) {
		if (PosWork == Pos) {
			return Pos->pItem;
		}
		GetNext(PosWork);
	}
	return NULL;
}

/////////////////////////////
// COBLIST Utility routines

/*  A D D  N O D E  */
/*-------------------------------------------------------------------------
    %%Function: AddNode

    Add a node to a list.
    Initializes the ObList, if necessary.
    Returns the position in the list or NULL if there was a problem.
-------------------------------------------------------------------------*/
POSITION AddNode(PVOID pv, COBLIST ** ppList)
{
	ASSERT(NULL != ppList);
	if (NULL == *ppList)
	{
		*ppList = new COBLIST();
		if (NULL == *ppList)
			return NULL;
	}

	return (*ppList)->AddTail(pv);
}


/*  R E M O V E  N O D E  */
/*-------------------------------------------------------------------------
    %%Function: RemoveNode

    Remove a node from a list.
    Sets pPos to NULL
-------------------------------------------------------------------------*/
PVOID RemoveNode(POSITION * pPos, COBLIST *pList)
{
	if ((NULL == pList) || (NULL == pPos))
		return NULL;

	PVOID pv = pList->RemoveAt(*pPos);
	*pPos = NULL;
	return pv;
}


////////////////////////////////////////////////////////////////////////////
// BSTRING

// We don't support construction from an ANSI string in the Unicode build.
#if !defined(UNICODE)

BSTRING::BSTRING(LPCSTR lpcString)
{
	m_bstr = NULL;

	// Compute the length of the required BSTR, including the null
	int cWC =  MultiByteToWideChar(CP_ACP, 0, lpcString, -1, NULL, 0);
	if (cWC <= 0)
		return;

	// Allocate the BSTR, including the null
	m_bstr = SysAllocStringLen(NULL, cWC - 1); // SysAllocStringLen adds another 1

	ASSERT(NULL != m_bstr);
	if (NULL == m_bstr)
	{
		return;
	}

	// Copy the string
	MultiByteToWideChar(CP_ACP, 0, lpcString, -1, (LPWSTR) m_bstr, cWC);

	// Verify that the string is null terminated
	ASSERT(0 == m_bstr[cWC - 1]);
}

#endif // !defined(UNICODE)


///////////////////////////
// BTSTR

BTSTR::BTSTR(BSTR bstr)
{
	m_psz = PszFromBstr(bstr);
}

BTSTR::~BTSTR()
{
	if (NULL != m_psz)
		LocalFree(m_psz);
}

LPTSTR PszFromBstr(BSTR bstr)
{
	if (NULL == bstr)
		return NULL;
	int cch =  WideCharToMultiByte(CP_ACP, 0, (LPWSTR)bstr, -1, NULL, 0, NULL, NULL);
	if (cch <= 0)
		return NULL;

	LPTSTR psz = (LPTSTR)LocalAlloc(LMEM_FIXED, sizeof(TCHAR) * (cch+1) );
	if (NULL == psz)
		return NULL;

	WideCharToMultiByte(CP_ACP, 0, (LPWSTR)bstr, -1, psz, cch+1, NULL, NULL);
	return psz;
}


/*  B  S  T  R _ T O _  L  P  T  S  T  R  */
/*-------------------------------------------------------------------------
    %%Function: BSTR_to_LPTSTR
    
-------------------------------------------------------------------------*/
HRESULT BSTR_to_LPTSTR(LPTSTR *ppsz, BSTR bstr)
{
#ifndef UNICODE
	// compute the length of the required BSTR
	int cch =  WideCharToMultiByte(CP_ACP, 0, (LPWSTR)bstr, -1, NULL, 0, NULL, NULL);
	if (cch <= 0)
	{
		ERROR_OUT(("WideCharToMultiByte failed"));
		return E_FAIL;
	}

	// cch is the number of BYTES required, including the null terminator
	*ppsz = (LPTSTR) new char[cch];
	if (*ppsz == NULL)
	{
		ERROR_OUT(("WideCharToMultiByte out of memory"));
		return E_OUTOFMEMORY;
	}

	WideCharToMultiByte(CP_ACP, 0, (LPWSTR)bstr, -1, *ppsz, cch, NULL, NULL);
	return S_OK;
#else
	return E_NOTIMPL;
#endif // UNICODE
}

/////////////////////////////////////////////////////////////////////////////
// Connection Point Helpers

HRESULT NmAdvise(IUnknown* pUnkCP, IUnknown* pUnk, const IID& iid, LPDWORD pdw)
{
	IConnectionPointContainer *pCPC;
	IConnectionPoint *pCP;
	HRESULT hRes = pUnkCP->QueryInterface(IID_IConnectionPointContainer, (void**)&pCPC);
	if (SUCCEEDED(hRes))
	{
		hRes = pCPC->FindConnectionPoint(iid, &pCP);
		pCPC->Release();
	}
	if (SUCCEEDED(hRes))
	{
		hRes = pCP->Advise(pUnk, pdw);
		pCP->Release();
	}
	return hRes;
}

HRESULT NmUnadvise(IUnknown* pUnkCP, const IID& iid, DWORD dw)
{
	IConnectionPointContainer *pCPC;
	IConnectionPoint *pCP;
	HRESULT hRes = pUnkCP->QueryInterface(IID_IConnectionPointContainer, (void**)&pCPC);
	if (SUCCEEDED(hRes))
	{
		hRes = pCPC->FindConnectionPoint(iid, &pCP);
		pCPC->Release();
	}
	if (SUCCEEDED(hRes))
	{
		hRes = pCP->Unadvise(dw);
		pCP->Release();
	}
	return hRes;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\remdsk\rds\samples\service\dbg.cpp ===
#include "precomp.h"
#pragma hdrstop

#ifdef DEBUG /*** THIS WHOLE FILE ***/

unsigned long g_BreakAlloc = (unsigned long)-1;

/*  U P D A T E  C R T  D B G  S E T T I N G S  */
/*-------------------------------------------------------------------------
    %%Function: UpdateCrtDbgSettings

    Update the C runtime debug memory settings
-------------------------------------------------------------------------*/
VOID UpdateCrtDbgSettings(void)
{
#if 0
	// This depends on the use of the debug c runtime library
	int tmpFlag = _CrtSetDbgFlag(_CRTDBG_REPORT_FLAG);

	// Always enable memory leak checking debug spew
	// tmpFlag |= _CRTDBG_LEAK_CHECK_DF;

	// Release memory just like the retail version
	tmpFlag &= ~_CRTDBG_DELAY_FREE_MEM_DF;

	// Don't bother checking the entire heap
	tmpFlag &= ~_CRTDBG_CHECK_ALWAYS_DF;
	
	_CrtSetDbgFlag(tmpFlag);
#endif // 0
}

#if 0
int _cdecl MyAllocHook ( int allocType, void *userData,
			size_t size, int blockType,
			long requestNumber, const char *filename, int lineNumber )
{
	char buf[256];
	wsprintf(buf, "%s {%d}: %d bytes on line %d file %s\n\r",
					allocType == _HOOK_ALLOC ? "ALLOC" :
					( allocType == _HOOK_REALLOC ? "REALLOC" : "FREE" ),
					requestNumber,
					size, lineNumber, filename );
	OutputDebugString(buf);
	return TRUE;
}
#endif // 0 

/*  I N I T  D E B U G  M E M O R Y  O P T I O N S  */
/*-------------------------------------------------------------------------
    %%Function: InitDebugMemoryOptions

    Initilize the runtime memory
-------------------------------------------------------------------------*/
BOOL InitDebugMemoryOptions(void)
{
#if 0
	// _asm int 3; chance to set _crtBreakAlloc - use debugger or uncomment
	_CrtSetBreakAlloc(g_BreakAlloc);

	UpdateCrtDbgSettings();

	_CrtSetReportMode(_CRT_ERROR, _CRTDBG_MODE_WNDW); // create a message box on errors

	{	//  To track down memory leaks, set cAlloc to the allocation number
		LONG cAlloc = 0; // Allocation number
		if (0 != cAlloc)
			_CrtSetBreakAlloc(cAlloc);
	}

	#ifdef MNMSRVC_SETALLOCHOOK
	_CrtSetAllocHook ( MyAllocHook );
	#endif // MNMSRVC_SETALLOCHOOK
#endif // 0
	return TRUE;
}

VOID DumpMemoryLeaksAndBreak(void)
{
#if 0
	if ( _CrtDumpMemoryLeaks() )
	{
		// _asm int 3; Uncomment to break after leak spew
	}
#endif // 0
}

#endif /* DEBUG - whole file */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\remdsk\rds\samples\server\server.h ===
//
// SERVER.H
//


BOOL InitServer(void);
void TermServer(void);
BOOL CALLBACK ServerDlgProc(HWND, UINT, WPARAM, LPARAM);
BOOL ActivateServer(void);
void DeactivateServer(void);
BOOL ActivatePrivateChannel(void);
void DeactivatePrivateChannel(void);
void SendPrivateData(void);

class CMgrNotify :  public RefCount,
                    public CNotify,
                    public INmManagerNotify,
                    public IAppSharingNotify
{
public:
	CMgrNotify();
	~CMgrNotify();

        // IUnknown methods
	STDMETHODIMP_(ULONG) AddRef(void);
	STDMETHODIMP_(ULONG) Release(void);
	STDMETHODIMP QueryInterface(REFIID riid, PVOID *ppvObj);

 	// ICNotify methods
	STDMETHODIMP Connect (IUnknown *pUnk);
	STDMETHODIMP Disconnect(void);

	// INmManagerNotify
	STDMETHODIMP NmUI(CONFN confn);
	STDMETHODIMP ConferenceCreated(INmConference *pConference);
	STDMETHODIMP CallCreated(INmCall *pNmCall);

    // IAppSharingNotify
    STDMETHODIMP OnReadyToShare(BOOL fReady);
    STDMETHODIMP OnShareStarted();
    STDMETHODIMP OnSharingStarted();
    STDMETHODIMP OnShareEnded();
    STDMETHODIMP OnPersonJoined(IAS_GCC_ID gccID);
    STDMETHODIMP OnPersonLeft(IAS_GCC_ID gccID);
    STDMETHODIMP OnStartInControl(IAS_GCC_ID gccInControlOf);
    STDMETHODIMP OnStopInControl(IAS_GCC_ID gccInControlOf);
    STDMETHODIMP OnControllable(BOOL fControllable);
    STDMETHODIMP OnStartControlled(IAS_GCC_ID gccControlledBy);
    STDMETHODIMP OnStopControlled(IAS_GCC_ID gccControlledBy);
};



class CConfNotify : public RefCount,
                    public CNotify,
                    public INmConferenceNotify
{
public:
	CConfNotify();
	~CConfNotify();

	// IUnknown methods
	STDMETHODIMP_(ULONG) AddRef(void);
    STDMETHODIMP_(ULONG) Release(void);
	STDMETHODIMP QueryInterface(REFIID riid, PVOID *ppvObj);

	// ICNotify methods
	STDMETHODIMP Connect (IUnknown *pUnk);
	STDMETHODIMP Disconnect(void);

	// INmConferenceNotify
	STDMETHODIMP NmUI(CONFN uNotify);
	STDMETHODIMP StateChanged(NM_CONFERENCE_STATE uState);
	STDMETHODIMP MemberChanged(NM_MEMBER_NOTIFY uNotify, INmMember *pfMember);

};



class CCallNotify : public INmCallNotify
{
private:
	INmCall * m_pCall;
	BOOL      m_fIncoming;
	LPTSTR    m_pszName;
	NM_CALL_STATE m_State;
	BOOL      m_fSelectedConference;

	POSITION  m_pos;           // position in g_pCallList
	DWORD     m_dwTick;        // tick count at call start
	ULONG     m_cRef;
	DWORD     m_dwCookie;

public:
	CCallNotify(INmCall * pCall);
	~CCallNotify();

	// IUnknown methods
	STDMETHODIMP_(ULONG) AddRef(void);
	STDMETHODIMP_(ULONG) Release(void);
	STDMETHODIMP QueryInterface(REFIID riid, PVOID *ppv);

	// INmCallNotify methods
	STDMETHODIMP NmUI(CONFN uNotify);
	STDMETHODIMP StateChanged(NM_CALL_STATE uState);
	STDMETHODIMP Failed(ULONG uError);
	STDMETHODIMP Accepted(INmConference *pConference);
	STDMETHODIMP CallError(UINT cns);
	STDMETHODIMP RemoteConference(BOOL fMCU, BSTR *pwszConfNames, BSTR *pbstrConfToJoin);
	STDMETHODIMP RemotePassword(BSTR bstrConference, BSTR *pbstrPassword, BYTE *pb, DWORD cb);

	// Internal methods
	VOID    Update(void);
	VOID	RemoveCall(void);
};


class CNmDataNotify : public RefCount,
                    public CNotify,
                    public INmChannelDataNotify
{
public:
	// IUnknown methods
	STDMETHODIMP_(ULONG) AddRef(void);
    STDMETHODIMP_(ULONG) Release(void);
	STDMETHODIMP QueryInterface(REFIID riid, PVOID *ppvObj);

	// ICNotify methods
	STDMETHODIMP Connect (IUnknown *pUnk);
	STDMETHODIMP Disconnect(void);

	// INmChannelDataNotify
	STDMETHODIMP NmUI(CONFN uNotify);
	STDMETHODIMP MemberChanged(NM_MEMBER_NOTIFY uNotify, INmMember *pfMember);
    STDMETHODIMP DataSent(INmMember * pMember, ULONG uSize, LPBYTE pvBuffer);
    STDMETHODIMP DataReceived(INmMember * pMember, ULONG uSize, LPBYTE pvBuffer,
        ULONG dwFlags);
    STDMETHODIMP AllocateHandleConfirm(ULONG handle_value, ULONG chandles);
};




extern HINSTANCE        g_hInst;
extern HWND             g_hwndMain;
extern INmManager *     g_pMgr;
extern INmConference *  g_pConf;
extern IAppSharing *    g_pAS;
extern BOOL             g_fUnattended;
extern BOOL             g_fSecurity;
extern CMgrNotify *     g_pMgrNotify;
extern CConfNotify *    g_pConfNotify;
extern UINT             g_cPeopleInConf;
extern UINT             g_cPeopleInShare;
extern INmChannelData * g_pPrivateChannel;
extern CNmDataNotify *  g_pDataNotify;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\remdsk\rds\samples\server\server.cpp ===
#include "precomp.h"

#include <initguid.h>
#include <service.h>
#include <nmmkcert.h>

//
// SERVER.CPP
// Created 4/19/2000 LauraBu
//
// Sample server-side app for remote desktop sharing
//      - Holds a conference (secure)
//      - Shares the desktop out when somebody calls in
//      - Gives control of the shared desktop to the remote
//
// Depending on options turned on/off in the dialog we
//      - automatically accepts new callers into the call
//                OR
//        prompts user to accept
//      - automatically gives control of the shared desktop to the
//        caller
//                OR
//        waits for caller to request control
//


// Globals
HINSTANCE           g_hInst;
HWND                g_hwndMain;
INmManager *        g_pMgr;
INmConference *     g_pConf;
IAppSharing *       g_pAS;
BOOL                g_fUnattended;
BOOL                g_fSecurity;
CMgrNotify *        g_pMgrNotify;
CConfNotify *       g_pConfNotify;
UINT                g_cPeopleInConf;
UINT                g_cPeopleInShare;
INmChannelData *    g_pPrivateChannel;
CNmDataNotify *     g_pDataNotify;


#ifdef DEBUG
enum
{
    ZONE_CORE   = BASE_ZONE_INDEX,
};

#define MLZ_FILE_ZONE   ZONE_CORE

static PTCHAR c_apszDbgZones[] =
{
    TEXT("Server"),
    DEFAULT_ZONES
    TEXT("Core"),
};
#endif // DEBUG

//
// Main entry point
//
void __cdecl main(int argc, char **argv)
{
    MSG msg;

#ifdef _DEBUG
    MLZ_DbgInit((PSTR *)&c_apszDbgZones[0],
        (sizeof(c_apszDbgZones) / sizeof(c_apszDbgZones[0])) - 1);
#endif

    g_hInst = ::GetModuleHandle(NULL);

    if (!InitServer())
    {
        goto Cleanup;
    }

    // Main message loop
    while (GetMessage(&msg, NULL, 0, 0))
    {
        if (!g_hwndMain || !IsDialogMessage(g_hwndMain, &msg))
        {
            TranslateMessage(&msg);
            DispatchMessage(&msg);
        }
    }

Cleanup:
    TermServer();

#ifdef DEBUG
    MLZ_DbgDeInit();
#endif // DEBUG

    ExitProcess(0);
}



//
// InitServer()
//
// Create the demo modeless dialog and initialize T.120 etc.
//
BOOL InitServer(void)
{
    CoInitialize(NULL);

    if (CreateDialogParam(g_hInst, MAKEINTRESOURCE(IDD_SERVERUI),
        NULL, ServerDlgProc, 0) == NULL)
    {
        ERROR_OUT(("CreateDialog of IDD_SERVERUI failed"));
        return FALSE;
    }

    ShowWindow(g_hwndMain, SW_SHOW);
    UpdateWindow(g_hwndMain);

    return TRUE;
}


//
// TermServer()
//
// Destroy the font demo modeless dialog and shutdown
//
void TermServer(void)
{
    DeactivateServer();

    if (g_hwndMain)
    {
        DestroyWindow(g_hwndMain);
        g_hwndMain = NULL;
    }

    CoUninitialize();
}


//
// ActivateServer()
//
BOOL ActivateServer(void)
{
    HRESULT         hr;
    HCERTSTORE      hStore;
    PCCERT_CONTEXT  pCertContext = NULL;

    //
    // Initialize the calling/conf stuff
    //

    //
    // Get NmManager object from RDCALL
    //
    hr = CreateNmManager(&g_pMgr);
    if (FAILED(hr))
    {
        ERROR_OUT(("CreateNmManager failed with error 0x%08x", hr));
        return FALSE;
    }


    //
    // Register our notification objects with NmManager so we can
    //      find out about calls and people in the conference
    //
    g_pMgrNotify = new CMgrNotify();
    if (!g_pMgrNotify)
    {
        ERROR_OUT(("new CMgrNotify() failed"));
        return FALSE;
    }

    hr = g_pMgrNotify->Connect(g_pMgr);
    if (FAILED(hr))
    {
        ERROR_OUT(("Connect to INmManager failed with error 0x%08x", hr));
        return FALSE;
    }

    //
    // Set up our credentials
    //

    //
    // SALEM BUGBUG
    // Currently am using the NetMeeting certificate.  You will want to
    // provide your own cert/credentials for real.
    //

    // Open the NetMeeting user certificate store.
    hStore = CertOpenStore(CERT_STORE_PROV_SYSTEM,
        X509_ASN_ENCODING, 0, CERT_SYSTEM_STORE_CURRENT_USER,
        WSZNMSTORE);

    if ( NULL != hStore )
    {
        // Check the store for any certificate
        pCertContext = CertFindCertificateInStore(hStore,
            X509_ASN_ENCODING, 0, CERT_FIND_ANY, NULL, NULL);

        CertCloseStore( hStore, 0);
    }

    if ( NULL == pCertContext )
    {
        WARNING_OUT(("No server context cert found!"));
    }


    //
    // Initialize calling with our name, properties, credentials
    //
    TCHAR szComputerName[MAX_PATH+1];
    DWORD dwComputerNameLength = sizeof(szComputerName) / sizeof(szComputerName[0]);

    if (!GetComputerName(szComputerName, &dwComputerNameLength))
    {
        ERROR_OUT(("GetComputerName failed"));
        lstrcpy(szComputerName, "<UNKNOWN>");
    }

    hr = g_pMgr->Initialize(BSTRING(szComputerName), (DWORD_PTR)pCertContext,
        DEFAULT_LISTEN_PORT, NMMANAGER_SERVER);

    if (pCertContext)
    {
        CertFreeCertificateContext(pCertContext);
    }

    if (FAILED(hr))
    {
        ERROR_OUT(("INmManager Initialize failed with error 0x%08x", hr));
        return FALSE;
    }

    //
    // Create and hold a conference
    //
    TCHAR szConfName[MAX_PATH];
    ::LoadString(g_hInst, IDS_CONFERENCE_TITLE, szConfName, CCHMAX(szConfName));
    BSTRING bstrConfName(szConfName);

    hr = g_pMgr->CreateConference(&g_pConf, bstrConfName, NULL, g_fSecurity);
    if (FAILED(hr))
    {
        ERROR_OUT(("CreateConference failed with error 0x%08x", hr));
        return FALSE;
    }

    ASSERT(g_pConf);

    // Connect to the conference object
    ASSERT(NULL == g_pConfNotify);
    g_pConfNotify = new CConfNotify();
    if (NULL == g_pConfNotify)
    {
        ERROR_OUT(("failed to new CConfNotify"));
        hr = E_OUTOFMEMORY;
    }
    else
    {
        hr = g_pConfNotify->Connect(g_pConf);
        if (FAILED(hr))
        {
            ERROR_OUT(("Failed to connect to g_pConfNotify"));
            g_pConfNotify->Release();
            g_pConfNotify = NULL;
        }
    }

    hr = g_pConf->Host();
    if (FAILED(hr))
    {
        ERROR_OUT(("Host conference failed with error 0x%08x", hr));
        return FALSE;
    }

    return TRUE;
}



//
// DeactivateServer()
//
void DeactivateServer(void)
{
    //
    // Release the AppSharing interface
    //
    if (g_pAS)
    {
        g_pAS->AllowControl(FALSE);
        g_pAS->UnshareDesktop();
        g_pAS->Release();
        g_pAS = NULL;
        g_cPeopleInShare = 0;
    }

    //
    // Release our private data channel
    //
    DeactivatePrivateChannel();

    //
    // Leave the conference
    //
    if (g_pConf)
    {
        g_pConf->Leave();
        if (g_hwndMain)
        {
            ::SendDlgItemMessage(g_hwndMain, IDC_ROSTER, LB_RESETCONTENT, 0, 0);
        }
    }

    //
    // Disconnect from the conference if there is one currently,
    //  to stop getting notifications
    //
    if (g_pConfNotify)
    {
        g_pConfNotify->Disconnect();
        g_pConfNotify->Release();
        g_pConfNotify = NULL;
    }

    //
    // Release the NmConference interface
    //
    if (g_pConf)
    {
        g_pConf->Release();
        g_pConf = NULL;
    }
    g_cPeopleInConf = 0;

    //
    // Sleep for a second so T.120 cn clean up
    //
    Sleep(1000);

    //
    // Disconnect from NmManager to stop getting notifications
    //
    if (g_pMgrNotify)
    {
        g_pMgrNotify->Disconnect();
        g_pMgrNotify->Release();
        g_pMgrNotify = NULL;
    }

    //
    // Let go of the NmManager interface.  We need to sleep a bit first
    // though.
    //
    if (g_pMgr)
    {
        g_pMgr->Release();
        g_pMgr = NULL;
    }
}



//
// ActivatePrivateChannel()
//
BOOL ActivatePrivateChannel(void)
{
    HRESULT hr;

    ASSERT(g_pConf);

    hr = g_pConf->CreateDataChannel(&g_pPrivateChannel,
        GUID_SAMPLEDATA);
    if (!SUCCEEDED(hr))
    {
        ERROR_OUT(("CreateDataChannel failed with error 0x%08x", hr));
        return FALSE;
    }

    g_pDataNotify = new CNmDataNotify();
    if (!g_pDataNotify)
    {
        ERROR_OUT(("new CNmDataNotify failed"));
        return FALSE;
    }

    hr = g_pDataNotify->Connect(g_pPrivateChannel);
    if (FAILED(hr))
    {
        ERROR_OUT(("Connect to g_pPrivateChannel failed with error 0x%08x", hr));
        return FALSE;
    }

    return S_OK;
}

//
// DeactivatePrivateChannel()
//
void DeactivatePrivateChannel(void)
{
    if (g_pDataNotify)
    {
        g_pDataNotify->Disconnect();
        g_pDataNotify->Release();
        g_pDataNotify = NULL;
    }

    if (g_pPrivateChannel)
    {
        g_pPrivateChannel->Release();
        g_pPrivateChannel = NULL;
    }
}


//
// ServerDlgProc()
//
// Server demo modeless dialog handler
//
BOOL CALLBACK ServerDlgProc
(
    HWND    hwnd,
    UINT    uMsg,
    WPARAM  wParam,
    LPARAM  lParam
)
{
    BOOL    rc = TRUE;

    switch (uMsg)
    {
        case WM_INITDIALOG:
        {
            g_hwndMain = hwnd;
            break;
        }

        case WM_CLOSE:
        {
            DestroyWindow(hwnd);
            break;
        }

        case WM_DESTROY:
        {
            g_hwndMain = NULL;
            PostQuitMessage(0);
            break;
        }

        case WM_COMMAND:
        {
            switch (GET_WM_COMMAND_ID(wParam, lParam))
            {
                case IDC_ACTIVATE:
                {
                    if (ActivateServer())
                    {
                        TCHAR   szText[MAX_PATH];

                        ::SetWindowLong(GetDlgItem(hwnd, IDC_ACTIVATE), GWL_ID, IDC_DEACTIVATE);

                        // Change the button to deactivate
                        ::CheckDlgButton(hwnd, IDC_DEACTIVATE, TRUE);
                        ::LoadString(g_hInst, IDS_DEACTIVATE, szText, CCHMAX(szText));
                        ::SetDlgItemText(hwnd, IDC_DEACTIVATE, szText);
                    }
                    else
                    {
                        DeactivateServer();
                    }
                    break;
                }

                case IDC_DEACTIVATE:
                {
                    TCHAR   szText[MAX_PATH];

                    DeactivateServer();

                    ::SetWindowLong(GetDlgItem(hwnd, IDC_DEACTIVATE), GWL_ID, IDC_ACTIVATE);

                    // Change the button to activate
                    ::CheckDlgButton(hwnd, IDC_ACTIVATE, FALSE);
                    ::LoadString(g_hInst, IDS_ACTIVATE, szText, CCHMAX(szText));
                    ::SetDlgItemText(hwnd, IDC_ACTIVATE, szText);

                    break;
                }

                case IDC_UNATTENDED:
                {
                    g_fUnattended = ::IsDlgButtonChecked(hwnd, IDC_UNATTENDED);
                    break;
                }

                case IDC_SECURITY:
                {
                    g_fSecurity = ::IsDlgButtonChecked(hwnd, IDC_SECURITY);
                    break;
                }

                case IDC_LOADAS:
                {
                    HRESULT hr;

                    ASSERT(!g_pAS);

                    hr = CreateASObject(g_pMgrNotify, (g_fUnattended ?
                        AS_UNATTENDED : 0), &g_pAS);
                    if (FAILED(hr))
                    {
                        ERROR_OUT(("CreateASObject failed"));
                    }
                    break;
                }

                case IDC_UNLOADAS:
                {
                    if (g_pAS)
                    {
                        g_pAS->AllowControl(FALSE);
                        g_pAS->UnshareDesktop();
                        g_pAS->Release();
                        g_pAS = NULL;
                        g_cPeopleInShare = 0;
                    }
                    break;
                }

                case IDC_SENDBUTTON:
                {
                    SendPrivateData();
                    break;
                }

                default:
                    break;
            }
            break;
        }

        default:
        {
            rc = FALSE;
            break;
        }
    }

    return rc;
}


CMgrNotify::CMgrNotify() : RefCount(), CNotify()
{
    TRACE_OUT(("CMgrNotify created"));
}

CMgrNotify::~CMgrNotify()
{
    TRACE_OUT(("CMgrNotify destroyed"));
}


///////////////////////////
//  CMgrNotify:IUnknown

ULONG STDMETHODCALLTYPE CMgrNotify::AddRef(void)
{
    return RefCount::AddRef();
}


ULONG STDMETHODCALLTYPE CMgrNotify::Release(void)
{
    return RefCount::Release();
}

HRESULT STDMETHODCALLTYPE CMgrNotify::QueryInterface(REFIID riid, PVOID *ppvObject)
{
    HRESULT hr = S_OK;

    TRACE_OUT(("CMgrNotify QI'd"));

    if (riid == IID_IUnknown || riid == IID_INmManagerNotify)
    {
        *ppvObject = (INmManagerNotify *)this;
    }
    else
    {
        hr = E_NOINTERFACE;
        *ppvObject = NULL;
    }

    if (S_OK == hr)
    {
        AddRef();
    }

    return hr;
}



////////////////////////////
//  CMgrNotify:ICNotify

HRESULT STDMETHODCALLTYPE CMgrNotify::Connect(IUnknown *pUnk)
{
    TRACE_OUT(("CMgrNotify::Connect"));
    return CNotify::Connect(pUnk, IID_INmManagerNotify, (INmManagerNotify *)this);
}

HRESULT STDMETHODCALLTYPE CMgrNotify::Disconnect(void)
{
    TRACE_OUT(("CMgrNotify::Disconnect"));
    return CNotify::Disconnect();
}



//////////////////////////////////
//  CMgrNotify:INmManagerNotify

HRESULT STDMETHODCALLTYPE CMgrNotify::NmUI(CONFN confn)
{
    TRACE_OUT(("CMgrNotify::NmUI"));
    return S_OK;
}

HRESULT STDMETHODCALLTYPE CMgrNotify::CallCreated(INmCall *pNmCall)
{
    new CCallNotify(pNmCall);

    TRACE_OUT(("CMgrNotify::CallCreated"));
    return S_OK;
}



HRESULT STDMETHODCALLTYPE CMgrNotify::ConferenceCreated(INmConference *pConference)
{
    g_cPeopleInConf = 0;
    g_cPeopleInShare = 0;

    ASSERT(pConference);
    pConference->AddRef();

    return S_OK;
}

// CMgrNotify::IAppSharingNotify
HRESULT STDMETHODCALLTYPE CMgrNotify::OnReadyToShare(BOOL fReady)
{
    HRESULT hr = S_OK;

    TRACE_OUT(("CMgrNotify::OnReadyToShare"));

    if (g_pAS)
    {
        //
        // Share out the desktop
        //
        hr = g_pAS->ShareDesktop();
        if (FAILED(hr))
        {
            ERROR_OUT(("OnReadyToShare: sharing desktop failed: %x",hr));
        }
    }

    return hr;
}

HRESULT STDMETHODCALLTYPE CMgrNotify::OnShareStarted()
{
    TRACE_OUT(("CMgrNotify::OnShareStarted"));
    return S_OK;
}

HRESULT STDMETHODCALLTYPE CMgrNotify::OnSharingStarted()
{
    HRESULT hr = S_OK;

    TRACE_OUT(("CMgrNotify::OnSharingStarted"));

    if (g_pAS)
    {
        //
        // Allow control
        //
        hr = g_pAS->AllowControl ( TRUE );
        if (FAILED(hr))
        {
            ERROR_OUT(("OnSharingStarted: allowing control failed: %x",hr));
        }
    }

    return hr;
}

HRESULT STDMETHODCALLTYPE CMgrNotify::OnShareEnded()
{
    TRACE_OUT(("CMgrNotify::OnShareEnded"));
    return S_OK;
}

HRESULT STDMETHODCALLTYPE CMgrNotify::OnPersonJoined(IAS_GCC_ID gccID)
{
    TRACE_OUT(("CMgrNotify::OnPersonJoined"));

    ASSERT(g_pAS);
    ASSERT(g_cPeopleInShare >= 0);
    g_cPeopleInShare++;

    if ((g_cPeopleInShare == 2) && g_fUnattended)
    {
        HRESULT hr;

        //
        // Once we are no longer alone in the share, invite the remote party to
        // take control of us.
        //
        ASSERT(g_pAS);

        //
        // Give control to the remote party
        //
        hr = g_pAS->GiveControl(gccID);
        if (FAILED(hr))
        {
            ERROR_OUT(("OnPersonJoined: GiveControl to %d failed: %x",
                gccID, hr));
        }
    }

    return S_OK;
}

HRESULT STDMETHODCALLTYPE CMgrNotify::OnPersonLeft(IAS_GCC_ID gccID)
{
    TRACE_OUT(("CMgrNotify::OnPersonLeft"));

    ASSERT(g_pAS);

    g_cPeopleInShare--;
    ASSERT(g_cPeopleInShare >= 0);

    return S_OK;
}

HRESULT STDMETHODCALLTYPE CMgrNotify::OnStartInControl(IAS_GCC_ID gccID)
{
    TRACE_OUT(("CMgrNotify::OnStartInControl"));
    return S_OK;
}

HRESULT STDMETHODCALLTYPE CMgrNotify::OnStopInControl(IAS_GCC_ID gccID)
{
    TRACE_OUT(("CMgrNotify::OnStopInControl"));
    return S_OK;
}



HRESULT STDMETHODCALLTYPE CMgrNotify::OnControllable(BOOL fControllable)
{
    TRACE_OUT(("CMgrNotify::OnControllable"));
    return S_OK;
}

HRESULT STDMETHODCALLTYPE CMgrNotify::OnStartControlled(IAS_GCC_ID gccID)
{
    TRACE_OUT(("CMgrNotify::OnStartControlled"));
    return S_OK;
}

HRESULT STDMETHODCALLTYPE CMgrNotify::OnStopControlled(IAS_GCC_ID gccID)
{
    TRACE_OUT(("CMgrNotify::OnStopControlled"));
    return S_OK;
}



//////////////////////////////////////////////////////////////////////////
//  C  C N F  N O T I F Y

CConfNotify::CConfNotify() : RefCount(), CNotify()
{
    TRACE_OUT(("CConfNotify created"));
}

CConfNotify::~CConfNotify()
{
    TRACE_OUT(("CConfNotify destroyed"));
}


///////////////////////////
//  CConfNotify:IUknown

ULONG STDMETHODCALLTYPE CConfNotify::AddRef(void)
{
    TRACE_OUT(("CConfNotify::AddRef"));
    return RefCount::AddRef();
}


ULONG STDMETHODCALLTYPE CConfNotify::Release(void)
{
    TRACE_OUT(("CConfNotify::Release"));
    return RefCount::Release();
}


HRESULT STDMETHODCALLTYPE CConfNotify::QueryInterface(REFIID riid, PVOID *ppvObject)
{
    HRESULT hr = S_OK;

    TRACE_OUT(("CConfNotify::QueryInterface"));

    if (riid == IID_IUnknown)
    {
        TRACE_OUT(("CConfNotify::QueryInterface IID_IUnknown"));
        *ppvObject = (IUnknown *)this;
    }
    else if (riid == IID_INmConferenceNotify)
    {
        TRACE_OUT(("CConfNotify::QueryInterface IID_INmConferenceNotify"));
        *ppvObject = (INmConferenceNotify *)this;
    }
    else
    {
        WARNING_OUT(("CConfNotify::QueryInterface bogus"));
        hr = E_NOINTERFACE;
        *ppvObject = NULL;
    }

    if (S_OK == hr)
    {
        AddRef();
    }

    return hr;
}



////////////////////////////
//  CConfNotify:ICNotify

HRESULT STDMETHODCALLTYPE CConfNotify::Connect(IUnknown *pUnk)
{
    TRACE_OUT(("CConfNotify::Connect"));
    return CNotify::Connect(pUnk,IID_INmConferenceNotify,(IUnknown *)this);
}

HRESULT STDMETHODCALLTYPE CConfNotify::Disconnect(void)
{
    TRACE_OUT(("CConfNotify::Disconnect"));
    return CNotify::Disconnect();
}


//////////////////////////////////
//  CConfNotify:IConfNotify

HRESULT STDMETHODCALLTYPE CConfNotify::NmUI(CONFN uNotify)
{
    TRACE_OUT(("CConfNotify::NmUI"));
    TRACE_OUT(("NmUI called."));
    return S_OK;
}

HRESULT STDMETHODCALLTYPE CConfNotify::StateChanged(NM_CONFERENCE_STATE uState)
{
    TRACE_OUT(("CConfNotify::StateChanged"));

    if (NULL == g_pConf)
        return S_OK; // weird

    switch (uState)
    {
    case NM_CONFERENCE_ACTIVE:
        break;

    case NM_CONFERENCE_INITIALIZING:
        break; // can't do anything just yet

    case NM_CONFERENCE_WAITING:
        break;

    case NM_CONFERENCE_IDLE:
        break;
    }

    return S_OK;
}


HRESULT STDMETHODCALLTYPE CConfNotify::MemberChanged(NM_MEMBER_NOTIFY uNotify, INmMember *pMember)
{
    HRESULT hr;

    switch (uNotify)
    {
        case NM_MEMBER_ADDED:
        {
            TRACE_OUT(("CConfNotify::MemberChanged() Member added"));

            ASSERT( g_cPeopleInConf >= 0 );
            g_cPeopleInConf++;

            //
            // Add to our roster
            //
            ULONG   id = 0;
            BSTR    bstrName;

            pMember->GetID(&id);

            hr = pMember->GetName(&bstrName);
            if (FAILED(hr))
            {
                ERROR_OUT(("GetName of member failed"));
            }
            else
            {
                CSTRING string(bstrName);
                TCHAR   szName[MAX_PATH];

                wsprintf(szName, "%s - %d", (LPCSTR)string, id);

                ::SendDlgItemMessage(g_hwndMain, IDC_ROSTER, LB_ADDSTRING,
                    (WPARAM)-1, (LPARAM)szName);

                SysFreeString(bstrName);
            }

            //
            // Once we are no longer alone in the conference, share the desktop
            // and allow control:
            //

            if (1 == g_cPeopleInConf)
            {
                ActivatePrivateChannel();
            }
            else if (2 == g_cPeopleInConf)
            {
                TRACE_OUT(("%d parties in conf, Sharing the desktop",
                    g_cPeopleInConf));

                PostMessage(g_hwndMain, WM_COMMAND, IDC_LOADAS, 0);
            }
            break;
        }

        case NM_MEMBER_REMOVED:
        {
            TRACE_OUT(("CConfNotify::MemberChanged() Member removed"));
            g_cPeopleInConf--;
            ASSERT( g_cPeopleInConf >= 0 );

            if (0 == g_cPeopleInConf)
            {
                DeactivatePrivateChannel();
            }
            else if (1 == g_cPeopleInConf)
            {
                TRACE_OUT(("%d parties in conf, Unsharing the desktop",
                    g_cPeopleInConf));

                //
                // Release app sharing
                //
                PostMessage(g_hwndMain, WM_COMMAND, IDC_UNLOADAS, 0);
            }

            //
            // Remove from our roster
            //
            ULONG   id = 0;
            BSTR    bstrName;

            pMember->GetID(&id);

            hr = pMember->GetName(&bstrName);
            if (FAILED(hr))
            {
                ERROR_OUT(("GetName of member failed"));
            }
            else
            {
                CSTRING string(bstrName);
                TCHAR   szName[MAX_PATH];
                int     iItem;

                wsprintf(szName, "%s - %d", (LPCSTR)string, id);

                iItem = ::SendDlgItemMessage(g_hwndMain, IDC_ROSTER,
                    LB_FINDSTRING, 0, (LPARAM)szName);
                if (iItem != -1)
                {
                    ::SendDlgItemMessage(g_hwndMain, IDC_ROSTER, LB_DELETESTRING,
                        iItem, 0);
                }

                SysFreeString(bstrName);
            }

            break;
        }

        case NM_MEMBER_UPDATED:
        {
            TRACE_OUT(("CConfNotify::MemberChanged() Member updated"));
            break;
        }

        default:
            break;
    }

    return hr;
}



CCallNotify::CCallNotify(INmCall * pNmCall) :
        m_pCall  (pNmCall),
        m_pszName  (NULL),
        m_fSelectedConference (FALSE),
        m_pos      (NULL),
        m_cRef     (1),
        m_dwCookie (0)
{
        HRESULT hr;

        TRACE_OUT(("CCallNotify: Created %08X (INmCall=%08X)", this, pNmCall));

        ASSERT(NULL != m_pCall);
        m_pCall->AddRef();

        // Get the display name
        BSTR  bstr;
        hr = m_pCall->GetAddress(&bstr);
        if (SUCCEEDED(hr))
        {
                hr = BSTR_to_LPTSTR(&m_pszName, bstr);
                SysFreeString(bstr);
        }
        if (FEmptySz(m_pszName))
        {
                // Default to "another person" if no name available in the call data
                m_pszName = TEXT("Somebody");
        }

        // These should never change
        m_fIncoming = (m_pCall->IsIncoming() == S_OK);
        m_dwTick = ::GetTickCount();

        Update();

        NmAdvise(m_pCall, this, IID_INmCallNotify, &m_dwCookie);
}

VOID CCallNotify::RemoveCall(void)
{
        NmUnadvise(m_pCall, IID_INmCallNotify, m_dwCookie);
}

CCallNotify::~CCallNotify()
{
        delete m_pszName;

        ASSERT(NULL != m_pCall);
        m_pCall->Release();
}

// IUnknown methods
STDMETHODIMP_(ULONG) CCallNotify::AddRef(void)
{
        return ++m_cRef;
}

STDMETHODIMP_(ULONG) CCallNotify::Release(void)
{
        ASSERT(m_cRef > 0);
        if (m_cRef > 0)
        {
                m_cRef--;
        }

        ULONG cRef = m_cRef;

        if (0 == cRef)
        {
                delete this;
        }

        return cRef;
}

STDMETHODIMP CCallNotify::QueryInterface(REFIID riid, PVOID *ppv)
{
        HRESULT hr = S_OK;

        if ((riid == IID_INmCallNotify) || (riid == IID_IUnknown))
        {
                *ppv = (INmCallNotify *)this;
        }
        else
        {
                hr = E_NOINTERFACE;
                *ppv = NULL;
        }

        if (S_OK == hr)
        {
                AddRef();
        }

        return hr;
}

// INmCallNotify methods
STDMETHODIMP CCallNotify::NmUI(CONFN uNotify)
{
        return S_OK;
}

STDMETHODIMP CCallNotify::StateChanged(NM_CALL_STATE uState)
{
        // REVIEW: This check should be done outside of this routine
        if (uState == m_State)
        {
                // Don't bother the UI when nothing changes!
                return S_OK;
        }

        Update();

        return S_OK;
}

STDMETHODIMP CCallNotify::Failed(ULONG uError)
{
        return S_OK;
}

STDMETHODIMP CCallNotify::Accepted(INmConference *pConference)
{
        return S_OK;
}

// INmCallNotify2 methods
STDMETHODIMP CCallNotify::CallError(UINT cns)
{
        return S_OK;
}

STDMETHODIMP CCallNotify::RemoteConference(BOOL fMCU, BSTR *pwszConfNames, BSTR *pbstrConfToJoin)
{
        return S_OK;
}

STDMETHODIMP CCallNotify::RemotePassword(BSTR bstrConference, BSTR *pbstrPassword, BYTE *pb, DWORD cb)
{
        return S_OK;
}

/*  U P D A T E  */
/*-------------------------------------------------------------------------
    %%Function: Update

    Update the cached information about the call
-------------------------------------------------------------------------*/
VOID CCallNotify::Update(void)
{
        m_pCall->GetState(&m_State);
        // TRACE_OUT(("CCall: New State=%0d for call=%08X", m_State, this));

        switch (m_State)
        {
        case NM_CALL_ACCEPTED:
            case NM_CALL_REJECTED:
        case NM_CALL_CANCELED:
        {
                RemoveCall();
                Release();
                    break;
        }

        case NM_CALL_RING:
        {
                m_pCall->Accept();
                break;
        }

        default:
                ERROR_OUT(("CCall::Update: Unknown state %08X", m_State));

        case NM_CALL_INVALID:
            case NM_CALL_INIT:
        case NM_CALL_SEARCH:
            case NM_CALL_WAIT:
                    break;
        }

}


//
// SendPrivateData()
//
void SendPrivateData(void)
{
    LPSTR   szData = NULL;
    UINT    cbData;
    HRESULT hr;

    if (!g_pPrivateChannel)
    {
        ERROR_OUT(("Can't send private data - no channel object"));
        return;
    }

    cbData = ::SendDlgItemMessage(g_hwndMain, IDC_PRIVATESEND,
        WM_GETTEXTLENGTH, 0, 0);

    if (!cbData)
    {
        WARNING_OUT(("SendPrivateData - nothing to send"));
        return;
    }

    cbData++;
    szData = new char[cbData];
    if (!szData)
    {
        ERROR_OUT(("SendPrivateData - unable to allocate buffer"));
        return;
    }

    szData[cbData-1] = 0;
    ::SendDlgItemMessage(g_hwndMain, IDC_PRIVATESEND, WM_GETTEXT,
        cbData, (LPARAM)szData);

    //
    // Now send the data
    //
    hr = g_pPrivateChannel->SendData(NULL, cbData, (LPBYTE)szData,
        DATA_MEDIUM_PRIORITY | DATA_NORMAL_SEND);
    if (FAILED(hr))
    {
        ERROR_OUT(("SendPrivateData - SendData failed"));
    }

    delete szData;
}



//
// CNmDataNotify
//
ULONG STDMETHODCALLTYPE CNmDataNotify::AddRef(void)
{
    TRACE_OUT(("CNmDataNotify::AddRef"));
    return RefCount::AddRef();
}


ULONG STDMETHODCALLTYPE CNmDataNotify::Release(void)
{
    TRACE_OUT(("CNmDataNotify::Release"));
    return RefCount::Release();
}


HRESULT STDMETHODCALLTYPE CNmDataNotify::QueryInterface(REFIID riid, PVOID *ppvObject)
{
    HRESULT hr = S_OK;

    TRACE_OUT(("CNmDataNotify::QueryInterface"));

    if (riid == IID_IUnknown)
    {
        TRACE_OUT(("CNmDataNotify::QueryInterface IID_IUnknown"));
        *ppvObject = (IUnknown *)this;
    }
    else if (riid == IID_INmChannelDataNotify)
    {
        TRACE_OUT(("CNmDataNotify::QueryInterface IID_INmChannelDataNotify"));
        *ppvObject = (INmChannelDataNotify *)this;
    }
    else
    {
        WARNING_OUT(("CNmDataNotify::QueryInterface bogus"));
        hr = E_NOINTERFACE;
        *ppvObject = NULL;
    }

    if (S_OK == hr)
    {
        AddRef();
    }

    return hr;
}



////////////////////////////
//  CNmDataNotify:ICNotify

HRESULT STDMETHODCALLTYPE CNmDataNotify::Connect(IUnknown *pUnk)
{
    TRACE_OUT(("CNmDataNotify::Connect"));
    return CNotify::Connect(pUnk,IID_INmChannelDataNotify,(IUnknown *)this);
}

HRESULT STDMETHODCALLTYPE CNmDataNotify::Disconnect(void)
{
    TRACE_OUT(("CNmDataNotify::Disconnect"));
    return CNotify::Disconnect();
}


HRESULT STDMETHODCALLTYPE CNmDataNotify::NmUI(CONFN uNotify)
{
    TRACE_OUT(("CNmDataNotify::NmUI"));
    return S_OK;
}


HRESULT STDMETHODCALLTYPE CNmDataNotify::MemberChanged(NM_MEMBER_NOTIFY uNotify, INmMember *pMember)
{
    TRACE_OUT(("CNmDataNotify::MemberChanged"));
    return S_OK;
}


HRESULT STDMETHODCALLTYPE CNmDataNotify::DataSent
(
    INmMember *     pMember,
    ULONG           uSize,
    LPBYTE          pvBuffer
)
{
    TRACE_OUT(("CNmDataNotify::DataSent"));
    return S_OK;
}


HRESULT STDMETHODCALLTYPE CNmDataNotify::DataReceived
(
    INmMember *     pMember,
    ULONG           uSize,
    LPBYTE          pvBuffer,
    ULONG           dwFlags
)
{
    HRESULT         hr;

    TRACE_OUT(("CNmDataNotify::DataReceived"));

    //
    // Get the member's name, and add the data + name to the received
    // edit field.
    //
    if (pMember)
    {
        BSTR            bstrName;

        hr = pMember->GetName(&bstrName);
        if (SUCCEEDED(hr))
        {
            UINT            cch;
            char            szName[MAX_PATH];

            cch = SysStringLen(bstrName);
            WideCharToMultiByte(CP_ACP, 0, bstrName, -1, szName, cch+1, NULL, NULL);
            SysFreeString(bstrName);

            lstrcat(szName, ":  ");

            ::SendDlgItemMessage(g_hwndMain, IDC_PRIVATERECV, EM_REPLACESEL,
                    FALSE, (LPARAM)szName);
        }
    }

    //
    // Add data to the end of the edit field
    //
    ::SendDlgItemMessage(g_hwndMain, IDC_PRIVATERECV, EM_REPLACESEL,
        FALSE, (LPARAM)pvBuffer);

    //
    // Add carriage return to end of edit field
    //
    ::SendDlgItemMessage(g_hwndMain, IDC_PRIVATERECV, EM_REPLACESEL,
        FALSE, (LPARAM)"\r\n");

    return S_OK;
}


HRESULT STDMETHODCALLTYPE CNmDataNotify::AllocateHandleConfirm
(
    ULONG           handle_value,
    ULONG           chandles
)
{
    TRACE_OUT(("CNmDataNotify::AllocateHandleConfirm"));
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\remdsk\rds\samples\service\clutil.cpp ===
//****************************************************************************
//  Module:     NMCHAT.EXE
//  File:       CLUTIL.CPP
//  Content:    
//              
//
//  Copyright (c) Microsoft Corporation 1997
//
// THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF 
// ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO 
// THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A 
// PARTICULAR PURPOSE.
//****************************************************************************

#include "precomp.h"


///////////////////////////////////////////////////////////////////////////
// RefCount

/*  R E F  C O U N T  */
/*-------------------------------------------------------------------------
    %%Function: RefCount
    
-------------------------------------------------------------------------*/
RefCount::RefCount(void)
{
	m_cRef = 1;
}


RefCount::~RefCount(void)
{
}


ULONG STDMETHODCALLTYPE RefCount::AddRef(void)
{
   ASSERT(m_cRef >= 0);

   InterlockedIncrement(&m_cRef);

   return (ULONG) m_cRef;
}


ULONG STDMETHODCALLTYPE RefCount::Release(void)
{
	if (0 == InterlockedDecrement(&m_cRef))
	{
		delete this;
		return 0;
	}

	ASSERT(m_cRef > 0);
	return (ULONG) m_cRef;
}



///////////////////////////////////////////////////////////////////////////
// CNotify

/*  C  N O T I F Y  */
/*-------------------------------------------------------------------------
    %%Function: CNotify
    
-------------------------------------------------------------------------*/
CNotify::CNotify() :
	m_pcnpcnt(NULL),
    m_pcnp(NULL),
    m_dwCookie(0),
    m_pUnk(NULL)
{
}

CNotify::~CNotify()
{
	Disconnect(); // Make sure we're disconnected
}


/*  C O N N E C T  */
/*-------------------------------------------------------------------------
    %%Function: Connect

-------------------------------------------------------------------------*/
HRESULT CNotify::Connect(IUnknown *pUnk, REFIID riid, IUnknown *pUnkN)
{
	HRESULT hr;

	ASSERT(0 == m_dwCookie);

	// Get the connection container
	hr = pUnk->QueryInterface(IID_IConnectionPointContainer, (void **)&m_pcnpcnt);
	if (SUCCEEDED(hr))
	{
		// Find an appropriate connection point
		hr = m_pcnpcnt->FindConnectionPoint(riid, &m_pcnp);
		if (SUCCEEDED(hr))
		{
			ASSERT(NULL != m_pcnp);
			// Connect the sink object
			hr = m_pcnp->Advise((IUnknown *)pUnkN, &m_dwCookie);
		}
	}

	if (FAILED(hr))
	{
		ERROR_OUT(("MNMSRVC: CNotify::Connect failed: %x", hr));
		m_dwCookie = 0;
	}
	else
	{
    	m_pUnk = pUnk; // keep around for caller
    }

	return hr;
}



/*  D I S C O N N E C T  */
/*-------------------------------------------------------------------------
    %%Function: Disconnect
    
-------------------------------------------------------------------------*/
HRESULT CNotify::Disconnect (void)
{
    if (0 != m_dwCookie)
    {
        // Disconnect the sink object
        m_pcnp->Unadvise(m_dwCookie);
        m_dwCookie = 0;

        m_pcnp->Release();
        m_pcnp = NULL;

        m_pcnpcnt->Release();
        m_pcnpcnt = NULL;

        m_pUnk = NULL;
    }

    return S_OK;
}



///////////////////////////////////////////////////////////////////////////
// COBLIST


COBLIST::~COBLIST()
{
    ASSERT(IsEmpty());
}


#ifdef DEBUG
VOID* COBLIST::GetHead()
{
	ASSERT(m_pHead);

	return m_pHead->pItem;
}
   
VOID* COBLIST::GetTail()
{
	ASSERT(m_pTail);

	return m_pTail->pItem;
}
#endif /* DEBUG */

VOID* COBLIST::GetNext(POSITION& rPos)
{
	ASSERT(rPos);
	
	VOID* pReturn = rPos->pItem;
	rPos = rPos->pNext;

	return pReturn;
}

VOID* COBLIST::RemoveAt(POSITION Pos)
{
	VOID* pReturn = NULL;

	if (m_pHead)
	{
		if (m_pHead == Pos)
		{
			// Removing the first element in the list
			
			m_pHead = Pos->pNext;
			pReturn = Pos->pItem;
			delete Pos;
			m_cItem--;
			ASSERT(0 <= m_cItem);

			if (NULL == m_pHead)
			{
				// Removing the only element!
				m_pTail = NULL;
			}
		}
		else
		{
			POSITION pCur = m_pHead;

			while (pCur && pCur->pNext)
			{
				if (pCur->pNext == Pos)
				{
					// Removing 
					
					pCur->pNext = Pos->pNext;
					if (m_pTail == Pos)
					{
						m_pTail = pCur;
					}
					pReturn = Pos->pItem;
					delete Pos;

					m_cItem--;
					ASSERT(0 <= m_cItem);
				}

				pCur = pCur->pNext;
			}
		}
	}

	return pReturn;
}

POSITION COBLIST::AddTail(VOID* pItem)
{
	POSITION posRet = NULL;

	if (m_pTail)
	{
		if (m_pTail->pNext = new COBNODE)
		{
			m_pTail = m_pTail->pNext;
			m_pTail->pItem = pItem;
			m_pTail->pNext = NULL;
			m_cItem++;
		}
	}
	else
	{
		ASSERT(!m_pHead);
		if (m_pHead = new COBNODE)
		{
			m_pTail = m_pHead;
			m_pTail->pItem = pItem;
			m_pTail->pNext = NULL;
			m_cItem++;
		}
	}

	return m_pTail;
}

void COBLIST::EmptyList()
{
    while (!IsEmpty()) {
        RemoveAt(GetHeadPosition());
    }
}


#ifdef DEBUG
VOID* COBLIST::RemoveTail()
{
	ASSERT(m_pHead);
	ASSERT(m_pTail);
	
	return RemoveAt(m_pTail);
}

VOID* COBLIST::RemoveHead()
{
	ASSERT(m_pHead);
	ASSERT(m_pTail);
	
	return RemoveAt(m_pHead);
}

void * COBLIST::GetFromPosition(POSITION Pos)
{
    void * Result = SafeGetFromPosition(Pos);
	ASSERT(Result);
	return Result;
}
#endif /* DEBUG */

POSITION COBLIST::GetPosition(void* _pItem)
{
    POSITION    Position = m_pHead;

    while (Position) {
        if (Position->pItem == _pItem) {
            break;
        }
		GetNext(Position);
    }
    return Position;
}

POSITION COBLIST::Lookup(void* pComparator)
{
    POSITION    Position = m_pHead;

    while (Position) {
        if (Compare(Position->pItem, pComparator)) {
            break;
        }
		GetNext(Position);
    }
    return Position;
}

void * COBLIST::SafeGetFromPosition(POSITION Pos)
{
	// Safe way to validate that an entry is still in the list,
	// which ensures bugs that would reference deleted memory,
	// reference a NULL pointer instead
	// (e.g. an event handler fires late/twice).
	// Note that versioning on entries would provide an additional 
	// safeguard against re-use of a position.
	// Walk	list to find entry.

	POSITION PosWork = m_pHead;
	
	while (PosWork) {
		if (PosWork == Pos) {
			return Pos->pItem;
		}
		GetNext(PosWork);
	}
	return NULL;
}

/////////////////////////////
// COBLIST Utility routines

/*  A D D  N O D E  */
/*-------------------------------------------------------------------------
    %%Function: AddNode

    Add a node to a list.
    Initializes the ObList, if necessary.
    Returns the position in the list or NULL if there was a problem.
-------------------------------------------------------------------------*/
POSITION AddNode(PVOID pv, COBLIST ** ppList)
{
	ASSERT(NULL != ppList);
	if (NULL == *ppList)
	{
		*ppList = new COBLIST();
		if (NULL == *ppList)
			return NULL;
	}

	return (*ppList)->AddTail(pv);
}


/*  R E M O V E  N O D E  */
/*-------------------------------------------------------------------------
    %%Function: RemoveNode

    Remove a node from a list.
    Sets pPos to NULL
-------------------------------------------------------------------------*/
PVOID RemoveNode(POSITION * pPos, COBLIST *pList)
{
	if ((NULL == pList) || (NULL == pPos))
		return NULL;

	PVOID pv = pList->RemoveAt(*pPos);
	*pPos = NULL;
	return pv;
}


////////////////////////////////////////////////////////////////////////////
// BSTRING

// We don't support construction from an ANSI string in the Unicode build.
#if !defined(UNICODE)

BSTRING::BSTRING(LPCSTR lpcString)
{
	m_bstr = NULL;

	// Compute the length of the required BSTR, including the null
	int cWC =  MultiByteToWideChar(CP_ACP, 0, lpcString, -1, NULL, 0);
	if (cWC <= 0)
		return;

	// Allocate the BSTR, including the null
	m_bstr = SysAllocStringLen(NULL, cWC - 1); // SysAllocStringLen adds another 1

	ASSERT(NULL != m_bstr);
	if (NULL == m_bstr)
	{
		return;
	}

	// Copy the string
	MultiByteToWideChar(CP_ACP, 0, lpcString, -1, (LPWSTR) m_bstr, cWC);

	// Verify that the string is null terminated
	ASSERT(0 == m_bstr[cWC - 1]);
}

#endif // !defined(UNICODE)


///////////////////////////
// BTSTR

BTSTR::BTSTR(BSTR bstr)
{
	m_psz = PszFromBstr(bstr);
}

BTSTR::~BTSTR()
{
	if (NULL != m_psz)
		LocalFree(m_psz);
}

LPTSTR PszFromBstr(BSTR bstr)
{
	if (NULL == bstr)
		return NULL;
	int cch =  WideCharToMultiByte(CP_ACP, 0, (LPWSTR)bstr, -1, NULL, 0, NULL, NULL);
	if (cch <= 0)
		return NULL;

	LPTSTR psz = (LPTSTR)LocalAlloc(LMEM_FIXED, sizeof(TCHAR) * (cch+1) );
	if (NULL == psz)
		return NULL;

	WideCharToMultiByte(CP_ACP, 0, (LPWSTR)bstr, -1, psz, cch+1, NULL, NULL);
	return psz;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\remdsk\rds\samples\service\cconf.cpp ===
//****************************************************************************
//  File:       CCONF.CPP
//  Content:
//
//
//  Copyright (c) Microsoft Corporation 1997
//
// THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
// ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO
// THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
// PARTICULAR PURPOSE.
//****************************************************************************

#include <precomp.h>
#include "srvccall.h"
#include "cstring.hpp"

#define ZERO_DELAY "0"

const int SERVICE_IN_CALL = 1001;
const int SERVICE_NOT_IN_CALL = 1000;

// Global Variables
INmManager * g_pMgr  = NULL;             // The Conference Manager
CMgrNotify * g_pMgrNotify = NULL;        // Notifications for the Manager
INmConference * g_pConference = NULL;    // The Current Conference
CConfNotify * g_pConferenceNotify =NULL; // Notifications for the Conference
IAppSharing * g_pAS = NULL;             // Interface to AppSharing
int g_cPersonsInConf = 0;
int g_cPersonsInShare = 0;
extern BOOL g_fInShutdown;

CHAR szConfName[64];
static BOOL RunScrSaver(void);

/*  I N I T  C O N F  M G R  */
/*-------------------------------------------------------------------------
    %%Function: InitConfMgr

-------------------------------------------------------------------------*/
HRESULT InitConfMgr(void)
{
    HRESULT hr;

    TRACE_OUT(("InitConfMgr"));

    ASSERT(!g_pMgr);
    hr = CreateNmManager(&g_pMgr);

    if (SUCCEEDED(hr))
    {
        // Connect to the conference manager object
        g_pMgrNotify = new CMgrNotify();

        if (NULL != g_pMgrNotify)
        {
            hr = g_pMgrNotify->Connect(g_pMgr);

            //
            // Now initialize, with the user name, credentials, and
            // port.
            //
            if (SUCCEEDED(hr))
            {
                HCERTSTORE hStore;
                PCCERT_CONTEXT pCertContext = NULL;
                DWORD dwResult = -1;
                TCHAR szComputerName[MAX_COMPUTERNAME_LENGTH+1];
                DWORD dwComputerNameLength = sizeof(szComputerName) / sizeof(szComputerName[0]);


                // Open the "MY" local machine certificate store. This one will be
                // used when we're running as a service
                hStore = CertOpenStore(CERT_STORE_PROV_SYSTEM,
                                        X509_ASN_ENCODING,
                                        0,
                                        CERT_SYSTEM_STORE_LOCAL_MACHINE,
                                        L"MY" );

                if ( NULL != hStore )
                {
#ifdef DUMPCERTS
                    DumpCertStore(this, "Local Machine Store MY", hStore);
#endif // DUMPCERTS

                    // Check the local machine store for a certificate - any!
                    pCertContext = CertFindCertificateInStore(hStore,
                                              X509_ASN_ENCODING,
                                              0,
                                              CERT_FIND_ANY,
                                              NULL,
                                              NULL);

                    CertCloseStore( hStore, 0);
                }

                if ( NULL == pCertContext )
                {
                    // Open the RDS local machine certificate store.
                    hStore = CertOpenStore(CERT_STORE_PROV_SYSTEM,
                                            X509_ASN_ENCODING,
                                            0,
                                            CERT_SYSTEM_STORE_LOCAL_MACHINE,
                                            WSZNMSTORE );
                    if ( NULL != hStore )
                    {
#ifdef DUMPCERTS
                        DumpCertStore(this, "Local Machine Store _RDSTR", hStore);
#endif // DUMPCERTS

                        // Check the local machine store for a certificate - any!
                        pCertContext = CertFindCertificateInStore(hStore,
                                                  X509_ASN_ENCODING,
                                                  0,
                                                  CERT_FIND_ANY,
                                                  NULL,
                                                  NULL);

                        CertCloseStore( hStore, 0);
                    }
                }

                if ( NULL == pCertContext )
                {
                    ERROR_OUT(("No service context cert found!"));
                }


                if ( !GetComputerName( szComputerName, &dwComputerNameLength))
                {
                   lstrcpy(szComputerName,TEXT("?"));
                   ERROR_OUT(("GetComputerName failed"));
                }

                //
                // Do the intialization
                //
                hr = g_pMgr->Initialize(BSTRING(szComputerName),
                    (DWORD_PTR)pCertContext,
                    DEFAULT_LISTEN_PORT,
                    NMMANAGER_SERVICE | NMMANAGER_SERVER);

                if (pCertContext)
                {
                    CertFreeCertificateContext ( pCertContext );
                }

                if (FAILED(hr))
                {
                    ERROR_OUT(("g_pMgr->Initialize failed"));
                }
            }
            else
                ERROR_OUT(("g_pMgrNotify->Connect failed"));
        }
        else
            ERROR_OUT(("new CMgrNotify failed"));
    }

    if (!g_pMgr)
    {
        ERROR_OUT(("Failed to init conference manager"));
        return hr;
    }

    //
    // Init app sharing
    //
    hr = ::CreateASObject(g_pMgrNotify, AS_SERVICE | AS_UNATTENDED, &g_pAS);
    if (FAILED(hr))
    {
        ERROR_OUT(("Failed to start AppSharing"));
        return(hr);
    }

    //
    // Make sure that sharing is enabled
    //

    if ( !g_pAS->IsSharingAvailable() )
    {
        WARNING_OUT(("MNMSRVC: sharing not enabled"));
        return E_FAIL;
    }

    // Create conference
    ASSERT(g_pConference == NULL);

    //
    // Only allow remotes to send files, they can't initiate anything else
    // themselves.
    LoadString(GetModuleHandle(NULL), IDS_MNMSRVC_TITLE,
        szConfName, CCHMAX(szConfName));
        BSTRING bstrConfName(szConfName);

    hr = g_pMgr->CreateConference(&g_pConference, bstrConfName, NULL, TRUE);

    if (FAILED(hr))
    {
        ERROR_OUT(("Conference could not be created"));
        return hr;
    }

    hr = g_pConference->Host();

    if (FAILED(hr))
    {
        ERROR_OUT(("Could not host conference"));
        return hr;
    }

    return hr;
}


/*  F R E E  C O N F  M G R  */
/*-------------------------------------------------------------------------
    %%Function: FreeConfMgr

-------------------------------------------------------------------------*/
VOID FreeConfMgr(void)
{
    DebugEntry(FreeConfMgr);
    // Release conference manager notify
    if (NULL != g_pMgrNotify)
    {
        g_pMgrNotify->Disconnect();

        UINT ref = g_pMgrNotify->Release();
        TRACE_OUT(("g_pMgrNotify after Release: refcount: %d", ref));
        g_pMgrNotify = NULL;
    }

    // Release conference manager
    if (NULL != g_pMgr)
    {
        UINT ref;
        ref = g_pMgr->Release();
        TRACE_OUT(("g_pMgr after Release: refcount: %d", ref));
        g_pMgr = NULL;
    }
    DebugExitVOID(FreeConfMgr);
}


/*  F R E E  C O N F E R E N C E  */
/*-------------------------------------------------------------------------
    %%Function: FreeConference

-------------------------------------------------------------------------*/
VOID FreeConference(void)
{
    DebugEntry(FreeConference);

    if (g_pConference)
    {
        g_pConference->Leave();
    }

    if (NULL != g_pConferenceNotify)
    {
        g_pConferenceNotify->Disconnect();
        g_pConferenceNotify->Release();
        g_pConferenceNotify = NULL;
    }

    if (NULL != g_pConference)
    {
        UINT ref = g_pConference->Release();

        ASSERT(1 == ref); // The confmgr holds last reference

        g_pConference = NULL;
    }
    else
    {
        WARNING_OUT(("FreeConference: no conference???"));
    }

    DebugExitVOID(FreeConference);
}



//////////////////////////////////////////////////////////////////////////
//  C  C N F  M G R  N O T I F Y

CMgrNotify::CMgrNotify() : RefCount(), CNotify()
{
    TRACE_OUT(("CMgrNotify created"));
}

CMgrNotify::~CMgrNotify()
{
    TRACE_OUT(("CMgrNotify destroyed"));
}


///////////////////////////
//  CMgrNotify:IUnknown

ULONG STDMETHODCALLTYPE CMgrNotify::AddRef(void)
{
    return RefCount::AddRef();
}


ULONG STDMETHODCALLTYPE CMgrNotify::Release(void)
{
    return RefCount::Release();
}

HRESULT STDMETHODCALLTYPE CMgrNotify::QueryInterface(REFIID riid, PVOID *ppvObject)
{
    HRESULT hr = S_OK;

    TRACE_OUT(("CMgrNotify QI'd"));

    if (riid == IID_IUnknown || riid == IID_INmManagerNotify)
    {
        *ppvObject = (INmManagerNotify *)this;
    }
    else
    {
        hr = E_NOINTERFACE;
        *ppvObject = NULL;
    }

    if (S_OK == hr)
    {
        AddRef();
    }

    return hr;
}



////////////////////////////
//  CMgrNotify:ICNotify

HRESULT STDMETHODCALLTYPE CMgrNotify::Connect(IUnknown *pUnk)
{
    TRACE_OUT(("CMgrNotify::Connect"));
    return CNotify::Connect(pUnk, IID_INmManagerNotify, (INmManagerNotify *)this);
}

HRESULT STDMETHODCALLTYPE CMgrNotify::Disconnect(void)
{
    TRACE_OUT(("CMgrNotify::Disconnect"));
    return CNotify::Disconnect();
}



//////////////////////////////////
//  CMgrNotify:INmManagerNotify

HRESULT STDMETHODCALLTYPE CMgrNotify::NmUI(CONFN confn)
{
    TRACE_OUT(("CMgrNotify::NmUI"));
    return S_OK;
}

HRESULT STDMETHODCALLTYPE CMgrNotify::CallCreated(INmCall *pNmCall)
{

    new CSrvcCall(pNmCall);

    TRACE_OUT(("CMgrNotify::CallCreated"));
    return S_OK;
}

HRESULT STDMETHODCALLTYPE CMgrNotify::ConferenceCreated(INmConference *pConference)
{
    g_cPersonsInConf = 0;
    g_cPersonsInShare = 0;

    if (NULL == g_pConference)
    {
        TRACE_OUT(("CMgrNotify::ConferenceCreated"));
        HookConference(pConference);
    }
    else
    {
        ERROR_OUT(("Second conference created???"));
    }
    return S_OK;
}

// CMgrNotify::IAppSharingNotify
HRESULT STDMETHODCALLTYPE CMgrNotify::OnReadyToShare(BOOL fReady)
{
    TRACE_OUT(("CMgrNotify::OnReadyToShare"));
    return S_OK;
}

HRESULT STDMETHODCALLTYPE CMgrNotify::OnShareStarted()
{
    TRACE_OUT(("CMgrNotify::OnShareStarted"));
    return S_OK;
}

HRESULT STDMETHODCALLTYPE CMgrNotify::OnSharingStarted()
{
    TRACE_OUT(("CMgrNotify::OnSharingStarted"));
    return S_OK;
}

HRESULT STDMETHODCALLTYPE CMgrNotify::OnShareEnded()
{
    TRACE_OUT(("CMgrNotify::OnShareEnded"));
    return S_OK;
}

HRESULT STDMETHODCALLTYPE CMgrNotify::OnPersonJoined(IAS_GCC_ID gccID)
{
    TRACE_OUT(("CMgrNotify::OnPersonJoined"));

    ASSERT(g_pAS);
    ASSERT(g_cPersonsInShare >= 0);
    g_cPersonsInShare++;

    //
    // Once we are no longer alone in the share, invite the remote party to
    // take control of us.
    //
    if ( 2 == g_cPersonsInShare && g_pAS)
    {
        HRESULT hr;
        TRACE_OUT(("OnPersonJoined: giving control to 2nd dude %d",
            gccID));

        //
        // Give control to the remote party
        //
        hr = g_pAS->GiveControl(gccID);
        if ( S_OK != hr )
        {
            ERROR_OUT(("OnPersonJoined: GiveControl to %d failed: %x",
                gccID, hr));
        }
    }

    return S_OK;
}

HRESULT STDMETHODCALLTYPE CMgrNotify::OnPersonLeft(IAS_GCC_ID gccID)
{
    TRACE_OUT(("CMgrNotify::OnPersonLeft"));

    ASSERT(g_pAS);

    g_cPersonsInShare--;
    ASSERT(g_cPersonsInShare >= 0);

    return S_OK;
}

HRESULT STDMETHODCALLTYPE CMgrNotify::OnStartInControl(IAS_GCC_ID gccID)
{
    TRACE_OUT(("CMgrNotify::OnStartInControl"));
    return S_OK;
}

HRESULT STDMETHODCALLTYPE CMgrNotify::OnStopInControl(IAS_GCC_ID gccID)
{
    TRACE_OUT(("CMgrNotify::OnStopInControl"));
    return S_OK;
}



HRESULT STDMETHODCALLTYPE CMgrNotify::OnControllable(BOOL fControllable)
{
    TRACE_OUT(("CMgrNotify::OnControllable"));
    return S_OK;
}

HRESULT STDMETHODCALLTYPE CMgrNotify::OnStartControlled(IAS_GCC_ID gccID)
{
    TRACE_OUT(("CMgrNotify::OnStartControlled"));
    return S_OK;
}

HRESULT STDMETHODCALLTYPE CMgrNotify::OnStopControlled(IAS_GCC_ID gccID)
{
    TRACE_OUT(("CMgrNotify::OnStopControlled"));
    ::RunScrSaver();
    return S_OK;
}


/*  H O O K  C O N F E R E N C E  */
/*-------------------------------------------------------------------------
    %%Function: HookConference

-------------------------------------------------------------------------*/
HRESULT HookConference(INmConference * pConference)
{
    HRESULT hr;

    DebugEntry(HookConference);

    TRACE_OUT(("HookConference"));
    ASSERT(NULL != pConference);
    ASSERT(NULL == g_pConference);

    TRACE_OUT(("Set g_pConference in HookConference"));
    g_pConference = pConference;

    pConference->AddRef();

    // Connect to the conference object
    ASSERT(NULL == g_pConferenceNotify);
    g_pConferenceNotify = new CConfNotify();
    if (NULL == g_pConferenceNotify)
    {
        ERROR_OUT(("failed to new CConfNotify"));
        hr = E_OUTOFMEMORY;
    }
    else
    {
        hr = g_pConferenceNotify->Connect(pConference);
        if (FAILED(hr))
        {
            ERROR_OUT(("Failed to connect to g_pConferenceNotify"));
            g_pConferenceNotify->Release();
            g_pConferenceNotify = NULL;
        }
    }

    DebugExitHRESULT(HookConference,hr);

    return hr;
}


//////////////////////////////////////////////////////////////////////////
//  C  C N F  N O T I F Y

CConfNotify::CConfNotify() : RefCount(), CNotify()
{
    TRACE_OUT(("CConfNotify created"));
}

CConfNotify::~CConfNotify()
{
    TRACE_OUT(("CConfNotify destroyed"));
}


///////////////////////////
//  CConfNotify:IUknown

ULONG STDMETHODCALLTYPE CConfNotify::AddRef(void)
{
    TRACE_OUT(("CConfNotify::AddRef"));
    return RefCount::AddRef();
}


ULONG STDMETHODCALLTYPE CConfNotify::Release(void)
{
    TRACE_OUT(("CConfNotify::Release"));
    return RefCount::Release();
}

HRESULT STDMETHODCALLTYPE CConfNotify::QueryInterface(REFIID riid, PVOID *ppvObject)
{
    HRESULT hr = S_OK;

    TRACE_OUT(("CConfNotify::QueryInterface"));

    if (riid == IID_IUnknown)
    {
        TRACE_OUT(("CConfNotify::QueryInterface IID_IUnknown"));
        *ppvObject = (IUnknown *)this;
    }
    else if (riid == IID_INmConferenceNotify)
    {
        TRACE_OUT(("CConfNotify::QueryInterface IID_INmConferenceNotify"));
        *ppvObject = (INmConferenceNotify *)this;
    }
    else
    {
        WARNING_OUT(("CConfNotify::QueryInterface bogus"));
        hr = E_NOINTERFACE;
        *ppvObject = NULL;
    }

    if (S_OK == hr)
    {
        AddRef();
    }

    return hr;
}



////////////////////////////
//  CConfNotify:ICNotify

HRESULT STDMETHODCALLTYPE CConfNotify::Connect(IUnknown *pUnk)
{
    TRACE_OUT(("CConfNotify::Connect"));
    return CNotify::Connect(pUnk,IID_INmConferenceNotify,(IUnknown *)this);
}

HRESULT STDMETHODCALLTYPE CConfNotify::Disconnect(void)
{
    TRACE_OUT(("CConfNotify::Disconnect"));

    //
    // Release for Addref in HookConference before CConfNotify::Connect
    //

    if ( g_pConference )
        g_pConference->Release();

    return CNotify::Disconnect();
}


//////////////////////////////////
//  CConfNotify:IConfNotify

HRESULT STDMETHODCALLTYPE CConfNotify::NmUI(CONFN uNotify)
{
    TRACE_OUT(("CConfNotify::NmUI"));
    TRACE_OUT(("NmUI called."));
    return S_OK;
}

HRESULT STDMETHODCALLTYPE CConfNotify::StateChanged(NM_CONFERENCE_STATE uState)
{
    TRACE_OUT(("CConfNotify::StateChanged"));

    if (NULL == g_pConference)
        return S_OK; // weird

    switch (uState)
    {
    case NM_CONFERENCE_ACTIVE:
        if (IS_NT) {
            g_ssStatus.dwControlsAccepted = SERVICE_ACCEPT_STOP | SERVICE_ACCEPT_PAUSE_CONTINUE | SERVICE_ACCEPT_SHUTDOWN;
            SetServiceStatus(g_sshStatusHandle,&g_ssStatus);
        }
        break;

    case NM_CONFERENCE_INITIALIZING:
        break; // can't do anything just yet

    case NM_CONFERENCE_WAITING:
        if (IS_NT) {
            g_ssStatus.dwControlsAccepted = SERVICE_ACCEPT_STOP | SERVICE_ACCEPT_PAUSE_CONTINUE;
            SetServiceStatus(g_sshStatusHandle,&g_ssStatus);
        }
        break;

    case NM_CONFERENCE_IDLE:
        break;
    }

    return S_OK;
}


HRESULT STDMETHODCALLTYPE CConfNotify::MemberChanged(NM_MEMBER_NOTIFY uNotify, INmMember *pMember)
{
    switch (uNotify)
    {
    case NM_MEMBER_ADDED:
    {
        TRACE_OUT(("CConfNotify::MemberChanged() Member added"));

        ASSERT( g_cPersonsInConf >= 0 );

        g_cPersonsInConf++;

        //
        // Once we are no longer alone in the conference, share the desktop
        // and allow control:
        //

        if ( 2 == g_cPersonsInConf && g_pAS )
        {
            HRESULT hr;
            TRACE_OUT(("%d parties in conf, Sharing the desktop",
                g_cPersonsInConf));

            //
            // Share out the desktop
            //
            hr = g_pAS->ShareDesktop();
            if ( S_OK != hr )
            {
                ERROR_OUT(("OnPersonJoined: sharing desktop failed: %x",hr));
            }

            //
            // Allow control
            //
            hr = g_pAS->AllowControl ( TRUE );
            if ( S_OK != hr )
            {
                ERROR_OUT(("OnPersonJoined: allowing control failed: %x",hr));
            }
        }
        break;
    }
    case NM_MEMBER_REMOVED:
    {
        TRACE_OUT(("CConfNotify::MemberChanged() Member removed"));
        g_cPersonsInConf--;
        ASSERT( g_cPersonsInConf >= 0 );

        if ( 1 == g_cPersonsInConf && g_pAS )
        {
            HRESULT hr;
            TRACE_OUT(("%d parties in conf, Unsharing the desktop",
                g_cPersonsInConf));

            //
            // Disallow control
            //
            hr = g_pAS->AllowControl ( FALSE );
            if ( S_OK != hr )
            {
                ERROR_OUT(("Disallowing control failed: %x",hr));
            }

            //
            // Unshare the desktop
            //
            hr = g_pAS->UnshareDesktop();
            if ( S_OK != hr )
            {
                ERROR_OUT(("Unsharing desktop failed: %x",hr));
            }
        }
        break;
    }
    case NM_MEMBER_UPDATED:
    {
        TRACE_OUT(("CConfNotify::MemberChanged() Member updated"));
        break;
    }
    default:
        break;
    }

    return S_OK;
}


BOOL ServiceCtrlHandler(DWORD dwCtrlType)
{
    HRESULT hr = S_OK;

    TRACE_OUT(("ServiceCtrlHandler received %d",dwCtrlType));
    switch (dwCtrlType)
    {
    case CTRL_SHUTDOWN_EVENT:
        if (g_pConference != NULL)
        {
            TRACE_OUT(("Leaving conference in CTRL_SHUTDOWN_EVENT"));
            hr = g_pConference->Leave();

            if (FAILED(hr))
            {
                WARNING_OUT(("Service Ctrl Handler failed to leave"));
            }
        }
        else
        {
            WARNING_OUT(("g_pConference NULL in CTRL_SHUTDOWN_EVENT"));
        }

        break;
    default:
        break;
    }
    return FALSE;
}

static BOOL RunScrSaver(void)
{
    BOOL fIsScrSaverActive = FALSE;
    if (g_fInShutdown)
    {
        return FALSE;
    }
    if (!SystemParametersInfo(SPI_GETSCREENSAVEACTIVE, 0, &fIsScrSaverActive, 0))
    {
        ERROR_OUT(("RunScrSaver: SystemParametersInfo failed"));
        return FALSE;
    }
    if (fIsScrSaverActive)
    {
        RegEntry reWinlogon(IS_NT ? WINNT_WINLOGON_KEY : WIN95_WINLOGON_KEY, HKEY_LOCAL_MACHINE);
        CSTRING strGracePeriod = reWinlogon.GetString(REGVAL_SCREENSAVER_GRACEPERIOD);
        reWinlogon.SetValue(REGVAL_SCREENSAVER_GRACEPERIOD, ZERO_DELAY);
        reWinlogon.FlushKey();
        DefWindowProc(GetDesktopWindow(), WM_SYSCOMMAND, SC_SCREENSAVE, 0);
        if (lstrlen(strGracePeriod))
        {
            int cSeconds = RtStrToInt(strGracePeriod);
            if (cSeconds > 0 && cSeconds <= 20)
            {
                Sleep(1000*cSeconds);
                reWinlogon.SetValue(REGVAL_SCREENSAVER_GRACEPERIOD, strGracePeriod);
                reWinlogon.FlushKey();
                return TRUE;
            }
        }

        Sleep(5000);
        reWinlogon.DeleteValue(REGVAL_SCREENSAVER_GRACEPERIOD);
        reWinlogon.FlushKey();
        return TRUE;
    }
    else {
        return FALSE;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\remdsk\rds\samples\service\clutil.h ===
//****************************************************************************
//  Module:     NMCHAT.EXE
//  File:       CLUTIL.H
//  Content:    
//              
//
//  Copyright (c) Microsoft Corporation 1997
//
// THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF 
// ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO 
// THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A 
// PARTICULAR PURPOSE.
//****************************************************************************

#ifndef _CL_UTIL_H_
#define _CL_UTIL_H_


////////////////////
// Reference Count
class RefCount
{
private:
   LONG m_cRef;

public:
   RefCount();
   // Virtual destructor defers to destructor of derived class.
   virtual ~RefCount();

   // IUnknown methods

   ULONG STDMETHODCALLTYPE AddRef(void);
   ULONG STDMETHODCALLTYPE Release(void);
};



//////////////////////
// Notification Sink
class CNotify
{
private:
    DWORD  m_dwCookie;
	IUnknown * m_pUnk;
    IConnectionPoint           * m_pcnp;
    IConnectionPointContainer  * m_pcnpcnt;
public:
    CNotify(void);
    ~CNotify();

    HRESULT Connect(IUnknown *pUnk, REFIID riid, IUnknown *pUnkN);
    HRESULT Disconnect(void);

    IUnknown * GetPunk() {return m_pUnk;}
};


///////////
// OBLIST

#define POSITION COBNODE*

struct COBNODE
{
	POSITION	pNext;
	void*		pItem;
};

class COBLIST
{
protected:
	POSITION m_pHead;
	POSITION m_pTail;
	int      m_cItem;
    virtual BOOL Compare(void* pItemToCompare, void* pComparator) 
                       { return(pItemToCompare == pComparator); }
public:
	COBLIST() : m_pHead(NULL), m_pTail(NULL), m_cItem(0) { }
    virtual         ~COBLIST();
	
	virtual void *  RemoveAt(POSITION rPos);
    void            EmptyList();
	POSITION	    AddTail(void* pItem);
	void *		    GetNext(POSITION& rPos);
    void *          SafeGetFromPosition(POSITION rPos);
    POSITION        GetPosition(void* pItem);
    POSITION        Lookup(void* pComparator);
	POSITION	    GetHeadPosition()  { return (m_pHead); }
	POSITION	    GetTailPosition()  { return (m_pTail); }
	BOOL		    IsEmpty()          { return (!m_pHead); }
	int             GetItemCount()     { return (m_cItem); }
#ifdef DEBUG
	void *		    GetHead();
	void *		    GetTail();
	void *		    RemoveHead();
	void *	        RemoveTail();
	void *		    GetFromPosition(POSITION rPos);
#else
	void *		    GetHead()          { return GetFromPosition(GetHeadPosition());}
	void *          GetTail()          { return m_pTail->pItem;}
	void *		    RemoveHead()       { return RemoveAt(m_pHead); }
	void *	        RemoveTail()       { return RemoveAt(m_pTail); }
	void *		    GetFromPosition(POSITION rPos){return(rPos->pItem);}
#endif
};

// Utility Functions
POSITION AddNode(PVOID pv, COBLIST ** ppList);
PVOID RemoveNode(POSITION * pPos, COBLIST *pList);



////////////
// BSTRING

class BSTRING
{
private:
	BSTR   m_bstr;

public:
	// Constructors
	BSTRING() {m_bstr = NULL;}

	inline BSTRING(LPCWSTR lpcwString);

#if !defined(UNICODE)
	// We don't support construction from an ANSI string in the Unicode build.
	BSTRING(LPCSTR lpcString);
#endif // !defined(UNICODE)

	// Destructor
	inline ~BSTRING();

	// Cast to BSTR
	operator BSTR() {return m_bstr;}
	inline LPBSTR GetLPBSTR(void);
};


BSTRING::BSTRING(LPCWSTR lpcwString)
{
	if (NULL != lpcwString)
	{
		m_bstr = SysAllocString(lpcwString);
		//ASSERT(NULL != m_bstr);
	}
	else
	{
		m_bstr = NULL;
	}
}

BSTRING::~BSTRING()
{
	if (NULL != m_bstr)
	{
		SysFreeString(m_bstr);
	}
}

inline LPBSTR BSTRING::GetLPBSTR(void)
{
	//ASSERT(NULL == m_bstr);

	return &m_bstr;
}

class BTSTR
{
private:
	LPTSTR m_psz;

public:
	BTSTR(BSTR bstr);
	~BTSTR();

	// Cast to BSTR
	operator LPTSTR() {return (NULL == m_psz) ? TEXT("<null>") : m_psz;}
};

LPTSTR PszFromBstr(BSTR bst);


#endif  // _CL_UTIL_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\remdsk\rds\samples\service\precomp.h ===
#ifdef DEBUG
#define _CRTDBG_MAP_ALLOC
#endif

#include <windows.h>
#include <stdio.h>
#include <stdlib.h>
#include <shellapi.h>
#include <process.h>
#include <tchar.h>
#include <stock.h>
#include <ConfDbg.h>
#include <memtrack.h>
#include <strutil.h>
#include <debspew.h>
#include "nmmgr.h"
#include <RegEntry.h>
#include <ConfReg.h>
#include <service.h>
#include <resource.h>
#include <ias.h>
#include <nmmkcert.h>

#include "imsconf3.h"
#include "confguid.h"
#include "objidl.h"
#include "oleidl.h"
#include "ocidl.h"
#include "oaidl.h"
#include "clutil.h"
#include "cconf.h"
#include "taskbar.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\remdsk\rds\samples\service\resource.h ===
#define IDI_SM_WORLD 100
#define IDS_MNMSRVC_TITLE 101
#define IDS_MNMSRVC_DESCRIPTION 102
#define IDC_STOP_ICON	103

#define IDR_TASKBAR_POPUP 200
#define IDM_TBPOPUP_STOP 201
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\remdsk\rds\samples\service\nmmgr.h ===
// Copyright (C) 1993-1998  Microsoft Corporation.  All Rights Reserved.
//
//  MODULE: nmmgr.h
//
//  AUTHOR: claus giloi
//
//  COMMENTS: Based on Service sample in NT SDK
//            Code will have the following command line interface
//
//  <service exe> -?                to display this list
//  <service exe> -install          to install the service
//  <service exe> -remove           to remove the service
//  <service exe> -debug <params>   to run as a console app for debugging
//
//  Note: This code also implements Ctrl+C and Ctrl+Break handlers
//        when using the debug option.  These console events cause
//        your ServiceStop routine to be called
//
//        Also, this code only handles the OWN_SERVICE service type
//        running in the LOCAL_SYSTEM security context.
//
//        To control your service ( start, stop, etc ) you may use the
//        Services control panel applet or the NET.EXE program.
//
//        To aid in writing/debugging service, the
//        SDK contains a utility (MSTOOLS\BIN\SC.EXE) that
//        can be used to control, configure, or obtain service status.
//        SC displays complete status for any service/driver
//        in the service database, and allows any of the configuration
//        parameters to be easily changed at the command line.
//        For more information on SC.EXE, type SC at the command line.
//

#ifndef __NTSRVC_H__
#define __NTSRVC_H__


#ifdef __cplusplus
extern "C" {
#endif

extern SERVICE_STATUS          g_ssStatus;       // current status of the service 
extern SERVICE_STATUS_HANDLE   g_sshStatusHandle;


//////////////////////////////////////////////////////////////////////////////
////       The service should use ReportStatusToSCMgr to indicate
////       progress.  This routine must also be used by StartService()
////       to report to the SCM when the service is running.
////
////       If a ServiceStop procedure is going to take longer than
////       3 seconds to execute, it should spawn a thread to
////       execute the stop code, and return.  Otherwise, the
////       ServiceControlManager will believe that the service has
////       stopped responding
////
VOID MNMServiceStart(DWORD dwArgc, LPTSTR *lpszArgv);
BOOL MNMServiceActivate();
BOOL MNMServiceDeActivate();
//////////////////////////////////////////////////////////////////////////////



//////////////////////////////////////////////////////////////////////////////
//// The following are procedures which
//// may be useful to call within the above procedures,
//// but require no implementation by the user.
//// They are implemented in service.c

//
//  FUNCTION: ReportStatusToSCMgr()
//
//  PURPOSE: Sets the current status of the service and
//           reports it to the Service Control Manager
//
//  PARAMETERS:
//    dwCurrentState - the state of the service
//    dwWin32ExitCode - error code to report
//    dwWaitHint - worst case estimate to next checkpoint
//
//  RETURN VALUE:
//    TRUE  - success 
//    FALSE - failure
//
BOOL ReportStatusToSCMgr(DWORD dwCurrentState, DWORD dwWin32ExitCode, DWORD dwWaitHint);


#ifdef __cplusplus
}
#endif

#endif __NTSRVC_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\remdsk\rds\samples\service\nmmgr.cpp ===
// 
// Copyright (C) 1993-1997  Microsoft Corporation.  All Rights Reserved. 
// 
//  MODULE:  nmmgr.cpp 
// 
//  PURPOSE:  Implements the body of the service. 
// 
//  FUNCTIONS: 
//            MNMServiceStart(DWORD dwArgc, LPTSTR *lpszArgv); 
//            MNMServiceStop( ); 
// 
//  COMMENTS: The functions implemented in nmmgr.c are 
//            prototyped in nmmgr.h 
//              
// 
//  AUTHOR: Claus Giloi
// 
 
#include <precomp.h>

#define NMSRVC_TEXT "SalemSrvc"

// DEBUG only -- Define debug zone
#ifdef DEBUG
HDBGZONE ghZone = NULL;
static PTCHAR rgZones[] = {
    NMSRVC_TEXT,
    "Warning",
    "Trace",
    "Function"
};
#endif // DEBUG


extern DWORD g_dwMainThreadID;

// 
//  FUNCTION: MNMServiceStart 
// 
//  PURPOSE: Actual code of the service 
//          that does the work. 
// 
//  PARAMETERS: 
//    dwArgc  - number of command line arguments 
//    lpszArgv - array of command line arguments 
// 
//  RETURN VALUE: 
//    none 
// 
//  COMMENTS: 
// 
VOID MNMServiceStart (DWORD dwArgc, LPTSTR *lpszArgv) 
{ 
    HRESULT hRet;
    DWORD   dwResult;
    MSG     msg;
    DWORD   dwError = NO_ERROR;
    int     i;

    // Initialization
    DBGINIT(&ghZone, rgZones);
    InitDebugModule(NMSRVC_TEXT);

    g_dwMainThreadID = GetCurrentThreadId();

    DebugEntry(MNMServiceStart);

    //
    // report the status to the service control manager. 
    //
    if (!ReportStatusToSCMgr( SERVICE_START_PENDING, NO_ERROR, 30000))
    {
        ERROR_OUT(("ReportStatusToSCMgr failed"));
        dwError = GetLastError();
        goto cleanup; 
    }
    
    CoInitialize(NULL);

    SetConsoleCtrlHandler(ServiceCtrlHandler, TRUE);

    //////////////////////////////////////////////////////// 
    // 
    // Service is now running, perform work until shutdown 
    //

    if (!MNMServiceActivate())
    {
        ERROR_OUT(("Unable to activate service"));
        goto cleanup;
    }

    while (GetMessage(&msg, NULL, 0, 0))
    {
        TranslateMessage(&msg);
        DispatchMessage(&msg);
    }

cleanup: 

    MNMServiceDeActivate();
 
    DebugExitVOID(MNMServiceStart);

    CoUninitialize();

    g_dwMainThreadID = 0;

    DBGDEINIT(&ghZone);
    ExitDebugModule();
}
 




BOOL MNMServiceActivate ( VOID )
{
    DebugEntry(MNMServiceActivate);


    HRESULT hRet = InitConfMgr();
    if (FAILED(hRet))
    {
        ERROR_OUT(("ERROR %x initializing nmmanger", hRet));
        return FALSE;
    }

    AddTaskbarIcon();
    ReportStatusToSCMgr( SERVICE_RUNNING, NO_ERROR, 0);

    DebugExitBOOL(MNMServiceActivate,TRUE);
    return TRUE;
}


BOOL MNMServiceDeActivate ( VOID )
{
    DebugEntry(MNMServiceDeActivate);

    RemoveTaskbarIcon();

    ReportStatusToSCMgr(SERVICE_PAUSED, NO_ERROR, 0);

    //
    // Leave Conference
    //

    if (NULL != g_pConference)
    {
        if ( FAILED(g_pConference->Leave()))
        {
            ERROR_OUT(("Conference Leave failed"));;
        }
    }

    //
    // Free the conference
    //

    FreeConference();

    //
    // Free the AS interface
    //

    ASSERT(g_pAS);
    UINT ret = g_pAS->Release();
    g_pAS = NULL;
    TRACE_OUT(("AS interface freed, ref %d after Release", ret));


    // not to call FreeConfMfr imediately after FreeConference to avoid
    // a bug in t120 will remove this sleep call after fix the bug in t120
    FreeConfMgr();

    ReportStatusToSCMgr( SERVICE_STOPPED, 0, 0);

    DebugExitBOOL(MNMServiceDeActivate,TRUE);
    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\remdsk\rds\samples\service\cconf.h ===
//****************************************************************************
//  Module:     NMCHAT.EXE
//  File:       CCONF.H
//  Content:    
//              
//
//  Copyright (c) Microsoft Corporation 1997
//
// THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF 
// ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO 
// THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A 
// PARTICULAR PURPOSE.
//****************************************************************************

class CMgrNotify : public RefCount, public CNotify, public INmManagerNotify, public IAppSharingNotify
{
public:
	CMgrNotify();
	~CMgrNotify();

        // IUnknown methods
	STDMETHODIMP_(ULONG) AddRef(void);
	STDMETHODIMP_(ULONG) Release(void);
	STDMETHODIMP QueryInterface(REFIID riid, PVOID *ppvObj);

 	// ICNotify methods
	STDMETHODIMP Connect (IUnknown *pUnk);
	STDMETHODIMP Disconnect(void);

	// INmManagerNotify
	STDMETHODIMP NmUI(CONFN confn);
	STDMETHODIMP ConferenceCreated(INmConference *pConference);
	STDMETHODIMP CallCreated(INmCall *pNmCall);

        // IAppSharingNotify
        STDMETHODIMP OnReadyToShare(BOOL fReady);
        STDMETHODIMP OnShareStarted();
        STDMETHODIMP OnSharingStarted();
        STDMETHODIMP OnShareEnded();
        STDMETHODIMP OnPersonJoined(IAS_GCC_ID gccID);
        STDMETHODIMP OnPersonLeft(IAS_GCC_ID gccID);
        STDMETHODIMP OnStartInControl(IAS_GCC_ID gccInControlOf);
        STDMETHODIMP OnStopInControl(IAS_GCC_ID gccInControlOf);
        STDMETHODIMP OnControllable(BOOL fControllable);
        STDMETHODIMP OnStartControlled(IAS_GCC_ID gccControlledBy);
        STDMETHODIMP OnStopControlled(IAS_GCC_ID gccControlledBy);
};


class CConfNotify : public RefCount, public CNotify, public INmConferenceNotify
{
public:
	CConfNotify();
	~CConfNotify();

	// INmConferenceNotify
	HRESULT STDMETHODCALLTYPE NmUI(CONFN uNotify);
	HRESULT STDMETHODCALLTYPE StateChanged(NM_CONFERENCE_STATE uState);
	HRESULT STDMETHODCALLTYPE MemberChanged(NM_MEMBER_NOTIFY uNotify, INmMember *pfMember);

	// ICNotify methods
	HRESULT STDMETHODCALLTYPE Connect (IUnknown *pUnk);
	HRESULT STDMETHODCALLTYPE Disconnect(void);

	// IUnknown methods
	ULONG STDMETHODCALLTYPE AddRef(void);
	ULONG STDMETHODCALLTYPE Release(void);
	HRESULT STDMETHODCALLTYPE QueryInterface(REFIID riid, PVOID *ppvObj);
};


const WM_CREATEDATA = 0x07181975;

// Global Variables
extern INmManager * g_pMgr;
extern INmConference * g_pConference;
extern IAppSharing * g_pAS;


// Global Functions
HRESULT InitConfMgr(void);
VOID FreeConfMgr(void);
VOID FreeConference(void);
HRESULT HookConference(INmConference * pConference);
BOOL ServiceCtrlHandler(DWORD dwCtrlType);

#define IS_NT (g_osvi.dwPlatformId == VER_PLATFORM_WIN32_NT)
extern OSVERSIONINFO g_osvi;  					// The os version info structure global
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\remdsk\rds\samples\service\service.cpp ===
//
// Copyright (C) 1993-1997  Microsoft Corporation.  All Rights Reserved.
//
//  MODULE:   service.c
//
//  PURPOSE:  Implements functions required by all services
//            windows.
//
//  FUNCTIONS:
//    main(int argc, char **argv);
//    NTmain(int argc, char **argv);
//    W95main(int argc, char **argv);
//    service_ctrl(DWORD dwCtrlCode);
//    ControlHandler ( DWORD dwCtrlType );  // DEBUG only
//    GetLastErrorText( LPTSTR lpszBuf, DWORD dwSize );  // DEBUG only
//
//  COMMENTS:
//
//  AUTHOR: Claus Giloi (based on SDK sample)
//


#include "precomp.h"

#ifndef DEBUG
#undef _tprintf
#define _tprintf force_compile_error
#endif // !DEBUG

// internal variables
SERVICE_STATUS          g_ssStatus;       // current status of the service
SERVICE_STATUS_HANDLE   g_sshStatusHandle;
DWORD                   dwErr = 0;
OSVERSIONINFO           g_osvi;                      // The os version info structure global
BOOL                    g_fInShutdown = FALSE;
DWORD                   g_dwMainThreadID = 0;

// internal function prototypes
VOID WINAPI service_ctrl(DWORD dwCtrlCode);
void __cdecl NTmain(int argc, char **argv);
void __cdecl W95main(int argc, char **argv);


// Debug only functionality
#ifdef DEBUG
TCHAR                   szErr[256];
BOOL                    bDebug = FALSE;
BOOL WINAPI ControlHandler ( DWORD dwCtrlType );
LPTSTR GetLastErrorText( LPTSTR lpszBuf, DWORD dwSize );
extern BOOL InitDebugMemoryOptions(void);
extern VOID DumpMemoryLeaksAndBreak(void);
#endif // DEBUG

typedef BOOL (WINAPI *PFNCHANGESERVICECONFIG2)(SC_HANDLE, DWORD, LPVOID);

//
//  FUNCTION: main
//
//  PURPOSE: entrypoint for service
//
//  PARAMETERS:
//    argc - number of command line arguments
//    argv - array of command line arguments
//
//  RETURN VALUE:
//    none
//
//  COMMENTS:
//      Get Platform type and
//    call appropriate main for platform (NT or Win95)
//
void __cdecl main(int argc, char **argv)
{
    #ifdef DEBUG
    InitDebugMemoryOptions();
    #endif // DEBUG

    // Store OS version info
    g_osvi.dwOSVersionInfoSize = sizeof(g_osvi);
    if (FALSE == ::GetVersionEx(&g_osvi))
    {
        ERROR_OUT(("GetVersionEx() failed!"));
        return;
    }

    if ( IS_NT )
    {
        NTmain( argc, argv );
    }
    else
    {
        W95main( argc, argv );
    }

    #ifdef DEBUG
    DumpMemoryLeaksAndBreak();
    #endif // DEBUG
}


//
//  FUNCTION: NTmain
//
//  PURPOSE: entrypoint for service
//
//  PARAMETERS:
//    argc - number of command line arguments
//    argv - array of command line arguments
//
//  RETURN VALUE:
//    none
//
//  COMMENTS:
//    NTmain() either performs the command line task, or
//    call StartServiceCtrlDispatcher to register the
//    main service thread.  When the this call returns,
//    the service has stopped, so exit.
//
void __cdecl NTmain(int argc, char **argv)
{
    DWORD dwArgc;
    LPTSTR *lpszArgv;

#ifdef UNICODE
    lpszArgv = CommandLineToArgvW(GetCommandLineW(), &(dwArgc) );
#else
    dwArgc   = (DWORD) argc;
    lpszArgv = argv;
#endif

#ifdef DEBUG
    SetConsoleCtrlHandler( ControlHandler, TRUE );
#endif // DEBUG

    MNMServiceStart( dwArgc, lpszArgv );
}

//
//  FUNCTION: W95main
//
//  PURPOSE: entrypoint for pseudo-service on Win95
//
//  PARAMETERS:
//    argc - number of command line arguments
//    argv - array of command line arguments
//
//  RETURN VALUE:
//    none
//
//  COMMENTS:
//    W95main() registers as Win95 service and calls Init routine directly
//
typedef DWORD (WINAPI * REGISTERSERVICEPROC)(DWORD, DWORD);
#ifndef RSP_SIMPLE_SERVICE
#define RSP_SIMPLE_SERVICE    0x00000001
#endif

void __cdecl W95main(int argc, char **argv)
{
    HMODULE hKernel;
    REGISTERSERVICEPROC lpfnRegisterServiceProcess;

    if ( hKernel = GetModuleHandle("KERNEL32.DLL") )
    {
        if ( lpfnRegisterServiceProcess =
            (REGISTERSERVICEPROC)GetProcAddress ( hKernel,
                                    "RegisterServiceProcess" ))
        {
            if (!lpfnRegisterServiceProcess(NULL, RSP_SIMPLE_SERVICE))
            {
                ERROR_OUT(("RegisterServiceProcess failed"));
            }
        }
        else
        {
            ERROR_OUT(("GetProcAddr of RegisterServiceProcess failed"));
        }
    }
    else
    {
        ERROR_OUT(("GetModuleHandle of KERNEL32.DLL failed"));
    }

    MNMServiceStart(argc, argv);
}



//
//  FUNCTION: service_ctrl
//
//  PURPOSE: This function is called by the SCM whenever
//           ControlService() is called on this service.
//
//  PARAMETERS:
//    dwCtrlCode - type of control requested
//
//  RETURN VALUE:
//    none
//
//  COMMENTS:
//
VOID WINAPI service_ctrl(DWORD dwCtrlCode)
{
    // Handle the requested control code.
    //
    switch(dwCtrlCode)
    {
        // Stop the service.
        //
        // SERVICE_STOP_PENDING should be reported before
        // setting the Stop Event - hServerStopEvent - in
        // MNMServiceStop().  This avoids a race condition
        // which may result in a 1053 - The Service did not respond...
        // error.
        case SERVICE_CONTROL_STOP:
            ReportStatusToSCMgr(SERVICE_STOP_PENDING, NO_ERROR, 30000);
            ::PostThreadMessage(g_dwMainThreadID, WM_QUIT, 0, 0);
            return;

        case SERVICE_CONTROL_SHUTDOWN:
            g_fInShutdown = TRUE;
            break;

        // Update the service status.
        //
        case SERVICE_CONTROL_INTERROGATE:
            break;

        case SERVICE_CONTROL_PAUSE:
            ReportStatusToSCMgr(SERVICE_PAUSE_PENDING, NO_ERROR, 30000);
            return;

        case SERVICE_CONTROL_CONTINUE:
            ReportStatusToSCMgr(SERVICE_CONTINUE_PENDING, NO_ERROR, 30000);
            return;

        default:
            break;

    }
}



//
//  FUNCTION: ReportStatusToSCMgr()
//
//  PURPOSE: Sets the current status of the service and
//           reports it to the Service Control Manager
//
//  PARAMETERS:
//    dwCurrentState - the state of the service
//    dwWin32ExitCode - error code to report
//    dwWaitHint - worst case estimate to next checkpoint
//
//  RETURN VALUE:
//    TRUE  - success
//    FALSE - failure
//
//  COMMENTS:
//
BOOL ReportStatusToSCMgr(DWORD dwCurrentState,
                         DWORD dwWin32ExitCode,
                         DWORD dwWaitHint)
{
    static DWORD dwCheckPoint = 1;
    BOOL fResult = TRUE;

    #ifdef DEBUG
    if ( bDebug )
        return TRUE;
    #endif

    if ( IS_NT ) // when debugging we don't report to the SCM
    {
        switch ( dwCurrentState )
        {
            case SERVICE_START_PENDING:
            case SERVICE_STOP_PENDING:
            case SERVICE_CONTINUE_PENDING:
            case SERVICE_PAUSE_PENDING:
                break;

            case SERVICE_PAUSED:
            case SERVICE_STOPPED:
            case SERVICE_RUNNING:
                g_ssStatus.dwControlsAccepted = SERVICE_ACCEPT_STOP |
                                              SERVICE_ACCEPT_PAUSE_CONTINUE ;

                break;
        }

        g_ssStatus.dwCurrentState = dwCurrentState;
        g_ssStatus.dwWin32ExitCode = dwWin32ExitCode;
        g_ssStatus.dwWaitHint = dwWaitHint;

        if ( ( dwCurrentState == SERVICE_RUNNING ) ||
             ( dwCurrentState == SERVICE_STOPPED ) ||
             ( dwCurrentState == SERVICE_PAUSED  ))
            g_ssStatus.dwCheckPoint = 0;
        else
            g_ssStatus.dwCheckPoint = dwCheckPoint++;

        // Report the status of the service to the service control manager.
        //
        if (!(fResult = SetServiceStatus( g_sshStatusHandle, &g_ssStatus))) {
        }
    }
    return fResult;
}


///////////////////////////////////////////////////////////////////
//
//  The following code handles service installation and removal
//




#ifdef DEBUG

///////////////////////////////////////////////////////////////////
//
//  The following code is for running the service as a console app
//


//
//  FUNCTION: ControlHandler ( DWORD dwCtrlType )
//
//  PURPOSE: Handled console control events
//
//  PARAMETERS:
//    dwCtrlType - type of control event
//
//  RETURN VALUE:
//    True - handled
//    False - unhandled
//
//  COMMENTS:
//
BOOL WINAPI ControlHandler ( DWORD dwCtrlType )
{
    switch( dwCtrlType )
    {
        case CTRL_BREAK_EVENT:  // use Ctrl+C or Ctrl+Break to simulate
        case CTRL_C_EVENT:      // SERVICE_CONTROL_STOP in debug mode
            PostThreadMessage(g_dwMainThreadID, WM_QUIT, 0, 0);
            return TRUE;
            break;

    }
    return FALSE;
}

//
//  FUNCTION: GetLastErrorText
//
//  PURPOSE: copies error message text to string
//
//  PARAMETERS:
//    lpszBuf - destination buffer
//    dwSize - size of buffer
//
//  RETURN VALUE:
//    destination buffer
//
//  COMMENTS:
//
LPTSTR GetLastErrorText( LPTSTR lpszBuf, DWORD dwSize )
{
    DWORD dwRet;
    LPTSTR lpszTemp = NULL;

    dwRet = FormatMessage( FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_SYSTEM |FORMAT_MESSAGE_ARGUMENT_ARRAY,
                           NULL,
                           GetLastError(),
                           LANG_NEUTRAL,
                           (LPTSTR)&lpszTemp,
                           0,
                           NULL );

    // supplied buffer is not long enough
    if ( !dwRet || ( (long)dwSize < (long)dwRet+14 ) )
        lpszBuf[0] = TEXT('\0');
    else
    {
        lpszTemp[lstrlen(lpszTemp)-2] = TEXT('\0');  //remove cr and newline character
        _stprintf( lpszBuf, TEXT("%s (0x%x)"), lpszTemp, GetLastError() );
    }

    if ( lpszTemp )
        LocalFree((HLOCAL) lpszTemp );

    return lpszBuf;
}

#endif // DEBUG
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\remdsk\rds\samples\service\srvccall.h ===
// File: srvccall.h

#ifndef _SRVCCALL_H_
#define _SRVCCALL_H_

class CSrvcCall : public INmCallNotify
{
private:
	INmCall * m_pCall;
	BOOL      m_fIncoming;
	LPTSTR    m_pszName;
	NM_CALL_STATE m_State;
	BOOL      m_fSelectedConference;

	POSITION  m_pos;           // position in g_pCallList
	ULONG     m_cRef;
	DWORD     m_dwCookie;

public:
	CSrvcCall(INmCall * pCall);
	~CSrvcCall();

	// IUnknown methods
	STDMETHODIMP_(ULONG) AddRef(void);
	STDMETHODIMP_(ULONG) Release(void);
	STDMETHODIMP QueryInterface(REFIID riid, PVOID *ppv);

	// INmCallNotify methods
	STDMETHODIMP NmUI(CONFN uNotify);
	STDMETHODIMP StateChanged(NM_CALL_STATE uState);
	STDMETHODIMP Failed(ULONG uError);
	STDMETHODIMP Accepted(INmConference *pConference);
	STDMETHODIMP CallError(UINT cns);
	STDMETHODIMP RemoteConference(BOOL fMCU, BSTR *pwszConfNames, BSTR *pbstrConfToJoin);
	STDMETHODIMP RemotePassword(BSTR bstrConference, BSTR *pbstrPassword, BYTE *pb, DWORD cb);

	// Internal methods
	VOID    Update(void);
	VOID	RemoveCall(void);

};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\remdsk\rds\samples\service\srvcutil.cpp ===
// srvcutil.cpp

#include "precomp.h"

/*  B  S  T  R _ T O _  L  P  T  S  T  R  */
/*-------------------------------------------------------------------------
    %%Function: BSTR_to_LPTSTR
    
-------------------------------------------------------------------------*/
HRESULT BSTR_to_LPTSTR(LPTSTR *ppsz, BSTR bstr)
{
#ifndef UNICODE
	// compute the length of the required BSTR
	int cch =  WideCharToMultiByte(CP_ACP, 0, (LPWSTR)bstr, -1, NULL, 0, NULL, NULL);
	if (cch <= 0)
	{
		ERROR_OUT(("WideCharToMultiByte failed"));
		return E_FAIL;
	}

	// cch is the number of BYTES required, including the null terminator
	*ppsz = (LPTSTR) new char[cch];
	if (*ppsz == NULL)
	{
		ERROR_OUT(("WideCharToMultiByte out of memory"));
		return E_OUTOFMEMORY;
	}

	WideCharToMultiByte(CP_ACP, 0, (LPWSTR)bstr, -1, *ppsz, cch, NULL, NULL);
	return S_OK;
#else
	return E_NOTIMPL;
#endif // UNICODE
}

/////////////////////////////////////////////////////////////////////////////
// Connection Point Helpers

HRESULT NmAdvise(IUnknown* pUnkCP, IUnknown* pUnk, const IID& iid, LPDWORD pdw)
{
	IConnectionPointContainer *pCPC;
	IConnectionPoint *pCP;
	HRESULT hRes = pUnkCP->QueryInterface(IID_IConnectionPointContainer, (void**)&pCPC);
	if (SUCCEEDED(hRes))
	{
		hRes = pCPC->FindConnectionPoint(iid, &pCP);
		pCPC->Release();
	}
	if (SUCCEEDED(hRes))
	{
		hRes = pCP->Advise(pUnk, pdw);
		pCP->Release();
	}
	return hRes;
}

HRESULT NmUnadvise(IUnknown* pUnkCP, const IID& iid, DWORD dw)
{
	IConnectionPointContainer *pCPC;
	IConnectionPoint *pCP;
	HRESULT hRes = pUnkCP->QueryInterface(IID_IConnectionPointContainer, (void**)&pCPC);
	if (SUCCEEDED(hRes))
	{
		hRes = pCPC->FindConnectionPoint(iid, &pCP);
		pCPC->Release();
	}
	if (SUCCEEDED(hRes))
	{
		hRes = pCP->Unadvise(dw);
		pCP->Release();
	}
	return hRes;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\remdsk\rds\samples\service\srvccall.cpp ===
// SrvcCall.cpp
// Code to implement the INmCallNotify interface for the remote control service

#include "precomp.h"
#include "srvcutil.h"
#include "srvccall.h"

CSrvcCall::CSrvcCall(INmCall * pNmCall) :
	m_pCall  (pNmCall),
	m_pszName  (NULL),
	m_fSelectedConference (FALSE),
	m_pos      (NULL),
	m_cRef     (1),
	m_dwCookie (0)
{
	HRESULT hr;

	TRACE_OUT(("CSrvcCall: Created %08X (INmCall=%08X)", this, pNmCall));

	ASSERT(NULL != m_pCall);
	m_pCall->AddRef();

	// Get the display name
	BSTR  bstr;
	hr = m_pCall->GetAddress(&bstr);
	if (SUCCEEDED(hr))
	{
		hr = BSTR_to_LPTSTR(&m_pszName, bstr);
		SysFreeString(bstr);
	}
	if (FEmptySz(m_pszName))
	{
		// Default to "another person" if no name available in the call data
		m_pszName = TEXT("Somebody");
	}

	// These should never change
	m_fIncoming = (m_pCall->IsIncoming() == S_OK);

	Update();

	NmAdvise(m_pCall, this, IID_INmCallNotify, &m_dwCookie);
}

VOID CSrvcCall::RemoveCall(void)
{
	NmUnadvise(m_pCall, IID_INmCallNotify, m_dwCookie);
}

CSrvcCall::~CSrvcCall()
{
	delete m_pszName;

	ASSERT(NULL != m_pCall);
	m_pCall->Release();
}

// IUnknown methods
STDMETHODIMP_(ULONG) CSrvcCall::AddRef(void)
{
	return ++m_cRef;
}

STDMETHODIMP_(ULONG) CSrvcCall::Release(void)
{
	ASSERT(m_cRef > 0);
	if (m_cRef > 0)
	{
		m_cRef--;
	}

	ULONG cRef = m_cRef;

	if (0 == cRef)
	{
		delete this;
	}

	return cRef;
}

STDMETHODIMP CSrvcCall::QueryInterface(REFIID riid, PVOID *ppv)
{
	HRESULT hr = S_OK;

	if ((riid == IID_INmCallNotify) || (riid == IID_IUnknown))
	{
		*ppv = (INmCallNotify *)this;
//		ApiDebugMsg(("CCall::QueryInterface()"));
	}
	else
	{
		hr = E_NOINTERFACE;
		*ppv = NULL;
//		ApiDebugMsg(("CCall::QueryInterface(): Called on unknown interface."));
	}

	if (S_OK == hr)
	{
		AddRef();
	}

	return hr;
}

// INmCallNotify methods
STDMETHODIMP CSrvcCall::NmUI(CONFN uNotify)
{
	return S_OK;
}

STDMETHODIMP CSrvcCall::StateChanged(NM_CALL_STATE uState)
{
	// REVIEW: This check should be done outside of this routine
	if (uState == m_State)
	{
		// Don't bother the UI when nothing changes!
		return S_OK;
	}

	Update();

	return S_OK;
}

STDMETHODIMP CSrvcCall::Failed(ULONG uError)
{
	return S_OK;
}

STDMETHODIMP CSrvcCall::Accepted(INmConference *pConference)
{
	return S_OK;
}

// INmCallNotify3 methods
STDMETHODIMP CSrvcCall::CallError(UINT cns)
{
	return S_OK;
}


STDMETHODIMP CSrvcCall::RemoteConference(BOOL fMCU, BSTR *pwszConfNames, BSTR *pbstrConfToJoin)
{
	return S_OK;
}

STDMETHODIMP CSrvcCall::RemotePassword(BSTR bstrConference, BSTR *pbstrPassword, BYTE *pb, DWORD cb)
{
	return S_OK;
}

/*  U P D A T E  */
/*-------------------------------------------------------------------------
    %%Function: Update

    Update the cached information about the call
-------------------------------------------------------------------------*/
VOID CSrvcCall::Update(void)
{
	m_pCall->GetState(&m_State);
	// TRACE_OUT(("CCall: New State=%0d for call=%08X", m_State, this));

	switch (m_State)
	{
	case NM_CALL_ACCEPTED:
	case NM_CALL_REJECTED:
	case NM_CALL_CANCELED:

		RemoveCall();
		Release();
		break;

	case NM_CALL_RING:
		m_pCall->Accept();
		break;

	default:
		ERROR_OUT(("CCall::Update: Unknown state %08X", m_State));

	case NM_CALL_INVALID:
	case NM_CALL_INIT:
	case NM_CALL_SEARCH:
	case NM_CALL_WAIT:
		break;
	}

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\remdsk\rds\samples\service\srvcutil.h ===
// srvcutil.h

HRESULT BSTR_to_LPTSTR(LPTSTR *ppsz, BSTR bstr);

HRESULT NmAdvise(IUnknown* pUnkCP, IUnknown* pUnk, const IID& iid, LPDWORD pdw);
HRESULT NmUnadvise(IUnknown* pUnkCP, const IID& iid, DWORD dw);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\remdsk\rds\samples\service\taskbar.h ===
#ifndef _TASKBAR_H_
#define _TASKBAR_H_

#define ID_TASKBAR_ICON	1000
const UINT WM_TASKBAR_NOTIFY =          WM_USER + 200;

BOOL AddTaskbarIcon(VOID);
BOOL RemoveTaskbarIcon(VOID);
BOOL OnRightClickTaskbar(VOID);
#endif // _TASKBAR_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\remdsk\rds\t120\common\appcap.cpp ===
#include "precomp.h"
#include "fsdiag.h"
DEBUG_FILEZONE(ZONE_T120_UTILITY);

/* 
 *	appcap.cpp
 *
 *	Copyright (c) 1994 by DataBeam Corporation, Lexington, KY
 *
 *	Abstract:
 *		This is the implementation file for the class CAppCap. 
 *
 *	Caveats:
 *		None.
 *
 *	Author:
 *		jbo
 */

#include "appcap.h"
#include "clists.h"


/*
 *	CAppCap ()
 *
 *	Public Function Description:
 *		This constructor is used to create a AppCapabilityData object 
 * 		from an "API" GCCApplicationCapability list.
 */
CAppCap::CAppCap(UINT   						number_of_capabilities,
				PGCCApplicationCapability		*	capabilities_list,
				PGCCError							pRetCode)
:
    CRefCount(MAKE_STAMP_ID('A','C','a','p')),
    m_AppCapItemList(DESIRED_MAX_CAPS),
    m_cbDataSize(0)
{
	APP_CAP_ITEM    *pAppCapItem;
	UINT			i;
	GCCError        rc;

	rc = GCC_NO_ERROR;

	for (i = 0; i < number_of_capabilities; i++)
	{
		DBG_SAVE_FILE_LINE
		pAppCapItem = new APP_CAP_ITEM((GCCCapabilityType) capabilities_list[i]->capability_class.eType);
		if (pAppCapItem != NULL)
		{
			DBG_SAVE_FILE_LINE
			pAppCapItem->pCapID = new CCapIDContainer(
			                                &capabilities_list[i]->capability_id,
			                                &rc);
			if ((pAppCapItem->pCapID != NULL) && (rc == GCC_NO_ERROR))
			{
				if (capabilities_list[i]->capability_class.eType ==
										GCC_UNSIGNED_MINIMUM_CAPABILITY)
				{
					pAppCapItem->nUnsignedMinimum =
							capabilities_list[i]->capability_class.nMinOrMax;
				}
				else if	(capabilities_list[i]->capability_class.eType 
									== GCC_UNSIGNED_MAXIMUM_CAPABILITY)
				{
					pAppCapItem->nUnsignedMaximum =
							capabilities_list[i]->capability_class.nMinOrMax;
				}

				pAppCapItem->cEntries = 1;

				/*
				 * Add this capability to the list.
				 */
				m_AppCapItemList.Append(pAppCapItem);
			}
			else if (pAppCapItem->pCapID == NULL)
			{
				rc = GCC_ALLOCATION_FAILURE;
			}
			else
			{
				delete pAppCapItem;
			}
		}
		else
		{
			rc = GCC_ALLOCATION_FAILURE;
		}

		if (rc != GCC_NO_ERROR)
			break;
	}

    *pRetCode = rc;
}

/*
 *	~CAppCap()
 *
 *	Public Function Description
 *		The CAppCap destructor is responsible for freeing 
 *		any memory allocated to hold the capability data.
 *
 */
CAppCap::~CAppCap(void)
{
	m_AppCapItemList.DeleteList();
}

/*
 *	LockCapabilityData ()
 *
 *	Public Function Description:
 *		This routine locks the capability data and determines the amount of
 *		memory referenced by the "API" non-collapsing capability data structure.
 */
UINT CAppCap::LockCapabilityData(void)
{
	/*
	 * If this is the first time this routine is called, determine the size of 
	 * the memory required to hold the data referenced by the list of
	 * capabilities.  Otherwise, just increment the lock count.
	 */
	if (Lock() == 1)
	{
		APP_CAP_ITEM    *pAppCapItem;
		/*
		 * Add the amount of memory necessary to hold the string data associated
		 * with each capability ID.
		 */
		m_AppCapItemList.Reset();

		/*
		 * Lock the data for each capability ID.  The lock call	returns the 
		 * length of the data referenced by each capability ID rounded to occupy
		 * an even multiple of four-bytes.
		 */
		while (NULL != (pAppCapItem = m_AppCapItemList.Iterate()))
		{
			m_cbDataSize += pAppCapItem->pCapID->LockCapabilityIdentifierData();
		}

		/*
		 * Add the memory to hold the application capability pointers
		 * and structures.
		 */
		m_cbDataSize += m_AppCapItemList.GetCount() * 
				(sizeof (PGCCApplicationCapability) +
				ROUNDTOBOUNDARY( sizeof(GCCApplicationCapability)) );
	}

	return m_cbDataSize;
}

/*
 *	GetGCCApplicationCapabilityList ()
 *
 *	Public Function Description:
 *		This routine retrieves the application capabilities list in the form of
 * 		a list of PGCCApplicationCapability's.	This routine is called after 
 * 		"locking" the capability data.
 */
UINT CAppCap::GetGCCApplicationCapabilityList(
						PUShort							number_of_capabilities,
						PGCCApplicationCapability  * *	capabilities_list,
						LPBYTE							memory)
{
	UINT cbDataSizeToRet = 0;

	/*
	 * If the capability data has been locked, fill in the output structure and
	 * the data referenced by the structure.
	 */ 
	if (GetLockCount() > 0)
	{
    	UINT								data_length = 0;
    	UINT								capability_id_data_length = 0;
    	USHORT								capability_count;
    	PGCCApplicationCapability			gcc_capability;
    	PGCCApplicationCapability		*	gcc_capability_list;
    	APP_CAP_ITEM                        *pAppCapItem;

		/*
		 * Fill in the output length parameter which indicates how much data
		 * referenced outside the structure will be written.
		 */
		cbDataSizeToRet = m_cbDataSize;

		/*
		 * Retrieve the number of capabilities and fill in any that are present.
		 */
		*number_of_capabilities = (USHORT) m_AppCapItemList.GetCount();

		if (*number_of_capabilities != 0)
		{
			/*
			 * Fill in the pointer to the list of application capability
			 * pointers.  The pointer list will begin at the memory location 
			 * passed into this routine.  Save the list pointer in a local 
			 * variable for convenience.
			 */
			*capabilities_list = (PGCCApplicationCapability *)memory;
			gcc_capability_list = *capabilities_list;

			/*
			 * Move the memory pointer past the list of capability pointers.
			 * This	is where the first application capability structure will be
			 * written.
			 */
			memory += (*number_of_capabilities * sizeof(PGCCApplicationCapability));

			/*
			 * Add to the data length the amount of memory necessary to hold the
			 * application capability pointers.  Go ahead and add the amount of 
			 * memory necessary to hold all of the GCCApplicationCapability 
			 * structures.
			 */
			data_length += *number_of_capabilities *
					(sizeof(PGCCApplicationCapability) + 
					ROUNDTOBOUNDARY ( sizeof(GCCApplicationCapability)) ); 

			/*
			 * Iterate through the capabilities list, building an "API"
			 * capability for each capability in the list.
			 */
			capability_count = 0;
			m_AppCapItemList.Reset();
			while (NULL != (pAppCapItem = m_AppCapItemList.Iterate()))
			{
				/*
				 * Set the application capability pointer equal to the
				 * location in memory where it will be written.
				 */
				gcc_capability = (PGCCApplicationCapability)memory;

				/*
				 * Save the pointer to the application capability in the
				 * list of application capability pointers.
				 */
				gcc_capability_list[capability_count] = gcc_capability;

				/*
				 * Advance the memory pointer past the application capability
				 * structure.  This is where the string data for the capability
				 * ID will be written.  Ensure that the memory pointer falls on 
				 * an even four-byte boundary.
				 */
				memory += ROUNDTOBOUNDARY(sizeof(GCCApplicationCapability));

				/*
				 * Retrieve the capability ID information from the internal 
				 * CapabilityIDData object.  The length returned by this call 
				 * will	have already been rounded to an even multiple of four 
				 * bytes.
				 */
				capability_id_data_length = pAppCapItem->pCapID->
						GetGCCCapabilityIDData(&gcc_capability->capability_id, memory);

				/*
				 * Advance the memory pointer past the string data written into 
				 * memory by the capability ID object.  Add the length of the 
				 * string data to the overall capability length.
				 */
				memory += capability_id_data_length;
				data_length += capability_id_data_length;

				/*
				 * Now fill in the rest of the capability.
				 */
				gcc_capability->capability_class.eType = pAppCapItem->eCapType;

				if (gcc_capability->capability_class.eType ==
										GCC_UNSIGNED_MINIMUM_CAPABILITY)
				{
					gcc_capability->capability_class.nMinOrMax =
						pAppCapItem->nUnsignedMinimum;
				}
				else if (gcc_capability->capability_class.eType ==
										GCC_UNSIGNED_MAXIMUM_CAPABILITY)
				{
					gcc_capability->capability_class.nMinOrMax =
						pAppCapItem->nUnsignedMaximum;
				}

				gcc_capability->number_of_entities = pAppCapItem->cEntries;

				/*
				 * Increment the capability array counter.
				 */
				capability_count++;
			}
		}
		else
		{
			cbDataSizeToRet = 0;
	  		capabilities_list = NULL;
		}
	}
	else
	{
		ERROR_OUT(("CAppCap::GetData: Error: data not locked"));
	}

	return (cbDataSizeToRet);
}

/*
 *	UnLockCapabilityData ()
 *
 *	Public Function Description:
 *		This routine decrements the lock count and frees the memory associated 
 *		with the "API" capability once the lock count reaches zero.
 */
void CAppCap::UnLockCapabilityData(void)
{
	if (Unlock(FALSE) == 0)
	{
		APP_CAP_ITEM    *pAppCapItem;
		/*
		 * Iterate through the list of collapsed capabilities, unlocking the
		 * data for each CapabilityIDData object associated with each 
		 * capability.
		 */
		m_AppCapItemList.Reset();
		while (NULL != (pAppCapItem = m_AppCapItemList.Iterate()))
		{
			pAppCapItem->pCapID->UnLockCapabilityIdentifierData();
		}
	}

    // we have to call Release() because we used Unlock(FALSE)
    Release();
}



APP_CAP_ITEM::APP_CAP_ITEM(GCCCapabilityType eCapType)
:
	pCapID(NULL),
	eCapType(eCapType),
	cEntries(0),
	poszAppData(NULL)
{
}

APP_CAP_ITEM::APP_CAP_ITEM(APP_CAP_ITEM *p, PGCCError pError)
	:	poszAppData(NULL)
{
	//	First set up the capability id
	DBG_SAVE_FILE_LINE
	pCapID = new CCapIDContainer(p->pCapID, pError);
	if (NULL != pCapID)
	{
		//	Initialize the new capability to default values.
		eCapType = p->eCapType;

		if (p->eCapType == GCC_UNSIGNED_MINIMUM_CAPABILITY)
		{
			nUnsignedMinimum = (UINT) -1;
		}
		else if (p->eCapType == GCC_UNSIGNED_MAXIMUM_CAPABILITY)
		{
			nUnsignedMaximum = 0;
		}

		cEntries = p->cEntries;
        //
		// LONCHANC: We do not copy the entries in application data???
        //

		*pError = GCC_NO_ERROR;
	}
	else
	{
		*pError = GCC_ALLOCATION_FAILURE;
	}
}


APP_CAP_ITEM::~APP_CAP_ITEM(void)
{
    if (NULL != pCapID)
    {
        pCapID->Release();
    }

    delete poszAppData;
}


void CAppCapItemList::DeleteList(void)
{
    APP_CAP_ITEM *pAppCapItem;
    while (NULL != (pAppCapItem = Get()))
    {
        delete pAppCapItem;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\remdsk\rds\samples\service\taskbar.cpp ===
// File: taskbar.cpp

#include "precomp.h"
#include "taskbar.h"

static HWND g_hwndHidden = NULL;
const TCHAR g_cszHiddenWndClassName[] = _TEXT("MnmSrvcHiddenWindow");
BOOL g_fTaskBarIconAdded = FALSE;
BOOL g_fTimerRunning = FALSE;
extern INmManager * g_pMgr;
extern int g_cPersonsInConf;
extern DWORD g_dwMainThreadID;

// This routine starts a timer to periodically retry adding the taskbar icon.
// This is necessary in case the taskbar is not showing at the time the
// service is launched, or the taskbar is destroyed by a logoff-logon sequence.

VOID StartTaskbarTimer(VOID)
{
    if ( !g_fTimerRunning)
    {
        ASSERT(g_hwndHidden);
        SetTimer(g_hwndHidden, 0, 5000, NULL);
        g_fTimerRunning = TRUE;
    }
}

VOID KillTaskbarTimer(VOID)
{
    if ( g_fTimerRunning )
    {
        KillTimer ( g_hwndHidden, 0 );
        g_fTimerRunning = FALSE;
    }
}

LRESULT CALLBACK HiddenWndProc(    HWND hwnd, UINT uMsg,
                                WPARAM wParam, LPARAM lParam)
{
    switch(uMsg)
    {
        case WM_USERCHANGED:
        case WM_ENDSESSION:
            // A user is logging on or off... We don't know which but
            // since the desktop is changing we assume our taskbar icon
            // is toast. Start a timer to periodically try to add it back
            // until it succeeds.
            g_fTaskBarIconAdded = FALSE;
            StartTaskbarTimer();
            break;
            
        case WM_TASKBAR_NOTIFY:
        {
            if (WM_RBUTTONUP == lParam)
            {
                ::OnRightClickTaskbar();
            }
            break;
        }

        case WM_TIMER:
            AddTaskbarIcon();
            break;
        
        case WM_DESTROY:
        {
            // NULL the global variable:
            g_hwndHidden = NULL;
            return 0;
        }

        default:
            return DefWindowProc(hwnd, uMsg, wParam, lParam);
    }
    return FALSE;
}


BOOL AddTaskbarIcon(VOID)
{
    BOOL bRet = FALSE;
    
    ASSERT( NULL == g_hwndHidden );

    {
        // Register hidden window class:
        WNDCLASS wcHidden =
        {
            0L,
            HiddenWndProc,
            0,
            0,
            GetModuleHandle(NULL),
            NULL,
            NULL,
            NULL,
            NULL,
            g_cszHiddenWndClassName
        };
        
        if (!RegisterClass(&wcHidden))
        {
            ERROR_OUT(("Could not register hidden wnd classes"));
            return FALSE;
        }

        // Create a hidden window for event processing:
        g_hwndHidden = ::CreateWindow(    g_cszHiddenWndClassName,
                                        _TEXT(""),
                                        WS_POPUP, // not visible!
                                        0, 0, 0, 0,
                                        NULL,
                                        NULL,
                                        GetModuleHandle(NULL),
                                        NULL);
    }

    if (NULL == g_hwndHidden)
    {
        ERROR_OUT(("Could not create hidden windows"));
        return FALSE;
    }

    // Place a 16x16 icon in the taskbar notification area:    
    NOTIFYICONDATA tnid;

    tnid.cbSize = sizeof(NOTIFYICONDATA);
    tnid.hWnd = g_hwndHidden;
    tnid.uID = ID_TASKBAR_ICON;
    tnid.uFlags = NIF_MESSAGE | NIF_ICON | NIF_TIP;
    tnid.uCallbackMessage = WM_TASKBAR_NOTIFY;
    tnid.hIcon = LoadIcon(GetModuleHandle(NULL), MAKEINTRESOURCE(IDI_SM_WORLD));

    ::LoadString(GetModuleHandle(NULL), IDS_MNMSRVC_TITLE,
        tnid.szTip, CCHMAX(tnid.szTip));

    // Attempt to add the icon. This may fail because there is no taskbar
    // (no user desktop shown). Warn if this is so... We will retry on
    // a periodic timer.

    if (FALSE == (bRet = Shell_NotifyIcon(NIM_ADD, &tnid)))
    {
        #ifdef DEBUG
        if ( !g_fTimerRunning )
           WARNING_OUT(("Could not add notify icon!"));
        #endif // DEBUG

        // Start the taskbar timer to periodically retry until this succeeds
        StartTaskbarTimer();
    }
    else
    {
        g_fTaskBarIconAdded = TRUE;
        KillTaskbarTimer(); // Kill timer if necessary
    }

    if (NULL != tnid.hIcon)
    {
        DestroyIcon(tnid.hIcon);
    }

    return bRet;
}

BOOL RemoveTaskbarIcon(VOID)
{
    NOTIFYICONDATA tnid;
    BOOL ret;

    if ( !g_fTaskBarIconAdded || NULL == g_hwndHidden )
    {
        return FALSE;
    }

    tnid.cbSize = sizeof(NOTIFYICONDATA);
    tnid.hWnd = g_hwndHidden;
    tnid.uID = ID_TASKBAR_ICON;

    ret = Shell_NotifyIcon(NIM_DELETE, &tnid);

    g_fTaskBarIconAdded = FALSE;

    if (g_hwndHidden)
    {
        DestroyWindow(g_hwndHidden);
        g_hwndHidden = NULL;
    }

    return ret;
}


BOOL OnRightClickTaskbar()
{
    TRACE_OUT(("OnRightClickTaskbar called"));

    POINT ptClick;
    if (FALSE == ::GetCursorPos(&ptClick))
    {
        ptClick.x = ptClick.y = 0;
    }
    
    // Get the menu for the popup from the resource file.
    HMENU hMenu = ::LoadMenu(GetModuleHandle(NULL), MAKEINTRESOURCE(IDR_TASKBAR_POPUP));
    if (NULL == hMenu)
    {
        return FALSE;
    }

    // Get the first menu in it which we will use for the call to
    // TrackPopup(). This could also have been created on the fly using
    // CreatePopupMenu and then we could have used InsertMenu() or
    // AppendMenu.
    HMENU hMenuTrackPopup = ::GetSubMenu(hMenu, 0);

    // Draw and track the "floating" popup 
    // According to the font view code, there is a bug in USER which causes
    // TrackPopupMenu to work incorrectly when the window doesn't have the
    // focus.  The work-around is to temporarily create a hidden window and
    // make it the foreground and focus window.

    HWND hwndDummy = ::CreateWindow(_TEXT("STATIC"), NULL, 0, 
                                    ptClick.x, 
                                    ptClick.y,
                                    1, 1, HWND_DESKTOP,
                                    NULL, GetModuleHandle(NULL), NULL);
    if (NULL != hwndDummy)
    {
        HWND hwndPrev = ::GetForegroundWindow();    // to restore

        TPMPARAMS tpmp;
        tpmp.cbSize = sizeof(tpmp);
        tpmp.rcExclude.right = 1 + (tpmp.rcExclude.left = ptClick.x);
        tpmp.rcExclude.bottom = 1 + (tpmp.rcExclude.top = ptClick.y);
        
        ::SetForegroundWindow(hwndDummy);
        ::SetFocus(hwndDummy);

        int iRet = ::TrackPopupMenuEx(    hMenuTrackPopup, 
                                                TPM_RETURNCMD | TPM_HORIZONTAL | TPM_RIGHTALIGN | 
                                                TPM_RIGHTBUTTON | TPM_LEFTBUTTON,
                                                ptClick.x, 
                                                ptClick.y,
                                                hwndDummy, 
                                                &tpmp);

        // Restore the previous foreground window (before destroying hwndDummy).
        if (hwndPrev)
        {
            ::SetForegroundWindow(hwndPrev);
        }

        ::DestroyWindow(hwndDummy);

        switch (iRet)
        {
            case IDM_TBPOPUP_STOP:
            {
                PostThreadMessage(g_dwMainThreadID, WM_QUIT, 0, 0);
                break;
            }

            default:
                break;
        }
    }

    // We are finished with the menu now, so destroy it
    ::RemoveMenu(hMenu, 0, MF_BYPOSITION);
    ::DestroyMenu(hMenuTrackPopup);
    ::DestroyMenu(hMenu);

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\remdsk\rds\t120\common\appenrol.cpp ===
#include "precomp.h"
#include "fsdiag.h"
DEBUG_FILEZONE(ZONE_T120_UTILITY);
/* 
 *	appenrol.cpp
 *
 *	Copyright (c) 1994 by DataBeam Corporation, Lexington, KY
 *
 *	Abstract:
 *		This is the implementation file for the class 
 *		ApplicationEnrollRequestData. 
 *
 *	Caveats:
 *		None.
 *
 *	Author:
 *		jbo
 */

#include "appenrol.h"

/*
 *	ApplicationEnrollRequestData ()
 *
 *	Public Function Description:
 *		This constructor is used to create a ApplicationEnrollRequestData object
 *		from an ApplicationEnrollRequestMessage in preparation for serializing
 *		the application enroll request data.
 */
ApplicationEnrollRequestData::ApplicationEnrollRequestData(
				PApplicationEnrollRequestMessage		enroll_request_message,
				PGCCError								pRetCode)
{
    GCCError rc = GCC_NO_ERROR;
	Session_Key_Data = NULL;
	Non_Collapsing_Caps_Data = NULL;
	Application_Capability_Data = NULL;

	/*
	 * Save the message structure in an instance variable.  This will save all
	 * structure elements except the session key and the lists of non-collapsing
	 * and application capabilities.
	 */
	Enroll_Request_Message = *enroll_request_message;

	/*
	 * Create a CSessKeyContainer object to be used to handle the session key
	 * contained in the enroll request message.
	 */
	if (Enroll_Request_Message.session_key != NULL)
	{
		DBG_SAVE_FILE_LINE
		Session_Key_Data = new CSessKeyContainer(
										Enroll_Request_Message.session_key,
										&rc);
		if ((Session_Key_Data != NULL) && (rc == GCC_NO_ERROR))
		{
			if (Enroll_Request_Message.number_of_non_collapsed_caps != 0)
			{
				/*
				 * Create a CNonCollAppCap object to hold the non-
				 * collapsing capabilities.
				 */
				DBG_SAVE_FILE_LINE
				Non_Collapsing_Caps_Data = new CNonCollAppCap(	
							(ULONG) Enroll_Request_Message.number_of_non_collapsed_caps,
							Enroll_Request_Message.non_collapsed_caps_list,
							&rc);
				if (Non_Collapsing_Caps_Data == NULL)
				{
					rc = GCC_ALLOCATION_FAILURE;
				}
				else if (rc != GCC_NO_ERROR)
				{
				    Non_Collapsing_Caps_Data->Release();
				    Non_Collapsing_Caps_Data = NULL;
				}
			}
			else
			{
				Non_Collapsing_Caps_Data = NULL;
			}

			if ((rc == GCC_NO_ERROR) &&
				(Enroll_Request_Message.number_of_collapsed_caps != 0))
			{
				/*
				 * Create an CAppCap object to hold the
				 * application capabilities.
				 */
				DBG_SAVE_FILE_LINE
				Application_Capability_Data = new CAppCap(
							(ULONG) Enroll_Request_Message.number_of_collapsed_caps,
							Enroll_Request_Message.collapsed_caps_list,
							&rc);
				if (Application_Capability_Data == NULL)
				{
					rc = GCC_ALLOCATION_FAILURE;
				}
				else if (rc != GCC_NO_ERROR)
				{
				    Application_Capability_Data->Release();
				    Application_Capability_Data = NULL;
				}
			}
			else
			{
				Application_Capability_Data = NULL;
			}
		}
		else if (Session_Key_Data == NULL)
		{
			rc = GCC_ALLOCATION_FAILURE;
		}
		else
		{
		    Session_Key_Data->Release();
		    Session_Key_Data = NULL;
		}
	}
	else
	{
		Session_Key_Data = NULL;
		Application_Capability_Data = NULL;
		Non_Collapsing_Caps_Data = NULL;

		/*
		**	Note that if no session key is present there is no need to pass
		**	any capability information.
		*/
		Enroll_Request_Message.number_of_non_collapsed_caps = 0;
		Enroll_Request_Message.non_collapsed_caps_list = NULL;
		Enroll_Request_Message.number_of_collapsed_caps = 0;
		Enroll_Request_Message.collapsed_caps_list = NULL;
	}

    *pRetCode = rc;
}

/*
 *	ApplicationEnrollRequestData ()
 *
 *	Public Function Description:
 *		This constructor is used to create a ApplicationEnrollRequestData object
 *		from an ApplicationEnrollRequestMessage and the memory holding the
 *		enroll request's serialized data in preparation for deserializing
 *		the application enroll request data.
 */
ApplicationEnrollRequestData::ApplicationEnrollRequestData(
				PApplicationEnrollRequestMessage		enroll_request_message)
{
	Session_Key_Data = NULL;
	Non_Collapsing_Caps_Data = NULL;
	Application_Capability_Data = NULL;

	/*
	 * Save the message structure in an instance variable.  This will save all
	 * structure elements but not the data associated with the session key and 
	 * the lists of non-collapsing and application capabilities.
	 */
	Enroll_Request_Message = *enroll_request_message;

}

/*
 *	~ApplicationEnrollRequestData	()
 *
 *	Public Function Description
 *		The ApplicationEnrollRequestData destructor.
 *
 */
ApplicationEnrollRequestData::~ApplicationEnrollRequestData()
{
	/*
	 * Delete any internal data objects which may exist.
	 */
	if (NULL != Session_Key_Data)
	{
	    Session_Key_Data->Release();
	}

	if (NULL != Non_Collapsing_Caps_Data)
	{
	    Non_Collapsing_Caps_Data->Release();
	}

	if (NULL != Application_Capability_Data)
	{
	    Application_Capability_Data->Release();
	}
}

/*
 *	GetDataSize ()
 *
 *	Public Function Description
 *		This routine is used to determine the amount of memory necessary to
 *		hold all of the data associated with an ApplicationEnrollRequestMessage
 *		that is not held within the message strucuture.
 */
ULONG ApplicationEnrollRequestData::GetDataSize(void)
{
	ULONG data_size = 0;

	/*
	 * The first data referenced by the enroll request message is the data for
	 * the session key.  Use the internal CSessKeyContainer object to determine
	 * the length of the data referenced by the session key.  Also add the size
	 * of the actual session key structure.
	 */
	if (Session_Key_Data != NULL)
	{
		data_size += Session_Key_Data->LockSessionKeyData();
		data_size += ROUNDTOBOUNDARY (sizeof(GCCSessionKey));
	}

	/*
	 * Now determine the length of the list of non-collapsing capabilities and
	 * the length of the list of application capabilities.  This is done using
	 * the internal CNonCollAppCap and CAppCap objects.
	 */
	if (Non_Collapsing_Caps_Data != NULL)
	{
		data_size += Non_Collapsing_Caps_Data->LockCapabilityData();
	}

	if (Application_Capability_Data != NULL)
	{
		data_size += Application_Capability_Data->LockCapabilityData();
	}

	return (data_size);
}

/*
 *	Serialize ()
 *
 *	Public Function Description
 *		This routine is used to prepare an ApplicationEnrollRequest message
 *		for passing through shared memory.  The message structure is filled in
 *		and the data referenced by the structure written into the memory
 *		provided.
 */
ULONG ApplicationEnrollRequestData::Serialize(
					PApplicationEnrollRequestMessage	enroll_request_message,
	  				LPSTR								memory)
{
	ULONG	data_length;
	ULONG	total_data_length = 0;
	USHORT	app_capability_data_length;

	/*
	 * Copy the internal message structure into the output structure.  This will
	 * copy all	structure elements except the session key and the lists of 
	 * non-collapsing and application capabilities.
	 */
	*enroll_request_message = Enroll_Request_Message;

	if (Session_Key_Data != NULL)
	{
		/*
		 * Set the pointer to the session key structure.
		 */
		enroll_request_message->session_key = (PGCCSessionKey)memory;

		/*
		 * Move the memory pointer past the session key structure.
		 */
		memory += ROUNDTOBOUNDARY(sizeof(GCCSessionKey));

		/*
		 * Retrieve the session key data from the internal CSessKeyContainer 
		 * object.  It will serialize the necessary data into memory and return 
		 * the amount of data written.
		 */
		data_length = Session_Key_Data->GetGCCSessionKeyData (
								enroll_request_message->session_key, memory);

		total_data_length = data_length + ROUNDTOBOUNDARY(sizeof(GCCSessionKey));

		/*
		 * Move the memory pointer past the session key data.
		 */
		memory += data_length;
		Session_Key_Data->UnLockSessionKeyData();
	}
	else
    {
		enroll_request_message->session_key = NULL;
    }

	/*
	 * Retrieve the non-collapsing capabilities data from the internal
	 * CNonCollAppCap object.  It will serialize the necessary data
	 * into memory and return the amount of memory written.
	 */
	if (Non_Collapsing_Caps_Data != NULL)
	{
		data_length = Non_Collapsing_Caps_Data->GetGCCNonCollapsingCapsList (	
			&enroll_request_message->non_collapsed_caps_list,
			memory);
	
		total_data_length += data_length;

		/*
		 * Move the memory pointer past the non-collapsing capabilities and the
		 * associated data.
		 */
		memory += data_length;
		Non_Collapsing_Caps_Data->UnLockCapabilityData();
	}
	else
    {
		enroll_request_message->non_collapsed_caps_list = NULL;
    }
	
	if (Application_Capability_Data != NULL)
	{
		/*
		 * Retrieve the application capabilities from the internal 
		 * CAppCap object.  It will serialize the necessary data
		 * into memory and return the amount of memory written.
		 */
		total_data_length += Application_Capability_Data->
				GetGCCApplicationCapabilityList(
					&app_capability_data_length,
					&enroll_request_message->collapsed_caps_list,
					memory);
		Application_Capability_Data->UnLockCapabilityData();
	}

	diagprint1("AppEnrollReqData: Serialized %ld bytes", total_data_length);
	return (total_data_length);
}

/*
 *	Deserialize ()
 *
 *	Public Function Description
 *		This routine is used to retrieve an ApplicationEnrollRequest message
 *		after it has been passed through shared memory.
 */
void ApplicationEnrollRequestData::Deserialize(
					PApplicationEnrollRequestMessage	enroll_request_message)
{
	/*
	 * The internal structure contains the enroll request data with the pointers
	 * addressing the correct locations in memory so just copy the structure
	 * into the output parameter.
	 */
	*enroll_request_message = Enroll_Request_Message; 
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\remdsk\rds\t120\common\hash.cpp ===
/*	hash.cpp
 *
 *	Copyright (c) 1996 by Microsoft Corporation
 *
 *  Written by:	 Christos Tsollis
 *
 *  Revisions:
 *		
 *	Abstract:
 *
 *	This is the implementation of a dictionary data structure.  
 *
 */

#include "precomp.h"
DEBUG_FILEZONE(ZONE_T120_UTILITY);

#define MyMalloc(size)	new BYTE[size]
#define MyFree(ptr)		(delete [] (BYTE *) (ptr))
#define Max(a,b)		(((a) > (b)) ? (a) : (b))


/*  Function:  Constructor
 *
 *	Parameters:
 *		num_of_buckets:		Number of buckets in the dictionary
 *		dtype:				Dictionary type
 *
 *	Return value:
 *		None
 */

DictionaryClass::DictionaryClass (ULong num_of_buckets, DictionaryType dtype) :
	Type (dtype), NumOfExternItems (0)
{
	DWORD				i;	
	PDICTIONARY_ITEM	p;	// Goes through the initially allocated dictionary items to initialize the stack

	NumOfBuckets = Max (num_of_buckets, DEFAULT_NUMBER_OF_BUCKETS);

	/* Allocate the space needed for the dictionary */
	dwNormalSize = NumOfBuckets * (4 * sizeof (PDICTIONARY_ITEM) + 3 * sizeof (DICTIONARY_ITEM));
	Buckets = (PDICTIONARY_ITEM *) MyMalloc (dwNormalSize);
	if (Buckets == NULL)
		return;

	/* Initialize the Buckets */
	for (i = 0; i < NumOfBuckets; i++)
		Buckets[i] = NULL;

	// Initialize the class iterator
	pCurrent = NULL;

	/* Initialize the Dictionary items array.
	 * This is a stack of pointers to the real dictionary items. The stack is initialized with
	 * the addresses of the dictionary items
	 */ 

	ItemArray = (PDICTIONARY_ITEM *) ((PBYTE) Buckets + NumOfBuckets * sizeof (PDICTIONARY_ITEM));
	ItemCount = 3 * NumOfBuckets;

	p = (PDICTIONARY_ITEM) (ItemArray + ItemCount);
	for (i = 0; i < ItemCount; i++)
		ItemArray[i] = p++;
}


/*  Function:  Copy Constructor
 *
 *	Parameters:
 *		original:	The original dictionary to make a copy of 
 *
 *	Return value:
 *		None
 *
 *	Note:
 *		This copy constructor will work ONLY for DWORD_DICTIONARY dictionaries.
 *		It will NOT work for the string dictionary types.
 */


DictionaryClass::DictionaryClass (const DictionaryClass& original)
{
	DWORD			 i;
	PDICTIONARY_ITEM p, q, r;

	NumOfBuckets = original.NumOfBuckets;
	Type = original.Type;
	NumOfExternItems = original.NumOfExternItems;

	// Allocate the space needed for the dictionary
	dwNormalSize = original.dwNormalSize;
	Buckets = (PDICTIONARY_ITEM *) MyMalloc (dwNormalSize);
	if (Buckets == NULL)
		return;

	// Initialize the class iterator
	pCurrent = NULL;

	/* Initialize the Dictionary items array */
	ItemArray = (PDICTIONARY_ITEM *) ((PBYTE) Buckets + NumOfBuckets * sizeof (PDICTIONARY_ITEM));
	ItemCount = 3 * NumOfBuckets;

	// Traverse the whole original hash sturcture to create the copy
	// p: goes through the original items
	// q: goes through current instance's items and initializes them
	// r: remembers the previous item in the new instance so that its "next" field could be set

	q = (PDICTIONARY_ITEM) (ItemArray + ItemCount);
	for (q--, i = 0; i < NumOfBuckets; i++) {
		for (r = NULL, p = original.Buckets[i]; p != NULL; p = p->next) {
			
			// Check if there are unused items in the current dictionary
			if (ItemCount <= 0) {
				q = (PDICTIONARY_ITEM) MyMalloc (sizeof (DICTIONARY_ITEM));
				if (q == NULL)
					break;
			}
			else {
				ItemCount--;
				q++;
			}

			q->value = p->value;
			q->key = p->key;
			if (p == original.Buckets[i])
				Buckets[i] = q;
			else
				r->next = q;
			r = q;
		}

		// Set the "next" field for the last item in the bucket
		if (r == NULL)
			Buckets[i] = NULL;
		else
			r->next = NULL;
	}

	// Initialize the rest of the ItemArray array
	for (i = 0; i < ItemCount; i++)
		ItemArray[i] = q++;

}


/*  Function:  Destructor
 *
 *	Parameters:
 *		None.
 *
 *	Return value:
 *		None
 *
 */


DictionaryClass::~DictionaryClass ()
{
	DWORD			 i;
	DWORD			 dwOffset;		// Offset of the dictionary item.  If the offset does not indicate
									// that the item is from the initially allocated array, it has to 
									// be freed.
	PDICTIONARY_ITEM p, q;

	if (Buckets != NULL) {

		// Go through the buckets to free the non-native items
		for (i = 0; i < NumOfBuckets; i++)
			for (p = Buckets[i]; p != NULL; ) {
				if (Type >= STRING_DICTIONARY)
					MyFree (p->key);
				dwOffset = (PBYTE) p - (PBYTE) Buckets;
				if (dwOffset >= 0 && dwOffset < dwNormalSize)
					p = p->next;
				else {  
					// if the item was not allocated in the initialization, we should free it.
					q = p;
					p = p->next;	
					MyFree (q);
				}
			}
					
		MyFree (Buckets);
		Buckets = NULL;
	}
}


/*  Function:  hashFunction
 *
 *	Parameters:
 *		key:	The key value
 *
 *	Return value:
 *		An integer in the range [0..NumOfBuckets-1] that indicates the bucket used for the "key".
 *
 */


DWORD DictionaryClass::hashFunction (DWORD key) 
{
	if (Type < STRING_DICTIONARY)
		return (key % NumOfBuckets);
	else
		return (*((unsigned char *) key) % NumOfBuckets);
}


/*  Function:  LengthStrcmp
 *
 *	Parameters:
 *		DictionaryKey:	Pointer to dictionary storage that keeps a length-sensitive string (which
 *						is a length followed by a string of that length.
 *		ChallengeKey:	Pointer to the length-sensitive key that is compared with the "DictionaryKey"
 *		length:			The length of the "ChallengeKey" string
 *
 *	Return value:
 *		0 if the "DictionaryKey" and "ChallengeKey" strings are the same. 1, otherwise.
 *
 *	Note:
 *		This function is only used for dictionaries of type LENGTH_STRING_DICTIONARY.
 */

int DictionaryClass::LengthStrcmp (DWORD DictionaryKey, DWORD ChallengeKey, ULong length)
{
	ULong					 i;
	char					*pDictionaryChar;	// Goes through the dictionary key string
	char					*pChallengeChar;	// Goes through the challenge string

	// Compare the lengths first
	if (length != * (ULong *) DictionaryKey)
		return 1;

	// Now, compare the strings themselves
	pDictionaryChar	= (char *) (DictionaryKey + sizeof (ULong));
	pChallengeChar = (char *) ChallengeKey;
	for (i = 0; i < length; i++)
		if (*pDictionaryChar++ != *pChallengeChar++)
			return 1;

	return 0;
}


/*  Function:  insert
 *		Inserts (key, value) pair in the dictionary
 *
 *	Parameters:
 *		new_key:	The new key that has to be inserted in the dictionary
 *		new_value:	The value associated with the "new_key"
 *		length:		Used only for LENGTH_STRING_DICTIONARY dictionaries; specifies the length of the new key
 *
 *	Return value:
 *		TRUE, if the operation succeeds, FALSE, otherwise.
 *
 *	Note:
 *		If the "new_key" is already in the dictionary, the (new_key, new_value) pair is NOT
 *		inserted (the dictionary remains the same), and the return value is TRUE.
 */


BOOL DictionaryClass::insert (DWORD new_key, DWORD new_value, ULong length)
{
	PDICTIONARY_ITEM	pNewItem;			// Points to the allocated new dictionary item
	PDICTIONARY_ITEM	p;					// Goes through the bucket for the "new_key", searching for "new_key"
	DWORD				hash_val;			// The bucket ID for "new_key"
	BOOL				bIsNative = TRUE;	// TRUE, if the new allocated dictionary item is from the cache, FALSE otherwise

	if (Buckets == NULL)
		return FALSE;

	// Find if the item is already in the bucket, and if it's not, where it will get added.
	p = Buckets[hash_val = hashFunction (new_key)];

	ASSERT (hash_val >= 0 && hash_val < NumOfBuckets);

	if (p != NULL) {
		switch (Type) {
#if 0
		case STRING_DICTIONARY:
			ASSERT (length == 0);
			for (; lstrcmp ((LPCTSTR) p->key, (LPCTSTR) new_key) && p->next != NULL; p = p->next);
			if (0 == lstrcmp ((LPCTSTR) p->key, (LPCTSTR) new_key)) {
				// the key already exists; no need to add it
				return TRUE;
			}
			break;
#endif
		case LENGTH_STRING_DICTIONARY:
			ASSERT (length > 0);
			for (; LengthStrcmp (p->key, new_key, length) && p->next != NULL; p = p->next);
			if (0 == LengthStrcmp (p->key, new_key, length)) {
				// the key already exists; no need to add it
				return TRUE;
			}
			break;
		default:
			ASSERT (length == 0);
			for (; p->key != new_key && p->next != NULL; p = p->next);
			if (p->key == new_key) {
				// the key already exists; no need to add it
				return TRUE;
			}
			break;
		}
	}

	// Allocate the new item
	if (ItemCount > 0)
		pNewItem = ItemArray[--ItemCount];		// from the cache
	else {										// the cache is empty, we have to malloc the new item
		pNewItem = (PDICTIONARY_ITEM) MyMalloc (sizeof (DICTIONARY_ITEM));
		if (pNewItem != NULL) {
			bIsNative = FALSE;
			NumOfExternItems++;
		}
		else {
			return FALSE;
		}
	}

	ASSERT (pNewItem != NULL);

	// Fill in the "key" field of the new item
	switch (Type) {
#if 0
	case STRING_DICTIONARY:
		ASSERT (length == 0);
		pNewItem->key = (DWORD) MyMalloc ((lstrlen ((LPCTSTR) new_key) + 1) * sizeof(TCHAR));
		if (pNewItem->key == (DWORD) NULL) {
			if (bIsNative == FALSE) {
				// We have to free the allocated hash item
				MyFree (pNewItem);
				NumOfExternItems--;
			}
			else
				ItemCount++;
			return FALSE;
		}
		lstrcpy ((LPTSTR) pNewItem->key, (LPCTSTR) new_key);
		break;
#endif

	case LENGTH_STRING_DICTIONARY:
		ASSERT (length > 0);
		pNewItem->key = (DWORD) MyMalloc (sizeof (ULong) + length * sizeof (TCHAR));
		if (pNewItem->key != (DWORD) NULL) {
			* ((ULong *) (pNewItem->key)) = length;
			memcpy ((void *) (pNewItem->key + sizeof (ULong)), (void *) new_key, length * sizeof (TCHAR));
		}
		else {
			if (bIsNative == FALSE) {
				// We have to free the allocated hash item
				MyFree (pNewItem);
				NumOfExternItems--;
			}
			else
				ItemCount++;
			return FALSE;
		}
		break;

	default:
		ASSERT (length == 0);
		pNewItem->key = new_key;
		break;
	}

	// Fill in the rest of the fields of the new item
	pNewItem->value = new_value;
	pNewItem->next = NULL;

	// Insert the item in its bucket
	if (p == NULL)
		Buckets[hash_val] = pNewItem;
	else
		p->next = pNewItem;

	return TRUE;
}


/*  Function:  remove
 *		Removes (key, value) pair from the dictionary
 *
 *	Parameters:
 *		Key:	The key that has to be removed from the dictionary
 *		length:	Used only for LENGTH_STRING_DICTIONARY dictionaries; specifies the length of the "Key"
 *
 *	Return value:
 *		None.
 *
 */

BOOL DictionaryClass::remove (DWORD Key, ULong length)
{
	PDICTIONARY_ITEM	p, q;		// They go through the dictionary items in "Key"'s bucket.
									// p: points to the current dictionary item in the bucket
									// q: points to the previous item
	DWORD				hash_val;	// The bucket ID for "Key"
	
	if (Buckets != NULL) {

		// Find the item in the dictionary
		p = Buckets [hash_val = hashFunction (Key)];

		ASSERT (hash_val >= 0 && hash_val < NumOfBuckets);

		switch (Type) {
#if 0
		case STRING_DICTIONARY:
			ASSERT (length == 0);
			for (q = NULL; p != NULL && lstrcmp ((LPCTSTR) p->key, (LPCTSTR) Key); p = (q = p)->next) ;
			break;
#endif

		case LENGTH_STRING_DICTIONARY:
			ASSERT (length > 0);
			for (q = NULL; p != NULL && LengthStrcmp (p->key, Key, length); p = (q = p)->next) ;
			break;

		default:
			ASSERT (length == 0);
			for (q = NULL; p != NULL && p->key != Key; p = (q = p)->next);
			break;
		}

		// Remove the item 
		if (p != NULL) {
			if (q == NULL) 
				Buckets[hash_val] = p->next;
			else
				q->next = p->next;

			// Free the item found
			ASSERT (p != NULL);

			if (Type >= STRING_DICTIONARY)
				MyFree (p->key);
			hash_val = (PBYTE) p - (PBYTE) Buckets;
			if (hash_val >= 0 && hash_val < dwNormalSize)
				ItemArray[ItemCount++] = p;
			else {
				MyFree (p);
				NumOfExternItems--;
			}
			return TRUE;
		}
	}
	return FALSE;
}


/* Function:  find
 *		Looks up the key in the dictionary
 * 
 * Parameters
 *		Key:	The key to lookup
 *		pValue: Pointer to receive the value associated with "Key"
 *				It can be NULL, if we just try to find whether "Key" is in the dictionary
 *		length:	Used only for LENGTH_STRING_DICTIONARY dictionaries; specifies the length of "Key"
 *
 * Return value: 
 *		FALSE, if "Key" is not found in the dictionary
 *		TRUE, otherwise.
 */

BOOL DictionaryClass::find (DWORD Key, LPDWORD pValue, ULong length)
{
	PDICTIONARY_ITEM	p;		// Goes through the dictionary items in "Key"'s bucket.

	if (Buckets != NULL) {
		// Find the item in the dictionary
		p = Buckets [hashFunction (Key)];

		switch (Type) {
#if 0
		case STRING_DICTIONARY:
			ASSERT (length == 0);
			for (; p != NULL && lstrcmp ((LPCTSTR) p->key, (LPCTSTR) Key); p = p->next) ;
			break;
#endif

		case LENGTH_STRING_DICTIONARY:
			ASSERT (length > 0);
			for (; p != NULL && LengthStrcmp (p->key, Key, length); p = p->next) ;
			break;

		default:
			ASSERT (length == 0);
			for (; p != NULL && p->key != Key; p = p->next);
			break;
		}

		if (p != NULL) {
			// "Key" was found
			if (pValue != NULL)
				*pValue = p->value;
			return TRUE;
		}
	}

	if (pValue != NULL)
		*pValue = 0;
	return FALSE;

}

LPVOID DictionaryClass::Find(DWORD Key, UINT length)
{
	LPVOID Val;
	return find(Key, (LPDWORD) &Val, (ULONG) length) ? Val : NULL; 
}


/* Function:  iterate
 *		Iterates through the items of a dictionary.  It remembers where it has 
 *		stopped during the last call and starts from there.
 * 
 * Parameters
 *		pValue:	Pointer to DWORD that will hold the next value from the dictionary.
 *				It can be NULL.
 *		pKey:	Pointer to DWORD or unsigned short value to receive the key associated with the value.
 *				It can be NULL.
 *
 * Return value: 
 *		FALSE, when we reach the end of the dictionary
 *		TRUE, otherwise.  Then, *pKey and *pValue are valid
 *
 */

BOOL DictionaryClass::iterate (LPDWORD pValue, LPDWORD pKey)
{

	if (Buckets != NULL) {
		if (pCurrent) {
			pCurrent = pCurrent->next;
		}
		else {
			// start from the 1st item in the dictionary
			pCurrent = Buckets[ulCurrentBucket = 0];
		}

		// Advance "pCurrent" until it's not NULL, or we reach the end of the dictionary.
		for (; ulCurrentBucket < NumOfBuckets; pCurrent = Buckets[++ulCurrentBucket]) {
			if (pCurrent != NULL) {
				// we found the next item
				if (pKey)
					*pKey = pCurrent->key;
				if (pValue)
					*pValue = pCurrent->value;
				return TRUE;
			}
		}
	}

	pCurrent = NULL;
	return FALSE;
}

LPVOID DictionaryClass::Iterate(LPDWORD pKey)
{
	LPVOID Val;
	return iterate((LPDWORD) &Val, pKey) ? Val : NULL;
}

/* Function:  isEmpty
 * 
 * Parameters
 *		None.
 *
 * Return value: 
 *		TRUE, if the dictionary is empty.  FALSE, otherwise.
 *
 */

BOOL DictionaryClass::isEmpty (void)
{
	DWORD i;

	if (Buckets != NULL) {
		for (i = 0; i < NumOfBuckets; i++)
			if (Buckets[i] != NULL)
				return FALSE;
	}
	return TRUE;
}


/* Function:  clear
 *		Clears up the dictionary.  No (key, value) pairs are left in the dictionary.
 * 
 * Parameters:
 *		None.
 *
 * Return value: 
 *		None.
 *
 */

void DictionaryClass::clear (void)
{

	DWORD			 i;			// Goes through the "Buckets" array
	DWORD			 dwOffset;	// The offset of a dictionary item is used to determine
								// whether it's a native item (that needs to be returned to the cache),
								// or not (and needs to be freed).
	PDICTIONARY_ITEM p, q;		// Go through the items in a bucket

	if (Buckets != NULL) {
		// Go through the buckets to free the non-native items
		for (i = 0; i < NumOfBuckets; i++) {
			for (p = Buckets[i]; p != NULL; ) {
				if (Type >= STRING_DICTIONARY) 
					MyFree (p->key);

				// Compute the offset of the current dictionary item
				dwOffset = (PBYTE) p - (PBYTE) Buckets;
				if (dwOffset >= 0 && dwOffset < dwNormalSize)
					p = p->next;
				else {  
					// if the item was not allocated in the initialization, we should free it.
					q = p;
					p = p->next;	
					MyFree (q);
				}
			}
			Buckets[i] = NULL;
		}

		// Initialize the class iterator
		pCurrent = NULL;

		/* Initialize the Dictionary items array */
		ItemCount = 3 * NumOfBuckets;
		p = (PDICTIONARY_ITEM) (ItemArray + ItemCount);
		for (i = 0; i < ItemCount; i++)
			ItemArray[i] = p++;

		NumOfExternItems = 0;
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\remdsk\rds\t120\common\ms_util.cpp ===
#include "precomp.h"


CRefCount::CRefCount(DWORD dwStampID)
:
#ifndef SHIP_BUILD
    m_dwStampID(dwStampID),
#endif
    m_cRefs(1),
    m_cLocks(0)
{
}


// though it is pure virtual, we still need to have a destructor.
CRefCount::~CRefCount(void)
{
}


LONG CRefCount::AddRef(void)
{
    ASSERT(0 < m_cRefs);
    ::InterlockedIncrement(&m_cRefs);
    return m_cRefs;
}


LONG CRefCount::Release(void)
{
    ASSERT(NULL != this);
    ASSERT(0 < m_cRefs);
    if (0 == ::InterlockedDecrement(&m_cRefs))
    {
        ASSERT(0 == m_cLocks);
        delete this;
        return 0;
    }
    return m_cRefs;
}


void CRefCount::ReleaseNow(void)
{
    ASSERT(NULL != this);
    ASSERT(0 < m_cRefs);
    m_cRefs = 0;
    delete this;
}


LONG CRefCount::Lock(void)
{
    AddRef();
    ASSERT(0 <= m_cLocks);
    ::InterlockedIncrement(&m_cLocks);
    return m_cLocks;
}


LONG CRefCount::Unlock(BOOL fRelease)
{
    ASSERT(0 < m_cLocks);
    ::InterlockedDecrement(&m_cLocks);
    LONG c = m_cLocks; // in case Release() frees the object
    if (fRelease)
    {
        Release();
    }
    return c;
}


UINT My_strlenA(LPCSTR pszSrc)
{
	UINT cch = 0;
	if (NULL != pszSrc)
	{
		cch = lstrlenA(pszSrc);
	}
	return cch;
}

#if defined(_DEBUG)
LPSTR _My_strdupA(LPCSTR pszSrc, LPSTR pszFileName, UINT nLineNumber)
#else
LPSTR My_strdupA(LPCSTR pszSrc)
#endif
{
	if (NULL == pszSrc)
	{
		return NULL;
	}

	UINT cch = lstrlenA(pszSrc) + 1;
#if defined(_DEBUG)
	LPSTR pszDst = (LPSTR) DbgMemAlloc(cch, NULL, pszFileName, nLineNumber);
#else
	LPSTR pszDst = new char[cch];
#endif
	if (NULL != pszDst)
	{
		CopyMemory(pszDst, pszSrc, cch);
	}
	return pszDst;
}

UINT My_strlenW(LPCWSTR pszSrc)
{
	UINT cch = 0;
	if (NULL != pszSrc)
	{
		cch = lstrlenW(pszSrc);
	}
	return cch;
}

#if defined(_DEBUG)
LPWSTR _My_strdupW(LPCWSTR pszSrc, LPSTR pszFileName, UINT nLineNumber)
#else
LPWSTR My_strdupW(LPCWSTR pszSrc)
#endif
{
	if (NULL == pszSrc)
	{
		return NULL;
	}

	UINT cch = lstrlenW(pszSrc) + 1;
#if defined(_DEBUG)
	LPWSTR pszDst = (LPWSTR) DbgMemAlloc(cch * sizeof(WCHAR), NULL, pszFileName, nLineNumber);
#else
	LPWSTR pszDst = new WCHAR[cch];
#endif
	if (NULL != pszDst)
	{
		CopyMemory(pszDst, pszSrc, cch * sizeof(WCHAR));
	}
	return pszDst;
}

//
// LONCHANC: This is to provide backward compatibility to UnicodeString
// in protocol structures. hopefully, we can remove this hack later.
//
#if defined(_DEBUG)
LPWSTR _My_strdupW2(UINT cchSrc, LPCWSTR pszSrc, LPSTR pszFileName, UINT nLineNumber)
#else
LPWSTR My_strdupW2(UINT cchSrc, LPCWSTR pszSrc)
#endif
{
#if defined(_DEBUG)
	LPWSTR pwsz = (LPWSTR) DbgMemAlloc((cchSrc+1) * sizeof(WCHAR), NULL, pszFileName, nLineNumber);
#else
	LPWSTR pwsz = new WCHAR[cchSrc+1];
#endif
	if (NULL != pwsz)
	{
		CopyMemory(pwsz, pszSrc, cchSrc * sizeof(WCHAR));
	}
	pwsz[cchSrc] = 0;
	return pwsz;
}

int My_strcmpW(LPCWSTR pwsz1, LPCWSTR pwsz2)
{
	if (NULL == pwsz1 || NULL == pwsz2)
	{
		return -1;
	}

	WCHAR ch;
	while (0 == (ch = *pwsz1 - *pwsz2) &&
			NULL != *pwsz1++ &&
			NULL != *pwsz2++)
		;

	return (int) ch;
}


#if defined(_DEBUG)
LPOSTR _My_strdupO2(LPBYTE lpbSrc, UINT cOctets, LPSTR pszFileName, UINT nLineNumber)
#else
LPOSTR My_strdupO2(LPBYTE lpbSrc, UINT cOctets)
#endif
{
#if defined(_DEBUG)
	LPOSTR poszDst = (LPOSTR) DbgMemAlloc(sizeof(OSTR) + cOctets + 1, NULL, pszFileName, nLineNumber);
#else
	LPOSTR poszDst = (LPOSTR) new char[sizeof(OSTR) + cOctets + 1];
#endif
	if (NULL != poszDst)
	{
		poszDst->length = cOctets;
		poszDst->value = (LPBYTE) (poszDst + 1);
		::CopyMemory(poszDst->value, lpbSrc, cOctets);
	}
	return poszDst;
}


INT My_strcmpO(LPOSTR posz1, LPOSTR posz2)
{
	if (NULL == posz1 || NULL == posz2)
	{
		return -1;
	}

	if (posz1->length != posz2->length)
	{
		return -1;
	}

	UINT cnt = posz1->length;
	LPBYTE lpb1 = posz1->value, lpb2 = posz2->value;
	BYTE b = 0;
	while (cnt--)
	{
		if (0 != (b = *lpb1++ - *lpb2++))
		{
			break;
		}
	}
	return (INT) b;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\remdsk\rds\t120\common\cntlist.cpp ===
#include "precomp.h"
#include "cntlist.h"


CList::CList(void)
:
    m_fQueue(FALSE),
    m_cMaxEntries(CLIST_DEFAULT_MAX_ITEMS)
{
    Init(1);
}


CList::CList(ULONG cMaxItems)
:
    m_fQueue(FALSE),
    m_cMaxEntries(cMaxItems)
{
    Init(1);
}


CList::CList(ULONG cMaxItems, ULONG cSubItems)
:
    m_fQueue(FALSE),
    m_cMaxEntries(cMaxItems)
{
    Init(cSubItems);
}


CList::CList(ULONG cMaxItems, ULONG cSubItems, BOOL fQueue)
:
    m_fQueue(fQueue),
    m_cMaxEntries(cMaxItems)
{
    Init(cSubItems);
}


CList::CList(CList *pSrc)
:
    m_fQueue(pSrc->m_fQueue),
    m_cMaxEntries(pSrc->GetCount())
{

    Init(1);

    LPVOID p;
    pSrc->Reset();
    while (NULL != (p = pSrc->Iterate()))
    {
        Append(p);
    }
}


BOOL CList::Init(ULONG cSubItems)
{
    if (m_cMaxEntries < CLIST_DEFAULT_MAX_ITEMS)
    {
        m_cMaxEntries = CLIST_DEFAULT_MAX_ITEMS;
    }

    m_cEntries = 0;
    m_nHeadOffset = 0;
    m_nCurrOffset = CLIST_END_OF_ARRAY_MARK;
    m_cSubItems = cSubItems;

    // it is kind of bad here because there is no way to return an error.
    // unfortunately it won't fault here and later.
    DBG_SAVE_FILE_LINE
    m_aEntries = (LPVOID *) new char[m_cMaxEntries * m_cSubItems * sizeof(LPVOID)];
    CalcKeyArray();
    return m_aEntries ? TRUE : FALSE;
}


CList::~CList(void)
{
    delete m_aEntries;
}


void CList::CalcKeyArray(void)
{
    if (1 == m_cSubItems)
    {
        m_aKeys = NULL;
    }
    else
    {
        ASSERT(2 == m_cSubItems);
        m_aKeys = (NULL != m_aEntries) ?
                        (UINT_PTR *) &m_aEntries[m_cMaxEntries] :
                        NULL;
    }
}


BOOL CList::Expand(void)
{
    if (NULL == m_aEntries)
    {
        // it is impossible.
        ASSERT(FALSE);
        return Init(m_cSubItems);
    }

    // the current array is full
    ASSERT(m_cEntries == m_cMaxEntries);

    // remember the old array to free or to restore
    LPVOID  *aOldEntries = m_aEntries;

    // we need to allocate a bigger array to hold more data.
    // the new array has twice the size of the old one
    ULONG cNewMaxEntries = m_cMaxEntries << 1;
    DBG_SAVE_FILE_LINE
    m_aEntries = (LPVOID *) new char[cNewMaxEntries * m_cSubItems * sizeof(LPVOID)];
    if (NULL == m_aEntries)
    {
        // we failed; we have to restore the array and return
        m_aEntries = aOldEntries;
        return FALSE;
    }

    // copy the old entries into the new array, starting from the beginning
    ULONG nIdx = m_cMaxEntries - m_nHeadOffset;
    ::CopyMemory(m_aEntries, &aOldEntries[m_nHeadOffset], nIdx * sizeof(LPVOID));
    ::CopyMemory(&m_aEntries[nIdx], aOldEntries, m_nHeadOffset * sizeof(LPVOID));

    // set the new max entries (required for the key array)
    m_cMaxEntries = cNewMaxEntries;

    if (m_cSubItems > 1)
    {
        ASSERT(2 == m_cSubItems);
        UINT_PTR *aOldKeys = m_aKeys;
        CalcKeyArray();
        ::CopyMemory(m_aKeys, &aOldKeys[m_nHeadOffset], nIdx * sizeof(UINT));
        ::CopyMemory(&m_aKeys[nIdx], aOldKeys, m_nHeadOffset * sizeof(UINT));
    }

    // Free the old array of entries
    delete aOldEntries;

    // Set the instance variables
    m_nHeadOffset = 0;
    m_nCurrOffset = CLIST_END_OF_ARRAY_MARK;

    return TRUE;
}


BOOL CList::Append(LPVOID pData)
{
    if (NULL == m_aEntries || m_cEntries >= m_cMaxEntries)
    {
        if (! Expand())
        {
            return FALSE;
        }
    }

    ASSERT(NULL != m_aEntries);
    ASSERT(m_cEntries < m_cMaxEntries);

    m_aEntries[(m_nHeadOffset + (m_cEntries++)) % m_cMaxEntries] = pData;

    return TRUE;
}


BOOL CList::Prepend(LPVOID pData)
{
    if (NULL == m_aEntries || m_cEntries >= m_cMaxEntries)
    {
        if (! Expand())
        {
            return FALSE;
        }
    }

    ASSERT(NULL != m_aEntries);
    ASSERT(m_cEntries < m_cMaxEntries);

    m_cEntries++;
    m_nHeadOffset = (0 == m_nHeadOffset) ? m_cMaxEntries - 1 : m_nHeadOffset - 1;
    m_aEntries[m_nHeadOffset] = pData;

    return TRUE;
}


BOOL CList::Find(LPVOID pData)
{
    for (ULONG i = 0; i < m_cEntries; i++)
    {
        if (pData == m_aEntries[(m_nHeadOffset + i) % m_cMaxEntries])
        {
            return TRUE;
        }
    }
    return FALSE;
}


BOOL CList::Remove(LPVOID pData)
{
    ULONG nIdx, nIdxSrc;
    for (ULONG i = 0; i < m_cEntries; i++)
    {
        nIdx = (m_nHeadOffset + i) % m_cMaxEntries;
        if (pData == m_aEntries[nIdx])
        {
            if (! m_fQueue)
            {
                // to remove the current, we simply move the last to here.
                nIdxSrc = (m_nHeadOffset + (m_cEntries - 1)) % m_cMaxEntries;
                m_aEntries[nIdx] = m_aEntries[nIdxSrc];
                if (m_cSubItems > 1)
                {
                    ASSERT(2 == m_cSubItems);
                    m_aKeys[nIdx] = m_aKeys[nIdxSrc];
                }
            }
            else
            {
                // to preserve the ordering
                if (0 == i)
                {
                    m_nHeadOffset = (m_nHeadOffset + 1) % m_cMaxEntries;
                }
                else
                {
                    for (ULONG j = i + 1; j < m_cEntries; j++)
                    {
                        nIdx = (m_nHeadOffset + j - 1) % m_cMaxEntries;
                        nIdxSrc = (m_nHeadOffset + j) % m_cMaxEntries;
                        m_aEntries[nIdx] = m_aEntries[nIdxSrc];
                        if (m_cSubItems > 1)
                        {
                            ASSERT(2 == m_cSubItems);
                            m_aKeys[nIdx] = m_aKeys[nIdxSrc];
                        }
                    }
                }
            }

            m_cEntries--;
            return TRUE;
        }
    }
    return FALSE;
}


LPVOID CList::Get(void)
{
    LPVOID pRet = NULL;

    if (m_cEntries > 0)
    {
        pRet = m_aEntries[m_nHeadOffset];
        m_cEntries--;
        m_nHeadOffset = (m_nHeadOffset + 1) % m_cMaxEntries;
    }
    else
    {
        pRet = NULL;
    }
    return pRet;
}


LPVOID CList::Iterate(void)
{
    if (0 == m_cEntries)
    {
        return NULL;
    }

    if (m_nCurrOffset == CLIST_END_OF_ARRAY_MARK)
    {
        // start from the beginning
        m_nCurrOffset = 0;
    }
    else
    {
        if (++m_nCurrOffset >= m_cEntries)
        {
            // reset the iterator
            m_nCurrOffset = CLIST_END_OF_ARRAY_MARK;
            return NULL;
        }
    }

    return m_aEntries[(m_nHeadOffset + m_nCurrOffset) % m_cMaxEntries];
}





CList2::CList2(CList2 *pSrc)
:
    CList(pSrc->GetCount(), 2, pSrc->m_fQueue)
{
    CalcKeyArray();

    LPVOID p;
    UINT_PTR n;
    pSrc->Reset();
    while (NULL != (p = pSrc->Iterate(&n)))
    {
        Append(n, p);
    }
}


BOOL CList2::Append(UINT_PTR nKey, LPVOID pData)
{
    if (! CList::Append(pData))
    {
        return FALSE;
    }

    // after CList::append(), m_cEntries has been incremented,
    // therefore, we need decrement it again.
    m_aKeys[(m_nHeadOffset + (m_cEntries - 1)) % m_cMaxEntries] = nKey;
    return TRUE;
}


BOOL CList2::Prepend(UINT_PTR nKey, LPVOID pData)
{
    if (! CList::Prepend(pData))
    {
        return FALSE;
    }

    m_aKeys[m_nHeadOffset] = nKey;
    return TRUE;
}


LPVOID CList2::Find(UINT_PTR nKey)
{
    ULONG nIdx;
    for (ULONG i = 0; i < m_cEntries; i++)
    {
        nIdx = (m_nHeadOffset + i) % m_cMaxEntries;
        if (nKey == m_aKeys[nIdx])
        {
            return m_aEntries[nIdx];
        }
    }
    return NULL;
}


LPVOID CList2::Remove(UINT_PTR nKey)
{
    ULONG nIdx, nIdxSrc;
    for (ULONG i = 0; i < m_cEntries; i++)
    {
        nIdx = (m_nHeadOffset + i) % m_cMaxEntries;
        if (nKey == m_aKeys[nIdx])
        {
            LPVOID pRet = m_aEntries[nIdx];
            if (! m_fQueue)
            {
                // to remove the current, we simply move the last to here.
                nIdxSrc = (m_nHeadOffset + (m_cEntries - 1)) % m_cMaxEntries;
                m_aEntries[nIdx] = m_aEntries[nIdxSrc];
                m_aKeys[nIdx] = m_aKeys[nIdxSrc];
            }
            else
            {
                // to preserve the ordering
                if (0 == i)
                {
                    m_nHeadOffset = (m_nHeadOffset + 1) % m_cMaxEntries;
                }
                else
                {
                    for (ULONG j = i + 1; j < m_cEntries; j++)
                    {
                        nIdx = (m_nHeadOffset + j - 1) % m_cMaxEntries;
                        nIdxSrc = (m_nHeadOffset + j) % m_cMaxEntries;
                        m_aEntries[nIdx] = m_aEntries[nIdxSrc];
                        m_aKeys[nIdx] = m_aKeys[nIdxSrc];
                    }
                }
            }

            m_cEntries--;
            return pRet;
        }
    }
    return NULL;
}


LPVOID CList2::Get(UINT_PTR *pnKey)
{
    LPVOID pRet;
    if (m_cEntries > 0)
    {
        pRet = m_aEntries[m_nHeadOffset];
        *pnKey = m_aKeys[m_nHeadOffset];
        m_cEntries--;
        m_nHeadOffset = (m_nHeadOffset + 1) % m_cMaxEntries;
    }
    else
    {
        pRet = NULL;
        *pnKey = 0;
    }
    return pRet;
}


LPVOID CList2::PeekHead(UINT_PTR *pnKey)
{
    LPVOID pRet;
    if (m_cEntries > 0)
    {
        pRet = m_aEntries[m_nHeadOffset];
        *pnKey = m_aKeys[m_nHeadOffset];
    }
    else
    {
        pRet = NULL;
        *pnKey = 0;
    }
    return pRet;
}


LPVOID CList2::Iterate(UINT_PTR *pnKey)
{
    LPVOID p = CList::Iterate();
    *pnKey = (NULL != p) ? m_aKeys[(m_nHeadOffset + m_nCurrOffset) % m_cMaxEntries] : 0;
    return p;
}





#ifdef ENABLE_HASHED_LIST2

CHashedList2::CHashedList2(ULONG cBuckets, ULONG cInitItemsPerBucket)
:
    m_cBuckets(cBuckets),
    m_cInitItemsPerBucket(cInitItemsPerBucket),
    m_cEntries(0),
    m_nCurrBucket(0)
{
    m_aBuckets = new CList2* [m_cBuckets];
    ASSERT(NULL != m_aBuckets);
    if (NULL != m_aBuckets)
    {
        ::ZeroMemory(m_aBuckets, m_cBuckets * sizeof(CList2*));
    }
}


CHashedList2::CHashedList2(CHashedList2 *pSrc)
:
    m_cBuckets(pSrc->m_cBuckets),
    m_cInitItemsPerBucket(pSrc->m_cInitItemsPerBucket),
    m_cEntries(0),
    m_nCurrBucket(0)
{
    LPVOID p;
    UINT n;

    m_aBuckets = new CList2* [m_cBuckets];
    ASSERT(NULL != m_aBuckets);
    if (NULL != m_aBuckets)
    {
        ::ZeroMemory(m_aBuckets, m_cBuckets * sizeof(CList2*));
        pSrc->Reset();
        while (NULL != (p = pSrc->Iterate(&n)))
        {
            Insert(n, p);
        }
    }
}


CHashedList2::~CHashedList2(void)
{
    if (NULL != m_aBuckets)
    {
        for (ULONG i = 0; i < m_cBuckets; i++)
        {
            delete m_aBuckets[i];
        }
        delete [] m_aBuckets;
    }
}


BOOL CHashedList2::Insert(UINT nKey, LPVOID pData)
{
    if (NULL != m_aBuckets)
    {
        ULONG nBucket = GetHashValue(nKey);
        if (NULL == m_aBuckets[nBucket])
        {
            m_aBuckets[nBucket] = new CList2(m_cInitItemsPerBucket);
        }
        ASSERT(NULL != m_aBuckets[nBucket]);
        if (NULL != m_aBuckets[nBucket])
        {
            if (m_aBuckets[nBucket]->Append(nKey, pData))
            {
                m_cEntries++;
                return TRUE;
            }
        }
    }
    return FALSE;
}


LPVOID CHashedList2::Find(UINT nKey)
{
    if (NULL != m_aBuckets)
    {
        ULONG nBucket = GetHashValue(nKey);
        if (NULL != m_aBuckets[nBucket])
        {
            return m_aBuckets[nBucket]->Find(nKey);
        }
    }
    return NULL;
}


LPVOID CHashedList2::Remove(UINT nKey)
{
    if (NULL != m_aBuckets)
    {
        ULONG nBucket = GetHashValue(nKey);
        if (NULL != m_aBuckets[nBucket])
        {
            LPVOID pRet = m_aBuckets[nBucket]->Remove(nKey);
            if (NULL != pRet)
            {
                m_cEntries--;
                return pRet;
            }
        }
    }
    return NULL;
}


LPVOID CHashedList2::Get(UINT *pnKey)
{
    if (NULL != m_aBuckets)
    {
        if (m_cEntries)
        {
            for (ULONG i = 0; i < m_cBuckets; i++)
            {
                if (NULL != m_aBuckets[i])
                {
                    LPVOID pRet = m_aBuckets[i]->Get(pnKey);
                    if (NULL != pRet)
                    {
                        m_cEntries--;
                        return pRet;
                    }
                }
            }
        }
    }
    return NULL;
}


LPVOID CHashedList2::Iterate(UINT *pnKey)
{
    if (NULL != m_aBuckets)
    {
        for (ULONG i = m_nCurrBucket; i < m_cBuckets; i++)
        {
            if (NULL != m_aBuckets[i])
            {
                LPVOID pRet = m_aBuckets[i]->Iterate(pnKey);
                if (NULL != pRet)
                {
                    m_nCurrBucket = i;
                    return pRet;
                }
            }
        }
    }
    m_nCurrBucket = m_cBuckets; // over
    return NULL;
}


void CHashedList2::Reset(void)
{
    m_nCurrBucket = 0;

    if (NULL != m_aBuckets)
    {
        for (ULONG i = 0; i < m_cBuckets; i++)
        {
            if (NULL != m_aBuckets[i])
            {
                m_aBuckets[i]->Reset();
            }
        }
    }
}


void CHashedList2::Clear(void)
{
    m_cEntries = 0;
    m_nCurrBucket = 0;

    if (NULL != m_aBuckets)
    {
        for (ULONG i = 0; i < m_cBuckets; i++)
        {
            if (NULL != m_aBuckets[i])
            {
                m_aBuckets[i]->Clear();
            }
        }
    }
};


ULONG CHashedList2::GetHashValue(UINT nKey)
{
    const UINT PRIME_NUMBER_1 = 89;
    const UINT PRIME_NUMBER_2 = 13;
    return ((ULONG) (nKey * PRIME_NUMBER_1 + PRIME_NUMBER_2) % m_cBuckets);
}

#endif // ENABLE_HASHED_LIST2


=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\remdsk\rds\t120\common\precomp.h ===
#define INC_OLE2
#define IDS_NULL_STRING			(0)
#include <windows.h>
#include <tchar.h>
#include <databeam.h>

#include <memtrack.h>
#include <confdbg.h>

extern "C"
{
#include <t120.h>
}
#include <memmgr.h>
#include <mcattprt.h>
#include <ncmcs.h>
#include <ConfDbg.h>
#include <debspew.h>
#include <RegEntry.h>
#include <ConfReg.h>
#include <it120nc.h>

#include "fclasses.h"

#include "cntlist.h"
#include "clists.h"
#include "ms_util.h"
#include <fsdiag.h>

#include <spacket.h>
#include <packet.h>
#include <datapkt.h>
#include <cmdtar.h>
#include <attmnt.h>
#include <channel.h>
#include <tptif.h>
#include <domain.h>
#include <connect.h>
#include <user.h>

#include "pdutypes.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\remdsk\rds\t120\common\capid.cpp ===
#include "precomp.h"
#include "fsdiag.h"
DEBUG_FILEZONE(ZONE_T120_UTILITY);
/* 
 *	capid.cpp
 *
 *	Copyright (c) 1995 by DataBeam Corporation, Lexington, KY
 *
 *	Abstract:
 *		This is the implementation file for the class CCapIDContainer. 
 *		A CCapIDContainer object is used to maintain information about
 *		a particular capability of an application.  A capability identifier can
 *		be either a standard type or a non-standard type.  When the type is 
 *		standard, the identifier is stored internally as an integer value.  When
 *		the type is non-standard, an CObjectKeyContainer container object is used 
 *		internally to buffer the necessary data.  In this case the identifier 
 *		data may exist as an Object ID which is a series of non-negative 
 *		integers or an H221 non-standard ID which is an octet string of no fewer
 *		than four octets and no more than 255 octets. 
 *
 *	Protected Instance Variables:
 *		m_InternalCapID
 *			Structure used to hold the capability ID data internally.
 *		m_CapIDPDU
 *			Storage for the "PDU" form of the capability ID.
 *		m_fValidCapIDPDU
 *			Flag indicating that memory has been allocated to hold the internal
 *			"PDU" capability ID.
 *		m_cbDataSize
 *			Variable holding the size of the memory which will be required to
 *			hold any data referenced by the "API" GCCCapabilityID structure.
 *
 *	Caveats:
 *		None.
 *
 *	Author:
 *		blp/jbo
 */
#include "capid.h"

/*
 *	CCapIDContainer()
 *
 *	Public Function Description:
 *		This constructor is used to create a CCapIDContainer object 
 *		from an "API" GCCCapabilityID.
 */
CCapIDContainer::
CCapIDContainer(PGCCCapabilityID capability_id, PGCCError pRetCode)
:
    CRefCount(MAKE_STAMP_ID('C','a','p','I')),
    m_fValidCapIDPDU(FALSE),
    m_cbDataSize(0)
{
	GCCError rc = GCC_NO_ERROR;

	if (capability_id == NULL)
	{
		rc = GCC_INVALID_PARAMETER;
	}
	else
	{
	
		/*
		 * Save the GCCCapabilityID in the internal information structure.
		 */
		m_InternalCapID.capability_id_type = capability_id->capability_id_type;

		if (capability_id->capability_id_type == GCC_STANDARD_CAPABILITY)
		{
			m_InternalCapID.u.standard_capability = (USHORT) capability_id->standard_capability;
		}
		else
		{
			/*
			 * The object key portion of the capability ID is saved in an
			 * CObjectKeyContainer object.
			 */
			DBG_SAVE_FILE_LINE
			m_InternalCapID.u.non_standard_capability = 
					new CObjectKeyContainer(&capability_id->non_standard_capability, &rc);
			if (m_InternalCapID.u.non_standard_capability == NULL)
			{
				rc = GCC_ALLOCATION_FAILURE;
			}
			else if (rc == GCC_BAD_OBJECT_KEY)
		    {
				rc = GCC_BAD_CAPABILITY_ID;
			}
		}
	}

	*pRetCode = rc;
}

/*
 *	CCapIDContainer()
 *
 *	Public Function Description:
 *		This constructor is used to create a  CapabilityIdentifier object from
 *		a "PDU" CapabilityID.
 */
CCapIDContainer::
CCapIDContainer(PCapabilityID capability_id, PGCCError pRetCode)
:
    CRefCount(MAKE_STAMP_ID('C','a','p','I')),
    m_fValidCapIDPDU(FALSE),
    m_cbDataSize(0)
{
	GCCError rc = GCC_NO_ERROR;

	if (capability_id->choice == STANDARD_CHOSEN)
	{
		m_InternalCapID.capability_id_type = GCC_STANDARD_CAPABILITY;
		m_InternalCapID.u.standard_capability = capability_id->u.standard;
	}
	else
	{
		m_InternalCapID.capability_id_type = GCC_NON_STANDARD_CAPABILITY;
		DBG_SAVE_FILE_LINE
		m_InternalCapID.u.non_standard_capability =
		            new CObjectKeyContainer(&capability_id->u.capability_non_standard, &rc);
		if (m_InternalCapID.u.non_standard_capability == NULL)
		{
			rc = GCC_ALLOCATION_FAILURE;
		}
		else if (rc == GCC_BAD_OBJECT_KEY)
	    {
			rc = GCC_BAD_CAPABILITY_ID;
		}
	}

	*pRetCode = rc;
}

/*
 *	CCapIDContainer()
 *
 *	Public Function Description:
 *		This copy constructor is used to create a new CCapIDContainer 
 *		object from	another CCapIDContainer object.
 */
CCapIDContainer::
CCapIDContainer(CCapIDContainer *capability_id, PGCCError pRetCode)
:
    CRefCount(MAKE_STAMP_ID('C','a','p','I')),
    m_fValidCapIDPDU(FALSE),
    m_cbDataSize(0)
{
	GCCError rc = GCC_NO_ERROR;

	m_InternalCapID = capability_id->m_InternalCapID;

	if (m_InternalCapID.capability_id_type == GCC_NON_STANDARD_CAPABILITY)
	{
		DBG_SAVE_FILE_LINE
		m_InternalCapID.u.non_standard_capability =
			new CObjectKeyContainer(capability_id->m_InternalCapID.u.non_standard_capability, &rc);
		if (m_InternalCapID.u.non_standard_capability == NULL)
		{
			rc = GCC_ALLOCATION_FAILURE;
		}
		else if (rc == GCC_BAD_OBJECT_KEY)
	    {
			rc = GCC_BAD_CAPABILITY_ID;
		}
	}

	*pRetCode = rc;
}

/*
 *	~CCapIDContainer()
 *
 *	Public Function Description
 *		The CCapIDContainer destructor is responsible for freeing any 
 *		memory allocated to hold the capability ID data for both the "API" and 
 *		"PDU" forms.
 *
 */
CCapIDContainer::~CCapIDContainer(void)
{
	/*
	 * If "PDU" data has been allocated for this object, free it now.
	 */
	if (m_fValidCapIDPDU)
		FreeCapabilityIdentifierDataPDU ();

	/* 
	 * Delete any object key data held internally.
	 */
	if (m_InternalCapID.capability_id_type == GCC_NON_STANDARD_CAPABILITY)
	{
		if (NULL != m_InternalCapID.u.non_standard_capability)
		{
		    m_InternalCapID.u.non_standard_capability->Release();
		}
	}
}

/*
 *	LockCapabilityIdentifierData ()
 *
 *	Public Function Description:
 *		This routine locks the capability ID data and determines the amount of
 *		memory referenced by the "API" capability ID structure.
 */
UINT CCapIDContainer::LockCapabilityIdentifierData(void)
{
	/*
	 * If this is the first time this routine is called, determine the size of 
	 * the memory required to hold the data referenced by the capability ID
	 * structure.  Otherwise, just increment the lock count.
	 */
	if (Lock() == 1)
	{
		m_cbDataSize = 0;

		if (m_InternalCapID.capability_id_type == GCC_NON_STANDARD_CAPABILITY)
		{
			m_cbDataSize = m_InternalCapID.u.non_standard_capability->LockObjectKeyData (); 
		}
	}

	return m_cbDataSize;
}

/*
 *	GetGCCCapabilityIDData ()
 *
 *	Public Function Description:
 *		This routine retrieves capability ID data in the form of a 
 *		GCCCapabilityID.  This routine is called after "locking" the capability
 *		ID data.
 */
UINT CCapIDContainer::GetGCCCapabilityIDData(
							PGCCCapabilityID 		capability_id,
							LPBYTE					memory)
{
	UINT cbDataSizeToRet = 0;

	if (GetLockCount() > 0)
	{
		/*
		 * Fill in the output parameter which indicates the amount of memory
		 * used to hold all of the data associated with the capability ID.
		 */
		cbDataSizeToRet = m_cbDataSize;

		/*
		 * Fill in the "API" capability ID from the internal structure.  If an
		 * object key exists, get the object key data by calling the "Get" 
		 * routine of the internal CObjectKeyContainer object.
		 */
		capability_id->capability_id_type = m_InternalCapID.capability_id_type;

		if (m_InternalCapID.capability_id_type == GCC_STANDARD_CAPABILITY)
		{
			capability_id->standard_capability = m_InternalCapID.u.standard_capability; 
		}
		else
		{
			/*
			 * The call to get the object key data returns the amount of data
			 * written into memory.  We do not need this value right now.
			 */
			m_InternalCapID.u.non_standard_capability->   
					GetGCCObjectKeyData( 
							&capability_id->non_standard_capability,
							memory);
		}
	}
	else
	{
		ERROR_OUT(("CCapIDContainer::GetGCCCapabilityIDData: Error data not locked"));
	}

	return (cbDataSizeToRet);
}

/*
 *	UnlockCapabilityIdentifierData ()
 *
 *	Public Function Description:
 *		This routine decrements the internal lock count and frees the memory 
 *		associated with the "API" capability ID when the lock count hits zero.
 */
void CCapIDContainer::UnLockCapabilityIdentifierData(void)
{
	if (Unlock(FALSE) == 0)
	{
		if (m_InternalCapID.capability_id_type == GCC_NON_STANDARD_CAPABILITY)
		{
			m_InternalCapID.u.non_standard_capability->UnLockObjectKeyData(); 
		}
	}

    // we have to call Release() because we used Unlock(FALSE)
    Release();
}

/*
 *	GetCapabilityIdentifierDataPDU ()
 *
 *	Public Function Description:
 *		This routine converts the capability ID from it's internal form of an
 *		CAP_ID_STRUCT structure into the "PDU" form which can be 
 *		passed in to the ASN.1 encoder.  A pointer to a "PDU" "CapabilityID" 
 *		structure is returned.
 */
GCCError CCapIDContainer::GetCapabilityIdentifierDataPDU(PCapabilityID capability_id)
{
	GCCError rc = GCC_NO_ERROR;

	/*
	 * If this is the first time that PDU data has been requested then we must
	 * fill in the internal PDU structure and copy it into the structure pointed
	 * to by the output parameter.  On subsequent calls to "GetPDU" we can just
	 * copy the internal PDU structure into the structure pointed to by the
	 * output parameter.
	 */
	if (m_fValidCapIDPDU == FALSE)
	{
		m_fValidCapIDPDU = TRUE;

			if (m_InternalCapID.capability_id_type== GCC_STANDARD_CAPABILITY)
			{
				m_CapIDPDU.choice = STANDARD_CHOSEN;
				m_CapIDPDU.u.standard = m_InternalCapID.u.standard_capability;
			}
			else
			{
				m_CapIDPDU.choice = CAPABILITY_NON_STANDARD_CHOSEN;
				rc = m_InternalCapID.u.non_standard_capability->
							GetObjectKeyDataPDU(&m_CapIDPDU.u.capability_non_standard);
			}
	}

	/*
	 * Copy the internal PDU structure into the structure pointed to by the
	 * output parameter.
	 */
	*capability_id = m_CapIDPDU;

	return rc;
}

/*
 *	FreeCapabilityIdentifierDataPDU ()
 *
 *	Public Function Description:
 *		This routine is used to free the capability ID data held internally in
 *		the "PDU" form of a "CapabilityID".
 */
void CCapIDContainer::FreeCapabilityIdentifierDataPDU(void)
{
	if (m_fValidCapIDPDU)
	{
		/*
		 * Set the flag indicating that PDU session key data is no longer
		 * allocated.
		 */
		m_fValidCapIDPDU = FALSE;

		if (m_CapIDPDU.choice == CAPABILITY_NON_STANDARD_CHOSEN)
		{
			m_InternalCapID.u.non_standard_capability->FreeObjectKeyDataPDU();
		}
	}
}

/*
 *	operator== ()
 *
 *	Public Function Description:
 *		This routine is used to determine whether or not two Capibility ID's
 *		are equal in value.
 */
BOOL operator==(const CCapIDContainer& capability_id_1, const CCapIDContainer& capability_id_2)
{
	BOOL rc = FALSE;

	if (capability_id_1.m_InternalCapID.capability_id_type == 
						capability_id_2.m_InternalCapID.capability_id_type)
	{
		if (capability_id_1.m_InternalCapID.capability_id_type ==
														GCC_STANDARD_CAPABILITY)
		{
			if (capability_id_1.m_InternalCapID.u.standard_capability == 
					capability_id_2.m_InternalCapID.u.standard_capability)
			{
				rc = TRUE;
			}
		}
		else
		{
			if (*capability_id_1.m_InternalCapID.u.non_standard_capability == 
				*capability_id_2.m_InternalCapID.u.non_standard_capability)
			{
				rc = TRUE;
			}
		}
	}

	return rc;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\remdsk\rds\t120\common\memory.cpp ===
#include "precomp.h"
/*
 *	memory.cpp
 *
 *	Copyright (c) 1993 - 1995 by DataBeam Corporation, Lexington, KY
 *
 *	Abstract:
 *		This is the implementation file for the Memory class.  Instances of
 *		this class represent chunks of data that are passed through a system.
 *		This class is particularly useful in cases where a memory buffer
 *		needs to be used in several different places, none of which know
 *		about each other.  This is because this class encapsulates things
 *		like lock counts, which are useful for holding memory until
 *		everyone that needs it is through.
 *
 *		Note that this class does NOT do memory management.  It is told by
 *		a higher level memory manager where its buffers are, etc.  For this
 *		reason, this class does not do any platform specific calls.
 *
 *	IMPORTANT NOTE:
 *		This class SHOULD NEVER contain virtual member functions. This is
 *		because of the Init() member than can be called as the "constructor"
 *		of this class.
 *
 *	Private Instance Variables:
 *		Length
 *			This is the length of the reference buffer.
 *		Copy_Ptr
 *			This is the address of the allocated buffer that this object
 *			uses.
 *
 *	Private Member Functions:
 *		None.
 *
 *	Caveats:
 *		None.
 *
 *	Author:
 *		James P. Galvin, Jr.
 */

const char *MemorySignature = "T120Memr";

/*
 *	Memory ()
 *
 *	Public
 *
 *	Functional Description:
 *		This is the constructor for the Memory class.  It just initializes
 *		all instance variable, based on the passed in values.
 */
Memory::Memory (
		PUChar			reference_ptr,
		ULong			length,
		PUChar			copy_ptr) :
Length (length), 
Copy_Ptr (copy_ptr),
lLock (1),
m_priority (HIGHEST_PRIORITY)
{
	SIGNATURE_COPY(MemorySignature);
	
	/*
	 *	If the reference pointer is a valid pointer, then the pointer type
	 *	will be set to reference (indicating that the reference data has not
	 *	yet been copied).  If the reference pointer is NULL, then this is
	 *	a memory allocation with no associated reference data, so set the
	 *	pointer type to copy.
	 */
	if (reference_ptr != NULL)
		memcpy (Copy_Ptr, reference_ptr, (Int) Length);
}


/*
 *	Init ()
 *
 *	Public
 *
 *	Functional Description:
 *		This is the initializer for the Memory class, in the cases
 *		where the space for an object has been allocated, without
 *		calling the constructor.  It just initializes
 *		all instance variable, based on the passed in values.
 *
 *	NOTE: Because of this use of the Memory class, it should NOT
 *		contain any virtual functions.
 */
Void Memory::Init (
		PUChar			reference_ptr,
		ULong			length,
		MemoryPriority	priority,
		PUChar			copy_ptr)
{

	Length = length;
	Copy_Ptr = copy_ptr;
	lLock = 1;
	m_priority = priority;
	
	SIGNATURE_COPY(MemorySignature);
	
	/*
	 *	If the reference pointer is a valid pointer, then the pointer type
	 *	will be set to reference (indicating that the reference data has not
	 *	yet been copied).  If the reference pointer is NULL, then this is
	 *	a memory allocation with no associated reference data, so set the
	 *	pointer type to copy.
	 */
	if (reference_ptr != NULL)
		memcpy (Copy_Ptr, reference_ptr, (Int) Length);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\remdsk\rds\t120\common\t120dbg.cpp ===
// t120dbg.cpp

#include "precomp.h"

#ifdef _DEBUG

#define INIT_DBG_ZONE_DATA
#include "fsdiag.h"


VOID T120DiagnosticCreate(VOID)
{
	MLZ_DbgInit((PSTR *) &c_apszDbgZones[0],
				(sizeof(c_apszDbgZones) / sizeof(c_apszDbgZones[0])) - 1);
}

VOID T120DiagnosticDestroy(VOID)
{
	MLZ_DbgDeInit();
}

#endif /* _DEBUG */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\remdsk\rds\t120\common\objkey.cpp ===
#include "precomp.h"
DEBUG_FILEZONE(ZONE_T120_UTILITY);
/* 
 *	objkey.cpp
 *
 *	Copyright (c) 1995 by DataBeam Corporation, Lexington, KY
 *
 *	Abstract:
 *		This is the implementation file for the class CObjectKeyContainer.  This class 
 *		manages the data associated with an Object Key.  Object Key's are used 
 *		to identify a particular application protocol, whether it is standard or
 *		non-standard.  When used to identify a standard protocol, the Object Key
 *		takes the form of an Object ID which is a series of non-negative 
 *		integers.  This type of Object Key is maintained internally through the
 *		use of a Memory object.  When used to identify a non-standard 
 *		protocol, the Object Key takes the form of an H221 non-standard ID which
 *		is an octet string of no fewer than four octets and no more than 255 
 *		octets.  In this case the Object Key is maintained internally by using a
 *		Rogue Wave string object. 
 *
 *	Protected Instance Variables:
 *		m_InternalObjectKey
 *			Structure used to hold the object key data internally.
 *		m_ObjectKeyPDU
 *			Storage for the "PDU" form of the object key.
 *		m_fValidObjectKeyPDU
 *			Flag indicating that memory has been allocated to hold the internal
 *			"PDU" object key.
 *		m_cbDataSize
 *			Variable holding the size of the memory which will be required to
 *			hold any data referenced by the "API" GCCObjectKey structure.
 *
 *	Caveats:
 *		None.
 *
 *	Author:
 *		jbo
 */
#include "objkey.h"

/*
 *	CObjectKeyContainer()
 *
 *	Public Function Description:
 *		This constructor is used to create an CObjectKeyContainer object from
 *		an "API" GCCObjectKey.
 */
CObjectKeyContainer::CObjectKeyContainer(PGCCObjectKey		 	object_key,
						                PGCCError				pRetCode)
:
    CRefCount(MAKE_STAMP_ID('O','b','j','K')),
    m_fValidObjectKeyPDU(FALSE),
    m_cbDataSize(0)
{
	GCCError                rc = GCC_NO_ERROR;
	BOOL    				object_key_is_valid = TRUE;
	UINT					object_id_size;

	m_InternalObjectKey.object_id_key = NULL;
	m_InternalObjectKey.poszNonStandardIDKey = NULL;

	/*
	 * Check to see what type of key is contained in the object key.
	 * Object ID keys will be stored internally in a Memory object and
	 * non-standard ID keys will be stored internally as Octet Strings.
	 */
	if (object_key->key_type == GCC_OBJECT_KEY)
	{
		/*
		 * The key is of type object ID.  Perform a parameter check for a legal
		 * object ID by examining the first two arcs in the object ID.
		 */
		if (object_key->object_id.long_string_length >= MINIMUM_OBJECT_ID_ARCS)
		{
			object_key_is_valid = ValidateObjectIdValues(
					object_key->object_id.long_string[0],
					object_key->object_id.long_string[1]);
		}
		else
		{
			object_key_is_valid = FALSE;
		}

		if (object_key_is_valid)
		{
			/*
			 * The key is of type Object ID.  Determine the amount of memory
			 * required to hold the Object ID and allocate it.  Copy the Object
			 * ID values from the object key passed in into the internal
			 * structure. 
			 */
			m_InternalObjectKey.object_id_length = object_key->object_id.long_string_length;
			object_id_size = m_InternalObjectKey.object_id_length * sizeof(UINT);
            DBG_SAVE_FILE_LINE
			m_InternalObjectKey.object_id_key = new BYTE[object_id_size];
			if (m_InternalObjectKey.object_id_key != NULL)
			{
				::CopyMemory(m_InternalObjectKey.object_id_key,
				             object_key->object_id.long_string,
				             object_id_size);
			}
			else
			{
				ERROR_OUT(("CObjectKeyContainer::CObjectKeyContainer: Error allocating memory"));
				rc = GCC_ALLOCATION_FAILURE;
			}
		}
		else
		{
			ERROR_OUT(("CObjectKeyContainer::CObjectKeyContainer: Object ID has illegal values."));
			rc = GCC_BAD_OBJECT_KEY;
		}
	}
	else
	{
		/*
		 * The key is non-standard.  Check to make sure the length of the 
		 * non-standard ID is within the allowable limits.
		 */
		if ((object_key->h221_non_standard_id.length >= 
					MINIMUM_NON_STANDARD_ID_LENGTH) &&
			(object_key->h221_non_standard_id.length <= 
					MAXIMUM_NON_STANDARD_ID_LENGTH))
		{
			/*
			 * The key is of type H221 non-standard ID.  Create a new Rogue
			 * Wave string container to hold the non-standard data.
			 */
			if (NULL == (m_InternalObjectKey.poszNonStandardIDKey = ::My_strdupO2(
				 				object_key->h221_non_standard_id.value,
				 				object_key->h221_non_standard_id.length)))
			{
				ERROR_OUT(("CObjectKeyContainer::CObjectKeyContainer: Error creating non standard id key"));
				rc = GCC_ALLOCATION_FAILURE;
			}
		}
		else
		{
			ERROR_OUT(("CObjectKeyContainer::CObjectKeyContainer:  Non standard ID is outside legal range"));
			rc = GCC_BAD_OBJECT_KEY;
		}
	}

    *pRetCode = rc;
}

/*
 *	CObjectKeyContainer()
 *
 *	Public Function Description:
 *		This constructor is used to create an CObjectKeyContainer object from
 *		a "PDU" Key.
 */
CObjectKeyContainer::CObjectKeyContainer(PKey				object_key,
						                PGCCError			pRetCode)
:
    CRefCount(MAKE_STAMP_ID('O','b','j','K')),
    m_fValidObjectKeyPDU(FALSE),
    m_cbDataSize(0)
{
	GCCError            rc = GCC_NO_ERROR;
	PSetOfObjectID		object_id_set_ptr;
	UINT               *object_id_ptr;
	UINT				object_id_size = 0;
	Int					i = 0;

	m_InternalObjectKey.object_id_key = NULL;
	m_InternalObjectKey.object_id_length = 0;
	m_InternalObjectKey.poszNonStandardIDKey = NULL;

	/*
	 * Check to see what type of key is contained in the object key.
	 * Object ID keys will be stored internally in a Memory object and
	 * non-standard ID keys will be stored internally in Rogue Wave string
	 * containers.
	 */
	if (object_key->choice == OBJECT_CHOSEN)
	{
		/*
		 * Retrieve the first object ID pointer from the "PDU" structure in
		 * preparation for determining how much memory will be needed to hold
		 * the object ID values.
		 */
		object_id_set_ptr = object_key->u.object;

		/*
		 * Loop through the ObjectID structure, adding up the size of the 
		 * string.
		 */
		while (object_id_set_ptr != NULL)
		{
			m_InternalObjectKey.object_id_length++;
			object_id_set_ptr = object_id_set_ptr->next;
		}

		object_id_size = m_InternalObjectKey.object_id_length * sizeof(UINT);

		/*
		 * Allocate the memory to be used to hold the object ID values.
		 */
		DBG_SAVE_FILE_LINE
		m_InternalObjectKey.object_id_key = new BYTE[object_id_size];
		if (m_InternalObjectKey.object_id_key != NULL)
		{
			object_id_ptr = (UINT *) m_InternalObjectKey.object_id_key;

			/*
			 * Again retrieve the first object ID pointer from the "PDU" 
			 * structure in	order to get the values out for saving.
			 */
			object_id_set_ptr = object_key->u.object;

			/*
			 * Loop through the ObjectID structure, getting each object ID
			 * value and saving it in the allocated memory.
			 */
			while (object_id_set_ptr != NULL)
			{
				object_id_ptr[i++] = object_id_set_ptr->value;
				object_id_set_ptr = object_id_set_ptr->next;
			}
		} 
		else
		{
			ERROR_OUT(("CObjectKeyContainer::CObjectKeyContainer: Error allocating memory."));
			rc = GCC_ALLOCATION_FAILURE;
		}
	}
	else
	{
		/*
		 * The key is of type H221 non-standard ID so create a new Rogue Wave
		 * string container to hold the data.
		 */
		if (NULL == (m_InternalObjectKey.poszNonStandardIDKey = ::My_strdupO2(
						object_key->u.h221_non_standard.value,
						object_key->u.h221_non_standard.length)))
		{
			ERROR_OUT(("CObjectKeyContainer::CObjectKeyContainer: Error creating non standard id key"));
			rc = GCC_ALLOCATION_FAILURE;
		}
	}

    *pRetCode = rc;
}

/*
 *	CObjectKeyContainer()
 *
 *	Public Function Description:
 *		This copy constructor is used to create a new CObjectKeyContainer object from
 *		another CObjectKeyContainer object.
 */
CObjectKeyContainer::CObjectKeyContainer(CObjectKeyContainer	*object_key,
						                PGCCError				pRetCode)
:
    CRefCount(MAKE_STAMP_ID('O','b','j','K')),
    m_fValidObjectKeyPDU(FALSE),
    m_cbDataSize(0)
{
	GCCError    rc = GCC_NO_ERROR;
	UINT		object_id_size;

	m_InternalObjectKey.object_id_key = NULL;
	m_InternalObjectKey.poszNonStandardIDKey = NULL;

	/*
	 * If an object ID "key" exists for the CObjectKeyContainer to be copied,
	 * allocate memory to hold the object ID "key" information internally.
	 * Check to make sure construction of the object is successful.
	 */
	if (object_key->m_InternalObjectKey.object_id_key != NULL)
	{
		/*
		 * The key is of type Object ID.
		 */
		m_InternalObjectKey.object_id_length = object_key->m_InternalObjectKey.object_id_length;
		object_id_size = m_InternalObjectKey.object_id_length * sizeof(UINT);

        DBG_SAVE_FILE_LINE
		m_InternalObjectKey.object_id_key = new BYTE[object_id_size];
		if (m_InternalObjectKey.object_id_key != NULL)
		{
			::CopyMemory(m_InternalObjectKey.object_id_key,
			             object_key->m_InternalObjectKey.object_id_key,
			             object_id_size);
		}
		else
		{
			ERROR_OUT(("CObjectKeyContainer::CObjectKeyContainer: Error allocating memory"));
			rc = GCC_ALLOCATION_FAILURE;
		}
	}
	else if (object_key->m_InternalObjectKey.poszNonStandardIDKey != NULL)
	{
		/*
		 * If a non-standard ID "key" exists for the CObjectKeyContainer to be copied,
		 * create a new Rogue Wave string to hold the non-standard "key" 
		 * information internally.  Check to make sure construction of the
		 * object is successful.
		 */
		if (NULL == (m_InternalObjectKey.poszNonStandardIDKey = ::My_strdupO(
							object_key->m_InternalObjectKey.poszNonStandardIDKey)))
		{
			ERROR_OUT(("CObjectKeyContainer::CObjectKeyContainer: Error creating new non standard id key"));
			rc = GCC_ALLOCATION_FAILURE;
		}
	}
	else
	{
		/*
		 * At least one of the internal pointers for the passed in object key 
		 * must be valid.
		 */
		ERROR_OUT(("CObjectKeyContainer::CObjectKeyContainer: Bad input parameters"));
		rc = GCC_BAD_OBJECT_KEY;
	}

    *pRetCode = rc;
}

/*
 *	~CObjectKeyContainer()
 *
 *	Public Function Description
 *		The CObjectKeyContainer destructor is responsible for freeing any memory
 *		allocated to hold the object key data.
 *
 */
CObjectKeyContainer::~CObjectKeyContainer(void)
{
	/*
	 * If "PDU" data has been allocated for this object, free it now.
	 */
	if (m_fValidObjectKeyPDU)
	{
		FreeObjectKeyDataPDU();
	}

	/* 
	 * Delete any object key data held internally.
	 */
	delete m_InternalObjectKey.object_id_key;
	delete m_InternalObjectKey.poszNonStandardIDKey;
}

/*
 *	LockObjectKeyData ()
 *
 *	Public Function Description:
 *		This routine locks the object key data and determines the amount of
 *		memory referenced by the "API" object key data structure.
 */
UINT CObjectKeyContainer::LockObjectKeyData(void)
{
	/*
	 * If this is the first time this routine is called, determine the size of 
	 * the memory required to hold the data referenced by the object key
	 * structure.  Otherwise, just increment the lock count.
	 */
	if (Lock() == 1)
	{
		/*
		 * Determine the amount of space required to hold the data referenced
		 * by the "API" Object Key structure.
		 */
		if (m_InternalObjectKey.object_id_key != NULL)
		{
			/*
			 * Since the object ID is just a series of "longs" without a NULL
			 * terminator, we do not want to include a NULL terminator when 
			 * determining the length.
			 */
			m_cbDataSize = m_InternalObjectKey.object_id_length * sizeof(UINT);
		}
		else
		{
			/*
			 * The data referenced by the non-standard object key is just the
			 * length of the octet string.
			 */
			m_cbDataSize = m_InternalObjectKey.poszNonStandardIDKey->length;
		}

		/*
		 * Force the size to be on a four-byte boundary.
		 */
		m_cbDataSize = ROUNDTOBOUNDARY(m_cbDataSize);
	}

	return m_cbDataSize;
}

/*
 *	GetGCCObjectKeyData ()
 *
 *	Public Function Description:
 *		This routine retrieves object key data in the form of an "API"
 *		GCCObjectKey.  This routine is called after "locking" the object 
 *		key data.
 */
UINT CObjectKeyContainer::GetGCCObjectKeyData(
								PGCCObjectKey 		object_key,
								LPBYTE				memory)
{
	UINT	cbDataSizeToRet = 0;
	UINT   *object_id_ptr;

	/*
	 * If the object key data has been locked, fill in the output structure and
	 * the data referenced by the structure.  Otherwise, report that the object
	 * key has yet to be locked into the "API" form.
	 */ 
	if (GetLockCount() > 0)
	{
		/*
		 * Fill in the output length parameter which indicates how much data
		 * referenced outside the structure will be written.
		 */
		cbDataSizeToRet = m_cbDataSize;

		if (m_InternalObjectKey.object_id_key != NULL)
		{
			/*
			 * The object key is a standard type.  Set the object key type 
			 * and the length of the long string. The length set here does 
			 * not include a NULL terminator.
			 */
			object_key->key_type = GCC_OBJECT_KEY;
			object_key->object_id.long_string_length = (USHORT) m_InternalObjectKey.object_id_length;

			/*
			 * Set the offset for the long string equal to the memory pointer
			 * passed in since it will be the first data referenced by the 
			 * object key structure.
			 */
			object_key->object_id.long_string = (ULONG *) memory;

			/*
			 * Now retrieve the memory pointer and copy the long string data 
			 * from the internal memory object.  
			 */		
			object_id_ptr = (UINT *) m_InternalObjectKey.object_id_key;

			::CopyMemory(memory, object_id_ptr, 
						m_InternalObjectKey.object_id_length * sizeof (UINT));
		}
		else if (m_InternalObjectKey.poszNonStandardIDKey != NULL)
		{
			/*
			 * The object key is a non-standard type.  Set the object key 
			 * type and the length of the octet string.
			 */
			object_key->key_type = GCC_H221_NONSTANDARD_KEY;
			object_key->h221_non_standard_id.length =
						m_InternalObjectKey.poszNonStandardIDKey->length;

			/*
			 * Set the offset for the octet string equal to the memory pointer
			 * passed in since it will be the first data referenced by the 
			 * object key structure.
			 */
			object_key->h221_non_standard_id.value = memory;

			/*
			 * Now copy the octet string data from the internal Rogue Wave
			 * string into the object key structure held in memory.
			 */		
			::CopyMemory(memory, m_InternalObjectKey.poszNonStandardIDKey->value,
									m_InternalObjectKey.poszNonStandardIDKey->length);
		}
		else
		{
			ERROR_OUT(("CObjectKeyContainer::LockObjectKeyData: Error, no valid internal data"));
		}
	}
	else
	{
		object_key = NULL;
		ERROR_OUT(("CObjectKeyContainer::GetGCCObjectKeyData: Error Data Not Locked"));
	}

	return cbDataSizeToRet;
}

/*
 *	UnLockObjectKeyData ()
 *
 *	Public Function Description:
 *		This routine decrements the lock count and frees the memory associated
 *		with the "API" object key once the lock count reaches zero.
 */
void CObjectKeyContainer::UnLockObjectKeyData(void)
{
    Unlock();
}

/*
 *	GetObjectKeyDataPDU ()
 *
 *	Public Function Description:
 *		This routine converts the object key from it's internal form of an
 *		OBJECT_KEY structure into the "PDU" form which can be passed in
 *		to the ASN.1 encoder.  A pointer to a "PDU" "Key" structure is 
 *		returned.
 */
GCCError CObjectKeyContainer::GetObjectKeyDataPDU(PKey object_key)
{
	PSetOfObjectID			new_object_id_ptr;
	PSetOfObjectID			old_object_id_ptr;
	UINT                   *object_id_string;
	GCCError				rc = GCC_NO_ERROR;
	UINT					i;

	/*
	 * Set the loop pointer to NULL to avoid a compiler warning.
	 */
    old_object_id_ptr = NULL;

	/*
	 * If this is the first time that PDU data has been requested then we must
	 * fill in the internal PDU structure and copy it into the structure pointed
	 * to by the output parameter.  On subsequent calls to "GetPDU" we can just
	 * copy the internal PDU structure into the structure pointed to by the
	 * output parameter.
	 */
	if (m_fValidObjectKeyPDU == FALSE)
	{
		m_fValidObjectKeyPDU = TRUE;

		/*
		 * Fill in the "PDU" object key after checking to see what form of 
		 * key exists in the internal structure.
		 */
		if (m_InternalObjectKey.object_id_key != NULL)
		{
			/*
			 * The key is an object ID so set the choice accordingly and 
			 * initialize the PDU object pointer to NULL.  Get the pointer to
			 * the internal list of object key values stored in the memory
			 * object.
			 */
			m_ObjectKeyPDU.choice = OBJECT_CHOSEN;
			m_ObjectKeyPDU.u.object = NULL;

			object_id_string = (UINT *) m_InternalObjectKey.object_id_key;

			/*
			 * The "PDU" structure "ObjectID" is a linked list of unsigned
			 * longs.  Retrieve the Object ID values from the internal memory
			 * object and fill in the "ObjectID" structure. 
			 */
			for (i=0; i<m_InternalObjectKey.object_id_length; i++)
			{
				DBG_SAVE_FILE_LINE
				new_object_id_ptr = new SetOfObjectID;
				if (new_object_id_ptr != NULL)
				{
					/*
					 * The first time through the new pointer is saved in the
					 * PDU structure.  On subsequent iterations, the previous
					 * "next" pointer is set equal to the new pointer.
					 */
					if (m_ObjectKeyPDU.u.object == NULL)
                    {
						m_ObjectKeyPDU.u.object = new_object_id_ptr;
                    }
					else
                    {
						old_object_id_ptr->next = new_object_id_ptr;
                    }

                    old_object_id_ptr = new_object_id_ptr;

					/*
					 * Save the actual Object ID value.
					 */
					new_object_id_ptr->value = object_id_string[i];
					new_object_id_ptr->next = NULL;
				}
				else
				{
					ERROR_OUT(("CObjectKeyContainer::GetObjectKeyDataPDU: creating new ObjectID"));
					rc = GCC_ALLOCATION_FAILURE;
					break;
				}
			}
		}
		else if (m_InternalObjectKey.poszNonStandardIDKey != NULL)
		{
			/*
			 * The key is a non-standard ID so convert the internal Rogue Wave
			 * string into the "PDU" non-standard ID.
			 */
			m_ObjectKeyPDU.choice = H221_NON_STANDARD_CHOSEN;
			m_ObjectKeyPDU.u.h221_non_standard.length =
					m_InternalObjectKey.poszNonStandardIDKey->length;

			::CopyMemory(m_ObjectKeyPDU.u.h221_non_standard.value,
							m_InternalObjectKey.poszNonStandardIDKey->value,
							m_InternalObjectKey.poszNonStandardIDKey->length);
		}
		else
		{
			/*
			 * The constructors make sure that at least one of the internal
			 * pointers is valid so this should never be encountered.
			 */
			ERROR_OUT(("CObjectKeyContainer::GetObjectKeyDataPDU: No valid m_InternalObjectKey"));
			rc = GCC_ALLOCATION_FAILURE;
		}
	}

	/*
	 * Copy the internal PDU structure into the structure pointed to by the
	 * output parameter.
	 */
	*object_key = m_ObjectKeyPDU;

	return rc;
}

/*
 *	FreeObjectKeyDataPDU ()
 *
 *	Public Function Description:
 *		This routine is used to free the object key data held internally in
 *		the "PDU" form of a "Key".
 */
void CObjectKeyContainer::FreeObjectKeyDataPDU(void)
{
	PSetOfObjectID		set_of_object_id;
	PSetOfObjectID		next_set_of_object_id;

	if (m_fValidObjectKeyPDU)
	{
		/*
		 * Set the flag indicating that PDU object key data is no longer
		 * allocated.
		 */
		m_fValidObjectKeyPDU = FALSE;

		if (m_ObjectKeyPDU.choice == OBJECT_CHOSEN)
		{
            for (set_of_object_id = m_ObjectKeyPDU.u.object;
                    set_of_object_id != NULL;
					set_of_object_id = next_set_of_object_id)
            {
				next_set_of_object_id = set_of_object_id->next;
				delete set_of_object_id;
			}
		}
	}
}

/*
 *	operator== ()
 *
 *	Public Function Description:
 *		This routine is used to compare two CObjectKeyContainer objects to determine
 *		if they are equal in value.
 */
BOOL operator==(const CObjectKeyContainer& object_key_1, const CObjectKeyContainer& object_key_2)
{
	UINT       *object_id_1, *object_id_2;
	UINT		i;
	BOOL    	rc = FALSE;
	
	/*
	 * Check to make sure that both the object ID key and the non-standard
	 * ID key are equal.
	 */
	if ((object_key_1.m_InternalObjectKey.object_id_key != NULL) && 
			(object_key_2.m_InternalObjectKey.object_id_key != NULL))
	{
		if (object_key_1.m_InternalObjectKey.object_id_length == 
				object_key_2.m_InternalObjectKey.object_id_length)
		{
			object_id_1 = (UINT *) object_key_1.m_InternalObjectKey.object_id_key;
			object_id_2 = (UINT *) object_key_2.m_InternalObjectKey.object_id_key;

			/*
			 * Compare each Object ID value to make sure they are equal.
			 */
			rc = TRUE;
			for (i=0; i<object_key_1.m_InternalObjectKey.object_id_length; i++)
			{
				if (object_id_1[i] != object_id_2[i])
				{
					rc = FALSE;
					break;
				}
			}
		}
	} 
	else
	if (0 == My_strcmpO(object_key_1.m_InternalObjectKey.poszNonStandardIDKey,
						object_key_2.m_InternalObjectKey.poszNonStandardIDKey))
	{
		rc = TRUE;
	} 

	return rc;
}

/*
 *	BOOL    	ValidateObjectIdValues (	UINT		first_arc,
 *											UINT		second_arc);
 *
 *	Private member function of CObjectKeyContainer.
 *
 *	Function Description:
 *		This routine is used to determine whether or not the values for the
 *		object ID component of the object key are valid.
 *
 *	Formal Parameters:
 *		first_arc			(i) The first integer value of the Object ID.
 *		second_arc			(i) The second integer value of the Object ID.
 *
 *	Return Value:
 *		TRUE				-	The first two arcs of the Object ID are valid.
 *		FALSE				- 	The first two arcs of the Object ID are not 
 *									valid.
 *
 *  Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */
BOOL CObjectKeyContainer::ValidateObjectIdValues(UINT first_arc, UINT second_arc)
{
	BOOL rc = FALSE;

	if (first_arc == ITUT_IDENTIFIER)
	{
		if (0 <= second_arc && second_arc <= 4)
		{
			rc = TRUE;
		} 
	}
	else if (first_arc == ISO_IDENTIFIER)
	{
		if ((second_arc == 0L) ||
			(second_arc == 2L) ||
			(second_arc == 3L))
		{
			rc = TRUE;
		} 
	}
	else if (first_arc == JOINT_ISO_ITUT_IDENTIFIER)
	{
		/*
		 * Referring to ISO/IEC 8824-1 : 1994 (E) Annex B:
		 * Join assignment of OBJECT IDENTIFIER component values are assigned
		 * and agreed from time to time by ISO and ITU-T to identify areas of
		 * joint ISO/ITU-T standardization activity, in accordance with the
		 * procedures of .... ANSI.  So we just let them all through for now.
		 */
		rc = TRUE;
	}
	else
	{
		ERROR_OUT(("ObjectKeyData::ValidateObjectIdValues: ObjectID is invalid"));
	}

	return rc;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\remdsk\rds\t120\common\sesskey.cpp ===
#include "precomp.h"
#include "fsdiag.h"
DEBUG_FILEZONE(ZONE_T120_UTILITY);
/* 
 *	sesskey.cpp
 *
 *	Copyright (c) 1995 by DataBeam Corporation, Lexington, KY
 *
 *	Abstract:
 *		This is the implementation file for the class CSessKeyContainer. This class 
 *		manages the data associated with a Session Key. Session Key's are used
 *		to uniquely identify an Application Protocol Session.  The Application
 *		Protocol is identified by an Object Key and the particular session
 *		identified by an optional session ID.  The CSessKeyContainer class uses an
 *		CObjectKeyContainer container to maintain the object key data internally.  An
 *		unsigned short integer is used to hold the optional session ID. 
 *
 *	Protected Instance Variables:
 *		m_InternalSessKey
 *			Structure used to hold the object key data internally.
 *		m_SessionKeyPDU
 *			Storage for the "PDU" form of the session key.
 *		m_fValidSessionKeyPDU
 *			Flag indicating that memory has been allocated to hold the internal
 *			"PDU" session key.
 *		m_cbDataSize
 *			Variable holding the size of the memory which will be required to
 *			hold any data referenced by the "API" GCCSessionKey structure.
 *
 *	Caveats:
 *		None.
 *
 *	Author:
 *		jbo
 */


#include "sesskey.h"

/*
 *	CSessKeyContainer()
 *
 *	Public Function Description:
 *		This constructor is used to create a CSessKeyContainer object from
 *		an "API" GCCSessionKey.
 */
CSessKeyContainer::
CSessKeyContainer(PGCCSessionKey session_key, PGCCError pRetCode)
:
    CRefCount(MAKE_STAMP_ID('S','e','s','K')),
    m_fValidSessionKeyPDU(FALSE),
    m_cbDataSize(0)
{
    GCCError rc;

	/*
	 * Save the Object Key portion of the Session Key in the internal structure
	 * by creating a new CObjectKeyContainer object.  Check to make sure the object
	 * is successfully created.
	 */
	DBG_SAVE_FILE_LINE
	m_InternalSessKey.application_protocol_key = new CObjectKeyContainer(
										&session_key->application_protocol_key,
										&rc);
	if (NULL != m_InternalSessKey.application_protocol_key && GCC_NO_ERROR == rc)
	{
    	/*
    	 * Save the session ID if the CObjectKeyContainer was saved correctly.  A zero 
    	 * value of the GCC session ID will indicate that one is not actually
    	 * present.
    	 */
    	m_InternalSessKey.session_id = session_key->session_id;
	}
	else if (GCC_BAD_OBJECT_KEY == rc)
	{
		ERROR_OUT(("CSessKeyContainer::SessionKeyData1: bad session key"));
		rc = GCC_BAD_SESSION_KEY;
	}
	else
	{
		ERROR_OUT(("CSessKeyContainer::SessionKeyData1: Error creating new CObjectKeyContainer"));
		rc = GCC_ALLOCATION_FAILURE;
	}

    *pRetCode = rc;
}

/*
 *	CSessKeyContainer()
 *
 *	Public Function Description:
 *		This constructor is used to create a CSessKeyContainer object from
 *		a "PDU" SessionKey.
 */
CSessKeyContainer::
CSessKeyContainer(PSessionKey session_key, PGCCError pRetCode)
:
    CRefCount(MAKE_STAMP_ID('S','e','s','K')),
    m_fValidSessionKeyPDU(FALSE),
    m_cbDataSize(0)
{
    GCCError rc;

	/*
	 * Save the Object Key portion of the Session Key in the internal structure
	 * by creating a new CObjectKeyContainer object.  Check to make sure the object
	 * is successfully created.
	 */
	DBG_SAVE_FILE_LINE
	m_InternalSessKey.application_protocol_key = new CObjectKeyContainer(
										&session_key->application_protocol_key,
										&rc);
	if (NULL != m_InternalSessKey.application_protocol_key && GCC_NO_ERROR == rc)
	{
    	/*
    	 * Save the session ID if one is present and the CObjectKeyContainer was saved 
    	 * correctly.  If a session ID is not present, set the internal session ID
    	 * to zero to indicate this.
    	 */
    	if (session_key->bit_mask & SESSION_ID_PRESENT)
    	{
    		m_InternalSessKey.session_id = session_key->session_id;
    	}
    	else
    	{
    		m_InternalSessKey.session_id = 0;
    	}
	}
	else if (GCC_BAD_OBJECT_KEY == rc)
	{
		ERROR_OUT(("CSessKeyContainer::SessionKeyData2: bad session key"));
		rc = GCC_BAD_SESSION_KEY;
	}
	else
	{
		ERROR_OUT(("CSessKeyContainer::SessionKeyData2: Error creating new CObjectKeyContainer"));
		rc = GCC_ALLOCATION_FAILURE;
	}

    *pRetCode = rc;
}

/*
 *	CSessKeyContainer()
 *
 *	Public Function Description:
 *		This copy constructor is used to create a new CSessKeyContainer object from
 *		another CSessKeyContainer object.
 */
CSessKeyContainer::
CSessKeyContainer(CSessKeyContainer *session_key, PGCCError pRetCode)
:
    CRefCount(MAKE_STAMP_ID('S','e','s','K')),
    m_fValidSessionKeyPDU(FALSE),
    m_cbDataSize(0)
{
    GCCError rc;

	/*
	 * Copy the Object Key portion of the Session Key using the copy constructor
	 * of the CObjectKeyContainer class.  Check to make sure the CObjectKeyContainer object
	 * is successfully created.
	 */
	DBG_SAVE_FILE_LINE
	m_InternalSessKey.application_protocol_key = new CObjectKeyContainer(
							session_key->m_InternalSessKey.application_protocol_key,
							&rc);
	if (NULL != m_InternalSessKey.application_protocol_key && GCC_NO_ERROR == rc)
	{
    	/*
    	 * Save the session ID if the CObjectKeyContainer was saved correctly.  A zero 
    	 * value of the GCC session ID will indicate that one is not actually
    	 * present.
    	 */
    	m_InternalSessKey.session_id = session_key->m_InternalSessKey.session_id;
	}
	else if (GCC_BAD_OBJECT_KEY == rc)
	{
		ERROR_OUT(("CSessKeyContainer::SessionKeyData3: bad session key"));
		rc = GCC_BAD_SESSION_KEY;
	}
	else
	{
		ERROR_OUT(("CSessKeyContainer::SessionKeyData3: Error creating new CObjectKeyContainer"));
		rc = GCC_ALLOCATION_FAILURE;
	}

    *pRetCode = rc;
}

/*
 *	~CSessKeyContainer()
 *
 *	Public Function Description
 *		The CSessKeyContainer destructor is responsible for freeing any memory
 *		allocated to hold the session key data.
 *
 */
CSessKeyContainer::
~CSessKeyContainer(void)
{
	/*
	 * If "PDU" data has been allocated for this object, free it now.
	 */
	if (m_fValidSessionKeyPDU)
	{
		FreeSessionKeyDataPDU();
	}

	/* 
	 * Delete any object key data held internally.
	 */
	if (NULL != m_InternalSessKey.application_protocol_key)
	{
	    m_InternalSessKey.application_protocol_key->Release();
	}
}

/*
 *	LockSessionKeyData ()
 *
 *	Public Function Description:
 *		This routine locks the session key data and determines the amount of
 *		memory referenced by the "API" session key data structure.
 */
UINT CSessKeyContainer::
LockSessionKeyData(void)
{
	/*
	 * If this is the first time this routine is called, determine the size of 
	 * the memory required to hold the data referenced by the session key
	 * structure.  Otherwise, just increment the lock count.
	 */
	if (Lock() == 1)
	{
		/*
		 * Lock the data for the object key held within the session key.  The
		 * pointer to the CObjectKeyContainer object is validated in the constructor.
		 */
		m_cbDataSize = m_InternalSessKey.application_protocol_key->LockObjectKeyData();
	}

	return m_cbDataSize;
}

/*
 *	GetGCCSessionKeyData ()
 *
 *	Public Function Description:
 *		This routine retrieves session key data in the "API" form of a 
 *		GCCSessionKey.  This routine is called after "locking" the session
 *		key data.
 */
UINT CSessKeyContainer::
GetGCCSessionKeyData(PGCCSessionKey session_key, LPBYTE memory)
{
	UINT cbDataSizeToRet = 0;

	/*
	 * If the session key data has been locked, fill in the output structure and
	 * the data referenced by the structure.  Call the "Get" routine for the 
	 * ObjectKey to fill in the object key data.
	 */ 
	if (GetLockCount() > 0)
	{
		/*
		 * Fill in the output length parameter which indicates how much data
		 * referenced outside the structure will be written.
		 */
		cbDataSizeToRet = m_cbDataSize;
        ::ZeroMemory(memory, m_cbDataSize);

		session_key->session_id = m_InternalSessKey.session_id;

		m_InternalSessKey.application_protocol_key->GetGCCObjectKeyData(
				&session_key->application_protocol_key,
				memory);
	}
	else
	{
		ERROR_OUT(("CSessKeyContainer::GetGCCSessionKeyData: Error: data not locked"));
	}

	return cbDataSizeToRet;
}

/*
 *	UnlockSessionKeyData ()
 *
 *	Public Function Description:
 *		This routine decrements the lock count and frees the memory associated 
 *		with the "API" session key once the lock count reaches zero.
 */
void CSessKeyContainer::
UnLockSessionKeyData(void)
{
	if (Unlock(FALSE) == 0)
	{
		/*
		 * Unlock the data associated with the internal CObjectKeyContainer and
		 * delete this object if the "free flag" is set.
		 */
		if (m_InternalSessKey.application_protocol_key != NULL)
		{
			m_InternalSessKey.application_protocol_key->UnLockObjectKeyData(); 
		} 
	}

    // we have to call Release() because we used Unlock(FALSE)
    Release();
}

/*
 *	GetSessionKeyDataPDU ()
 *
 *	Public Function Description:
 *		This routine converts the session key from it's internal form of a
 *		SESSION_KEY structure into the "PDU" form which can be passed in
 *		to the ASN.1 encoder.  A pointer to a "PDU" "SessionKey" structure is 
 *		returned.
 */
GCCError CSessKeyContainer::
GetSessionKeyDataPDU(PSessionKey session_key)
{
	GCCError	rc = GCC_NO_ERROR;

	/*
	 * If this is the first time that PDU data has been requested then we must
	 * fill in the internal PDU structure and copy it into the structure pointed
	 * to by the output parameter.  On subsequent calls to "GetPDU" we can just
	 * copy the internal PDU structure into the structure pointed to by the
	 * output parameter.
	 */
	if (m_fValidSessionKeyPDU == FALSE)
	{
		m_fValidSessionKeyPDU = TRUE;

		/*
		 * Initialize the "PDU" session key's bit mask to zero.
		 */
		m_SessionKeyPDU.bit_mask = 0;

		/*
		 * Fill in the "PDU" session key from the internal structure.
		 */
		if (m_InternalSessKey.application_protocol_key != NULL)
		{
			/*
			 * Fill in the object key portion of the session key by using the
			 * "GetPDU" routine of the internal CObjectKeyContainer object.
			 */
			rc = m_InternalSessKey.application_protocol_key->
					GetObjectKeyDataPDU(&m_SessionKeyPDU.application_protocol_key);
		}
		else
		{
			rc = GCC_ALLOCATION_FAILURE;
		}

		/*
		 * Fill in the "PDU" session ID if one exists.  A value of zero for the
		 * internal session ID indicates that one really does not exist.
		 */
		if (m_InternalSessKey.session_id != 0)
		{
			m_SessionKeyPDU.bit_mask |= SESSION_ID_PRESENT;
			m_SessionKeyPDU.session_id = m_InternalSessKey.session_id;
		}
	}

	/*
	 * Copy the internal PDU structure into the structure pointed to by the
	 * output parameter.
	 */
	*session_key = m_SessionKeyPDU;

	return rc;
}

/*
 *	FreeSessionKeyDataPDU ()
 *
 *	Public Function Description:
 *		This routine is used to free the session key data held internally in
 *		the "PDU" form of a "SessionKey".
 */
void CSessKeyContainer::
FreeSessionKeyDataPDU(void)
{
	if (m_fValidSessionKeyPDU)
	{
		/*
		 * Set the flag indicating that PDU session key data is no longer
		 * allocated.
		 */
		m_fValidSessionKeyPDU = FALSE;

		if (m_InternalSessKey.application_protocol_key != NULL)
		{
			m_InternalSessKey.application_protocol_key->FreeObjectKeyDataPDU ();
		}
		else
		{
			ERROR_OUT(("CSessKeyContainer::FreeSessionKeyDataPDU: Bad internal pointer"));
		}
	}
}

/*
 *	IsThisYourApplicationKey()
 *
 *	Public Function Description:
 *		This routine is used to determine whether the specified application
 *		key is held within this session key.
 */
BOOL CSessKeyContainer::
IsThisYourApplicationKey(PGCCObjectKey application_key)
{
	BOOL    		fRet = FALSE;
	CObjectKeyContainer	    *object_key_data;
	GCCError		rc2;

	DBG_SAVE_FILE_LINE
	object_key_data = new CObjectKeyContainer(application_key, &rc2);
	if ((object_key_data != NULL) && (rc2 == GCC_NO_ERROR))
	{
		if (*object_key_data == *m_InternalSessKey.application_protocol_key)
		{
			fRet = TRUE;
		}
	}
	else
	{
		ERROR_OUT(("CSessKeyContainer::IsThisYourApplicationKey: Error creating new CObjectKeyContainer"));
	}

	if (NULL != object_key_data)
	{
	    object_key_data->Release();
	}

	return fRet;
}

/*
 *	IsThisYourApplicationKeyPDU()
 *
 *	Public Function Description:
 *		This routine is used to determine whether the specified application
 *		key is held within this session key.
 */
BOOL CSessKeyContainer::
IsThisYourApplicationKeyPDU(PKey application_key)
{
	BOOL    		fRet = FALSE;
	CObjectKeyContainer	    *object_key_data;
	GCCError		rc2;

	DBG_SAVE_FILE_LINE
	object_key_data = new CObjectKeyContainer(application_key, &rc2);
	if ((object_key_data != NULL) && (rc2 == GCC_NO_ERROR))
	{
		if (*object_key_data == *m_InternalSessKey.application_protocol_key)
		{
			fRet = TRUE;
		}
	}
	else
	{
		ERROR_OUT(("CSessKeyContainer::IsThisYourApplicationKeyPDU: Error creating new CObjectKeyContainer"));
	}

	if (NULL != object_key_data)
	{
	    object_key_data->Release();
	}

	return fRet;
}

/*
 *	IsThisYourSessionKeyPDU ()
 *
 *	Public Function Description:
 *		This routine is used to determine whether the specified session key
 *		is equal in value to this session key.
 */
BOOL CSessKeyContainer::
IsThisYourSessionKeyPDU(PSessionKey session_key)
{
	BOOL    			fRet = FALSE;
	CSessKeyContainer   *session_key_data;
	GCCError			rc2;

	DBG_SAVE_FILE_LINE
	session_key_data = new CSessKeyContainer(session_key, &rc2);
	if ((session_key_data != NULL) && (rc2 == GCC_NO_ERROR))
	{
		if (*session_key_data == *this)
		{
			fRet = TRUE;
		}
	}
	else
	{
		ERROR_OUT(("CSessKeyContainer::IsThisYourSessionKeyPDU: Error creating new CSessKeyContainer"));
	}

	if (NULL != session_key_data)
	{
	    session_key_data->Release();
	}

	return fRet;
}

/*
 *	operator== ()
 *
 *	Public Function Description:
 *		This routine is used to determine whether or not two session keys are
 *		equal in value.
 */
BOOL operator==(const CSessKeyContainer& session_key_1, const CSessKeyContainer& session_key_2)
{
	BOOL fRet = FALSE;

	if ((session_key_1.m_InternalSessKey.application_protocol_key != NULL) &&
		(session_key_2.m_InternalSessKey.application_protocol_key != NULL))
	{
		if (*session_key_1.m_InternalSessKey.application_protocol_key ==
			*session_key_2.m_InternalSessKey.application_protocol_key)
		{
			if (session_key_1.m_InternalSessKey.session_id == 
				session_key_2.m_InternalSessKey.session_id)
			{
				fRet = TRUE;
			}
		}
	}

	return fRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\remdsk\rds\t120\common\regkey.cpp ===
#include "precomp.h"
DEBUG_FILEZONE(ZONE_T120_UTILITY);
/* 
 *	regkey.cpp
 *
 *	Copyright (c) 1995 by DataBeam Corporation, Lexington, KY
 *
 *	Abstract:
 *		This is the implementation file for the class CRegKeyContainer.  This 
 *		class manages the data associated with a Registry Key.  Registry Key's 
 *		are used to identify resources held in the application registry and 
 *		consist of a Session Key and a resource ID octet string.  The 
 *		CRegKeyContainer class uses a CSessKeyContainer container to maintain the 
 *		session key data internally.  A Rogue Wave string object is used to 
 *		hold the resource ID octet string. 
 *
 *	Protected Instance Variables:
 *		m_InternalRegKey
 *			Structure used to hold the registry key data internally.
 *		m_RegKeyPDU
 *			Storage for the "PDU" form of the registry key.
 *		m_fValidRegKeyPDU
 *			Flag indicating that memory has been allocated to hold the internal
 *			"PDU" registry key.
 *		m_cbDataSize
 *			Variable holding the size of the memory which will be required to
 *			hold any data referenced by the "API" GCCRegistryKey structure.
 *
 *	Caveats:
 *		None.
 *
 *	Author:
 *		jbo
 */

#include "regkey.h"


/*
 * This macro is used to ensure that the Resource ID contained in the Registry
 * Key does not violate the imposed ASN.1 constraint.
 */
#define		MAXIMUM_RESOURCE_ID_LENGTH		64


/*
 *	CRegKeyContainer()
 *
 *	Public Function Description:
 *		This constructor is used to create a CRegKeyContainer object from
 *		an "API" GCCRegistryKey.
 */
CRegKeyContainer::
CRegKeyContainer(PGCCRegistryKey registry_key, PGCCError pRetCode)
:
    CRefCount(MAKE_STAMP_ID('R','e','g','K')),
    m_fValidRegKeyPDU(FALSE),
    m_cbDataSize(0)
{
	GCCError rc = GCC_NO_ERROR;

    /*
	 * Initialize instance variables.
	 */
    ::ZeroMemory(&m_InternalRegKey, sizeof(m_InternalRegKey));
    ::ZeroMemory(&m_RegKeyPDU, sizeof(m_RegKeyPDU));

	/*
	 * Check to make sure the resource ID string does not violate the imposed
	 * ASN.1 constraint.
	 */
	if (registry_key->resource_id.length > MAXIMUM_RESOURCE_ID_LENGTH)
	{
		ERROR_OUT(("CRegKeyContainer::CRegKeyContainer: Error: resource ID exceeds allowable length"));
		rc = GCC_BAD_REGISTRY_KEY;
        goto MyExit;
	}

	/*
	 * Save the Session Key portion of the Registry Key in the internal
	 * structure by creating a new CSessKeyContainer object.  Check to make  
	 * sure the object is successfully created.
	 */
	DBG_SAVE_FILE_LINE
	m_InternalRegKey.session_key = new CSessKeyContainer(&registry_key->session_key, &rc);
	if (m_InternalRegKey.session_key == NULL)
	{
		ERROR_OUT(("CRegKeyContainer::CRegKeyContainer: Error creating new CSessKeyContainer"));
		rc = GCC_ALLOCATION_FAILURE;
        goto MyExit;
	}
	else if (rc == GCC_BAD_SESSION_KEY)
	{
		rc = GCC_BAD_REGISTRY_KEY;
        goto MyExit;
	}

	/*
	 * Save the resource ID if the CSessKeyContainer was successfully created.
	 */
	if (NULL == (m_InternalRegKey.poszResourceID = ::My_strdupO2(
				 		registry_key->resource_id.value,
				 		registry_key->resource_id.length)))
	{
		ERROR_OUT(("CRegKeyContainer::CRegKeyContainer: Error creating resource id"));
		rc = GCC_ALLOCATION_FAILURE;
        // goto MyExit;
	}

MyExit:

    *pRetCode = rc;
}


/*
 *	CRegKeyContainer()
 *
 *	Public Function Description:
 *		This constructor is used to create a CRegKeyContainer object from
 *		a "PDU" RegistryKey.
 */
CRegKeyContainer::
CRegKeyContainer(PRegistryKey registry_key, PGCCError pRetCode)
:
    CRefCount(MAKE_STAMP_ID('R','e','g','K')),
    m_fValidRegKeyPDU(FALSE),
    m_cbDataSize(0)
{
	GCCError rc = GCC_NO_ERROR;

	/*
	 * Initialize instance variables.
	 */
    ::ZeroMemory(&m_InternalRegKey, sizeof(m_InternalRegKey));
    ::ZeroMemory(&m_RegKeyPDU, sizeof(m_RegKeyPDU));

	/*
	 * Save the Session Key portion of the Registry Key in the internal 
	 * structure by creating a new CSessKeyContainer object.  Check to make sure 
	 * the object is successfully created.
	 */
	DBG_SAVE_FILE_LINE
	m_InternalRegKey.session_key = new CSessKeyContainer(&registry_key->session_key, &rc);
	if ((m_InternalRegKey.session_key == NULL) || (rc != GCC_NO_ERROR))
	{
		ERROR_OUT(("CRegKeyContainer::CRegKeyContainer: Error creating new CSessKeyContainer"));
		rc = GCC_ALLOCATION_FAILURE;
        goto MyExit;
	}

	/*
	 * Save the resource ID if the CSessKeyContainer was successfully created.
	 */
	if (NULL == (m_InternalRegKey.poszResourceID = ::My_strdupO2(
						registry_key->resource_id.value,
						registry_key->resource_id.length)))
	{
		ERROR_OUT(("CRegKeyContainer::CRegKeyContainer: Error creating resource id"));
		rc = GCC_ALLOCATION_FAILURE;
        // goto MyExit;
	}

MyExit:

    *pRetCode = rc;
}


/*
 *	CRegKeyContainer()
 *
 *	Public Function Description:
 *		This copy constructor is used to create a new CRegKeyContainer object
 *		from another CRegKeyContainer object.
 */
CRegKeyContainer::
CRegKeyContainer(CRegKeyContainer *registry_key, PGCCError pRetCode)
:
    CRefCount(MAKE_STAMP_ID('R','e','g','K')),
    m_fValidRegKeyPDU(FALSE),
    m_cbDataSize(0)
{
	GCCError rc = GCC_NO_ERROR;

	/*
	 * Initialize instance variables.
	 */
    ::ZeroMemory(&m_InternalRegKey, sizeof(m_InternalRegKey));
    ::ZeroMemory(&m_RegKeyPDU, sizeof(m_RegKeyPDU));

	/*
	 * Copy the Session Key portion of the Registry Key using the copy 
	 * constructor of the CSessKeyContainer class.  Check to make sure the 
	 * CSessKeyContainer object is successfully created.
	 */
	DBG_SAVE_FILE_LINE
	m_InternalRegKey.session_key = new CSessKeyContainer(registry_key->m_InternalRegKey.session_key, &rc);
	if ((m_InternalRegKey.session_key == NULL) || (rc != GCC_NO_ERROR))
	{
		ERROR_OUT(("CRegKeyContainer::CRegKeyContainer: Error creating new CSessKeyContainer"));
		rc = GCC_ALLOCATION_FAILURE;
        goto MyExit;
	}

	/*
	 * Save the resource ID if the CSessKeyContainer was saved correctly.
	 * Store the resource ID in a Rogue Wave string container.
	 */
	if (NULL == (m_InternalRegKey.poszResourceID = ::My_strdupO(
								registry_key->m_InternalRegKey.poszResourceID)))
	{
		ERROR_OUT(("CRegKeyContainer::CRegKeyContainer: Error creating new resource id"));
		rc = GCC_ALLOCATION_FAILURE;
        // goto MyExit;
	}

MyExit:

    *pRetCode = rc;
}


/*
 *	~CRegKeyContainer()
 *
 *	Public Function Description
 *		The CRegKeyContainer destructor is responsible for freeing any memory
 *		allocated to hold the registry key data.
 *
 */
CRegKeyContainer::
~CRegKeyContainer(void)
{
	/*
	 * If "PDU" data has been allocated for this object, free it now.
	 */
	if (m_fValidRegKeyPDU)
	{
		FreeRegistryKeyDataPDU();
	}

	/* 
	 * Delete any registry key data held internally.
	 */
	if (NULL != m_InternalRegKey.session_key)
	{
	    m_InternalRegKey.session_key->Release();
	}
	delete m_InternalRegKey.poszResourceID;
}


/*
 *	LockRegistryKeyData ()
 *
 *	Public Function Description:
 *		This routine locks the registry key data and determines the amount of
 *		memory referenced by the "API" registry key structure.
 */
UINT CRegKeyContainer::
LockRegistryKeyData(void)
{
	/*
	 * If this is the first time this routine is called, determine the size of 
	 * the memory required to hold the data referenced by the registry key
	 * structure.  Otherwise, just increment the lock count.
	 */
	if (Lock() == 1)
	{
		/*
		 * Lock the data for the session key by	using the "Lock" routine of
		 * the internal CSessKeyContainer object.  Determine the amount of memory
		 * necessary to hold the data referenced by the "API" registry key
		 * structure.  The referenced data consists of data for the object key
		 * as well as data for the resource ID octet string.  The sizes for
		 * both of these memory blocks are rounded to occupy an even multiple
		 * of four-byte blocks, with the session key block being rounded at a
		 * lower level.  The pointers to the internal objects were validated in
		 * the constructor.  
		 */
		m_cbDataSize = m_InternalRegKey.session_key->LockSessionKeyData();
		m_cbDataSize += m_InternalRegKey.poszResourceID->length;
		m_cbDataSize = ROUNDTOBOUNDARY(m_cbDataSize);
	}

	return m_cbDataSize;
}


/*
 *	GetGCCRegistryKeyData ()
 *
 *	Public Function Description:
 *		This routine retrieves registry key data in the form of an "API" 
 *		GCCRegistryKey.	 This routine is called after "locking" the registry 
 *		key data.
 */
UINT CRegKeyContainer::
GetGCCRegistryKeyData(PGCCRegistryKey registry_key, LPBYTE memory)
{
	UINT cbDataSizeToRet = 0;

	/*
	 * If the registry key data has been locked, fill in the output structure
	 * and the data referenced by the structure.  Call the "Get" routine for the 
	 * SessionKey to fill in the session key data.
	 */ 
	if (GetLockCount() > 0)
	{
    	UINT		session_key_data_length;
    	LPBYTE		data_memory = memory;

		/*
		 * Fill in the output parameter which indicates the amount of memory
		 * used to hold all of the data associated with the registry key.
		 */
		cbDataSizeToRet = m_cbDataSize;

		session_key_data_length = m_InternalRegKey.session_key->
				GetGCCSessionKeyData(&registry_key->session_key, data_memory);
		data_memory += session_key_data_length;

		/*
		 * Move the memory pointer past the session key data.  The length of
		 * the session key data is rounded to a four-byte boundary by the
		 * lower level routines.  Set the resource ID octet string length
		 * and pointer and copy the octet string data into the memory block
		 * from the internal Rogue Wave string.
		 */
		registry_key->resource_id.value = data_memory;
		registry_key->resource_id.length = m_InternalRegKey.poszResourceID->length;

		::CopyMemory(data_memory, m_InternalRegKey.poszResourceID->value,
					m_InternalRegKey.poszResourceID->length);
	}
	else
	{
		ERROR_OUT(("CRegKeyContainer::GetGCCRegistryKeyData Error Data Not Locked"));
	}

	return cbDataSizeToRet;
}


/*
 *	UnlockRegistryKeyData ()
 *
 *	Public Function Description:
 *		This routine decrements the lock count and frees the memory associated 
 *		with the "API" registry key once the lock count reaches zero.
 */
void CRegKeyContainer::
UnLockRegistryKeyData(void)
{
	if (Unlock(FALSE) == 0)
	{
		/*
		 * Unlock the data associated with the internal CSessKeyContainer.
		 */
		if (m_InternalRegKey.session_key != NULL)
		{
			m_InternalRegKey.session_key->UnLockSessionKeyData();
		} 
	}

    // we have to call Release() because we used Unlock(FALSE)
    Release();
}


/*
 *	GetRegistryKeyDataPDU ()
 *
 *	Public Function Description:
 *		This routine converts the registry key from it's internal form of a
 *		REG_KEY structure into the "PDU" form which can be passed in
 *		to the ASN.1 encoder.  A pointer to a "PDU" "RegistryKey" structure is 
 *		returned.
 */
GCCError CRegKeyContainer::
GetRegistryKeyDataPDU(PRegistryKey registry_key)
{
	GCCError rc = GCC_NO_ERROR;

	/*
	 * If this is the first time that PDU data has been requested then we must
	 * fill in the internal PDU structure and copy it into the structure pointed
	 * to by the output parameter.  On subsequent calls to "GetPDU" we can just
	 * copy the internal PDU structure into the structure pointed to by the
	 * output parameter.
	 */
	if (m_fValidRegKeyPDU == FALSE)
	{
		m_fValidRegKeyPDU = TRUE;

		/*
		 * Fill in the "PDU" registry key from the internal structure.
		 */
		if (m_InternalRegKey.session_key != NULL)
		{
			/*
			 * Fill in the session key portion of the registry key by using the
			 * "Get" routine of the internal CSessKeyContainer object.
			 */
			rc = m_InternalRegKey.session_key->GetSessionKeyDataPDU(&m_RegKeyPDU.session_key);
		}
		else
		{
			rc = GCC_ALLOCATION_FAILURE;
		}

		if (rc == GCC_NO_ERROR)
		{
			/*
			 * Fill in the "PDU" resource ID if no error has occurred.
			 */
			::CopyMemory(m_RegKeyPDU.resource_id.value,
					m_InternalRegKey.poszResourceID->value,
					m_InternalRegKey.poszResourceID->length);

			m_RegKeyPDU.resource_id.length = m_InternalRegKey.poszResourceID->length;
		}
	}

	/*
	 * Copy the internal PDU structure into the structure pointed to by the
	 * output parameter.
	 */
	*registry_key = m_RegKeyPDU;

	return rc;
}


/*
 *	FreeRegistryKeyDataPDU ()
 *
 *	Public Function Description:
 *		This routine is used to free the registry key data held internally in
 *		the "PDU" form of a "RegistryKey".
 */
void CRegKeyContainer::
FreeRegistryKeyDataPDU(void)
{
	if (m_fValidRegKeyPDU)
	{
		/*
		 * Set the flag indicating that PDU registry key data is no longer
		 * allocated.
		 */
		m_fValidRegKeyPDU = FALSE;

		if (m_InternalRegKey.session_key != NULL)
		{
			m_InternalRegKey.session_key->FreeSessionKeyDataPDU();
		}
		else
		{
			ERROR_OUT(("CRegKeyContainer::FreeRegistryKeyDataPDU: Bad internal pointer"));
		}
	}
}


GCCError CRegKeyContainer::
CreateRegistryKeyData(PGCCRegistryKey *ppRegKey)
{
    GCCError rc;

    DebugEntry(CRegKeyContainer::CreateRegistryKeyData);

    /*
    **	Here we calculate the length of the bulk data.  This
    **	includes the registry key and registry item.  These objects are
    **	"locked" in order to determine how much bulk memory they will
    **	occupy.
    */
    UINT cbKeySize = ROUNDTOBOUNDARY(sizeof(GCCRegistryKey));
    UINT cbDataSize = LockRegistryKeyData() + cbKeySize;
    LPBYTE pData;

    DBG_SAVE_FILE_LINE
    if (NULL != (pData = new BYTE[cbDataSize]))
    {
        *ppRegKey = (PGCCRegistryKey) pData;
        ::ZeroMemory(pData, cbKeySize);

        pData += cbKeySize;
        GetGCCRegistryKeyData(*ppRegKey, pData);

        rc = GCC_NO_ERROR;
    }
    else
    {
        ERROR_OUT(("CRegKeyContainer::CreateRegistryKeyData: can't create GCCRegistryKey"));
        rc = GCC_ALLOCATION_FAILURE;
    }

    //	UnLock the registry key since it is no longer needed
    UnLockRegistryKeyData();

    DebugExitINT(CRegKeyContainer::CreateRegistryKeyData, rc);
    return rc;
}


/*
 *	IsThisYourSessionKey ()
 *
 *	Public Function Description:
 *		This routine determines whether this registry key holds the specified
 *		session key.
 */
BOOL CRegKeyContainer::
IsThisYourSessionKey(CSessKeyContainer *session_key)
{
	BOOL			fRet = FALSE;
	CSessKeyContainer *session_key_data;
	GCCError		rc2;

	DBG_SAVE_FILE_LINE
	session_key_data = new CSessKeyContainer(session_key, &rc2);
	if ((session_key_data != NULL) && (rc2 == GCC_NO_ERROR))
	{
		if (*session_key_data == *m_InternalRegKey.session_key)
		{
			fRet = TRUE;
		}
	}
	else
	{
		ERROR_OUT(("CRegKeyContainer::IsThisYourSessionKey: Error creating new CSessKeyContainer"));
	}

	if (NULL != session_key_data)
	{
	    session_key_data->Release();
	}

	return fRet;
}


/*
 *	GetSessionKey ()
 *
 *	Public Function Description:
 *		This routine is used to retrieve the session key which is held within
 *		this registry key.  The session key is returned in the form of a
 *		CSessKeyContainer container object.
 */


/*
 *	operator== ()
 *
 *	Public Function Description:
 *		This routine is used to determine whether or not two registry keys are
 *		equal in value.
 */
BOOL operator==(const CRegKeyContainer& registry_key_1, const CRegKeyContainer& registry_key_2)
{
	BOOL fRet = FALSE;
	
	if ((registry_key_1.m_InternalRegKey.session_key != NULL) &&
		(registry_key_2.m_InternalRegKey.session_key != NULL))
	{
		if (*registry_key_1.m_InternalRegKey.session_key ==
			*registry_key_2.m_InternalRegKey.session_key)
		{
			if (0 == My_strcmpO(registry_key_1.m_InternalRegKey.poszResourceID,
							registry_key_2.m_InternalRegKey.poszResourceID))
			{
				fRet = TRUE;
			}
		}
	}

	return fRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\remdsk\rds\t120\h\alarm.h ===
/*
 *	alarm.h
 *
 *	Copyright (c) 1994 by DataBeam Corporation, Lexington, Kentucky
 *
 *	Abstract:
 *		
 *	Caveats:
 *		None
 *
 *	Author:
 *		James P. Galvin, Jr.
 *
 *	Revision History:
 *		09JAN95   jpg	Original
 */
#ifndef	_ALARM_
#define	_ALARM_

/*
 *	This is the class definition for the Alarm class.
 */
class CAlarm
{
public:

	CAlarm(UINT nDuration);
	~CAlarm(void) { }

	void			Set(UINT nDuration);
	void			Reset(void);
	void			Expire(void) { m_fExpired = TRUE; }
	BOOL			IsExpired(void);

private:

	UINT			m_nDuration;
	UINT			m_nStartTime;
	BOOL			m_fExpired;
};

typedef		CAlarm		Alarm,	*PAlarm;

/*
 *	Alarm (
 *			Long			duration)
 *	
 *	Function Description
 *
 *	Formal Parameters
 *		
 *	Return value
 *
 *	Side Effects
 *
 *	Caveats
 */

/*
 *	~Alarm ()
 *	
 *	Function Description
 *
 *	Formal Parameters
 *		
 *	Return value
 *
 *	Side Effects
 *
 *	Caveats
 */

/*
 *	Void	Set (
 *					Long			duration)
 *	
 *	Function Description
 *
 *	Formal Parameters
 *		
 *	Return value
 *
 *	Side Effects
 *
 *	Caveats
 */

/*
 *	Void	Reset ()
 *	
 *	Function Description
 *
 *	Formal Parameters
 *		
 *	Return value
 *
 *	Side Effects
 *
 *	Caveats
 */

/*
 *	Long	GetTimeRemaining ()
 *	
 *	Function Description
 *
 *	Formal Parameters
 *		
 *	Return value
 *
 *	Side Effects
 *
 *	Caveats
 */

/*
 *	Void	Expire ()
 *	
 *	Function Description
 *
 *	Formal Parameters
 *		
 *	Return value
 *
 *	Side Effects
 *
 *	Caveats
 */

/*
 *	BOOL		IsExpired ()
 *	
 *	Function Description
 *
 *	Formal Parameters
 *		
 *	Return value
 *
 *	Side Effects
 *
 *	Caveats
 */

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\remdsk\rds\t120\h\appcap.h ===
/*
 *	appcap.h
 *
 *	Copyright (c) 1993 by DataBeam Corporation, Lexington, KY
 *
 *	Abstract:
 *		This is the interface file for the class ApplicationaCapabilityData.
 *
 *	Caveats:
 *		None.
 *
 *	Author:
 *		jbo
 */
#ifndef	_APP_CAPABILITY_DATA_
#define	_APP_CAPABILITY_DATA_

#include "capid.h"
#include "cntlist.h"

/*
**	Below is the definition for all the capabilities related structures and
**	containers.  The ListOfCapabilitiesList definition is used to maintain
**	all of the individual capabilities list at a single node (for multiple
**	protocol entities).
*/
typedef struct APP_CAP_ITEM
{
	APP_CAP_ITEM(GCCCapabilityType eCapType);
	APP_CAP_ITEM(APP_CAP_ITEM *p, GCCError *pError);
	~APP_CAP_ITEM(void);

    // in non-collapsing case, pCapID and poszAppData are used.
    // in appcap case, all but poszAppData are used.
    // in invoklst case, pCapID, eCapType, and the union are used.
	CCapIDContainer             *pCapID;
	GCCCapabilityType			eCapType;
	UINT       					cEntries;
	LPOSTR						poszAppData;	//	For Non-Collapsing only
	union 
	{
		UINT	nUnsignedMinimum;
		UINT	nUnsignedMaximum;
	};
}
    APP_CAP_ITEM;


/*
**	Holds the list of individual capabilities for a single Application Protocol 
**	Entity.  Remember that a single APE can have many capabilities.  
*/
class CAppCapItemList : public CList
{
    DEFINE_CLIST(CAppCapItemList, APP_CAP_ITEM*)
    void DeleteList(void);
};



// LONCHANC: CAppCap and CNonCollAppCap are very similar to each.

class CAppCap : public CRefCount
{
public:

	CAppCap(UINT cCaps, PGCCApplicationCapability *, PGCCError);
	~CAppCap(void);

	UINT		GetGCCApplicationCapabilityList(USHORT *pcCaps, PGCCApplicationCapability **, LPBYTE memory);

	UINT		LockCapabilityData(void);
	void		UnLockCapabilityData(void);

protected:

	UINT			    m_cbDataSize;
	CAppCapItemList     m_AppCapItemList;
};


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\remdsk\rds\t120\h\appldr.h ===
#ifndef  __APPLET_LOADER_H
#define  __APPLET_LOADER_H


#include "iappldr.h"

typedef struct {
	HINSTANCE       hLibApplet;
	IAppletLoader   *pIAppLoader;
	APPLET_STATUS   eStatus;
	int				cLoads;
} AppLoaderInfo;


T120Error AppLdr_Initialize(void);
void AppLdr_Shutdown(void);


#endif // __APPLET_LOADER_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\remdsk\rds\t120\h\appenrol.h ===
/*
 *	appenrol.h
 *
 *	Copyright (c) 1993 by DataBeam Corporation, Lexington, KY
 *
 *	Abstract:
 *		This is the header file for the class ApplicationEnrollRequestData.
 *
 *	Caveats:
 *		None.
 *
 *	Author:
 *		jbo
 */
#ifndef	_APPLICATION_ENROLL_REQUEST_DATA_
#define	_APPLICATION_ENROLL_REQUEST_DATA_

#include "gcctypes.h"
#include "pdutypes.h"
#include "aportmsg.h"
#include "sesskey.h"
#include "appcap.h"
#include "ncollcap.h"

class 	ApplicationEnrollRequestData;
typedef	ApplicationEnrollRequestData 	*	PApplicationEnrollRequestData;

class ApplicationEnrollRequestData
{
public:

    ApplicationEnrollRequestData(PApplicationEnrollRequestMessage, PGCCError);
	ApplicationEnrollRequestData(PApplicationEnrollRequestMessage);
	~ApplicationEnrollRequestData(void);

	ULONG		GetDataSize(void);
	ULONG		Serialize(PApplicationEnrollRequestMessage, LPSTR memory);

	void		Deserialize(PApplicationEnrollRequestMessage);

protected:

	ApplicationEnrollRequestMessage				Enroll_Request_Message;
	CSessKeyContainer   					    *Session_Key_Data;
	CNonCollAppCap				                *Non_Collapsing_Caps_Data;
	CAppCap							            *Application_Capability_Data;
};
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\remdsk\rds\t120\h\appsap.h ===
/*
 * appsap.h
 *
 *	Copyright (c) 1995 by DataBeam Corporation, Lexington, KY
 *
 *	Abstract:
 *		This is the interface file for the class CAppSap.  CAppSap
 *		objects represent an external user application's Service Access 
 *		Point to GCC.  This object inherits from the CBaseSap class. The CAppSap 
 *		object is instantiated when GCCCreateSap is called.  From that point 
 *		forward all messages to and from that application pass through this 
 *		object.  The object is explicitly deleted when GCCDeleteSap is called 
 *		or it is implicitly deleted when GCCCleanup is called by the Node 
 *		Controller.	 
 *
 *		The primary responsibility of the CAppSap object is to route
 *		incoming GCC primitives to their appropriate destination and to convert
 *		the primitives into a form that is understandable to the objects 
 *		processing them. A secondary responsibility of the CAppSap object is to 
 *		maintain a queue for all indications and confirm messages that are sent
 *		back to the registered application.  Commands can be routed by the 
 *		CAppSap in one of two directions. Either to the controller or to a 
 *		specified conference.  Commands that are passed to the controller, are
 *		done so using owner callbacks.  Commands that are routed to conferences
 *		are done so using command target calls and are routed based on a 
 *		Conference ID.  Note that various User Application commands will only be
 *		routed to the CConf if that application has previously enrolled 
 *		with the conference.  The CAppSap receives all confirms and indications
 *		from either the Controller or a CConf object.  These messages are
 *		formatted into GCCMessages within the CAppSap and queued up for later 
 *		delivery.  Periodically, the CAppSap's message queue is flushed by the 
 *		Controller object and the messages are delivered to the appropriate 
 *		application.
 *
 *	Caveats:
 *		The message structures that are passed back to the node controller
 *		are defined in GCC.H.
 *
 *	Author:
 *		blp
 */

#ifndef _APPSAP_
#define _APPSAP_

/*
 * include files 
 */
#include "igccapp.h"
#include "sap.h"
#include "clists.h"


/*
**	This is the message base that is passed into any SAP objects that use this
**	classes Owner callback.  It will typically be the controller's 
**	responsibility to pass this message on.
*/
#define	APPLICATION_MESSAGE_BASE			0

/*
**	Class definition
*/
class CAppSap : public CBaseSap, public IGCCAppSap 
{
    friend LRESULT CALLBACK SapNotifyWndProc(HWND, UINT, WPARAM, LPARAM);

public:

    CAppSap(LPVOID pAppData, LPFN_APP_SAP_CB, PGCCError);
    ~CAppSap(void);

    GCCAPI_(void)   ReleaseInterface(void);

    /* ------ IGCCAppSap Interface ------ */

    GCCAPI  AppEnroll(GCCConfID, GCCEnrollRequest *, PGCCRequestTag);
    GCCAPI  AppInvoke(GCCConfID, GCCAppProtEntityList *, GCCSimpleNodeList *, PGCCRequestTag);

    GCCAPI  AppRosterInquire(GCCConfID, GCCSessionKey *, GCCAppSapMsg **);
    GCCAPI_(void)  FreeAppSapMsg(GCCAppSapMsg *);

    GCCAPI_(BOOL)  IsThisNodeTopProvider(GCCConfID);
    GCCAPI_(GCCNodeID) GetTopProvider(GCCConfID);
    GCCAPI  ConfRosterInquire(GCCConfID, GCCAppSapMsg **);

    GCCAPI  RegisterChannel(GCCConfID, GCCRegistryKey *, ChannelID);
    GCCAPI  RegistryAssignToken(GCCConfID, GCCRegistryKey *);
    GCCAPI  RegistrySetParameter(GCCConfID, GCCRegistryKey *, LPOSTR, GCCModificationRights);
    GCCAPI  RegistryRetrieveEntry(GCCConfID, GCCRegistryKey *);
    GCCAPI  RegistryDeleteEntry(GCCConfID, GCCRegistryKey *);
    GCCAPI  RegistryMonitor(GCCConfID, BOOL fEnableDelivery, GCCRegistryKey *);
    GCCAPI  RegistryAllocateHandle(GCCConfID, ULONG cHandles);

    GCCAPI  ConductorInquire(GCCConfID);

    /* ------ IGCCAppSapNotify Handler ------ */

    GCCError PermissionToEnrollIndication(GCCConfID, BOOL fGranted);
    GCCError AppEnrollConfirm(GCCAppEnrollConfirm *);

    GCCError RegistryAllocateHandleConfirm(GCCConfID,
                                           ULONG        cHandles,
                                           ULONG        nFirstHandle,
                                           GCCResult);

    GCCError RegistryConfirm(GCCConfID,
                             GCCMessageType,
                             CRegKeyContainer *,
                             CRegItem *,
                             GCCModificationRights,
                             GCCNodeID                  nidOwner,
                             GCCEntityID                eidOwner,
                             BOOL                       fDeliveryEnabled,
                             GCCResult);

    GCCError RegistryMonitorIndication(GCCConfID                nConfID,
                                       CRegKeyContainer         *pRegKey,
                                       CRegItem                 *pRegItem,
                                       GCCModificationRights    eRights,
                                       GCCNodeID                nidOwner,
                                       GCCEntityID              eidOwner)
    {
        return RegistryConfirm(nConfID,
                               GCC_MONITOR_INDICATION,
                               pRegKey,
                               pRegItem,
                               eRights,
                               nidOwner,
                               eidOwner,
                               FALSE,
                               GCC_RESULT_SUCCESSFUL);
    }

    GCCError ConfRosterInquireConfirm(GCCConfID,
                                      PGCCConferenceName,
                                      LPSTR                 pszConfModifier,
                                      LPWSTR                pwszConfDescriptor,
                                      CConfRoster *,
                                      GCCResult,
                                      GCCAppSapMsgEx **);

    GCCError AppRosterInquireConfirm(GCCConfID,
                                     CAppRosterMsg *,
                                     GCCResult,
                                     GCCAppSapMsgEx **);

    GCCError AppRosterReportIndication(GCCConfID, CAppRosterMsg *);

    GCCError AppInvokeConfirm(GCCConfID, CInvokeSpecifierListContainer *, GCCResult, GCCRequestTag);
    GCCError AppInvokeIndication(GCCConfID, CInvokeSpecifierListContainer *, GCCNodeID nidInvoker);

    GCCError ConductorInquireConfirm(GCCNodeID nidConductor, GCCResult, BOOL fGranted, BOOL fConducted, GCCConfID);
    GCCError ConductorPermitGrantIndication(GCCConfID,
                            UINT cGranted, GCCNodeID *aGranted,
                            UINT cWaiting, GCCNodeID *aWaiting,
                            BOOL fThisNodeIsGranted);
    GCCError ConductorAssignIndication(GCCNodeID nidConductor, GCCConfID);
    GCCError ConductorReleaseIndication(GCCConfID);


protected:

    void NotifyProc(GCCAppSapMsgEx *pAppSapMsgEx);

private:

    void PostAppSapMsg(GCCAppSapMsgEx *pAppSapMsgEx);
    void PurgeMessageQueue(void);

private:

    LPVOID              m_pAppData;        // app defined user data
    LPFN_APP_SAP_CB     m_pfnCallback;
};



/*
 *	Comments explaining the public and protected class member functions
 */

/*
 *	CAppSap (
 *				UINT				owner_message_base,
 *				UINT				application_messsage_base)
 *
 *	Public member function of CAppSap.
 *
 *	Function Description:
 *		This is the constructor for the CAppSap class.  It initializes instance
 *		variables and registers with the new application.
 *
 *	Formal Parameters:
 *		owner_object		(i) A pointer to the owner of this object, namely
 *									the controller.
 *		owner_message_base	(i) The	message base offset for callbacks into the
 *									controller.
 *		application_object	(i)	A pointer to the application requesting service.
 *		application_messsage_base	(i) The message base offset for callbacks
 *											to the application.
 *		sap_handle			(i) The handle registered for this SAP.
 *
 *	Return Value:
 *		None.
 *
 *  Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */


/*
 *	virtual 	~AppSap();
 *
 *	Public member function of CAppSap.
 *
 *	Function Description:
 *		This is the destructor for the CAppSap class.  It is called when the 
 *		controller marks the CAppSap to be deleted.  This occurs when either
 *		the CAppSap asks to be deleted due to an "unregister request" 
 *		issued from the client application, or when there is an error
 *		condition in the CAppSap.
 *
 *	Formal Parameters:
 *		owner_object		(i) A pointer to the owner of this object, namely
 *									the controller.
 *		owner_message_base	(i) The	message base offset for callbacks into the
 *									controller.
 *		application_object	(i)	A pointer to the application requesting service.
 *		application_messsage_base	(i) The message base offset for callbacks
 *											to the application.
 *		sap_handle			(i) The handle registered for this SAP.
 *
 *	Return Value:
 *		GCC_NO_ERROR					- No error.
 *		GCC_ALLOCATION_FAILURE			- A resource allocation error occurred.
 *		GCC_BAD_OBJECT_KEY				- An invalid object key passed in.
 *
 *  Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

/*
 *	GCCError	AppEnroll(
 *					GCCConfID   			conference_id,
 *					PGCCSessionKey				session_key,
 *					BOOL					enroll_actively,
 *					UserID						application_user_id,
 *					BOOL					is_conducting_capable,
 *					MCSChannelType				startup_channel_type,
 *					UINT						number_of_non_collapsed_caps,
 *					PGCCNonCollapsingCapability *non_collapsed_caps_list,		
 *					UINT						number_of_collapsed_caps,
 *					PGCCApplicationCapability *	collapsed_caps_list,		
 *					BOOL					application_is_enrolled);
 *
 *	Public member function of CAppSap.
 *
 *	Function Description:
 *		This routine is called when an application wants to enroll in a 
 *		conference.  The controller is notified of the enrollment request.
 *
 *	Formal Parameters:
 *		conference_id					(i) The conference identifier value.
 *		session_key						(i) Key identifying the session.
 *		enroll_actively					(i) Flag indicating whether to enroll
 *												actively or inactively.
 *		application_user_id				(i) The application identifier value.
 *		is_conducting_capable			(i) Flag indicating whether this app
 *												is capable of conducting.
 *		startup_channel_type			(i) The type of channel to use. 
 *		number_of_non_collapsed_caps	(i) Number of non-collapsed capabilities
 *		non_collapsed_caps_list			(i) List of non-collapsed capabilities.
 *		number_of_collapsed_caps		(i) Number of collapsed capabilities.
 *		collapsed_caps_list				(i) List of collapsed capabilities.
 *		application_is_enrolled)		(i) Flag indicating whether or not the
 *												application wishes to enroll.
 *
 *	Return Value:
 *		GCC_NO_ERROR				- No error.
 *		GCC_INVALID_MCS_USER_ID		- The user ID is less than the minimum value
 *		GCC_BAD_SESSION_KEY			- A NULL session key pointer is passed in.
 *		GCC_INVALID_CONFERENCE		- The conference does not exist at this node
 *		GCC_NO_SUCH_APPLICATION		- A SAP has not been registered for this app
 *		GCC_BAD_SESSION_KEY			- An invalid session key was passed in.
 *		GCC_INVALID_PARAMETER		- The node record was not found in the list.
 *		GCC_BAD_CAPABILITY_ID		- An invalid capability ID was passed in.
 *		GCC_ALLOCATION_FAILURE		- A resource allocation error occurred.
 *
 *  Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */


/*
 *	GCCError		RegisterChannel(
 *								GCCConfID		conference_id,
 *								PGCCRegistryKey		registry_key,
 *								ChannelID			channel_id);	
 *
 *	Public member function of CAppSap.
 *
 *	Function Description:
 *		This routine is called when an application wishes to register a 
 *		channel.  The call is routed to the appropriate conference object.
 *
 *	Formal Parameters:
 *		conference_id					(i) The conference identifier value.
 *		registry_key					(i) Key identifying the session and
 *												resource ID.
 *		channel_id						(i) ID of channel to register
 *
 *	Return Value:
 *		GCC_NO_ERROR					- No error.
 *		GCC_INVALID_CONFERENCE			- Conference not found to exist.
 *		GCC_ALLOCATION_FAILURE			- A resource error occurred.
 *		GCC_BAD_REGISTRY_KEY			- The registry key is invalid.
 *		GCC_APP_NOT_ENROLLED			- Requesting application is not
 *										  		enrolled with the conference.
 *
 *  Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */


/*
 *	GCCError		RegistryAssignToken(
 *								GCCConfID		conference_id,
 *								PGCCRegistryKey		registry_key);
 *
 *	Public member function of CAppSap.
 *
 *	Function Description:
 *		This routine is called when an application wishes to assign a 
 *		token.  The call is routed to the appropriate conference object.
 *
 *	Formal Parameters:
 *		conference_id					(i) The conference identifier value.
 *		registry_key					(i) Key identifying the session and
 *												resource ID.
 *
 *	Return Value:
 *		GCC_NO_ERROR					- No error.
 *		GCC_INVALID_CONFERENCE			- Conference not found to exist.
 *		GCC_ALLOCATION_FAILURE			- A resource error occurred.
 *		GCC_BAD_REGISTRY_KEY			- The registry key is invalid.
 *		GCC_APP_NOT_ENROLLED			- Requesting application is not
 *										  		enrolled with the conference.
 *
 *  Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */


/*
 *	GCCError   		GCCRegistrySetParameterRequest (
 *								GCCConfID		 	conference_id,
 *								PGCCRegistryKey			registry_key,
 *								LPOSTR      			parameter_value,
 *								GCCModificationRights	modification_rights	);
 *
 *	Public member function of CAppSap.
 *
 *	Function Description:
 *		This routine is called when an application wishes to set a 
 *		parameter.  The call is routed to the appropriate conference object.
 *
 *	Formal Parameters:
 *		conference_id					(i) The conference identifier value.
 *		registry_key					(i) Key identifying the session and
 *												resource ID.
 *		parameter_value					(i) String identifying the parameter
 *												to set.
 *		modification_rights				(i) Structure specifying the rights
 *												to be allowed for modifying
 *												the registry parameter.
 *
 *	Return Value:
 *		GCC_NO_ERROR					- No error.
 *		GCC_INVALID_CONFERENCE			- Conference not found to exist.
 *		GCC_ALLOCATION_FAILURE			- A resource error occurred.
 *		GCC_BAD_REGISTRY_KEY			- The registry key is invalid.
 *		GCC_APP_NOT_ENROLLED			- Requesting application is not
 *										  		enrolled with the conference.
 *		GCC_INVALID_MODIFICATION_RIGHTS	- The modification rights passed in
 *											were not valid.
 *
 *  Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */


/*
 *	GCCError		GCCRegistryRetrieveEntryRequest(
 *								GCCConfID		conference_id,
 *								PGCCRegistryKey		registry_key);
 *
 *	Public member function of CAppSap.
 *
 *	Function Description:
 *		This routine is called when an application wishes to retrieve a registry 
 *		entry.  The call is routed to the appropriate conference object.
 *
 *	Formal Parameters:
 *		conference_id					(i) The conference identifier value.
 *		registry_key					(i) Key identifying the session and
 *												resource ID.
 *
 *	Return Value:
 *		GCC_NO_ERROR					- No error.
 *		GCC_INVALID_CONFERENCE			- Conference not found to exist.
 *		GCC_ALLOCATION_FAILURE			- A resource error occurred.
 *		GCC_BAD_REGISTRY_KEY			- The registry key is invalid.
 *		GCC_APP_NOT_ENROLLED			- Requesting application is not
 *										  		enrolled with the conference.
 *
 *  Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */


/*
 *	GCCError		GCCRegistryDeleteEntryRequest(
 *								GCCConfID		conference_id,
 *								PGCCRegistryKey		registry_key);
 *
 *	Public member function of CAppSap.
 *
 *	Function Description:
 *		This routine is called when an application wishes to delete a registry 
 *		entry.  The call is routed to the appropriate conference object.
 *
 *	Formal Parameters:
 *		conference_id					(i) The conference identifier value.
 *		registry_key					(i) Key identifying the session and
 *												resource ID.
 *
 *	Return Value:
 *		GCC_NO_ERROR					- No error.
 *		GCC_INVALID_CONFERENCE			- Conference not found to exist.
 *		GCC_ALLOCATION_FAILURE			- A resource error occurred.
 *		GCC_BAD_REGISTRY_KEY			- The registry key is invalid.
 *		GCC_APP_NOT_ENROLLED			- Requesting application is not
 *										 		enrolled with the conference.
 *
 *  Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */


/*
 *	GCCError		GCCRegistryMonitorRequest (
 *								GCCConfID		conference_id,
 *								BOOL			enable_delivery,
 *								PGCCRegistryKey		registry_key );
 *
 *	Public member function of CAppSap.
 *
 *	Function Description:
 *		This routine is called when an application wishes to monitor a 
 *		particular registry entry.  The call is routed to the appropriate 
 *		conference object.
 *
 *	Formal Parameters:
 *		conference_id					(i) The conference identifier value.
 *		enable_delivery					(i) Flag indicating whether to turn
 *												monitoring on or off.
 *		registry_key					(i) Key identifying the session and
 *												resource ID.
 *
 *	Return Value:
 *		GCC_NO_ERROR					- No error.
 *		GCC_INVALID_CONFERENCE			- Conference not found to exist.
 *		GCC_ALLOCATION_FAILURE			- A resource error occurred.
 *		GCC_BAD_REGISTRY_KEY			- The registry key is invalid.
 *		GCC_APP_NOT_ENROLLED			- Requesting application is not
 *										  		enrolled with the conference.
 *
 *  Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */


/*
 *	GCCError		GCCRegistryAllocateHandleRequest (
 *								GCCConfID		conference_id,
 *								UINT				number_of_handles );
 *
 *	Public member function of CAppSap.
 *
 *	Function Description:
 *		This routine is called when an application wishes to allocate one or 
 *		more handles.  The call is routed to the appropriate conference object.
 *
 *	Formal Parameters:
 *		conference_id					(i) The conference identifier value.
 *		number_of_handles				(i) The number of handles to allocate.
 *
 *	Return Value:
 *		GCC_NO_ERROR					- No error.
 *		GCC_INVALID_CONFERENCE			- Conference not found to exist.
 *		GCC_BAD_NUMBER_OF_HANDLES		- The number of handles requested is
 *												not within the allowable range.
 *		GCC_ALLOCATION_FAILURE			- A resource error occurred.
 *		GCC_BAD_REGISTRY_KEY			- The registry key is invalid.
 *		GCC_APP_NOT_ENROLLED			- Requesting application is not
 *										  enrolled with the conference.
 *
 *  Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */


/*
 *	GCCError		PermissionToEnrollIndication(
 *								GCCConfID		conference_id,
 *								PGCCConferenceName	conference_name,
 *								GCCNumericString	conference_modifier,
 *								BOOL			permission_is_granted);
 *
 *	Public member function of CAppSap.
 *
 *	Function Description:
 *		This routine is called from a conference object when it wishes to send 
 *		an indication to the user application notifying it of a "permission to 
 *		enroll" event.  This does not mean that permission to enroll is
 *		necessarily granted to the application.  It may mean that permission is
 *		being revoked.
 *
 *	Formal Parameters:
 *		conference_id					(i) The conference identifier value.
 *		conference_name					(i) The conference name.
 *		conference_modifier				(i) The confererence modifier.
 *		permission_is_granted			(i) Flag indicating whether or not
 *												permission to enroll is granted.
 *
 *	Return Value:
 *		GCC_NO_ERROR				- No error.
 *		GCC_ALLOCATION_FAILURE		- A resource allocation error occurred.
 *
 *  Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */



/*
 *	GCCError	AppEnrollConfirm(GCCAppEnrollConfirm *);
 *								GCCConfID			conference_id,
 *								PGCCSessionKey			session_key,
 *								UINT					entity_id,
 *								UserID					node_id,
 *								GCCResult				result);
 *
 *	Public member function of CAppSap.
 *
 *	Function Description:
 *		This routine is called by the CConf object when it wishes
 *		to send an enrollment confirmation to the user application.
 *
 *	Formal Parameters:
 *		conference_id				(i) The conference identifier value.
 *		session_key					(i) The key identifying the session.
 *		entity_id					(i) The ID for this instance of the 
 *											application.
 *		node_id						(i) ID for this node.
 *		result						(i) Result code indicating whether or not
 *											the enrollment was successful.
 *
 *	Return Value:
 *		GCC_NO_ERROR					- No error.
 *		GCC_ALLOCATION_FAILURE			- A resource error occurred.
 *		GCC_BAD_SESSION_KEY				- The session key is invalid.
 *
 *  Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */


/*
 *	GCCError	RegistryConfirm (
 *						GCCConfID			conference_id,
 *						GCCMessageType			message_type,
 *						CRegKeyContainer        *registry_key_data,
 *						CRegItem                *registry_item_data,
 *						GCCModificationRights	modification_rights,
 *						UserID					owner_id,
 *						EntityID				entity_id,
 *						BOOL				enable_monitoring,
 *						GCCResult				result);
 *
 *	Public member function of CAppSap.
 *
 *	Function Description:
 *		This command target routine is called by the CConf object when it
 *		wishes to send an registry confirmation to the user application.
 *
 *	Formal Parameters:
 *		conference_id				(i) The conference identifier value.
 *		message_type				(i) Indicates what type of registry item
 *											confirm this is.
 *		registry_key_data			(i) Object holding the registry key.
 *		registry_item_data			(i) Object holding the registry item.
 *		modification_rights			(i) Structure specifying the rights
 *											to be allowed for modifying
 *											the registry parameter.
 *		owner_id					(i) The ID of the owner of the registry item
 *		entity_id					(i) The ID for this instance of the 
 *											application.
 *		enable_monitoring			(i) Flag indicating whether the registry
 *											item is to be monitored.
 *		result						(i) Result code indicating whether or not
 *											the registry request was successful.
 *
 *	Return Value:
 *		GCC_NO_ERROR					- No error.
 *		GCC_ALLOCATION_FAILURE			- A resource error occurred.
 *
 *  Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */


/*
 *	GCCError	RegistryMonitorIndication(	
 *								GCCConfID			conference_id,
 *								CRegKeyContainer        *registry_key_data,
 *								CRegItem                *registry_item_data,
 *								GCCModificationRights	modification_rights,
 *								UserID					owner_id,
 *								EntityID				owner_entity_id);
 *
 *	Public member function of CAppSap.
 *
 *	Function Description:
 *		This command target routine is called by the CConf object when it
 *		wishes to send a Registry monitor indication to the user application.
 *
 *	Formal Parameters:
 *		conference_id				(i) The conference identifier value.
 *		registry_key_data			(i) Object holding the registry key.
 *		registry_item_data			(i) Object holding the registry item.
 *		modification_rights			(i) Structure specifying the rights
 *											to be allowed for modifying
 *											the registry parameter.
 *		owner_id					(i) The ID of the owner of the registry item
 *		owner_entity_id				(i) The ID for the instance of the 
 *											application owning the registry.
 *
 *	Return Value:
 *		GCC_NO_ERROR					- No error.
 *		GCC_ALLOCATION_FAILURE			- A resource error occurred.
 *
 *  Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */


/*
 *	GCCError	RegistryAllocateHandleConfirm(	
 *								GCCConfID			conference_id,
 *								UINT					number_of_handles,
 *								UINT					first_handle,
 *								GCCResult				result);
 *
 *	Public member function of CAppSap.
 *
 *	Function Description:
 *		This routine is called by the CConf object when it wishes
 *		to send an enrollment confirmation to the user application.
 *
 *	Formal Parameters:
 *		conference_id				(i) The conference identifier value.
 *		number_of_handles			(i) The number of handles allocated.
 *		first_handle				(i) The first handle allocated.
 *		result						(i) Result code indicating whether or not
 *											the handle allocation was successful
 *
 *	Return Value:
 *		GCC_NO_ERROR					- No error.
 *		GCC_ALLOCATION_FAILURE			- A resource error occurred.
 *
 *  Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\remdsk\rds\t120\h\arostmgr.h ===
/*
 *	arostmgr.h
 *
 *	Copyright (c) 1995 by DataBeam Corporation, Lexington, KY
 *
 *	Abstract:
 *		A single instance of this class represents the owner of all the 
 *		Application Roster objects for a single "Application Protocol Key". The 
 *		CAppRosterMgr takes care of both the "Local" and "Global" 
 *		rosters for all the Sessions that exists which use the same Application 
 *		Protocol Key (peer applications).  Organizing ApplicationRosters this 
 *		way enables GCC to meet some of the requirements specified by the T.GAT 
 *		recommendation.  Specifically,  it enables GCC to deliver multiple 
 *		application rosters that a particular application might be interested in 
 *		a single application roster update indication.  It also hides much of 
 *		the complexity required to manage application rosters from the 
 *		CConf object.
 *
 *		To understand the responsibilities of the CAppRosterMgr it is 
 *		important to understand the meaning of a "Session" within the context 
 *		of GCC.  A "Session" is a logical entity that is used by a set of peer 
 *		Application Protocol Entities (APEs see T.GAT) to communicate.  When an 
 *		application enrolls with GCC it must specify the session it wishes to 
 *		enroll with by specifying a GCCSessionKey.  This session key includes an 
 *		Application Protocol Key and a session ID.  The enrolling application 
 *		must include an Application Protocol Key that is unique for that 
 *		particular APE (Application Protocol Entity see T.GAT).  When other APEs 
 *		in the conference enroll with the same GCCSessionKey, they all show up 
 *		in the same Application Roster.  This makes it possible for all the APEs 
 *		enrolled in the same session to determine who it is talking to who.
 *
 *		Note that it is possible for the same APE to be enrolled in multiple 
 *		sessions at the same time.  Typically the session that does not include 
 *		a session ID is considered the "Default" session for a particular APE.  
 *		The industry seems to be leaning toward using this default session to do 
 *		administrative task like announcing your capabilities to other APEs or 
 *		as a place to enroll inactively until you have time to join the channels 
 *		associated with the real session you want to enroll with.
 *
 *		An obvious requirement of the CAppRosterMgr is that it must 
 *		have the ability to deliver all the related rosters (the rosters 
 *		associated with all the sessions in existence for a particular APE) to 
 *		the enrolled User Application SAPs and to the Control SAP.  It must also 
 *		be able to manage the flow of PDU traffic to and from the application 
 *		rosters it manages.  Below is a more detailed description of the 
 *		responsibilities of the CAppRosterMgr.
 *
 *		The rules for when an CAppRosterMgr exist in a CConf object are 
 *		quite a bit more complex than with the CConfRosterMgr.  In the 
 *		later case, every node is explicitly required to maintain either a 
 *		single "Global" CConfRoster Manager (if it is a Top Provider node) 
 *		or both a "Local" and "Global" CConfRoster Manager (if it is a 
 *		subordinate node).  The existence of an CAppRosterMgr depends 
 *		entirely on an application being enrolled with the conference.  If no 
 *		applications are enrolled there are no ApplicationRosterManagers.  It 
 *		gets much more complicated if some nodes are servicing enrolled 
 *		applications while others are not.  This is often the case when a 
 *		dedicated MCU is in use.  Since an Application Roster's information base 
 *		is distributed throughout the CConf, this sometimes requires that 
 *		CAppRosterMgr objects exist at nodes that contain no enrolled 
 *		applications.
 *
 *		An CAppRosterMgr maintains both "Global" and "Local" rosters.  
 *		A "Local" CAppRoster consist of all the Application Roster 
 *		Records at its local node and below it in the connection hierarchy.  
 *		The CAppRosterMgr does not communicate any changes made to 
 *		"Local" ApplicationRosters to the CAppSap objects.  Its only input is 
 *		from either primitive calls at the local node or from Roster Update PDUs 
 *		received from subordinate nodes. A "Local" CAppRoster can only 
 *		exist at nodes that are not the Top Provider.  
 *
 *		A "Global" CAppRoster has a dual set of responsibilities 
 *		depending on whether or not it is at a Top Provider.  A "Global" roster 
 *		at a Top Provider is responsible for maintaining an Application Roster 
 *		that includes a record entry for every application in the CConf 
 *		that is enrolled with the same Application Protocol Key.  It is also 
 *		responsible for sending full application roster refreshes to all of its 
 *		subordinate nodes when changes to the roster occur.  All 
 *		ApplicationRosterManagers managing "Global" rosters (regardless of 
 *		location within the connection hierarchy) have the ability to send 
 *		Roster Update indications to their local enrolled CAppSap objects.  
 *		Pointers to CAppSap objects that have enrolled with the conference are 
 *		maintained in a list of enrolled ApplicationSaps.  These pointers are 
 *		passed in to this object whenever a new APE enrolls with an Application 
 *		Roster through a GCC primitive at the local node. Application Rosters 
 *		are propagated up to the enrolled applications through Command Target 
 *		calls to the ApplicationSap object.  The CAppRosterMgr also 
 *		maintains a pointer to the CControlSAP object.  Remember all roster 
 *		updates are directed to both the appropriate application SAPs and to the 
 *		Control SAP.  
 *
 *		ApplicationRosterManagers are also responsible for receiving full 
 *		refreshes of the Application Roster from the Top Provider and passing 
 *		them on to the appropriate "Global" CAppRoster object it 
 *		maintains.  It also sends (as mentioned above) Roster Update indications 
 *		to the enrolled Application SAP objects and the Control SAP via 
 *		CAppRosterMsg objects.
 *
 *		All PDUs and messages are delivered when the CAppRosterMgr is 
 *		flushed.  This is a very important concept in that it allows an 
 *		CAppRosterMgr to process a number of request and PDUs before 
 *		actually being flushed.  The CAppRoster itself will queue up 
 *		changes to a PDU that can consist of either multiple updates or a single 
 *		refresh and will not free it until after it is flushed.  Therefore, when 
 *		processing a roster update PDU that consists of changes to the 
 *		conference roster as well as multiple application rosters, a roster 
 *		refresh PDU can be held back until all the roster managers have had a 
 *		chance to process their portion of the roster update.  Once complete, a 
 *		single PDU can be built by flushing the CConfRosterMgr and all 
 *		the affected ApplicationRosterManagers.
 *
 *	Caveats:
 *		None.
 *
 *	Author:
 *		blp
 */
#ifndef	_APPLICATION_ROSTER_MANAGER_
#define	_APPLICATION_ROSTER_MANAGER_

#include "gccpdu.h"
#include "mcsuser.h"
// #include "gcmdtar.h"
#include "arost.h"
#include "sesskey.h"
#include "clists.h"


class CAppRosterMgr : public CRefCount
{
public:

	CAppRosterMgr(PGCCSessionKey,
            		PSessionKey, // PDU
            		GCCConfID,
            		PMCSUser,
            		CConf *,
            		PGCCError);

	~CAppRosterMgr(void);

    GCCError    EnrollRequest(GCCEnrollRequest *, GCCEntityID, GCCNodeID, CAppSap *);
	GCCError	UnEnrollRequest(PGCCSessionKey, GCCEntityID);

	GCCError	ProcessRosterUpdateIndicationPDU(PSetOfApplicationInformation, UserID uidSender);

	PSetOfApplicationInformation    FlushRosterUpdateIndication(PSetOfApplicationInformation *, PGCCError);
	PSetOfApplicationInformation    GetFullRosterRefreshPDU(PSetOfApplicationInformation *, PGCCError);
					
	BOOL	IsThisYourSessionKey(PGCCSessionKey pSessKey) { return IsThisSessionKeyValid(pSessKey); }
	BOOL	IsThisYourSessionKeyPDU(PSessionKey pSessKey) { return IsThisSessionKeyPDUValid(pSessKey); }

	GCCError	RemoveEntityReference(GCCEntityID);
	GCCError	RemoveUserReference(UserID uidDetached);
					
	GCCError	ApplicationRosterInquire(PGCCSessionKey, CAppRosterMsg *);

	BOOL		IsEntityEnrolled(GCCEntityID);
	BOOL		IsAPEEnrolled(GCCNodeID, GCCEntityID);
	BOOL		IsAPEEnrolled(CSessKeyContainer *, GCCNodeID, GCCEntityID);
	BOOL		IsEmpty(void);

    void    DeleteRosterRecord(GCCNodeID, GCCEntityID);

private:

	GCCError	SendRosterReportMessage(void);
	
	CAppRoster	*GetApplicationRoster(PGCCSessionKey, CAppRosterList *);
	CAppRoster	*GetApplicationRosterFromPDU(PSessionKey, CAppRosterList *);

	BOOL	IsThisSessionKeyValid(PGCCSessionKey pSessKey)
		{ return m_pSessionKey->IsThisYourApplicationKey(&pSessKey->application_protocol_key); }

	BOOL	IsThisSessionKeyPDUValid(PSessionKey pSessKey)
		{ return m_pSessionKey->IsThisYourApplicationKeyPDU(&pSessKey->application_protocol_key); }

	void				CleanupApplicationRosterLists(void);

private:

	GCCConfID   					m_nConfID;
	BOOL							m_fTopProvider;
	PMCSUser						m_pMcsUserObject;
	CAppSapEidList2 			    m_AppSapEidList2;
	CConf							*m_pConf;
	CAppRosterList					m_GlobalRosterList;
	CAppRosterList					m_LocalRosterList;
	CAppRosterList					m_RosterDeleteList;
	CSessKeyContainer			    *m_pSessionKey;
};


#endif // _APPLICATION_ROSTER_MANAGER_

/*
 *	CAppRosterMgr	(
 *                     	PGCCSessionKey					session_key,
 *						GCCConfID   					conference_id,
 *						PMCSUser						user_object,
 *						UINT        					owner_message_base,
 *						CControlSAP				        *pControlSap,
 *						PGCCError						return_value)
 *
 *	Public Function Description
 *		This is the application roster manager constructor. It is responsible 
 *		for initializing all the instance variables used by this class.
 *		This constructor is used when the initial roster data that is
 *		availble comes from local API data.
 *
 *	Formal Parameters:
 *		session_key			-	(i)	"API" Session Key used to establish the 
 *									application protocol key for this session.
 *		conference_id		-	(i)	Conference ID associated with this roster
 *									maanger.
 *		user_object			-	(i)	Pointer to the user attachment object used
 *									by this class.
 *		owner_object		-	(i)	Pointer to the owner object.
 *		owner_message_base	-	(i)	Message base to add to all the owner 
 *									callbacks.
 *		control_sap			-	(i)	Pointer to the node controller SAP object.
 *		return_value		-	(o)	Pointer to error value to be returned.
 *		
 *
 *	Return Value
 *		GCC_NO_ERROR				-	No resource error occured.
 *		GCC_ALLOCATION_FAILURE		-	A resource error occured.
 *
 *  Side Effects
 *		None.
 *
 *	Caveats
 *		None.
 */

/*
 *	CAppRosterMgr	(
 *						PSessionKey						session_key,
 *						GCCConfID   					conference_id,
 *						PMCSUser						user_object,
 *						UINT        					owner_message_base,
 *						CControlSAP				        *pControlSap,
 *						PGCCError						return_value)
 *
 *	Public Function Description
 *		This is the application roster manager constructor. It is responsible 
 *		for initializing all the instance variables used by this class.
 *		This constructor is used when the initial roster data that is
 *		availble comes from remote PDU data.
 *
 *		This constructor handles a number of different possiblities:
 *			For Non Top Providers:
 *				1)	A refresh received from the top provider.
 *				2)	An update from a node below this one.
 *
 *			For the Top Provider:
 *				1)	An Update from a lower node
 *
 *	Formal Parameters:
 *		session_key			-	(i)	"PDU" Session Key used to establish the 
 *									application protocol key for this session.
 *		conference_id		-	(i)	Conference ID associated with this roster
 *									maanger.
 *		user_object			-	(i)	Pointer to the user attachment object used
 *									by this class.
 *		owner_object		-	(i)	Pointer to the owner object.
 *		owner_message_base	-	(i)	Message base to add to all the owner 
 *									callbacks.
 *		control_sap			-	(i)	Pointer to the node controller SAP object.
 *		return_value		-	(o)	Pointer to error value to be returned.
 *		
 *
 *	Return Value
 *		GCC_NO_ERROR				-	No resource error occured.
 *		GCC_ALLOCATION_FAILURE		-	A resource error occured.
 *
 *  Side Effects
 *		None.
 *
 *	Caveats
 *		None.
 */

/*
 *	~ApplicationRosterManager ()
 *
 *	Public Function Description
 *		This is the application roster manager destructor.  It is used to
 *		free up all memory associated with this class.
 *
 *	Formal Parameters:
 *		None.
 *
 *	Return Value
 *		None.
 *
 *  Side Effects
 *		None.
 *
 *	Caveats
 *		None.
 */

/*
 *	GCCError	EnrollRequest (
 *                      PGCCSessionKey					session_key,
 *	        			PGCCApplicationRecord			application_record,
 *						EntityID						entity_id,
 *						UINT							number_of_capabilities,
 *						PGCCApplicationCapability	*	capabilities_list)
 *
 *	Public Function Description
 *		This routine is called whenever an APE wishes to enroll with the
 *		conference in a specific session.  This routine can be used to
 *		either add a new record or replace a currently existing record.
 *
 *	Formal Parameters:
 *		session_key				-	(i)	Session to enroll with.
 *		application_record		-	(i)	Application record to enroll with.
 *		entity_id				-	(i)	Entity ID of enrolling APE.
 *		number_of_capabilities	-	(i)	Number of capabilities in caps list.
 *		capabilities_list		-	(i)	list of capabilities that the APE is
 *										enrolling with.
 *		command_target			-	(i)	Pointer to APE SAP that is enrolling.
 *
 *	Return Value
 *		GCC_NO_ERROR					-	No error occured.
 *		GCC_BAD_SESSION_KEY				-	Session key passed in is invalid.
 *		GCC_ALLOCATION_FAILURE			-	A resource error occured.
 *		GCC_INVALID_NON_COLLAPSED_CAP	-	Bad non-collapsed capabilities.
 *		GCC_INVALID_PARAMETER			-	Invalid parameter passed in.
 *
 *  Side Effects
 *		None.
 *
 *	Caveats
 *		None.
 */

/*
 *	GCCError	UnEnrollRequest (
 *                     	PGCCSessionKey					session_key,
 *						EntityID						entity_id)
 *
 *	Public Function Description
 *		This routine is called whenever an APE wishes to unenroll from the
 *		conference (or a specific session).
 *
 *	Formal Parameters:
 *		session_key				-	(i)	Session to unenroll from.
 *		entity_id				-	(i)	Entity ID of unenrolling APE.
 *
 *	Return Value
 *		GCC_NO_ERROR					-	No error occured.
 *		GCC_BAD_SESSION_KEY				-	Session key passed in is invalid.
 *		GCC_APP_NOT_ENROLLED			-	APE is not enrolled with this
 *											session..
 *		GCC_INVALID_PARAMETER			-	Invalid parameter passed in.
 *
 *  Side Effects
 *		None.
 *
 *	Caveats
 *		None.
 */

/*
 *	GCCError	ProcessRosterUpdateIndicationPDU(
 *						PSetOfApplicationInformation	set_of_application_info,
 *						UserID							sender_id)
 *
 *	Public Function Description
 *		This routine processes an incomming roster update PDU.  It is
 *		responsible for passing the PDU on to the right application roster.
 *
 *	Formal Parameters:
 *		set_of_application_info	-	(i)	PDU data to process
 *		sender_id				-	(i)	Node ID that sent the update.
 *
 *	Return Value
 *		GCC_NO_ERROR					-	No error occured.
 *		GCC_BAD_SESSION_KEY				-	Session key passed in is invalid.
 *		GCC_ALLOCATION_FAILURE			-	A resource error occured.
 *		GCC_INVALID_PARAMETER			-	Invalid parameter passed in.
 *
 *  Side Effects
 *		None.
 *
 *	Caveats
 *		None.
 */

/*
 *	PSetOfApplicationInformation	FlushRosterUpdateIndication (
 *						PSetOfApplicationInformation *	set_of_information,
 *						PGCCError						return_value)
 *
 *	Public Function Description
 *		This routine is used to access any PDU data that might currently be
 *		queued inside the application rosters managed by this application
 *		roster manager.  It also is responsible for flushing any queued 
 *		roster update messages if necessary.
 *
 *	Formal Parameters:
 *		set_of_information	-	(o)	Pointer PDU to fill in.
 *		return_value		-	(o)	Error return here.
 *
 *	Return Value
 *		Pointer to the new set of application information.
 *
 *  Side Effects
 *		None.
 *
 *	Caveats
 *		None.
 */

/*
 *	PSetOfApplicationInformation	GetFullRosterRefreshPDU (
 *						PSetOfApplicationInformation *	set_of_information,
 *						PGCCError						return_value)
 *
 *	Public Function Description
 *		This routine is used to obtain a complete roster refresh of all the
 *		rosters maintained by this roster manger.
 *
 *	Formal Parameters:
 *		set_of_information	-	(o)	Pointer PDU to fill in.
 *		return_value		-	(o)	Error return here.
 *
 *	Return Value
 *		Pointer to the new set of application information.
 *
 *  Side Effects
 *		None.
 *
 *	Caveats
 *		None.
 */

/*
 *	BOOL	IsThisYourSessionKey(
 *						PGCCSessionKey					session_key)
 *
 *	Public Function Description
 *		This routine is used to determine if the specified "API" session key is
 *		associated with this application roster manager.
 *
 *	Formal Parameters:
 *		session_key		-	(i)	"API" session key to test.
 *
 *	Return Value
 *		TRUE	-	If session key is associated with this manager.
 *		FALSE	-	If session key is NOT associated with this manager.
 *
 *  Side Effects
 *		None.
 *
 *	Caveats
 *		None.
 */

/*
 *	BOOL	IsThisYourSessionKeyPDU(
 *						PSessionKey						session_key);
 *
 *	Public Function Description
 *		This routine is used to determine if the specified "PDU" session key is
 *		associated with this application roster manager.
 *
 *	Formal Parameters:
 *		session_key		-	(i)	"PDU" session key to test.
 *
 *	Return Value
 *		TRUE	-	If session key is associated with this manager.
 *		FALSE	-	If session key is NOT associated with this manager.
 *
 *  Side Effects
 *		None.
 *
 *	Caveats
 *		None.
 */

/*
 *	GCCError	RemoveEntityReference(
 *						EntityID						application_entity)
 *
 *	Public Function Description
 *		This routine is used to remove the specified APE entity from the 
 *		session it is enrolled with.  Note that this routine is only used
 *		to remove local entity references.
 *
 *	Formal Parameters:
 *		application_entity	-	(i)	Entity reference to remove.
 *
 *	Return Value
 *		GCC_NO_ERROR			-	Entity was removed.
 *		GCC_INVALID_PARAMETER	-	Entity does not exist here.
 *
 *  Side Effects
 *		None.
 *
 *	Caveats
 *		None.
 */

/*
 *	GCCError	RemoveUserReference(
 *						UserID							detached_user)
 *
 *	Public Function Description
 *		This routine is used to remove all references associated with the
 *		node defined by the detached user.
 *
 *	Formal Parameters:
 *		detached_user	-	(i)	User reference to remove.
 *
 *	Return Value
 *		GCC_NO_ERROR			-	User reference was removed.
 *		GCC_INVALID_PARAMETER	-	No records associated with this node.
 *
 *  Side Effects
 *		None.
 *
 *	Caveats
 *		None.
 */

/*
 *	BOOL	IsEntityEnrolled(
 *						EntityID						entity_id)
 *
 *	Public Function Description
 *		This routine informs the caller if the specified entity is enrolled
 *		with any sessions managed by this application roster manager.
 *
 *	Formal Parameters:
 *		entity_id	-	(i)	Entity to test.
 *
 *	Return Value
 *		TRUE	-	Entity is enrolled.
 *		FALSE	-	Entity is not enrolled.
 *
 *  Side Effects
 *		None.
 *
 *	Caveats
 *		None.
 */

/*
 *	GCCError	ApplicationRosterInquire (
 *						PGCCSessionKey					session_key,
 *						CAppRosterMsg					*roster_message)
 *
 *	Public Function Description
 *		This routine inserts the appropriate application rosters into the
 *		roster message that is passed in.  If the specified session key is set
 *		to NULL or a session ID of zero is passed in, all the global rosters 
 *		managed by this object will be returned.  Otherwise, only the
 *		specified session roster will be returned.
 *
 *	Formal Parameters:
 *		session_key		- (i) Session key defining roster being inquired about.
 *		roster_message 	- (o) Roster message to fill in.	
 *
 *	Return Value
 *		GCC_NO_ERROR			-	No error occured.
 *		GCC_ALLOCATION_FAILURE	-	A resource error occured.
 *
 *  Side Effects
 *		None.
 *
 *	Caveats
 *		None.
 */

/*
 *	BOOL	IsAPEEnrolled(
 *						UserID							node_id,
 *						EntityID						entity_id)
 *
 *	Public Function Description
 *		This routine determines if the specified APE is enrolled with one
 *		of the sessions managed by this application roster manager.
 *
 *	Formal Parameters:
 *		node_id		- (i) Node ID of APE to test.
 *		entity_id 	- (i) Entity ID of APE to test.	
 *
 *	Return Value
 *		TRUE	-	APE is enrolled here.
 *		FALSE	-	APE is not enrolled here.
 *
 *  Side Effects
 *		None.
 *
 *	Caveats
 *		None.
 */

/*
 *	BOOL	IsAPEEnrolled(
 *						CSessKeyContainer			    *session_key_data,
 *						UserID							node_id,
 *						EntityID						entity_id)
 *
 *	Public Function Description
 *		This routine determines if the specified APE is enrolled with the
 *		specified session.
 *
 *	Formal Parameters:
 *		session_key_data	- (i) Session Key of roster to check.
 *		node_id				- (i) Node ID of APE to test.
 *		entity_id 			- (i) Entity ID of APE to test.	
 *
 *	Return Value
 *		TRUE	-	APE is enrolled with this session.
 *		FALSE	-	APE is not enrolled with this session.
 *
 *  Side Effects
 *		None.
 *
 *	Caveats
 *		None.
 */

/*
 *	BOOL	IsEmpty(void)
 *
 *	Public Function Description
 *		This routine determines if this application roster managfer contains
 *		any application rosters.
 *
 *	Formal Parameters:
 *		None.
 *
 *	Return Value
 *		TRUE	-	Application Roster Manager is empty.
 *		FALSE	-	Application Roster Manager is NOT empty.
 *
 *  Side Effects
 *		None.
 *
 *	Caveats
 *		None.
 */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\remdsk\rds\t120\h\arostmsg.h ===
/*
 *	arostmsg.h
 *
 *	Copyright (c) 1995 by DataBeam Corporation, Lexington, KY
 *
 *	Abstract:
 *
 *	Caveats:
 *		None.
 *
 *	Author:
 *		blp/jbo
 */
#ifndef	_APPLICATION_ROSTER_MESSAGE_
#define	_APPLICATION_ROSTER_MESSAGE_

#include "arost.h"
#include "clists.h"

class CAppRosterMsg : public CRefCount
{
public:

	CAppRosterMsg(void);
	~CAppRosterMsg(void);

	GCCError		LockApplicationRosterMessage(void);
	void			UnLockApplicationRosterMessage(void);

	GCCError		GetAppRosterMsg(LPBYTE *ppData, ULONG *pcRosters);

    void            AddRosterToMessage(CAppRoster *);

private:

	CAppRosterList		    m_AppRosterList;
	LPBYTE					m_pMsgData;
};

#endif // _APPLICATION_ROSTER_MESSAGE_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\remdsk\rds\t120\h\arost.h ===
/*
 *	arost.h
 *
 *	Copyright (c) 1995 by DataBeam Corporation, Lexington, KY
 *
 *	Abstract:
 *		Instances of this class represent a single Application Roster's 
 *		information base. This includes both application record information and 
 *		capabilities information.  This is one of the most complex classes in 
 *		all of GCC.  It has a number of responsibilities and must maintain the 
 *		information in a very structured way to preserve the connection 
 *		hierarchy of the records.  This is necessary so that collapsed 
 *		capabilities lists can be calculated as changes to the roster are 
 *		propagated up to the Top Provider.
 *
 *		Similar to the CConfRoster class, the CAppRoster class 
 *		encapsulates all the functionality required to maintain the roster 
 *		information base which includes the ability to add new records, delete 
 *		records and update records. It has the ability to convert its internal 
 *		information base into a list of application records that can be used in 
 *		a GCC_APP_ROSTER_UPDATE_INDICATION callback.  It is also responsible for 
 *		converting its internal information base into Roster Update PDUs.  
 *		Basically,  this class is responsible for all operations that require 
 *		direct access to the records contained in an Application Roster.
 *
 *		The CAppRoster class is also responsible for maintaining the 
 *		capabilities list.  This includes storage as well as calculation of the 
 *		collapsed capabilities list.  This class is also responsible for 
 *		converting the internal capabilities list information base into a list 
 *		that can be used in a GCC_APP_ROSTER_UPDATE_INDICATION callback. It is 
 *		also responsible for converting its internal capabilities list 
 *		information base into the capabilities list portion of a Roster Update 
 *		PDU.  Basically,  this class is responsible for all operations that 
 *		require direct access to the capabilities list.
 *
 *		An Application Roster object has the ability to serialize its roster 
 *		data into a single contiguous memory block when it is required to send a 
 *		message to the application interface.  This serialization process is 
 *		managed externally by the CAppRosterMsg class through calls 
 *		to LockApplicationRoster(), UnLockApplicationRoster() and 
 *		GetAppRoster().  When an Application Roster is to be serialized, 
 *		a call is made to LockApplicationRoster() which causes the 
 *		CAppRoster object to increment an internal lock count and returns 
 *		the number of bytes required to hold the complete roster update.  The 
 *		Application Roster is then serialized into memory through a call to 
 *		GetAppRoster().  The CAppRoster is then unlocked to allow 
 *		it to be deleted when the free flag gets set through the 
 *		FreeApplicationRoster() function.  In the current implementation of GCC, 
 *		FreeApplicationRoster() is not used since the CAppRosterMsg 
 *		maintains the data used to deliver the message (see a more detailed 
 *		description of the lock, free and unlock mechanism in the section 
 *		describing the data containers).
 *
 *		The Application Roster class incorporates a number of Rogue Wave list to 
 *		both hold the roster record information and to maintain the connection 
 *		hierarchy.  In many cases there are lists which contain lists.  The 
 *		details of this get extremely complicated.  The Application Roster 
 *		object also is responsible for maintaining internal PDU data which is 
 *		updated whenever a change occurs to its internal information base.  This 
 *		PDU can be affected by both local request or by processing incoming 
 *		PDUs.  Higher level objects access this PDU data by calling the 
 *		Application Roster's flush routine which in turn causes the PDU to be 
 *		freed on any subsequent request that affects the rosters internal 
 *		information base.
 *
 *	Caveats:
 *		None.
 *
 *	Author:
 *		blp/jbo
 */
#ifndef	_APPLICATION_ROSTER_
#define	_APPLICATION_ROSTER_

#include "gccpdu.h"
#include "capid.h"
#include "sesskey.h"
#include "appcap.h"
#include "igccapp.h"


typedef enum
{
	APP_ADD_RECORD,
	APP_DELETE_RECORD,
	APP_REPLACE_RECORD,
	APP_FULL_REFRESH,
	APP_NO_CHANGE
}
	APP_ROSTER_UPDATE_TYPE;

/*
**	Holds list of capabilities "list" for each protocol entity at a single node.
**	Remember that there can be multiple protocol entities with identical session
**	keys at a single node. Also remember that each of these protocol entities
**	can have multiple capabilities.
*/
class CListOfAppCapItemList2 : public CList2
{
    DEFINE_CLIST2_(CListOfAppCapItemList2, CAppCapItemList*, EntityID)
    void DeleteList(void);
};

/*
**	This is the definition for a single application record.  All the application
**	information (except collapsed capability info) is contained as part of this 
**	record.
*/
typedef struct APP_RECORD
{
	BOOL								is_enrolled_actively;
	BOOL								is_conducting_capable;
	BOOL								was_conducting_capable;
	MCSChannelType						startup_channel_type; 
	UserID								application_user_id;
	CAppCapItemList						non_collapsed_caps_list;
}
	APP_RECORD;

/*
**	This list is used to keep track of the application records at a single node.
**	Since you can have multiple "Protocol Entities" at a single node we use
**	the entity id (which is unique at a node) to index into this list.
*/
class CAppRecordList2 : public CList2
{
    DEFINE_CLIST2_(CAppRecordList2, APP_RECORD*, EntityID)
};


/*
**	This list is used to hold the application record lists for each sub-node
**	of a particular node.
*/
class CSubNodeListOfRecordList2 : public CList2
{
    DEFINE_CLIST2_(CSubNodeListOfRecordList2, CAppRecordList2*, UserID)
};

/*
**	APP_NODE_RECORD
**
**	Below are all the definitions for the application node record. An 
**	application node record holds all the application information for either the
**	local node or a directly connected node.  Note that if the node is the Top 
**	Provider the AppRosterRecordList list will contain information about every
**	"matching" application protocol entity in the entire system.  Matching here
**	means APE's that have the same session key.  
** 
**	An application "roster" record contains all of the following:
**
**	AppRecordList	- 			The list of app records for the protocol 
**								entities at this node.
**
**	ListOfAppCapItemList2 -	    This list holds the list of capabilities for
**								each protocol entity at this node.
**
**	SubNodeList2 -				This list holds the app_record_list for all the
**								nodes below this node in the connection 
**								hierarchy.
**
**	CollapsedCapList -			This holds the collapsed capabilities for
**								all the nodes below this one in the connection
**								hierarchy.  Note that the 
**					   			list_of_capabilities_list is not included in
**								this collapsed list.
**
**	Notice that there is a constructor within this structure. This is
**	needed for the two hash list dictionaries that get instantiated when
**	an AppRosterRecord structure gets instantiated.
*/
typedef struct APP_NODE_RECORD
{
	APP_NODE_RECORD(void);

	CAppRecordList2					AppRecordList;
	CListOfAppCapItemList2		    ListOfAppCapItemList2;
	CSubNodeListOfRecordList2		SubNodeList2;
	CAppCapItemList    				CollapsedCapList;
}
    APP_NODE_RECORD;


/*
**	This list holds all roster records of nodes that are directly connected to 
**	this node.  This list also includes the application records for the local 
**	Application	Protocol entities.  Note that all nodes below this node that
**	are not directly connected to this node are contained in the sub-node list 
**	of the various APP_NODE_RECORD(s) that are contained in this list.
*/
//
// LONCHANC: Can CAppNodeRecordList2 be part of CAppRoster?
// why it is separated from CAppRoster???
//
class CAppNodeRecordList2 : public CList2
{
    DEFINE_CLIST2_(CAppNodeRecordList2, APP_NODE_RECORD*, UserID)
};


class CAppRosterMgr;

class CAppRoster : public CRefCount
{
public:

	CAppRoster(
			PGCCSessionKey,
			PSessionKey,
			CAppRosterMgr *,
			BOOL			fTopProvider,
			BOOL			fLocalRoster,
			BOOL			fMaintainPduBuffer,
			PGCCError);

	~CAppRoster(void);

	/*
	 * Utilities that operate on roster update PDU strucutures.
	 */
	void		FlushRosterUpdateIndicationPDU(PSetOfApplicationInformation *);
	GCCError	BuildFullRefreshPDU(void);
	GCCError	ProcessRosterUpdateIndicationPDU(PSetOfApplicationInformation, UserID);

	/*
	 * Utilities that operate on application records.
	 */
	UINT			LockApplicationRoster(void);
	void			UnLockApplicationRoster(void);
	UINT			GetAppRoster(PGCCApplicationRoster, LPBYTE pData);

	GCCError		AddRecord(GCCEnrollRequest *, GCCNodeID, GCCEntityID);
	GCCError		RemoveRecord(GCCNodeID, GCCEntityID);
	GCCError		ReplaceRecord(GCCEnrollRequest *, GCCNodeID, GCCEntityID);

	GCCError		RemoveUserReference(UserID);

	UINT			GetNumberOfApplicationRecords(void);

	CSessKeyContainer *GetSessionKey(void) { return m_pSessionKey; }

	void			ResetApplicationRoster(void);

	BOOL			DoesRecordExist(UserID, EntityID);

	BOOL			HasRosterChanged(void) { return m_fRosterHasChanged; }

private:

	/*
	 * Utilities used to create a roster update indication PDU.
	 */
	GCCError	BuildApplicationRecordListPDU(APP_ROSTER_UPDATE_TYPE, UserID, EntityID);
	GCCError	BuildSetOfRefreshesPDU(void);
	GCCError	BuildSetOfUpdatesPDU(APP_ROSTER_UPDATE_TYPE, UserID, EntityID);
	GCCError	BuildApplicationRecordPDU(APP_RECORD *, PApplicationRecord);
	GCCError	BuildSetOfCapabilityRefreshesPDU(void);
	GCCError	BuildSetOfNonCollapsingCapabilitiesPDU(PSetOfNonCollapsingCapabilities *, CAppCapItemList *);

	/*
	 * Utilities used to Free a roster update indication PDU.
	 */
	void		FreeRosterUpdateIndicationPDU(void);
	void		FreeSetOfRefreshesPDU(void);
	void		FreeSetOfUpdatesPDU(void);
	void		FreeSetOfCapabilityRefreshesPDU(void);
	void		FreeSetOfNonCollapsingCapabilitiesPDU(PSetOfNonCollapsingCapabilities);
														
	/*
	 * Utilities used to Process roster update indications.
	 */
	GCCError	ProcessSetOfRefreshesPDU(PSetOfApplicationRecordRefreshes, UserID uidSender);
	GCCError	ProcessSetOfUpdatesPDU(PSetOfApplicationRecordUpdates, UserID uidSender);
	GCCError	ProcessApplicationRecordPDU(APP_RECORD *, PApplicationRecord);
	GCCError	ProcessSetOfCapabilityRefreshesPDU(PSetOfApplicationCapabilityRefreshes, UserID uidSender);
	GCCError	ProcessNonCollapsingCapabilitiesPDU(CAppCapItemList *non_collapsed_caps_list,
					                                PSetOfNonCollapsingCapabilities set_of_capabilities);

	/*
	 * Utilities used to operate on conference roster reports.
	 */
	UINT		GetApplicationRecords(PGCCApplicationRoster, LPBYTE memory);
	UINT		GetCapabilitiesList(PGCCApplicationRoster, LPBYTE memory);
	UINT		GetNonCollapsedCapabilitiesList(PGCCApplicationRecord, CAppCapItemList *, LPBYTE memory);
	void		FreeApplicationRosterData(void);
	GCCError	AddCollapsableCapabilities(CAppCapItemList *, UINT cCaps, PGCCApplicationCapability *);
	GCCError	AddNonCollapsedCapabilities(CAppCapItemList *, UINT cCaps, PGCCNonCollapsingCapability *);
	GCCError	ClearNodeRecordFromList(UserID);
	void		ClearNodeRecordList(void);
	GCCError	DeleteRecord(UserID, EntityID, BOOL clear_empty_records);
	void		DeleteApplicationRecordData(APP_RECORD *);
	GCCError	MakeCollapsedCapabilitiesList(void);
	GCCError	AddCapabilityToCollapsedList(APP_CAP_ITEM *);
	BOOL		DoCapabilitiesListMatch(UserID, EntityID, UINT cCapas, PGCCApplicationCapability *);

private:

	UINT							m_nInstance;

	CAppRosterMgr					*m_pAppRosterMgr;
	UINT							m_cbDataMemory;
	BOOL							m_fTopProvider;
	BOOL							m_fLocalRoster;
	CSessKeyContainer			    *m_pSessionKey;

	BOOL							m_fRosterHasChanged;
	BOOL							m_fPeerEntitiesAdded;
	BOOL							m_fPeerEntitiesRemoved;
	BOOL							m_fCapabilitiesHaveChanged;

	CAppNodeRecordList2				m_NodeRecordList2;
//
// LONCHANC: What is the difference between m_NodeRecordList2.CollapsedCapList and
// the following m_CollapsedCapListForAllNodes?
//
// LONCHANC: m_CollapsedCapListForAllNodes is a complete list of collapsed capability list across
// the entire node record list.
//
	CAppCapItemList					m_CollapsedCapListForAllNodes;

	BOOL							m_fMaintainPduBuffer;
	BOOL							m_fPduIsFlushed;
	SetOfApplicationInformation		m_SetOfAppInfo;
	PSetOfApplicationRecordUpdates	m_pSetOfAppRecordUpdates;
};


#endif // _APPLICATION_ROSTER_


/*
 *	CAppRoster(	PGCCSessionKey				session_key,
 *						UINT        				owner_message_base,
 *						BOOL    					is_top_provider,
 *						BOOL    					is_local_roster,
 *						BOOL    					maintain_pdu_buffer,
 *						PGCCError					return_value)
 *
 *	Public Function Description
 *		This is the application roster constructor used when the session key is
 *		made available through local means (not PDU data). It is responsible for
 *		initializing all the instance variables used by this class.
 *
 *	Formal Parameters:
 *		session_key			-	(i) The session key associated with this roster.
 *		owner_object		-	(i)	Pointer to the object that owns this object.
 *		owner_message_base	-	(i) Message base to add to all owner callbacks. 
 *		is_top_provider		-	(i)	Flag indicating if this is a top provider.
 *		is_local_roster		-	(i)	Flag indicating if this is a local roster.
 *		maintain_pdu_buffer	-	(i)	Flag indicating if PDU should be maintained.
 *		return_value		-	(o)	Return value for constructor.
 *
 *	Return Value
 *		None.
 *
 *  Side Effects
 *		None.
 *
 *	Caveats
 *		None.
 */

/*
 *	CAppRoster(	PSessionKey					session_key,
 *						UINT        				owner_message_base,
 *						BOOL    					is_top_provider,
 *						BOOL    					is_local_roster,
 *						BOOL    					maintain_pdu_buffer,
 *						PGCCError					return_value)
 *
 *	Public Function Description
 *		This is the application roster constructor used when the session key is
 *		made available through a PDU. It is responsible for initializing all the 
 *		instance variables used by this class.
 *
 *	Formal Parameters:
 *		session_key			-	(i) The session key associated with this roster.
 *		owner_object		-	(i)	Pointer to the object that owns this object.
 *		owner_message_base	-	(i) Message base to add to all owner callbacks. 
 *		is_top_provider		-	(i)	Flag indicating if this is a top provider.
 *		is_local_roster		-	(i)	Flag indicating if this is a local roster.
 *		maintain_pdu_buffer	-	(i)	Flag indicating if PDU should be maintained.
 *		return_value		-	(o)	Return value for constructor.
 *
 *	Return Value
 *		None.
 *
 *  Side Effects
 *		None.
 *
 *	Caveats
 *		None.
 */

/*
 *	~ApplicationRoster()
 *
 *	Public Function Description
 *		This is the application roster destructor. It is responsible for
 *		freeing up all the internal memory used by this class.
 *
 *	Formal Parameters:
 *		None.
 *
 *	Return Value
 *		None.
 *
 *  Side Effects
 *		None.
 *
 *	Caveats
 *		None.
 */

/*
 *	void	FlushRosterUpdateIndicationPDU (
 *        				PSetOfApplicationInformation  *		indication_pdu)
 *
 *	Public Function Description
 *		This routine is used to access any PDU data that might currently be
 *		queued inside the application roster.  PDU data is queued whenever
 *		a request is made to the application roster that affects its
 *		internal information base. 
 *
 *	Formal Parameters:
 *		indication_pdu		-	(o) Pointer to the PDU buffer to fill in.
 *
 *	Return Value
 *		None.
 *
 *  Side Effects
 *		None.
 *
 *	Caveats
 *		The PDU data returned by this routine is automatically freed the next 
 *		time a request is made to this roster object that affects its internal
 *		databease.
 */

/*
 *	GCCError	BuildFullRefreshPDU (void)
 *
 *	Public Function Description
 *		This routine is responsible for generating a full application roster 
 *		refresh PDU.
 *
 *	Formal Parameters:
 *		None.
 *
 *	Return Value
 *		GCC_NO_ERROR			-	No error occured.
 *		GCC_ALLOCATION_FAILURE	-	A resource error occured.
 *
 *  Side Effects
 *		None.
 *
 *	Caveats
 *		None.
 */

/*
 *	GCCError	ProcessRosterUpdateIndicationPDU (
 *       					   PSetOfApplicationInformation indication_pdu,
 *       					   UserID						sender_id);
 *
 *	Public Function Description
 *		This routine is responsible for processing the decoded PDU data.
 *		It essentially changes the application roster object's internal database
 *		based on the information in the structure.
 *
 *	Formal Parameters:
 *		indication_pdu		-	(i) This is a pointer to a structure that
 *									holds the decoded PDU data.
 *		sender_id			-	(i)	The user ID of the node that sent the PDU.
 *
 *	Return Value
 *		GCC_NO_ERROR			-	No error occured.
 *		GCC_ALLOCATION_FAILURE	-	A resource error occured.
 *
 *  Side Effects
 *		None.
 *
 *	Caveats
 *		None.
 */

/*
 *	UINT		LockApplicationRoster()
 *
 *	Public Function Description:
 *		This routine is used to "lock" the "API" data for this object.  This
 *		results in the lock count for this object being incremented.  When the
 *		lock count transitions from 0 to 1, a calculation is made to determine
 *		how much memory will be needed to hold any "API" data which will
 *		be referenced by, but not held in, the GCCApplicationRoster structure
 *		which is filled in on a call to GetAppRoster.  This is the
 *		value returned by this routine in order to allow the calling object to
 *		allocate that amount of memory in preparation for the call to 
 *		GetAppRoster.
 *
 *	Formal Parameters:
 *		None.
 *
 *	Return Value:
 *		The amount of memory, if any, which will be needed to hold "API" data
 *		which is referenced by, but not held in, the GetAppRoster 
 *		structure provided as an output parameter to the GetAppRoster 
 *		call.
 *
 *  Side Effects:
 *		The internal lock count is incremented.
 *
 *	Caveats:
 *		The internal lock count is used in conjuction with an internal "free" 
 *		flag as a mechanism for ensuring that this object remains in existance 
 *		until all interested parties are through with it.  The object remains 
 *		valid (unless explicity deleted) until the lock count is zero and the 
 *		"free" flag is set through a call to FreeApplicationRoster.  This allows
 *		other objects to lock this object and be sure that it remains valid 
 *		until they call UnLock which will decrement the internal lock count.  A
 *		typical usage scenerio for this object would be:  An ApplicatonRoster
 *		object is constructed and then passed off to any interested parties
 *		through a function call.  On return from the function call, the
 *		FreeApplicationRoster call is made which will set the internal "free"
 *		flag.  If no other parties have locked the object with a Lock call,
 *		then the CAppRoster object will automatically delete itself when
 *		the FreeApplicationRoster call is made.  If, however, any number of 
 *		other parties has locked the object, it will remain in existence until
 *		each of them has unlocked the object through a call to UnLock.
 */

/*
 *	void			UnLockApplicationRoster ();
 *
 *	Public Function Description:
 *		This routine is used to "unlock" the "API" data for this object.  This
 *		results in the lock count for this object being decremented.  When the
 *		lock count transitions from 1 to 0, a check is made to determine 
 *		whether the object has been freed through a call to 
 *		FreeApplicationRoster.  If so, the object will automatically delete
 *		itself.
 *
 *	Formal Parameters:
 *		None.
 *
 *	Return Value:
 *		None.
 *
 *  Side Effects:
 *		The internal lock count is decremented.
 *
 *	Caveats:
 *		It is the responsibility of any party which locks an CAppRoster
 *		object by calling Lock to also unlock the object with a call to UnLock.
 *		If the party calling UnLock did not construct the CAppRoster 
 *		object,	it should assume the object to be invalid thereafter.
 */

/*
 *  UINT		GetAppRoster(
 *							PGCCApplicationRoster 		pGccAppRoster,
 *							LPSTR						pData)
 *
 *	Public Function Description:
 *		This routine is used to retrieve the conference roster data from 
 *		the CAppRoster object in the "API" form of a 
 *		GCCApplicationRoster.
 *
 *	Formal Parameters:
 *		application_roster	(o)	The GCCApplicationRoster structure to fill in.
 *		memory				(o)	The memory used to hold any data referenced by,
 *									but not held in, the output structure.
 *
 *	Return Value:
 *		The amount of data, if any, written into the bulk memory block provided.
 *
 *  Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

/*
 *	GCCError		AddRecord(	
 *							PGCCApplicationRecord		application_record,
 *							USHORT						number_of_capabilities,
 *							PGCCApplicationCapability * capabilities_list,
 *							UserID						user_id,
 *							EntityID					entity_id)
 *
 *	Public Function Description:
 *		This routine is used to add a single nodes conference record to the
 *		conference roster object's internal list of records.
 *
 *	Formal Parameters:
 *		application_record		(i)	Pointer to the "API" record	structure to 
 *									add.
 *		number_of_capabilities	(i)	Number of capabilities contained in the
 *									passed in list.
 *		capabilities_list		(i)	List of collapsed capabilities.
 *		user_id					(i)	Node ID associated with record being added.	
 *		entity_id				(i)	Entity ID associated with record being 
 *									added.	
 *
 *	Return Value:
 *		GCC_NO_ERROR					-	No error occured.
 *		GCC_ALLOCATION_FAILURE			-	A resource error occured.
 *		GCC_INVALID_NON_COLLAPSED_CAP	-	Bad non-collapsed capabilities.
 *		GCC_INVALID_PARAMETER			-	Invalid parameter passed in.
 *												an invalid object key.
 *
 *  Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

/*
 *	GCCError	RemoveRecord(	UserID			node_id)
 *								EntityID		entity_id)
 *
 *	Public Function Description:
 *		This routine is used to remove a single APEs application record from the
 *		application roster object's internal list of records.
 *
 *	Formal Parameters:
 *		node_id				(i)	Node ID of record to be removed.
 *		entity_id			(i)	Entity ID of record to be removed.
 *
 *	Return Value:
 *		GCC_NO_ERROR					-	No error occured.
 *		GCC_INVALID_PARAMETER			-	Invalid parameter passed in.
 *
 *  Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

/*
 *	GCCError	ReplaceRecord(		
 *							PGCCApplicationRecord		application_record,
 *							USHORT						number_of_capabilities,
 *							PGCCApplicationCapability * capabilities_list,
 *							UserID						user_id,
 *							EntityID					entity_id)
 *
 *	Public Function Description:
 *		This routine is used to replace a single APEs application record in the
 *		application roster object's internal list of records.
 *
 *	Formal Parameters:
 *		application_record		(i)	Conference record to use as the replacement.
 *		number_of_capabilities	(i)	Number of capabilities contained in the
 *									passed in list.
 *		capabilities_list		(i)	List of collapsed capabilities.
 *		user_id					(i)	Node ID of record to be replaced.
 *		entity_id				(i)	Entity ID of record to be replaced.
 *
 *	Return Value:
 *		GCC_NO_ERROR					-	No error occured.
 *		GCC_ALLOCATION_FAILURE			-	A resource error occured.
 *		GCC_INVALID_PARAMETER			-	Invalid parameter passed in.
 *		GCC_INVALID_NON_COLLAPSED_CAP	-	Bad non-collapsed capabilities.
 *
 *  Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

/*
 *	GCCError	RemoveUserReference (
 *							UserID					detached_node)
 *
 *	Public Function Description:
 *		This routine removes all records associated with the specified node
 *		id.
 *
 *	Formal Parameters:
 *		detached_node		(i)	Node reference to remove.
 *
 *	Return Value:
 *		GCC_NO_ERROR				-	No error occured.
 *		GCC_INVALID_PARAMETER		-	No records associated with this node
 *
 *  Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

/*
 *	USHORT	GetNumberOfApplicationRecords ();
 *
 *	Public Function Description:
 *		This routine returns the total number of application roster records
 *		contained in the objects conference roster record list.
 *
 *	Formal Parameters:
 *		None.
 *
 *	Return Value:
 *		The number of records in the application roster list.
 *
 *  Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

/*
 *	CSessKeyContainer *GetSessionKey ()
 *
 *	Public Function Description:
 *		This routine returns a pointer to the session key associated with this
 *		application roster.
 *
 *	Formal Parameters:
 *		None.
 *
 *	Return Value:
 *		The session key associated with this roster.
 *
 *  Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

/*
 *	void		ResetApplicationRoster ()
 *
 *	Public Function Description:
 *		This routine takes care of resetting all the internal flags that are
 *		used to convey the current state of the application roster.  Should be
 *		called after the roster is flushed and any roster update messages have
 *		been delivered (after a change to the roster occurs).
 *
 *	Formal Parameters:
 *		None.
 *
 *	Return Value:
 *		None.
 *
 *  Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

/*
 *	DBBoolean	DoesRecordExist (
 *							UserID						node_id,
 *							EntityID					entity_id)
 *
 *	Public Function Description:
 *		This routine informs the caller if the specified application record 
 *		exists or not.
 *
 *	Formal Parameters:
 *		node_id			-	(i)	Node ID of APE record to check.
 *		entity_id		-	(i)	Entity ID of APE record to check.
 *
 *	Return Value:
 *		TRUE		-	record exist.
 *		FALSE		-	record does not exist.
 *
 *  Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

/*
 *	DBBoolean		HasRosterChanged ();
 *
 *	Public Function Description:
 *		This routine informs the caller if the roster has changed since the
 *		last time it was reset.
 *
 *	Formal Parameters:
 *		None.
 *
 *	Return Value:
 *		TRUE		-	If roster has changed
 *		FALSE		-	If roster has not changed
 *
 *  Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\remdsk\rds\t120\h\clists.h ===
#ifndef _CLISTS_H_
#define _CLISTS_H_

#define DESIRED_MAX_APP_SAP_ITEMS       6

#define DESIRED_MAX_CONFS               CLIST_DEFAULT_MAX_ITEMS
#define DESIRED_MAX_CONF_ITEMS          DESIRED_MAX_CONFS

#define DESIRED_MAX_CAPS                8
#define DESIRED_MAX_CAP_LISTS           CLIST_DEFAULT_MAX_ITEMS

#define DESIRED_MAX_APP_RECORDS         DESIRED_MAX_APP_SAP_ITEMS
#define DESIRED_MAX_NODES               CLIST_DEFAULT_MAX_ITEMS
#define DESIRED_MAX_NODE_RECORDS        DESIRED_MAX_NODES

#define DESIRED_MAX_CALLBACK_MESSAGES   8

#define DESIRED_MAX_USER_DATA_ITEMS     8

#define DESIRED_MAX_CONN_HANDLES        CLIST_DEFAULT_MAX_ITEMS


// to hold all the non-default session application rosters
class CAppRosterList : public CList
{
    DEFINE_CLIST(CAppRosterList, CAppRoster*)
    void DeleteList(void);
};

// to hold all the application roster managers
class CAppRosterMgrList : public CList
{
    DEFINE_CLIST(CAppRosterMgrList, CAppRosterMgr*)
    void DeleteList(void);
};

// to hold a list of conferences
class CConfList : public CList
{
    DEFINE_CLIST(CConfList, CConf*)
    void DeleteList(void);
};

// to hold all the conferences indexed by conference id
class CConfList2 : public CList2
{
    DEFINE_CLIST2(CConfList2, CConf*, GCCConfID)
    void DeleteList(void);
};

// to hold a list of application sap
class CAppSapList : public CList
{
    DEFINE_CLIST(CAppSapList, CAppSap*)
    void DeleteList(void);
};

// to hold all application sap indexed by entity id
class CAppSapEidList2 : public CList2
{
    DEFINE_CLIST2_(CAppSapEidList2, CAppSap*, GCCEntityID)
    void DeleteList(void);
};

// to hold a list of user id or node id.
class CUidList : public CList
{
    DEFINE_CLIST_(CUidList, UserID)
    void BuildExternalList(PSetOfUserIDs *);
};

// to hold a list of entity id
class CEidList : public CList
{
    DEFINE_CLIST_(CEidList, GCCEntityID)
};

// to hold a list of channel id
class CChannelIDList : public CList
{
    DEFINE_CLIST_(CChannelIDList, ChannelID)
    void BuildExternalList(PSetOfChannelIDs *);
};

// to hold a list of token id
class CTokenIDList : public CList
{
    DEFINE_CLIST_(CTokenIDList, TokenID)
    void BuildExternalList(PSetOfTokenIDs *);
};

// simple packet queue
class CSimplePktQueue : public CQueue
{
    DEFINE_CQUEUE(CSimplePktQueue, PSimplePacket)
};

// remote connection list (aka remote attachment list)
class CConnectionList : public CList
{
    DEFINE_CLIST(CConnectionList, PConnection)
};

class CConnectionQueue : public CQueue
{
    DEFINE_CQUEUE(CConnectionQueue, PConnection)
};

class CTokenList2 : public CList2
{
    DEFINE_CLIST2_(CTokenList2, PToken, TokenID)
};

class CDomainList2 : public CList2
{
    DEFINE_CLIST2(CDomainList2, PDomain, GCCConfID)
};



class CChannelList2 : public CHashedList2
{
    DEFINE_HLIST2_(CChannelList2, PChannel, ChannelID)
};

class CConnectionList2 : public CHashedList2
{
    DEFINE_HLIST2_(CConnectionList2, PConnection, ConnectionHandle)
};

#endif // _CLISTS_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\remdsk\rds\t120\h\capid.h ===
/*
 *	capid.h
 *
 *	Copyright (c) 1995 by DataBeam Corporation, Lexington, KY
 *
 *	Abstract:
 *		This is the interface file for the class CCapIDContainer.  A
 *		CCapIDContainer object is used to maintain information about
 *		a particular capability of an application.  A capability identifier can
 *		be either a standard type or a non-standard type.  When the type is 
 *		standard, the identifier is stored internally as an integer value.  When
 *		the type is non-standard, an CObjectKeyContainer container object is used 
 *		internally to buffer the necessary data.  In this case the identifier 
 *		data may exist as an Object ID which is a series of non-negative 
 *		integers or an H221 non-standard ID which is an octet string of no fewer
 *		than four octets and no more than 255 octets.   
 * 
 *	Caveats:
 *		None.
 *
 *	Author:
 *		jbo
 */
#ifndef	_CAPABILITY_IDENTIFIER_DATA_
#define	_CAPABILITY_IDENTIFIER_DATA_

#include "objkey.h"

/*
 * This is the typedef for the structure used to hold the capability identifier
 * data	internally.
 */
typedef struct
{
    GCCCapabilityIDType		capability_id_type;

    union
    {
        USHORT			  	standard_capability;
        CObjectKeyContainer *non_standard_capability;
    } u;
}
    CAP_ID_STRUCT;

/*
 * Class definition:
 */
class CCapIDContainer : public CRefCount
{
public:

	CCapIDContainer(PGCCCapabilityID, PGCCError);
	CCapIDContainer(PCapabilityID, PGCCError);
	CCapIDContainer(CCapIDContainer *, PGCCError);

	~CCapIDContainer(void);

	UINT		LockCapabilityIdentifierData(void);
	void		UnLockCapabilityIdentifierData(void);

	UINT		GetGCCCapabilityIDData(PGCCCapabilityID, LPBYTE memory);
	GCCError	GetCapabilityIdentifierDataPDU(PCapabilityID);
	void		FreeCapabilityIdentifierDataPDU(void);

friend BOOL 	operator== (const CCapIDContainer&, const CCapIDContainer&);

protected:

	CAP_ID_STRUCT	                m_InternalCapID;
	UINT							m_cbDataSize;

	CapabilityID					m_CapIDPDU;
	BOOL    						m_fValidCapIDPDU;
};

/*
 *	Comments explaining the public and protected class member functions
 */

/*
 *	CCapIDContainer (	PGCCCapabilityID	capability_id,
 *								PGCCError			return_value);
 *
 *	Public member function of CCapIDContainer.
 *
 *	Function Description:
 *		This is the constructor for the CCapIDContainer class which 
 *		takes as input the "API" version of capability ID data, GCCCapabilityID.
 *
 *	Formal Parameters:
 *		capability_id		(i)	The capability ID data to store.
 *		return_value		(o)	The output parameter used to indicate errors.
 *
 *	Return Value:
 *		GCC_NO_ERROR					-	No error.
 *		GCC_ALLOCATION_FAILURE			- 	Error creating an object using the
 *												"new" operator.
 *		GCC_BAD_CAPABILITY_ID			-	An invalid capability ID passed in.
 *
 *  Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

/*
 *	CCapIDContainer (	PCapabilityID		capability_id,
 *								PGCCError			return_value);
 *
 *	Public member function of CCapIDContainer.
 *
 *	Function Description:
 *		This is the constructor for the CCapIDContainer class which 
 *		takes as input the "PDU" version of capability ID data, CapabilityID.
 *
 *	Formal Parameters:
 *		capability_id		(i)	The capability ID data to store.
 *		return_value		(o)	The output parameter used to indicate errors.
 *
 *	Return Value:
 *		GCC_NO_ERROR					-	No error.
 *		GCC_ALLOCATION_FAILURE			- 	Error creating an object using the
 *												"new" operator.
 *		GCC_BAD_CAPABILITY_ID			-	An invalid capability ID passed in.
 *
 *  Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */
/*
 *	CCapIDContainer(CCapIDContainer *capability_id,
 *			PGCCError						return_value);
 *
 *	Public member function of CCapIDContainer.
 *
 *	Function Description:
 *		This is the copy constructor for the CCapIDContainer class 
 *		which takes as input another CCapIDContainer object.
 *
 *	Formal Parameters:
 *		capability_id		(i)	The CCapIDContainer object to copy.
 *		return_value		(o)	The output parameter used to indicate errors.
 *
 *	Return Value:
 *		GCC_NO_ERROR					-	No error.
 *		GCC_ALLOCATION_FAILURE			- 	Error creating an object using the
 *												"new" operator.
 *		GCC_BAD_CAPABILITY_ID			-	An invalid CCapIDContainer
 *												passed in.
 *
 *  Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */


/*
 *	~CapabilityIdentifierData();
 *
 *	Public member function of CCapIDContainer.
 *
 *	Function Description:
 *		This is the destructor for the CCapIDContainer class.  It is 
 *		used to	clean up any memory allocated during the life of this object.
 *
 *	Formal Parameters:
 *		None.
 *
 *	Return Value:
 *		None.
 *
 *  Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */


/*
 *	UINT			LockCapabilityIdentifierData ();
 *
 *	Public member function of CCapIDContainer.
 *
 *	Function Description:
 *		This routine is used to "lock" the "API" data for this object.  This
 *		results in the lock count for this object being incremented.  When the
 *		lock count transitions from 0 to 1, a calculation is made to determine
 *		how much memory will be needed to hold any "API" data which will
 *		be referenced by, but not held in, the GCCCapabilityID structure
 *		which is filled in on a call to GetGCCCapabilityIDData.  This is the
 *		value returned by this routine in order to allow the calling object to
 *		allocate that amount of memory in preparation for the call to 
 *		GetGCCCapabilityIDData.
 *
 *	Formal Parameters:
 *		None.
 *
 *	Return Value:
 *		The amount of memory, if any, which will be needed to hold "API" data
 *		which is referenced by, but not held in, the GCCCapabilityID structure
 *		provided as an output parameter to the GetGCCCapabilityIDData call.
 *
 *  Side Effects:
 *		The internal lock count is incremented.
 *
 *	Caveats:
 *		The internal lock count is used in conjuction with an internal "free" 
 *		flag as a mechanism for ensuring that this object remains in existance 
 *		until all interested parties are through with it.  The object remains 
 *		valid (unless explicity deleted) until the lock count is zero and the 
 *		"free" flag is set through a call to FreeCapabilityIdentifierData.  This
 *		allows other objects to lock this object and be sure that it remains 
 *		valid until they call UnLock which will decrement the internal lock 
 *		count.  A typical usage scenerio for this object would be:  A
 *		CCapIDContainer object is constructed and then passed off to 
 *		any interested parties through a function call.  On return from the 
 *		function call, the FreeCapabilityIdentifierData call is made which will
 *		set the internal "free"	flag.  If no other parties have locked the 
 *		object with a Lock call, then the CCapIDContainer object will 
 *		automatically delete itself when the FreeCapabilityIdentifierData call
 *		is made.  If, however, any number of other parties has locked the 
 *		object, it will remain in existence until each of them has unlocked the
 *		object through a call to UnLock.
 */


/*
 *	UINT			GetGCCCapabilityIdentifierData (	
 *							PGCCCapabilityID 		capability_id,
 *							LPSTR					memory);
 *
 *	Public member function of CCapIDContainer.
 *
 *	Function Description:
 *		This routine is used to retrieve the capability ID data from the
 *		CCapIDContainer object in the "API" form of a GCCCapabilityID.
 *
 *	Formal Parameters:
 *		capability_id		(o)	The GCCCapabilityID structure to fill in.
 *		memory				(o)	The memory used to hold any data referenced by,
 *									but not held in, the output structure.
 *
 *	Return Value:
 *		The amount of data, if any, written into the bulk memory block provided.
 *
 *  Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */


/*
 *	void			UnLockCapabilityIdentifierData ();
 *
 *	Public member function of CCapIDContainer.
 *
 *	Function Description:
 *		This routine is used to "unlock" the "API" data for this object.  This
 *		results in the lock count for this object being decremented.  When the
 *		lock count transitions from 1 to 0, a check is made to determine 
 *		whether the object has been freed through a call to 
 *		FreeCapabilityIdentifierData.  If so, the object will automatically 
 *		delete itself.
 *
 *	Formal Parameters:
 *		None.
 *
 *	Return Value:
 *		None.
 *
 *  Side Effects:
 *		The internal lock count is decremented.
 *
 *	Caveats:
 *		It is the responsibility of any party which locks a 
 *		CCapIDContainer object by calling Lock to also unlock the 
 *		object with a call to UnLock.  If the party calling UnLock did not 
 *		construct the CCapIDContainer object,	it should assume the 
 *		object to be invalid thereafter.
 */


/*
 *	GCCError		GetCapabilityIdentifierDataPDU (	
 *							PCapabilityID 		capability_id);
 *
 *	Public member function of CCapIDContainer.
 *
 *	Function Description:
 *		This routine is used to retrieve the capability ID data from the
 *		CCapIDContainer object in the "PDU" form of a CapabilityID.
 *
 *	Formal Parameters:
 *		capability_id		(o)	The CapabilityID structure to fill in.
 *
 *	Return Value:
 *		GCC_NO_ERROR					-	No error.
 *		GCC_ALLOCATION_FAILURE			- 	Error creating an object using the
 *												"new" operator.
 *		GCC_BAD_OBJECT_KEY				-	One of the internal pointers has
 *												been corrupted.
 *
 *  Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */


/*
 *	void		FreeCapabilityIdentifierDataPDU ();
 *
 *	Public member function of CCapIDContainer.
 *
 *	Function Description:
 *		This routine is used to "free" the "PDU" data allocated for this object
 *		which is held internally in a CapabilityID structure.
 *
 *	Formal Parameters:
 *		None.
 *
 *	Return Value:
 *		None.
 *
 *  Side Effects:
 *		The internal "free" flag is set.
 *
 *	Caveats:
 *		This object should be assumed invalid after a call to 
 *		FreeCapabilityIdentifierDataPDU has been made.
 */


/*
 *	friend BOOL	operator== (
 *					const CCapIDContainer& 		capability_id_1, 
 *					const CCapIDContainer& 		capability_id_2);
 *
 *	Public member function of CCapIDContainer.
 *
 *	Function Description:
 *		This routine is used to compare two CCapIDContainer objects 
 *		to determine whether or not they are equal in value.
 *
 *	Formal Parameters:
 *		capability_id_1			(i)	The first CCapIDContainer object 
 *										to compare.
 *		capability_id_2			(i)	The other CCapIDContainer object 
 *										to compare.
 *
 *	Return Value:
 *		TRUE				-	The two objects are equal in value.
 *		FALSE				- 	The two objects are not equal in value.
 *
 *  Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\remdsk\rds\t120\h\attmnt.h ===
#ifndef __MCS_ATTACHMENT_H__
#define __MCS_ATTACHMENT_H__

typedef enum
{
    USER_ATTACHMENT,        // local attachment
    CONNECT_ATTACHMENT      // remote attachment
}
    ATTACHMENT_TYPE;


class CAttachmentList : public CList
{
    DEFINE_CLIST(CAttachmentList, CAttachment*)

    PUser IterateUser(void);
    PConnection IterateConn(void);

    BOOL FindUser(PUser pUser) { return Find((CAttachment *) pUser); }
    BOOL FindConn(PConnection pConn) { return Find((CAttachment *) pConn); }

    BOOL AppendUser(PUser pUser) { return Append((CAttachment *) pUser); }
    BOOL AppendConn(PConnection pConn) { return Append((CAttachment *) pConn); }
};

class CAttachmentQueue : public CQueue
{
    DEFINE_CQUEUE(CAttachmentQueue, CAttachment*)

    PUser IterateUser(void);
    PConnection IterateConn(void);

    BOOL FindUser(PUser pUser) { return Find((CAttachment *) pUser); }
    BOOL FindConn(PConnection pConn) { return Find((CAttachment *) pConn); }

    BOOL AppendUser(PUser pUser) { return Append((CAttachment *) pUser); }
    BOOL AppendConn(PConnection pConn) { return Append((CAttachment *) pConn); }
};



class CAttachment
{
public:

    CAttachment(ATTACHMENT_TYPE eAttmntType) : m_eAttmntType(eAttmntType) { }
    // ~CAttachment(void) { }

    ATTACHMENT_TYPE GetAttachmentType(void) { return m_eAttmntType; }
    BOOL            IsUserAttachment(void) { return (USER_ATTACHMENT == m_eAttmntType); }
    BOOL            IsConnAttachment(void) { return (CONNECT_ATTACHMENT == m_eAttmntType); }


    virtual void PlumbDomainIndication(ULONG height_limit) = 0;
    virtual void PurgeChannelsIndication(CUidList *, CChannelIDList *) = 0;
    virtual void PurgeTokensIndication(PDomain, CTokenIDList *) = 0;
    virtual void DisconnectProviderUltimatum(Reason) = 0;
    virtual void AttachUserConfirm(Result, UserID uidInitiator) = 0;
    virtual void DetachUserIndication(Reason, CUidList *) = 0;
    virtual void ChannelJoinConfirm(Result, UserID uidInitiator, ChannelID requested_id, ChannelID) = 0;
    virtual void ChannelConveneConfirm(Result, UserID uidInitiator, ChannelID) = 0;
    virtual void ChannelDisbandIndication(ChannelID) = 0;
    virtual void ChannelAdmitIndication(UserID uidInitiator, ChannelID, CUidList *) = 0;
    virtual void ChannelExpelIndication(ChannelID, CUidList *) = 0;
    virtual void SendDataIndication(UINT message_type, PDataPacket data_packet) = 0;
    virtual void TokenGrabConfirm(Result, UserID uidInitiator, TokenID, TokenStatus) = 0;
    virtual void TokenInhibitConfirm(Result, UserID uidInitiator, TokenID, TokenStatus) = 0;
    virtual void TokenGiveIndication(PTokenGiveRecord) = 0;
    virtual void TokenGiveConfirm(Result, UserID uidInitiator, TokenID, TokenStatus) = 0;
    virtual void TokenReleaseConfirm(Result, UserID uidInitiator, TokenID, TokenStatus) = 0;
    virtual void TokenPleaseIndication(UserID uidInitiator, TokenID) = 0;
    virtual void TokenTestConfirm(UserID uidInitiator, TokenID, TokenStatus) = 0;
    virtual void MergeDomainIndication(MergeStatus) = 0;

private:

    ATTACHMENT_TYPE     m_eAttmntType;
};



#endif // __MCS_ATTACHMENT_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\remdsk\rds\t120\h\channel.h ===
/*
 *	channel.h
 *
 *	Copyright (c) 1993 - 1995 by DataBeam Corporation, Lexington, KY
 *
 *	Abstract:
 *		This is the interface file for the Channel class.  This class represents
 *		both static and assigned channels within an MCS domain.  This class is
 *		also the base class for all other types of channels in MCS.  It defines
 *		the default behavior that can be inherited by these other classes.
 *
 *		Instances of the Channel class have three primary responsibilities:
 *		managing the join/leave process; sending data; and issuing merge
 *		requests during a domain merger.
 *
 *		When a user tries to join a channel, the request is sent to the Channel
 *		object that represents the channel.  The Channel object can then decide
 *		whether or not to allow the join.  By overriding the appropriate
 *		member functions, derived classes can change the criteria by which
 *		this decision is made.
 *
 *		All Channel objects maintain an internal list of which attachments are
 *		joined to the channel they represent.  When data is sent on the channel,
 *		the request is sent to the Channel object, who then knows how to route
 *		the data.  The data is sent to all the appropriate attachments.
 *
 *		During a domain information base merger, all Channel objects will be
 *		asked to issue a merge request upward toward the new top provider.  The
 *		merge request will be built using information contained in the Channel
 *		object.
 *
 *		All public member functions of this class are declared as virtual, so
 *		that they can be overridden in case a derived class has to modify the
 *		behavior.
 *
 *	Caveats:
 *		None.
 *
 *	Author:
 *		James P. Galvin, Jr.
 */
#ifndef _CHANNEL_
#define _CHANNEL_


/*
 *	This is a dictionary of channels that exist within the current domain.
 *	The key to the dictionary is the channel ID, by which channels are
 *	identified.  The value is a pointer to an object of class Channel.  By
 *	definition, if a channel is in the list, then it exists and knows how
 *	to respond to channel related activity.  If a channel is not in the
 *	list, then it does not exist (from the point-of-view of this MCS
 *	provider).
 */

/*
 *	This is the class definition for class Channel.
 */
class Channel
{
public:

	Channel (
			ChannelID			channel_id,
			PDomain             local_provider,
			PConnection         top_provider,
			CChannelList2      *channel_list,
			CAttachmentList    *attachment_list);
	Channel (
			ChannelID			channel_id,
			PDomain             local_provider,
			PConnection         top_provider,
			CChannelList2      *channel_list,
			CAttachmentList    *attachment_list,
			PConnection         pConn);
	virtual					~Channel ();

    void    SetTopProvider(PConnection top_provider) { m_pConnToTopProvider = top_provider; }
    BOOL    IsTopProvider(void) { return (NULL == m_pConnToTopProvider); }

	virtual Channel_Type	GetChannelType ();
	virtual	BOOL    		IsValid ();
    virtual CAttachment *GetAttachment(void) { return NULL; }
	virtual	Void			IssueMergeRequest ();
	virtual Void			ChannelJoinRequest (
									CAttachment        *originator,
									UserID				uidInitiator,
									ChannelID			channel_id);
	Void			ChannelJoinConfirm (
									CAttachment        *originator,
									Result				result,
									UserID				uidInitiator,
									ChannelID			requested_id,
									ChannelID			channel_id);
	Void			ChannelLeaveRequest (
									CAttachment        *originator,
									CChannelIDList     *channel_id_list);
	virtual Void			SendDataRequest (
									CAttachment        *originator,
									UINT				type,
									PDataPacket			data_packet);
	Void			SendDataIndication (
									PConnection         originator,
									UINT				type,
									PDataPacket			data_packet);

protected:
	ChannelID				Channel_ID;
	PDomain                 m_pDomain;
	PConnection             m_pConnToTopProvider;
	CChannelList2          *m_pChannelList2;
	CAttachmentList        *m_pAttachmentList;
	CAttachmentList         m_JoinedAttachmentList;
};

/*
 *	Channel (
 *			ChannelID			channel_id,
 *			PDomain     		local_provider,
 *			PConnection 		top_provider,
 *			PChannelList		channel_list,
 *			PAttachmentList		attachment_list)
 *
 *	Functional Description:
 *		This is the normal constructor for the Channel class.  It simply
 *		initializes the instance variables that identify the channel, the local
 *		provider, and the top provider.  The attachment list is empty by
 *		default.
 *
 *	Formal Parameters:
 *		channel_id (i)
 *			This is the ID of the channel object.  By keeping track of this
 *			internally, it doesn't have to be passed in for every operation.
 *		local_provider (i)
 *			This is the identity of the local provider.  A Channel object
 *			needs this since it issues MCS commands on behalf of the local
 *			provider.
 *		top_provider (i)
 *			This is a pointer to the top provider.  This is used by the
 *			Channel object when it needs to issue a request to the Top
 *			Provider.  If NULL, then this is the top provider.
 *		channel_list (i)
 *			This is a pointer to the domain's channel list, which identifies
 *			all valid channels in the domain.  This is used by channel objects
 *			to validate user IDs.
 *		attachment_list (i)
 *			This is a pointer to the domain's attachment list, which identifies
 *			all valid attachments in the domain.  This is used by channel
 *			objects to validate joined attachments.
 *
 *	Return Value:
 *		None.
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

/*
 *	Channel (
 *			ChannelID			channel_id,
 *			PDomain     		local_provider,
 *			PConnection 		top_provider,
 *			PChannelList		channel_list,
 *			PAttachmentList		attachment_list,
 *			PCommandTarget		attachment)
 *
 *	Functional Description:
 *		This is a secondary version of the constructor that is used only during
 *		merge operations.  The only difference between this one and the one
 *		above is that this one allows the specification of an initial
 *		attachment.  This allows a Channel object to be constructed with an
 *		existing attachment, without the transmission of a ChannelJoinConfirm.
 *
 *		Remember that if a Channel object is constructed, and then a join
 *		request is used to add an attachment, a Channel object automatically
 *		issues a join confirm.  This constructor allows that to be bypassed
 *		during a merger when a join confirm is inappropriate.
 *
 *	Formal Parameters:
 *		channel_id (i)
 *			This is the ID of the channel object.  By keeping track of this
 *			internally, it doesn't have to be passed in for every operation.
 *		local_provider (i)
 *			This is the identity of the local provider.  A Channel object
 *			needs this since it issues MCS commands on behalf of the local
 *			provider.
 *		top_provider (i)
 *			This is a pointer to the top provider.  This is used by the
 *			Channel object when it needs to issue a request to the Top
 *			Provider.  If NULL, then this is the top provider.
 *		channel_list (i)
 *			This is a pointer to the domain's channel list, which identifies
 *			all valid channels in the domain.  This is used by channel objects
 *			to validate user IDs.
 *		attachment_list (i)
 *			This is a pointer to the domain's attachment list, which identifies
 *			all valid attachments in the domain.  This is used by channel
 *			objects to validate joined attachments.
 *		attachment (i)
 *			This is the initial attachment for the channel.  A channel join
 *			confirm is NOT issued to the attachment.
 *
 *	Return Value:
 *		None.
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

/*
 *	~Channel ()
 *
 *	Functional Description:
 *		This is the Channel class destructor.  It clears the joined attachment
 *		list, sending channel leave indications to any user that is locally
 *		attached.
 *
 *	Formal Parameters:
 *		None.
 *
 *	Return Value:
 *		None.
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

/*
 *	Void		SetTopProvider (
 *						PConnection		top_provider)
 *
 *	Functional Description:
 *		This member function is used to change the identity of the Top Provider
 *		in an existing channel.  The only time this will really occur is when
 *		a provider that used to be the Top Provider merges into another
 *		domain, and therefore ceases to be the Top Provider.
 *
 *	Formal Parameters:
 *		top_provider (i)
 *			This is a pointer to the new Top Provider.
 *
 *	Return Value:
 *		None.
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

/*
 *	Channel_Type	GetChannelType ()
 *
 *	Functional Description:
 *		This virtual member function returns the type of the channel.  For this
 *		class it will be either STATIC_CHANNEL or ASSIGNED_CHANNEL, depending
 *		on the value of the channel ID.
 *
 *		This member function should be overridden by all classes that inherit
 *		from this one so that they return a different type.
 *
 *	Formal Parameters:
 *		None.
 *
 *	Return Value:
 *		STATIC_CHANNEL if the channel ID is 1000 or less.
 *		ASSIGNED_CHANNEL if the channel ID is greater than 1000.
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

/*
 *	BOOL	IsValid ()
 *
 *	Functional Description:
 *		This function returns TRUE if the channel is still valid, and FALSE if
 *		it is ready for deletion.  This is a virtual function allowing derived
 *		classes to change the way this decision is made.
 *
 *		This function will use the information in the domain's channel and
 *		attachment lists to validate its own existence.  For example, if a
 *		channel is owned by a user, and that user detaches, the channel will
 *		ask to be deleted.
 *
 *	Formal Parameters:
 *		None.
 *
 *	Return Value:
 *		TRUE if channel still valid.
 *		FALSE if channel needs to be deleted.
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

/*
 *	CAttachment *GetAttachment ()
 *
 *	Functional Description:
 *		This function returns a pointer to the attachment that leads to the
 *		owner of the channel.  Since STATIC and ASSIGNED channels do not have
 *		owners, this function will always return NULL.
 *
 *	Formal Parameters:
 *		None.
 *
 *	Return Value:
 *		NULL.
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

/*
 *	Void		IssueMergeRequest ()
 *
 *	Functional Description:
 *		This member function causes the Channel object to issue a merge request
 *		to the top provider.  It will pack the appropriate local information
 *		into the command.
 *
 *	Formal Parameters:
 *		None.
 *
 *	Return Value:
 *		None.
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

/*
 *	Void		ChannelJoinRequest (
 *						PCommandTarget		originator,
 *						UserID				uidInitiator,
 *						ChannelID			channel_id)
 *
 *	Functional Description:
 *		This function is invoked when a user tries to join the channel
 *		associated with a Channel object.  The originator will be added to
 *		the attachment list if it is not already there.
 *
 *		If the user ID passed in is valid (not 0), then a channel join confirm
 *		will be issued to the user.  Setting the user ID to 0 (zero), inhibits
 *		this.
 *
 *		Derived classes can override this member function to provide more
 *		stringent rules about who can join a channel.  This class lets anyone
 *		join, as specified in MCS for static and assigned channels.
 *
 *	Formal Parameters:
 *		originator
 *			This is the attachment of the user wishing to join the channel.
 *		uidInitiator
 *			This is the user ID of the user joining the channel.  This can
 *			be used for security checking in derived classes if desired.
 *		channel_id
 *			This is the channel being acted upon.
 *
 *	Return Value:
 *		None.
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

/*
 *	Void		ChannelJoinConfirm (
 *						PCommandTarget		originator,
 *						Result				result,
 *						UserID				uidInitiator,
 *						UserID				requested_id,
 *						ChannelID			channel_id)
 *
 *	Functional Description:
 *		This function performs essentially the same operation as JoinRequest
 *		above.  The only difference is that the user ID cannot be set to 0
 *		to inhibit the re-transmission of the join confirm to the user who
 *		is joining the channel.
 *
 *	Formal Parameters:
 *		originator (i)
 *			This is the attachment of the user wishing to join the channel.
 *		result (i)
 *			This is the result of the previous join request.
 *		uidInitiator (i)
 *			This is the user ID of the user joining the channel.  This can
 *			be used for security checking in derived classes if desired.
 *		requested_id (i)
 *			This is the ID of the channel that the user originally asked to
 *			join.  The only time this will be different from the channel ID
 *			below is if the user asked for channel 0, which is interpreted as
 *			a request for an assigned channel.
 *		channel_id (i)
 *			This is the channel being acted upon.
 *
 *	Return Value:
 *		None.
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

/*
 *	Void	ChannelLeaveRequest (
 *					PCommandTarget		originator,
 *					CChannelIDList     *channel_id_list)
 *
 *	Functional Description:
 *		This member function is used when an attachment needs to be removed
 *		from a channel.  A leave request will only be received from a lower
 *		provider when all attachments at that level have left (this means that
 *		the data for the channel no longer needs to be sent downward).
 *
 *		If this request results in an empty attachment list a
 *		ChannelLeaveRequest will be sent upward to the next higher provider in
 *		the domain (unless this is the Top Provider).
 *
 *	Formal Parameters:
 *		originator (i)
 *			This is the attachment to be removed from the channel.
 *		channel_id_list (i)
 *			This is the list of channels being acted upon.
 *
 *	Return Value:
 *		None.
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

/*
 *	Void		SendDataRequest (
 *						PCommandTarget		originator,
 *						UINT				type, 
 *						PDataPacket			data_packet)
 *
 *	Functional Description:
 *		This function is called when it is necessary to send data through the
 *		channel that this Channel object represents.  All rules for
 *		non-uniform data apply.  The data will be forwarded upward toward
 *		the Top Provider (unless this is the Top Provider).  Data will also
 *		be sent immediately downward to all attachments who are joined to
 *		the channel, except for the attachment from which the data came.
 *
 *	Formal Parameters:
 *		originator (i)
 *			This is the attachment from which the data came.
 *		type (i)
 *			Simple or uniform send data request.
 *		data_packet (i)
 *			This is a pointer to a DataPacket object containing the channel
 *			ID, the User ID of the data sender, segmentation flags, priority of
 *			the data packet and a pointer to the packet to be sent.
 *
 *	Return Value:
 *		None.
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

/*
 *	Void		SendDataIndication (
 *						PCommandTarget		originator,
 *						UINT				type,
 *						PDataPacket			data_packet)
 *
 *	Functional Description:
 *		This function is called when it is necessary to send data through the
 *		channel that this Channel object represents.  The data will be sent
 *		downward to all attachments joined to the channel.
 *
 *	Formal Parameters:
 *		originator (i)
 *			This is the attachment from which the data came.
 *		type (i)
 *			normal or uniform indication.
 *		data_packet (i)
 *			This is a pointer to a DataPacket object containing the channel
 *			ID, the User ID of the data sender, segmentation flags, priority of
 *			the data packet and a pointer to the packet to be sent.
 *
 *	Return Value:
 *		None.
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\remdsk\rds\t120\h\cmdtar.h ===
/*
 *	cmdtar.h
 *
 *	Copyright (c) 1993 - 1995 by DataBeam Corporation, Lexington, KY
 *
 *	Abstract:
 *		This is the interface file for the CommandTarget class.  This
 *		is an abstract base class, meaning that it cannot be directly
 *		instantiated, but rather, exists to be inherited from.  It defines
 *		a set of virtual member functions which will be shared by all classes
 *		that inherit from this one.
 *
 *		These virtual member function can be thought of as a "language" that
 *		is used by CommandTarget objects to communicate with one another
 *		at run-time.  This language contains all "MCS commands" (or just
 *		commands) that are necessary for domain management within an MCS
 *		provider.
 *
 *		The MCS commands that make up this language have a one-to-one
 *		correspondence with the Domain Protocol Data Units (Domain MCSPDUs) that
 *		are defined in T.125.  There are also three additional MCS command that
 *		do not have T.125 counterparts: ChannelLeaveIndication,
 *		TokenReleaseIndication, and MergeDomainIndication.  These are specific
 *		to this implementation, and used for local traffic only (these do NOT
 *		correspond to PDUs that travel over any connection).  See the
 *		description of each command at the end of this interface file to see
 *		what each command does.
 *
 *		The first parameter of all commands is the address of the object
 *		who is sending it (its "this" pointer).  This can be used by the
 *		recipient of the command to track identity of other CommandTargets
 *		in the system.  Since all CommandTarget classes share the same
 *		language, the communication between them is bi-directional.
 *
 *		Any class inheriting from this one that wants to receive and process
 *		a command needs to override the virtual member function corresponding
 *		to that command.  It is only necessary to override those commands that
 *		a given class expects to receive at run-time (for example, the Channel
 *		class would never receive a TokenGrabRequest).
 *
 *		See the description of each class that inherits from this one for a
 *		more complete discussion of how the command language is used.
 *
 *	Caveats:
 *		None.
 *
 *	Author:
 *		James P. Galvin, Jr.
 */
#ifndef	_COMMANDTARGET_
#define	_COMMANDTARGET_

#include "clists.h"

/*
 *	This enumeration defines the valid types of attachments.  Note that for
 *	most operations, the domain class does not distinguish between user
 *	attachments and MCS connections.  They are both lumped under the term
 *	attachment.  There are, however, a few cases where this identity is
 *	important, so the type is saved as one of the following:
 *
 *	LOCAL_ATTACHMENT
 *		This attachment type refers to a user attachment.
 *	REMOTE_ATTACHMENT
 *		This attachment type refers to an MCS connection (through one or more
 *		transport connections).
 *
 *	Each attachment in the attachment list is identified as one of these two
 *	types.
 */

/*
 *	This is a set of container definitions using templates. All containers
 *	are based on classes in the Rogue Wave Tools.h++ class library.
 *
 *	Each container that is defined here has an associated iterator which is
 *	not explicitly mentioned.  All iterators simply allow the code to walk
 *	through all items in the container in a very efficient manner.
 *
 *	CAttachmentList
 *		This is a dictionary of attachments that are hierarchically below the
 *		current provider.  The key to the dictionary is a pointer to an object
 *		of class CommandTarget.  The value is the attachment type, which is
 *		either local (for user attachments), or remote (for MCS connections).
 *	CChannelIDList
 *		This is a list of channel IDs.  This is used when it is necessary to
 *		keep a list of channels to perform some action on (such as deletion)
 *		that cannot be performed right away.
 *	CUserIDList (aka CUidList)
 *		This is a list of user IDs.  This is for such things as keeping a list
 *		of admitted users in a private channel, and keeping a list of inhibitors
 *		of a token.
 *	CTokenIDList
 *		This is a list of token IDs.  This is used when it is necessary to
 *		keep a list of tokens to perform some action on (such as deletion)
 *		that cannot be performed right away.
 */

/*
 *	These types are used when dealing with MCS channels.
 *
 *	Channel_Type
 *		This type defines the types of channels that are available in MCS.
 *	StaticChannelAttributes
 *		This structure is used to define those attributes that are specific
 *		to static channels.
 *	UserChannelAttributes
 *		This structure is used to define those attributes that are specific
 *		to user channels.
 *	PrivateChannelAttributes
 *		This structure is used to define those attributes that are specific
 *		to private channels.
 *	AssignedChannelAttributes
 *		This structure is used to define those attributes that are specific
 *		to assigned channels.
 *	ChannelAttributes
 *		This structure is used to define the attributes of ANY type of channel.
 *		It contains a channel type, and a union of the above four types.
 *	CChannelAttributesList
 *		This is an S-list of ChannelAttributes structures.
 */
typedef	enum
{
	STATIC_CHANNEL,
	USER_CHANNEL,
	PRIVATE_CHANNEL,
	ASSIGNED_CHANNEL
} Channel_Type;
typedef	Channel_Type *			PChannelType;

typedef	struct
{
	ChannelID			channel_id;
} StaticChannelAttributes;

typedef	struct
{
	DBBoolean			joined;
	UserID				user_id;
} UserChannelAttributes;

typedef	struct
{
	DBBoolean			joined;
	ChannelID			channel_id;
	UserID				channel_manager;
	CUidList           *admitted_list;
} PrivateChannelAttributes;

typedef	struct
{
	ChannelID			channel_id;
} AssignedChannelAttributes;

typedef	struct
{
	Channel_Type		channel_type;
	union
	{
		StaticChannelAttributes		static_channel_attributes;
		UserChannelAttributes		user_channel_attributes;
		PrivateChannelAttributes	private_channel_attributes;
		AssignedChannelAttributes	assigned_channel_attributes;
	} u;
} ChannelAttributes;
typedef	ChannelAttributes *		PChannelAttributes;

class CChannelAttributesList : public CList
{
    DEFINE_CLIST(CChannelAttributesList, PChannelAttributes)
};

/*
 *	These types are used when dealing with MCS tokens.
 *
 *	TokenState
 *		This type specifies which state the token is in at any given time.
 *	GrabbedTokenAttributes
 *		This structure is used to define those attributes that are specific
 *		to grabbed tokens.
 *	InhibitedTokenAttributes
 *		This structure is used to define those attributes that are specific
 *		to inhibited tokens.
 *	GivingTokenAttributes
 *		This structure is used to define those attributes that are specific
 *		to giving tokens.
 *	GivenTokenAttributes
 *		This structure is used to define those attributes that are specific
 *		to given tokens.
 *	TokenAttributes
 *		This structure is used to define the attributes of ANY token.  It
 *		contains a token state, and a union of the above four types.
 *	CTokenAttributesList
 *		This is an S-list of TokenAttributes structures.
 */
typedef	enum
{
	TOKEN_AVAILABLE,
	TOKEN_GRABBED,
	TOKEN_INHIBITED,
	TOKEN_GIVING,
	TOKEN_GIVEN
} TokenState;
typedef	TokenState *			PTokenState;

typedef	struct
{
	TokenID				token_id;
	UserID				grabber;
} GrabbedTokenAttributes;

typedef	struct
{
	TokenID				token_id;
	CUidList           *inhibitors;
} InhibitedTokenAttributes;

typedef	struct
{
	TokenID				token_id;
	UserID				grabber;
	UserID				recipient;
} GivingTokenAttributes;

typedef	struct
{
	TokenID				token_id;
	UserID				recipient;
} GivenTokenAttributes;

typedef	struct
{
	TokenState			token_state;
	union
	{
		GrabbedTokenAttributes		grabbed_token_attributes;
		InhibitedTokenAttributes	inhibited_token_attributes;
		GivingTokenAttributes		giving_token_attributes;
		GivenTokenAttributes		given_token_attributes;
	} u;
} TokenAttributes;
typedef	TokenAttributes *		PTokenAttributes;

class CTokenAttributesList : public CList
{
    DEFINE_CLIST(CTokenAttributesList, PTokenAttributes)
};

/*
 *	The following structure is passed around between CommandTarget
 *	objects representing TokenGive requests and indications.
 */
typedef struct
{
	UserID				uidInitiator;
	TokenID				token_id;
	UserID				receiver_id;
} TokenGiveRecord;
typedef TokenGiveRecord *	PTokenGiveRecord;


/*
 *	These macros define the values used for domain parameters.  The default
 *	numbers are used upon initialization, to provide valid values.  The
 *	minimum and maximum numbers are used during arbitration, to provide a set
 *	of limits that are specific to this implementation.  Note that because
 *	this implementation does not use a table driven approach that requires
 *	up-front allocation of all resources, we do not impose an artificial limit
 *	on resources.  Resources (channels and tokens) will simply be allocated
 *	as-needed until no more can be allocated (or until arbitrated domain
 *	parameters have been reached).
 */
#define	DEFAULT_MAXIMUM_CHANNELS		1024
#define	DEFAULT_MAXIMUM_USERS			1024
#define	DEFAULT_MAXIMUM_TOKENS			1024
#define	DEFAULT_NUMBER_OF_PRIORITIES	3
#define	DEFAULT_NUM_PLUGXPRT_PRIORITIES	1
#define	DEFAULT_MINIMUM_THROUGHPUT		0
#define	DEFAULT_MAXIMUM_DOMAIN_HEIGHT	16
#define	DEFAULT_MAXIMUM_PDU_SIZE		4128
#define	DEFAULT_PROTOCOL_VERSION		2

#define	MINIMUM_MAXIMUM_CHANNELS		1
#define	MINIMUM_MAXIMUM_USERS			1
#define	MINIMUM_MAXIMUM_TOKENS			1
#define	MINIMUM_NUMBER_OF_PRIORITIES	1
#define	MINIMUM_NUM_PLUGXPRT_PRIORITIES	1
#define	MINIMUM_MINIMUM_THROUGHPUT		0
#define	MINIMUM_MAXIMUM_DOMAIN_HEIGHT	1
#define	MINIMUM_MAXIMUM_PDU_SIZE		1056
#define	MINIMUM_PROTOCOL_VERSION		2

#define	MAXIMUM_MAXIMUM_CHANNELS		65535L
#define	MAXIMUM_MAXIMUM_USERS			64535L
#define	MAXIMUM_MAXIMUM_TOKENS			65535L
#define	MAXIMUM_NUMBER_OF_PRIORITIES	4
#define	MAXIMUM_NUM_PLUGXPRT_PRIORITIES	1
#define	MAXIMUM_MINIMUM_THROUGHPUT		0
#define	MAXIMUM_MAXIMUM_DOMAIN_HEIGHT	100 
#define	MAXIMUM_MAXIMUM_PDU_SIZE		(8192 - PROTOCOL_OVERHEAD_X224 - PROTOCOL_OVERHEAD_SECURITY)
#define	MAXIMUM_PROTOCOL_VERSION		2

#define	PROTOCOL_VERSION_BASIC			1
#define	PROTOCOL_VERSION_PACKED			2

/*
 *	This macro is used to determine how many DataPacket objects to allocate.  This class
 *	is the most often created and destroyed during normal CommandTarget
 *	traffic.
 */
#define	ALLOCATE_DATA_PACKET_OBJECTS	128

/*
 *	~CommandTarget ()
 *
 *	Functional Description:
 *		This is a virtual destructor.  It does not actually do anything in this
 *		class.  By declaring it as virtual, we guarantee that all destructors
 *		in derived classes will be executed properly.
 *
 *	Formal Parameters:
 *		None.
 *
 *	Return Value:
 *		None.
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */
/*
 *	Void	PlumbDomainIndication (
 *					PCommandTarget		originator,
 *					ULong				height_limit)
 *
 *	Functional Description:
 *		This MCS command is used to insure that a cycle has not been created
 *		in an MCS domain.  It is broadcast downward after the creation of
 *		a new MCS connection.
 *
 *	Formal Parameters:
 *		originator (i)
 *			This is the address of the CommandTarget that issued this command.
 *		height_limit (i)
 *			This is the height limit from the originating domain downward.
 *			It is decremented each time the PDU is forwarded down another
 *			level.
 *
 *	Return Value:
 *		None.
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */
/*
 *	Void	ErectDomainRequest (
 *					PCommandTarget		originator,
 *					ULong				height_in_domain,
 *					ULong				throughput_interval)
 *
 *	Functional Description:
 *		This MCS command is used to communicate information upward to the
 *		Top Provider.  That information consists of the height of the current
 *		provider and the throughput enforcement interval.  Only the former is
 *		supported at this time.
 *
 *	Formal Parameters:
 *		originator (i)
 *			This is the address of the CommandTarget that issued this command.
 *		height_in_domain (i)
 *			This is the height of the originator in the domain.
 *		throughput_interval (i)
 *			This is not currently support, and will always be set to 0.
 *
 *	Return Value:
 *		None.
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */
/*
 *	Void	MergeChannelsRequest (
 *					PCommandTarget			originator,
 *					CChannelAttributesList *merge_channel_list,
 *					CChannelIDList         *purge_channel_list)
 *
 *	Functional Description:
 *		This command represents a channel being merged upward.
 *
 *	Formal Parameters:
 *		originator (i)
 *			This is the address of the CommandTarget that issued this command.
 *		merge_channel_list (i)
 *			This is list of attributes structures, each of which contains the
 *			attributes of one channel being merged upward.
 *		purge_channel_list (i)
 *			This is a list of channels that are to purged from the lower domain.
 *
 *	Return Value:
 *		None.
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */
/*
 *	Void	MergeChannelsConfirm (
 *					PCommandTarget			originator,
 *					CChannelAttributesList *merge_channel_list,
 *					CChannelIDList         *purge_channel_list)
 *
 *	Functional Description:
 *		This command represents the response to a previous request for a
 *		channel to be merged upward.
 *
 *	Formal Parameters:
 *		originator (i)
 *			This is the address of the CommandTarget that issued this command.
 *		merge_channel_list (i)
 *			This is list of attributes structures, each of which contains the
 *			attributes of one channel that was successfully merged upward.
 *		purge_channel_list (i)
 *			This is a list of channels that are to purged from the lower domain.
 *
 *	Return Value:
 *		None.
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */
/*
 *	Void	PurgeChannelsIndication (
 *					PCommandTarget		originator,
 *					CUidList           *purge_user_list,
 *					CChannelIDList     *purge_channel_list)
 *
 *	Functional Description:
 *		This command represents a channel being purged from a lower domain
 *		during a merge operation.
 *
 *	Formal Parameters:
 *		originator (i)
 *			This is the address of the CommandTarget that issued this command.
 *		purge_user_list (i)
 *			This is a list of user IDs representing users being purged from
 *			the lower domain during a merge operation.
 *		purge_channel_list (i)
 *			This is a list of channel IDs representing channels being purged
 *			from the lower domain during a merge operation.
 *
 *	Return Value:
 *		None.
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */
/*
 *	Void	MergeTokensRequest (
 *					PCommandTarget			originator,
 *					CTokenAttributesList   *merge_token_list,
 *					CTokenIDList           *purge_token_list)
 *
 *	Functional Description:
 *		This command represents a token being merged upward.
 *
 *	Formal Parameters:
 *		originator (i)
 *			This is the address of the CommandTarget that issued this command.
 *		merge_token_list (i)
 *			This is list of attributes structures, each of which contains the
 *			attributes of one token being merged upward.
 *		purge_token_list (i)
 *			This is a list of tokens that are to purged from the lower domain.
 *
 *	Return Value:
 *		None.
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */
/*
 *	Void	MergeTokensConfirm (
 *					PCommandTarget			originator,
 *					CTokenAttributesList   *merge_token_list,
 *					CTokenIDList           *purge_token_list)
 *
 *	Functional Description:
 *		This command represents the response to a previous request for a
 *		token merge.
 *
 *	Formal Parameters:
 *		originator (i)
 *			This is the address of the CommandTarget that issued this command.
 *		merge_token_list (i)
 *			This is list of attributes structures, each of which contains the
 *			attributes of one token being merged upward.
 *		purge_token_list (i)
 *			This is a list of tokens that are to purged from the lower domain.
 *
 *	Return Value:
 *		None.
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */
/*
 *	Void	PurgeTokensIndication (
 *					PCommandTarget			originator,
 *					CTokenIDList           *purge_token_list)
 *
 *	Functional Description:
 *		This command represents a token being purged from the lower domain
 *		during a merge operation.
 *
 *	Formal Parameters:
 *		originator (i)
 *			This is the address of the CommandTarget that issued this command.
 *		purge_token_list (i)
 *			This is a list of tokens that are to purged from the lower domain.
 *
 *	Return Value:
 *		None.
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */
/*
 *	Void	DisconnectProviderUltimatum (
 *					PCommandTarget		originator,
 *					Reason				reason)
 *
 *	Functional Description:
 *		This command represents an attachment into a domain being destroyed.
 *		This can be either a user attachment or an MCS connection.
 *
 *	Formal Parameters:
 *		originator (i)
 *			This is the address of the CommandTarget that issued this command.
 *		reason (i)
 *			The reason for the diconnect.
 *
 *	Return Value:
 *		None.
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */
/*
 *	Void	RejectUltimatum (
 *					PCommandTarget		originator,
 *					Diagnostic			diagnostic,
 *					PUChar				octet_string_address,
 *					ULong				octet_string_length)
 *
 *	Functional Description:
 *		This MCS command is used to indicate illegal traffic on an MCS
 *		connection.  The default response to this message is to disconnect
 *		the connection that conveyed it.
 *
 *	Formal Parameters:
 *		originator (i)
 *			This is the address of the CommandTarget that issued this command.
 *		diagnostic (i)
 *			One of the diagnostic codes elaborating on the cause of the problem.
 *		octet_string_address (i)
 *			The address of an optional user data field.  This will usually
 *			contain a copy of the packet that was received in error.
 *		octet_string_length (i)
 *			Length of the above field.
 *
 *	Return Value:
 *		None.
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */
/*
 *	Void	AttachUserRequest (
 *					PCommandTarget		originator)
 *
 *	Functional Description:
 *		This command represents a user request to attach to a domain.
 *
 *	Formal Parameters:
 *		originator (i)
 *			This is the address of the CommandTarget that issued this command.
 *
 *	Return Value:
 *		None.
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */
/*
 *	Void	AttachUserConfirm (
 *					PCommandTarget		originator,
 *					Result				result,
 *					UserID				uidInitiator)
 *
 *	Functional Description:
 *		This command represents the result of a previous request to attach
 *		to a domain.
 *
 *	Formal Parameters:
 *		originator (i)
 *			This is the address of the CommandTarget that issued this command.
 *		result (i)
 *			The result of the attach request.
 *		uidInitiator (i)
 *			If the result was successful, this will contain the unique user
 *			ID to be associated with this user.
 *
 *	Return Value:
 *		None.
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */
/*
 *	Void	DetachUserRequest (
 *					PCommandTarget		originator,
 *					Reason				reason,
 *					CUidList           *user_id_list)
 *
 *	Functional Description:
 *		This command represents a request to detach from a domain.
 *
 *	Formal Parameters:
 *		originator (i)
 *			This is the address of the CommandTarget that issued this command.
 *		reason (i)
 *			This is the reason for the detachment.
 *		user_id_list (i)
 *			A list of user IDs of users who are detaching from the domain.
 *
 *	Return Value:
 *		None.
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */
/*
 *	Void	DetachUserIndication (
 *					PCommandTarget		originator,
 *					Reason				reason,
 *					CUidList           *user_id_list)
 *
 *	Functional Description:
 *		This command represents a notification that a user has detached from
 *		the domain.
 *
 *	Formal Parameters:
 *		originator (i)
 *			This is the address of the CommandTarget that issued this command.
 *		reason (i)
 *			The reason for the detachment.
 *		user_id_list (i)
 *			A list of user IDs of users who are detaching from the domain.
 *
 *	Return Value:
 *		None.
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */
/*
 *	Void	ChannelJoinRequest (
 *					PCommandTarget		originator,
 *					UserID				uidInitiator,
 *					ChannelID			channel_id)
 *
 *	Functional Description:
 *		This command represents a request to join a channel.
 *
 *	Formal Parameters:
 *		originator (i)
 *			This is the address of the CommandTarget that issued this command.
 *		uidInitiator (i)
 *			The ID of the user who initiated the request.
 *		channel_id (i)
 *			The ID of the channel to be joined.
 *
 *	Return Value:
 *		None.
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */
/*
 *	Void	ChannelJoinConfirm (
 *					PCommandTarget		originator,
 *					Result				result,
 *					UserID				uidInitiator,
 *					ChannelID			requested_id,
 *					ChannelID			channel_id)
 *
 *	Functional Description:
 *		This command represents a response to a previous request to join a
 *		channel.
 *
 *	Formal Parameters:
 *		originator (i)
 *			This is the address of the CommandTarget that issued this command.
 *		result (i)
 *			The result of the join request.
 *		uidInitiator (i)
 *			The ID of the user who initiated the request.
 *		requested_id (i)
 *			This is the ID of the channel that was originally requested (which
 *			may be 0).
 *		channel_id (i)
 *			The ID of the channel being joined.
 *
 *	Return Value:
 *		None.
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */
/*
 *	Void	ChannelLeaveRequest (
 *					PCommandTarget		originator,
 *					CChannelIDList     *channel_id_list)
 *
 *	Functional Description:
 *		This command represents a request to leave a channel.
 *
 *	Formal Parameters:
 *		originator (i)
 *			This is the address of the CommandTarget that issued this command.
 *		channel_id_list (i)
 *			A list of channel IDs to be left.
 *
 *	Return Value:
 *		None.
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */
/*
 *	Void	ChannelConveneRequest (
 *					PCommandTarget		originator,
 *					UserID				uidInitiator)
 *
 *	Functional Description:
 *		This command represents a request to form a new private channel.
 *
 *	Formal Parameters:
 *		originator (i)
 *			This is the address of the CommandTarget that issued this command.
 *		uidInitiator (i)
 *			This is the initiator of the request.  If the request is
 *			successful, this wil be the channel manager.
 *
 *	Return Value:
 *		None.
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */
/*
 *	Void	ChannelConveneConfirm (
 *					PCommandTarget		originator,
 *					Result				result,
 *					UserID				uidInitiator,
 *					ChannelID			channel_id)
 *
 *	Functional Description:
 *		This command represents a response to a previous request to create a
 *		new private channel.
 *
 *	Formal Parameters:
 *		originator (i)
 *			This is the address of the CommandTarget that issued this command.
 *		result (i)
 *			This indicates whether or not the request was successful.
 *		uidInitiator (i)
 *			This is the User ID of the user who requested the creation of the
 *			new private channel.
 *		channel_id (i)
 *			The ID of the new private channel (if the request was successful).
 *
 *	Return Value:
 *		None.
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */
/*
 *	Void	ChannelDisbandRequest (
 *					PCommandTarget		originator,
 *					UserID				uidInitiator,
 *					ChannelID			channel_id)
 *
 *	Functional Description:
 *		This command represents a request to destroy an existing private
 *		channel.
 *
 *	Formal Parameters:
 *		originator (i)
 *			This is the address of the CommandTarget that issued this command.
 *		uidInitiator (i)
 *			This is the User ID of the user who is trying to destroy the private
 *			channel.  If this is not the same as the channel manager, the
 *			request will be denied.
 *		channel_id (i)
 *			The ID of the channel to be destroyed.
 *
 *	Return Value:
 *		None.
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */
/*
 *	Void	ChannelDisbandIndication (
 *					PCommandTarget		originator,
 *					ChannelID			channel_id)
 *
 *	Functional Description:
 *		This command represents the destruction of an existing private channel.
 *
 *	Formal Parameters:
 *		originator (i)
 *			This is the address of the CommandTarget that issued this command.
 *		channel_id (i)
 *			The ID of the channel to be destroyed.
 *
 *	Return Value:
 *		None.
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */
/*
 *	Void	ChannelAdmitRequest (
 *					PCommandTarget		originator,
 *					UserID				uidInitiator,
 *					ChannelID			channel_id,
 *					CUidList           *user_id_list)
 *
 *	Functional Description:
 *		This command represents a request to add new user IDs to an existing
 *		private channel.
 *
 *	Formal Parameters:
 *		originator (i)
 *			This is the address of the CommandTarget that issued this command.
 *		uidInitiator (i)
 *			This is the User ID of the user that is trying to expand the list
 *			of authorized users.  If this is not the channel manager, the
 *			request will fail.
 *		channel_id (i)
 *			The ID of the private channel to be affected.
 *		user_id_list (i)
 *			This is a container holding the User IDs to be added to the
 *			authorized user list.
 *
 *	Return Value:
 *		None.
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */
/*
 *	Void	ChannelAdmitIndication (
 *					PCommandTarget		originator,
 *					UserID				uidInitiator,
 *					ChannelID			channel_id,
 *					CUidList           *user_id_list)
 *
 *	Functional Description:
 *		This command represents the expansion of the authorized user list for a
 *		private channel.
 *
 *	Formal Parameters:
 *		originator (i)
 *			This is the address of the CommandTarget that issued this command.
 *		uidInitiator (i)
 *			This identifies the channel manager.
 *		channel_id (i)
 *			The ID of the private channel to be affected.
 *		user_id_list (i)
 *			This is a container holding the User IDs to be added to the
 *			authorized user list.
 *
 *	Return Value:
 *		None.
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */
/*
 *	Void	ChannelExpelRequest (
 *					PCommandTarget		originator,
 *					UserID				uidInitiator,
 *					ChannelID			channel_id,
 *					CUidList           *user_id_list)
 *
 *	Functional Description:
 *		This command represents a request to remove user IDs from an existing
 *		private channel.
 *
 *	Formal Parameters:
 *		originator (i)
 *			This is the address of the CommandTarget that issued this command.
 *		uidInitiator (i)
 *			This is the User ID of the user that is trying to shrink the list
 *			of authorized users.  If this is not the channel manager, the
 *			request will fail.
 *		channel_id (i)
 *			The ID of the private channel to be affected.
 *		user_id_list (i)
 *			This is a container holding the User IDs to be removed from the
 *			authorized user list.
 *
 *	Return Value:
 *		None.
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */
/*
 *	Void	ChannelExpelIndication (
 *					PCommandTarget		originator,
 *					ChannelID			channel_id,
 *					CUidList           *user_id_list)
 *
 *	Functional Description:
 *		This command represents the shrinkage of the authorized user list for a
 *		private channel.
 *
 *	Formal Parameters:
 *		originator (i)
 *			This is the address of the CommandTarget that issued this command.
 *		channel_id (i)
 *			The ID of the private channel to be affected.
 *		user_id_list (i)
 *			This is a container holding the User IDs to be removed from the
 *			authorized user list.
 *
 *	Return Value:
 *		None.
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

/*
 *	Void	SendDataRequest (
 *					PCommandTarget		originator,
 *					UINT				type,
					PDataPacket			data_packet)
 *
 *	Functional Description:
 *		This command represents non-uniform data travelling upward in the
 *		domain.
 *
 *	Formal Parameters:
 *		originator (i)
 *			This is the address of the CommandTarget that issued this command.
 *		type (i)
 *			Normal or uniform send data request
 *		data_packet (i)
 *			This is a pointer to a DataPacket object containing the channel
 *			ID, the User ID of the data sender, segmentation flags, priority of
 *			the data packet and a pointer to the packet to be sent.
 *
 *	Return Value:
 *		None.
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

/*
 *	Void	SendDataIndication (
 *					PCommandTarget		originator,
 *					UINT				type,
 *					PDataPacket			data_packet)
 *
 *	Functional Description:
 *		This command represents non-uniform data travelling downward in the
 *		domain.
 *
 *	Formal Parameters:
 *		originator (i)
 *			This is the address of the CommandTarget that issued this command.
 *		type (i)
 *			normal or uniform data indication
 *		data_packet (i)
 *			This is a pointer to a DataPacket object containing the channel
 *			ID, the User ID of the data sender, segmentation flags, priority of
 *			the data packet and a pointer to the packet to be sent.
 *
 *	Return Value:
 *		None.
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */
/*
 *	Void	UniformSendDataRequest (
 *					PCommandTarget		originator,
 *					PDataPacket			data_packet)
 *
 *	Functional Description:
 *		This command represents uniform data travelling upward in the domain.
 *
 *	Formal Parameters:
 *		originator (i)
 *			This is the address of the CommandTarget that issued this command.
 *		data_packet (i)
 *			This is a pointer to a DataPacket object containing the channel
 *			ID, the User ID of the data sender, segmentation flags, priority of
 *			the data packet and a pointer to the packet to be sent.
 *
 *	Return Value:
 *		None.
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */
/*
 *	Void	TokenGrabRequest (
 *					PCommandTarget		originator,
 *					UserID				uidInitiator,
 *					TokenID				token_id)
 *
 *	Functional Description:
 *		This command represents a request to grab a token.
 *
 *	Formal Parameters:
 *		originator (i)
 *			This is the address of the CommandTarget that issued this command.
 *		uidInitiator (i)
 *			The ID of the user attempting to grab the token.
 *		token_id (i)
 *			The ID of the token being grabbed.
 *
 *	Return Value:
 *		None.
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */
/*
 *	Void	TokenGrabConfirm (
 *					PCommandTarget		originator,
 *					Result				result,
 *					UserID				uidInitiator,
 *					TokenID				token_id,
 *					TokenStatus			token_status)
 *
 *	Functional Description:
 *		This command represents a response to a previous request to grab a
 *		token.
 *
 *	Formal Parameters:
 *		originator (i)
 *			This is the address of the CommandTarget that issued this command.
 *		result (i)
 *			The result of the grab operation.
 *		uidInitiator (i)
 *			The ID of the user attempting to grab the token.
 *		token_id (i)
 *			The ID of the token being grabbed.
 *		token_status (i)
 *			The status of the token after processing the request.
 *
 *	Return Value:
 *		None.
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */
/*
 *	Void	TokenInhibitRequest (
 *					PCommandTarget		originator,
 *					UserID				uidInitiator,
 *					TokenID				token_id)
 *
 *	Functional Description:
 *		This command represents a request to inhibit a token.
 *
 *	Formal Parameters:
 *		originator (i)
 *			This is the address of the CommandTarget that issued this command.
 *		uidInitiator (i)
 *			The ID of the user attempting to inhibit the token.
 *		token_id (i)
 *			The ID of the token being inhibited.
 *
 *	Return Value:
 *		None.
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */
/*
 *	Void	TokenInhibitConfirm (
 *					PCommandTarget		originator,
 *					Result				result,
 *					UserID				uidInitiator,
 *					TokenID				token_id,
 *					TokenStatus			token_status)
 *
 *	Functional Description:
 *		This command represents a response to a previous request to inhibit a
 *		token.
 *
 *	Formal Parameters:
 *		originator (i)
 *			This is the address of the CommandTarget that issued this command.
 *		result (i)
 *			The result of the inhibit operation.
 *		uidInitiator (i)
 *			The ID of the user attempting to inhibit the token.
 *		token_id (i)
 *			The ID of the token being inhibited.
 *		token_status (i)
 *			The status of the token after processing the request.
 *
 *	Return Value:
 *		None.
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */
/*
 *	Void	TokenGiveRequest (
 *					PCommandTarget		originator,
 *					PTokenGiveRecord	pTokenGiveRec)
 *
 *	Functional Description:
 *		This command represents a request to give a token to another user.
 *
 *	Formal Parameters:
 *		originator (i)
 *			This is the address of the CommandTarget that issued this command.
 *		pTokenGiveRec (i)
 *			This is the address of a structure containing the following information:
 *			The ID of the user attempting to give away the token.
 *			The ID of the token being given.
 *			The ID of the user that the token is being given to.
 *
 *	Return Value:
 *		None.
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */
/*
 *	Void	TokenGiveIndication (
 *					PCommandTarget		originator,
 *					PTokenGiveRecord	pTokenGiveRec)
 *
 *	Functional Description:
 *		This command represents notification that a user is trying to give a
 *		token to someone else.  It is issued by the Top Provider and propagates
 *		downward to the recipient.
 *
 *	Formal Parameters:
 *		originator (i)
 *			This is the address of the CommandTarget that issued this command.
 *		pTokenGiveRec (i)
 *			This is the address of a structure containing the following information:
 *			The ID of the user attempting to give away the token.
 *			The ID of the token being given.
 *			The ID of the user that the token is being given to.
 *
 *	Return Value:
 *		None.
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */
/*
 *	Void	TokenGiveResponse (
 *					PCommandTarget		originator,
 *					Result				result,
 *					UserID				receiver_id,
 *					TokenID				token_id)
 *
 *	Functional Description:
 *		This command represents a response to an offer to give away a token.
 *		It is issued by the recipient of a give offer, and moves upward to
 *		the Top Provider.  It contains the result of the give request.
 *
 *	Formal Parameters:
 *		originator (i)
 *			This is the address of the CommandTarget that issued this command.
 *		result (i)
 *			This parameter indicates whether or not the token was accepted.
 *			RESULT_SUCCESSFUL means that it was.
 *		receiver_id (i)
 *			The ID of the user that the token is being given to.
 *		token_id (i)
 *			The ID of the token being given.
 *
 *	Return Value:
 *		None.
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */
/*
 *	Void	TokenGiveConfirm (
 *					PCommandTarget		originator,
 *					Result				result,
 *					UserID				uidInitiator,
 *					TokenID				token_id,
 *					TokenStatus			token_status)
 *
 *	Functional Description:
 *		This command represents a response to a previous call to
 *		TokenGiveRequest.  It flows downward to the original giver letting it
 *		know whether or not the token was accepted.
 *
 *	Formal Parameters:
 *		originator (i)
 *			This is the address of the CommandTarget that issued this command.
 *		result (i)
 *			This parameter indicates whether or not the token was accepted.
 *			RESULT_SUCCESSFUL means that it was.
 *		uidInitiator (i)
 *			The ID of the user attempting to give away a token.
 *		token_id (i)
 *			The ID of the token being given.
 *		token_status (i)
 *			The status of the token as a result of the give operation.
 *
 *	Return Value:
 *		None.
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */
/*
 *	Void	TokenPleaseRequest (
 *					PCommandTarget		originator,
 *					UserID				uidInitiator,
 *					TokenID				token_id)
 *
 *	Functional Description:
 *		This command represents a request to receive a token that is already
 *		owned by one or more other users.
 *
 *	Formal Parameters:
 *		originator (i)
 *			This is the address of the CommandTarget that issued this command.
 *		uidInitiator (i)
 *			The ID of the user that wishes to own the token.
 *		token_id (i)
 *			The ID of the token that the user wishes to own.
 *
 *	Return Value:
 *		None.
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */
/*
 *	Void	TokenPleaseIndication (
 *					PCommandTarget		originator,
 *					UserID				uidInitiator,
 *					TokenID				token_id)
 *
 *	Functional Description:
 *		This command represents a request by another user to own the token.
 *		This is issued by the Top Provider and flows downward to all current
 *		owners of the specified token.
 *
 *	Formal Parameters:
 *		originator (i)
 *			This is the address of the CommandTarget that issued this command.
 *		uidInitiator (i)
 *			The ID of the user that wishes to own the token.
 *		token_id (i)
 *			The ID of the token that the user wishes to own.
 *
 *	Return Value:
 *		None.
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */
/*
 *	Void	TokenReleaseRequest (
 *					PCommandTarget		originator,
 *					UserID				uidInitiator,
 *					TokenID				token_id)
 *
 *	Functional Description:
 *		This command represents a request to release a token.
 *
 *	Formal Parameters:
 *		originator (i)
 *			This is the address of the CommandTarget that issued this command.
 *		uidInitiator (i)
 *			The ID of the user attempting to release the token.
 *		token_id (i)
 *			The ID of the token being released.
 *
 *	Return Value:
 *		None.
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */
/*
 *	Void	TokenReleaseIndication (
 *					PCommandTarget		originator,
 *					Reason				reason,
 *					TokenID				token_id)
 *
 *	Functional Description:
 *		This command represents an indication that a user has lost ownership
 *		of a token during a merge operation.
 *
 *	Formal Parameters:
 *		originator (i)
 *			This is the address of the CommandTarget that issued this command.
 *		reason (i)
 *			This is the reason that the user's ownership of the token is
 *			being taken away.
 *		token_id (i)
 *			The ID of the token being taken away.
 *
 *	Return Value:
 *		None.
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */
/*
 *	Void	TokenReleaseConfirm (
 *					PCommandTarget		originator,
 *					Result				result,
 *					UserID				uidInitiator,
 *					TokenID				token_id,
 *					TokenStatus			token_status)
 *
 *	Functional Description:
 *		This command represents a response to a previous request to release a
 *		token.
 *
 *	Formal Parameters:
 *		originator (i)
 *			This is the address of the CommandTarget that issued this command.
 *		result (i)
 *			The result of the release operation.
 *		uidInitiator (i)
 *			The ID of the user attempting to release the token.
 *		token_id (i)
 *			The ID of the token being released.
 *		token_status (i)
 *			The status of the token after processing the request.
 *
 *	Return Value:
 *		None.
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */
/*
 *	Void	TokenTestRequest (
 *					PCommandTarget		originator,
 *					UserID				uidInitiator,
 *					TokenID				token_id)
 *
 *	Functional Description:
 *		This command represents a request to test a token.
 *
 *	Formal Parameters:
 *		originator (i)
 *			This is the address of the CommandTarget that issued this command.
 *		uidInitiator (i)
 *			The ID of the user testing the token.
 *		token_id (i)
 *			The ID of the token being tested.
 *
 *	Return Value:
 *		None.
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */
/*
 *	Void	TokenTestConfirm (
 *					PCommandTarget		originator,
 *					UserID				uidInitiator,
 *					TokenID				token_id,
 *					TokenStatus			token_status)
 *
 *	Functional Description:
 *		This command represents a response to a previous request to test a
 *		token.
 *
 *	Formal Parameters:
 *		originator (i)
 *			This is the address of the CommandTarget that issued this command.
 *		uidInitiator (i)
 *			The ID of the user testing the token.
 *		token_id (i)
 *			The ID of the token being tested.
 *		token_status (i)
 *			The status of the token after processing the request.
 *
 *	Return Value:
 *		None.
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */
/*
 *	Void	MergeDomainIndication (
 *					PCommandTarget		originator,
 *					MergeStatus			merge_status)
 *
 *	Functional Description:
 *		This command indicates that the local provider is either entering or
 *		leaving a domain merge state.
 *
 *	Formal Parameters:
 *		originator (i)
 *			This is the address of the CommandTarget that issued this command.
 *		merge_status (i)
 *			This indicates whether the provider is entering or leaving the merge
 *			state.
 *
 *	Return Value:
 *		None.
 *
 *	Side Effects:
 *		When issued by a domain, it means that no upward traffic should be
 *		sent to the domain until, the merge state is complete.
 *
 *	Caveats:
 *		None.
 */

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\remdsk\rds\t120\h\cnpcoder.h ===
/*
 *	ogcccode.h
 *
 *	Copyright (c) 1999 by Microsoft Corporation
 *
 *	Abstract:
 *		This is the interface file for the CNPCoder class.  This
 *		class is used to encode and decode CNP Protocol Data Units (PDU's)
 *		to and from ASN.1 compliant byte streams using the ASN.1 toolkit.
 *
 *	Caveats:
 *		None.
 *
 *	Author:
 *		Xin Liu
 *
 */
#ifndef	_CCNPCODER_
#define	_CCNPCODER_

#include "pktcoder.h"
#include "cnppdu.h"

/*
 *	This is the class definition for class CCNPCoder
 */
class	CCNPCoder : public PacketCoder
{
 public:
    CCNPCoder ();
    BOOL                Init ( void );
    virtual             ~CCNPCoder ();
    virtual	BOOL	Encode (LPVOID                  pdu_structure,
                                int                     pdu_type,
                                UINT                    rules_type,
                                LPBYTE			*encoding_buffer,
                                UINT			*encoding_buffer_length);
    
    virtual BOOL	Decode (LPBYTE			encoded_buffer,
                                UINT			encoded_buffer_length,
                                int                     pdu_type,
                                UINT			rules_type,
                                LPVOID			*decoding_buffer,
                                UINT			*decoding_buffer_length);
    
    virtual void	FreeEncoded (LPBYTE encoded_buffer);
    
    virtual void	FreeDecoded (int pdu_type, LPVOID decoded_buffer);
    
    virtual BOOL     IsMCSDataPacket (	LPBYTE,	UINT		) { return FALSE; };
    
 private:
    //    BOOL    		IsObjectIDCompliant (PKey	t124_identifier);
    ASN1encoding_t  m_pEncInfo;    // ptr to encoder info
    ASN1decoding_t  m_pDecInfo;    // ptr to decoder info
};

typedef CCNPCoder *		PCCNPCoder;

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\remdsk\rds\t120\h\conf.h ===
/*
 *	conf.h
 *
 *	Copyright (c) 1995 by DataBeam Corporation, Lexington, KY
 *
 *	Abstract:
 *		This is the interface file for the CConf class.  This class
 *		is where most of the inteligence within GCC lies.  The class
 *		manages the GCC databases and routes the messages and PDUs.
 *
 *		CConf objects represent the true heart of GCC.  Each CConf
 *		object represents one logical conference within a GCC provider.  This
 *		class encapsulates the conference information base which is the focal
 *		point for all GCC traffic.  This information base consists of several
 *		Rogue Wave containers, including:
 *		-	a dictionary of enrolled applications (indexed by application SAP
 *			handles).
 *		-	a list of application roster managers.
 *		-	a list of downward MCS connections.
 *		-	a list of outstanding sequence numbers (used during conference
 *			establishment).
 *		-	a list of outstanding join requests.
 *
 *		In order to simplify the CConf class as much as possible, there are
 *		some things that CConf objects do not worry about.  First and
 *		foremost is Conference and Application Roster management.  This is
 *		handled by two separate classes.  Next is the Application Registry.
 *		CConf objects don't maintain the Application Registry information
 *		base.  CConf objects also do not worry about memory management.
 *		They merely pass Packet objects around, which contain the user data
 *		being handled.  A CConf object has absolutely no responsibility
 *		for protocol data associated with an enrolled application. Below is
 *		more detail about what a conference is responsible for.
 *
 *		When a CConf object is first created, its information base is
 *		empty.  It has no enrolled applications, it has not established any MCS
 *		connections and it has no user attachment to MCS.  There is a period of
 *		time that will be referred to as the Conference Establishment Process
 *		where the CConf object is progressing through the steps defined by
 *		the T.124 specification to join or create a conference.  This process
 *		varies depending on the request that initiated the creation of the
 *		conference.  A CConf Object must know if it is a Top Provider.
 *		Many of the establishment procedures and normal operating procedures
 *		vary depending on this.  A CConf object learns of its type through
 *		the initial requests that are made to it.  For example,  if a
 *		CConf receives a ConferenceCreateRequest where the conference is
 *		to be created locally it knows it is the Top Provider.
 *
 *		The establishment process involves three main steps that all nodes go
 *		through when creating a new conference.  The first is establishing the
 *		MCS connection either through a ConnectProviderRequest or a
 *		ConnectProviderResponse call  (note that this step is skipped when
 *		creating a local conference).  If this step is successful, the
 *		CConf object will create an MCSUser object which progresses through
 *		a number of its own internal steps which include creating an MCS User
 *		Attachment and joining the appropriate channels (which are handled by
 *		the MCSUser object). Finally, when the above two steps have successfully
 *		completed, the conference creates an Application Registry and the
 *		CConfRosterMgr objects and informs the Controller that the
 *		conference is established.  A conference cannot respond to any request
 *		during this establishment process.  For instance, a conference will not
 *		show up in a Conference Query descriptor list during the establishment
 *		phase.
 *
 *		A note about the creation of the CConfRosterMgr objects.
 *		A CConf object that is not the Top Provider will instantiate both
 *		a Local and a Global CConfRosterMgr while the Top Provider
 *		only maintains a Global Conference Roster Manager.  A Local manager
 *		maintains a Conference Roster which holds the local nodes conference
 *		record and the conference records for all nodes below it in the
 *		connection hierarchy.  A Global manager maintains a Conference Roster
 *		which includes the conference records for every node that has announced
 *		its presence with the conference.
 *
 *		After the above establishment process is complete the Owner Object is
 *		notified through an owner callback that the conference is ready for
 *		action.  When the node controller receives a
 *		GCC_PERMIT_TO_ANNOUNCE_PRESENCE indication it must respond with a call
 *		to GCCAnnouncePresenceRequest().  This is when the node controller
 *		passes its conference record (which contains all the pertinent
 *		information about the node) to the newly created conference.  This
 *		request travels through the CControlSAP directly to the conference
 *		through a GCCCommandTarget call.  Remember that the CConf class
 *		inherits from the GCCCommandTarget class.  Whenever a call is made
 *		directly to a CConf object from either a CControlSAP or an CAppSap
 *		object, it is made through a command target call.
 *
 *		When an application receives a GCC_PERMIT_TO_ENROLL_INDICATION it must
 *		respond by calling AppEnrollRequest() to inform the
 *		CConf object whether or not it wants to enroll with the conference.
 *		When an application enroll request is received by a CConf
 *		object a number of things happen, some of which depend on whether the
 *		CConf object is a Top Provider or a subordinate node.  First the
 *		CConf determines if the application is enrolling.  If it isn't,  a
 *		GCC_APPLICATION_ENROLL_CONFIRM is sent to the application that made the
 *		request and no further action is taken.  If the application is
 *		enrolling, the CConf object first registers itself with the CAppSap
 *		making the request.  This allows future application requests to travel
 *		directly to the CConf object through command target calls.  The
 *		CConf then establishes the Application Roster Manager
 *		(if necessary) for this particular application.
 *
 *		After the above establishment and enrollment process is completed a
 *		CConf object sits idle waiting to service requests or process
 *		incoming PDUs.  These include RosterUpdateIndications as well as
 *		CRegistry requests.
 *
 *		A CConf object can be deleted in a number of different ways.  If a
 *		resource error occurs, a conference can Terminate itself by sending an
 *		error TERMINATE indication to its owner through an owner callback.
 *		The node controller can terminate a conference object by calling
 *		GCCConferenceDisconnectRequest() or GCCConferenceTerminateRequest().  A
 *		CConf object can also be terminated if it loses its parent
 *		connection or if it is set up to automatically terminate after all its
 *		subordinate nodes disconnect.  These types of Terminates are initiated
 *		through owner callbacks to the Owner Object.
 *
 *	Portable:
 *		Yes
 *
 *	Caveats:
 *		None.
 *
 *	Author:
 *		blp
 */
#ifndef	_CONFERENCE_
#define	_CONFERENCE_

#include "arostmgr.h"
#include "sap.h"
#include "pktcoder.h"
#include "mcsdllif.h"
#include "password.h"
#include "netaddr.h"
#include "privlist.h"
#include "crostmgr.h"
#include "registry.h"
#include "appsap.h"
#include "csap.h"

//	Message bases
#define		USER_ATTACHMENT_MESSAGE_BASE	100
#define		APP_ROSTER_MGR_MESSAGE_BASE		200
#define		CONF_ROSTER_MGR_MESSAGE_BASE	300


enum
{
    CONF_FLUSH_ROSTER_DATA      = CONFMSG_BASE + 1,
};


typedef struct
{
	GCCConfID		conference_id;
	GCCReason		reason;
}
    CONF_TERMINATE_INFO;


typedef struct
{
	ConnectionHandle	connection_handle;
	TagNumber			invite_tag;
	CUserDataListContainer *user_data_list;
}
    INVITE_REQ_INFO;


/*	This structure is used to hold all of an APEs enrollment information.
**	Every APE enrolled with a conference will have a single one of these
**	info structures defined for it.
*/
//
// LONCHANC: We should merge the following to another structure or class
// because it has 2 dwords and we need to allocate memory for it.
//
typedef struct
{
	CAppSap             *pAppSap;
	CSessKeyContainer	*session_key;
}
    ENROLLED_APE_INFO;

/*
**	Lists/Dictionaries used by the CConf Object
*/

//	This list is used to keep track of the outstanding join responses
class CJoinRespNamePresentConnHdlList2 : public CList2
{
    // use TRUE_PTR and FALSE_PTR
    DEFINE_CLIST2_(CJoinRespNamePresentConnHdlList2, BOOL_PTR, ConnectionHandle)
};

//	This list is used to keep track of the enrolled APEs
class CEnrolledApeEidList2 : public CList2
{
    DEFINE_CLIST2_(CEnrolledApeEidList2, ENROLLED_APE_INFO*, GCCEntityID)
};

//	This list is keeps up with the child node connection handles
class CConnHandleList : public CList
{
    DEFINE_CLIST_(CConnHandleList, ConnectionHandle)
};

//	This list is used to match outstanding user IDs
typedef	TagNumber	        UserIDTagNumber; // unsigned long
class CConnHdlTagNumberList2 : public CList2
{
    DEFINE_CLIST2(CConnHdlTagNumberList2, ConnectionHandle, UserIDTagNumber)
};

//	This list is used to hold all the outstanding invite request
class CInviteRequestList : public CList
{
    DEFINE_CLIST(CInviteRequestList, INVITE_REQ_INFO*)
};

//	This list is used to hold all the outstanding ejects
class CEjectedNodeConfirmList : public CList
{
    DEFINE_CLIST_(CEjectedNodeConfirmList, GCCNodeID)
};

//	This list is a queue of outstanding conductor token test
class CConductorTestList : public CList
{
    DEFINE_CLIST(CConductorTestList, CBaseSap*)
};

// this list is a queue of outstanding "add" request
class CNetAddrTagNumberList2 : public CList2
{
    DEFINE_CLIST2(CNetAddrTagNumberList2, CNetAddrListContainer*, TagNumber)
};

class CTagNumberTagNumberList2 : public CList2
{
    DEFINE_CLIST2__(CTagNumberTagNumberList2, TagNumber)
};

// this list holds the NetMeeting version numbers of all nodes in the conference
class CNodeVersionList2 : public CList2
{
	DEFINE_CLIST2_(CNodeVersionList2, DWORD, GCCNodeID)
};


// Conference specification parameters
typedef struct
{
	BOOL						fClearPassword;
	BOOL						fConfLocked;
	BOOL						fConfListed;
	BOOL						fConfConductable;
	GCCTerminationMethod		eTerminationMethod;
	PGCCConferencePrivileges	pConductPrivilege;
	PGCCConferencePrivileges	pConductModePrivilege;
	PGCCConferencePrivileges	pNonConductPrivilege;
	LPWSTR						pwszConfDescriptor;
}
	CONF_SPEC_PARAMS;

//	The class definition
class CConf : public CRefCount
{
    friend class MCSUser;

public:

	CConf
	(
		PGCCConferenceName			conference_name,
		GCCNumericString			conference_modifier,
		GCCConfID				    conference_id,
		CONF_SPEC_PARAMS			*pConfSpecParams,
		UINT						cNetworkAddresses,
		PGCCNetworkAddress 			*pLocalNetworkAddress,
		PGCCError					return_value
	);

	~CConf(void);

	/*
	**	Public Member Functions : should only be called
	**	by the owner object
	*/
	GCCError		ConfCreateRequest(
						TransportAddress		calling_address,
						TransportAddress		called_address,
						BOOL					fSecure,
						CPassword               *convener_password,
						CPassword               *password,
						LPWSTR					pwszCallerID,
						PDomainParameters		domain_parameters,
						CUserDataListContainer  *user_data_list,
						PConnectionHandle		connection_handle);

	GCCError		ConfCreateResponse(
						ConnectionHandle		connection_handle,
						PDomainParameters		domain_parameters,
						CUserDataListContainer  *user_data_list);

	GCCError		ConfJoinRequest
					(
						GCCNumericString		called_node_modifier,
						CPassword               *convener_password,
						CPassword               *password_challenge,
						LPWSTR					pwszCallerID,
						TransportAddress		calling_address,
						TransportAddress		called_address,
						BOOL					fSecure,
						PDomainParameters 		domain_parameters,
						CUserDataListContainer  *user_data_list,
						PConnectionHandle		connection_handle
					);

	GCCError		ForwardConfJoinRequest
					(
						CPassword               *convener_password,
						CPassword               *password_challange,
						LPWSTR					pwszCallerID,
						CUserDataListContainer  *user_data_list,
						BOOL					numeric_name_present,
						ConnectionHandle		connection_handle
					);

	GCCError		ConfJoinIndResponse
					(
						ConnectionHandle		connection_handle,
						CPassword               *password_challenge,
						CUserDataListContainer  *user_data_list,
						BOOL					numeric_name_present,
						BOOL					convener_is_joining,
						GCCResult				result
					);

	GCCError		ConfInviteResponse(
						UserID					parent_user_id,
						UserID					top_user_id,
						TagNumber				tag_number,
						ConnectionHandle		connection_handle,
						BOOL					fSecure,
						PDomainParameters		domain_parameters,
						CUserDataListContainer  *user_data_list);

	GCCError		RegisterAppSap(CAppSap *);
	GCCError		UnRegisterAppSap(CAppSap *);
	GCCError		DisconnectProviderIndication(ConnectionHandle);
	GCCError		ConfRosterInquireRequest(CBaseSap *, GCCAppSapMsgEx **);
	GCCError		AppRosterInquireRequest(GCCSessionKey *, CAppRosterMsg **);
	BOOL			FlushOutgoingPDU(void);

    GCCConfID GetConfID ( void ) { return m_nConfID; }
    ConferenceNodeType GetConfNodeType ( void ) { return m_eNodeType; }

    GCCNodeID GetParentNodeID(void) { return (m_pMcsUserObject ? m_pMcsUserObject->GetParentNodeID() : 0); }

    BOOL IsConfTopProvider ( void )
    {
        return ((m_eNodeType == TOP_PROVIDER_AND_CONVENER_NODE) ||
                (m_eNodeType == TOP_PROVIDER_NODE));
    }

    GCCNodeID GetTopProvider(void) { return (m_pMcsUserObject ? m_pMcsUserObject->GetTopNodeID() : 0); }

    BOOL DoesConvenerExists ( void ) { return (m_nConvenerNodeID != 0); }
    BOOL IsConfListed ( void ) { return m_fConfListed; }
    BOOL IsConfPasswordInTheClear ( void ) { return m_fClearPassword; }
    BOOL IsConfLocked ( void ) { return m_fConfLocked; }
    BOOL IsConfEstablished ( void ) { return m_fConfIsEstablished; }
    BOOL IsConfConductible ( void ) { return m_fConfConductible; }
    BOOL IsConfSecure ( void ) { return m_fSecure; }

    LPSTR GetNumericConfName ( void ) { return m_pszConfNumericName; }
    LPWSTR GetTextConfName ( void ) { return m_pwszConfTextName; }
    LPSTR GetConfModifier ( void ) { return m_pszConfModifier; }
    LPWSTR GetConfDescription ( void ) { return m_pwszConfDescription; }
    CNetAddrListContainer *GetNetworkAddressList ( void ) { return m_pNetworkAddressList; }
    void ConfIsOver ( void ) { m_fConfIsEstablished = FALSE; }

    CRegistry *GetRegistry ( void ) { return m_pAppRegistry; }

	/*
	**	These are Command Targets
	*/

	GCCError			ConfJoinReqResponse(
							UserID				    receiver_id,
							CPassword               *password_challenge,
							CUserDataListContainer  *user_data_list,
							GCCResult			    result);

	GCCError			ConfInviteRequest(
							LPWSTR					pwszCallerID,
							TransportAddress		calling_address,
							TransportAddress		called_address,
							BOOL					fSecure,
							CUserDataListContainer  *user_data_list,
							PConnectionHandle		connection_handle);

	GCCError			ConfLockResponse(UserID uidRequester, GCCResult);

	GCCError 			ConfEjectUserRequest(UserID uidEjected, GCCReason reason);
	GCCError			ConfAnnouncePresenceRequest(PGCCNodeRecord node_record);
	GCCError			ConfDisconnectRequest(void);

	GCCError			AppEnrollRequest(CAppSap *, GCCEnrollRequest *, GCCRequestTag);

#ifdef JASPER
	GCCError			ConfLockRequest(void);
	GCCError			ConfUnlockRequest(void);
	GCCError			ConfUnlockResponse(UserID uidRequester, GCCResult result);
	GCCError			ConfTerminateRequest(GCCReason reason);
#endif // JASPER

	/******************** Registry calls **************************/

	GCCError			RegistryRegisterChannelRequest(
							PGCCRegistryKey			registry_key,
							ChannelID				channel_id,
							CAppSap *);
					
	GCCError			RegistryAssignTokenRequest(
							PGCCRegistryKey			registry_key,
							CAppSap *);

	GCCError			RegistrySetParameterRequest (
							PGCCRegistryKey			registry_key,
							LPOSTR			        parameter_value,
							GCCModificationRights	modification_rights,
							CAppSap *);

	GCCError			RegistryRetrieveEntryRequest(
							PGCCRegistryKey			registry_key,
							CAppSap *);

	GCCError			RegistryDeleteEntryRequest(
							PGCCRegistryKey			registry_key,
							CAppSap *);

	GCCError			RegistryMonitorRequest(
							BOOL					enable_delivery,
							PGCCRegistryKey			registry_key,
							CAppSap *);

	GCCError			RegistryAllocateHandleRequest(
							UINT					number_of_handles,
							CAppSap *);
								
	/******************** Conductorship calls **************************/

	GCCError 			ConductorGiveResponse(GCCResult result);

#ifdef JASPER
	GCCError 			ConductorAssignRequest(void);
	GCCError 			ConductorReleaseRequest(void);
	GCCError 			ConductorPleaseRequest(void);
	GCCError 			ConductorGiveRequest(UserID recipient_node_id);
	GCCError 			ConductorPermitAskRequest(BOOL grant_permission);
    GCCError 			ConductorPermitGrantRequest(
							UINT					number_granted,
							PUserID					granted_node_list,
							UINT					number_waiting,
							PUserID					waiting_node_list);
#endif // JASPER

	GCCError 			ConductorInquireRequest(CBaseSap *);

	/********************************************************************/

	//	Miscelaneous calls
	GCCError		ConferenceTimeRemainingRequest (
							UINT			time_remaining,
							UserID			node_id);

    GCCError 		AppInvokeRequest(
						CInvokeSpecifierListContainer*,
                        GCCSimpleNodeList *,
              			CBaseSap *,
              			GCCRequestTag);

	GCCError		UpdateNodeVersionList(PGCCPDU	roster_update,
										  UserID	sender_id);

	DWORD			GetNodeVersion(UserID   nodeId) { return m_NodeVersionList2.Find(nodeId); }
						
    BOOL            HasNM2xNode(void);


#ifdef JASPER
	GCCError 		ConfTimeInquireRequest(BOOL time_is_conference_wide);
	GCCError		ConfExtendRequest (
							UINT			extension_time,
							BOOL		 	time_is_conference_wide);
	GCCError		ConfAssistanceRequest(
							UINT			number_of_user_data_members,
							PGCCUserData *	user_data_list);
	GCCError 		TextMessageRequest (
						LPWSTR				pwszTextMsg,
						UserID				destination_node );
	GCCError		ConfTransferRequest (
						PGCCConferenceName	destination_conference_name,
						GCCNumericString	destination_conference_modifier,
						CNetAddrListContainer *network_address_list,
						UINT				number_of_destination_nodes,
						PUserID				destination_node_list,
						CPassword           *password);
	GCCError		ConfAddRequest (	
						CNetAddrListContainer   *network_address_container,
						UserID				    adding_node,
						CUserDataListContainer  *user_data_container);
#endif // JASPER

	GCCError		ConfAddResponse (	
						GCCResponseTag		    add_response_tag,
						UserID				    requesting_node,
						CUserDataListContainer	*user_data_container,
						GCCResult			    result);


    void  WndMsgHandler(UINT);

	//	Routines called from the mcs interface
	void			ProcessConnectProviderConfirm(PConnectProviderConfirm connect_provider_confirm);

    // Callback from conf roster manager

    void ConfRosterReportIndication ( CConfRosterMsg * );

    void CancelInviteRequest(ConnectionHandle);

protected:

    //
    // Routines called from the user object via owner callbacks
    //

	void			ProcessConferenceCreateResponsePDU(
								PConferenceCreateResponse	create_response,
								PConnectProviderConfirm		connect_provider_confirm);

	void			ProcessConferenceJoinResponsePDU(
								PConferenceJoinResponse		join_response,
								PConnectProviderConfirm		connect_provider_confirm);

	void 			ProcessConferenceInviteResponsePDU(
								PConferenceInviteResponse	invite_response,
								PConnectProviderConfirm		connect_provider_confirm);

	void   			ProcessUserIDIndication(
								TagNumber			tag_number,
								UserID				user_id);

	void			ProcessUserCreateConfirm(
								UserResultType		result,
								UserID				user_id);

	void			ProcessRosterUpdatePDU(
								PGCCPDU				roster_update,
								UserID				sender_id);

	void			ProcessRosterRefreshPDU(
								PGCCPDU				roster_update,
								UserID				sender_id);

	GCCError		ProcessAppRosterIndicationPDU(	
								PGCCPDU					roster_update,
								UserID					sender_id);
						
	void			ProcessDetachUserIndication(
								UserID					detached_user,
								GCCReason				reason);

								
	void			ProcessTerminateRequest(
								UserID					requester_id,
								GCCReason				reason);

	void			ProcessTerminateIndication(GCCReason reason);
	void			ProcessEjectUserRequest(PUserEjectNodeRequestInfo eject_node_request);
	void			ProcessEjectUserIndication(GCCReason reason);
  	void			ProcessEjectUserResponse(PUserEjectNodeResponseInfo eject_node_response);
	void			ProcessConferenceLockRequest(UserID requester_id);
	void			ProcessConferenceUnlockRequest(UserID requester_id);
	void			ProcessConferenceLockIndication(UserID source_id);
	void			ProcessConferenceUnlockIndication(UserID source_id);

    void            ProcessConfJoinResponse(PUserJoinResponseInfo);
    void            ProcessAppInvokeIndication(CInvokeSpecifierListContainer *, UserID);
#ifdef JASPER
    void            ProcessConductorPermitAskIndication(PPermitAskIndicationInfo);
#endif // JASPER
    void            ProcessConfAddResponse(PAddResponseInfo);


	/***************** Conductorship calls ***********************/

	void			ProcessConductorGrabConfirm(GCCResult result);
	void			ProcessConductorAssignIndication(UserID uidNewConductor, UserID uidSender);
	void			ProcessConductorReleaseIndication(UserID uidSender);
	void			ProcessConductorGiveIndication(UserID uidGiver);
	void			ProcessConductorGiveConfirm(GCCResult);
	void			ProcessConductorPermitGrantInd(PUserPermissionGrantIndicationInfo, UserID uidSender);
	void			ProcessConductorTestConfirm(GCCResult);

    void			ProcessConferenceTransferRequest(
								UserID				requesting_node_id,
								PGCCConferenceName	destination_conference_name,
								GCCNumericString	destination_conference_modifier,
								CNetAddrListContainer *destination_address_list,
								UINT				number_of_destination_nodes,
 								PUserID				destination_node_list,
								CPassword           *password);
								
	void			ProcessConferenceTransferIndication(
								PGCCConferenceName	destination_conference_name,
								GCCNumericString	destination_conference_modifier,
								CNetAddrListContainer *destination_address_list,
								CPassword               *password);

	void			ProcessConferenceAddRequest(
								CNetAddrListContainer *network_address_list,
								CUserDataListContainer *user_data_list,
								UserID				adding_node,
								TagNumber			add_request_tag,
								UserID				requesting_node);

	void			InitiateTermination(GCCReason, UserID uidRequester);

    // look for this node ID in the roster's record set.
    BOOL            IsThisNodeParticipant(GCCNodeID);

private:

	/*************************************************************/

	CAppRosterMgr		*GetAppRosterManager(PGCCSessionKey session_key);
	TagNumber			GetNewUserIDTag(void);
	void				GetConferenceNameAndModifier(PGCCConferenceName, PGCCNumericString pszConfModifier);
	BOOL				DoesRequesterHavePrivilege(UserID uidRequester, ConferencePrivilegeType);
	GCCError			SendFullRosterRefresh(void);
	GCCError			UpdateNewConferenceNode(void);

	/*
	**	This group of routines operates on the enrolled APE list.
	*/
	GCCError			GetEntityIDFromAPEList(CAppSap *, PGCCSessionKey, GCCEntityID *);
	GCCError			GenerateEntityIDForAPEList(CAppSap *, PGCCSessionKey, GCCEntityID *);
	void				RemoveSAPFromAPEList(CAppSap *);
	ENROLLED_APE_INFO	*GetEnrolledAPEbySap(CAppSap *, GCCEntityID *);
	GCCError			FlushRosterData(void);
	GCCError			AsynchFlushRosterData(void);
	void				DeleteEnrolledAPE(GCCEntityID);
	BOOL				IsReadyToSendAppRosterUpdate(void);
	void				DeleteOutstandingInviteRequests(void);
    void                DeleteInviteRequest(INVITE_REQ_INFO *);

    BOOL	DoesSAPHaveEnrolledAPE(CAppSap *pAppSap)
	{
		return (BOOL) (UINT_PTR) GetEnrolledAPEbySap(pAppSap, NULL);
	}


	// Yikang:  This method checks whether the roster update PDU
	// contains the applet. The refreshonly argument indicates
	// whether or not to check the record updates.
	BOOL	DoesRosterPDUContainApplet(PGCCPDU  roster_update,
				const struct Key *obj_key, BOOL  refreshonly = TRUE);

    void    AddNodeVersion(UserID, NodeRecord*);


private:

	CAppRosterMgrList				    m_AppRosterMgrList;
	CAppSapList                         m_RegisteredAppSapList;
	CEnrolledApeEidList2			    m_EnrolledApeEidList2;

    CNetAddrListContainer               *m_pNetworkAddressList;
	CUserDataListContainer		        *m_pUserDataList;

	CConnHandleList     			    m_ConnHandleList;
	CConnHdlTagNumberList2				m_ConnHdlTagNumberList2;

    CJoinRespNamePresentConnHdlList2	m_JoinRespNamePresentConnHdlList2;
	CInviteRequestList				    m_InviteRequestList;
	CEjectedNodeConfirmList			    m_EjectedNodeConfirmList;
	CConductorTestList   	            m_ConductorTestList;
	CNetAddrTagNumberList2				m_AddRequestList;
	CTagNumberTagNumberList2			m_AddResponseList;
	CNodeVersionList2					m_NodeVersionList2;
	
	PMCSUser						m_pMcsUserObject;

	LPSTR							m_pszConfNumericName;
	LPWSTR							m_pwszConfTextName;
	LPWSTR							m_pwszConfDescription;
	LPSTR							m_pszConfModifier;
	LPSTR							m_pszRemoteModifier;

	GCCConfID   					m_nConfID;
	UserID							m_nConvenerNodeID;

	BOOL							m_fConfLocked;
	BOOL							m_fConfListed;
	BOOL							m_fConfConductible;
	BOOL							m_fClearPassword;
	BOOL							m_fConfIsEstablished;
	BOOL							m_fConfDisconnectPending;
	BOOL							m_fConfTerminatePending;
    BOOL                            m_fTerminationInitiated;
	BOOL							m_fSecure;

	BOOL							m_fWBEnrolled;
	BOOL							m_fFTEnrolled;
	BOOL							m_fChatEnrolled;

	GCCTerminationMethod			m_eTerminationMethod;
	GCCReason						m_eConfTerminateReason;

	PDomainParameters 				m_pDomainParameters;

	ConferenceNodeType				m_eNodeType;

	UserIDTagNumber					m_nUserIDTagNumber;
	UserIDTagNumber					m_nConvenerUserIDTagNumber;
	TagNumber						m_nParentIDTagNumber;
	TagNumber						m_nConfAddRequestTagNumber;

    ConnectionHandle				m_hParentConnection;
	ConnectionHandle				m_hConvenerConnection;

	PAlarm							m_pConfTerminateAlarm;
	PAlarm							m_pConfStartupAlarm;

	PPrivilegeListData				    m_pConductorPrivilegeList;
	PPrivilegeListData				    m_pConductModePrivilegeList;
	PPrivilegeListData				    m_pNonConductModePrivilegeList;

    GCCResponseTag					m_nConfAddResponseTag;
	CConfRosterMgr					*m_pConfRosterMgr;
	CRegistry                       *m_pAppRegistry;
	UserID							m_nConductorNodeID;
	UserID							m_nPendingConductorNodeID;
	BOOL							m_fConductorGrantedPermission;
	BOOL							m_fConductorGiveResponsePending;
	BOOL							m_fConductorAssignRequestPending;
	EntityID						m_nAPEEntityID;
    //
    // LONCHANC; m_cPermittedEnrollment is the number of
	// GCC-Application-Permit-to-Enroll. we need to wait for all
	// the corresponding GCC-Application-Enroll-Request come in.
	// then, we will send out a single
	// GCC-Application-Roster-Update-Indication to the wire.
    //
    int								m_cEnrollRequests; // LONCHANC: must be signed
	BOOL							m_fFirstAppRosterSent;
};
typedef	CConf 		*			PConference;

#endif

/*
 *	CConf(		PGCCConferenceName			conference_name,
 *					GCCNumericString			conference_modifier,
 *					GCCConfID   				conference_id,
 *					BOOL						use_password_in_the_clear,
 *					BOOL						conference_locked,
 *					BOOL						conference_listed,
 *					BOOL						conference_conductable,
 *					GCCTerminationMethod		termination_method,
 *					PGCCConferencePrivileges	conduct_privilege_list,
 *					PGCCConferencePrivileges	conduct_mode_privilege_list,
 *					PGCCConferencePrivileges	non_conduct_privilege_list,
 *					LPWSTR						pwszConfDescriptor,
 *					UINT						number_of_network_addresses,
 *					PGCCNetworkAddress 		*	local_network_address_list,
 *					CControlSAP					*control_sap,
 *					UINT						owner_message_base,
 *					PGCCError					return_value);
 *
 *	Public member function of CConf
 *
 *	Function Description
 *		This is the conference constructor. It is responsible for
 *		initializing all the instance variables used by this class.
 *		It also creates the MCS domain based on the conference id.
 *		Fatal errors are returned from this constructor in the
 *		return value. Note that this constructor is used when the
 *		CConf specification parameters such as termination	
 *		method or known in advance of conference creation.  This is
 *		the case for a convenor node and a top provider.  It is not
 *		used for joining nodes.
 *
 *	Formal Parameters:
 *		conference_name		(i)	Structure pointer that holds the confernce name.
 *		conference_modifier	(i)	Pointer to the conference modifier.
 *		conference_id		(i)	The assigned conference ID.
 *		use_password_in_the_clear	
 *							(i)	Flag specifying if the password is in the clear.
 *		conference_locked	(i)	Flag specifying if the conference is locked.
 *		conference_listed	(i)	Flag specifying if the conference is listed.
 *		conference_conductable
 *							(i)	Flag specifying if conference is conductable.
 *		termination_method	(i)	Flag specifying the termination method.
 *		conduct_privilege_list
 *							(i)	Privilege list used by the conductor.
 *		conduct_mode_privilege_list
 *							(i)	Privilege list used in conducted mode.
 *		non_conduct_privilege_list
 *							(i) Privilege list used when not in conducted mode.
 *		conference_descriptor
 *							(i)	Pointer to the conference descriptor.
 *		number_of_network_addresses
 *							(i)	Number of network addresses in list.
 *		local_network_address_list
 *							(i) List of local network addresses.
 *		mcs_interface		(i)	Pointer to the MCS interface object.
 *		control_sap			(i) Pointer to the Node Controller SAP.
 *		owner_object		(i)	Pointer to the object that created this object.
 *		owner_message_base	(i) The number added to all owner callback messages.
 *		packet_coder		(i)	Pointer to the Packet Coder object used for PDUs
 *		return_value		(o)	Errors that occur are returned here.
 *		
 *
 *	Return Value
 *		GCC_NO_ERROR					-	No error occured.
 *		GCC_ALLOCATION_FAILURE			-	Resource error occured.
 *		GCC_INVALID_CONFERENCE_NAME		-	Invalid conference name passed in.
 *		GCC_FAILURE_CREATING_DOMAIN		-	Failure creating domain.
 *		GCC_BAD_NETWORK_ADDRESS			-	Bad network address passed in.
 *		GCC_BAD_NETWORK_ADDRESS_TYPE	-	Bad network address type passed in.
 *
 *  Side Effects
 *		None.
 *
 *	Caveats
 *		None.
 */

/*
 *	CConf(		PGCCConferenceName	  		conference_name,
 *					GCCNumericString			conference_modifier,
 *					GCCConfID   				conference_id,
 *					UINT						number_of_network_addresses,
 *					PGCCNetworkAddress 	*		local_network_address_list,
 *					CControlSAP					*control_sap,
 *					UINT								owner_message_base,
 *					PGCCError					return_value);
 *
 *	Public member function of CConf
 *
 *	Function Description
 *		This is the conference constructor. It is responsible for
 *		initializing all the instance variables used by this class.
 *		It also creates the MCS domain based on the conference id.
 *		Fatal errors are returned from this constructor in the
 *		return value. Note that this constructor is used by nodes that
 *		do not know the CConf specification parameters such as
 *		termination	method in advance of conference creation.  This is
 *		the case for joining nodes.
 *
 *	Formal Parameters:
 *		conference_name		(i)	Structure pointer that holds the confernce name.
 *		conference_modifier	(i)	Pointer to the conference modifier.
 *		conference_id		(i)	The assigned conference ID.
 *		number_of_network_addresses
 *							(i)	Number of local network addresses in list.
 *		local_network_address_list
 *							(i) List of local network addresses.
 *		control_sap			(i) Pointer to the Node Controller SAP.
 *		packet_coder		(i)	Pointer to the Packet Coder object used for PDUs
 *		return_value		(o)	Errors that occur are returned here.
 *		
 *
 *	Return Value
 *		GCC_NO_ERROR					-	No error occured.
 *		GCC_ALLOCATION_FAILURE			-	Resource error occured.
 *		GCC_FAILURE_CREATING_DOMAIN		-	Failure creating domain.
 *		GCC_BAD_NETWORK_ADDRESS			-	Bad network address passed in.
 *		GCC_BAD_NETWORK_ADDRESS_TYPE	-	Bad network address type passed in.
 *
 *  Side Effects
 *		None.
 *
 *	Caveats
 *		None.
 */

/*
 *	GCCError	ConfCreateRequest(
 *							TransportAddress		calling_address,
 *							TransportAddress		called_addrescs,
 *							CPassword               *convener_password,
 *							CPassword               *password,
 *							LPWSTR					pwszCallerID,
 *							PDomainParameters		domain_parameters,
 *							CUserDataListContainer  *user_data_list,
 *							PConnectionHandle		connection_handle)
 *
 *	Public member function of CConf
 *
 *	Function Description
 *		This function is called when a Conference Create Request PDU is to be
 *		issued.  Note that a local conference can be created by setting the
 *		called address to NULL.
 *
 *	Formal Parameters:
 *		calling_address		(i)	Address of the calling node.
 *		called_address		(i)	Address of the called node. Null for local conf.
 *		convener_password	(i)	Password used by convener to get back priviliges
 *		password			(i)	Password needed to join the conference.
 *		caller_identifier	(i) Unicode string specifying the caller ID.
 *		domain_parameters	(i)	The MCS domain parameters.
 *		user_data_list		(i) Pointer to a User data list object.
 *		connection_handle	(o)	The logical connection handle is returned here.
 *
 *	Return Value
 *		GCC_NO_ERROR:					- No error
 *		GCC_ALLOCATION_FAILURE			- Resource error occured
 *		GCC_INVALID_TRANSPORT_ADDRESS	- Something wrong with transport address
 *		GCC_FAILURE_ATTACHING_TO_MCS	- Failure creating MCS user attachment
 *		GCC_INVALID_ADDRESS_PREFIX		- Invalid transport address prefix
 *
 *  Side Effects
 *		None.
 *
 *	Caveats
 *		Passing in NULL for the called address will create a local conference.
 */

/*
 *	GCCError	ConfCreateResponse(
 *							ConnectionHandle		connection_handle,
 *							PDomainParameters		domain_parameters,
 *							CUserDataListContainer  *user_data_list)
 *
 *	Public member function of CConf
 *
 *	Function Description
 *		This function is called when a Conference Create Response PDU is to be
 *		issued.  It should only be issued in response to a
 *		ConferenceCreateRequest. The connection handle is used to match the
 *		request with the response.
 *
 *	Formal Parameters:
 *		connection_handle	(i)	Connection handled specified in the request.
 *		domain_parameters	(i)	The MCS domain parameters.
 *		user_data_list		(i) Pointer to a User data list object.
 *
 *	Return Value
 *		GCC_NO_ERROR:					- No error
 *		GCC_ALLOCATION_FAILURE			- Resource error occured
 *		GCC_FAILURE_ATTACHING_TO_MCS	- Failure creating MCS user attachment
 *
 *  Side Effects
 *		None.
 *
 *	Caveats
 *		None.
 */

/*
 * 	GCCError	ConfJoinRequest(
 *							GCCNumericString		called_node_modifier,
 *							CPassword               *convener_password,
 *							CPassword               *password_challenge,
 *							LPWSTR					pwszCallerID,
 *							TransportAddress		calling_address,
 *							TransportAddress		called_address,
 *							PDomainParameters 		domain_parameters,
 *							CUserDataListContainer  *user_data_list,
 *							PConnectionHandle		connection_handle)
 *
 *	Public member function of CConf
 *
 *	Function Description
 *		This function is called when a Conference Join Request PDU is to be
 *		issued.  The second constructor defined above should have been
 *		used to create the conference object before the routine is called.
 *
 *	Formal Parameters:
 *		called_node_modifier(i)	The conference modifier at the node being joined
 *		convener_password	(i)	Password used by convener to get back priviliges
 *		password_challenge	(i) Password used to join a conference.
 *		caller_identifier	(i) Unicode string specifying the caller ID.
 *		calling_address		(i)	Address of the calling node.
 *		called_address		(i)	Address of the called node.
 *		domain_parameters	(i)	The MCS domain parameters.
 *		user_data_list		(i) Pointer to a User data list object.
 *		connection_handle	(o)	The logical connection handle is returned here.
 *
 *	Return Value
 *		GCC_NO_ERROR:					- No error
 *		GCC_ALLOCATION_FAILURE			- Resource error occured
 *		GCC_INVALID_TRANSPORT_ADDRESS	- Something wrong with transport address
 *		GCC_FAILURE_ATTACHING_TO_MCS	- Failure creating MCS user attachment
 *		GCC_INVALID_ADDRESS_PREFIX		- Invalid transport address prefix
 *
 *  Side Effects
 *		None.
 *
 *	Caveats
 *		None.
 */

/*
 *	GCCError	ForwardConfJoinRequest (
 *							CPassword               *convener_password,
 *							CPassword               *password_challange,
 *							LPWSTR					pwszCallerID,
 *							CUserDataListContainer  *user_data_list,
 *							BOOL					numeric_name_present,
 *							ConnectionHandle		connection_handle)
 *
 *	Public member function of CConf
 *
 *	Function Description
 *		This function is called when a Conference Join Request is to be
 *		forwarded to the Top Provider.  This call will be made after an
 *		intermediate node calls Join Response with a successful result
 *		value.
 *
 *	Formal Parameters:
 *		convener_password	(i)	Password used by convener to get back priviliges
 *		password_challenge	(i) Password used to join a conference.
 *		caller_identifier	(i) Unicode string specifying the caller ID.
 *		user_data_list		(i) Pointer to a User data list object.
 *		numeric_name_present(i) This flag states that the numeric portion of
 *								the conference name was specified in the
 *								request.  Therefore, the text name is returned
 *								in the response.
 *		connection_handle	(i)	The logical connection handle defined by the
 *								request.
 *
 *	Return Value
 *		GCC_NO_ERROR:					- No error
 *		GCC_ALLOCATION_FAILURE			- Resource error occured
 *		GCC_INVALID_CONFERENCE			- Returned if this node is the Top
 *										  Provider
 *
 *  Side Effects
 *		None.
 *
 *	Caveats
 *		None.
 */

/*
 *	GCCError	ConfJoinIndResponse(
 *							ConnectionHandle		connection_handle,
 *							CPassword               *password_challenge,
 *							CUserDataListContainer  *user_data_list,
 *							BOOL					numeric_name_present,
 *							BOOL					convener_is_joining,
 *							GCCResult				result)
 *
 *	Public member function of CConf
 *
 *	Function Description
 *		This function is called when a Conference Join Response PDU is to be
 *		issued.  It is called in response to a ConferenceJoinRequest being
 *		received.
 *
 *	Formal Parameters:
 *		connection_handle	(i)	Connection handled specified in the request.
 *		password_challenge	(i) Password used when joining a conference.
 *		user_data_list		(i) Pointer to a User data list object.
 *		numeric_name_present(i) This flag states that the numeric portion of
 *								the conference name was specified in the
 *								request.  Therefore, the text name is returned
 *								in the response.
 *		convener_is_joining	(i)	Flag stating that the convener is rejoining
 *								the conference.
 *		result				(i)	Result code to be returned in the response.
 *
 *	Return Value
 *		GCC_NO_ERROR:						- No error
 *		GCC_ALLOCATION_FAILURE				- Resource error occured
 *		GCC_DOMAIN_PARAMETERS_UNACCEPTABLE	- Domain parameters were
 *											  unacceptable for this connection.
 *
 *  Side Effects
 *		None.
 *
 *	Caveats
 *		If the GCC_DOMAIN_PARAMETERS_UNACCEPTABLE error is returned from this
 *		routine, MCS will automatically reject the connection sending a
 *		result to the other side stating the the Domain Parameters were
 *		unacceptable.
 */

/*
 *	GCCError	ConfInviteResponse(
 *							UserID					parent_user_id,
 *							UserID					top_user_id,
 *							TagNumber				tag_number,
 *							ConnectionHandle		connection_handle,
 *							PDomainParameters		domain_parameters,
 *							CUserDataListContainer  *user_data_list)
 *
 *	Public member function of CConf
 *
 *	Function Description
 *		This function is called when a Conference Invite Response PDU is to be
 *		issued.  It is called in response to an Invite request.
 *
 *	Formal Parameters:
 *		parent_user_id		(i)	The MCS user ID of the parent node.
 *		top_user_id			(i) The MCS user ID of the Top Provider.
 *		tag_number			(i) Tag the matches the request with the response.
 *		connection_handle	(i)	Connection handled specified in the request.
 *		domain_parameters	(i)	The MCS domain parameters.
 *		user_data_list		(i) Pointer to a User data list object.
 *
 *	Return Value
 *		GCC_NO_ERROR:						- No error
 *		GCC_ALLOCATION_FAILURE				- Resource error occured
 *		GCC_FAILURE_ATTACHING_TO_MCS		- Failure creating MCS user
 *											  attachment
 *		GCC_DOMAIN_PARAMETERS_UNACCEPTABLE	- Domain parameters were
 *											  unacceptable for this connection.
 *
 *  Side Effects
 *		None.
 *
 *	Caveats
 *		None.
 */

/*
 *	CConf::RegisterAppSap(CAppSap *pAppSap)
 *
 *	Public Function Description
 *		This routine is called from the owner object whenever an application
 *		SAP becomes a candidate for Enrollment.  This will happen whenever
 *		Applications SAPs exists at the same time a conference becomes
 *		established.  It will also be called whenever a conference exists
 *		and a new application SAP is created.
 *
 *	Formal Parameters:
 *		pAppSap		(i)	Pointer to the application SAP object associated
 *								with the registering Application.
 *		hSap
 *							(i) SAP handle of the registering Application.
 *
 *	Return Value
 *		GCC_NO_ERROR:					- No error
 *		GCC_ALLOCATION_FAILURE			- Resource error occured
 *		GCC_CONFERENCE_NOT_ESTABLISHED	- CConf object has not completed
 *										  its establishment process.
 *
 *  Side Effects
 *		None.
 *
 *	Caveats
 *		None.
 */

/*
 *	CConf::UnRegisterAppSap(CAppSap *pAppSap)
 *
 *	Public Function Description
 *		This routine is called from the owner object whenever an application
 *		SAP becomes unavailable due to whatever reason.  This routine is
 *		responsible for unenrolling any APEs from any rosters that it might have
 *		used this SAP to enroll with.
 *
 *	Formal Parameters:
 *		application_sap_handle
 *							(i) SAP handle of the unregistering Application.
 *
 *	Return Value
 *		GCC_NO_ERROR:					- No error
 *		GCC_APPLICATION_NOT_REGISTERED	- The application was not registered.
 *
 *  Side Effects
 *		None.
 *
 *	Caveats
 *		None.
 */

/*
 *	GCCError	DisconnectProviderIndication(
 *							ConnectionHandle		connection_handle)
 *
 *	Public member function of CConf
 *
 *	Function Description
 *		This function is called whenever a disconnect indication is received
 *		by GCC.  It is used to inform the conference of any logical connections
 *		it that might have gone down.
 *
 *	Formal Parameters:
 *		connection_handle	(i)	Logical connection handle that was disconnected
 *
 *	Return Value
 *		GCC_NO_ERROR:					- No error
 *		GCC_ALLOCATION_FAILURE			- Resource error occured
 *		GCC_INVALID_PARAMETER			- This connection handle is not used
 *										  by this conference.
 *
 *  Side Effects
 *		None.
 *
 *	Caveats
 *		None.
 */

/*
 *	GCCError	DisconnectProviderIndication(
 *							ConnectionHandle		connection_handle)
 *
 *	Public member function of CConf
 *
 *	Function Description
 *		This function is called whenever a disconnect indication is received
 *		by GCC.  It is used to inform the conference of any logical connections
 *		it that might have gone down.
 *
 *	Formal Parameters:
 *		connection_handle	(i)	Logical connection handle that was disconnected
 *
 *	Return Value
 *		GCC_NO_ERROR:					- No error
 *		GCC_ALLOCATION_FAILURE			- Resource error occured
 *		GCC_INVALID_PARAMETER			- This connection handle is not used
 *										  by this conference.
 *
 *  Side Effects
 *		None.
 *
 *	Caveats
 *		None.
 */

/*
 *	GCCError	ConfRosterInquireRequest(CBaseSap *)
 *
 *	Public member function of CConf
 *
 *	Function Description
 *		This function is used to obtain a conference roster.  The conference
 *		roster is delivered to the requesting command target in a Conference
 *		Roster inquire confirm.
 *
 *	Formal Parameters:
 *		command_target	(i)	Pointer to object that made the request.
 *
 *	Return Value
 *		GCC_NO_ERROR:					- No error
 *		GCC_ALLOCATION_FAILURE			- Resource error occured
 *		GCC_CONFERENCE_NOT_ESTABLISHED	- CConf object has not completed
 *										  its establishment process.
 *
 *  Side Effects
 *		None.
 *
 *	Caveats
 *		None.
 */

/*
 *	GCCError	AppRosterInquireRequest(GCCSessionKey *, CAppRosterMsg **)
 *
 *	Public member function of CConf
 *
 *	Function Description
 *		This function is used to obtain a list of application rosters.  This
 *		list is delivered to the requesting SAP through an	Application Roster
 *		inquire confirm message.
 *
 *	Formal Parameters:
 *		session_key		(i)	Session Key of desired roster.  If NULL is
 *							specified then all the available application rosters
 *							are delivered in the confirm.
 *		command_target	(i)	Pointer to object that made the request.
 *
 *	Return Value
 *		GCC_NO_ERROR:					- No error
 *		GCC_ALLOCATION_FAILURE			- Resource error occured
 *
 *  Side Effects
 *		None.
 *
 *	Caveats
 *		None.
 */

/*
 *	BOOL		FlushOutgoingPDU ();
 *
 *	Public member function of CConf
 *
 *	Function Description
 *		This function is used by the owner object to flush any PDUs queued
 *		by the conference object.  This routine will all flush PDUs queued
 *		by the User Attachment object.
 *
 *	Formal Parameters:
 *		None.
 *
 *	Return value:
 *		TRUE, if there remain un-processed msgs in the conference message queue
 *		FALSE, if all the msgs in the conference msg queue were processed.
 *
 *  Side Effects
 *		None.
 *
 *	Caveats
 *		None.
 */

/*
 *	BOOL			IsConfEstablished();
 *
 *	Public member function of CConf
 *
 *	Function Description
 *		Function informs whether the conference has completed its
 *		establishment process.
 *
 *	Formal Parameters:
 *		None.
 *
 *	Return Value
 *		TRUE	-	Establishment is complete.
 *		FALSE	-	Establishment is still in process.
 *
 *  Side Effects
 *		None.
 *
 *	Caveats
 *		None.
 */

/*
 *	BOOL		IsConfTopProvider();
 *
 *	Public member function of CConf
 *
 *	Function Description
 *		Function informs whether this node is the Top Provider of the
 *		conference.
 *
 *	Formal Parameters:
 *		None.
 *
 *	Return Value
 *		TRUE	-	This node is the Top Provider.
 *		FALSE	-	This node is NOT the Top Provider.
 *
 *  Side Effects
 *		None.
 *
 *	Caveats
 *		None.
 */

/*
 *	BOOL		DoesConvenerExists();
 *
 *	Public member function of CConf
 *
 *	Function Description
 *		This function informs whether or not the convener is still joined to
 *		this conference.
 *
 *	Formal Parameters:
 *		None.
 *
 *	Return Value
 *		TRUE	-	There is a convener node joined to the conference.
 *		FALSE	-	There is NOT a convener node joined to the conference.
 *
 *  Side Effects
 *		None.
 *
 *	Caveats
 *		None.
 */

/*
 *	LPSTR	GetNumericConfName();
 *
 *	Public member function of CConf
 *
 *	Function Description
 *		This function returns an internal pointer to a LPSTR string
 *		that holds the numeric conference name.  This string should not be
 *		altered by the requesting module.  It should also not be used after
 *		the conference is deleted.
 *
 *	Formal Parameters:
 *		None.
 *
 *	Return Value
 *		Pointer to the numeric string portion of the Conference Name.
 *
 *  Side Effects
 *		None.
 *
 *	Caveats
 *		None.
 */

/*
 *	LPWSTR	GetTextConfName();
 *
 *	Public member function of CConf
 *
 *	Function Description
 *		This function returns an internal pointer to the unicode string
 *		that holds the text portion of the conference name.  This string should
 *		not be altered by the requesting module.  It should also not be used
 *		after the conference is deleted.
 *
 *	Formal Parameters:
 *		None.
 *
 *	Return Value
 *		Pointer to the text string portion of the Conference Name.
 *		NULL if no text conference name exists.
 *
 *  Side Effects
 *		None.
 *
 *	Caveats
 *		None.
 */

/*
 *	LPSTR	GetConfModifier();
 *
 *	Public member function of CConf
 *
 *	Function Description
 *		This function returns an internal pointer to the LPSTR string
 *		that holds the conference name modifier.  This string should
 *		not be altered by the requesting module.  It should also not be used
 *		after the conference is deleted.
 *
 *	Formal Parameters:
 *		None.
 *
 *	Return Value
 *		Pointer to the Conference Name modifier.
 *		NULL if no modifier exists.
 *
 *  Side Effects
 *		None.
 *
 *	Caveats
 *		None.
 */

/*
 *	LPWSTR	GetConfDescription()
 *
 *	Public member function of CConf
 *
 *	Function Description
 *		This function returns an internal pointer to the unicode string
 *		that holds the conference descriptor.  This string should
 *		not be altered by the requesting module.  It should also not be used
 *		after the conference is deleted.
 *
 *	Formal Parameters:
 *		None.
 *
 *	Return Value
 *		Pointer to the Conference Descriptor.
 *		NULL if no descriptor exists.
 *
 *  Side Effects
 *		None.
 *
 *	Caveats
 *		None.
 */

/*
 *	CNetAddrListContainer *GetNetworkAddressList()
 *
 *	Public member function of CConf
 *
 *	Function Description
 *		This function returns an internal pointer to the object that holds the
 *		list of local network addresses.  This object should
 *		not be altered by the requesting module.  It should also not be used
 *		after the conference is deleted.
 *
 *	Formal Parameters:
 *		None.
 *
 *	Return Value
 *		Pointer to the Local network address list.
 *		NULL if no descriptor exists.
 *
 *  Side Effects
 *		None.
 *
 *	Caveats
 *		None.
 */

/*
 *	GCCConfID		GetConfID()
 *
 *	Public member function of CConf
 *
 *	Function Description
 *		This function returns the conference ID for this conference object.
 *
 *	Formal Parameters:
 *		None.
 *
 *	Return Value
 *		The conference ID
 *
 *  Side Effects
 *		None.
 *
 *	Caveats
 *		None.
 */

/*
 *	BOOL			IsConfListed();
 *
 *	Public member function of CConf
 *
 *	Function Description
 *		This function informs whether or NOT the conference is listed.
 *
 *	Formal Parameters:
 *		None.
 *
 *	Return Value
 *		TRUE	-	The conference is listed
 *		FALSE	-	This conference is NOT listed
 *
 *  Side Effects
 *		None.
 *
 *	Caveats
 *		None.
 */

/*
 *	BOOL			IsConfPasswordInTheClear();
 *
 *	Public member function of CConf
 *
 *	Function Description
 *		This function informs whether or NOT the conference is using an
 *		in the clear password.
 *
 *	Formal Parameters:
 *		None.
 *
 *	Return Value
 *		TRUE	-	The conference is using a Password in the clear
 *		FALSE	-	The conference is NOT using a Password in the clear
 *
 *  Side Effects
 *		None.
 *
 *	Caveats
 *		None.
 */

/*
 *	BOOL			IsConfLocked();
 *
 *	Public member function of CConf
 *
 *	Function Description
 *		This function informs whether or NOT the conference is locked.
 *
 *	Formal Parameters:
 *		None.
 *
 *	Return Value
 *		TRUE	-	The conference is locked.
 *		FALSE	-	The conference is NOT locked.
 *
 *  Side Effects
 *		None.
 *
 *	Caveats
 *		None.
 */


/*
 *	These routines live in conf2.cpp
 */

/*
 *		GCCError		ConfJoinReqResponse(
 *									UserID				receiver_id,
 *									CPassword           *password_challenge,
 *									CUserDataListContainer *user_data_list,
 *									GCCResult			result)
 *
 *	Public member function of CConf
 *
 *	Function Description
 *		This Command Target function is used when the join request was delivered
 *		through an intermediate node.  In this case, the join response is sent
 *		back through the intermediate node.
 *
 *	Formal Parameters:
 *		receiver_id		- (i)	The user ID of the intermediate node that
 *								forwarded the join request.  This user ID is
 *								used to match the join request with the join
 *								response.
 *		password_challenge
 *						- (i)	The password challenge to be delivered to the
 *								joining node.  NULL if none should be delivered.
 *		user_data_list	- (i)	Pointer to a user data object to be delivered
 *								to joiner.  NULL if none should be delivered.
 *		result			- (i)	Result of the join request.
 *
 *	Return Value
 *		GCC_NO_ERROR		-	No error.
 *
 *  Side Effects
 *		None.
 *
 *	Caveats
 *		None.
 */

/*
 *	GCCError		ConfInviteRequest(
 *								LPWSTR					pwszCallerID,
 *								TransportAddress		calling_address,
 *								TransportAddress		called_address,
 *								CUserDataListContainer  *user_data_list,
 *								PConnectionHandle		connection_handle)
 *
 *	Public member function of CConf
 *
 *	Function Description
 *		This Command Target function is used to issue an invite request.  This
 *		can be a command target because the conference at the requesting node
 *		should already be established before the request comes in.
 *
 *	Formal Parameters:
 *		caller_identifier	(i) Unicode string specifying the caller ID.
 *		calling_address		(i)	Address of the calling node.
 *		called_address		(i)	Address of the called node.
 *		user_data_list		(i) Pointer to a User data list object.
 *		connection_handle	(o)	The logical connection handle is returned here.
 *
 *	Return Value
 *		GCC_NO_ERROR					- No error.
 *		GCC_ALLOCATION_FAILURE			- A resource error occured.	
 *		GCC_INVALID_TRANSPORT_ADDRESS	- Something wrong with transport address
 *		GCC_INVALID_ADDRESS_PREFIX		- Invalid transport address prefix
 *		GCC_CONFERENCE_NOT_ESTABLISHED	- CConf object has not completed
 *										  its establishment process.
 *
 *  Side Effects
 *		None.
 *
 *	Caveats
 *		None.
 */

/*
 *	GCCError		ConfLockRequest ()
 *
 *	Public member function of CConf
 *
 *	Function Description
 *		This Command Target function is used to issue a lock request to
 *		the conference.
 *
 *	Formal Parameters:
 *		None.
 *
 *	Return Value
 *		GCC_NO_ERROR					- No error.
 *		GCC_ALLOCATION_FAILURE			- A resource error occured.	
 *		GCC_CONFERENCE_NOT_ESTABLISHED	- CConf object has not completed
 *										  its establishment process.
 *
 *  Side Effects
 *		None.
 *
 *	Caveats
 *		None.
 */

/*
 *	GCCError	ConfLockResponse (
 *								UserID					requesting_node,
 *								GCCResult				result)
 *
 *	Public member function of CConf
 *
 *	Function Description
 *		This Command Target function is used to issue a lock response.  It
 *		is called in response to a lock request.
 *
 *	Formal Parameters:
 *		requesting_node		-	(i)	Node ID of node the issued the lock request.
 *		result				-	(i)	Result of lock request.
 *
 *	Return Value
 *		GCC_NO_ERROR					- No error.
 *		GCC_ALLOCATION_FAILURE			- A resource error occured.	
 *		GCC_CONFERENCE_NOT_ESTABLISHED	- CConf object has not completed
 *										  its establishment process.
 *
 *  Side Effects
 *		None.
 *
 *	Caveats
 *		None.
 */

/*
 *	GCCError		ConfUnlockRequest ()
 *
 *	Public member function of CConf
 *
 *	Function Description
 *		This Command Target function is used to issue an unlock request to
 *		the conference.
 *
 *	Formal Parameters:
 *		None.
 *
 *	Return Value
 *		GCC_NO_ERROR					- No error.
 *		GCC_ALLOCATION_FAILURE			- A resource error occured.	
 *		GCC_CONFERENCE_NOT_ESTABLISHED	- CConf object has not completed
 *										  its establishment process.
 *
 *  Side Effects
 *		None.
 *
 *	Caveats
 *		None.
 */

/*
 *	GCCError	ConfUnlockResponse (
 *								UserID					requesting_node,
 *								GCCResult				result)
 *
 *	Public member function of CConf
 *
 *	Function Description
 *		This Command Target function is used to issue an unlock response.  It
 *		is called in response to an unlock request.
 *
 *	Formal Parameters:
 *		requesting_node		-	(i)	ID of node the issued the unlock request.
 *		result				-	(i)	Result of unlock request.
 *
 *	Return Value
 *		GCC_NO_ERROR					- No error.
 *		GCC_ALLOCATION_FAILURE			- A resource error occured.	
 *		GCC_CONFERENCE_NOT_ESTABLISHED	- CConf object has not completed
 *										  its establishment process.
 *
 *  Side Effects
 *		None.
 *
 *	Caveats
 *		None.
 */

/*
 *	GCCError 	ConfEjectUserRequest (
 *									UserID					ejected_node_id,
 *									GCCReason				reason)
 *
 *	Public member function of CConf
 *
 *	Function Description
 *		This Command Target function is used to eject a user from the
 *		conference.  Note that the user must have the appropriate priviliges
 *		to perform the eject.
 *
 *	Formal Parameters:
 *		ejected_node_id		-	(i)	ID of node to be ejected.
 *		reason				-	(i)	Reason for ejection
 *
 *	Return Value
 *		GCC_NO_ERROR					- No error.
 *		GCC_ALLOCATION_FAILURE			- A resource error occured.	
 *		GCC_CONFERENCE_NOT_ESTABLISHED	- CConf object has not completed
 *										  its establishment process.
 *
 *  Side Effects
 *		None.
 *
 *	Caveats
 *		None.
 */

/*
 *	GCCError		ConfAnnouncePresenceRequest(
 *									PGCCNodeRecord		node_record)
 *
 *	Public member function of CConf
 *
 *	Function Description
 *		This Command Target function is called when the Node Controller
 *		announces its presence with the conference.  This request will
 *		generate a roster report PDU and indication.
 *
 *	Formal Parameters:
 *		node_record		-	(i)	Structure containing the complete node
 *								record for the requesting node controller.
 *
 *	Return Value
 *		GCC_NO_ERROR					- No error.
 *		GCC_ALLOCATION_FAILURE			- A resource error occured.
 *		GCC_BAD_NETWORK_ADDRESS			- If an invalid network address is
 *										  passed in as part of the record.	
 *		GCC_BAD_USER_DATA				- If an invalid user data list is
 *										  passed in as part of the record.	
 *		GCC_CONFERENCE_NOT_ESTABLISHED	- CConf object has not completed
 *										  its establishment process.
 *
 *  Side Effects
 *		None.
 *
 *	Caveats
 *		None.
 */

/*
 *	GCCError	ConfDisconnectRequest(void)
 *
 *	Public member function of CConf
 *
 *	Function Description
 *		This Command Target function is called when the Node Controller
 *		wishes to disconnect the node from the conference.
 *
 *	Formal Parameters:
 *		None.
 *
 *	Return Value
 *		GCC_NO_ERROR					- No error.
 *		GCC_ALLOCATION_FAILURE			- A resource error occured.
 *
 *  Side Effects
 *		None.
 *
 *	Caveats
 *		If this node is the Top Provider the conference will be terminated
 *		on all nodes.
 */

/*
 *	GCCError		ConfTerminateRequest(
 *									GCCReason			reason)
 *
 *	Public member function of CConf
 *
 *	Function Description
 *		This Command Target function is called when the Node Controller
 *		wishes to terminate the conference.  This will eventually cause
 *		the object to be deleted if successful.
 *
 *	Formal Parameters:
 *		None.
 *
 *	Return Value
 *		GCC_NO_ERROR					- No error.
 *		GCC_ALLOCATION_FAILURE			- A resource error occured.
 *		GCC_CONFERENCE_NOT_ESTABLISHED	- CConf object has not completed
 *										  its establishment process.
 *
 *  Side Effects
 *		None.
 *
 *	Caveats
 *		None.
 */

/*
 *	GCCError	AppEnrollRequest(
 *							CAppSap     *			pAppSap,
 *							PGCCSessionKey			session_key,
 *							PGCCApplicationRecord	application_record,
 *							BOOL					application_enrolled,
 *							UINT					number_of_capabilities,
 *							PGCCApplicationCapability	FAR *
 *													capabilities_list)
 *
 *	Public Function Description
 *		This function is called when a User Application wishes to enroll with
 *		the conference (or wishes to UnEnroll with it).  This call will
 *		initiate a roster update if the conference is established.
 *
 *	Formal Parameters:
 *		application_sap_handle
 *							(i) SAP handle of the enrolling Application.  Used
 *								for the entity ID.
 *		session_key			(i) Session key of the enrolling application
 *		application_record	(i)	Structure that defines the Application
 *								attributes.
 *		application_enrolled
 *							(i)	Is the application enrolling or unenrolling?
 *		number_of_capabilities
 *							(i) Number of Application capabilities in list.
 *		capabilities_list	(i)	Actual list of capabilities.
 *
 *	Return Value
 *		GCC_NO_ERROR:					- No error
 *		GCC_ALLOCATION_FAILURE			- Resource error occured
 *		GCC_CONFERENCE_NOT_ESTABLISHED	- CConf object has not completed
 *										  its establishment process.
 *
 *  Side Effects
 *		None.
 *
 *	Caveats
 *		None.
 */

/*
 *	GCCError	RegistryRegisterChannelRequest(
 *									PGCCRegistryKey			registry_key,
 *									ChannelID				channel_id,
 *									CAppSap                  *app_sap)
 *
 *	Public member function of CConf
 *
 *	Function Description
 *		This Command Target function is called by an application wishing to
 *		register a channel with the conference.	Here the application must
 *		supply the channel.
 *
 *	Formal Parameters:
 *		registry_key	-	(i)	Pointer to structure that holds registry key.
 *		channel_id		-	(i)	Channel ID to be registered.
 *		app_sap			-	(i)	The Command Target that is making the request.
 *
 *	Return Value
 *		GCC_NO_ERROR					- No error.
 *		GCC_ALLOCATION_FAILURE			- A resource error occured.
 *		GCC_BAD_REGISTRY_KEY			- The registry key is invalid.
 *		GCC_APP_NOT_ENROLLED			- Requesting application is not
 *										  enrolled with the conference.
 *
 *  Side Effects
 *		None.
 *
 *	Caveats
 *		None.
 */

/*
 *	GCCError	RegistryAssignTokenRequest(
 *									PGCCRegistryKey			registry_key,
 *									CAppSap		            *app_sap);
 *
 *	Public member function of CConf
 *
 *	Function Description
 *		This Command Target function is called by an application wishing to
 *		register a token with the conference.  Here the token is supplied by
 *		the conference.
 *
 *	Formal Parameters:
 *		registry_key	-	(i)	Pointer to structure that holds registry key.
 *		app_sap			-	(i)	The Command Target that is making the request.
 *
 *	Return Value
 *		GCC_NO_ERROR					- No error.
 *		GCC_ALLOCATION_FAILURE			- A resource error occured.
 *		GCC_BAD_REGISTRY_KEY			- The registry key is invalid.
 *		GCC_APP_NOT_ENROLLED			- Requesting application is not
 *										  enrolled with the conference.
 *
 *  Side Effects
 *		None.
 *
 *	Caveats
 *		None.
 */

/*
 *	GCCError		RegistrySetParameterRequest (
 *								PGCCRegistryKey			registry_key,
 *								LPOSTR                  parameter_value,
 *								GCCModificationRights	modification_rights,
 *								CAppSap		            *app_sap);
 *
 *	Public member function of CConf
 *
 *	Function Description
 *		This Command Target function is called by an application wishing to
 *		register a parameter with the conference.  Here the token is supplied by
 *		the conference.
 *
 *	Formal Parameters:
 *		registry_key	-	(i)	Pointer to structure that holds registry key.
 *		parameter_value	-	(i)	Parameter to be registered
 *		modification_rights-(i)	Modification rights on the parameter.
 *		app_sap			-	(i)	The Command Target that is making the request.
 *
 *	Return Value
 *		GCC_NO_ERROR					- No error.
 *		GCC_ALLOCATION_FAILURE			- A resource error occured.
 *		GCC_BAD_REGISTRY_KEY			- The registry key is invalid.
 *		GCC_APP_NOT_ENROLLED			- Requesting application is not
 *										  enrolled with the conference.
 *
 *  Side Effects
 *		None.
 *
 *	Caveats
 *		None.
 */

/*
 *	GCCError	RegistryRetrieveEntryRequest(
 *									PGCCRegistryKey			registry_key,
 *									CAppSap		            *app_sap)
 *
 *	Public member function of CConf
 *
 *	Function Description
 *		This Command Target function is called by an application wishing to
 *		retrieve a registry entry.
 *
 *	Formal Parameters:
 *		registry_key	-	(i)	Pointer to structure that holds registry key.
 *		app_sap			-	(i)	The Command Target that is making the request.
 *
 *	Return Value
 *		GCC_NO_ERROR					- No error.
 *		GCC_ALLOCATION_FAILURE			- A resource error occured.
 *		GCC_BAD_REGISTRY_KEY			- The registry key is invalid.
 *		GCC_APP_NOT_ENROLLED			- Requesting application is not
 *										  enrolled with the conference.
 *
 *  Side Effects
 *		None.
 *
 *	Caveats
 *		None.
 */

/*
 *	GCCError	RegistryDeleteEntryRequest(
 *									PGCCRegistryKey			registry_key,
 *									CAppSap		            *app_sap);
 *
 *	Public member function of CConf
 *
 *	Function Description
 *		This Command Target function is called by an application wishing to
 *		delete a registry entry.
 *
 *	Formal Parameters:
 *		registry_key	-	(i)	Pointer to structure that holds registry key.
 *		app_sap			-	(i)	The Command Target that is making the request.
 *
 *	Return Value
 *		GCC_NO_ERROR					- No error.
 *		GCC_ALLOCATION_FAILURE			- A resource error occured.
 *		GCC_BAD_REGISTRY_KEY			- The registry key is invalid.
 *		GCC_APP_NOT_ENROLLED			- Requesting application is not
 *										  enrolled with the conference.
 *
 *  Side Effects
 *		None.
 *
 *	Caveats
 *		None.
 */

/*
 *	GCCError	RegistryMonitorRequest(
 *									BOOL					enable_delivery,
 *									PGCCRegistryKey			registry_key,
 *									CAppSap		            *app_sap)
 *
 *	Public member function of CConf
 *
 *	Function Description
 *		This Command Target function is called by an application wishing to
 *		delete a registry entry.
 *
 *	Formal Parameters:
 *		enable_delivery -	(i)	Toggle used to turn on and off monitoring of
 *								an entry.
 *		registry_key	-	(i)	Pointer to structure that holds registry key.
 *		app_sap			-	(i)	The Command Target that is making the request.
 *
 *	Return Value
 *		GCC_NO_ERROR					- No error.
 *		GCC_ALLOCATION_FAILURE			- A resource error occured.
 *		GCC_BAD_REGISTRY_KEY			- The registry key is invalid.
 *		GCC_APP_NOT_ENROLLED			- Requesting application is not
 *										  enrolled with the conference.
 *
 *  Side Effects
 *		None.
 *
 *	Caveats
 *		None.
 */

/*
 *	GCCError	RegistryAllocateHandleRequest(
 *									UINT					number_of_handles,
 *									CAppSap		            *app_sap)
 *
 *	Public member function of CConf
 *
 *	Function Description
 *		This Command Target function is called by an application that needs
 *		to allocate a certain number of parameters.
 *
 *	Formal Parameters:
 *		number_of_handles -	(i) Number of handles to allocate.
 *		app_sap			-	(i)	The Command Target that is making the request.
 *
 *	Return Value
 *		GCC_NO_ERROR					- No error.
 *		GCC_ALLOCATION_FAILURE			- A resource error occured.
 *		GCC_BAD_REGISTRY_KEY			- The registry key is invalid.
 *		GCC_APP_NOT_ENROLLED			- Requesting application is not
 *										  enrolled with the conference.
 *
 *  Side Effects
 *		None.
 *
 *	Caveats
 *		None.
 */

/*
 *	GCCError 			ConductorAssignRequest();
 *
 *	Public member function of CConf
 *
 *	Function Description
 *		This Command Target function is called when a node wants to become
 *		the conductor.
 *
 *	Formal Parameters:
 *		None.
 *
 *	Return Value
 *		GCC_NO_ERROR					- No error.
 *		GCC_ALLOCATION_FAILURE			- A resource error occured.
 *		GCC_CONFERENCE_NOT_ESTABLISHED	- CConf object has not completed
 *										  its establishment process.
 *
 *  Side Effects
 *		None.
 *
 *	Caveats
 *		None.
 */

/*
 *	GCCError 	ConductorReleaseRequest()
 *
 *	Public member function of CConf
 *
 *	Function Description
 *		This Command Target function is called when a node wants to give up
 *		conductorship.
 *
 *	Formal Parameters:
 *		None.
 *
 *	Return Value
 *		GCC_NO_ERROR					- No error.
 *		GCC_ALLOCATION_FAILURE			- A resource error occured.
 *		GCC_CONFERENCE_NOT_ESTABLISHED	- CConf object has not completed
 *										  its establishment process.
 *
 *  Side Effects
 *		None.
 *
 *	Caveats
 *		None.
 */

/*
 *	GCCError 	ConductorPleaseRequest()
 *
 *	Public member function of CConf
 *
 *	Function Description
 *		This Command Target function is called when a node wants to request
 *		the conductorship token from another node.
 *
 *	Formal Parameters:
 *		None.
 *
 *	Return Value
 *		GCC_NO_ERROR					- No error.
 *		GCC_ALLOCATION_FAILURE			- A resource error occured.
 *
 *  Side Effects
 *		None.
 *
 *	Caveats
 *		None.
 */

/*
 *	GCCError 		ConductorGiveRequest(
 *								UserID					recipient_node_id)
 *
 *	Public member function of CConf
 *
 *	Function Description
 *		This Command Target function is called when a node wants to give
 *		the conductorship token to another node.  Usually called in response
 *		to a please request.
 *
 *	Formal Parameters:
 *		recipient_node_id	-	(i)	User ID of node to give conductorship to.
 *
 *	Return Value
 *		GCC_NO_ERROR					- No error.
 *		GCC_ALLOCATION_FAILURE			- A resource error occured.
 *
 *  Side Effects
 *		None.
 *
 *	Caveats
 *		None.
 */

/*
 *	GCCError 		ConductorGiveResponse(
 *									GCCResult				result)
 *
 *	Public member function of CConf
 *
 *	Function Description
 *		This Command Target function is called after a node has received a
 *		give indication.  This response informs the conference of whether or
 *		not this node is accepting the conductorship token.
 *
 *	Formal Parameters:
 *		result		-	(i)	If the node is accepting conductorship the result
 *							will be set to GCC_RESULT_SUCCESSFUL.
 *
 *	Return Value
 *		GCC_NO_ERROR					- No error.
 *		GCC_ALLOCATION_FAILURE			- A resource error occured.
 *		GCC_NO_GIVE_RESPONSE_PENDING	- A give indication was never issued.
 *
 *  Side Effects
 *		None.
 *
 *	Caveats
 *		None.
 */

/*
 *	GCCError 		ConductorPermitAskRequest(
 *							BOOL					grant_permission)
 *
 *	Public member function of CConf
 *
 *	Function Description
 *		This Command Target function is called when a node wants permission
 *		from the conductor.  The definition of permission may vary from
 *		application to application.
 *
 *	Formal Parameters:
 *		grant_permission -	(i)	Flag stating whether permission is being
 *								requested or given up.
 *
 *	Return Value
 *		GCC_NO_ERROR					- No error.
 *		GCC_ALLOCATION_FAILURE			- A resource error occured.
 *
 *  Side Effects
 *		None.
 *
 *	Caveats
 *		None.
 */

/*
 *	GCCError 				ConductorPermitGrantRequest(
 *									UINT					number_granted,
 *									PUserID					granted_node_list,
 *									UINT					number_waiting,
 *									PUserID					waiting_node_list);
 *
 *	Public member function of CConf
 *
 *	Function Description
 *		This Command Target function is called by the conductor when
 *		permission is being granted to a node or list of nodes.
 *
 *	Formal Parameters:
 *		number_granted 		-	(i)	The number of nodes granted permission.
 *		granted_node_list 	-	(i)	List of nodes granted permission.
 *		number_waiting		-	(i)	The number of nodes waiting for permission.
 *		waiting_node_list 	-	(i)	List of nodes waiting for permission.
 *
 *	Return Value
 *		GCC_NO_ERROR					- No error.
 *		GCC_ALLOCATION_FAILURE			- A resource error occured.
 *
 *  Side Effects
 *		None.
 *
 *	Caveats
 *		None.
 */

/*
 *		GCCError ConductorInquireRequest(CBaseSap *pSap);
 *
 *	Public member function of CConf
 *
 *	Function Description
 *		This Command Target function is called when conductorship information
 *		is required by a SAP.
 *
 *	Formal Parameters:
 *		pSap 	-	(i)	SAP making the request.
 *
 *	Return Value
 *		GCC_NO_ERROR					- No error.
 *		GCC_ALLOCATION_FAILURE			- A resource error occured.
 *
 *  Side Effects
 *		None.
 *
 *	Caveats
 *		None.
 */

/*
 *	GCCError	ConferenceTimeRemainingRequest (
 *									UINT			time_remaining,
 *									UserID			node_id)
 *
 *	Public member function of CConf
 *
 *	Function Description
 *		This Command Target function is called to inform all the nodes in
 *		the conference how much time is left in the conference.
 *
 *	Formal Parameters:
 *		time_remaining 	-	(i)	Time in miliseconds left in the conference.
 *		node_id		 	-	(i)	node_id of node to deliver time remaining
 *								indication. NULL if it should go to all nodes.
 *
 *	Return Value
 *		GCC_NO_ERROR					- No error.
 *		GCC_ALLOCATION_FAILURE			- A resource error occured.
 *		GCC_CONFERENCE_NOT_ESTABLISHED	- CConf object has not completed
 *										  its establishment process.
 *
 *  Side Effects
 *		None.
 *
 *	Caveats
 *		None.
 */

/*
 *	GCCError 		ConfTimeInquireRequest (
 *									BOOL			time_is_conference_wide)
 *
 *	Public member function of CConf
 *
 *	Function Description
 *		This Command Target function is called by a node that wants to
 *		know how much time is remaining in a timed conference.
 *
 *	Formal Parameters:
 *		time_is_conference_wide	-	(i)	TRUE if time is for entire conference.
 *
 *	Return Value
 *		GCC_NO_ERROR					- No error.
 *		GCC_ALLOCATION_FAILURE			- A resource error occured.
 *		GCC_CONFERENCE_NOT_ESTABLISHED	- CConf object has not completed
 *										  its establishment process.
 *
 *  Side Effects
 *		None.
 *
 *	Caveats
 *		None.
 */

/*
 *	GCCError	ConfExtendRequest (
 *									UINT			extension_time,
 *									BOOL		 	time_is_conference_wide)
 *
 *	Public member function of CConf
 *
 *	Function Description
 *		This Command Target function is called when the time left in the
 *		conference is to be extended.
 *
 *	Formal Parameters:
 *		extension_time			-	(i)	Extension time.
 *		time_is_conference_wide	-	(i)	TRUE if time is for entire conference.
 *
 *	Return Value
 *		GCC_NO_ERROR					- No error.
 *		GCC_ALLOCATION_FAILURE			- A resource error occured.
 *		GCC_CONFERENCE_NOT_ESTABLISHED	- CConf object has not completed
 *										  its establishment process.
 *
 *  Side Effects
 *		None.
 *
 *	Caveats
 *		None.
 */

/*
 *	GCCError	ConfAssistanceRequest(
 *									UINT			number_of_user_data_members,
 *									PGCCUserData *	user_data_list)
 *
 *	Public member function of CConf
 *
 *	Function Description
 *		This Command Target function is called when a node wishes to request
 *		assistance.
 *
 *	Formal Parameters:
 *		number_of_user_data_members	-	(i)	number of user data members in list.
 *		user_data_list				-	(i)	list of user data members.
 *
 *	Return Value
 *		GCC_NO_ERROR					- No error.
 *		GCC_ALLOCATION_FAILURE			- A resource error occured.
 *		GCC_CONFERENCE_NOT_ESTABLISHED	- CConf object has not completed
 *										  its establishment process.
 *
 *  Side Effects
 *		None.
 *
 *	Caveats
 *		None.
 */

/*
 *	GCCError	AppInvokeRequest(
 *							CInvokeSpecifierListContainer	*invoke_list,
 *							UINT			number_of_destination_nodes,
 *							UserID			*list_of_destination_nodes,
 *                 			CBaseSap        *pSap)
 *
 *	Public member function of CConf
 *
 *	Function Description
 *		This Command Target function is called when a node wishes to invoke
 *		a list of applications on remote node or nodes.
 *
 *	Formal Parameters:
 *		invoke_list					-	(i)	list of applications to invoke.
 *		number_of_destination_nodes	-	(i)	number of nodes in destination list
 *		list_of_destination_nodes	-	(i)	list of destination user IDs
 *		command_target				-	(i)	Command Target that made the request
 *
 *	Return Value
 *		GCC_NO_ERROR					- No error.
 *		GCC_ALLOCATION_FAILURE			- A resource error occured.
 *		GCC_CONFERENCE_NOT_ESTABLISHED	- CConf object has not completed
 *										  its establishment process.
 *
 *  Side Effects
 *		None.
 *
 *	Caveats
 *		None.
 */

/*
 *	GCCError 	TextMessageRequest (
 *							LPWSTR				pwszTextMsg,
 *							UserID				destination_node )
 *
 *	Public member function of CConf
 *
 *	Function Description
 *		This Command Target function is called when a node wishes to deliver
 *		a text message to a remote node.
 *
 *	Formal Parameters:
 *		pwszTextMsg				-	(i)	the actual text message in unicode.
 *		destination_node		-	(i)	Node ID of node receiving message
 *
 *	Return Value
 *		GCC_NO_ERROR					- No error.
 *		GCC_ALLOCATION_FAILURE			- A resource error occured.
 *		GCC_CONFERENCE_NOT_ESTABLISHED	- CConf object has not completed
 *										  its establishment process.
 *
 *  Side Effects
 *		None.
 *
 *	Caveats
 *		None.
 */

/*
 *	GCCError	ConfTransferRequest (
 *							PGCCConferenceName	destination_conference_name,
 *							GCCNumericString	destination_conference_modifier,
 *							CNetAddrListContainer *network_address_list,
 *							UINT				number_of_destination_nodes,
 *	 						PUserID				destination_node_list,
 *							CPassword           *password)
 *
 *	Public member function of CConf
 *
 *	Function Description
 *		This Command Target function is called when a node wishes transfer a
 *		list of nodes to another conference.
 *
 *	Formal Parameters:
 *		destination_conference_name	-	(i)	Name of conference to transfer to.
 *		destination_conference_modifier-(i)	Name of modifier to transfer to.
 *		network_address_list		-	(i)	Address list of new conference.
 *		number_of_destination_nodes	-	(i)	Number of nodes to transfer
 *		destination_node_list		-	(i)	List of nodes to transfer.
 *		password					-	(i)	Password needed to join new conf.
 *
 *	Return Value
 *		GCC_NO_ERROR					- No error.
 *		GCC_ALLOCATION_FAILURE			- A resource error occured.
 *		GCC_CONFERENCE_NOT_ESTABLISHED	- CConf object has not completed
 *										  its establishment process.
 *
 *  Side Effects
 *		None.
 *
 *	Caveats
 *		None.
 */

/*
 *	GCCError		ConfAddRequest (	
 *							CNetAddrListContainer *network_address_container,
 *							UserID				adding_node,
 *							CUserDataListContainer *user_data_container)
 *
 *	Public member function of CConf
 *
 *	Function Description
 *		This Command Target function is called when a node wishes add a new
 *		node to the conference.
 *
 *	Formal Parameters:
 *		network_address_container	-	(i)	Address of node to add.
 *		adding_node					-	(i)	Node to perform the invite. If
 *											zero then Top Provider does the
 *											invite.
 *		user_data_container			-	(i)	Container holding user data to be
 *											passed in the add request.
 *
 *	Return Value
 *		GCC_NO_ERROR					- No error.
 *		GCC_ALLOCATION_FAILURE			- A resource error occured.
 *		GCC_CONFERENCE_NOT_ESTABLISHED	- CConf object has not completed
 *										  its establishment process.
 *
 *  Side Effects
 *		None.
 *
 *	Caveats
 *		None.
 */

/*
 *	GCCError		ConfAddResponse (	
 *							GCCResponseTag		add_response_tag,
 *							UserID				requesting_node,
 *							CUserDataListContainer *user_data_container,
 *							GCCResult			result)
 *
 *	Public member function of CConf
 *
 *	Function Description
 *		This Command Target function is called when a node wishes to respond
 *		to an add request.  This response should be done after the invite
 *		sequence is complete (unless result is not successful).
 *
 *	Formal Parameters:
 *		add_response_tag		-	(i)	Tag used to match request with response.
 *		requesting_node			-	(i)	Node that made the original add request.
 *		user_data_container		-	(i)	Container holding user data to be
 *										passed in the add response.
 *		result					-	(i)	The result of the Add request.
 *
 *	Return Value
 *		GCC_NO_ERROR					- No error.
 *		GCC_ALLOCATION_FAILURE			- A resource error occured.
 *		GCC_CONFERENCE_NOT_ESTABLISHED	- CConf object has not completed
 *										  its establishment process.
 *		GCC_INVALID_ADD_RESPONSE_TAG	- There was no match of the response tag
 *
 *  Side Effects
 *		None.
 *
 *	Caveats
 *		None.
 */



=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\remdsk\rds\t120\h\cntlist.h ===
#ifndef _CONTAINED_LIST_H_
#define _CONTAINED_LIST_H_


#define CLIST_DEFAULT_MAX_ITEMS   4
#define CLIST_END_OF_ARRAY_MARK   ((UINT) -1)


class CList
{
public:

    CList(void);
    CList(ULONG cMaxItems);
    CList(ULONG cMaxItems, ULONG cSubItems);
    CList(ULONG cMaxItems, ULONG cSubItems, BOOL fQueue);

    CList(CList *pSrc);

    ~CList(void);

    BOOL Append(LPVOID pData);
    BOOL Prepend(LPVOID pData);

    BOOL Find(LPVOID pData);
    BOOL Remove(LPVOID pData);

    LPVOID Get(void);

    LPVOID Iterate(void);

    void Reset(void) { m_nCurrOffset = CLIST_END_OF_ARRAY_MARK; };
    void Clear(void) { m_cEntries = 0; m_nHeadOffset = 0; m_nCurrOffset = CLIST_END_OF_ARRAY_MARK; };

    UINT GetCount(void) { return m_cEntries; };
    BOOL IsEmpty(void) { return (m_cEntries == 0); };

    LPVOID PeekHead(void) { return (0 != m_cEntries) ? m_aEntries[m_nHeadOffset] : NULL; }

protected:

    void CalcKeyArray(void);

protected:

    ULONG      m_cEntries;
    ULONG      m_cMaxEntries;
    ULONG      m_nHeadOffset;
    ULONG      m_nCurrOffset;
    ULONG      m_cSubItems;    // 1 for CList, 2 for CList2
    BOOL       m_fQueue;       // TRUE for CQueue, FALSE for CList

    LPVOID     *m_aEntries;
    UINT_PTR   *m_aKeys;       // for CList2

private:

    BOOL Expand(void);
    BOOL Init(ULONG cSubItems);
};


#define DEFINE_CLIST(_NewClass_,_PtrItemType_) \
            public: \
            _NewClass_(void) : CList() { C_ASSERT(sizeof(_PtrItemType_) == sizeof(LPVOID)); } \
            _NewClass_(ULONG cMaxItems) : CList(cMaxItems) { C_ASSERT(sizeof(_PtrItemType_) == sizeof(LPVOID)); } \
            _NewClass_(_NewClass_ *pSrc) : CList((CList *) pSrc) { C_ASSERT(sizeof(_PtrItemType_) == sizeof(LPVOID)); } \
            _NewClass_(_NewClass_ &Src) : CList((CList *) &Src) { C_ASSERT(sizeof(_PtrItemType_) == sizeof(LPVOID)); } \
            BOOL Append(_PtrItemType_ pData) { return CList::Append((LPVOID) pData); } \
            BOOL Prepend(_PtrItemType_ pData) { return CList::Prepend((LPVOID) pData); } \
            BOOL Remove(_PtrItemType_ pData) { return CList::Remove((LPVOID) pData); } \
            BOOL Find(_PtrItemType_ pData) { return CList::Find((LPVOID) pData); } \
            _PtrItemType_ Get(void) { return (_PtrItemType_) CList::Get(); } \
            _PtrItemType_ PeekHead(void) { return (_PtrItemType_) CList::PeekHead(); } \
            _PtrItemType_ Iterate(void) { return (_PtrItemType_) CList::Iterate(); }

#define DEFINE_CLIST_(_NewClass_,_IntItemType_) \
            public: \
            _NewClass_(void) : CList() { C_ASSERT(sizeof(_IntItemType_) <= sizeof(LPVOID)); } \
            _NewClass_(ULONG cMaxItems) : CList(cMaxItems) { C_ASSERT(sizeof(_IntItemType_) <= sizeof(LPVOID)); } \
            _NewClass_(_NewClass_ *pSrc) : CList((CList *) pSrc) { C_ASSERT(sizeof(_IntItemType_) <= sizeof(LPVOID)); } \
            _NewClass_(_NewClass_ &Src) : CList((CList *) &Src) { C_ASSERT(sizeof(_IntItemType_) <= sizeof(LPVOID)); } \
            BOOL Append(_IntItemType_ nData) { return CList::Append((LPVOID) nData); } \
            BOOL Prepend(_IntItemType_ nData) { return CList::Prepend((LPVOID) nData); } \
            BOOL Remove(_IntItemType_ nData) { return CList::Remove((LPVOID) nData); } \
            BOOL Find(_IntItemType_ nData) { return CList::Find((LPVOID) nData); } \
            _IntItemType_ Get(void) { return (_IntItemType_) (UINT_PTR) CList::Get(); } \
            _IntItemType_ PeekHead(void) { return (_IntItemType_) (UINT_PTR) CList::PeekHead(); } \
            _IntItemType_ Iterate(void) { return (_IntItemType_) (UINT_PTR) CList::Iterate(); }


class CList2 : public CList
{
public:

    CList2(ULONG cMaxItems = CLIST_DEFAULT_MAX_ITEMS) : CList(cMaxItems, 2) { }
    CList2(ULONG cMaxItems, BOOL fQueue)              : CList(cMaxItems, 2, fQueue) { }

    CList2(CList2 *pSrc);

    BOOL Append(UINT_PTR nKey, LPVOID pData);
    BOOL Prepend(UINT_PTR nKey, LPVOID pData);

    // BOOL Remove(LPVOID pData); // inherited from CList
    LPVOID Remove(UINT_PTR nKey);

    // BOOL Find(LPVOID pData); // inherited from CList
    LPVOID Find(UINT_PTR nKey);

    // LPVOID Get(void); // inheirted from CList
    LPVOID Get(UINT_PTR *pnKey);

    // LPVOID Iterate(void); // inherited from CList
    LPVOID Iterate(UINT_PTR *pnKey);

    LPVOID PeekHead(UINT_PTR *pnKey);
};


#define DEFINE_CLIST2(_NewClass_,_PtrItemType_,_IntKeyType_) \
            public: \
            _NewClass_(void) : CList2() { C_ASSERT(sizeof(_IntKeyType_) <= sizeof(UINT_PTR)); C_ASSERT(sizeof(_PtrItemType_) <= sizeof(LPVOID)); } \
            _NewClass_(ULONG cMaxItems) : CList2(cMaxItems) { C_ASSERT(sizeof(_IntKeyType_) <= sizeof(UINT_PTR)); C_ASSERT(sizeof(_PtrItemType_) <= sizeof(LPVOID)); } \
            _NewClass_(_NewClass_ *pSrc) : CList2((CList2 *) pSrc) { C_ASSERT(sizeof(_IntKeyType_) <= sizeof(UINT_PTR)); C_ASSERT(sizeof(_PtrItemType_) <= sizeof(LPVOID)); } \
            _NewClass_(_NewClass_ &Src) : CList2((CList2 *) &Src) { C_ASSERT(sizeof(_IntKeyType_) <= sizeof(UINT_PTR)); C_ASSERT(sizeof(_PtrItemType_) <= sizeof(LPVOID)); } \
            BOOL Append(_IntKeyType_ nKey, _PtrItemType_ pData) { return CList2::Append((UINT_PTR) nKey, (LPVOID) pData); } \
            BOOL Prepend(_IntKeyType_ nKey, _PtrItemType_ pData) { return CList2::Prepend((UINT_PTR) nKey, (LPVOID) pData); } \
            BOOL          Remove(_PtrItemType_ pData) { return CList::Remove((LPVOID) pData); } \
            _PtrItemType_ Remove(_IntKeyType_ nKey) { return (_PtrItemType_) (UINT_PTR) CList2::Remove((UINT_PTR) nKey); } \
            BOOL          Find(_PtrItemType_ pData) { return CList::Find((LPVOID) pData); } \
            _PtrItemType_ Find(_IntKeyType_ nKey) { return (_PtrItemType_) (UINT_PTR) CList2::Find((UINT_PTR) nKey); } \
            _PtrItemType_ Get(void) { return (_PtrItemType_) (UINT_PTR) CList::Get(); } \
            _PtrItemType_ Get(_IntKeyType_ *pnKey) { UINT_PTR n; _PtrItemType_ p = (_PtrItemType_) (UINT_PTR) CList2::Get(&n); *pnKey = (_IntKeyType_) n; return p; } \
            _PtrItemType_ PeekHead(void) { return (_PtrItemType_) (UINT_PTR) CList::PeekHead(); } \
            _PtrItemType_ PeekHead(_IntKeyType_ *pnKey) { UINT_PTR n; _PtrItemType_ p = (_PtrItemType_) (UINT_PTR) CList2::PeekHead(&n); *pnKey = (_IntKeyType_) n; return p; } \
            _PtrItemType_ Iterate(void) { return (_PtrItemType_) (UINT_PTR) CList::Iterate(); } \
            _PtrItemType_ Iterate(_IntKeyType_ *pnKey) { UINT_PTR n; _PtrItemType_ p = (_PtrItemType_) (UINT_PTR) CList2::Iterate(&n); *pnKey = (_IntKeyType_) n; return p; }

#define DEFINE_CLIST2_(_NewClass_,_PtrItemType_,_ShortKeyType_) \
            DEFINE_CLIST2(_NewClass_,_PtrItemType_,_ShortKeyType_)

#define DEFINE_CLIST2__(_NewClass_,_IntKeyType_) \
            public: \
            _NewClass_(void) : CList2() { C_ASSERT(sizeof(_IntKeyType_) <= sizeof(UINT_PTR)); C_ASSERT(sizeof(_IntKeyType_) <= sizeof(LPVOID)); } \
            _NewClass_(ULONG cMaxItems) : CList2(cMaxItems) { C_ASSERT(sizeof(_IntKeyType_) <= sizeof(UINT_PTR)); C_ASSERT(sizeof(_IntKeyType_) <= sizeof(LPVOID)); } \
            _NewClass_(_NewClass_ *pSrc) : CList2((CList2 *) pSrc) { C_ASSERT(sizeof(_IntKeyType_) <= sizeof(UINT_PTR)); C_ASSERT(sizeof(_IntKeyType_) <= sizeof(LPVOID)); } \
            _NewClass_(_NewClass_ &Src) : CList2((CList2 *) &Src) { C_ASSERT(sizeof(_IntKeyType_) <= sizeof(UINT_PTR)); C_ASSERT(sizeof(_IntKeyType_) <= sizeof(LPVOID)); } \
            BOOL Append(_IntKeyType_ nKey, _IntKeyType_ nData) { return CList2::Append((UINT_PTR) nKey, (LPVOID) nData); } \
            BOOL Prepend(_IntKeyType_ nKey, _IntKeyType_ nData) { return CList2::Prepend((UINT_PTR) nKey, (LPVOID) nData); } \
            _IntKeyType_ Remove(_IntKeyType_ nKey) { return (_IntKeyType_) (UINT_PTR) CList2::Remove((UINT_PTR) nKey); } \
            _IntKeyType_ Find(_IntKeyType_ nKey) { return (_IntKeyType_) (UINT_PTR) CList2::Find((UINT_PTR) nKey); } \
            _IntKeyType_ Get(void) { return (_IntKeyType_) (UINT_PTR) CList::Get(); } \
            _IntKeyType_ Get(_IntKeyType_ *pnKey) { UINT_PTR n; _IntKeyType_ p = (_IntKeyType_) (UINT_PTR) CList2::Get(&n); *pnKey = (_IntKeyType_) n; return p; } \
            _IntKeyType_ PeekHead(void) { return (_IntKeyType_) (UINT_PTR) CList::PeekHead(); } \
            _IntKeyType_ PeekHead(_IntKeyType_ *pnKey) { UINT_PTR n; _IntKeyType_ p = (_IntKeyType_) (UINT_PTR) CList2::PeekHead(&n); *pnKey = (_IntKeyType_) n; return p; } \
            _IntKeyType_ Iterate(void) { return (_IntKeyType_) (UINT_PTR) CList::Iterate(); } \
            _IntKeyType_ Iterate(_IntKeyType_ *pnKey) { UINT_PTR n; _IntKeyType_ p = (_IntKeyType_) (UINT_PTR) CList2::Iterate(&n); *pnKey = (_IntKeyType_) n; return p; }

#define DEFINE_CLIST2___(_NewClass_,_ShortKeyType_) \
            DEFINE_CLIST2__(_NewClass_,_ShortKeyType_)

class CQueue : public CList
{
public:

    CQueue(ULONG cMaxItems = CLIST_DEFAULT_MAX_ITEMS) : CList(cMaxItems, 1, TRUE) { };
    CQueue(CQueue *pSrc) : CList((CList *) pSrc) { };
};


#define DEFINE_CQUEUE(_NewClass_,_PtrItemType_) \
            public: \
            _NewClass_(void) : CQueue() { C_ASSERT(sizeof(_PtrItemType_) == sizeof(LPVOID)); } \
            _NewClass_(ULONG cMaxItems) : CQueue(cMaxItems) { C_ASSERT(sizeof(_PtrItemType_) == sizeof(LPVOID)); } \
            _NewClass_(_NewClass_ *pSrc) : CQueue((CQueue *) pSrc) { C_ASSERT(sizeof(_PtrItemType_) == sizeof(LPVOID)); } \
            _NewClass_(_NewClass_ &Src) : CQueue((CQueue *) &Src) { C_ASSERT(sizeof(_PtrItemType_) == sizeof(LPVOID)); } \
            BOOL Append(_PtrItemType_ pData) { return CList::Append((LPVOID) pData); } \
            BOOL Prepend(_PtrItemType_ pData) { return CList::Prepend((LPVOID) pData); } \
            BOOL Remove(_PtrItemType_ pData) { return CList::Remove((LPVOID) pData); } \
            BOOL Find(_PtrItemType_ pData) { return CList::Find((LPVOID) pData); } \
            _PtrItemType_ Get(void) { return (_PtrItemType_) CList::Get(); } \
            _PtrItemType_ PeekHead(void) { return (_PtrItemType_) CList::PeekHead(); } \
            _PtrItemType_ Iterate(void) { return (_PtrItemType_) CList::Iterate(); }

#define DEFINE_CQUEUE_(_NewClass_,_IntItemType_) \
            public: \
            _NewClass_(void) : CQueue() { C_ASSERT(sizeof(_IntItemType_) <= sizeof(LPVOID)); } \
            _NewClass_(ULONG cMaxItems) : CQueue(cMaxItems) { C_ASSERT(sizeof(_IntItemType_) <= sizeof(LPVOID)); } \
            _NewClass_(_NewClass_ *pSrc) : CQueue((CQueue *) pSrc) { C_ASSERT(sizeof(_IntItemType_) <= sizeof(LPVOID)); } \
            _NewClass_(_NewClass_ &Src) : CQueue((CQueue *) &Src) { C_ASSERT(sizeof(_IntItemType_) <= sizeof(LPVOID)); } \
            BOOL Append(_IntItemType_ nData) { return CList::Append((LPVOID) nData); } \
            BOOL Prepend(_IntItemType_ nData) { return CList::Prepend((LPVOID) nData); } \
            BOOL Remove(_IntItemType_ nData) { return CList::Remove((LPVOID) nData); } \
            BOOL Find(_IntItemType_ nData) { return CList::Find((LPVOID) nData); } \
            _IntItemType_ Get(void) { return (_IntItemType_) (UINT_PTR) CList::Get(); } \
            _IntItemType_ PeekHead(void) { return (_IntItemType_) (UINT_PTR) CList::PeekHead(); } \
            _IntItemType_ Iterate(void) { return (_IntItemType_) (UINT_PTR) CList::Iterate(); }



class CQueue2 : public CList2
{
public:

    CQueue2(ULONG cMaxItems = CLIST_DEFAULT_MAX_ITEMS) : CList2(cMaxItems, TRUE) { };
    CQueue2(CQueue2 *pSrc) : CList2((CList2 *) pSrc) { };
};


#define DEFINE_CQUEUE2(_NewClass_,_PtrItemType_,_IntKeyType_) \
            public: \
            _NewClass_(void) : CQueue2() { C_ASSERT(sizeof(_IntKeyType_) <= sizeof(UINT_PTR)); C_ASSERT(sizeof(_PtrItemType_) <= sizeof(LPVOID)); } \
            _NewClass_(ULONG cMaxItems) : CQueue2(cMaxItems) { C_ASSERT(sizeof(_IntKeyType_) <= sizeof(UINT_PTR)); C_ASSERT(sizeof(_PtrItemType_) <= sizeof(LPVOID)); } \
            _NewClass_(_NewClass_ *pSrc) : CQueue2((CQueue2 *) pSrc) { C_ASSERT(sizeof(_IntKeyType_) <= sizeof(UINT_PTR)); C_ASSERT(sizeof(_PtrItemType_) <= sizeof(LPVOID)); } \
            _NewClass_(_NewClass_ &Src) : CQueue2((CQueue2 *) &Src) { C_ASSERT(sizeof(_IntKeyType_) <= sizeof(UINT_PTR)); C_ASSERT(sizeof(_PtrItemType_) <= sizeof(LPVOID)); } \
            BOOL Append(_IntKeyType_ nKey, _PtrItemType_ pData) { return CList2::Append((UINT_PTR) nKey, (LPVOID) pData); } \
            BOOL Prepend(_IntKeyType_ nKey, _PtrItemType_ pData) { return CList2::Prepend((UINT_PTR) nKey, (LPVOID) pData); } \
            BOOL          Remove(_PtrItemType_ pData) { return CList::Remove((LPVOID) pData); } \
            _PtrItemType_ Remove(_IntKeyType_ nKey) { return (_PtrItemType_) (UINT_PTR) CList2::Remove((UINT_PTR) nKey); } \
            BOOL          Find(_PtrItemType_ pData) { return CList::Find((LPVOID) pData); } \
            _PtrItemType_ Find(_IntKeyType_ nKey) { return (_PtrItemType_) (UINT_PTR) CList2::Find((UINT_PTR) nKey); } \
            _PtrItemType_ Get(void) { return (_PtrItemType_) (UINT_PTR) CList::Get(); } \
            _PtrItemType_ Get(_IntKeyType_ *pnKey) { UINT_PTR n; _PtrItemType_ p = (_PtrItemType_) (UINT_PTR) CList2::Get(&n); *pnKey = (_IntKeyType_) n; return p; } \
            _PtrItemType_ PeekHead(void) { return (_PtrItemType_) (UINT_PTR) CList::PeekHead(); } \
            _PtrItemType_ PeekHead(_IntKeyType_ *pnKey) { UINT_PTR n; _PtrItemType_ p = (_PtrItemType_) (UINT_PTR) CList2::PeekHead(&n); *pnKey = (_IntKeyType_) n; return p; } \
            _PtrItemType_ Iterate(void) { return (_PtrItemType_) (UINT_PTR) CList::Iterate(); } \
            _PtrItemType_ Iterate(_IntKeyType_ *pnKey) { UINT_PTR n; _PtrItemType_ p = (_PtrItemType_) (UINT_PTR) CList2::Iterate(&n); *pnKey = (_IntKeyType_) n; return p; }

#define DEFINE_CQUEUE2_(_NewClass_,_PtrItemType_,_ShortKeyType_) \
            DEFINE_CQUEUE2(_NewClass_,_PtrItemType_,_ShortKeyType_)

// both key and item are of the same type
#define DEFINE_CQUEUE2__(_NewClass_,_IntKeyType_) \
            public: \
            _NewClass_(void) : CQueue2() { C_ASSERT(sizeof(_IntKeyType_) == sizeof(UINT_PTR)); C_ASSERT(sizeof(_IntKeyType_) == sizeof(LPVOID)); } \
            _NewClass_(ULONG cMaxItems) : CQueue2(cMaxItems) { C_ASSERT(sizeof(_IntKeyType_) == sizeof(UINT_PTR)); C_ASSERT(sizeof(_IntKeyType_) == sizeof(LPVOID)); } \
            _NewClass_(_NewClass_ *pSrc) : CQueue2((CQueue2 *) pSrc) { C_ASSERT(sizeof(_IntKeyType_) == sizeof(UINT_PTR)); C_ASSERT(sizeof(_IntKeyType_) == sizeof(LPVOID)); } \
            _NewClass_(_NewClass_ &Src) : CQueue2((CQueue2 *) &Src) { C_ASSERT(sizeof(_IntKeyType_) == sizeof(UINT_PTR)); C_ASSERT(sizeof(_IntKeyType_) == sizeof(LPVOID)); } \
            BOOL Append(_IntKeyType_ nKey, _IntKeyType_ nData) { return CList2::Append((UINT_PTR) nKey, (LPVOID) nData); } \
            BOOL Prepend(_IntKeyType_ nKey, _IntKeyType_ nData) { return CList2::Prepend((UINT_PTR) nKey, (LPVOID) nData); } \
            _IntKeyType_ Remove(_IntKeyType_ nKey) { return (_IntKeyType_) CList2::Remove((UINT_PTR) nKey); } \
            _IntKeyType_ Find(_IntKeyType_ nKey) { return (_IntKeyType_) CList2::Find((UINT_PTR) nKey); } \
            _IntKeyType_ Get(void) { return (_IntKeyType_) CList::Get(); } \
            _IntKeyType_ Get(_IntKeyType_ *pnKey) { return (_IntKeyType_) CList2::Get((UINT_PTR *) pnKey); } \
            _IntKeyType_ PeekHead(void) { return (_IntKeyType_) CList::PeekHead(); } \
            _IntKeyType_ PeekHead(_IntKeyType_ *pnKey) { return (_IntKeyType_) CList2::PeekHead((UINT_PTR *) pnKey); } \
            _IntKeyType_ Iterate(void) { return (_IntKeyType_) CList::Iterate(); } \
            _IntKeyType_ Iterate(_IntKeyType_ *pnKey) { return (_IntKeyType_) CList2::Iterate((UINT_PTR *) pnKey); }


#define HASHED_LIST_DEFAULT_BUCKETS             16

#ifdef ENABLE_HASHED_LIST2

class CHashedList2
{
public:

    CHashedList2(ULONG cBuckets = HASHED_LIST_DEFAULT_BUCKETS, ULONG cInitItemsPerBucket = CLIST_DEFAULT_MAX_ITEMS);
    CHashedList2(CHashedList2 *pSrc);
    ~CHashedList2(void);

    BOOL Insert(UINT nKey, LPVOID pData);

    LPVOID Remove(UINT nKey);
    LPVOID Find(UINT nKey);

    LPVOID Get(void);
    LPVOID Get(UINT *pnKey);

    LPVOID Iterate(UINT *pnKey);
    LPVOID Iterate(void) { UINT n; return Iterate(&n); }

    void Reset(void);
    void Clear(void);

    ULONG GetCount(void) { return m_cEntries; };
    BOOL IsEmpty(void) { return (m_cEntries == 0); };

private:

    ULONG GetHashValue(UINT nKey);

    ULONG       m_cBuckets;
    ULONG       m_cInitItemsPerBucket;
    CList2    **m_aBuckets;
    ULONG       m_cEntries;
    ULONG       m_nCurrBucket;
};

#else // ! ENABLE_HASHED_LIST2

class CHashedList2 : public CList2
{
public:

    CHashedList2(ULONG cBuckets = HASHED_LIST_DEFAULT_BUCKETS, ULONG cInitItemsPerBucket = CLIST_DEFAULT_MAX_ITEMS)
                                     : CList2(cInitItemsPerBucket) { }
    CHashedList2(CHashedList2 *pSrc) : CList2((CList2 *) pSrc) { }

    BOOL Insert(UINT_PTR nKey, LPVOID pData) { return CList2::Append(nKey, pData); }

    LPVOID Get(void) { return CList::Get(); }
    LPVOID Get(UINT_PTR *pnKey) { return CList2::Get(pnKey); }

    LPVOID Iterate(void) { return CList::Iterate(); }
    LPVOID Iterate(UINT_PTR *pnKey) { return CList2::Iterate(pnKey); }
};

#endif // ENABLE_HASHED_LIST2

#define DEFINE_HLIST2(_NewClass_,_PtrItemType_,_IntKeyType_) \
            public: \
            _NewClass_(ULONG cBuckets = HASHED_LIST_DEFAULT_BUCKETS, ULONG cInitItemsPerBucket = CLIST_DEFAULT_MAX_ITEMS) \
                : CHashedList2(cBuckets, cInitItemsPerBucket) { C_ASSERT(sizeof(_IntKeyType_) == sizeof(UINT)); C_ASSERT(sizeof(_PtrItemType_) == sizeof(LPVOID)); } \
            _NewClass_(_NewClass_ *pSrc) : CHashedList2((CHashedList2 *) pSrc) { C_ASSERT(sizeof(_IntKeyType_) == sizeof(UINT)); C_ASSERT(sizeof(_PtrItemType_) == sizeof(LPVOID)); } \
            _NewClass_(_NewClass_ &Src) : CHashedList2((CHashedList2 *) &Src) { C_ASSERT(sizeof(_IntKeyType_) == sizeof(UINT)); C_ASSERT(sizeof(_PtrItemType_) == sizeof(LPVOID)); } \
            BOOL Insert(_IntKeyType_ nKey, _PtrItemType_ pData) { return CHashedList2::Insert((UINT) nKey, (LPVOID) pData); } \
            _PtrItemType_ Remove(_IntKeyType_ nKey) { return (_PtrItemType_) CHashedList2::Remove((UINT) nKey); } \
            _PtrItemType_ Find(_IntKeyType_ nKey) { return (_PtrItemType_) CHashedList2::Find((UINT) nKey); } \
            _PtrItemType_ Get(_IntKeyType_ *pnKey) { return (_PtrItemType_) CHashedList2::Get((UINT *) pnKey); } \
            _PtrItemType_ Iterate(void) { return (_PtrItemType_) CHashedList2::Iterate(); } \
            _PtrItemType_ Iterate(_IntKeyType_ *pnKey) { return (_PtrItemType_) CHashedList2::Iterate((UINT *) pnKey); }

#define DEFINE_HLIST2_(_NewClass_,_PtrItemType_,_ShortKeyType_) \
            public: \
            _NewClass_(ULONG cBuckets = HASHED_LIST_DEFAULT_BUCKETS, ULONG cInitItemsPerBucket = CLIST_DEFAULT_MAX_ITEMS) \
                : CHashedList2(cBuckets, cInitItemsPerBucket) { C_ASSERT(sizeof(_ShortKeyType_) < sizeof(UINT_PTR)); C_ASSERT(sizeof(_PtrItemType_) == sizeof(LPVOID)); } \
            _NewClass_(_NewClass_ *pSrc) : CHashedList2((CHashedList2 *) pSrc) { C_ASSERT(sizeof(_ShortKeyType_) < sizeof(UINT_PTR)); C_ASSERT(sizeof(_PtrItemType_) == sizeof(LPVOID)); } \
            _NewClass_(_NewClass_ &Src) : CHashedList2((CHashedList2 *) &Src) { C_ASSERT(sizeof(_ShortKeyType_) < sizeof(UINT_PTR)); C_ASSERT(sizeof(_PtrItemType_) == sizeof(LPVOID)); } \
            BOOL Insert(_ShortKeyType_ nKey, _PtrItemType_ pData) { return CHashedList2::Insert((UINT_PTR) nKey, (LPVOID) pData); } \
            _PtrItemType_ Remove(_ShortKeyType_ nKey) { return (_PtrItemType_) CHashedList2::Remove((UINT_PTR) nKey); } \
            _PtrItemType_ Find(_ShortKeyType_ nKey) { return (_PtrItemType_) CHashedList2::Find((UINT_PTR) nKey); } \
            _PtrItemType_ Get(_ShortKeyType_ *pnKey) { UINT_PTR n; _PtrItemType_ p = (_PtrItemType_) CHashedList2::Get(&n); *pnKey = (_ShortKeyType_) n; return p; } \
            _PtrItemType_ Iterate(void) { return (_PtrItemType_) CHashedList2::Iterate(); } \
            _PtrItemType_ Iterate(_ShortKeyType_ *pnKey) { UINT_PTR n; _PtrItemType_ p = (_PtrItemType_) CHashedList2::Iterate(&n); *pnKey = (_ShortKeyType_) n; return p; }




typedef LPVOID          BOOL_PTR;
#define TRUE_PTR        ((LPVOID) (UINT)  1)
#define FALSE_PTR       ((LPVOID) (UINT) -1)

#define LPVOID_NULL     ((LPVOID) (UINT) -1)


#endif // _CONTAINED_LIST_H_


=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\remdsk\rds\t120\h\control.h ===
/*
 *	control.h
 *
 *	Copyright (c) 1993 - 1996 by DataBeam Corporation, Lexington, KY
 *
 *	Abstract:
 *		This is the interface file for the MCS Controller class.  There will
 *		be exactly one instance of this class at run-time, whose job it is
 *		to coordinate the creation, deletion, and linking of other objects
 *		in the system.
 *
 *		The controller is primarily responsible for managing five "layers"
 *		of objects in the system at run-time.  These layers can be depicted
 *		as follows:
 *
 *		+---+       +------------------------+
 *		|   | <---> | Application Interfaces |
 *		|   |       +------------------------+
 *		|   |                   |
 *		| C |       +------------------------+
 *		| o | <---> |    User Attachments    |
 *		| n |       +------------------------+
 *		| t |                   |
 *		| r |       +------------------------+
 *		| o | <---> |        Domains         |
 *		| l |       +------------------------+
 *		| l |                   |
 *		| e |       +------------------------+
 *		| r | <---> |    MCS Connections     |
 *		|   |       +------------------------+
 *		|   |                   |
 *		|   |       +------------------------+
 *		|   | <---> |  Transport Interfaces  |
 *		+---+       +------------------------+
 *
 *		The controller is the first object created in the MCS system.  It is
 *		responsible for creating all other objects during initialization.  In
 *		the constructor, the controller creates all necessary application
 *		interface and transport interface objects.  These are the objects
 *		through which MCS communicates with the outside world.  They are
 *		static in that they live throughout the lifetime of MCS itself.
 *
 *		During initialization, the node controller must register itself with
 *		the controller so that the controller knows which application interface
 *		object to use when issuing indications and confirms back to the node
 *		controller.  Note that even though it is possible to have more than
 *		one way to communicate with applications, there is still only one node
 *		controller.
 *
 *		Four of the five layers of objects communicate with the controller
 *		through the owner callback facility.  This mechanism is used to send
 *		requests to the controller.
 *
 *		User attachments (instances of class User) are created when the
 *		controller receives an AttachUserRequest from one of the application
 *		interface objects (with a valid domain selector).  A new user object
 *		is created, who in turn registers with the correct application interface
 *		object to insure proper data flow at run-time.
 *
 *		Domains (instances of class Domain) are created when the controller
 *		receives a CreateDomain from one of the application interface objects.
 *		Since both user attachments and MCS connections identify specific
 *		domains, this must occur before any attaching or connecting can be
 *		done.
 *
 *		MCS connections (instances of class Connection) are created in two
 *		possible ways.  First, when a ConnectProviderRequest is received from
 *		one of the application interface objects (with a valid local domain
 *		selector and a valid transport address).  Second, when a
 *		ConnectProviderResponse is received from one of the application
 *		interface objects in response to a previous connect provider indication.
 *		Either way, a Connection object is created to represent the new MCS
 *		connection.
 *
 *		User attachments are deleted in one of two ways.  First, when a
 *		DetachUserRequest is received from an application interface with a
 *		valid user handle.  Second, if the user attachment is told by the
 *		domain that the attachment is severed.  In the latter case, the user
 *		object asks the controller to delete it using the owner callback
 *		facility.
 *
 *		Domains are deleted when a DeleteDomain is received from an application
 *		interface.
 *
 *		Connections are deleted in one of three ways.  First, when a
 *		DisconnectProviderRequest is received from an application interface
 *		with a valid connection handle.  Second, if the transport interface
 *		detects a loss of the connection at a lower layer.  Third, if the
 *		connection is told by the domain that the connection is to be severed.
 *		In the latter two cases, the connection object asks the controller to
 *		delete it using the owner callback facility.
 *
 *		The primary role of the controller is to create and delete all of these
 *		objects, and to "plug" them together as needed.
 *
 *		During initialization, the controller also creates a single instance
 *		of a memory manager.  This objects is then passed on to all other
 *		objects that require its services (in their constructors).  A possible
 *		way to improve upon this scheme would be to create a memory manager
 *		for each domain, so that traffic in one domain does not influence
 *		traffic in another.
 *
 *	Portable:
 *		Not completely.  During initialization, the constructor "knows"
 *		how to create application interface and transport interface objects
 *		that are specific to the environment.  In the case of the transport
 *		interfaces, it actually reads a windows ".INI" file.  It can also
 *		optionally allocate a windows timer in order have a "heartbeat".  Other
 *		than initialization, everything else is portable.
 *
 *	Caveats:
 *		There can be only one instance of this class in an MCS provider.
 *
 *	Author:
 *		James P. Galvin, Jr.
 */
#ifndef	_CONTROLLER_
#define	_CONTROLLER_

/*
 *	Include files.
 */
#include "omcscode.h"

/*
 *	This structure is used to hold information about an incoming connection,
 *	while MCS waits for a connect provider response from the node controller.
 */
typedef	struct
{
	TransportConnection		transport_connection;
	BOOL    				upward_connection;
	DomainParameters		domain_parameters;
	DomainParameters		minimum_domain_parameters;
	DomainParameters		maximum_domain_parameters;
} ConnectionPending;
typedef	ConnectionPending *				PConnectionPending;

/*
 *	This is the set of container definitions defined using templates.  All
 *	containers are based on classes in the Rogue Wave Tools.h++ class
 *	library.
 *
 *	The controller keeps a list of objects at each of the five levels, as
 *	follows:
 *
 *	DomainList
 *		This is a dictionary of currently existing domain objects, which is
 *		keyed by DomainSelector.
 *	CConnectionList2
 *		This is a dictionary of currently existing connection objects, which is
 *		keyed by connection handle.
 *	TransportList
 *		This is a dictionary of currently existing transport interface objects,
 *		which is keyed by transport identifier.  Note that the transport
 *		identifier is just a character string.
 *	ConnectionPendingList
 *		This is a dictionary of pending connections.  The key is the connection
 *		handle, and the value is a pointer to a connection pending structure
 *		that "remembers" details about a pending connection that are not
 *		going to be passed back in the connect provider response.
 *	ConnectionPollList
 *		This is a singly-linked list that is used to hold all connection
 *		objects.  This list is used to iterate through the list, granting a time
 *		slice to each object during the heartbeat.
 */
class CConnPendingList2 : public CList2
{
    DEFINE_CLIST2_(CConnPendingList2, PConnectionPending, ConnectionHandle)
};

class CConnPollList : public CList
{
    DEFINE_CLIST(CConnPollList, PConnection)
};

/*
 *	The controller makes extensive use of the owner callback mechanism to
 *	receive requests from the objects that it owns.  In order for the
 *	requests to be differentiated here in the controller, each object must
 *	issue its message using a different message offset.  The required message
 *	offset is given to each object as it is created by the controller.  The
 *	message offsets for the five layers of objects are as follows.
 *
 *	This allows the controller to easily determine what type of object a
 *	given owner callback message is from (see the implementation of the
 *	OwnerCallback member function for details).
 */
#define	APPLICATION_MESSAGE_BASE		0
#define	USER_MESSAGE_BASE				100
#define	DOMAIN_MESSAGE_BASE				200
#define	CONNECTION_MESSAGE_BASE			300
#ifndef TRANSPORT_MESSAGE_BASE
#define	TRANSPORT_MESSAGE_BASE			400
#endif  // !TRANSPORT_MESSAGE_BASE

/*
**	The following are timeout times that are used to set and test the
**	Controller_Wait_Timeout instance variable of a Controller object.
**	When the controller is signalled thru an event to process and send
**	msgs to an application, GCC, etc..., tries to process it. Sometimes
**	the event can't be processed immediately. In these cases, we make
**	the controller timeout in the WaitForMultipleObjects finite, and set
**	the Controller_Event_Mask to store which event we want to re-try
**	later. When the event is processed, the mask is reset.
*/
#define CONTROLLER_THREAD_TIMEOUT				200
#define TRANSPORT_RECEIVE_TIMEOUT				300
#define	TRANSPORT_TRANSMIT_TIMEOUT				10000

/*
**	The following are the indices in the arrays of masks and timeouts.
*/
#define TRANSPORT_RECEIVE_INDEX			0
#define	TRANSPORT_TRANSMIT_INDEX		1
#define GCC_FLUSH_OUTGOING_PDU_INDEX    3

/*
**	The following values are the masks used for checking against
**	the Controller_Event_Mask in the PollMCSDevices() member of the
**	MCS Controller.
*/
#define TRANSPORT_RECEIVE_MASK 			(0x1 << TRANSPORT_RECEIVE_INDEX)
#define	TRANSPORT_TRANSMIT_MASK 		(0x1 << TRANSPORT_TRANSMIT_INDEX)
#define GCC_FLUSH_OUTGOING_PDU_MASK     (0x1 << GCC_FLUSH_OUTGOING_PDU_INDEX)
#define TRANSPORT_MASK					(TRANSPORT_RECEIVE_MASK | TRANSPORT_TRANSMIT_MASK)

/*
 *	These are the owner callback functions that an application interface object
 *	can send to its creator (which is typically the MCS controller).  The
 *	first one allows an application interface object to tell the controller that
 *	it represents the interface to the node controller application.  The rest
 *	are primitives that would generally come from the node controller
 *	application, but must be acted upon internally by the MCS controller.
 *
 *	When an object instantiates an application interface object (or any other
 *	object that uses owner callbacks), it is accepting the responsibility of
 *	receiving and handling those callbacks.  For that reason, any object that
 *	issues owner callbacks will have those callbacks defined as part of the
 *	interface file (since they really are part of a bi-directional interface).
 *
 *	Each owner callback function, along with a description of how its parameters
 *	are packed, is described in the following section.
 */
#define	REGISTER_NODE_CONTROLLER			0
#define	RESET_DEVICE						1
#define	CREATE_DOMAIN						2
#define	DELETE_DOMAIN						3
#define	CONNECT_PROVIDER_REQUEST			4
#define	CONNECT_PROVIDER_RESPONSE			5
#define	DISCONNECT_PROVIDER_REQUEST			6
#define	APPLICATION_ATTACH_USER_REQUEST		7

/*
 *	These are the structures used by some of the owner callback function listed
 *	above (for the case that the parameters to a function cannot fit into two
 *	32-bit parameters).
 */

#ifdef NM_RESET_DEVICE
typedef	struct
{
	PChar					device_identifier;
} ResetDeviceInfo;
typedef	ResetDeviceInfo *		PResetDeviceInfo;
#endif // #ifdef NM_RESET_DEVICE

typedef	struct
{
	TransportAddress		local_address;
	PInt					local_address_length;
} LocalAddressInfo;
typedef	LocalAddressInfo *		PLocalAddressInfo;

typedef	struct
{
	GCCConfID              *calling_domain;
	GCCConfID              *called_domain;
	PChar					calling_address;
	PChar					called_address;
	BOOL					fSecure;
	BOOL    				upward_connection;
	PDomainParameters		domain_parameters;
	PUChar					user_data;
	ULong					user_data_length;
	PConnectionHandle		connection_handle;
} ConnectRequestInfo;
typedef	ConnectRequestInfo *	PConnectRequestInfo;

typedef	struct
{
	ConnectionHandle		connection_handle;
	GCCConfID              *domain_selector;
	PDomainParameters		domain_parameters;
	Result					result;
	PUChar					user_data;
	ULong					user_data_length;
} ConnectResponseInfo;
typedef	ConnectResponseInfo *	PConnectResponseInfo;

typedef	struct
{
	GCCConfID              *domain_selector;
	PUser					*ppuser;
} AttachRequestInfo;
typedef	AttachRequestInfo *		PAttachRequestInfo;

/*
 *	These structures are used to hold information that would not fit into
 *	the one parameter defined as part of an MCS call back function.  In the case
 *	where these structures are used for call backs, the address of the structure
 *	is passed as the only parameter.
 */
// LONCHANC: we dropped calling and called domain selectors here.
typedef struct
{
	ConnectionHandle	connection_handle;
	BOOL    			upward_connection;
	DomainParameters	domain_parameters;
	unsigned char  *	user_data;
	unsigned long		user_data_length;
	BOOL				fSecure;
} ConnectProviderIndication;
typedef	ConnectProviderIndication  *		PConnectProviderIndication;

typedef struct
{
	ConnectionHandle	connection_handle;
	DomainParameters	domain_parameters;
	Result				result;
	unsigned char  *	user_data;
	unsigned long		user_data_length;
	PBYTE               pb_cred;
	DWORD               cb_cred;
} ConnectProviderConfirm;
typedef	ConnectProviderConfirm  *		PConnectProviderConfirm;

/*
 *	This is the class definition for the Controller class.  It is worth
 *	noting that there are only three public member functions defined in the
 *	controller (besides the constructor and the destructor).  The Owner
 *	callback function is used by all "owned" objects to make requests
 *	of the controller (who created them).  The poll routine, which is
 *	called from the windows timer event handler.  This is the heartbeat
 *	of MCS at the current time.
 */
class	Controller : public CRefCount
{
public:
	Controller (
		PMCSError			mcs_error);
	~Controller ();

	Void		CreateTCPWindow ();
	Void		DestroyTCPWindow ();
	Void		EventLoop ();
	BOOL		FindSocketNumber(ConnectionHandle connection_handle, SOCKET * socket_number);
	BOOL    	GetLocalAddress(
						ConnectionHandle	connection_handle,
						TransportAddress	local_address,
						PInt				local_address_length);

    // the old owner callback
    void     HandleTransportDataIndication(PTransportData);
    void     HandleTransportWaitUpdateIndication(BOOL fMoreData);
#ifdef NM_RESET_DEVICE
    MCSError HandleAppletResetDevice(PResetDeviceInfo);
#endif
    MCSError HandleAppletCreateDomain(GCCConfID *domain_selector);
    MCSError HandleAppletDeleteDomain(GCCConfID *domain_selector);
    MCSError HandleAppletConnectProviderRequest(PConnectRequestInfo);
    MCSError HandleAppletConnectProviderResponse(PConnectResponseInfo);
    MCSError HandleAppletDisconnectProviderRequest(ConnectionHandle);
    MCSError HandleAppletAttachUserRequest(PAttachRequestInfo);
    void     HandleConnDeleteConnection(ConnectionHandle);
    void     HandleConnConnectProviderConfirm(PConnectConfirmInfo, ConnectionHandle);
    void     HandleTransportDisconnectIndication(TransportConnection, ULONG *pnNotify);
#ifdef TSTATUS_INDICATION
    void     HandleTransportStatusIndication(PTransportStatus);
#endif


private:

#ifdef NM_RESET_DEVICE
			ULong		ApplicationResetDevice (
								PChar				device_identifier);
#endif // NM_RESET_DEVICE
			MCSError	ApplicationCreateDomain(GCCConfID *domain_selector);
			MCSError	ApplicationDeleteDomain(GCCConfID *domain_selector);
			MCSError	ApplicationConnectProviderRequest (
								PConnectRequestInfo	pcriConnectRequestInfo);
			MCSError	ApplicationConnectProviderResponse (
								ConnectionHandle	connection_handle,
								GCCConfID          *domain_selector,
								PDomainParameters	domain_parameters,
								Result				result,
								PUChar				user_data,
								ULong				user_data_length);
			MCSError	ApplicationDisconnectProviderRequest (
								ConnectionHandle	connection_handle);
			MCSError	ApplicationAttachUserRequest (
								GCCConfID          *domain_selector,
								PUser				*ppUser);
			Void		ConnectionDeleteConnection (
								ConnectionHandle    connection_handle);
			void		ConnectionConnectProviderConfirm (
								ConnectionHandle    connection_handle,
								PDomainParameters	domain_parameters,
								Result				result,
								PMemory				memory);
			Void		TransportDisconnectIndication (
								TransportConnection	transport_connection);
			Void		TransportDataIndication (
								TransportConnection	transport_connection,
								PUChar				user_data,
								ULong				user_data_length);
#ifdef TSTATUS_INDICATION
			Void		TransportStatusIndication (
								PTransportStatus	transport_status);
#endif
			Void		ProcessConnectInitial (
								TransportConnection	transport_connection,
								ConnectInitialPDU *pdu_structure);
			Void		ProcessConnectAdditional (
								TransportConnection	transport_connection,
								ConnectAdditionalPDU *pdu_structure);
			Void		ConnectResponse (
								TransportConnection	transport_connection,
								Result				result,
								PDomainParameters	domain_parameters,
								ConnectID			connect_id,
								PUChar				user_data,
								ULong				user_data_length);
			Void		ConnectResult (
								TransportConnection	transport_connection,
								Result				result);
	ConnectionHandle	AllocateConnectionHandle ();
			Void		PollMCSDevices ();
			Void		UpdateWaitInfo (
								BOOL     			bMoreData,
								UINT        		index);

	ConnectionHandle		Connection_Handle_Counter;
	HANDLE					Transport_Transmit_Event;
	HANDLE					Connection_Deletion_Pending_Event;
	BOOL    				Controller_Closing;
	BOOL					m_fControllerThreadActive;

	CDomainList2			m_DomainList2;
	CConnectionList2		m_ConnectionList2;

	CConnPollList		    m_ConnPollList;
	CConnPendingList2       m_ConnPendingList2;

	CConnectionList2		m_ConnectionDeletionList2;
	BOOL    				Connection_Deletion_Pending;
	BOOL    				Domain_Traffic_Allowed;

	DWORD					Controller_Wait_Timeout;
	DWORD					Controller_Event_Mask;

#ifndef NO_TCP_TIMER
	UINT_PTR       			Timer_ID;
#endif	/* NO_TCP_TIMER */

public:
	HANDLE					Synchronization_Event;
};
typedef	Controller *			PController;

/*
 *	Controller (
 *			UShort					timer_duration,
 *			PMCSError				mcs_error)
 *
 *	Functional Description:
 *		This is the constructor for the MCS controller.  Its primary
 *		duty is to instantiate the application interface and transport
 *		interface objects that will be used by this provider.  These objects
 *		are static in that they are created by the controller constructor
 *		and destroyed by the controller destructor (below).  Unlike other
 *		objects in the system, they are NOT created and destroyed as needed.
 *
 *		The constructor also instantiates the memory manager that will be
 *		used throughout the MCS system.
 *
 *		The constructor also allocates a windows timer that is used to
 *		provide MCS with a "heartbeat".  This is VERY platform specific and
 *		will definitely change before final release.
 *
 *		Note that if anything goes wrong, the mcs_error variable will be
 *		set to the appropriate error.  It is assumed that whoever is creating
 *		the controller will check this return value and destroy the newly
 *		created controller if something is wrong.
 *
 *		Note that it is not possible to use MCS if there is not at least
 *		one application interface object successfully created.  However, it
 *		is possible to use MCS if there are no transport interfaces.  Multiple
 *		user applications could use this to communicate with one another.  On the
 *		other hand, MCS_NO_TRANSPORT_STACKS is considered a fatal error.
 *
 *	Formal Parameters:
 *		timer_duration (i)
 *			If non-zero, this causes the constructor to allocate a timer to
 *			provide the heartbeat, and this variable is in milliseconds.  If
 *			zero, no timer is allocated, and the application is responsible
 *			for providing the heartbeat.
 *		mcs_error (o)
 *			This is the return value for the constructor.  In C++ constructors
 *			cannot directly return a value, but this can be simulated by passing
 *			in the address of a return value variable.  This value should be
 *			checked by whoever creates the controller.  If it is anything but
 *			MCS_NO_ERROR, the controller should be
 *			deleted immediately, as this is a non-recoverable failure.
 *
 *	Return Value:
 *		MCS_NO_ERROR
 *			Everything worked fine, and the controller is ready to be used.
 *		MCS_NO_TRANSPORT_STACKS
 *			The controller initialized okay, but the TCP transport did
 *			not initialize.
 *		MCS_ALLOCATION_FAILURE
 *			MCS was unable to initialize properly due to a memory allocation
 *			failure.  The controller should be deleted immediately.
 *
 *	Side Effects:
 *		The proper initialization of the application interface and transport
 *		interface objects will probably cause device initializations to occur
 *		in readying for communication.
 *
 *	Caveats:
 *		None.
 */
/*
 *	~Controller ();
 *
 *	Functional Description:
 *		This is the controller destructor.  Its primary purpose is to free up
 *		all resources used by this MCS provider.  It attempts to destroy all
 *		objects in a controlled fashion so as to cleanly sever both user
 *		attachments and MCS connections.  It does this by destroying
 *		connections first, and then transport interfaces.  Next it deletes
 *		user attachments, followed by application interfaces.  Only then does
 *		it destroy existing domains (which should be empty as a result of all
 *		the previous destruction).
 *
 *		Note that this is the ONLY place where application interface and
 *		transport interface objects are destroyed.
 *
 *	Formal Parameters:
 *		Destructors have no parameters.
 *
 *	Return Value:
 *		Destructors have no return value.
 *
 *	Side Effects:
 *		All external connections are broken, and devices will be released.
 *
 *	Caveats:
 *		None.
 */

/*
 *	ULong		OwnerCallback (
 *						unsigned int			message,
 *						PVoid					parameter1,
 *						ULong					parameter2)
 *
 *	Functional Description:
 *		This is the owner callback routine for the MCS controller.  This member
 *		function is used when it is necessary for an object created by the
 *		controller to send a message back to it.
 *		Essentially, it allows objects to make requests of their creators
 *		without having to "tightly couple" the two classes by having them
 *		both aware of the public interface of the other.
 *
 *		When an object such as the controller creates an object that expects
 *		to use the owner callback facility, the creator is accepting the
 *		responsibility of handling owner callbacks.  All owner callbacks
 *		are defined as part of the interface specification for the object
 *		that will issue them.
 *
 *		How the controller handles each owner callback is considered an
 *		implementation issue within the controller.  As such, that information
 *		can be found in the controller implementation file.
 *
 *	Formal Parameters:
 *		message (i)
 *			This is the message to processed.  Note that when the controller
 *			creates each object, it gives it a message offset to use for owner
 *			callbacks, so that the controller can differentiate between
 *			callbacks from different classes.
 *		parameter1 (i)
 *			The meaning of this parameter varies according to the message being
 *			processed.  See the interface specification for the class issuing
 *			the owner callback for a detailed explanation.
 *		parameter2 (i)
 *			The meaning of this parameter varies according to the message being
 *			processed.  See the interface specification for the class issuing
 *			the owner callback for a detailed explanation.
 *
 *	Return Value:
 *		Each owner callback returns an unsigned long.  The meaning of this
 *		return value varies according to the message being processed.  See the
 *		interface specification for the class issuing the owner callback for a
 *		detailed explanation.
 *
 *	Side Effects:
 *		Message specific.
 *
 *	Caveats:
 *		None.
 */

#endif

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\remdsk\rds\t120\h\connect.h ===
/*
 *	connect.h
 *
 *	Copyright (c) 1993 - 1995 by DataBeam Corporation, Lexington, KY
 *
 *	Abstract:
 *		This is the interface file for the Connection class.  Instances of
 *		this class are used to connect CommandTarget objects within the local
 *		provider to CommandTarget objects in a remote provider.  This class
 *		inherits from CommandTarget, allowing it to communicate with other
 *		CommandTarget classes using their common MCS command language.
 *
 *		This class can be thought of as providing a Remote Procedure Call (RPC)
 *		facility between CommandTarget objects.  When an MCS command is sent
 *		to a Connection object, it encodes the command as a T.125 Protocol
 *		Data Unit (PDU) and sends it to a remote provider via the transport
 *		services provided by a TransportInterface object.  At the remote side
 *		The PDU is received by a Connection object who decodes the PDU, and
 *		issues the equivalent MCS command to the CommandTarget object that it is
 *		attached to.  The fact that the call crossed a transport connection
 *		in route to its destination is completely transparent to the object
 *		that initiated the command sequence.
 *
 *		The primary responsibility of this class is to convert MCS commands
 *		to T.125 PDUs and back again (as described above).  This class overrides
 *		all of the commands that are defined in class CommandTarget.
 *
 *		A secondary responsibility of this class is to provide flow control
 *		to and from the transport layer.  To do this is keeps a queue of PDUs
 *		that need to be transmitted (actually it keeps 4 queues, one for each
 *		data priority).  During each MCS heartbeat, all Connection objects are
 *		given the opportunity to flush PDUs from the queues.  If the transport
 *		layer returns an error, the PDU in question will be re-tried during
 *		the next heartbeat.  For data coming from the transport layer, this
 *		class provides code to allocate memory.  If an allocation fails, then
 *		an error will be returned to the transport layer, effectively telling
 *		it that it needs to retry that data indication during the next
 *		heartbeat.
 *
 *	Caveats:
 *		None.
 *
 *	Author:
 *		James P. Galvin, Jr.
 */
#ifndef	_CONNECTION_
#define	_CONNECTION_

/*
 *	These are the owner callback functions that a Connection object can send to
 *	its creator (which is typically the MCS controller).
 *
 *	When a class uses an instance of the Connection class (or any other class
 *	that can issue owner callbacks), it is accepting the responsibility of
 *	receiving and handling these callbacks.
 *
 *	Each owner callback function, along with a description of how its parameters
 *	are packed, is described in the following section.
 */
#define	DELETE_CONNECTION						0
#define	CONNECT_PROVIDER_CONFIRM				1

typedef	struct
{
	PDomainParameters	domain_parameters;
	Result				result;
	PMemory				memory;
} ConnectConfirmInfo;
typedef	ConnectConfirmInfo *		PConnectConfirmInfo;

/*
 *	Owner Callback:	DELETE_CONNECTION
 *	Parameter1:		PDisconnectProviderIndication
 *											disconnect_provider_indication
 *	Parameter2:		Unused
 *
 *	Usage:
 *		This owner callback will be issued if the Connection detects a situation
 *		is which it is no longer valid.  This can happen for several reasons:
 *		transmission or reception of a ConnectResult with a failed result
 *		code; transmission or reception of a DisconnectProviderUltimatum; or
 *		a Disconnect-Indication from the transport layer.
 */

/*
 *	Owner Callback:	CONNECT_PROVIDER_CONFIRM
 *	Parameter1:		PConnectConfirmInfo		connect_confirm_info
 *	Parameter2:		ConnectionHandle		connection_handle
 *
 *	Usage:
 *		This callback is issued when the connection object completes the
 *		building of a new MCS connection that was locally requested.  This is to
 *		inform the requester that the connection is ready for use.
 */

/*
 *	This enumeration dsefines the various states that a transport connection
 *	can be in at any given time.
 */
typedef	enum
{
	TRANSPORT_CONNECTION_UNASSIGNED,
	TRANSPORT_CONNECTION_PENDING,
	TRANSPORT_CONNECTION_READY
} TransportConnectionState;
typedef	TransportConnectionState *	PTransportConnectionState;


/*
 *	This is the class definition for class CommandTarget.
 */
class Connection : public CAttachment
{
public:

	Connection (
				PDomain				attachment,
				ConnectionHandle	connection_handle,
				GCCConfID          *calling_domain,
				GCCConfID          *called_domain,
				PChar				called_address,
				BOOL				fSecure,
				BOOL    			upward_connection,
				PDomainParameters	domain_parameters,
				PUChar				user_data,
				ULong				user_data_length,
				PMCSError			connection_error);
		Connection (
				PDomain				attachment,
				ConnectionHandle	connection_handle,
				TransportConnection	transport_connection,
				BOOL    			upward_connection,
				PDomainParameters	domain_parameters,
				PDomainParameters	min_domain_parameters,
				PDomainParameters	max_domain_parameters,
				PUChar				user_data,
				ULong				user_data_length,
				PMCSError			connection_error);
		~Connection ();

    void		RegisterTransportConnection (
				TransportConnection	transport_connection,
				Priority			priority);

private:

		Void		ConnectInitial (
							GCCConfID          *calling_domain,
							GCCConfID          *called_domain,
							BOOL    			upward_connection,
							PDomainParameters	domain_parameters,
							PDomainParameters	min_domain_parameters,
							PDomainParameters	max_domain_parameters,
							PUChar				user_data,
							ULong				user_data_length);
		Void		ConnectResponse (
							Result				result,
							PDomainParameters	domain_parameters,
							ConnectID			connect_id,
							PUChar				user_data,
							ULong				user_data_length);
		Void		ConnectAdditional (
							ConnectID			connect_id,
							Priority			priority);
		Void		ConnectResult (
							Result				result,
							Priority			priority);
		ULong		ProcessConnectResponse (
							PConnectResponsePDU	pdu_structure);
		Void		ProcessConnectResult (
							PConnectResultPDU	pdu_structure);
		Void		IssueConnectProviderConfirm (
							Result				result);
		Void		DestroyConnection (
							Reason				reason);
		Void		AssignRemainingTransportConnections ();
    TransportError	CreateTransportConnection (
							LPCTSTR				called_address,
							BOOL				fSecure,
							Priority			priority);
    TransportError	AcceptTransportConnection (
							TransportConnection	transport_connection,
							Priority			priority);
		Void		AdjustDomainParameters (
							PDomainParameters	min_domain_parameters,
							PDomainParameters	max_domain_parameters,
							PDomainParameters	domain_parameters);
		BOOL    	MergeDomainParameters (
							PDomainParameters	min_domain_parameters1,
							PDomainParameters	max_domain_parameters1,
							PDomainParameters	min_domain_parameters2,
							PDomainParameters	max_domain_parameters2);
#ifdef DEBUG
		Void		PrintDomainParameters (
							PDomainParameters	domain_parameters);
#endif // DEBUG

public:

		inline TransportConnection GetTransportConnection (UInt priority)
		{
			return (Transport_Connection[priority]);
		}

		virtual Void		PlumbDomainIndication (
									ULong				height_limit);
		Void		ErectDomainRequest (
									ULong				height_in_domain,
									ULong				throughput_interval);
		Void		RejectUltimatum (
									Diagnostic			diagnostic,
									PUChar				octet_string_address,
									ULong				octet_string_length);
		Void		MergeChannelsRequest (
									CChannelAttributesList *merge_channel_list,
									CChannelIDList         *purge_channel_list);
		Void		MergeChannelsConfirm (
									CChannelAttributesList *merge_channel_list,
									CChannelIDList         *purge_channel_list);
		virtual	Void		PurgeChannelsIndication (
									CUidList           *purge_user_list,
									CChannelIDList     *purge_channel_list);
		Void		MergeTokensRequest (
									CTokenAttributesList   *merge_token_list,
									CTokenIDList           *purge_token_list);
		Void		MergeTokensConfirm (
									CTokenAttributesList   *merge_token_list,
									CTokenIDList           *purge_token_list);
		virtual	Void		PurgeTokensIndication (
									PDomain             originator,
									CTokenIDList       *purge_token_ids);
		virtual	Void		DisconnectProviderUltimatum (
									Reason				reason);
		Void		AttachUserRequest ( void );
		virtual	Void		AttachUserConfirm (
									Result				result,
									UserID				uidInitiator);
		Void		DetachUserRequest (
									Reason				reason,
									CUidList           *user_id_list);
		virtual	Void		DetachUserIndication (
									Reason				reason,
									CUidList           *user_id_list);
		Void		ChannelJoinRequest (
									UserID				uidInitiator,
									ChannelID			channel_id);
		virtual	Void		ChannelJoinConfirm (
									Result				result,
									UserID				uidInitiator,
									ChannelID			requested_id,
									ChannelID			channel_id);
		Void		ChannelLeaveRequest (
									CChannelIDList     *channel_id_list);
		Void		ChannelConveneRequest (
									UserID				uidInitiator);
		virtual	Void		ChannelConveneConfirm (
									Result				result,
									UserID				uidInitiator,
									ChannelID			channel_id);
		Void		ChannelDisbandRequest (
									UserID				uidInitiator,
									ChannelID			channel_id);
		virtual	Void		ChannelDisbandIndication (
									ChannelID			channel_id);
		Void		ChannelAdmitRequest (
									UserID				uidInitiator,
									ChannelID			channel_id,
									CUidList           *user_id_list);
		virtual	Void		ChannelAdmitIndication (
									UserID				uidInitiator,
									ChannelID			channel_id,
									CUidList           *user_id_list);
		Void		ChannelExpelRequest (
									UserID				uidInitiator,
									ChannelID			channel_id,
									CUidList           *user_id_list);
		virtual	Void		ChannelExpelIndication (
									ChannelID			channel_id,
									CUidList           *user_id_list);
		Void		SendDataRequest ( PDataPacket data_packet )
					{
						QueueForTransmission ((PSimplePacket) data_packet,
											  data_packet->GetPriority());
					};
		virtual	Void		SendDataIndication (
									UINT,
									PDataPacket			data_packet)
								{
									QueueForTransmission ((PSimplePacket) data_packet, 
														  data_packet->GetPriority());
								};
		Void		TokenGrabRequest (
									UserID				uidInitiator,
									TokenID				token_id);
		virtual	Void		TokenGrabConfirm (
									Result				result,
									UserID				uidInitiator,
									TokenID				token_id,
									TokenStatus			token_status);
		Void		TokenInhibitRequest (
									UserID				uidInitiator,
									TokenID				token_id);
		virtual	Void		TokenInhibitConfirm (
									Result				result,
									UserID				uidInitiator,
									TokenID				token_id,
									TokenStatus			token_status);
		Void		TokenGiveRequest (
									PTokenGiveRecord	pTokenGiveRec);
		virtual Void		TokenGiveIndication (
									PTokenGiveRecord	pTokenGiveRec);
		Void		TokenGiveResponse (
									Result				result,
									UserID				receiver_id,
									TokenID				token_id);
		virtual Void		TokenGiveConfirm (
									Result				result,
									UserID				uidInitiator,
									TokenID				token_id,
									TokenStatus			token_status);
		Void		TokenReleaseRequest (
									UserID				uidInitiator,
									TokenID				token_id);
		virtual	Void		TokenReleaseConfirm (
									Result				result,
									UserID				uidInitiator,
									TokenID				token_id,
									TokenStatus			token_status);
		Void		TokenPleaseRequest (
									UserID				uidInitiator,
									TokenID				token_id);
		virtual Void		TokenPleaseIndication (
									UserID				uidInitiator,
									TokenID				token_id);
		Void		TokenTestRequest (
									UserID				uidInitiator,
									TokenID				token_id);
		virtual	Void		TokenTestConfirm (
									UserID				uidInitiator,
									TokenID				token_id,
									TokenStatus			token_status);
		virtual	Void		MergeDomainIndication (
									MergeStatus			merge_status);

private:

	Void		SendPacket (
						PVoid				pdu_structure,
						int					pdu_type,
						Priority			priority);
	Void		QueueForTransmission (
						PSimplePacket		packet,
						Priority			priority,
						BOOL    			bFlush = TRUE);
	BOOL    	FlushAMessage (
						PSimplePacket		packet,
						Priority			priority);
	Void		MergeChannelsRC (
						ASN1choice_t		choice,
						CChannelAttributesList *merge_channel_list,
						CChannelIDList         *purge_channel_list);
	Void		MergeTokensRC (
						ASN1choice_t		choice,
						CTokenAttributesList   *merge_token_list,
						CTokenIDList           *purge_token_list);
	Void		UserChannelRI (
						ASN1choice_t		choice,
						UINT				reason_userID,
						ChannelID			channel_id,
						CUidList           *user_id_list);

public:

	BOOL    	FlushMessageQueue();
	BOOL    	FlushPriority (
						Priority				priority);
	BOOL    	IsDomainTrafficAllowed() { return Domain_Traffic_Allowed; };

public:

    // the old owner callback
    TransportError  HandleDataIndication(PTransportData, TransportConnection);
    void            HandleBufferEmptyIndication(TransportConnection transport_connection);
    void            HandleConnectConfirm(TransportConnection transport_connection);
    void            HandleDisconnectIndication(TransportConnection transport_connection, ULONG *pnNotify);

    LPSTR       GetCalledAddress(void) { return m_pszCalledAddress; }

private:

	inline ULong	ProcessMergeChannelsRequest (
						PMergeChannelsRequestPDU	pdu_structure);
	inline ULong	ProcessMergeChannelsConfirm (
						PMergeChannelsConfirmPDU	pdu_structure);
	inline Void		ProcessPurgeChannelIndication (
						PPurgeChannelIndicationPDU	pdu_structure);
	inline ULong	ProcessMergeTokensRequest (
						PMergeTokensRequestPDU		pdu_structure);
	inline ULong	ProcessMergeTokensConfirm (
						PMergeTokensConfirmPDU		pdu_structure);
	inline Void		ProcessPurgeTokenIndication (
						PPurgeTokenIndicationPDU	pdu_structure);
	inline Void		ProcessDisconnectProviderUltimatum (
						PDisconnectProviderUltimatumPDU
													pdu_structure);
	inline Void		ProcessAttachUserRequest (
						PAttachUserRequestPDU		pdu_structure);
	inline Void		ProcessAttachUserConfirm (
						PAttachUserConfirmPDU		pdu_structure);
	inline Void		ProcessDetachUserRequest (
						PDetachUserRequestPDU		pdu_structure);
	inline Void		ProcessDetachUserIndication (
						PDetachUserIndicationPDU	pdu_structure);
	inline Void		ProcessChannelJoinRequest (
						PChannelJoinRequestPDU		pdu_structure);
	inline Void		ProcessChannelJoinConfirm (
						PChannelJoinConfirmPDU		pdu_structure);
	inline Void		ProcessChannelLeaveRequest (
						PChannelLeaveRequestPDU		pdu_structure);
	inline Void		ProcessChannelConveneRequest (
						PChannelConveneRequestPDU	pdu_structure);
	inline Void		ProcessChannelConveneConfirm (
						PChannelConveneConfirmPDU	pdu_structure);
	inline Void		ProcessChannelDisbandRequest (
						PChannelDisbandRequestPDU	pdu_structure);
	inline Void		ProcessChannelDisbandIndication (
						PChannelDisbandIndicationPDU
													pdu_structure);
	inline Void		ProcessChannelAdmitRequest (
						PChannelAdmitRequestPDU		pdu_structure);
	inline Void		ProcessChannelAdmitIndication (
						PChannelAdmitIndicationPDU	pdu_structure);
	inline Void		ProcessChannelExpelRequest (
						PChannelExpelRequestPDU		pdu_structure);
	inline Void		ProcessChannelExpelIndication (
						PChannelExpelIndicationPDU	pdu_structure);
	inline Void		ProcessSendDataRequest (
						PSendDataRequestPDU			pdu_structure,
						PDataPacket					packet);
	inline Void		ProcessSendDataIndication (
						PSendDataIndicationPDU		pdu_structure,
						PDataPacket					packet);
	inline Void		ProcessUniformSendDataRequest (
						PUniformSendDataRequestPDU	pdu_structure,
						PDataPacket					packet);
	inline Void		ProcessUniformSendDataIndication (
						PUniformSendDataIndicationPDU
													pdu_structure,
						PDataPacket					packet);
	inline Void		ProcessTokenGrabRequest (
						PTokenGrabRequestPDU		pdu_structure);
	inline Void		ProcessTokenGrabConfirm (
						PTokenGrabConfirmPDU		pdu_structure);
	inline Void		ProcessTokenInhibitRequest (
						PTokenInhibitRequestPDU		pdu_structure);
	inline Void		ProcessTokenInhibitConfirm (
						PTokenInhibitConfirmPDU		pdu_structure);
	inline Void		ProcessTokenReleaseRequest (
						PTokenReleaseRequestPDU		pdu_structure);
	inline Void		ProcessTokenReleaseConfirm (
						PTokenReleaseConfirmPDU		pdu_structure);
	inline Void		ProcessTokenTestRequest (
						PTokenTestRequestPDU		pdu_structure);
	inline Void		ProcessTokenTestConfirm (
						PTokenTestConfirmPDU		pdu_structure);
	inline Void		ProcessRejectUltimatum (
						PRejectUltimatumPDU			pdu_structure);
	inline Void		ProcessTokenGiveRequest (
						PTokenGiveRequestPDU		pdu_structure);
	inline Void		ProcessTokenGiveIndication (
						PTokenGiveIndicationPDU		pdu_structure);
	inline Void		ProcessTokenGiveResponse (
						PTokenGiveResponsePDU		pdu_structure);
	inline Void		ProcessTokenGiveConfirm (
						PTokenGiveConfirmPDU		pdu_structure);
	inline Void		ProcessTokenPleaseRequest (
						PTokenPleaseRequestPDU		pdu_structure);
	inline Void		ProcessTokenPleaseIndication (
						PTokenPleaseIndicationPDU	pdu_structure);
	inline Void		ProcessPlumbDomainIndication (
						PPlumbDomainIndicationPDU	pdu_structure);
	inline Void		ProcessErectDomainRequest (
						PErectDomainRequestPDU		pdu_structure);
	inline ULong 	ValidateConnectionRequest ();

private:

    LPSTR               m_pszCalledAddress;
	UINT        		Encoding_Rules;
	PDomain				m_pDomain;
	PDomain				m_pPendingDomain;
	ConnectionHandle	Connection_Handle;
	DomainParameters	Domain_Parameters;
	PMemory				Connect_Response_Memory;

	TransportConnection	Transport_Connection[MAXIMUM_PRIORITIES];
	int					Transport_Connection_PDU_Type[MAXIMUM_PRIORITIES];
	TransportConnectionState
						Transport_Connection_State[MAXIMUM_PRIORITIES];
	UINT				Transport_Connection_Count;
	CSimplePktQueue		m_OutPktQueue[MAXIMUM_PRIORITIES];

	Reason				Deletion_Reason;
	
	BOOL				Upward_Connection;
	BOOL				m_fSecure;
	BOOL    			Merge_In_Progress;
	BOOL    			Domain_Traffic_Allowed;
	BOOL    			Connect_Provider_Confirm_Pending;
};

/*
 *	ULong	ProcessMergeChannelsRequest()
 *
 *	Private
 *
 *	Functional Description:
 *		This routine processes the "MergeChannelsRequest" PDU's being received
 *		through the transport interface.  The pertinent data is read from the
 *		incoming packet and passed on to the domain.
 *
 *	Caveats:
 *		None.
 */
inline ULong Connection::ProcessMergeChannelsRequest ( 
									PMergeChannelsRequestPDU	pdu_structure)
{
	PChannelAttributes			channel_attributes;
	PSetOfChannelIDs			channel_ids;
	PSetOfUserIDs				user_ids;
	CUidList					admitted_list;
	CChannelAttributesList		merge_channel_list;
	CChannelIDList				purge_channel_list;
	PSetOfPDUChannelAttributes	merge_channels;
	BOOL    					first_set = TRUE;

	/*
	 *	Retrieve values from the decoded PDU structure and fill in the
	 *	parameters lists to be passed into the domain.
	 */
	merge_channels = pdu_structure->merge_channels;
	while (merge_channels != NULL)
	{
		DBG_SAVE_FILE_LINE
		channel_attributes = new ChannelAttributes;

		/*
		 *	Check to make to sure the memory allocation has succeeded.  If
		 *	the memory allocation fails we just return an error code which
		 *	results in the PDU being rejected so that it may be tried again
		 *	at a later time.  If subsequent allocations fail, we must first
		 *	free the memory for the successful allocations and then return.
		 */
		if (channel_attributes == NULL)
		{
			if (first_set)
				return (TRANSPORT_READ_QUEUE_FULL);
			else
			{
				while (NULL != (channel_attributes = merge_channel_list.Get()))
				{
					delete channel_attributes;
				}
				return (TRANSPORT_READ_QUEUE_FULL);
			}
		}

		switch (merge_channels->value.choice)
		{
			case CHANNEL_ATTRIBUTES_STATIC_CHOSEN:
				channel_attributes->channel_type = STATIC_CHANNEL;
				channel_attributes->u.static_channel_attributes.channel_id =
						merge_channels->value.u.
						channel_attributes_static.channel_id;
				break;

			case CHANNEL_ATTRIBUTES_USER_ID_CHOSEN:
				channel_attributes->channel_type = USER_CHANNEL;
				channel_attributes->u.user_channel_attributes.joined =
						merge_channels->value.u.
						channel_attributes_user_id.joined;
				channel_attributes->u.user_channel_attributes.user_id =
						(UShort)merge_channels->value.u.
						channel_attributes_user_id.user_id;
				break;

			case CHANNEL_ATTRIBUTES_PRIVATE_CHOSEN:
				channel_attributes->channel_type = PRIVATE_CHANNEL;
				user_ids = merge_channels->value.u.
						channel_attributes_private.admitted;
				channel_attributes->u.private_channel_attributes.joined =
						merge_channels->value.u.
						channel_attributes_private.joined;
				channel_attributes->u.private_channel_attributes.channel_id=
						(UShort)merge_channels->value.u.
						channel_attributes_private.channel_id;
				channel_attributes->u.private_channel_attributes.
						channel_manager = (UShort)merge_channels->
						value.u.channel_attributes_private.manager;

				/*
				 *	Retrieve all of the user ID's from the PDU structure and
				 *	put them into the list to be passed into the domain.
				 */
				while (user_ids != NULL)
				{
					admitted_list.Append(user_ids->value);
					user_ids = user_ids->next;
				}
				channel_attributes->u.private_channel_attributes.
						admitted_list =	&admitted_list;
				break;

			case CHANNEL_ATTRIBUTES_ASSIGNED_CHOSEN:
				channel_attributes->channel_type = ASSIGNED_CHANNEL;
				channel_attributes->u.assigned_channel_attributes.
						channel_id = (UShort)merge_channels->value.u.
						channel_attributes_assigned.channel_id;
				break;

			default:
				ERROR_OUT(("Connection::ProcessMergeChannelsRequest "
						"Bad channel attributes choice."));
				break;
		}
		/*
		 *	Put the channel attributes structure into the list to be passed
		 *	into the domain.  Retrieve the "next" merge channels structure.
		 */
		merge_channel_list.Append(channel_attributes);
		merge_channels = merge_channels->next;
	}

	/*
	 *	Retrieve all of the purge channel ID's from the PDU structure and
	 *	put them into the list to be passed into the domain.
	 */
	channel_ids = pdu_structure->purge_channel_ids;
	while (channel_ids != NULL)
	{
		purge_channel_list.Append(channel_ids->value);
		channel_ids = channel_ids->next;
	}

	m_pDomain->MergeChannelsRequest(this, &merge_channel_list, &purge_channel_list);

	/*
	 *	Free any memory which was allocated for the channel attributes
	 *	structures by setting up an iterator for the list of channel 
	 *	attributes and freeing the memory associated with each pointer.
	 */
	while (NULL != (channel_attributes = merge_channel_list.Get()))
	{
		delete channel_attributes;
	}
	return (TRANSPORT_NO_ERROR);
}

/*
 *	ULong	ProcessMergeChannelsConfirm()
 *
 *	Private
 *
 *	Functional Description:
 *		This routine processes the "MergeChannelsConfirm" PDU's being received
 *		through the transport interface.  The pertinent data is read from the
 *		incoming packet and passed on to the domain.
 *
 *	Caveats:
 *		None.
 */
inline ULong	Connection::ProcessMergeChannelsConfirm (
									PMergeChannelsConfirmPDU	pdu_structure)
{
	PChannelAttributes			channel_attributes;
	PSetOfChannelIDs			channel_ids;
	PSetOfUserIDs				user_ids;
	CUidList					admitted_list;
	CChannelAttributesList		merge_channel_list;
	CChannelIDList				purge_channel_list;
	PSetOfPDUChannelAttributes	merge_channels;
	BOOL    					first_set = TRUE;

	/*
	 *	Retrieve values from the decoded PDU structure and fill in the
	 *	parameters lists to be passed into the domain.
	 */
	merge_channels = pdu_structure->merge_channels;
	while (merge_channels != NULL)
	{
		DBG_SAVE_FILE_LINE
		channel_attributes = new ChannelAttributes;

		/*
		 *	Check to make to sure the memory allocation has succeeded.  If
		 *	the memory allocation fails we just return an error code which
		 *	results in the PDU being rejected so that it may be tried again
		 *	at a later time.  If subsequent allocations fail, we must first
		 *	free the memory for the successful allocations and then return.
		 */
		if (channel_attributes == NULL)
		{
			if (first_set)
				return (TRANSPORT_READ_QUEUE_FULL);
			else
			{
				while (NULL != (channel_attributes = merge_channel_list.Get()))
				{
					delete channel_attributes;
				}
				return (TRANSPORT_READ_QUEUE_FULL);
			}
		}

		switch (merge_channels->value.choice)
		{
			case CHANNEL_ATTRIBUTES_STATIC_CHOSEN:
					channel_attributes->channel_type = STATIC_CHANNEL;
					channel_attributes->u.static_channel_attributes.channel_id =
							merge_channels->value.u.
							channel_attributes_static.channel_id;
					break;

			case CHANNEL_ATTRIBUTES_USER_ID_CHOSEN:
					channel_attributes->channel_type = USER_CHANNEL;
					channel_attributes->u.user_channel_attributes.joined =
							merge_channels->value.u.
							channel_attributes_user_id.joined;
					channel_attributes->u.user_channel_attributes.user_id =
							(UShort)merge_channels->value.u.
							channel_attributes_user_id.user_id;
					break;

			case CHANNEL_ATTRIBUTES_PRIVATE_CHOSEN:
					channel_attributes->channel_type = PRIVATE_CHANNEL;
					user_ids = merge_channels->value.u.
							channel_attributes_private.admitted;

					channel_attributes->u.private_channel_attributes.joined =
							merge_channels->value.u.
							channel_attributes_private.joined;
					channel_attributes->u.private_channel_attributes.channel_id=
							(UShort)merge_channels->value.u.
							channel_attributes_private.channel_id;
					channel_attributes->u.private_channel_attributes.
							channel_manager = (UShort)merge_channels->
							value.u.channel_attributes_private.manager;

					/*
					 *	Retrieve all of the user ID's from the PDU structure and
					 *	put them into the list to be passed into the domain.
					 */
					while (user_ids != NULL)
					{
						admitted_list.Append(user_ids->value);
						user_ids = user_ids->next;
					}
					channel_attributes->u.private_channel_attributes.
							admitted_list =	&admitted_list;
					break;

			case CHANNEL_ATTRIBUTES_ASSIGNED_CHOSEN:
					channel_attributes->channel_type = ASSIGNED_CHANNEL;
					channel_attributes->u.assigned_channel_attributes.
							channel_id = (UShort)merge_channels->value.u.
							channel_attributes_assigned.channel_id;
					break;

			default:
					ERROR_OUT(("Connection::ProcessMergeChannelsConfirm "
							"Bad channel attributes choice."));
					break;
		}
		/*
		 *	Put the channel attributes structure into the list to be passed
		 *	into the domain.  Retrieve the "next" merge channels structure.
		 */
		merge_channel_list.Append(channel_attributes);
		merge_channels = merge_channels->next;
	}

	/*
	 *	Retrieve all of the purge channel ID's from the PDU structure and
	 *	put them into the list to be passed into the domain.
	 */
	channel_ids = pdu_structure->purge_channel_ids;
	while (channel_ids != NULL)
	{
		purge_channel_list.Append(channel_ids->value);
		channel_ids = channel_ids->next;
	}

	m_pDomain->MergeChannelsConfirm(this, &merge_channel_list, &purge_channel_list);

	/*
	 *	Free any memory which was allocated for the channel attributes
	 *	structures by setting up an iterator for the list of channel 
	 *	attributes and freeing the memory associated with each pointer.
	 */
	while (NULL != (channel_attributes = merge_channel_list.Get()))
	{
		delete channel_attributes;
	}
	return (TRANSPORT_NO_ERROR);
}

/*
 *	Void	ProcessPurgeChannelIndication()
 *
 *	Private
 *
 *	Functional Description:
 *		This routine processes the "PurgeChannelsIndication" PDU's being
 *		received through the transport interface.  The pertinent data is read
 *		from the incoming packet and passed on to the domain.
 *
 *	Caveats:
 *		None.
 */
inline Void	Connection::ProcessPurgeChannelIndication (
								PPurgeChannelIndicationPDU	 	pdu_structure)
{
	CUidList				purge_user_list;
	CChannelIDList			purge_channel_list;
	PSetOfChannelIDs		channel_ids;
	PSetOfUserIDs	   		user_ids;

	/*
	 *	Retrieve all of the purge user ID's from the PDU structure and put
	 *	them into the list to be passed into the domain.
	 */
	user_ids = pdu_structure->detach_user_ids;

	while (user_ids != NULL)
	{
		purge_user_list.Append(user_ids->value);
		user_ids = user_ids->next;
	}

	/*
	 *	Retrieve all of the purge channel ID's from the PDU structure and
	 *	put them into the list to be passed into the domain.
	 */
	channel_ids = pdu_structure->purge_channel_ids;
	while (channel_ids != NULL)
	{
		purge_channel_list.Append(channel_ids->value);
		channel_ids = channel_ids->next;
	}

	m_pDomain->PurgeChannelsIndication(this, &purge_user_list, &purge_channel_list);
}

/*
 *	ULong	ProcessMergeTokensRequest()
 *
 *	Private
 *
 *	Functional Description:
 *		This routine processes the "MergeTokenRequest" PDU's being received
 *		through the transport interface.  The pertinent data is read from the
 *		incoming packet and passed on to the domain.
 *
 *	Caveats:
 *		None.
 */
inline ULong	Connection::ProcessMergeTokensRequest (
								PMergeTokensRequestPDU			pdu_structure)
{
	PTokenAttributes			token_attributes;
	PSetOfTokenIDs				token_ids;
	PSetOfUserIDs				user_ids;
	CUidList					inhibited_list;
	CTokenAttributesList		merge_token_list;
	CTokenIDList				purge_token_list;
	PSetOfPDUTokenAttributes	merge_tokens;
	BOOL    					first_set = TRUE;

	/*
 	 *	Retrieve values from the decoded PDU structure and fill in the
 	 *	parameters lists to be passed into the domain.
 	 */
	merge_tokens = pdu_structure->merge_tokens;

	while (merge_tokens != NULL)
	{
		DBG_SAVE_FILE_LINE
		token_attributes = new TokenAttributes;

		/*
		 *	Check to make to sure the memory allocation has succeeded.  If
		 *	the memory allocation fails we just return an error code which
		 *	results in the PDU being rejected so that it may be tried again
		 *	at a later time.  If subsequent allocations fail, we must first
		 *	free the memory for the successful allocations and then return.
		 */
		if (token_attributes == NULL)
		{
			if (first_set)
				return (TRANSPORT_READ_QUEUE_FULL);
			else
			{
				while (NULL != (token_attributes = merge_token_list.Get()))
				{
					delete token_attributes;
				}
				return (TRANSPORT_READ_QUEUE_FULL);
			}
		}

		switch (merge_tokens->value.choice)
		{
			case GRABBED_CHOSEN:
					token_attributes->token_state = TOKEN_GRABBED;
					token_attributes->u.grabbed_token_attributes.token_id =
							(UShort)merge_tokens->value.u.
							grabbed.token_id;
					token_attributes->u.grabbed_token_attributes.grabber =
							(UShort)merge_tokens->
							value.u.grabbed.grabber;
				  break;

			case INHIBITED_CHOSEN:
					token_attributes->token_state = TOKEN_INHIBITED;
					user_ids = merge_tokens->value.u.
							inhibited.inhibitors;

					token_attributes->u.inhibited_token_attributes.token_id =
							(UShort)merge_tokens->
							value.u.inhibited.token_id;
					/*
					 *	Retrieve all of the user ID's from the PDU structure and 
					 *	put them into the list to be passed into the domain.
					 */
					while (user_ids != NULL)
					{
						inhibited_list.Append(user_ids->value);
						user_ids= user_ids->next;
					}
					token_attributes->u.inhibited_token_attributes.
							inhibitors = &inhibited_list;
					break;

			case GIVING_CHOSEN:
					token_attributes->token_state = TOKEN_GIVING;
					token_attributes->u.giving_token_attributes.token_id =
							(UShort)merge_tokens->
							value.u.giving.token_id;
					token_attributes->u.giving_token_attributes.grabber =
							(UShort)merge_tokens->
							value.u.giving.grabber;
					token_attributes->u.giving_token_attributes.recipient =
							(UShort)merge_tokens->value.u.giving.
							recipient;
					break;

			case GIVEN_CHOSEN:
					token_attributes->token_state = TOKEN_GIVEN;
					token_attributes->u.given_token_attributes.token_id =
							(UShort)merge_tokens->
							value.u.given.token_id;
					token_attributes->u.given_token_attributes.recipient =
							(UShort)merge_tokens->
							value.u.given.recipient;
					break;

			default:
					ERROR_OUT(("Connection::ProcessMergeTokensRequest "
							"Bad token attributes choice."));
					break;
		}
		/*
		 *	Put the token attributes structure into the list to be passed
		 *	into the domain.  We are only doing one channel attributes 
		 *	structures at a time for now.
		 */
		merge_token_list.Append(token_attributes);
		merge_tokens = merge_tokens->next;
	}

	/*
	 *	Retrieve all of the purge token ID's from the PDU structure and put
	 *	them into the list to be passed into the domain.
	 */
	token_ids = pdu_structure->purge_token_ids;
	while (token_ids != NULL)
	{
		purge_token_list.Append(token_ids->value);
		token_ids = token_ids->next;
	}

	m_pDomain->MergeTokensRequest(this, &merge_token_list, &purge_token_list);

	/*
	 *	Free any memory which was allocated for the token attributes
	 *	structures by setting up an iterator for the list of token 
	 *	attributes and freeing the memory associated with each pointer.
	 */
	while (NULL != (token_attributes = merge_token_list.Get()))
	{
		delete token_attributes;
	}
	return (TRANSPORT_NO_ERROR);
}

/*
 *	ULong	ProcessMergeTokensConfirm()
 *
 *	Private
 *
 *	Functional Description:
 *		This routine processes the "MergeTokenConfirm" PDU's being received
 *		through the transport interface.  The pertinent data is read from the
 *		incoming packet and passed on to the domain.
 *
 *	Caveats:
 *		None.
 */
inline ULong	Connection::ProcessMergeTokensConfirm (
								PMergeTokensConfirmPDU			pdu_structure)
{
	PTokenAttributes			token_attributes;
	PSetOfTokenIDs				token_ids;
	PSetOfUserIDs				user_ids;
	CUidList					inhibited_list;
	CTokenAttributesList		merge_token_list;
	CTokenIDList				purge_token_list;
	PSetOfPDUTokenAttributes	merge_tokens;
	BOOL    					first_set = TRUE;

	/*
 	 *	Retrieve values from the decoded PDU structure and fill in the
 	 *	parameters lists to be passed into the domain.
 	 */
	merge_tokens = pdu_structure->merge_tokens;

	while (merge_tokens != NULL)
	{
		DBG_SAVE_FILE_LINE
		token_attributes = new TokenAttributes;

		/*
		 *	Check to make to sure the memory allocation has succeeded.  If
		 *	the memory allocation fails we just return an error code which
		 *	results in the PDU being rejected so that it may be tried again
		 *	at a later time.  If subsequent allocations fail, we must first
		 *	free the memory for the successful allocations and then return.
		 */
		if (token_attributes == NULL)
		{
			if (first_set)
				return (TRANSPORT_READ_QUEUE_FULL);
			else
			{
				while (NULL != (token_attributes = merge_token_list.Get()))
				{
					delete token_attributes;
				}
				return (TRANSPORT_READ_QUEUE_FULL);
			}
		}

		switch (merge_tokens->value.choice)
		{
			case GRABBED_CHOSEN:
					token_attributes->token_state = TOKEN_GRABBED;
					token_attributes->u.grabbed_token_attributes.token_id =
							(UShort)merge_tokens->value.u.
							grabbed.token_id;
					token_attributes->u.grabbed_token_attributes.grabber =
							(UShort)merge_tokens->
							value.u.grabbed.grabber;
				  break;

			case INHIBITED_CHOSEN:
					token_attributes->token_state = TOKEN_INHIBITED;
					user_ids = merge_tokens->value.u.
							inhibited.inhibitors;

					token_attributes->u.inhibited_token_attributes.token_id =
							(UShort)merge_tokens->
							value.u.inhibited.token_id;
					/*
					 *	Retrieve all of the user ID's from the PDU structure and 
					 *	put them into the list to be passed into the domain.
					 */
					while (user_ids != NULL)
					{
						inhibited_list.Append(user_ids->value);
						user_ids = user_ids->next;
					}
					token_attributes->u.inhibited_token_attributes.
							inhibitors = &inhibited_list;
					break;

			case GIVING_CHOSEN:
					token_attributes->token_state = TOKEN_GIVING;
					token_attributes->u.giving_token_attributes.token_id =
							(UShort)merge_tokens->
							value.u.giving.token_id;
					token_attributes->u.giving_token_attributes.grabber =
							(UShort)merge_tokens->
							value.u.giving.grabber;
					token_attributes->u.giving_token_attributes.recipient =
							(UShort)merge_tokens->value.u.giving.
							recipient;
					break;

			case GIVEN_CHOSEN:
					token_attributes->token_state = TOKEN_GIVEN;
					token_attributes->u.given_token_attributes.token_id =
							(UShort)merge_tokens->
							value.u.given.token_id;
					token_attributes->u.given_token_attributes.recipient =
							(UShort)merge_tokens->
							value.u.given.recipient;
					break;

			default:
					ERROR_OUT(("Connection::ProcessMergeTokensConfirm "
							"Bad token attributes choice."));
					break;
		}
		/*
		 *	Put the token attributes structure into the list to be passed
		 *	into the domain.  We are only doing one channel attributes 
		 *	structures at a time for now.
		 */
		merge_token_list.Append(token_attributes);
		merge_tokens = merge_tokens->next;
	}

	/*
	 *	Retrieve all of the purge token ID's from the PDU structure and put
	 *	them into the list to be passed into the domain.
	 */
	token_ids = pdu_structure->purge_token_ids;
	while (token_ids != NULL)
	{
		purge_token_list.Append(token_ids->value);
		token_ids = token_ids->next;
	}

	m_pDomain->MergeTokensConfirm(this, &merge_token_list, &purge_token_list);

	/*
	 *	Free any memory which was allocated for the token attributes
	 *	structures by setting up an iterator for the list of token 
	 *	attributes and freeing the memory associated with each pointer.
	 */
	while (NULL != (token_attributes = merge_token_list.Get()))
	{
		delete token_attributes;
	}
	return (TRANSPORT_NO_ERROR);
}

/*
 *	Void	ProcessPurgeTokenIndication()
 *
 *	Private
 *
 *	Functional Description:
 *		This routine processes the "PurgeTokenIndication" PDU's being received
 *		through the transport interface.  The pertinent data is read from the
 *		incoming packet and passed on to the domain.
 *
 *	Caveats:
 *		None.
 */
inline Void	Connection::ProcessPurgeTokenIndication ( 
									PPurgeTokenIndicationPDU	pdu_structure)
{
	PSetOfTokenIDs			token_ids;
	CTokenIDList			purge_token_list;
	
	/*
	 *	Retrieve all of the purge token ID's from the PDU structure and put
	 *	them into the list to be passed into the domain.
	 */
	token_ids = pdu_structure->purge_token_ids;
	while (token_ids != NULL)
	{
		purge_token_list.Append(token_ids->value);
		token_ids = token_ids->next;
	}

	m_pDomain->PurgeTokensIndication(this, &purge_token_list);
}

/*
 *	Void	ProcessDisconnectProviderUltimatum()
 *
 *	Private
 *
 *	Functional Description:
 *		This routine processes the "DisconnectProviderUltimatum" PDU's being
 *		received through the transport interface.  The pertinent data is read
 *		from the incoming packet and passed on to the domain.
 *
 *	Caveats:
 *		None.
 */
inline Void	Connection::ProcessDisconnectProviderUltimatum (
						PDisconnectProviderUltimatumPDU			pdu_structure)
{
	TRACE_OUT(("Connection::ProcessDisconnectProviderUltimatum: PDU received"));

	m_pDomain->DisconnectProviderUltimatum(this, (Reason)pdu_structure->reason);
	m_pDomain = NULL;
}

/*
 *	Void	ProcessAttachUserRequest()
 *
 *	Private
 *
 *	Functional Description:
 *		This routine processes the "AttachUserRequest" PDU's being received
 *		through the transport interface by forwarding the request on to the
 *		domain.
 *
 *	Caveats:
 *		None.
 */
inline Void	Connection::ProcessAttachUserRequest (PAttachUserRequestPDU)
{
	m_pDomain->AttachUserRequest(this);
}

/*
 *	Void	ProcessAttachUserConfirm()
 *
 *	Private
 *
 *	Functional Description:
 *		This routine processes the "AttachUserConfirm" PDU's being received
 *		through the transport interface.  The pertinent data is read from the
 *		incoming packet and passed on to the domain.
 *
 *	Caveats:
 *		None.
 */
inline Void	Connection::ProcessAttachUserConfirm (
							PAttachUserConfirmPDU		pdu_structure)
{
	m_pDomain->AttachUserConfirm(this, (Result) pdu_structure->result,
	                                   (UserID) pdu_structure->initiator);
}

/*
 *	Void	ProcessDetachUserRequest()
 *
 *	Private
 *
 *	Functional Description:
 *		This routine processes the "DetachUserRequest" PDU's being received
 *		through the transport interface.  The pertinent data is read from the
 *		incoming packet and passed on to the domain.
 *
 *	Caveats:
 *		None.
 */
inline Void	Connection::ProcessDetachUserRequest (
								PDetachUserRequestPDU			pdu_structure)
{
	PSetOfUserIDs		user_ids;
	CUidList			user_id_list;

	/*
	 *	Retrieve the user ID's from the PDU structure and put them into the
	 *	list to be passed into the domain.
	 */
	user_ids = pdu_structure->user_ids;
	while (user_ids != NULL)
	{
		user_id_list.Append(user_ids->value);
		user_ids = user_ids->next;
	}

	m_pDomain->DetachUserRequest(this, (Reason) pdu_structure->reason, &user_id_list);
}

/*
 *	Void	ProcessDetachUserIndication()
 *
 *	Private
 *
 *	Functional Description:
 *		This routine processes the "DetachUserIndication" PDU's being received
 *		through the transport interface.  The pertinent data is read from the
 *		incoming packet and passed on to the domain.
 *
 *	Caveats:
 *		None.
 */
inline Void	Connection::ProcessDetachUserIndication (
									PDetachUserIndicationPDU	pdu_structure)
{
	PSetOfUserIDs		user_ids;
	CUidList			user_id_list;

	/*
	 *	Retrieve the user ID's from the PDU structure and put them into the
	 *	list to be passed into the domain.
	 */
	user_ids = pdu_structure->user_ids;
	while (user_ids != NULL)
	{
		user_id_list.Append(user_ids->value);
		user_ids = user_ids->next;
	}

	m_pDomain->DetachUserIndication(this, (Reason) pdu_structure->reason,
                                          &user_id_list);
}

/*
 *	Void	ProcessChannelJoinRequest()
 *
 *	Private
 *
 *	Functional Description:
 *		This routine processes the "ChannelJoinRequest" PDU's being received
 *		through the transport interface.  The pertinent data is read from the
 *		incoming packet and passed on to the domain.
 *
 *	Caveats:
 *		None.
 */
inline Void	Connection::ProcessChannelJoinRequest (
									PChannelJoinRequestPDU		pdu_structure)
{
	m_pDomain->ChannelJoinRequest(this, (UserID) pdu_structure->initiator,
                                        (ChannelID) pdu_structure->channel_id);
}

/*
 *	Void	ProcessChannelJoinConfirm()
 *
 *	Private
 *
 *	Functional Description:
 *		This routine processes the "ChannelJoinConfirm" PDU's being received
 *		through the transport interface.  The pertinent data is read from the
 *		incoming packet and passed on to the domain.
 *
 *	Caveats:
 *		None.
 */
inline Void	Connection::ProcessChannelJoinConfirm (
									PChannelJoinConfirmPDU		pdu_structure)
{
	m_pDomain->ChannelJoinConfirm(this, (Result) pdu_structure->result,
                                        (UserID) pdu_structure->initiator,
                                        (ChannelID) pdu_structure->requested,
                                        (ChannelID) pdu_structure->join_channel_id);
}

/*
 *	Void	ProcessChannelLeaveRequest()
 *
 *	Private
 *
 *	Functional Description:
 *		This routine processes the "ChannelLeaveRequest" PDU's being received
 *		through the transport interface.  The pertinent data is read from the
 *		incoming packet and passed on to the domain.
 *
 *	Caveats:
 *		None.
 */
inline Void	Connection::ProcessChannelLeaveRequest (
									PChannelLeaveRequestPDU		pdu_structure)
{
	PSetOfChannelIDs		channel_ids;
	CChannelIDList			channel_id_list;

	/*
	 *	Retrieve the channel ID's from the PDU structure and put them into
	 *	the list to be passed into the domain.
	 */
	channel_ids = pdu_structure->channel_ids;
	while (channel_ids != NULL)
	{
		channel_id_list.Append(channel_ids->value);
		channel_ids = channel_ids->next;
	}

	m_pDomain->ChannelLeaveRequest(this, &channel_id_list);
}

/*
 *	Void	ProcessChannelConveneRequest()
 *
 *	Private
 *
 *	Functional Description:
 *		This routine processes the "ChannelConveneRequest" PDU's being received
 *		through the transport interface.  The pertinent data is read from the
 *		incoming packet and passed on to the domain.
 *
 *	Caveats:
 *		None.
 */
inline Void	Connection::ProcessChannelConveneRequest (
									PChannelConveneRequestPDU	pdu_structure)
{
	m_pDomain->ChannelConveneRequest(this, (UserID) pdu_structure->initiator);
}

/*
 *	Void	ProcessChannelConveneConfirm ()
 *
 *	Private
 *
 *	Functional Description:
 *		This routine processes the "ChannelConveneConfirm" PDU's being received
 *		through the transport interface.  The pertinent data is read from the
 *		incoming packet and passed on to the domain.
 *
 *	Caveats:
 *		None.
 */
inline Void	Connection::ProcessChannelConveneConfirm (
									PChannelConveneConfirmPDU	pdu_structure)
{
	m_pDomain->ChannelConveneConfirm(this, (Result) pdu_structure->result,
                                           (UserID) pdu_structure->initiator,
                                           (ChannelID) pdu_structure->convene_channel_id);
}

/*
 *	Void	ProcessChannelDisbandRequest ()
 *
 *	Private
 *
 *	Functional Description:
 *		This routine processes the "ChannelDisbandRequest" PDU's being received
 *		through the transport interface.  The pertinent data is read from the
 *		incoming packet and passed on to the domain.
 *
 *	Caveats:
 *		None.
 */
inline Void	Connection::ProcessChannelDisbandRequest (
									PChannelDisbandRequestPDU	pdu_structure)
{
	m_pDomain->ChannelDisbandRequest(this, (UserID) pdu_structure->initiator,
                                           (ChannelID) pdu_structure->channel_id);
}

/*
 *	Void	ProcessChannelDisbandIndication ()
 *
 *	Private
 *
 *	Functional Description:
 *		This routine processes the "ChannelDisbandIndication" PDU's being
 *		received through the transport interface.  The pertinent data is read
 *		from the incoming packet and passed on to the domain.
 *
 *	Caveats:
 *		None.
 */
inline Void	Connection::ProcessChannelDisbandIndication (
								PChannelDisbandIndicationPDU	pdu_structure)
{
	m_pDomain->ChannelDisbandIndication(this, (ChannelID) pdu_structure->channel_id);
}

/*
 *	Void	ProcessChannelAdmitRequest ()
 *
 *	Private
 *
 *	Functional Description:
 *		This routine processes the "ChannelAdmitRequest" PDU's being received
 *		through the transport interface.  The pertinent data is read from the
 *		incoming packet and passed on to the domain.
 *
 *	Caveats:
 *		None.
 */
inline Void	Connection::ProcessChannelAdmitRequest (
									PChannelAdmitRequestPDU		pdu_structure)
{
	PSetOfUserIDs		user_ids;
	CUidList			user_id_list;

	/*
	 *	Retrieve the user ID's from the PDU structure and put them into the
	 *	list to be passed into the domain.
	 */
	user_ids = pdu_structure->user_ids;
	while (user_ids != NULL)
	{
		user_id_list.Append(user_ids->value);
		user_ids = user_ids->next;
	}

	m_pDomain->ChannelAdmitRequest(this, (UserID) pdu_structure->initiator,
                                         (ChannelID) pdu_structure->channel_id,
                                         &user_id_list);
}

/*
 *	Void	ProcessChannelAdmitIndication ()
 *
 *	Private
 *
 *	Functional Description:
 *		This routine processes the "ChannelAdmitIndication" PDU's being received
 *		through the transport interface.  The pertinent data is read from the
 *		incoming packet and passed on to the domain.
 *
 *	Caveats:
 *		None.
 */
inline Void	Connection::ProcessChannelAdmitIndication (
								PChannelAdmitIndicationPDU		pdu_structure)
{
	PSetOfUserIDs		user_ids;
	CUidList			user_id_list;

	/*
	 *	Retrieve the user ID's from the PDU structure and put them into the
	 *	list to be passed into the domain.
	 */
	user_ids = pdu_structure->user_ids;
	while (user_ids != NULL)
	{
		user_id_list.Append(user_ids->value);
		user_ids = user_ids->next;
	}

	m_pDomain->ChannelAdmitIndication(this, (UserID) pdu_structure->initiator,
                                            (ChannelID) pdu_structure->channel_id,
                                            &user_id_list);
}

/*
 *	Void	ProcessChannelExpelRequest ()
 *
 *	Private
 *
 *	Functional Description:
 *		This routine processes the "ChannelExpelRequest" PDU's being received
 *		through the transport interface.  The pertinent data is read from the
 *		incoming packet and passed on to the domain.
 *
 *	Caveats:
 *		None.
 */
inline Void	Connection::ProcessChannelExpelRequest (
							PChannelExpelRequestPDU				pdu_structure)
{
	PSetOfUserIDs		user_ids;
	CUidList			user_id_list;

	/*
	 *	Retrieve the user ID's from the PDU structure and put them into the
	 *	list to be passed into the domain.
	 */
	user_ids = pdu_structure->user_ids;
	while (user_ids != NULL)
	{
		user_id_list.Append(user_ids->value);
		user_ids = user_ids->next;
	}

	m_pDomain->ChannelExpelRequest(this, (UserID) pdu_structure->initiator,
                                         (ChannelID) pdu_structure->channel_id,
                                         &user_id_list);
}

/*
 *	Void	ProcessChannelExpelIndication ()
 *
 *	Private
 *
 *	Functional Description:
 *		This routine processes the "ChannelExpelIndication" PDU's being received
 *		through the transport interface.  The pertinent data is read from the
 *		incoming packet and passed on to the domain.
 *
 *	Caveats:
 *		None.
 */
inline Void	Connection::ProcessChannelExpelIndication (
								PChannelExpelIndicationPDU		pdu_structure)
{
	PSetOfUserIDs		user_ids;
	CUidList			user_id_list;

	/*
	 *	Retrieve the user ID's from the PDU structure and put them into the
	 *	list to be passed into the domain.
	 */
	user_ids = pdu_structure->user_ids;
	while (user_ids != NULL)
	{
		user_id_list.Append(user_ids->value);
		user_ids = user_ids->next;
	}

	m_pDomain->ChannelExpelIndication(this, (ChannelID) pdu_structure->channel_id,
                                            &user_id_list);
}

/*
 *	Void	ProcessSendDataRequest()
 *
 *	Private
 *
 *	Functional Description:
 *		This routine processes the "SendDataRequest" PDU's being received
 *		through the transport interface.  The pertinent data is read from the
 *		incoming packet and passed on to the domain.
 *
 *	Caveats:
 *		None.
 */
inline Void	Connection::ProcessSendDataRequest (
									PSendDataRequestPDU			pdu_structure,
									PDataPacket					packet)
{	
	m_pDomain->SendDataRequest(this, MCS_SEND_DATA_INDICATION, packet);
}

/*
 *	Void	ProcessSendDataIndication()
 *
 *	Private
 *
 *	Functional Description:
 *		This routine processes the "SendDataIndication" PDU's being received
 *		through the transport interface.  The pertinent data is read from the
 *		incoming packet and passed on to the domain.
 *
 *	Caveats:
 *		None.
 */
inline Void	Connection::ProcessSendDataIndication (
									PSendDataIndicationPDU		pdu_structure,
									PDataPacket					data_packet)
{	
	m_pDomain->SendDataIndication(this, MCS_SEND_DATA_INDICATION, data_packet);
}

/*
 *	Void	ProcessUniformSendDataRequest()
 *
 *	Private
 *
 *	Functional Description:
 *		This routine processes the "UniformSendDataRequest" PDU's being received
 *		through the transport interface.  The pertinent data is read from the
 *		incoming packet and passed on to the domain.
 *
 *	Caveats:
 *		None.
 */
inline Void	Connection::ProcessUniformSendDataRequest (
									PUniformSendDataRequestPDU	pdu_structure,
									PDataPacket					packet)
{	
	m_pDomain->SendDataRequest(this, MCS_UNIFORM_SEND_DATA_INDICATION, packet);
}

/*
 *	Void	ProcessUniformSendDataIndication()
 *
 *	Private
 *
 *	Functional Description:
 *		This routine processes the "UniformSendDataIndication" PDU's being
 *		received through the transport interface.  The pertinent data is read
 *		from the incoming packet and passed on to the domain.
 *
 *	Caveats:
 *		None.
 */
inline Void	Connection::ProcessUniformSendDataIndication (
								PUniformSendDataIndicationPDU	pdu_structure,
								PDataPacket						data_packet)
{	
	m_pDomain->SendDataIndication(this, MCS_UNIFORM_SEND_DATA_INDICATION, data_packet);
}

/*
 *	Void	ProcessTokenGrabRequest()
 *
 *	Private
 *
 *	Functional Description:
 *		This routine processes the "TokenGrabRequest" PDU's being received
 *		through the transport interface.  The pertinent data is read from the
 *		incoming packet and passed on to the domain.
 *
 *	Caveats:
 *		None.
 */
inline Void	Connection::ProcessTokenGrabRequest (
									PTokenGrabRequestPDU		pdu_structure)
{
	m_pDomain->TokenGrabRequest(this, (UserID) pdu_structure->initiator,
                                      (TokenID) pdu_structure->token_id);
}

/*
 *	Void	ProcessTokenGrabConfirm()
 *
 *	Private
 *
 *	Functional Description:
 *		This routine processes the "TokenGrabConfirm" PDU's being received
 *		through the transport interface.  The pertinent data is read from the
 *		incoming packet and passed on to the domain.
 *
 *	Caveats:
 *		None.
 */
inline Void	Connection::ProcessTokenGrabConfirm (
									PTokenGrabConfirmPDU		pdu_structure)
{
	m_pDomain->TokenGrabConfirm(this, (Result) pdu_structure->result,
                                      (UserID) pdu_structure->initiator,
                                      (TokenID) pdu_structure->token_id,
                                      (TokenStatus)pdu_structure->token_status);
}

/*
 *	Void	ProcessTokenInhibitRequest()
 *
 *	Private
 *
 *	Functional Description:
 *		This routine processes the "TokenInhibitRequest" PDU's being received
 *		through the transport interface.  The pertinent data is read from the
 *		incoming packet and passed on to the domain.
 *
 *	Caveats:
 *		None.
 */
inline Void	Connection::ProcessTokenInhibitRequest (
									PTokenInhibitRequestPDU		pdu_structure)
{
	m_pDomain->TokenInhibitRequest(this, (UserID) pdu_structure->initiator,
                                         (TokenID) pdu_structure->token_id);
}

/*
 *	Void	ProcessTokenInhibitConfirm()
 *
 *	Private
 *
 *	Functional Description:
 *		This routine processes the "TokenInhibitConfirm" PDU's being received
 *		through the transport interface.  The pertinent data is read from the
 *		incoming packet and passed on to the domain.
 *
 *	Caveats:
 *		None.
 */
inline Void	Connection::ProcessTokenInhibitConfirm (
									PTokenInhibitConfirmPDU		pdu_structure)
{
	m_pDomain->TokenInhibitConfirm(this, (Result) pdu_structure->result,
                                         (UserID) pdu_structure->initiator,
                                         (TokenID) pdu_structure->token_id,
                                         (TokenStatus)pdu_structure->token_status);
}

/*
 *	Void	ProcessTokenReleaseRequest()
 *
 *	Private
 *
 *	Functional Description:
 *		This routine processes the "TokenReleaseRequest" PDU's being received
 *		through the transport interface.  The pertinent data is read from the
 *		incoming packet and passed on to the domain.
 *
 *	Caveats:
 *		None.
 */
inline Void	Connection::ProcessTokenReleaseRequest (
									PTokenReleaseRequestPDU		pdu_structure)
{
	m_pDomain->TokenReleaseRequest(this, (UserID) pdu_structure->initiator,
                                         (TokenID) pdu_structure->token_id);
}

/*
 *	Void	ProcessTokenReleaseConfirm()
 *
 *	Private
 *
 *	Functional Description:
 *		This routine processes the "TokenReleaseConfirm" PDU's being received
 *		through the transport interface.  The pertinent data is read from the
 *		incoming packet and passed on to the domain.
 *
 *	Caveats:
 *		None.
 */
inline Void	Connection::ProcessTokenReleaseConfirm (
									PTokenReleaseConfirmPDU		pdu_structure)
{
	m_pDomain->TokenReleaseConfirm(this, (Result) pdu_structure->result,
                                         (UserID) pdu_structure->initiator,
                                         (TokenID) pdu_structure->token_id,
                                         (TokenStatus)pdu_structure->token_status);
}

/*
 *	Void	ProcessTokenTestRequest()
 *
 *	Private
 *
 *	Functional Description:
 *		This routine processes the "TokenTestRequest" PDU's being received
 *		through the transport interface.  The pertinent data is read from the
 *		incoming packet and passed on to the domain.
 *
 *	Caveats:
 *		None.
 */
inline Void	Connection::ProcessTokenTestRequest (
									PTokenTestRequestPDU		pdu_structure)
{
	m_pDomain->TokenTestRequest(this, (UserID) pdu_structure->initiator,
                                      (TokenID) pdu_structure->token_id);
}

/*
 *	Void	ProcessTokenTestConfirm()
 *
 *	Private
 *
 *	Functional Description:
 *		This routine processes the "TokenTestConfirm" PDU's being received
 *		through the transport interface.  The pertinent data is read from the
 *		incoming packet and passed on to the domain.
 *
 *	Caveats:
 *		None.
 */
inline Void	Connection::ProcessTokenTestConfirm (
									PTokenTestConfirmPDU		pdu_structure)
{
	m_pDomain->TokenTestConfirm(this, (UserID) pdu_structure->initiator,
                                      (TokenID) pdu_structure->token_id,
                                      (TokenStatus)pdu_structure->token_status);
}

/*
 *	Void	ProcessRejectUltimatum()
 *
 *	Private
 *
 *	Functional Description:
 *		This routine processes the "RejectUltimatum" PDU's being received
 *		through the transport interface.  The pertinent data is read from the
 *		incoming packet and passed on to the domain.
 *
 *	Caveats:
 *		None.
 */
inline Void	Connection::ProcessRejectUltimatum (
									PRejectUltimatumPDU			pdu_structure)
{
	m_pDomain->RejectUltimatum(this,
				pdu_structure->diagnostic,
				pdu_structure->initial_octets.value,
				(ULong) pdu_structure->initial_octets.length);
}

/*
 *	Void	ProcessTokenGiveRequest()
 *
 *	Private
 *
 *	Functional Description:
 *		This routine processes the "TokenGiveRequest" PDU's being received
 *		through the transport interface.  The pertinent data is read from the
 *		incoming packet and passed on to the domain.
 *
 *	Caveats:
 *		None.
 */
inline Void	Connection::ProcessTokenGiveRequest (
									PTokenGiveRequestPDU		pdu_structure)
{
		TokenGiveRecord		TokenGiveRec;

	// Fill in the TokenGive record
	TokenGiveRec.uidInitiator = pdu_structure->initiator;
	TokenGiveRec.token_id = pdu_structure->token_id;
	TokenGiveRec.receiver_id = pdu_structure->recipient;
	m_pDomain->TokenGiveRequest(this, &TokenGiveRec);
}

/*
 *	Void	ProcessTokenGiveIndication()
 *
 *	Private
 *
 *	Functional Description:
 *		This routine processes the "TokenGiveIndication" PDU's being received
 *		through the transport interface.  The pertinent data is read from the
 *		incoming packet and passed on to the domain.
 *
 *	Caveats:
 *		None.
 */
inline Void	Connection::ProcessTokenGiveIndication (
									PTokenGiveIndicationPDU		pdu_structure)
{
		TokenGiveRecord		TokenGiveRec;

	// Fill in the TokenGive record
	TokenGiveRec.uidInitiator = pdu_structure->initiator;
	TokenGiveRec.token_id = pdu_structure->token_id;
	TokenGiveRec.receiver_id = pdu_structure->recipient;
	m_pDomain->TokenGiveIndication(this, &TokenGiveRec);
}

/*
 *	Void	ProcessTokenGiveResponse()
 *
 *	Private
 *
 *	Functional Description:
 *		This routine processes the "TokenGiveResponse" PDU's being received
 *		through the transport interface.  The pertinent data is read from the
 *		incoming packet and passed on to the domain.
 *
 *	Caveats:
 *		None.
 */
inline Void	Connection::ProcessTokenGiveResponse (
									PTokenGiveResponsePDU		pdu_structure)
{
	m_pDomain->TokenGiveResponse(this, (Result) pdu_structure->result,
                                       (UserID) pdu_structure->recipient,
                                       (TokenID) pdu_structure->token_id);
}

/*
 *	Void	ProcessTokenGiveConfirm()
 *
 *	Private
 *
 *	Functional Description:
 *		This routine processes the "TokenGiveConfirm" PDU's being received
 *		through the transport interface.  The pertinent data is read from the
 *		incoming packet and passed on to the domain.
 *
 *	Caveats:
 *		None.
 */
inline Void	Connection::ProcessTokenGiveConfirm (
									PTokenGiveConfirmPDU		pdu_structure)
{
	m_pDomain->TokenGiveConfirm(this, (Result) pdu_structure->result,
                                      (UserID) pdu_structure->initiator,
                                      (TokenID) pdu_structure->token_id,
                                      (TokenStatus)pdu_structure->token_status);
}

/*
 *	Void	ProcessTokenPleaseRequest()
 *
 *	Private
 *
 *	Functional Description:
 *		This routine processes the "TokenPleaseRequest" PDU's being received
 *		through the transport interface.  The pertinent data is read from the
 *		incoming packet and passed on to the domain.
 *
 *	Caveats:
 *		None.
 */
inline Void	Connection::ProcessTokenPleaseRequest (
									PTokenPleaseRequestPDU		pdu_structure)
{
	m_pDomain->TokenPleaseRequest(this, (UserID) pdu_structure->initiator,
                                        (TokenID) pdu_structure->token_id);
}

/*
 *	Void	ProcessTokenPleaseIndication()
 *
 *	Private
 *
 *	Functional Description:
 *		This routine processes the "TokenPleaseIndication" PDU's being received
 *		through the transport interface.  The pertinent data is read from the
 *		incoming packet and passed on to the domain.
 *
 *	Caveats:
 *		None.
 */
inline Void	Connection::ProcessTokenPleaseIndication (
									PTokenPleaseIndicationPDU	pdu_structure)
{
	m_pDomain->TokenPleaseIndication(this, (UserID) pdu_structure->initiator,
                                           (TokenID) pdu_structure->token_id);
}

/*
 *	Void	ProcessPlumbDomainIndication()
 *
 *	Private
 *
 *	Functional Description:
 *		This routine processes the "PlumbDomainIndication" PDU's being received
 *		through the transport interface.  The pertinent data is read from the
 *		incoming packet and passed on to the domain.
 *
 *	Caveats:
 *		None.
 */
inline Void	Connection::ProcessPlumbDomainIndication (
									PPlumbDomainIndicationPDU	pdu_structure)
{
	m_pDomain->PlumbDomainIndication(this, pdu_structure->height_limit);
}

/*
 *	Void	ProcessErectDomainRequest()
 *
 *	Private
 *
 *	Functional Description:
 *		This routine processes the "ErectDomainRequest" PDU's being received
 *		through the transport interface.  The pertinent data is read from the
 *		incoming packet and passed on to the domain.
 *
 *	Caveats:
 *		None.
 */
inline Void	Connection::ProcessErectDomainRequest (
									PErectDomainRequestPDU		pdu_structure)
{
	m_pDomain->ErectDomainRequest(this, pdu_structure->sub_height,
                                        pdu_structure->sub_interval);
}

/*
 *	ULong	ValidateConnectionRequest ()
 *
 *	Private
 *
 *	Functional Description:
 *		This function is used to determine if it is valid to process an incoming
 *		request at the current time.  It checks several different conditions
 *		to determine this, as follows:
 *
 *		- If there is a merge in progress, then the request is not valid.
 *		- If this MCS connection is not yet bound to a domain, then the request
 *		  is not valid.
 *		- If there are not enough objects of the Memory, Packet, or UserMessage
 *		  class to handle a reasonable request, then the request is not valid.
 *
 *		Note that the check on number of objects is not an absolute guarantee
 *		that there will be enough to handle a given request, because a request
 *		can result in MANY PDUs and user messages being generated.  For example,
 *		a single channel admit request can result in lots of channel admit
 *		indications being sent.  However, checking against a minimum number
 *		of objects can reduce the possibility of failure to be astronomically
 *		low.  And remember, even if MCS runs out of something while processing
 *		such a request, it WILL handle it properly (by cleanly destroying the
 *		user attachment or MCS connection upon which the failure occurred).  So
 *		there is no chance of MCS crashing as a result of this.
 *
 *	Caveats:
 *		None.
 */
inline ULong	Connection::ValidateConnectionRequest ()
{
	ULong				return_value;

	/*
	 *	Check to see if there is a domain merger in progress.
	 */
	if (Merge_In_Progress == FALSE)
	{
		/*
		 *	Make sure that this MCS connection is bound to a domain.
		 */
		if (m_pDomain != NULL)
		{
			/*
			 *	Everything is okay, so the request is to be permitted.
			 */
			return_value = TRANSPORT_NO_ERROR;
		}
		else
		{
			/*
			 *	We are not yet attached to a domain.
			 */
			TRACE_OUT (("Connection::ValidateConnectionRequest: "
					"not attached to a domain"));
			return_value = TRANSPORT_READ_QUEUE_FULL;
		}
	}
	else
	{
		/*
		 *	There is a domain merge in progress.
		 */
		WARNING_OUT (("Connection::ValidateConnectionRequest: "
				"domain merger in progress"));
		return_value = TRANSPORT_READ_QUEUE_FULL;
	}

	return (return_value);
}

/*
 *	Connection (
 *				PCommandTarget		attachment,
 *				ConnectionHandle	connection_handle,
 *				PUChar				calling_domain,
 *				UINT				calling_domain_length,
 *				PUChar				called_domain,
 *				UINT				called_domain_length,
 *				PChar				calling_address,
 *				PChar				called_address,
 *				BOOL    			upward_connection,
 *				PDomainParameters	domain_parameters,
 *				PUChar				user_data,
 *				ULong				user_data_length,
 *				PMCSError			connection_error)
 *
 *	Functional Description:
 *		This is a constructor for the Connection class.  This constructor
 *		is used for creating outbound connections.  It initializes private
 *		instance variables and calls the transport interface to set up a
 *		transport connection and register this connection object (through a
 *		callback structure) with the transport object.
 *
 *	Formal Parameters:
 *		packet_coder
 *			This is the coder which is used by the connection object to encode
 *			PDU's into, and decode PDU's from, ASN.1 compliant byte streams.
 *		attachment
 *			The Domain to which this connection object is attached.
 *		connection_handle
 *			The handle which uniquely identifies this connection object.
 *		owner_object
 *			This is a pointer to the owner of this connection object (typically
 *			the MCS Controller) which allows this connection to communicate with
 *			the owner through callbacks. 
 *		owner_message_base
 *			This is the base value to which offsets are added to identify which
 *			callback routine in the owner object this connection is calling.
 *		calling_domain
 *			This is a pointer to an ASCII string which contains the name of the
 *			domain to which this connection object is attached.
 *		calling_domain_length
 *			The length of the ASCII string which is the name of domain to which
 *			this connection object is attached.
 *		called_domain
 *			This is a pointer to an ASCII string which contains the name of the
 *			remote domain with which this connection will communicate.
 *		called_domain_length
 *			The length of the ASCII string which is the name of the remote
 *			domain.
 *		calling_address
 *			The transport address of the caller.
 *		called_address
 *			The transport address of the party being called.
 *		upward_connection
 *			This is a boolean flag which indicates whether this is an upward
 *			connection or a downward connection.
 *		domain_parameters
 *			This is the set of parameters which describes the local domain.
 *		user_data
 *			This is a pointer to a buffer containing data which is sent to the
 *			remote provider through the "ConnectInitial" PDU.
 *		user_data_length
 *			The length of the user data described above.
 *		connection_error
 *			A return parameter which indicates any errors which may have 
 *			occurred in construction of the connection object.
 *
 *	Return Value:
 *		MCS_NO_ERROR			The connection was created successfully.
 *		MCS_TRANSPORT_FAILED	An error occurred in creating the transport
 *									connection.
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

/*
 *	Connection (
 *				PCommandTarget		attachment,
 *				ConnectionHandle	connection_handle,
 *				TransportConnection	transport_connection,
 *				BOOL    			upward_connection,
 *				PDomainParameters	domain_parameters,
 *				PDomainParameters	min_domain_parameters,
 *				PDomainParameters	max_domain_parameters,
 *				PUChar				user_data,
 *				ULong				user_data_length,
 *				PMCSError			connection_error)
 *
 *	Functional Description:
 *		This is a constructor for the Connection class.  This constructor is 
 *		used for creating inbound connections and is called when a transport
 *		connection already exists.  It initializes private instance variables
 *		and calls the transport interface to register this connection object 
 *		(through a callback structure) with the transport object.
 *
 *	Formal Parameters:
 *		attachment
 *			The Domain to which this connection object is attached.
 *		connection_handle
 *			The handle which uniquely identifies this connection object.
 *		owner_object
 *			This is a pointer to the owner of this connection object (typically
 *			the MCS Controller) which allows this connection to communicate with
 *			the owner through callbacks. 
 *		owner_message_base
 *			This is the base value to which offsets are added to identify which
 *			callback routine in the owner object this connection is calling.
 *		transport_connection
 *			This is the object used by this connection to communicate with the
 *			transport layer.
 *		upward_connection
 *			This is a boolean flag which indicates whether this is an upward
 *			connection or a downward connection.
 *		domain_parameters
 *			This is the set of parameters which describes the local domain.
 *		min_domain_parameters
 *			This is the set of parameters which describes the minimum
 *			permissable values for local domain parameters.
 *		max_domain_parameters
 *			This is the set of parameters which describes the maximum
 *			permissable values for local domain parameters.
 *		user_data
 *			This is a pointer to a buffer containing data which is sent to the
 *			remote provider through the "ConnectInitial" PDU.
 *		user_data_length
 *			The length of the user data described above.
 *		connection_error
 *			A return parameter which indicates any errors which may have 
 *			occurred in construction of the connection object.
 *
 *	Return Value:
 *		MCS_NO_ERROR			
 *			The connection was created successfully.
 *		MCS_TRANSPORT_FAILED	
 *			An error occurred in accepting the transport connection.
 *		MCS_BAD_DOMAIN_PARAMETERS
 *			There was no acceptable overlap between the local and remote
 *			domain parameters.
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

/*
 *	~Connection ()
 *
 *	Functional Description:
 *		This is the destructor for the Connection class.  If no connection
 *		deletion is pending, it terminates the current connection by issuing
 *		a DisconnectProviderUltimatum to the domain, transmitting a
 *		"DISCONNECT_PROVIDER_ULTIMATUM" PDU, and issuing a DisconnectRequest
 *		to the transport interface.  The destructor also clears the transmission
 *		queue and frees any allocated memory.
 *
 *	Formal Parameters:
 *		None.
 *
 *	Return Value:
 *		None.
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

/*
 *	void		RegisterTransportConnection ()
 *
 *	Functional Description:
 *		This routine is called in order to register the transport connection
 *		with the connection object.
 *
 *	Formal Parameters:
 *		None.
 *
 *	Return Value:
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */
/*
 *	Void		PlumbDomainIndication (
 *						PCommandTarget		originator,
 *						ULong				height_limit)
 *
 *	Functional Description:
 *		This routine is called by the domain in order to send a
 *		"PlumbDomainIndication" PDU through the transport interface.
 *
 *	Formal Parameters:
 *		originator
 *			This is the address of the CommandTarget that issued this command.
 *		height_limit
 *			This is the number of connections between this user and the
 *			top provider.
 *
 *	Return Value:
 *		None.
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

/*
 *	Void		ErectDomainRequest (
 *						PCommandTarget		originator,
 *						ULong				height_in_domain,
 *						ULong				throughput_interval)
 *
 *	Functional Description:
 *		This routine is called by the domain in order to send a
 *		"ErectDomainRequest" PDU through the transport interface.
 *
 *	Formal Parameters:
 *		originator
 *			This is the address of the CommandTarget that issued this command.
 *		height_in_domain
 *			This is the number of connections between this user and the
 *			top provider.
 *		throughput_interval
 *			The minimum number of octets per second required.
 *
 *	Return Value:
 *		None.
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

/*
 *	Void		RejectUltimatum (
 *						PCommandTarget		originator,
 *						Diagnostic			diagnostic,
 *						PUChar				octet_string_address,
 *						ULong				octet_string_length)
 *
 *	Functional Description:
 *		This routine is called by the domain in order to send a
 *		"RejectUltimatum" PDU through the transport interface.
 *
 *	Formal Parameters:
 *		originator
 *			This is the address of the CommandTarget that issued this command.
 *		diagnostic
 *			An enumeration indicating the reason for this reject.
 *		octet_string_address
 *			A pointer to the PDU data which resulted in the reject.
 *		octet_string_length
 *			The length of the PDU data which resulted in the reject.
 *
 *	Return Value:
 *		None.
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */
/*
 *	Void	MergeChannelsRequest (
 *					PCommandTarget			originator,
 *					CChannelAttributesList *merge_channel_list,
 *					CChannelIDList         *purge_channel_list)
 *
 *	Functional Description:
 *		This routine is called by the domain in order to send a
 *		"MergeChannelsRequest" PDU through the transport interface.
 *
 *	Formal Parameters:
 *		originator
 *			This is the address of the CommandTarget that issued this command.
 *		merge_channel_list
 *			This is a list of attributes describing the channels which are to
 *			be merged.
 *		purge_channel_list
 *			This is a list of ID's for the channels that are to be purged.
 *
 *	Return Value:
 *		None.
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */
/*
 *	Void	MergeChannelsConfirm (
 *					PCommandTarget			originator,
 *					CChannelAttributesList *merge_channel_list,
 *					CChannelIDList         *purge_channel_list)
 *
 *	Functional Description:
 *		This command is received when the local attachment wishes to send a
 *		MergeChannelConfirm command to the remote attachment.
 *
 *	Formal Parameters:
 *		originator
 *			This is the address of the CommandTarget that issued this command.
 *		merge_channel_list
 *			This is a list of attributes describing the channels which are to
 *			be merged.
 *		purge_channel_list
 *			This is a list of ID's for the channels that are to be purged.
 *
 *	Return Value:
 *		None.
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

/*
 *	Void	PurgeChannelsIndication (
 *					PCommandTarget		originator,
 *					CUidList           *purge_user_list,
 *					CChannelIDList     *purge_channel_list)
 *
 *	Functional Description:
 *		This routine is called by the domain in order to send a
 *		"PurgeChannelsIndication" PDU through the transport interface.
 *
 *	Formal Parameters:
 *		originator
 *			This is the address of the CommandTarget that issued this command.
 *		purge_user_list
 *			This is a list of IDs of the users being purged.
 *		purge_channel_list
 *			This is a list of IDs of the channels being purged.
 *
 *	Return Value:
 *		None.
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */
/*
 *	Void	MergeTokensRequest (
 *					PCommandTarget			originator,
 *					CTokenAttributesList   *merge_token_list,
 *					CTokenIDList           *purge_token_list)
 *
 *	Functional Description:
 *		This routine is called by the domain in order to send a
 *		"MergeTokensRequest" PDU through the transport interface.
 *
 *	Formal Parameters:
 *		originator
 *			This is the address of the CommandTarget that issued this command.
 *		merge_token_list
 *			This is a list of attributes describing the tokens which are to
 *			be merged.
 *		purge_token_list
 *			This is a list of ID's for the tokens that are to be purged.
 *
 *	Return Value:
 *		None.
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */
/*
 *	Void	MergeTokensConfirm (
 *					PCommandTarget			originator,
 *					CTokenAttributesList   *merge_token_list,
 *					CTokenIDList           *purge_token_list)
 *
 *	Functional Description:
 *		This command is received when the local attachment wishes to send a
 *		MergeTokensConfirm command to the remote attachment.
 *
 *	Formal Parameters:
 *		originator
 *			This is the address of the CommandTarget that issued this command.
 *		merge_token_list
 *			This is a list of attributes describing the tokens which are to
 *			be merged.
 *		purge_token_list
 *			This is a list of ID's for the tokens that are to be purged.
 *
 *	Return Value:
 *		None.
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */
/*
 *	Void	PurgeTokensIndication (
 *					PCommandTarget		originator,
 *					CTokenIDList       *purge_token_ids)
 *
 *	Functional Description:
 *		This command is received when the local attachment wishes to send a
 *		PurgeTokenIndication command to the remote attachment.
 *
 *	Formal Parameters:
 *		originator
 *			This is the address of the CommandTarget that issued this command.
 *		purge_token_ids
 *			This is a list of ID's for the tokens that are to be purged.
 *
 *	Return Value:
 *		None.
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */
/*
 *	Void	DisconnectProviderUltimatum (
 *					PCommandTarget		originator,
 *					Reason				reason)
 *
 *	Functional Description:
 *		This command is received when the local attachment wishes to send a
 *		DisconnectProviderUltimatum command to the remote attachment.  Note
 *		that this command automatically causes this Connection object to
 *		destroy itself.
 *
 *	Formal Parameters:
 *		originator
 *			This is the address of the CommandTarget that issued this command.
 *		reason
 *			The reason for the diconnect.
 *
 *	Return Value:
 *		None.
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */
/*
 *	Void	AttachUserRequest (
 *					PCommandTarget		originator)
 *
 *	Functional Description:
 *		This command is received when the local attachment wishes to send a
 *		AttachUserRequest command to the remote attachment.
 *
 *	Formal Parameters:
 *		originator
 *			This is the address of the CommandTarget that issued this command.
 *
 *	Return Value:
 *		None.
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */
/*
 *	Void	AttachUserConfirm (
 *					PCommandTarget		originator,
 *					Result				result,
 *					UserID				uidInitiator)
 *
 *	Functional Description:
 *		This command is received when the local attachment wishes to send a
 *		AttachUserConfirm command to the remote attachment.
 *
 *	Formal Parameters:
 *		originator
 *			This is the address of the CommandTarget that issued this command.
 *		result
 *			The result of the attach request.
 *		uidInitiator
 *			If the result was successful, this will contain the unique user
 *			ID to be associated with this user.
 *
 *	Return Value:
 *		None.
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */
/*
 *	Void	DetachUserRequest (
 *					PCommandTarget		originator,
 *					Reason				reason,
 *					UserID				user_id)
 *
 *	Functional Description:
 *		This command is received when the local attachment wishes to send a
 *		DetachUserRequest command to the remote attachment.
 *
 *	Formal Parameters:
 *		originator
 *			This is the address of the CommandTarget that issued this command.
 *		reason
 *			This is the reason for the detachment.
 *		user_id
 *			The ID of the user who wishes to detach.
 *
 *	Return Value:
 *		None.
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */
/*
 *	Void	DetachUserIndication (
 *					PCommandTarget		originator,
 *					Reason				reason,
 *					UserID				user_id)
 *
 *	Functional Description:
 *		This command is received when the local attachment wishes to send a
 *		DetachUserIndication command to the remote attachment.
 *
 *	Formal Parameters:
 *		originator
 *			This is the address of the CommandTarget that issued this command.
 *		reason
 *			The reason for the detachment.
 *		user_id
 *			The ID of the user who has detached.
 *
 *	Return Value:
 *		None.
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */
/*
 *	Void	ChannelJoinRequest (
 *					PCommandTarget		originator,
 *					UserID				uidInitiator,
 *					ChannelID			channel_id)
 *
 *	Functional Description:
 *		This command is received when the local attachment wishes to send a
 *		ChannelJoinRequest command to the remote attachment.
 *
 *	Formal Parameters:
 *		originator
 *			This is the address of the CommandTarget that issued this command.
 *		uidInitiator
 *			The ID of the user who initiated the request.
 *		channel_id
 *			The ID of the channel to be joined.
 *
 *	Return Value:
 *		None.
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */
/*
 *	Void	ChannelJoinConfirm (
 *					PCommandTarget		originator,
 *					Result				result,
 *					UserID				uidInitiator,
 *					ChannelID			requested_id,
 *					ChannelID			channel_id)
 *
 *	Functional Description:
 *		This command is received when the local attachment wishes to send a
 *		ChannelJoinConfirm command to the remote attachment.
 *
 *	Formal Parameters:
 *		originator
 *			This is the address of the CommandTarget that issued this command.
 *		result
 *			The result of the join request.
 *		uidInitiator
 *			The ID of the user who initiated the request.
 *		requested_id
 *			This ID of the channel that the user attempted to join (which may
 *			be 0).
 *		channel_id
 *			The ID of the channel being joined.
 *
 *	Return Value:
 *		None.
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */
/*
 *	Void	ChannelLeaveRequest (
 *					PCommandTarget		originator,
 *					CChannelIDList     *channel_id_list)
 *
 *	Functional Description:
 *		This command is received when the local attachment wishes to send a
 *		ChannelLeaveRequest command to the remote attachment.
 *
 *	Formal Parameters:
 *		originator
 *			This is the address of the CommandTarget that issued this command.
 *		channel_id_list
 *			The list of IDs of the channels to be left.
 *
 *	Return Value:
 *		None.
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */
/*
 *	Void	ChannelConveneRequest (
 *					PCommandTarget		originator,
 *					UserID				uidInitiator)
 *
 *	Functional Description:
 *		This command is received when the local attachment wishes to send a
 *		ChannelConveneRequest command to the remote attachment.
 *
 *	Formal Parameters:
 *		originator
 *			This is the address of the CommandTarget that issued this command.
 *		uidInitiator
 *			This is the ID of the user who is trying to convene a private
 *			channel.
 *
 *	Return Value:
 *		None.
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */
/*
 *	Void	ChannelConveneConfirm (
 *					PCommandTarget		originator,
 *					Result				result,
 *					UserID				uidInitiator,
 *					ChannelID			channel_id)
 *
 *	Functional Description:
 *		This command is received when the local attachment wishes to send a
 *		ChannelConveneConfirm command to the remote attachment.
 *
 *	Formal Parameters:
 *		originator
 *			This is the address of the CommandTarget that issued this command.
 *		result
 *			This is the result of the previously requested convene operation.
 *		uidInitiator
 *			This is the ID of the user who tried to convene a new channel.
 *		channel_id
 *			If the request was successful, this is the ID of the newly created
 *			private channel.
 *
 *	Return Value:
 *		None.
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */
/*
 *	Void	ChannelDisbandRequest (
 *					PCommandTarget		originator,
 *					UserID				uidInitiator,
 *					ChannelID			channel_id)
 *
 *	Functional Description:
 *		This command is received when the local attachment wishes to send a
 *		ChannelDisbandRequest command to the remote attachment.
 *
 *	Formal Parameters:
 *		originator
 *			This is the address of the CommandTarget that issued this command.
 *		uidInitiator
 *			This is the ID of the user who is trying to disband a private
 *			channel.
 *		channel_id
 *			This is the ID of the channel being disbanded.
 *
 *	Return Value:
 *		None.
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */
/*
 *	Void	ChannelDisbandIndication (
 *					PCommandTarget		originator,
 *					ChannelID			channel_id)
 *
 *	Functional Description:
 *		This command is received when the local attachment wishes to send a
 *		ChannelDisbandIndication command to the remote attachment.
 *
 *	Formal Parameters:
 *		originator
 *			This is the address of the CommandTarget that issued this command.
 *		channel_id
 *			This is the ID of the channel being disbanded.
 *
 *	Return Value:
 *		None.
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */
/*
 *	Void	ChannelAdmitRequest (
 *					PCommandTarget		originator,
 *					UserID				uidInitiator,
 *					ChannelID			channel_id,
 *					CUidList           *user_id_list)
 *
 *	Functional Description:
 *		This command is received when the local attachment wishes to send a
 *		ChannelAdmitRequest command to the remote attachment.
 *
 *	Formal Parameters:
 *		originator
 *			This is the address of the CommandTarget that issued this command.
 *		uidInitiator
 *			This is the ID of the user who is trying to admit some users to
 *			a private channel.
 *		channel_id
 *			This is the ID of the channel to be affected.
 *		user_id_list
 *			This is a container holding the IDs of the users to be admitted.
 *
 *	Return Value:
 *		None.
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */
/*
 *	Void	ChannelAdmitIndication (
 *					PCommandTarget		originator,
 *					UserID				uidInitiator,
 *					ChannelID			channel_id,
 *					CUidList           *user_id_list)
 *
 *	Functional Description:
 *		This command is received when the local attachment wishes to send a
 *		ChannelAdmitIndication command to the remote attachment.
 *
 *	Formal Parameters:
 *		originator
 *			This is the address of the CommandTarget that issued this command.
 *		uidInitiator
 *			This is the ID of the user who is trying to admit some users to
 *			a private channel.
 *		channel_id
 *			This is the ID of the channel to be affected.
 *		user_id_list
 *			This is a container holding the IDs of the users to be admitted.
 *
 *	Return Value:
 *		None.
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */
/*
 *	Void	ChannelExpelRequest (
 *					PCommandTarget		originator,
 *					UserID				uidInitiator,
 *					ChannelID			channel_id,
 *					CUidList           *user_id_list)
 *
 *	Functional Description:
 *		This command is received when the local attachment wishes to send a
 *		ChannelExpelRequest command to the remote attachment.
 *
 *	Formal Parameters:
 *		originator
 *			This is the address of the CommandTarget that issued this command.
 *		uidInitiator
 *			This is the ID of the user who is trying to expel some users from
 *			a private channel.
 *		channel_id
 *			This is the ID of the channel to be affected.
 *		user_id_list
 *			This is a container holding the IDs of the users to be expelled.
 *
 *	Return Value:
 *		None.
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */
/*
 *	Void	ChannelExpelIndication (
 *					PCommandTarget		originator,
 *					ChannelID			channel_id,
 *					CUidList           *user_id_list)
 *
 *	Functional Description:
 *		This command is received when the local attachment wishes to send a
 *		ChannelExpelIndication command to the remote attachment.
 *
 *	Formal Parameters:
 *		originator
 *			This is the address of the CommandTarget that issued this command.
 *		channel_id
 *			This is the ID of the channel to be affected.
 *		user_id_list
 *			This is a container holding the IDs of the users to be expelled.
 *
 *	Return Value:
 *		None.
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

/*
 *	Void	SendDataRequest (
 *					PCommandTarget		originator,
 *					UINT				type,
					PDataPacket			data_packet)
 *
 *	Functional Description:
 *		This command is received when the local attachment wishes to send a
 *		SendDataRequest command to the remote attachment.
 *
 *	Formal Parameters:
 *		originator (i)
 *			This is the address of the CommandTarget that issued this command.
 *		type (i)
 *			Normal or uniform send data request
 *		pDataPacket (i)
 *			This is a pointer to a DataPacket object containing the channel
 *			ID, the User ID of the data sender, segmentation flags, priority of
 *			the data packet and a pointer to the packet to be sent.
 *
 *	Return Value:
 *		None.
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

/*
 *	Void	SendDataIndication (
 *					PCommandTarget		originator,
 *					UINT				type,
 *					PDataPacket			data_packet)
 *
 *	Functional Description:
 *		This command is received when the local attachment wishes to send a
 *		SendDataIndication command to the remote attachment.
 *
 *	Formal Parameters:
 *		originator
 *			This is the address of the CommandTarget that issued this command.
 *		type (i)
 *			normal or uniform data indication
 *		data_packet (i)
 *			This is a pointer to a DataPacket object containing the channel
 *			ID, the User ID of the data sender, segmentation flags, priority of
 *			the data packet and a pointer to the packet to be sent.
 *
 *	Return Value:
 *		None.
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */
/*
 *	Void	TokenGrabRequest (
 *					PCommandTarget		originator,
 *					UserID				uidInitiator,
 *					TokenID				token_id)
 *
 *	Functional Description:
 *		This command is received when the local attachment wishes to send a
 *		TokenGrabRequest command to the remote attachment.
 *
 *	Formal Parameters:
 *		originator
 *			This is the address of the CommandTarget that issued this command.
 *		uidInitiator
 *			The ID of the user attempting to grab the token.
 *		token_id
 *			The ID of the token being grabbed.
 *
 *	Return Value:
 *		None.
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */
/*
 *	Void	TokenGrabConfirm (
 *					PCommandTarget		originator,
 *					Result				result,
 *					UserID				uidInitiator,
 *					TokenID				token_id,
 *					TokenStatus			token_status)
 *
 *	Functional Description:
 *		This command is received when the local attachment wishes to send a
 *		TokenGrabConfirm command to the remote attachment.
 *
 *	Formal Parameters:
 *		originator
 *			This is the address of the CommandTarget that issued this command.
 *		result
 *			The result of the grab operation.
 *		uidInitiator
 *			The ID of the user attempting to grab the token.
 *		token_id
 *			The ID of the token being grabbed.
 *		token_status
 *			The status of the token after processing the request.
 *
 *	Return Value:
 *		None.
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */
/*
 *	Void	TokenInhibitRequest (
 *					PCommandTarget		originator,
 *					UserID				uidInitiator,
 *					TokenID				token_id)
 *
 *	Functional Description:
 *		This command is received when the local attachment wishes to send a
 *		TokenInhibitRequest command to the remote attachment.
 *
 *	Formal Parameters:
 *		originator
 *			This is the address of the CommandTarget that issued this command.
 *		uidInitiator
 *			The ID of the user attempting to inhibit the token.
 *		token_id
 *			The ID of the token being inhibited.
 *
 *	Return Value:
 *		None.
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */
/*
 *	Void	TokenInhibitConfirm (
 *					PCommandTarget		originator,
 *					Result				result,
 *					UserID				uidInitiator,
 *					TokenID				token_id,
 *					TokenStatus			token_status)
 *
 *	Functional Description:
 *		This command is received when the local attachment wishes to send a
 *		TokenInhibitConfirm command to the remote attachment.
 *
 *	Formal Parameters:
 *		originator
 *			This is the address of the CommandTarget that issued this command.
 *		result
 *			The result of the inhibit operation.
 *		uidInitiator
 *			The ID of the user attempting to inhibit the token.
 *		token_id
 *			The ID of the token being inhibited.
 *		token_status
 *			The status of the token after processing the request.
 *
 *	Return Value:
 *		None.
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */
/*
 *	Void	TokenGiveRequest (
 *					PCommandTarget		originator,
 *					PTokenGiveRecord	pTokenGiveRec)
 *
 *	Functional Description:
 *		This command is received when the local attachment wishes to send a
 *		TokenGiveRequest command to the remote attachment.
 *
 *	Formal Parameters:
 *		originator
 *			This is the address of the CommandTarget that issued this command.
 *		pTokenGiveRec (i)
 *			This is the address of a structure containing the following information:
 *			The ID of the user attempting to give away the token.
 *			The ID of the token being given.
 *			The ID of the user that the token is being given to.
 *
 *	Return Value:
 *		None.
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */
/*
 *	Void	TokenGiveIndication (
 *					PCommandTarget		originator,
 *					PTokenGiveRecord	pTokenGiveRec)
 *
 *	Functional Description:
 *		This command is received when the local attachment wishes to send a
 *		TokenGiveIndication command to the remote attachment.
 *
 *	Formal Parameters:
 *		originator
 *			This is the address of the CommandTarget that issued this command.
 *		pTokenGiveRec (i)
 *			This is the address of a structure containing the following information:
 *			The ID of the user attempting to give away the token.
 *			The ID of the token being given.
 *			The ID of the user that the token is being given to.
 *
 *	Return Value:
 *		None.
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */
/*
 *	Void	TokenGiveResponse (
 *					PCommandTarget		originator,
 *					Result				result,
 *					UserID				receiver_id,
 *					TokenID				token_id)
 *
 *	Functional Description:
 *		This command is received when the local attachment wishes to send a
 *		TokenGiveResponse command to the remote attachment.
 *
 *	Formal Parameters:
 *		originator
 *			This is the address of the CommandTarget that issued this command.
 *		result
 *			The result of the give operation.
 *		receiver_id
 *			The ID of the user being given the token.
 *		token_id
 *			The ID of the token being given.
 *
 *	Return Value:
 *		None.
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */
/*
 *	Void	TokenGiveConfirm (
 *					PCommandTarget		originator,
 *					Result				result,
 *					UserID				uidInitiator,
 *					TokenID				token_id,
 *					TokenStatus			token_status)
 *
 *	Functional Description:
 *		This command is received when the local attachment wishes to send a
 *		TokenGiveConfirm command to the remote attachment.
 *
 *	Formal Parameters:
 *		originator
 *			This is the address of the CommandTarget that issued this command.
 *		result
 *			The result of the give operation.
 *		uidInitiator
 *			The ID of the user being given the token.
 *		token_id
 *			The ID of the token being given.
 *		token_status
 *			The status of the token after processing the request.
 *
 *	Return Value:
 *		None.
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */
/*
 *	Void	TokenReleaseRequest (
 *					PCommandTarget		originator,
 *					UserID				uidInitiator,
 *					TokenID				token_id)
 *
 *	Functional Description:
 *		This command is received when the local attachment wishes to send a
 *		TokenReleaseRequest command to the remote attachment.
 *
 *	Formal Parameters:
 *		originator
 *			This is the address of the CommandTarget that issued this command.
 *		uidInitiator
 *			The ID of the user attempting to release the token.
 *		token_id
 *			The ID of the token being released.
 *
 *	Return Value:
 *		None.
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */
/*
 *	Void	TokenReleaseConfirm (
 *					PCommandTarget		originator,
 *					Result				result,
 *					UserID				uidInitiator,
 *					TokenID				token_id,
 *					TokenStatus			token_status)
 *
 *	Functional Description:
 *		This command is received when the local attachment wishes to send a
 *		TokenReleaseConfirm command to the remote attachment.
 *
 *	Formal Parameters:
 *		originator
 *			This is the address of the CommandTarget that issued this command.
 *		result
 *			The result of the release operation.
 *		uidInitiator
 *			The ID of the user attempting to release the token.
 *		token_id
 *			The ID of the token being released.
 *		token_status
 *			The status of the token after processing the request.
 *
 *	Return Value:
 *		None.
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */
/*
 *	Void	TokenPleaseRequest (
 *					PCommandTarget		originator,
 *					UserID				uidInitiator,
 *					TokenID				token_id)
 *
 *	Functional Description:
 *		This command is received when the local attachment wishes to send a
 *		TokenPleaseRequest command to the remote attachment.
 *
 *	Formal Parameters:
 *		originator
 *			This is the address of the CommandTarget that issued this command.
 *		uidInitiator
 *			The ID of the user requesting the token.
 *		token_id
 *			The ID of the token being requested.
 *
 *	Return Value:
 *		None.
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */
/*
 *	Void	TokenPleaseIndication (
 *					PCommandTarget		originator,
 *					UserID				uidInitiator,
 *					TokenID				token_id)
 *
 *	Functional Description:
 *		This command is received when the local attachment wishes to send a
 *		TokenPleaseIndication command to the remote attachment.
 *
 *	Formal Parameters:
 *		originator
 *			This is the address of the CommandTarget that issued this command.
 *		uidInitiator
 *			The ID of the user requesting the token.
 *		token_id
 *			The ID of the token being requested.
 *
 *	Return Value:
 *		None.
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */
/*
 *	Void	TokenTestRequest (
 *					PCommandTarget		originator,
 *					UserID				uidInitiator,
 *					TokenID				token_id)
 *
 *	Functional Description:
 *		This command is received when the local attachment wishes to send a
 *		TokenTestRequest command to the remote attachment.
 *
 *	Formal Parameters:
 *		originator
 *			This is the address of the CommandTarget that issued this command.
 *		uidInitiator
 *			The ID of the user testing the token.
 *		token_id
 *			The ID of the token being tested.
 *
 *	Return Value:
 *		None.
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */
/*
 *	Void	TokenTestConfirm (
 *					PCommandTarget		originator,
 *					UserID				uidInitiator,
 *					TokenID				token_id,
 *					TokenStatus			token_status)
 *
 *	Functional Description:
 *		This command is received when the local attachment wishes to send a
 *		TokenTestConfirm command to the remote attachment.
 *
 *	Formal Parameters:
 *		originator
 *			This is the address of the CommandTarget that issued this command.
 *		uidInitiator
 *			The ID of the user testing the token.
 *		token_id
 *			The ID of the token being tested.
 *		token_status
 *			The status of the token after processing the request.
 *
 *	Return Value:
 *		None.
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */
/*
 *	Void	MergeDomainIndication (
 *					PCommandTarget		originator,
 *					MergeStatus			merge_status)
 *
 *	Functional Description:
 *		This command is received when a domain enters or leaves the domain merge
 *		state.  When in a domain merge state, NO commands are to be sent to
 *		the Domain object.
 *
 *	Formal Parameters:
 *		originator
 *			This is the address of the CommandTarget that issued this command.
 *		merge_status
 *			This is the current status of the domain merge.  It indicates
 *			whether the merge is active, or just completed.
 *
 *	Return Value:
 *		None.
 *
 *	Side Effects:
 *		All command traffic to the Domain object must halt when the domain is
 *		in the merge state.
 *
 *	Caveats:
 *		None.
 */
/*
 *	Void	FlushMessageQueue()
 *
 *	Functional Description:
 *		This function is called by the controller during the MCS heartbeat to
 *		allow it to flush its output buffers.  If there is any data waiting
 *		to be transmitted (at any priority), the Connection object will attempt
 *		to send it at this time.
 *
 *	Formal Parameters:
 *		None.
 *
 *	Return Value:
 *		None.
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

/*
 *	ULong		OwnerCallback (
 *						unsigned int		message,
 *						PVoid				parameter1,
 						TransportConnection	transport_connection)
 *
 *	Functional Description:
 *		This function is used to receive owner callbacks from the Transport
 *		Interface object.  Connection objects sends data and requests to
 *		the Transport Interface object through its public interface, but it
 *		receives data and indications through this owner callback.  For a more
 *		complete description of the callbacks, and how the parameter for each
 *		one are packed, see the interface file for the class TransportInterface
 *		(since it is this class that originates the callbacks).
 *
 *	Formal Parameters:
 *		message
 *			This is the message to be processed.  These are defined in the
 *			interface file of the class issuing the callbacks.
 *		parameter1
 *			The meaning of this parameter varies according to the message
 *			being processed.
 *		transport_connection
 *			The transport connection on which the callback applies.
 *
 *	Return Value:
 *		The meaning of the return value varies according to the message being
 *		processed.
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\remdsk\rds\t120\h\conflist.h ===
/*
 *	conflist.h
 *
 *	Copyright (c) 1995 by DataBeam Corporation, Lexington, KY
 *
 *	Abstract:
 *		This is the interface file for the class CConfDescriptorListContainer.
 *		Instances of this class represent the Conference Descriptor list that is
 *		generated by a call to GCCConferenceQueryRequest.  This class hides most
 *		of the complexity associated with building this list.  It also handles
 *		building the set of conference descriptors used in the
 *		ConferenceQueryResponse PDU	and the conference descriptor list passed 
 *		to the GCC interface.  This class is designed so that a CControlSAP 
 *		object can use it to create	a GCC_CONFERENCE_QUERY_CONFIRM message by 
 *		requesting a pointer to a list of Conference Descriptor pointers from 
 *		it.  Objects of this type only live long enough to service a particular
 *		query request.  After a message	callback has returned or a PDU has been
 *		sent to MCS, the CConfDescriptorListContainer object is deleted.
 *
 *	Caveats:
 *		None.
 *
 *	Author:
 *		blp
 */
#ifndef _CONFERENCE_DESCRIPTOR_LIST_
#define _CONFERENCE_DESCRIPTOR_LIST_

#include "netaddr.h"

/*
 * This typedef defines the structure used internally by this class to maintain
 * the data associated with an individual conference descriptor.
 */
typedef struct CONF_DESCRIPTOR
{
	CONF_DESCRIPTOR(void);
	~CONF_DESCRIPTOR(void);

	LPSTR					pszNumericConfName;
	LPWSTR					pwszTextConfName;
	LPSTR					pszConfModifier;
	LPWSTR					pwszConfDescription;
	CNetAddrListContainer   *network_address_list;
	BOOL					conference_is_locked;
	BOOL					password_in_the_clear;
}
    CONF_DESCRIPTOR;

/*
 * These typedefs define the Rogue Wave container used to hold the list of 
 * CONF_DESCRIPTOR structures internally and the iterator used for
 * accessing structures in the list.
 */
class CConfDesccriptorList : public CList
{
    DEFINE_CLIST(CConfDesccriptorList, CONF_DESCRIPTOR*)
};


/*
 * Class definition:
 */
class CConfDescriptorListContainer : public CRefCount
{
public:

    CConfDescriptorListContainer(void);
    CConfDescriptorListContainer(PSetOfConferenceDescriptors, PGCCError);

    ~CConfDescriptorListContainer(void);

    GCCError	AddConferenceDescriptorToList(
    						LPSTR					pszNumericConfName,
    						LPWSTR					conference_text_name,
    						LPSTR					pszConfModifier,
    						BOOL					locked_conference,
    						BOOL					password_in_the_clear,
    						LPWSTR					pwszConfDescription,
    						CNetAddrListContainer   *network_address_list);

    GCCError	GetConferenceDescriptorListPDU(PSetOfConferenceDescriptors *);
    void		FreeConferenceDescriptorListPDU(void);

    GCCError	LockConferenceDescriptorList(void);
    void		UnLockConferenceDescriptorList(void);

    void		GetConferenceDescriptorList(PGCCConferenceDescriptor **, UINT *pcDescriptors);

private:

	void		GetConferenceDescriptor(PGCCConferenceDescriptor, CONF_DESCRIPTOR *);

private:

	/*
	 * Instance variables:
	 */
	PGCCConferenceDescriptor	*	m_ppGCCConfDescriptorList;
	PSetOfConferenceDescriptors		m_pSetOfConfDescriptors;
	UINT							m_cDescriptors;
	LPBYTE							m_pDescriptorListMemory;
	CConfDesccriptorList            m_ConfDescriptorList;

	//
	// LONCHANC: m_pNetAddrMemoryPointer points to available space,
	// initially equaling to m_pNetAddrListMemory.
	//
	LPBYTE							m_pNetAddrListMemory;
    LPBYTE                          m_pNetAddrMemoryPointer;
};

/*
 *	Comments explaining the public and private class member functions
 */

/*
 *	CConfDescriptorListContainer ();
 *
 *	Public member function of CConfDescriptorListContainer.
 *
 *	Function Description:
 *		This is a constructor for the CConfDescriptorListContainer class.  It
 *		initializes instance variables.
 *
 *	Formal Parameters:
 *
 *	Return Value:
 *		None.
 *
 *  Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

/*
 *	CConfDescriptorListContainer (	PSetOfConferenceDescriptors		conference_list,
 *								PGCCError						gcc_error);
 *
 *	Public member function of CConfDescriptorListContainer.
 *
 *	Function Description:
 *		This is a constructor for the CConfDescriptorListContainer class.  
 *		This constructor builds a list of conference descriptors that can
 *		be passed on to the GCC interface.  This list is built from a set
 *		of conference descriptors which is part of a Query Response PDU.
 *
 *	Formal Parameters:
 *		conference_list		(i) The PDU form of the descriptor list.
 *		gcc_error			(o) Error return parameter.
 *
 *	Return Value:
 *		GCC_NO_ERROR					-	No error.
 *		GCC_ALLOCATION_FAILURE			- 	Error creating an object using the
 *												"new" operator.
 *
 *  Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

/*
 *	~CConfDescriptorListContainer ();
 *
 *	Public member function of CConfDescriptorListContainer.
 *
 *	Function Description:
 *		This is the destructor for the CConfDescriptorListContainer class.  It is
 *		responsible for freeing up any resources allocated during the life of
 *		this object.
 *
 *	Formal Parameters:
 *		None.
 *
 *	Return Value:
 *		None.
 *
 *  Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */


/*
 *	GCCError		AddConferenceDescriptorToList (
 *								LPSTR					pszNumericConfName,
 *								LPWSTR					conference_text_name,
 *								LPSTR					pszConfModifier,
 *								BOOL					locked_conference,
 *								BOOL					password_in_the_clear,
 *								LPWSTR					pwszConfDescription,
 *								CNetAddrListContainer   *network_address_list);
 *
 *	Public member function of CConfDescriptorListContainer.
 *
 *	Function Description:
 *		This routine is used to add a single new conference descriptor to the
 *		list of conference descriptors.
 *
 *	Formal Parameters:
 *		conference_numeric_name		(i)	The numeric form of the conference name.
 *		conference_text_name		(i) The text form of the conference name.
 *		pszConfModifier				(i) The conference modifier string.
 *		locked_conference			(i) Flag indicating whether or not the
 *											conference is locked.
 *		password_in_the_clear		(i)	Flag indicating whether the conference 
 *											password is "clear" or is a
 *											"challenge".
 *		pwszConfDescription			(i)	The conference description string.
 *		network_address_list		(i) List of network addresses at the queried
 *											node.
 *
 *	Return Value:
 *		GCC_NO_ERROR					-	No error.
 *		GCC_ALLOCATION_FAILURE			- 	Error creating an object using the
 *												"new" operator.
 *
 *  Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */


/*
 *	GCCError		GetConferenceDescriptorListPDU (
 *								PSetOfConferenceDescriptors	*  conference_list);
 *
 *	Public member function of CConfDescriptorListContainer.
 *
 *	Function Description:
 *		This routine is used to retrieve the PDU form of the conference 
 *		descriptor list which is a list of "SetOfConferenceDescriptors"
 *		structures.
 *
 *	Formal Parameters:
 *		conference_list			(o)	The pointer to the list of 
 *										"SetOfConferenceDescriptors" structures
 *										to fill in.
 *
 *	Return Value:
 *		GCC_NO_ERROR					-	No error.
 *		GCC_ALLOCATION_FAILURE			- 	Error creating an object using the
 *												"new" operator.
 *
 *  Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */


/*
 *	void		FreeConferenceDescriptorListPDU ();
 *
 *	Public member function of CConfDescriptorListContainer.
 *
 *	Function Description:
 *		This routine is used to free up any resources allocated to hold the PDU 
 *		form of the conference descriptor list.
 *
 *	Formal Parameters:
 *		None.
 *
 *	Return Value:
 *		None.
 *
 *  Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */


/*
 *	GCCError		LockConferenceDescriptorList ();
 *
 *	Public member function of CConfDescriptorListContainer.
 *
 *	Function Description:
 *		This routine is used to "lock" the API form of the conference descriptor
 *		list.  The lock count is incremented and the API form of the list
 *		created in preparation for a "GetConferenceDescriptorList" call used to
 *		retrieve the API form of the list.  The memory necessary to hold the
 *		API list is allocated by this routine.
 *
 *	Formal Parameters:
 *		None.
 *
 *	Return Value:
 *		GCC_NO_ERROR			   -	No error.
 *		GCC_ALLOCATION_FAILURE	   - 	Error creating an object using the "new"
 *											operator or else an	allocation using
 *								   			the memory manager failed.
 *
 *  Side Effects:
 *		The internal lock count is incremented.
 *
 *	Caveats:
 *		None.
 */


/*
 *	void		GetConferenceDescriptorList (
 *								PGCCConferenceDescriptor **	   conference_list,	
 *								UINT*							number_of_descriptors);
 *
 *	Public member function of CConfDescriptorListContainer.
 *
 *	Function Description:
 *		This routine is used to retrieve the API form of the conference 
 *		descriptor list.
 *
 *	Formal Parameters:
 *		conference_list			(o) Pointer to list of GCCConferenceDescriptor
 *										API structures to fill in.
 *		number_of_descriptors	(o) Pointer to the number of descriptors in the
 *										list to fill in.
 *
 *	Return Value:
 *		None.
 *
 *  Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */


/*
 *	void		UnLockConferenceDescriptorList ();
 *
 *	Public member function of CConfDescriptorListContainer.
 *
 *	Function Description:
 *		This routine is used to "unlock" the "API" data for this object.  This
 *		results in the lock count for this object being decremented.  When the
 *		lock count transitions from 1 to 0, a check is made to determine 
 *		whether the object has been freed through a call to 
 *		FreeConferenceDescriptorList.  If so, the object will automatically 
 *		delete itself.  If not, any resources allocated to hold the API form
 *		of the decriptor list are freed.
 *
 *	Formal Parameters:
 *		None.
 *
 *	Return Value:
 *		None.
 *
 *  Side Effects:
 *		The internal lock count is decremented.
 *
 *	Caveats:
 *		None.
 */

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\remdsk\rds\t120\h\crostmsg.h ===
/*
 *	crostmsg.h
 *
 *	Copyright (c) 1995 by DataBeam Corporation, Lexington, KY
 *
 *	Abstract:
 *
 *	Caveats:
 *		None.
 *
 *	Author:
 *		blp/jbo
 */
#ifndef	_CONFERENCE_ROSTER_MESSAGE_
#define	_CONFERENCE_ROSTER_MESSAGE_

#include "crost.h"

class CConfRosterMsg : public CRefCount
{
public:

	CConfRosterMsg(CConfRoster *conference_roster);

	~CConfRosterMsg(void);

	GCCError		LockConferenceRosterMessage(void);
	void			UnLockConferenceRosterMessage(void);
	GCCError		GetConferenceRosterMessage(LPBYTE *ppData);

private:

	LPBYTE			m_pMemoryBlock;
	CConfRoster		*m_pConfRoster;
};


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\remdsk\rds\t120\h\crost.h ===
/*
 *	crost.h
 *
 *	Copyright (c) 1995 by DataBeam Corporation, Lexington, KY
 *
 *	Abstract:
 *		Instances of this class represent a single Conference Roster's
 *		information base.  It encapsulates all the functionality required to
 *		maintain the information base which includes the ability to add new
 *		roster records, delete records and update records.  It has the ability
 *		to convert its internal information base into a list of conference
 *		records that can be used in a GCC_ROSTER_UPDATE_INDICATION callback.  It
 *		is also responsible for converting its internal information base into
 *		Conference Roster Update PDUs.  Basically,  this class is responsible
 *		for all operations that require direct access to the records contained
 *		in a Conference Roster.
 *
 *		The Conference Roster class incorporates Rogue Wave list to hold the
 *		roster record information.  Using iterators throughout the class makes
 *		it easy to quickly convert the information contained in the list into
 *		either a PDU or into a list of record pointers (for roster update
 *		indications back to the node controller).
 *
 *		A Conference Roster object has the ability to serialize its roster data
 *		into a single contiguous memory block when it is required to send a
 *		message to the application interface.  This serialization process is
 *		managed externally by the CConfRosterMsg class through calls to
 *		LockConferenceRoster(), UnLockConferenceRoster() and
 *		GetConfRoster().  When a conference roster is to be serialized, a
 *		call is made to LockConferenceRoster() which causes the CConfRoster
 *		object to increment an internal lock count and returns the number of
 *		bytes required to hold the complete roster update.  The Conference
 *		Roster is then serialized into memory through a call to
 *		GetConfRoster().  The CConfRoster is then unlocked to allow
 *		it to be deleted when the free flag gets set through the
 *		FreeConferenceRoster() function.  In the current implementation of GCC,
 *		FreeConferenceRoster() is not used since the CConfRosterMsg
 *		maintains the data used to deliver the message (see a more detailed
 *		description of the lock, free and unlock mechanism in the section
 *		describing the data containers).
 *
 *		The Conference Roster object also is responsible for maintaining
 *		internal PDU data which is updated whenever a change occurs to its
 *		internal information base.  This PDU can be affected by both local
 *		request or by processing incoming PDUs.  Higher level objects access
 *		this PDU data by calling the Conference Roster's flush routine which in
 *		turn causes the PDU to be freed on any subsequent request that affects
 *		the rosters internal information base.
 *
 *	Caveats:
 *		None.
 *
 *	Author:
 *		blp
 */
#ifndef	_CONFERENCE_ROSTER_
#define	_CONFERENCE_ROSTER_

#include "netaddr.h"
#include "userdata.h"
#include "clists.h"

/*
**	These enumerations define the different ways the a conference roster list
**	can be updated.  It is used externally to inform a conference roster object
**	what to of send data PDU to build.
*/
typedef enum
{
	ADD_RECORD,
	DELETE_RECORD,
	REPLACE_RECORD,
	FULL_REFRESH
}
	CONF_ROSTER_UPDATE_TYPE;

/*
**	This list is used to keep track of the conference participants.  It is
**	a list of rogue wave pointers to Unicode Strings.
*/
class CParticipantNameList : public CList
{
	DEFINE_CLIST(CParticipantNameList, LPWSTR)
	void DeleteList(void);
};

/*
**	This is the structure used to maintain the conference roster information
**	internally.  Optional paramters use a NULL pointer to indicate that the
**	parameter is not in use.
*/
typedef struct CONF_RECORD
{
	CONF_RECORD(void);
	~CONF_RECORD(void);

	UserID					superior_node;
	NodeType				node_type;
	NodeProperties			node_properties;
	LPWSTR					pwszNodeName;
	CParticipantNameList	*participant_name_list;
	LPWSTR					pwszSiteInfo;
	CNetAddrListContainer   *network_address_list;
	LPOSTR					poszAltNodeID;
	CUserDataListContainer  *user_data_list;
}
	CONF_RECORD;

/*
**	This list is used to hold the pointers to the actual conference record for
**	each node in the conference.  The list is indexed by the Node ID associated
**	with the record.
*/
class CConfRecordList2 : public CList2
{
	DEFINE_CLIST2_(CConfRecordList2, CONF_RECORD*, UserID)
	void CleanList(void);
};


class CConfRoster : public CRefCount
{
public:

	CConfRoster(UserID uidTopProvider, UserID uidSuperiorNode, UserID uidMime,
				BOOL is_top_provider, BOOL is_local_roster, BOOL maintain_pdu_buffer);

	~CConfRoster(void);

	/*
	 * Utilities that operate on roster update PDU strucutures.
	 */
	void				FlushRosterUpdateIndicationPDU(PNodeInformation);
	GCCError			BuildFullRefreshPDU(void);
	GCCError			ProcessRosterUpdateIndicationPDU(PNodeInformation, UserID uidSender);

	/*
	 * Utilities used to generate a roster update message.
	 */
	UINT	    LockConferenceRoster(void);
	void		UnLockConferenceRoster(void);
	UINT		GetConfRoster(PGCCConferenceRoster *, LPBYTE memory_pointer);
	/*
	**	Utilities that operate directly on the conference roster objects
	**	internal databease.
	*/
	GCCError	AddRecord(PGCCNodeRecord, UserID);
	GCCError	ReplaceRecord(PGCCNodeRecord, UserID);
	GCCError	RemoveUserReference(UserID);

	/*
	**	Miscelaneous utilities.
	*/
	void    ResetConferenceRoster(void);

	UINT    GetNumberOfNodeRecords(void) { return m_RecordList2.GetCount(); }
	BOOL	Contains(UserID uidConf) { return m_RecordList2.Find(uidConf) ? TRUE : FALSE; }
	BOOL	HasRosterChanged(void) { return m_fRosterChanged; }

private:

	/*
	 * Utilities used to create a roster update indication PDU.
	 */
	GCCError	BuildRosterUpdateIndicationPDU(CONF_ROSTER_UPDATE_TYPE, UserID);
	GCCError	BuildSetOfRefreshesPDU(void);
	GCCError	BuildSetOfUpdatesPDU(UserID, CONF_ROSTER_UPDATE_TYPE);
	GCCError	BuildParticipantsListPDU(UserID, PParticipantsList *);

	/*
	 * Utilities used to Free a roster update indication PDU.
	 */
	void    FreeRosterUpdateIndicationPDU(void);
	void    FreeSetOfRefreshesPDU(void);
	void    FreeSetOfUpdatesPDU(void);
	void    FreeParticipantsListPDU(PParticipantsList);
    void    CleanUpdateRecordPDU(PSetOfNodeRecordUpdates);

	/*
	 * Utilities used to Process roster update indications.
	 */
	GCCError				ProcessSetOfRefreshesPDU(PSetOfNodeRecordRefreshes);
	GCCError				ProcessSetOfUpdatesPDU(PSetOfNodeRecordUpdates);
	GCCError				ProcessParticipantsListPDU(PParticipantsList, CONF_RECORD *);
								
	/*
	 * Utilities used to operate on conference roster reports.
	 */
	void					ClearRecordList(void);
	
	void					GetNodeTypeAndProperties (
								NodeType			pdu_node_type,
								NodeProperties		pdu_node_properties,
								PGCCNodeType		node_type,
								PGCCNodeProperties	node_properties);

	void					GetPDUNodeTypeAndProperties (
								GCCNodeType			node_type,
								GCCNodeProperties	node_properties,
								PNodeType			pdu_node_type,
								PNodeProperties		pdu_node_properties);
	
	GCCError				DeleteRecord(UserID node_id);

	GCCError				GetNodeSubTree(UserID, CUidList *);

private:

	BOOL					m_fNodesAdded;
	BOOL	 				m_fNodesRemoved;
	BOOL	 				m_fRosterChanged;
	BOOL					m_fTopProvider;
	BOOL					m_fLocalRoster;
	BOOL					m_fMaintainPduBuffer;
	BOOL					m_fPduFlushed;
	UserID					m_uidTopProvider;
	UserID					m_uidSuperiorNode;
	UserID					m_uidMyNodeID;
	UINT					m_nInstanceNumber;
	UINT					m_cbDataMemorySize;
	NodeInformation			m_NodeInformation;
	CConfRecordList2		m_RecordList2;
	PSetOfNodeRecordUpdates	m_pNodeRecordUpdateSet;
};

#endif

/*
 *	CConfRoster(	UserID					top_provider_id,
 *						UserID					superior_node,
 *						BOOL					is_top_provider,
 *						BOOL					is_local_roster,
 *						BOOL					maintain_pdu_buffer,
 *
 *	Public Function Description
 *		This is the conference roster constructor. It is responsible for
 *		initializing all the instance variables used by this class.
 *
 *	Formal Parameters:
 *		top_provider_id		-	(i) The Node ID of the Top Provider
 *		superior_node		-	(i) The Node ID of the node that is the parent
 *								to this one. Zero for the top provider.
 *		is_top_provider		-	(i)	Indicates if this is the top provider node.
 *		is_local_roster		-	(i)	Indicates if this roster is a local one.
 *		maintain_pdu_buffer	-	(i)	Indicates if this roster should maintain
 *									a PDU buffer.
 *		
 *
 *	Return Value
 *		None.
 *
 *  Side Effects
 *		None.
 *
 *	Caveats
 *		None.
 */

/*
 *	~CConfRoster ()
 *
 *	Public Function Description
 *		This is the conference roster destructor. It is responsible for
 *		freeing up all the internal memory used by this class.
 *
 *	Formal Parameters:
 *		None.
 *
 *	Return Value
 *		None.
 *
 *  Side Effects
 *		None.
 *
 *	Caveats
 *		None.
 */

/*
 *	void	FlushRosterUpdateIndicationPDU (
 *								PNodeInformation			node_information)
 *
 *	Public Function Description
 *		This routine is used to access any PDU data that might currently be
 *		queued inside the conference roster.  PDU data is queued whenever
 *		a request is made to the conference roster that affects its
 *		internal information base.
 *
 *	Formal Parameters:
 *		node_information	-	(o) Pointer to the PDU buffer to fill in.
 *
 *	Return Value
 *		None.
 *
 *  Side Effects
 *		None.
 *
 *	Caveats
 *		The PDU data returned by this routine is automatically freed the next
 *		time a request is made to this roster object that affects its internal
 *		databease.
 */

/*
 *	GCCError	BuildFullRefreshPDU (void)
 *
 *	Public Function Description
 *		This routine is responsible for generating a full conference roster
 *		refresh PDU.
 *
 *	Formal Parameters:
 *		None.
 *
 *	Return Value
 *		GCC_NO_ERROR			-	No error occured.
 *		GCC_ALLOCATION_FAILURE	-	A resource error occured.
 *
 *  Side Effects
 *		None.
 *
 *	Caveats
 *		None.
 */

/*
 *	GCCError	ProcessRosterUpdateIndicationPDU (
 *						PNodeInformation			node_information)
 *
 *	Public Function Description
 *		This routine is responsible for processing the decoded PDU data.
 *		It essentially changes the conference roster objects internal database
 *		based on the information in the structure.
 *
 *	Formal Parameters:
 *		node_information	-	(i) This is a pointer to a structure that
 *									holds the decoded PDU data.
 *
 *	Return Value
 *		GCC_NO_ERROR			-	No error occured.
 *		GCC_ALLOCATION_FAILURE	-	A resource error occured.
 *
 *  Side Effects
 *		None.
 *
 *	Caveats
 *		None.
 */

/*
 *	UINT		LockConferenceRoster()
 *
 *	Public Function Description:
 *		This routine is used to "lock" the "API" data for this object.  This
 *		results in the lock count for this object being incremented.  When the
 *		lock count transitions from 0 to 1, a calculation is made to determine
 *		how much memory will be needed to hold any "API" data which will
 *		be referenced by, but not held in, the GCCConferenceRoster structure
 *		which is filled in on a call to GetConfRoster.  This is the
 *		value returned by this routine in order to allow the calling object to
 *		allocate that amount of memory in preparation for the call to
 *		GetConfRoster.
 *
 *	Formal Parameters:
 *		None.
 *
 *	Return Value:
 *		The amount of memory, if any, which will be needed to hold "API" data
 *		which is referenced by, but not held in, the GCCConferenceRoster
 *		structure provided as an output parameter to the GetConfRoster
 *		call.
 *
 *  Side Effects:
 *		The internal lock count is incremented.
 *
 *	Caveats:
 *		The internal lock count is used in conjuction with an internal "free"
 *		flag as a mechanism for ensuring that this object remains in existance
 *		until all interested parties are through with it.  The object remains
 *		valid (unless explicity deleted) until the lock count is zero and the
 *		"free" flag is set through a call to FreeConferenceRoster.  This allows
 *		other objects to lock this object and be sure that it remains valid
 *		until they call UnLock which will decrement the internal lock count.  A
 *		typical usage scenerio for this object would be:  A CConfRoster
 *		object is constructed and then passed off to any interested parties
 *		through a function call.  On return from the function call, the
 *		FreeConferenceRoster call is made which will set the internal "free"
 *		flag.  If no other parties have locked the object with a Lock call,
 *		then the CConfRoster object will automatically delete itself when
 *		the FreeConferenceRoster call is made.  If, however, any number of
 *		other parties has locked the object, it will remain in existence until
 *		each of them has unlocked the object through a call to UnLock.
 */

/*
 *	void			UnLockConferenceRoster ();
 *
 *	Public Function Description:
 *		This routine is used to "unlock" the "API" data for this object.  This
 *		results in the lock count for this object being decremented.  When the
 *		lock count transitions from 1 to 0, a check is made to determine
 *		whether the object has been freed through a call to
 *		FreeConferenceRoster.  If so, the object will automatically delete
 *		itself.
 *
 *	Formal Parameters:
 *		None.
 *
 *	Return Value:
 *		None.
 *
 *  Side Effects:
 *		The internal lock count is decremented.
 *
 *	Caveats:
 *		It is the responsibility of any party which locks an CConfRoster
 *		object by calling Lock to also unlock the object with a call to UnLock.
 *		If the party calling UnLock did not construct the CConfRoster
 *		object,	it should assume the object to be invalid thereafter.
 */

/*
 *  UINT		GetConfRoster(
 *        					PGCCConferenceRoster	FAR * 	conference_roster,
 *                          LPSTR							memory_pointer);
 *
 *	Public Function Description:
 *		This routine is used to retrieve the conference roster data from
 *		the CConfRoster object in the "API" form of a GCCConferenceRoster.
 *
 *	Formal Parameters:
 *		conference_roster	(o)	The GCCConferenceRoster structure to fill in.
 *		memory_pointer		(o)	The memory used to hold any data referenced by,
 *									but not held in, the output structure.
 *
 *	Return Value:
 *		The amount of data, if any, written into the bulk memory block provided.
 *
 *  Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

/*
 *	GCCError		AddRecord(	PGCCNodeRecord			conference_record,
 *								UserID					node_id)
 *
 *	Public Function Description:
 *		This routine is used to add a single nodes conference record to the
 *		conference roster object's internal list of records.
 *
 *	Formal Parameters:
 *		conference_record	(i)	Pointer to the "API" record	structure to add.
 *		node_id				(i)	Node ID associated with record being added.	
 *
 *	Return Value:
 *		GCC_NO_ERROR					-	No error occured.
 *		GCC_ALLOCATION_FAILURE			-	A resource error occured.
 *		GCC_INVALID_PARAMETER			-	Invalid parameter passed in.
 *		GCC_BAD_NETWORK_ADDRESS			-	Invalid network address passed in.
 *		GCC_BAD_NETWORK_ADDRESS_TYPE	-	Bad "choice" field for address
 *		GCC_BAD_USER_DATA				-	The user data passed in contained
 *												an invalid object key.
 *
 *  Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

/*
 *	GCCError	RemoveRecord(UserID			node_id)
 *
 *	Public Function Description:
 *		This routine is used to remove a single nodes conference record from the
 *		conference roster object's internal list of records.
 *
 *	Formal Parameters:
 *		node_id				(i)	Node ID of record to be removed.
 *
 *	Return Value:
 *		GCC_NO_ERROR					-	No error occured.
 *		GCC_INVALID_PARAMETER			-	Invalid parameter passed in.
 *
 *  Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

/*
 *	GCCError	ReplaceRecord(		PGCCNodeRecord			conference_record,
 *									UserID					node_id)
 *
 *	Public Function Description:
 *		This routine is used to replace a single nodes conference record in the
 *		conference roster object's internal list of records.
 *
 *	Formal Parameters:
 *		conference_record	(i)	Conference record to use as the replacement.
 *		node_id				(i)	Node ID of record to be replaced.
 *
 *	Return Value:
 *		GCC_NO_ERROR					-	No error occured.
 *		GCC_ALLOCATION_FAILURE			-	A resource error occured.
 *		GCC_INVALID_PARAMETER			-	Invalid parameter passed in.
 *		GCC_BAD_NETWORK_ADDRESS			-	Invalid network address passed in.
 *		GCC_BAD_NETWORK_ADDRESS_TYPE	-	Bad "choice" field for address
 *		GCC_BAD_USER_DATA				-	The user data passed in contained
 *
 *  Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

/*
 *	GCCError	RemoveUserReference (
 *							UserID					detached_node)
 *
 *	Public Function Description:
 *		This routine removes the record associated with the specified node
 *		id.
 *
 *	Formal Parameters:
 *		detached_node		(i)	Node reference to remove.
 *
 *	Return Value:
 *		GCC_NO_ERROR				-	No error occured.
 *		GCC_INVALID_PARAMETER		-	No records associated with this node
 *
 *  Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

/*
 *	BOOL			Contains( UserID			conference_node_id )
 *
 *	Public Function Description:
 *		This routine is used to determine if the specified record exists in
 *		the conference roster.
 *
 *	Formal Parameters:
 *		conference_node_id	(i)	Node ID of record to check for
 *
 *	Return Value:
 *		TRUE	-	If the record is contained in the conference roster.
 *		FALSE	-	If the record is not contained in the conference roster.
 *
 *  Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

/*
 *	USHORT		GetNumberOfNodeRecords ();
 *
 *	Public Function Description:
 *		This routine returns the total number of conference roster records
 *		contained in the objects conference roster record list.
 *
 *	Formal Parameters:
 *		None.
 *
 *	Return Value:
 *		The number of records in the conference roster list.
 *
 *  Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

/*
 *	void		ResetConferenceRoster ()
 *
 *	Public Function Description:
 *		This routine takes care of resetting all the internal flags that are
 *		used to convey the current state of the conference roster.  Should be
 *		called after the roster is flushed and any roster update messages have
 *		been delivered (after a change to the roster occurs).
 *
 *	Formal Parameters:
 *		None.
 *
 *	Return Value:
 *		None.
 *
 *  Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

/*
 *	BOOL			HasRosterChanged ();
 *
 *	Public Function Description:
 *		This routine informs the caller if the roster has changed since the
 *		last time it was reset.
 *
 *	Formal Parameters:
 *		None.
 *
 *	Return Value:
 *		TRUE		-	If roster has changed
 *		FALSE		-	If roster has not changed
 *
 *  Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\remdsk\rds\t120\h\crostmgr.h ===
/*
 *	crostmgr.h
 *
 *	Copyright (c) 1995 by DataBeam Corporation, Lexington, KY
 *
 *	Abstract:
 *		Instances of this class represent the owner of the Conference Roster 
 *		for a single Conference object at an individual node.  This class will 
 *		create either a single CConfRoster object (referred to as a 
 *		"Global" roster) or two CConfRoster objects (refered to as a 
 *		"Local" and "Global" roster) in its constructor and will return a 
 *		resource error if there is not enough memory to instantiate it.  The 
 *		CConfRosterMgr is mainly responsible for routing Roster 
 *		Updates to and from the CConfRoster object(s) it manages.  This 
 *		includes updates sent to both the Control SAP and Application SAPs as 
 *		well as Updates sent to other nodes via PDUs.  This class makes 
 *		decisions on how to route updates based on whether or not it is at a 
 *		Top Provider node.  It also must make routing decisions based on whether 
 *		the change affects the Local or Global roster being maintained.
 *
 *		The CConfRosterMgr object at every node except the Top Provider 
 *		will maintain two ConferenceRosters, a local one and a global one.  This 
 *		is a very important distinction in that it implies two entirely 
 *		different sets of responsibilities. Conference Roster information is 
 *		distributed over the entire Conference.  Nodes that lie lower in the 
 *		connection hierarchy (subordinate nodes) contain less information than 
 *		higher nodes but all play an important role in maintaining the overall 
 *		roster.  
 *
 *		The "Local" CConfRoster is mainly used to inform parent nodes of 
 *		changes to the Conference Roster that occur at the local node or below 
 *		it in the connection hierarchy.  The Local CConfRoster consist of 
 *		all the Conference Roster Records at its local node and below it.  It is 
 *		not used to deliver Conference Roster Update messages to the various 
 *		SAPs.  Its only input is from either primitive calls at the local node 
 *		or from Roster Update PDUs received from subordinate nodes.  A "Local" 
 *		CConfRoster is only maintained by ConferenceRosterManagers at nodes 
 *		that are not the Top Provider.  
 *
 *		A "Global" CConfRoster maintained by a CConfRosterMgr has 
 *		a dual set of responsibilities depending on if it is at a Top Provider 
 *		node.  A CConfRoster of this type at a Top Provider is responsible 
 *		for maintaining a record entry for every node in the Conference.  It is 
 *		also used to send full conference roster refreshes to all of its 
 *		subordinate nodes when changes to the roster occur.  All "Global" 
 *		ConferenceRosters (regardless of location within the connection 
 *		hierarchy) are used to send Roster Update indications to all the 
 *		appropriate SAPs (Control and Application) via an Owner-Callback call to 
 *		the Conference Object that owns it.  The owner object is informed of the 
 *		roster update through a CONF_ROSTER_MGR_ROSTER_REPORT message.  Included 
 *		in this message is a pointer to a CConfRosterMsg object.  The 
 *		CConfRosterMgr creates a CConfRosterMsg from the 
 *		"Global" CConfRoster object that it maintains.  This 
 *		CConfRosterMsg object contains all the conference roster data 
 *		serialized into a single memory block which is formatted for delivery to 
 *		the appropriate SAPs.  You can think of this as a snapshot in time of 
 *		the CConfRoster being delivered in the roster update message.
 *
 *		A "Global" CConfRoster at a subordinate node is responsible for 
 *		storing full refreshes of the Conference Roster from the Top Provider.  
 *		It is also used to send the Conference Roster Update message to all the 
 *		appropriate SAPs through an Owner-Callback to the Conference object (as 
 *		mentioned above) after processing the full refresh PDU.
 *
 *		All PDUs and messages are delivered when the CConfRosterMgr is 
 *		flushed. This is also true for ApplicationRosterManagers.  This is a 
 *		very important concept in that it allows a CConfRosterMgr to 
 *		process a number of request and PDUs before actually being flushed.  The 
 *		CConfRoster itself will queue up changes to a PDU that can consist 
 *		of either multiple updates or a single refresh and will not free it 
 *		until after it is flushed.  Therefore, when processing a roster update 
 *		PDU that consists of changes to the conference roster as well as 
 *		multiple application rosters, a roster refresh PDU can be held back 
 *		until all the roster managers have had a chance to process their portion 
 *		of the roster update.  Once complete, a single PDU can be built by 
 *		flushing the CConfRosterMgr and all the affected 
 *		ApplicationRosterManagers.
 *
 *	Caveats:
 *		None.
 *
 *	Author:
 *		blp
 */
#ifndef	_CONFERENCE_ROSTER_MANAGER_
#define	_CONFERENCE_ROSTER_MANAGER_

#include "mcsuser.h"
#include "clists.h"
#include "crost.h"


class CConf;
class CConfRosterMgr : public CRefCount
{
public:

	CConfRosterMgr(
		PMCSUser				user_object,
		CConf					*pConf,
		BOOL					top_provider,
		PGCCError				roster_error);

	~CConfRosterMgr(void);

	GCCError			AddNodeRecord(PGCCNodeRecord node_record);

	GCCError			UpdateNodeRecord(PGCCNodeRecord node_record);
	
	GCCError			RemoveUserReference(UserID deteched_node_id);
								
	GCCError			RosterUpdateIndication(
							PGCCPDU					roster_update,
							UserID					sender_id);
								
	GCCError			FlushRosterUpdateIndication(PNodeInformation node_information);

	GCCError			GetFullRosterRefreshPDU(PNodeInformation node_information);
								

	CConfRoster		*GetConferenceRosterPointer(void) { return (m_pGlobalConfRoster); }
	BOOL			Contains(UserID uid) { return m_pGlobalConfRoster->Contains(uid); }
	UINT			GetNumberOfNodeRecords(void) { return m_pGlobalConfRoster->GetNumberOfNodeRecords(); }

    BOOL            IsThisNodeParticipant ( GCCNodeID );

private:

	BOOL							m_fTopProvider;
	CConfRoster						*m_pGlobalConfRoster;
	CConfRoster						*m_pLocalConfRoster;
	MCSUser						    *m_pMcsUserObject;
	CConf							*m_pConf;
};

#endif


/*
 *	CConfRosterMgr	(	
 *					PMCSUser				user_object,
 *					UINT        			owner_message_base,
 *					BOOL					top_provider,
 *					PGCCError				roster_error)
 *
 *	Public Function Description
 *		This is the conference roster manager constructor. It is responsible for
 *		initializing all the instance variables used by this class.
 *
 *	Formal Parameters:
 *		user_object			-	(i)	Pointer to the user attachment object used
 *									by this class.
 *		owner_object		-	(i)	Pointer to the owner object.
 *		owner_message_base	-	(i)	Message base to add to all the owner 
 *									callbacks.
 *		top_provider		-	(i)	Indicates if this is the top provider node.
 *		roster_error		-	(o)	Pointer to error value to be returned.
 *		
 *
 *	Return Value
 *		GCC_NO_ERROR				-	No resource error occured.
 *		GCC_ALLOCATION_FAILURE		-	A resource error occured.
 *
 *  Side Effects
 *		None.
 *
 *	Caveats
 *		None.
 */

/*
 *	~CConfRosterMgr ()
 *
 *	Public Function Description
 *		This is the conference roster destructor. It is responsible for
 *		freeing up all memory allocated by this class.
 *
 *	Formal Parameters:
 *		None.
 *		
 *	Return Value
 *		None.
 *
 *  Side Effects
 *		None.
 *
 *	Caveats
 *		None.
 */

/*
 *	GCCError	AddNodeRecord (PGCCNodeRecord			node_record)
 *
 *	Public Function Description
 *		This routine is used to add a new record to the conference roster.
 *		This class makes the decision about which roster the new record goes
 *		into (global or local).
 *
 *	Formal Parameters:
 *		node_record		-	(i)	Pointer to the record to add to the roster.
 *		
 *	Return Value
 *		GCC_NO_ERROR					-	No error occured.
 *		GCC_ALLOCATION_FAILURE			-	A resource error occured.
 *		GCC_INVALID_PARAMETER			-	Invalid parameter passed in.
 *		GCC_BAD_NETWORK_ADDRESS			-	Invalid network address passed in.
 *		GCC_BAD_NETWORK_ADDRESS_TYPE	-	Bad "choice" field for address
 *		GCC_BAD_USER_DATA				-	The user data passed in contained
 *												an invalid object key.
 *
 *  Side Effects
 *		None.
 *
 *	Caveats
 *		None.
 */

/*
 *	GCCError	UpdateNodeRecord(
 *								PGCCNodeRecord			node_record)
 *
 *	Public Function Description
 *		This routine is used to replace a record in the conference roster with
 *		a new record. This class makes the decision about which roster the new 
 *		record affects (global or local).
 *
 *	Formal Parameters:
 *		node_record		-	(i)	Pointer to the record to replace with.
 *		
 *	Return Value
 *		GCC_NO_ERROR					-	No error occured.
 *		GCC_ALLOCATION_FAILURE			-	A resource error occured.
 *		GCC_INVALID_PARAMETER			-	Invalid parameter passed in.
 *		GCC_BAD_NETWORK_ADDRESS			-	Invalid network address passed in.
 *		GCC_BAD_NETWORK_ADDRESS_TYPE	-	Bad "choice" field for address
 *		GCC_BAD_USER_DATA				-	The user data passed in contained
 *
 *  Side Effects
 *		None.
 *
 *	Caveats
 *		None.
 */

/*
 *	GCCError	RemoveUserReference (
 *								UserID					deteched_node_id)
 *
 *	Public Function Description
 *		This routine removes the record associated with the specified node
 *		id.
 *
 *	Formal Parameters:
 *		deteched_node_id		(i)	Node reference to remove.
 *
 *	Return Value:
 *		GCC_NO_ERROR				-	No error occured.
 *		GCC_INVALID_PARAMETER		-	No records associated with this node
 *
 *  Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

/*
 *	GCCError	RosterUpdateIndication(
 *								PGCCPDU					roster_update,
 *								UserID					sender_id)
 *
 *	Public Function Description
 *		This routine is responsible for processing the decoded PDU data.
 *		It essentially passes the PDU on along to the appropriate roster.
 *
 *	Formal Parameters:
 *		roster_update	-	(i) This is a pointer to a structure that
 *									holds the decoded PDU data.
 *
 *	Return Value
 *		GCC_NO_ERROR			-	No error occured.
 *		GCC_ALLOCATION_FAILURE	-	A resource error occured.
 *
 *  Side Effects
 *		None.
 *
 *	Caveats
 *		None.
 */

/*
 *	GCCError	FlushRosterUpdateIndication(
 *								PNodeInformation		node_information)
 *
 *	Public Function Description
 *		This routine is used to access any PDU data that might currently be
 *		queued inside the conference roster.  It also is responsible for 
 *		flushing a roster update message if necessary.
 *
 *	Formal Parameters:
 *		node_information	-	(o) Pointer to the PDU buffer to fill in.
 *
 *	Return Value
 *		None.
 *
 *  Side Effects
 *		None.
 *
 *	Caveats
 *		None.
 */

/*
 *	GCCError	GetFullRosterRefreshPDU(
 *								PNodeInformation		node_information)
 *
 *	Public Function Description
 *		This routine is used to access a full conference roster refresh.
 *
 *	Formal Parameters:
 *		node_information	-	(o) Pointer to the PDU buffer to fill in.
 *
 *	Return Value
 *		None.
 *
 *  Side Effects
 *		None.
 *
 *	Caveats
 *		None.
 */

/*
 *	BOOL			Contains(UserID		node_record_entry)
 *
 *	Public Function Description
 *		This routine is used to determine if the specified record exists in
 *		the conference roster.
 *
 *	Formal Parameters:
 *		node_record_entry	(i)	Node ID of record to check for
 *
 *	Return Value:
 *		TRUE	-	If the record is contained in the conference roster.
 *		FALSE	-	If the record is not contained in the conference roster.
 *
 *  Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

/*
 *	CConfRoster		*GetConferenceRosterPointer ()
 *
 *	Public Function Description
 *		This routine is used to access a pointer to the conference roster
 *		managed by this conference roster manager.  The global roster
 *		is always returned by this routine.
 *
 *	Formal Parameters:
 *		None.
 *
 *	Return Value:
 *		A pointer to the Global conference roster.
 *
 *  Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

/*
 *	USHORT		GetNumberOfNodeRecords ();
 *
 *	Public Function Description
 *		This routine returns the total number of conference roster records
 *		contained in the global conference roster record list.
 *
 *	Formal Parameters:
 *		None.
 *
 *	Return Value:
 *		The number of records in the conference roster list.
 *
 *  Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\remdsk\rds\t120\h\csap.h ===
/*
 *	csap.h
 *
 *	Copyright (c) 1995 by DataBeam Corporation, Lexington, KY
 *
 *	Abstract:
 *		This is the interface file for the class CControlSAP.  CControlSAP objects
 *		represent the node controller's Service Access Point to GCC.  This 
 *		class inherits from the SAP class.  The CControlSAP object is 
 *		instantiated when GCCInitialize is called.  From that point forward all
 *		messages to and from the node controller pass through this object.  The
 *		primary responsibility of the CControlSAP object is to route incoming GCC
 *		primitives to their appropriate destination and to convert the 
 *		primitives into a form that is understandable to the objects processing
 *		them. A secondary responsibility of the CControlSAP is to maintain a 
 *		queue for all indication and confirm messages that are eventually sent 
 *		back to the node controller.  
 *
 *		Commands received from the Application Interface (or Node Controller) 
 *		can be routed by the CControlSAP in one of two directions.  Either to the
 *		controller or to a specified conference.  Commands that are passed to 
 *		the controller, are done so using owner callbacks.  Commands that are 
 *		routed to conferences are done so using command target calls and are 
 *		routed based on a Conference ID.  Whenever a new CConf is 
 *		instantiated by the Controller, the CConf informs the CControlSAP 
 *		of its existence by registering its conference ID with it.  The 
 *		CControlSAP maintains a list of command target objects which are indexed
 *		by the conference ID.  
 *
 *	Caveats:
 *		Structures that are passed back to the node controller
 *		are defined in GCC.H.
 *
 *	Author:
 *		blp
 */

#ifndef _GCC_CONTROL_SAP_
#define _GCC_CONTROL_SAP_

/*
 * include files 
 */
#include "sap.h"
#include "password.h"
#include "privlist.h"
#include "conflist.h"

#define GCCNC_DIRECT_INDICATION
#define GCCNC_DIRECT_CONFIRM


/* 
 *	Structure used for passing conference create information from control sap
 *	to the controller.
 */

typedef struct
{
    GCCConfCreateReqCore    Core;
    CPassword               *convener_password;
    CPassword               *password;
    BOOL					fSecure;
    CUserDataListContainer  *user_data_list;
}
    CONF_CREATE_REQUEST;    // internal data structure


typedef struct
{
	GCCNumericString				conference_modifier;
	GCCConfID   					conference_id;
	BOOL							use_password_in_the_clear;
	PDomainParameters 				domain_parameters;
	UINT        					number_of_network_addresses;
	PGCCNetworkAddress 	*			network_address_list;
	CUserDataListContainer		    *user_data_list;
	GCCResult						result;
}
    ConfCreateResponseInfo, *PConfCreateResponseInfo;

typedef struct
{
	GCCNodeType					node_type;
	PGCCAsymmetryIndicator		asymmetry_indicator;
	TransportAddress			calling_address;
	TransportAddress			called_address;
	BOOL                        fSecure;
	CUserDataListContainer      *user_data_list;
	PConnectionHandle			connection_handle;
}
    ConfQueryRequestInfo, *PConfQueryRequestInfo;

typedef struct
{
	GCCResponseTag				query_response_tag;
	GCCNodeType					node_type;
	PGCCAsymmetryIndicator		asymmetry_indicator;
	CUserDataListContainer      *user_data_list;
	GCCResult					result;
}
    ConfQueryResponseInfo, *PConfQueryResponseInfo;

typedef struct
{
	PGCCConferenceName				conference_name;
	GCCNumericString				called_node_modifier;
	GCCNumericString				calling_node_modifier;
	CPassword                       *convener_password;
	CPassword                       *password_challenge;
	LPWSTR							pwszCallerID;
	TransportAddress				calling_address;
	TransportAddress				called_address;
	BOOL							fSecure;
	PDomainParameters 				domain_parameters;
	UINT        					number_of_network_addresses;
	PGCCNetworkAddress			*	local_network_address_list;
	CUserDataListContainer  	    *user_data_list;
	PConnectionHandle				connection_handle;
}
    ConfJoinRequestInfo, *PConfJoinRequestInfo;

typedef struct
{
	GCCConfID   					conference_id;
	CPassword                       *password_challenge;
	CUserDataListContainer  	    *user_data_list;
	GCCResult						result;
	ConnectionHandle				connection_handle;
}
    ConfJoinResponseInfo, *PConfJoinResponseInfo;

typedef struct
{
	UserID						user_id;
	ConnectionHandle			connection_handle;
	GCCConfID   				conference_id;
	BOOL						command_target_call;
}
    JoinResponseStructure, *PJoinResponseStructure;

typedef struct
{
	GCCConfID   			conference_id;
	GCCNumericString		conference_modifier;
	BOOL					fSecure;
	PDomainParameters 		domain_parameters;
	UINT        			number_of_network_addresses;
	PGCCNetworkAddress	*	local_network_address_list;
	CUserDataListContainer  *user_data_list;
	GCCResult				result;
}
    ConfInviteResponseInfo, *PConfInviteResponseInfo;

#ifdef NM_RESET_DEVICE
typedef struct
{
	LPSTR						device_identifier;
}
    ResetDeviceInfo, *PResetDeviceInfo;
#endif // #ifdef NM_RESET_DEVICE

/*
 *	Container used to hold the list of outstanding join response 
 *	structures.
 */
class CJoinResponseTagList2 : public CList2
{
    DEFINE_CLIST2(CJoinResponseTagList2, JoinResponseStructure*, GCCResponseTag)
};



//
//	This structure holds any data that may need to be deleted after a particular
//	GCC message is delivered.
//
typedef struct DataToBeDeleted
{
	LPSTR							pszNumericConfName;
	LPWSTR							pwszTextConfName;
	LPSTR							pszConfNameModifier;
	LPSTR							pszRemoteModifier;
	LPWSTR							pwszConfDescriptor;
	LPWSTR							pwszCallerID;
	LPSTR							pszCalledAddress;
	LPSTR							pszCallingAddress;
	LPBYTE							user_data_list_memory;
	DomainParameters                *pDomainParams;
	GCCConferencePrivileges         *conductor_privilege_list;
	GCCConferencePrivileges         *conducted_mode_privilege_list;
	GCCConferencePrivileges         *non_conducted_privilege_list;
	CPassword                       *convener_password;
	CPassword                       *password;
	CConfDescriptorListContainer    *conference_list;
	CAppRosterMsg					*application_roster_message;
	CConfRosterMsg					*conference_roster_message;
}
    DataToBeDeleted, *PDataToBeDeleted;

//
// Control SAP callback message.
//
typedef GCCMessage      GCCCtrlSapMsg;
typedef struct GCCCtrlSapMsgEx
{
    //
    // Message body
    //
    GCCCtrlSapMsg       Msg;

    //
    // Data to free later.
    //
    LPBYTE              pBuf;
    DataToBeDeleted     *pToDelete;
}
    GCCCtrlSapMsgEx, *PGCCCtrlSapMsgEx;


/*
 *	Class definition:
 */
class CControlSAP : public CBaseSap, public IT120ControlSAP
{
    friend class GCCController;
    friend class CConf;
    friend class CAppRosterMgr; // for AppRosterReportIndication()
    friend class MCSUser; // for ForwardedConfJoinIndication()

    friend LRESULT CALLBACK SapNotifyWndProc(HWND, UINT, WPARAM, LPARAM);

public:

    CControlSAP(void);
    ~CControlSAP(void);

    HWND GetHwnd ( void ) { return m_hwndNotify; }

    //
    // Node Controller (NC conference manager) callback
    //
    void RegisterNodeController ( LPFN_T120_CONTROL_SAP_CB pfn, LPVOID user_defined )
    {
        m_pfnNCCallback = pfn;
        m_pNCData = user_defined;
    }
    void UnregisterNodeController ( void )
    {
        m_pfnNCCallback = NULL;
        m_pNCData = NULL;
    }


    //
    // IT120ControlSAP
    //

    STDMETHOD_(void, ReleaseInterface) (THIS);

    /*
     *  GCCError    ConfCreateRequest()
     *        This routine is a request to create a new conference. Both 
     *        the local node and the node to which the create conference 
     *        request is directed to, join the conference automatically.  
     */
    STDMETHOD_(GCCError, ConfCreateRequest) (THIS_
                    GCCConfCreateRequest *,
                    GCCConfID *);

    /*    
     *  GCCError    ConfCreateResponse()
     *        This procedure is a remote node controller's response to a con-
     *        ference creation request by the convener. 
     */

    STDMETHOD_(GCCError, ConfCreateResponse) (THIS_
                    GCCNumericString            conference_modifier,
                    GCCConfID,
                    BOOL                        use_password_in_the_clear,
                    DomainParameters           *domain_parameters,
                    UINT                        number_of_network_addresses,
                    GCCNetworkAddress         **local_network_address_list,
                    UINT                        number_of_user_data_members,
                    GCCUserData               **user_data_list,
                    GCCResult);

    /*
     *  GCCError    ConfQueryRequest()
     *        This routine is a request to query a node for information about the
     *        conferences that exist at that node.
     */
    STDMETHOD_(GCCError, ConfQueryRequest) (THIS_
                    GCCNodeType                 node_type,
                    GCCAsymmetryIndicator      *asymmetry_indicator,
                    TransportAddress            calling_address,
                    TransportAddress            called_address,
                    BOOL                        fSecure,
                    UINT                        number_of_user_data_members,
                    GCCUserData               **user_data_list,
                    ConnectionHandle           *connection_handle);

    STDMETHOD_(void, CancelConfQueryRequest) (THIS_
                    ConnectionHandle);

    /*
     *  GCCError    ConfQueryResponse()
     *        This routine is called in response to a conference query request.
     */
    STDMETHOD_(GCCError, ConfQueryResponse) (THIS_
                    GCCResponseTag              query_response_tag,
                    GCCNodeType                 node_type,
                    GCCAsymmetryIndicator      *asymmetry_indicator,
                    UINT                        number_of_user_data_members,
                    GCCUserData               **user_data_list,
                    GCCResult);

    /*
     *  GCCError    AnnouncePresenceRequest()
     *        This routine is invoked by node controller when a node joins a 
     *        conference, to announce the presence of the new node to all
     *        other nodes of the conference. This should be followed by a
     *        GCCConferenceReport indication by the GCC to all nodes.
     */
    STDMETHOD_(GCCError, AnnouncePresenceRequest) (THIS_
                    GCCConfID,
                    GCCNodeType                 node_type,
                    GCCNodeProperties           node_properties,
                    LPWSTR                      pwszNodeName,
                    UINT                        number_of_participants,
                    LPWSTR                     *ppwszParticipantNameList,
                    LPWSTR                      pwszSiteInfo,
                    UINT                        number_of_network_addresses,
                    GCCNetworkAddress         **network_address_list,
                    LPOSTR                      alternative_node_id,
                    UINT                        number_of_user_data_members,
                    GCCUserData               **user_data_list);

    /*
     *  GCCError    ConfJoinRequest()
     *        This routine is invoked by node controller to cause the local
     *        node to join an existing conference.    
     */
    STDMETHOD_(GCCError, ConfJoinRequest) (THIS_
                    GCCConferenceName          *conference_name,
                    GCCNumericString            called_node_modifier,
                    GCCNumericString            calling_node_modifier,
                    GCCPassword                *convener_password,
                    GCCChallengeRequestResponse*password_challenge,
                    LPWSTR                      pwszCallerID,
                    TransportAddress            calling_address,
                    TransportAddress            called_address,
                    BOOL						fSecure,
                    DomainParameters           *domain_parameters,
                    UINT                        number_of_network_addresses,
                    GCCNetworkAddress         **local_network_address_list,
                    UINT                        number_of_user_data_members,
                    GCCUserData               **user_data_list,
                    ConnectionHandle           *connection_handle,
                    GCCConfID                  *pnConfID);

    /*
     *  GCCError    ConfJoinResponse()
     *        This routine is remote node controller's response to conference join 
     *        request by the local node controller.
     */
    STDMETHOD_(GCCError, ConfJoinResponse) (THIS_
                    GCCResponseTag              join_response_tag,
                    GCCChallengeRequestResponse*password_challenge,
                    UINT                        number_of_user_data_members,
                    GCCUserData               **user_data_list,
                    GCCResult);

    /*
     *  GCCError    ConfInviteRequest()
     *        This routine is invoked by node controller to invite a node  
     *        to join a conference.
     */
    STDMETHOD_(GCCError, ConfInviteRequest) (THIS_
                    GCCConfID,
                    LPWSTR                      pwszCallerID,
                    TransportAddress            calling_address,
                    TransportAddress            called_address,
                    BOOL						fSecure,
                    UINT                        number_of_user_data_members,
                    GCCUserData               **user_data_list,
                    ConnectionHandle           *connection_handle);

    STDMETHOD_(void, CancelInviteRequest) (THIS_
                    GCCConfID,
                    ConnectionHandle);

    /*
     *  GCCError    ConfInviteResponse()
     *        This routine is invoked by node controller to respond to an
     *        invite indication.
     */
    STDMETHOD_(GCCError, ConfInviteResponse) (THIS_
                    GCCConfID,
                    GCCNumericString            conference_modifier,
                    BOOL						fSecure,
                    DomainParameters           *domain_parameters,
                    UINT                        number_of_network_addresses,
                    GCCNetworkAddress         **local_network_address_list,
                    UINT                        number_of_user_data_members,
                    GCCUserData               **user_data_list,
                    GCCResult);

    /*
     *  GCCError    ConfAddResponse()
     */
    STDMETHOD_(GCCError, ConfAddResponse) (THIS_
                    GCCResponseTag              app_response_tag,
                    GCCConfID,
                    UserID                      requesting_node,
                    UINT                        number_of_user_data_members,
                    GCCUserData               **user_data_list,
                    GCCResult);

    /*
     *  GCCError    ConfLockResponse()
     *        This routine is invoked by node controller to respond to a
     *        lock indication.
     */
    STDMETHOD_(GCCError, ConfLockResponse) (THIS_
                    GCCConfID,
                    UserID                      requesting_node,
                    GCCResult);

    /*
     *  GCCError    ConfDisconnectRequest()
     *        This routine is used by a node controller to disconnect itself
     *        from a specified conference. GccConferenceDisconnectIndication
     *        sent to all other nodes of the conference. This is for client 
     *        initiated case.
     */
    STDMETHOD_(GCCError, ConfDisconnectRequest) (THIS_
                    GCCConfID);

    /*
     *  GCCError    ConfEjectUserRequest()
     */
    STDMETHOD_(GCCError, ConfEjectUserRequest) (THIS_
                    GCCConfID,
                    UserID                      ejected_node_id,
                    GCCReason);

    /*
     *  GCCError    AppletInvokeRequest()
     */
    STDMETHOD_(GCCError, AppletInvokeRequest) (THIS_
                    GCCConfID,
                    UINT                        number_of_app_protcol_entities,
                    GCCAppProtocolEntity      **app_protocol_entity_list,
                    UINT                        number_of_destination_nodes,
                    UserID                     *list_of_destination_nodes);

    /*
     *  GCCError    ConfRosterInqRequest()
     *        This routine is invoked to request a conference roster.  It can be
     *        called by either the Node Controller or the client application.
     */
    STDMETHOD_(GCCError, ConfRosterInqRequest) (THIS_
                    GCCConfID);

    /*
     *  GCCError    ConductorGiveResponse()
     */
    STDMETHOD_(GCCError, ConductorGiveResponse) (THIS_
                    GCCConfID,
                    GCCResult);

    /*
     *  GCCError    ConfTimeRemainingRequest()
     */
    STDMETHOD_(GCCError, ConfTimeRemainingRequest) (THIS_
                    GCCConfID,
                    UINT                        time_remaining,
                    UserID                      node_id);



    STDMETHOD_(GCCError, GetParentNodeID) (THIS_
                    GCCConfID,
                    GCCNodeID *);

#ifdef JASPER // ------------------------------------------------
    /*
     *  GCCError    ConfAddRequest()
     */
    STDMETHOD_(GCCError, ConfAddRequest) (THIS_
                    GCCConfID,
                    UINT                        number_of_network_addresses,
                    GCCNetworkAddress         **network_address_list,
                    UserID                      adding_node,
                    UINT                         number_of_user_data_members,
                    GCCUserData               **user_data_list);

    /*
     *  GCCError    ConfLockRequest()
     *        This routine is invoked by node controller to lock a conference.
     */
    STDMETHOD_(GCCError, ConfLockRequest) (THIS_
                    GCCConfID);

    /*
     *  GCCError    ConfUnlockRequest()
     *        This routine is invoked by node controller to unlock a conference.
     */
    STDMETHOD_(GCCError, ConfUnlockRequest) (THIS_
                    GCCConfID);

    /*
     *  GCCError    ConfUnlockResponse()
     *        This routine is invoked by node controller to respond to an
     *        unlock indication.
     */
    STDMETHOD_(GCCError, ConfUnlockResponse) (
                    GCCConfID,
                    UserID                      requesting_node,
                    GCCResult);

    /*
     *  GCCError    ConfTerminateRequest()
     */
    STDMETHOD_(GCCError, ConfTerminateRequest) (THIS_
                    GCCConfID,
                    GCCReason);

    /*
     *  GCCError    ConfTransferRequest()
     */
    STDMETHOD_(GCCError, ConfTransferRequest) (THIS_
                    GCCConfID,
                    GCCConferenceName          *destination_conference_name,
                    GCCNumericString            destination_conference_modifier,
                    UINT                        number_of_destination_addresses,
                    GCCNetworkAddress         **destination_address_list,
                    UINT                        number_of_destination_nodes,
                    UserID                     *destination_node_list,
                    GCCPassword                *password);

    /*
     *  GCCError    ConductorAssignRequest()
     */
    STDMETHOD_(GCCError, ConductorAssignRequest) (THIS_
                    GCCConfID);

    /*
     *  GCCError    ConductorReleaseRequest()
     */
    STDMETHOD_(GCCError, ConductorReleaseRequest) (THIS_
                    GCCConfID);

    /*
     *  GCCError    ConductorPleaseRequest()
     */
    STDMETHOD_(GCCError, ConductorPleaseRequest) (THIS_
                    GCCConfID);

    /*
     *  GCCError    ConductorGiveRequest()
     */
    STDMETHOD_(GCCError, ConductorGiveRequest) (THIS_
                    GCCConfID,
                    UserID                      recipient_user_id);

    /*
     *  GCCError    ConductorPermitAskRequest()
     */
    STDMETHOD_(GCCError, ConductorPermitAskRequest) (THIS_
                            GCCConfID,
                            BOOL                grant_permission);

    /*
     *  GCCError    ConductorPermitGrantRequest()
     */
    STDMETHOD_(GCCError, ConductorPermitGrantRequest) (THIS_
                    GCCConfID,
                    UINT                        number_granted,
                    UserID                     *granted_node_list,
                    UINT                        number_waiting,
                    UserID                     *waiting_node_list);

    /*
     *  GCCError    ConductorInquireRequest()
     */
    STDMETHOD_(GCCError, ConductorInquireRequest) (THIS_
                    GCCConfID);

    /*
     *  GCCError    ConfTimeInquireRequest()
     */
    STDMETHOD_(GCCError, ConfTimeInquireRequest) (THIS_
                    GCCConfID,
                    BOOL                        time_is_conference_wide);

    /*
     *  GCCError    ConfExtendRequest()
     */
    STDMETHOD_(GCCError, ConfExtendRequest) (THIS_
                    GCCConfID,
                    UINT                        extension_time,
                    BOOL                        time_is_conference_wide);

    /*
     *  GCCError    ConfAssistanceRequest()
     */
    STDMETHOD_(GCCError, ConfAssistanceRequest) (THIS_
                    GCCConfID,
                    UINT                        number_of_user_data_members,
                    GCCUserData               **user_data_list);

    /*
     *  GCCError    TextMessageRequest()
     */
    STDMETHOD_(GCCError, TextMessageRequest) (THIS_
                    GCCConfID,
                    LPWSTR                      pwszTextMsg,
                    UserID                      destination_node);
#endif // JASPER // ------------------------------------------------


#ifdef NM_RESET_DEVICE
    GCCError	ResetDevice ( LPSTR device_identifier );
#endif // NM_RESET_DEVICE

protected:

    //
    // These methods are called by GCC Controller.
    //

    GCCError	ConfCreateIndication (
    			PGCCConferenceName			conference_name,
    			GCCConfID   				conference_id,
    			CPassword                   *convener_password,
    			CPassword                   *password,
    			BOOL						conference_is_locked,
    			BOOL						conference_is_listed,
    			BOOL						conference_is_conductible,
    			GCCTerminationMethod		termination_method,
    			PPrivilegeListData			conductor_privilege_list,
    			PPrivilegeListData			conduct_mode_privilege_list,
    			PPrivilegeListData			non_conduct_privilege_list,
    			LPWSTR						pwszConfDescriptor,
    			LPWSTR						pwszCallerID,
    			TransportAddress			calling_address,
    			TransportAddress			called_address,
    			PDomainParameters			domain_parameters,
    			CUserDataListContainer      *user_data_list,
    			ConnectionHandle			connection_handle);

    GCCError	ConfQueryIndication (
    			GCCResponseTag				query_response_tag,
    			GCCNodeType					node_type,
    			PGCCAsymmetryIndicator		asymmetry_indicator,
    			TransportAddress			calling_address,
    			TransportAddress			called_address,
    			CUserDataListContainer      *user_data_list,
    			ConnectionHandle			connection_handle);

    GCCError	ConfQueryConfirm (
    			GCCNodeType					node_type,
    			PGCCAsymmetryIndicator		asymmetry_indicator,
    			CConfDescriptorListContainer *conference_list,
    			CUserDataListContainer      *user_data_list,
    			GCCResult					result,
    			ConnectionHandle			connection_handle);

    GCCError	ConfJoinIndication (
    			GCCConfID   				conference_id,
    			CPassword                   *convener_password,
    			CPassword                   *password_challenge,
    			LPWSTR						pwszCallerID,
    			TransportAddress			calling_address,
    			TransportAddress			called_address,
    			CUserDataListContainer      *user_data_list,
    			BOOL						intermediate_node,
    			ConnectionHandle			connection_handle);

    GCCError	ConfInviteIndication (
    			GCCConfID   			conference_id,
    			PGCCConferenceName		conference_name,
    			LPWSTR					pwszCallerID,
    			TransportAddress		calling_address,
    			TransportAddress		called_address,
		        BOOL					fSecure,
    			PDomainParameters 		domain_parameters,
    			BOOL					clear_password_required,
    			BOOL					conference_is_locked,
    			BOOL					conference_is_listed,
    			BOOL					conference_is_conductible,
    			GCCTerminationMethod	termination_method,
    			PPrivilegeListData		conductor_privilege_list,
    			PPrivilegeListData		conducted_mode_privilege_list,
    			PPrivilegeListData		non_conducted_privilege_list, 
    			LPWSTR					pwszConfDescriptor, 
    			CUserDataListContainer  *user_data_list,
    			ConnectionHandle		connection_handle);

#ifdef TSTATUS_INDICATION
    GCCError	TransportStatusIndication (
    				PTransportStatus		transport_status);

    GCCError	StatusIndication (
    				GCCStatusMessageType	status_message,
    				UINT					parameter);
#endif // TSTATUS_INDICATION

    GCCError	ConnectionBrokenIndication (
    				ConnectionHandle		connection_handle);

    //
    // These methods are called by CConf.
    //

    GCCError	ConfCreateConfirm (
    				PGCCConferenceName	  	conference_name,
    				GCCNumericString		conference_modifier,
    				GCCConfID   			conference_id,
    				PDomainParameters		domain_parameters,
    				CUserDataListContainer  *user_data_list,
    				GCCResult				result,
    				ConnectionHandle		connection_handle);

    GCCError	ConfDisconnectConfirm (
    			GCCConfID   		  			conference_id,
    			GCCResult						result);

    GCCError	ConfPermissionToAnnounce (
    				GCCConfID   			conference_id,
    				UserID					gcc_node_id);

    GCCError	ConfAnnouncePresenceConfirm (
    				GCCConfID   			conference_id,
    				GCCResult				result);

    GCCError	ConfDisconnectIndication (
    				GCCConfID   			conference_id,
    				GCCReason				reason,
    				UserID					disconnected_node_id);

    GCCError  	ForwardedConfJoinIndication (
    				UserID					sender_id,
    				GCCConfID   			conference_id,
    				CPassword               *convener_password,
    				CPassword               *password_challange,
    				LPWSTR					pwszCallerID,
    				CUserDataListContainer  *user_data_list);

    GCCError  	ConfJoinConfirm (
    				PGCCConferenceName		conference_name,
    				GCCNumericString		remote_modifier,
    				GCCNumericString		local_modifier,
    				GCCConfID   			conference_id,
    				CPassword               *password_challenge,
    				PDomainParameters		domain_parameters,
    				BOOL					password_in_the_clear,
    				BOOL					conference_locked,
    				BOOL					conference_listed,
    				BOOL					conference_conductible,
    				GCCTerminationMethod	termination_method,
    				PPrivilegeListData		conductor_privilege_list,
    				PPrivilegeListData		conduct_mode_privilege_list,
    				PPrivilegeListData		non_conduct_privilege_list,
    				LPWSTR					pwszConfDescription,
    				CUserDataListContainer  *user_data_list,	
    				GCCResult				result,
    				ConnectionHandle		connection_handle,
    				PBYTE                   pbRemoteCred,
    				DWORD                   cbRemoteCred);

    GCCError	ConfInviteConfirm (
    				GCCConfID   			conference_id,
    				CUserDataListContainer  *user_data_list,
    				GCCResult				result,
    				ConnectionHandle		connection_handle);

    GCCError	ConfTerminateIndication (
    				GCCConfID   			conference_id,
    				UserID					requesting_node_id,
    				GCCReason				reason);

    GCCError	ConfLockIndication (
    				GCCConfID   			conference_id,
    				UserID					source_node_id);

    GCCError	ConfEjectUserIndication (
    				GCCConfID   			conference_id,
    				GCCReason				reason,
    				UserID					gcc_node_id);

    GCCError	ConfTerminateConfirm (
    				GCCConfID   			conference_id,
    				GCCResult				result);

    GCCError	ConductorGiveIndication (
    				GCCConfID   			conference_id);

    GCCError	ConfTimeInquireIndication (
    				GCCConfID   			conference_id,
    				BOOL					time_is_conference_wide,
    				UserID					requesting_node_id);

#ifdef JASPER
    GCCError 	ConfLockReport (
    				GCCConfID   			conference_id,
    				BOOL					conference_is_locked);

    GCCError	ConfLockConfirm (
    				GCCResult				result,
    				GCCConfID   			conference_id);

    GCCError	ConfUnlockIndication (
    				GCCConfID   			conference_id,
    				UserID					source_node_id);

    GCCError 	ConfUnlockConfirm (
    				GCCResult				result,
    				GCCConfID   			conference_id);

    GCCError	ConfEjectUserConfirm (
    				GCCConfID   			conference_id,
    				UserID					ejected_node_id,
    				GCCResult				result);

    GCCError	ConductorAssignConfirm (
    				GCCResult				result,
    				GCCConfID   			conference_id);

    GCCError	ConductorReleaseConfirm (
    				GCCResult				result,
    				GCCConfID   			conference_id);

    GCCError	ConductorPleaseIndication (
    				GCCConfID   			conference_id,
    				UserID					requester_user_id);

    GCCError	ConductorPleaseConfirm (
    				GCCResult				result,
    				GCCConfID   			conference_id);

    GCCError	ConductorGiveConfirm (
    				GCCResult				result,
    				GCCConfID   			conference_id,
    				UserID					recipient_node);

    GCCError	ConductorPermitAskIndication (
    				GCCConfID   			conference_id,
    				BOOL					grant_flag,
    				UserID					requester_id);

    GCCError	ConductorPermitAskConfirm (
    				GCCResult				result,
    				BOOL					grant_permission,
    				GCCConfID   			conference_id);

    GCCError	ConductorPermitGrantConfirm (
    				GCCResult				result,
    				GCCConfID   			conference_id);

    GCCError	ConfTimeRemainingIndication (
    				GCCConfID   			conference_id,
    				UserID					source_node_id,
    				UserID					node_id,
    				UINT					time_remaining);

    GCCError	ConfTimeRemainingConfirm (
    				GCCConfID   			conference_id,
    				GCCResult				result);

    GCCError	ConfTimeInquireConfirm (
    				GCCConfID   			conference_id,
    				GCCResult				result);

    GCCError	ConfExtendIndication (
    				GCCConfID   			conference_id,
    				UINT					extension_time,
    				BOOL					time_is_conference_wide,
    				UserID                  requesting_node_id);

    GCCError 	ConfExtendConfirm (
    				GCCConfID   			conference_id,
    				UINT					extension_time,
    				GCCResult				result);

    GCCError	ConfAssistanceIndication (
    				GCCConfID   			conference_id,
    				CUserDataListContainer  *user_data_list,
    				UserID					source_node_id);

    GCCError	ConfAssistanceConfirm (
    				GCCConfID   	 		conference_id,
    				GCCResult				result);

    GCCError	TextMessageIndication (
    				GCCConfID   			conference_id,
    				LPWSTR					pwszTextMsg,
    				UserID					source_node_id);

    GCCError	TextMessageConfirm (
    				GCCConfID   			conference_id,
    				GCCResult				result);

    GCCError	ConfTransferIndication (
    				GCCConfID   		conference_id,
    				PGCCConferenceName	destination_conference_name,
    				GCCNumericString	destination_conference_modifier,
    				CNetAddrListContainer *destination_address_list,
    				CPassword           *password);

    GCCError	ConfTransferConfirm (
    				GCCConfID   		conference_id,
    				PGCCConferenceName	destination_conference_name,
    				GCCNumericString	destination_conference_modifier,
    				UINT				number_of_destination_nodes,
    				PUserID				destination_node_list,
    				GCCResult			result);
#endif // JASPER

    GCCError	ConfAddIndication (
    				GCCConfID   		conference_id,
    				GCCResponseTag		add_response_tag,
    				CNetAddrListContainer *network_address_list,
    				CUserDataListContainer *user_data_list,
    				UserID				requesting_node);

    GCCError	ConfAddConfirm (
    				GCCConfID   		conference_id,
    				CNetAddrListContainer *network_address_list,
    				CUserDataListContainer *user_data_list,
    				GCCResult			result);

    GCCError	SubInitializationCompleteIndication (
    				UserID				user_id,
    				ConnectionHandle	connection_handle);

    /* ------ pure virtual in CBaseSap (shared with CAppSap) ------ */

    GCCError	ConfRosterInquireConfirm (
    					GCCConfID,
    					PGCCConferenceName,
    					LPSTR           			conference_modifier,
    					LPWSTR						pwszConfDescriptor,
    					CConfRoster *,
    					GCCResult,
    					GCCAppSapMsgEx **);

    GCCError	AppRosterInquireConfirm (
    					GCCConfID,
    					CAppRosterMsg *,
    					GCCResult,
                        GCCAppSapMsgEx **);

    GCCError	ConductorInquireConfirm (
    					GCCNodeID				nidConductor,
    					GCCResult,
    					BOOL					permission_flag,
    					BOOL					conducted_mode,
    					GCCConfID);

    GCCError AppInvokeConfirm (
                        GCCConfID,
                        CInvokeSpecifierListContainer *,
                        GCCResult,
                        GCCRequestTag);

    GCCError AppInvokeIndication (
                        GCCConfID,
                        CInvokeSpecifierListContainer *,
                        GCCNodeID nidInvoker);

    GCCError ConfRosterReportIndication ( GCCConfID, CConfRosterMsg * );

    GCCError AppRosterReportIndication ( GCCConfID, CAppRosterMsg * );


    /* ------ from CBaseSap ------ */

	GCCError	ConductorAssignIndication (
					UserID					conductor_user_id,
					GCCConfID   			conference_id);

	GCCError	ConductorReleaseIndication (
					GCCConfID   			conference_id);

	GCCError	ConductorPermitGrantIndication (
					GCCConfID   			conference_id,
					UINT					number_granted,
					GCCNodeID				*granted_node_list,
					UINT					number_waiting,
					GCCNodeID				*waiting_node_list,
					BOOL					permission_is_granted);

protected:

    void NotifyProc ( GCCCtrlSapMsgEx * );
    void WndMsgHandler ( UINT uMsg, WPARAM wParam, LPARAM lParam );

private:

    GCCCtrlSapMsgEx * CreateCtrlSapMsgEx ( GCCMessageType, BOOL fUseToDelete = FALSE );
    void FreeCtrlSapMsgEx ( GCCCtrlSapMsgEx * );

#if defined(GCCNC_DIRECT_INDICATION) || defined(GCCNC_DIRECT_CONFIRM)
    void SendCtrlSapMsg ( GCCCtrlSapMsg *pCtrlSapMsg );
#endif // GCCNC_DIRECT_INDICATION

    void PostCtrlSapMsg ( GCCCtrlSapMsgEx *pCtrlSapMsgEx );
    void PostConfirmCtrlSapMsg ( GCCCtrlSapMsgEx *pCtrlSapMsgEx ) { PostCtrlSapMsg(pCtrlSapMsgEx); }
    void PostIndCtrlSapMsg ( GCCCtrlSapMsgEx *pCtrlSapMsgEx ) { PostCtrlSapMsg(pCtrlSapMsgEx); }

    void PostAsynDirectConfirmMsg ( UINT uMsg, WPARAM wParam, GCCConfID nConfID )
    {
        ASSERT(NULL != m_hwndNotify);
        ::PostMessage(m_hwndNotify, CSAPCONFIRM_BASE + uMsg, wParam, (LPARAM) nConfID);
    }

    void PostAsynDirectConfirmMsg ( UINT uMsg, GCCResult nResult, GCCConfID nConfID )
    {
        PostAsynDirectConfirmMsg(uMsg, (WPARAM) nResult, nConfID);
    }

    void PostAsynDirectConfirmMsg ( UINT uMsg, GCCResult nResult, GCCNodeID nid, GCCConfID nConfID )
    {
        PostAsynDirectConfirmMsg(uMsg, (WPARAM) MAKELONG(nResult, nid), nConfID);
    }

    void PostAsynDirectConfirmMsg ( UINT uMsg, GCCReason nReason, GCCNodeID nid, GCCConfID nConfID )
    {
        PostAsynDirectConfirmMsg(uMsg, (WPARAM) MAKELONG(nReason, nid), nConfID);
    }

    void PostAsynDirectConfirmMsg ( UINT uMsg, GCCResult nResult, BOOL flag, GCCConfID nConfID )
    {
        flag = ! (! flag);  // to make sure it is either TRUE or FALSE
        ASSERT(flag == TRUE || flag == FALSE);
        PostAsynDirectConfirmMsg(uMsg, (WPARAM) MAKELONG(nResult, flag), nConfID);
    }


    void HandleResourceFailure ( void )
    {
        ERROR_OUT(("CSAPHandleResourceFailure: Resource Error occurred"));
        #ifdef TSTATUS_INDICATION
        StatusIndication(GCC_STATUS_CTL_SAP_RESOURCE_ERROR, 0);
        #endif
    }
    void HandleResourceFailure ( GCCError rc )
    {
        if (GCC_ALLOCATION_FAILURE == rc)
        {
            HandleResourceFailure();
        }
    }

    GCCError		QueueJoinIndication (
    					GCCResponseTag				response_tag,
    					GCCConfID   				conference_id,
    					CPassword                   *convener_password,
    					CPassword                   *password_challenge,
    					LPWSTR						pwszCallerID,
    					TransportAddress			calling_address,
    					TransportAddress			called_address,
    					CUserDataListContainer      *user_data_list,
    					BOOL						intermediate_node,
    					ConnectionHandle			connection_handle);
    					
    BOOL			IsNumericNameValid ( GCCNumericString );

    BOOL			IsTextNameValid ( LPWSTR );

    GCCError		RetrieveUserDataList (
    					CUserDataListContainer  *user_data_list_object,
    					UINT					*number_of_data_members,
    					PGCCUserData 			**user_data_list,
    					LPBYTE                  *ppUserDataMemory);

private:

    //
    // Node Controller (NC conference manager) callback
    //
    LPFN_T120_CONTROL_SAP_CB    m_pfnNCCallback;
    LPVOID                      m_pNCData;

    GCCResponseTag              m_nJoinResponseTag;
    CJoinResponseTagList2       m_JoinResponseTagList2;
};


extern CControlSAP *g_pControlSap;


//
// Some handy utility functions to set up DataToBeDeleted in GCCCtrlSapMsgEx.
//
#ifdef GCCNC_DIRECT_INDICATION

__inline void
CSAP_CopyDataToGCCMessage_ConfName
(
    GCCConfName     *pSrcConfName,
    GCCConfName     *pDstConfName
)
{
    *pDstConfName = *pSrcConfName;
}

__inline void
CSAP_CopyDataToGCCMessage_Modifier
(
    GCCNumericString    pszSrc,
    GCCNumericString    *ppszDst
)
{
    *ppszDst = pszSrc;
}

__inline void
CSAP_CopyDataToGCCMessage_Password
(
    CPassword           *pSrcPassword,
    GCCPassword         **ppDstPassword
)
{
    *ppDstPassword = NULL;
    if (NULL != pSrcPassword)
    {
        pSrcPassword->LockPasswordData();
        pSrcPassword->GetPasswordData(ppDstPassword);
    }
}

__inline void
CSAP_CopyDataToGCCMessage_Challenge
(
    CPassword                       *pSrcPassword,
    GCCChallengeRequestResponse     **ppDstChallenge
)
{
    *ppDstChallenge = NULL;
    if (pSrcPassword != NULL)
    {
        pSrcPassword->LockPasswordData();
        pSrcPassword->GetPasswordChallengeData(ppDstChallenge);
    }
}

__inline void
CSAP_CopyDataToGCCMessage_PrivilegeList
(
    PrivilegeListData       *pSrcPrivilegeListData,
    GCCConfPrivileges       **ppDstPrivileges,
    GCCConfPrivileges       *pDstPlaceHolder
)
{
    if (pSrcPrivilegeListData != NULL)
    {
        *ppDstPrivileges = pDstPlaceHolder;
        *pDstPlaceHolder = *(pSrcPrivilegeListData->GetPrivilegeListData());
    }
    else
    {
        *ppDstPrivileges = NULL;
    }
}

__inline void
CSAP_CopyDataToGCCMessage_IDvsDesc
(
    LPWSTR          pwszSrc,
    LPWSTR          *ppwszDst
)
{
    *ppwszDst = pwszSrc;
}

__inline void
CSAP_CopyDataToGCCMessage_Call
(
    TransportAddress    pszSrcTransportAddr,
    TransportAddress    *ppszDstTransportAddr
)
{
    *ppszDstTransportAddr = pszSrcTransportAddr;
}

__inline void
CSAP_CopyDataToGCCMessage_DomainParams
(
    DomainParameters    *pSrcDomainParams,
    DomainParameters    **ppDstDomainParams,
    DomainParameters    *pDstPlaceHolder
)
{
    if (pSrcDomainParams != NULL)
    {
        *ppDstDomainParams = pDstPlaceHolder;
        *pDstPlaceHolder = *pSrcDomainParams;
    }
    else
    {
        *ppDstDomainParams = NULL;
    }
}

#endif // GCCNC_DIRECT_CALLBACK


void CSAP_CopyDataToGCCMessage_ConfName(
				PDataToBeDeleted		data_to_be_deleted,
				PGCCConferenceName		source_conference_name,
				PGCCConferenceName		destination_conference_name,
				PGCCError				pRetCode);

void CSAP_CopyDataToGCCMessage_Modifier(
				BOOL					fRemoteModifier,
				PDataToBeDeleted		data_to_be_deleted,
				GCCNumericString		source_numeric_string,
				GCCNumericString		*destination_numeric_string,
				PGCCError				pRetCode);

void CSAP_CopyDataToGCCMessage_Password(
				BOOL					fConvener,
				PDataToBeDeleted		data_to_be_deleted,
				CPassword               *source_password,
				PGCCPassword			*destination_password,
				PGCCError				pRetCode);

void CSAP_CopyDataToGCCMessage_Challenge(
				PDataToBeDeleted				data_to_be_deleted,
				CPassword                       *source_password,
				PGCCChallengeRequestResponse	*password_challenge,
				PGCCError						pRetCode);

void CSAP_CopyDataToGCCMessage_PrivilegeList(
				PPrivilegeListData			source_privilege_list_data,
				PGCCConferencePrivileges	*destination_privilege_list,
				PGCCError					pRetCode);

void CSAP_CopyDataToGCCMessage_IDvsDesc(
				BOOL				fCallerID,
				PDataToBeDeleted	data_to_be_deleted,
				LPWSTR				source_text_string,
				LPWSTR				*destination_text_string,
				PGCCError			pRetCode);

void CSAP_CopyDataToGCCMessage_Call(
				BOOL				fCalling,
				PDataToBeDeleted	data_to_be_deleted,
				TransportAddress	source_transport_address,
				TransportAddress	*destination_transport_address,
				PGCCError			pRetCode);

void CSAP_CopyDataToGCCMessage_DomainParams(
				PDataToBeDeleted	data_to_be_deleted,
				PDomainParameters	source_domain_parameters,
				PDomainParameters	*destination_domain_parameters,
				PGCCError			pRetCode);

/*
 *	Comments explaining the public and protected class member functions
 */

/*
 *	CControlSAP (		UINT        				owner_message_base,
 *						UINT						application_messsage_base);
 *
 *	Public member function of CControlSAP.
 *
 *	Function Description:
 *		This is the control sap constructor. It is responsible for
 *		registering control sap with the application interface via
 *		an owner callback.
 *
 *	Formal Parameters:
 *		owner_object			(i) The owner of this object (the controller)
 *		owner_message_base		(i) Offset into the controller callback message
 *										base.
 *		application_object		(i) The node controller interface object.
 *		application_messsage_base	(i) Offset into the node controller callback
 *											message base.
 *
 *	Return Value:
 *		None.
 *
 *  Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

/*
 *	~ControlSap ();
 *
 *	Public member function of CControlSAP.
 *
 *	Function Description:
 *		This is the CControlSAP destructor.  It is responsible for 
 *		flushing any pending upward bound messages and freeing all
 *		the resources tied up with pending messages.  Also it clears 
 *		the message queue and the queue of command targets that are registered
 *		with it.  Actually all command targets at this point should 
 *		already have been unregistered but this is just a double check.
 *
 *	Formal Parameters:
 *		None.
 *
 *	Return Value:
 *		None.
 *
 *  Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

/*
 *	GCCError	ConfCreateRequest(
 *						PGCCConferenceName			conference_name,
 *						GCCNumericString			conference_modifier,
 *						PGCCPassword				convener_password,
 *						PGCCPassword				password,
 *						BOOL						use_password_in_the_clear,
 *						BOOL						conference_is_locked,
 *						BOOL						conference_is_listed,
 *						BOOL						conference_is_conductible,
 *						GCCTerminationMethod		termination_method,
 *						PGCCConferencePrivileges	conduct_privilege_list,
 *						PGCCConferencePrivileges	conduct_mode_privilege_list,
 *						PGCCConferencePrivileges	non_conduct_privilege_list,
 *						LPWSTR						pwszConfDescriptor,
 *						LPWSTR						pwszCallerID,
 *						TransportAddress			calling_address,
 *						TransportAddress			called_address,
 *						PDomainParameters 			domain_parameters,
 *						UINT        				number_of_network_addresses,
 *						PGCCNetworkAddress 		*	local_network_address_list,
 *						UINT					   	number_of_user_data_members,
 *						PGCCUserData			*	user_data_list,				 
 *						PConnectionHandle			connection_handle);
 *
 *	Public member function of CControlSAP.
 *
 *	Function Description:
 *		This function is called by the interface when it gets a conference 
 *		create request from the node controller.  This function just passes this 
 *		request	to the controller via an owner callback. 
 *
 *	Formal Parameters:
 *		conference_name				(i) Name of the conference.
 *		conference_modifier			(i) Conference modifier numeric string.
 *		convener_password			(i) Password used for convener privileges.
 *		password					(i) Password used for conference create.
 *		use_password_in_the_clear	(i) Flag indicating use clear password.
 *		conference_is_locked		(i) Flag indicating if conference is locked.
 *		conference_is_listed		(i) Flag indicating if conference is listed
 *											in roster.
 *		conference_is_conductible	(i) Flag indicating if conference is
 *											conductable.
 *		termination_method			(i) Method of termination to use.
 *		conduct_privilege_list		(i) List of conductor privileges.
 *		conduct_mode_privilege_list	(i) List of privileges available when in
 *											conducted mode.
 *		non_conduct_privilege_list	(i) List of privileges available when not
 *											in conducted mode.
 *		pwszConfDescriptor			(i) Conference descriptor string.
 *		pwszCallerID				(i) Caller identifier string.
 *		calling_address				(i) Transport address of caller.
 *		called_address				(i) Transport address of party being called.
 *		domain_parameters			(i) Structure holding domain parameters.
 *		number_of_network_addresses	(i) Number of network addresses.
 *		local_network_address_list	(i) List of local network addresses.
 *		number_of_user_data_members	(i) Number of items in user data list.
 *		user_data_list				(i) List of user data items.
 *		connection_handle			(i) Logical connection handle.
 *
 *	Return Value:
 *		GCC_NO_ERROR					- No error occurred.
 *		GCC_ALLOCATION_FAILURE			- A resource error occurred.
 *		GCC_INVALID_CONFERENCE_NAME		- Invalid conference name passed in.
 *		GCC_INVALID_CONFERENCE_MODIFIER - Invalid conference modifier passed.
 *		GCC_FAILURE_CREATING_DOMAIN		- Failure creating domain.
 *		GCC_BAD_NETWORK_ADDRESS			- Bad network address passed in.
 *		GCC_BAD_NETWORK_ADDRESS_TYPE	- Bad network address type passed in.
 *		GCC_CONFERENCE_ALREADY_EXISTS	- Conference specified already exists.
 *		GCC_INVALID_TRANSPORT			- Cannot find specified transport.
 *		GCC_INVALID_ADDRESS_PREFIX		- Bad transport address passed in.
 *		GCC_INVALID_TRANSPORT_ADDRESS	- Bad transport address
 *		GCC_INVALID_PASSWORD			- Invalid password passed in.
 *		GCC_FAILURE_ATTACHING_TO_MCS	- Failure creating MCS user attachment
 *		GCC_BAD_USER_DATA				- Invalid user data passed in.
 *		GCC_BAD_CONNECTION_HANDLE_POINTER - Null connection handle ptr passed in
 *
 *  Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

/*
 *	GCCError	ConfCreateResponse (
 *						PGCCConferenceName			conference_name,
 *						GCCNumericString			conference_modifier,
 *						GCCConfID   				conference_id,
 *						BOOL						use_password_in_the_clear,
 *						PDomainParameters 			domain_parameters,
 *						UINT        				number_of_network_addresses,
 *						PGCCNetworkAddress 		*	local_network_address_list,
 *						UINT					   	number_of_user_data_members,
 *						PGCCUserData			*	user_data_list,				 
 *						GCCResult				 	result);
 *
 *	Public member function of CControlSAP.
 *
 *	Function Description:
 *		This function is called by the interface when it gets a conference 
 *		create response from the node controller, to be sent to the provider
 *		that issued the conference create request. This function just passes 
 *		this request to the controller via an owner callback. 
 *
 *	Formal Parameters:
 *		conference_name				(i) Name of conference.
 *		conference_modifier			(i) Conference modifier numeric string.
 *		conference_id				(i) Conference ID.
 *		use_password_in_the_clear	(i) Flag indicating password is clear.
 *		domain_parameters			(i) Structure holding domain parameters.
 *		number_of_network_addresses	(i) Number of local network addresses.
 *		local_network_address_list	(i) List of local network addresses.
 *		number_of_user_data_members	(i) Number of items in list of user data.
 *		user_data_list,				(i) List of user data items.
 *		result						(i) Result code for the create.
 *
 *	Return Value:
 *		GCC_NO_ERROR					- No error occurred.
 *		GCC_ALLOCATION_FAILURE			- A resource error occurred.
 *		GCC_INVALID_CONFERENCE			- An invalid conference was passed in.
 *		GCC_INVALID_CONFERENCE_NAME		- Invalid conference name passed in.
 *		GCC_INVALID_CONFERENCE_MODIFIER - Invalid conference modifier passed in.
 *		GCC_FAILURE_CREATING_DOMAIN		- Failure creating domain.
 *		GCC_CONFERENCE_ALREADY_EXISTS	- Conference specified already exists.
 *		GCC_BAD_USER_DATA				- Invalid user data passed in.
 *		GCC_FAILURE_ATTACHING_TO_MCS	- Failure creating MCS user attachment
 *
 *  Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

/*
 *	GCCError 	ConfQueryRequest (
 *						GCCNodeType					node_type,
 *						PGCCAsymmetryIndicator		asymmetry_indicator,
 *						TransportAddress			calling_address,
 *						TransportAddress			called_address,
 *						UINT				   		number_of_user_data_members,
 *						PGCCUserData			*	user_data_list,
 *						PConnectionHandle			connection_handle);
 *
 *	Public member function of CControlSAP.
 *
 *	Function Description:
 *		This function is called by the interface when it gets a conference 
 *		query request from the node controller. This function just passes 
 *		this request to the controller via an owner callback.   
 *
 *	Formal Parameters:
 *		node_type					(i)	Type of node (terminal, MCU, both).
 *		asymmetry_indicator			(i) Structure used to indicate caller and
 *											called nodes.
 *		calling_address				(i) Transport address of calling node.
 *		called_address				(i) Transport address of node being called.
 *		number_of_user_data_members	(i) Number of items in list of user data.
 *		user_data_list				(i) List of user data items.
 *		connection_handle			(i) Logical connection handle.
 *
 *	Return Value:
 *		GCC_NO_ERROR						- No error occurred.
 *		GCC_ALLOCATION_FAILURE				- A resource error occurred.
 *		GCC_INVALID_ADDRESS_PREFIX			- Bad transport address passed in.
 *		GCC_INVALID_TRANSPORT				- Bad transport address passed in.
 *		GCC_BAD_USER_DATA					- Invalid user data passed in.
 *		GCC_INVALID_TRANSPORT_ADDRESS		- Bad transport address passed in.
 *		GCC_BAD_CONNECTION_HANDLE_POINTER	- Bad connection handle ptr. passed.
 *		GCC_INVALID_NODE_TYPE				- Invalid node type passed in.
 *		GCC_INVALID_ASYMMETRY_INDICATOR		- Asymmetry indicator has invalid
 *													type.
 *
 *  Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

/*
 *	GCCError 	ConfQueryResponse (
 *						GCCResponseTag				query_response_tag,
 *						GCCNodeType					node_type,
 *						PGCCAsymmetryIndicator		asymmetry_indicator,
 *						UINT				   		number_of_user_data_members,
 *						PGCCUserData			*	user_data_list,
 *						GCCResult					result);
 *
 *	Public member function of CControlSAP.
 *
 *	Function Description:
 *		This function is called by the DLL interface when it gets a conference 
 *		query response from the node controller.  This function just passes 
 *		this response to the controller via an owner callback.  
 *
 *	Formal Parameters:
 *		query_response_tag			(i) Tag identifying the query response.
 *		node_type					(i) Type of node (terminal, MCU, both).
 *		asymmetry_indicator			(i) Structure used to identify the caller
 *											and called nodes.
 *		number_of_user_data_members	(i) Number of items in list of user data.
 *		user_data_list				(i) List of user data items.
 *		result						(i) Result code for query.
 *
 *	Return Value:
 *		GCC_NO_ERROR					- No error occurred.
 *		GCC_ALLOCATION_FAILURE			- A resource error occurred.
 *		GCC_BAD_NETWORK_ADDRESS			- Bad network address passed in.
 *		GCC_BAD_NETWORK_ADDRESS_TYPE	- Bad network address type passed in.
 *		GCC_BAD_USER_DATA				- Invalid user data passed in.
 *		GCC_INVALID_NODE_TYPE			- Invalid node type passed in.
 *		GCC_INVALID_ASYMMETRY_INDICATOR	- Invalid asymmetry indicator.
 *
 *  Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

/*
 *	GCCError	AnnouncePresenceRequest (
 *						GCCConfID   				conference_id,
 *						GCCNodeType					node_type,
 *						GCCNodeProperties			node_properties,
 *						LPWSTR						node_name,
 *						UINT						number_of_participants,
 *						LPWSTR					*	participant_name_list,
 *						LPWSTR						pwszSiteInfo,
 *						UINT        				number_of_network_addresses,
 *						PGCCNetworkAddress		*	network_address_list,
 *						LPOSTR      				alternative_node_id,
 *						UINT						number_of_user_data_members,
 *						PGCCUserData			*	user_data_list);
 *
 *	Public member function of CControlSAP.
 *
 *	Function Description:
 *		This function is called by the interface when it gets an announce 
 *		presence request from the node controller.  This function passes this
 *		request on to the appropriate conference object as obtained from
 *		the list of command targets that control sap maintains. The ConferenceID
 *		passed in is used to index the list of command targets to get the
 *		correct conference.
 *
 *	Formal Parameters:
 *		conference_id				(i)	Conference identifier value.
 *		node_type					(i) Type of node (terminal, MCU, both).
 *		node_properties				(i) Properties of the node.
 *		node_name					(i) Name of the node.
 *		number_of_participants		(i) Number of participants in the conference
 *		participant_name_list		(i) List of conference participants names.
 *		pwszSiteInfo				(i) Other information about the node.
 *		number_of_network_addresses	(i) Number of local network addresses.
 *		network_address_list		(i) List of local network addresses.
 *		alternative_node_id			(i) ID used to associate announcing node
 *											with an alternative node.
 *		number_of_user_data_members	(i) Number of items in list of user data.
 *		user_data_list				(i) List of user data items.
 *
 *	Return Value:
 *		GCC_NO_ERROR					- No error.
 *		GCC_ALLOCATION_FAILURE			- A resource error occurred.
 *		GCC_BAD_NETWORK_ADDRESS			- If an invalid network address is
 *										  		passed in as part of the record.	
 *		GCC_BAD_USER_DATA				- If an invalid user data list is
 *										  		passed in as part of the record.	
 *		GCC_CONFERENCE_NOT_ESTABLISHED	- Conference object has not completed 
 *										  		its establishment process.
 *		GCC_INVALID_NODE_TYPE			- Invalid node type passed in.
 *		GCC_INVALID_NODE_PROPERTIES		- Invalid node properties passed in.
 *		GCC_INVALID_CONFERENCE			- Conference not present.
 *
 *  Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

/*
 *	GCCError 	ConfJoinRequest (
 *					PGCCConferenceName				conference_name,
 *					GCCNumericString				called_node_modifier,
 *					GCCNumericString				calling_node_modifier,
 *					PGCCPassword					convener_password,
 *					PGCCChallengeRequestResponse	password_challenge,
 *					LPWSTR							pwszCallerID,
 *					TransportAddress				calling_address,
 *					TransportAddress				called_address,
 *					PDomainParameters 				domain_parameters,
 *					UINT        					number_of_network_addresses,
 *					PGCCNetworkAddress			*	local_network_address_list,
 *					UINT						   	number_of_user_data_members,
 *					PGCCUserData				*	user_data_list,
 *					PConnectionHandle				connection_handle);
 *
 *	Public member function of CControlSAP.
 *
 *	Function Description:
 *		This function is called by the interface when it gets a conference 
 *		join request from the node controller, to be sent to the top provider
 *		either directly or through a directly connected intermediate provider.
 *	    This function just passes this request to the controller via an owner 
 *		callback.  
 *
 *	Formal Parameters:
 *		conference_name				(i) Name of conference.
 *		called_node_modifier		(i)	Numeric modifier string for called node.
 *		calling_node_modifier		(i) Numeric modifier string for calling node
 *		convener_password			(i) Password used for convener privileges.
 *		password_challenge			(i) Password challenge used for join.
 *		pwszCallerID				(i) Calling node identifier string.
 *		calling_address				(i) Transport address of calling node.
 *		called_address				(i) Transport address of node being called.
 *		domain_parameters			(i) Structure holding domain parameters.
 *		number_of_network_addresses	(i) Number of local network addresses.
 *		local_network_address_list	(i) List of local network addresses.
 *		number_of_user_data_members	(i) Number of items in list of user data.
 *		user_data_list,				(i) List of user data items.
 *		connection_handle			(i)	Logical connection handle.
 *
 *	Return Value:
 *		GCC_NO_ERROR					- No error occurred.
 *		GCC_ALLOCATION_FAILURE			- A resource error occurred.
 *		GCC_INVALID_CONFERENCE_NAME		- Invalid conference name passed in.
 *		GCC_FAILURE_CREATING_DOMAIN		- Failure creating domain.
 *		GCC_BAD_NETWORK_ADDRESS			- Bad network address passed in.
 *		GCC_BAD_NETWORK_ADDRESS_TYPE	- Bad network address type passed in.
 *		GCC_CONFERENCE_ALREADY_EXISTS	- Conference specified already exists.
 *		GCC_INVALID_ADDRESS_PREFIX		- Bad transport address passed in.
 *		GCC_INVALID_TRANSPORT			- Bad transport address passed in.
 *		GCC_INVALID_PASSWORD			- Invalid password passed in.
 *		GCC_BAD_USER_DATA				- Invalid user data passed in.
 *		GCC_FAILURE_ATTACHING_TO_MCS	- Failure creating MCS user attachment
 *		GCC_INVALID_CONFERENCE_MODIFIER	- Invalid conference modifier passed in.
 *		GCC_BAD_CONNECTION_HANDLE_POINTER - Bad connection handle ptr. passed in
 *		GCC_INVALID_TRANSPORT_ADDRESS	- Called address passed in is NULL.
 *
 *  Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

/*
 *	GCCError 	ConfJoinResponse (
 *					GCCResponseTag					join_response_tag,
 *					PGCCChallengeRequestResponse	password_challenge,
 *					UINT						   	number_of_user_data_members,
 *					PGCCUserData				*	user_data_list,
 *					GCCResult						result);
 *
 *	Public member function of CControlSAP.
 *
 *	Function Description:
 *		This function is called by the interface when it gets a conference
 *		join response from the node controller.  This routine is responsible
 *		for routing the response to either the conference that made the
 *		request or the controller.  Responses which are routed to a conference
 *		are associated with requests that originate at a subnode that is a
 *		node removed from the Top Provider.
 *
 *	Formal Parameters:
 *		join_response_tag			(i) Tag identifying the join response.
 *		password_challenge			(i) Password challenge structure.
 *		number_of_user_data_members	(i) Number of user data items in list.
 *		user_data_list				(i) List of user data items.
 *		result						(i) Result of join.
 *
 *	Return Value:
 *		GCC_NO_ERROR					-	No error occurred.
 *		GCC_ALLOCATION_FAILURE			-	A resource error occurred.
 *		GCC_INVALID_JOIN_RESPONSE_TAG	-	No match found for join response tag
 *		GCC_INVALID_CONFERENCE_NAME		-	Invalid conference name passed in.
 *		GCC_FAILURE_CREATING_DOMAIN		-	Failure creating domain.
 *		GCC_CONFERENCE_ALREADY_EXISTS	-	Conference specified already exists.
 *		GCC_INVALID_PASSWORD			-	Invalid password passed in.
 *		GCC_BAD_USER_DATA				-	Invalid user data passed in.
 *		GCC_INVALID_CONFERENCE			-	Invalid conference ID passed in.
 *		GCC_DOMAIN_PARAMETERS_UNACCEPTABLE	- Domain parameters were
 *											  unacceptable for this connection.
 *
 *  Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

/*
 *	GCCError	ConfInviteRequest (
 *					GCCConfID   					conference_id,
 *					LPWSTR							pwszCallerID,
 *					TransportAddress				calling_address,
 *					TransportAddress				called_address,
 *					UINT						   	number_of_user_data_members,
 *					PGCCUserData				*	user_data_list,
 *					PConnectionHandle				connection_handle);
 *
 *	Public member function of CControlSAP.
 *
 *	Function Description:
 *		This function is called by the interface when it gets a conference
 *		invite request from the node controller.  This function passes the
 *		request on to the appropriate conference object as obtained from
 *		the list of command targets that the control sap maintains.  
 *
 *	Formal Parameters:
 *		conference_id				(i) Conference identifier.
 *		pwszCallerID				(i) Identifier string of calling node.
 *		calling_address				(i) Transport address of calling node.
 *		called_address				(i) Transport address of node being called. 
 *		number_of_user_data_members	(i) Number of items in user data list.
 *		user_data_list				(i) List of user data items.
 *		connection_handle			(i) Logical connection handle.
 *
 *	Return Value:
 *		GCC_NO_ERROR					- No error.
 *		GCC_ALLOCATION_FAILURE			- A resource error occurred.	
 *		GCC_INVALID_TRANSPORT_ADDRESS	- Something wrong with transport address
 *		GCC_INVALID_ADDRESS_PREFIX		- Invalid transport address prefix
 *		GCC_CONFERENCE_NOT_ESTABLISHED	- CConf object has not completed 
 *										  		its establishment process.
 *		GCC_BAD_CONNECTION_HANDLE_POINTER - Connection handle pointer invalid.
 *		GCC_INVALID_CONFERENCE 			- Invalid conference ID passed in.
 *
 *  Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

/*
 *	GCCError	ConfInviteResponse (
 *					GCCConfID   					conference_id,
 *					GCCNumericString				conference_modifier,
 *					PDomainParameters 				domain_parameters,
 *					UINT        					number_of_network_addresses,
 *					PGCCNetworkAddress 			*	local_network_address_list,
 *					UINT						   	number_of_user_data_members,
 *					PGCCUserData				*	user_data_list,
 *					GCCResult						result);
 *
 *	Public member function of CControlSAP.
 *
 *	Function Description:
 *		This function is called by the interface when it gets a conference
 *		invite response from the node controller.  This function passes the
 *		response on to the appropriate conference object as obtained from
 *		the list of command targets that the control sap maintains.  
 *
 *	Formal Parameters:
 *		conference_id				(i) Conference identifier.
 *		conference_modifier			(i) Modifier string for conference.
 *		domain_parameters			(i) Structure holding domain parameters.
 *		number_of_network_addresses	(i) Number of local network addresses.
 *		local_network_address_list	(i) List of local network addresses.
 *		number_of_user_data_members	(i) Number of items in list of user data.
 *		user_data_list,				(i) List of user data items.
 *		result						(i)	Result of invitation.
 *
 *	Return Value:
 *		GCC_NO_ERROR					- No error occurred.
 *		GCC_ALLOCATION_FAILURE			- A resource error occurred.
 *		GCC_INVALID_CONFERENCE_NAME		- Invalid conference name passed in.
 *		GCC_FAILURE_CREATING_DOMAIN		- Failure creating domain.
 *		GCC_CONFERENCE_ALREADY_EXISTS	- Conference specified already exists.
 *		GCC_BAD_USER_DATA				- Invalid user data passed in.
 *		GCC_INVALID_CONFERENCE			- Invalid conference ID passed in.
 *		GCC_FAILURE_ATTACHING_TO_MCS	- Failure creating MCS user attachment
 *		GCC_INVALID_CONFERENCE_MODIFIER	- Invalid conference modifier passed in.
 *		GCC_DOMAIN_PARAMETERS_UNACCEPTABLE	- Domain parameters were
 *											  unacceptable for this connection.
 *
 *  Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

/*
 *	GCCError 	ConfLockRequest (
 *						GCCConfID   					conference_id);
 *
 *	Public member function of CControlSAP.
 *
 *	Function Description:
 *		This function is called by the interface when it gets a conference
 *		lock request from the node controller.  This function passes the
 *		request on to the appropriate conference object as obtained from
 *		the list of command targets that the control sap maintains.
 *
 *	Formal Parameters:
 *		conference_id				(i) Conference identifier.
 *
 *	Return Value:
 *		GCC_NO_ERROR					- No error.
 *		GCC_ALLOCATION_FAILURE			- A resource error occurred.	
 *		GCC_CONFERENCE_NOT_ESTABLISHED	- CConf object has not completed 
 *										  		its establishment process.
 *		GCC_INVALID_CONFERENCE			- Conference ID not valid.
 *
 *  Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

/*
 *	GCCError 	ConfLockResponse (
 *						GCCConfID   					conference_id,
 *						UserID							requesting_node,
 *						GCCResult						result);
 *
 *	Public member function of CControlSAP.
 *
 *	Function Description:
 *		This function is called by the interface when it gets a conference
 *		lock response from the node controller.  This function passes the
 *		response on to the appropriate conference object as obtained from
 *		the list of command targets that the control sap maintains.
 *
 *	Formal Parameters:
 *		conference_id				(i) Conference identifier.
 *		requesting_node				(i) Node ID of the requesting node.
 *		result						(i) Result of conference lock request.
 *
 *	Return Value:
 *		GCC_NO_ERROR					- No error.
 *		GCC_ALLOCATION_FAILURE			- A resource error occurred.	
 *		GCC_CONFERENCE_NOT_ESTABLISHED	- CConf object has not completed 
 *										  		its establishment process.
 *		GCC_INVALID_CONFERENCE			- Conference ID not valid.
 *
 *  Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

/*
 *	GCCError 	ConfUnlockRequest (
 *						GCCConfID   					conference_id);
 *
 *	Public member function of CControlSAP.
 *
 *	Function Description:
 *		This function is called by the interface when it gets a conference
 *		unlock request from the node controller.  This function passes the
 *		request on to the appropriate conference object as obtained from
 *		the list of command targets that the control sap maintains.
 *
 *	Formal Parameters:
 *		conference_id				(i) Conference identifier.
 *
 *	Return Value:
 *		GCC_NO_ERROR					- No error.
 *		GCC_ALLOCATION_FAILURE			- A resource error occurred.	
 *		GCC_CONFERENCE_NOT_ESTABLISHED	- CConf object has not completed 
 *										  		its establishment process.
 *		GCC_INVALID_CONFERENCE			- Conference ID not valid.
 *
 *  Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

/*
 *	GCCError 	ConfUnlockResponse (
 *						GCCConfID   					conference_id,
 *						UserID							requesting_node,
 *						GCCResult						result);
 *
 *	Public member function of CControlSAP.
 *
 *	Function Description:
 *		This function is called by the interface when it gets a conference
 *		lock request from the node controller.  This function passes the
 *		request on to the appropriate conference object as obtained from
 *		the list of command targets that the control sap maintains.
 *
 *	Formal Parameters:
 *		conference_id				(i) Conference identifier.
 *		requesting_node				(i) Node ID of the requesting node.
 *		result						(i) Result of conference lock request.
 *
 *	Return Value:
 *		GCC_NO_ERROR					- No error.
 *		GCC_ALLOCATION_FAILURE			- A resource error occurred.	
 *		GCC_CONFERENCE_NOT_ESTABLISHED	- CConf object has not completed 
 *										  		its establishment process.
 *		GCC_INVALID_CONFERENCE			- Conference ID not valid.
 *
 *  Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

/*
 *	GCCError	ConfDisconnectRequest(
 *						GCCConfID   					conference_id);
 *
 *	Public member function of CControlSAP.
 *
 *	Function Description:
 *		This function is called by the interface when it gets a conference 
 *		disconnect request from the node controller.  This function passes the
 *		request on to the appropriate conference object as obtained from
 *		the list of command targets that the control sap maintains. 
 *
 *	Formal Parameters:
 *		conference_id				(i) Conference identifier.
 *
 *	Return Value:
 *		GCC_NO_ERROR					- No error.
 *		GCC_ALLOCATION_FAILURE			- A resource error occurred.
 *		GCC_INVALID_CONFERENCE			- Conference ID not valid.
 *
 *  Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

/*
 *	GCCError	ConfTerminateRequest(
 *						GCCConfID   					conference_id,
 *						GCCReason						reason);
 *
 *	Public member function of CControlSAP.
 *
 *	Function Description:
 *		This function is called by the interface when it gets a conference 
 *		terminate request from the node controller.  This function passes the
 *		request on to the appropriate conference object as obtained from
 *		the list of command targets that the control sap maintains. 
 *
 *	Formal Parameters:
 *		conference_id				(i) Conference identifier.
 *		reason						(i) Reason for the termination.
 *
 *	Return Value:
 *		GCC_NO_ERROR					- No error.
 *		GCC_ALLOCATION_FAILURE			- A resource error occurred.
 *		GCC_CONFERENCE_NOT_ESTABLISHED	- CConf object has not completed 
 *										  		its establishment process.
 *		GCC_INVALID_CONFERENCE			- Conference ID not valid.
 *
 *  Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

/*
 *	GCCError	ConfDisconnectConfirm (
 *						GCCConfID   		  			conference_id,
 *						GCCResult						result);
 *
 *	Public member function of CControlSAP.
 *
 *	Function Description:
 *		This function is called by the Conference when it need to send a 
 *		conference disconnect confirm to the node controller. It adds the 
 *		message	to a queue of messages to be sent to the node controller in 
 *		the next heartbeat.
 *
 *	Formal Parameters:
 *		conference_id				(i) Conference identifier.
 *		result						(i) Result of disconnect attempt.
 *
 *	Return Value:
 *		GCC_NO_ERROR					- No error.
 *		GCC_ALLOCATION_FAILURE			- A resource error occurred.
 *
 *  Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

/*
 *	GCCError 	ConfEjectUserRequest (
 *						GCCConfID   					conference_id,
 *						UserID							ejected_node_id,
 *						GCCReason						reason);
 *
 *	Public member function of CControlSAP.
 *
 *	Function Description:
 *		This function is called by the interface when it gets a conference 
 *		eject user request from the node controller.  This function passes the
 *		request on to the appropriate conference object as obtained from
 *		the list of command targets that the control sap maintains. 
 *
 *	Formal Parameters:
 *		conference_id				(i) Conference identifier.
 *		ejected_node_id				(i) Node ID of node being ejected.
 *		reason						(i) Reason for the ejection.
 *
 *	Return Value:
 *		GCC_NO_ERROR					- No error.
 *		GCC_ALLOCATION_FAILURE			- A resource error occurred.	
 *		GCC_CONFERENCE_NOT_ESTABLISHED	- CConf object has not completed 
 *										  		its establishment process.
 *		GCC_INVALID_MCS_USER_ID			- Invalid eject node ID.
 *		GCC_INVALID_CONFERENCE			- Invalid conference ID.
 *
 *  Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

/*
 *	GCCError	ConductorAssignRequest(
 *						GCCConfID   					conference_id);
 *
 *	Public member function of CControlSAP.
 *
 *	Function Description:
 *		This function is called by the interface when it gets a conductor
 *		assign request from the node controller.  This function passes the
 *		request on to the appropriate conference object as obtained from
 *		the list of command targets that the control sap maintains.
 *
 *	Formal Parameters:
 *		conference_id			(i) The conference identifier.
 *
 *	Return Value:
 *		GCC_NO_ERROR					- No error.
 *		GCC_ALLOCATION_FAILURE			- A resource error occurred.
 *		GCC_CONFERENCE_NOT_ESTABLISHED	- CConf object has not completed 
 *										  		its establishment process.
 *		GCC_INVALID_CONFERENCE			- Conference ID invalid.
 *
 *  Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

/*
 *	GCCError	ConductorReleaseRequest(
 *						GCCConfID   					conference_id);
 *
 *	Public member function of CControlSAP.
 *
 *	Function Description:
 *		This function is called by the interface when it gets a conductor
 *		release request from the node controller.  This function passes the
 *		request on to the appropriate conference object as obtained from
 *		the list of command targets that the control sap maintains.
 *
 *	Formal Parameters:
 *		conference_id			(i) The conference identifier.
 *
 *	Return Value:
 *		GCC_NO_ERROR					- No error.
 *		GCC_ALLOCATION_FAILURE			- A resource error occurred.
 *		GCC_CONFERENCE_NOT_ESTABLISHED	- CConf object has not completed 
 *										  		its establishment process.
 *		GCC_INVALID_CONFERENCE			- Conference ID invalid.
 *
 *  Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

/*
 *	GCCError	ConductorPleaseRequest(
 *						GCCConfID   					conference_id);
 *
 *	Public member function of CControlSAP.
 *
 *	Function Description:
 *		This function is called by the interface when it gets a conductor
 *		please request from the node controller.  This function passes the
 *		request on to the appropriate conference object as obtained from
 *		the list of command targets that the control sap maintains.
 *
 *	Formal Parameters:
 *		conference_id			(i) The conference identifier.
 *
 *	Return Value:
 *		GCC_NO_ERROR					- No error.
 *		GCC_ALLOCATION_FAILURE			- A resource error occurred.
 *		GCC_INVALID_CONFERENCE			- Conference ID is invalid.
 *
 *  Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

/*
 *	GCCError	ConductorGiveRequest(
 *						GCCConfID   					conference_id,
 *						UserID							recipient_user_id);
 *
 *	Public member function of CControlSAP.
 *
 *	Function Description:
 *		This function is called by the interface when it gets a conductor
 *		give request from the node controller.  This function passes the
 *		request on to the appropriate conference object as obtained from
 *		the list of command targets that the control sap maintains.
 *
 *	Formal Parameters:
 *		conference_id			(i) The conference identifier.
 *		recipient_user_id		(i) ID of user to give conductroship to.
 *
 *	Return Value:
 *		GCC_NO_ERROR					- No error.
 *		GCC_ALLOCATION_FAILURE			- A resource error occurred.
 *		GCC_INVALID_MCS_USER_ID			- Recipient user ID invalid.
 *		GCC_INVALID_CONFERENCE			- Conference ID invalid.
 *
 *  Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

/*
 *	GCCError	ConductorGiveResponse(
 *						GCCConfID   					conference_id,
 *						GCCResult						result);
 *
 *	Public member function of CControlSAP.
 *
 *	Function Description:
 *		This function is called by the interface when it gets a conductor
 *		give response from the node controller.  This function passes the
 *		response on to the appropriate conference object as obtained from
 *		the list of command targets that the control sap maintains.
 *
 *	Formal Parameters:
 *		conference_id			(i) The conference identifier.
 *		result					(i) Result of the conductorship give.
 *
 *	Return Value:
 *		GCC_NO_ERROR					- No error.
 *		GCC_ALLOCATION_FAILURE			- A resource error occurred.
 *		GCC_NO_GIVE_RESPONSE_PENDING	- A give indication was never issued.
 *		GCC_INVALID_CONFERENCE			- Conference ID invalid.
 *
 *  Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

/*
 *	GCCError	ConductorPermitGrantRequest(
 *						GCCConfID   					conference_id,
 *						UINT							number_granted,
 *						PUserID							granted_node_list,
 *						UINT							number_waiting,
 *						PUserID							waiting_node_list);
 *
 *	Public member function of CControlSAP.
 *
 *	Function Description:
 *		This function is called by the interface when it gets a conductor
 *		permit grant request from the node controller.  This function passes the
 *		request on to the appropriate conference object as obtained from
 *		the list of command targets that the control sap maintains.
 *
 *	Formal Parameters:
 *		 conference_id			(i) The conference identifier value.
 *		 number_granted			(i) Number of nodes being granted permission.
 *		 granted_node_list		(i) List of nodes being granted permission.
 *		 number_waiting			(i) Number of nodes waiting for permission.
 *		 waiting_node_list		(i) List of nodes waiting for permission.
 *
 *	Return Value:
 *		GCC_NO_ERROR					- No error.
 *		GCC_ALLOCATION_FAILURE			- A resource error occurred.
 *		GCC_INVALID_MCS_USER_ID			- Invalid user ID in the granted node
 *												list.
 *		GCC_INVALID_CONFERENCE			- The conference ID is invalid.
 *
 *  Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

/*
 *	GCCError 	ConfTimeRemainingRequest (
 *						GCCConfID   					conference_id,
 *						UINT							time_remaining,
 *						UserID							node_id);
 *
 *	Public member function of CControlSAP.
 *
 *	Function Description:
 *		This function is called by the interface when it gets a conference time
 *		remaining request from the node controller.  This function passes the
 *		request on to the appropriate conference object as obtained from
 *		the list of command targets that the control sap maintains.
 *
 *	Formal Parameters:
 *		conference_id			(i) Conference identifier value.
 *		time_remaining			(i) Time remaining in the conference (in sec.).
 *		node_id					(i) If present, indicates time remaining applies
 *										only to this node.
 *
 *	Return Value:
 *		GCC_NO_ERROR					- No error.
 *		GCC_ALLOCATION_FAILURE			- A resource error occurred.
 *		GCC_CONFERENCE_NOT_ESTABLISHED	- CConf object has not completed 
 *										  		its establishment process.
 *		GCC_INVALID_MCS_USER_ID			- Invalid node ID.
 *		GCC_INVALID_CONFERENCE			- Invalid conference ID.
 *
 *  Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

/*
 *	GCCError 	ConfTimeInquireRequest (
 *						GCCConfID   				conference_id,
 *						BOOL						time_is_conference_wide);
 *
 *	Public member function of CControlSAP.
 *
 *	Function Description:
 *		This function is called by the interface when it gets a conference time
 *		inquire request from the node controller.  This function passes the
 *		request on to the appropriate conference object as obtained from
 *		the list of command targets that the control sap maintains.
 *
 *	Formal Parameters:
 *		conference_id				(i) Conference identifier value.
 *		time_is_conference_wide		(i) Flag indicating request is for time
 *											remaining in entire conference.
 *
 *	Return Value:
 *		GCC_NO_ERROR					- No error.
 *		GCC_ALLOCATION_FAILURE			- A resource error occurred.
 *		GCC_CONFERENCE_NOT_ESTABLISHED	- CConf object has not completed 
 *										  		its establishment process.
 *		GCC_INVALID_CONFERENCE			- Conference ID invalid.
 *
 *  Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

/*
 *	GCCError	ConfExtendRequest (
 *						GCCConfID   				conference_id,
 *						UINT						extension_time,
 *						BOOL						time_is_conference_wide);
 *
 *	Public member function of CControlSAP.
 *
 *	Function Description:
 *		This function is called by the interface when it gets a conference
 *		extend request from the node controller.  This function passes the
 *		request on to the appropriate conference object as obtained from
 *		the list of command targets that the control sap maintains.
 *
 *	Formal Parameters:
 *		conference_id				(i) Conference identifier value.
 *		extension_time				(i) Amount of time to extend the
 *											conference (in seconds).
 *		time_is_conference_wide		(i) Flag indicating time extension is for
 *											entire conference.
 *
 *	Return Value:
 *		GCC_NO_ERROR					- No error.
 *		GCC_ALLOCATION_FAILURE			- A resource error occurred.
 *		GCC_CONFERENCE_NOT_ESTABLISHED	- CConf object has not completed 
 *										  		its establishment process.
 *		GCC_INVALID_CONFERENCE			- Conference ID invalid.
 *
 *  Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

/*
 *	GCCError	ConfAssistanceRequest (
 *						GCCConfID   				conference_id,
 *						UINT						number_of_user_data_members,
 *						PGCCUserData		  *		user_data_list);
 *
 *	Public member function of CControlSAP.
 *
 *	Function Description:
 *		This function is called by the interface when it gets a conference
 *		assistance request from the node controller.  This function passes the
 *		request on to the appropriate conference object as obtained from
 *		the list of command targets that the control sap maintains.
 *
 *	Formal Parameters:
 *		conference_id				(i) Conference identifier value.
 *		number_of_user_data_members	(i) Number of items in list of user data.
 *		user_data_list				(i) List of user data items.
 *
 *	Return Value:
 *		GCC_NO_ERROR					- No error.
 *		GCC_ALLOCATION_FAILURE			- A resource error occurred.
 *		GCC_CONFERENCE_NOT_ESTABLISHED	- CConf object has not completed 
 *										  		its establishment process.
 *		GCC_INVALID_CONFERENCE			- Conference ID invalid.
 *
 *  Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

/*
 *	GCCError 	TextMessageRequest (
 *						GCCConfID   					conference_id,
 *						LPWSTR							pwszTextMsg,
 *						UserID							destination_node );
 *
 *	Public member function of CControlSAP.
 *
 *	Function Description:
 *		This function is called by the interface when it gets a text message
 *		request from the node controller.  This function passes the
 *		request on to the appropriate conference object as obtained from
 *		the list of command targets that the control sap maintains.
 *
 *	Formal Parameters:
 *		conference_id				(i) Conference identifier value.
 *		pwszTextMsg					(i) Text message to send.
 *		destination_node			(i) ID of node to receive text message.
 *
 *	Return Value:
 *		GCC_NO_ERROR					- No error.
 *		GCC_ALLOCATION_FAILURE			- A resource error occurred.
 *		GCC_CONFERENCE_NOT_ESTABLISHED	- CConf object has not completed 
 *										  		its establishment process.
 *		GCC_INVALID_CONFERENCE			- Conference ID invalid.
 *		GCC_INVALID_MCS_USER_ID			- Destination node invalid.
 *
 *  Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

/*
 *	GCCError	ConfTransferRequest (
 *						GCCConfID   			conference_id,
 *						PGCCConferenceName		destination_conference_name,
 *						GCCNumericString		destination_conference_modifier,
 *						UINT        			number_of_destination_addresses,
 *						PGCCNetworkAddress		*destination_address_list,
 *						UINT					number_of_destination_nodes,
 *						PUserID					destination_node_list,
 *						PGCCPassword			password);
 *
 *	Public member function of CControlSAP.
 *
 *	Function Description:
 *		This function is called by the interface when it gets a conference
 *		transfer request from the node controller.  This function passes the
 *		request on to the appropriate conference object as obtained from
 *		the list of command targets that the control sap maintains.
 *
 *	Formal Parameters:
 *		conference_id					(i) Conference identifier value.
 *		destination_conference_name		(i) Name of conference to transfer to.
 *		destination_conference_modifier	(i) Name modifier of transfer conference
 *		number_of_destination_addresses	(i) Number of optional called addresses
 *												to be included in JoinRequest to
 *												be issued by transferring nodes.
 *		destination_address_list		(i) Optional called address parameter to
 *												be included in Join Request to
 *												be issued by transferring nodes.
 *		number_of_destination_nodes		(i)	Number of nodes to be transferred.
 *		destination_node_list			(i) List of nodes to be transferred.
 *		password						(i) Password to be used for joining
 *												transfer conference.
 *
 *	Return Value:
 *		GCC_NO_ERROR					- No error.
 *		GCC_ALLOCATION_FAILURE			- A resource error occurred.
 *		GCC_CONFERENCE_NOT_ESTABLISHED	- CConf object has not completed 
 *										  		its establishment process.
 *		GCC_INVALID_CONFERENCE_NAME		- Conference name is invalid.
 *		GCC_INVALID_CONFERENCE_MODIFIER	- Conference modifier is invalid.
 *		GCC_INVALID_PASSWORD			- Password is invalid.
 *		GCC_INVALID_MCS_USER_ID			- A destination node ID is invalid.
 *		GCC_INVALID_CONFERENCE			- Conference ID invalid.
 *
 *  Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

/*
 *	GCCError 	ConfAddRequest	(
 *						GCCConfID   			conference_id,
 *						UINT        			number_of_network_addresses,
 *						PGCCNetworkAddress	*	network_address_list,
 *						UserID					adding_node,
 *						UINT					number_of_user_data_members,
 *						PGCCUserData		*	user_data_list );
 *
 *	Public member function of CControlSAP.
 *
 *	Function Description:
 *		This function is called by the interface when it gets a conference
 *		add request from the node controller.  This function passes the
 *		request on to the appropriate conference object as obtained from
 *		the list of command targets that the control sap maintains.
 *
 *	Formal Parameters:
 *		conference_id				(i) Conference identifier value.
 *		number_of_network_addresses	(i) Number of network addresses in list
 *											of addresses of adding node.
 *		network_address_list		(i) List of addresses of adding node.
 *		adding_node					(i)	Node ID of node to add.
 *		number_of_user_data_members	(i) Number of items in list of user data.
 *		user_data_list 				(i) List of user data items.
 *
 *	Return Value:
 *		GCC_NO_ERROR					- No error.
 *		GCC_ALLOCATION_FAILURE			- A resource error occurred.
 *		GCC_CONFERENCE_NOT_ESTABLISHED	- CConf object has not completed 
 *										  		its establishment process.
 *		GCC_INVALID_MCS_USER_ID			- Adding node ID invalid.
 *		GCC_INVALID_CONFERENCE			- Conference ID invalid.
 *
 *  Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

/*
 *	GCCError 	ConfAddResponse (
 *						GCCResponseTag			add_response_tag,
 *						GCCConfID   			conference_id,
 *						UserID					requesting_node,
 *						UINT					number_of_user_data_members,
 *						PGCCUserData		*	user_data_list,
 *						GCCResult				result);
 *
 *	Public member function of CControlSAP.
 *
 *	Function Description:
 *		This function is called by the interface when it gets a conference
 *		add response from the node controller.  This function passes the
 *		response on to the appropriate conference object as obtained from
 *		the list of command targets that the control sap maintains.
 *
 *	Formal Parameters:
 *		add_response_tag			(i) Tag identifying the Add request.
 *		conference_id				(i) ID of conference to add node to.
 *		requesting_node				(i) ID of node requesting the Add.
 *		number_of_user_data_members	(i) Number of items in user data list.
 *		user_data_list				(i) List of user data items.
 *		result						(i) Result of Add.
 *
 *	Return Value:
 *		GCC_NO_ERROR					- No error.
 *		GCC_ALLOCATION_FAILURE			- A resource error occurred.
 *		GCC_CONFERENCE_NOT_ESTABLISHED	- CConf object has not completed 
 *										  its establishment process.
 *		GCC_INVALID_ADD_RESPONSE_TAG	- There was no match of the response tag
 *		GCC_INVALID_MCS_USER_ID			- Adding node ID invalid.
 *		GCC_INVALID_CONFERENCE			- Conference ID invalid.
 *
 *  Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

/*
 *	GCCError	ConfCreateIndication (
 *						PGCCConferenceName			conference_name,
 *						GCCConfID   				conference_id,
 *						CPassword                   *convener_password,
 *						CPassword                   *password,
 *						BOOL						conference_is_locked,
 *						BOOL						conference_is_listed,
 *						BOOL						conference_is_conductible,
 *						GCCTerminationMethod		termination_method,
 *						PPrivilegeListData			conductor_privilege_list,
 *						PPrivilegeListData			conduct_mode_privilege_list,
 *						PPrivilegeListData			non_conduct_privilege_list,
 *						LPWSTR						pwszConfDescriptor,
 *						LPWSTR						pwszCallerID,
 *						TransportAddress			calling_address,
 *						TransportAddress			called_address,
 *						PDomainParameters			domain_parameters,
 *						CUserDataListContainer      *user_data_list,
 *						ConnectionHandle			connection_handle);
 *
 *	Public member function of CControlSAP.
 *
 *	Function Description:
 *		This function is called by the GCC Controller when it gets a connect 
 *		provider indication from MCS, carrying a conference create request PDU.
 *		This function fills in all the parameters in the CreateIndicationInfo 
 *		structure. It then adds it to a queue of messages supposed to be sent to
 *		the node controller in the next heartbeat.
 *
 *	Formal Parameters:
 *		conference_name				(i) Name of the conference.
 *		conference_id				(i) ID of the conference.
 *		convener_password			(i) Password used for convener privileges.
 *		password					(i) Password used for access restriction.
 *		conference_is_locked		(i) Flag indicating whether conf. is locked.
 *		conference_is_listed		(i) Flag indicating whether conf. is listed.
 *		conference_is_conductible	(i) Flag indicating whether conference is
 *											conductable.
 *		termination_method			(i)	Type of termination method.
 *		conductor_privilege_list	(i) List of privileges granted to conductor
 *											by the convener.
 *		conduct_mode_privilege_list	(i) List of privileges granted to all nodes
 *											when in conducted mode.
 *		non_conduct_privilege_list	(i) List of privileges granted to all nodes
 *											when not in conducted mode.
 *		pwszConfDescriptor			(i) Conference descriptor string.
 *		pwszCallerID				(i) Caller identifier string.
 *		calling_address				(i) Transport address of calling node.
 *		called_address				(i) Tranport address of called node.
 *		domain_parameters			(i) Conference domain parameters.
 *		user_data_list				(i) List of user data items.
 *		connection_handle			(i) Logical connection handle.
 *
 *	Return Value:
 *		GCC_NO_ERROR				- Message successfully queued.
 *		GCC_ALLOCATION_FAILURE		- A resource allocation failure occurred.
 *
 *  Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

/*
 *	GCCError	ConfQueryIndication (
 *						GCCResponseTag				query_response_tag,
 *						GCCNodeType					node_type,
 *						PGCCAsymmetryIndicator		asymmetry_indicator,
 *						TransportAddress			calling_address,
 *						TransportAddress			called_address,
 *						CUserDataListContainer      *user_data_list,
 *						ConnectionHandle			connection_handle);
 *
 *	Public member function of CControlSAP.
 *
 *	Function Description:
 *		This function is called by the GCC Controller when it need to send a 
 *		conference query indication to the node controller. It adds the message
 *		to a queue of messages to be sent to the node controller in the next 
 *		heartbeat.
 *
 *	Formal Parameters:
 *		query_response_tag			(i)	Tag identifying this query.
 *		node_type					(i) Type of node (terminal, MCU, both).
 *		asymmetry_indicator			(i) Structure used to identify calling and
 *											called nodes.
 *		calling_address				(i) Transport address of calling node.
 *		called_address				(i) Transport address of called node.
 *		user_data_list				(i) List of user data items.
 *		connection_handle			(i) Logical connection handle.
 *
 *	Return Value:
 *		GCC_NO_ERROR				- Message successfully queued.
 *		GCC_ALLOCATION_FAILURE		- A resource allocation failure occurred.
 *
 *  Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

/*
 *	GCCError	ConfQueryConfirm (
 *						GCCNodeType					node_type,
 *						PGCCAsymmetryIndicator		asymmetry_indicator,
 *						CConfDescriptorListContainer *conference_list,
 *						CUserDataListContainer	    *user_data_list,
 *						GCCResult					result,
 *						ConnectionHandle			connection_handle);
 *
 *	Public member function of CControlSAP.
 *
 *	Function Description:
 *		This function is called by the GCC Controller when it need to send a 
 *		conference query confirm to the node controller. It adds the message
 *		to a queue of messages to be sent to the node controller in the next 
 *		heartbeat.
 *
 *	Formal Parameters:
 *		node_type					(i) Type of node (terminal, MCU, both).
 *		asymmetry_indicator			(i) Structure used to identify calling and
 *											called nodes.
 *		conference_list				(i) List of available conferences.
 *		user_data_list				(i) List of user data items.
 *		result						(i) Result of query.
 *		connection_handle			(i) Logical connection handle.
 *
 *	Return Value:
 *		GCC_NO_ERROR				- Message successfully queued.
 *		GCC_ALLOCATION_FAILURE		- A resource allocation failure occurred.
 *
 *  Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

/*
 *	GCCError	ConfJoinIndication(
 *						GCCConfID   				conference_id,
 *						CPassword                   *convener_password,
 *						CPassword                   *password_challenge,
 *						LPWSTR						pwszCallerID,
 *						TransportAddress			calling_address,
 *						TransportAddress			called_address,
 *						CUserDataListContainer      *user_data_list,
 *						BOOL						intermediate_node,
 *						ConnectionHandle			connection_handle);
 *
 *	Public member function of CControlSAP.
 *
 *	Function Description:
 *		This join indication is recevied from the owner object. This join
 *		indication is designed to make the join response very flexible at the 
 *		node controller.  The node controller can respond to this indication
 *		by either creating a new conference and moving the joiner into it, 
 *		putting the joiner in the conference requested or putting the joiner
 *		into a different conference that already exist.
 *
 *	Formal Parameters:
 *		conference_id				(i) Conference identifier value.
 *		convener_password			(i)	Password used for convener privileges.
 *		password_challenge			(i) Password challenge used for join.
 *		pwszCallerID				(i) Caller identifier string.
 *		calling_address				(i) Transport address of calling node.
 *		called_address				(i) Transport address of called node.
 *		user_data_list				(i) List of user data items.
 *		intermediate_node			(i) Flag indicating if join made at
 *											an intermediate node.
 *		connection_handle			(i) Logical connection handle.
 *
 *	Return Value:
 *
 *  Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

/*
 *	GCCError	???GCCConferenceQueryConfirm (
 *						GCCResponseTag				query_response_tag,
 *						GCCNodeType					node_type,
 *						PGCCAsymmetryIndicator		asymmetry_indicator,
 *						TransportAddress			calling_address,
 *						TransportAddress			called_address,
 *						CUserDataListContainer      *user_data_list,
 *						ConnectionHandle			connection_handle);
 *
 *	Public member function of CControlSAP.
 *
 *	Function Description:
 *		This function is called by the interface when it gets a conference
 *		add request from the node controller.  This function passes the
 *		request on to the appropriate conference object as obtained from
 *		the list of command targets that the control sap maintains.
 *
 *	Formal Parameters:
 *		conference_id				(i) Conference identifier value.
 *		number_of_network_addresses	(i) Number of network addresses in list
 *											of addresses of adding node.
 *		network_address_list		(i) List of addresses of adding node.
 *		adding_node					(i)	Node ID of node to add.
 *		number_of_user_data_members	(i) Number of items in list of user data.
 *		user_data_list 				(i) List of user data items.
 *
 *	Return Value:
 *
 *  Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

/*
 *	GCCError	ConfInviteIndication(
 *						GCCConfID   			conference_id,
 *						PGCCConferenceName		conference_name,
 *						LPWSTR					pwszCallerID,			  
 *						TransportAddress		calling_address,			  
 *						TransportAddress		called_address,				  
 *						PDomainParameters 		domain_parameters,			  
 *						BOOL					clear_password_required,
 *						BOOL					conference_is_locked,
 *						BOOL					conference_is_listed,
 *						BOOL					conference_is_conductible,
 *						GCCTerminationMethod	termination_method,
 *						PPrivilegeListData		conductor_privilege_list,	  
 *						PPrivilegeListData		conducted_mode_privilege_list,
 *						PPrivilegeListData		non_conducted_privilege_list, 
 *						LPWSTR					pwszConfDescriptor,		  
 *						CUserDataListContainer  *user_data_list,				  
 *						ConnectionHandle		connection_handle,
 *
 *	Public member function of CControlSAP.
 *
 *	Function Description:
 *		This function is called by the GCC Controller when it need to send a 
 *		conference invite indication to the node controller. It adds the message
 *		to a queue of messages to be sent to the node controller in the next 
 *		heartbeat.
 *
 *	Formal Parameters:
 *		conference_id					(i)	Conference identifier value.
 *		conference_name					(i) Name of conference.
 *		pwszCallerID	,			 	(i) Caller identifier value.
 *		calling_address,			 	(i) Transport address of calling node.
 *		called_address,				 	(i) Transport address of called node.
 *		domain_parameters,			 	(i) Conference domain parameters.
 *		clear_password_required			(i) Flag indicating if a clear password
 *												is required.
 *		conference_is_locked			(i) Flag indicating whether conference
 *												is locked.
 *		conference_is_listed			(i)	Flag indicating whether conference
 *												is listed.
 *		conference_is_conductible		(i)	Flag indicating whether conference
 *												is conductable.
 *		termination_method				(i)	Method of conference termination.
 *		conductor_privilege_list		(i) List of privileges granted to 
 *												conductor by the convener.
 *		conduct_mode_privilege_list		(i) List of privileges granted to all 
 *												nodes when in conducted mode.
 *		non_conducted_privilege_list	(i) List of privileges granted to all 
 *												nodes when not in conducted mode
 *		pwszConfDescriptor			 	(i)	Conference descriptor string.
 *		user_data_list				 	(i) List of user data items.
 *		connection_handle				(i) Logical connection handle.
 *
 *	Return Value:
 *
 *  Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

/*
 *	GCCError	TransportStatusIndication (
 *							PTransportStatus		transport_status);
 *
 *	Public member function of CControlSAP.
 *
 *	Function Description:
 *		This function is called by the GCC Controller when it need to send a 
 *		transport status indication to the node controller. It adds the 
 *		message	to a queue of messages to be sent to the node controller in 
 *		the next heartbeat.
 *
 *	Formal Parameters:
 *		transport_status			(i)	Transport status message.
 *
 *	Return Value:
 *
 *  Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

/*
 *	GCCError	StatusIndication (
 *							GCCStatusMessageType	status_message,
 *							UINT					parameter);
 *
 *	Public member function of CControlSAP.
 *
 *	Function Description:
 *		This function is called by the GCC Controller when it need to send a 
 *		status indication to the node controller. It adds the message to a  
 *		queue of messages to be sent to the node controller in the next 
 *		heartbeat.
 *
 *	Formal Parameters:
 *		status_message					(i)	GCC status message.
 *		parameter						(i) Parameter whose meaning depends 
 *												upon the type of message.
 *
 *	Return Value:
 *
 *  Side Effects:
 *		None.
 *
 *	Caveats:
 *		Note that we do not handle a resource error here to avoid an
 *		endless loop that could occur when this routine is called from the
 *		HandleResourceError() routine.
 */

/*
 *	GCCError	ConnectionBrokenIndication (	
 *							ConnectionHandle		connection_handle);
 *
 *	Public member function of CControlSAP.
 *
 *	Function Description:
 *		This function is called by the GCC Controller when it need to send a 
 *		connection broken indication to the node controller. It adds the 
 *		message	to a queue of messages to be sent to the node controller in 
 *		the next heartbeat.
 *
 *	Formal Parameters:
 *		connection_handle			(i)	Logical connection handle.
 *
 *	Return Value:
 *
 *  Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

/*
 *	GCCError	ConfCreateConfirm (
 *							PGCCConferenceName	  	conference_name,
 *							GCCNumericString		conference_modifier,
 *							GCCConfID   			conference_id,
 *							PDomainParameters		domain_parameters,			
 *							CUserDataListContainer  *user_data_list,				
 *							GCCResult				result,
 *							ConnectionHandle		connection_handle);
 *
 *	Public member function of CControlSAP.
 *
 *	Function Description:
 *		This function is called by the CConf when it need to send a 
 *		conference create confirm to the node controller. It adds the 
 *		message	to a queue of messages to be sent to the node controller in 
 *		the next heartbeat.
 *
 *	Formal Parameters:
 *		conference_name				(i) Conference name string.
 *		conference_modifier			(i) Conference modifier string.
 *		conference_id				(i) Conference identifier value.
 *		domain_parameters,			(i) Conference domain parameters.
 *		user_data_list,				(i) List of user data items.
 *		result						(i) Result of creation.
 *		connection_handle			(i) Logical connection handle.
 *
 *	Return Value:
 *
 *  Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

/*
 *	GCCError	ConfPermissionToAnnounce (
 *							GCCConfID   			conference_id,
 *							UserID					gcc_node_id);
 *
 *	Public member function of CControlSAP.
 *
 *	Function Description:
 *		This function is called by the CConf when it need to send a 
 *		conference permission to announce to the node controller. It adds the 
 *		message	to a queue of messages to be sent to the node controller in 
 *		the next heartbeat.
 *
 *	Formal Parameters:
 *		conference_id			(i)	Conference identifier value.
 *		gcc_node_id				(i) Node ID of node being given permission.
 *
 *	Return Value:
 *
 *  Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

/*
 *	GCCError	ConfAnnouncePresenceConfirm (
 *							GCCConfID   			conference_id,
 *							GCCResult				result);
 *
 *	Public member function of CControlSAP.
 *
 *	Function Description:
 *		This function is called by the CConf when it need to send a 
 *		conference announce presence confirm to the node controller. It adds the 
 *		message	to a queue of messages to be sent to the node controller in 
 *		the next heartbeat.
 *
 *	Formal Parameters:
 *		conference_id		(i)	Conference identifier value.
 *		result				(i) Result of announcing presence.
 *
 *	Return Value:
 *
 *  Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

/*
 *	GCCError	ConfDisconnectIndication (
 *							GCCConfID   			conference_id,
 *							GCCReason				reason,
 *							UserID					disconnected_node_id);
 *
 *	Public member function of CControlSAP.
 *
 *	Function Description:
 *		This function is called by the Conference when it need to send a 
 *		conference disconnect indication to the node controller. It adds the 
 *		message	to a queue of messages to be sent to the node controller in 
 *		the next heartbeat.
 *
 *	Formal Parameters:
 *		conference_id				(i) Conferenc identifier value.
 *		reason						(i) Reason for disconnection.
 *		disconnected_node_id		(i) Node ID of node disconnected.
 *
 *	Return Value:
 *
 *  Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

/*
 *	GCCError  	ConfJoinIndication (
 *							UserID					sender_id,
 *							GCCConfID   			conference_id,
 *							CPassword               *convener_password,
 *							CPassword               *password_challange,
 *							LPWSTR					pwszCallerID,
 *							CUserDataListContainer  *user_data_list);
 *
 *	Public member function of CControlSAP.
 *
 *	Function Description:
 *		This function is called by the CConf when it need to send a 
 *		conference join indication to the node controller. It adds the 
 *		message	to a queue of messages to be sent to the node controller in 
 *		the next heartbeat.
 *
 *	Formal Parameters:
 *		sender_id					(i)	ID of node sending join indication.
 *		conference_id				(i) Conference identifier value.
 *		convener_password			(i) Password used for convener privileges.
 *		password_challange			(i) Password challenge used for join.
 *		pwszCallerID				(i) Caller identifier string.
 *		user_data_list)				(i) List of user data items.
 *
 *	Return Value:
 *		GCC_NO_ERROR				- Message successfully queued.
 *		GCC_ALLOCATION_FAILURE		- A resource allocation failure occurred.
 *
 *  Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

/*
 *	GCCError  	ConfJoinConfirm (
 *							PGCCConferenceName		conference_name,
 *							GCCNumericString		remote_modifier,
 *							GCCNumericString		local_modifier,
 *							GCCConfID   			conference_id,
 *							CPassword               *password_challenge,
 *							PDomainParameters		domain_parameters,
 *							BOOL					password_in_the_clear,
 *							BOOL					conference_locked,
 *							BOOL					conference_listed,
 *							BOOL					conference_conductible,
 *							GCCTerminationMethod	termination_method,
 *							PPrivilegeListData		conductor_privilege_list,
 *							PPrivilegeListData		conduct_mode_privilege_list,
 *							PPrivilegeListData		non_conduct_privilege_list,
 *							LPWSTR					pwszConfDescription,
 *							CUserDataListContainer  *user_data_list,	
 *							GCCResult				result,
 *							ConnectionHandle		connection_handle);
 *
 *	Public member function of CControlSAP.
 *
 *	Function Description:
 *		This function is called by the CConf when it need to send a 
 *		conference join confirm to the node controller. It adds the 
 *		message	to a queue of messages to be sent to the node controller in 
 *		the next heartbeat.
 *
 *	Formal Parameters:
 *		conference_name				(i)	Conference name.
 *		remote_modifier				(i) Conference name modifier at remote node.
 *		local_modifier				(i) Conference name modifier at local node.
 *		conference_id				(i) Conference identifier value.
 *		password_challenge			(i) Password challenge used for join.
 *		domain_parameters			(i) Conference domain parameters.
 *		password_in_the_clear		(i) Flag indicating	password is clear.
 *		conference_locked			(i) Flag indicating conference is locked.
 *		conference_listed			(i) Flag indicating conference is listed.
 *		conference_conductible		(i) Flag indicating conference is 
 *											conductable.
 *		termination_method			(i) Method of termination.
 *		conductor_privilege_list	(i) List of privileges granted the conductor
 *											by the convener.
 *		conduct_mode_privilege_list	(i) List of privileges granted to all nodes
 *											when in conducted mode.
 *		non_conduct_privilege_list	(i)	List of privileges granted to all nodes
 *											when in conducted mode.
 *		pwszConfDescription			(i)	Conference description string.
 *		user_data_list,				(i) List of user data items.
 *		result						(i) Result of conference join.
 *		connection_handle			(i) Logical connection handle.
 *
 *	Return Value:
 *		GCC_NO_ERROR				- Message successfully queued.
 *		GCC_ALLOCATION_FAILURE		- A resource allocation failure occurred.
 *
 *  Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

/*
 *	GCCError	ConfInviteConfirm (
 *							GCCConfID   			conference_id,
 *							CUserDataListContainer  *user_data_list,
 *							GCCResult				result,
 *							ConnectionHandle		connection_handle);
 *
 *	Public member function of CControlSAP.
 *
 *	Function Description:
 *		This function is called by the CConf when it need to send a 
 *		conference invite confirm to the node controller. It adds the 
 *		message	to a queue of messages to be sent to the node controller in 
 *		the next heartbeat.
 *
 *	Formal Parameters:
 *		conference_id				(i)	Conference identifier value.
 *		user_data_list,				(i) List of user data items.
 *		result						(i) Result of conference join.
 *		connection_handle			(i) Logical connection handle.
 *
 *	Return Value:
 *		GCC_NO_ERROR				- Message successfully queued.
 *		GCC_ALLOCATION_FAILURE		- A resource allocation failure occurred.
 *
 *  Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */
 
/*
 *	GCCError	ConfTerminateIndication (
 *							GCCConfID   			conference_id,
 *							UserID					requesting_node_id,
 *							GCCReason				reason);
 *
 *	Public member function of CControlSAP.
 *
 *	Function Description:
 *		This function is called by the GCC Controller when it need to send a 
 *		conference terminate indication to the node controller. It adds the 
 *		message	to a queue of messages to be sent to the node controller in 
 *		the next heartbeat.
 *
 *	Formal Parameters:
 *		conference_id					(i)	Conference identifier value.
 *		requesting_node_id				(i) ID of node requesting termination.
 *		reason							(i) Reason for termination.
 *
 *	Return Value:
 *
 *  Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */


/*
 *	GCCError 	ConfLockReport (
 *							GCCConfID   			conference_id,
 *							BOOL					conference_is_locked);
 *
 *	Public member function of CControlSAP.
 *
 *	Function Description:
 *		This function is called by the CConf when it need to send a 
 *		conference lock report to the node controller. It adds the 
 *		message	to a queue of messages to be sent to the node controller in 
 *		the next heartbeat.
 *
 *	Formal Parameters:
 *		conference_id				(i)	Conference identifier value.
 *		conference_is_locked		(i) Flag indicating whether conference is
 *											locked.
 *
 *	Return Value:
 *		GCC_NO_ERROR				- Message successfully queued.
 *		GCC_ALLOCATION_FAILURE		- A resource allocation failure occurred.
 *
 *  Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

/*
 *	GCCError	ConfLockIndication (
 *							GCCConfID   			conference_id,
 *							UserID					source_node_id);
 *
 *	Public member function of CControlSAP.
 *
 *	Function Description:
 *		This function is called by the CConf when it need to send a 
 *		conference lock indication to the node controller. It adds the 
 *		message	to a queue of messages to be sent to the node controller in 
 *		the next heartbeat.
 *
 *	Formal Parameters:
 *		conference_id				(i)	Conference identifier value.
 *		source_node_id				(i) ID of node requesting lock.
 *
 *	Return Value:
 *		GCC_NO_ERROR				- Message successfully queued.
 *		GCC_ALLOCATION_FAILURE		- A resource allocation failure occurred.
 *
 *  Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

/*
 *	GCCError	ConfLockConfirm(
 *							GCCResult				result,
 *							GCCConfID   			conference_id);
 *
 *	Public member function of CControlSAP.
 *
 *	Function Description:
 *		This function is called by the CConf when it need to send a 
 *		conference lock confirm to the node controller. It adds the 
 *		message	to a queue of messages to be sent to the node controller in 
 *		the next heartbeat.
 *
 *	Formal Parameters:
 *		result						(i) Result of conference lock.
 *		conference_id				(i)	Conference identifier value.
 *
 *	Return Value:
 *		GCC_NO_ERROR				- Message successfully queued.
 *		GCC_ALLOCATION_FAILURE		- A resource allocation failure occurred.
 *
 *  Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

/*
 *	GCCError	ConfUnlockIndication (
 *							GCCConfID   			conference_id,
 *							UserID					source_node_id);
 *
 *	Public member function of CControlSAP.
 *
 *	Function Description:
 *		This function is called by the CConf when it need to send a 
 *		conference unlock indication to the node controller. It adds the 
 *		message	to a queue of messages to be sent to the node controller in 
 *		the next heartbeat.
 *
 *	Formal Parameters:
 *		conference_id				(i)	Conference identifier value.
 *		source_node_id				(i) ID of node requesting unlock.
 *
 *	Return Value:
 *		GCC_NO_ERROR				- Message successfully queued.
 *		GCC_ALLOCATION_FAILURE		- A resource allocation failure occurred.
 *
 *  Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

/*
 *	GCCError 	ConfUnlockConfirm (
 *							GCCResult				result,
 *							GCCConfID   			conference_id);
 *
 *	Public member function of CControlSAP.
 *
 *	Function Description:
 *		This function is called by the CConf when it need to send a 
 *		conference unlock confirm to the node controller. It adds the 
 *		message	to a queue of messages to be sent to the node controller in 
 *		the next heartbeat.
 *
 *	Formal Parameters:
 *		result						(i) Result of conference unlock.
 *		conference_id				(i)	Conference identifier value.
 *
 *	Return Value:
 *		GCC_NO_ERROR				- Message successfully queued.
 *		GCC_ALLOCATION_FAILURE		- A resource allocation failure occurred.
 *
 *  Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

/*
 *	GCCError	ConfEjectUserIndication (	
 *							GCCConfID   			conference_id,
 *							GCCReason				reason,
 *							UserID					gcc_node_id);
 *
 *	Public member function of CControlSAP.
 *
 *	Function Description:
 *		This function is called by the CConf when it need to send a 
 *		conference eject user indication to the node controller. It adds the 
 *		message	to a queue of messages to be sent to the node controller in 
 *		the next heartbeat.
 *
 *	Formal Parameters:
 *		conference_id				(i)	Conference identifier value.
 *		reason						(i) Reason for node ejection.
 *		gcc_node_id					(i) ID of node being ejected.
 *
 *	Return Value:
 *		GCC_NO_ERROR				- Message successfully queued.
 *		GCC_ALLOCATION_FAILURE		- A resource allocation failure occurred.
 *
 *  Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

/*
 *	GCCError	ConfEjectUserConfirm (
 *							GCCConfID   			conference_id,
 *							UserID					ejected_node_id,
 *							GCCResult				result);
 *
 *	Public member function of CControlSAP.
 *
 *	Function Description:
 *		This function is called by the CConf when it need to send a 
 *		conference eject user confirm to the node controller. It adds the 
 *		message	to a queue of messages to be sent to the node controller in 
 *		the next heartbeat.
 *
 *	Formal Parameters:
 *		conference_id				(i)	Conference identifier value.
 *		ejected_node_id				(i) ID of node being ejected.
 *		result						(i) Result of ejection attempt.
 *
 *	Return Value:
 *		GCC_NO_ERROR				- Message successfully queued.
 *		GCC_ALLOCATION_FAILURE		- A resource allocation failure occurred.
 *
 *  Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

/*
 *	GCCError	ConfTerminateConfirm (
 *							GCCConfID   			conference_id,
 *							GCCResult				result);
 *
 *	Public member function of CControlSAP.
 *
 *	Function Description:
 *		This function is called by the CConf when it need to send a 
 *		conference terminate confirm to the node controller. It adds the 
 *		message	to a queue of messages to be sent to the node controller in 
 *		the next heartbeat.
 *
 *	Formal Parameters:
 *		conference_id				(i)	Conference identifier value.
 *		result						(i) Result of termination attempt.
 *
 *	Return Value:
 *		GCC_NO_ERROR				- Message successfully queued.
 *		GCC_ALLOCATION_FAILURE		- A resource allocation failure occurred.
 *
 *  Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

/*
 *	GCCError	ConductorAssignConfirm (
 *							GCCResult				result,
 *							GCCConfID   			conference_id);
 *
 *	Public member function of CControlSAP.
 *
 *	Function Description:
 *		This function is called by the CConf when it need to send a 
 *		conductor assign confirm to the node controller. It adds the 
 *		message	to a queue of messages to be sent to the node controller in 
 *		the next heartbeat.
 *
 *	Formal Parameters:
 *		result						(i) Result of conductor assign attempt.
 *		conference_id				(i)	Conference identifier value.
 *
 *	Return Value:
 *		GCC_NO_ERROR				- Message successfully queued.
 *		GCC_ALLOCATION_FAILURE		- A resource allocation failure occurred.
 *
 *  Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

/*
 *	GCCError	ConductorReleaseConfirm (
 *							GCCResult				result,
 *							GCCConfID   			conference_id);
 *
 *	Public member function of CControlSAP.
 *
 *	Function Description:
 *		This function is called by the CConf when it need to send a 
 *		conductor release confirm to the node controller. It adds the 
 *		message	to a queue of messages to be sent to the node controller in 
 *		the next heartbeat.
 *
 *	Formal Parameters:
 *		result						(i) Result of conductor release attempt.
 *		conference_id				(i)	Conference identifier value.
 *
 *	Return Value:
 *		GCC_NO_ERROR				- Message successfully queued.
 *		GCC_ALLOCATION_FAILURE		- A resource allocation failure occurred.
 *
 *  Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

/*
 *	GCCError	ConductorPleaseIndication (
 *							GCCConfID   			conference_id,
 *							UserID					requester_user_id);
 *
 *	Public member function of CControlSAP.
 *
 *	Function Description:
 *		This function is called by the CConf when it need to send a 
 *		conductor please indication to the node controller. It adds the 
 *		message	to a queue of messages to be sent to the node controller in 
 *		the next heartbeat.
 *
 *	Formal Parameters:
 *		conference_id				(i)	Conference identifier value.
 *		requester_user_id			(i) ID of node requesting conductorship.
 *
 *	Return Value:
 *		GCC_NO_ERROR				- Message successfully queued.
 *		GCC_ALLOCATION_FAILURE		- A resource allocation failure occurred.
 *
 *  Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

/*
 *	GCCError	ConductorPleaseConfirm (	
 *							GCCResult				result,
 *							GCCConfID   			conference_id);
 *
 *	Public member function of CControlSAP.
 *
 *	Function Description:
 *		This function is called by the CConf when it need to send a 
 *		conductor please confirm to the node controller. It adds the 
 *		message	to a queue of messages to be sent to the node controller in 
 *		the next heartbeat.
 *
 *	Formal Parameters:
 *		result						(i) Result of conductor please attempt.
 *		conference_id				(i)	Conference identifier value.
 *
 *	Return Value:
 *		GCC_NO_ERROR				- Message successfully queued.
 *		GCC_ALLOCATION_FAILURE		- A resource allocation failure occurred.
 *
 *  Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

/*
 *	GCCError	ConductorGiveIndication (
 *							GCCConfID   			conference_id);
 *
 *	Public member function of CControlSAP.
 *
 *	Function Description:
 *		This function is called by the CConf when it need to send a 
 *		conductor give indication to the node controller. It adds the 
 *		message	to a queue of messages to be sent to the node controller in 
 *		the next heartbeat.
 *
 *	Formal Parameters:
 *		conference_id				(i)	Conference identifier value.
 *
 *	Return Value:
 *		GCC_NO_ERROR				- Message successfully queued.
 *		GCC_ALLOCATION_FAILURE		- A resource allocation failure occurred.
 *
 *  Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

/*
 *	GCCError	ConductorGiveConfirm (	
 *							GCCResult				result,
 *							GCCConfID   			conference_id,
 *							UserID					recipient_node);
 *
 *	Public member function of CControlSAP.
 *
 *	Function Description:
 *		This function is called by the CConf when it need to send a 
 *		conductor give confirm to the node controller. It adds the 
 *		message	to a queue of messages to be sent to the node controller in 
 *		the next heartbeat.
 *
 *	Formal Parameters:
 *		result						(i) Result of conductor assign attempt.
 *		conference_id				(i)	Conference identifier value.
 *		recipient_node				(i) ID of node receiving conductorship.
 *
 *	Return Value:
 *		GCC_NO_ERROR				- Message successfully queued.
 *		GCC_ALLOCATION_FAILURE		- A resource allocation failure occurred.
 *
 *  Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

/*
 *	GCCError	ConductorPermitAskIndication (	
 *							GCCConfID   			conference_id,
 *							BOOL					grant_flag,
 *							UserID					requester_id);
 *
 *	Public member function of CControlSAP.
 *
 *	Function Description:
 *		This function is called by the CConf when it need to send a 
 *		conductor permit ask indication to the node controller. It adds the 
 *		message	to a queue of messages to be sent to the node controller in 
 *		the next heartbeat.
 *
 *	Formal Parameters:
 *		conference_id				(i)	Conference identifier value.
 *		grant_flag					(i) Flag indicating whether conductorship
 *											is to be granted or given up.
 *		requester_id				(i)	ID of node asking for permission.
 *
 *	Return Value:
 *		GCC_NO_ERROR				- Message successfully queued.
 *		GCC_ALLOCATION_FAILURE		- A resource allocation failure occurred.
 *
 *  Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

/*
 *	GCCError	ConductorPermitAskConfirm (
 *							GCCResult				result,
 *							BOOL					grant_permission,
 *							GCCConfID   			conference_id);
 *
 *	Public member function of CControlSAP.
 *
 *	Function Description:
 *		This function is called by the CConf when it need to send a 
 *		conductor permit ask confirm to the node controller. It adds the 
 *		message	to a queue of messages to be sent to the node controller in 
 *		the next heartbeat.
 *
 *	Formal Parameters:
 *		result						(i) Result of conductor permit ask attempt.
 *		grant_permission			(i) Flag indicating whether conductor
 *											permission is granted.
 *		conference_id				(i)	Conference identifier value.
 *
 *	Return Value:
 *		GCC_NO_ERROR				- Message successfully queued.
 *		GCC_ALLOCATION_FAILURE		- A resource allocation failure occurred.
 *
 *  Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

/*
 *	GCCError	ConductorPermitGrantConfirm (
 *							GCCResult				result,
 *							GCCConfID   			conference_id);
 *
 *	Public member function of CControlSAP.
 *
 *	Function Description:
 *		This function is called by the CConf when it need to send a 
 *		conductor permit grant confirm to the node controller. It adds the 
 *		message	to a queue of messages to be sent to the node controller in 
 *		the next heartbeat.
 *
 *	Formal Parameters:
 *		result						(i) Result of conductor permit grant attempt
 *		conference_id				(i)	Conference identifier value.
 *
 *	Return Value:
 *		GCC_NO_ERROR				- Message successfully queued.
 *		GCC_ALLOCATION_FAILURE		- A resource allocation failure occurred.
 *
 *  Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

/*
 *	GCCError	ConfTimeRemainingIndication (
 *							GCCConfID   			conference_id,
 *							UserID					source_node_id,
 *							UserID					node_id,
 *							UINT					time_remaining);
 *
 *	Public member function of CControlSAP.
 *
 *	Function Description:
 *		This function is called by the CConf when it need to send a 
 *		conference time remaining indication to the node controller. It adds the 
 *		message	to a queue of messages to be sent to the node controller in 
 *		the next heartbeat.
 *
 *	Formal Parameters:
 *		conference_id				(i)	Conference identifier value.
 *		source_node_id				(i)	Node ID of the node that issued the
 *											time remaining request..
 *		node_id						(i)	Optional parameter which, if present,
 *											indicates that time remaining 
 *											applies only to node with this ID.
 *		time_remaining				(i)	Time remaining in conference (in sec.).
 *
 *	Return Value:
 *		GCC_NO_ERROR				- Message successfully queued.
 *		GCC_ALLOCATION_FAILURE		- A resource allocation failure occurred.
 *
 *  Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

/*
 *	GCCError	ConfTimeRemainingConfirm (
 *							GCCConfID   			conference_id,
 *							GCCResult				result);
 *
 *	Public member function of CControlSAP.
 *
 *	Function Description:
 *		This function is called by the CConf when it need to send a 
 *		conference time remaining confirm to the node controller. It adds the 
 *		message	to a queue of messages to be sent to the node controller in 
 *		the next heartbeat.
 *
 *	Formal Parameters:
 *		conference_id				(i)	Conference identifier value.
 *		result						(i) Result of time remaining request.
 *
 *	Return Value:
 *		GCC_NO_ERROR				- Message successfully queued.
 *		GCC_ALLOCATION_FAILURE		- A resource allocation failure occurred.
 *
 *  Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

/*
 *	GCCError	ConfTimeInquireIndication (
 *							GCCConfID   			conference_id,
 *							BOOL					time_is_conference_wide,
 *							UserID					requesting_node_id);
 *
 *	Public member function of CControlSAP.
 *
 *	Function Description:
 *		This function is called by the CConf when it need to send a 
 *		conference time inquire indication to the node controller. It adds the 
 *		message	to a queue of messages to be sent to the node controller in 
 *		the next heartbeat.
 *
 *	Formal Parameters:
 *		conference_id				(i)	Conference identifier value.
 *		time_is_conference_wide		(i) Flag indicating time inquire is for
 *											entire conference.
 *		requesting_node_id			(i) Node ID of node inquiring.
 *
 *	Return Value:
 *		GCC_NO_ERROR				- Message successfully queued.
 *		GCC_ALLOCATION_FAILURE		- A resource allocation failure occurred.
 *
 *  Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

/*
 *	GCCError	ConfTimeInquireConfirm (
 *							GCCConfID   			conference_id,
 *							GCCResult				result);
 *
 *	Public member function of CControlSAP.
 *
 *	Function Description:
 *		This function is called by the CConf when it need to send a 
 *		conference time inquire confirm to the node controller. It adds the 
 *		message	to a queue of messages to be sent to the node controller in 
 *		the next heartbeat.
 *
 *	Formal Parameters:
 *		conference_id				(i)	Conference identifier value.
 *		result						(i) Result of time inquire attempt.
 *
 *	Return Value:
 *		GCC_NO_ERROR				- Message successfully queued.
 *		GCC_ALLOCATION_FAILURE		- A resource allocation failure occurred.
 *
 *  Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

/*
 *	GCCError	ConfExtendIndication (
 *							GCCConfID   			conference_id,
 *							UINT					extension_time,
 *							BOOL					time_is_conference_wide,
 *							UserID                  requesting_node_id);
 *
 *	Public member function of CControlSAP.
 *
 *	Function Description:
 *		This function is called by the CConf when it need to send a 
 *		conference extend indication to the node controller. It adds the 
 *		message	to a queue of messages to be sent to the node controller in 
 *		the next heartbeat.
 *
 *	Formal Parameters:
 *		conference_id				(i)	Conference identifier value.
 *		extension_time				(i) Amount of time (in sec.) to extend
 *											conference.
 *		time_is_conference_wide		(i) Flag indicating time inquire is for
 *											entire conference.
 *		requesting_node_id			(i) Node ID of node requesting extension.
 *
 *	Return Value:
 *		GCC_NO_ERROR				- Message successfully queued.
 *		GCC_ALLOCATION_FAILURE		- A resource allocation failure occurred.
 *
 *  Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

/*
 *	GCCError 	ConfExtendConfirm (
 *							GCCConfID   			conference_id,
 *							UINT					extension_time,
 *							GCCResult				result);
 *
 *	Public member function of CControlSAP.
 *
 *	Function Description:
 *		This function is called by the CConf when it need to send a 
 *		conference extend confirm to the node controller. It adds the 
 *		message	to a queue of messages to be sent to the node controller in 
 *		the next heartbeat.
 *
 *	Formal Parameters:
 *		conference_id				(i)	Conference identifier value.
 *		extension_time				(i) Amount of time (in sec.) to extend
 *											conference.
 *		result						(i) Result of conductor assign attempt.
 *
 *	Return Value:
 *		GCC_NO_ERROR				- Message successfully queued.
 *		GCC_ALLOCATION_FAILURE		- A resource allocation failure occurred.
 *
 *  Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

/*
 *	GCCError	ConfAssistanceIndication (
 *							GCCConfID   			conference_id,
 *							CUserDataListContainer  *user_data_list,
 *							UserID					source_node_id);
 *
 *	Public member function of CControlSAP.
 *
 *	Function Description:
 *		This function is called by the CConf when it need to send a 
 *		conference assistance indication to the node controller. It adds the 
 *		message	to a queue of messages to be sent to the node controller in 
 *		the next heartbeat.
 *
 *	Formal Parameters:
 *		conference_id				(i)	Conference identifier value.
 *		user_data_list				(i) List of user data items.
 *		source_node_id				(i) Node ID of node requesting assistance.
 *
 *	Return Value:
 *		GCC_NO_ERROR				- Message successfully queued.
 *		GCC_ALLOCATION_FAILURE		- A resource allocation failure occurred.
 *
 *  Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

/*
 *	GCCError	ConfAssistanceConfirm (
 *							GCCConfID   	 		conference_id,
 *							GCCResult				result);
 *
 *	Public member function of CControlSAP.
 *
 *	Function Description:
 *		This function is called by the CConf  when it need to send a 
 *		conference assistance confirm to the node controller. It adds the 
 *		message	to a queue of messages to be sent to the node controller in 
 *		the next heartbeat.
 *
 *	Formal Parameters:
 *		conference_id				(i)	Conference identifier value.
 *		result						(i) Result of conference assistance attempt.
 *
 *	Return Value:
 *		GCC_NO_ERROR				- Message successfully queued.
 *		GCC_ALLOCATION_FAILURE		- A resource allocation failure occurred.
 *
 *  Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

/*
 *	GCCError	TextMessageIndication (
 *							GCCConfID   			conference_id,
 *							LPWSTR					pwszTextMsg,
 *							UserID					source_node_id);
 *
 *	Public member function of CControlSAP.
 *
 *	Function Description:
 *		This function is called by the CConf when it need to send a 
 *		text message indication to the node controller. It adds the 
 *		message	to a queue of messages to be sent to the node controller in 
 *		the next heartbeat.
 *
 *	Formal Parameters:
 *		conference_id				(i)	Conference identifier value.
 *		pwszTextMsg					(i) Text message being sent.
 *		source_node_id				(i) Node ID of node sending text message.
 *
 *	Return Value:
 *		GCC_NO_ERROR				- Message successfully queued.
 *		GCC_ALLOCATION_FAILURE		- A resource allocation failure occurred.
 *
 *  Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

/*
 *	GCCError	TextMessageConfirm ( 	
 *							GCCConfID   			conference_id,
 *							GCCResult				result);
 *
 *	Public member function of CControlSAP.
 *
 *	Function Description:
 *		This function is called by the CConf when it need to send a 
 *		text message confirm to the node controller. It adds the message 
 *		to a queue of messages to be sent to the node controller in the
 *		next heartbeat.
 *
 *	Formal Parameters:
 *		conference_id				(i)	Conference identifier value.
 *		result						(i) Result of text message send attempt.
 *
 *	Return Value:
 *		GCC_NO_ERROR				- Message successfully queued.
 *		GCC_ALLOCATION_FAILURE		- A resource allocation failure occurred.
 *
 *  Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

/*
 *	GCCError	ConfTransferIndication (
 *							GCCConfID   		conference_id,
 *							PGCCConferenceName	destination_conference_name,
 *							GCCNumericString	destination_conference_modifier,
 *							CNetAddrListContainer *destination_address_list,
 *							CPassword           *password);
 *
 *	Public member function of CControlSAP.
 *
 *	Function Description:
 *		This function is called by the CConf when it need to send a 
 *		conference transfer indication to the node controller. It adds the 
 *		message	to a queue of messages to be sent to the node controller in 
 *		the next heartbeat.
 *
 *	Formal Parameters:
 *		conference_id					(i)	Conference identifier value.
 *		destination_conference_name		(i)	Name of destination conference.
 *		destination_conference_modifier	(i) Name modifier of destination conf.
 *		destination_address_list		(i) List of network addresses for
 *												inclusion in the Join Request to
 *												be made by transferring nodes.
 *		password						(i)	Password to be used in Join	Request
 *												by transferring nodes.
 *
 *	Return Value:
 *		GCC_NO_ERROR				- Message successfully queued.
 *		GCC_ALLOCATION_FAILURE		- A resource allocation failure occurred.
 *
 *  Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

/*
 *	GCCError	ConfTransferConfirm (
 *							GCCConfID   		conference_id,
 *							PGCCConferenceName	destination_conference_name,
 *							GCCNumericString	destination_conference_modifier,
 *							UINT				number_of_destination_nodes,
 *			 				PUserID				destination_node_list,
 *							GCCResult			result);
 *
 *	Public member function of CControlSAP.
 *
 *	Function Description:
 *		This function is called by the CConf when it need to send a 
 *		conference transfer confirm to the node controller. It adds the 
 *		message	to a queue of messages to be sent to the node controller in 
 *		the next heartbeat.
 *
 *	Formal Parameters:
 *		conference_id					(i)	Conference identifier value.
 *		destination_conference_name		(i)	Name of destination conference.
 *		destination_conference_modifier	(i) Name modifier of destination conf.
 *		number_of_destination_nodes		(i) Number of nodes being transferred.
 *		destination_node_list			(i) List of nodes being transferred.
 *		result							(i) Result of conference transfer.
 *
 *	Return Value:
 *		GCC_NO_ERROR				- Message successfully queued.
 *		GCC_ALLOCATION_FAILURE		- A resource allocation failure occurred.
 *
 *  Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

/*
 *	GCCError	ConfAddIndication (
 *							GCCConfID   		conference_id,
 *							GCCResponseTag		add_response_tag,
 *							CNetAddrListContainer *network_address_list,
 *							CUserDataListContainer *user_data_list,
 *							UserID				requesting_node);
 *
 *	Public member function of CControlSAP.
 *
 *	Function Description:
 *		This function is called by the CConf when it need to send a 
 *		conference add indication to the node controller. It adds the 
 *		message	to a queue of messages to be sent to the node controller in 
 *		the next heartbeat.
 *
 *	Formal Parameters:
 *		conference_id				(i)	Conference identifier value.
 *		add_response_tag			(i)	Tag used to identify this add event.
 *		network_address_list		(i) Network addresses of node to be added.
 *		user_data_list				(i) List of user data items.
 *		requesting_node				(i) Node ID of node requesting the add.
 *
 *	Return Value:
 *		GCC_NO_ERROR				- Message successfully queued.
 *		GCC_ALLOCATION_FAILURE		- A resource allocation failure occurred.
 *
 *  Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

/*
 *	GCCError	ConfAddConfirm (
 *							GCCConfID   		conference_id,
 *							CNetAddrListContainer *network_address_list,
 *							CUserDataListContainer *user_data_list,
 *							GCCResult			result);
 *
 *	Public member function of CControlSAP.
 *
 *	Function Description:
 *		This function is called by the CConf when it need to send a 
 *		conference add confirm to the node controller. It adds the 
 *		message	to a queue of messages to be sent to the node controller in 
 *		the next heartbeat.
 *
 *	Formal Parameters:
 *		conference_id				(i)	Conference identifier value.
 *		network_address_list		(i) Network addresses of node to be added.
 *		user_data_list				(i) List of user data items.
 *		result						(i) Result of Add attempt.
 *
 *	Return Value:
 *		GCC_NO_ERROR				- Message successfully queued.
 *		GCC_ALLOCATION_FAILURE		- A resource allocation failure occurred.
 *
 *  Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

/*
 *	GCCError	SubInitializationCompleteIndication (
 *							UserID				user_id,
 *							ConnectionHandle	connection_handle);
 *
 *	Public member function of CControlSAP.
 *
 *	Function Description:
 *		This function is called by the CConf when it need to send a 
 *		sub-initialization complete indication to the node controller. This call
 *		tells this node that a node directly connected to it has initialized.
 *		It adds the message	to a queue of messages to be sent to the node 
 *		controller in the next heartbeat.
 *
 *	Formal Parameters:
 *		user_id						(i) Node ID of the intializing node. 
 *		connection_handle			(i) Logical connection handle for directly
 *											connected node.
 *
 *	Return Value:
 *		GCC_NO_ERROR				- Message successfully queued.
 *		GCC_ALLOCATION_FAILURE		- A resource allocation failure occurred.
 *
 *  Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

#endif // _GCC_CONTROL_SAP_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\remdsk\rds\t120\h\datapkt.h ===
/*
 *	datapkt.h
 *
 *	Copyright (c) 1997 by Microsoft Corporation, Redmond, WA
 *
 *	Abstract:
 *		This is the interface file for the MCS Data Packet class.  Instances of this
 *		class represent MCS Data Protocol Data Units (Data PDUs) as they flow through the
 *		system.  These instances allocate the memory required to hold both
 *		encoded and decoded versions of the PDU, and make sure that no PDU
 *		is ever encoded or decoded more than once.  However, they differ from normal
 *		packets, in that there is only one copy of the user data in the encoded 
 *		and decoded buffers.  The use of lock counts
 *		allows multiple objects in the system to reference and use the same
 *		packet object at the same time.  This class inherits from the SimplePacket
 *		class, which is a pure virtual class.
 *
 *		A data packet object can be created in two different ways.  It can be created
 *		with either decoded data or encoded data.  During instantiation, the
 *		new packet object will include the memory it will need to
 *		hold both the encoded and decoded data
 *		The DataPacket class, however, does not put any data into those buffers.
 *
 *		When a Lock message is sent to the object, it will put encoded
 *		data into the encode buffer.  If the packet was created
 *		with decoded data, then this will entail an encode operation.  However,
 *		if the packet was created with encoded data, then it is smart enough
 *		to just COPY the encoded data into the internal buffer, thus avoiding
 *		the overhead associated with the encode operation.
 *                  
 *		When a Lock message is sent to the object, it will put decoded
 *		data into the pre-allocated decode buffer.  If the packet was created
 *		with encoded data, then this will entail a decode operation.  However,
 *		if the packet was created with decoded data, then it is smart enough
 *		to just COPY the decoded data into the internal buffer, thus avoiding
 *		the overhead associated with the decode operation.
 *
 *		When Unlock messages are received, the lock count is decremented.  When a packet's
 *		lock count is 0, the packet deletes itself (it commits
 *		suicide).  Note that for this reason, no other object should explicitly
 *		delete a packet object.
 *                  
 *	Caveats:
 *		None.
 *
 *	Authors:
 *		Christos Tsollis
 */

#ifndef _DATAPACKET_
#define _DATAPACKET_

#include "mpdutype.h"

/*
 *	 Definition of class DataPacket.
 */

class DataPacket;
typedef DataPacket *		PDataPacket;

class DataPacket : public SimplePacket
{
	public:
		static Void		AllocateMemoryPool (long maximum_objects);
		static Void		FreeMemoryPool ();
		PVoid			operator new (size_t);
		Void			operator delete (PVoid	object);

						DataPacket (ASN1choice_t		choice,
									PUChar				data_ptr,
									ULong				data_length,
									UINT				channel_id,
									Priority			priority,
									Segmentation		segmentation,
									UINT				initiator_id,
									SendDataFlags		flags,
									PMemory				memory,
									PPacketError		packet_error);	
						DataPacket(	PTransportData		pTransportData,
									BOOL				fPacketDirectionUp);	
		virtual			~DataPacket ();
		Void			SetDirection (DBBoolean packet_direction_up);
		virtual PVoid	GetDecodedData(void);
		virtual BOOL	IsDataPacket (void);
		virtual int		GetPDUType (void);
		BOOL			Equivalent (PDataPacket);
		Priority		GetPriority (void) 
						{
							return ((Priority) m_DecodedPDU.u.send_data_request.
												data_priority);
						};
		UserID			GetInitiator (void)
						{
							return (m_DecodedPDU.u.send_data_request.initiator);
						};
		ChannelID		GetChannelID (void)
						{
							return (m_DecodedPDU.u.send_data_request.channel_id);
						};
		Segmentation	GetSegmentation (void)
						{
							return (m_DecodedPDU.u.send_data_request.segmentation);
						};
		LPBYTE			GetUserData (void)
						{
							return ((LPBYTE) m_DecodedPDU.u.send_data_request.user_data.value);
						};
		UINT			GetUserDataLength (void)
						{
							return (m_DecodedPDU.u.send_data_request.user_data.length);
						};
		PMemory			GetMemory (void)
						{
							return (m_Memory);
						};
		BOOL			IsEncodedDataBroken (void)
						{
							return (m_EncodedDataBroken);
						};

        void SetMessageType(UINT nMsgType) { m_nMessageType = nMsgType; }
        UINT GetMessageType(void) { return m_nMessageType; }

	protected:
	
		static PVoid *	Object_Array;
		static long		Object_Count;
		BOOL			fPreAlloc;

		DomainMCSPDU	m_DecodedPDU;	// The decoded data PDU (w/o the user data)
		PMemory			m_Memory;		// Memory object pointing to big buffer which contains the object's buffer.
		BOOL			m_fIncoming;	// Does this packet represent recv data?
		BOOL			m_EncodedDataBroken;
		UINT            m_nMessageType; // for retry in CUser::SendDataIndication
};


/*
 *	Void	AllocateMemoryPool (
 *					long			maximum_objects);
 *
 *	Functional Description:
 *		This is a static member function that should only be called during MCS
 *		initialization (exactly once).  It allocates a memory block that will
 *		be used to hold all instances of this class during the operation of
 *		the system.  This allows us to VERY efficiently allocate and destroy
 *		instances of this class.
 *
 *	Formal Parameters:
 *		maximum_objects
 *			This is the maximum number of objects of this class that can exist
 *			in the system at the same time.  This is used to determine how much
 *			memory to allocate to hold the objects.  Once this number of
 *			objects exist, all calls to "new" will return NULL.
 *
 *	Return Value:
 *		None.
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

/*
 *	Void	FreeMemoryPool ();
 *
 *	Functional Description:
 *		This is a static member function that should only be called during a
 *		shutdown of MCS (exactly once).  It frees up the memory pool allocated
 *		to hold all instances of this class.  Note that calling this function
 *		will cause ALL existing instances of this class to be invalid (they
 *		no longer exist, and should not be referenced).
 *
 *	Formal Parameters:
 *		None.
 *
 *	Return Value:
 *		None.
 *
 *	Side Effects:
 *		Any existing instances of this class are no longer valid and should not
 *		be referenced.
 *
 *	Caveats:
 *		None.
 */

/*
 *	PVoid	operator new (
 *					size_t			object_size);
 *
 *	Functional Description:
 *		This is an override of the "new" operator for this class.  Since all
 *		instances of this class come from a single memory pool allocated up
 *		front, this function merely pops the first entry from the list of
 *		available objects.
 *
 *	Formal Parameters:
 *		None.
 *
 *	Return Value:
 *		Pointer to an object of this class, or NULL if no memory is available.
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

/*
 *	Void	operator delete (
 *					PVoid			object);
 *
 *	Functional Description:
 *		This function is used to free up a previously allocated object of this
 *		class.  Note that it is VERY important not to call this function with an
 *		invalid address, because no error checking is performed.  This decision
 *		was made due to speed requirements.
 *
 *	Formal Parameters:
 *		None.
 *
 *	Return Value:
 *		None.
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

/*
 *	DataPacket(	PUChar			pEncodedData,
 *				ULong			ulEncodedDataSize,
 *				BOOL			fPacketDirectionUp,
 *				PPacketError	pePktErr)
 *
 *	Functional Description:
 *		This version of the constructor is used to create a Data Packet object
 *		for incomming PDUs when the packet is to be created from an encoded
 *		data stream containing the PDU data to be decoded.
 *
 *	Formal Parameters:
 *		pEncodedData (i)
 *			Pointer to the input encoded PDU.
 *		ulEncodedDataSize (i)
 *			The length in bytes of the input encoded PDU.
 *		fPacketDirectionUp (i)
 *			The packet_direction_up flag indicates the initial orientation of
 *			the packet.  Valid values are:
 *				TRUE -	The packet's direction is up.
 *				FALSE -	The packet's direction is down.
 *		pePktErr (o)
 *			When the constructor returns control to the calling function, this
 *			variable will be set to one of the return values listed below.
 *
 *	Return Value:
 *		None.
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */							      

/*
 *	DataPacket (ASN1choice_t	choice,
 *				PUChar			data_ptr,
 *				ULong			data_length,
 *				UINT			channel_id,
 *				Priority		priority,
 *				Segmentation	segmentation,
 *				UINT			initiator_id,
 *				PPacketError	packet_error)
 *
 *	Functional Description:
 *		This constructor is used for outgoing data packets.
 *		It needs to copy the data into the encoded PDU buffer
 *		that will be allocated by this constructor.
 *
 *	Formal Parameters:
 *		choice (i)
 *			Either normal or uniform send data PDU
 *		data_ptr (i)
 *			Pointer to the user data for this data PDU.
 *		data_length (i)
 *			The length of the user data
 *		channel_id (i)
 *			The MCS channel on which the data will be xmitted.
 *		priority (i)
 *			Data priority
 *		segmentation (i)
 *			The segmentation bits for the packet
 *		initiator_id (i)
 *			MCS user id of the user (application) sending the data
 *		packet_error (o)
 *			Ptr to location for storing the success/failure code for the constructor.
 *
 *	Return Value:
 *		None.
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */	
/*
 *	~DataPacket ()
 *
 *	Functional Description:
 *		Destructor for the DataPacket class.  The destructor ensures that all 
 *		resources that have been allocated are freed.
 *
 *	Formal Parameters:
 *		None.
 *
 *	Return Value:
 *		None.
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

/*
 *	GetDecodedData ()
 *
 *	Functional Description:
 *		The GetDecodedData method returns a pointer to the decoded data
 *		buffer.  
 *
 *	Formal Parameters:
 *		None.
 *
 *	Return Value:
 *		A pointer to the decoded data.  If an decoding error occurs, this
 *		method will return NULL.
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

/*
 *	GetEncodedDataLength ()
 *
 *	Functional Description:
 *		This method returns the encoded data's length.
 *
 *	Formal Parameters:
 *		None.
 *
 *	Return Value:
 *		The number of bytes in the encoded data.
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

/*
 *	GetDecodedDataLength ()
 *
 *	Functional Description:
 *		This method returns the decoded data's length.
 *
 *	Formal Parameters:
 *		None.
 *
 *	Return Value:
 *		The number of bytes in the decoded data.
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\remdsk\rds\t120\h\crc.h ===
/*	crc.h
 *
 *	Copyright (c) 1994-1995 by DataBeam Corporation, Lexington, KY
 *
 *	Abstract:
 *		This file contains the CRC class definition.  This class can use either
 *		the table-driven or bit-shifting approach to generate its CRC.
 *
 *	Public Instance Variable:
 *		None
 *
 *	Caveats:
 *		None.
 *
 *	Authors:
 *		Marvin Nicholson
 */

#ifndef _CRC_
#define _CRC_

#include "databeam.h"

#define	CRC_TABLE_SIZE	256

class	CRC
{
	public:
				CRC ();
				~CRC ();

		ULong 	OldCRCGenerator(
					PUChar	block_adr,
					ULong	block_len);
		ULong 	CRCGenerator(
					PUChar	block_adr,
					ULong	block_len);
		DBBoolean CheckCRC(
					PUChar	block_adr,
					ULong	block_len);
		Void	GetOverhead(
					UShort		maximum_packet,
					PUShort		new_maximum_packet);

	private:
		UShort		CRCTableValue(
						Int		Index,
						ULong	poly);
		Void		CRCTableGenerator(
						ULong poly);

        UShort		CRC_Table[CRC_TABLE_SIZE];
		Int			CRC_Width;
        ULong		CRC_Poly;
        ULong		CRC_Init;
        UShort		CRC_Check_Value;
		DBBoolean	Invert;
		UShort		CRC_Register;

};
typedef CRC *	PCRC;

#endif

/*	
 *	CRC::CRC ();
 *
 *	Functional Description
 *		This is the constructor for this class.
 *
 *	Formal Parameters
 *		None.
 *
 *	Return Value
 *		None
 *
 *	Side Effects
 *		None
 *
 *	Caveats
 *		None
 */

/*	
 *	CRC::~CRC ();
 *
 *	Functional Description
 *		This is the destructor for this class.
 *
 *	Formal Parameters
 *		None.
 *
 *	Return Value
 *		None
 *
 *	Side Effects
 *		None
 *
 *	Caveats
 *		None
 */

/*	
 *	ULong 	CRC::OldCRCGenerator(
 *					PUChar	block_adr,
 *					ULong	block_len);
 *
 *	Functional Description
 *		This function generates the crc using bit-shifting methods.  This method
 *		is slower than the table-driven approach.
 *
 *	Formal Parameters
 *		block_adr	(i)	-	Address of buffer to generate CRC on.
 *		block_lengh	(i)	-	Length of buffer
 *
 *	Return Value
 *		CRC value
 *
 *	Side Effects
 *		None
 *
 *	Caveats
 *		None
 */

/*	
 *	ULong 	CRC::CRCGenerator(
 *					PUChar	block_adr,
 *					ULong	block_len);
 *
 *	Functional Description
 *		This function generates the crc using the table-driven method.
 *
 *	Formal Parameters
 *		block_adr	(i)	-	Address of buffer to generate CRC on.
 *		block_lengh	(i)	-	Length of buffer
 *
 *	Return Value
 *		CRC value
 *
 *	Side Effects
 *		None
 *
 *	Caveats
 *		None
 */

/*	
 *	DBBoolean CRC::CheckCRC(
 *					PUChar	block_adr,
 *					ULong	block_len);
 *
 *	Functional Description
 *		This function generates a CRC based on the block passed in.  It assumes
 *		that the CRC is attached to the end of the block.  It compares the
 *		CRC generated to the CRC at the end of the block and returns TRUE if
 *		the CRC is correct.
 *
 *	Formal Parameters
 *		block_adr	(i)	-	Address of buffer to generate CRC on.
 *		block_lengh	(i)	-	Length of buffer
 *
 *	Return Value
 *		TRUE		-	CRC in the block is correct
 *		FALSE		-	CRC in the block is NOT correct
 *
 *	Side Effects
 *		None
 *
 *	Caveats
 *		None
 */

/*	
 *	Void	CRC::GetOverhead(
 *					UShort		maximum_packet,
 *					PUShort		new_maximum_packet);
 *
 *	Functional Description
 *		This function is called to determine the overhead that will be added
 *		to the packet by the CRC.
 *
 *	Formal Parameters
 *		maximum_packet		(i)	-	Current max. packet size
 *		new_maximum_packet	(o)	-	Maximum length of packet including CRC.
 *
 *	Return Value
 *		None
 *
 *	Side Effects
 *		None
 *
 *	Caveats
 *		None
 */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\remdsk\rds\t120\h\domain.h ===
/*
 *	domain.h
 *
 *	Copyright (c) 1993 - 1995 by DataBeam Corporation, Lexington, KY
 *
 *	Abstract:
 *		This is the interface file for the domain class.  This class contains
 *		all code necessary to maintain a domain information base within the
 *		MCS system.  When a domain object is first created, it is completely
 *		empty.  That is, it has no user attachments, no MCS connections, and
 *		therefore no outstanding resources, such as channels and tokens.
 *
 *		A word of caution about terminology.  Throughout the MCS documentation
 *		the word "attachment" is used in conjunction with a USER attachment. The
 *		word "connection" is used in conjunction with a TRANSPORT connection. In
 *		this class, the two types of "attachments" are NOT differentiated (most
 *		of the time).  They are both referred to as attachments.  When deleting
 *		an attachment, it is necessary to know the difference, however, and so
 *		there is an enumerated type (AttachmentType) to distinguish.  The type
 *		of each attachment is stored in a dictionary for easy access (see
 *		description of AttachmentType below).
 *
 *		This class keeps a list of "attachments" that are hierarchically below
 *		the local provider within the domain.  It also keeps a pointer to the
 *		one attachment that is hierarchically above the local provider (if any).
 *
 *		Since this class inherits from CommandTarget, it processes MCS commands
 *		as member function calls (see cmdtar.h for a description of how this
 *		mechanism works).  In essence, domain objects are just big command
 *		routers who react to incoming commands according to the contents of the
 *		information base.  That information base, in turn, is modified by the
 *		commands that are handled.
 *
 *		Domain objects keep lists of both channel objects and token objects,
 *		who maintain information about the current state of various channels
 *		and tokens.  Objects of this class are the heart of MCS.
 *
 *	Caveats:
 *		None.
 *
 *	Author:
 *		James P. Galvin, Jr.
 */

#ifndef	_DOMAIN_
#define	_DOMAIN_

/*
 *	Interface files.
 */
#include "userchnl.h"
#include "privchnl.h"
#include "token.h"
#include "randchnl.h"
#include "attmnt.h"

/*
 *	This enumeration defines the errors that a domain object can return when
 *	instructed to do something by its creator.
 */
typedef	enum
{
	DOMAIN_NO_ERROR,
	DOMAIN_NOT_HIERARCHICAL,
	DOMAIN_NO_SUCH_CONNECTION,
	DOMAIN_CONNECTION_ALREADY_EXISTS
} DomainError;
typedef	DomainError *		PDomainError;

/*
 *	This enumeration defines the different merge states that a domain can be in
 *	at any given time.  They can be described as follows:
 *
 *	MERGE_INACTIVE
 *		There is no merge operation underway.  This is the normal operational
 *		state.
 *	MERGE_USER_IDS
 *		The domain is currently merging user IDs into the upper domain.
 *	MERGE_STATIC_CHANNELS
 *		The domain is currently merging static channels into the upper domain.
 *	MERGE_ASSIGNED_CHANNELS
 *		The domain is currently merging assigned channels into the upper domain.
 *	MERGE_PRIVATE_CHANNELS
 *		The domain is currently merging private channels into the upper domain.
 *	MERGE_TOKENS
 *		The domain is currently merging tokens into the upper domain.
 *	MERGE_COMPLETE
 *		The merge operation is complete (this is a transitional state).
 */
typedef	enum
{
	MERGE_INACTIVE,
	MERGE_USER_IDS,
	MERGE_STATIC_CHANNELS,
	MERGE_ASSIGNED_CHANNELS,
	MERGE_PRIVATE_CHANNELS,
	MERGE_TOKENS,
	MERGE_COMPLETE
} MergeState;
typedef	MergeState *		PMergeState;

/*
 *	This collection type is used to hold the height of the domain across
 *	various downward attachments.  The Domain object needs to know this in order
 *	to calculate the effect of attachment loss on the height of the domain.
 */
class CDomainHeightList2 : public CList2
{
    DEFINE_CLIST2(CDomainHeightList2, UINT, PConnection)
};

/*
 *	This is the class definition for the Domain class.
 */
class Domain
{
public:

    Domain ();
    ~Domain ();

    BOOL    IsTopProvider(void) { return (NULL == m_pConnToTopProvider); }

			Void		GetDomainParameters (
									PDomainParameters	domain_parameters,
									PDomainParameters	min_domain_parameters,
									PDomainParameters	max_domain_parameters);
			Void		BindConnAttmnt (
									PConnection         originator,
									BOOL    			upward_connection,
									PDomainParameters	domain_parameters);
			Void		PlumbDomainIndication (
									PConnection         originator,
									ULong				height_limit);
			Void		ErectDomainRequest (
									PConnection         originator,
									ULong				height_in_domain,
									ULong				throughput_interval);
			Void		MergeChannelsRequest (
									PConnection             originator,
									CChannelAttributesList *merge_channel_list,
									CChannelIDList         *purge_channel_list);
			Void		MergeChannelsConfirm (
									PConnection             originator,
									CChannelAttributesList *merge_channel_list,
									CChannelIDList         *purge_channel_list);
			Void		PurgeChannelsIndication (
									PConnection             originator,
									CUidList               *purge_user_list,
									CChannelIDList         *purge_channel_list);
			Void		MergeTokensRequest (
									PConnection             originator,
									CTokenAttributesList   *merge_token_list,
									CTokenIDList           *purge_token_list);
			Void		MergeTokensConfirm (
									PConnection             originator,
									CTokenAttributesList   *merge_token_list,
									CTokenIDList           *purge_token_list);
			Void		PurgeTokensIndication (
									PConnection             originator,
									CTokenIDList           *purge_token_list);
			Void		DisconnectProviderUltimatum (
									CAttachment        *originator,
									Reason				reason);
			Void		RejectUltimatum (
									PConnection         originator,
									Diagnostic			diagnostic,
									PUChar				octet_string_address,
									ULong				octet_string_length);
			Void		AttachUserRequest (
									CAttachment        *originator);
			Void		AttachUserConfirm (
									PConnection         originator,
									Result				result,
									UserID				uidInitiator);
			Void		DetachUserRequest (
									CAttachment        *originator,
									Reason				reason,
									CUidList           *user_id_list);
			Void		DetachUserIndication (
									PConnection         originator,
									Reason				reason,
									CUidList           *user_id_list);
			Void		ChannelJoinRequest (
									CAttachment        *originator,
									UserID				uidInitiator,
									ChannelID			channel_id);
			Void		ChannelJoinConfirm (
									PConnection         originator,
									Result				result,
									UserID				uidInitiator,
									ChannelID			requested_id,
									ChannelID			channel_id);
			Void		ChannelLeaveRequest (
									CAttachment        *originator,
									CChannelIDList     *channel_id_list);
			Void		ChannelConveneRequest (
									CAttachment        *originator,
									UserID				uidInitiator);
			Void		ChannelConveneConfirm (
									PConnection         originator,
									Result				result,
									UserID				uidInitiator,
									ChannelID			channel_id);
			Void		ChannelDisbandRequest (
									CAttachment        *originator,
									UserID				uidInitiator,
									ChannelID			channel_id);
			Void		ChannelDisbandIndication (
									PConnection         originator,
									ChannelID			channel_id);
			Void		ChannelAdmitRequest (
									CAttachment        *originator,
									UserID				uidInitiator,
									ChannelID			channel_id,
									CUidList           *user_id_list);
			Void		ChannelAdmitIndication (
									PConnection         originator,
									UserID				uidInitiator,
									ChannelID			channel_id,
									CUidList           *user_id_list);
			Void		ChannelExpelRequest (
									CAttachment        *originator,
									UserID				uidInitiator,
									ChannelID			channel_id,
									CUidList           *user_id_list);
			Void		ChannelExpelIndication (
									PConnection         originator,
									ChannelID			channel_id,
									CUidList           *user_id_list);
			Void		SendDataRequest (
									CAttachment        *originator,
									UINT				type,
									PDataPacket			data_packet);
			Void		SendDataIndication (
									PConnection         originator,
									UINT				type,
									PDataPacket			data_packet);
			Void		TokenGrabRequest (
									CAttachment        *originator,
									UserID				uidInitiator,
									TokenID				token_id);
			Void		TokenGrabConfirm (
									PConnection         originator,
									Result				result,
									UserID				uidInitiator,
									TokenID				token_id,
									TokenStatus			token_status);
			Void		TokenInhibitRequest (
									CAttachment        *originator,
									UserID				uidInitiator,
									TokenID				token_id);
			Void		TokenInhibitConfirm (
									PConnection         originator,
									Result				result,
									UserID				uidInitiator,
									TokenID				token_id,
									TokenStatus			token_status);
			Void		TokenGiveRequest (
									CAttachment        *originator,
									PTokenGiveRecord	pTokenGiveRec);
			Void		TokenGiveIndication (
									PConnection         originator,
									PTokenGiveRecord	pTokenGiveRec);
			Void		TokenGiveResponse (
									CAttachment        *originator,
									Result				result,
									UserID				receiver_id,
									TokenID				token_id);
			Void		TokenGiveConfirm (
									PConnection         originator,
									Result				result,
									UserID				uidInitiator,
									TokenID				token_id,
									TokenStatus			token_status);
			Void		TokenPleaseRequest (
									CAttachment        *originator,
									UserID				uidInitiator,
									TokenID				token_id);
			Void		TokenPleaseIndication (
									PConnection         originator,
									UserID				uidInitiator,
									TokenID				token_id);
			Void		TokenReleaseRequest (
									CAttachment        *originator,
									UserID				uidInitiator,
									TokenID				token_id);
			Void		TokenReleaseConfirm (
									PConnection         originator,
									Result				result,
									UserID				uidInitiator,
									TokenID				token_id,
									TokenStatus			token_status);
			Void		TokenTestRequest (
									CAttachment        *originator,
									UserID				uidInitiator,
									TokenID				token_id);
			Void		TokenTestConfirm (
									PConnection         originator,
									UserID				uidInitiator,
									TokenID				token_id,
									TokenStatus			token_status);

	private:
				Void		LockDomainParameters (
									PDomainParameters	domain_parameters,
									BOOL    			parameters_locked);
				ChannelID	AllocateDynamicChannel ();
				BOOL    	ValidateUserID (
									UserID				user_id,
									CAttachment         *pOrigAtt);
				Void		PurgeDomain (
									Reason				reason);
				Void		DeleteAttachment (
									CAttachment         *pAtt,
									Reason				reason);
				Void		DeleteUser (
									UserID				user_id);
				Void		DeleteChannel (
									ChannelID			channel_id);
				Void		DeleteToken (
									TokenID				token_id);
				Void		ReclaimResources ();
				Void		MergeInformationBase ();
				Void		SetMergeState (
									MergeState			merge_state);
				Void		AddChannel (
									PConnection             pConn,
									PChannelAttributes	merge_channel,
									CChannelAttributesList *merge_channel_list,
									CChannelIDList         *purge_channel_list);
				Void		AddToken (
									PTokenAttributes	merge_token,
									CTokenAttributesList   *merge_token_list,
									CTokenIDList           *purge_token_list);
				Void		CalculateDomainHeight ();

		MergeState			Merge_State;
		UShort				Outstanding_Merge_Requests;
		UINT				Number_Of_Users;
		UINT				Number_Of_Channels;
		UINT				Number_Of_Tokens;
		DomainParameters	Domain_Parameters;
		BOOL    			Domain_Parameters_Locked;

		PConnection 		m_pConnToTopProvider;
		CAttachmentList     m_AttachmentList;

		CAttachmentQueue    m_AttachUserQueue;
		CConnectionQueue    m_MergeQueue;

		CChannelList2       m_ChannelList2;
		CTokenList2         m_TokenList2;

		UINT				m_nDomainHeight;
		CDomainHeightList2	m_DomainHeightList2;

		RandomChannelGenerator
							Random_Channel_Generator;
};

/*
 *	Domain ()
 *
 *	Functional Description:
 *		This is the constructor for the domain class.  It initializes the state
 *		of the domain, which at creation is empty.  It also initializes the
 *		domain parameters structure that will be used by this domain for all
 *		future parameters and negotiation.
 *
 *	Formal Parameters:
 *		None.
 *
 *	Return Value:
 *		None.
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

/*
 *	~Domain ()
 *
 *	Functional Description:
 *		This is the destructor for the domain class.  It purges the entire
 *		domain by first sending disconnect provider ultimatums to ALL
 *		attachments (both user attachments and MCS connections).  It then frees
 *		up all resources in use by the domain (which is just objects in its
 *		various containers).
 *
 *		Note that doing this will result in all user attachments and MCS
 *		connections being broken.  Furthermore, all providers that are
 *		hierarchically below this one, will respond by purging their domains
 *		as well.
 *
 *	Formal Parameters:
 *		None.
 *
 *	Return Value:
 *		None.
 *
 *	Side Effects:
 *		The domain from this provider downward is completely eradicated.
 *
 *	Caveats:
 *		None.
 */

/*
 *	BOOL    	IsTopProvider ()
 *
 *	Functional Description:
 *		This function is used to ask the domain if it is the top provider in
 *		the domain that it represents.
 *
 *	Formal Parameters:
 *		None.
 *
 *	Return Value:
 *		TRUE if this is the top provider.  FALSE otherwise.
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

/*
 *	Void	GetDomainParameters (
 *					PDomainParameters		domain_parameters,
 *					PDomainParameters		min_domain_parameters,
 *					PDomainParameters		max_domain_parameters)
 *
 *	Functional Description:
 *		This function is used to ask the domain what the minimum and maximum
 *		acceptable values for domain parameters are.  If the domain has no
 *		connections (and therefore has not yet locked its domain parameters),
 *		then it will return min and max values based on what it can handle.
 *		If it has locked its domain parameters, then both the min and max values
 *		will be set to the locked set (indicating that it will not accept
 *		anything else).
 *
 *	Formal Parameters:
 *		domain_parameters (o)
 *			Pointer to a structure to be filled with the current domain
 *			parameters (those that are in use).  Setting this to NULL will
 *			prevent current domain parameters from being returned.
 *		min_domain_parameters (o)
 *			Pointer to a structure to be filled with the minimum domain
 *			parameters.  Setting this to NULL will prevent minimum domain
 *			parameters from being returned.
 *		max_domain_parameters (o)
 *			Pointer to a structure to be filled with the maximum domain
 *			parameters.  Setting this to NULL will prevent maximum domain
 *			parameters from being returned.
 *
 *	Return Value:
 *		None (except as specified in the parameter list above).
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

/*
 *	Void	BindConnAttmnt (
 *					PConnection         originator,
 *					BOOL    			upward_connection,
 *					PDomainParameters	domain_parameters,
 *					AttachmentType		attachment_type)
 *
 *	Functional Description:
 *		This function is used when an attachment wishes to bind itself to the
 *		domain.  This will occur only after the connection has been been
 *		completely and successfully negotiated.
 *
 *	Formal Parameters:
 *		originator (i)
 *			This is the attachment that wishes to bind.
 *		upward_connection (i)
 *			A boolean flag indicating whether or not this is an upward
 *			connection.
 *		domain_parameters (i)
 *			A pointer to a domain parameters structure that holds the parameters
 *			that were negotiated for the connection.  If the domain has not
 *			already locked its parameters, it will accept and lock these.
 *		attachment_type (i)
 *			What type of attachment is this (local or remote).
 *
 *	Return Value:
 *		None.
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

/*
 *	Void	PlumbDomainIndication (
 *					PCommandTarget		originator,
 *					ULong				height_limit)
 *
 *	Functional Description:
 *		This member function represents the reception of a plumb domain
 *		indication from the top provider.  If the height limit is zero, then
 *		the connection to the top provder will be severed.  If its not, then
 *		it will be decremented and broadcast to all downward attachments.
 *
 *	Formal Parameters:
 *		originator (i)
 *			This is the attachment from which the command originated.
 *		height_limit (i)
 *			This is initially the height limit for the domain.  It is
 *			decremented at each layer in the domain.  When it reaches zero,
 *			the recipient is too far from the top provider, and must
 *			disconnect.
 *
 *	Return Value:
 *		None.
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

/*
 *	Void	ErectDomainRequest (
 *					PCommandTarget		originator,
 *					ULong				height_in_domain,
 *					ULong				throughput_interval)
 *
 *	Functional Description:
 *		This member function represents the reception of an erect domain request
 *		from one of its downward attachments.  This contains information needed
 *		by higher providers to know what's going on below (such as total
 *		height of domain).
 *
 *	Formal Parameters:
 *		originator (i)
 *			This is the attachment from which the command originated.
 *		height_in_domain (i)
 *			This is the height of the domain from the originator down.
 *		throughput_interval (i)
 *			This is not currently supported and will always be zero (0).
 *
 *	Return Value:
 *		None.
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

/*
 *	Void	MergeChannelsRequest (
 *					PCommandTarget			originator,
 *					CChannelAttributesList *merge_channel_list,
 *					CChannelIDList         *purge_channel_list)
 *
 *	Functional Description:
 *		This member function represents the reception of a merge channel
 *		request from one of this domain's attachments.  If this is the top
 *		provider, then the merge request will be processed locally (which
 *		will result in the transmission of merge channel confirms back to
 *		the originating attachment).  If this is not the top provider, then
 *		the command will be forwarded toward the top provider, and this
 *		provider will remember how to route it back.
 *
 *	Formal Parameters:
 *		originator (i)
 *			This is the attachment from which the command originated.
 *		merge_channel_list (i)
 *			This is a list of strutures that contains the attributes of channels
 *			that are being merged into the upper domain.
 *		purge_channel_list (i)
 *			This is a list of channel IDs for those channels that are determined
 *			to be invalid even before this request reaches the Top Provider.
 *
 *	Return Value:
 *		None.
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

/*
 *	Void	MergeChannelsConfirm (
 *					PCommandTarget			originator,
 *					CChannelAttributesList *merge_channel_list,
 *					CChannelIDList         *purge_channel_list)
 *
 *	Functional Description:
 *		This member function represents the reception of a merge channel
 *		confirm from the top provider.  If this is the former top provider of
 *		a lower domain, the confirm will contain information indicating
 *		acceptance or rejection of the named channel.  If a channel is rejected,
 *		the former top provider will issue a purge channel indication
 *		downwards.  If this is not the former top provider, then it must be
 *		an intermediate provider. The command will be forwarded downward towards
 *		the former top provider.  The intermediate providers will also add the
 *		channel to their channel lists if it was accepted into the upper
 *		domain.
 *
 *	Formal Parameters:
 *		originator (i)
 *			This is the attachment from which the command originated.
 *		merge_channel_list (i)
 *			This is a list of strutures that contains the attributes of channels
 *			that are being merged into the upper domain.
 *		purge_channel_list (i)
 *			This is a list of channel IDs for those channels that are to be
 *			purged from the lower domain.
 *
 *	Return Value:
 *		None.
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

/*
 *	Void	PurgeChannelsIndication (
 *					PCommandTarget		originator,
 *					CUidList           *purge_user_list,
 *					CChannelIDList     *purge_channel_list)
 *
 *	Functional Description:
 *		This member function represents the reception of a purge channel
 *		indication from the top provider.  This will cause the local
 *		provider to remove the channel from the local information base (if
 *		it are there).  It will also broadcast the message downward in the
 *		domain.  Note that this will be translated by user objects into either
 *		a detach user indication or a channel leave indication, depending on
 *		which type of channel is being left.
 *
 *	Formal Parameters:
 *		originator (i)
 *			This is the attachment from which the command originated.
 *		purge_user_list (i)
 *			This is a list of users that are being purged from the lower
 *			domain.
 *		purge_channel_list (i)
 *			This is a list of channels that are being purged from the lower
 *			domain.
 *
 *	Return Value:
 *		None.
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

/*
 *	Void	MergeTokensRequest (
 *					PCommandTarget			originator,
 *					CTokenAttributesList   *merge_token_list,
 *					CTokenIDList           *purge_token_list)
 *
 *	Functional Description:
 *		This member function represents the reception of a merge token
 *		request from one of this domain's attachments.  If this is the top
 *		provider, then the merge request will be processed locally (which
 *		will result in the transmission of merge token confirms back to
 *		the originating attachment).  If this is not the top provider, then
 *		the command will be forwarded toward the top provider, and this provider
 *		will remember how to route it back.
 *
 *	Formal Parameters:
 *		originator (i)
 *			This is the attachment from which the command originated.
 *		merge_token_list (i)
 *			This is a list of token attributes structures, each of which
 *			describes one token to be merged.
 *		purge_token_list (i)
 *			This is a list of tokens that are to be purged from the lower
 *			domain.
 *
 *	Return Value:
 *		None.
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

/*
 *	Void	MergeTokensConfirm (
 *					PCommandTarget			originator,
 *					CTokenAttributesList   *merge_token_list,
 *					CTokenIDList           *purge_token_list)
 *
 *	Functional Description:
 *		This member function represents the reception of a merge token
 *		confirm from the top provider.  If this is the former top provider of
 *		a lower domain, the confirm will contain information indicating
 *		acceptance or rejection of the named token.  If a token is rejected,
 *		the former top provider will issue a purge token indication
 *		downwards.  If this is not the former top provider, then it must be
 *		an intermediate provider. The command will be forwarded downward towards
 *		the former top provider.  The intermediate providers will also add the
 *		token to their token lists if it was accepted into the upper
 *		domain.
 *
 *	Formal Parameters:
 *		originator (i)
 *			This is the attachment from which the command originated.
 *		merge_token_list (i)
 *			This is a list of token attributes structures, each of which
 *			describes one token to be merged.
 *		purge_token_list (i)
 *			This is a list of tokens that are to be purged from the lower
 *			domain.
 *
 *	Return Value:
 *		None.
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

/*
 *	Void	PurgeTokensIndication (
 *					PCommandTarget		originator,
 *					CTokenIDList       *purge_token_list)
 *
 *	Functional Description:
 *		This member function represents the reception of a purge token
 *		indication  from the top provider.  This will cause the local
 *		provider to remove the token from the local information base (if
 *		it are there).  It will also broadcast the message downward in the
 *		domain.  Note that this will be translated by user objects into a
 *		token release indication.
 *
 *	Formal Parameters:
 *		originator (i)
 *			This is the attachment from which the command originated.
 *		purge_token_list (i)
 *			This is a list of tokens that are to be purged from the lower
 *			domain.
 *
 *	Return Value:
 *		None.
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

/*
 *	Void	DisconnectProviderUltimatum (
 *					PCommandTarget		originator,
 *					Reason				reason)
 *
 *	Functional Description:
 *		This member function represents the reception of a disconnect provider
 *		ultimatum.  The attachment from which this command is received is
 *		automatically terminated.  Any resources that are held by users on
 *		the other side of the attachment are automatically freed by the top
 *		provider (if it was a downward attachment).  If it was an upward
 *		attachment then the domain is purged completely (which means that it
 *		is returned to its initialized state).
 *
 *	Formal Parameters:
 *		originator (i)
 *			This is the attachment from which the command originated.
 *		reason (i)
 *			This is the reason for the disconnect.  This will be one of the
 *			reasons defined in "mcatmcs.h".
 *
 *	Return Value:
 *		None.
 *
 *	Side Effects:
 *		An attachment will be severed, and potentially the entire domain can
 *		be purged.
 *
 *	Caveats:
 *		None.
 */

/*
 *	Void	RejectUltimatum (
 *					PCommandTarget		originator,
 *					Diagnostic			diagnostic,
 *					PUChar				octet_string_address,
 *					ULong				octet_string_length)
 *
 *	Functional Description:
 *		This command represents the reception of a reject ultimatum.  This
 *		indicates that the remote side was unable to correctly process a PDU
 *		that was sent to them.  At this time we simply sever the connection
 *		that carried the reject.
 *
 *	Formal Parameters:
 *		originator (i)
 *			This is the attachment from which the command originated.
 *		diagnostic (i)
 *			This is a diagnostic code describing the nature of the problem.
 *		octet_string_address (i)
 *			This is address of an optional octet string that contains the
 *			bad PDU.
 *		octet_string_length (i)
 *			This is the length of the above octet string.
 *
 *	Return Value:
 *		None.
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

/*
 *	Void	AttachUserRequest (
 *					PCommandTarget		originator)
 *
 *	Functional Description:
 *		This member function represents the reception of an attach user request.
 *		If this is the top provider, the domain will attempt to add the
 *		new user into the channel list (as a user channel).  A confirm will
 *		be issued in the direction of the requesting user, letting it know
 *		the outcome of the attach operation (as well as the user ID if the
 *		attach was successful).  If his is not the top provider, then the
 *		request will be forwarded in the direction of the top provider.
 *
 *	Formal Parameters:
 *		originator (i)
 *			This is the attachment from which the command originated.
 *
 *	Return Value:
 *		None.
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

/*
 *	Void	AttachUserConfirm (
 *					PCommandTarget		originator,
 *					Result				result,
 *					UserID				uidInitiator)
 *
 *	Functional Description:
 *		This member function represents the reception of an attach user confirm.
 *		If this provider has an outstanding attach user request, then it
 *		will forward the confirm in the direction of the requester.  It will
 *		also add the new user channel to the local channel list.  If there
 *		are no outstanding requests (as a result of the requester being
 *		disconnected), then this provider will issue a detach user request
 *		upward to eliminate the user ID that is no longer needed (it will only
 *		do this if the result of the attach was successful).
 *
 *	Formal Parameters:
 *		originator (i)
 *			This is the attachment from which the command originated.
 *		result (i)
 *			This is the result of the attach operation.  Anything but
 *			RESULT_SUCCESSFUL indicates that the attach did not succeed.
 *		uidInitiator (i)
 *			If the attach succeeded, then this field will contain the user ID
 *			of the newly attached user.
 *
 *	Return Value:
 *		None.
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

/*
 *	Void	DetachUserRequest (
 *					PCommandTarget		originator,
 *					Reason				reason,
 *					CUidList           *user_id_list)
 *
 *	Functional Description:
 *		This member function represents the reception of a detach user request.
 *		This causes the user channels associated with all users in the list to
 *		be deleted from the user information base.  If this is not the top
 *		provider, the request will then be forwarded upward.  Additionally,
 *		all resources owned by the detaching users will be reclaimed by all
 *		providers along the way.
 *
 *	Formal Parameters:
 *		originator (i)
 *			This is the attachment from which the command originated.
 *		reason (i)
 *			This is the reason for th detachment.
 *		user_id_list (i)
 *			This is a list of the users that are detaching.
 *
 *	Return Value:
 *		None.
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

/*
 *	Void	DetachUserIndication (
 *					PCommandTarget		originator,
 *					Reason				reason,
 *					CUidList           *user_id_list)
 *
 *	Functional Description:
 *		This member function represents the reception of a detach user
 *		indication.  This indication will be repeated to all downward
 *		attachments (both user attachments and MCS connections).  Then, if
 *		the user IDs represent any users in the local sub-tree, those users will
 *		be removed from the information base.
 *
 *	Formal Parameters:
 *		originator (i)
 *			This is the attachment from which the command originated.
 *		reason (i)
 *			This is the reason for the detachment.
 *		user_id_list (i)
 *			This is a list of the users that are detaching.
 *
 *	Return Value:
 *		None.
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

/*
 *	Void	ChannelJoinRequest (
 *					PCommandTarget		originator,
 *					UserID				uidInitiator,
 *					ChannelID			channel_id)
 *
 *	Functional Description:
 *		This member function represents the reception of a channel join request.
 *		If the channel exists in the local information base, then the
 *		domain will attempt to join the requesting attachment to the channel.
 *		A channel join confirm will be sent to the requesting attachment
 *		informing the requester of the result.  If the channel is not already
 *		in the information base, then one of two things will happen.  If this
 *		is the top provider, then the domain will attempt to add the channel
 *		(if it is a static channel).  If this is not the top provider, then
 *		the request will be forwarded upward.
 *
 *	Formal Parameters:
 *		originator (i)
 *			This is the attachment from which the command originated.
 *		uidInitiator (i)
 *			This is the user ID of the user requesting the join.
 *		channel_id (i)
 *			This is the ID of the channel to be joined.
 *
 *	Return Value:
 *		None.
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

/*
 *	Void	ChannelJoinConfirm (
 *					PCommandTarget		originator,
 *					Result				result,
 *					UserID				uidInitiator,
 *					ChannelID			requested_id,
 *					ChannelID			channel_id)
 *
 *	Functional Description:
 *		This member function represents the reception of a channel join confirm.
 *		If the channel has not already been added to the channel, it will
 *		be put there now.  The confirm will then be forwarded in the direction
 *		of the requesting user.
 *
 *	Formal Parameters:
 *		originator (i)
 *			This is the attachment from which the command originated.
 *		result (i)
 *			This is the result of the join.  Anything but RESULT_SUCCESSFUL
 *			means that the join failed.
 *		uidInitiator (i)
 *			This is the user ID of the user that requested the channel join.
 *			This is used to properly route the confirm.
 *		requested_id (i)
 *			This is the ID of the channel the user originally requested, which
 *			may be 0.
 *		channel_id (i)
 *			This is the ID of the channel that has been joined.  If the original
 *			request was for channel 0, then this field will indicate to the
 *			user which assigned channel was selected by the top provider.
 *
 *	Return Value:
 *		None.
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

/*
 *	Void	ChannelLeaveRequest (
 *					PCommandTarget		originator,
 *					CChannelIDList     *channel_id_list)
 *
 *	Functional Description:
 *		This member function represents the reception of a channel leave
 *		request.  The domain removes the requesting attachment from all channels
 *		in the channel list. If this results in any empty channels, then the
 *		channel leave request will be forwarded to the next higher provider in
 *		the domain (unless this is the top provider).  Furthermore, if a static
 *		or assigned channel is left empty, it is automatically removed from the
 *		channel list.
 *
 *	Formal Parameters:
 *		originator (i)
 *			This is the attachment from which the command originated.
 *		channel_id_list (i)
 *			This is a list of channels to be left.
 *
 *	Return Value:
 *		None.
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

/*
 *	Void		ChannelConveneRequest (
 *						PCommandTarget		originator,
 *						UserID				uidInitiator)
 *
 *	Functional Description:
 *		This member function represents the reception of a channel convene
 *		request.  If this is not the Top Provider, the request will be sent
 *		upward.  If this is the Top Provider, then a new private channel will
 *		be created (if domain parameters allow).
 *
 *	Formal Parameters:
 *		originator (i)
 *			This is the attachment from which the command originated.
 *		uidInitiator (i)
 *			This is the user ID of the user that requested the creation of a
 *			new private channel.  This is used to properly route the confirm.
 *
 *	Return Value:
 *		None.
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

/*
 *	Void		ChannelConveneConfirm (
 *						PCommandTarget		originator,
 *						Result				result,
 *						UserID				uidInitiator,
 *						ChannelID			channel_id)
 *
 *	Functional Description:
 *		This member function represents the reception of a channel convene
 *		confirm.  This causes the local provider to add the new private channel
 *		to the local information base, and route the confirm on toward the
 *		initiator of the request.
 *
 *	Formal Parameters:
 *		originator (i)
 *			This is the attachment from which the command originated.
 *		result (i)
 *			This is the result of the convene.  Anything but RESULT_SUCCESSFUL
 *			means that the convene failed.
 *		uidInitiator (i)
 *			This is the user ID of the user that requested the channel convene.
 *			This is used to properly route the confirm.
 *		channel_id (i)
 *			This is the ID of the new private channel that has been created.
 *
 *	Return Value:
 *		None.
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

/*
 *	Void		ChannelDisbandRequest (
 *						PCommandTarget		originator,
 *						UserID				uidInitiator,
 *						ChannelID			channel_id)
 *
 *	Functional Description:
 *		This member function represents the reception of a channel disband
 *		request.  If this is not the Top Provider, then the request will be
 *		forwarded upward.  If this is the Top Provider, then the specified
 *		private channel will be destroyed (after appropriate identity
 *		verification).  This will cause channel disband and channel expel
 *		indications to be sent downward to all admitted users.
 *
 *	Formal Parameters:
 *		originator (i)
 *			This is the attachment from which the command originated.
 *		uidInitiator (i)
 *			This is the user ID of the user that requested the channel disband.
 *			If this does not correspond to the channel manager, then the request
 *			will be ignored.
 *		channel_id (i)
 *			This is the ID of the channel to be disbanded.
 *
 *	Return Value:
 *		None.
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

/*
 *	Void		ChannelDisbandIndication (
 *						PCommandTarget		originator,
 *						ChannelID			channel_id)
 *
 *	Functional Description:
 *		This member function represents the reception of a channel disband
 *		indication.  This causes the specified private channel to be removed
 *		from the information base.  The indication is then forwarded to all
 *		attachments that are either admitted or the channel manager.
 *
 *	Formal Parameters:
 *		originator (i)
 *			This is the attachment from which the command originated.
 *		channel_id (i)
 *			This is the ID of the channel being disbanded.
 *
 *	Return Value:
 *		None.
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

/*
 *	Void		ChannelAdmitRequest (
 *						PCommandTarget		originator,
 *						UserID				uidInitiator,
 *						ChannelID			channel_id,
 *						CUidList           *user_id_list)
 *
 *	Functional Description:
 *		This member function represents the reception of a channel admit
 *		request.  If this is not the Top Provider, then the request will be
 *		forwarded upward.  If this is the Top Provider, then the user IDs
 *		will be added to the admitted list, and a channel admit indication will
 *		be sent downward toward all attachments that contain an admitted user.
 *
 *	Formal Parameters:
 *		originator (i)
 *			This is the attachment from which the command originated.
 *		uidInitiator (i)
 *			This is the user ID of the user that requested the channel admit.
 *			This must be the channel manager for the admit to succeed.
 *		channel_id (i)
 *			This is the ID of the private channel whose admitted list is to
 *			be expanded.
 *		user_id_list (i)
 *			This is a container holding the user IDs of those users to be
 *			admitted to the private channel.
 *
 *	Return Value:
 *		None.
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

/*
 *	Void		ChannelAdmitIndication (
 *						PCommandTarget		originator,
 *						UserID				uidInitiator,
 *						ChannelID			channel_id,
 *						CUidList           *user_id_list)
 *
 *	Functional Description:
 *		This member function represents the reception of a channel admit
 *		indication.  If the specified private channel does not yet exist in the
 *		information base, it will be created now.  The users specified will be
 *		added to the admitted list, and this indication will be forwarded to
 *		all attachments that contain an admitted user.
 *
 *	Formal Parameters:
 *		originator (i)
 *			This is the attachment from which the command originated.
 *		uidInitiator (i)
 *			This is the user ID of the manager of this private channel.
 *		channel_id (i)
 *			This is the ID of the private channel for which this indication
 *			is intended.
 *		user_id_list (i)
 *			This is a container holding the list of user IDs to be added to
 *			the admitted list.
 *
 *	Return Value:
 *		None.
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

/*
 *	Void		ChannelExpelRequest (
 *						PCommandTarget		originator,
 *						UserID				uidInitiator,
 *						ChannelID			channel_id,
 *						CUidList           *user_id_list)
 *
 *	Functional Description:
 *		This member function represents the reception of a channel expel
 *		request.  If this is not the Top Provider, then the request will be
 *		forwarded upward.  If this is the Top Provider, then the specifed users
 *		will be removed from the private channel, and an expel indication will
 *		be sent downward to all attachments that contain (or did contain) an
 *		admitted user.
 *
 *	Formal Parameters:
 *		originator (i)
 *			This is the attachment from which the command originated.
 *		uidInitiator (i)
 *			This is the user ID of the user that requested the channel expel.
 *			This must be the channel manager for the expel to succeed.
 *		channel_id (i)
 *			This is the ID of the private channel whose admitted list is to
 *			be reduced.
 *		user_id_list (i)
 *			This is a container holding the user IDs of those users to be
 *			expelled from the private channel.
 *
 *	Return Value:
 *		None.
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

/*
 *	Void		ChannelExpelIndication (
 *						PCommandTarget		originator,
 *						ChannelID			channel_id,
 *						CUidList           *user_id_list)
 *
 *	Functional Description:
 *		This member function represents the reception of a channel expel
 *		indication.  The specified users will be removed from the admitted
 *		list of the channel.  If the channel is empty, and the channel manager
 *		is not in the sub-tree of this provider, then the channel will be
 *		removed from the local information base.  The expel indication will
 *		also be forwarded to all attachments that contain (or did contain( an
 *		admitted user.
 *
 *	Formal Parameters:
 *		originator (i)
 *			This is the attachment from which the command originated.
 *		channel_id (i)
 *			This is the ID of the private channel for which this indication
 *			is intended.
 *		user_id_list (i)
 *			This is a container holding the list of user IDs to be removed
 *			from the admitted list.
 *
 *	Return Value:
 *		None.
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

/*
 *	Void	SendDataRequest (
 *					PCommandTarget		originator,
 *					UINT				type,
 *					PDataPacket			data_packet)
 *
 *	Functional Description:
 *		This member function represents the reception of a send data request.
 *		If this is not the top provider, the request will be repeated
 *		upward toward the top provider.  The data will also be sent downward
 *		to all attachments that are joined to the channel (except for the
 *		originator) in the form of a send data indication.
 *
 *	Formal Parameters:
 *		originator (i)
 *			This is the attachment from which the command originated.
 *		type (i)
 *			Normal or uniform send data request.
 *		data_packet (i)
 *			This is a pointer to a DataPacket object containing the channel
 *			ID, the User ID of the data sender, segmentation flags, priority of
 *			the data packet and a pointer to the packet to be sent.
 *
 *	Return Value:
 *		None.
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

/*
 *	Void	SendDataIndication (
 *					PCommandTarget		originator,
 *					UINT				type,
 *					PDataPacket			data_packet)
 *
 *	Functional Description:
 *		This member function represents the reception of a send data indication.
 *		This indication will be repeated downward to all attachments that
 *		are joined to the channel.
 *
 *	Formal Parameters:
 *		originator (i)
 *			This is the attachment from which the command originated.
 *		type (i)
 *			normal or uniform send data indication
 *		data_packet (i)
 *			This is a pointer to a DataPacket object containing the channel
 *			ID, the User ID of the data sender, segmentation flags, priority of
 *			the data packet and a pointer to the packet to be sent.
 *
 *	Return Value:
 *		None.
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */
/*
 *	Void	TokenGrabRequest (
 *					PCommandTarget		originator,
 *					UserID				uidInitiator,
 *					TokenID				token_id)
 *
 *	Functional Description:
 *		This member function represents the reception of a token grab request.
 *		If this is not the top provider, the request will be forwarded
 *		upward towards the top provider.  If this is the top provider, the
 *		domain will attempt to grab the token on behalf of the requesting user.
 *		A token grab confirm will be issued to the requesting user informing
 *		it of the outcome.
 *
 *	Formal Parameters:
 *		originator (i)
 *			This is the attachment from which the command originated.
 *		uidInitiator (i)
 *			This is the ID of the user that is requesting the token grab.
 *		token_id (i)
 *			This is the ID of the token that the user is attempting to grab.
 *
 *	Return Value:
 *		None.
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

/*
 *	Void	TokenGrabConfirm (
 *					PCommandTarget		originator,
 *					Result				result,
 *					UserID				uidInitiator,
 *					TokenID				token_id,
 *					TokenStatus			token_status)
 *
 *	Functional Description:
 *		This member function represents the reception of a token grab confirm.
 *		This confirm will simply be forwarded in the direction of the
 *		requesting user.
 *
 *	Formal Parameters:
 *		originator (i)
 *			This is the attachment from which the command originated.
 *		result (i)
 *			This is the result of the grab request.  If it is anything but
 *			RESULT_SUCCESSFUL, the grab request failed.
 *		uidInitiator (i)
 *			This is the ID of the user that is requesting the token grab.
 *		token_id (i)
 *			This is the ID of the token that the user is attempting to grab.
 *		token_status (i)
 *			This is the state of the token after the grab request was
 *			processed at the top provider.
 *
 *	Return Value:
 *		None.
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

/*
 *	Void	TokenInhibitRequest (
 *					PCommandTarget		originator,
 *					UserID				uidInitiator,
 *					TokenID				token_id)
 *
 *	Functional Description:
 *		This member function represents the reception of a token inhibit
 *		request.  If this is not the top provider, the request will be forwarded
 *		upward towards the top provider.  If this is the top provider, the
 *		domain will attempt to inhibit the token on behalf of the requesting
 *		user.  A token inhibit confirm will be issued to the requesting user
 *		informing it of the outcome.
 *
 *	Formal Parameters:
 *		originator (i)
 *			This is the attachment from which the command originated.
 *		uidInitiator (i)
 *			This is the ID of the user that is requesting the token inhibit.
 *		token_id (i)
 *			This is the ID of the token that the user is attempting to inhibit.
 *
 *	Return Value:
 *		None.
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

/*
 *	Void	TokenInhibitConfirm (
 *					PCommandTarget		originator,
 *					Result				result,
 *					UserID				uidInitiator,
 *					TokenID				token_id,
 *					TokenStatus			token_status)
 *
 *	Functional Description:
 *		This member function represents the reception of a token inhibit
 *		confirm.  This confirm will simply be forwarded in the direction of the
 *		requesting user.
 *
 *	Formal Parameters:
 *		originator (i)
 *			This is the attachment from which the command originated.
 *		result (i)
 *			This is the result of the inhibit request.  If it is anything but
 *			RESULT_SUCCESSFUL, the inhibit request failed.
 *		uidInitiator (i)
 *			This is the ID of the user that is requesting the token inhibit.
 *		token_id (i)
 *			This is the ID of the token that the user is attempting to inhibit.
 *		token_status (i)
 *			This is the state of the token after the inhibit request was
 *			processed at the top provider.
 *
 *	Return Value:
 *		None.
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

/*
 *	Void		TokenGiveRequest (
 *						PCommandTarget		originator,
 *						PTokenGiveRecord	pTokenGiveRec)
 *
 *	Functional Description:
 *		This member function represents the reception of a token give request.
 *		If this is not the top provider, the request will be forwarded upward
 *		towards the top provider.  If this is the top provider, the domain will
 *		issue a token give indication in the direction of the user identified
 *		to receive the token.
 *
 *	Formal Parameters:
 *		originator (i)
 *			This is the attachment from which the command originated.
 *		pTokenGiveRec (i)
 *			This is the address of a structure containing the following information:
 *			The ID of the user attempting to give away the token.
 *			The ID of the token being given.
 *			The ID of the user that the token is being given to.
 *
 *	Return Value:
 *		None.
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

/*
 *	Void		TokenGiveIndication (
 *						PCommandTarget		originator,
 *						PTokenGiveRecord	pTokenGiveRec)
 *
 *	Functional Description:
 *		This member function represents the reception of a token give
 *		indication.  This indication will be forwarded toward the user that
 *		is to receive the token.
 *
 *	Formal Parameters:
 *		originator (i)
 *			This is the attachment from which the command originated.
 *		pTokenGiveRec (i)
 *			This is the address of a structure containing the following information:
 *			The ID of the user attempting to give away the token.
 *			The ID of the token being given.
 *			The ID of the user that the token is being given to.
 *
 *	Return Value:
 *		None.
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

/*
 *	Void		TokenGiveResponse (
 *						PCommandTarget		originator,
 *						Result				result,
 *						UserID				receiver_id,
 *						TokenID				token_id)
 *
 *	Functional Description:
 *		This member function represents the reception of a token give response.
 *		If this is not the top provider, the response will be forwarded
 *		upward towards the top provider.  If this is the top provider, the
 *		domain will make the appropriate changes to the state of the token in
 *		the local information base, and then issue a token give confirm to the
 *		user that initiated the give request.
 *
 *	Formal Parameters:
 *		originator (i)
 *			This is the attachment from which the command originated.
 *		result (i)
 *			This specifies whether or not the token was accepted.  Anything but
 *			RESULT_SUCCESSFUL indicates that the token was rejected.
 *		receiver_id (i)
 *			This is the ID of the user that has either accepted or rejected the
 *			token.
 *		token_id (i)
 *			This is the ID of the token that the user has been given.
 *
 *	Return Value:
 *		None.
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

/*
 *	Void		TokenGiveConfirm (
 *						PCommandTarget		originator,
 *						Result				result,
 *						UserID				uidInitiator,
 *						TokenID				token_id,
 *						TokenStatus			token_status)
 *
 *	Functional Description:
 *		This member function represents the reception of a token give confirm.
 *		This is forwarded toward the user that initiated the give request to
 *		inform it of the outcome.
 *
 *	Formal Parameters:
 *		originator (i)
 *			This is the attachment from which the command originated.
 *		result (i)
 *			This parameter specifies whether or not the token was accepted.
 *			Anything but RESULT_SUCCESSFUL indicates that the token was not
 *			accepted.
 *		uidInitiator (i)
 *			This is the ID of the user that originally requested the token
 *			give request.
 *		token_id (i)
 *			This is the ID of the token that the user is attempting to give.
 *		token_status (i)
 *			This specifies the status of the token after the give operation
 *			was complete.
 *
 *	Return Value:
 *		None.
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

/*
 *	Void		TokenPleaseRequest (
 *						PCommandTarget		originator,
 *						UserID				uidInitiator,
 *						TokenID				token_id)
 *
 *	Functional Description:
 *		This member function represents the reception of a token please
 *		request.  If this is not the top provider, the request will be forwarded
 *		upward towards the top provider.  If this is the top provider, the
 *		domain will issue a token please indication in the direction of all
 *		users that currently own the token.
 *
 *	Formal Parameters:
 *		originator (i)
 *			This is the attachment from which the command originated.
 *		uidInitiator (i)
 *			This is the ID of the user that is asking for the token.
 *		token_id (i)
 *			This is the ID of the token that the user is asking for.
 *
 *	Return Value:
 *		None.
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

/*
 *	Void		TokenPleaseIndication (
 *						PCommandTarget		originator,
 *						UserID				uidInitiator,
 *						TokenID				token_id)
 *
 *	Functional Description:
 *		This member function represents the reception of a token please
 *		indication.  This indication is forwarded to all users who currently
 *		own the specified token.
 *
 *	Formal Parameters:
 *		originator (i)
 *			This is the attachment from which the command originated.
 *		uidInitiator (i)
 *			This is the ID of the user that is asking for the token.
 *		token_id (i)
 *			This is the ID of the token that the user is asking for.
 *
 *	Return Value:
 *		None.
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

/*
 *	Void	TokenReleaseRequest (
 *					PCommandTarget		originator,
 *					UserID				uidInitiator,
 *					TokenID				token_id)
 *
 *	Functional Description:
 *		This member function represents the reception of a token release
 *		request.  If this is not the top provider, the request will be forwarded
 *		upward towards the top provider.  If this is the top provider, the
 *		domain will attempt to release the token on behalf of the requesting
 *		user.  A token release confirm will be issued to the requesting user
 *		informing it of the outcome.
 *
 *	Formal Parameters:
 *		originator (i)
 *			This is the attachment from which the command originated.
 *		uidInitiator (i)
 *			This is the ID of the user that is requesting the token release.
 *		token_id (i)
 *			This is the ID of the token that the user is attempting to release.
 *
 *	Return Value:
 *		None.
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

/*
 *	Void	TokenReleaseConfirm (
 *					PCommandTarget		originator,
 *					Result				result,
 *					UserID				uidInitiator,
 *					TokenID				token_id,
 *					TokenStatus			token_status)
 *
 *	Functional Description:
 *		This member function represents the reception of a token release
 *		confirm.  This confirm will simply be forwarded in the direction of the
 *		requesting user.
 *
 *	Formal Parameters:
 *		originator (i)
 *			This is the attachment from which the command originated.
 *		result (i)
 *			This is the result of the release request.  If it is anything but
 *			RESULT_SUCCESSFUL, the release request failed.
 *		uidInitiator (i)
 *			This is the ID of the user that is requesting the token release.
 *		token_id (i)
 *			This is the ID of the token that the user is attempting to release.
 *		token_status (i)
 *			This is the state of the token after the release request was
 *			processed at the top provider.
 *
 *	Return Value:
 *		None.
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

/*
 *	Void	TokenTestRequest (
 *					PCommandTarget		originator,
 *					UserID				uidInitiator,
 *					TokenID				token_id)
 *
 *	Functional Description:
 *		This member function represents the reception of a token test request.
 *		If this is not the top provider, the request will be forwarded
 *		upward towards the top provider.  If this is the top provider, the
 *		domain will test the current state of the token.  A token test confirm
 *		will be issued to the requesting user informing it of the outcome.
 *
 *	Formal Parameters:
 *		originator (i)
 *			This is the attachment from which the command originated.
 *		uidInitiator (i)
 *			This is the ID of the user that is requesting the token test.
 *		token_id (i)
 *			This is the ID of the token that the user is testing.
 *
 *	Return Value:
 *		None.
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

/*
 *	Void	TokenTestConfirm (
 *					PCommandTarget		originator,
 *					UserID				uidInitiator,
 *					TokenID				token_id,
 *					TokenStatus			token_status)
 *
 *	Functional Description:
 *		This member function represents the reception of a token test confirm.
 *		This confirm will simply be forwarded in the direction of the
 *		requesting user.
 *
 *	Formal Parameters:
 *		originator (i)
 *			This is the attachment from which the command originated.
 *		uidInitiator (i)
 *			This is the ID of the user that is requesting the token test.
 *		token_id (i)
 *			This is the ID of the token that the user is testing.
 *		token_status (i)
 *			This is the state of the token at the time of the test.
 *
 *	Return Value:
 *		None.
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\remdsk\rds\t120\h\fclasses.h ===
#ifndef __FORWARD_DECL_CLASSES__
#define __FORWARD_DECL_CLASSES__

// Forward declarations of GCC classes

class CAppRoster;
class CAppRosterMgr;
class CAppRosterMsg;

class CConfRoster;
class CConfRosterMgr;
class CConfRosterMsg;

class CConf;

class CBaseSap;
class CAppSap;
class CControlSAP;

// Forward declarations of MCS classes

class Domain;
typedef Domain *PDomain;

class Channel;
typedef Channel *PChannel;

class PrivateChannel;
typedef PrivateChannel *PPrivateChannel;

class UserChannel;
typedef UserChannel *PUserChannel;

class Connection;
typedef Connection *PConnection;

class User;
typedef User *PUser;

class Token;
typedef Token *PToken;

class SimplePacket;
typedef SimplePacket *PSimplePacket;

class CAttachment;

#endif // __FORWARD_DECL_CLASSES__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\remdsk\rds\t120\h\fsdiag.h ===
// fsdiag.h


#ifndef	_FSDIAG_
#define	_FSDIAG_

#define MULTI_LEVEL_ZONES
#include <mlzdbg.h>

#if defined(_DEBUG)

VOID T120DiagnosticCreate(VOID);
VOID T120DiagnosticDestroy(VOID);

#define TRACE_OUT_EX(z,s)	(MLZ_TraceZoneEnabled(z) || MLZ_TraceZoneEnabled(MLZ_FILE_ZONE))  ? (MLZ_TraceOut s) : 0

#else

#define T120DiagnosticCreate()
#define T120DiagnosticDestroy()
#define DEBUG_FILEZONE(z)

#define TRACE_OUT_EX(z,s)

#endif // _DEBUG


#ifdef _DEBUG

enum
{
    ZONE_T120_MCSNC = BASE_ZONE_INDEX,
    ZONE_T120_GCCNC,    // GCC Provider
    ZONE_T120_MSMCSTCP,
    ZONE_T120_SAP,      // GCC App SAP and Control SAP
    ZONE_T120_APP_ROSTER,
    ZONE_T120_CONF_ROSTER,
    ZONE_T120_REGISTRY, // GCC App Registry
    ZONE_T120_MEMORY,
    ZONE_T120_UTILITY,
    ZONE_GCC_NC,        // GCC Node Controller
    ZONE_GCC_NCI,       // GCC Node Controller Interface INodeController
    ZONE_T120_T123PSTN,
};

extern UINT MLZ_FILE_ZONE;
#define DEBUG_FILEZONE(z)  static UINT MLZ_FILE_ZONE = (z)

#endif // _DEBUG

#endif // _FSDIAG_


// lonchanc: this must be outside the _FSDIAG_ protection.
#if defined(_DEBUG) && defined(INIT_DBG_ZONE_DATA)

static const PSTR c_apszDbgZones[] =
{
	"T.120",				// debug zone module name
	DEFAULT_ZONES
	TEXT("MCS"),			// ZONE_T120_MCSNC
	TEXT("GCC"),			// ZONE_T120_GCCNC
	TEXT("TCP"),			// ZONE_T120_MSMCSTCP
	TEXT("SAP"),			// ZONE_T120_SAP
	TEXT("A-Roster"),		// ZONE_T120_APP_ROSTER
	TEXT("C-Roster"),		// ZONE_T120_CONF_ROSTER
	TEXT("Registry"),		// ZONE_T120_REGISTRY
	TEXT("Memory Tracking"),// ZONE_T120_MEMORY
	TEXT("Common"),			// ZONE_T120_UTILITY
	TEXT("GCC NC"),         // ZONE_GCC_NC
	TEXT("GCC NC Intf"),    // ZONE_GCC_NCI
    TEXT("T123 PSTN"),      // ZONE_T120_T123PSTN
};

UINT MLZ_FILE_ZONE = ZONE_T120_UTILITY;

#endif // _DEBUG && INIT_DBG_ZONE_DATA
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\remdsk\rds\t120\h\hash.h ===
/*	hash.h
 *
 *	Copyright (c) 1996 by Microsoft Corporation
 *
 *  Written by:	 Christos Tsollis
 *
 *  Revisions:
 *		
 *	Abstract:
 *
 *	This is the interface to a dictionary data structure.  
 *	Both the key and the value in a dictionary entry are DWORD values.  So, for example, if the 
 *  value is really a pointer it has to be converted into a DWORD before being passed into a 
 *  member dictionary function.
 *
 */


#ifndef _HASH_
#define _HASH_

#include <windows.h>

#define DEFAULT_NUMBER_OF_BUCKETS	3


typedef enum {
	DWORD_DICTIONARY,			/* The key is a 32-bit unsigned value */
	STRING_DICTIONARY,			/* The key is a NULL-terminated string that is being pointed by 
								 * the "key" field in the structure below */
	LENGTH_STRING_DICTIONARY	/* The key is a string with a specific length.  The "key" field
								 * in the structure below, points to memory space containing 
								 * the length and a string of that length. */
} DictionaryType;


typedef struct _dictionary_item {
	DWORD						key;	// The key value, or a pointer to a string (depending on the dictionary type)
	DWORD						value;	// This is always a 32-bit unsigned value
	struct _dictionary_item		*next;	// Pointer to the next structure in the dictionary bucket
} DICTIONARY_ITEM, *PDICTIONARY_ITEM;


class DictionaryClass
{
public:

	DictionaryClass (ULong num_of_buckets = DEFAULT_NUMBER_OF_BUCKETS, DictionaryType dtype = DWORD_DICTIONARY);
	DictionaryClass (const DictionaryClass& original);
	~DictionaryClass ();

	BOOL insert (DWORD new_key, DWORD new_value, ULong length = 0);
	BOOL remove (DWORD Key, ULong length = 0);
	BOOL find (DWORD Key, LPDWORD pValue = NULL, ULong length = 0);
	BOOL isEmpty ();
	void clear ();
	ULong entries () {
		return (3 * NumOfBuckets - ItemCount + NumOfExternItems);
	};
	BOOL iterate (LPDWORD pValue = NULL, LPDWORD pKey = NULL);
	void reset () { pCurrent = NULL; };		// Resets the dictionary iterator

	BOOL Insert(DWORD new_key, LPVOID new_value, UINT length = 0) { ASSERT(new_value != NULL); return insert(new_key, (DWORD) new_value, (ULONG) length); }
	BOOL Remove(DWORD Key, UINT length = 0) { return remove(Key, (ULONG) length); }
	LPVOID Find(DWORD Key, UINT length = 0);
	LPVOID Iterate(LPDWORD pKey = NULL);
	BOOL IsEmpty(void) { return isEmpty(); }
	void Clear(void) { clear(); }
	UINT GetCount(void) { return (UINT) entries(); }
	void Reset(void) { reset(); }


private:

	DWORD hashFunction (DWORD key);
	int LengthStrcmp (DWORD DictionaryKey, DWORD ChallengeKey, ULong length);

	ULong				 NumOfBuckets;		// Number of dictionary buckets.  Specified during object construction.
	DWORD				 dwNormalSize;		// Initial space allocated for the dictionary
	PDICTIONARY_ITEM	*Buckets;			// Address of the Buckets array
	PDICTIONARY_ITEM	*ItemArray;			// Pointer to the array of initially allocated dictionary items
	ULong		 		 ItemCount;			// Number of dictionary items left in the ItemArray
	PDICTIONARY_ITEM	 pCurrent;			// Points to the current dictionary item while we iterate through the dictionary
	ULong				 ulCurrentBucket;	// Id of the current bucket while we iterate
	DictionaryType		 Type;				// Dictionary type
	ULong				 NumOfExternItems;	// Number of external dictionary items

};

typedef DictionaryClass * PDictionaryClass;

#define DEFINE_DICTIONARY_FRIENDLY_METHODS(_ClassName_)			\
	BOOL Insert(DWORD new_key, _ClassName_ *new_value, UINT length = 0) { return DictionaryClass::Insert(new_key, (LPVOID) new_value, length); }	\
	BOOL Remove(DWORD Key, UINT length = 0) { return DictionaryClass::Remove(Key, length); }	\
	_ClassName_ *Find(DWORD Key, UINT length = 0) { return (_ClassName_ *) DictionaryClass::Find(Key, length); }	\
	_ClassName_ *Iterate(LPDWORD pKey = NULL) { return (_ClassName_ *) DictionaryClass::Iterate(pKey); }

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\remdsk\rds\t120\h\framer.h ===
/*	Framer.h
 *
 *	Copyright (c) 1994-1995 by DataBeam Corporation, Lexington, KY
 *
 *	Abstract:
 *		This is the packet frame base class.  This class defines the behavior
 *		for other packet framers that inherit from this class.  Some packet
 *		framing definitions can be found in RFC1006 and Q.922
 *	
 *	Caveats:
 *
 *	Authors:
 *		James W. Lawwill
 */

#ifndef _PACKETFRAME_
#define _PACKETFRAME_

#include "databeam.h"

typedef	enum
{
	PACKET_FRAME_NO_ERROR,
	PACKET_FRAME_DEST_BUFFER_TOO_SMALL,
	PACKET_FRAME_PACKET_DECODED,
	PACKET_FRAME_ILLEGAL_FLAG_FOUND,
	PACKET_FRAME_FATAL_ERROR
}	PacketFrameError;

class  PacketFrame
{
	public:

		virtual	PacketFrameError	PacketEncode (
										PUChar		source_address, 
										UShort		source_length,
										PUChar		dest_address,
										UShort		dest_length,
										DBBoolean	prepend_flag,
										DBBoolean	append_flag,
										PUShort		packet_size) = 0;
									
		virtual	PacketFrameError	PacketDecode (
										PUChar		source_address,
										UShort		source_length,
										PUChar		dest_address,
										UShort		dest_length,
										PUShort		bytes_accepted,
										PUShort		packet_size,
										DBBoolean	continue_packet) = 0;
		virtual	Void				GetOverhead (
										UShort		original_packet_size,
										PUShort		max_packet_size) = 0;


};
typedef	PacketFrame	*	PPacketFrame;

#endif


/*	
 *	PacketFrameError	PacketFrame::PacketEncode (
 *										PUChar		source_address, 
 *										UShort		source_length,
 *										PUChar		dest_address,
 *										UShort		dest_length,
 *										DBBoolean	packet_start,
 *										DBBoolean	packet_end,
 *										PUShort		packet_size) = 0;
 *
 *	Functional Description
 *		This function receives takes the source data and encodes it.
 *
 *	Formal Parameters
 *		source_address	- (i)	Address of source buffer
 *		source_length	- (i)	Length of source buffer
 *		dest_address	- (i)	Address of destination buffer.
 *		dest_length		- (i)	Length of destination buffer.
 *		packet_start	- (i)	This is the beginning of a packet.
 *		packet_end		- (i)	This is the end of a packet.
 *		packet_size		- (o)	Size of packet after encoding
 *
 *	Return Value
 *		PACKET_FRAME_NO_ERROR				-	No error
 *		PACKET_FRAME_FATAL_ERROR			-	Fatal error during encode
 *		PACKET_FRAME_DEST_BUFFER_TOO_SMALL	-	Self-explanatory
 *
 *	Side Effects
 *		None
 *
 *	Caveats
 *		None
 */

/*	
 *	PacketFrameError	PacketFrame::PacketDecode (
 *										PUChar		source_address,
 *										UShort		source_length,
 *										PUChar		dest_address,
 *										UShort		dest_length,
 *										PUShort		bytes_accepted,
 *										PUShort		packet_size,
 *										DBBoolean	continue_packet) = 0;
 *
 *	Functional Description
 *		This function takes the stream data passed in and decodes it into a
 *		packet
 *		
 *	Formal Parameters
 *		source_address	- (i)	Address of source buffer.  If this parm is 
 *								NULL, continue using the current address.
 *		source_length	- (i)	Length of source buffer
 *		dest_address	- (i)	Address of destination buffer.  If this address
 *								is NULL, continue using current buffer.
 *		dest_length		- (i)	Length of destination buffer.
 *		bytes_accepted	- (o)	Number of bytes processed before return
 *		packet_size		- (o)	Size of packet after decoding
 *		continue_packet	- (i)	Restart decoding
 *
 *	Return Value
 *		PACKET_FRAME_NO_ERROR				-	No error
 *		PACKET_FRAME_FATAL_ERROR			-	Fatal error during encode
 *		PACKET_FRAME_DEST_BUFFER_TOO_SMALL	-	Self-explanatory
 *		PACKET_FRAME_PACKET_DECODED			-	Self-explanatory
 *
 *	Side Effects
 *		None
 *
 *	Caveats
 *		None
 *
 */

/*	
 *	Void	PacketFrame::GetOverhead (
 *							UShort	original_packet_size,
 *							PUShort	max_packet_size) = 0;
 *
 *	Functional Description
 *		This returns the new maximum packet size
 *
 *	Formal Parameters
 *		original_packet_size	- (i)
 *		max_packet_size			- (o)	new maximum packet size
 *
 *	Return Value
 *		PACKET_FRAME_NO_ERROR	-	No error
 *
 *	Side Effects
 *		None
 *
 *	Caveats
 *		None
 *
 */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\remdsk\rds\t120\h\gccpdu.h ===
#ifndef _GCCPDU_Module_H_
#define _GCCPDU_Module_H_

#include "msper.h"

#ifdef __cplusplus
extern "C" {
#endif

typedef struct WaitingList * PWaitingList;

typedef struct PermissionList * PPermissionList;

typedef struct SetOfDestinationNodes * PSetOfDestinationNodes;

typedef struct SetOfTransferringNodesIn * PSetOfTransferringNodesIn;

typedef struct SetOfTransferringNodesRs * PSetOfTransferringNodesRs;

typedef struct SetOfTransferringNodesRq * PSetOfTransferringNodesRq;

typedef struct ParticipantsList * PParticipantsList;

typedef struct SetOfPrivileges * PSetOfPrivileges;

typedef struct SetOfApplicationRecordUpdates * PSetOfApplicationRecordUpdates;

typedef struct SetOfApplicationRecordRefreshes * PSetOfApplicationRecordRefreshes;

typedef struct SetOfApplicationCapabilityRefreshes * PSetOfApplicationCapabilityRefreshes;

typedef struct SetOfNodeRecordUpdates * PSetOfNodeRecordUpdates;

typedef struct SetOfNodeRecordRefreshes * PSetOfNodeRecordRefreshes;

typedef struct ApplicationProtocolEntityList * PApplicationProtocolEntityList;

typedef struct SetOfApplicationInformation * PSetOfApplicationInformation;

typedef struct SetOfConferenceDescriptors * PSetOfConferenceDescriptors;

typedef struct SetOfExpectedCapabilities * PSetOfExpectedCapabilities;

typedef struct SetOfNonCollapsingCapabilities * PSetOfNonCollapsingCapabilities;

typedef struct SetOfChallengeItems * PSetOfChallengeItems;

typedef struct SetOfUserData * PSetOfUserData;

typedef struct SetOfNetworkAddresses * PSetOfNetworkAddresses;

typedef ASN1uint16_t ChannelID;

typedef ASN1uint16_t StaticChannelID;

typedef ASN1uint16_t DynamicChannelID;

typedef DynamicChannelID UserID;

typedef ASN1uint16_t TokenID;

typedef ASN1uint16_t StaticTokenID;

typedef ASN1uint16_t DynamicTokenID;

typedef ASN1int32_t Time;

typedef ASN1uint32_t Handle;

typedef struct H221NonStandardIdentifier {
    ASN1uint32_t length;
    ASN1octet_t value[255];
} H221NonStandardIdentifier;

typedef ASN1char16string_t TextString;

typedef ASN1char16string_t SimpleTextString;

typedef ASN1char_t SimpleNumericString[256];

typedef ASN1char_t DialingString[17];

typedef ASN1char_t SubAddressString[41];

typedef TextString ExtraDialingString;

typedef SimpleNumericString ConferenceNameModifier;

typedef enum Privilege {
    terminate = 0,
    ejectUser = 1,
    add = 2,
    lockUnlock = 3,
    transfer = 4,
} Privilege;

typedef enum TerminationMethod {
    automatic = 0,
    manual = 1,
} TerminationMethod;

typedef enum NodeType {
    terminal = 0,
    multiportTerminal = 1,
    mcu = 2,
} NodeType;

typedef enum ChannelType {
    ChannelType_static = 0,
    dynamicMulticast = 1,
    dynamicPrivate = 2,
    dynamicUserId = 3,
} ChannelType;

typedef ASN1uint16_t EntityID;

typedef enum RegistryModificationRights {
    owner = 0,
    session = 1,
    RegistryModificationRights_public = 2,
} RegistryModificationRights;

typedef struct ApplicationCapabilitiesList {
    ASN1choice_t choice;
    union {
#	define capability_no_change_chosen 1
#	define application_capability_refresh_chosen 2
	PSetOfApplicationCapabilityRefreshes application_capability_refresh;
    } u;
} ApplicationCapabilitiesList;

typedef struct ApplicationRecordList {
    ASN1choice_t choice;
    union {
#	define application_no_change_chosen 1
#	define application_record_refresh_chosen 2
	PSetOfApplicationRecordRefreshes application_record_refresh;
#	define application_record_update_chosen 3
	PSetOfApplicationRecordUpdates application_record_update;
    } u;
} ApplicationRecordList;

typedef struct HighLayerCompatibility {
    ASN1bool_t telephony3kHz;
    ASN1bool_t telephony7kHz;
    ASN1bool_t videotelephony;
    ASN1bool_t videoconference;
    ASN1bool_t audiographic;
    ASN1bool_t audiovisual;
    ASN1bool_t multimedia;
} HighLayerCompatibility;

typedef struct TransferModes {
    ASN1bool_t speech;
    ASN1bool_t voice_band;
    ASN1bool_t digital_56k;
    ASN1bool_t digital_64k;
    ASN1bool_t digital_128k;
    ASN1bool_t digital_192k;
    ASN1bool_t digital_256k;
    ASN1bool_t digital_320k;
    ASN1bool_t digital_384k;
    ASN1bool_t digital_512k;
    ASN1bool_t digital_768k;
    ASN1bool_t digital_1152k;
    ASN1bool_t digital_1472k;
    ASN1bool_t digital_1536k;
    ASN1bool_t digital_1920k;
    ASN1bool_t packet_mode;
    ASN1bool_t frame_mode;
    ASN1bool_t atm;
} TransferModes;

typedef struct TransportConnectionType {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    struct TransportConnectionType_nsap_address_nsap_address {
	ASN1uint32_t length;
	ASN1octet_t value[20];
    } nsap_address;
#   define transport_selector_present 0x80
    ASN1octetstring_t transport_selector;
} TransportConnectionType;

typedef struct AggregateChannel {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    TransferModes transfer_modes;
    DialingString international_number;
#   define sub_address_present 0x80
    SubAddressString sub_address;
#   define extra_dialing_string_present 0x40
    ExtraDialingString extra_dialing_string;
#   define high_layer_compatibility_present 0x20
    HighLayerCompatibility high_layer_compatibility;
} AggregateChannel;

typedef struct NodeRecordList {
    ASN1choice_t choice;
    union {
#	define node_no_change_chosen 1
#	define node_record_refresh_chosen 2
	PSetOfNodeRecordRefreshes node_record_refresh;
#	define node_record_update_chosen 3
	PSetOfNodeRecordUpdates node_record_update;
    } u;
} NodeRecordList;

typedef struct WaitingList {
    PWaitingList next;
    UserID value;
} WaitingList_Element;

typedef struct PermissionList {
    PPermissionList next;
    UserID value;
} PermissionList_Element;

typedef struct SetOfDestinationNodes {
    PSetOfDestinationNodes next;
    UserID value;
} SetOfDestinationNodes_Element;

typedef struct NodeInformation {
    NodeRecordList node_record_list;
    ASN1uint16_t roster_instance_number;
    ASN1bool_t nodes_are_added;
    ASN1bool_t nodes_are_removed;
} NodeInformation;

typedef struct SetOfTransferringNodesIn {
    PSetOfTransferringNodesIn next;
    UserID value;
} SetOfTransferringNodesIn_Element;

typedef struct SetOfTransferringNodesRs {
    PSetOfTransferringNodesRs next;
    UserID value;
} SetOfTransferringNodesRs_Element;

typedef struct SetOfTransferringNodesRq {
    PSetOfTransferringNodesRq next;
    UserID value;
} SetOfTransferringNodesRq_Element;

typedef struct RegistryEntryOwnerOwned {
    UserID node_id;
    EntityID entity_id;
} RegistryEntryOwnerOwned;

typedef struct ParticipantsList {
    PParticipantsList next;
    TextString value;
} ParticipantsList_Element;

typedef struct Key {
    ASN1choice_t choice;
    union {
#	define object_chosen 1
	ASN1objectidentifier_t object;
#	define h221_non_standard_chosen 2
	H221NonStandardIdentifier h221_non_standard;
    } u;
} Key;

typedef struct NonStandardParameter {
    Key key;
    ASN1octetstring_t data;
} NonStandardParameter;

typedef struct Password {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    SimpleNumericString numeric;
#   define password_text_present 0x80
    SimpleTextString password_text;
} Password;

typedef struct PasswordSelector {
    ASN1choice_t choice;
    union {
#	define password_selector_numeric_chosen 1
	SimpleNumericString password_selector_numeric;
#	define password_selector_text_chosen 2
	SimpleTextString password_selector_text;
    } u;
} PasswordSelector;

typedef struct ChallengeResponseItem {
    ASN1choice_t choice;
    union {
#	define password_string_chosen 1
	PasswordSelector password_string;
#	define set_of_response_data_chosen 2
	PSetOfUserData set_of_response_data;
    } u;
} ChallengeResponseItem;

typedef struct ChallengeResponseAlgorithm {
    ASN1choice_t choice;
    union {
#	define algorithm_clear_password_chosen 1
#	define non_standard_algorithm_chosen 2
	NonStandardParameter non_standard_algorithm;
    } u;
} ChallengeResponseAlgorithm;

typedef struct ChallengeItem {
    ChallengeResponseAlgorithm response_algorithm;
    PSetOfUserData set_of_challenge_data;
} ChallengeItem;

typedef struct ChallengeRequest {
    ASN1int32_t challenge_tag;
    PSetOfChallengeItems set_of_challenge_items;
} ChallengeRequest;

typedef struct ChallengeResponse {
    ASN1int32_t challenge_tag;
    ChallengeResponseAlgorithm response_algorithm;
    ChallengeResponseItem response_item;
} ChallengeResponse;

typedef struct ConferenceName {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    SimpleNumericString numeric;
#   define conference_name_text_present 0x80
    SimpleTextString conference_name_text;
} ConferenceName;

typedef struct ConferenceNameSelector {
    ASN1choice_t choice;
    union {
#	define name_selector_numeric_chosen 1
	SimpleNumericString name_selector_numeric;
#	define name_selector_text_chosen 2
	SimpleTextString name_selector_text;
    } u;
} ConferenceNameSelector;

typedef struct NodeProperties {
    ASN1bool_t device_is_manager;
    ASN1bool_t device_is_peripheral;
} NodeProperties;

typedef struct AsymmetryIndicator {
    ASN1choice_t choice;
    union {
#	define calling_node_chosen 1
#	define called_node_chosen 2
#	define unknown_chosen 3
	ASN1uint32_t unknown;
    } u;
} AsymmetryIndicator;

typedef struct AlternativeNodeID {
    ASN1choice_t choice;
    union {
#	define h243_node_id_chosen 1
	struct AlternativeNodeID_h243_node_id_h243_node_id {
	    ASN1uint32_t length;
	    ASN1octet_t value[2];
	} h243_node_id;
    } u;
} AlternativeNodeID;

typedef struct ConferenceDescriptor {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    ConferenceName conference_name;
#   define conference_name_modifier_present 0x80
    ConferenceNameModifier conference_name_modifier;
#   define conference_description_present 0x40
    TextString conference_description;
    ASN1bool_t conference_is_locked;
    ASN1bool_t clear_password_required;
#   define descriptor_net_address_present 0x20
    PSetOfNetworkAddresses descriptor_net_address;
} ConferenceDescriptor;

typedef struct NodeRecord {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
#   define superior_node_present 0x80
    UserID superior_node;
    NodeType node_type;
    NodeProperties node_properties;
#   define node_name_present 0x40
    TextString node_name;
#   define participants_list_present 0x20
    PParticipantsList participants_list;
#   define site_information_present 0x10
    TextString site_information;
#   define record_net_address_present 0x8
    PSetOfNetworkAddresses record_net_address;
#   define alternative_node_id_present 0x4
    AlternativeNodeID alternative_node_id;
#   define record_user_data_present 0x2
    PSetOfUserData record_user_data;
} NodeRecord;

typedef struct SessionKey {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    Key application_protocol_key;
#   define session_id_present 0x80
    ChannelID session_id;
} SessionKey;

typedef struct ApplicationRecord {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    ASN1bool_t application_is_active;
    ASN1bool_t is_conducting_capable;
#   define record_startup_channel_present 0x80
    ChannelType record_startup_channel;
#   define application_user_id_present 0x40
    UserID application_user_id;
#   define non_collapsing_capabilities_present 0x20
    PSetOfNonCollapsingCapabilities non_collapsing_capabilities;
} ApplicationRecord;

typedef struct CapabilityID {
    ASN1choice_t choice;
    union {
#	define standard_chosen 1
	ASN1uint16_t standard;
#	define capability_non_standard_chosen 2
	Key capability_non_standard;
    } u;
} CapabilityID;

typedef struct CapabilityClass {
    ASN1choice_t choice;
    union {
#	define logical_chosen 1
#	define unsigned_minimum_chosen 2
	ASN1uint32_t unsigned_minimum;
#	define unsigned_maximum_chosen 3
	ASN1uint32_t unsigned_maximum;
    } u;
} CapabilityClass;

typedef struct ApplicationInvokeSpecifier {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    SessionKey session_key;
#   define expected_capability_set_present 0x80
    PSetOfExpectedCapabilities expected_capability_set;
#   define invoke_startup_channel_present 0x40
    ChannelType invoke_startup_channel;
    ASN1bool_t invoke_is_mandatory;
} ApplicationInvokeSpecifier;

typedef struct RegistryKey {
    SessionKey session_key;
    struct RegistryKey_resource_id_resource_id {
	ASN1uint32_t length;
	ASN1octet_t value[64];
    } resource_id;
} RegistryKey;

typedef struct RegistryItem {
    ASN1choice_t choice;
    union {
#	define channel_id_chosen 1
	DynamicChannelID channel_id;
#	define token_id_chosen 2
	DynamicTokenID token_id;
#	define parameter_chosen 3
	struct RegistryItem_parameter_parameter {
	    ASN1uint32_t length;
	    ASN1octet_t value[64];
	} parameter;
#	define vacant_chosen 4
    } u;
} RegistryItem;

typedef struct RegistryEntryOwner {
    ASN1choice_t choice;
    union {
#	define owned_chosen 1
	RegistryEntryOwnerOwned owned;
#	define not_owned_chosen 2
    } u;
} RegistryEntryOwner;

typedef struct UserIDIndication {
    ASN1int32_t tag;
} UserIDIndication;

typedef struct SetOfPrivileges {
    PSetOfPrivileges next;
    Privilege value;
} SetOfPrivileges_Element;

typedef struct ConferenceCreateRequest {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    ConferenceName conference_name;
#   define ccrq_convener_password_present 0x80
    Password ccrq_convener_password;
#   define ccrq_password_present 0x40
    Password ccrq_password;
    ASN1bool_t conference_is_locked;
    ASN1bool_t conference_is_listed;
    ASN1bool_t conference_is_conductible;
    TerminationMethod termination_method;
#   define ccrq_conductor_privs_present 0x20
    PSetOfPrivileges ccrq_conductor_privs;
#   define ccrq_conducted_privs_present 0x10
    PSetOfPrivileges ccrq_conducted_privs;
#   define ccrq_non_conducted_privs_present 0x8
    PSetOfPrivileges ccrq_non_conducted_privs;
#   define ccrq_description_present 0x4
    TextString ccrq_description;
#   define ccrq_caller_id_present 0x2
    TextString ccrq_caller_id;
#   define ccrq_user_data_present 0x1
    PSetOfUserData ccrq_user_data;
} ConferenceCreateRequest;

typedef enum ConferenceCreateResult {
    ConferenceCreateResult_success = 0,
    ConferenceCreateResult_userRejected = 1,
    resourcesNotAvailable = 2,
    rejectedForSymmetryBreaking = 3,
    lockedConferenceNotSupported = 4,
} ConferenceCreateResult;
typedef struct ConferenceCreateResponse {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    UserID node_id;
    ASN1int32_t tag;
    ConferenceCreateResult result;
#   define ccrs_user_data_present 0x80
    PSetOfUserData ccrs_user_data;
} ConferenceCreateResponse;

typedef struct ConferenceQueryRequest {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    NodeType node_type;
#   define cqrq_asymmetry_indicator_present 0x80
    AsymmetryIndicator cqrq_asymmetry_indicator;
#   define cqrq_user_data_present 0x40
    PSetOfUserData cqrq_user_data;
} ConferenceQueryRequest;

typedef enum ConferenceQueryResult {
    ConferenceQueryResult_success = 0,
    ConferenceQueryResult_userRejected = 1,
} ConferenceQueryResult;
typedef struct ConferenceQueryResponse {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    NodeType node_type;
#   define cqrs_asymmetry_indicator_present 0x80
    AsymmetryIndicator cqrs_asymmetry_indicator;
    PSetOfConferenceDescriptors conference_list;
    ConferenceQueryResult result;
#   define cqrs_user_data_present 0x40
    PSetOfUserData cqrs_user_data;
} ConferenceQueryResponse;

typedef struct ConferenceInviteRequest {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    ConferenceName conference_name;
    UserID node_id;
    UserID top_node_id;
    ASN1int32_t tag;
    ASN1bool_t clear_password_required;
    ASN1bool_t conference_is_locked;
    ASN1bool_t conference_is_listed;
    ASN1bool_t conference_is_conductible;
    TerminationMethod termination_method;
#   define cirq_conductor_privs_present 0x80
    PSetOfPrivileges cirq_conductor_privs;
#   define cirq_conducted_privs_present 0x40
    PSetOfPrivileges cirq_conducted_privs;
#   define cirq_non_conducted_privs_present 0x20
    PSetOfPrivileges cirq_non_conducted_privs;
#   define cirq_description_present 0x10
    TextString cirq_description;
#   define cirq_caller_id_present 0x8
    TextString cirq_caller_id;
#   define cirq_user_data_present 0x4
    PSetOfUserData cirq_user_data;
} ConferenceInviteRequest;

typedef enum ConferenceInviteResult {
    ConferenceInviteResult_success = 0,
    ConferenceInviteResult_userRejected = 1,
} ConferenceInviteResult;
typedef struct ConferenceInviteResponse {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    ConferenceInviteResult result;
#   define cirs_user_data_present 0x80
    PSetOfUserData cirs_user_data;
} ConferenceInviteResponse;

typedef struct ConferenceAddRequest {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    PSetOfNetworkAddresses add_request_net_address;
    UserID requesting_node;
    ASN1int32_t tag;
#   define adding_mcu_present 0x80
    UserID adding_mcu;
#   define carq_user_data_present 0x40
    PSetOfUserData carq_user_data;
} ConferenceAddRequest;

typedef enum ConferenceAddResult {
    ConferenceAddResult_success = 0,
    ConferenceAddResult_invalidRequester = 1,
    invalidNetworkType = 2,
    invalidNetworkAddress = 3,
    addedNodeBusy = 4,
    networkBusy = 5,
    noPortsAvailable = 6,
    connectionUnsuccessful = 7,
} ConferenceAddResult;
typedef struct ConferenceAddResponse {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    ASN1int32_t tag;
    ConferenceAddResult result;
#   define cars_user_data_present 0x80
    PSetOfUserData cars_user_data;
} ConferenceAddResponse;

typedef struct ConferenceLockRequest {
    char placeholder;
} ConferenceLockRequest;

typedef enum ConferenceLockResult {
    ConferenceLockResult_success = 0,
    ConferenceLockResult_invalidRequester = 1,
    alreadyLocked = 2,
} ConferenceLockResult;
typedef struct ConferenceLockResponse {
    ConferenceLockResult result;
} ConferenceLockResponse;

typedef struct ConferenceLockIndication {
    char placeholder;
} ConferenceLockIndication;

typedef struct ConferenceUnlockRequest {
    char placeholder;
} ConferenceUnlockRequest;

typedef enum ConferenceUnlockResult {
    ConferenceUnlockResult_success = 0,
    ConferenceUnlockResult_invalidRequester = 1,
    alreadyUnlocked = 2,
} ConferenceUnlockResult;
typedef struct ConferenceUnlockResponse {
    ConferenceUnlockResult result;
} ConferenceUnlockResponse;

typedef struct ConferenceUnlockIndication {
    char placeholder;
} ConferenceUnlockIndication;

typedef enum ConferenceTerminateRequestReason {
    ConferenceTerminateRequestReason_userInitiated = 0,
    ConferenceTerminateRequestReason_timedConferenceTermination = 1,
} ConferenceTerminateRequestReason;
typedef struct ConferenceTerminateRequest {
    ConferenceTerminateRequestReason reason;
} ConferenceTerminateRequest;

typedef enum ConferenceTerminateResult {
    ConferenceTerminateResult_success = 0,
    ConferenceTerminateResult_invalidRequester = 1,
} ConferenceTerminateResult;
typedef struct ConferenceTerminateResponse {
    ConferenceTerminateResult result;
} ConferenceTerminateResponse;

typedef enum ConferenceTerminateIndicationReason {
    ConferenceTerminateIndicationReason_userInitiated = 0,
    ConferenceTerminateIndicationReason_timedConferenceTermination = 1,
} ConferenceTerminateIndicationReason;
typedef struct ConferenceTerminateIndication {
    ConferenceTerminateIndicationReason reason;
} ConferenceTerminateIndication;

typedef enum ConferenceEjectRequestReason {
    ConferenceEjectRequestReason_userInitiated = 0,
} ConferenceEjectRequestReason;
typedef struct ConferenceEjectUserRequest {
    UserID node_to_eject;
    ConferenceEjectRequestReason reason;
} ConferenceEjectUserRequest;

typedef enum ConferenceEjectResult {
    ConferenceEjectResult_success = 0,
    ConferenceEjectResult_invalidRequester = 1,
    invalidNode = 2,
} ConferenceEjectResult;
typedef struct ConferenceEjectUserResponse {
    UserID node_to_eject;
    ConferenceEjectResult result;
} ConferenceEjectUserResponse;

typedef enum ConferenceEjectIndicationReason {
    ConferenceEjectIndicationReason_userInitiated = 0,
    higherNodeDisconnected = 1,
    higherNodeEjected = 2,
} ConferenceEjectIndicationReason;
typedef struct ConferenceEjectUserIndication {
    UserID node_to_eject;
    ConferenceEjectIndicationReason reason;
} ConferenceEjectUserIndication;

typedef struct ConferenceTransferRequest {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    ConferenceNameSelector conference_name;
#   define ctrq_conference_modifier_present 0x80
    ConferenceNameModifier ctrq_conference_modifier;
#   define ctrq_net_address_present 0x40
    PSetOfNetworkAddresses ctrq_net_address;
#   define ctrq_transferring_nodes_present 0x20
    PSetOfTransferringNodesRq ctrq_transferring_nodes;
#   define ctrq_password_present 0x10
    PasswordSelector ctrq_password;
} ConferenceTransferRequest;

typedef enum ConferenceTransferResult {
    ConferenceTransferResult_success = 0,
    ConferenceTransferResult_invalidRequester = 1,
} ConferenceTransferResult;
typedef struct ConferenceTransferResponse {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    ConferenceNameSelector conference_name;
#   define ctrs_conference_modifier_present 0x80
    ConferenceNameModifier ctrs_conference_modifier;
#   define ctrs_transferring_nodes_present 0x40
    PSetOfTransferringNodesRs ctrs_transferring_nodes;
    ConferenceTransferResult result;
} ConferenceTransferResponse;

typedef struct ConferenceTransferIndication {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    ConferenceNameSelector conference_name;
#   define ctin_conference_modifier_present 0x80
    ConferenceNameModifier ctin_conference_modifier;
#   define ctin_net_address_present 0x40
    PSetOfNetworkAddresses ctin_net_address;
#   define ctin_transferring_nodes_present 0x20
    PSetOfTransferringNodesIn ctin_transferring_nodes;
#   define ctin_password_present 0x10
    PasswordSelector ctin_password;
} ConferenceTransferIndication;

typedef struct RosterUpdateIndication {
    ASN1bool_t refresh_is_full;
    NodeInformation node_information;
    PSetOfApplicationInformation application_information;
} RosterUpdateIndication;

typedef struct ApplicationInvokeIndication {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    PApplicationProtocolEntityList application_protocol_entity_list;
#   define destination_nodes_present 0x80
    PSetOfDestinationNodes destination_nodes;
} ApplicationInvokeIndication;

typedef struct RegistryRegisterChannelRequest {
    EntityID entity_id;
    RegistryKey key;
    DynamicChannelID channel_id;
} RegistryRegisterChannelRequest;

typedef struct RegistryAssignTokenRequest {
    EntityID entity_id;
    RegistryKey registry_key;
} RegistryAssignTokenRequest;

typedef struct RegistrySetParameterRequest {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    EntityID entity_id;
    RegistryKey key;
    struct RegistrySetParameterRequest_registry_set_parameter_registry_set_parameter {
	ASN1uint32_t length;
	ASN1octet_t value[64];
    } registry_set_parameter;
#   define parameter_modify_rights_present 0x80
    RegistryModificationRights parameter_modify_rights;
} RegistrySetParameterRequest;

typedef struct RegistryRetrieveEntryRequest {
    EntityID entity_id;
    RegistryKey key;
} RegistryRetrieveEntryRequest;

typedef struct RegistryDeleteEntryRequest {
    EntityID entity_id;
    RegistryKey key;
} RegistryDeleteEntryRequest;

typedef struct RegistryMonitorEntryRequest {
    EntityID entity_id;
    RegistryKey key;
} RegistryMonitorEntryRequest;

typedef struct RegistryMonitorEntryIndication {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    RegistryKey key;
    RegistryItem item;
    RegistryEntryOwner owner;
#   define entry_modify_rights_present 0x80
    RegistryModificationRights entry_modify_rights;
} RegistryMonitorEntryIndication;

typedef struct RegistryAllocateHandleRequest {
    EntityID entity_id;
    ASN1uint16_t number_of_handles;
} RegistryAllocateHandleRequest;

typedef enum RegistryAllocateHandleResult {
    RegistryAllocateHandleResult_successful = 0,
    noHandlesAvailable = 1,
} RegistryAllocateHandleResult;
typedef struct RegistryAllocateHandleResponse {
    EntityID entity_id;
    ASN1uint16_t number_of_handles;
    Handle first_handle;
    RegistryAllocateHandleResult result;
} RegistryAllocateHandleResponse;

typedef enum RegistryResponsePrimitiveType {
    registerChannel = 0,
    assignToken = 1,
    setParameter = 2,
    retrieveEntry = 3,
    deleteEntry = 4,
    monitorEntry = 5,
} RegistryResponsePrimitiveType;
typedef enum RegistryResponseResult {
    RegistryResponseResult_successful = 0,
    belongsToOther = 1,
    tooManyEntries = 2,
    inconsistentType = 3,
    entryNotFound = 4,
    entryAlreadyExists = 5,
    RegistryResponseResult_invalidRequester = 6,
} RegistryResponseResult;
typedef struct RegistryResponse {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    EntityID entity_id;
    RegistryResponsePrimitiveType primitive_type;
    RegistryKey key;
    RegistryItem item;
    RegistryEntryOwner owner;
#   define response_modify_rights_present 0x80
    RegistryModificationRights response_modify_rights;
    RegistryResponseResult result;
} RegistryResponse;

typedef struct ConductorAssignIndication {
    UserID user_id;
} ConductorAssignIndication;

typedef struct ConductorReleaseIndication {
    char placeholder;
} ConductorReleaseIndication;

typedef struct ConductorPermissionAskIndication {
    ASN1bool_t permission_is_granted;
} ConductorPermissionAskIndication;

typedef struct ConductorPermissionGrantIndication {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    PPermissionList permission_list;
#   define waiting_list_present 0x80
    PWaitingList waiting_list;
} ConductorPermissionGrantIndication;

typedef struct ConferenceTimeRemainingIndication {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    Time time_remaining;
#   define time_remaining_node_id_present 0x80
    UserID time_remaining_node_id;
} ConferenceTimeRemainingIndication;

typedef struct ConferenceTimeInquireIndication {
    ASN1bool_t time_is_node_specific;
} ConferenceTimeInquireIndication;

typedef struct ConferenceTimeExtendIndication {
    Time time_to_extend;
    ASN1bool_t time_is_node_specific;
} ConferenceTimeExtendIndication;

typedef struct ConferenceAssistanceIndication {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
#   define cain_user_data_present 0x80
    PSetOfUserData cain_user_data;
} ConferenceAssistanceIndication;

typedef struct TextMessageIndication {
    TextString message;
} TextMessageIndication;

typedef struct NonStandardPDU {
    NonStandardParameter data;
} NonStandardPDU;

typedef struct ConnectData {
    Key t124_identifier;
    ASN1octetstring_t connect_pdu;
} ConnectData;
#define ConnectData_PDU 0
#define SIZE_GCCPDU_Module_PDU_0 sizeof(ConnectData)

typedef struct IndicationPDU {
    ASN1choice_t choice;
    union {
#	define user_id_indication_chosen 1
	UserIDIndication user_id_indication;
#	define conference_lock_indication_chosen 2
	ConferenceLockIndication conference_lock_indication;
#	define conference_unlock_indication_chosen 3
	ConferenceUnlockIndication conference_unlock_indication;
#	define conference_terminate_indication_chosen 4
	ConferenceTerminateIndication conference_terminate_indication;
#	define conference_eject_user_indication_chosen 5
	ConferenceEjectUserIndication conference_eject_user_indication;
#	define conference_transfer_indication_chosen 6
	ConferenceTransferIndication conference_transfer_indication;
#	define roster_update_indication_chosen 7
	RosterUpdateIndication roster_update_indication;
#	define application_invoke_indication_chosen 8
	ApplicationInvokeIndication application_invoke_indication;
#	define registry_monitor_entry_indication_chosen 9
	RegistryMonitorEntryIndication registry_monitor_entry_indication;
#	define conductor_assign_indication_chosen 10
	ConductorAssignIndication conductor_assign_indication;
#	define conductor_release_indication_chosen 11
	ConductorReleaseIndication conductor_release_indication;
#	define conductor_permission_ask_indication_chosen 12
	ConductorPermissionAskIndication conductor_permission_ask_indication;
#	define conductor_permission_grant_indication_chosen 13
	ConductorPermissionGrantIndication conductor_permission_grant_indication;
#	define conference_time_remaining_indication_chosen 14
	ConferenceTimeRemainingIndication conference_time_remaining_indication;
#	define conference_time_inquire_indication_chosen 15
	ConferenceTimeInquireIndication conference_time_inquire_indication;
#	define conference_time_extend_indication_chosen 16
	ConferenceTimeExtendIndication conference_time_extend_indication;
#	define conference_assistance_indication_chosen 17
	ConferenceAssistanceIndication conference_assistance_indication;
#	define text_message_indication_chosen 18
	TextMessageIndication text_message_indication;
#	define non_standard_indication_chosen 19
	NonStandardPDU non_standard_indication;
    } u;
} IndicationPDU;

typedef struct ApplicationUpdate {
    ASN1choice_t choice;
    union {
#	define application_add_record_chosen 1
	ApplicationRecord application_add_record;
#	define application_replace_record_chosen 2
	ApplicationRecord application_replace_record;
#	define application_remove_record_chosen 3
    } u;
} ApplicationUpdate;

typedef struct RosterUpdateIndication_application_information_Set_application_capabilities_list_application_capability_refresh_Set {
    CapabilityID capability_id;
    CapabilityClass capability_class;
    ASN1uint32_t number_of_entities;
} RosterUpdateIndication_application_information_Set_application_capabilities_list_application_capability_refresh_Set;

typedef struct RosterUpdateIndication_application_information_Set_application_record_list_application_record_refresh_Set {
    UserID node_id;
    EntityID entity_id;
    ApplicationRecord application_record;
} RosterUpdateIndication_application_information_Set_application_record_list_application_record_refresh_Set;

typedef struct RosterUpdateIndication_application_information_Set_application_record_list_application_record_update_Set {
    UserID node_id;
    EntityID entity_id;
    ApplicationUpdate application_update;
} RosterUpdateIndication_application_information_Set_application_record_list_application_record_update_Set;

typedef struct NodeUpdate {
    ASN1choice_t choice;
    union {
#	define node_add_record_chosen 1
	NodeRecord node_add_record;
#	define node_replace_record_chosen 2
	NodeRecord node_replace_record;
#	define node_remove_record_chosen 3
    } u;
} NodeUpdate;

typedef struct RosterUpdateIndication_node_information_node_record_list_node_record_refresh_Set {
    UserID node_id;
    NodeRecord node_record;
} RosterUpdateIndication_node_information_node_record_list_node_record_refresh_Set;

typedef struct RosterUpdateIndication_node_information_node_record_list_node_record_update_Set {
    UserID node_id;
    NodeUpdate node_update;
} RosterUpdateIndication_node_information_node_record_list_node_record_update_Set;

typedef struct SetOfApplicationRecordUpdates {
    PSetOfApplicationRecordUpdates next;
    RosterUpdateIndication_application_information_Set_application_record_list_application_record_update_Set value;
} SetOfApplicationRecordUpdates_Element;

typedef struct SetOfApplicationRecordRefreshes {
    PSetOfApplicationRecordRefreshes next;
    RosterUpdateIndication_application_information_Set_application_record_list_application_record_refresh_Set value;
} SetOfApplicationRecordRefreshes_Element;

typedef struct SetOfApplicationCapabilityRefreshes {
    PSetOfApplicationCapabilityRefreshes next;
    RosterUpdateIndication_application_information_Set_application_capabilities_list_application_capability_refresh_Set value;
} SetOfApplicationCapabilityRefreshes_Element;

typedef struct SetOfNodeRecordUpdates {
    PSetOfNodeRecordUpdates next;
    RosterUpdateIndication_node_information_node_record_list_node_record_update_Set value;
} SetOfNodeRecordUpdates_Element;

typedef struct SetOfNodeRecordRefreshes {
    PSetOfNodeRecordRefreshes next;
    RosterUpdateIndication_node_information_node_record_list_node_record_refresh_Set value;
} SetOfNodeRecordRefreshes_Element;

typedef struct ApplicationRecord_non_collapsing_capabilities_Set {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    CapabilityID capability_id;
#   define application_data_present 0x80
    ASN1octetstring_t application_data;
} ApplicationRecord_non_collapsing_capabilities_Set;

typedef struct ApplicationInvokeSpecifier_expected_capability_set_Set {
    CapabilityID capability_id;
    CapabilityClass capability_class;
} ApplicationInvokeSpecifier_expected_capability_set_Set;

typedef struct RosterUpdateIndication_application_information_Set {
    SessionKey session_key;
    ApplicationRecordList application_record_list;
    ApplicationCapabilitiesList application_capabilities_list;
    ASN1uint16_t roster_instance_number;
    ASN1bool_t peer_entities_are_added;
    ASN1bool_t peer_entities_are_removed;
} RosterUpdateIndication_application_information_Set;

typedef struct ApplicationProtocolEntityList {
    PApplicationProtocolEntityList next;
    ApplicationInvokeSpecifier value;
} ApplicationProtocolEntityList_Element;

typedef struct SetOfApplicationInformation {
    PSetOfApplicationInformation next;
    RosterUpdateIndication_application_information_Set value;
} SetOfApplicationInformation_Element;

typedef struct SetOfConferenceDescriptors {
    PSetOfConferenceDescriptors next;
    ConferenceDescriptor value;
} SetOfConferenceDescriptors_Element;

typedef struct SetOfExpectedCapabilities {
    PSetOfExpectedCapabilities next;
    ApplicationInvokeSpecifier_expected_capability_set_Set value;
} SetOfExpectedCapabilities_Element;

typedef struct SetOfNonCollapsingCapabilities {
    PSetOfNonCollapsingCapabilities next;
    ApplicationRecord_non_collapsing_capabilities_Set value;
} SetOfNonCollapsingCapabilities_Element;

typedef struct NetworkAddress {
    ASN1choice_t choice;
    union {
#	define aggregated_channel_chosen 1
	AggregateChannel aggregated_channel;
#	define transport_connection_chosen 2
	TransportConnectionType transport_connection;
#	define address_non_standard_chosen 3
	NonStandardParameter address_non_standard;
    } u;
} NetworkAddress;

typedef struct ChallengeRequestResponse {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
#   define challenge_request_present 0x80
    ChallengeRequest challenge_request;
#   define challenge_response_present 0x40
    ChallengeResponse challenge_response;
} ChallengeRequestResponse;

typedef struct SetOfChallengeItems {
    PSetOfChallengeItems next;
    ChallengeItem value;
} SetOfChallengeItems_Element;

typedef struct UserData_Set {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    Key key;
#   define user_data_field_present 0x80
    ASN1octetstring_t user_data_field;
} UserData_Set;

typedef struct SetOfUserData {
    PSetOfUserData next;
    UserData_Set user_data_element;
} SetOfUserData_Element;

typedef struct PasswordChallengeRequestResponse {
    ASN1choice_t choice;
    union {
#	define challenge_clear_password_chosen 1
	PasswordSelector challenge_clear_password;
#	define challenge_request_response_chosen 2
	ChallengeRequestResponse challenge_request_response;
    } u;
} PasswordChallengeRequestResponse;

typedef struct SetOfNetworkAddresses {
    PSetOfNetworkAddresses next;
    NetworkAddress value;
} SetOfNetworkAddresses_Element;

typedef struct ConferenceJoinRequest {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
#   define conference_name_present 0x80
    ConferenceNameSelector conference_name;
#   define cjrq_conference_modifier_present 0x40
    ConferenceNameModifier cjrq_conference_modifier;
#   define tag_present 0x20
    ASN1int32_t tag;
#   define cjrq_password_present 0x10
    PasswordChallengeRequestResponse cjrq_password;
#   define cjrq_convener_password_present 0x8
    PasswordSelector cjrq_convener_password;
#   define cjrq_caller_id_present 0x4
    TextString cjrq_caller_id;
#   define cjrq_user_data_present 0x2
    PSetOfUserData cjrq_user_data;
} ConferenceJoinRequest;

typedef enum ConferenceJoinResult {
    ConferenceJoinResult_success = 0,
    ConferenceJoinResult_userRejected = 1,
    invalidConference = 2,
    invalidPassword = 3,
    invalidConvenerPassword = 4,
    challengeResponseRequired = 5,
    invalidChallengeResponse = 6,
} ConferenceJoinResult;
typedef struct ConferenceJoinResponse {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
#   define cjrs_node_id_present 0x80
    UserID cjrs_node_id;
    UserID top_node_id;
    ASN1int32_t tag;
#   define conference_name_alias_present 0x40
    ConferenceNameSelector conference_name_alias;
    ASN1bool_t clear_password_required;
    ASN1bool_t conference_is_locked;
    ASN1bool_t conference_is_listed;
    ASN1bool_t conference_is_conductible;
    TerminationMethod termination_method;
#   define cjrs_conductor_privs_present 0x20
    PSetOfPrivileges cjrs_conductor_privs;
#   define cjrs_conducted_privs_present 0x10
    PSetOfPrivileges cjrs_conducted_privs;
#   define cjrs_non_conducted_privs_present 0x8
    PSetOfPrivileges cjrs_non_conducted_privs;
#   define cjrs_description_present 0x4
    TextString cjrs_description;
#   define cjrs_password_present 0x2
    PasswordChallengeRequestResponse cjrs_password;
    ConferenceJoinResult result;
#   define cjrs_user_data_present 0x1
    PSetOfUserData cjrs_user_data;
} ConferenceJoinResponse;

typedef struct ConnectGCCPDU {
    ASN1choice_t choice;
    union {
#	define conference_create_request_chosen 1
	ConferenceCreateRequest conference_create_request;
#	define conference_create_response_chosen 2
	ConferenceCreateResponse conference_create_response;
#	define conference_query_request_chosen 3
	ConferenceQueryRequest conference_query_request;
#	define conference_query_response_chosen 4
	ConferenceQueryResponse conference_query_response;
#	define connect_join_request_chosen 5
	ConferenceJoinRequest connect_join_request;
#	define connect_join_response_chosen 6
	ConferenceJoinResponse connect_join_response;
#	define conference_invite_request_chosen 7
	ConferenceInviteRequest conference_invite_request;
#	define conference_invite_response_chosen 8
	ConferenceInviteResponse conference_invite_response;
    } u;
} ConnectGCCPDU;
#define ConnectGCCPDU_PDU 1
#define SIZE_GCCPDU_Module_PDU_1 sizeof(ConnectGCCPDU)

typedef struct RequestPDU {
    ASN1choice_t choice;
    union {
#	define conference_join_request_chosen 1
	ConferenceJoinRequest conference_join_request;
#	define conference_add_request_chosen 2
	ConferenceAddRequest conference_add_request;
#	define conference_lock_request_chosen 3
	ConferenceLockRequest conference_lock_request;
#	define conference_unlock_request_chosen 4
	ConferenceUnlockRequest conference_unlock_request;
#	define conference_terminate_request_chosen 5
	ConferenceTerminateRequest conference_terminate_request;
#	define conference_eject_user_request_chosen 6
	ConferenceEjectUserRequest conference_eject_user_request;
#	define conference_transfer_request_chosen 7
	ConferenceTransferRequest conference_transfer_request;
#	define registry_register_channel_request_chosen 8
	RegistryRegisterChannelRequest registry_register_channel_request;
#	define registry_assign_token_request_chosen 9
	RegistryAssignTokenRequest registry_assign_token_request;
#	define registry_set_parameter_request_chosen 10
	RegistrySetParameterRequest registry_set_parameter_request;
#	define registry_retrieve_entry_request_chosen 11
	RegistryRetrieveEntryRequest registry_retrieve_entry_request;
#	define registry_delete_entry_request_chosen 12
	RegistryDeleteEntryRequest registry_delete_entry_request;
#	define registry_monitor_entry_request_chosen 13
	RegistryMonitorEntryRequest registry_monitor_entry_request;
#	define registry_allocate_handle_request_chosen 14
	RegistryAllocateHandleRequest registry_allocate_handle_request;
#	define non_standard_request_chosen 15
	NonStandardPDU non_standard_request;
    } u;
} RequestPDU;

typedef struct FunctionNotSupportedResponse {
    RequestPDU request;
} FunctionNotSupportedResponse;

typedef struct ResponsePDU {
    ASN1choice_t choice;
    union {
#	define conference_join_response_chosen 1
	ConferenceJoinResponse conference_join_response;
#	define conference_add_response_chosen 2
	ConferenceAddResponse conference_add_response;
#	define conference_lock_response_chosen 3
	ConferenceLockResponse conference_lock_response;
#	define conference_unlock_response_chosen 4
	ConferenceUnlockResponse conference_unlock_response;
#	define conference_terminate_response_chosen 5
	ConferenceTerminateResponse conference_terminate_response;
#	define conference_eject_user_response_chosen 6
	ConferenceEjectUserResponse conference_eject_user_response;
#	define conference_transfer_response_chosen 7
	ConferenceTransferResponse conference_transfer_response;
#	define registry_response_chosen 8
	RegistryResponse registry_response;
#	define registry_allocate_handle_response_chosen 9
	RegistryAllocateHandleResponse registry_allocate_handle_response;
#	define function_not_supported_response_chosen 10
	FunctionNotSupportedResponse function_not_supported_response;
#	define non_standard_response_chosen 11
	NonStandardPDU non_standard_response;
    } u;
} ResponsePDU;

typedef struct GCCPDU {
    ASN1choice_t choice;
    union {
#	define request_chosen 1
	RequestPDU request;
#	define response_chosen 2
	ResponsePDU response;
#	define indication_chosen 3
	IndicationPDU indication;
    } u;
} GCCPDU;
#define GCCPDU_PDU 2
#define SIZE_GCCPDU_Module_PDU_2 sizeof(GCCPDU)

extern Key t124identifier;

extern ASN1char32string_t simpleTextFirstCharacter;

extern ASN1char32string_t simpleTextLastCharacter;

extern ASN1module_t GCCPDU_Module;
extern void ASN1CALL GCCPDU_Module_Startup(void);
extern void ASN1CALL GCCPDU_Module_Cleanup(void);

/* Prototypes of element functions for SEQUENCE OF and SET OF constructs */
    extern int ASN1CALL ASN1Enc_WaitingList_ElmFn(ASN1encoding_t enc, PWaitingList val);
    extern int ASN1CALL ASN1Dec_WaitingList_ElmFn(ASN1decoding_t dec, PWaitingList val);
    extern void ASN1CALL ASN1Free_WaitingList_ElmFn(PWaitingList val);
    extern int ASN1CALL ASN1Enc_PermissionList_ElmFn(ASN1encoding_t enc, PPermissionList val);
    extern int ASN1CALL ASN1Dec_PermissionList_ElmFn(ASN1decoding_t dec, PPermissionList val);
    extern void ASN1CALL ASN1Free_PermissionList_ElmFn(PPermissionList val);
    extern int ASN1CALL ASN1Enc_SetOfDestinationNodes_ElmFn(ASN1encoding_t enc, PSetOfDestinationNodes val);
    extern int ASN1CALL ASN1Dec_SetOfDestinationNodes_ElmFn(ASN1decoding_t dec, PSetOfDestinationNodes val);
    extern void ASN1CALL ASN1Free_SetOfDestinationNodes_ElmFn(PSetOfDestinationNodes val);
    extern int ASN1CALL ASN1Enc_SetOfTransferringNodesIn_ElmFn(ASN1encoding_t enc, PSetOfTransferringNodesIn val);
    extern int ASN1CALL ASN1Dec_SetOfTransferringNodesIn_ElmFn(ASN1decoding_t dec, PSetOfTransferringNodesIn val);
    extern void ASN1CALL ASN1Free_SetOfTransferringNodesIn_ElmFn(PSetOfTransferringNodesIn val);
    extern int ASN1CALL ASN1Enc_SetOfTransferringNodesRs_ElmFn(ASN1encoding_t enc, PSetOfTransferringNodesRs val);
    extern int ASN1CALL ASN1Dec_SetOfTransferringNodesRs_ElmFn(ASN1decoding_t dec, PSetOfTransferringNodesRs val);
    extern void ASN1CALL ASN1Free_SetOfTransferringNodesRs_ElmFn(PSetOfTransferringNodesRs val);
    extern int ASN1CALL ASN1Enc_SetOfTransferringNodesRq_ElmFn(ASN1encoding_t enc, PSetOfTransferringNodesRq val);
    extern int ASN1CALL ASN1Dec_SetOfTransferringNodesRq_ElmFn(ASN1decoding_t dec, PSetOfTransferringNodesRq val);
    extern void ASN1CALL ASN1Free_SetOfTransferringNodesRq_ElmFn(PSetOfTransferringNodesRq val);
    extern int ASN1CALL ASN1Enc_ParticipantsList_ElmFn(ASN1encoding_t enc, PParticipantsList val);
    extern int ASN1CALL ASN1Dec_ParticipantsList_ElmFn(ASN1decoding_t dec, PParticipantsList val);
    extern void ASN1CALL ASN1Free_ParticipantsList_ElmFn(PParticipantsList val);
    extern int ASN1CALL ASN1Enc_SetOfPrivileges_ElmFn(ASN1encoding_t enc, PSetOfPrivileges val);
    extern int ASN1CALL ASN1Dec_SetOfPrivileges_ElmFn(ASN1decoding_t dec, PSetOfPrivileges val);
    extern void ASN1CALL ASN1Free_SetOfPrivileges_ElmFn(PSetOfPrivileges val);
    extern int ASN1CALL ASN1Enc_SetOfApplicationRecordUpdates_ElmFn(ASN1encoding_t enc, PSetOfApplicationRecordUpdates val);
    extern int ASN1CALL ASN1Dec_SetOfApplicationRecordUpdates_ElmFn(ASN1decoding_t dec, PSetOfApplicationRecordUpdates val);
    extern void ASN1CALL ASN1Free_SetOfApplicationRecordUpdates_ElmFn(PSetOfApplicationRecordUpdates val);
    extern int ASN1CALL ASN1Enc_SetOfApplicationRecordRefreshes_ElmFn(ASN1encoding_t enc, PSetOfApplicationRecordRefreshes val);
    extern int ASN1CALL ASN1Dec_SetOfApplicationRecordRefreshes_ElmFn(ASN1decoding_t dec, PSetOfApplicationRecordRefreshes val);
    extern void ASN1CALL ASN1Free_SetOfApplicationRecordRefreshes_ElmFn(PSetOfApplicationRecordRefreshes val);
    extern int ASN1CALL ASN1Enc_SetOfApplicationCapabilityRefreshes_ElmFn(ASN1encoding_t enc, PSetOfApplicationCapabilityRefreshes val);
    extern int ASN1CALL ASN1Dec_SetOfApplicationCapabilityRefreshes_ElmFn(ASN1decoding_t dec, PSetOfApplicationCapabilityRefreshes val);
    extern void ASN1CALL ASN1Free_SetOfApplicationCapabilityRefreshes_ElmFn(PSetOfApplicationCapabilityRefreshes val);
    extern int ASN1CALL ASN1Enc_SetOfNodeRecordUpdates_ElmFn(ASN1encoding_t enc, PSetOfNodeRecordUpdates val);
    extern int ASN1CALL ASN1Dec_SetOfNodeRecordUpdates_ElmFn(ASN1decoding_t dec, PSetOfNodeRecordUpdates val);
    extern void ASN1CALL ASN1Free_SetOfNodeRecordUpdates_ElmFn(PSetOfNodeRecordUpdates val);
    extern int ASN1CALL ASN1Enc_SetOfNodeRecordRefreshes_ElmFn(ASN1encoding_t enc, PSetOfNodeRecordRefreshes val);
    extern int ASN1CALL ASN1Dec_SetOfNodeRecordRefreshes_ElmFn(ASN1decoding_t dec, PSetOfNodeRecordRefreshes val);
    extern void ASN1CALL ASN1Free_SetOfNodeRecordRefreshes_ElmFn(PSetOfNodeRecordRefreshes val);
    extern int ASN1CALL ASN1Enc_ApplicationProtocolEntityList_ElmFn(ASN1encoding_t enc, PApplicationProtocolEntityList val);
    extern int ASN1CALL ASN1Dec_ApplicationProtocolEntityList_ElmFn(ASN1decoding_t dec, PApplicationProtocolEntityList val);
    extern void ASN1CALL ASN1Free_ApplicationProtocolEntityList_ElmFn(PApplicationProtocolEntityList val);
    extern int ASN1CALL ASN1Enc_SetOfApplicationInformation_ElmFn(ASN1encoding_t enc, PSetOfApplicationInformation val);
    extern int ASN1CALL ASN1Dec_SetOfApplicationInformation_ElmFn(ASN1decoding_t dec, PSetOfApplicationInformation val);
    extern void ASN1CALL ASN1Free_SetOfApplicationInformation_ElmFn(PSetOfApplicationInformation val);
    extern int ASN1CALL ASN1Enc_SetOfConferenceDescriptors_ElmFn(ASN1encoding_t enc, PSetOfConferenceDescriptors val);
    extern int ASN1CALL ASN1Dec_SetOfConferenceDescriptors_ElmFn(ASN1decoding_t dec, PSetOfConferenceDescriptors val);
    extern void ASN1CALL ASN1Free_SetOfConferenceDescriptors_ElmFn(PSetOfConferenceDescriptors val);
    extern int ASN1CALL ASN1Enc_SetOfExpectedCapabilities_ElmFn(ASN1encoding_t enc, PSetOfExpectedCapabilities val);
    extern int ASN1CALL ASN1Dec_SetOfExpectedCapabilities_ElmFn(ASN1decoding_t dec, PSetOfExpectedCapabilities val);
    extern void ASN1CALL ASN1Free_SetOfExpectedCapabilities_ElmFn(PSetOfExpectedCapabilities val);
    extern int ASN1CALL ASN1Enc_SetOfNonCollapsingCapabilities_ElmFn(ASN1encoding_t enc, PSetOfNonCollapsingCapabilities val);
    extern int ASN1CALL ASN1Dec_SetOfNonCollapsingCapabilities_ElmFn(ASN1decoding_t dec, PSetOfNonCollapsingCapabilities val);
    extern void ASN1CALL ASN1Free_SetOfNonCollapsingCapabilities_ElmFn(PSetOfNonCollapsingCapabilities val);
    extern int ASN1CALL ASN1Enc_SetOfChallengeItems_ElmFn(ASN1encoding_t enc, PSetOfChallengeItems val);
    extern int ASN1CALL ASN1Dec_SetOfChallengeItems_ElmFn(ASN1decoding_t dec, PSetOfChallengeItems val);
    extern void ASN1CALL ASN1Free_SetOfChallengeItems_ElmFn(PSetOfChallengeItems val);
    extern int ASN1CALL ASN1Enc_SetOfUserData_ElmFn(ASN1encoding_t enc, PSetOfUserData val);
    extern int ASN1CALL ASN1Dec_SetOfUserData_ElmFn(ASN1decoding_t dec, PSetOfUserData val);
    extern void ASN1CALL ASN1Free_SetOfUserData_ElmFn(PSetOfUserData val);
    extern int ASN1CALL ASN1Enc_SetOfNetworkAddresses_ElmFn(ASN1encoding_t enc, PSetOfNetworkAddresses val);
    extern int ASN1CALL ASN1Dec_SetOfNetworkAddresses_ElmFn(ASN1decoding_t dec, PSetOfNetworkAddresses val);
    extern void ASN1CALL ASN1Free_SetOfNetworkAddresses_ElmFn(PSetOfNetworkAddresses val);

#ifdef __cplusplus
} /* extern "C" */
#endif

#endif /* _GCCPDU_Module_H_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\remdsk\rds\t120\h\gcontrol.h ===
#ifndef _GCC_CONTROLLER_
#define _GCC_CONTROLLER_

/*
 *	gcontrol.h
 *
 *	Copyright (c) 1995 by DataBeam Corporation, Lexington, KY
 *
 *	Abstract:
 *		It is the responsibility of the controller to create and destroy many 
 *		of the other objects in the system at run-time.  There is should only 
 *		be one controller in existence at a time per GCC provider.  The 
 *		controller is constructed during system initialization, and not 
 *		destroyed until the provider is shut down.  The controller's primary 
 *		responsibility is to maintain five "layers" of objects in the system at 
 *		run-time.  These include the Application Interface, the SAPs (the
 *		Control SAP as well as the Application SAPs), the Conference objects, 
 *		the MCSUser object (which is actualy created by the conference object),
 *		and the MCS Interface.  It also "plugs" together objects in adjacent 
 *		layers by informing a newly created object of the identity of those 
 *		objects with which it must communicate.  The newly created object can 
 *		then register itself with the appropriate objects in the layers above 
 *		and below.  The controller plays a small role in the passing of 
 *		information during a conference (this is handled by the objects it 
 *		creates).
 *
 *		It is worth noting that the controller is the primary recipient of 
 *		owner callbacks in the GCC system.  Most of the objects in its "object 
 *		stack" are capable of issuing owner callbacks to the controller for 
 *		various events and requests.
 *
 *		The controller is not completely portable.  Since the nature of 
 *		application and MCS interfaces will vary from platform to platform, the 
 *		interface objects that must be created will also vary.  It is necessary 
 *		for the controller to know which objects to create and destroy during 
 *		initialization and cleanup.  Other than this, however, the rest of the 
 *		code in the controller class should port cleanly.
 *
 *		The constructor performs all activity required to prepare GCC for use.  
 *		It creates an instance of the Memory Manager class (and possibly a 
 *		Message Memory Manager class in certain environments), which will be 
 *		used for memory handling by other objects in the system.  It creates the 
 *		GccAppInterface objects that will be used to communicate with all user 
 *		applications (including the node controller).  It creates the MCS 
 *		Interface object that will be used to communicate with MCS.  GCC relies 
 *		on an owner callback from a GccAppInterface object to give it a 
 *		heartbeat.  It is during this heartbeat that the controller does all of 
 *		its work at run-time.
 *
 *		The destructor essentially does the opposite of what the constructor 
 *		does (as you might expect).  It destroys all objects that are "owned" 
 *		by the controller, cleanly shutting everything down.
 *
 *		As mentioned above, the controller is the primary recipient of owner 
 *		callbacks in the GCC system.  To accomplish this it overrides the 
 *		Owner-Callback member function.  It can then pass its "this" pointer to 
 *		objects that it creates, allowing them to issue owner callbacks when 
 *		necessary.  Everything the controller does at run-time is in response 
 *		to these owner callbacks.
 *
 *		The controller is the prime recipient of connect provider indications 
 *		from MCS.  Many of the messages that are passed between GCC and the 
 *		GccAppInterface before a conference is established involve the 
 *		controller.  These include ConferenceCreateIndication,  
 *		ConferenceInviteIndication,  etc.  Also, the controller object is 
 *		exclusively responsible for handling conference queries since it 
 *		maintains a complete list of all the conferences that exist in the 
 *		system.
 *
 *	Portable:
 *		Not Completely (80 % portable)
 *		Member functions which aren't portable:
 *			-	GCCControl()
 *			-	~GCCControl()
 *			-	EventLoop()
 *			-	PollCommDevices()
 *			-	CreateApplicationSap()
 *
 *	Protected Instance Variables:
 *		None.
 *
 *	Caveats:
 *		None.
 *
 *	Author:
 *		blp
 */

#include "sap.h"
#include "csap.h"
#include "appsap.h"
#include "conf.h"
#include "pktcoder.h"
#include "privlist.h"
#include "mcsdllif.h"
#include "t120app.h"

// #include "gccncif.h"

extern CRITICAL_SECTION     g_csGCCProvider;


/*
**	These are the message bases used by the controller object.  Any
**	owner callback message received from an object that the controller
**	created must have a message base added to it before it is received
**	at the controller.
*/
#define MCS_INTERFACE_MESSAGE_BASE		300   //	Leave room for status

enum
{
    GCTRL_REBUILD_CONF_POLL_LIST    = GCTRLMSG_BASE + 1,
};


// permit to enroll callback list
class CApplet;
class CAppletList : public CList
{
    DEFINE_CLIST(CAppletList, CApplet*)
};

/*
**	The conference information structure is used to temporarily store
**	information needed to create a conference while waiting for a
**	conference create response.
*/
typedef struct PENDING_CREATE_CONF
{
	// a destructor to this data structure
	PENDING_CREATE_CONF(void);
	~PENDING_CREATE_CONF(void);

	LPSTR							pszConfNumericName;
	LPWSTR							pwszConfTextName;
	BOOL							password_in_the_clear;
	BOOL							conference_is_locked;
	BOOL							conference_is_listed;
	BOOL							conference_is_conductible;
	GCCTerminationMethod			termination_method;
	PPrivilegeListData				conduct_privilege_list;
	PPrivilegeListData				conduct_mode_privilege_list;
	PPrivilegeListData				non_conduct_privilege_list;
	LPWSTR							pwszConfDescription;
    ConnectionHandle				connection_handle;
	UserID							parent_node_id;
	UserID							top_node_id;
	TagNumber						tag_number;
}
	PENDING_CREATE_CONF;

/*
**	This defines the template for the list that keeps track of information
**	associated with a conference that is waiting for a response on a 
**	create conference indication.
*/
class CPendingCreateConfList2 : public CList2
{
    DEFINE_CLIST2(CPendingCreateConfList2, PENDING_CREATE_CONF*, GCCConfID)
};


/*
**	The join information structure is used to temporarily store
**	information needed to join a conference after the join response is
**	issued.
*/
typedef struct PENDING_JOIN_CONF
{
	PENDING_JOIN_CONF(void);
	~PENDING_JOIN_CONF(void);

	CPassword               *convener_password;
	CPassword               *password_challenge;
	LPWSTR					pwszCallerID;
	BOOL					numeric_name_present;
	GCCConfID               nConfID;
}
	PENDING_JOIN_CONF;

/*
**	This defines the template for the list that keeps track of information
**	associated with an outstanding join request.
*/
class CPendingJoinConfList2 : public CList2
{
    DEFINE_CLIST2_(CPendingJoinConfList2, PENDING_JOIN_CONF*, ConnectionHandle)
};


//	Holds the list of outstanding query request
class CPendingQueryConfList2 : public CList2
{
    DEFINE_CLIST2_(CPendingQueryConfList2, GCCConfID, ConnectionHandle)
};


extern HANDLE g_hevGCCOutgoingPDU;


class GCCController : public CRefCount
{
public:

	GCCController(PGCCError);
	~GCCController(void);

    void RegisterAppSap(CAppSap *);
    void UnRegisterAppSap(CAppSap *);

    void RegisterApplet(CApplet *);
    void UnregisterApplet(CApplet *);

    CConf *GetConfObject(GCCConfID nConfID) { return m_ConfList2.Find(nConfID); }

	//	Functions initiated from the node controller 
	GCCError ConfCreateRequest(CONF_CREATE_REQUEST *, GCCConfID *);

    void WndMsgHandler ( UINT uMsg );
    BOOL FlushOutgoingPDU ( void );
    void SetEventToFlushOutgoingPDU ( void ) { ::SetEvent(g_hevGCCOutgoingPDU); }

	//	Functions initiated from Control SAP
	GCCError    ConfCreateResponse(PConfCreateResponseInfo);
	GCCError    ConfQueryRequest(PConfQueryRequestInfo);
	GCCError    ConfQueryResponse(PConfQueryResponseInfo);
	GCCError    ConfJoinRequest(PConfJoinRequestInfo, GCCConfID *);
	GCCError    ConfJoinIndResponse(PConfJoinResponseInfo);
	GCCError    ConfInviteResponse(PConfInviteResponseInfo);
    GCCError    FailConfJoinIndResponse(GCCConfID, ConnectionHandle);
    GCCError    FailConfJoinIndResponse(PConfJoinResponseInfo);
    void        RemoveConfJoinInfo(ConnectionHandle hConn);

	//	Functions initiated from Conference object
	GCCError    ProcessConfEstablished(GCCConfID);
	GCCError    ProcessConfTerminated(GCCConfID, GCCReason);

	//	Functions initiated from the MCS Interface
	GCCError	ProcessConnectProviderIndication(PConnectProviderIndication);
	GCCError	ProcessConferenceCreateRequest(PConferenceCreateRequest, PConnectProviderIndication);
	GCCError	ProcessConferenceQueryRequest(PConferenceQueryRequest, PConnectProviderIndication);
	GCCError	ProcessConferenceJoinRequest(PConferenceJoinRequest, PConnectProviderIndication);
	GCCError	ProcessConferenceInviteRequest(PConferenceInviteRequest, PConnectProviderIndication);
	GCCError	ProcessConnectProviderConfirm(PConnectProviderConfirm);
	GCCError	ProcessConferenceQueryResponse(PConferenceQueryResponse, PConnectProviderConfirm);
	GCCError	ProcessDisconnectProviderIndication(ConnectionHandle);
    void        CancelConfQueryRequest(ConnectionHandle);

private:

	/*
	**	Routines called from the Owner-Callback function
	*/

    //	Miscelaneous support functions
	GCCConfID	AllocateConferenceID();
	GCCConfID	AllocateQueryID();

	GCCConfID	GetConferenceIDFromName(
							PGCCConferenceName		conference_name,
							GCCNumericString		conference_modifier);

    void RebuildConfPollList ( void );
    void PostMsgToRebuildConfPollList ( void );

private:

	CPendingCreateConfList2			m_PendingCreateConfList2;
	CPendingJoinConfList2			m_PendingJoinConfList2;
	CPendingQueryConfList2			m_PendingQueryConfList2;

	CConfList           			m_ConfDeleteList;
	CConfList2  					m_ConfList2;

	CAppSapList 				    m_AppSapList;

    BOOL							m_fConfListChangePending;

	GCCConfID   					m_ConfIDCounter;
	GCCConfID   					m_QueryIDCounter;

    BOOL							m_fControllerIsExiting;

	DWORD							m_dwControllerWaitTimeout;
	DWORD							m_dwControllerEventMask;
	
    //	These list are used only for iterating.  Whenever a conference or 
    //	application SAP object is deleted (or created in the case of an
    //	application SAP) it is added to the dictionary list first and
    //	a flag is set which forces the Polled list to get recreated at the
    //	top of the next heartbeat.
	CConfList                       m_ConfPollList;

    // T120 Applet list
    CAppletList                     m_AppletList;

};

extern GCCController *g_pGCCController;

/*
 *	GCCController (PGCCError	gcc_error)
 *
 *	Public member function of Conference
 *
 *	Function Description
 *		This is the Windows 32 Bit version of the GCC controller constructor. It 
 *		is responsible for initializing all the instance variables used by this 
 *		class.  It is also responsible for creating the memory manager, the
 *		packet coder, the Node Controller application interface, the Shared 
 *		memory interface used to communicate with enrolled applications, the
 *		Node Controller SAP and the MCS Interface.  It also sets up the 
 *		g_csGCCProvider that protects the core of GCC in the multi-threaded 
 *		Win32 environment.  It also sets up a number of Windows Event objects
 *		used to signal the GCC thread when various events happen at the
 *		interfaces. The last thing it does before returning if no errors have
 *		occured is launch the GCC thread. Fatal errors are returned from this 
 *		constructor in the return value. 
 *
 *	Formal Parameters:
 *		gcc_error	-	(o)	Errors that occur are returned here.
 *
 *	Return Value
 *		None.
 *
 *  Side Effects
 *		This constructor launches the GCC thread if no errors occur.
 *
 *	Caveats
 *		This constructor is very specific to the Win32 environment.  When
 *		porting GCC to other platforms, this constructor will have to be
 *		rewritten for the proper platform.
 */

/*
 *	GCCController(	USHORT		timer_duration,
 *					PGCCError	gcc_error)
 *
 *	Public member function of Conference
 *
 *	Function Description
 *		This is the Windows 16 Bit version of the GCC controller constructor. It 
 *		is responsible for initializing all the instance variables used by this 
 *		class.  It is also responsible for creating the memory manager, the
 *		packet coder, the Node Controller application interface, the Shared 
 *		memory interface used to communicate with enrolled applications, the
 *		Node Controller SAP and the MCS Interface.  It also sets up the 
 *		internal Windows timer if a timer_interval other than zero is specified.
 *		Fatal errors are returned from this constructor in the return value. 
 *
 *	Formal Parameters:
 *		timer_duration	-	(i)	Timer interval in miliseconds that the
 *								heartbeat will trigger at.
 *		instance_handle	-	(i)	This is the windows instance handle used to
 *								set up the Windows timer.
 *		gcc_error		-	(o)	Errors that occur are returned here.
 *
 *	Return Value
 *		None.
 *
 *  Side Effects
 *		None.
 *
 *	Caveats
 *		This constructor is very specific to the Win16 environment.  When
 *		porting GCC to other platforms, this constructor will have to be
 *		rewritten for the proper platform.
 */

/*
 *	~GCCController();
 *
 *	Public member function of Conference
 *
 *	Function Description
 *		This is the Controller destructor.  All platform specific cleanup that
 *		occurs is included in this destructor but is "macro'd" out in 
 *		environments where the cleanup is not necessary (things like
 *		critical sections, and Windows timers).  Deleting the controller
 *		essentially shuts down GCC.  Deleting all the active conferences, SAPs,
 *		and interfaces along with all the GCC support modules (memory manager,
 *		packet coder, etc.).
 *
 *	Formal Parameters:
 *		None.
 *
 *	Return Value
 *		None.
 *
 *  Side Effects
 *		None.
 *
 *	Caveats
 *		This destructor includes platform specific code.  It may be necessary
 *		to include some platform specific code here when porting GCC to 
 *		other platforms.  Macros should be used to isolate this code
 *		where ever possible.
 */

/*
 *	ULONG		Owner-Callback (		UINT        		message,
 *									LPVOID				parameter1,
 *									ULONG				parameter2);
 *
 *	Public member function of Conference
 *
 *	Function Description
 *		This function overides the base class function and is used to
 *		receive all owner callback information from the objects the
 *		the controller creates.
 *
 *	Formal Parameters:
 *		message		-		(i)	Message number including base offset.
 *		parameter1	-		(i)	void pointer of message data.
 *		parameter2	-		(i)	Long holding message data.		
 *
 *	Return Value
 *		GCC_NO_ERROR					-	No error occured.
 *		GCC_ALLOCATION_FAILURE			-	Resource error occured.
 *		GCC_INVALID_CONFERENCE_NAME		-	Invalid conference name passed in.
 *		GCC_FAILURE_CREATING_DOMAIN		-	Failure creating domain.
 *		GCC_BAD_NETWORK_ADDRESS			-	Bad network address passed in.
 *		GCC_BAD_NETWORK_ADDRESS_TYPE	-	Bad network address type passed in.
 *		GCC_CONFERENCE_ALREADY_EXISTS	-	Conference specified already exists.
 *		GCC_INVALID_TRANSPORT			-	Cannot find specified transport.
 *		GCC_INVALID_ADDRESS_PREFIX		-	Bad transport address passed in.
 *		GCC_INVALID_TRANSPORT_ADDRESS	- 	Bad transport address
 *		GCC_BAD_SESSION_KEY				-	Enrolling with invalid session key.
 *		GCC_INVALID_PASSWORD			-	Invalid password passed in.
 *		GCC_BAD_USER_DATA				-	Invalid user data passed in.
 *		GCC_INVALID_JOIN_RESPONSE_TAG	-	No match found for join response tag
 *		GCC_NO_SUCH_APPLICATION			-	Invalid SAP handle passed in.
 *		GCC_CONFERENCE_NOT_ESTABLISHED	-	Request failed because conference
 *											was not established.
 *		GCC_BAD_CAPABILITY_ID			-	Invalid capability ID passed in.
 *		GCC_NO_SUCH_APPLICATION			-	Bad SAP handle passed in.
 *		GCC_DOMAIN_PARAMETERS_UNACCEPTABLE	- Domain parameters were
 *											  unacceptable for this connection.
 *
 *  Side Effects
 *		None.
 *
 *	Caveats
 *		None.
 */

/*
 *	void	EventLoop();
 *
 *	Public member function of Conference
 *
 *	Function Description
 *		This routine is only used for the 32 bit windows platform.  It gets
 *		called whenever an event occurs in this environment.  These include
 *		timer events as well as PDU and message events
 *
 *	Formal Parameters:
 *		None.
 *
 *	Return Value
 *		None.
 *
 *  Side Effects
 *		None.
 *
 *	Caveats
 *		None.
 */

#endif // _GCC_CONTROLLER_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\remdsk\rds\t120\h\imst123.h ===
#ifndef _T123_TRANSPORT_DRIVER_INTERFACE_H_
#define _T123_TRANSPORT_DRIVER_INTERFACE_H_

#include <basetyps.h>
#include <t120type.h>
#include "iplgxprt.h"

typedef UINT_PTR        LEGACY_HANDLE;
typedef HANDLE          PHYSICAL_HANDLE;


typedef ULONG (CALLBACK *TransportCallback) (ULONG, void *, void *);


/*
 *  This structure is passed back with the TRANSPORT_DATA_INDICATION message.
 */
typedef	struct
{
	UINT_PTR            logical_handle;
	LPBYTE              pbData;
	ULONG               cbDataSize;
}
    LegacyTransportData;


/*
 *  This structure is passed back with the TRANSPORT_CONNECT_INDICATION,
 *  TRANSPORT_CONNECT_CONFIRM, and the TRANSPORT_DISONNECT_INDICATION messages.
 *  This structure contains the transport connection identifier and
 *  physical handle.
 */
typedef struct
{
    LEGACY_HANDLE       logical_handle;
    PHYSICAL_HANDLE     hCommLink;
}
    LegacyTransportID;


#undef  INTERFACE
#define INTERFACE ILegacyTransport
DECLARE_INTERFACE(ILegacyTransport)
{
    STDMETHOD_(void, ReleaseInterface) (THIS) PURE;

    STDMETHOD_(TransportError, TInitialize) (THIS_ TransportCallback, void *user_defined) PURE;
    STDMETHOD_(TransportError, TCleanup) (THIS) PURE;
    STDMETHOD_(TransportError, TCreateTransportStack) (THIS_ BOOL fCaller, HANDLE hCommLink, HANDLE hevtClose, PLUGXPRT_PARAMETERS *pParams) PURE;
    STDMETHOD_(TransportError, TCloseTransportStack) (THIS_ HANDLE hCommLink) PURE;
    STDMETHOD_(TransportError, TConnectRequest) (THIS_ LEGACY_HANDLE *, HANDLE hCommLink) PURE;
    STDMETHOD_(TransportError, TDisconnectRequest) (THIS_ LEGACY_HANDLE, BOOL trash_packets) PURE;
    STDMETHOD_(TransportError, TDataRequest) (THIS_ LEGACY_HANDLE, LPBYTE pbData, ULONG cbDataSize) PURE;
    STDMETHOD_(TransportError, TReceiveBufferAvailable) (THIS) PURE;
    STDMETHOD_(TransportError, TPurgeRequest) (THIS_ LEGACY_HANDLE) PURE;
    STDMETHOD_(TransportError, TEnableReceiver) (THIS) PURE;
};


#ifdef __cplusplus
extern "C" {
#endif

TransportError WINAPI T123_CreateTransportInterface(ILegacyTransport **);
typedef TransportError (WINAPI *LPFN_T123_CreateTransportInterface) (ILegacyTransport **);
#define LPSTR_T123_CreateTransportInterface     "T123_CreateTransportInterface"

#ifdef __cplusplus
}
#endif


#endif // _PSTN_TRANSPORT_DRIVER_INTERFACE_H_


=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\remdsk\rds\t120\h\lportmsg.h ===
/*
 *	lportmsg.h
 *
 *	Copyright (c) 1993 - 1995 by DataBeam Corporation, Lexington, KY
 *
 *	Abstract:
 *
 *	Portable:
 *
 *	Author:
 *		James P. Galvin, Jr.
 */
#ifndef	_LISTEN_GCC_PORTAL_MESSAGE_
#define	_LISTEN_GCC_PORTAL_MESSAGE_

#define	LISTEN_CREATE_SAP_PORTALS_REQUEST	0
#define	LISTEN_CREATE_SAP_PORTALS_CONFIRM	1

#define	LISTEN_NO_ERROR						0
#define	LISTEN_CREATE_FAILED				1

typedef struct
{
} LPCreateSapPortalsRequest;


typedef struct
{
	ULong		return_value;
	PVoid		blocking_portal_address;
	PVoid		non_blocking_portal_address;
} LPCreateSapPortalsConfirm;

typedef struct
{
} LPCloseSapPortalsRequest;

typedef	struct
{
	unsigned int		message_type;
	union
	{
		LPCreateSapPortalsRequest		create_sap_portals_request;
		LPCreateSapPortalsConfirm		create_sap_portals_confirm;
		LPCloseSapPortalsRequest		close_sap_portals_request;
	} u;
} GccListenPortalMessage;
typedef	GccListenPortalMessage *		PGccListenPortalMessage;

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\remdsk\rds\t120\h\invoklst.h ===
/*
 *	invoklst.h
 *
 *	Copyright (c) 1995 by DataBeam Corporation, Lexington, KY
 *
 *	Abstract:
 *		This is the interface file for the class CInvokeSpecifierListContainer.
 *		This class manages the data associated with an Application Invoke 
 *		Request or Indication.  This includes a list of applications to be 
 *		invoked.  The CInvokeSpecifierListContainer data container utilizes a 
 *		CSessKeyContainer container to buffer part of the data associated with each
 *		application invoke specifier.  Each application invoke specifier also 
 *		includes a capability ID whose data is buffered internally by the 
 *		using a CCapIDContainer container.  The list of application 
 *		invoke specifiers is maintained internally by the class through the use
 *		of a Rogue Wave list container.
 *
 *	Caveats:
 *		None.
 *
 *	Author:
 *		blp/jbo
 */
#ifndef	_APPLICATION_INVOKE_SPECIFIER_LIST_
#define	_APPLICATION_INVOKE_SPECIFIER_LIST_

#include "capid.h"
#include "sesskey.h"
#include "arost.h"

/*
 * This is the internal structure used to hold the data associated with each
 * invoke specifier.
 */
typedef struct
{
	CSessKeyContainer			    *session_key;
	CAppCapItemList             	ExpectedCapItemList;
	MCSChannelType					startup_channel_type;
	BOOL    						must_be_invoked;
}
    INVOKE_SPECIFIER;

/*
 * These are the typedefs for the Rogue Wave list which is used to hold the
 * invoke specifier info structures.
 */
class CInvokeSpecifierList : public CList
{
    DEFINE_CLIST(CInvokeSpecifierList, INVOKE_SPECIFIER*)
};

/*
 * Class definition:
 */
class CInvokeSpecifierListContainer : public CRefCount
{
public:

	CInvokeSpecifierListContainer(UINT cProtEntities, PGCCAppProtocolEntity *, PGCCError);
	CInvokeSpecifierListContainer(PApplicationProtocolEntityList, PGCCError);

	~CInvokeSpecifierListContainer(void);

	UINT		LockApplicationInvokeSpecifierList(void);
	void		UnLockApplicationInvokeSpecifierList(void);

    UINT		GetApplicationInvokeSpecifierList(USHORT *pcProtEntities, LPBYTE memory);
    UINT		GetApplicationInvokeSpecifierList(ULONG *pcProtEntities, LPBYTE pMemory)
    {
        USHORT c;
        UINT nRet = GetApplicationInvokeSpecifierList(&c, pMemory);
        *pcProtEntities = c;
        return nRet;
    }

    GCCError	GetApplicationInvokeSpecifierListPDU(PApplicationProtocolEntityList *);
	void		FreeApplicationInvokeSpecifierListPDU(void);

protected:

	CInvokeSpecifierList			m_InvokeSpecifierList;
	UINT							m_cbDataSize;

	PApplicationProtocolEntityList	m_pAPEListPDU;
	BOOL    						m_fValidAPEListPDU;

private:

	GCCError	SaveAPICapabilities(INVOKE_SPECIFIER *, UINT cCaps, PGCCApplicationCapability *);
	GCCError	SavePDUCapabilities(INVOKE_SPECIFIER *, PSetOfExpectedCapabilities);
	UINT		GetApplicationCapability(APP_CAP_ITEM *, PGCCApplicationCapability, LPBYTE memory);
	GCCError	ConvertInvokeSpecifierInfoToPDU(INVOKE_SPECIFIER *, PApplicationProtocolEntityList);
	GCCError	ConvertExpectedCapabilityDataToPDU(APP_CAP_ITEM *, PSetOfExpectedCapabilities);
};


/*
 *	Comments explaining the public and private class member functions
 */

/*
 *	CInvokeSpecifierListContainer (
 *					USHORT						number_of_protocol_entities,
 *					PGCCAppProtocolEntity *		app_protocol_entity_list,
 *					PGCCError					return_value);
 *
 *	Public member function of CInvokeSpecifierListContainer.
 *
 *	Function Description:
 *		This is a constructor for the CInvokeSpecifierListContainer class.
 *		This constructor is used to create an CInvokeSpecifierListContainer
 * 		object from a list of "API" application protocol entities.
 *
 *	Formal Parameters:
 *		number_of_protocol_entities		(i) The number of "APE"s in the list.
 *		app_protocol_entity_list		(i) The list of API "APE"s.
 *		return_value					(o) Error return value.
 *
 *	Return Value:
 *		GCC_NO_ERROR			- Function completed successfully.
 *		GCC_ALLOCATION_FAILURE	- A resource allocation error occurred.
 *		GCC_BAD_SESSION_KEY		- An APE contained an invalid session key.
 *		GCC_BAD_CAPABILITY_ID	- An API contained an invalid capability ID.
 *
 *  Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */


/*
 *	CInvokeSpecifierListContainer (
 *				PApplicationProtocolEntityList		app_protocol_entity_list,
 *				PGCCError							return_value);
 *
 *	Public member function of CInvokeSpecifierListContainer.
 *
 *	Function Description:
 *		This is a constructor for the CInvokeSpecifierListContainer class.
 *		This constructor is used to create an CInvokeSpecifierListContainer 
 *		object from	a "PDU" ApplicationProtocolEntityList.
 *
 *	Formal Parameters:
 *		app_protocol_entity_list		(i) The list of PDU "APE"s.
 *		return_value					(o) Error return value.
 *
 *	Return Value:
 *		GCC_NO_ERROR			- Function completed successfully.
 *		GCC_ALLOCATION_FAILURE	- A resource allocation error occurred.
 *		GCC_BAD_SESSION_KEY		- An APE contained an invalid session key.
 *		GCC_BAD_CAPABILITY_ID	- An API contained an invalid capability ID.
 *
 *  Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */


/*
 *	~CInvokeSpecifierListContainer ();
 *
 *	Public member function of CInvokeSpecifierListContainer.
 *
 *	Function Description:
 *		This is the destructor for the CInvokeSpecifierListContainer class.
 *		It is responsible for freeing any memory allocated to hold the 
 *		invoke data.
 *
 *	Formal Parameters:
 *		None.
 *
 *	Return Value:
 *		None.
 *
 *  Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */


/*
 *	UINT	LockApplicationInvokeSpecifierList ();
 *
 *	Public member function of CInvokeSpecifierListContainer.
 *
 *	Function Description:
 *		This routine is used to "lock" the "API" data for this object.  This
 *		results in the lock count for this object being incremented.  When the
 *		lock count transitions from 0 to 1, a calculation is made to determine
 *		how much memory will be needed to hold any "API" data which will
 *		be referenced by, but not held in, the list of GCCAppProtocolEntity 
 *		structures which is filled in on a call to GetApplicationInvoke-
 *		SpecifierList.  This is the	value returned by this routine in order to 
 *		allow the calling object to	allocate that amount of memory in 
 *		preparation for the call to GetApplicationInvokeSpecifierList.
 *
 *	Formal Parameters:
 *		None.
 *
 *	Return Value:
 *		The amount of memory which will be needed to hold "API" data
 *		which is a list of GCCAppProtocolEntity structures.
 *
 *  Side Effects:
 *		The internal lock count is incremented.
 *
 *	Caveats:
 *		The internal lock count is used in conjuction with an internal "free" 
 *		flag as a mechanism for ensuring that this object remains in existance 
 *		until all interested parties are through with it.  The object remains 
 *		valid (unless explicity deleted) until the lock count is zero and the 
 *		"free" flag is set through a call to FreeApplicationInvokeSpecifierList.
 *		This allows	other objects to lock this object and be sure that it 
 *		remains valid until they call UnLock which will decrement the internal 
 *		lock count.  A typical usage scenerio for this object would be:  An 
 *		CInvokeSpecifierListContainer object is constructed and then passed off
 *		to any interested parties through a function call.  On return from the 
 *		function call, the FreeApplicationInvokeSpecifierList call is made which
 *		will set the internal "free" flag.  If no other parties have locked the 
 *		object with a Lock call, then the CInvokeSpecifierListContainer object
 *		will automatically delete itself when the FreeApplicationInvoke-
 *		SpecifierList call is made.  If, however, any number of other parties 
 *		has locked the object, it will remain in existence until each of them 
 *		has unlocked the object through a call to UnLock.
 */


/*
 *	UINT	GetApplicationInvokeSpecifierList (
 *								PUShort			number_of_protocol_entities,
 *								LPSTR			memory);
 *
 *	Public member function of CInvokeSpecifierListContainer.
 *
 *	Function Description:
 *		This routine is used to retrieve the application invoke specifier list
 *		from the CInvokeSpecifierListContainer object in the "API" form of a 
 *		list of PGCCAppProtocolEntity structures.
 *
 *	Formal Parameters:
 *		number_of_protocol_entities		(o) The number of APEs in the list.
 *		memory							(o)	The memory used to hold the 
 *												APE data.
 *
 *	Return Value:
 *		The amount of memory which will be needed to hold "API" data
 *		which is a list of GCCAppProtocolEntity structures.
 *
 *  Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */


/*
 *	void	UnLockApplicationInvokeSpecifierList ();
 *
 *	Public member function of CInvokeSpecifierListContainer.
 *
 *	Function Description:
 *		This routine is used to "unlock" the "API" data for this object.  This
 *		results in the lock count for this object being decremented.  When the
 *		lock count transitions from 1 to 0, a check is made to determine 
 *		whether the object has been freed through a call to 
 *		FreeApplicationInvokeSpecifierList.  If so, the object will 
 *		automatically delete itself.
 *
 *	Formal Parameters:
 *		None.
 *
 *	Return Value:
 *		None.
 *
 *  Side Effects:
 *		The internal lock count is decremented.
 *
 *	Caveats:
 *		None.
 */


/*
 *	GCCError	GetApplicationInvokeSpecifierListPDU (
 *					PApplicationProtocolEntityList	*  protocol_entity_list);
 *
 *	Public member function of CInvokeSpecifierListContainer.
 *
 *	Function Description:
 *		This routine is used to retrieve the object key data from the
 *		CInvokeSpecifierListContainer object in the "PDU" form of a list of
 *		PApplicationProtocolEntityList structures.
 *
 *	Formal Parameters:
 *		protocol_entity_list		(o)	The list of structures to fill in.
 *
 *	Return Value:
 *		GCC_NO_ERROR				-	No error.
 *		GCC_ALLOCATION_FAILURE		- 	A resource allocation error occurred.
 *
 *  Side Effects:
 *		The first time this routine is called, data is allocated internally to
 *		hold the PDU form.
 *
 *	Caveats:
 *		None.
 */


/*
 *	void	FreeApplicationInvokeSpecifierListPDU ();
 *
 *	Public member function of CInvokeSpecifierListContainer.
 *
 *	Function Description:
 *		This routine is used to "free" the "PDU" data allocated for this object
 *		which is held internally.
 *
 *	Formal Parameters:
 *		None.
 *
 *	Return Value:
 *		None.
 *
 *  Side Effects:
 *		The internal flag is set to indicate that the PDU form of data no
 *		longer is valid for this object.
 *
 *	Caveats:
 *		None.
 */
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\remdsk\rds\t120\h\mcattprt.h ===
/*	MCATTPRT.h
 *
 *	Copyright (c) 1993-1995 by DataBeam Corporation, Lexington, KY
 *
 *	Abstract:
 *		This is the interface file for the TCP Transport. If an application
 *		is making calls directly to the Transport DLL, this file MUST be
 *		included.  All transports have the same interface.  This makes
 *		programming to the Transports simpler for the user.
 *
 *		This file contains all of the prototypes and defintions needed to use
 *		any of the Transport DLLs.
 *
 *		Transports have 2 modes of operation, either in-band call control or
 *		out-of-band call control.  With in-band call control, the Transport DLL
 *		makes the physical connection when the TConnectRequest() call is made
 *		from MCS.  It also breaks the physical connection when MCS makes a
 *		TDisconnectRequest() call.  This basic mode of operation works well but
 *		we have added the out-of-band call control mode for 2 reasons:
 *
 *			1.  Allow the user to make multiple MCS connections without
 *				breaking the physical connection.  This is needed if the
 *				application is using the GCC Query commands.
 *
 *			2.  Allow the user to use any type of calling mechanism (i.e. TAPI,
 *				TSAPI,...) that they want.
 *		
 *	Caveats:
 *		None.
 *
 *	Author:
 *		James W. Lawwill
 *
 */
#ifndef	_MCATTPRT_
#define	_MCATTPRT_

#include "databeam.h"

/*
 *	These are valid return codes from the Transport DLL.
 *	
 *	TRANSPORT_NO_ERROR
 *		The function executed properly, without error.  This does not mean
 *		that the function is complete.  Some functions are non-blocking
 *		(they don't occur immediately), therefore they could still fail.
 *		A good example of this is the TConnectRequest() function in the
 *		TCP transport.  It takes a few seconds to call the remote site and
 *		establish a link.  If the connection fails or succeeds, a callback
 *		will be sent back to the user to give them the status.
 *	TRANSPORT_INITIALIZATION_FAILED
 *		The TInitialize() function failed.  This can occur for a number of
 *		reasons.
 *	TRANSPORT_NOT_INITIALIZED
 *		The user is attempting to use a function even though the TInitialize()
 *		function failed.
 *	TRANSPORT_NO_SUCH_CONNECTION
 *		The user is attempting a function call with an illegal
 *		TransportConnection handle.
 *	TRANSPORT_WRITE_QUEUE_FULL
 *		The TDataRequest() function failed because its write queue is full
 *	TRANSPORT_READ_QUEUE_FULL
 *		This return value is returned from the TRANSPORT_DATA_INDICATION
 *		callback.  It occurs when the user application can not handle the
 *		data packet because it does not currently have room for it.  This
 *		is a flow control mechanism between the user application and the
 *		Transport DLL.
 *	TRANSPORT_CONNECT_REQUEST_FAILED
 *		The TConnectRequest() function failed because the modem was not
 *		in the proper mode.  As we initialize a modem, it is not possible
 *		to dial out it.  Try the TConnectRequest() later.
 *	TRANSPORT_CONNECT_RESPONSE_FAILED
 *		The TConnectResponse() function failed.  Evidently, the function was
 *		called at the wrong time.
 *	TRANSPORT_NO_CONNECTION_AVAILABLE
 *		The TConnectRequest() function failed because all available modems
 *		are currently in use.
 *	TRANSPORT_NOT_READY_TO_TRANSMIT
 *		The TDataRequest() function failed because it is not ready to send
 *		data.  If you attempt this function before you receive a
 *		TRANSPORT_CONNECT_INDICATION callback, you will receive this value
 *	TRANSPORT_ILLEGAL_COMMAND
 *		TResetDevice() or TProcessCommand() failed because the command submitted
 *		to the function was invalid.
 *	TRANSPORT_CONFIGURATION_ERROR
 *		Return value from TProcessCommand() if the user is enabling a device
 *		that has an illegal configuration setup in the .ini file
 *	TRANSPORT_MEMORY_FAILURE
 *		The function failed because the Transport Stack was not able to allocate
 *		the memory necessary to perform the function.
 */
typedef	unsigned long						TransportError;
typedef	TransportError *					PTransportError;

#define	TRANSPORT_NO_ERROR					0
#define	TRANSPORT_INITIALIZATION_FAILED		1
#define	TRANSPORT_NOT_INITIALIZED			2
#define	TRANSPORT_NO_SUCH_CONNECTION		3
#define	TRANSPORT_WRITE_QUEUE_FULL			4
#define	TRANSPORT_READ_QUEUE_FULL			5
#define	TRANSPORT_CONNECT_REQUEST_FAILED	6
#define TRANSPORT_MEMORY_FAILURE			7
#define	TRANSPORT_NOT_READY_TO_TRANSMIT		8
#define TRANSPORT_CANT_SEND_NOW				9
#define	TRANSPORT_ILLEGAL_COMMAND			10
#define	TRANSPORT_CONFIGURATION_ERROR		12
#define TRANSPORT_CONNECT_RESPONSE_FAILED	13

#define TRANSPORT_SECURITY_FAILED			14

#define TRANSPORT_BUFFER_TOO_SMALL          15
#define TRANSPORT_NO_PLUGGABLE_CONNECTION   16
#define TRANSPORT_WRITE_FILE_FAILED         17
#define TRANSPORT_ALREADY_INITIALIZED       18
#define TRANSPORT_INVALID_PARAMETER         19
#define TRANSPORT_PHYSICAL_LAYER_NOT_FOUND  20
#define TRANSPORT_NO_T123_STACK             21

/*
 *	TransportConnection is the handle used by the Transport DLL
 *	to distinguish one logical connection from another.  The DLL assigns
 *	the transport connection in a TConnectRequest() call or as a
 *	result of a TRANSPORT_CONNECT_INDICATION callback
 */
typedef enum tagTransportType
{
    TRANSPORT_TYPE_WINSOCK          = 0,
    TRANSPORT_TYPE_PLUGGABLE_X224   = 1,
    TRANSPORT_TYPE_PLUGGABLE_PSTN   = 2,
}
    TransportType;

typedef struct tagTransportConnection
{
    TransportType   eType;
    UINT_PTR        nLogicalHandle;
}
    TransportConnection, *PTransportConnection;

#define PACK_XPRTCONN(x)            (MAKELONG((x).nLogicalHandle, (x).eType))
#define UNPACK_XPRTCONN(x,n)        { (x).nLogicalHandle = LOWORD((n)); (x).eType = (TransportType) HIWORD((n)); }

#define IS_SAME_TRANSPORT_CONNECTION(x1,x2) (((x1).eType == (x2).eType) && ((x1).nLogicalHandle == (x2).nLogicalHandle))
#define IS_SOCKET(x)                        (TRANSPORT_TYPE_WINSOCK == (x).eType)
#define IS_PLUGGABLE(x)                     (TRANSPORT_TYPE_WINSOCK != (x).eType)
#define IS_PLUGGABLE_X224(x)                (TRANSPORT_TYPE_PLUGGABLE_X224 == (x).eType)
#define IS_PLUGGABLE_PSTN(x)                (TRANSPORT_TYPE_PLUGGABLE_PSTN == (x).eType)
#define IS_VALID_TRANSPORT_CONNECTION_TYPE(x) (IS_SOCKET(x) || IS_PLUGGABLE_X224(x) || IS_PLUGGABLE_PSTN(x))

#define SET_SOCKET_CONNECTION(x,s)          { (x).eType = TRANSPORT_TYPE_WINSOCK; (x).nLogicalHandle = (s); }


/*
 *	This structure is passed back with the TRANSPORT_DATA_INDICATION message.
 *
 *	Since there is only one callback address passed into the Transport DLL and
 *	there can be many transport connections maintained by this DLL, the
 *	transport_connection number is included in the structure.  This number
 *	tells the user application which connection the data is associated with.
 *
 *	The other two parameters are the data address and data length
 */
typedef	struct
{
	TransportConnection		transport_connection;
	unsigned char *			user_data;
	unsigned long			user_data_length;
	PMemory					memory;
} TransportData;
typedef	TransportData *		PTransportData;


/*
 *	The following section defines the callbacks that can be issued to the
 *	user.
 *
 *	The callback contains three parameters:
 *		The first is the callback message.
 *		The second is specific to the callback message.
 *		The third is the user defined value that is passed in
 *			during TInitialize().
 */

/*
 *	Message:	TRANSPORT_CONNECT_INDICATION
 *	Parameter:	
 *		TransportConnection		transport_connection
 *
 *	Functional Description:
 *		The user receives this message when an incoming call has been
 *		received.  The user can issue a TConnectResponse() to accept the
 *		call or a TDisconnectRequest() to terminate the connection.
 *
 *		The user will never receive this callback message if he originates
 *		the connection.  In that case the user will receive a
 *		TRANSPORT_CONNECT_CONFIRM.
 */

/*
 *	Message:	TRANSPORT_DATA_INDICATION
 *	Parameter:	
 *		PTransportData
 *			This is the address of the transport data structure
 *
 *	Functional Description:
 *		The callback returns this message when it has data for the user.
 *		The message is sent with the address of a TransportData structure,
 *		which contains the transport_connection, the data address, and the
 *		data length.
 */

/*
 *	Message:	TRANSPORT_EXPEDITED_DATA_INDICATION
 *	Parameter:	
 *		PTransportData
 *			This is the address of the transport data structure
 *
 *	Functional Description:
 *		This callback is currently unsupported.
 */

/*
 *	Message:	TRANSPORT_DISCONNECT_INDICATION
 *	Parameter:	
 *		TransportConnection
 *
 *	Functional Description:
 *		The callback returns this message when the transport connection
 *		is broken.  It can result from a TDisconnectRequest() call by the
 *		user, or from an unstable physical connection.
 */

/*
 *	Message:	TRANSPORT_CONNECT_CONFIRM
 *	Parameter:	
 *		TransportConnection
 *
 *	Functional Description:
 *		The callback returns this message when a new transport connection
 *		has been established.
 *
 *		This message is issued in response to the user issuing a
 *		TConnectRequest().  When the Transport Connection is up and
 *		operational, the user will receive this callback message.
 *
 *		If you are called by another user, you will receive a
 *		TRANSPORT_CONNECT_INDICATION.
 */

/*
 *  Message:    TRANSPORT_STATUS_INDICATION
 *  Parameter:
 *      PTransportStatus
 *          Address of the TransportStatus structure
 *
 *  Functional Description:
 *      This callback is sent from a Transport Layer to notify the user of a
 *      change in a physical device.  For example, in the case of the PSTN
 *      Transport Stack, this message will be sent up when the modem detects an
 *      incoming RING or when a connection is established.  Any time the state
 *      of the modem changes, a message will be sent up.  Messages will also be
 *      sent up when an error occurs
 */

#define TRANSPORT_CONNECT_INDICATION            0
#define TRANSPORT_CONNECT_CONFIRM               1
#define TRANSPORT_DATA_INDICATION               2
// #define TRANSPORT_EXPEDITED_DATA_INDICATION     3
#define TRANSPORT_DISCONNECT_INDICATION         4
// #define TRANSPORT_STATUS_INDICATION             5
#define TRANSPORT_BUFFER_EMPTY_INDICATION       6



#ifdef TSTATUS_INDICATION
/*
 *	Physical Device states
 */
typedef enum
{
	TSTATE_NOT_READY,
	TSTATE_NOT_CONNECTED,
	TSTATE_CONNECT_PENDING,
	TSTATE_CONNECTED,
	TSTATE_REMOVED
}  TransportState;

/*
 *	The following structure is passed to ths user via the
 *	TRANSPORT_STATUS_INDICATION callback.
 *
 *
 *		device_identifier 	 -	The device_identifier is only set if a specific
 *								device is referenced (i.e. "COM1").
 *
 *		remote_address 		 -	String specifying the address of the person we
 *								are linked to.
 *
 *		message				 -	This string is filled in to give the user some
 *								type of feedback.  A message may reflect an
 *								error in the configuration file, an incoming
 *								RING from the modem, or a BUSY signal on the
 *								telephone line.
 *
 *		state				 -	Current state of the device.  This is one of
 *								the TransportState enumerations.
 */
typedef struct
{
	char *			device_identifier;
	char *			remote_address;
	char *			message;
	TransportState	state;
}  TransportStatus;
typedef TransportStatus *	PTransportStatus;

#endif // TSTATUS_INDICATION

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\remdsk\rds\t120\h\mportmsg.h ===
/*
 *	mportmsg.h
 *
 *	Copyright (c) 1993 - 1995 by DataBeam Corporation, Lexington, KY
 *
 *	Abstract:
 *
 *	Portable:
 *
 *	Author:
 *		James P. Galvin, Jr.
 */
#ifndef	_LISTEN_MCS_PORTAL_MESSAGE_
#define	_LISTEN_MCS_PORTAL_MESSAGE_

#define	LISTEN_PORTAL_NAME				"MCS Listen Portal"
#define	USER_PORTAL_NAME				"MCS User Portal"

#define	LISTEN_CREATE_PORTAL_REQUEST	0
#define	LISTEN_CREATE_PORTAL_CONFIRM	1

#define	LISTEN_NO_ERROR					0
#define	LISTEN_CREATE_FAILED			1

#define	USER_PORTAL_NAME_LENGTH			32

/*
 *	The following type defines a container that is used to map domain selectors to
 *	portal memory addresses.  This is necessary to find the right in-process
 *	MCS portal for each domain.
 */
typedef struct
{
} LPCreatePortalRequest;

typedef struct
{
	ULong			return_value;
	unsigned int	portal_id;
} LPCreatePortalConfirm;

typedef struct
{
} LPClosePortalRequest;

typedef	struct
{
	unsigned int			message_type;
	union
	{
		LPCreatePortalRequest		create_portal_request;
		LPCreatePortalConfirm		create_portal_confirm;
	} u;
} ListenPortalMessage;
typedef	ListenPortalMessage *		PListenPortalMessage;

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\remdsk\rds\t120\h\mcsdllif.h ===
/*
 *	mcsdllif.h
 *
 *	Copyright (c) 1993 by DataBeam Corporation, Lexington, KY
 *
 *	Abstract:
 *		This is the interface file for the MCAT MCS DLL Interface class.
 *
 *		When this class is first instantiated, it initializes MCS.  After
 *		that, the application using this object requests MCS services through
 *		this object. This object is also responsible for receiving and
 *		forwarding cllback messages.  When this object is deleted it calls
 *		MCSCleanupAPI to shut down the MCATMCS DLL.
 *
 *		MCS interface objects represent the Service Access Point (SAP)
 *		between GCC and MCS.  Exactly how the interface works is an
 *		implementation matter for those classes that inherit from this one.
 *		This class defines the public member functions that GCC expects to be
 *		able to call upon to utilize MCS.
 *
 *		The public member functions defined here can be broken into two
 *		categories: those that are part of T.122; and those that are not.
 *		The T.122 functions include connect provider request, connect
 *		provider response, disconnect provider request, create domain, delete
 *		domain, send data request, etc.  All other member functions are
 *		considered a local matter from a standards point-of-view.  These
 *		functions include support for initialization and setup, as well as
 *		functions allowing GCC to poll MCS for activity.
 *
 *		Note that this class also handles the connect provider confirms by
 *		keeping a list of all the objects with outstanding connect provider
 *		request.  These are held in the ConfirmObjectList.
 *
 *	Caveats:
 *		None.
 *
 *	Author:
 *		Christos Tsollis
 *
 */
#ifndef	_MCS_DLL_INTERFACE_
#define	_MCS_DLL_INTERFACE_

#include "mcsuser.h"

/*
**	This dictionary keeps up with all the outstanding connect provider
**	request.  When a response is received, this interface class will obtain
**	a pointer to the correct object from this list and will then pass on the
**	response.
*/
class CConnHdlConfList2 : public CList2
{
    DEFINE_CLIST2_(CConnHdlConfList2, CConf*, ConnectionHandle)
};

extern  PController					g_pMCSController;

/*
 *	CONNECT_PROVIDER_INDICATION
 *
 *	Parameter1:
 *		PConnectProviderIndication
 *			This is a pointer to a structure that contains all necessary
 *			information about an incoming connection.
 *	Parameter2: Unused
 *
 *	Functional Description:
 *		This indication is sent to the owner object when an incoming
 *		connection is detected.  The owner object should respond by calling
 *		MCSConnectProviderResponse indicating whether or not the connection
 *		is to be accepted.
 */

/*
 *	CONNECT_PROVIDER_CONFIRM
 *
 *	Parameter1:
 *		PConnectProviderConfirm
 *			This is a pointer to a structure that contains all necessary
 *			information about an outgoing connection.
 *	Parameter2: Unused
 *
 *	Functional Description:
 *		This confirm is sent to the object that made the original connect
 *		provider request.  It informs the requesting object of when the new
 *		connection is available for use, or that the connection could not be
 *		established (or that it was rejected by the	remote site).
 */

/*
 *	DISCONNECT_PROVIDER_INDICATION
 *
 *	Parameter1: Unused
 *	Parameter2:
 *		(LOWUSHORT) ConnectionHandle
 *			This is the handle for the connection that was lost.
 *		(HIGHUSHORT) Reason
 *			This is the reason for the disconnect.
 *
 *	Functional Description:
 *		This indication is sent to the owner object whenever a connection
 *		is lost.  This essentially tells the owner object that the contained
 *		connection handle is no longer valid.
 */

/*
 *	GCC_ATTACH_USER_CONFIRM
 *
 *	Parameter1: Unused
 *	Parameter2:
 *		(LOWUSHORT) UserID
 *			If the result is success, then this is the newly assigned user ID.
 *			If the result is failure, then this field is undefined.
 *		(HIGHUSHORT) Result
 *			This is the result of the attach user request.
 *
 *	Functional Description:
 *		This confirm is sent to the user object in response to a previous
 *		call to MCS_AttachRequest.  It contains the result of that service
 *		request.  If successful, it also contains the user ID that has been
 *		assigned to that attachment.
 */

/*
 *	GCC_DETACH_USER_INDICATION
 *
 *	Parameter1: Unused
 *	Parameter2:
 *		(LOWUSHORT) UserID
 *			This is the user ID of the user that is detaching.
 *		(HIGHUSHORT) Reason
 *			This is the reason for the detachment.
 *
 *	Functional Description:
 *		This indication is sent to the user object whenever a user detaches
 *		from the domain.  This is sent to ALL remaining user objects in the
 *		domain automatically.  Note that if the user ID contained in this
 *		indication is the same as that of the user object receiving it, the
 *		user is	essentially being told that it has been kicked out of the
 *		conference.  The user handle and user ID are no longer valid in this
 *		case.  It is the responsibility of the user object to recognize when
 *		this occurs.
 */

/*
 *	GCC_CHANNEL_JOIN_CONFIRM
 *
 *	Parameter1: Unused
 *	Parameter2:
 *		(LOWUSHORT) ChannelID
 *			This is the channel that has been joined.
 *		(HIGHUSHORT) Result
 *			This is the result of the join request.
 *
 *	Functional Description:
 *		This confirm is sent to a user object in response to a previous
 *		call to ChannelJoinRequest.  It lets the user object know if the
 *		join was successful for a particular channel.  Furthermore, if the
 *		join request was for channel 0 (zero), then the ID of the assigned
 *		channel is contained in this confirm.
 */

/*
 *	CHANNEL_LEAVE_INDICATION
 *
 *	Parameter1: Unused
 *	Parameter2:
 *		(LOWUSHORT) ChannelID
 *			This is the channel that has been left or is being told to leave.
 *		(HIGHUSHORT) Reason
 *			This is the reason for the leave.
 *
 *	Functional Description:
 *		This indication is sent to a user object when a domain merger has
 *		caused a channel to be purged from the lower domain.  This informs the
 *		the user that it is no longer joined to the channel.
 */

/*
 *	GCC_SEND_DATA_INDICATION
 *
 *	Parameter1:
 *		PSendData
 *			This is a pointer to a SendData structure that contains all
 *			information about the data received.
 *	Parameter2: Unused
 *
 *	Functional Description:
 *		This indication is sent to a user object when data is received
 *		by the local MCS provider on a channel to which the user is joined.
 */

/*
 *	GCC_UNIFORM_SEND_DATA_INDICATION
 *
 *	Parameter1:
 *		PSendData
 *			This is a pointer to a SendData structure that contains all
 *			information about the data received.
 *	Parameter2: Unused
 *
 *	Functional Description:
 *		This indication is sent to a user object when data is received
 *		by the local MCS provider on a channel to which the user is joined.
 */
/*
 *	TRANSPORT_STATUS_INDICATION
 *
 *	Parameter1:
 *		PTransportStatus
 *			This is a pointer to a TransportStatus structure that contains
 *			information about this indication.  This structure is defined in
 *			"transprt.h".
 *
 *	Functional Description:
 *		A transport stack will issue this indication when it detects a status
 *		change of some sort.  It fills in the TransportStatus structure to
 *		describe the state change and the sends it to MCS.  MCS fills in the
 *		field containing the name of the stack (using the transport identifier),
 *		and forwards it to GCC.
 */

class CConf;
class MCSUser;

class CMCSUserList : public CList
{
    DEFINE_CLIST(CMCSUserList, MCSUser*)
};

class MCSDLLInterface
{
public:

    MCSDLLInterface(PMCSError);
    ~MCSDLLInterface ();

	MCSError 	CreateDomain(GCCConfID *domain_selector)
	{
		ASSERT (g_pMCSController != NULL);
		return g_pMCSController->HandleAppletCreateDomain(domain_selector);
	};

	MCSError 	DeleteDomain(GCCConfID *domain_selector)
	{
		ASSERT (g_pMCSController != NULL);
		return g_pMCSController->HandleAppletDeleteDomain(domain_selector);
	}


	MCSError	ConnectProviderRequest (
							GCCConfID          *calling_domain,
							GCCConfID          *called_domain,
							TransportAddress	calling_address,
							TransportAddress	called_address,
							BOOL				fSecure,
							DBBoolean			upward_connection,
							PUChar				user_data,
							ULong				user_data_length,
							PConnectionHandle	connection_handle,
							PDomainParameters	domain_parameters,
							CConf		        *confirm_object);


	MCSError	ConnectProviderResponse (
							ConnectionHandle	connection_handle,
							GCCConfID          *domain_selector,
							PDomainParameters	domain_parameters,
							Result				result,
							PUChar				user_data,
							ULong				user_data_length);

	MCSError	DisconnectProviderRequest (
							ConnectionHandle	connection_handle);

	MCSError	AttachUserRequest (
							GCCConfID           *domain_selector,
							PIMCSSap 			*ppMCSSap,
							MCSUser		        *user_object);

	MCSError	DetachUserRequest (
							PIMCSSap 			pMCSSap,
							MCSUser 			*pMCSUser);

	MCSError	ChannelJoinRequest (
							ChannelID			channel_id,
							PIMCSSap 			pMCSSap)
				{
					return pMCSSap->ChannelJoin (channel_id);
				};

	MCSError	ChannelLeaveRequest (
							ChannelID			channel_id,
							PIMCSSap 			pMCSSap)
				{
					return pMCSSap->ChannelLeave (channel_id);
				};

	MCSError	SendDataRequest (
							ChannelID			channel_id,
							PIMCSSap 			pMCSSap,
							Priority			priority,
							PUChar				user_data,
							ULong				user_data_length)
				{
					return pMCSSap->SendData (NORMAL_SEND_DATA,
									channel_id,
									priority,
									user_data,
									user_data_length,
									APP_ALLOCATION);
				};

	MCSError	UniformSendDataRequest (	
							ChannelID			channel_id,
							PIMCSSap 			pMCSSap,
							Priority			priority,
							PUChar				user_data,
							ULong				user_data_length)
				{
					return pMCSSap->SendData (UNIFORM_SEND_DATA,
									channel_id,
									priority,
									user_data,
									user_data_length,
									APP_ALLOCATION);
				};

	MCSError	TokenGrabRequest (
							PIMCSSap 			pMCSSap,
							TokenID				token_id)
				{
					return pMCSSap->TokenGrab (token_id);
				};
							
	MCSError	TokenGiveRequest (
							PIMCSSap 			pMCSSap,
							TokenID				token_id,
							UserID				receiver_id)
				{
					return pMCSSap->TokenGive (token_id,
									receiver_id);
				};
							
	MCSError	TokenGiveResponse (
							PIMCSSap 			pMCSSap,
							TokenID				token_id,
							Result				result)
				{
					return pMCSSap->TokenGiveResponse (token_id,
									result);
				};

	MCSError	TokenPleaseRequest (
							PIMCSSap 			pMCSSap,
							TokenID				token_id)
				{
					return pMCSSap->TokenPlease (token_id);
				};
							
	MCSError	TokenReleaseRequest (
							PIMCSSap 			pMCSSap,
							TokenID				token_id)
				{
					return pMCSSap->TokenRelease (token_id);
				};

	MCSError	TokenTestRequest (
							PIMCSSap 			pMCSSap,
							TokenID				token_id)
				{
					return pMCSSap->TokenTest (token_id);
				};

#ifdef NM_RESET_DEVICE
	MCSError	ResetDevice (
							PChar				device_identifier)
				{
					return MCSResetDevice (device_identifier);
				};
#endif // NM_RESET_DEVICE

	GCCError	TranslateMCSIFErrorToGCCError (MCSError	mcs_error)
				{
					return ((mcs_error <= MCS_SECURITY_FAILED) ?
							(GCCError) mcs_error : GCC_UNSUPPORTED_ERROR);
				};

	void			ProcessCallback (
							unsigned int		message,
							LPARAM				parameter,
							PVoid				object_ptr);
private:
	MCSError	AddObjectToConfirmList (
								CConf		        *confirm_object,
								ConnectionHandle	connection_handle);

	DBBoolean			IsUserAttachmentVaid (
								MCSUser				*user_object)
						{
							return (m_MCSUserList.Find(user_object));
						};
	CConnHdlConfList2   m_ConfirmConnHdlConfList2;
	CMCSUserList        m_MCSUserList;
};
typedef	MCSDLLInterface *			PMCSDLLInterface;


GCCResult TranslateMCSResultToGCCResult ( Result mcs_result );

/*
 *	MCSDLLInterface (	HANDLE				instance_handle,
 *						PMCSError			error_value)
 *
 *	Functional Description:
 *		This is the constructor for the MCS Interface class. It is responsible
 *		for initializing the MCAT MCS DLL.  Any errors that occur during
 *		initialization are returned in the error_value provided.
 *
 *	Formal Parameters:
 *		instance_handle (i)
 *			The windows instance handle is used when creating MCS diagnostics.
 *		error_value (i)
 *			This pointer is used to pass back any errors that may have occured
 *			while initializing the class.  This includes any problems with
 *			initializing the MCAT MCS DLL.
 *
 *	Return Value:
 *		None.
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

/*
 *	~MCSDLLInterface ()
 *
 *	Functional Description:
 *		This is the destructor for the MCS Interface class. It is responsible
 *		for cleaning up both itself and the MCAT MCS DLL.
 *
 *	Formal Parameters:
 *		None.
 *
 *	Return Value:
 *		None.
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

/*
 *	MCSError	CreateDomain (
 *							DomainSelector		domain_selector_string,
 *							UINT				domain_selector_length)
 *
 *	Functional Description:
 *		This function is used to create an MCS domain.
 *
 *	Formal Parameters:
 *		domain_selector_string (i)
 *			This is the name of the domain to be created.
 *		domain_selector_length (i)
 *			This is the length of the domain name in characters.
 *
 *	Return Value:
 *		MCS_NO_ERROR
 *			On success
 *		MCS_NOT_INITIALIZED
 *			The mcs interface did not initialize properly
 *		MCS_DOMAIN_ALREADY_EXISTS
 *			A domain by this name alread exist
 *		MCS_ALLOCATION_FAILURE
 *			A memory failure occured
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

/*
 *	MCSError	DeleteDomain (
 *							DomainSelector		domain_selector_string,
 *							UINT				domain_selector_length)
 *
 *	Functional Description:
 *		This function an MCS domain which was created using the CreateDomain
 *		call.
 *
 *	Formal Parameters:
 *		domain_selector_string (i)
 *			This is the name of the domain to be deleted.
 *		domain_selector_length (i)
 *			This is the length of the domain name in characters.
 *
 *	Return Value:
 *		MCS_NO_ERROR
 *			On success
 *		MCS_NOT_INITIALIZED
 *			The mcs interface did not initialize properly
 *		MCS_NO_SUCH_DOMAIN
 *			The domain to be deleted does not exist
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

/*
 *	MCSError	ConnectProviderRequest (
 *							DomainSelector		calling_domain,
 *							UINT				calling_domain_length,
 *							DomainSelector		called_domain,
 *							UINT				called_domain_length,
 *							TransportAddress	calling_address,
 *							TransportAddress	called_address,
 *							DBBoolean				upward_connection,
 *							PUChar				user_data,
 *							ULong				user_data_length,
 *							PConnectionHandle	connection_handle,
 *							PDomainParameters	domain_parameters,
 *							CConf		        *confirm_object)
 *
 *	Functional Description:
 *		This T.122 primitive is used to connect two domains. This request
 *		should always be followed by a connect provider confirm.  The
 *		confirm will be sent to be object specified by the confirm object
 *		the is passed into this routine.
 *
 *	Formal Parameters:
 *		calling_domain (i)
 *			This is a pointer to the calling domain selector string.
 *		calling_domain_length (i)
 *			This is the length of the calling domain selector string.
 *		called_domain (i)
 *			This is a pointer to the called domain selector string.
 *		called_domain_length (i)
 *			This is the length of the called domain selector length.
 *		calling_address (i)
 *			This is a pointer to the calling addres (an ASCII string).
 *		called_address (i)
 *			This is a pointer to the address being called (an ASCII string).
 *		upward_connection (i)
 *			This boolean flag denotes the hierarchical direction of the
 *			connection to be created (TRUE means upward, FALSE means downward).
 *		user_data (i)
 *			This is a pointer to the user data to be transmitted during the
 *			creation of this new connection.
 *		user_data_length (i)
 *			This is the length of the user data field mentioned above.
 *		connection_handle (o)
 *			This is set by MCS to a unique handle that can be used to access
 *			this connection on subsequent calls.
 *		domain_parameters (i)
 *			This is a pointer to a structure containing the domain parameters
 *			that the node controller wishes to use for this new connection.
 *		confirm_object (i)
 *			This is a pointer to the object that the connect provider response
 *			is sent to.
 *		object_message_base (i)
 *			This message base is added to the connect provider response
 *			message.
 *
 *	Return Value:
 *		MCS_NO_ERROR
 *			On success
 *		MCS_NOT_INITIALIZED
 *			The mcs interface did not initialize properly
 *		MCS_NO_SUCH_DOMAIN
 *			The domain to connect does not exist
 *		MCS_DOMAIN_NOT_HIERARCHICAL
 *			An upward connection from this domain already exist
 *		MCS_NVALID_ADDRESS_PREFIX
 *			The transport prefix is not recognized
 *		MCS_ALLOCATION_FAILURE
 *			A memory failure occured
 *		MCS_INVALID_PARAMETER
 *			One of the parameters to the request is invalid
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

/*
 *	MCSError	ConnectProviderResponse (
 *							ConnectionHandle	connection_handle,
 *							DomainSelector		domain_selector,
 *							UINT				domain_selector_length,
 *							PDomainParameters	domain_parameters,
 *							Result				result,
 *							PUChar				user_data,
 *							ULong				user_data_length)
 *
 *	Functional Description:
 *		This function is used to respond to a connect provider indication.
 *		This call will result in a connect provider confirm at the remote
 *		node.
 *
 *	Formal Parameters:
 *		connection_handle (i)
 *			This is the handle of the connection that the response is for.
 *		domain_selector (i)
 *			This is a pointer to the domain selector identifying which domain
 *			the inbound connection is to be bound to.
 *		domain_selector_length (i)
 *			This is the length of the above domain selector.
 *		domain_parameters (i)
 *			This is a pointer to a structure containing the domain parameters
 *			that the node controller has agreed to use for the connection
 *			being created.
 *		result (i)
 *			This is the result.  This determines whether an inbound connection
 *			is accepted or rejected.  Anything but RESULT_SUCCESSFUL rejects
 *			the connection.
 *		user_data (i)
 *			This is the address of user data to be sent in the connect response
 *			PDU.
 *		user_data_length (i)
 *			This is the length of the user data mentioned above.
 *
 *	Return Value:
 *		MCS_NO_ERROR
 *			On success
 *		MCS_NOT_INITIALIZED
 *			The mcs interface did not initialize properly
 *		MCS_NO_SUCH_CONNECTION
 *			The connection specified is invalid
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

/*
 *	MCSError	DisconnectProviderRequest (
 *							ConnectionHandle	connection_handle)
 *
 *	Functional Description:
 *		This function is used to disconnect a node from a particular connection.
 *		This can be either an upward or downward connection
 *
 *	Formal Parameters:
 *		connection_handle (i)
 *			This is the handle of the connection which the node controller wants
 *			to disconnect.
 *
 *	Return Value:
 *		MCS_NO_ERROR
 *			On success
 *		MCS_NOT_INITIALIZED
 *			The mcs interface did not initialize properly
 *		MCS_NO_SUCH_CONNECTION
 *			The connection specified is invalid
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

/*
 *	MCSError	AttachUserRequest (
 *							DomainSelector		domain_selector,
 *							UINT				domain_selector_length,
 *							PIMCSSap 			*ppMCSSap,
 *							PMCSUser			user_object)
 *
 *	Functional Description:
 *		This function is used to create a user attachment to MCS. It will result
 *		in an attach user confirm.
 *
 *	Formal Parameters:
 *		domain_selector (i)
 *			This is the name of the domain to which the user wishes to attach.
 *		domain_selector_length (i)
 *			This is the length of the above domain selector.
 *		ppMCSSap (o)
 *			This is a pointer to a variable where the new user handle will be
 *			stored upon successful completion of this call.
 *		user_object (i)
 *			This is a pointer to the MCSUser object which should receive the callbacks
 *			for this user attachment.
 *
 *	Return Value:
 *		MCS_NO_ERROR
 *			On success
 *		MCS_NO_SUCH_DOMAIN
 *			The domain to be attached to does not exist
 *		MCS_ALLOCATION_FAILURE
 *			A memory failure occured
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

/*
 *	void	ProcessCallback (	UINT				message,
 *								ULong				parameter,
 *								PVoid				object_ptr)
 *
 *	Functional Description:
 *		This routine is called whenever a callback message is received by
 *		the "C" callback routine. It is responsible for both processing
 *		callback messages and forwarding callback messages on to the
 *		appropriate object.
 *
 *	Formal Parameters:
 *		message	(i)
 *			This is the mcs message to be processed
 *		parameter (i)
 *			Varies according to the message. See the MCAT programmers manual
 *		object_ptr (i)
 *			This is the user defined field that was passed to MCS on
 *			initialization.
 *
 *	Return Value:
 *		MCS_NO_ERROR
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */
/*
 *	MCSDLLInterface::TranslateMCSIFErrorToGCCError ()
 *								MCSError			mcs_error)
 *
 *	Public
 *
 *	Function Description
 *		This routine translate an MCS Interface error into a GCC Error.
 *
 *	Formal Parameters:
 *		mcs_error (i)
 *			This is the error to be translated.
 *
 *	Return Value:
 *		This is the translated GCC error.
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */
#endif

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\remdsk\rds\t120\h\memmgr.h ===
/*
 *	memmgr.h
 *
 *	Copyright (c) 1998 by Microsoft Corporation, Redmond, WA
 *
 *	Abstract:
 *		This is the header file for the T.120 memory allocation mechanism.  This
 *		file contains the declarations necessary to allocate and distribute memory
 *		in the form of Memory objects within T.120.
 *
 *	This implementation defines priorities of memory allocations.  A lower
 *	priority number implies higher priority.  Priority-0 allocations will be
 *	satisfied, unless the system is out of memory.  Priorities 1 and 2
 *	limit the amount of total memory that can be allocated, but priority 1 (recv priority)
 *	has higher water mark limits than priority 2 (send priority).
 *
 *	Protected Member Functions:
 *		None.
 *
 *	Caveats:
 *		None.
 *
 *	Author:
 *		Christos Tsollis
 */

/*
 *	We define the following 3 memory priorities:
 *		TOP_PRIORITY  (0): 	The allocation will succeed unless the system is out of memory
 *		RECV_PRIORITY (1):	Allocation will succeed only if less than 1 MB has been allocated
 *		SEND_PRIORITY (2):	Allocation will succeed only if less than 0xE0000 bytes have been allocated so far.
 */
#ifndef _T120_MEMORY_MANAGER
#define _T120_MEMORY_MANAGER

#include "memory.h"

// This is the main T.120 allocation routine
PMemory	AllocateMemory (
				PUChar				reference_ptr,
				UINT				length,
				MemoryPriority		priority = HIGHEST_PRIORITY);
// Routine to ReAlloc memory allocated by AllocateMemory().
BOOL ReAllocateMemory (
				PMemory		*pmemory,
				UINT		length);
// Routine to free the memory allocated by AllocateMemory().
void FreeMemory (PMemory	memory);

// To discover how much space is available at a non-TOP priority...
unsigned int GetFreeMemory (MemoryPriority	priority);

// Macro to get to the Memory object from app-requested buffer space
#define GetMemoryObject(p)				((PMemory) ((PUChar) p - (sizeof(Memory) + MAXIMUM_PROTOCOL_OVERHEAD)))
// Macro to get to the Memory object from the coder-alloced buffer space
#define GetMemoryObjectFromEncData(p)	((PMemory) ((PUChar) p - sizeof(Memory)))

// Routines to lock/unlock (AddRef/Release) memory allocated by AllocateMemory()
#define  LockMemory(memory)  			((memory)->Lock())
#define	 UnlockMemory(memory)			(FreeMemory(memory))

// Routines to allocate, realloc and free space without an associated Memory object
#ifdef DEBUG
	PUChar	Allocate (UINT		length);
#else 
#	define Allocate(length)				((PUChar) new BYTE[length])
#endif // DEBUG
#define Free(p)							(delete [] (BYTE *) (p))

#endif // _T120_MEMORY_MANAGER
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\remdsk\rds\t120\h\mpdutype.h ===
/*
 *	mpdutype.h
 *
 *	Copyright (c) 1995 by DataBeam Corporation, Lexington, KY
 *
 *	Abstract:
 *		This file is used to convert from the ASN.1 generated types into types
 *		compliant with the DataBeam coding standard.
 *
 *	Author:
 *		
 *
 *	Caveats:
 *		none
 */

#ifndef	_MCS_PDU_TYPES_
#define	_MCS_PDU_TYPES_

#include "mcspdu.h"

/*
 *	PDU types
 */
#define CONNECT_MCS_PDU   					ConnectMCSPDU_PDU
#define DOMAIN_MCS_PDU    					DomainMCSPDU_PDU
#define DATA_MCS_PDU						(DOMAIN_MCS_PDU + CONNECT_MCS_PDU + 1)

/*
 * Segmentation bits.
 */
#define BEGIN								begin
#define END									end

/*
 *	Typedef for Octet Strings.
 */
typedef	struct	_octet1						OctetString;

/*
 *	PDUChannelAttributes and ChannelIDs
 */
#define CHANNEL_ATTRIBUTES_STATIC_CHOSEN	channel_attributes_static_chosen
#define CHANNEL_ATTRIBUTES_USER_ID_CHOSEN	channel_attributes_user_id_chosen
#define CHANNEL_ATTRIBUTES_PRIVATE_CHOSEN	channel_attributes_private_chosen
#define CHANNEL_ATTRIBUTES_ASSIGNED_CHOSEN	channel_attributes_assigned_chosen

/*
 *	PDUTokenAttributes and TokenIDs
 */
#define GRABBED_CHOSEN			grabbed_chosen
#define INHIBITED_CHOSEN		inhibited_chosen
#define GIVING_CHOSEN			giving_chosen
#define UNGIVABLE_CHOSEN		ungivable_chosen
#define GIVEN_CHOSEN			given_chosen

/*
 * Diagnostics
 */
#define DC_INCONSISTENT_MERGE			dc_inconsistent_merge
#define DC_FORBIDDEN_PDU_DOWNWARD		dc_forbidden_pdu_downward
#define DC_FORBIDDEN_PDU_UPWARD			dc_forbidden_pdu_upward
#define DC_INVALID_BER_ENCODING			dc_invalid_ber_encoding
#define DC_INVALID_PER_ENCODING			dc_invalid_per_encoding
#define DC_MISROUTED_USER				dc_misrouted_user
#define DC_UNREQUESTED_CONFIRM			dc_unrequested_confirm
#define DC_WRONG_TRANSPORT_PRIORITY		dc_wrong_transport_priority
#define DC_CHANNEL_ID_CONFLICT			dc_channel_id_conflict
#define DC_TOKEN_ID_CONFLICT			dc_token_id_conflict
#define DC_NOT_USER_ID_CHANNEL			dc_not_user_id_channel
#define DC_TOO_MANY_CHANNELS			dc_too_many_channels
#define DC_TOO_MANY_TOKENS				dc_too_many_tokens
#define DC_TOO_MANY_USERS				dc_too_many_users

/*
 * AttachUserConfirmPDU
 */
#define INITIATOR_PRESENT		initiator_present

/*
 * ChannelJoinConfirmPDU
 */
#define JOIN_CHANNEL_ID_PRESENT		join_channel_id_present

/*
 * ChannelConveneConfirmPDU
 */
#define CONVENE_CHANNEL_ID_PRESENT		convene_channel_id_present

/*
 * ConnectMCSPDU
 */
#define CONNECT_INITIAL_CHOSEN			connect_initial_chosen
#define CONNECT_RESPONSE_CHOSEN			connect_response_chosen
#define CONNECT_ADDITIONAL_CHOSEN		connect_additional_chosen
#define CONNECT_RESULT_CHOSEN			connect_result_chosen

/*
 * DomainMCSPDU
 */
#define PLUMB_DOMAIN_INDICATION_CHOSEN	plumb_domain_indication_chosen
#define ERECT_DOMAIN_REQUEST_CHOSEN		erect_domain_request_chosen
#define MERGE_CHANNELS_REQUEST_CHOSEN	merge_channels_request_chosen
#define MERGE_CHANNELS_CONFIRM_CHOSEN	merge_channels_confirm_chosen
#define PURGE_CHANNEL_INDICATION_CHOSEN	purge_channel_indication_chosen
#define MERGE_TOKENS_REQUEST_CHOSEN		merge_tokens_request_chosen
#define MERGE_TOKENS_CONFIRM_CHOSEN		merge_tokens_confirm_chosen
#define PURGE_TOKEN_INDICATION_CHOSEN	purge_token_indication_chosen
#define DISCONNECT_PROVIDER_ULTIMATUM_CHOSEN disconnect_provider_ultimatum_chosen
#define REJECT_ULTIMATUM_CHOSEN			reject_user_ultimatum_chosen
#define ATTACH_USER_REQUEST_CHOSEN		attach_user_request_chosen
#define ATTACH_USER_CONFIRM_CHOSEN		attach_user_confirm_chosen
#define DETACH_USER_REQUEST_CHOSEN		detach_user_request_chosen
#define DETACH_USER_INDICATION_CHOSEN	detach_user_indication_chosen
#define CHANNEL_JOIN_REQUEST_CHOSEN		channel_join_request_chosen
#define CHANNEL_JOIN_CONFIRM_CHOSEN		channel_join_confirm_chosen
#define CHANNEL_LEAVE_REQUEST_CHOSEN	channel_leave_request_chosen
#define CHANNEL_CONVENE_REQUEST_CHOSEN	channel_convene_request_chosen
#define CHANNEL_CONVENE_CONFIRM_CHOSEN	channel_convene_confirm_chosen
#define CHANNEL_DISBAND_REQUEST_CHOSEN	channel_disband_request_chosen
#define CHANNEL_DISBAND_INDICATION_CHOSEN channel_disband_indication_chosen
#define CHANNEL_ADMIT_REQUEST_CHOSEN	channel_admit_request_chosen
#define CHANNEL_ADMIT_INDICATION_CHOSEN	channel_admit_indication_chosen
#define CHANNEL_EXPEL_REQUEST_CHOSEN	channel_expel_request_chosen
#define CHANNEL_EXPEL_INDICATION_CHOSEN	channel_expel_indication_chosen
#define SEND_DATA_REQUEST_CHOSEN		send_data_request_chosen
#define SEND_DATA_INDICATION_CHOSEN		send_data_indication_chosen
#define UNIFORM_SEND_DATA_REQUEST_CHOSEN uniform_send_data_request_chosen
#define UNIFORM_SEND_DATA_INDICATION_CHOSEN	uniform_send_data_indication_chosen
#define TOKEN_GRAB_REQUEST_CHOSEN		token_grab_request_chosen
#define TOKEN_GRAB_CONFIRM_CHOSEN		token_grab_confirm_chosen
#define TOKEN_INHIBIT_REQUEST_CHOSEN	token_inhibit_request_chosen
#define TOKEN_INHIBIT_CONFIRM_CHOSEN	token_inhibit_confirm_chosen
#define TOKEN_GIVE_REQUEST_CHOSEN		token_give_request_chosen
#define TOKEN_GIVE_INDICATION_CHOSEN	token_give_indication_chosen
#define TOKEN_GIVE_RESPONSE_CHOSEN		token_give_response_chosen
#define TOKEN_GIVE_CONFIRM_CHOSEN		token_give_confirm_chosen
#define TOKEN_PLEASE_REQUEST_CHOSEN		token_please_request_chosen
#define TOKEN_PLEASE_INDICATION_CHOSEN	token_please_indication_chosen
#define TOKEN_RELEASE_REQUEST_CHOSEN	token_release_request_chosen
#define TOKEN_RELEASE_CONFIRM_CHOSEN	token_release_confirm_chosen
#define TOKEN_TEST_REQUEST_CHOSEN		token_test_request_chosen
#define TOKEN_TEST_CONFIRM_CHOSEN		token_test_confirm_chosen

/*
 * Pointer typedefs
 */
typedef ConnectInitialPDU * 				PConnectInitialPDU;
typedef ConnectResponsePDU * 				PConnectResponsePDU;
typedef ConnectAdditionalPDU * 				PConnectAdditionalPDU;
typedef ConnectResultPDU * 					PConnectResultPDU;
typedef PlumbDomainIndicationPDU * 			PPlumbDomainIndicationPDU;
typedef ErectDomainRequestPDU * 			PErectDomainRequestPDU;
typedef MergeChannelsRequestPDU *			PMergeChannelsRequestPDU;
typedef MergeChannelsConfirmPDU *			PMergeChannelsConfirmPDU;
typedef PurgeChannelIndicationPDU *			PPurgeChannelIndicationPDU;
typedef MergeTokensRequestPDU *				PMergeTokensRequestPDU;
typedef MergeTokensConfirmPDU *				PMergeTokensConfirmPDU;
typedef PurgeTokenIndicationPDU *			PPurgeTokenIndicationPDU;
typedef DisconnectProviderUltimatumPDU *	PDisconnectProviderUltimatumPDU;
typedef RejectUltimatumPDU *				PRejectUltimatumPDU;
typedef AttachUserRequestPDU *				PAttachUserRequestPDU;
typedef AttachUserConfirmPDU *				PAttachUserConfirmPDU;
typedef DetachUserRequestPDU *				PDetachUserRequestPDU;
typedef DetachUserIndicationPDU *			PDetachUserIndicationPDU;
typedef ChannelJoinRequestPDU *				PChannelJoinRequestPDU;
typedef ChannelJoinConfirmPDU *				PChannelJoinConfirmPDU;
typedef ChannelLeaveRequestPDU *			PChannelLeaveRequestPDU;
typedef ChannelConveneRequestPDU *			PChannelConveneRequestPDU;
typedef ChannelConveneConfirmPDU *			PChannelConveneConfirmPDU;
typedef ChannelDisbandRequestPDU *			PChannelDisbandRequestPDU;
typedef ChannelDisbandIndicationPDU *		PChannelDisbandIndicationPDU;
typedef ChannelAdmitRequestPDU *			PChannelAdmitRequestPDU;
typedef ChannelAdmitIndicationPDU *			PChannelAdmitIndicationPDU;
typedef ChannelExpelRequestPDU *			PChannelExpelRequestPDU;
typedef ChannelExpelIndicationPDU *			PChannelExpelIndicationPDU;
typedef SendDataRequestPDU *				PSendDataRequestPDU;
typedef SendDataIndicationPDU *				PSendDataIndicationPDU;
typedef UniformSendDataRequestPDU *			PUniformSendDataRequestPDU;
typedef UniformSendDataIndicationPDU *		PUniformSendDataIndicationPDU;
typedef TokenGrabRequestPDU *				PTokenGrabRequestPDU;
typedef TokenGrabConfirmPDU *				PTokenGrabConfirmPDU;
typedef TokenInhibitRequestPDU *			PTokenInhibitRequestPDU;
typedef TokenInhibitConfirmPDU *			PTokenInhibitConfirmPDU;
typedef TokenGiveRequestPDU *				PTokenGiveRequestPDU;
typedef TokenGiveIndicationPDU *			PTokenGiveIndicationPDU;
typedef TokenGiveResponsePDU *				PTokenGiveResponsePDU;
typedef TokenGiveConfirmPDU *				PTokenGiveConfirmPDU;
typedef TokenPleaseRequestPDU *				PTokenPleaseRequestPDU;
typedef TokenPleaseIndicationPDU *			PTokenPleaseIndicationPDU;
typedef TokenReleaseRequestPDU *			PTokenReleaseRequestPDU;
typedef TokenReleaseConfirmPDU *			PTokenReleaseConfirmPDU;
typedef TokenTestRequestPDU *				PTokenTestRequestPDU;
typedef TokenTestConfirmPDU *				PTokenTestConfirmPDU;

typedef ConnectMCSPDU 	*	PConnectMCSPDU;
typedef DomainMCSPDU 	*	PDomainMCSPDU;

/*
 *	Typedefs for other PDU structures.
 */
typedef PDUDomainParameters *				PPDUDomainParameters;
typedef	Diagnostic *						PDiagnostic;

typedef	struct	SetOfUserIDs				SetOfUserIDs;

typedef	struct	SetOfPDUChannelAttributes	SetOfPDUChannelAttributes;
typedef PDUChannelAttributes * 				PPDUChannelAttributes;

typedef struct	SetOfChannelIDs			    SetOfChannelIDs;

typedef struct	SetOfPDUTokenAttributes	    SetOfPDUTokenAttributes;
typedef PDUTokenAttributes * 				PPDUTokenAttributes;

typedef struct	SetOfTokenIDs				SetOfTokenIDs;

/*
 *	MAXIMUM_PROTOCOL_OVERHEAD
 *		This is used to calculate the maximum size of the user data field within
 *		a send data PDU.  This will be set to the maximum PDU size as set in
 *		the domain parameters, minus this number to allow for protocol overhead.
 *		This number MUST be large enough to handle the worst case overhead
 *		for ONLY the Packed Encoding Rules (PER).
 *		The max overhead consists of 2 parts: MAXIMUM_PROTOCOL_OVERHEAD_MCS
 *		is the max MCS overhead for a Send Data request while 
 *		PROTOCOL_OVERHEAD_X224 is the overhead imposed by X.224.
 *
 *	PROTOCOL_OVERHEAD_SECURITY
 *		This is the max overhead allowed for encryption/decryption of MCS data
 *		packets. That space should be enough for both the trailer and
 *		the header of an encrypted X.224 packet.
 */
#define PROTOCOL_OVERHEAD_SECURITY		64
#define	MAXIMUM_PROTOCOL_OVERHEAD_MCS	8
#define PROTOCOL_OVERHEAD_X224			sizeof(X224_DATA_PACKET)
#define	MAXIMUM_PROTOCOL_OVERHEAD		(MAXIMUM_PROTOCOL_OVERHEAD_MCS + PROTOCOL_OVERHEAD_X224)

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\remdsk\rds\t120\h\memory.h ===
/*
 *	memory.h
 *
 *	Copyright (c) 1993 - 1995 by DataBeam Corporation, Lexington, KY
 *
 *	Abstract:
 *		This is the interface file for the Memory class.  Instances of this
 *		class are used to pass data around the system.
 *
 *		Each instance of this class maintains two pointers.  The first is a
 *		pointer to the reference data (or the source data) which this object
 *		is responsible for representing.  The second is a pointer to a copy
 *		buffer, which is a piece of allocated memory that a Memory object
 *		can copy the data into if necessary.
 *
 *		When a Memory object is created, both of these addresses are passed
 *		in to it.  It does not, however, copy the data from the reference
 *		buffer to the copy buffer just yet.  If anyone asks the address of the
 *		buffer, it will simply return the reference pointer.  However, the
 *		first time the buffer is locked, the data will be copied from the
 *		reference buffer to the copy buffer for safe keeping.  In essence,
 *		the lock function tells the Memory object that someone is interested
 *		in the data for longer than the reference buffer will remain valid.
 *
 *		After the object is locked, a call to retrieve a memory pointer will
 *		result in the copy pointer being returned.
 *
 *		Each time the lock function is called, a lock count is incremented.
 *		The copy operation only takes place the first time the buffer is
 *		locked, however.
 *
 *		In addition to maintaining a lock count, this object keeps a flag
 *		indicating whether or not it has been freed by the allocator.  This
 *		freeing really means that the object is enabled to be freed as soon
 *		as the lock count hits zero.
 *
 *	Caveats:
 *		None.
 *
 *	Author:
 *		James P. Galvin, Jr.
 */
#ifndef	_MEMORY_
#define	_MEMORY_

#include "signatr.h"

#define MEMORY_PRIORITIES		3

typedef enum {
	HIGHEST_PRIORITY		= 0,
	RECV_PRIORITY			= 1,
	SEND_PRIORITY			= 2
} MemoryPriority;

/*
 *	This is the class definition for the Memory class.
 */
class Memory;
typedef	Memory *		PMemory;

class Memory
{	
	public:
						Memory (PUChar			reference_ptr,
								ULong			length,
								PUChar			copy_ptr);
						~Memory ()
						{
							ASSERT(SIGNATURE_MATCH(this, MemorySignature));
						};
		Void			Init (PUChar			reference_ptr,
								ULong			length,
								MemoryPriority	priority,
								PUChar			copy_ptr);
		PUChar			GetPointer ()
						{
							ASSERT(SIGNATURE_MATCH(this, MemorySignature));
							return (Copy_Ptr);
						}
		ULong			GetLength ()
						{
							ASSERT(SIGNATURE_MATCH(this, MemorySignature));
							return (Length);
						}
		int				GetLockCount ()
						{
							ASSERT(SIGNATURE_MATCH(this, MemorySignature));
							return ((int) lLock);
						};
		MemoryPriority	GetMemoryPriority ()
						{
							return m_priority;
						};
		Void			Lock ()
						{
							ASSERT(SIGNATURE_MATCH(this, MemorySignature));
							InterlockedIncrement (& lLock);
							TRACE_OUT (("Memory::Lock: buffer at address %p. Lock count: %d",
										(UINT_PTR) Copy_Ptr, lLock));
							ASSERT (lLock > 0);
						};
		long			Unlock ()
						{
							ASSERT(SIGNATURE_MATCH(this, MemorySignature));
							ASSERT (lLock > 0);
							TRACE_OUT (("Memory::UnLock: buffer at address %p. Lock count: %d",
										(UINT_PTR) Copy_Ptr, lLock - 1));
							return (InterlockedDecrement (&lLock));
						}

	private:
		ULong			Length;
		PUChar			Copy_Ptr;
		long			lLock;
		MemoryPriority	m_priority;
/*
 *	NOTEs:
 *		1. The Memory class can not have virtual member functions, because
 *			of the Init() member.
 *		2. sizeof(Memory) should be DWORD-aligned, because of the
 *			AllocateMemory implementation.
 */

#ifndef SHIP_BUILD
	public:
		char			mSignature[SIGNATURE_LENGTH];
#endif // SHIP_BUILD
};


/*
 *	Memory (
 *			PUChar		reference_ptr,
 *			ULong		length,
 *			PUChar		copy_ptr)
 *
 *	Functional Description:
 *		This is the constructor for the Memory class.  All it does is
 *		initialize the instance variable with the passed in values.
 *
 *	Formal Parameters:
 *		reference_ptr (i)
 *			This is a pointer to the data that is to represented by this
 *			Memory object.
 *		length (i)
 *			This is the length of the reference buffer.
 *		copy_ptr (i)
 *			This is the address of an allocated buffer that the Memory object
 *			can use to preserve the contents of the reference buffer if a lock
 *			operation occurs.
 *
 *	Return Value:
 *		None.
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

/*
 *	~Memory ()
 *
 *	Functional Description:
 *		This is the destructor for the Memory class.  It does nothing at this
 *		time.  Note that it is the responsibility of the memory manager that
 *		is using Memory objects to free up the memory.
 *
 *	Formal Parameters:
 *		None.
 *
 *	Return Value:
 *		None.
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

/*
 *	ULong		GetLength ()
 *
 *	Functional Description:
 *		This function retrieves the length of the data being represented by
 *		this object.
 *
 *	Formal Parameters:
 *		None.
 *
 *	Return Value:
 *		The length of the data.
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

/*
 *	PUChar		GetPointer ()
 *
 *	Functional Description:
 *		This function retrieves the buffer being represented by
 *		this object.
 *
 *	Formal Parameters:
 *		None.
 *
 *	Return Value:
 *		The buffer pointer.
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

/*
 *	int		GetLockCount ()
 *
 *	Functional Description:
 *		This function retrieves the lock counter for the buffer being represented by
 *		this object.
 *
 *	Formal Parameters:
 *		None.
 *
 *	Return Value:
 *		The buffer's current lock counter.
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

/*
 *	Void		Lock ()
 *
 *	Functional Description:
 *		This function locks the buffer being represented by
 *		this object.
 *
 *	Formal Parameters:
 *		None.
 *
 *	Return Value:
 *		None.
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

/*
 *	int		Unlock ()
 *
 *	Functional Description:
 *		This function unlocks the buffer being represented by
 *		this object.
 *
 *	Formal Parameters:
 *		None.
 *
 *	Return Value:
 *		The lock count after the unlock operation.
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

#endif

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\remdsk\rds\t120\h\ms_util.h ===
#ifndef __MS_UTIL_H__
#define __MS_UTIL_H__

extern "C"
{
#include "t120.h"
}

//
// GUI message boxes kill us when we hit an assert or error, because they
// have a message pump that causes messages to get dispatched, making it
// very difficult for us to debug problems when they occur.  Therefore
// we redefine ERROR_OUT and ASSERT
//
#ifdef _DEBUG

__inline void MyDebugBreak(void) { DebugBreak(); }

#endif // _DEBUG




/*
 * Macro used to force values to four byte boundaries.  This macro will need to
 * be considered when portability issues arise.
 */
#define ROUNDTOBOUNDARY(num)	(((UINT)(num) + 0x03) & 0xfffffffcL)


// the following create a dword that will look like "abcd" in debugger
#ifdef SHIP_BUILD
#define MAKE_STAMP_ID(a,b,c,d)     
#else
#define MAKE_STAMP_ID(a,b,c,d)     MAKELONG(MAKEWORD(a,b),MAKEWORD(c,d))
#endif // SHIP_BUILD

class CRefCount
{
public:

#ifdef SHIP_BUILD
    CRefCount(void);
#else
    CRefCount(DWORD dwStampID);
#endif
    virtual ~CRefCount(void) = 0;

    LONG AddRef(void);
    LONG Release(void);

    void ReleaseNow(void);

protected:

    LONG GetRefCount(void) { return m_cRefs; }
    BOOL IsRefCountZero(void) { return (0 == m_cRefs); }

    LONG Lock(void);
    LONG Unlock(BOOL fRelease = TRUE);

    LONG GetLockCount(void) { return m_cLocks; }
    BOOL IsLocked(void) { return (0 == m_cLocks); }

private:

#ifndef SHIP_BUILD
    DWORD       m_dwStampID;// to remove before we ship it
#endif
    LONG        m_cRefs;    // reference count
    LONG        m_cLocks;   // lock count of the essential contents
};


extern HINSTANCE g_hDllInst;

__inline void My_CloseHandle(HANDLE hdl)
{
    if (NULL != hdl)
    {
        CloseHandle(hdl);
    }
}


#if defined(_DEBUG)
LPSTR _My_strdupA(LPCSTR pszSrc, LPSTR pszFileName, UINT nLineNumber);
LPWSTR _My_strdupW(LPCWSTR pszSrc, LPSTR pszFileName, UINT nLineNumber);
LPWSTR _My_strdupW2(UINT cchSrc, LPCWSTR pszSrc, LPSTR pszFileName, UINT nLineNumber);
LPOSTR _My_strdupO2(LPBYTE lpbSrc, UINT cOctets, LPSTR pszFileName, UINT nLineNumber);

#define My_strdupA(pszSrc) _My_strdupA(pszSrc, __FILE__, __LINE__)
#define My_strdupW(pszSrc) _My_strdupW(pszSrc, __FILE__, __LINE__)
#define My_strdupW2(cchSrc,pszSrc) _My_strdupW2(cchSrc, pszSrc, __FILE__, __LINE__)
#define My_strdupO2(lpbSrc,cOctets) _My_strdupO2(lpbSrc, cOctets, __FILE__, __LINE__)
#define My_strdupO(poszSrc) _My_strdupO2(poszSrc->value, poszSrc->length, __FILE__, __LINE__)
#else
LPSTR My_strdupA(LPCSTR pszSrc);
LPWSTR My_strdupW(LPCWSTR pszSrc);
LPWSTR My_strdupW2(UINT cchSrc, LPCWSTR pszSrc); // backward compatible to UnicodeString
LPOSTR My_strdupO2(LPBYTE lpbSrc, UINT cOctets);
__inline LPOSTR My_strdupO(LPOSTR poszSrc) { return My_strdupO2(poszSrc->value, poszSrc->length); }
#endif

UINT My_strlenA(LPCSTR pszSrc);
UINT My_strlenW(LPCWSTR pszSrc);
int My_strcmpW(LPCWSTR pwsz1, LPCWSTR pwsz2);

#ifdef _UNICODE
#define My_strdup			My_strdupW
#define My_strlen			My_strlenW
#define My_strcmp			My_strcmpW
#else
#define My_strdup			My_strdupA
#define My_strlen			My_strlenA
#define My_strcmp			lstrcmpA
#endif

INT My_strcmpO(LPOSTR posz1, LPOSTR posz2);



#endif // __MS_UTIL_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\remdsk\rds\t120\h\mcsuser.h ===
/*
 *	mcsuser.h
 *
 *	Copyright (c) 1995 by DataBeam Corporation, Lexington, KY
 *
 *	Abstract:
 *		An instance of this class represents a Conference object's user 
 *		attachment to MCS.  This is a fairly complex class that handles a lot of 
 *		conference establishment details such as creating a User attachment to 
 *		MCS and joining all the appropriate MCS channels.  After everything is 
 *		established the User object is responsible for encoding and decoding 
 *		certain PDUs as well as management of a data queue which can hold a 
 *		number of outgoing PDUs.  The MCSUser object is designed so that it 
 *		knows very little about any object other than the MCS Interface object 
 *		which it uses to send out PDUs.  This class only deals with data PDUs 
 *		(or GCC PDUs) as opposed to connect PDUs.  These GCC PDUs are sent and 
 *		received through channels joined by the GCC user attachment.
 *
 *		When an MCSUser object is first instantiated it goes through a number of 
 *		steps to establish its links to MCS.  First,  an MCSUser object 
 *		immediately creates an MCS user attachment in its constructor.  After 
 *		the MCS_ATTACH_USER_CONFIRM is received it begins joining all of the 
 *		appropriate channels.  The channels it joins varies depending on the 
 *		node type which is passed in through the MCSUser objects constructor.  
 *		After all channels have been successfully joined, the MCSUser object 
 *		issues an owner callback informing the Conference object that it is 
 *		completely initiated and ready to service requests.  
 *
 *		The MCSUser object can handle a number of different requests that can 
 *		result in PDU traffic being generated.  Therefore,  the user object has 
 *		the ability (within certain requests) to encode outgoing PDUs.  Many of 
 *		the more complex PDUs are handled by the class that contains the 
 *		information needed to build the PDU such as the ConferenceRoster and the 
 *		ApplicationRoster.  All PDU traffic received by an MCSUser object is 
 *		directly decoded by this class and immediately sent back to the owner 
 *		object (a Conference object) through an owner callback.
 *
 *		An MCSUser object has the ability to Terminate itself when an 
 *		unrecoverable resource error occurs.  This is handled through an owner 
 *		callback message informing the Owner Object to do the delete.  
 *
 *	Caveats:
 *		None.
 *
 *	Author:
 *		blp
 */
#ifndef _GCC_MCS_USER_
#define _GCC_MCS_USER_

/** include files **/
#include "mcsdllif.h"
#include "pktcoder.h"
#include "userdata.h"
#include "password.h"
#include "alarm.h"
#include "regkey.h"
#include "regitem.h"
#include "netaddr.h"
#include "invoklst.h"
#include "clists.h"


// was defined in gcmdtar.h
typedef UINT       TagNumber;


/*
 * Result types for attach user and channel joins performed by the user object
 */
typedef enum
{
	USER_RESULT_SUCCESSFUL,
	USER_ATTACH_FAILURE,
	USER_CHANNEL_JOIN_FAILURE
}UserResultType;


/*
 *	This enum defines all the possible types of nodes that can exists
 *	in a GCC conference.  Note that this is an internal definition and
 *	is not the save the the T.124 node type.
 */
typedef enum
{
	TOP_PROVIDER_NODE,
	CONVENER_NODE,		  
	TOP_PROVIDER_AND_CONVENER_NODE,
	JOINED_NODE,
	INVITED_NODE,
	JOINED_CONVENER_NODE
} ConferenceNodeType;


/*
**	The structures defined below are used to pack the data associated with
**	all the above owner callback messages.  A pointer to one of these
**	structures is passed in the LPVOID parameter of the owner callback.
*/

//	USER_CREATE_CONFIRM data structure
typedef struct
{
	UserID			user_id;
	UserResultType	create_result;
}
    UserCreateConfirmInfo, *PUserCreateConfirmInfo;

//	USER_CONFERENCE_JOIN_REQUEST data structure
typedef struct
{
	CPassword       *convener_password;
	CPassword       *password_challenge;		
	LPWSTR			pwszCallerID;
	CUserDataListContainer *user_data_list;
	UserID			sender_id;
}
    UserJoinRequestInfo, *PUserJoinRequestInfo;

//	USER_CONFERENCE_JOIN_RESPONSE data structure
typedef struct
{
	CPassword           *password_challenge;		
	CUserDataListContainer *user_data_list;
	ConnectionHandle	connection_handle;
	GCCResult			result;
}
    UserJoinResponseInfo, *PUserJoinResponseInfo;

//	USER_TIME_REMAINING_INDICATION data structure
typedef struct
{
	UserID		source_node_id;
	UserID		node_id;
	UINT		time_remaining;
}
    UserTimeRemainingInfo, *PUserTimeRemainingInfo;

//	USER_CONFERENCE_EXTEND_INDICATION data structure
typedef struct
{
	UINT			extension_time;
	BOOL    	time_is_conference_wide;
	UserID		source_node_id;
}
    UserTimeExtendInfo, *PUserTimeExtendInfo;

//	USER_TERMINATE_REQUEST data structure
typedef struct
{
	UserID		requester_id;
	GCCReason	reason;
}
    UserTerminateRequestInfo, *PUserTerminateRequestInfo;

//	USER_NODE_EJECTION_REQUEST data structure
typedef struct
{
	UserID		requester_id;
	UserID		node_to_eject;
	GCCReason	reason;
}
    UserEjectNodeRequestInfo, *PUserEjectNodeRequestInfo;

//	USER_NODE_EJECTION_RESPONSE data structure
typedef struct
{
	UserID		node_to_eject;
	GCCResult	result;
}
    UserEjectNodeResponseInfo, *PUserEjectNodeResponseInfo;

//	USER_REGISTRY_CHANNEL_REQUEST data structure
typedef struct
{
	CRegKeyContainer    *registry_key;
	ChannelID			channel_id;
	EntityID			requester_entity_id;
}
    UserRegistryChannelRequestInfo, *PUserRegistryChannelRequestInfo;

//	USER_REGISTRY_SET_PARAMETER_REQUEST data structure
typedef struct
{
	CRegKeyContainer        *registry_key;
	LPOSTR                  parameter_value;
	GCCModificationRights	modification_rights;
	EntityID				requester_entity_id;
}
    UserRegistrySetParameterRequestInfo, *PUserRegistrySetParameterRequestInfo;

/*
**	Data structure associated with the following: 
**
**	USER_REGISTRY_TOKEN_REQUEST,
**	USER_REGISTRY_RETRIEVE_REQUEST, 
**	USER_REGISTRY_DELETE_REQUEST,
**	USER_REGISTRY_MONITOR_REQUEST.
*/
typedef struct
{
	CRegKeyContainer    *registry_key;
	EntityID			requester_entity_id;
}
    UserRegistryRequestInfo, *PUserRegistryRequestInfo;

//	USER_REGISTRY_RESPONSE data structure
typedef struct
{
	RegistryResponsePrimitiveType	primitive_type;
	CRegKeyContainer                *registry_key;
	CRegItem                        *registry_item;
	GCCModificationRights			modification_rights;
	EntityID						owner_node_id;
	EntityID						owner_entity_id;
	EntityID						requester_entity_id;
	GCCResult						result;
}
    UserRegistryResponseInfo, *PUserRegistryResponseInfo;

//	USER_REGISTRY_MONITOR_INDICATION data structure
typedef struct
{
	CRegKeyContainer                *registry_key;
	CRegItem                        *registry_item;
	GCCModificationRights			modification_rights;
	EntityID						owner_node_id;
	EntityID						owner_entity_id;
}
    UserRegistryMonitorInfo, *PUserRegistryMonitorInfo;

/*
**	Data structure associated with the following:
**
**	USER_REGISTRY_ALLOCATE_HANDLE_REQUEST,
**	USER_REGISTRY_ALLOCATE_HANDLE_RESPONSE.
*/
typedef struct
{
	EntityID						requester_entity_id;
	USHORT							number_of_handles;
	UINT							first_handle;
	GCCResult						result;
}
    UserRegistryAllocateHandleInfo, *PUserRegistryAllocateHandleInfo;

//	USER_CONDUCTOR_PERMIT_GRANT_INDICATION data structure
typedef struct
{
	USHORT			number_granted;
	PUserID			granted_node_list;
	USHORT			number_waiting;
	PUserID			waiting_node_list;
}
    UserPermissionGrantIndicationInfo, *PUserPermissionGrantIndicationInfo;

//	USER_USER_ID_INDICATION data structure
typedef struct
{
	UserID			sender_id;
	TagNumber		tag;
}
    UserIDIndicationInfo, *PUserIDIndicationInfo;

//	USER_TIME_INQUIRE_INDICATION data structure
typedef struct
{
	UserID			sender_id;
	BOOL    		time_is_node_specific;
}
    TimeInquireIndicationInfo, *PTimeInquireIndicationInfo;

//	USER_CONDUCTOR_ASSIGN_INDICATION data structure
typedef struct
{
	UserID			sender_id;
	UserID			conductor_id;
}
    ConductorAssignIndicationInfo, *PConductorAssignIndicationInfo;

//	USER_CONDUCTOR_PERMIT_ASK_INDICATION data structure
typedef struct
{
	UserID			sender_id;
	BOOL    		permission_is_granted;
}
    PermitAskIndicationInfo, *PPermitAskIndicationInfo;

//	USER_DETACH_INDICATION data structure
typedef struct
{
	UserID			detached_user;
	GCCReason		reason;
}
    DetachIndicationInfo, *PDetachIndicationInfo;

/*
**	Data structure associated with the following:
**
**	USER_CONFERENCE_TRANSFER_REQUEST,
**	USER_CONFERENCE_TRANSFER_INDICATION,
**	USER_CONFERENCE_TRANSFER_RESPONSE.
*/
typedef struct
{
	GCCConferenceName		destination_conference_name;
	GCCNumericString		destination_conference_modifier;
	CNetAddrListContainer   *destination_address_list;
	USHORT					number_of_destination_nodes;
	PUserID					destination_node_list;
	CPassword               *password;
	UserID					requesting_node_id;
	GCCResult				result;
}
    TransferInfo, *PTransferInfo;

//	USER_CONFERENCE_ADD_REQUEST data structure
typedef struct
{
	CNetAddrListContainer   *network_address_list;
	CUserDataListContainer  *user_data_list;
	UserID					adding_node;
	TagNumber				add_request_tag;
	UserID					requesting_node;
}
    AddRequestInfo, *PAddRequestInfo;

//	USER_CONFERENCE_ADD_RESPONSE data structure
typedef struct
{
	CUserDataListContainer  *user_data_list;
	TagNumber				add_request_tag;
	GCCResult				result;
}
    AddResponseInfo, *PAddResponseInfo;

/******************** End of callback data structures *********************/


/*
 *	Structure to hold send data information (besides the actual data packet), 
 *	when the send data request is queued to be sent during the heartbeat.
 */
typedef struct
{
	ChannelID				channel_id;
	Priority				priority;
	BOOL    				uniform_send;

	PPacket                 packet;
}
    SEND_DATA_REQ_INFO;

/* 
 *	This structure holds information as to which channels the user object
 *	has joined at a particular instance of time. Also it indicates whether
 *	there has been an error in joining any of these channels or not.
 */
typedef struct
{
	BOOL    				convener_channel_joined;
	BOOL    				user_channel_joined;
	BOOL    				broadcast_channel_joined;
	BOOL    				channel_join_error;
}
    ChannelJoinedFlag, *PChannelJoinedFlag;

/* 
**	Queue of structures (SendDataMessages) to be flushed during a
**	heartbeat.
*/
class COutgoingPDUQueue : public CQueue
{
    DEFINE_CQUEUE(COutgoingPDUQueue, SEND_DATA_REQ_INFO*);
};

/*	
**	List to maintain sequence number in the response with sender's userid
**	to be able to route the response to the correct gcc provider.
*/
class CConfJoinResponseList2 : public CList2
{
    DEFINE_CLIST2_(CConfJoinResponseList2, TagNumber, UserID);
};

/*
**	List to hold the user ids of users in this provider's subtree
**	This list is used to match outstanding user IDs
*/
class CConnHandleUidList2 : public CList2
{
    DEFINE_CLIST2___(CConnHandleUidList2, USHORT)
};

/*
**	This list holds alarms used to disconnect any misbehaving nodes.  If an
**	alarm is placed in this list, the node has a specified amount of time to
**	disconnect before this node will disconnect it.
*/
class CAlarmUidList2 : public CList2
{
    DEFINE_CLIST2_(CAlarmUidList2, PAlarm, UserID)
};


//	The class definition.
class CConf;
class MCSUser : public CRefCount
{
    friend class MCSDLLInterface;

public:

    MCSUser(CConf *,
            GCCNodeID       nidTopProvider,
            GCCNodeID       nidParent,
            PGCCError);

    ~MCSUser(void);

    void		SendUserIDRequest(TagNumber);
	void		SetChildUserIDAndConnection(UserID, ConnectionHandle);

	/* 
	 * Called by conference of intermediate node to send join request
	 * over to the top provider.
	 */
	GCCError	ConferenceJoinRequest(
					CPassword               *convener_password,
					CPassword               *password_challange,
					LPWSTR					pwszCallerID,
					CUserDataListContainer  *user_data_list,
					ConnectionHandle		connection_handle);
			
	/*
	**	Called by conference of top provider to send the response
	**	back to the intermediate node.
	*/
	void		ConferenceJoinResponse(
					UserID					receiver_id,
					BOOL    				password_is_in_the_clear,
					BOOL    				conference_locked,
					BOOL    				conference_listed,
					GCCTerminationMethod	termination_method,
					CPassword               *password_challenge,
					CUserDataListContainer  *user_data_list,
					GCCResult				result);
					
	GCCError SendConferenceLockRequest(void);
	GCCError SendConferenceLockResponse(UserID uidSource, GCCResult);
	GCCError SendConferenceUnlockRequest(void);
	GCCError SendConferenceUnlockResponse(UserID uidSource, GCCResult);
	GCCError SendConferenceLockIndication(BOOL fUniformSend, UserID uidSource);
	GCCError SendConferenceUnlockIndication(BOOL fUniformSend, UserID uidSource);

	//	Calls related to conference termination
	void		ConferenceTerminateRequest(GCCReason);
	void		ConferenceTerminateResponse(UserID uidRequester, GCCResult);
	void		ConferenceTerminateIndication(GCCReason);

    GCCError	EjectNodeFromConference(UserID uidEjected, GCCReason);
	GCCError	SendEjectNodeResponse(UserID uidRequester, UserID uidEject, GCCResult);

	//	Roster related calls
	void		RosterUpdateIndication(PGCCPDU, BOOL send_update_upward);

    //	Registry related calls
	void		RegistryRegisterChannelRequest(CRegKeyContainer *, ChannelID, EntityID);
	void		RegistryAssignTokenRequest(CRegKeyContainer *, EntityID);
	void		RegistrySetParameterRequest(CRegKeyContainer *,
	                                        LPOSTR,
					                        GCCModificationRights,
					                        EntityID);
	void		RegistryRetrieveEntryRequest(CRegKeyContainer *, EntityID);
	void		RegistryDeleteEntryRequest(CRegKeyContainer *, EntityID);
	void		RegistryMonitorRequest(CRegKeyContainer *, EntityID);
   	void		RegistryAllocateHandleRequest(UINT, EntityID);
	void		RegistryAllocateHandleResponse(UINT cHandles, UINT registry_handle,
        					EntityID eidRequester, UserID uidRequester, GCCResult);

    void		RegistryResponse(
					RegistryResponsePrimitiveType	primitive_type,
					UserID  						requester_owner_id,
					EntityID						requester_entity_id,
					CRegKeyContainer	            *registry_key_data,
					CRegItem                        *registry_item_data,
					GCCModificationRights			modification_rights,
					UserID  						entry_owner_id,
					EntityID						entry_entity_id,
					GCCResult						result);

   	void		RegistryMonitorEntryIndication ( 	
					CRegKeyContainer	            *registry_key_data,
					CRegItem                        *registry_item,
					UserID  						entry_owner_id,
					EntityID						entry_entity_id,
					GCCModificationRights			modification_rights);

	GCCError 	AppInvokeIndication(CInvokeSpecifierListContainer *, GCCSimpleNodeList *);

	GCCError 	TextMessageIndication(LPWSTR pwszTextMsg, UserID uidDst);

	GCCError	ConferenceAssistanceIndication(UINT cElements, PGCCUserData *);

	GCCError	ConferenceTransferRequest (
					PGCCConferenceName		destination_conference_name,
					GCCNumericString		destination_conference_modifier,
					CNetAddrListContainer   *destination_address_list,
					UINT					number_of_destination_nodes,
					PUserID					destination_node_list,
					CPassword               *password);

	GCCError	ConferenceTransferIndication (
					PGCCConferenceName		destination_conference_name,
					GCCNumericString		destination_conference_modifier,
					CNetAddrListContainer   *destination_address_list,
					UINT					number_of_destination_nodes,
 					PUserID					destination_node_list,
					CPassword               *password);

	GCCError	ConferenceTransferResponse (
					UserID					requesting_node_id,
					PGCCConferenceName		destination_conference_name,
					GCCNumericString		destination_conference_modifier,
					UINT					number_of_destination_nodes,
 					PUserID					destination_node_list,
					GCCResult				result);
																		 
	GCCError	ConferenceAddRequest(
					TagNumber				conference_add_tag,
					UserID					requesting_node,
					UserID					adding_node,
					UserID					target_node,
					CNetAddrListContainer   *network_address_container,
					CUserDataListContainer  *user_data_container);
		
	GCCError	ConferenceAddResponse(
					TagNumber				add_request_tag,
					UserID					requesting_node,
					CUserDataListContainer  *user_data_container,
					GCCResult				result);
	

	//	Calls related to conductorship
 	GCCError	ConductorTokenGrab(void);
	GCCError	ConductorTokenRelease(void);
   	GCCError	ConductorTokenPlease(void);
	GCCError	ConductorTokenGive(UserID uidRecipient);
   	GCCError	ConductorTokenGiveResponse(Result);
	GCCError	ConductorTokenTest(void);
   	GCCError	SendConductorAssignIndication(UserID uidConductor);
   	GCCError	SendConductorReleaseIndication(void);
	GCCError	SendConductorPermitAsk(BOOL fGranted);

	GCCError	SendConductorPermitGrant(UINT cGranted, PUserID granted_node_list,
					                     UINT cWaiting, PUserID waiting_node_list);

    //	Miscelaneous calls
	GCCError	TimeRemainingRequest(UINT time_remaining, UserID);
	GCCError	TimeInquireRequest(BOOL time_is_conference_wide);	
	GCCError	ConferenceExtendIndication(UINT extension_time, BOOL time_is_conference_wide);
    void        CheckEjectedNodeAlarms(void);
	BOOL    	FlushOutgoingPDU(void);

	GCCNodeID	GetMyNodeID(void) {  return(m_nidMyself); }
	GCCNodeID	GetTopNodeID(void) { return(m_nidTopProvider); }
	GCCNodeID	GetParentNodeID(void) { return(m_nidParent); }

	UserID		GetUserIDFromConnection(ConnectionHandle);
	void		UserDisconnectIndication(UserID);

protected:

	UINT  				ProcessAttachUserConfirm(
							Result					result,
							UserID					user_id);

	UINT				ProcessChannelJoinConfirm(	
							Result					result,
							ChannelID				channel_id);

	UINT				ProcessDetachUserIndication(
							Reason					mcs_reason,
							UserID					detached_user);

	UINT				ProcessSendDataIndication(
							PSendData				send_data_info);

	UINT				ProcessUniformSendDataIndication(	
							PSendData				send_data_info);

	void				ProcessConferenceJoinRequestPDU(
							PConferenceJoinRequest	join_request,
							PSendData				send_data_info);

	void				ProcessConferenceJoinResponsePDU(
							PConferenceJoinResponse	join_response);

	void				ProcessConferenceTerminateRequestPDU(
							PConferenceTerminateRequest	terminate_request,
							PSendData					send_data_info);

	void				ProcessConferenceTerminateResponsePDU(
							PConferenceTerminateResponse
														terminate_response);

	void				ProcessConferenceTerminateIndicationPDU (
							PConferenceTerminateIndication	
													terminate_indication,
							UserID					sender_id);

#ifdef JASPER
	void				ProcessTimeRemainingIndicationPDU (
							PConferenceTimeRemainingIndication	
												time_remaining_indication,
							UserID					sender_id);
#endif // JASPER

#ifdef JASPER
	void				ProcessConferenceAssistanceIndicationPDU(
							PConferenceAssistanceIndication
												conf_assistance_indication,
							UserID					sender_id);
#endif // JASPER

#ifdef JASPER
	void  				ProcessConferenceExtendIndicationPDU(
							PConferenceTimeExtendIndication
												conf_time_extend_indication,
							UserID					sender_id);
#endif // JASPER

	void				ProcessConferenceEjectUserRequestPDU(
							PConferenceEjectUserRequest	
													eject_user_request,
							PSendData				send_data_info);

	void				ProcessConferenceEjectUserResponsePDU(
							PConferenceEjectUserResponse	
													eject_user_request);

	void				ProcessConferenceEjectUserIndicationPDU (
							PConferenceEjectUserIndication	
													eject_user_indication,
							UserID					sender_id);

	void				ProcessRegistryRequestPDU(	
							PGCCPDU					gcc_pdu,
							PSendData				send_data_info);

	void				ProcessRegistryAllocateHandleRequestPDU(
							PRegistryAllocateHandleRequest	
													allocate_handle_request,
							PSendData				send_data_info);

	void				ProcessRegistryAllocateHandleResponsePDU(
							PRegistryAllocateHandleResponse
                        						allocate_handle_response);

	void				ProcessRegistryResponsePDU(	
							PRegistryResponse			registry_response);

	void				ProcessRegistryMonitorIndicationPDU(
							PRegistryMonitorEntryIndication		
														monitor_indication,
							UserID						sender_id);

	void				ProcessTransferRequestPDU (
							PConferenceTransferRequest
											conference_transfer_request,
							PSendData		send_data_info);

#ifdef JASPER
	void				ProcessTransferIndicationPDU (
							PConferenceTransferIndication
											conference_transfer_indication);
#endif // JASPER

#ifdef JASPER
	void				ProcessTransferResponsePDU (
							PConferenceTransferResponse
											conference_transfer_response);
#endif // JASPER

	void				ProcessAddRequestPDU (
							PConferenceAddRequest	conference_add_request,
							PSendData				send_data_info);

	void				ProcessAddResponsePDU (
							PConferenceAddResponse	
												conference_add_response);

	void				ProcessPermissionGrantIndication(
							PConductorPermissionGrantIndication
												permission_grant_indication,
							UserID				sender_id);

	void				ProcessApplicationInvokeIndication(
							PApplicationInvokeIndication	
												invoke_indication,
							UserID				sender_id);

#ifdef JASPER
	GCCError			ProcessTextMessageIndication(
							PTextMessageIndication	text_message_indication,
							UserID					sender_id);
#endif // JASPER

	void				ProcessFunctionNotSupported (
							UINT					request_choice);

    void ProcessTokenGrabConfirm(TokenID, Result);
    void ProcessTokenGiveIndication(TokenID, UserID);
    void ProcessTokenGiveConfirm(TokenID, Result);

#ifdef JASPER
    void ProcessTokenPleaseIndication(TokenID, UserID);
#endif // JASPER

#ifdef JASPER
    void ProcessTokenReleaseConfirm(TokenID, Result);
#endif // JASPER

    void ProcessTokenTestConfirm(TokenID, TokenStatus);

private:

    void                AddToMCSMessageQueue(
                        	PPacket                 packet,
                        	ChannelID				channel_id,
                        	Priority				priority,
                        	BOOL    				uniform_send);

	GCCError			InitiateEjectionFromConference (
      						GCCReason				reason);

	MCSError			JoinUserAndBroadCastChannels();

	MCSError			JoinConvenerChannel();

	BOOL    			AreAllChannelsJoined();

    void ResourceFailureHandler(void);

private:

    CConf                           *m_pConf;

	PIMCSSap 						m_pMCSSap;
	GCCNodeID						m_nidMyself;
	GCCNodeID						m_nidTopProvider;
	GCCNodeID						m_nidParent;

	BOOL    						m_fEjectionPending;
	GCCReason						m_eEjectReason;

	ChannelJoinedFlag				m_ChannelJoinedFlags;
	CConnHandleUidList2             m_ChildUidConnHdlList2;
	COutgoingPDUQueue				m_OutgoingPDUQueue;                
	CConfJoinResponseList2          m_ConfJoinResponseList2;
	CAlarmUidList2                  m_EjectedNodeAlarmList2;
	CUidList    					m_EjectedNodeList;
};
typedef	MCSUser *		PMCSUser;

/*
 *	MCSUser(	UINT        		owner_message_base,
 *				GCCConferenceID		conference_id,
 *				ConferenceNodeType	conference_node_type,
 *				UserID				top_provider,
 *				UserID				parent_user_id,
 *				PGCCError			return_value)
 *
 *	Public Function Description
 *		This is the MCSUser object constructor.  It is responsible for
 *		initializing all the instance variables used by this class.  The
 *		constructor is responsible for establishing the user attachment to
 *		the MCS domain defined by the conference ID.  It also kicks off the
 *		process of joining all the appropriate channels.
 *
 *	Formal Parameters:
 *		conference_id		-	(i)	Conference ID associated with this user also
 *									defines the domain to attach to.	
 *		conference_node_type-	(i)	Internal Node type (see above enumeration).
 *		top_provider		-	(i)	User ID of top provider node. Zero if this
 *									is the top provider.	
 *		parent_user_id		-	(i)	User ID of parent node. Zero if this is the
 *									top provider node.	
 *		return_value		-	(o)	Return value for constructor.
 *
 *	Return Value
 *		GCC_NO_ERROR					-	No error occured.
 *		GCC_FAILURE_ATTACHING_TO_MCS	-	Failure to attach to MCS.
 *
 *  Side Effects
 *		The constructor kicks off a sequence of events that culminates in
 *		a USER_CREATE_CONFIRM message being returned to the owner object.
 *		This includes attaching to MCS and joining all the appropriate channels.
 *
 *	Caveats
 *		None.
 */

/*
 *	~MCSUser ()
 *
 *	Public Function Description
 *		This is the MCSUser object destructor.  It is responsible for freeing
 *		up all the internal data allocated by this object.  It also performs
 *		the detach from GCC and leaves all the appropriate channels.
 *
 *	Formal Parameters:
 *		None.
 *
 *	Return Value
 *		None.
 *
 *  Side Effects
 *		None.
 *
 *	Caveats
 *		None.
 */

/*
 *	void	SendUserIDRequest(
 *						TagNumber			tag_number)
 *
 *	Public Function Description
 *		This routine maps directly to a GCC PDU that delivers the this
 *		nodes user ID to the appropriate node.  The tag number matches the
 *		tag specified by the other node.
 *
 *	Formal Parameters:
 *		tag_number	-	(i)	Tag number that matches the request to the
 *							reponse for the user ID.
 *
 *	Return Value
 *		GCC_NO_ERROR					-	No error occured.
 *		GCC_FAILURE_ATTACHING_TO_MCS	-	Failure to attach to MCS.
 *
 *  Side Effects
 *		None.
 *
 *	Caveats
 *		None.
 */

/*
 *	void		SetChildUserIDAndConnection (
 *						UserID				child_user_id,
 *						ConnectionHandle	child_connection_handle)
 *
 *	Public Function Description
 *		This routine is used to set the child user id associated with a
 *		particular logical connection.  This information is saved by the
 *		MCSUser object in an internal list.  This is typical called after 
 *		receiving a user ID indication back from a child node.
 *
 *	Formal Parameters:
 *		child_user_id			-	(i)	User ID associated with child connection
 *		child_connection_handle	-	(i)	Logical connection assoicated with
 *										specified user id.
 *
 *	Return Value
 *		None.
 *
 *  Side Effects
 *		None.
 *
 *	Caveats
 *		None.
 */

/*
 *	GCCError	ConferenceJoinRequest(
 *					CPassword               *convener_password,
 *					CPassword               *password_challange,
 *					LPWSTR					pwszCallerID,
 *					CUserDataListContainer  *user_data_list,
 *					ConnectionHandle		connection_handle);
 *
 *	Public Function Description:
 *		This function is used to pass a join request on up to the Top Provider.
 *		It is called by a conference at an intermediate node.  This routine is
 *		not used if the joining node is directly connected to the top 
 *		provider.
 *
 *	Formal Parameters:
 *		convener_password	-	(i)	Convener password included with the
 *									original join request.
 *		password_challenge	-	(i)	Password challenge included with the
 *									original join request.
 *		pwszCallerID		-	(i)	Caller ID used in original join request.
 *		user_data_list		-	(i)	User data included in original join
 *									request.
 *		connection_handle	-	(i)	This is the logical connection handle
 *									on which the original join came in.  It is
 *									used here as a tag to match the request
 *									with the response.  
 *
 *	Return Value
 *		GCC_NO_ERROR			-	No error occured.
 *		GCC_ALLOCATION_FAILURE	-	A resource error occured.
 *
 *  Side Effects
 *		None.
 *
 *	Caveats
 *		None.
 */

/*
 *	void		ConferenceJoinResponse(
 *						UserID					receiver_id,
 *						BOOL    				password_is_in_the_clear,
 *						BOOL    				conference_locked,
 *						BOOL    				conference_listed,
 *						GCCTerminationMethod	termination_method,
 *						CPassword               *password_challenge,
 *						CUserDataListContainer  *user_data_list,
 *						GCCResult				result);
 *
 *	Public Function Description:
 *		This routine is used to send a join response back to a node that is
 *		joining through an intermediate nodes.
 *
 *	Formal Parameters:
 *		receiver_id			-	(i)	This is the intermediate node id that made 
 *									the request to the top provider.
 *		password_is_in_the_clear(i)	Flag indicating password in the clear
 *									status of the conference.
 *		conference_locked	-	(i)	Lock state of the conference.
 *		conference_listed	-	(i)	Listed state of the conference.
 *		termination_method	-	(i)	Termination method of the conference.
 *		password_challenge	-	(i)	Password challenge to pass back to the
 *									joining node.
 *		user_data_list		-	(i)	User data to pass back to the joining node.
 *									request.
 *		result				-	(i)	The result of the join request.
 *
 *	Return Value
 *		None.
 *
 *  Side Effects
 *		None.
 *
 *	Caveats
 *		None.
 */

/*
 *	GCCError SendConferenceLockRequest()
 *
 *	Public Function Description:
 *		This routine is used to issue a conference lock request to the
 *		top provider.
 *
 *	Formal Parameters:
 *		None.
 *
 *	Return Value
 *		GCC_NO_ERROR			-	No error occured.
 *		GCC_ALLOCATION_FAILURE	-	A resource error occured.
 *
 *  Side Effects
 *		None.
 *
 *	Caveats
 *		None.
 */

/*
 *	GCCError SendConferenceLockResponse(
 *									UserID		source_node,
 *									GCCResult	result)
 *
 *	Public Function Description:
 *		This routine is used to issue the conference lock response back to the
 *		original requester.
 *
 *	Formal Parameters:
 *		source_node		-	(i)	Node ID of node that made the original request.
 *		result			-	(i)	Result of the lock request.
 *
 *	Return Value
 *		GCC_NO_ERROR			-	No error occured.
 *		GCC_ALLOCATION_FAILURE	-	A resource error occured.
 *
 *  Side Effects
 *		None.
 *
 *	Caveats
 *		None.
 */

/*
 *	GCCError SendConferenceUnlockRequest()
 *
 *	Public Function Description:
 *		This routine is used to issue a conference unlock request to the
 *		top provider.
 *
 *	Formal Parameters:
 *		None.
 *
 *	Return Value
 *		GCC_NO_ERROR			-	No error occured.
 *		GCC_ALLOCATION_FAILURE	-	A resource error occured.
 *
 *  Side Effects
 *		None.
 *
 *	Caveats
 *		None.
 */

/*
 *	GCCError SendConferenceUnlockResponse(
 *									UserID		source_node,
 *									GCCResult	result)
 *
 *	Public Function Description:
 *		This routine is used to issue the conference lock response back to the
 *		original requester.
 *
 *	Formal Parameters:
 *		source_node		-	(i)	Node ID of node that made the original request.
 *		result			-	(i)	Result of the lock request.
 *
 *	Return Value
 *		GCC_NO_ERROR			-	No error occured.
 *		GCC_ALLOCATION_FAILURE	-	A resource error occured.
 *
 *  Side Effects
 *		None.
 *
 *	Caveats
 *		None.
 */

/*
 *	GCCError SendConferenceLockIndication(
 *									BOOL    	uniform_send,
 *									UserID		source_node)
 *
 *	Public Function Description:
 *		This routine is used by the Top Provider to issue a conference lock 
 *		indication to either everyone in the conference or to a specific node.
 *
 *	Formal Parameters:
 *		uniform_send		-	(i)	Flag indicating whether this indication 
 *									should be sent to everyone or to a
 *									specific node (TRUE for everyone).
 *		source_node			-	(i)	Specific node to send it to.  uniform_send
 *									must equal FALSE to use this.
 *
 *	Return Value
 *		GCC_NO_ERROR			-	No error occured.
 *		GCC_ALLOCATION_FAILURE	-	A resource error occured.
 *
 *  Side Effects
 *		None.
 *
 *	Caveats
 *		None.
 */

/*
 *	GCCError SendConferenceUnlockIndication(
 *									BOOL    	uniform_send,
 *									UserID		source_node)
 *
 *	Public Function Description:
 *		This routine is used by the Top Provider to issue a conference unlock 
 *		indication to either everyone in the conference or to a specific node.
 *
 *	Formal Parameters:
 *		uniform_send		-	(i)	Flag indicating whether this indication 
 *									should be sent to everyone or to a
 *									specific node (TRUE for everyone).
 *		source_node			-	(i)	Specific node to send it to.  uniform_send
 *									must equal FALSE to use this.
 *
 *	Return Value
 *		GCC_NO_ERROR			-	No error occured.
 *		GCC_ALLOCATION_FAILURE	-	A resource error occured.
 *
 *  Side Effects
 *		None.
 *
 *	Caveats
 *		None.
 */

/*
 *	void		ConferenceTerminateRequest(
 *						GCCReason				reason)
 *
 *	Public Function Description:
 *		This routine is used by a node subordinate to the top provider to 
 *		request that the conference by terminated.
 *
 *	Formal Parameters:
 *		reason		-	(i)	Reason for the terminate.
 *
 *	Return Value
 *		None.
 *
 *  Side Effects
 *		None.
 *
 *	Caveats
 *		None.
 */

/*
 *	void		ConferenceTerminateResponse (	
 *						UserID					requester_id,
 *						GCCResult				result)
 *
 *	Public Function Description:
 *		This routine is used by the top provider to respond to a terminate
 *		request issued by a subordinate node.  The result indicates if the
 *		requesting node had the correct privileges.
 *
 *	Formal Parameters:
 *		requester_id	-	(i)	Node ID of node to send the response back to.
 *		result			-	(i)	Result of terminate request.
 *
 *	Return Value
 *		None.
 *
 *  Side Effects
 *		None.
 *
 *	Caveats
 *		None.
 */

/*
 *	void		ConferenceTerminateIndication (
 *							GCCReason				reason)
 *
 *	Public Function Description:
 *		This routine is used by the top provider to send out a terminate 
 *		indication to every node in the conference.
 *
 *	Formal Parameters:
 *		reason		-	(i)	Reason for the terminate.
 *
 *	Return Value
 *		None.
 *
 *  Side Effects
 *		None.
 *
 *	Caveats
 *		None.
 */

/*
 *	GCCError	EjectNodeFromConference (	
 *						UserID					ejected_node_id,
 *						GCCReason				reason)
 *
 *	Public Function Description:
 *		This routine is used when attempting to eject a node from the
 *		conference.
 *
 *	Formal Parameters:
 *		ejected_node_id	-	(i)	Node ID of node to eject.
 *		reason			-	(i)	Reason for node being ejected.
 *
 *	Return Value
 *		GCC_NO_ERROR			-	No error occured.
 *		GCC_ALLOCATION_FAILURE	-	A resource error occured.
 *
 *  Side Effects
 *		None.
 *
 *	Caveats
 *		None.
 */

/*
 *	GCCError	SendEjectNodeResponse (	
 *						UserID					requester_id,
 *						UserID					node_to_eject,
 *						GCCResult				result)
 *
 *	Public Function Description:
 *		This routine is used by the top provider to respond to an eject
 *		user request.
 *
 *	Formal Parameters:
 *		requester_id	-	(i)	Node ID of node that requested the eject.
 *		node_to_eject	-	(i)	Node that was requested to eject.
 *		result			-	(i)	Result of the eject request.
 *
 *	Return Value
 *		GCC_NO_ERROR			-	No error occured.
 *		GCC_ALLOCATION_FAILURE	-	A resource error occured.
 *
 *  Side Effects
 *		None.
 *
 *	Caveats
 *		None.
 */

/*
 *	void	RosterUpdateIndication (
 *						PGCCPDU					gcc_pdu,
 *						BOOL    				send_update_upward)
 *
 *	Public Function Description:
 *		This routine is used to forward a roster update indication either
 *		upward to the parent node or downward as a full refresh to all nodes
 *		in the conference.
 *
 *	Formal Parameters:
 *		gcc_pdu				-	(i)	Pointer to the roster update PDU structure 
 *									to send.
 *		send_update_upward	-	(i)	Flag indicating if this indication should
 *									be sent upward to the parent node or
 *									downward to all nodes (TRUE is upward).
 *
 *	Return Value
 *		None.
 *
 *  Side Effects
 *		None.
 *
 *	Caveats
 *		None.
 */

/*
 *	void	RegistryRegisterChannelRequest (
 *						CRegKeyContainer        *registry_key_data,
 *						ChannelID				channel_id,
 *						EntityID				entity_id)
 *
 *	Public Function Description:
 *		This routine is used when an APE wishes to register a channel in
 *		the application registry.
 *
 *	Formal Parameters:
 *		registry_key_data	-	(i)	Registry key associated with the channel
 *									to register.
 *		channel_id			-	(i)	Channel ID to add to the registry.
 *		entity_id			-	(i)	Entity ID associated with the APE that is
 *									registering the channel.
 *
 *	Return Value
 *		None.
 *
 *  Side Effects
 *		None.
 *
 *	Caveats
 *		None.
 */

/*
 *	void	RegistryAssignTokenRequest (
 *						CRegKeyContainer        *registry_key_data,
 *						EntityID				entity_id)
 *
 *	Public Function Description:
 *		This routine is used when an APE wishes to register a token in
 *		the application registry.  Note that there is no token ID included in
 *		this request.  The token ID is allocated at the top provider.
 *
 *	Formal Parameters:
 *		registry_key_data	-	(i)	Registry key associated with the token
 *									to register.
 *		entity_id			-	(i)	Entity ID associated with the APE that is
 *									registering the token.
 *
 *	Return Value
 *		None.
 *
 *  Side Effects
 *		None.
 *
 *	Caveats
 *		None.
 */

/*
 *	void	RegistrySetParameterRequest (
 *						CRegKeyContainer        *registry_key_data,
 *						LPOSTR      			parameter_value,
 *						GCCModificationRights	modification_rights,
 *						EntityID				entity_id);
 *
 *	Public Function Description:
 *		This routine is used when an APE wishes to register a parameter in
 *		the application registry.  Note that parameter to be registered is
 *		included in this request.
 *
 *	Formal Parameters:
 *		registry_key_data	-	(i)	Registry key associated with the parameter
 *									to register.
 *		parameter_value		-	(i)	The parameter string to register.
 *		modification_rights	-	(i)	The modification rights associated with the
 *									parameter being registered.
 *		entity_id			-	(i)	Entity ID associated with the APE that is
 *									registering the parameter.
 *
 *	Return Value
 *		None.
 *
 *  Side Effects
 *		None.
 *
 *	Caveats
 *		None.
 */

/*
 *	void	RegistryRetrieveEntryRequest (
 *						CRegKeyContainer        *registry_key_data,
 *						EntityID				entity_id)
 *
 *	Public Function Description:
 *		This routine is used when an APE wishes to retrieve an registry item
 *		from the registry.
 *
 *	Formal Parameters:
 *		registry_key_data	-	(i)	Registry key associated with the registry
 *									entry to retrieve.
 *		entity_id			-	(i)	Entity ID associated with the APE that is
 *									requesting the registry entry.
 *
 *	Return Value
 *		None.
 *
 *  Side Effects
 *		None.
 *
 *	Caveats
 *		None.
 */

/*
 *	void	RegistryDeleteEntryRequest (
 *						CRegKeyContainer   	    *registry_key_data,
 *						EntityID				entity_id)
 *
 *	Public Function Description:
 *		This routine is used when an APE wishes to delete a registry item
 *		from the registry.
 *
 *	Formal Parameters:
 *		registry_key_data	-	(i)	Registry key associated with the registry
 *									entry to delete.
 *		entity_id			-	(i)	Entity ID associated with the APE that is
 *									making the delete request.
 *
 *	Return Value
 *		None.
 *
 *  Side Effects
 *		None.
 *
 *	Caveats
 *		None.
 */

/*
 *	void	RegistryMonitorRequest (	
 *						CRegKeyContainer        *registry_key_data,
 *						EntityID				entity_id)
 *
 *	Public Function Description:
 *		This routine is used when an APE wishes to monitor a registry item
 *		in the registry.
 *
 *	Formal Parameters:
 *		registry_key_data	-	(i)	Registry key associated with the registry
 *									entry to monitor.
 *		entity_id			-	(i)	Entity ID associated with the APE that is
 *									making the monitor request.
 *
 *	Return Value
 *		None.
 *
 *  Side Effects
 *		None.
 *
 *	Caveats
 *		None.
 */

/*
 *	void	RegistryAllocateHandleRequest ( 	
 *  						USHORT					number_of_handles, 
 *  						EntityID				entity_id )
 *
 *	Public Function Description:
 *		This routine is used when an APE wishes to allocate a number of
 *		handles from the application registry.
 *
 *	Formal Parameters:
 *		number_of_handles	-	(i)	Number of handles to allocate.
 *		entity_id			-	(i)	Entity ID associated with the APE that is
 *									making the request.
 *
 *	Return Value
 *		None.
 *
 *  Side Effects
 *		None.
 *
 *	Caveats
 *		None.
 */

/*
 *	void	RegistryAllocateHandleResponse (
 *						USHORT					number_of_handles,
 *						UINT					registry_handle,
 *						EntityID				requester_entity_id,
 *						UserID					requester_node_id,
 *						GCCResult				result)
 *
 *	Public Function Description:
 *		This routine is used by the Top Provider to respond to an allocate
 *		handle request from an APE at a remote node.  The allocated handles
 *		are passed back here.
 *
 *	Formal Parameters:
 *		number_of_handles	-	(i)	Number of handles allocated.
 *		registry_handle		-	(i)	The first handle in the list of contiguously
 *									allocated handles.
 *		requester_entity_id	-	(i)	Entity ID associated with the APE that made
 *									the request.
 *		requester_node_id	-	(i)	Node ID of node that made the request.
 *		result				-	(i)	Result of the request.
 *
 *	Return Value
 *		None.
 *
 *  Side Effects
 *		None.
 *
 *	Caveats
 *		None.
 */

/*
 *	void	RegistryResponse (
 *						RegistryResponsePrimitiveType	primitive_type,
 *						UserID							requester_owner_id,
 *						EntityID						requester_entity_id,
 *						CRegKeyContainer	            *registry_key_data,
 *						CRegItem                        *registry_item_data,
 *						GCCModificationRights			modification_rights,
 *						UserID							entry_owner_id,
 *						EntityID						entry_entity_id,
 *						GCCResult						result)
 *
 *	Public Function Description:
 *		This routine is used to respond to all the registry request except
 *		allocate handle.  It formulates the response PDU and queues it for
 *		delivery.
 *
 *	Formal Parameters:
 *		primitive_type		-	(i)	This is the type of response being issued.
 *									(i.e. register channel response, register
 *									token response, etc.).
 *		requester_owner_id	-	(i)	Node ID of APE making the original request.
 *		requester_entity_id	-	(i)	Entity ID of APE making the original
 *									request.
 *		registry_key_data	-	(i)	Registry key associated with registry 
 *									entry info being included in the response.
 *		registry_item_data	-	(i)	Registry item data associated with registry 
 *									entry info being included in the response.
 *		modification_rights	-	(i)	Modification rights associated with registry 
 *									entry info being included in the response.
 *		entry_owner_id		-	(i)	Node ID associated with registry entry
 *									info being included in the response.
 *		entry_entity_id		-	(i)	APE Entity ID associated with registry entry
 *									info being included in the response.
 *		result				-	(i)	Result to be sent back in the response.
 *
 *	Return Value
 *		None.
 *
 *  Side Effects
 *		None.
 *
 *	Caveats
 *		None.
 */

/*
 *	void	RegistryMonitorEntryIndication ( 	
 *						CRegKeyContainer                *registry_key_data,
 *						CRegItem                        *registry_item,
 *						UserID							entry_owner_id,
 *						EntityID						entry_entity_id,
 *						GCCModificationRights			modification_rights)
 *
 *	Public Function Description:
 *		This routine is used by the top provider to issue a monitor
 *		indication anytime a registry entry that is being monitored changes.
 *
 *	Formal Parameters:
 *		registry_key_data	-	(i)	Registry key associated with registry 
 *									entry being monitored.
 *		registry_item		-	(i)	Registry item data associated with registry 
 *									entry being monitored.
 *		entry_owner_id		-	(i)	Node ID associated with registry entry
 *									info being monitored.
 *		entry_entity_id		-	(i)	APE Entity ID associated with registry entry
 *									info being monitored.
 *		modification_rights	-	(i)	Modification rights associated with registry 
 *									entry info being monitored.
 *
 *	Return Value
 *		None.
 *
 *  Side Effects
 *		None.
 *
 *	Caveats
 *		None.
 */

/*
 *	GCCError 	AppInvokeIndication(
 *						CInvokeSpecifierListContainer *invoke_specifier_list,
 *						USHORT						number_of_destination_nodes,
 *						UserID			*			list_of_destination_nodes)
 *
 *	Public Function Description:
 *		This routine is used to send an application invoke indication to
 *		every node in the conference.
 *
 *	Formal Parameters:
 *		invoke_specifier_list		-	(i)	List of applications to invoke. 
 *		number_of_destination_nodes	-	(i)	Number of nodes in the destination
 *											node list.
 *		list_of_destination_nodes	-	(i)	List of nodes that should process
 *											invoke indication. 
 *
 *	Return Value
 *		GCC_NO_ERROR			-	No error occured.
 *		GCC_ALLOCATION_FAILURE	-	A resource error occured.
 *
 *  Side Effects
 *		None.
 *
 *	Caveats
 *		None.
 */

/*
 *	GCCError 	TextMessageIndication (
 *						LPWSTR						pwszTextMsg,
 *						UserID						destination_node )
 *
 *	Public Function Description:
 *		This routine is used to send a text message to either a specific node
 *		or to every node in the conference.
 *
 *	Formal Parameters:
 *		pwszTextMsg			-	(i)	Text message string to send.
 *		destination_node	-	(i)	Node to receive the text message.  If zero
 *									the text message is sent to every node in 
 *									the conference.
 *
 *	Return Value
 *		GCC_NO_ERROR			-	No error occured.
 *		GCC_ALLOCATION_FAILURE	-	A resource error occured.
 *
 *  Side Effects
 *		None.
 *
 *	Caveats
 *		None.
 */

/*
 *	GCCError	ConferenceAssistanceIndication (
 *						USHORT						number_of_user_data_members,
 *						PGCCUserData		*		user_data_list)
 *
 *	Public Function Description:
 *		This routine is used to send a conference assistance indication to
 *		every node in the conference.
 *
 *	Formal Parameters:
 *		number_of_user_data_members	-	(i)	Number of entries in the user data
 *											list passed into this routine.
 *		user_data_list				-	(i)	This list holds pointers to the
 *											user data to send out in the
 *											indication.
 *
 *	Return Value
 *		GCC_NO_ERROR			-	No error occured.
 *		GCC_ALLOCATION_FAILURE	-	A resource error occured.
 *
 *  Side Effects
 *		None.
 *
 *	Caveats
 *		None.
 */

/*
 *	GCCError	ConferenceTransferRequest (
 *						PGCCConferenceName		destination_conference_name,
 *						GCCNumericString		destination_conference_modifier,
 *						CNetAddrListContainer   *destination_address_list,
 *						USHORT					number_of_destination_nodes,
 *						PUserID					destination_node_list,
 *						CPassword               *password);
 *
 *	Public Function Description:
 *		This routine is used to send a conference transfer request to the
 *		top provider in the conference.
 *
 *	Formal Parameters:
 *		destination_conference_name	-	(i)	The conference name to transfer to.
 *		destination_conference_modifier (i)	The conference modifier to 
 *											transfer to.
 *		destination_address_list	-	(i)	Network address list used to
 *											determine address of node to 
 *											transfer to.
 *		number_of_destination_nodes	-	(i)	Number of nodes in the list
 *											of nodes that should transfer.
 *		destination_node_list		-	(i)	List of node IDs that should perform
 *											the transfer.
 *		password					-	(i)	Password to use to join the
 *											new conference.
 *
 *	Return Value
 *		GCC_NO_ERROR			-	No error occured.
 *		GCC_ALLOCATION_FAILURE	-	A resource error occured.
 *
 *  Side Effects
 *		None.
 *
 *	Caveats
 *		None.
 */

/*
 *	GCCError	ConferenceTransferIndication (
 *						PGCCConferenceName		destination_conference_name,
 *						GCCNumericString		destination_conference_modifier,
 *						CNetAddrListContainer   *destination_address_list,
 *						USHORT					number_of_destination_nodes,
 *						PUserID					destination_node_list,
 *						CPassword               *password)
 *
 *	Public Function Description:
 *		This routine is used by the top provider to send out the transfer
 *		indication to every node in the conference.  It is each nodes
 *		responsiblity to search the destination node list to see if
 *		it should transfer.
 *
 *	Formal Parameters:
 *		destination_conference_name	-	(i)	The conference name to transfer to.
 *		destination_conference_modifier (i)	The conference modifier to 
 *											transfer to.
 *		destination_address_list	-	(i)	Network address list used to
 *											determine address of node to 
 *											transfer to.
 *		number_of_destination_nodes	-	(i)	Number of nodes in the list
 *											of nodes that should transfer.
 *		destination_node_list		-	(i)	List of node IDs that should perform
 *											the transfer.
 *		password					-	(i)	Password to use to join the
 *											new conference.
 *
 *	Return Value
 *		GCC_NO_ERROR			-	No error occured.
 *		GCC_ALLOCATION_FAILURE	-	A resource error occured.
 *
 *  Side Effects
 *		None.
 *
 *	Caveats
 *		None.
 */

/*
 *	GCCError	ConferenceTransferResponse (
 *						UserID					requesting_node_id,
 *						PGCCConferenceName		destination_conference_name,
 *						GCCNumericString		destination_conference_modifier,
 *						USHORT					number_of_destination_nodes,
 *						PUserID					destination_node_list,
 *						GCCResult				result)
 *																		     
 *
 *	Public Function Description:
 *		This routine is used by the top provider to send back a response to
 *		the node that made a transfer request.  The info specified in the
 *		request is included in the response to match request to response.
 *
 *	Formal Parameters:
 *		requesting_node_id			-	(i)	The node ID of the node that made
 *											the original transfer request.
 *		destination_conference_name	-	(i)	The conference name to transfer to.
 *		destination_conference_modifier (i)	The conference modifier to 
 *											transfer to.
 *		number_of_destination_nodes	-	(i)	Number of nodes in the list
 *											of nodes that should transfer.
 *		destination_node_list		-	(i)	List of node IDs that should perform
 *											the transfer.
 *		result						-	(i)	Result of the transfer request.
 *
 *	Return Value
 *		GCC_NO_ERROR			-	No error occured.
 *		GCC_ALLOCATION_FAILURE	-	A resource error occured.
 *
 *  Side Effects
 *		None.
 *
 *	Caveats
 *		None.
 */

/*
 *	GCCError	ConferenceAddRequest(
 *						TagNumber				conference_add_tag,
 *						UserID					requesting_node,
 *						UserID					adding_node,
 *						UserID					target_node,
 *						CNetAddrListContainer   *network_address_container,
 *						CUserDataListContainer  *user_data_container)
 *																		     
 *
 *	Public Function Description:
 *		This routine is used to send a conference add request to the appropriate
 *		node.  This call can be made by the requesting node or by the top
 *		provider to pass the add request on to the adding node.
 *
 *	Formal Parameters:
 *		conference_add_tag			-	(i)	Tag that is returned in the
 *											response to match request and
 *											response.
 *		requesting_node				-	(i)	Node ID of node that made the
 *											original request.
 *		adding_node					-	(i)	Node ID of node that is to do
 *											the invite request to the new node.
 *		target_node					-	(i)	Node ID of node that this request
 *											should be sent to.
 *		network_address_container	-	(i)	Network address list that can be
 *											used when inviting the new node.
 *		user_data_container			-	(i)	User data to pass on to the
 *											adding node.
 *
 *	Return Value
 *		GCC_NO_ERROR			-	No error occured.
 *		GCC_ALLOCATION_FAILURE	-	A resource error occured.
 *
 *  Side Effects
 *		None.
 *
 *	Caveats
 *		None.
 */

/*
 *	GCCError	ConferenceAddResponse(
 *						TagNumber				add_request_tag,
 *						UserID					requesting_node,
 *						CUserDataListContainer  *user_data_container,
 *						GCCResult				result)
 *																		     
 *	Public Function Description:
 *		This routine is used to send a conference add request to the appropriate
 *		node.  This call can be made by the requesting node or by the top
 *		provider to pass the add request on to the adding node.
 *
 *	Formal Parameters:
 *		add_request_tag		-	(i)	Tag number that was specified in the
 *									original add request.
 *		requesting_node		-	(i)	Node ID of node that made the original 
 *									request.
 *		user_data_container	-	(i)	User data to pass back to the requesting 
 *									node.
 *		result				-	(i)	Final result of the add request.
 *
 *	Return Value
 *		GCC_NO_ERROR			-	No error occured.
 *		GCC_ALLOCATION_FAILURE	-	A resource error occured.
 *
 *  Side Effects
 *		None.
 *
 *	Caveats
 *		None.
 */

/*
 *	GCCError	ConductorTokenGrab();
 *																		     
 *	Public Function Description:
 *		This routine makes the MCS calls to grab the conductor token.
 *
 *	Formal Parameters:
 *		None.
 *
 *	Return Value
 *		GCC_NO_ERROR			-	No error occured.
 *
 *  Side Effects
 *		None.
 *
 *	Caveats
 *		None.
 */

/*
 *	GCCError	ConductorTokenRelease();
 *																		     
 *	Public Function Description:
 *		This routine makes the MCS calls to release the conductor token.
 *
 *	Formal Parameters:
 *		None.
 *
 *	Return Value
 *		GCC_NO_ERROR	-	No error occured.
 *
 *  Side Effects
 *		None.
 *
 *	Caveats
 *		None.
 */

/*
 *	GCCError	ConductorTokenPlease();
 *																		     
 *	Public Function Description:
 *		This routine makes the MCS calls to request the conductor token from
 *		the current conductor.
 *
 *	Formal Parameters:
 *		None.
 *
 *	Return Value
 *		GCC_NO_ERROR	-	No error occured.
 *
 *  Side Effects
 *		None.
 *
 *	Caveats
 *		None.
 */

/*
 *	GCCError	ConductorTokenGive (
 *						UserID					recipient_user_id)
 *																		     
 *	Public Function Description:
 *		This routine makes the MCS calls to give the conductor token to the
 *		specified node.
 *
 *	Formal Parameters:
 *		recipient_user_id	-	(i)	Node ID of node to give the token to.
 *
 *	Return Value
 *		GCC_NO_ERROR	-	No error occured.
 *
 *  Side Effects
 *		None.
 *
 *	Caveats
 *		None.
 */

/*
 *	GCCError	ConductorTokenGiveResponse(
 *  						Result					result)
 *																		     
 *	Public Function Description:
 *		This routine makes the MCS calls to respond to a conductor give
 *		request.
 *
 *	Formal Parameters:
 *		result	-	(i)	Did this node accept the token or not?
 *
 *	Return Value
 *		GCC_NO_ERROR	-	No error occured.
 *
 *  Side Effects
 *		None.
 *
 *	Caveats
 *		None.
 */

/*
 *	GCCError	ConductorTokenTest()
 *																		     
 *	Public Function Description:
 *		This routine is used to test the current state of the conductor token
 *		(is it grabbed or not).
 *
 *	Formal Parameters:
 *		None.
 *
 *	Return Value
 *		GCC_NO_ERROR	-	No error occured.
 *
 *  Side Effects
 *		None.
 *
 *	Caveats
 *		None.
 */

/*
 *	GCCError	SendConductorAssignIndication(
 *  						UserID					conductor_user_id)
 *																		     
 *	Public Function Description:
 *		This routine sends a conductor assign indication to all the
 *		nodes in the conference.
 *
 *	Formal Parameters:
 *		conductor_user_id	-	(i)	The Node ID of the new Conductor.
 *
 *	Return Value
 *		GCC_NO_ERROR			-	No error occured.
 *		GCC_ALLOCATION_FAILURE	-	A resource error occured.
 *
 *  Side Effects
 *		None.
 *
 *	Caveats
 *		None.
 */

/*
 *	GCCError	SendConductorReleaseIndication()
 *																		     
 *	Public Function Description:
 *		This routine sends a conductor release indication to all the
 *		nodes in the conference.
 *
 *	Formal Parameters:
 *		None.
 *
 *	Return Value
 *		GCC_NO_ERROR			-	No error occured.
 *		GCC_ALLOCATION_FAILURE	-	A resource error occured.
 *
 *  Side Effects
 *		None.
 *
 *	Caveats
 *		None.
 */

/*
 *	GCCError	SendConductorPermitAsk (
 *						BOOL    				grant_permission)
 *																		     
 *	Public Function Description:
 *		This routine sends a conductor permission ask request directly to the
 *		conductor node.
 *
 *	Formal Parameters:
 *		grant_permission	-	(i)	The flag indicates if permission is
 *									being requested or given up.
 *
 *	Return Value
 *		GCC_NO_ERROR			-	No error occured.
 *		GCC_ALLOCATION_FAILURE	-	A resource error occured.
 *
 *  Side Effects
 *		None.
 *
 *	Caveats
 *		None.
 */

/*
 *	GCCError	SendConductorPermitGrant (
 *						USHORT					number_granted,
 *						PUserID					granted_node_list,
 *						USHORT					number_waiting,
 *						PUserID					waiting_node_list)
 *																		     
 *	Public Function Description:
 *		This routine sends a conductor permission grant indication to every
 *		node in the conference.  Usually issued when permissions change.
 *
 *	Formal Parameters:
 *		number_granted		-	(i)	Number of nodes in the permission granted 
 *									list.
 *		granted_node_list	-	(i)	List of nodes that have been granted 
 *									permission.
 *		number_waiting		-	(i)	Number of nodes in the list of nodes
 *									waiting to be granted permission.
 *		waiting_node_list	-	(i)	List of nodes waiting. 
 *
 *	Return Value
 *		GCC_NO_ERROR			-	No error occured.
 *		GCC_ALLOCATION_FAILURE	-	A resource error occured.
 *
 *  Side Effects
 *		None.
 *
 *	Caveats
 *		None.
 */

/*
 *	GCCError	TimeRemainingRequest (
 *						UINT					time_remaining,
 *						UserID					node_id)
 *																		     
 *	Public Function Description:
 *		This routine sends out an indication to every node in the
 *		conference informing how much time is remaining in the conference.
 *
 *	Formal Parameters:
 *		time_remaining	-	(i)	Time in seconds left in the conference.
 *		node_id			-	(i)	If a value other than zero, it is which node
 *								to send the time remaining indication to.  If
 *								zero send it to every node in the conference.
 *
 *	Return Value
 *		GCC_NO_ERROR			-	No error occured.
 *		GCC_ALLOCATION_FAILURE	-	A resource error occured.
 *
 *  Side Effects
 *		None.
 *
 *	Caveats
 *		None.
 */

/*
 *	GCCError	TimeInquireRequest (
 *						BOOL    				time_is_conference_wide)
 *																		     
 *	Public Function Description:
 *		This routine sends out a request for a time remaing update.
 *
 *	Formal Parameters:
 *		time_is_conference_wide	-	(i)	Flag indicating if the request is
 *										for the time conference wide.
 *
 *	Return Value
 *		GCC_NO_ERROR			-	No error occured.
 *		GCC_ALLOCATION_FAILURE	-	A resource error occured.
 *
 *  Side Effects
 *		None.
 *
 *	Caveats
 *		None.
 */

/*
 *	GCCError	ConferenceExtendIndication (
 *						UINT					extension_time,
 *						BOOL    				time_is_conference_wide)
 *
 *																		     
 *	Public Function Description:
 *		This routine sends out an indication informing conference participants
 *		of an extension.
 *
 *	Formal Parameters:
 *		extension_time			-	(i)	Amount of time that the conference is
 *										extended.
 *		time_is_conference_wide	-	(i)	Flag indicating if the extension time 
 *										is conference wide.
 *
 *	Return Value
 *		GCC_NO_ERROR			-	No error occured.
 *		GCC_ALLOCATION_FAILURE	-	A resource error occured.
 *
 *  Side Effects
 *		None.
 *
 *	Caveats
 *		None.
 */

/*
 *	ULONG		OwnerCallback (		UINT				message,
 *									PVoid				parameter1,
 *									ULONG				parameter2);
 *
 *	Public Function Description
 *		This function overides the base class function and is used to
 *		receive all owner callback information from the MCS Interface object.
 *
 *	Formal Parameters:
 *		message		-		(i)	Message number including base offset.
 *		parameter1	-		(i)	void pointer of message data.
 *		parameter2	-		(i)	Long holding message data.		
 *
 *	Return Value
 *		GCC_NO_ERROR is always returned from this.
 *
 *  Side Effects
 *		None.
 *
 *	Caveats
 *		None.
 */

/*
 *	BOOL    		FlushOutgoingPDU();
 *
 *	Public Function Description
 *		This function gives the user object a chance to flush all the PDUs
 *		queued up for delivery.  GCC PDUs are only delivered during this call.
 *
 *	Formal Parameters:
 *		None.
 *
 *	Return Value
 *		TRUE, if there remain un-processed msgs in the MCS message queue
 *		FALSE, if all the msgs in the MCS msg queue were processed.
 *
 *  Side Effects
 *		None.
 *
 *	Caveats
 *		None.
 */

/*
 *	GCCNodeID		GetMyNodeID()
 *
 *	Public Function Description
 *		This function returns the Node ID for this node.
 *
 *	Formal Parameters:
 *		None.
 *
 *	Return Value
 *		This nodes Node ID.
 *
 *  Side Effects
 *		None.
 *
 *	Caveats
 *		None.
 */

/*
 *	GCCNodeID		GetTopNodeID ()
 *
 *	Public Function Description
 *		This function returns the Top Provider's Node ID.
 *
 *	Formal Parameters:
 *		None.
 *
 *	Return Value
 *		The Top Providers node ID.
 *
 *  Side Effects
 *		None.
 *
 *	Caveats
 *		None.
 */

/*
 *	GCCNodeID		GetParentNodeID ()
 *
 *	Public Function Description
 *		This function returns the Node ID of this nodes Parent Node.
 *		It returns zero if this is the top provider.
 *
 *	Formal Parameters:
 *		None.
 *
 *	Return Value
 *		The Parent Node ID or zero if Top Provider.
 *
 *  Side Effects
 *		None.
 *
 *	Caveats
 *		None.
 */

/*
 *	UserID		GetUserIDFromConnection(
 *						ConnectionHandle		connection_handle)
 *
 *	Public Function Description
 *		This function returns the Node ID associated with the specified
 *		connection handle.  It returns zero if the connection handle is
 *		not a child connection of this node.
 *
 *	Formal Parameters:
 *		connection_handle	-	(i)	Connection Handle to search on.
 *
 *	Return Value
 *		The Node ID associated with the passed in connection handle or
 *		ZERO if connection is not a child connection.
 *
 *  Side Effects
 *		None.
 *
 *	Caveats
 *		None.
 */

/*
 *	void		UserDisconnectIndication (
 *						UserID					disconnected_user)
 *
 *	Public Function Description
 *		This function informs the user object when a Node disconnects from
 *		the conference.  This gives the user object a chance to clean up
 *		its internal information base.
 *
 *	Formal Parameters:
 *		disconnected_user	-	(i)	User ID of user that disconnected.
 *
 *	Return Value
 *		None.
 *
 *  Side Effects
 *		None.
 *
 *	Caveats
 *		None.
 */

#endif // _MCS_USER_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\remdsk\rds\t120\h\ncmcs.h ===
/*
 *	ncmcs.h
 *
 *	Copyright (c) 1998 by Microsoft Corporation, Redmond, WA
 *
 *	Abstract:
 *		This file defines macros, types, and functions needed to use the Node Controller MCS 
 *		interface.
 *
 *		Basically, the Node Controller (GCC) requests services from MCS by making direct
 *		calls into the DLL (this includes T.122 requests and responses).  MCS
 *		sends information back to the application through a callback (this
 *		includes T.122 indications and confirms).  The callback for the node
 *		controller is specified in the call MCSInitialize.
 *
 *	Author:
 *		Christos Tsollis
 */
#ifndef	_NCMCS_
#define	_NCMCS_

#include "mcspdu.h"

/*
 *	The following structure is used to identify various parameters that apply
 *	only within a given domain.  This information is negotiated between the
 *	first two providers in the domain, and must be accepted by any others
 *	providers that attempt to connect to that domain.
 *
 *	Note that MCS allows up to 4 priorities of data transfer, all of which are
 *	supported by this implementation.
 */
#define	MAXIMUM_PRIORITIES		4
typedef PDUDomainParameters		DomainParameters;
typedef	DomainParameters  *		PDomainParameters;

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\remdsk\rds\t120\h\ogcccode.h ===
/*
 *	ogcccode.h
 *
 *	Copyright (c) 1994 by DataBeam Corporation, Lexington, KY
 *
 *	Abstract:
 *		This is the interface file for the CGCCCoder class.  This
 *		class is used to encode and decode GCC Protocol Data Units (PDU's)
 *		to and from ASN.1 compliant byte streams using the ASN.1 toolkit.
 *
 *	Caveats:
 *		None.
 *
 *	Author:
 *		John B. O'Nan
 *
 */
#ifndef	_CGCCCODER_
#define	_CGCCCODER_

#include "pktcoder.h"
#include "pdutypes.h"
#include "gccpdu.h"

/*
 * Macros
 */
#define		MAXIMUM_PDU_SIZE			512
#define		DECODED_ROSTER_PDU_SIZE		1024

#define		USER_ID_INDICATION				0x61
#define		CONFERENCE_CREATE_REQUEST		0x62
#define		CONFERENCE_CREATE_RESPONSE		0x63
#define		CONFERENCE_QUERY_REQUEST		0x64
#define		CONFERENCE_QUERY_RESPONSE		0x65
#define		CONFERENCE_JOIN_REQUEST			0x66
#define		CONFERENCE_JOIN_RESPONSE		0x67
#define		CONFERENCE_INVITE_REQUEST		0x68
#define		CONFERENCE_INVITE_RESPONSE		0x69
#define		ROSTER_UPDATE_INDICATION		0x7e
#define		MULTIPLE_OCTET_ID	 			0x7f
#define		REGISTER_CHANNEL_REQUEST		0xa0
#define		ASSIGN_TOKEN_REQUEST			0xa1
#define		RETRIEVE_ENTRY_REQUEST			0xa3
#define		DELETE_ENTRY_REQUEST			0xa4
#define		REGISTRY_RESPONSE				0xa9


/*
 *	This is the class definition for class CGCCCoder
 */
class	CGCCCoder : public PacketCoder
{
	public:
						CGCCCoder ();
		        BOOL    Init ( void );
		virtual			~CGCCCoder ();
		virtual	BOOL	Encode (LPVOID			pdu_structure,
								int				pdu_type,
								UINT		 	rules_type,
								LPBYTE			*encoding_buffer,
								UINT			*encoding_buffer_length);

		virtual BOOL	Decode (LPBYTE			encoded_buffer,
								UINT			encoded_buffer_length,
								int				pdu_type,
								UINT			rules_type,
								LPVOID			*decoding_buffer,
								UINT			*decoding_buffer_length);
									
		virtual void	FreeEncoded (LPBYTE encoded_buffer);

		virtual void	FreeDecoded (int pdu_type, LPVOID decoded_buffer);

		virtual BOOL     IsMCSDataPacket (	LPBYTE,	UINT		) 
													{ return FALSE; };

	private:
		BOOL    		IsObjectIDCompliant (PKey	t124_identifier);
		ASN1encoding_t  m_pEncInfo;    // ptr to encoder info
		ASN1decoding_t  m_pDecInfo;    // ptr to decoder info
};
typedef CGCCCoder *		PCGCCCoder;

/*
 *	CGCCCoder ()
 *
 *	Functional Description:
 *		This is the constructor for the CGCCCoder class.
 *
 *	Formal Parameters:
 *		None.
 *
 *	Return Value:
 *		None.
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

/*
 *	~CGCCCoder ()
 *
 *	Functional Description:
 *		This is a virtual destructor.
 *
 *	Formal Parameters:
 *		None.
 *
 *	Return Value:
 *		None.
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

/*
 *	void Encode (	LPVOID		pdu_structure,
 *					int			pdu_type,
 *					UINT		rules_type,
 *					LPBYTE		*encoding_buffer,
 *					UINT		*encoding_buffer_length);
 *
 *	Functional Description:
 *		This function encodes Protocol data units (PDU's) into ASN.1 compliant
 *		byte streams.  The Encode happens into an encoder-allocated buffer.
 *
 *	Formal Parameters:
 *		pdu_structure (i)		Pointer to structure holding PDU data.
 *		pdu_type (i)			Define indicating type of GCC PDU.
 *		rules_type (i)			Type (PER or BER) of encoding rules to use.
 *		encoding_buffer (o)		Indirect pointer to buffer to hold encoded data.
 *		encoding_buffer_length(o)	Pointer that receives the Length of buffer for encoded data.
 *
 *	Return Value:
 *		None.
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

/*
 *	void Decode (	LPBYTE		encoded_buffer,
 *					UINT		encoded_buffer_length,
 *					int			pdu_type,
 *					UINT		rules_type,
 *					LPVOID		decoding_buffer,
 *					UINT		decoding_buffer_length,
 *					PULong);
 *
 *	Functional Description:
 *		This function decodes ASN.1 compliant byte streams into the
 *		appropriate GCC PDU structures.
 *
 *	Formal Parameters:
 *		encoded_buffer (i)		Pointer to buffer holding data to decode.
 *		encoded_buffer_length (i)	Length of buffer holding data to decode.
 *		pdu_type (i)			Define indicating type of GCC PDU.
 *		rules_type (i)			Type (PER or BER) of encoding rules to use.
 *		decoding_buffer (o)		Pointer to buffer to hold the decoded data.
 *		decoding_buffer_length(i)	Length of buffer to hold decoded data.
 *
 *	Return Value:
 *		None.
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

/*
 *	void	CopyDecodedData (	LPVOID	pdu_source_structure,
 *								LPVOID	pdu_destination_structure,
 *								UShort	pdu_type)
 *
 *	Functional Description:
 *		This function makes a complete copy of a decoded PDU structure.
 *
 *	Formal Parameters:
 *		pdu_source_structure (i)	Pointer to buffer holding decoded structure.
 *		pdu_destination_structure (i) Pointer to copy buffer.
 *		pdu_type (i)				Define indicating type of GCC PDU.
 *
 *	Return Value:
 *		None.
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

 /*
 *	BOOL    	IsMCSDataPacket ()
 *
 *	Functional Description:
 *		This function determines whether the encoded packet is an MCS Data packet
 *		or not.
 *
 *	Formal Parameters:
 *		encoded_buffer (i)		Pointer to buffer holding the encoded PDU.
 *		rules_type (i)			The used encoding rules.
 *
 *	Return value:
 *		Always returns FALSE.
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\remdsk\rds\t120\h\objkey.h ===
/*
 *	objkey.h
 *
 *	Copyright (c) 1995 by DataBeam Corporation, Lexington, KY
 *
 *	Abstract:
 *		This is the interface file for the class CObjectKeyContainer.  This class 
 *		manages the data associated with an Object Key.  Object Key are used 
 *		to identify a particular application protocol, whether it is standard or
 *		non-standard.  When used to identify a standard protocol, the Object Key
 *		takes the form of an Object ID which is a series of non-negative 
 *		integers.  This type of Object Key is maintained internally through the
 *		use of a UnicodeString object.  When used to identify a non-standard 
 *		protocol, the Object Key takes the form of an H221 non-standard ID which
 *		is an octet string of no fewer than four octets and no more than 255 
 *		octets.  In this case the Object Key is maintained internally by using a
 *		Rogue Wave string object.
 *
 *	Caveats:
 *		None.
 *
 *	Author:
 *		jbo
 */
#ifndef	_OBJECT_KEY_DATA_
#define	_OBJECT_KEY_DATA_


/*
 * Macros used by this class.
 */
#define 	MINIMUM_OBJECT_ID_ARCS				3
#define 	ITUT_IDENTIFIER						0
#define 	ISO_IDENTIFIER						1
#define 	JOINT_ISO_ITUT_IDENTIFIER			2
#define 	MINIMUM_NON_STANDARD_ID_LENGTH		4
#define 	MAXIMUM_NON_STANDARD_ID_LENGTH		255


/*
 * This is the typedef for the structure used to hold the object key data
 * internally.
 */
typedef struct
{
	LPBYTE						object_id_key;
	UINT						object_id_length;
	LPOSTR						poszNonStandardIDKey;
}
    OBJECT_KEY;

/*
 * Class definition:
 */
class CObjectKeyContainer : public CRefCount
{
public:

	CObjectKeyContainer(PGCCObjectKey, PGCCError);
	CObjectKeyContainer(PKey, PGCCError);
	CObjectKeyContainer(CObjectKeyContainer *, PGCCError);

	~CObjectKeyContainer(void);

	UINT		LockObjectKeyData(void);
	void		UnLockObjectKeyData(void);

	UINT		GetGCCObjectKeyData(PGCCObjectKey, LPBYTE memory);
	GCCError	GetObjectKeyDataPDU(PKey);
	void		FreeObjectKeyDataPDU(void);

	friend BOOL operator== (const CObjectKeyContainer&, const CObjectKeyContainer&);

protected:

	OBJECT_KEY  		m_InternalObjectKey;
	UINT				m_cbDataSize;

	Key					m_ObjectKeyPDU;
	BOOL    			m_fValidObjectKeyPDU;

private:

	BOOL		ValidateObjectIdValues(UINT first_arc, UINT second_arc);
};

/*
 *	Comments explaining the public and protected class member functions
 */

/*
 *	CObjectKeyContainer (	PGCCObjectKey		object_key,
 *					PGCCError			return_value);
 *
 *	Public member function of CObjectKeyContainer.
 *
 *	Function Description:
 *		This is the constructor for the CObjectKeyContainer class which takes as
 *		input the "API" version of object key data, GCCObjectKey.
 *
 *	Formal Parameters:
 *		object_key			(i)	The object key data to store.
 *		return_value		(o)	The output parameter used to indicate errors.
 *
 *	Return Value:
 *		GCC_NO_ERROR					-	No error.
 *		GCC_ALLOCATION_FAILURE			- 	Error creating an object using the
 *												"new" operator.
 *		GCC_BAD_OBJECT_KEY				-	An invalid object key passed in.
 *
 *  Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */


/*
 *	CObjectKeyContainer (		PKey				object_key,
 *						PGCCError			return_value);
 *
 *	Public member function of CObjectKeyContainer.
 *
 *	Function Description:
 *		This is the constructor for the CObjectKeyContainer class which takes as
 *		input the "PDU" version of object key data, Key.
 *
 *	Formal Parameters:
 *		object_key			(i)	The object key data to store.
 *		return_value		(o)	The output parameter used to indicate errors.
 *
 *	Return Value:
 *		GCC_NO_ERROR					-	No error.
 *		GCC_ALLOCATION_FAILURE			- 	Error creating an object using the
 *												"new" operator.
 *
 *  Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */


/*
 *	CObjectKeyContainer (		CObjectKeyContainer		    *object_key,
 *						PGCCError			return_value);
 *
 *	Public member function of CObjectKeyContainer.
 *
 *	Function Description:
 *		This is the copy constructor for the CObjectKeyContainer class which takes
 *		as input another CObjectKeyContainer object.
 *
 *	Formal Parameters:
 *		object_key			(i)	The CObjectKeyContainer object to copy.
 *		return_value		(o)	The output parameter used to indicate errors.
 *
 *	Return Value:
 *		GCC_NO_ERROR					-	No error.
 *		GCC_ALLOCATION_FAILURE			- 	Error creating an object using the
 *												"new" operator.
 *		GCC_BAD_OBJECT_KEY				-	An invalid CObjectKeyContainer passed in.
 *
 *  Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */


/*
 *	~ObjectKeyData();
 *
 *	Public member function of CObjectKeyContainer.
 *
 *	Function Description:
 *		This is the destructor for the CObjectKeyContainer class.  It is used to
 *		clean up any memory allocated during the life of this object.
 *
 *	Formal Parameters:
 *		None.
 *
 *	Return Value:
 *		None.
 *
 *  Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */


/*
 *	UINT			LockObjectKeyData ();
 *
 *	Public member function of CObjectKeyContainer.
 *
 *	Function Description:
 *		This routine is used to "lock" the "API" data for this object.  This
 *		results in the lock count for this object being incremented.  When the
 *		lock count transitions from 0 to 1, a calculation is made to determine
 *		how much memory will be needed to hold any "API" data which will
 *		be referenced by, but not held in, the GCCObjectKey structure
 *		which is filled in on a call to GetGCCObjectKeyData.  This is the
 *		value returned by this routine in order to allow the calling object to
 *		allocate that amount of memory in preparation for the call to 
 *		GetGCCObjectKeyData.
 *
 *	Formal Parameters:
 *		None.
 *
 *	Return Value:
 *		The amount of memory, if any, which will be needed to hold "API" data
 *		which is referenced by, but not held in, the GCCObjectKey structure
 *		provided as an output parameter to the GetGCCObjectKeyData call.
 *
 *  Side Effects:
 *		The internal lock count is incremented.
 *
 *	Caveats:
 *		The internal lock count is used in conjuction with an internal "free" 
 *		flag as a mechanism for ensuring that this object remains in existance 
 *		until all interested parties are through with it.  The object remains 
 *		valid (unless explicity deleted) until the lock count is zero and the 
 *		"free" flag is set through a call to FreeObjectKeyData.  This allows
 *		other objects to lock this object and be sure that it remains valid 
 *		until they call UnLock which will decrement the internal lock count.  A
 *		typical usage scenerio for this object would be:  An CObjectKeyContainer
 *		object is constructed and then passed off to any interested parties
 *		through a function call.  On return from the function call, the
 *		FreeObjectKeyData call is made which will set the internal "free"
 *		flag.  If no other parties have locked the object with a Lock call,
 *		then the CObjectKeyContainer object will automatically delete itself when
 *		the FreeObjectKeyData call is made.  If, however, any number of 
 *		other parties has locked the object, it will remain in existence until
 *		each of them has unlocked the object through a call to UnLock.
 */


/*
 *	UINT			GetGCCObjectKeyData (	
 *							PGCCObjectKey 		object_key,
 *							LPSTR				memory);
 *
 *	Public member function of CObjectKeyContainer.
 *
 *	Function Description:
 *		This routine is used to retrieve the object key data from the
 *		CObjectKeyContainer object in the "API" form of a GCCObjectKey.
 *
 *	Formal Parameters:
 *		object_key			(o)	The GCCObjectKey structure to fill in.
 *		memory				(o)	The memory used to hold any data referenced by,
 *									but not held in, the output structure.
 *
 *	Return Value:
 *		The amount of data, if any, written into the bulk memory block provided.
 *
 *  Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */


/*
 *	void			UnLockObjectKeyData ();
 *
 *	Public member function of CObjectKeyContainer.
 *
 *	Function Description:
 *		This routine is used to "unlock" the "API" data for this object.  This
 *		results in the lock count for this object being decremented.  When the
 *		lock count transitions from 1 to 0, a check is made to determine 
 *		whether the object has been freed through a call to 
 *		FreeObjectKeyData.  If so, the object will automatically delete
 *		itself.
 *
 *	Formal Parameters:
 *		None.
 *
 *	Return Value:
 *		None.
 *
 *  Side Effects:
 *		The internal lock count is decremented.
 *
 *	Caveats:
 *		It is the responsibility of any party which locks an CObjectKeyContainer
 *		object by calling Lock to also unlock the object with a call to UnLock.
 *		If the party calling UnLock did not construct the CObjectKeyContainer 
 *		object,	it should assume the object to be invalid thereafter.
 */


/*
 *	void			FreeObjectKeyData ();
 *
 *	Public member function of CObjectKeyContainer.
 *
 *	Function Description:
 *		This routine is used to "free" the "API" data for this object.  This 
 *		will result in the automatic deletion of this object if the object is
 *		not in the "locked" state.
 *
 *	Formal Parameters:
 *		None.
 *
 *	Return Value:
 *		None.
 *
 *  Side Effects:
 *		The internal "free" flag is set.
 *
 *	Caveats:
 *		This object should be assumed invalid after a call to 
 *		FreeObjectKeyData has been made.
 */


/*
 *	GCCError		GetObjectKeyDataPDU (	
 *							PKey 		object_key);
 *
 *	Public member function of CObjectKeyContainer.
 *
 *	Function Description:
 *		This routine is used to retrieve the object key data from the
 *		CObjectKeyContainer object in the "PDU" form of a Key.
 *
 *	Formal Parameters:
 *		object_key		(o)	The Key structure to fill in.
 *
 *	Return Value:
 *		GCC_NO_ERROR					-	No error.
 *		GCC_ALLOCATION_FAILURE			- 	Error creating an object using the
 *												"new" operator.
 *		GCC_BAD_OBJECT_KEY				-	One of the internal pointers has
 *												been corrupted.
 *
 *  Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */


/*
 *	void		FreeObjectKeyDataPDU ();
 *
 *	Public member function of CObjectKeyContainer.
 *
 *	Function Description:
 *		This routine is used to "free" the "PDU" data allocated for this object
 *		which is held internally in a Key structure.
 *
 *	Formal Parameters:
 *		None.
 *
 *	Return Value:
 *		None.
 *
 *  Side Effects:
 *		The internal flag is set to indicate that the PDU form of data no
 *		longer is valid for this object.
 *
 *	Caveats:
 *		None.
 */


/*
 *	friend BOOL    	operator== (const CObjectKeyContainer& 		object_key_1, 
 *									const CObjectKeyContainer& 		object_key_2);
 *
 *	Public member function of CObjectKeyContainer.
 *
 *	Function Description:
 *		This routine is used to compare two CObjectKeyContainer objects to determine
 *		whether or not they are equal in value.
 *
 *	Formal Parameters:
 *		object_key_1			(i)	The first CObjectKeyContainer object to compare.
 *		object_key_2			(i)	The other CObjectKeyContainer object to compare.
 *
 *	Return Value:
 *		TRUE				-	The two objects are equal in value.
 *		FALSE				- 	The two objects are not equal in value.
 *
 *  Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\remdsk\rds\t120\h\netaddr.h ===
/*
 *	netaddr.h
 *
 *	Copyright (c) 1995 by DataBeam Corporation, Lexington, KY
 *
 *	Abstract:
 *		This is the interface file for the Network Address List class.  This  
 *		class manages the data associated with a network address.  Network
 *		addresses can be one of three types: aggregated channel, transport
 *		connection, or non-standard.  A variety of structures, objects, and
 *		Rogue Wave containers are used to buffer the network address data
 *		internally.
 *
 *	Caveats:
 *		A network address may contain an Object Key if it is a non-standard
 *		type.  When created locally with "API" data, checks are made to ensure
 *		that the constraints imposed upon Object Keys are not violated.  Checks
 *		are also performed to validate certain types of strings which may exist
 *		in a network address.  If however, a network address is created from 
 *		"PDU" data received from a remote site no such validation is performed.
 *		We are taking no responsibility for validation of data originated by
 *		other GCC providers.
 *
 *	Author:
 *		blp/jbo
 */
#ifndef	_NETWORK_ADDRESS_
#define	_NETWORK_ADDRESS_

#include "objkey.h"

/*
 * This structure holds network address information and data.
 */
typedef struct NET_ADDR
{
    NET_ADDR(void);
    ~NET_ADDR(void);

    GCCNetworkAddress	        network_address;
  
	// Variables associated with aggregated channels.
	LPSTR						pszSubAddress;
	LPWSTR						pwszExtraDialing;
    PGCCHighLayerCompatibility	high_layer_compatibility;

    // Variables associated with transport connection addresses.
	LPOSTR						poszTransportSelector;

    // Variables associated with non-standard network addresses.
	LPOSTR						poszNonStandardParam;
	CObjectKeyContainer 	    *object_key;
}
    NET_ADDR;


/*
 * This list is holds the network address information structures.
 */
class CNetAddrList : public CList
{
    DEFINE_CLIST(CNetAddrList, NET_ADDR*)
};


/*
 * Class definition:
 */
class CNetAddrListContainer : public CRefCount
{
public:

	CNetAddrListContainer(UINT cAddrs, PGCCNetworkAddress *, PGCCError);
	CNetAddrListContainer(PSetOfNetworkAddresses, PGCCError);
	CNetAddrListContainer(CNetAddrListContainer *, PGCCError);

    ~CNetAddrListContainer(void);

	UINT		LockNetworkAddressList(void);
	void		UnLockNetworkAddressList(void);

	UINT		GetNetworkAddressListAPI(UINT *pcAddrs, PGCCNetworkAddress **, LPBYTE pMemory);
	GCCError	GetNetworkAddressListPDU(PSetOfNetworkAddresses *);
	GCCError	FreeNetworkAddressListPDU(void);

protected:

	CNetAddrList    		    m_NetAddrItemList;
	UINT						m_cbDataSize;

    PSetOfNetworkAddresses		m_pSetOfNetAddrPDU;
	BOOL						m_fValidNetAddrPDU;

private:

	GCCError	StoreNetworkAddressList(UINT cAddrs, PGCCNetworkAddress *);
	GCCError	ConvertPDUDataToInternal(PSetOfNetworkAddresses);
	GCCError	ConvertNetworkAddressInfoToPDU(NET_ADDR *, PSetOfNetworkAddresses);
    void		ConvertTransferModesToInternal(PTransferModes pSrc, PGCCTransferModes pDst);
	void		ConvertHighLayerCompatibilityToInternal(PHighLayerCompatibility pSrc, PGCCHighLayerCompatibility pDst);
	void		ConvertTransferModesToPDU(PGCCTransferModes pSrc, PTransferModes pDst);
	void		ConvertHighLayerCompatibilityToPDU(PGCCHighLayerCompatibility pSrc,	PHighLayerCompatibility	pDst);

    BOOL		IsDialingStringValid(GCCDialingString);
	BOOL		IsCharacterStringValid(GCCCharacterString);
	BOOL		IsExtraDialingStringValid(PGCCExtraDialingString);
};

/*
 *	Comments explaining the public and protected class member functions
 */

/*
 *	CNetAddrListContainer (
 *		UINT       			number_of_network_addresses,
 *		PGCCNetworkAddress 	*	network_address_list,
 *		PGCCError				return_value);
 *
 *	Public member function of CNetAddrListContainer.
 *
 *	Function Description:
 *		This is the constructor for the CNetAddrListContainer class which takes as
 *		input the "API" version of network address data, GCCNetworkAddress.
 *
 *	Formal Parameters:
 *		number_of_network_addresses	(i) The number of addresses in the list.
 *		network_address_list		(i)	The network address data to store.
 *		return_value		(o)	The output parameter used to indicate errors.
 *
 *	Return Value:
 *		GCC_NO_ERROR					-	No error.
 *		GCC_ALLOCATION_FAILURE			- 	Error creating an object using the
 *												"new" operator.
 *		GCC_BAD_NETWORK_ADDRESS			-	Invalid network address passed in.
 *		GCC_BAD_NETWORK_ADDRESS_TYPE	-	Bad "choice" field for address
 *
 *  Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

/*
 *	CNetAddrListContainer (		
 *			PSetOfNetworkAddresses		network_address_list,
 *			PGCCError					return_value);
 *
 *	Public member function of CNetAddrListContainer.
 *
 *	Function Description:
 *		This is the constructor for the CNetAddrListContainer class which takes as
 *		input the "PDU" version of network address data, SetOfNetworkAddresses.
 *
 *	Formal Parameters:
 *		network_address_list	(i)	The network address data to store.
 *		return_value		(o)	The output parameter used to indicate errors.
 *
 *	Return Value:
 *		GCC_NO_ERROR					-	No error.
 *		GCC_ALLOCATION_FAILURE			- 	Error creating an object using the
 *												"new" operator.
 *
 *  Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

/*
 *	CNetAddrListContainer (		
 *				CNetAddrListContainer		*network_address_list,
 *				PGCCError		return_value);
 *
 *	Public member function of CNetAddrListContainer.
 *
 *	Function Description:
 *		This is the copy constructor for the CNetAddrListContainer class which
 *		takes as input another CNetAddrListContainer object.
 *
 *	Formal Parameters:
 *		network_address_list	(i)	The CNetAddrListContainer object to copy.
 *		return_value		(o)	The output parameter used to indicate errors.
 *
 *	Return Value:
 *		GCC_NO_ERROR					-	No error.
 *		GCC_ALLOCATION_FAILURE			- 	Error creating an object using the
 *												"new" operator.
 *
 *  Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */


/*
 *	~CNetAddrListContainer ();
 *
 *	Public member function of CNetAddrListContainer.
 *
 *	Function Description:
 *		This is the destructor for the CNetAddrListContainer class.  It is used to
 *		clean up any memory allocated during the life of this object.
 *
 *	Formal Parameters:
 *		None.
 *
 *	Return Value:
 *		None.
 *
 *  Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */


/*
 *	UINT	LockNetworkAddressList ();
 *
 *	Public member function of CNetAddrListContainer.
 *
 *	Function Description:
 *		This routine is used to "lock" the "API" data for this object.  This
 *		results in the lock count for this object being incremented.  When the
 *		lock count transitions from 0 to 1, a calculation is made to determine
 *		how much memory will be needed to hold any "API" data which will
 *		be referenced by, but not held in, the list of GCCNetworkAddress 
 *		structures which is filled in on a call to GetNetworkAddressListAPI.  
 *		This is the	value returned by this routine in order to allow the calling
 *		object to allocate that amount of memory in preparation for the call to 
 *		GetNetworkAddressListAPI.
 *
 *	Formal Parameters:
 *		None.
 *
 *	Return Value:
 *		The amount of memory, if any, which will be needed to hold "API" data
 *		which is referenced by, but not held in, the list of GCCNetworkAddress
 *		structures provided as an output parameter to the 
 *		GetNetworkAddressListAPI call.
 *
 *  Side Effects:
 *		The internal lock count is incremented.
 *
 *	Caveats:
 *		The internal lock count is used in conjuction with an internal "free" 
 *		flag as a mechanism for ensuring that this object remains in existance 
 *		until all interested parties are through with it.  The object remains 
 *		valid (unless explicity deleted) until the lock count is zero and the 
 *		"free" flag is set through a call to FreeNetworkAddressList. This allows
 *		other objects to lock this object and be sure that it remains valid 
 *		until they call UnLock which will decrement the internal lock count.  A
 *		typical usage scenerio for this object would be:  A CNetAddrListContainer
 *		object is constructed and then passed off to any interested parties
 *		through a function call.  On return from the function call, the
 *		FreeNetworkAddressList call is made which will set the internal "free"
 *		flag.  If no other parties have locked the object with a Lock call,
 *		then the CNetAddrListContainer object will automatically delete itself when
 *		the FreeNetworkAddressList call is made.  If, however, any number of 
 *		other parties has locked the object, it will remain in existence until
 *		each of them has unlocked the object through a call to UnLock.
 */

/*
 *	UINT			GetNetworkAddressListAPI (	
 *							UINT *			number_of_network_addresses,
 *							PGCCNetworkAddress	**	network_address_list,
 *							LPSTR					memory);
 *
 *	Public member function of CNetAddrListContainer.
 *
 *	Function Description:
 *		This routine is used to retrieve the network address data from the
 *		CNetAddrListContainer object in the "API" form of a list of 
 *		GCCNetworkAddress structures.
 *
 *	Formal Parameters:
 *		number_of_network_addresses	(o) Number of addresses in returned list.
 *		network_address_list		(o)	The pointer to the list of
 *											GCCNetworkAddress structures 
 *											to fill in.
 *		memory						(o)	The memory used to hold any data 
 *											referenced by, but not held in, the 
 *											list of output structures.
 *
 *	Return Value:
 *		The amount of data, if any, written into the bulk memory block provided.
 *
 *  Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */


/*
 *	void		UnLockNetworkAddressList ();
 *
 *	Public member function of CNetAddrListContainer.
 *
 *	Function Description:
 *		This routine is used to "unlock" the "API" data for this object.  This
 *		results in the lock count for this object being decremented.  When the
 *		lock count transitions from 1 to 0, a check is made to determine 
 *		whether the object has been freed through a call to 
 *		FreeNetworkAddressList.  If so, the object will automatically delete
 *		itself.
 *
 *	Formal Parameters:
 *		None.
 *
 *	Return Value:
 *		None.
 *
 *  Side Effects:
 *		The internal lock count is decremented.
 *
 *	Caveats:
 *		It is the responsibility of any party which locks a CNetAddrListContainer
 *		object by calling Lock to also unlock the object with a call to UnLock.
 *		If the party calling UnLock did not construct the CNetAddrListContainer 
 *		object,	it should assume the object to be invalid thereafter.
 */


/*
 *	GCCError		GetNetworkAddressListPDU (	
 *						PSetOfNetworkAddresses	*	set_of_network_addresses);
 *
 *	Public member function of CNetAddrListContainer.
 *
 *	Function Description:
 *		This routine is used to retrieve the network address data from the
 *		CNetAddrListContainer object in the "PDU" form of a SetOfNetworkAddresses.
 *
 *	Formal Parameters:
 *		set_of_network_addresses	(o)	The address structure to fill in.
 *
 *	Return Value:
 *		GCC_NO_ERROR					-	No error.
 *		GCC_ALLOCATION_FAILURE			- 	Error creating an object using the
 *												"new" operator.
 *
 *  Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */


/*
 *	GCCError		FreeNetworkAddressListPDU ();
 *
 *	Public member function of CNetAddrListContainer.
 *
 *	Function Description:
 *		This routine is used to "free" the "PDU" data allocated for this object
 *		which is held internally in a SetOfNetworkAddresses structure.
 *
 *	Formal Parameters:
 *		None.
 *
 *	Return Value:
 *		GCC_NO_ERROR					-	No error.
 *
 *  Side Effects:
 *		The internal "free" flag is set.
 *
 *	Caveats:
 *		This object should be assumed invalid after a call to 
 *		FreeNetworkAddressListPDU has been made.
 */

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\remdsk\rds\t120\h\omcscode.h ===
/*
 *	omcscode.h
 *
 *	Copyright (c) 1993 - 1995 by DataBeam Corporation, Lexington, KY
 *
 *	Abstract:
 *		This is the interface file for the CMCSCoder class.  This
 *		class is used to encode and decode MCS Protocol Data Units (PDU's)
 *		to and from ASN.1 compliant byte streams using the ASN.1 toolkit.
 *
 *	Caveats:
 *		None.
 *
 *	Author:
 *		John B. O'Nan
 *
 */
#ifndef	_CMCSCODER_
#define	_CMCSCODER_

#include "pktcoder.h"
#include "mcspdu.h"

/*
 * Macros
 */
#define		PLUMB_DOMAIN_INDICATION	 		0x60
#define		ERECT_DOMAIN_REQUEST		 	0x61
#define		MERGE_CHANNELS_REQUEST	 		0x62
#define		MERGE_CHANNELS_CONFIRM		 	0x63
#define		PURGE_CHANNEL_INDICATION		0x64
#define		MERGE_TOKENS_REQUEST	 		0x65
#define		MERGE_TOKENS_CONFIRM		 	0x66
#define		PURGE_TOKEN_INDICATION		 	0x67
#define		DISCONNECT_PROVIDER_ULTIMATUM	0x68
#define		REJECT_ULTIMATUM			 	0x69
#define		ATTACH_USER_REQUEST		 		0x6a
#define		ATTACH_USER_CONFIRM		 		0x6b
#define		DETACH_USER_REQUEST		 		0x6c
#define		DETACH_USER_INDICATION		 	0x6d
#define		CHANNEL_JOIN_REQUEST		 	0x6e
#define		CHANNEL_JOIN_CONFIRM		 	0x6f
#define		CHANNEL_LEAVE_REQUEST		 	0x70
#define		CHANNEL_CONVENE_REQUEST		 	0x71
#define		CHANNEL_CONVENE_CONFIRM		 	0x72
#define		CHANNEL_DISBAND_REQUEST		 	0x73
#define		CHANNEL_DISBAND_INDICATION		0x74
#define		CHANNEL_ADMIT_REQUEST		 	0x75
#define		CHANNEL_ADMIT_INDICATION		0x76
#define		CHANNEL_EXPEL_REQUEST		 	0x77
#define		CHANNEL_EXPEL_INDICATION		0x78
#define		SEND_DATA_REQUEST		 		0x79
#define		SEND_DATA_INDICATION		 	0x7a
#define		UNIFORM_SEND_DATA_REQUEST		0x7b
#define		UNIFORM_SEND_DATA_INDICATION	0x7c
#define		TOKEN_GRAB_REQUEST		 		0x7d
#define		TOKEN_GRAB_CONFIRM		 		0x7e
#define		MULTIPLE_OCTET_ID	 			0x7f
#define		TOKEN_INHIBIT_REQUEST			0x1f
#define		TOKEN_INHIBIT_CONFIRM			0x20
#define		TOKEN_GIVE_REQUEST				0x21
#define		TOKEN_GIVE_INDICATION			0x22
#define		TOKEN_GIVE_RESPONSE				0x23
#define		TOKEN_GIVE_CONFIRM				0x24
#define		TOKEN_PLEASE_REQUEST			0x25
#define		TOKEN_PLEASE_INDICATION			0x26
#define		TOKEN_RELEASE_REQUEST			0x27
#define		TOKEN_RELEASE_CONFIRM			0x28
#define		TOKEN_TEST_REQUEST				0x29
#define		TOKEN_TEST_CONFIRM				0x2a
#define		CONNECT_INITIAL				 	0x65
#define		CONNECT_RESPONSE				0x66
#define		CONNECT_ADDITIONAL				0x67
#define		CONNECT_RESULT				 	0x68

#define		HIGHEST_BER_SEND_DATA_OVERHEAD		25
#define		LOWEST_BER_SEND_DATA_OVERHEAD		19		
#define		HIGHEST_PER_SEND_DATA_OVERHEAD		9
#define		LOWEST_PER_SEND_DATA_OVERHEAD		7

#define		PER_SEND_DATA_REQUEST				0x64
#define		PER_SEND_DATA_INDICATION			0x68
#define		PER_UNIFORM_SEND_DATA_REQUEST		0x6c
#define		PER_UNIFORM_SEND_DATA_INDICATION	0x70

#define		INITIATOR_LOWER_BOUND				1001

/*
 *	This is the class definition for class CMCSCoder
 */
class	CMCSCoder : public PacketCoder
{
	public:
						CMCSCoder ();
		        BOOL    Init ( void );
		virtual			~CMCSCoder ();
		virtual	BOOL	Encode (LPVOID			pdu_structure,
								int				pdu_type,
								UINT			rules_type,
								LPBYTE			*encoding_buffer,
								UINT			*encoding_buffer_length);

		virtual BOOL	Decode (LPBYTE			encoded_buffer,
								UINT			encoded_buffer_length,
								int				pdu_type,
								UINT			rules_type,
								LPVOID			*pdecoding_buffer,
								UINT			*pdecoding_buffer_length);

		Void			ReverseDirection (LPBYTE		encoded_buffer);
											
		virtual DBBoolean IsMCSDataPacket (	LPBYTE		 encoded_buffer,
											UINT		 rules_type);
		virtual void	FreeEncoded (LPBYTE encoded_buffer);

		virtual void	FreeDecoded (int pdu_type, LPVOID decoded_buffer);

	private:
		void SetEncodingRules				(UINT			rules_type); 
												 
		UINT					Encoding_Rules_Type;
		ASN1encoding_t  m_pEncInfo;    // ptr to encoder info
		ASN1decoding_t  m_pDecInfo;    // ptr to decoder info
};
typedef CMCSCoder *		PCMCSCoder;

/*
 *	CMCSCoder ()
 *
 *	Functional Description:
 *		This is the constructor for the CMCSCoder class.  It initializes the
 *		ASN.1 toolkit and sets the type of encoding rules to Basic Encoding
 *		Rules (BER).  It also initializes some private instance variables.
 *
 *	Formal Parameters:
 *		None.
 *
 *	Return Value:
 *		None.
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

/*
 *	~CMCSCoder ()
 *
 *	Functional Description:
 *		This is a virtual destructor.  It cleans up after the ASN.1 toolkit.
 *
 *	Formal Parameters:
 *		None.
 *
 *	Return Value:
 *		None.
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

/*
 *	void Encode (	LPVOID		pdu_structure,
 *					int			pdu_type,
 *					UINT		 rules_type,
 *					LPBYTE		*encoding_buffer,
 *					UINT		*encoding_buffer_length)
 *
 *	Functional Description:
 *		This function encodes Protocol data units (PDU's) into ASN.1 compliant
 *		byte streams.
 *		The coder allocates the buffer space for the encoded data.
 *
 *	Formal Parameters:
 *		pdu_structure (i)		Pointer to structure holding PDU data.
 *		pdu_type (i)			Define indicating Connect or Domain MCS PDU.
 *		rules_type (i)			Type of encoding rules (BER or PER).
 *		encoding_buffer (o)		Pointer to buffer to hold encoded data.
 *		encoding_buffer_length (o) Length of encoded data.
 *
 *	Return Value:
 *		None.
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

/*
 *	void Decode (	LPBYTE		encoded_buffer,
 *					UINT		encoded_buffer_length,
 *					int			pdu_type,
 *					UINT		rules_type,
 *					LPVOID		decoding_buffer,
 *					UINT		decoding_buffer_length,
 *					UINT		*pulDataOffset)
 *
 *	Functional Description:
 *		This function decodes ASN.1 compliant byte streams into the
 *		appropriate MCS PDU structures.
 *
 *	Formal Parameters:
 *		encoded_buffer (i)		Pointer to buffer holding data to decode.
 *		encoded_buffer_length(i) Length of buffer holding encoded data.
 *		pdu_type (i)			Type (Domain or Connect) of MCS PDU.
 *		rules_type (i)			Type of encoding rules (BER or PER).
 *		decoding_buffer (o)		Pointer to buffer to hold the decoded data.
 *		decoding_buffer_length (i) Length of buffer to hold decoded data.
 *		pulDataOffset (o)		Pointer to a value that stores the offset of the data in an encoded MCS data packet.
 *
 *	Return Value:
 *		None.
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

/*
 *	void	CopyDecodedData (	LPVOID	pdu_source_structure,
 *								LPVOID	pdu_destination_structure,
 *								UINT		 pdu_type)
 *
 *	Functional Description:
 *		This function makes a complete copy of a decoded PDU structure.
 *
 *	Formal Parameters:
 *		pdu_source_structure (i)	Pointer to buffer holding decoded structure.
 *		pdu_destination_structure (i) Pointer to copy buffer.
 *		pdu_type (i) 				Type (Domain or Connect) of PDU.
 *
 *	Return Value:
 *		None.
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

/*
 *	Void ReverseDirection (LPBYTE	encoded_buffer)
 *
 *	Functional Description:
 *		This function alters the identifier of encoded "Send Data" PDU's in 
 * 		order to change back and forth between data requests and indications.
 *
 *	Formal Parameters:
 *		encoded_buffer (i)		Pointer to buffer holding encoded data.
 *
 *	Return Value:
 *		None.
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

 /*
 *	DBBoolean	IsMCSDataPacket ()
 *
 *	Functional Description:
 *		This function determines whether the encoded packet is an MCS Data packet
 *		or not.
 *
 *	Formal Parameters:
 *		encoded_buffer (i)		Pointer to buffer holding the encoded PDU.
 *		rules_type (i)			The used encoding rules.
 *
 *	Return value:
 *		TRUE, if the packet is an MCS Data packet. FALSE, otherwise.
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\remdsk\rds\t120\h\password.h ===
/*
 *	password.h
 *
 *	Copyright (c) 1995 by DataBeam Corporation, Lexington, KY
 *
 *	Abstract:
 *		This is the interface file for the class CPassword.  This class
 *		manages the data associated with a Password.  Passwords are used to 
 *		restrict access to conferences.  A password can be one of two basic
 *		types.  The simple type consists of either a simple numeric password or
 *		a simple textual password, or both.  The "PDU" type "Password" is a
 *		structure which must contain the numeric form of the password and may
 *		optionally contain the textual part as well.  The "PDU" type
 *		"PasswordSelector" is a union of the numeric and textual forms of a
 *		password and is therefore always one or the other but not both.  When
 *		the password is not the simple type it assumes the form of a
 *		"PasswordChallengeRequestResponse".  This complex structure allows a
 *		challenge-response scheme to be used to control access to conferences.
 *
 *	Caveats:
 *		None.
 *
 *	Author:
 *		blp/jbo
 */
#ifndef	_PASSWORD_DATA_
#define	_PASSWORD_DATA_

#include "userdata.h"

class CPassword;

/*
 * This is the typedef for the structure used to maintain the challenge 
 * response algorithms internally.
 */
typedef struct
{
	GCCPasswordAlgorithmType	algorithm_type;
	CObjectKeyContainer 	    *object_key;
	LPOSTR						poszOctetString;
} ResponseAlgorithmInfo;
typedef	ResponseAlgorithmInfo * 	PResponseAlgorithmInfo;

/*
 * This is the typedef for the structure used to maintain the challenge items 
 * associated with a challenge request.
 */
typedef struct
{
	ResponseAlgorithmInfo		algorithm;
	CUserDataListContainer      *challenge_data_list;
} ChallengeItemInfo;
typedef	ChallengeItemInfo * 	PChallengeItemInfo;

/*
 * This is the typedef for the structure used to maintain the memory used 
 * to hold the user data and object key data associated with a challenge 
 * request item.
 */
typedef struct
{
	LPBYTE						user_data_list_memory;
	LPBYTE						object_key_memory;
} ChallengeItemMemoryInfo;
typedef	ChallengeItemMemoryInfo * 	PChallengeItemMemoryInfo;

/*
 * This is the typedef for the structure used to maintain the 
 * challenge-reponse items internally.
 */
typedef struct
{
	CPassword                   *password;
	CUserDataListContainer	    *response_data_list;
} ChallengeResponseItemInfo;
typedef	ChallengeResponseItemInfo * 	PChallengeResponseItemInfo;

/*
 * The set of challenge items is maintained internally in a linked List.
 */
class CChallengeItemList : public CList
{
    DEFINE_CLIST(CChallengeItemList, PChallengeItemInfo)
};

/*
 * The memory associated with each challenge item is maintained internally in 
 * linked List.
 */
class CChallengeItemMemoryList : public CList
{
    DEFINE_CLIST(CChallengeItemMemoryList, PChallengeItemMemoryInfo)
};

/*
 * This is the typedef for the structure used to maintain the "Request" 
 * data internally.
 */
typedef struct
{
	GCCResponseTag				challenge_tag;
	CChallengeItemList			ChallengeItemList;
}
    RequestInfo, *PRequestInfo;

/*
 * This is the typedef for the structure used to maintain the "Response" 
 * data internally.
 */
typedef struct
{
	GCCResponseTag						challenge_tag;
	ResponseAlgorithmInfo				algorithm;
	ChallengeResponseItemInfo			challenge_response_item;
}
    ResponseInfo, *PResponseInfo;

/*
 * Class definition:
 */
class CPassword : public CRefCount
{
public:

	CPassword(PGCCPassword, PGCCError);
	CPassword(PGCCChallengeRequestResponse, PGCCError);
	CPassword(PPassword, PGCCError);
	CPassword(PPasswordSelector, PGCCError);
	CPassword(PPasswordChallengeRequestResponse, PGCCError);

    ~CPassword(void);

	GCCError	LockPasswordData(void);
	void		UnLockPasswordData(void);
	GCCError	GetPasswordData(PGCCPassword *);
	GCCError	GetPasswordChallengeData(PGCCChallengeRequestResponse *);
	GCCError	GetPasswordPDU(PPassword);
	GCCError	GetPasswordSelectorPDU(PPasswordSelector);
	GCCError	GetPasswordChallengeResponsePDU(PPasswordChallengeRequestResponse);
	void		FreePasswordChallengeResponsePDU(void);

protected:

    BOOL							m_fSimplePassword;
    BOOL							m_fClearPassword;

    /*
     * Variables and structures used to hold the password data internally.
     */
    LPSTR							m_pszNumeric;
    LPWSTR							m_pwszText;
    PRequestInfo					m_pInternalRequest;
    PResponseInfo					m_pInternalResponse;

    /*
     * Structures used to hold the password data in "API" form.
     */
    PGCCChallengeRequestResponse	m_pChallengeResponse;
    PGCCPassword					m_pPassword;
    LPBYTE							m_pUserDataMemory;
    LPBYTE							m_pChallengeItemListMemory;
    LPBYTE							m_pObjectKeyMemory;
    CChallengeItemMemoryList		m_ChallengeItemMemoryList;

    /*
     * Structure used to hold the password data in "PDU" form.
     */
    PasswordChallengeRequestResponse		m_ChallengeResponsePDU;
    BOOL									m_fValidChallengeResponsePDU;

private:

	GCCError	ConvertAPIChallengeRequest(PGCCChallengeRequest);
	GCCError	ConvertAPIChallengeResponse(PGCCChallengeResponse);
	GCCError	CopyResponseAlgorithm(PGCCChallengeResponseAlgorithm, PResponseAlgorithmInfo);
	GCCError	ConvertPDUChallengeRequest(PChallengeRequest);
	GCCError	ConvertPDUChallengeItem(PChallengeItem);
	GCCError	ConvertPDUChallengeResponse(PChallengeResponse);
	GCCError	ConvertPDUResponseAlgorithm(PChallengeResponseAlgorithm, PResponseAlgorithmInfo);
	GCCError	GetGCCChallengeRequest(PGCCChallengeRequest);
	GCCError	GetGCCChallengeResponse(PGCCChallengeResponse);
	GCCError	GetChallengeRequestPDU(PChallengeRequest);
	GCCError	ConvertInternalChallengeItemToPDU(PChallengeItemInfo, PChallengeItem);
	GCCError	GetChallengeResponsePDU(PChallengeResponse);
	void		FreeChallengeRequestPDU(void);
	void		FreeChallengeResponsePDU(void);
    void		FreeAPIPasswordData(void);
};

/*
 *	Comments explaining the public and protected class member functions
 */

/*
 *	CPassword (	PGCCPassword		password,
 *					PGCCError			return_value);
 *
 *	Public member function of CPassword.
 *
 *	Function Description:
 *		This is the constructor for the CPassword class which takes as
 *		input the "API" version of password data, GCCPassword.
 *
 *	Formal Parameters:
 *		password			(i)	The password data to store.
 *		return_value		(o)	The output parameter used to indicate errors.
 *
 *	Return Value:
 *		GCC_NO_ERROR					-	No error.
 *		GCC_ALLOCATION_FAILURE			- 	Error creating an object using the
 *												"new" operator.
 *		GCC_INVALID_PASSWORD			-	An invalid password passed in.
 *
 *  Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

/*
 *	CPassword ( 	PGCCChallengeRequestResponse		challenge_response_data,
 *					PGCCError							return_value)
 *
 *	Public member function of CPassword.
 *
 *	Function Description:
 *		This is the constructor for the CPassword class which takes as
 *		input the "API" version of password challenge data, 
 *		GCCChallengeRequestResponse.
 *
 *	Formal Parameters:
 *		challenge_response_data	(i)	The password challenge data to store.
 *		return_value		(o)	The output parameter used to indicate errors.
 *
 *	Return Value:
 *		GCC_NO_ERROR					-	No error.
 *		GCC_ALLOCATION_FAILURE			- 	Error creating an object using the
 *												"new" operator.
 *		GCC_INVALID_PASSWORD			-	An invalid password passed in.
 *
 *  Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */
/*
 *	CPassword ( 	PPassword				password_pdu,
 *					PGCCError				return_value)
 *
 *	Public member function of CPassword.
 *
 *	Function Description:
 *		This is the constructor for the CPassword class which takes as
 *		input the "PDU" version of password data, Password.
 *
 *	Formal Parameters:
 *		password_pdu		(i)	The password data to store.
 *		return_value		(o)	The output parameter used to indicate errors.
 *
 *	Return Value:
 *		GCC_NO_ERROR					-	No error.
 *		GCC_ALLOCATION_FAILURE			- 	Error creating an object using the
 *												"new" operator.
 *		GCC_INVALID_PASSWORD			-	An invalid password passed in.
 *
 *  Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */
/*
 *	CPassword(	PPasswordSelector			password_selector_pdu,
 *					PGCCError					return_value)
 *
 *	Public member function of CPassword.
 *
 *	Function Description:
 *		This is the constructor for the CPassword class which takes as
 *		input the "PDU" version of password data, PasswordSelector.
 *
 *	Formal Parameters:
 *		password_selector_pdu	(i)	The password selector data to store.
 *		return_value		(o)	The output parameter used to indicate errors.
 *
 *	Return Value:
 *		GCC_NO_ERROR					-	No error.
 *		GCC_ALLOCATION_FAILURE			- 	Error creating an object using the
 *												"new" operator.
 *		GCC_INVALID_PASSWORD			-	An invalid password passed in.
 *
 *  Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */
/*
 *	CPassword (	PPasswordChallengeRequestResponse	pdu_challenge_data,
 *					PGCCError							return_value)
 *
 *	Public member function of CPassword.
 *
 *	Function Description:
 *		This is the constructor for the CPassword class which takes as
 *		input the "PDU" version of password challenge data, 
 *		PasswordChallengeRequestResponse.
 *
 *	Formal Parameters:
 *		pdu_challenge_data	(i)	The password challenge data to store.
 *		return_value		(o)	The output parameter used to indicate errors.
 *
 *	Return Value:
 *		GCC_NO_ERROR					-	No error.
 *		GCC_ALLOCATION_FAILURE			- 	Error creating an object using the
 *												"new" operator.
 *		GCC_INVALID_PASSWORD			-	An invalid password passed in.
 *
 *  Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */


/*
 *	~CPassword();
 *
 *	Public member function of CPassword.
 *
 *	Function Description:
 *		This is the destructor for the CPassword class.  It is used to
 *		clean up any memory allocated during the life of this object.
 *
 *	Formal Parameters:
 *		None.
 *
 *	Return Value:
 *		None.
 *
 *  Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */


/*
 *	GCCError	LockPasswordData ();
 *
 *	Public member function of CPassword.
 *
 *	Function Description:
 *		This routine is used to "lock" the "API" data for this object.  This
 *		results in the appropriate form of the "API" password being stored
 *		internally in preparation for a call to "GetGCCPasswordData" which will
 *		return that data.  
 *
 *	Formal Parameters:
 *		None.
 *
 *	Return Value:
 *		GCC_NO_ERROR					-	No error.
 *		GCC_ALLOCATION_FAILURE			- 	Error creating an object using the
 *												"new" operator.
 *
 *  Side Effects:
 *		The internal lock count is incremented.
 *
 *	Caveats:
 *		The internal lock count is used in conjuction with an internal "free" 
 *		flag as a mechanism for ensuring that this object remains in existance 
 *		until all interested parties are through with it.  The object remains 
 *		valid (unless explicity deleted) until the lock count is zero and the 
 *		"free" flag is set through a call to FreePasswordData.  This allows
 *		other objects to lock this object and be sure that it remains valid 
 *		until they call UnLock which will decrement the internal lock count.  A
 *		typical usage scenerio for this object would be:  A CPassword
 *		object is constructed and then passed off to any interested parties
 *		through a function call.  On return from the function call, the
 *		FreePasswordData call is made which will set the internal "free"
 *		flag.  If no other parties have locked the object with a Lock call,
 *		then the CPassword object will automatically delete itself when
 *		the FreePasswordData call is made.  If, however, any number of 
 *		other parties has locked the object, it will remain in existence until
 *		each of them has unlocked the object through a call to UnLock.
 */


/*
 *	GCCError	GetPasswordData (	PGCCPassword	 *	gcc_password)
 *
 *	Public member function of CPassword.
 *
 *	Function Description:
 *		This routine is used to retrieve the password data from the
 *		CPassword object in the "API" form of a GCCPassword.
 *
 *	Formal Parameters:
 *		gcc_password			(o)	The GCCPassword structure to fill in.
 *
 *	Return Value:
 *		GCC_NO_ERROR					-	No error.
 *		GCC_ALLOCATION_FAILURE			- 	The object was not properly locked
 *												prior to this call.
 *
 *  Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */


/*
 *	GCCError	GetPasswordChallengeData (
 *					PGCCChallengeRequestResponse	 *	gcc_challenge_password)
 *
 *	Public member function of CPassword.
 *
 *	Function Description:
 *		This routine is used to retrieve the password challenge data from the
 *		CPassword object in the "API" form of a GCCChallengeRequestResponse.
 *
 *	Formal Parameters:
 *		gcc_challenge_password		(o)	The GCCChallengeRequestResponse 
 *											structure to fill in.
 *
 *	Return Value:
 *		GCC_NO_ERROR					-	No error.
 *		GCC_ALLOCATION_FAILURE			- 	The object was not properly locked
 *												prior to this call.
 *
 *  Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */


/*
 *	void	UnLockPasswordData ();
 *
 *	Public member function of CPassword.
 *
 *	Function Description:
 *		This routine is used to "unlock" the "API" data for this object.  This
 *		results in the lock count for this object being decremented.  When the
 *		lock count transitions from 1 to 0, a check is made to determine 
 *		whether the object has been freed through a call to FreePasswordData.
 *		If so, the object will automatically delete	itself.
 *
 *	Formal Parameters:
 *		None.
 *
 *	Return Value:
 *		None.
 *
 *  Side Effects:
 *		The internal lock count is decremented.
 *
 *	Caveats:
 *		It is the responsibility of any party which locks a CPassword
 *		object by calling Lock to also unlock the object with a call to UnLock.
 *		If the party calling UnLock did not construct the CPassword 
 *		object,	it should assume the object to be invalid thereafter.
 */


/*
 *	GCCError	GetPasswordPDU (PPassword		pdu_password)
 *
 *	Public member function of CPassword.
 *
 *	Function Description:
 *		This routine is used to retrieve the password data from the
 *		CPassword object in the "PDU" form of a Password.
 *
 *	Formal Parameters:
 *		pdu_password		(o)	The Password structure to fill in.
 *
 *	Return Value:
 *		GCC_NO_ERROR					-	No error.
 *		GCC_ALLOCATION_FAILURE			- 	The required numeric portion of the
 *												password does not exist.
 *
 *  Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */


/*
 *	GCCError	GetPasswordSelectorPDU(
 *					PPasswordSelector				password_selector_pdu)
 *
 *	Public member function of CPassword.
 *
 *	Function Description:
 *		This routine is used to retrieve the password data from the
 *		CPassword object in the "PDU" form of a PasswordSelector.
 *
 *	Formal Parameters:
 *		password_selector_pdu	(o)	The PasswordSelector structure to fill in.
 *
 *	Return Value:
 *		GCC_NO_ERROR					-	No error.
 *		GCC_INVALID_PASSWORD			- 	Neither the numeric nor the textual
 *												form of the password are valid.
 *
 *  Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */


/*
 *	GCCError	GetPasswordChallengeResponsePDU(
 *					PPasswordChallengeRequestResponse	challenge_pdu)
 *
 *	Public member function of CPassword.
 *
 *	Function Description:
 *		This routine is used to retrieve the password challenge data from the
 *		CPassword object in the "PDU" form of a 
 *		PasswordChallengeRequestResponse.
 *
 *	Formal Parameters:
 *		challenge_pdu			(o)	The PasswordChallengeRequestResponse 
 *										structure to fill in.
 *
 *	Return Value:
 *		GCC_NO_ERROR					-	No error.
 *		GCC_INVALID_PARAMETER			-	Invalid attempt to retrieve
 *												challenge data from a simple
 *												password.
 *		GCC_INVALID_PASSWORD			-	The challenge password is "clear"
 *												but no valid data exists.
 *		GCC_ALLOCATION_FAILURE			- 	Neither the numeric nor the textual
 *												form of the password are valid.
 *
 *  Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */


/*
 *	void	FreePasswordChallengeResponsePDU ()
 *
 *	Public member function of CPassword.
 *
 *	Function Description:
 *		This routine is used to "free" the "PDU" data allocated for this object
 *		which is held internally in a GCCChallengeRequestResponse structure.
 *
 *	Formal Parameters:
 *		None.
 *
 *	Return Value:
 *		None.
 *
 *  Side Effects:
 *		The internal "free" flag is set.
 *
 *	Caveats:
 *		This object should be assumed invalid after a call to 
 *		FreePasswordChallengeResponsePDU has been made.
 */

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\remdsk\rds\t120\h\packet.h ===
/*
 *	packet.h
 *
 *	Copyright (c) 1993 - 1995 by DataBeam Corporation, Lexington, KY
 *				  1997 by Microsoft Corporation, Redmond, WA
 *
 *	Abstract:
 *		This is the interface file for the Packet class.  Instances of this
 *		class represent Protocol Data Units (PDUs) as they flow through the
 *		system.  These instances manage the memory required to hold both
 *		encoded and decoded versions of the PDU, and make sure that no PDU
 *		is ever encoded or decoded more than once.  The use of lock counts
 *		allow multiple objects in the system to reference and use the same
 *		packet object at the same time. This class inherits from the SimplePacket
 *		class (a pure virtual class).
 *
 *		A packet object can be created in 2 different ways.  It can be created
 *		with either decoded data or encoded data.  During instantiation, the
 *		new packet object will calculate how much memory it will need to
 *		hold both the encoded and decoded data, and attempts to allocate that
 *		memory.  If it cannot, then it will report an error, and the newly
 *		created object should be immediately destroyed.  If the allocations are
 *		successful, then the packet will report success, but WILL NOT yet put
 *		any data into those allocated buffers.
 *
 *		When a Lock message is sent to the object, it will put encoded
 *		data into the pre-allocated encode buffer.  If the packet was created
 *		with decoded data, then this will entail an encode operation.  However,
 *		if the packet was created with encoded data, then it is smart enough
 *		to just COPY the encoded data into the internal buffer, thus avoiding
 *		the overhead associated with the encode operation.
 *                  
 *		When a Lock message is sent to the object, it will put decoded
 *		data into the pre-allocated decode buffer.  If the packet was created
 *		with encoded data, then this will entail a decode operation.  However,
 *		if the packet was created with decoded data, then it is smart enough
 *		to just COPY the decoded data into the internal buffer, thus avoiding
 *		the overhead associated with the decode operation.
 *
 *		When Unlock messages are received, the lock count is decremented.  When
 *		the lock count is 0, the packet deletes itself (it commits
 *		suicide).  Note that for this reason, no other object should explicitly
 *		delete a packet object.
 *                  
 *	Caveats:
 *		None.
 *
 *	Authors:
 *		James J. Johnstone IV
 *		Christos Tsollis
 */

#ifndef _PACKET_
#define _PACKET_

#include "pktcoder.h"

/*
 *	 Definition of class Packet.
 */

class Packet;
typedef Packet *		PPacket;

class Packet : public SimplePacket
{
public:

	// outgoing packets
	Packet(PPacketCoder	pPacketCoder,
			UINT			nEncodingRules,
			LPVOID			pInputPduStructure,
			int				nPduType,
			BOOL			fPacketDirectionUp,
			PPacketError	pePktErr,
			BOOL			fLockEncodedData = FALSE);

	// incoming packets
	Packet(PPacketCoder	pPacketCoder,
			UINT			nEncodingRules,
			LPBYTE			pEncodedData,
			UINT			cbEncodedDataSize,
			int				nPduType,
			BOOL			fPacketDirectionUp,
			PPacketError	pePktErr);

	virtual 			~Packet(void);
	
	virtual BOOL		IsDataPacket (void);
	virtual PVoid		GetDecodedData(void);
	UINT				GetDecodedDataLength(void) { return Decoded_Data_Length; };
	virtual int			GetPDUType(void);

protected:
	
	PPacketCoder	Packet_Coder;
	LPVOID			m_Decoded_Data;
	UINT			Decoded_Data_Length;
	int				PDU_Type;
};


/*
 *	Packet (
 *			PPacketCoder	packet_coder,
 *			UINT			encoding_rules,
 *			PVoid			pInputPduStructure,
 *			PMemory			pInputPduStructure_Memory,
 *			int				pdu_type,
 *			DBBoolean		packet_direction_up,
 *			PPacketError	return_value )
 *
 *	Functional Description:
 *		This version of the constructor is used to create a Packet object
 *		for outgoing PDUs when the packet is to be created from a structure
 *		containing the PDU data to be encoded.
 *
 *	Formal Parameters:
 *		packet_coder (i)
 *			Pointer to the packet coder object.  This pointer will be used by
 *			the packet object to encode and decode PDU structures.  This pointer
 *			must not become stale during the life of the packet object.
 *		encoding_rules (i)
 *			This value identifies which set of encoding rules should be used
 *			on the current packet.  This is simply through to the packet coder
 *			during all encode and decode operations.
 *		pInputPduStructure (i)
 *			Pointer to the input PDU structure.
 *		pInputPduStructure_Memory
 *			Pointer to a Memory struct for the buffer containing the pdu structure.
 *			Exactly one of the args pInputPduStructure_Memory and pInputPduStructure
 *			should be non-NULL;
 *		pdu_type (i)
 *			The type of PDU contained in the packet.  This is passed through
 *			to the packet coder specified above.
 *		packet_direction_up (i)
 *			The packet_direction_up flag indicates the initial orientation of
 *			the packet.  Valid values are:
 *				TRUE -	The packet's direction is up.
 *				FALSE -	The packet's direction is down.
 *		return_value (o)
 *			When the constructor returns control to the calling function, this
 *			variable will be set to one of the return values listed below.
 *
 *	Return Value:
 *		PACKET_NO_ERROR
 *			The Packet object was constructed correctly. 
 *		PACKET_MALLOC_FAILURE
 *			The constructor was unable to allocate the memory required to work
 *			properly.  The Packet object should be deleted.
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

/*
 *	Packet (
 *			PPacketCoder	packet_coder,
 *			UINT			encoding_rules,
 *			PUChar			encoded_data_ptr,
 *			UShort			encoded_data_length,
 *			int				pdu_type,
 *			DBBoolean		packet_direction_up,
 *			PPacketError	return_value )
 *
 *	Functional Description:
 *		This version of the constructor is used to create a Packet object
 *		for incomming PDUs when the packet is to be created from an encoded
 *		data stream containing the PDU data to be decoded.
 *
 *	Formal Parameters:
 *		packet_coder (i)
 *			Pointer to the packet coder object.  This pointer will be used by
 *			the packet object to encode and decode PDU structures.  This pointer
 *			must not become stale during the life of the packet object.
 *		encoding_rules (i)
 *			This value identifies which set of encoding rules should be used
 *			on the current packet.  This is simply through to the packet coder
 *			during all encode and decode operations.
 *		encoded_data_ptr (i)
 *			Pointer to the input encoded PDU.
 *		encoded_data_length (i)
 *			The length in bytes of the input encoded PDU.
 *		pdu_type (i)
 *			The type of PDU contained in the packet.  This is passed through
 *			to the packet coder specified above.
 *		packet_direction_up (i)
 *			The packet_direction_up flag indicates the initial orientation of
 *			the packet.  Valid values are:
 *				TRUE -	The packet's direction is up.
 *				FALSE -	The packet's direction is down.
 *		return_value (o)
 *			When the constructor returns control to the calling function, this
 *			variable will be set to one of the return values listed below.
 *
 *	Return Value:
 *		PACKET_NO_ERROR
 *			The Packet object was constructed correctly. 
 *		PACKET_MALLOC_FAILURE
 *			The constructor was unable to allocate the memory required to work
 *			properly.  The Packet object should be deleted.
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */							      				      
/*
 *	~Packet ()
 *
 *	Functional Description:
 *		Destructor for the Packet class.  The destructor ensures that all 
 *		resources that have been allocated are freed.
 *
 *	Formal Parameters:
 *		None.
 *
 *	Return Value:
 *		None.
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

/*
 *	GetDecodedData ()
 *
 *	Functional Description:
 *		The GetDecodedData method returns a pointer to the decoded data
 *		buffer.  
 *
 *	Formal Parameters:
 *		None.
 *
 *	Return Value:
 *		A pointer to the decoded data.  If an decoding error occurs, this
 *		method will return NULL.
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

/*
 *	GetDecodedDataLength ()
 *
 *	Functional Description:
 *		This method returns the decoded data's length.
 *
 *	Formal Parameters:
 *		None.
 *
 *	Return Value:
 *		The number of bytes in the decoded data.
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

/*
 *	GetPDUType ()
 *
 *	Functional Description:
 *		This method returns the PDU type.
 *
 *	Formal Parameters:
 *		None.
 *
 *	Return Value:
 *		Either DOMAIN_MCS_PDU or CONNECT_MCS_PDU dependant upon the PDU type.
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\remdsk\rds\t120\h\pdutypes.h ===
/*
 *	pdutypes.h
 *
 *	Copyright (c) 1994, 1995 by DataBeam Corporation, Lexington, KY
 *
 *	Abstract:
 *		This file is used to convert from the ASN.1 generated types into types
 *		compliant with the DataBeam coding standard.
 *
 *	Author:
 *		jbo
 *
 *	Caveats:
 *		none
 */

#ifndef	_GCC_PDU_TYPES_
#define	_GCC_PDU_TYPES_

#include "gccpdu.h"

/*
 *	PDU types
 */
#define CONNECT_DATA_PDU   					ConnectData_PDU
#define CONNECT_GCC_PDU    					ConnectGCCPDU_PDU
#define GCC_PDU            					GCCPDU_PDU 

/*
 *	Key
 */
#define OBJECT_CHOSEN       				object_chosen
#define H221_NON_STANDARD_CHOSEN   			h221_non_standard_chosen

/*
 *	SetOfUserData
 */
#define USER_DATA_FIELD_PRESENT				user_data_field_present

/*
 *	Password
 */
#define PASSWORD_TEXT_PRESENT				password_text_present

/*
 *	PasswordSelector
 */
#define PASSWORD_SELECTOR_NUMERIC_CHOSEN  	password_selector_numeric_chosen
#define PASSWORD_SELECTOR_TEXT_CHOSEN     	password_selector_text_chosen

/*
 *	ChallengeResponseItem
 */
#define PASSWORD_STRING_CHOSEN				password_string_chosen
#define SET_OF_RESPONSE_DATA_CHOSEN			set_of_response_data_chosen

/*
 *	ChallengeResponseAlgorithm
 */
#define ALGORITHM_CLEAR_PASSWORD_CHOSEN		algorithm_clear_password_chosen
#define NON_STANDARD_ALGORITHM_CHOSEN		non_standard_algorithm_chosen

/*
 *	PasswordChallengeRequestResponse
 */
#define CHALLENGE_CLEAR_PASSWORD_CHOSEN		challenge_clear_password_chosen
#define CHALLENGE_REQUEST_RESPONSE_CHOSEN	challenge_request_response_chosen

/*
 *	ChallengeRequestResponse
 */
#define CHALLENGE_REQUEST_PRESENT			challenge_request_present
#define CHALLENGE_RESPONSE_PRESENT			challenge_response_present

/*
 *	ConferenceName
 */
#define CONFERENCE_NAME_TEXT_PRESENT		conference_name_text_present

/*
 *	ConferenceNameSelector
 */
#define NAME_SELECTOR_NUMERIC_CHOSEN  		name_selector_numeric_chosen
#define NAME_SELECTOR_TEXT_CHOSEN     		name_selector_text_chosen


/*
 *	Defines to match Enums for Privileges
 */
#define	NUMBER_OF_PRIVILEGES		5
#define TERMINATE_IS_ALLOWED		terminate
#define	EJECT_USER_IS_ALLOWED		ejectUser
#define	ADD_IS_ALLOWED				add
#define	LOCK_UNLOCK_IS_ALLOWED		lockUnlock
#define	TRANSFER_IS_ALLOWED			transfer


/*
 *	NetworkAddress
 */
#define AGGREGATED_CHANNEL_CHOSEN 			aggregated_channel_chosen
#define TRANSPORT_CONNECTION_CHOSEN 		transport_connection_chosen
#define ADDRESS_NON_STANDARD_CHOSEN			address_non_standard_chosen

/*
 *	AggregateChannel
 */
#define SUB_ADDRESS_PRESENT 				sub_address_present
#define EXTRA_DIALING_STRING_PRESENT 		extra_dialing_string_present
#define HIGH_LAYER_COMPATIBILITY_PRESENT 	high_layer_compatibility_present

/*
 *	TransportConnection
 */
#define TRANSPORT_SELECTOR_PRESENT 			transport_selector_present

/*
 *	AsymmetryIndicator
 */
#define CALLING_NODE_CHOSEN 				calling_node_chosen
#define CALLED_NODE_CHOSEN 					called_node_chosen
#define UNKNOWN_CHOSEN 						unknown_chosen

/*
 *	AlternativeNodeID
 */
#define H243_NODE_ID_CHOSEN 				h243_node_id_chosen

/*
 *	ConferenceDescriptor
 */
#define CONFERENCE_NAME_MODIFIER_PRESENT 	conference_name_modifier_present
#define CONFERENCE_DESCRIPTION_PRESENT 		conference_description_present
#define DESCRIPTOR_NET_ADDRESS_PRESENT 		descriptor_net_address_present

/*
 *	NodeRecord
 */
#define SUPERIOR_NODE_PRESENT 				superior_node_present
#define NODE_NAME_PRESENT 					node_name_present
#define PARTICIPANTS_LIST_PRESENT 			participants_list_present
#define SITE_INFORMATION_PRESENT 			site_information_present
#define RECORD_NET_ADDRESS_PRESENT 			record_net_address_present
#define ALTERNATIVE_NODE_ID_PRESENT 		alternative_node_id_present
#define RECORD_USER_DATA_PRESENT 			record_user_data_present

/*
 *	SessionKey
 */
#define SESSION_ID_PRESENT 					session_id_present

/*
 *	CapabilityID
 */
#define STANDARD_CHOSEN 					standard_chosen
#define CAPABILITY_NON_STANDARD_CHOSEN		capability_non_standard_chosen

/*
 *	ApplicationRecord
 */
#define RECORD_STARTUP_CHANNEL_PRESENT		record_startup_channel_present
#define APPLICATION_USER_ID_PRESENT 		application_user_id_present
#define NON_COLLAPSING_CAPABILITIES_PRESENT	non_collapsing_capabilities_present

/*
 *	SetOfNonCollapsingCapabilities
 */
#define APPLICATION_DATA_PRESENT 			application_data_present

/*
 *	CapabilityClass
 */
#define LOGICAL_CHOSEN 						logical_chosen
#define UNSIGNED_MINIMUM_CHOSEN 			unsigned_minimum_chosen
#define UNSIGNED_MAXIMUM_CHOSEN 			unsigned_maximum_chosen

/*
 *	ApplicationInvokeSpecifier
 */
#define EXPECTED_CAPABILITY_SET_PRESENT 	expected_capability_set_present
#define INVOKE_STARTUP_CHANNEL_PRESENT		invoke_startup_channel_present

/*
 *	RegistryItem
 */
#define CHANNEL_ID_CHOSEN 					channel_id_chosen
#define TOKEN_ID_CHOSEN 					token_id_chosen
#define PARAMETER_CHOSEN 					parameter_chosen
#define VACANT_CHOSEN 						vacant_chosen

/*
 *	RegistryEntryOwner
 */
#define OWNED_CHOSEN 						owned_chosen
#define NOT_OWNED_CHOSEN 					not_owned_chosen

/*
 *	ConferenceCreateRequest
 */
#define CCRQ_CONVENER_PASSWORD_PRESENT 		ccrq_convener_password_present
#define CCRQ_PASSWORD_PRESENT 				ccrq_password_present
#define CCRQ_CONDUCTOR_PRIVS_PRESENT 		ccrq_conductor_privs_present
#define CCRQ_CONDUCTED_PRIVS_PRESENT 		ccrq_conducted_privs_present
#define CCRQ_NON_CONDUCTED_PRIVS_PRESENT 	ccrq_non_conducted_privs_present
#define CCRQ_DESCRIPTION_PRESENT 			ccrq_description_present
#define CCRQ_CALLER_ID_PRESENT 				ccrq_caller_id_present
#define CCRQ_USER_DATA_PRESENT 				ccrq_user_data_present

/*
 *	ConferenceCreateResponse
 */
#define CCRS_USER_DATA_PRESENT				ccrs_user_data_present

/*
 *	ConferenceQueryRequest
 */
#define CQRQ_ASYMMETRY_INDICATOR_PRESENT	cqrq_asymmetry_indicator_present
#define CQRQ_USER_DATA_PRESENT				cqrq_user_data_present

/*
 *	ConferenceQueryResponse
 */
#define CQRS_ASYMMETRY_INDICATOR_PRESENT 	cqrs_asymmetry_indicator_present
#define CQRS_USER_DATA_PRESENT				cqrs_user_data_present

/*
 *	ConferenceJoinRequest
 */
#define CONFERENCE_NAME_PRESENT 			conference_name_present
#define CJRQ_CONFERENCE_MODIFIER_PRESENT 	cjrq_conference_modifier_present
#define TAG_PRESENT 						tag_present
#define CJRQ_PASSWORD_PRESENT 				cjrq_password_present
#define CJRQ_CONVENER_PASSWORD_PRESENT 		cjrq_convener_password_present
#define CJRQ_CALLER_ID_PRESENT 				cjrq_caller_id_present
#define CJRQ_USER_DATA_PRESENT 				cjrq_user_data_present

/*
 *	ConferenceJoinResponse
 */
#define CJRS_NODE_ID_PRESENT 				cjrs_node_id_present
#define CONFERENCE_NAME_ALIAS_PRESENT 		conference_name_alias_present
#define CJRS_CONDUCTOR_PRIVS_PRESENT 		cjrs_conductor_privs_present
#define CJRS_CONDUCTED_PRIVS_PRESENT 		cjrs_conducted_privs_present
#define CJRS_NON_CONDUCTED_PRIVS_PRESENT 	cjrs_non_conducted_privs_present
#define CJRS_DESCRIPTION_PRESENT 			cjrs_description_present
#define CJRS_PASSWORD_PRESENT 				cjrs_password_present
#define CJRS_USER_DATA_PRESENT 				cjrs_user_data_present

/*
 *	ConferenceInviteRequest
 */
#define CIRQ_CONDUCTOR_PRIVS_PRESENT 		cirq_conductor_privs_present
#define CIRQ_CONDUCTED_PRIVS_PRESENT 		cirq_conducted_privs_present
#define CIRQ_NON_CONDUCTED_PRIVS_PRESENT 	cirq_non_conducted_privs_present
#define CIRQ_DESCRIPTION_PRESENT 			cirq_description_present
#define CIRQ_CALLER_ID_PRESENT 				cirq_caller_id_present
#define CIRQ_USER_DATA_PRESENT 				cirq_user_data_present

/*
 *	ConferenceInviteResponse
 */
#define CIRS_USER_DATA_PRESENT				cirs_user_data_present

/*
 *	ConferenceAddRequest
 */
#define ADDING_MCU_PRESENT 					adding_mcu_present
#define CARQ_USER_DATA_PRESENT				carq_user_data_present

/*
 *	ConferenceAddResponse
 */
#define CARS_USER_DATA_PRESENT				cars_user_data_present

/*
 *	ConferenceTransferRequest
 */
#define CTRQ_CONFERENCE_MODIFIER_PRESENT 	ctrq_conference_modifier_present
#define CTRQ_NETWORK_ADDRESS_PRESENT 		ctrq_net_address_present
#define CTRQ_TRANSFERRING_NODES_PRESENT 	ctrq_transferring_nodes_present
#define CTRQ_PASSWORD_PRESENT 				ctrq_password_present

/*
 *	ConferenceTransferResponse
 */
#define CTRS_CONFERENCE_MODIFIER_PRESENT 	ctrs_conference_modifier_present
#define CTRS_TRANSFERRING_NODES_PRESENT 	ctrs_transferring_nodes_present

/*
 *	ConferenceTransferIndication
 */
#define CTIN_CONFERENCE_MODIFIER_PRESENT 	ctin_conference_modifier_present
#define CTIN_NETWORK_ADDRESS_PRESENT 		ctin_net_address_present
#define CTIN_TRANSFERRING_NODES_PRESENT 	ctin_transferring_nodes_present
#define CTIN_PASSWORD_PRESENT 				ctin_password_present

/*
 *	NodeUpdate
 */
#define NODE_ADD_RECORD_CHOSEN 				node_add_record_chosen
#define NODE_REPLACE_RECORD_CHOSEN 			node_replace_record_chosen
#define NODE_REMOVE_RECORD_CHOSEN 			node_remove_record_chosen

/*
 *	NodeRecordList
 */
#define NODE_NO_CHANGE_CHOSEN 				node_no_change_chosen
#define NODE_RECORD_REFRESH_CHOSEN 			node_record_refresh_chosen
#define NODE_RECORD_UPDATE_CHOSEN 			node_record_update_chosen

/*
 *	ApplicationUpdate
 */
#define APPLICATION_ADD_RECORD_CHOSEN 		application_add_record_chosen
#define APPLICATION_REPLACE_RECORD_CHOSEN 	application_replace_record_chosen
#define APPLICATION_REMOVE_RECORD_CHOSEN 	application_remove_record_chosen

/*
 *	ApplicationRecordList
 */
#define APPLICATION_NO_CHANGE_CHOSEN 		application_no_change_chosen
#define APPLICATION_RECORD_REFRESH_CHOSEN 	application_record_refresh_chosen
#define APPLICATION_RECORD_UPDATE_CHOSEN 	application_record_update_chosen

/*
 *	ApplicationCapabilitiesList
 */
#define CAPABILITY_NO_CHANGE_CHOSEN 		capability_no_change_chosen
#define APPLICATION_CAPABILITY_REFRESH_CHOSEN \
										application_capability_refresh_chosen

/*
 *	ApplicationInvokeIndication
 */
#define DESTINATION_NODES_PRESENT 			destination_nodes_present

/*
 *	RegistrySetParameterRequest
 */
#define PARAMETER_MODIFY_RIGHTS_PRESENT		parameter_modify_rights_present

/*
 *	RegistryMonitorEntryIndication
 */
#define ENTRY_MODIFY_RIGHTS_PRESENT 		entry_modify_rights_present

/*
 *	RegistryResponse
 */
#define RESPONSE_MODIFY_RIGHTS_PRESENT 		response_modify_rights_present

/*
 *	ConductorPermissionGrantIndication
 */
#define WAITING_LIST_PRESENT 				waiting_list_present

/*
 *	ConferenceTimeRemainingIndication
 */
#define TIME_REMAINING_NODE_ID_PRESENT		time_remaining_node_id_present

/*
 *	ConferenceAssistanceIndication
 */
#define CAIN_USER_DATA_PRESENT 				cain_user_data_present

/*
 *	RequestPDU
 */
#define CONFERENCE_JOIN_REQUEST_CHOSEN 				\
									conference_join_request_chosen
#define CONFERENCE_JOIN_RESPONSE_CHOSEN 			\
									conference_join_response_chosen
#define CONFERENCE_LOCK_REQUEST_CHOSEN 				\
									conference_lock_request_chosen
#define CONFERENCE_UNLOCK_REQUEST_CHOSEN 			\
									conference_unlock_request_chosen
#define CONFERENCE_TERMINATE_REQUEST_CHOSEN 		\
									conference_terminate_request_chosen
#define CONFERENCE_EJECT_USER_REQUEST_CHOSEN 		\
									conference_eject_user_request_chosen
#define CONFERENCE_TRANSFER_REQUEST_CHOSEN 			\
									conference_transfer_request_chosen
#define	CONFERENCE_ADD_REQUEST_CHOSEN				\
									conference_add_request_chosen
#define REGISTRY_REGISTER_CHANNEL_REQUEST_CHOSEN 	\
									registry_register_channel_request_chosen
#define REGISTRY_ASSIGN_TOKEN_REQUEST_CHOSEN 		\
									registry_assign_token_request_chosen
#define REGISTRY_SET_PARAMETER_REQUEST_CHOSEN 		\
									registry_set_parameter_request_chosen
#define REGISTRY_RETRIEVE_ENTRY_REQUEST_CHOSEN 		\
									registry_retrieve_entry_request_chosen
#define REGISTRY_DELETE_ENTRY_REQUEST_CHOSEN 		\
									registry_delete_entry_request_chosen
#define REGISTRY_MONITOR_ENTRY_REQUEST_CHOSEN 		\
									registry_monitor_entry_request_chosen
#define REGISTRY_ALLOCATE_HANDLE_REQUEST_CHOSEN 	\
									registry_allocate_handle_request_chosen
#define NON_STANDARD_REQUEST_CHOSEN 				\
									non_standard_request_chosen

/*
 *	ConnectGCCPDU
 */
#define CONFERENCE_CREATE_REQUEST_CHOSEN 	conference_create_request_chosen
#define CONFERENCE_CREATE_RESPONSE_CHOSEN 	conference_create_response_chosen
#define CONFERENCE_QUERY_REQUEST_CHOSEN 	conference_query_request_chosen
#define CONFERENCE_QUERY_RESPONSE_CHOSEN 	conference_query_response_chosen
#define CONNECT_JOIN_REQUEST_CHOSEN 		connect_join_request_chosen
#define CONNECT_JOIN_RESPONSE_CHOSEN 		connect_join_response_chosen
#define CONFERENCE_INVITE_REQUEST_CHOSEN 	conference_invite_request_chosen
#define CONFERENCE_INVITE_RESPONSE_CHOSEN 	conference_invite_response_chosen

/*
 *	ResponsePDU
 */
#define CONFERENCE_JOIN_RESPONSE_CHOSEN 			\
									conference_join_response_chosen
#define CONFERENCE_ADD_RESPONSE_CHOSEN 				\
									conference_add_response_chosen
#define CONFERENCE_LOCK_RESPONSE_CHOSEN 			\
									conference_lock_response_chosen
#define CONFERENCE_UNLOCK_RESPONSE_CHOSEN 			\
									conference_unlock_response_chosen
#define CONFERENCE_TERMINATE_RESPONSE_CHOSEN 		\
									conference_terminate_response_chosen
#define CONFERENCE_EJECT_USER_RESPONSE_CHOSEN		\
									conference_eject_user_response_chosen
#define CONFERENCE_TRANSFER_RESPONSE_CHOSEN 		\
									conference_transfer_response_chosen
#define REGISTRY_RESPONSE_CHOSEN 					\
									registry_response_chosen
#define REGISTRY_ALLOCATE_HANDLE_RESPONSE_CHOSEN 	\
									registry_allocate_handle_response_chosen
#define FUNCTION_NOT_SUPPORTED_RESPONSE_CHOSEN 		\
									function_not_supported_response_chosen
#define NON_STANDARD_RESPONSE_CHOSEN 				\
									non_standard_response_chosen

/*
 *	IndicationPDU
 */
#define USER_ID_INDICATION_CHOSEN 						\
									user_id_indication_chosen
#define CONFERENCE_LOCK_INDICATION_CHOSEN 				\
									conference_lock_indication_chosen
#define CONFERENCE_UNLOCK_INDICATION_CHOSEN 			\
									conference_unlock_indication_chosen
#define CONFERENCE_TERMINATE_INDICATION_CHOSEN 			\
									conference_terminate_indication_chosen
#define CONFERENCE_EJECT_USER_INDICATION_CHOSEN 		\
									conference_eject_user_indication_chosen
#define CONFERENCE_TRANSFER_INDICATION_CHOSEN 			\
									conference_transfer_indication_chosen
#define ROSTER_UPDATE_INDICATION_CHOSEN 				\
									roster_update_indication_chosen
#define APPLICATION_INVOKE_INDICATION_CHOSEN 			\
									application_invoke_indication_chosen
#define REGISTRY_MONITOR_ENTRY_INDICATION_CHOSEN 		\
									registry_monitor_entry_indication_chosen
#define CONDUCTOR_ASSIGN_INDICATION_CHOSEN 				\
									conductor_assign_indication_chosen
#define CONDUCTOR_RELEASE_INDICATION_CHOSEN 			\
									conductor_release_indication_chosen
#define CONDUCTOR_PERMISSION_ASK_INDICATION_CHOSEN 		\
									conductor_permission_ask_indication_chosen
#define CONDUCTOR_PERMISSION_GRANT_INDICATION_CHOSEN 	\
									conductor_permission_grant_indication_chosen
#define CONFERENCE_TIME_REMAINING_INDICATION_CHOSEN 	\
									conference_time_remaining_indication_chosen
#define CONFERENCE_TIME_INQUIRE_INDICATION_CHOSEN 		\
									conference_time_inquire_indication_chosen
#define CONFERENCE_TIME_EXTEND_INDICATION_CHOSEN 		\
									conference_time_extend_indication_chosen
#define CONFERENCE_ASSISTANCE_INDICATION_CHOSEN 		\
									conference_assistance_indication_chosen
#define TEXT_MESSAGE_INDICATION_CHOSEN 					\
									text_message_indication_chosen
#define NON_STANDARD_INDICATION_CHOSEN 					\
									non_standard_indication_chosen

/*
 *	GCCPDU
 */
#define REQUEST_CHOSEN 						request_chosen
#define RESPONSE_CHOSEN 					response_chosen
#define INDICATION_CHOSEN 					indication_chosen


/*
 * 	Typedefs for enumerated types generated in "gccpdu.h".
 */

/*
 *	Typedefs for Privilege enumerations.
 */
#define TERMINATE								terminate
#define EJECT_USER								ejectUser
#define ADD										add
#define LOCK_UNLOCK								lockUnlock
#define TRANSFER								transfer

/*
 *	Typedefs for TerminationMethod enumerations.
 */
#define AUTOMATIC								automatic
#define MANUAL									manual

/*
 *	Typedefs for NodeType enumerations.
 */
#define TERMINAL            					terminal
#define MULTIPORT_TERMINAL						multiportTerminal
#define MCU										mcu

/*
 *	Typedefs for ChannelType enumerations.
 */
#define CHANNEL_TYPE_STATIC            			ChannelType_static
#define DYNAMIC_MULTICAST						dynamicMulticast
#define DYNAMIC_PRIVATE							dynamicPrivate
#define DYNAMIC_USER_ID							dynamicUserId

/*
 *	Typedefs for RegistryModificationRights enumerations.
 */
#define OWNER			            		owner
#define SESSION								session
#define REGISTRY_MODIFY_RIGHTS_PUBLIC		RegistryModiFicationRights_public

/*
 *	Typedefs for ConferenceCreateResult enumerations.
 */
#define CCRS_RESULT_SUCCESS	            	ConferenceCreateResult_success
#define CCRS_USER_REJECTED					ConferenceCreateResult_userRejected
#define RESOURCES_NOT_AVAILABLE				resourcesNotAvailable
#define REJECTED_FOR_SYMMETRY_BREAKING		rejectedForSymmetryBreaking
#define LOCKED_CONFERENCE_NOT_SUPPORTED		lockedConferenceNotSupported

/*
 *	Typedefs for ConferenceQueryResult enumerations.
 */
#define CQRS_RESULT_SUCCESS	            	ConferenceQueryResult_success
#define CQRS_USER_REJECTED					ConferenceQueryResult_userRejected

/*
 *	Typedefs for ConferenceJoinResult enumerations.
 */
#define CJRS_RESULT_SUCCESS	            	ConferenceJoinResult_success
#define CJRS_USER_REJECTED					ConferenceJoinResult_userRejected
#define INVALID_CONFERENCE					invalidConference
#define INVALID_PASSWORD					invalidPassword
#define INVALID_CONVENER_PASSWORD			invalidConvenerPassword
#define CHALLENGE_RESPONSE_REQUIRED			challengeResponseRequired
#define INVALID_CHALLENGE_RESPONSE			invalidChallengeResponse

/*
 *	Typedefs for ConferenceInviteResult enumerations.
 */
#define CIRS_RESULT_SUCCESS	            	ConferenceInviteResult_success
#define CIRS_USER_REJECTED					ConferenceInviteResult_userRejected

/*
 *	Typedefs for ConferenceAddResult enumerations.
 */
#define CARS_SUCCESS	            		ConferenceAddResult_success
#define CARS_INVALID_REQUESTER				ConferenceAddResult_invalidRequester
#define INVALID_NETWORK_TYPE				invalidNetworkType
#define INVALID_NETWORK_ADDRESS				invalidNetworkAddress
#define ADDED_NODE_BUSY						addedNodeBusy
#define NETWORK_BUSY						networkBusy
#define NO_PORTS_AVAILABLE					noPortsAvailable
#define CONNECTION_UNSUCCESSFUL				connectionUnsuccessful

/*
 *	Typedefs for ConferenceLockResult enumerations.
 */
#define CLRS_SUCCESS	            		ConferenceLockResult_success
#define CLRS_INVALID_REQUESTER			ConferenceLockResult_invalidRequester
#define CLRS_ALREADY_LOCKED				alreadyLocked

/*
 *	Typedefs for ConferenceUnlockResult enumerations.
 */
#define CURS_SUCCESS	            	ConferenceUnlockResult_success
#define CURS_INVALID_REQUESTER		ConferenceUnlockResult_invalidRequester
#define CURS_ALREADY_UNLOCKED		   alreadyUnlocked

/*
 *	Typedefs for ConferenceTerminateRequestReason enumerations.
 */
#define CTRQ_REASON_USER_INITIATED	 		ConferenceTerminateRequestReason_userInitiated
#define CTRQ_TIMED_CONFERENCE_TERMINATE		ConferenceTerminateRequestReason_timedConferenceTermination

/*
 *	Typedefs for ConferenceTerminateResult enumerations.
 */
#define CTRS_RESULT_SUCCESS	 			ConferenceTerminateResult_success
#define CTRS_INVALID_REQUESTER			ConferenceTerminateResult_invalidRequester

/*
 *	Typedefs for ConferenceTerminateIndicationReason enumerations.
 */
#define CTIN_REASON_USER_INITIATED			ConferenceTerminateIndicationReason_userInitiated
#define CTIN_TIMED_CONFERENCE_TERMINATE		ConferenceTerminateIndicationReason_timedConferenceTermination

/*
 *	Typedefs for ConferenceEjectRequestReason enumerations.
 */
#define CERQ_REASON_USER_INITIATED		ConferenceEjectRequestReason_userInitiated

/*
 *	Typedefs for ConferenceEjectResult enumerations.
 */
#define CERS_RESULT_SUCCESS	 		ConferenceEjectResult_success
#define CERS_INVALID_REQUESTER		ConferenceEjectResult_invalidRequester
#define	CERS_INVALID_NODE			invalidNode

/*
 *	Typedefs for ConferenceEjectIndicationReason enumerations.
 */
#define CEIN_USER_INITIATED			ConferenceEjectIndicationReason_userInitiated
#define HIGHER_NODE_DISCONNECTED	higherNodeDisconnected
#define HIGHER_NODE_EJECTED			higherNodeEjected

/*
 *	Typedefs for ConferenceTransferResult enumerations.
 */
#define CTRANS_RESULT_SUCCESS				ConferenceTransferResult_success
#define CTRANS_RESULT_INVALID_REQUESTER		ConferenceTransferResult_invalidRequester

/*
 *	Typedefs for RegistryAllocateHandleResult enumerations.
 */
#define RARS_RESULT_SUCCESS	 		RegistryAllocateHandleResult_successful
#define NO_HANDLES_AVAILABLE		noHandlesAvailable

/*
 *	Typedefs for RegistryResponsePrimitiveType enumerations.
 */
#define REGISTER_CHANNEL	 		registerChannel
#define ASSIGN_TOKEN				assignToken
#define SET_PARAMETER				setParameter
#define RETRIEVE_ENTRY				retrieveEntry
#define DELETE_ENTRY				deleteEntry
#define MONITOR_ENTRY				monitorEntry

/*
 *	Typedefs for RegistryResponseResult enumerations.
 */
#define RRRS_RESULT_SUCCESSFUL	 		RegistryResponseResult_successful
#define BELONGS_TO_OTHER				belongsToOther
#define TOO_MANY_ENTRIES				tooManyEntries
#define INCONSISTENT_TYPE				inconsistentType
#define ENTRY_NOT_FOUND					entryNotFound
#define ENTRY_ALREADY_EXISTS			entryAlreadyExists
#define RRRS_INVALID_REQUESTER			RegistryResponseResult_invalidRequester


/*
 *	Typedefs for pointers to GCC Connect PDU structures.
 */
typedef	ConferenceCreateRequest			*	PConferenceCreateRequest;
typedef	ConferenceCreateResponse		*	PConferenceCreateResponse;
typedef	ConferenceQueryRequest			*	PConferenceQueryRequest;
typedef	ConferenceQueryResponse			*	PConferenceQueryResponse;
typedef	ConferenceJoinRequest			*	PConferenceJoinRequest;
typedef	ConferenceJoinResponse			*	PConferenceJoinResponse;
typedef	ConferenceInviteRequest			*	PConferenceInviteRequest;
typedef	ConferenceInviteResponse		*	PConferenceInviteResponse;

/*
 *	Typedefs for pointers to GCC Request PDU structures.
 */
typedef	ConferenceTerminateRequest		*	PConferenceTerminateRequest;
typedef	ConferenceEjectUserRequest		*	PConferenceEjectUserRequest;
typedef	ConferenceTransferRequest		*	PConferenceTransferRequest;
typedef ConferenceAddRequest			*	PConferenceAddRequest;


/*
 *	Typedefs for pointers to GCC Response PDU structures.
 */
typedef	ResponsePDU						*	PResponsePDU;
typedef	ConferenceAddResponse			*	PConferenceAddResponse;
typedef	ConferenceLockResponse			*	PConferenceLockResponse;
typedef	ConferenceUnlockResponse		*	PConferenceUnlockResponse;
typedef	ConferenceTerminateResponse		*	PConferenceTerminateResponse;
typedef	ConferenceEjectUserResponse		*	PConferenceEjectUserResponse;
typedef	ConferenceTransferResponse		*	PConferenceTransferResponse;
typedef	RegistryResponse				*	PRegistryResponse;
typedef	RegistryAllocateHandleRequest	*	PRegistryAllocateHandleRequest;
typedef	RegistryAllocateHandleResponse	*	PRegistryAllocateHandleResponse;
typedef	FunctionNotSupportedResponse	*	PFunctionNotSupportedResponse;
typedef	NonStandardPDU					*	PNonStandardPDU;

/*
 *	Typedefs for pointers to GCC Indication PDU structures.
 */
typedef IndicationPDU					*	PIndicationPDU;
typedef	UserIDIndication				*	PUserIDIndication;
typedef	ConferenceLockIndication		*	PConferenceLockIndication;
typedef	ConferenceUnlockIndication		*	PConferenceUnlockIndication;
typedef	ConferenceTerminateIndication	*	PConferenceTerminateIndication;
typedef	ConferenceEjectUserIndication	*	PConferenceEjectUserIndication;
typedef	ConferenceTransferIndication	*	PConferenceTransferIndication;
typedef	RosterUpdateIndication			*	PRosterUpdateIndication;
typedef	ApplicationInvokeIndication		*	PApplicationInvokeIndication;
typedef	RegistryMonitorEntryIndication	*	PRegistryMonitorEntryIndication;
typedef	ConductorAssignIndication		*	PConductorAssignIndication;
typedef	ConductorReleaseIndication		*	PConductorReleaseIndication;
typedef	ConductorPermissionAskIndication
								*	PConductorPermissionAskIndication;
typedef	ConductorPermissionGrantIndication
								*	PConductorPermissionGrantIndication;
typedef	ConferenceTimeRemainingIndication
								*	PConferenceTimeRemainingIndication;
typedef	ConferenceTimeInquireIndication
								*	PConferenceTimeInquireIndication;
typedef	ConferenceTimeExtendIndication	*	PConferenceTimeExtendIndication;
typedef	ConferenceAssistanceIndication	*	PConferenceAssistanceIndication;
typedef	TextMessageIndication			*	PTextMessageIndication;

/*
 *	Typedef for a pointer to the main GCC PDU structure.
 */
typedef	GCCPDU							*	PGCCPDU;
typedef	ConnectGCCPDU					*	PConnectGCCPDU;
typedef ConnectData						*	PConnectData;

/*
 *	Typedef for pointers to password structures.
 */
typedef	Password									*	PPassword;
typedef	PasswordSelector							*	PPasswordSelector;
typedef	PasswordChallengeRequestResponse			
									*	PPasswordChallengeRequestResponse;
typedef	ChallengeRequest							*	PChallengeRequest;
typedef	ChallengeResponse							*	PChallengeResponse;
typedef	ChallengeResponseAlgorithm	*	PChallengeResponseAlgorithm;

/*
 *	Typedefs for other PDU structures.
 */
typedef		ASN1objectidentifier_t              ObjectID;
typedef	    ASN1objectidentifier_s				SetOfObjectID;
typedef		ASN1objectidentifier_t				PSetOfObjectID;
typedef SetOfNodeRecordRefreshes		*		PSetOfNodeRecordRefreshes;
typedef SetOfNodeRecordUpdates			*		PSetOfNodeRecordUpdates;

typedef ParticipantsList				*		PParticipantsList;
typedef NodeType						*		PNodeType;
typedef NodeProperties					*		PNodeProperties;
typedef NodeRecord						*		PNodeRecord;
typedef Key								* 		PKey;
typedef SessionKey						* 		PSessionKey;
typedef ChallengeItem					* 		PChallengeItem;
typedef SetOfChallengeItems		*			PSetOfChallengeItems;

typedef SetOfConferenceDescriptors	*		PSetOfConferenceDescriptors;

typedef NetworkAddress				*		PNetworkAddress;
typedef TransferModes				*		PTransferModes;

typedef HighLayerCompatibility				*		PHighLayerCompatibility;

/*
 * Application related typedefs.
 */
typedef NodeInformation		*					PNodeInformation;

typedef SetOfApplicationRecordRefreshes		* PSetOfApplicationRecordRefreshes;


typedef SetOfApplicationCapabilityRefreshes		*	
										PSetOfApplicationCapabilityRefreshes;

typedef ApplicationRecord				*	PApplicationRecord;

typedef CapabilityID				*	PCapabilityID;

typedef SetOfNonCollapsingCapabilities	*	PSetOfNonCollapsingCapabilities;

typedef RegistryKey				*	PRegistryKey;
typedef RegistryItem			*	PRegistryItem;

typedef PermissionList		*						PPermissionList;

typedef WaitingList		*							PWaitingList;

typedef SetOfDestinationNodes	*	PSetOfDestinationNodes;

typedef ApplicationProtocolEntityList	*		PApplicationProtocolEntityList;
typedef SetOfExpectedCapabilities	*			PSetOfExpectedCapabilities;
												
												
typedef	SetOfTransferringNodesRq	*	PSetOfTransferringNodesRq;

typedef	SetOfTransferringNodesRs	*	PSetOfTransferringNodesRs;

typedef	SetOfTransferringNodesIn	*	PSetOfTransferringNodesIn;

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\remdsk\rds\t120\h\pktcoder.h ===
/*
 *	pktcoder.h
 *
 *	Copyright (c) 1993 - 1995 by DataBeam Corporation, Lexington, KY
 *
 *	Abstract:
 *		This is the interface file for the PacketCoder class.  This
 *		is an abstract base class which cannot be directly instantiated, but 
 *		rather, exists to be inherited from.  It defines  a set of virtual 
 *		member functions which will be shared by all classes that inherit from 
 *		this one.  This class defines the behaviors necessary to encode, 
 *		decode, and manipulate Protocol Data Unit (PDU) structures.
 *
 *	Caveats:
 *		None.
 *
 *	Author:
 *		John B. O'Nan
 */
#ifndef	_PACKETCODER_
#define	_PACKETCODER_

/*
 * Macros.
 */
#define		BASIC_ENCODING_RULES	0
#define		PACKED_ENCODING_RULES	1

/*
 *	This enumeration defines the various errors that can be returned during
 *	the use of a PacketCoder object.
 */
typedef	enum
{
	PACKET_CODER_NO_ERROR,
	PACKET_CODER_BAD_REVERSE_ATTEMPT,
	PACKET_CODER_INCOMPATIBLE_PROTOCOL
} PacketCoderError;
typedef	PacketCoderError *		PPacketCoderError;


/*
 *	This is the class definition for class PacketCoder
 */
class	PacketCoder
{
	public:
		virtual			~PacketCoder ();
		virtual	BOOL	Encode (LPVOID			pdu_structure,
								int				pdu_type,
								UINT			rules_type,
								LPBYTE			*encoding_buffer,
								UINT			*encoding_buffer_length) = 0;

		virtual BOOL	Decode (LPBYTE			encoded_buffer,
								UINT			encoded_buffer_length,
								int				pdu_type,
								UINT			rules_type,
								LPVOID			*pdecoding_buffer,
								UINT			*pdecoding_buffer_length) = 0;

		virtual DBBoolean IsMCSDataPacket (	LPBYTE			encoded_buffer,
											UINT			rules_type) = 0;
		virtual void	FreeEncoded (LPBYTE encoded_buffer) = 0;

		virtual void	FreeDecoded (int pdu_type, LPVOID decoded_buffer) = 0;

};
typedef PacketCoder *	PPacketCoder;

/*
 *	~PacketCoder ()
 *
 *	Functional Description:
 *		This is a virtual destructor.  It does not actually do anything in this
 *		class.
 *
 *	Formal Parameters:
 *		None.
 *
 *	Return Value:
 *		None.
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */
/*
 *	void Encode (	LPVOID		pdu_structure,
 *					int			pdu_type,
 *					LPBYTE		*encoding_buffer,
 *					UINT		*encoding_buffer_length)
 *
 *	Functional Description:
 *		This function encodes Protocol data units (PDU's) into ASN.1 compliant
 *		byte streams.
 *		The coder allocates the buffer space for the encoded data.
 *
 *	Formal Parameters:
 *		pdu_structure (i)		Pointer to structure holding PDU data.
 *		pdu_type (i)			Define indicating type of PDU.
 *		encoding_buffer (o)		Pointer to buffer to hold encoded data.
 *		encoding_buffer_length (o) Pointer to length of buffer for encoded data.
 *
 *	Return Value:
 *		None.
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */
/*
 *	void Decode (	LPBYTE		encoded_buffer,
 *					UINT		encoded_buffer_length,
 *					int			pdu_type,
 *					LPVOID		decoding_buffer,
 *					UINT		decoding_buffer_length,
 *					UINT		*pulDataOffset)
 *
 *	Functional Description:
 *		This function decodes ASN.1 compliant byte streams into the
 *		appropriate PDU structures.
 *
 *	Formal Parameters:
 *		encoded_buffer (i)		Pointer to buffer holding data to decode.
 *		encoded_buffer_length (i) Length of buffer holding data to decode.
 *		pdu_type (o)			Returns type of PDU.
 *		decoding_buffer (o)		Pointer to buffer to hold the decoded data.
 *		decoding_buffer_length (i) Length of buffer to hold the decoded data.
 *		pulDataOffset (o)		Pointer to a value that stores the offset of the data in an encoded MCS data packet.
 *
 *	Return Value:
 *		None.
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */
/*
 *	void	CopyDecodedData (	LPVOID		pdu_source_structure,
 *								LPVOID		pdu_destination_structure,
 *								int			pdu_type)
 *
 *	Functional Description:
 *		This function makes a copy of the non-encoded PDU structure.  It returns
 *		the length of the structure it has created.  Normally, this will just
 *		be the length of the source structure but the length is returned for
 *		added flexibility later.
 *
 *	Formal Parameters:
 *		pdu_source_structure(i)			Pointer to structure holding PDU data.
 *		pdu_destination_structure(o)	Pointer to structure to hold copy of
 *										PDU data.
 *		pdu_type (i)					The type of PDU to copy.
 *
 *	Return Value:
 *		Size of the destination PDU structure.
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */
/*
 *	DBBoolean	IsMCSDataPacket ()
 *
 *	Functional Description:
 *		This function determines whether the encoded packet is an MCS Data packet
 *		or not.
 *
 *	Formal Parameters:
 *		encoded_buffer (i)		Pointer to buffer holding the encoded PDU.
 *		rules_type (i)			The used encoding rules.
 *
 *	Return value:
 *		TRUE, if the packet is an MCS Data packet. FALSE, otherwise.
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\remdsk\rds\t120\h\privlist.h ===
/*
 *	privlist.h
 *
 *	Copyright (c) 1993 by DataBeam Corporation, Lexington, KY
 *
 *	Abstract:
 *		This is the header file for the class PrivilegeListData.
 *
 *	Caveats:
 *		None.
 *
 *	Author:
 *		blp/jbo
 */
#ifndef	_PRIVILEGE_LIST_DATA_
#define	_PRIVILEGE_LIST_DATA_


typedef enum
{
	TERMINATE_PRIVILEGE,
	EJECT_USER_PRIVILEGE,
	ADD_PRIVILEGE,
	LOCK_UNLOCK_PRIVILEGE,
	TRANSFER_PRIVILEGE
} ConferencePrivilegeType;
typedef	ConferencePrivilegeType	*	PConferencePrivilegeType;


class 	PrivilegeListData;
typedef	PrivilegeListData 	*	PPrivilegeListData;


class PrivilegeListData
{
public:

	PrivilegeListData(PGCCConferencePrivileges);
	PrivilegeListData(PSetOfPrivileges);
	~PrivilegeListData(void);

	PGCCConferencePrivileges GetPrivilegeListData(void) { return &Privilege_List; }
	void GetPrivilegeListData(PGCCConferencePrivileges *pp) { *pp = &Privilege_List; }

	GCCError	GetPrivilegeListPDU(PSetOfPrivileges *);
	void		FreePrivilegeListPDU(PSetOfPrivileges);
	BOOL    	IsPrivilegeAvailable(ConferencePrivilegeType);

protected:

	GCCConferencePrivileges		Privilege_List;
	BOOL        				Privilege_List_Free_Flag;
};
typedef	PrivilegeListData 	*		PPrivilegeListData;
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\remdsk\rds\t120\h\privchnl.h ===
/*
 *	privchnl.h
 *
 *	Copyright (c) 1993 - 1995 by DataBeam Corporation, Lexington, KY
 *
 *	Abstract:
 *		This is the interface file for the PrivateChannel class.  Objects of
 *		this class represent private channels in the MCS environment.  This
 *		class inherits much of its behavior from class Channel.  However,
 *		objects of this class maintain a list of authorized users, and do not
 *		allow any other users to use the channel.  Users that are not part
 *		of the authorized user list may not join the channel, nor may they
 *		even send data on the channel.
 *
 *		Private channels are created as the result of a user issuing a
 *		channel convene request.  This user is known as the channel manager.
 *		Only the channel manager may modify the authorized user list, and
 *		only the channel manager may destroy (disband) the private channel.
 *
 *		The channel adds users to the authorized user list by issuing a
 *		channel admit request.  Users are removed from this list when the
 *		channel manager issues a channel expel request.
 *
 *		Private channel objects will exist in the information base of all
 *		providers who contain either an admitted user or the channel
 *		manager in their sub-tree.  Requests pass upward to the Top Provider
 *		who issues the appropriate indications downward to manage the
 *		information base synchronization process.
 *
 *		Private channel objects restrict the joining of channel by overriding
 *		the join commands.  They restrict the transmission of data by
 *		overriding the send data commands.
 *
 *	Caveats:
 *		None.
 *
 *	Author:
 *		James P. Galvin, Jr.
 */
#ifndef	_PRIVATECHANNEL_
#define	_PRIVATECHANNEL_


/*
 *	This is the class definition for the PrivateChannel class.
 */
class	PrivateChannel : public Channel
{
public:
	PrivateChannel (
			ChannelID			channel_id,
			UserID				channel_manager,
			PDomain             local_provider,
			PConnection         top_provider,
			CChannelList2      *channel_list,
			CAttachmentList    *attachment_list);
	PrivateChannel (
			ChannelID			channel_id,
			UserID				channel_manager,
			PDomain             local_provider,
			PConnection         top_provider,
			CChannelList2      *channel_list,
			CAttachmentList    *attachment_list,
			CUidList           *admitted_list,
			PConnection         pConn);
    virtual					~PrivateChannel ();
		virtual Channel_Type	GetChannelType ();
		virtual	BOOL    		IsValid ();
		virtual CAttachment *GetAttachment(void);
		virtual	Void			IssueMergeRequest ();
		virtual Void			ChannelJoinRequest (
										CAttachment        *originator,
										UserID				uidInitiator,
										ChannelID			channel_id);
		Void			ChannelDisbandRequest (
										CAttachment        *originator,
										UserID				uidInitiator,
										ChannelID			channel_id);
		Void			ChannelDisbandIndication (
										ChannelID			channel_id);
		Void			ChannelAdmitRequest (
										CAttachment        *originator,
										UserID				uidInitiator,
										ChannelID			channel_id,
										CUidList           *user_id_list);
		Void			ChannelAdmitIndication (
										PConnection         originator,
										UserID				uidInitiator,
										ChannelID			channel_id,
										CUidList           *user_id_list);
		Void			ChannelExpelRequest (
										CAttachment        *originator,
										UserID				uidInitiator,
										ChannelID			channel_id,
										CUidList           *user_id_list);
		Void			ChannelExpelIndication (
										PConnection         originator,
										ChannelID			channel_id,
										CUidList           *user_id_list);
		virtual Void			SendDataRequest (
										CAttachment        *originator,
										UINT				type,
										PDataPacket			data_packet);
	private:
				BOOL    		ValidateUserID (
										UserID				user_id);
				Void			BuildAttachmentLists (
										CUidList            *user_id_list,
										CAttachmentList     *local_attachment_list,
										CAttachmentList     *remote_attachment_list);
				Void			BuildUserIDList (
										CUidList           *user_id_list,
										CAttachment        *attachment,
										CUidList           *user_id_subset);

private:

	UserID					m_uidChannelManager;
	CUidList				m_AuthorizedUserList;
	BOOL    				m_fDisbandRequestPending;
};

/*
 *	PrivateChannel (
 *			ChannelID			channel_id,
 *			UserID				channel_manager,
 *			PDomain     		local_provider,
 *			PConnection 		top_provider,
 *			PChannelList		channel_list,
 *			PAttachmentList		attachment_list)
 *
 *	Functional Description:
 *		This is the normal constructor for the PrivateChannel class.  It simply
 *		initializes the instance variables that identify the channel, the local
 *		provider, the top provider, and the channel manager.  The attachment
 *		list is empty by default (meaning that no users have joined the
 *		channel).  The authorized user list is also empty by default.
 *
 *		Upon successful construction of this object, a channel convene confirm
 *		is automatically issued to the channel manager, if it is in the
 *		sub-tree of this provider.
 *
 *	Formal Parameters:
 *		channel_id (i)
 *			This is the ID of the channel object.  By keeping track of this
 *			internally, it doesn't have to be passed in for every operation.
 *		channel_manager (i)
 *			This is the user ID of the channel manager.  Only this user is
 *			permitted to expand or reduce the size of the authorized user list.
 *		local_provider (i)
 *			This is the identity of the local provider.  A PrivateChannel object
 *			needs this since it issues MCS commands on behalf of the local
 *			provider.
 *		top_provider (i)
 *			This is a pointer to the top provider.  This is used by the
 *			PrivateChannel object when it needs to issue a request to the Top
 *			Provider.
 *		channel_list (i)
 *			This is a pointer to the domain's channel list, which identifies
 *			all valid channels in the domain.  This is used by channel objects
 *			to validate user IDs.
 *		attachment_list (i)
 *			This is a pointer to the domain's attachment list, which identifies
 *			all valid attachments in the domain.  This is used by channel
 *			objects to validate joined attachments.
 *
 *	Return Value:
 *		None.
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

/*
 *	PrivateChannel (
 *			ChannelID			channel_id,
 *			UserID				channel_manager,
 *			PDomain     		local_provider,
 *			PConnection 		top_provider,
 *			PChannelList		channel_list,
 *			PAttachmentList		attachment_list,
 *			CUidList           *admitted_list,
 *			PCommandTarget		attachment)
 *
 *	Functional Description:
 *		This is a secondary version of the constructor that is used only during
 *		merge operations.  The only difference between this one and the one
 *		above is that this one allows the specification of an initial
 *		attachment.  This allows a PrivateChannel object to be constructed with
 *		an attachment already joined to the channel.
 *
 *		This version of the constructor will not issue a channel convene confirm
 *		or a channel join confirm to the user.
 *
 *	Formal Parameters:
 *		channel_id (i)
 *			This is the ID of the channel object.  By keeping track of this
 *			internally, it doesn't have to be passed in for every operation.
 *		channel_manager (i)
 *			This is the user ID of the channel manager.  Only this user is
 *			permitted to expand or reduce the size of the authorized user list.
 *		local_provider (i)
 *			This is the identity of the local provider.  A PrivateChannel object
 *			needs this since it issues MCS commands on behalf of the local
 *			provider.
 *		top_provider (i)
 *			This is a pointer to the top provider.  This is used by the
 *			PrivateChannel object when it needs to issue a request to the Top
 *			Provider.
 *		channel_list (i)
 *			This is a pointer to the domain's channel list, which identifies
 *			all valid channels in the domain.  This is used by channel objects
 *			to validate user IDs.
 *		attachment_list (i)
 *			This is a pointer to the domain's attachment list, which identifies
 *			all valid attachments in the domain.  This is used by channel
 *			objects to validate joined attachments.
 *		admitted_list (i)
 *			This is a list of users that are admitted to the channel at the
 *			time of the merge.
 *		attachment (i)
 *			This is the initial attachment for the channel.  A channel join
 *			confirm is NOT issued to the attachment.
 *
 *	Return Value:
 *		None.
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

/*
 *	~PrivateChannel ()
 *
 *	Functional Description:
 *		This is the PrivateChannel class destructor.  It does nothing at this
 *		time.  The base class constructor takes care of clearing the attachment
 *		list.
 *
 *	Formal Parameters:
 *		None.
 *
 *	Return Value:
 *		None.
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

/*
 *	Channel_Type	GetChannelType ()
 *
 *	Functional Description:
 *		This virtual member function returns the type of the channel.  For this
 *		class it will always be PRIVATE_CHANNEL.
 *
 *	Formal Parameters:
 *		None.
 *
 *	Return Value:
 *		PRIVATE_CHANNEL
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */
/*
 *	BOOL    	IsValid ()
 *
 *	Functional Description:
 *		This function will return TRUE until the channel is disbanded.  Then
 *		it will return FALSE to indicate that the channel object can be deleted
 *		from the domain infirmation base.
 *
 *	Formal Parameters:
 *		None.
 *
 *	Return Value:
 *		TRUE if channel still valid.
 *		FALSE if the channel has been disbanded.
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

/*
 *	CAttachment *GetAttachment ()
 *
 *	Functional Description:
 *		This function returns the attachment which leads to the private channel
 *		manager.  If the channel manager is not in the sub-tree of this
 *		provider, it returns NULL.
 *
 *	Formal Parameters:
 *		None.
 *
 *	Return Value:
 *		Attachment that leads to channel manager, or NULL if channel manager is
 *		not in the sub-tree of this provider.
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

/*
 *	Void		IssueMergeRequest ()
 *
 *	Functional Description:
 *		This member function causes the PrivateChannel object to issue a merge
 *		request to the top provider.  It will pack the appropriate local
 *		information into the command.
 *
 *	Formal Parameters:
 *		None.
 *
 *	Return Value:
 *		None.
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

/*
 *	Void		ChannelJoinRequest (
 *						PCommandTarget		originator,
 *						UserID				uidInitiator,
 *						ChannelID			channel_id)
 *
 *	Functional Description:
 *		This function is invoked when a user tries to join the private channel
 *		associated with a PrivateChannel object.  The originator of the request
 *		will only be permitted to join if their user ID is contained in the
 *		authorized user list,  If it does, then the originator will be permitted
 *		to join.
 *
 *		If this provider is not the Top Provider, then the request will be
 *		forwarded upward to the Top Provider.  If this is the Top Provider,
 *		the a channel join confirm will be issued back to the requesting
 *		user.
 *
 *	Formal Parameters:
 *		originator (i)
 *			This is the attachment from which this command originated.
 *		uidInitiator (i)
 *			This is the user ID of the user joining the channel.  This must
 *			be contained in  the authorized user list maintained by the object,
 *			or the request will automatically be rejected.
 *		channel_id (i)
 *			This is the channel being acted upon.
 *
 *	Return Value:
 *		None.
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

/*
 *	Void	ChannelDisbandRequest (
 *					PCommandTarget		originator,
 *					UserID				uidInitiator,
 *					ChannelID			channel_id)
 *
 *	Functional Description:
 *		This function is invoked when a user tries to destroy an existing
 *		private channel.  This is only permitted if the operation is invoked
 *		by the manager of the specified private channel.
 *
 *		If this provider is not the Top Provider, then the request will be
 *		forwarded upward to the Top Provider.
 *
 *	Formal Parameters:
 *		originator (i)
 *			This is the attachment from which this command originated.
 *		uidInitiator (i)
 *			This is the user ID of the user disbanding the channel.  This must
 *			be the same as the user ID of the private channel manager, or the
 *			request will automatically be rejected.
 *		channel_id (i)
 *			This is the channel being acted upon.
 *
 *	Return Value:
 *		None.
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

/*
 *	Void	ChannelDisbandIndication (
 *					PCommandTarget		originator,
 *					ChannelID			channel_id)
 *
 *	Functional Description:
 *		This function is invoked when the Top Provider determines the need to
 *		destroy a private channel.  This may be done in response to a
 *		disband request from the channel manager, or it may be done for
 *		other reasons (such as the channel manager detaching from the domain).
 *
 *	Formal Parameters:
 *		originator (i)
 *			This is the attachment from which this command originated.
 *		channel_id (i)
 *			This is the channel being acted upon.
 *
 *	Return Value:
 *		None.
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

/*
 *	Void	ChannelAdmitRequest (
 *					PCommandTarget		originator,
 *					UserID				uidInitiator,
 *					ChannelID			channel_id,
 *					CUidList           *user_id_list)
 *
 *	Functional Description:
 *		This function is invoked when a user tries to expand the authorized
 *		user list of a private channel.  This operation will only be permitted
 *		if the uidInitiator is the same as the user ID of the private channel
 *		manager.
 *
 *		If this is the Top Provider, this request will be serviced locally,
 *		resulting in the transmission of a channel admit indication to all
 *		downward attachments that contain an admitted user in their sub-tree.
 *		If this is not the Top Provider, ths request will forwarded toward
 *		the Top Provider once the request has been validated.
 *
 *	Formal Parameters:
 *		originator (i)
 *			This is the attachment from which this command originated.
 *		uidInitiator (i)
 *			This is the user ID of the user who is attempting to add users to
 *			the authorized user list.  This must be the same as the user ID
 *			represented by the object, or the request will automatically be
 *			rejected.
 *		channel_id (i)
 *			This is the channel being acted upon.
 *		user_id_list (i)
 *			This is a list containing the IDs of the users to added to the
 *			user list.
 *
 *	Return Value:
 *		None.
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

/*
 *	Void	ChannelAdmitIndication (
 *					PCommandTarget		originator,
 *					UserID				uidInitiator,
 *					ChannelID			channel_id,
 *					CUidList           *user_id_list)
 *
 *	Functional Description:
 *		This function is invoked by the Top Provider upon reception of a
 *		channel admit request from the legitimate manager of a private channel.
 *		It travels downward toward any providers that contain an admitted user
 *		in their sub-tree.
 *
 *	Formal Parameters:
 *		originator (i)
 *			This is the attachment from which this command originated.
 *		uidInitiator (i)
 *			This is the user ID of the user who is attempting to add users to
 *			the authorized user list.  This must be the same as the user ID
 *			represented by the object, or the request will automatically be
 *			rejected.
 *		channel_id (i)
 *			This is the channel being acted upon.
 *		user_id_list (i)
 *			This is a list containing the IDs of the users to added to the
 *			user list.
 *
 *	Return Value:
 *		None.
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

/*
 *	Void	ChannelExpelRequest (
 *					PCommandTarget		originator,
 *					UserID				uidInitiator,
 *					ChannelID			channel_id,
 *					CUidList           *user_id_list)
 *
 *	Functional Description:
 *		This function is invoked when a user tries to shrink the authorized
 *		user list of a private channel.  This operation will only be permitted
 *		if the uidInitiator is the same as the user ID of the private channel
 *		manager.
 *
 *		If this is the Top Provider, this request will be serviced locally,
 *		resulting in the transmission of a channel admit indication to all
 *		downward attachments that contain an admitted user in their sub-tree.
 *		If this is not the Top Provider, ths request will forwarded toward
 *		the Top Provider once the request has been validated.
 *
 *	Formal Parameters:
 *		originator (i)
 *			This is the attachment from which this command originated.
 *		uidInitiator (i)
 *			This is the user ID of the user who is attempting to remove users
 *			from the authorized user list.  This must be the same as the user ID
 *			represented by the object, or the request will automatically be
 *			rejected.
 *		channel_id (i)
 *			This is the channel being acted upon.
 *		user_id_list (i)
 *			This is a list containing the IDs of the users to removed from the
 *			user list.
 *
 *	Return Value:
 *		None.
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

/*
 *	Void	ChannelExpelIndication (
 *					PCommandTarget		originator,
 *					ChannelID			channel_id,
 *					CUidList           *user_id_list)
 *
 *	Functional Description:
 *		This function is invoked by the Top Provider upon reception of a
 *		channel expel request from the legitimate manager of a private channel.
 *		It travels downward toward any providers that contain (or used to
 *		contain) an admitted user in their sub-tree.
 *
 *	Formal Parameters:
 *		originator (i)
 *			This is the attachment from which this command originated.
 *		uidInitiator (i)
 *			This is the user ID of the user who is attempting to remove users
 *			from the authorized user list.  This must be the same as the user ID
 *			represented by the object, or the request will automatically be
 *			rejected.
 *		channel_id (i)
 *			This is the channel being acted upon.
 *		user_id_list (i)
 *			This is a list containing the IDs of the users to removed from the
 *			user list.
 *
 *	Return Value:
 *		None.
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

/*
 *	Void		SendDataRequest (
 *						PCommandTarget		originator,
 *						UINT				type,
 *						PDataPacket			data_packet)
 *
 *	Functional Description:
 *		This function is called when it is necessary to send data through the
 *		channel that this PrivateChannel object represents.  The identity of
 *		the requesting user will be validated to make sure the user is allowed
 *		to send data on the private channel.  If so, then the request is
 *		passed to the Channel class SendDataRequest to be processed.
 *
 *	Formal Parameters:
 *		originator (i)
 *			This is the attachment from which the data came.
 *		type (i)
 *			Normal or uniform send data request.
 *		data_packet (i)
 *			This is a pointer to a DataPacket object containing the channel
 *			ID, the User ID of the data sender, segmentation flags, priority of
 *			the data packet and a pointer to the packet to be sent.
 *
 *	Return Value:
 *		None.
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\remdsk\rds\t120\h\randchnl.h ===
/*
 *	randchnl.h
 *
 *	Copyright (c) 1995 by DataBeam Corporation, Lexington, KY
 *
 *	Abstract:
 *		This is the interface file for the RandomChannelGenerator class.  This
 *		class inherits from the RandomNumberGenerator class.  On instantiation,
 *		instances of this class will internally generate a random number which
 *		falls within the allowable range of dynamic channel values.  Channel
 *		assignments are then generated by incrementing this value each time a
 *		new assignment is requested.  Once the maximum allowable value has been
 *		assigned, the next value to be generated "wraps around" to the minimum
 *		allowable value.
 *
 *		Obviously, this class does not generate completely random channel
 *		values for each request.  With a completely random generator, it is
 *		possible to delete a channel in MCS, and then have the random number
 *		generator assign the same value as the deleted channel before all
 *		components of the system even know that the channel was deleted to
 *		start with, thus causing erratic behavior in the system.  In this
 *		class, no channel can be reassigned until all other possible channels
 *		have been assigned.
 *
 *		This class can be modifed in the future to incorporate additional
 *		"randomness" into the algorithm and still not reassign any channel
 *		numbers before all other possible values are used.  This, however,
 *		would be at the expense of performance and/or memory resources.
 *                  
 *	Caveats:
 *		None.
 *
 *	Author:
 *		Alan D. May
 */
#ifndef _RANDOM_CHANNEL_GENERATOR_
#define _RANDOM_CHANNEL_GENERATOR_

#include "databeam.h"
#include "random.h"

/*
 *	The definition of the RandomChannelGenerator class.
 */
class RandomChannelGenerator
{
	public:
						RandomChannelGenerator ();
		virtual			~RandomChannelGenerator ();
		RandomValue		GetRandomChannel ();

	private:
		ULong			Current_Channel;
};		
typedef RandomChannelGenerator *		PRandomChannelGenerator;

/*
 *	RandomChannelGenerator ()
 *
 *	Functional Description:
 *		The constructor creates a random channel generator object by calling the
 *		constructor for the parent class, RandomNumberGenerator.  This then
 *		automatically seeds the random number generator with the current time.
 *		The default algorithm will be used.
 *
 *	Formal Parameters:
 *		None.
 *
 *	Return Value:
 *		None.
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

/*
 *	~RandomChannelGenerator ()
 *
 *	Public
 *
 *	Functional Description:
 *		This is the destructor for the RandomChannelGenerator class.
 *
 *	Formal Parameters:
 *		None.
 *
 *	Return Value:
 *		None.
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

/*
 *	RandomValue		GetRandomChannel ()
 *
 *	Public
 *
 *	Functional Description:
 *		This method returns a valid dynamic channel number.
 *
 *	Formal Parameters:
 *		None.
 *
 *	Return Value:
 *		A RandomValue in the range of valid dynamic channel values.
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\remdsk\rds\t120\h\registry.h ===
/*
 *	registry.h
 *
 *	Copyright (c) 1995 by DataBeam Corporation, Lexington, KY
 *
 *	Abstract:
 *		Instances of this class represent the application registry for a 
 *		single conference.  This is a dual purpose class that is designed 
 *		to support both a Top Provider node and all other nodes.  The 
 *		information base for the application registry is completely contained at 
 *		the Top Provider node. This information is not distributively held at 
 *		all nodes in the conference like roster information.  It is completely 
 *		managed at the Top Provider.  Therefore all requests to alter 
 *		information in the registry or get information from the registry are 
 *		made to the Top Provider.
 *
 *		When an Application Registry object is instantiated it is informed if it 
 *		is the Top Provider or not.  Application Registry objects that are Top 
 *		Providers are responsible for maintaining the registry information base 
 *		for the entire conference.  It is also responsible for servicing all 
 *		incoming requests and sending out the necessary confirms.  Application 
 *		Registry objects that are not Top Providers are responsible for sending 
 *		all requests to the Top Provider node.  They are also responsible for 
 *		issuing confirms to the CAppSap that made the request after receiving the 
 *		responses back from the Top Provider registry.  All Application Registry 
 *		requests include an Entity ID associated with the APE that made the 
 *		request.  Note that all registry requests are processed in the order 
 *		that they are received.  Therefore, there is no need to include 
 *		sequencing data with each request.  
 *
 *	Caveats:
 *		None.
 *
 *	Author:
 *		blp
 */
#ifndef	_APPLICATION_REGISTRY_
#define	_APPLICATION_REGISTRY_

#include "regkey.h"
#include "regitem.h"
#include "arostmgr.h"

/*
**	This list keeps up with all the APEs that are currently monitoring a 
**	registry entry.
*/
class CMonitoringList : public CList
{
    DEFINE_CLIST_(CMonitoringList, EntityID)
};


//	This structure defines a single registry entry
typedef struct
{
	CRegKeyContainer        *registry_key;
	CRegItem                *entry_item;
	GCCModificationRights	modification_rights;
	CMonitoringList			monitoring_list;
	BOOL    				monitoring_state;
	UserID					owner_id;
	EntityID				entity_id;
}
    REG_ENTRY;


//	This list holds all the registry entries
class CRegEntryList : public CList
{
    DEFINE_CLIST(CRegEntryList, REG_ENTRY*)
};


class CRegistry : public CRefCount
{
public:

    CRegistry(PMCSUser, BOOL top_provider, GCCConfID, CAppRosterMgrList *, PGCCError);
    ~CRegistry(void);

    void		EnrollAPE(EntityID, CAppSap *);
	void		UnEnrollAPE(EntityID);

	GCCError	RegisterChannel(PGCCRegistryKey, ChannelID, EntityID);
	GCCError	AssignToken(PGCCRegistryKey, EntityID);
	GCCError	SetParameter(PGCCRegistryKey, LPOSTR, GCCModificationRights, EntityID);
	GCCError	RetrieveEntry(PGCCRegistryKey, EntityID);
	GCCError	DeleteEntry(PGCCRegistryKey, EntityID);
	GCCError	MonitorRequest(PGCCRegistryKey, BOOL enable_delivery, EntityID);
	GCCError	AllocateHandleRequest(UINT cHandles, EntityID);
	GCCError	ProcessRegisterChannelPDU(CRegKeyContainer *, ChannelID, UserID, EntityID);
	GCCError	ProcessAssignTokenPDU(CRegKeyContainer *, UserID, EntityID);
	GCCError	ProcessSetParameterPDU(CRegKeyContainer *, LPOSTR param, GCCModificationRights, UserID, EntityID);
	void		ProcessRetrieveEntryPDU(CRegKeyContainer *, UserID, EntityID);
	void		ProcessDeleteEntryPDU(CRegKeyContainer *, UserID, EntityID);
	void		ProcessMonitorEntryPDU(CRegKeyContainer *, UserID, EntityID);
	void		ProcessRegistryResponsePDU(RegistryResponsePrimitiveType, CRegKeyContainer *, CRegItem *,
							                GCCModificationRights, EntityID eidRequester,
							                UserID uidOwner, EntityID eidOwner, GCCResult);
	void		ProcessMonitorIndicationPDU(CRegKeyContainer *, CRegItem *, GCCModificationRights,
							                UserID uidOwner, EntityID eidOwner);
	void		ProcessAllocateHandleRequestPDU(UINT cHandles, EntityID eidRequester, UserID uidRequester);
	void		ProcessAllocateHandleResponsePDU(UINT cHandles, UINT first_handle, EntityID, GCCResult);
	void		RemoveNodeOwnership(UserID);
	void		RemoveEntityOwnership(UserID, EntityID);
	void		RemoveSessionKeyReference(CSessKeyContainer *);

private:

    REG_ENTRY       *GetRegistryEntry(CRegKeyContainer *);
    TokenID			GetUnusedToken(void);
	GCCError		AddAPEToMonitoringList(CRegKeyContainer *, EntityID, CAppSap *);
    void			RemoveAPEFromMonitoringList(CRegKeyContainer *, EntityID);
	void			SendMonitorEntryIndicationMessage(REG_ENTRY *);

private:

    PMCSUser						m_pMCSUserObject;
	CRegEntryList				    m_RegEntryList;
	BOOL    						m_fTopProvider;
	TokenID							m_nCurrentTokenID;
	GCCConfID					    m_nConfID;
	CRegItem                        *m_pEmptyRegItem;
	CAppSapEidList2                 m_AppSapEidList2;
	UINT							m_nRegHandle;
	CAppRosterMgrList				*m_pAppRosterMgrList;
};
#endif

/*
 *	CRegistry	(
 *					PMCSUser						user_object,
 *					BOOL    						top_provider,
 *					GCCConfID   					conference_id,
 *					CAppRosterMgrList				*app_roster_manager_list,
 *					PGCCError						return_value )
 *
 *	Public Function Description
 *		This is the Application Registry constructor. It is responsible for
 *		initializing all the instance variables used by this class.  It also
 *		creates an Empty Registry Item to pass back in confirms where a real
 *		registry item does not exists.
 *
 *	Formal Parameters:
 *		user_object			-	(i) Pointer to the MCS User Attachment object.
 *		top_provider		-	(i) Flag indicating if this is the Top Provider
 *									node.
 *		conference_id		-	(i)	The Conference ID associated witht this
 *									registry.
 *		app_roster_manager_list	(i)	List holding all of the application
 *									roster managers assoicated with this
 *									conference.  Needed when verifying if
 *									an requesting APE is truly enrolled.
 *		return_value		-	(o)	Any errors that occur in the constructor
 *									are returned here.
 *		
 *
 *	Return Value
 *		GCC_NO_ERROR			-	No error occured.
 *		GCC_ALLOCATION_FAILURE	-	A resource error occured.
 *
 *  Side Effects
 *		None.
 *
 *	Caveats
 *		None.
 */
/*
 * 	~ApplicationRegistry ()
 *
 *	Public Function Description
 *		This is the Application Registry destructor.  It is responsible for
 *		freeing up all the registry data allocated by this class.
 *
 *	Formal Parameters:
 *		None.
 *
 *	Return Value
 *		None.
 *
 *  Side Effects
 *		None.
 *
 *	Caveats
 *		None.
 */
/*
 *	void EnrollAPE(EntityID		entity_id,
 *					CAppSap		*pAppSap)
 *
 *	Public Function Description
 *		This routine is used to inform the application registry of a newly
 *		enrolling APE and its corresponding command target interface.
 *
 *	Formal Parameters:
 *		entity_id		-	(i)	Entity ID associated with the enrolling APE.
 *		pAppSap     	-	(i)	Command Target pointer associated with the
 *								enrolling APE.
 *
 *	Return Value
 *		None.
 *
 *  Side Effects
 *		None.
 *
 *	Caveats
 *		None.
 */
/*
 *	void	UnEnrollAPE (	EntityID				entity_id )
 *
 *	Public Function Description
 *		This routine is used to inform the application registry of an 
 *		APE that is unerolling from the conference.
 *
 *	Formal Parameters:
 *		entity_id		-	(i)	Entity ID associated with the unenrolling APE.
 *
 *	Return Value
 *		None.
 *
 *  Side Effects
 *		None.
 *
 *	Caveats
 *		This routine removes ownership from all the entries currently owned by 
 *		the passed in application entity.  It will also remove any outstanding
 *		request for the SAP that unenrolled.
 */
/*
 *	GCCError		RegisterChannel (
 *							PGCCRegistryKey			registry_key,
 *							ChannelID				channel_id,
 *							EntityID				entity_id )
 *
 *	Public Function Description
 *		This routine is used by a local APE to register an MCS channel with this
 *		conferences application registry.  If this registry object does NOT 
 *		live at the top provider node this class is responsible for 
 *		forwarding the request on up to the top provider.
 *
 *	Formal Parameters:
 *		registry_key	-	(i)	Registry Key to associate with channel being
 *								registered (this is "API" data).
 *		channel_id		-	(i)	Channel ID to register.
 *		entity_id		-	(i)	Entity ID associated with the APE making the
 *								request.
 *
 *	Return Value
 *		GCC_NO_ERROR				-	No error occured.
 *		GCC_INVALID_REGISTRY_KEY	-	Specified registry key is invalid.
 *		GCC_ALLOCATION_FAILURE		-	A resource error occured.
 *
 *  Side Effects
 *		None.
 *
 *	Caveats
 *		The MCS channel being registerd must be determined before this
 *		routine is called.
 */
/*
 *	GCCError			AssignToken (
 *							PGCCRegistryKey			registry_key,
 *							EntityID				entity_id );
 *
 *	Public Function Description
 *		This routine is used by a local APE to register an MCS Token with this
 *		conferences application registry.  If this registry object does NOT 
 *		live at the top provider node this class is responsible for 
 *		forwarding the request on up to the top provider.
 *
 *	Formal Parameters:
 *		registry_key	-	(i)	Registry Key to associate with token being
 *								registered (this is "API" data).
 *		entity_id		-	(i)	Entity ID associated with the APE making the
 *								request.
 *
 *	Return Value
 *		GCC_NO_ERROR				-	No error occured.
 *		GCC_BAD_REGISTRY_KEY		-	Specified registry key is invalid.
 *		GCC_ALLOCATION_FAILURE		-	A resource error occured.
 *
 *  Side Effects
 *		None.
 *
 *	Caveats
 *		The MCS token being registerd is determined by GCC and is therefore
 *		not included in the request.
 */
/*
 *	GCCError		SetParameter (
 *							PGCCRegistryKey			registry_key,
 *							LPOSTR      			parameter_value,
 *							GCCModificationRights	modification_rights,
 *							EntityID				entity_id )
 *
 *	Public Function Description
 *		This routine is used by a local APE to register a  parameter with this
 *		conferences application registry.  If this registry object does NOT 
 *		live at the top provider node this class is responsible for 
 *		forwarding the request on up to the top provider.
 *
 *	Formal Parameters:
 *		registry_key		-	(i)	Registry Key to associate with parameter 
 *									being registered (this is "API" data).
 *		parameter_value		-	(i)	Value of the parameter being registered.
 *		modification_rights	-	(i)	Modification rights associated with
 *									parameter being registered.	
 *		entity_id			-	(i)	Entity ID associated with the APE making the
 *									request.
 *
 *	Return Value
 *		GCC_NO_ERROR				-	No error occured.
 *		GCC_BAD_REGISTRY_KEY		-	Specified registry key is invalid.
 *		GCC_INVALID_REGISTRY_ITEM	-	Parameter is not valid.
 *		GCC_ALLOCATION_FAILURE		-	A resource error occured.
 *
 *  Side Effects
 *		None.
 *
 *	Caveats
 *		None.
 */
/*
 *	GCCError		RetrieveEntry (
 *							PGCCRegistryKey			registry_key,
 *							EntityID				entity_id )
 *
 *	Public Function Description
 *		This routine is used by a local APE to obtain an item that was 
 *		registered with GCC.  If this registry object does NOT 
 *		live at the top provider node this class is responsible for 
 *		forwarding the request on up to the top provider.
 *
 *	Formal Parameters:
 *		registry_key		-	(i)	Registry Key associated with item being
 *									retrieved (this is "API" data).
 *		entity_id			-	(i)	Entity ID associated with the APE making the
 *									request.
 *
 *	Return Value
 *		GCC_NO_ERROR				-	No error occured.
 *		GCC_BAD_REGISTRY_KEY		-	Specified registry key is invalid.
 *		GCC_ALLOCATION_FAILURE		-	A resource error occured.
 *
 *  Side Effects
 *		None.
 *
 *	Caveats
 *		None.
 */
/*
 *	GCCError	DeleteEntry (
 *							PGCCRegistryKey			registry_key,
 *							EntityID				entity_id )
 *
 *	Public Function Description
 *		This routine is used by a local APE to delete an item that was 
 *		registered with GCC.  If this registry object does NOT 
 *		live at the top provider node this class is responsible for 
 *		forwarding the request on up to the top provider.
 *
 *	Formal Parameters:
 *		registry_key		-	(i)	Registry Key associated with item to delete
 *									(this is "API" data).
 *		entity_id			-	(i)	Entity ID associated with the APE making the
 *									request.
 *
 *	Return Value
 *		GCC_NO_ERROR				-	No error occured.
 *		GCC_BAD_REGISTRY_KEY		-	Specified registry key is invalid.
 *		GCC_ALLOCATION_FAILURE		-	A resource error occured.
 *
 *  Side Effects
 *		None.
 *
 *	Caveats
 *		None.
 */
/*
 *	GCCError	MonitorRequest (
 *							PGCCRegistryKey			registry_key,
 *							BOOL    				enable_delivery,
 *							EntityID				entity_id )
 *
 *	Public Function Description
 *		This routine is used by a local APE to monitor an item that was 
 *		registered with GCC.  If this registry object does NOT 
 *		live at the top provider node this class is responsible for 
 *		forwarding the request on up to the top provider.
 *
 *	Formal Parameters:
 *		registry_key		-	(i)	Registry Key associated with item to 
 *									monitor (this is "API" data).
 *		enable_delivery		-	(i)	This flag indicates if monitoring is being
 *									turned on or off.
 *		entity_id			-	(i)	Entity ID associated with the APE making the
 *									request.
 *
 *	Return Value
 *		GCC_NO_ERROR				-	No error occured.
 *		GCC_BAD_REGISTRY_KEY		-	Specified registry key is invalid.
 *		GCC_ALLOCATION_FAILURE		-	A resource error occured.
 *
 *  Side Effects
 *		None.
 *
 *	Caveats
 *		None.
 */
/*
 *	GCCError			AllocateHandleRequest (	
 *							UINT					number_of_handles,
 *							EntityID				entity_id )
 *
 *	Public Function Description
 *		This routine is used by a local APE to allocate a specified number of
 *		handles from the application registry.  If this registry object does NOT 
 *		live at the top provider node this class is responsible for 
 *		forwarding the request on up to the top provider.
 *
 *	Formal Parameters:
 *		number_of_handles	-	(i)	Number of handles to allocate.
 *		entity_id			-	(i)	Entity ID associated with the APE making the
 *									request.
 *
 *	Return Value
 *		GCC_NO_ERROR				-	No error occured.
 *
 *  Side Effects
 *		None.
 *
 *	Caveats
 *		None.
 */
/*
 *	GCCError		ProcessRegisterChannelPDU (
 *							CRegKeyContainer		            *registry_key,
 *							ChannelID				channel_id,
 *							UserID					requester_id,
 *							EntityID				entity_id )
 *
 *	Public Function Description
 *		This routine is used by the top provider node to process incomming
 *		register channel PDUs.  It is responsible for returning any
 *		necessary responses that must be sent back to the requesting node.
 *
 *	Formal Parameters:
 *		registry_key	-	(i)	Registry Key associated with channel to
 *								register (this is "PDU" data).
 *		channel_id		-	(i)	Channel ID to register.
 *		requester_id	-	(i)	Node ID associated with the APE making the
 *								request.
 *		entity_id		-	(i)	Entity ID associated with the APE making the
 *								request.
 *
 *	Return Value
 *		GCC_NO_ERROR				-	No error occured.
 *		GCC_BAD_REGISTRY_KEY		-	Specified registry key is invalid.
 *		GCC_ALLOCATION_FAILURE		-	A resource error occured.
 *
 *  Side Effects
 *		None.
 *
 *	Caveats
 *		None.
 */
/*
 *	GCCError	ProcessAssignTokenPDU (
 *							CRegKeyContainer		            *registry_key,
 *							UserID					requester_id,
 *							EntityID				entity_id )
 *
 *	Public Function Description
 *		This routine is used by the top provider node to process incomming
 *		register token PDUs.  It is responsible for returning any
 *		necessary responses that must be sent back to the requesting node.
 *
 *	Formal Parameters:
 *		registry_key	-	(i)	Registry Key associated with token to register
 *								(this is "PDU" data).
 *		requester_id	-	(i)	Node ID associated with the APE making the
 *								request.
 *		entity_id		-	(i)	Entity ID associated with the APE making the
 *								request.
 *
 *	Return Value
 *		GCC_NO_ERROR				-	No error occured.
 *		GCC_BAD_REGISTRY_KEY		-	Specified registry key is invalid.
 *		GCC_ALLOCATION_FAILURE		-	A resource error occured.
 *
 *  Side Effects
 *		None.
 *
 *	Caveats
 *		None.
 */
/*
 *	GCCError	ProcessSetParameterPDU(
 *							CRegKeyContainer		*registry_key_data,
 *							LPOSTR      			parameter_value,
 *							GCCModificationRights	modification_rights,
 *							UserID					requester_node_id,
 *							EntityID				requester_entity_id)
 *
 *	Public Function Description
 *		This routine is used by the top provider node to process incomming
 *		register parameter PDUs.  It is responsible for returning any
 *		necessary responses that must be sent back to the requesting node.
 *
 *	Formal Parameters:
 *		registry_key_data	-	(i)	Registry Key associated with parameter to 
 *									register (this is "PDU" data).
 *		parameter_value		-	(i)	Value of the parameter being registered.
 *		modification_rights	-	(i)	Modification rights associated with the
 *									parameter being registered.
 *		requester_node_id	-	(i)	Node ID associated with the APE making the
 *									request.
 *		requester_entity_id	-	(i)	Entity ID associated with the APE making the
 *									request.
 *
 *	Return Value
 *		GCC_NO_ERROR				-	No error occured.
 *		GCC_BAD_REGISTRY_KEY		-	Specified registry key is invalid.
 *		GCC_ALLOCATION_FAILURE		-	A resource error occured.
 *
 *  Side Effects
 *		None.
 *
 *	Caveats
 *		None.
 */
/*
 *	void	ProcessRetrieveEntryPDU (
 *							CRegKeyContainer        *registry_key,
 *							UserID					requester_id,
 *							EntityID				entity_id )
 *
 *	Public Function Description
 *		This routine is used by the top provider node to process an incomming
 *		request to retrieve a registry entry.  It is responsible for returning 
 *		any necessary responses that must be sent back to the requesting node.
 *
 *	Formal Parameters:
 *		registry_key	-	(i)	Registry Key associated with item to 
 *								retrieve (this is "PDU" data).
 *		requester_id	-	(i)	Node ID associated with the APE making the
 *								request.
 *		entity_id		-	(i)	Entity ID associated with the APE making the
 *								request.
 *
 *	Return Value
 *		None.
 *
 *  Side Effects
 *		None.
 *
 *	Caveats
 *		None.
 */
/*
 *	void	ProcessDeleteEntryPDU (
 *							CRegKeyContainer        *registry_key,
 *							UserID					requester_id,
 *							EntityID				entity_id )
 *
 *	Public Function Description
 *		This routine is used by the top provider node to process an incomming
 *		request to delete a registry entry.  It is responsible for returning 
 *		any necessary responses that must be sent back to the requesting node.
 *
 *	Formal Parameters:
 *		registry_key	-	(i)	Registry Key associated with item to 
 *								delete (this is "PDU" data).
 *		requester_id	-	(i)	Node ID associated with the APE making the
 *								request.
 *		entity_id		-	(i)	Entity ID associated with the APE making the
 *								request.
 *
 *	Return Value
 *		None.
 *
 *  Side Effects
 *		None.
 *
 *	Caveats
 *		None.
 */
/*
 *	void		ProcessMonitorEntryPDU (
 *							CRegKeyContainer        *registry_key_data,
 *							UserID					requester_node_id,
 *							EntityID				requester_entity_id )
 *
 *	Public Function Description
 *		This routine is used by the top provider node to process an incomming
 *		request to monitor a registry entry.  It is responsible for returning 
 *		any necessary responses that must be sent back to the requesting node.
 *
 *	Formal Parameters:
 *		registry_key_data	-	(i)	Registry Key associated with item to 
 *									monitor (this is "PDU" data).
 *		requester_node_id	-	(i)	Node ID associated with the APE making the
 *									request.
 *		requester_entity_id	-	(i)	Entity ID associated with the APE making
 *									the request.
 *
 *	Return Value
 *		None.
 *
 *  Side Effects
 *		None.
 *
 *	Caveats
 *		None.
 */
/*
 *	void	ProcessRegistryResponsePDU(
 *					RegistryResponsePrimitiveType	primitive_type,
 *					CRegKeyContainer                *registry_key_data,
 *					CRegItem                        *registry_item_data,
 *					GCCModificationRights			modification_rights,
 *					EntityID						requester_entity_id,
 *					UserID							owner_node_id,
 *					EntityID						owner_entity_id,
 *					GCCResult						result)
 *
 *	Public Function Description
 *		This routine is used by nodes other than the top provider node to 
 *		process registry responses from the top provider.  It is responsible for 
 *		generating any local messages associated with this response.
 *
 *	Formal Parameters:
 *		primitive_type		-	(i)	This parameter defines what type of
 *									registry response this is.
 *		registry_key_data	-	(i)	Registry Key associated with item in
 *									in the response (this is "PDU" data).
 *		registry_item_data	-	(i)	Registry item returned in the response.
 *		modification_rights	-	(i)	Modification rights associated with item
 *									in response (may not be used).
 *		requester_entity_id	-	(i)	Entity ID associated with the APE that 
 *									made the request that generated the 
 *									response.
 *		owner_node_id		-	(i)	Node ID associated with APE that owns the
 *									registry entry returned in the response.
 *		owner_entity_id		-	(i)	Entity ID associated with APE that owns the
 *									registry entry returned in the response.
 *		result				-	(i)	Result of original request.
 *
 *	Return Value
 *		None.
 *
 *  Side Effects
 *		None.
 *
 *	Caveats
 *		None.
 */
/*
 *	void		ProcessMonitorIndicationPDU (
 *							CRegKeyContainer        *registry_key_data,
 *							CRegItem                *registry_item_data,
 *							GCCModificationRights	modification_rights,
 *							UserID					owner_node_id,
 *							EntityID				owner_entity_id);
 *
 *	Public Function Description
 *		This routine is used by nodes other than the top provider node to 
 *		process registry monitor indications from the top provider.  It is 
 *		responsible for generating any local messages associated with this 
 *		response.
 *
 *	Formal Parameters:
 *		registry_key_data	-	(i)	Registry Key associated with item being
 *									monitored (this is "PDU" data).
 *		registry_item_data	-	(i)	Registry item being monitored.
 *		modification_rights	-	(i)	Modification rights of registry item being
 *									monitored (may not be used).
 *		owner_node_id		-	(i)	Node ID associated with APE that owns the
 *									registry entry returned in the indication.
 *		owner_entity_id		-	(i)	Entity ID associated with APE that owns the
 *									registry entry returned in the indication.
 *
 *	Return Value
 *		None.
 *
 *  Side Effects
 *		None.
 *
 *	Caveats
 *		None.
 */
/*
 *	void	ProcessAllocateHandleRequestPDU (
 *							UINT					number_of_handles,
 *							EntityID				requester_entity_id,
 *							UserID					requester_node_id)
 *
 *	Public Function Description
 *		This routine is used by the top provider node to process an incomming
 *		request to allocate a number of handles.  It is responsible for 
 *		returning any necessary responses that must be sent back to the 
 *		requesting node.
 *
 *	Formal Parameters:
 *		number_of_handles	-	(i)	Number of handles to allocate.
 *		requester_node_id	-	(i)	Node ID associated with the APE making the
 *								request.
 *		requester_entity_id	-	(i)	Entity ID associated with the APE making the
 *								request.
 *
 *	Return Value
 *		None.
 *
 *  Side Effects
 *		None.
 *
 *	Caveats
 *		None.
 */
/*
 *	void		ProcessAllocateHandleResponsePDU (
 *							UINT					number_of_handles,
 *							UINT					first_handle,
 *							EntityID				requester_entity_id,
 *							GCCResult				result)
 *
 *	Public Function Description
 *		This routine is used by a node other than the top provider node to 
 *		process an allocate handle response.  It is responsible for generating 
 *		any local messages associated with this response.
 *
 *	Formal Parameters:
 *		number_of_handles	-	(i)	Number of handles that were allocated.
 *		first_handle		-	(i)	This is the value of the first handle in
 *									the contiguous list of handles.
 *		requester_entity_id	-	(i)	Entity ID associated with the APE that made
 *									the original allocate handle request.
 *		result				-	(i)	Result of allocate handle request.
 *
 *	Return Value
 *		None.
 *
 *  Side Effects
 *		None.
 *
 *	Caveats
 *		None.
 */
/*
 *	void		RemoveNodeOwnership (
 *							UserID				node_id )
 *
 *	Public Function Description
 *		This routine removes ownership of all the registry entries associated 
 *		with the specified node ID.  These entries become unowned. This request 
 *		should only be made from the top provider node.  This is a local 
 *		operation.
 *
 *	Formal Parameters:
 *		node_id	-	(i) Node ID of node that owns the registry entries to set
 *						to unowned.
 *
 *	Return Value
 *		None.
 *
 *  Side Effects
 *		None.
 *
 *	Caveats
 *		None.
 */
/*
 *	void	RemoveEntityOwnership (
 *							UserID					node_id,
 *							EntityID				entity_id)
 *
 *	Public Function Description
 *		This routine removes ownership of all the registry entries associated 
 *		with the specified APE.  These entries become unowned. This request 
 *		should only be made from the top provider node.  This is a local 
 *		operation.
 *
 *	Formal Parameters:
 *		node_id	-	(i) Node ID of node that owns the registry entries to set
 *						to unowned.
 *		entity_id-	(i) Entity ID of node that owns the registry entries to set
 *						to unowned.
 *
 *	Return Value
 *		None.
 *
 *  Side Effects
 *		None.
 *
 *	Caveats
 *		None.
 */
/*
 *	void	RemoveSessionKeyReference(CSessKeyContainer *session_key)
 *
 *	Public Function Description
 *		This routine removes all registry entries associated with the
 *		specified session.  This is a local operation.
 *
 *	Formal Parameters:
 *		session_key	-	(i) Session key associated with all the registry 
 *							entries to delete.
 *
 *	Return Value
 *		None.
 *
 *  Side Effects
 *		None.
 *
 *	Caveats
 *		None.
 */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\remdsk\rds\t120\h\regkey.h ===
/*
 *	regkey.h
 *
 *	Copyright (c) 1995 by DataBeam Corporation, Lexington, KY
 *
 *	Abstract:
 *		This is the interface file for the class CRegKeyContainer.  This class
 *		manages the data associated with a Registry Key.  Registry Key are
 *		used to identify resources held in the application registry and consist
 *		of a Session Key and a resource ID octet string.  The CRegKeyContainer 
 *		class uses a CSessKeyContainer container to maintain the session key data 
 *		internally.  A Rogue Wave string object is used to hold the resource ID
 *		octet string.  
 *
 *	Caveats:
 *		None.
 *
 *	Author:
 *		jbo
 */
#ifndef	_REGISTRY_KEY_DATA_
#define	_REGISTRY_KEY_DATA_

#include "sesskey.h"

/*
 * This is the typedef for the structure used to hold the registry key data
 * internally.
 */
typedef struct
{
	CSessKeyContainer		    *session_key;
	LPOSTR						poszResourceID;
}
    REG_KEY;

/*
 * Class definition:
 */
class CRegKeyContainer : public CRefCount
{
public:

	CRegKeyContainer(PGCCRegistryKey, PGCCError);
	CRegKeyContainer(PRegistryKey, PGCCError);
	CRegKeyContainer(CRegKeyContainer *, PGCCError);

	~CRegKeyContainer(void);

	UINT		LockRegistryKeyData(void);
	void		UnLockRegistryKeyData(void);

	UINT		GetGCCRegistryKeyData(PGCCRegistryKey, LPBYTE memory);
	GCCError	GetRegistryKeyDataPDU(PRegistryKey);
	void		FreeRegistryKeyDataPDU(void);
    GCCError    CreateRegistryKeyData(PGCCRegistryKey *);
	BOOL    	IsThisYourSessionKey(CSessKeyContainer *);

    CSessKeyContainer *GetSessionKey(void) { return m_InternalRegKey.session_key; }

    friend BOOL operator==(const CRegKeyContainer&, const CRegKeyContainer&);

protected:

	REG_KEY     		m_InternalRegKey;
	UINT				m_cbDataSize;

    RegistryKey 		m_RegKeyPDU;
	BOOL    			m_fValidRegKeyPDU;
};

/*
 *	Comments explaining the public and protected class member functions
 */

/*
 *	CRegKeyContainer (	PGCCRegistryKey		registry_key,
 *						PGCCError			return_value);
 *
 *	Public member function of CRegKeyContainer.
 *
 *	Function Description:
 *		This is the constructor for the CRegKeyContainer class which takes as
 *		input the "API" version of registry key data, GCCRegistryKey.
 *
 *	Formal Parameters:
 *		registry_key		(i)	The registry key data to store.
 *		return_value		(o)	The output parameter used to indicate errors.
 *
 *	Return Value:
 *		GCC_NO_ERROR					-	No error.
 *		GCC_ALLOCATION_FAILURE			- 	Error creating an object using the
 *												"new" operator.
 *		GCC_BAD_REGISTRY_KEY			-	An invalid registry key passed in.
 *
 *  Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */
/*
 *	CRegKeyContainer (	PRegistryKey		registry_key,
 *						PGCCError			return_value);
 *
 *	Public member function of CRegKeyContainer.
 *
 *	Function Description:
 *		This is the constructor for the CRegKeyContainer class which takes as
 *		input the "PDU" version of registry key data, RegistryKey.
 *
 *	Formal Parameters:
 *		registry_key		(i)	The registry key data to store.
 *		return_value		(o)	The output parameter used to indicate errors.
 *
 *	Return Value:
 *		GCC_NO_ERROR					-	No error.
 *		GCC_ALLOCATION_FAILURE			- 	Error creating an object using the
 *												"new" operator.
 *
 *  Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */
/*
 *	CRegKeyContainer(CRegKeyContainer	            *registry_key,
 *			        PGCCError			return_value);
 *
 *	Public member function of CRegKeyContainer.
 *
 *	Function Description:
 *		This is the copy constructor for the CRegKeyContainer class which takes
 *		as input another CRegKeyContainer object.
 *
 *	Formal Parameters:
 *		registry_key		(i)	The CRegKeyContainer object to copy.
 *		return_value		(o)	The output parameter used to indicate errors.
 *
 *	Return Value:
 *		GCC_NO_ERROR					-	No error.
 *		GCC_ALLOCATION_FAILURE			- 	Error creating an object using the
 *												"new" operator.
 *
 *  Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */


/*
 *	~CRegKeyContainer();
 *
 *	Public member function of CRegKeyContainer.
 *
 *	Function Description:
 *		This is the destructor for the CRegKeyContainer class.  It is used to
 *		clean up any memory allocated during the life of this object.
 *
 *	Formal Parameters:
 *		None.
 *
 *	Return Value:
 *		None.
 *
 *  Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */


/*
 *	ULong			LockRegistryKeyData ();
 *
 *	Public member function of CRegKeyContainer.
 *
 *	Function Description:
 *		This routine is used to "lock" the "API" data for this object.  This
 *		results in the lock count for this object being incremented.  When the
 *		lock count transitions from 0 to 1, a calculation is made to determine
 *		how much memory will be needed to hold any "API" data which will
 *		be referenced by, but not held in, the GCCRegistryKey structure
 *		which is filled in on a call to GetGCCRegistryKeyData.  This is the
 *		value returned by this routine in order to allow the calling object to
 *		allocate that amount of memory in preparation for the call to 
 *		GetGCCRegistryKeyData.
 *
 *	Formal Parameters:
 *		None.
 *
 *	Return Value:
 *		The amount of memory, if any, which will be needed to hold "API" data
 *		which is referenced by, but not held in, the GCCRegistryKey structure
 *		provided as an output parameter to the GetGCCRegistryKeyData call.
 *
 *  Side Effects:
 *		The internal lock count is incremented.
 *
 *	Caveats:
 *		The internal lock count is used in conjuction with an internal "free" 
 *		flag as a mechanism for ensuring that this object remains in existance 
 *		until all interested parties are through with it.  The object remains 
 *		valid (unless explicity deleted) until the lock count is zero and the 
 *		"free" flag is set through a call to FreeRegistryKeyData.  This allows
 *		other objects to lock this object and be sure that it remains valid 
 *		until they call UnLock which will decrement the internal lock count.  A
 *		typical usage scenerio for this object would be:  A CRegKeyContainer
 *		object is constructed and then passed off to any interested parties
 *		through a function call.  On return from the function call, the
 *		FreeRegistryKeyData call is made which will set the internal "free"
 *		flag.  If no other parties have locked the object with a Lock call,
 *		then the CRegKeyContainer object will automatically delete itself when
 *		the FreeRegistryKeyData call is made.  If, however, any number of 
 *		other parties has locked the object, it will remain in existence until
 *		each of them has unlocked the object through a call to UnLock.
 */


/*
 *	ULong			GetGCCRegistryKeyData (	
 *							PGCCRegistryKey 		registry_key,
 *							LPSTR					memory);
 *
 *	Public member function of CRegKeyContainer.
 *
 *	Function Description:
 *		This routine is used to retrieve the registry key data from the
 *		CRegKeyContainer object in the "API" form of a GCCRegistryKey.
 *
 *	Formal Parameters:
 *		registry_key		(o)	The GCCRegistryKey structure to fill in.
 *		memory				(o)	The memory used to hold any data referenced by,
 *									but not held in, the output structure.
 *
 *	Return Value:
 *		The amount of data, if any, written into the bulk memory block provided.
 *
 *  Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */


/*
 *	void			UnLockRegistryKeyData ();
 *
 *	Public member function of CRegKeyContainer.
 *
 *	Function Description:
 *		This routine is used to "unlock" the "API" data for this object.  This
 *		results in the lock count for this object being decremented.  When the
 *		lock count transitions from 1 to 0, a check is made to determine 
 *		whether the object has been freed through a call to 
 *		FreeRegistryKeyData.  If so, the object will automatically delete
 *		itself.
 *
 *	Formal Parameters:
 *		None.
 *
 *	Return Value:
 *		None.
 *
 *  Side Effects:
 *		The internal lock count is decremented.
 *
 *	Caveats:
 *		It is the responsibility of any party which locks a CRegKeyContainer
 *		object by calling Lock to also unlock the object with a call to UnLock.
 *		If the party calling UnLock did not construct the CRegKeyContainer 
 *		object,	it should assume the object to be invalid thereafter.
 */


/*
 *	GCCError		GetRegistryKeyDataPDU (	
 *							PRegistryKey 		registry_key);
 *
 *	Public member function of CRegKeyContainer.
 *
 *	Function Description:
 *		This routine is used to retrieve the registry key data from the
 *		CRegKeyContainer object in the "PDU" form of a RegistryKey.
 *
 *	Formal Parameters:
 *		registry_key		(o)	The RegistryKey structure to fill in.
 *
 *	Return Value:
 *		GCC_NO_ERROR					-	No error.
 *		GCC_ALLOCATION_FAILURE			- 	Error creating an object using the
 *												"new" operator.
 *		GCC_BAD_OBJECT_KEY				-	One of the internal pointers has
 *												been corrupted.
 *
 *  Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */


/*
 *	void		FreeRegistryKeyDataPDU ();
 *
 *	Public member function of CRegKeyContainer.
 *
 *	Function Description:
 *		This routine is used to "free" the "PDU" data allocated for this object
 *		which is held internally in a RegistryKey structure.
 *
 *	Formal Parameters:
 *		None.
 *
 *	Return Value:
 *		None.
 *
 *  Side Effects:
 *		The internal "free" flag is set.
 *
 *	Caveats:
 *		This object should be assumed invalid after a call to 
 *		FreeRegistryKeyDataPDU has been made.
 */


/*
 *	BOOL    		IsThisYourSessionKey (
 *								CSessKeyContainer		*session_key);
 *
 *	Public member function of CRegKeyContainer.
 *
 *	Function Description:
 *		This routine is used to determine whether the specified session key
 *		is held within this registry key object.  The session key is 
 *		provided in "API" form.
 *
 *	Formal Parameters:
 *		session_key		(i)	The session key to use for comparison.
 *
 *	Return Value:
 *		TRUE				-	The specified session key is contained 
 *									within this	registry key object.
 *		FALSE				-	The specified session key is not contained 
 *									within this registry key object.
 *
 *  Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */


/*
 *	CSessKeyContainer *GetSessionKey ();
 *
 *	Public member function of CRegKeyContainer.
 *
 *	Function Description:
 *		This routine is used to retrieve the session key held in this registry
 *		key object.  The session key is returned in the form of a
 *		CSessKeyContainer object.
 *
 *	Formal Parameters:
 *		None.
 *
 *	Return Value:
 *		A pointer to the CSessKeyContainer object contained within this
 *		CRegKeyContainer object.
 *
 *  Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */


/*
 *	friend BOOL    	operator== (const CRegKeyContainer& 		registry_key_1, 
 *								const CRegKeyContainer& 		registry_key_2);
 *
 *	Public member function of CRegKeyContainer.
 *
 *	Function Description:
 *		This routine is used to compare two CRegKeyContainer objects to determine
 *		whether or not they are equal in value.
 *
 *	Formal Parameters:
 *		registry_key_1			(i)	The first CRegKeyContainer object to compare.
 *		registry_key_2			(i)	The other CRegKeyContainer object to compare.
 *
 *	Return Value:
 *		TRUE				-	The two objects are equal in value.
 *		FALSE				- 	The two objects are not equal in value.
 *
 *  Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\remdsk\rds\t120\h\random.h ===
/*
 *	random.h
 *
 *	Copyright (c) 1993-1995 by DataBeam Corporation, Lexington, KY
 *
 *	Abstract:
 *		This is the interface file for the RandomNumberGenerator class.
 *		Instances of this class can generate random numbers within a specifed
 *		range on demand.  Many of these objects can exist at once, and they
 *		will not interfere with each other.
 *                  
 *	Caveats:
 *		None.
 *
 *	Author:
 *		James J. Johnstone IV
 */
#ifndef _RANDOM_
#define _RANDOM_

/*
 *	The data type of the return value of the RandomNumberGenerator class.
 */

typedef	ULong				RandomValue;

#ifdef USE_RANDOM_CLASS

/*
 *	This typedef is an enumeration of all possible random number generation
 *	algorithms and is used when constructing a new random number generator.
 *	See "Numerical Recipes in 'C'" for details as to the difference between
 *	the various algorithms.
 */
typedef	enum
{
	ALGORITHM_RAN1,
	ALGORITHM_RANQD2,
	ALGORITHM_RAN4
} Algorithm;
typedef	Algorithm * 		PAlgorithm;

/*
 *	The default algorithm for the random number generator object.
 */
#define DEFAULT_ALGORITHM	ALGORITHM_RAN1

/*
 *	If specified as the seed value, a random seed will be generated by the 
 *	random number generator.
 */
#define RANDOM_SEED			0

/*
 *	Defines for ran1() algorithm from "Numerical Recipes in 'C'"
 */
#define IA					16807
#define	IM					2147483647L
#define	AM					(1.0/IM)
#define IQ					127773L
#define IR					2836
#define	NTAB				32
#define	NDIV				(1+(IM-1)/NTAB)
#define	EPS					1.2e-7
#define	RNMX				(1.0-EPS)

/*
 *	Defines for ranqd2() algorithm from "Numerical Recipes in 'C'"
 */
#define RANQD2_A			1664525L
#define RANQD2_C			1013904223L

/*
 *	Defines for ranqd2() and ran4() algorithms from "Numerical Recipes in 'C'"
 */
#define	JFLONE				0x3f800000L
#define JFLMSK				0x007fffffL

/*
 *	Defines for the ran4() algorithm from "Numerical Recipes in 'C'"
 */
#define NITER				4

/*
 *	The definition of the RandomNumberGenerator class.
 */
class RandomNumberGenerator
{
	public:
						RandomNumberGenerator ();
						RandomNumberGenerator (
								ULong			seed);
						RandomNumberGenerator (
								Algorithm		algorithm);
						RandomNumberGenerator (
								Algorithm		algorithm,
								ULong			seed);
		virtual			~RandomNumberGenerator ();
		RandomValue		GetRandomNumber (
								RandomValue		lo_extent,
								RandomValue		hi_extent);
		Void			Reseed ();
		Void			Reseed (
								ULong			seed);

	private:
		Void			GenerateSeed (
								ULong			seed);
		Float			RAN1UniformDeviate ();
		Float			RAN4UniformDeviate ();
		Void 			PseudoDESHashing (
								ULong 			*lword, 
								ULong 			*irword);

		Algorithm		Algorithm_In_Use;
		Long			Running_Random_Number;
};		
typedef RandomNumberGenerator *		PRandomNumberGenerator;

/*
 *	RandomNumberGenerator ()
 *
 *	Functional Description:
 *		This version of the constructor is used to create a random number
 *		generator object that has been automatically seeded with the current
 *		time.  The default algorithm will be used.
 *
 *	Formal Parameters:
 *		None.
 *
 *	Return Value:
 *		None.
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

/*
 *	RandomNumberGenerator (
 *			ULong	seed)
 *
 *	Functional Description:
 *		This version of the constructor is used to create a random number
 *		generator object which is seeded with the supplied value.  The default
 *		algorithm will be used.
 *
 *	Formal Parameters:
 *		seed (i)
 *			A value used to seed the random number generator.  If the seed value
 *			is zero, the random number generator object will use a random seed
 *			value based on the time. 
 *
 *	Return Value:
 *		None.
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

/*
 *	RandomNumberGenerator (
 *			Algorithm		algorithm)
 *
 *	Functional Description:
 *		This version of the constructor is used to create a random number
 *		generator object that has been automatically seeded with the current
 *		time.  The algorithm specifies the algorithm to be used.
 *
 *	Formal Parameters:
 *		algorithm (i)
 *			The random number generation algorithm to be used.  The parameter
 *			algorithm must be one of the following:
 *	
 *			ALGORITHM_RAN1
 *				A good general purpose algorithm with a rather long period.
 *				This algorithm was benchmarked on a Gateway 2000 486/33C at
 *				29+ Kops (thousand operations per second).
 *			ALGORITHM_RANQD2
 *				A quick and dirty algorithm.  Use this algorithm if speed is an
 *				issue and the period of the random sequence is unimportant.
 *				This algorithm was benchmarked on a Gateway 2000 486/33C at
 *				49+ Kops (thousand operations per second).
 *			ALGORITHM_RAN4
 *				A slow algorithm with an exceptionally long period.
 *				This algorithm was benchmarked on a Gateway 2000 486/33C at
 *				18+ Kops (thousand operations per second).
 *
 *	Return Value:
 *		None.
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

/*
 *	RandomNumberGenerator (
 *			Algorithm		algorithm,
 *			ULong			seed)
 *
 *	Functional Description:
 *		This version of the constructor is used to create a random number
 *		generator object which is seeded with the supplied value.  The algorithm
 *		specified the algorithm to be used.
 *
 *	Formal Parameters:
 *		algorithm (i)
 *			The random number generation algorithm to be used.  The parameter
 *			algorithm must be one of the following:
 *	
 *			ALGORITHM_RAN1
 *				A good general purpose algorithm with a rather long period.
 *				This algorithm was benchmarked on a Gateway 2000 486/33C at
 *				29+ Kops (thousand operations per second).
 *			ALGORITHM_RANQD2
 *				A quick and dirty algorithm.  Use this algorithm if speed is an
 *				issue and the period of the random sequence is unimportant.
 *				This algorithm was benchmarked on a Gateway 2000 486/33C at
 *				49+ Kops (thousand operations per second).
 *			ALGORITHM_RAN4
 *				A slow algorithm with an exceptionally long period.
 *				This algorithm was benchmarked on a Gateway 2000 486/33C at
 *				18+ Kops (thousand operations per second).
 *		seed (i)
 *			A value used to seed the random number generator.  If the seed value
 *			is zero, the random number generator object will use a random seed
 *			value based on the time. 
 *
 *	Return Value:
 *		None.
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

/*
 *	~RandomNumberGenerator ()
 *
 *	Public
 *
 *	Functional Description:
 *		This is the destructor for the RandomNumberGenerator class.
 *
 *	Formal Parameters:
 *		None.
 *
 *	Return Value:
 *		None.
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

/*
 *	RandomValue		GetRandomNumber (
 *							RandomValue 	lo_extent,
 *							RandomValue		hi_extent)
 *
 *	Public
 *
 *	Functional Description:
 *		This method is used to generate a random number between the 
 *		specified values.
 *
 *	Formal Parameters:
 *		lo_extent (i)
 *			The lowest number you wish to receive.
 *		hi_extent (i)
 *			The highest number you wish to receive.
 *
 *	Return Value:
 *		A RandomValue in the range specified.
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

/*
 *	Void		Reseed ()
 *
 *	Public
 *
 *	Functional Description:
 *		This method is used to reseed the random number generator object using
 *		the system time as the seed value.
 *
 *	Formal Parameters:
 *		None.
 *
 *	Return Value:
 *		None.
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

/*
 *	Void	Reseed (
 *					ULong		seed)
 *
 *	Public
 *
 *	Functional Description:
 *		This method is used to reseed the random number generator object using
 *		the specified seed value.
 *
 *	Formal Parameters:
 *		seed (i)
 *			A value used to seed the random number generator.  If the seed value
 *			is zero, the random number generator object will use a random seed
 *			value based on the time. 
 *
 *	Return Value:
 *		None.
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

#endif	// USE_RANDOM_CLASS
#endif	// _RANDOM_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\remdsk\rds\t120\h\sesskey.h ===
/*
 *	sesskey.h
 *
 *	Copyright (c) 1995 by DataBeam Corporation, Lexington, KY
 *
 *	Abstract:
 *		This is the interface file for the class CSessKeyContainer.  This class 
 *		manages the data associated with a Session Key. Session Keys are used
 *		to uniquely identify an Application Protocol Session.  The Application
 *		Protocol is identified by an Object Key and the particular session
 *		identified by an optional session ID.  The CSessKeyContainer class uses an
 *		CObjectKey container to maintain the object key data internally.  An
 *		unsigned short integer is used to hold the optional session ID.  
 *
 *	Caveats:
 *		None.
 *
 *	Author:
 *		jbo
 */
#ifndef	_SESSION_KEY_DATA_
#define	_SESSION_KEY_DATA_

#include "objkey.h"

/*
 * This is the typedef for the structure used to hold the session key data
 * internally.
 */
typedef struct
{
	CObjectKeyContainer		    *application_protocol_key;
	GCCSessionID				session_id;
}
    SESSION_KEY;

/*
 * Class definition:
 */
class CSessKeyContainer : public CRefCount
{

public:

	CSessKeyContainer(PGCCSessionKey, PGCCError);
	CSessKeyContainer(PSessionKey, PGCCError);
	CSessKeyContainer(CSessKeyContainer *, PGCCError);

	~CSessKeyContainer(void);

	UINT		LockSessionKeyData(void);
	void		UnLockSessionKeyData(void);

	UINT		GetGCCSessionKeyData(PGCCSessionKey, LPBYTE memory);

	GCCError	GetSessionKeyDataPDU(PSessionKey);
	void		FreeSessionKeyDataPDU(void);

	BOOL    	IsThisYourApplicationKey(PGCCObjectKey);
	BOOL    	IsThisYourApplicationKeyPDU(PKey);
	BOOL    	IsThisYourSessionKeyPDU(PSessionKey);

#if 0 // LONCHANC: no one use them
	BOOL	IsThisYourSessionID(PSessionKey pSessKey)
	{
		return (m_InternalSessKey.session_id == pSessKey->session_id);
	}
	BOOL	IsThisYourSessionID(PGCCSessionKey pGccSessKey)
	{
		return (m_InternalSessKey.session_id == pGccSessKey->session_id);
	}
	BOOL	IsThisYourSessionID(UINT nSessionID)
	{
		return ((UINT) m_InternalSessKey.session_id == nSessionID);
	}
#endif

friend BOOL     operator== (const CSessKeyContainer&, const CSessKeyContainer&);

protected:

	SESSION_KEY     	m_InternalSessKey;
	UINT				m_cbDataSize;

	SessionKey 			m_SessionKeyPDU;
	BOOL    			m_fValidSessionKeyPDU;
};

/*
 *	Comments explaining the public and protected class member functions
 */

/*
 *	CSessKeyContainer (	PGCCSessionKey		session_key,
 *						PGCCError			return_value);
 *
 *	Public member function of CSessKeyContainer.
 *
 *	Function Description:
 *		This is the constructor for the CSessKeyContainer class which takes as
 *		input the "API" version of session key data, GCCSessionKey.
 *
 *	Formal Parameters:
 *		session_key			(i)	The session key data to store.
 *		return_value		(o)	The output parameter used to indicate errors.
 *
 *	Return Value:
 *		GCC_NO_ERROR					-	No error.
 *		GCC_ALLOCATION_FAILURE			- 	Error creating an object using the
 *												"new" operator.
 *		GCC_BAD_SESSION_KEY				-	An invalid session key passed in.
 *
 *  Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */


/*
 *	CSessKeyContainer (	PSessionKey			session_key,
 *						PGCCError			return_value);
 *
 *	Public member function of CSessKeyContainer.
 *
 *	Function Description:
 *		This is the constructor for the CSessKeyContainer class which takes as
 *		input the "PDU" version of session key data, SessionKey.
 *
 *	Formal Parameters:
 *		session_key			(i)	The session key data to store.
 *		return_value		(o)	The output parameter used to indicate errors.
 *
 *	Return Value:
 *		GCC_NO_ERROR					-	No error.
 *		GCC_ALLOCATION_FAILURE			- 	Error creating an object using the
 *												"new" operator.
 *		GCC_BAD_SESSION_KEY				-	An invalid session key passed in.
 *
 *  Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */


/*
 *	CSessKeyContainer(CSessKeyContainer		*session_key,
 *				    PGCCError			return_value);
 *
 *	Public member function of CSessKeyContainer.
 *
 *	Function Description:
 *		This is the copy constructor for the CSessKeyContainer class which takes
 *		as input another CSessKeyContainer object.
 *
 *	Formal Parameters:
 *		session_key			(i)	The CSessKeyContainer object to copy.
 *		return_value		(o)	The output parameter used to indicate errors.
 *
 *	Return Value:
 *		GCC_NO_ERROR					-	No error.
 *		GCC_ALLOCATION_FAILURE			- 	Error creating an object using the
 *												"new" operator.
 *		GCC_BAD_SESSION_KEY				-	An invalid session key passed in.
 *
 *  Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */


/*
 *	~SessionKeyData();
 *
 *	Public member function of CSessKeyContainer.
 *
 *	Function Description:
 *		This is the destructor for the CSessKeyContainer class.  It is used to
 *		clean up any memory allocated during the life of this object.
 *
 *	Formal Parameters:
 *		None.
 *
 *	Return Value:
 *		None.
 *
 *  Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */


/*
 *	UINT			LockSessionKeyData ();
 *
 *	Public member function of CSessKeyContainer.
 *
 *	Function Description:
 *		This routine is used to "lock" the "API" data for this object.  This
 *		results in the lock count for this object being incremented.  When the
 *		lock count transitions from 0 to 1, a calculation is made to determine
 *		how much memory will be needed to hold any "API" data which will
 *		be referenced by, but not held in, the GCCSessionKey structure
 *		which is filled in on a call to GetGCCSessionKeyData.  This is the
 *		value returned by this routine in order to allow the calling object to
 *		allocate that amount of memory in preparation for the call to 
 *		GetGCCSessionKeyData.
 *
 *	Formal Parameters:
 *		None.
 *
 *	Return Value:
 *		The amount of memory, if any, which will be needed to hold "API" data
 *		which is referenced by, but not held in, the GCCSessionKey structure
 *		provided as an output parameter to the GetGCCSessionKeyData call.
 *
 *  Side Effects:
 *		The internal lock count is incremented.
 *
 *	Caveats:
 *		The internal lock count is used in conjuction with an internal "free" 
 *		flag as a mechanism for ensuring that this object remains in existance 
 *		until all interested parties are through with it.  The object remains 
 *		valid (unless explicity deleted) until the lock count is zero and the 
 *		"free" flag is set through a call to FreeSessionKeyData.  This allows
 *		other objects to lock this object and be sure that it remains valid 
 *		until they call UnLock which will decrement the internal lock count.  A
 *		typical usage scenerio for this object would be:  A CSessKeyContainer
 *		object is constructed and then passed off to any interested parties
 *		through a function call.  On return from the function call, the
 *		FreeSessionKeyData call is made which will set the internal "free"
 *		flag.  If no other parties have locked the object with a Lock call,
 *		then the CSessKeyContainer object will automatically delete itself when
 *		the FreeSessionKeyData call is made.  If, however, any number of 
 *		other parties has locked the object, it will remain in existence until
 *		each of them has unlocked the object through a call to UnLock.
 */


/*
 *	UINT			GetGCCSessionKeyData (	
 *							PGCCSessionKey 		session_key,
 *							LPSTR				memory);
 *
 *	Public member function of CSessKeyContainer.
 *
 *	Function Description:
 *		This routine is used to retrieve the session key data from the
 *		CSessKeyContainer object in the "API" form of a GCCSessionKey.
 *
 *	Formal Parameters:
 *		session_key			(o)	The GCCSessionKey structure to fill in.
 *		memory				(o)	The memory used to hold any data referenced by,
 *									but not held in, the output structure.
 *
 *	Return Value:
 *		The amount of data, if any, written into the bulk memory block provided.
 *
 *  Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */


/*
 *	void			UnLockSessionKeyData ();
 *
 *	Public member function of CSessKeyContainer.
 *
 *	Function Description:
 *		This routine is used to "unlock" the "API" data for this object.  This
 *		results in the lock count for this object being decremented.  When the
 *		lock count transitions from 1 to 0, a check is made to determine 
 *		whether the object has been freed through a call to 
 *		FreeSessionKeyData.  If so, the object will automatically delete
 *		itself.
 *
 *	Formal Parameters:
 *		None.
 *
 *	Return Value:
 *		None.
 *
 *  Side Effects:
 *		The internal lock count is decremented.
 *
 *	Caveats:
 *		It is the responsibility of any party which locks a CSessKeyContainer
 *		object by calling Lock to also unlock the object with a call to UnLock.
 *		If the party calling UnLock did not construct the CSessKeyContainer 
 *		object,	it should assume the object to be invalid thereafter.
 */


/*
 *	GCCError		GetSessionKeyDataPDU (	
 *							PSessionKey 		session_key);
 *
 *	Public member function of CSessKeyContainer.
 *
 *	Function Description:
 *		This routine is used to retrieve the session key data from the
 *		CSessKeyContainer object in the "PDU" form of a SessionKey.
 *
 *	Formal Parameters:
 *		session_key		(o)	The SessionKey structure to fill in.
 *
 *	Return Value:
 *		GCC_NO_ERROR					-	No error.
 *		GCC_ALLOCATION_FAILURE			- 	Error creating an object using the
 *												"new" operator.
 *
 *  Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */


/*
 *	void		FreeSessionKeyDataPDU ();
 *
 *	Public member function of CSessKeyContainer.
 *
 *	Function Description:
 *		This routine is used to "free" the "PDU" data allocated for this object
 *		which is held internally in a Key structure.
 *
 *	Formal Parameters:
 *		None.
 *
 *	Return Value:
 *		None.
 *
 *  Side Effects:
 *		The internal "free" flag is set.
 *
 *	Caveats:
 *		This object should be assumed invalid after a call to 
 *		FreeSessionKeyDataPDU has been made.
 */


/*
 *	BOOL    		IsThisYourApplicationKey (	
 *							PGCCObjectKey			application_key);
 *
 *	Public member function of CSessKeyContainer.
 *
 *	Function Description:
 *		This routine is used to determine whether the specified application key
 *		is held within this session key object.  The application key is 
 *		provided in "API" form.
 *
 *	Formal Parameters:
 *		application_key		(i)	The application key to use for comparison.
 *
 *	Return Value:
 *		TRUE				-	The specified application key is contained 
 *									within this	session key object.
 *		FALSE				-	The specified application key is not contained 
 *									within this session key object.
 *
 *  Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */


/*
 *	BOOL    		IsThisYourApplicationKeyPDU (	
 *							PKey				application_key);
 *
 *	Public member function of CSessKeyContainer.
 *
 *	Function Description:
 *		This routine is used to determine whether the specified application key
 *		is held within this session key object.  The application key is 
 *		provided in "PDU" form.
 *
 *	Formal Parameters:
 *		application_key		(i)	The application key to use for comparison.
 *
 *	Return Value:
 *		TRUE				-	The specified application key is contained 
 *									within this	session key object.
 *		FALSE				-	The specified application key is not contained 
 *									within this session key object.
 *
 *  Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */


/*
 *	BOOL    		IsThisYourSessionKeyPDU (	
 *							PSessionKey			session_key);
 *
 *	Public member function of CSessKeyContainer.
 *
 *	Function Description:
 *		This routine is used to determine whether the specified session key
 *		is equal in value to the session key maintained by this object.
 *
 *	Formal Parameters:
 *		session_key		(i)	The session key to use for comparison.
 *
 *	Return Value:
 *		TRUE				-	The specified session key is equal in value to
 *									the session key maintained by this object.
 *		FALSE				-	The specified session key is not equal in value
 *									to the session key maintained by this 
 *									object.
 *
 *  Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */


/*
 *	friend BOOL    	operator== (const CSessKeyContainer& 		session_key_1, 
 *								const CSessKeyContainer& 		session_key_2);
 *
 *	Public member function of CSessKeyContainer.
 *
 *	Function Description:
 *		This routine is used to compare two CSessKeyContainer objects to determine
 *		whether or not they are equal in value.
 *
 *	Formal Parameters:
 *		session_key_1			(i)	The first CSessKeyContainer object to compare.
 *		session_key_2			(i)	The other CSessKeyContainer object to compare.
 *
 *	Return Value:
 *		TRUE				-	The two objects are equal in value.
 *		FALSE				- 	The two objects are not equal in value.
 *
 *  Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\remdsk\rds\t120\h\signatr.h ===
/*
 *
 *	signatr.h
 *	
 *	This file defines the signatures of various T.120 objects.  These
 *	signatures are used mainly for debugging debug and retail versions
 *	of T.120.
 *
 *	T.120 used to have many many dictionaries where pointers to objects were put using
 *	16-bit values as keys to search the dictionary and get the pointer to
 *	the appropriate object.  These lookups were inefficient for three
 *	reasons:
 *
 *		1. The lookup takes time
 *		2. The dictionaries take space
 *		3. A 16-bit value passed around requires masking to extract in a 
 *			32-bit machine, that is, extra instructions.
 *
 *	To eliminate these efficiency problems, the pointers to the objects are
 *	used as handles to them (unique values identifying the objects).
 *	But, to catch bugs caused by modifications of these handles as they are
 *	passed around, we need to put a signature in each object that lets us
 *	verify whether an object of type X is really an object of type X.  The way
 *	we do this is by specifying a unique signature for type X and putting this
 *	signature into every object of type X.
 *
 *	Each signature contains only 8 significant bytes.
 */

#ifndef	_T120_SIGNATURES
#define _T120_SIGNATURES

// Signature length
#define SIGNATURE_LENGTH		8

#ifdef _DEBUG
// The macro to compare signatures
#define SIGNATURE_MATCH(p, s)		(memcmp ((p)->mSignature, (s), SIGNATURE_LENGTH) == 0)
// The macro to copy signatures
#define SIGNATURE_COPY(s)			(memcpy (mSignature, (s), SIGNATURE_LENGTH))

#else		// _DEBUG
#define SIGNATURE_MATCH(p, s)		(TRUE)

#	ifndef SHIP_BUILD
#	define SIGNATURE_COPY(s)		(memcpy (mSignature, (s), SIGNATURE_LENGTH))
#	else	// SHIP_BUILD
#	define SIGNATURE_COPY(s)
#	endif	// SHIP_BUILD
#endif		// _DEBUG

extern const char *MemorySignature;

#endif	// _T120_SIGNATURES
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\remdsk\rds\t120\h\regitem.h ===
/*
 *	regitem.h
 *
 *	Copyright (c) 1995 by DataBeam Corporation, Lexington, KY
 *
 *	Abstract:
 *		This is the interface file for the class CRegItem.  This class 
 *		manages the data associated with a Registry Item.  Registry Items are
 *		used to identify a particular entry in the application registry and
 *		may exist in the form of a Channel ID, a Token ID, or an octet string 
 *		parameter.  A CRegItem object holds the data for the first two 
 *		forms in a ChannelID and a TokeID, respectively.  When the registry item
 *		assumes the octet string parameter form, the data is held internally in
 *		a Rogue Wave string object.  
 *
 *	Caveats:
 *		None.
 *
 *	Author:
 *		blp/jbo
 */
#ifndef	_REGISTRY_ITEM_
#define	_REGISTRY_ITEM_


/*
 * Class definition:
 */
class CRegItem : public CRefCount
{
public:

    CRegItem(PGCCRegistryItem, PGCCError);
    CRegItem(PRegistryItem, PGCCError);
    CRegItem(CRegItem *, PGCCError);
    ~CRegItem(void);

	UINT			GetGCCRegistryItemData(PGCCRegistryItem, LPBYTE memory);

	UINT			LockRegistryItemData(void);
	void			UnLockRegistryItemData(void);

	void    		GetRegistryItemDataPDU(PRegistryItem);
	void			FreeRegistryItemDataPDU(void);

    GCCError        CreateRegistryItemData(PGCCRegistryItem *);

    BOOL IsThisYourTokenID(TokenID nTokenID)
    {
        return ((m_eItemType == GCC_REGISTRY_TOKEN_ID) && (nTokenID == m_nTokenID));
    }

	void			operator= (const CRegItem&);

protected:

	GCCRegistryItemType		m_eItemType;
	ChannelID   			m_nChannelID;
	TokenID					m_nTokenID;
	LPOSTR					m_poszParameter;
    UINT					m_cbDataSize;

    RegistryItem 			m_RegItemPDU;
	BOOL    				m_fValidRegItemPDU;
};

/*
 *	Comments explaining the public and protected class member functions
 */

/*
 *	CRegItem (	PGCCRegistryItem	registry_item,
 *						PGCCError			return_value);
 *
 *	Public member function of CRegItem.
 *
 *	Function Description:
 *		This is the constructor for the CRegItem class which takes as
 *		input the "API" version of registry item data, GCCRegistryItem.
 *
 *	Formal Parameters:
 *		registry_item		(i)	The registry item data to store.
 *		return_value		(o)	The output parameter used to indicate errors.
 *
 *	Return Value:
 *		GCC_NO_ERROR					-	No error.
 *
 *  Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */
/*
 *	CRegItem (	PRegistryItem		registry_item,
 *						PGCCError			return_value);
 *
 *	Public member function of CRegItem.
 *
 *	Function Description:
 *		This is the constructor for the CRegItem class which takes as
 *		input the "PDU" version of registry item data, RegistryItem.
 *
 *	Formal Parameters:
 *		registry_item		(i)	The registry item data to store.
 *		return_value		(o)	The output parameter used to indicate errors.
 *
 *	Return Value:
 *		GCC_NO_ERROR					-	No error.
 *
 *  Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */
/*
 *	CRegItem(CRegItem	*registry_item,
 *			PGCCError	return_value);
 *
 *	Public member function of CRegItem.
 *
 *	Function Description:
 *		This is the copy constructor for the CRegItem class which takes
 *		as input another CRegItem object.
 *
 *	Formal Parameters:
 *		registry_item		(i)	The CRegItem object to copy.
 *		return_value		(o)	The output parameter used to indicate errors.
 *
 *	Return Value:
 *		GCC_NO_ERROR					-	No error.
 *
 *  Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */
/*
 *	~CRegItem();
 *
 *	Public member function of CRegItem.
 *
 *	Function Description:
 *		This is the destructor for the CRegItem class.  Since all data
 *		maintained by this class is held in automatic private instance
 *		variables, there is no cleanup needed in this destructor.
 *
 *	Formal Parameters:
 *		None.
 *
 *	Return Value:
 *		None.
 *
 *  Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */
/*
 *	UINT			GetGCCRegistryItemData (	
 *							PGCCRegistryItem 	registry_item,
 *							LPSTR				memory);
 *
 *	Public member function of CRegItem.
 *
 *	Function Description:
 *		This routine is used to retrieve the registry item data from the
 *		CRegItem object in the "API" form of a GCCRegistryItem.
 *
 *	Formal Parameters:
 *		registry_item		(o)	The GCCRegistryItem structure to fill in.
 *		memory				(o)	The memory used to hold any data referenced by,
 *									but not held in, the output structure.
 *
 *	Return Value:
 *		The amount of data, if any, written into the bulk memory block provided.
 *
 *  Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */
/*
 *	UINT			LockRegistryItemData ();
 *
 *	Public member function of CRegItem.
 *
 *	Function Description:
 *		This routine is used to "lock" the "API" data for this object.  This
 *		results in the lock count for this object being incremented.  When the
 *		lock count transitions from 0 to 1, a calculation is made to determine
 *		how much memory, if any, will be needed to hold any "API" data which
 *		will be referenced by, but not held in, the GCCRegistryItem structure
 *		which is filled in on a call to GetGCCRegistryItemData.  This is the
 *		value returned by this routine in order to allow the calling object to
 *		allocate that amount of memory in preparation for the call to 
 *		GetGCCRegistryItemData.
 *
 *	Formal Parameters:
 *		None.
 *
 *	Return Value:
 *		The amount of memory, if any, which will be needed to hold "API" data
 *		which is referenced by, but not held in, the GCCRegistryItem structure
 *		provided as an output parameter to the GetGCCRegistryItemData call.
 *
 *  Side Effects:
 *		The internal lock count is incremented.
 *
 *	Caveats:
 *		The internal lock count is used in conjuction with an internal "free" 
 *		flag as a mechanism for ensuring that this object remains in existance 
 *		until all interested parties are through with it.  The object remains 
 *		valid (unless explicity deleted) until the lock count is zero and the 
 *		"free" flag is set through a call to FreeRegistryItemData.  This allows
 *		other objects to lock this object and be sure that it remains valid 
 *		until they call UnLock which will decrement the internal lock count.  A
 *		typical usage scenerio for this object would be:  A CRegItem
 *		object is constructed and then passed off to any interested parties
 *		through a function call.  On return from the function call, the
 *		FreeRegistryItemData call is made which will set the internal "free"
 *		flag.  If no other parties have locked the object with a Lock call,
 *		then the CRegItem object will automatically delete itself when
 *		the FreeRegistryItemData call is made.  If, however, any number of 
 *		other parties has locked the object, it will remain in existence until
 *		each of them has unlocked the object through a call to UnLock.
 */
/*
 *	void			UnLockRegistryItemData ();
 *
 *	Public member function of CRegItem.
 *
 *	Function Description:
 *		This routine is used to "unlock" the "API" data for this object.  This
 *		results in the lock count for this object being decremented.  When the
 *		lock count transitions from 1 to 0, a check is made to determine 
 *		whether the object has been freed through a call to 
 *		FreeRegistryItemData.  If so, the object will automatically delete
 *		itself.
 *
 *	Formal Parameters:
 *		None.
 *
 *	Return Value:
 *		None.
 *
 *  Side Effects:
 *		The internal lock count is decremented.
 *
 *	Caveats:
 *		It is the responsibility of any party which locks a CRegItem
 *		object by calling Lock to also unlock the object with a call to UnLock.
 *		If the party calling UnLock did not construct the CRegItem 
 *		object,	it should assume the object to be invalid thereafter.
 */
/*
 *	void		GetRegistryItemDataPDU (	
 *							PRegistryItem 	registry_item);
 *
 *	Public member function of CRegItem.
 *
 *	Function Description:
 *		This routine is used to retrieve the registry item data from the
 *		CRegItem object in the "PDU" form of a RegistryItem.
 *
 *	Formal Parameters:
 *		registry_item		(o)	The RegistryItem structure to fill in.
 *
 *	Return Value:
 *		GCC_NO_ERROR					-	No error.
 *
 *  Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */
/*
 *	void			FreeRegistryItemDataPDU ();
 *
 *	Public member function of CRegItem.
 *
 *	Function Description:
 *		This routine is used to "free" the "PDU" data for this object.  For
 *		this object, this means setting a flag to indicate that the "PDU" data
 *		for this object is no longer valid.
 *
 *	Formal Parameters:
 *		None.
 *
 *	Return Value:
 *		None.
 *
 *  Side Effects:
 *		The internal "free" flag is set.
 *
 *	Caveats:
 *		This object should be assumed invalid after a call to 
 *		FreeRegistryItemData has been made.
 */
/*
 *	BOOL    		IsThisYourTokenID (	
 *							TokenID				token_id);
 *
 *	Public member function of CRegItem.
 *
 *	Function Description:
 *		This routine is used to determine whether the specified token ID is
 *		held within this registry item object.
 *
 *	Formal Parameters:
 *		token_id			(i)	The token ID to use for comparison.
 *
 *	Return Value:
 *		TRUE				-	The specified token ID is contained within this
 *									registry item object.
 *		FALSE				-	The specified token ID is not contained within
 *									this registry item object.
 *
 *  Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */
/*
 *	void			operator= (
 *						const CRegItem&		registry_item_data);	
 *
 *	Public member function of CRegItem.
 *
 *	Function Description:
 *		This routine is used to set this CRegItem object to be equal
 *		in value to the specified CRegItem object.
 *
 *	Formal Parameters:
 *		registry_item_data			(i)	The CRegItem object to copy.
 *
 *	Return Value:
 *		None.
 *
 *  Side Effects:
 *		The registry item data values for this object are modified by this call.
 *
 *	Caveats:
 *		The "lock" and "free" states for this object are not affected by
 *		this call.
 */

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\remdsk\rds\t120\h\socket.h ===
/*	Socket.h
 *
 *	Copyright (c) 1996 by Microsoft Corporation
 *
 *	Abstract:
 *		This is the WinSock interface to a socket.  It can create a 
 *		connection with another machine, transmit and receive data, and shut
 *		down the socket when it is finished.
 *
 */
#ifndef _SOCKET_
#define _SOCKET_

#include "databeam.h"

extern "C"
{
	#include "t120.h"
	#include "winsock2.h"
}
#include "tprtsec.h"

/* States that the socket can be in */
typedef	enum
{
	NOT_CONNECTED,
	WAITING_FOR_CONNECTION,
	SOCKET_CONNECTED,
	X224_CONNECTED,
	WAITING_FOR_DISCONNECT
}	SocketState;

/* Security states that the socket can be in */
typedef enum
{
	SC_UNDETERMINED,
	SC_SECURE,
	SC_NONSECURE
}	SecurityState;

#define	MAXIMUM_IP_ADDRESS_SIZE	32


//
// LAURABU SALEM BUGBUG
// THIS IS A DUP OF \h\imsconf3.idl value
//
#define DEFAULT_LISTEN_PORT     522


typedef enum {
	READ_HEADER,
	READ_DATA,
	DISCONNECT_REQUEST,	/* There are dependencies on this order */
	CONNECTION_CONFIRM,
	CONNECTION_REQUEST,
	DATA_READY
} ReadState;

#define	WM_SOCKET_NOTIFICATION			(WM_APP)
#define	WM_SECURE_SOCKET_NOTIFICATION	(WM_APP+1)
#define	WM_PLUGGABLE_X224               (WM_APP+2)
#define WM_PLUGGABLE_PSTN               (WM_APP+3)

typedef struct _Security_Buffer_Info {
	LPBYTE		lpBuffer;
	UINT		uiLength;
} Security_Buffer_Info;

class CSocket : public CRefCount
{
public:

    CSocket(BOOL *, TransportConnection, PSecurityContext);
    ~CSocket(void);

    void FreeTransportBuffer(void);

public:

	X224_DATA_PACKET 	X224_Header;

	/* global variables */
	// SOCKET				Socket_Number;
	SocketState			State;
	SecurityState		SecState;
	PSecurityContext 	pSC;
	UINT				Max_Packet_Length;
	
	Char				Remote_Address[MAXIMUM_IP_ADDRESS_SIZE];

	/* recv state variables */
	UINT				Current_Length;
	PUChar				Data_Indication_Buffer;
	UINT				Data_Indication_Length;
	ReadState			Read_State;
	UINT				X224_Length;
	BOOL				bSpaceAllocated;
	PMemory				Data_Memory;

	/* send state variables */
	union {
	PDataPacket			pUnfinishedPacket;
	Security_Buffer_Info sbiBufferInfo;
	}					Retry_Info;

	BOOL			fExtendedX224;
	BOOL			fIncomingSecure;

    // plugable transport
    TransportConnection     XprtConn;
};

typedef	CSocket *PSocket;

class CSocketList : public CList
{
    DEFINE_CLIST(CSocketList, PSocket)
    void SafeAppend(PSocket);
    BOOL SafeRemove(PSocket);
    PSocket FindByTransportConnection(TransportConnection, BOOL fNoAddRef = FALSE);
    PSocket RemoveByTransportConnection(TransportConnection);
};

extern CSocketList     *g_pSocketList;


/* Function prototypes */
PSocket newSocket(TransportConnection, PSecurityContext);
PSocket	newPluggableSocket(TransportConnection);
PSocket	newSocketEx(TransportConnection, PSecurityContext);

void freeSocket(PSocket, TransportConnection);
void freeListenSocket(TransportConnection);
void freePluggableSocket(PSocket);
void freeSocketEx(PSocket, TransportConnection /* listen_socket_number */);

SOCKET			CreateAndConfigureListenSocket (VOID);

#endif	/* _SOCKET_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\remdsk\rds\t120\h\sap.h ===
/*
 *	sap.h
 *
 *	Copyright (c) 1995 by DataBeam Corporation, Lexington, KY
 *
 *	Abstract:
 *		This is the interface file for the class CBaseSap.  This class is an abstract
 *		base class for objects that act as Service Access Points (SAPs) to 
 *		external applications or the node controller. 
 *
 *		This class has two main responsibilities. First, it handles many of the 
 *		administrative tasks that are common to all types of SAPs.  These 
 *		include handling command target registration responsibilities and 
 *		managing the message queue.  It	also handles all of the primitives that
 *		are common between the Control SAP (CControlSAP class) and Application 
 *		SAPs (CAppSap class).  Since this class inherits from CommandTarget, it 
 *		has the ability to communicate directly with other command targets.  A 
 *		CommandTarget object wishing to	communicate with a CBaseSap object must 
 *		register itself by passing it a CommandTarget pointer and a handle 
 *		(typically a ConferenceID).  This process is identical for both of the 
 *		derived CBaseSap classes.  Note that the CBaseSap object can handle multiple 
 *		registered command targets at the same time.  
 *
 *	Caveats:
 *		None.
 *
 *	Author:
 *		blp
 */
#ifndef _SAP_
#define _SAP_

/*
 * include files 
 */
// #include "gcmdtar.h"
#include "password.h"
#include "crost.h"
#include "arost.h"
#include "conflist.h"
#include "sesskey.h"
#include "regkey.h"
#include "regitem.h"
#include "invoklst.h"
#include "arostmsg.h"
#include "crostmsg.h"
#include "privlist.h"
#include "clists.h"


#define MSG_RANGE                       0x0100
enum
{
    // GCCController
    GCTRLMSG_BASE                       = 0x2100,

    // CConf
    CONFMSG_BASE                        = 0x2200,

    // CControlSAP
    CSAPMSG_BASE                        = 0x2300,

    // CControlSAP asyn direct confirm message
    CSAPCONFIRM_BASE                    = 0x2400,

    // CAppSap
    ASAPMSG_BASE                        = 0x2500,
    
    // NCUI
    NCMSG_BASE                          = 0x2600,

    // MCS (Node) Controller
    MCTRLMSG_BASE                       = 0x2700,
};

LRESULT CALLBACK SapNotifyWndProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam);


typedef struct GCCAppSapMsgEx
{
    GCCAppSapMsgEx(GCCMessageType);
    ~GCCAppSapMsgEx(void);

    GCCAppSapMsg        Msg;
}
    GCCAppSapMsgEx, *PGCCAppSapMsgEx;


/*
 * This macro defines the minimum user ID value allowed by MCS.
 */
#define	MINIMUM_USER_ID_VALUE	1001

/*
 * Structures and enumerations used by the CBaseSap class.
 */


//
// Class definition.
//
class CConf;
class CBaseSap : public CRefCount
{
public:

#ifdef SHIP_BUILD
    CBaseSap();
#else
    CBaseSap(DWORD dwStampID);
#endif
    virtual ~CBaseSap(void) = 0;

    GCCError  ConfRosterInquire(GCCConfID, GCCAppSapMsgEx **);
    GCCError  AppRosterInquire(GCCConfID, GCCSessionKey *, GCCAppSapMsgEx **);
    GCCError  ConductorInquire(GCCConfID);
    GCCError  AppInvoke(GCCConfID, GCCAppProtEntityList *, GCCSimpleNodeList *, GCCRequestTag *);
    BOOL      IsThisNodeTopProvider(GCCConfID);
    GCCNodeID GetTopProvider(GCCConfID);

    virtual GCCError	ConfRosterInquireConfirm(
    					GCCConfID,
    					PGCCConferenceName,
    					LPSTR           	conference_modifier,
    					LPWSTR				pwszConfDescriptor,
    					CConfRoster *,
    					GCCResult,
    					GCCAppSapMsgEx **) = 0;

    virtual GCCError	AppRosterInquireConfirm(
    					GCCConfID,
    					CAppRosterMsg *,
    					GCCResult,
                        GCCAppSapMsgEx **) = 0;

    virtual GCCError AppInvokeConfirm(
                        GCCConfID,
                        CInvokeSpecifierListContainer *,
                        GCCResult,
                        GCCRequestTag) = 0;

    virtual GCCError AppInvokeIndication(
                        GCCConfID,
                        CInvokeSpecifierListContainer *,
                        GCCNodeID nidInvoker) = 0;

    virtual GCCError AppRosterReportIndication(GCCConfID, CAppRosterMsg *) = 0;

    virtual GCCError ConductorInquireConfirm(
    					GCCNodeID			nidConductor,
    					GCCResult,
    					BOOL				permission_flag,
    					BOOL				conducted_mode,
    					GCCConfID) = 0;

    virtual GCCError ConductorPermitGrantIndication(
                        GCCConfID           nConfID,
                        UINT                cGranted,
                        GCCNodeID           *aGranted,
                        UINT                cWaiting,
                        GCCNodeID           *aWaiting,
                        BOOL                fThisNodeIsGranted) = 0;

    virtual GCCError ConductorAssignIndication(
                        GCCNodeID			nidConductor,
                        GCCConfID			conference_id) = 0;

    virtual GCCError ConductorReleaseIndication(
                        GCCConfID			conference_id) = 0;


protected:

    GCCRequestTag GenerateRequestTag(void);

    GCCRequestTag       m_nReqTag;

    HWND                m_hwndNotify;
};



/*
 *	Comments explaining the public and protected class member functions
 */

/*
 *	CBaseSap();
 *
 *	Public member function of CBaseSap.
 *
 *	Function Description:
 *		This is the CBaseSap constructor.  The hash list used to hold command
 *		target objects is initialized by this constructor.
 *
 *	Formal Parameters:
 *		None.
 *
 *	Return Value:
 *		None.
 *
 *  Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */


/*
 *	~Sap ();
 *
 *	Public member function of CBaseSap.
 *
 *	Function Description:
 *		This is the CBaseSap destructor.  All message flushing and queue clearing
 *		is performed by the classes which inherit from CBaseSap.  No work is actually
 *		done by this constructor.
 *
 *	Formal Parameters:
 *		None.
 *
 *	Return Value:
 *		None.
 *
 *  Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */


/*
 *	GCCError	RegisterConf(CConf *, GCCConfID)
 *
 *	Public member function of CBaseSap.
 *
 *	Function Description:
 *		This routine is used by command target objects (such as Conferences) in
 *		order to register themselves with the CBaseSap object.  This is done in order
 *		to allow the command target object to communicate directly with the CBaseSap. 
 *
 *	Formal Parameters:
 *		cmdtar_object			(i) Pointer to the command target object 
 *										wishing to be registered with the CBaseSap.
 *		handle					(i) Integer value used to index the registering
 *										command target in the list of command
 *										targets (the conference ID for confs).
 *
 *	Return Value:
 *		SAP_NO_ERROR						- Command target object has been
 *													successfully registered.
 *		SAP_CONFERENCE_ALREADY_REGISTERED	- A command target object was 
 *													already registered with the
 *													handle passed in.
 *
 *  Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */


/*
 *	GCCError	UnRegisterConf (
 *							UINT					handle);
 *
 *	Public member function of CBaseSap.
 *
 *	Function Description:
 *		This routine is used by command target objects (such as Conferences) in
 *		order to un-register themselves with the CBaseSap object.  This is done when
 *		the command target object is through communicating with the CBaseSap. 
 *
 *	Formal Parameters:
 *		handle					(i) Integer value used to index the registering
 *										command target in the list of command
 *										targets (the conference ID for confs).
 *
 *	Return Value:
 *		SAP_NO_ERROR				- Command target object has been
 *											successfully un-registered.
 *		SAP_NO_SUCH_CONFERENCE		- No command target object was found 
 *											registered with the	handle passed in
 *
 *  Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */


/*
 *	GCCError	ConfRosterInquire(
 *							GCCConfID			conference_id);
 *
 *	Public member function of CBaseSap.
 *
 *	Function Description:
 *		This routine is used to retrieve the conference roster.  This function
 *		just passes this request to the controller via an owner callback.  The 
 *		conference roster is delivered to the requesting command target object
 *		in a Conference Roster inquire confirm. 
 *
 *	Formal Parameters:
 *		conference_id			- ID of conference for desired roster.
 *
 *	Return Value:
 *		GCC_NO_ERROR					- Function completed successfully.
 *		GCC_ALLOCATION_FAILURE			- A resource allocation error occurred.
 *		GCC_INVALID_CONFERENCE			- Conference ID is invalid.
 *		GCC_CONFERENCE_NOT_ESTABLISHED	- Conference object has not completed 
 *										  		its establishment process.
 *		
 *
 *  Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */


/*
 *	GCCError	AppRosterInquire (
 *							GCCConfID			conference_id,
 *							PGCCSessionKey			session_key	);
 *
 *	Public member function of CBaseSap.
 *
 *	Function Description:
 *		This routine is used to retrieve a list of application rosters.  This 
 *		function just passes this request to the controller via an owner 
 *		callback.  This	list is delivered to the requesting SAP through an
 *		Application Roster inquire confirm message.
 *
 *	Formal Parameters:
 *		handle					(i) Integer value used to index the registering
 *										command target in the list of command
 *										targets (the conference ID for confs).
 *
 *	Return Value:
 *		GCC_NO_ERROR			- Function completed successfully.
 *		GCC_ALLOCATION_FAILURE	- A resource allocation error occurred.
 *		GCC_INVALID_CONFERENCE	- Conference ID is invalid.
 *		GCC_BAD_SESSION_KEY		- Session key pointer is invalid.
 *
 *  Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */


/*
 *	GCCError	ConductorInquire (
 *							GCCConfID			conference_id);
 *
 *	Public member function of CBaseSap.
 *
 *	Function Description:
 *		This routine is called in order to retrieve conductorship information.
 *		The conductorship information is returned in the confirm.
 *
 *	Formal Parameters:
 *		conference_id		(i) ID of conference.
 *
 *	Return Value:
 *		GCC_NO_ERROR					- Function completed successfully.
 *		GCC_ALLOCATION_FAILURE			- A resource error occurred.
 *		GCC_INVALID_CONFERENCE			- Conference ID is invalid.
 *
 *  Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */


/*
 *	GCCError 	AppInvoke(
 *							GCCConfID			conference_id,
 *							UINT					number_of_apes,
 *							PGCCAppProtocolEntity *	ape_list,
 *							UINT					number_of_destination_nodes,
 *							UserID			*		list_of_destination_nodes);
 *
 *	Public member function of CBaseSap.
 *
 *	Function Description:
 *		This routine is called in order to invoke other applications at remote
 *		nodes.  The request is passed on to the appropriate Conference objects.
 *
 *	Formal Parameters:
 *		conference_id				(i) ID of conference.
 *		number_of_apes				(i)	Number of Application Protocol Entities
 *											to be invoked.
 *		ape_list					(i) List of "APE"s to be invoked.
 *		number_of_destination_nodes	(i) Number of nodes where applications are
 *											to be invoked.
 *		list_of_destination_nodes	(i) List of nodes where applications are to
 *											be invoked.
 *
 *	Return Value:
 *		GCC_NO_ERROR					- No error.
 *		GCC_ALLOCATION_FAILURE			- Error creating an object using the
 *										  		"new" operator.
 *		GCC_BAD_SESSION_KEY				- An invalid session key exists in
 *										  		an APE passed in.
 *		GCC_BAD_NUMBER_OF_APES			- Number of APEs passed in as zero.
 *		GCC_INVALID_CONFERENCE			- Conference ID is invalid.
 *		GCC_CONFERENCE_NOT_ESTABLISHED	- Conference object has not completed 
 *										  	its establishment process.
 *
 *  Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */


/*
 *	GCCError	ConductorPermitAskRequest(
 *							GCCConfID			conference_id,
 *							BOOL				grant_permission);
 *
 *	Public member function of CBaseSap.
 *
 *	Function Description:
 *		This routine is called in order to ask for certain permissions to be 
 *		granted (or not granted) by the conductor.
 *
 *	Formal Parameters:
 *		conference_id		(i) ID of conference.
 *		grant_permission	(i) Flag indicating whether asking for a certain
 *									permission or giving up that permission.
 *
 *	Return Value:
 *		GCC_NO_ERROR					- Function completed successfully.
 *		GCC_ALLOCATION_FAILURE			- A resource error occurred.
 *		GCC_INVALID_CONFERENCE			- Conference ID is invalid.
 *
 *  Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */


/*
 *	GCCError	AppRosterInquireConfirm(
 *							GCCConfID				conference_id,
 *							CAppRosterMsg				*roster_message,
 *							GCCResult					result );
 *
 *	Public member function of CBaseSap.
 *
 *	Function Description:
 *		This routine is called in order to return a requested list of
 *		application rosters to an application or the node controller.
 *
 *	Formal Parameters:
 *		conference_id		(i) ID of conference.
 *		roster_message		(i) Roster message object containing the roster data
 *		result				(i) Result code indicating if call is successful.
 *
 *	Return Value:
 *		GCC_NO_ERROR					- Function completed successfully.
 *		GCC_ALLOCATION_FAILURE			- A resource error occurred.
 *
 *  Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */


/*
 *	GCCError	ConfRosterInquireConfirm (
 *							GCCConfID				conference_id,
 *							PGCCConferenceName			conference_name,
 *							LPSTR           			conference_modifier,
 *							LPWSTR						pwszConfDescriptor,
 *							CConfRoster	  				*conference_roster,
 *							GCCResult					result );
 *
 *	Public member function of CBaseSap.
 *
 *	Function Description:
 *		This routine is called in order to return a requested conference
 *		roster to an application or the node controller.
 *
 *	Formal Parameters:
 *		conference_id			(i) ID of conference.
 *		conference_name			(i) Name of conference.
 *		conference_modifier		(i) Name modifier for conference.
 *		pwszConfDescriptor		(i) Desciptor string for conference.
 *		conference_roster		(i) The conference roster being returned.
 *		result					(i) Result code indicating result of call.
 *
 *	Return Value:
 *		GCC_NO_ERROR					- Function completed successfully.
 *		GCC_ALLOCATION_FAILURE			- A resource error occurred.
 *
 *  Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */


/*
 *	GCCError	AppInvokeConfirm( 	
 *							GCCConfID					conference_id,
 *							CInvokeSpecifierListContainer	*invoke_list,
 *							GCCResult						result);
 *
 *	Public member function of CBaseSap.
 *
 *	Function Description:
 *		This routine is called in order to confirm a call requesting application
 *		invocation.
 *
 *	Formal Parameters:
 *		conference_id		(i) ID of conference.
 *		invoke_list			(i) List of APE attempted to be invoked.
 *		result				(i) Result code indicating result of call.
 *
 *	Return Value:
 *		GCC_NO_ERROR					- Function completed successfully.
 *		GCC_ALLOCATION_FAILURE			- A resource error occurred.
 *
 *  Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */


/*
 *	GCCError	AppInvokeIndication (
 *							GCCConfID					conference_id,
 *							CInvokeSpecifierListContainer	*invoke_list,
 *							UserID							invoking_node_id);
 *
 *	Public member function of CBaseSap.
 *
 *	Function Description:
 *		This routine is called in order to send an indication to an application
 *		or node controller that a request for application invocation has been
 *		made.
 *
 *	Formal Parameters:
 *		conference_id		(i) ID of conference.
 *		invoke_list			(i) List of APE's to be invoked.
 *		invoking_node_id	(i) ID of node requesting the invoke.
 *
 *	Return Value:
 *		GCC_NO_ERROR					- Function completed successfully.
 *		GCC_ALLOCATION_FAILURE			- A resource error occurred.
 *
 *  Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */


/*
 *	GCCError	ConductorInquireConfirm (
 *							UserID					conductor_node_id,
 *							GCCResult				result,
 *							BOOL				permission_flag,
 *							BOOL				conducted_mode,
 *							GCCConfID			conference_id);
 *
 *	Public member function of CBaseSap.
 *
 *	Function Description:
 *		This routine is called in order to return conductorship information
 *		which has been requested.
 *
 *	Formal Parameters:
 *		conductor_node_id			(i) Node ID of conducting node.
 *		result						(i) Result of call.
 *		permission_flag				(i) Flag indicating whether or not local
 *											node has conductorship permission.
 *		conducted_mode				(i) Flag indicating whether or not 
 *											conference is in conducted mode.
 *		conference_id				(i) ID of conference.
 *
 *	Return Value:
 *		GCC_NO_ERROR					- Function completed successfully.
 *		GCC_ALLOCATION_FAILURE			- A resource error occurred.
 *
 *  Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */


/*
 *	GCCError	ConductorAssignIndication (
 *							UserID					conductor_user_id,
 *							GCCConfID			conference_id);
 *
 *	Public member function of CBaseSap.
 *
 *	Function Description:
 *		This routine is called in order to send an indication to an application
 *		or node controller that a request has been made to assign conductorship.
 *
 *	Formal Parameters:
 *		conductor_user_id			(i) Node ID of conductor.
 *		conference_id				(i) ID of conference.
 *
 *	Return Value:
 *		GCC_NO_ERROR					- Function completed successfully.
 *		GCC_ALLOCATION_FAILURE			- A resource error occurred.
 *
 *  Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */


/*
 *	GCCError	ConductorReleaseIndication (
 *							GCCConfID			conference_id);
 *
 *	Public member function of CBaseSap.
 *
 *	Function Description:
 *		This routine is called in order to send an indication to an application
 *		or node controller that a request for releasing conductorship has been
 *		made.
 *
 *	Formal Parameters:
 *		conference_id		(i) ID of conference.
 *
 *	Return Value:
 *		GCC_NO_ERROR					- Function completed successfully.
 *		GCC_ALLOCATION_FAILURE			- A resource error occurred.
 *
 *  Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */


/*
 *	GCCError	ConductorPermitGrantIndication (	
 *							GCCConfID			conference_id,
 *							UINT					number_granted,
 *							PUserID					granted_node_list,
 *							UINT					number_waiting,
 *							PUserID					waiting_node_list,
 *							BOOL				permission_is_granted);
 *
 *	Public member function of CBaseSap.
 *
 *	Function Description:
 *		This routine is called in order to send an indication to an application
 *		or node controller that a request for permission from the conductor
 *		has been made.
 *
 *	Formal Parameters:
 *		conference_id				(i) ID of conference.
 *		number_granted				(i) Number of nodes permission is requested
 *											for.
 *		granted_node_list			(i) List of node ID's for nodes to be
 *											granted permission.
 *		number_waiting				(i) Number of nodes waiting for permission.
 *		waiting_node_list			(i) List of nodes waiting for permission.
 *		permission_is_granted		(i) Flag indicating whether permission is
 *											granted.
 *
 *	Return Value:
 *		GCC_NO_ERROR					- Function completed successfully.
 *		GCC_ALLOCATION_FAILURE			- A resource error occurred.
 *
 *  Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */


/*
 *	GCCError	ConfRosterReportIndication (
 *							GCCConfID				conference_id,
 *							CConfRosterMsg				*roster_message);
 *
 *	Public member function of CBaseSap.
 *
 *	Function Description:
 *		This routine is called in order to indicate to applications and the
 *		node controller that the conference roster has been updated.
 *
 *	Formal Parameters:
 *		conference_id		(i) ID of conference.
 *		roster_message		(i) Roster message object holding the updated
 *									roster information.
 *
 *	Return Value:
 *		GCC_NO_ERROR					- Function completed successfully.
 *		GCC_ALLOCATION_FAILURE			- A resource error occurred.
 *
 *  Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */


/*
 *	GCCError	ApplicationRosterReportIndication (
 *							GCCConfID				conference_id,
 *							CAppRosterMsg				*roster_message);
 *
 *	Public member function of CBaseSap.
 *
 *	Function Description:
 *		This routine is called in order to indicate to applications and the
 *		node controller that the list of application rosters has been updated.
 *
 *	Formal Parameters:
 *		conference_id		(i) ID of conference.
 *		roster_message		(i) Roster message object holding the updated
 *									roster information.
 *
 *	Return Value:
 *		GCC_NO_ERROR					- Function completed successfully.
 *		GCC_ALLOCATION_FAILURE			- A resource error occurred.
 *
 *  Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\remdsk\rds\t120\h\t120qos.h ===
extern LPIQOS				g_pIQoS;

extern DWORD g_dwLastQoSCB;
extern DWORD g_dwSentSinceLastQoS;

typedef struct _t120rrq
{
	int cResourceRequests;
	RESOURCEREQUEST aResourceRequest[1];
}T120RRQ;

extern T120RRQ g_aRRq;

extern HRESULT CALLBACK QosNotifyDataCB (
		LPRESOURCEREQUESTLIST lpResourceRequestList,
		DWORD dwThis);
extern VOID InitializeQoS( VOID );
extern VOID DeInitializeQoS( VOID );
extern VOID MaybeReleaseQoSResources( VOID );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\remdsk\rds\t120\h\spacket.h ===
/*
 *	spacket.h
 *
 *	Copyright (c) 1997-98 by Microsoft Corporation, Redmond, WA
 *
 *	Abstract:
 *		This is the interface file for the SimplePacket class.  Instances of this
 *		class represent Protocol Data Units (PDUs) as they flow through the
 *		system.  Objects of this class can not be instantiated, because it's a 
 *		pure virtual class.  It exists only to be inherited from.  The Packet
 *		and DataPacket classes inherit from this one.  
 *
 *		A packet object can be created in 2 different ways.  It can be created
 *		with either decoded data or encoded data.  During instantiation, the
 *		new packet object will calculate how much memory it will need to
 *		hold both the encoded and decoded data, and attempts to allocate that
 *		memory.  If it cannot, then it will report an error, and the newly
 *		created object should be immediately destroyed.  If the allocations are
 *		successful, then the packet will report success, but WILL NOT yet put
 *		any data into those allocated buffers.
 *
 *		When a Lock message is sent to the object, it will put encoded
 *		data into the pre-allocated encode buffer.  If the packet was created
 *		with decoded data, then this will entail an encode operation.  However,
 *		if the packet was created with encoded data, then it is smart enough
 *		to just COPY the encoded data into the internal buffer, thus avoiding
 *		the overhead associated with the encode operation.
 *                  
 *		When a Lock message is sent to the object, it will put decoded
 *		data into the pre-allocated decode buffer.  If the packet was created
 *		with encoded data, then this will entail a decode operation.  However,
 *		if the packet was created with decoded data, then it is smart enough
 *		to just COPY the decoded data into the internal buffer, thus avoiding
 *		the overhead associated with the decode operation.
 *                  
 *	Caveats:
 *		None.
 *
 *	Authors:
 *		Christos Tsollis
 */

#ifndef _SIMPLE_PACKET_
#define _SIMPLE_PACKET_

/*
 *	This typedef is used to define possible return values from various public
 *	member functions of this class.
 */
typedef	enum
{
	PACKET_NO_ERROR,
	PACKET_MALLOC_FAILURE,
	PACKET_INCOMPATIBLE_PROTOCOL
} PacketError;
typedef	PacketError * 		PPacketError;

/*
 *	 Definition of class Packet.
 */

class SimplePacket
{
public:
							SimplePacket(BOOL fPacketDirectionUp);
	virtual					~SimplePacket(void) = 0;

	Void					Lock(void)
							{
								InterlockedIncrement(&lLock);
								ASSERT (lLock > 0);
							};
	UINT					GetEncodedDataLength(void) 
							{ 
								return (Encoded_Data_Length); 
							};

	void					Unlock(void);
			LPBYTE			GetEncodedData (void) 
							{ 
								ASSERT (m_EncodedPDU);
								return m_EncodedPDU;
							};
	virtual PVoid			GetDecodedData(void) = 0;
	virtual BOOL			IsDataPacket (void) = 0;
	virtual int				GetPDUType (void) = 0;

protected:
	
	long			lLock;
	LPBYTE			m_EncodedPDU;			// The encoded data pdu.
	BOOL			Packet_Direction_Up;
	UINT			Encoded_Data_Length; 	// the size of the whole encoded PDU.
};


/*
 *	SimplePacket ()
 *
 *	Functional Description:
 *		This is the default constructor of a SimplePacket.  It initializes 
 *		the few member variables to default values.
 *
 
/*
 *	~SimplePacket ()
 *
 *	Functional Description:
 *		Destructor for the SimplePacket class.
 *
 *	Formal Parameters:
 *		None.
 *
 *	Return Value:
 *		None.
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

/*
 *	GetEncodedData ()
 *
 *	Functional Description:
 *		The GetEncodedData method returns a pointer to the encoded data
 *		buffer.  If the Packet object is oriented differently than desired
 *		by the caller of this method, then the packet coder is called to
 *		reverse the direction of the PDU.
 *
 *	Formal Parameters:
 *		None.
 *
 *	Return Value:
 *		A pointer to the encoded data.  If an encoding error occurs, this
 *		method will return NULL.
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

/*
 *	GetDecodedData ()
 *
 *	Functional Description:
 *		The GetDecodedData method returns a pointer to the decoded data
 *		buffer.  
 *
 *	Formal Parameters:
 *		None.
 *
 *	Return Value:
 *		A pointer to the decoded data.  If an decoding error occurs, this
 *		method will return NULL.
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\remdsk\rds\t120\h\tprtsec.h ===
/*
 *	tprtsec.h
 *
 *	Copyright (c) 1997 by Microsoft Corp.
 *
 *	Author:
 *		Claus T. Giloi
 */

#ifndef	_TPRTSEC
#define	_TPRTSEC


#define SECURITY_WIN32
#include "sspi.h"
#include "spseal.h"
#include "schnlsp.h"

typedef BOOL (WINAPI *PFN_SSL_EMPTY_CACHE)(VOID);
#define SZ_SSLEMPTYCACHE "SslEmptyCache"

#ifdef UNICODE
#error "Compile time character width conflict"
// Above entry point strings need to be changed to unicode equivalents
// or abstracted.
#endif // UNICODE

/*
 *	This typedef defines the errors that can be returned from calls that are
 *	specific to TransportSecurity classes.
 */
typedef	enum
{
	TPRTSEC_NOERROR,
	TPRTSEC_NODLL,
	TPRTSEC_NOENTRYPT,
	TPRTSEC_SSPIFAIL,
	TPRTSEC_NOMEM,
	TPRTSEC_INVALID_PARAMETER,
	TPRTSEC_INCOMPLETE_CONTEXT,
	TPRTSEC_INVALID_STATE
} TransportSecurityError;

/*
 * This typedef defines the states that a security context object can be
 * in.
 */
typedef enum
{
	SECCTX_STATE_NEW,
	SECCTX_STATE_INIT,
	SECCTX_STATE_ACCEPT,
	SECCTX_STATE_INIT_COMPLETE,
	SECCTX_STATE_ACCEPT_COMPLETE,
	SECCTX_STATE_ERROR
} SecurityContextState;

/*
 *	This is simply a forward reference for the class defined below.  It is used
 *	in the definition of the owner callback structure defined in this section.
 */
class SecurityInterface;
typedef	SecurityInterface *		PSecurityInterface;
class SecurityContext;
typedef	SecurityContext *		PSecurityContext;

#ifdef DEBUG
extern void dumpbytes(PSTR szComment, PBYTE p, int cb);
#endif // DEBUG
extern BOOL InitCertList ( SecurityInterface * pSI, HWND hwnd);
extern BOOL SetUserPreferredCert ( SecurityInterface * pSI, DWORD dwCertID);

class SecurityInterface
{

	friend class SecurityContext;

	public:
								SecurityInterface ();
								~SecurityInterface ();

		TransportSecurityError Initialize ();
		TransportSecurityError InitializeCreds (PCCERT_CONTEXT);
		TransportSecurityError GetLastError(VOID) { return LastError; };

		BOOL GetUserCert(PBYTE pInfo, PDWORD pcbInfo);
	
	private:

		HINSTANCE				hSecurityDll;
		INIT_SECURITY_INTERFACE pfnInitSecurityInterface;
		PSecurityFunctionTable pfnTable;
		PFN_SSL_EMPTY_CACHE pfn_SslEmptyCache;
		

		PBYTE		m_pbEncodedCert;
		DWORD		m_cbEncodedCert;

		BOOL		bInboundCredentialValid;
		BOOL		bOutboundCredentialValid;
		CredHandle hInboundCredential;
		CredHandle hOutboundCredential;
		TimeStamp tsExpiry;
		TransportSecurityError LastError;
};


class SecurityContext
{
	public:

		SecurityContext (PSecurityInterface pSI, LPCSTR szHostName);
		~SecurityContext ();

		TransportSecurityError Initialize (PBYTE pData, DWORD cbData);
		TransportSecurityError Accept (PBYTE pData, DWORD cbData);
		TransportSecurityError Encrypt(LPBYTE pBufIn1, UINT cbBufIn1,
									LPBYTE pBufIn2, UINT cbBufIn2,
									LPBYTE *ppBufOut, UINT *pcbBufOut);
		TransportSecurityError Decrypt( PBYTE pszBuf,
								  DWORD cbBuf);
		PVOID GetTokenBuf(VOID) { return OutBuffers[0].pvBuffer; };
		ULONG GetTokenSiz(VOID) { return OutBuffers[0].cbBuffer; };
		BOOL ContinueNeeded(VOID) { return fContinueNeeded; };
		BOOL StateComplete(VOID) { return
									scstate == SECCTX_STATE_INIT_COMPLETE ||
									scstate == SECCTX_STATE_ACCEPT_COMPLETE; };
		BOOL WaitingForPacket(VOID) { return
									scstate == SECCTX_STATE_NEW ||
									scstate == SECCTX_STATE_ACCEPT ||
									scstate == SECCTX_STATE_INIT; };
		TransportSecurityError AdvanceState(PBYTE pBuf,DWORD cbBuf);
		BOOL EncryptOutgoing(VOID)
			{ return scstate == SECCTX_STATE_INIT_COMPLETE; };
		BOOL DecryptIncoming(VOID)
			{ return scstate == SECCTX_STATE_ACCEPT_COMPLETE; };
		ULONG GetStreamHeaderSize(VOID) { return Sizes.cbHeader; };
		ULONG GetStreamTrailerSize(VOID) { return Sizes.cbTrailer; };
		TransportSecurityError GetLastError(VOID) { return LastError; };
		BOOL GetUserCert(PBYTE pInfo, PDWORD pcbInfo);
		BOOL Verify(VOID);

	private:

		TransportSecurityError InitContextAttributes(VOID);

		PSecurityInterface pSecurityInterface;
		SecurityContextState		scstate;
		CHAR			szTargetName[128]; // Long enough for any dotted-decimal
										  // address, followed by 2 dwords in
										  // hex.
		BOOL			bContextHandleValid;
		CtxtHandle		hContext;
		TimeStamp		Expiration;
		SecPkgContext_StreamSizes Sizes;
		SecBufferDesc	OutputBufferDescriptor;
		SecBufferDesc	InputBufferDescriptor;
		SecBuffer		OutBuffers[1];
		SecBuffer		InBuffers[2];
		ULONG			ContextRequirements;
		ULONG			ContextAttributes;
		BOOL			fContinueNeeded;
		TransportSecurityError LastError;

};

// Codes used for GetSecurityInfo()
#define NOT_DIRECTLY_CONNECTED		-1
		
#endif // _TPRTSEC
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\remdsk\rds\t120\h\token.h ===
/*
 *	token.h
 *
 *	Copyright (c) 1993 - 1995 by DataBeam Corporation, Lexington, KY
 *
 *	Abstract:
 *		This is the interface file for the Token class.  Objects of this class
 *		represent tokens in the MCS environment.  Whenever a token is allocated
 *		by a user, one of these objects is created.  Its job is to handle all
 *		requests that are specific to the token ID with which it is associated.
 *
 *		Tokens in the MCS environment are used for critical resource management.
 *		The exact use of tokens is up to the user applications attaching to
 *		MCS.  They are provided as a generic resource.
 *
 *		Tokens can be "owned" by one or more users.  There are two types of
 *		ownership.  There is exclusive ownership, where only one user can
 *		own the token at a time.  That user has "grabbed" the token.  And there
 *		is non-exclusive ownership, where several users can own the token at
 *		the same time.  Those users have "inhibited" the token.  It is not
 *		possible to mix exclusive and non-exclusive ownership.
 *
 *		If a user has grabbed a token, that same user can inhibit the token,
 *		thus converting to non-exclusive ownership.  Similarly, if a user is
 *		the sole inhibitor of a token, that user can grab the token, thus
 *		converting to exclusive ownership.
 *
 *		During a domain merge operation, it is necessary to merge tokens upward
 *		to the new Top Provider of the enlarged domain.  This class also defines
 *		a member function allowing it to be told to issue a merge request with
 *		all of its state contained therein.
 *
 *	Caveats:
 *		None.
 *
 *	Author:
 *		James P. Galvin, Jr.
 */
#ifndef	_TOKEN_
#define	_TOKEN_

/*
 *	This is the class definition for the Token class.
 */
class	Token
{
public:

	Token (
			TokenID				token_id,
			PDomain             local_provider,
			PConnection         top_provider,
			CChannelList2      *channel_list,
			CAttachmentList    *attachment_list);
	Token (
			TokenID				token_id,
			PDomain             local_provider,
			PConnection         top_provider,
			CChannelList2      *channel_list,
			CAttachmentList    *attachment_list,
			TokenState			token_state,
			UserID				grabber,
			CUidList           *inhibitor_list,
			UserID				recipient);
	~Token ();

    void    SetTopProvider(PConnection top_provider) { m_pConnToTopProvider = top_provider; }
    BOOL    IsTopProvider(void) { return (m_pConnToTopProvider == NULL); }

				TokenState	GetTokenState () { return (Token_State); };
				BOOL    	IsValid ();
				Void		IssueMergeRequest ();
		Void		TokenGrabRequest (
									CAttachment        *originator,
									UserID				uidInitiator,
									TokenID				token_id);
		Void		TokenGrabConfirm (
									Result				result,
									UserID				uidInitiator,
									TokenID				token_id,
									TokenStatus			token_status);
		Void		TokenInhibitRequest (
									CAttachment        *originator,
									UserID				uidInitiator,
									TokenID				token_id);
		Void		TokenInhibitConfirm (
									Result				result,
									UserID				uidInitiator,
									TokenID				token_id,
									TokenStatus			token_status);
		Void		TokenGiveRequest (
									CAttachment        *originator,
									PTokenGiveRecord	pTokenGiveRec);
		Void		TokenGiveIndication (
									PTokenGiveRecord	pTokenGiveRec);
		Void		TokenGiveResponse (
									Result				result,
									UserID				receiver_id,
									TokenID				token_id);
		Void		TokenGiveConfirm (
									Result				result,
									UserID				uidInitiator,
									TokenID				token_id,
									TokenStatus			token_status);
		Void		TokenPleaseRequest (
									UserID				uidInitiator,
									TokenID				token_id);
		Void		TokenPleaseIndication (
									UserID				uidInitiator,
									TokenID				token_id);
		Void		TokenReleaseRequest (
									CAttachment        *originator,
									UserID				uidInitiator,
									TokenID				token_id);
		Void		TokenReleaseConfirm (
									Result				result,
									UserID				uidInitiator,
									TokenID				token_id,
									TokenStatus			token_status);
		Void		TokenTestRequest (
									CAttachment        *originator,
									UserID				uidInitiator,
									TokenID				token_id);
		Void		TokenTestConfirm (
									UserID				uidInitiator,
									TokenID				token_id,
									TokenStatus			token_status);

	private:
				BOOL    	ValidateUserID (
									UserID				user_id);
			CAttachment    *GetUserAttachment (
									UserID				user_id);
				Void		IssueTokenReleaseIndication (
									UserID				user_id);
				Void		BuildAttachmentList (
									CUidList            *user_id_list,
									CAttachmentList     *attachment_list);

		TokenID				Token_ID;
		PDomain             m_pDomain;
		PConnection         m_pConnToTopProvider;
		CChannelList2      *m_pChannelList2;
		CAttachmentList    *m_pAttachmentList;
		TokenState			Token_State;
		UserID				m_uidGrabber;
		CUidList			m_InhibitorList;
		UserID				m_uidRecipient;
};

/*
 *	Token (
 *			TokenID				token_id,
 *			PDomain     		local_provider,
 *			PConnection 		top_provider,
 *			PChannelList		channel_list,
 *			PAttachmentList		attachment_list)
 *
 *	Functional Description:
 *		This is the constructor for the Token class.  It simply initializes
 *		local instance variables with the passed in values.  It also marks
 *		the state of the token as available.
 *
 *	Formal Parameters:
 *		token_id (i)
 *			This is the token ID that this token object is associated with.
 *		local_provider (i)
 *			This is a pointer to the local provider.  A Token object will
 *			never actually send a command to the local provider, but it needs
 *			this value to use a parameter when it sends commands to various
 *			attachments (since it is doing so on behalf of the local provider).
 *		top_provider (i)
 *			This is a pointer to the top provider.  This is used by the
 *			Token object when it needs to issue a request to the Top
 *			Provider.
 *		channel_list (i)
 *			This is a pointer to the domain's channel list, which identifies
 *			all valid channels in the domain.  This is used by token objects
 *			to validate user IDs.
 *		attachment_list (i)
 *			This is a pointer to the domain's attachment list, which identifies
 *			all valid attachments in the domain.  This is used by token
 *			objects to validate joined attachments.
 *
 *	Return Value:
 *		None.
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

/*
 *	Token (
 *			TokenID				token_id,
 *			PDomain     		local_provider,
 *			PConnection 		top_provider,
 *			PChannelList		channel_list,
 *			PAttachmentList		attachment_list,
 *			TokenState			token_state,
 *			UserID				grabber,
 *			CUidList           *inhibitor_list,
 *			UserID				recipient)
 *
 *	Functional Description:
 *		This is the constructor for the Token class.  It simply initializes
 *		local instance variables with the passed in values.  It also marks
 *		the state of the token as available.
 *
 *	Formal Parameters:
 *		token_id (i)
 *			This is the token ID that this token object is associated with.
 *		local_provider (i)
 *			This is a pointer to the local provider.  A Token object will
 *			never actually send a command to the local provider, but it needs
 *			this value to use a parameter when it sends commands to various
 *			attachments (since it is doing so on behalf of the local provider).
 *		top_provider (i)
 *			This is a pointer to the top provider.  This is used by the
 *			Token object when it needs to issue a request to the Top
 *			Provider.
 *		channel_list (i)
 *			This is a pointer to the domain's channel list, which identifies
 *			all valid channels in the domain.  This is used by token objects
 *			to validate user IDs.
 *		attachment_list (i)
 *			This is a pointer to the domain's attachment list, which identifies
 *			all valid attachments in the domain.  This is used by token
 *			objects to validate joined attachments.
 *		token_state (i)
 *			This is the state of the token being merged.
 *		grabber (i)
 *			This is the user ID of the user who has the token grabbed (this is
 *			only valid if the token state is grabbed or giving).
 *		inhibitor_list (i)
 *			This is a list of the users who have the token inhibited (this is
 *			only valid if the token state is inhibited).
 *		recipient (i)
 *			This is the user ID of the user who is being offered the token
 *			as part of a give operation (this is only valid if the token state
 *			is giving or given).
 *
 *	Return Value:
 *		None.
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

/*
 *	~Token ()
 *
 *	Functional Description:
 *		This is a virtual destructor defined for the Token class.  It does
 *		nothing at this time.
 *
 *	Formal Parameters:
 *		None.
 *
 *	Return Value:
 *		None.
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

/*
 *	Void		SetTopProvider (
 *						PConnection		top_provider)
 *
 *	Functional Description:
 *		This member function is used to change the identity of the Top Provider
 *		in an existing token.  The only time this will really occur is when
 *		a provider that used to be the Top Provider merges into another
 *		domain, and therefore ceases to be the Top Provider.  When the merge
 *		operation has been successfully completed, this function allows the
 *		domain to inform all of its Token objects about the identity of
 *		the new Top Provider.
 *
 *	Formal Parameters:
 *		top_provider (i)
 *			This is a pointer to the new Top Provider.
 *
 *	Return Value:
 *		None.
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

/*
 *	TokenState		GetTokenState ()
 *
 *	Functional Description:
 *		This function returns the current state of the token.  This is used
 *		by the caller primarily during a merge operation, when decisions have
 *		to made about what tokens can and cannot be merged.
 *
 *	Formal Parameters:
 *		None.
 *
 *	Return Value:
 *		TOKEN_AVAILABLE if the token is not in use.
 *		TOKEN_GRABBED if the token is currently grabbed.
 *		TOKEN_INHIBITED if the token is currently inhiited.
 *		TOKEN_GIVING if the token is currently in the giving state.
 *		TOKEN_GIVEN if the token is currently in the given state.
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

/*
 *	BOOL    	IsValid ()
 *
 *	Functional Description:
 *		This function returns TRUE if the token is still valid, or FALSE if the
 *		token needs to be deleted.  A token is valid if it has ANY owners
 *		(grabbers, inhibitors, or recipient).
 *
 *	Formal Parameters:
 *		None.
 *
 *	Return Value:
 *		TRUE if the token is valid.
 *		FALSE if the token needs to be deleted.
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

/*
 *	Void			IssueMergeRequest ()
 *
 *	Functional Description:
 *		This function is called during a domain merge operation.  It causes
 *		the token object to pack it state and send it out in a merge token
 *		request to the top provider.
 *
 *	Formal Parameters:
 *		None.
 *
 *	Return Value:
 *		None.
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

/*
 *	Void			TokenGrabRequest (
 *							PCommandTarget		originator,
 *							UserID				uidInitiator,
 *							TokenID				token_id)
 *
 *	Functional Description:
 *		This function is called when a user wishes to grab a token.  Depending
 *		on the current state of the token, the request will either succeed or
 *		fail.  Either way, an appropriate token grab confirm will be issued
 *		to the requesting user.
 *
 *	Formal Parameters:
 *		originator (i)
 *			This is a pointer to the attachment that leads to the originator
 *			of the request.
 *		uidInitiator (i)
 *			This is the user ID of the user that originated the request.
 *		token_id (i)
 *			This is the token being acted upon.
 *
 *	Return Value:
 *		None.
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

/*
 *	Void			TokenGrabConfirm (
 *							PCommandTarget		originator,
 *							Result				result,
 *							UserID				uidInitiator,
 *							TokenID				token_id,
 *							TokenStatus			token_status)
 *
 *	Functional Description:
 *		This function is called as a result of the top provider answering a
 *		previous grab request.  It tells the user whether or not the request
 *		succeeded.
 *
 *	Formal Parameters:
 *		originator (i)
 *			This is a pointer to the attachment that leads to the originator
 *			of the request.
 *		result (i)
 *			This is the result of the request.  RESULT_SUCCESSFUL indicates
 *			that the token was successfully grabbed.
 *		uidInitiator (i)
 *			This is the user ID of the user that originated the request.
 *		token_id (i)
 *			This is the token being acted upon.
 *		token_status (i)
 *			This is the status of the token after this request is processed.
 *
 *	Return Value:
 *		None.
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

/*
 *	Void			TokenInhibitRequest (
 *							PCommandTarget		originator,
 *							UserID				uidInitiator,
 *							TokenID				token_id)
 *
 *	Functional Description:
 *		This function is called when a user wishes to inhibit a token.
 *		Depending on the current state of the token, the request will either
 *		succeed or fail.  Either way, an appropriate token inhibit confirm will
 *		be issued to the requesting user.
 *
 *	Formal Parameters:
 *		originator (i)
 *			This is a pointer to the attachment that leads to the originator
 *			of the request.
 *		uidInitiator (i)
 *			This is the user ID of the user that originated the request.
 *		token_id (i)
 *			This is the token being acted upon.
 *
 *	Return Value:
 *		None.
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

/*
 *	Void			TokenInhibitConfirm (
 *							PCommandTarget		originator,
 *							Result				result,
 *							UserID				uidInitiator,
 *							TokenID				token_id,
 *							TokenStatus			token_status)
 *
 *	Functional Description:
 *		This function is called as a result of the top provider answering a
 *		previous inhibit request.  It tells the user whether or not the request
 *		succeeded.
 *
 *	Formal Parameters:
 *		originator (i)
 *			This is a pointer to the attachment that leads to the originator
 *			of the request.
 *		result (i)
 *			This is the result of the request.  RESULT_SUCCESSFUL indicates
 *			that the token was successfully inhibited.
 *		uidInitiator (i)
 *			This is the user ID of the user that originated the request.
 *		token_id (i)
 *			This is the token being acted upon.
 *		token_status (i)
 *			This is the status of the token after this request is processed.
 *
 *	Return Value:
 *		None.
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

/*
 *	Void	TokenGiveRequest (
 *					PCommandTarget		originator,
 *					PTokenGiveRecord	pTokenGiveRec)
 *
 *	Functional Description:
 *		This function is called when a user wishes to give a token to another
 *		user.  Depending on the current state of the token, the request will
 *		either succeed or fail.  Either way, an appropriate token grab confirm
 *		will be issued to the requesting user.
 *
 *	Formal Parameters:
 *		originator (i)
 *			This is a pointer to the attachment that leads to the originator
 *			of the request.
 *		pTokenGiveRec (i)
 *			This is the address of a structure containing the following information:
 *			The ID of the user attempting to give away the token.
 *			The ID of the token being given.
 *			The ID of the user that the token is being given to.
 *
 *	Return Value:
 *		None.
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

/*
 *	Void	TokenGiveIndication (
 *					PCommandTarget		originator,
 *					PTokenGiveRecord	pTokenGiveRec)
 *
 *	Functional Description:
 *		This function is called when the top provider wants to indicate to a
 *		user that another user is offering them a token.
 *
 *	Formal Parameters:
 *		originator (i)
 *			This is a pointer to the attachment that leads to the originator
 *			of the request.
 *		pTokenGiveRec (i)
 *			This is the address of a structure containing the following information:
 *			The ID of the user attempting to give away the token.
 *			The ID of the token being given.
 *			The ID of the user that the token is being given to.
 *
 *	Return Value:
 *		None.
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

/*
 *	Void	TokenGiveResponse (
 *					PCommandTarget		originator,
 *					Result				result,
 *					UserID				receiver_id,
 *					TokenID				token_id)
 *
 *	Functional Description:
 *		This function is called in response to a previous give indication.  It
 *		contains the user's answer as to whether or not the token was
 *		accepted.
 *
 *	Formal Parameters:
 *		originator (i)
 *			This is a pointer to the attachment that leads to the originator
 *			of the request.
 *		result (i)
 *			This is the result of the request.  RESULT_SUCCESSFUL indicates that
 *			the recipient has accepted the token.
 *		token_id (i)
 *			This is the token being acted upon.
 *		receiver_id (i)
 *			This is the ID of the user that is to receive the token.
 *
 *	Return Value:
 *		None.
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

/*
 *	Void	TokenGiveConfirm (
 *					PCommandTarget		originator,
 *					Result				result,
 *					UserID				uidInitiator,
 *					TokenID				token_id,
 *					TokenStatus			token_status)
 *
 *	Functional Description:
 *		This function is called to send a confirmation back to a user who
 *		is trying to give away a token.  It lets the user know whether or
 *		not the operation was successful.
 *
 *	Formal Parameters:
 *		originator (i)
 *			This is a pointer to the attachment that leads to the originator
 *			of the request.
 *		result (i)
 *			This is the result of the request.  RESULT_SUCCESSFUL indicates that
 *			the recipient has accepted the token.
 *		uidInitiator (i)
 *			This is the user ID of the user that originated the request.
 *		token_id (i)
 *			This is the token being acted upon.
 *		token_status (i)
 *			This is the status of the token after the operation.
 *
 *	Return Value:
 *		None.
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

/*
 *	Void	TokenPleaseRequest (
 *					PCommandTarget		originator,
 *					UserID				uidInitiator,
 *					TokenID				token_id)
 *
 *	Functional Description:
 *		This function is called when a user wishes to ask the current owners
 *		of a token to relinquish it.
 *
 *	Formal Parameters:
 *		originator (i)
 *			This is a pointer to the attachment that leads to the originator
 *			of the request.
 *		uidInitiator (i)
 *			This is the user ID of the user that originated the request.
 *		token_id (i)
 *			This is the token being acted upon.
 *
 *	Return Value:
 *		None.
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

/*
 *	Void	TokenPleaseIndication (
 *					PCommandTarget		originator,
 *					UserID				uidInitiator,
 *					TokenID				token_id)
 *
 *	Functional Description:
 *		This function is initially called by the top provider in response to
 *		a received token please request.  It is forwarded to all users who
 *		currently own the specified token, asking them to relinquish it.
 *
 *	Formal Parameters:
 *		originator (i)
 *			This is a pointer to the attachment that leads to the originator
 *			of the request.
 *		uidInitiator (i)
 *			This is the user ID of the user that originated the request.
 *		token_id (i)
 *			This is the token being acted upon.
 *
 *	Return Value:
 *		None.
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

/*
 *	BOOL    		TokenReleaseRequest (
 *							PCommandTarget		originator,
 *							UserID				uidInitiator,
 *							TokenID				token_id)
 *
 *	Functional Description:
 *		This function is called when a user wishes to release a token.
 *		Depending on the current state of the token, the request will either
 *		succeed or fail.  Either way, an appropriate token release confirm will
 *		be issued to the requesting user.
 *
 *	Formal Parameters:
 *		originator (i)
 *			This is a pointer to the attachment that leads to the originator
 *			of the request.
 *		uidInitiator (i)
 *			This is the user ID of the user that originated the request.
 *		token_id (i)
 *			This is the token being acted upon.
 *
 *	Return Value:
 *		None.
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

/*
 *	Void			TokenReleaseConfirm (
 *							PCommandTarget		originator,
 *							Result				result,
 *							UserID				uidInitiator,
 *							TokenID				token_id,
 *							TokenStatus			token_status)
 *
 *	Functional Description:
 *		This function is called as a result of the top provider answering a
 *		previous release request.  It tells the user whether or not the request
 *		succeeded.
 *
 *	Formal Parameters:
 *		originator (i)
 *			This is a pointer to the attachment that leads to the originator
 *			of the request.
 *		result (i)
 *			This is the result of the request.  RESULT_SUCCESSFUL indicates
 *			that the token was successfully released.
 *		uidInitiator (i)
 *			This is the user ID of the user that originated the request.
 *		token_id (i)
 *			This is the token being acted upon.
 *		token_status (i)
 *			This is the status of the token after this request is processed.
 *
 *	Return Value:
 *		None.
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

/*
 *	Void			TokenTestRequest (
 *							PCommandTarget		originator,
 *							UserID				uidInitiator,
 *							TokenID				token_id)
 *
 *	Functional Description:
 *		This function is called when a user wishes to test the current state
 *		of a token.  The token will issue a token test confirm to the
 *		originating user containing the requested information.
 *
 *	Formal Parameters:
 *		originator (i)
 *			This is a pointer to the attachment that leads to the originator
 *			of the request.
 *		uidInitiator (i)
 *			This is the user ID of the user that originated the request.
 *		token_id (i)
 *			This is the token being acted upon.
 *
 *	Return Value:
 *		None.
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

/*
 *	Void			TokenTestConfirm (
 *							PCommandTarget		originator,
 *							UserID				uidInitiator,
 *							TokenID				token_id,
 *							TokenStatus			token_status)
 *
 *	Functional Description:
 *		This function is called as a result of the top provider answering a
 *		previous test request.  It tells the user the current state of the
 *		token.
 *
 *	Formal Parameters:
 *		originator (i)
 *			This is a pointer to the attachment that leads to the originator
 *			of the request.
 *		uidInitiator (i)
 *			This is the user ID of the user that originated the request.
 *		token_id (i)
 *			This is the token being tested.
 *		token_status (i)
 *			This is the current status of the token.
 *
 *	Return Value:
 *		None.
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\remdsk\rds\t120\h\tptif.h ===
/*
 *	tptif.h
 *
 *	Copyright (c) 1993 - 1995 by DataBeam Corporation, Lexington, KY
 *
 *	Abstract:
 *		This is the interface file for the TransportInterface class.
 *		This class provides a seamless interface to the TCP	transport stack.
 *	
 *		The public interface of this class includes a member function for each
 *		of the API routines that a user application would need to call.  The
 *		only API routines not directly accessible are those used for
 *		initialization and cleanup (which are automatically executed in the
 *		constructor and destructor, respectively).  When a user application
 *		needs to call one of the available API routines, it merely calls the
 *		equivalent member function within the proper instance of this class.
 *		The API routine will then be invoked using the same parameters.
 *	
 *		The destructor calls the cleanup routine within the DLL for which it is
 *		responsible.
 *
 *		The management plane functions include support for initialization and
 *		setup, as well as functions allowing MCS to poll the transport
 *		interfaces for activity.
 *	
 *	Caveats:
 *		None.
 *
 *	Author:
 *		James P. Galvin, Jr.
 */
#ifndef	_TRANSPORTINTERFACE_
#define	_TRANSPORTINTERFACE_

#include "tprtsec.h"

/*
 *	This typedef defines the errors that can be returned from calls that are
 *	specific to TransportInterface classes.  Note that the public member
 *	functions that map to transport stack calls do not return an error of this
 *	type.  Rather, they return an error as defined by the transport API (TRAPI).
 */
typedef	enum
{
	TRANSPORT_INTERFACE_NO_ERROR,
	TRANSPORT_INTERFACE_INITIALIZATION_FAILED,
	TRANSPORT_INTERFACE_ALLOCATION_FAILED,
	TRANSPORT_INTERFACE_NO_SUCH_CONNECTION,
	TRANSPORT_INTERFACE_CONNECTION_ALREADY_EXISTS
} TransportInterfaceError;
typedef	TransportInterfaceError *		PTransportInterfaceError;


class CTransportConnList2 : public CList2
{
    DEFINE_CLIST2(CTransportConnList2, PConnection, UINT)
    void AppendEx(PConnection p, TransportConnection XprtConn)
    {
        UINT nKey = PACK_XPRTCONN(XprtConn);
        Append(nKey, p);
    }
    PConnection FindEx(TransportConnection XprtConn)
    {
        UINT nKey = PACK_XPRTCONN(XprtConn);
        return Find(nKey);
    }
    PConnection RemoveEx(TransportConnection XprtConn)
    {
        UINT nKey = PACK_XPRTCONN(XprtConn);
        return Remove(nKey);
    }
};


/*
 *	These are the owner callback messages that a transport interface object
 *	can send.  They correspond directly to the messages that will be received
 *	from the various transport stacks.
 */
#define	CONNECT_CONFIRM				0
#define	DISCONNECT_INDICATION		1
#define	DATA_INDICATION				2
#define	STATUS_INDICATION			3
#define BUFFER_EMPTY_INDICATION		4
#define	WAIT_UPDATE_INDICATION		5

/*
 *	This is simply a forward reference for the class defined below.  It is used
 *	in the definition of the owner callback structure defined in this section.
 */
class TransportInterface;
typedef	TransportInterface *		PTransportInterface;

/*
 *	Owner Callback:	CONNECT_CONFIRM
 *	Parameter1:		Unused
 *	Parameter2:		TransportConnection		transport_connection
 *
 *	Usage:
 *		This owner callback is sent when a connect confirm is received from
 *		the transport layer.  This is to inform the recipient that a transport
 *		connection is now available for use.  Connect confirm will occur
 *		on outbound connections.  They represent a new transport connection
 *		that has resulted from this system calling a remote one.  As such,
 *		there should always be a registered owner of the transport connection
 *		(registration is a side-effect of the call to ConnectRequest).
 *
 *		So the connect confirm will be routed to the object that is the
 *		registered owner of the transport connection.  That object may now
 *		utilize the connection to transfer data.
 */

/*
 *	Owner Callback:	DISCONNECT_INDICATION
 *	Parameter1:		Unused
 *	Parameter2:		TransportConnection		transport_connection
 *
 *	Usage:
 *		This owner callback is sent when a disconnect indication is received
 *		from the transport layer.  This is to inform the recipient that a
 *		transport connection is no longer available for use.  If an object
 *		has explicitly registered itself as the owner of a transport connection,
 *		then it will receive the disconnect indication.  If there has been no
 *		such registration, then the disconnect indication will be sent to the
 *		default owner callback.
 *
 *		Once a disconnect indication has been issued for a given transport
 *		connection, that connection can no longer be used for anything.
 */

/*
 *	Owner Callback:	DATA_INDICATION
 *	Parameter1:		PDataIndicationInfo		data_indication_info
 *	Parameter2:		TransportConnection		transport_connection
 *
 *	Usage:
 *		This owner callback is sent when a data indication is received from
 *		the transport layer.  The transport data structure contains the address
 *		and length of the user data field that is associated with the data
 *		indication.  If an object in the system has explicitly registered
 *		ownership of the transport connection that carried the data (either
 *		through ConnectRequest or RegisterTransportConnection), then this
 *		callback will be sent to that object.  If no object has registered
 *		this transport connection, then the data will be sent to the default
 *		owner.
 */

/*
 *	Owner Callback:	STATUS_INDICATION
 *	Parameter1:		PTransportStatus		transport_status
 *	Parameter2:		Unused
 *
 *	Usage:
 *		This owner callback is just a pass-through of the status indication
 *		that comes from the transport layer.  It contains a pointer to a
 *		transport status structure that contains status information that
 *		originated from the stack represented by this object.  This is always
 *		passed to the default owner object.
 */

/*
 *	Owner Callback:	BUFFER_EMPTY_INDICATION
 *	Parameter1:		Unused
 *	Parameter2:		TransportConnection		transport_connection
 *
 *	Usage:
 *		This owner callback is a pass-through of the buffer empty indication
 *		that comes from the transport layer.  It is sent to the object that
 *		has registered ownership of the specified transport connection.  This
 *		indication tells that object that the transport layer can now accept
 *		more data.
 */

class Connection;
typedef Connection *PConnection;

/*
 *	This is the class definition for the TransportInterface class.  Remember,
 *	this class contains pure virtual functions which makes it an abstract base
 *	class.  It cannot be instantiated, but rather, exists to be inherited from.
 *	These derived classes will implement the behavior that is specific to a
 *	particular transport stack (or possibly just the interface to a particular
 *	transport stack).
 */
class TransportInterface
{
	public:
								TransportInterface (
									HANDLE			transport_transmit_event,
									PTransportInterfaceError
											transport_interface_error);
								~TransportInterface ();
		TransportInterfaceError RegisterTransportConnection (
									TransportConnection	transport_connection,
									PConnection			owner_object,
									BOOL				bNoNagle);
#ifdef NM_RESET_DEVICE
				TransportError 	ResetDevice (
									PChar				device_identifier);
#endif // NM_RESET_DEVICE
				TransportError 	ConnectRequest (
									TransportAddress	transport_address,
									BOOL				fSecure,
									BOOL				bNoNagle,
									PConnection			owner_object,
									PTransportConnection
														transport_connection);
				void		 	DisconnectRequest (
									TransportConnection	transport_connection);
				void			DataRequestReady () { 
									SetEvent (Transport_Transmit_Event); 
								};
				void		 	ReceiveBufferAvailable ();
				BOOL			GetSecurity( TransportConnection transport_connection );

				PSecurityInterface		pSecurityInterface;
		TransportInterfaceError	CreateConnectionCallback (
									TransportConnection	transport_connection,
									PConnection			owner_object);
				void			ConnectIndication (
									TransportConnection	transport_connection);
				void			ConnectConfirm (
									TransportConnection	transport_connection);
				void			DisconnectIndication (
									TransportConnection	transport_connection,
									ULONG               ulReason);
				TransportError	DataIndication (
									PTransportData		transport_data);
				void			BufferEmptyIndication (
									TransportConnection	transport_connection);

private:

		CTransportConnList2     m_TrnsprtConnCallbackList2;
		HANDLE					Transport_Transmit_Event;
};

/*
 *	TransportInterface (
 *			PTransportInterfaceError	transport_interface_error)
 *
 *	Functional Description:
 *		The constructor initializes the TCP transport code.
 *	
 *		The constructor also includes parameters specifying the default
 *		callback. This callback is used to inform the controller whenever an
 *		unexpected inbound connection is detected.  This gives the controller
 *		the opportunity to assign responsibility for the new connection to some
 *		other object in the system.
 *	
 *		If anything goes wrong in the constructor, the return value (whose
 *		address is passed as a constructor parameter) will be set to one of the
 *		failure codes.  If this happens, it is expected that whoever invoked the
 *		constructor (probably the controller), will immediately delete the
 *		object without using it.  Failure to do this WILL result in unexpected
 *		behavior.
 *
 *	Formal Parameters:
 *		default_owner_object (i)
 *			This is the address of the object that will handle all transport
 *			events for unregistered transport connections.  This includes
 *			connect indication, dicsonnect indication, and data indication.
 *			This object will also receive all state and message indications.
 *		default_owner_message_base (i)
 *			This is the base value to be used for all owner callback messages.
 *		transport_interface_error (o)
 *			This is where the return code will be stored so that the creator of
 *			this object can make sure that everything is okay before using the
 *			new object.  If this value is set to anything but success, the
 *			object should be destroyed immediately, without being used.
 *
 *	Return Value:
 *		Note: the return value is handled as a constructor parameter.
 *		TRANSPORT_INTERFACE_NO_ERROR
 *			Everything worked, and the object is ready for use.
 *		TRANSPORT_INTERFACE_INITIALIZATION_FAILED
 *			The initialization of the transport interface object failed.  It is
 *			therefore necessary to destroy the object without attempting to
 *			use it.
 *
 *	Side Effects:
 *		A DLL will be loaded into memory, for later use.
 *
 *	Caveats:
 */
 
/*
 *	~TransportInterface ()
 *
 *	Functional Description:
 *		The destructor frees up all resources used by the base class.  This
 *		is primarily associated with the callback list (which is maintained by
 *		this class).
 *
 *	Formal Parameters:
 *		Destructors have no parameters.
 *
 *	Return Value:
 *		Destructors have no return value.
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

/*
 *	TransportInterfaceError 	RegisterTransportConnection (
 *			TransportConnection		transport_connection,
 *			PConnection				owner_object,
 *			BOOL					bNoNagle)
 *
 *	Functional Description:
 *		When an inbound connection is detected, an entry is created in the
 *		callback list for it using the default owner callback information (that
 *		was specified in the constructor).  This means that all events detected
 *		for the new transport connection will be sent to the default owner
 *		object until another object explicitly registers itself as the owner
 *		of the transport connection.  That is what this routine is used for.
 *
 *		Once an object has registered itself as the owner of a transport
 *		connection, it will receive all events related to that connection.
 *
 *	Formal Parameters:
 *		transport_connection (i)
 *			This is the transport connection for which the callback information
 *			is to be associated.
 *		owner_object (i)
 *			This is the address of the Connection object that is to receive all transport
 *			layer events for the specified transport connection.
 *		bNoNagle (i)
 *			Should the connection stop using the Nagle algorithm?
 *
 *	Return Value:
 *		TRANSPORT_INTERFACE_NO_ERROR
 *			The operation completed successfully.
 *		TRANSPORT_INTERFACE_NO_SUCH_CONNECTION
 *			This indicates that the named transport connection does not exist.
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

/*
 *	TransportError 	ConnectRequest (
 *			TransportAddress		transport_address,
 *			BOOL					bNoNagle,
 *			PConnection				owner_object,
 *			PTransportConnection	transport_connection)
 *
 *	Functional Description:
 *		This operation is invoked when the user application wishes to establish
 *		an outbound connection.  Assuming that everything is successful, the
 *		owner callback information that is passed in to this operation is saved
 *		for later use.  All events for this transport connection will be routed
 *		to the specified owner rather than the default owner.
 *
 *	Formal Parameters:
 *		transport_address (i)
 *			This is the transport address to be passed to the transport stack
 *			during the connection creation process.  The format of this address
 *			string will vary by transport stack, and cannot be specified here.
 *		bNoNagle (i)
 *			Do we need to disable the Nagle algorithm?
 *		owner_object (i)
 *			This is the address of the object that is to receive all transport
 *			layer events for the new transport connection.
 *		transport_connection (o)
 *			This is the address of the variable that is to receive the transport
 *			connection handle that is associated with this connection.  Note
 *			that this handle is assigned before the connection is actually
 *			established, to allow the application to abort a connection in
 *			progress.
 *
 *	Return Value:
 *		TRANSPORT_NO_ERROR
 *			The operation completed successfully.
 *		TRANSPORT_NOT_INITIALIZED
 *			The transport stack is not initialized.
 *
 *	Side Effects:
 *		An outbound connection establishment process is begun in the background.
 *
 *	Caveats:
 *		None.
 */
/*
 *	TransportError 	DisconnectRequest (
 *			TransportConnection		transport_connection)
 *
 *	Functional Description:
 *		This operation is used to break an existing transport connection.  If
 *		the operation is successful, the transport connection will be removed
 *		from the callback list.
 *
 *	Formal Parameters:
 *		transport_connection (i)
 *			This is the transport connection that is to be broken.
 *
 *	Return Value:
 *		TRANSPORT_NO_ERROR
 *			The operation completed successfully.
 *		TRANSPORT_NOT_INITIALIZED
 *			The transport stack is not initialized.
 *		TRANSPORT_NO_SUCH_CONNECTION
 *			This indicates that the specified transport connection does not
 *			exist.
 *
 *	Side Effects:
 *		A transport connection is severed.
 *
 *	Caveats:
 *		None.
 */

/*
 *	TransportError 	PollReceiver ()
 *
 *	Functional Description:
 *		This operation is used to check a transport stack for incoming data (or
 *		other events, such as connect and disconnect indications).  In a single
 *		threaded environment, this call could also be used to provide a
 *		time-slice for the processing of inbound data, as well as other events
 *		(such as the creation of new connections).
 *
 *	Formal Parameters:
 *		None.
 *
 *	Return Value:
 *		TRANSPORT_NO_ERROR
 *			The operation completed successfully.
 *
 *	Side Effects:
 *		This can result in callbacks from the transport layer back into this
 *		object.
 *
 *	Caveats:
 *		None.
 */


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\remdsk\rds\t120\h\translat.h ===
/*
 *	translat.h
 *
 *	Copyright (c) 1993 by DataBeam Corporation, Lexington, KY
 *
 *	Abstract:
 *
 *	Caveats:
 *		None.
 *
 *	Author:
 *		jbo
 */
#ifndef	_REASON_RESULT_TRANSLATOR_
#define	_REASON_RESULT_TRANSLATOR_

#include "gccpdu.h"

GCCResult				TranslateCreateResultToGCCResult (
						ConferenceCreateResult		create_result);

GCCResult				TranslateQueryResultToGCCResult (
						ConferenceQueryResult		query_result);

GCCResult				TranslateJoinResultToGCCResult (
						ConferenceJoinResult		join_result);

GCCResult				TranslateInviteResultToGCCResult (
						ConferenceInviteResult		invite_result);

GCCResult				TranslateRegistryRespToGCCResult(
						RegistryResponseResult		response_result);

ConferenceCreateResult	TranslateGCCResultToCreateResult (
						GCCResult 					gcc_result);

ConferenceQueryResult	TranslateGCCResultToQueryResult (
						GCCResult 					gcc_result);

ConferenceJoinResult	TranslateGCCResultToJoinResult (
						GCCResult 					gcc_result);

ConferenceInviteResult	TranslateGCCResultToInviteResult (
						GCCResult 					gcc_result);

RegistryResponseResult	TranslateGCCResultToRegistryResp(
						GCCResult					gcc_result);

GCCReason				TranslateTerminateRqReasonToGCCReason (
						ConferenceTerminateRequestReason 	reason);

ConferenceTerminateRequestReason	
						TranslateGCCReasonToTerminateRqReason (
						GCCReason 					gcc_reason);

GCCReason				TranslateEjectIndReasonToGCCReason(
						ConferenceEjectIndicationReason	eject_reason);

ConferenceEjectIndicationReason						
						TranslateGCCReasonToEjectInd (
						GCCReason					gcc_reason);

GCCResult				TranslateEjectResultToGCCResult(
						ConferenceEjectResult		eject_result);

ConferenceEjectResult	TranslateGCCResultToEjectResult (
						GCCResult					gcc_result);

GCCReason				TranslateTerminateInReasonToGCCReason (
						ConferenceTerminateIndicationReason	reason);

ConferenceTerminateIndicationReason
						TranslateGCCReasonToTerminateInReason (
						GCCReason							gcc_reason);

ConferenceTerminateResult	
						TranslateGCCResultToTerminateResult (
						GCCResult						gcc_result);

GCCResult				TranslateTerminateResultToGCCResult (
						ConferenceTerminateResult		result);

ConferenceLockResult	TranslateGCCResultToLockResult (
								GCCResult				gcc_result);

GCCResult				TranslateLockResultToGCCResult (
								ConferenceLockResult	result);

ConferenceUnlockResult	TranslateGCCResultToUnlockResult (
								GCCResult				gcc_result);

GCCResult				TranslateUnlockResultToGCCResult (
								ConferenceUnlockResult	result);

ConferenceAddResult		TranslateGCCResultToAddResult (
								GCCResult				gcc_result);

GCCResult				TranslateAddResultToGCCResult (
								ConferenceAddResult		add_result);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\remdsk\rds\t120\h\userchnl.h ===
/*
 *	userchnl.h
 *
 *	Copyright (c) 1993 - 1995 by DataBeam Corporation, Lexington, KY
 *
 *	Abstract:
 *		This is the interface file for the UserChannel class.  Objects of this
 *		class represent user ID channels in the MCS environment.  This class
 *		inherits most of its behavior from class Channel.  In fact, with the
 *		exception of how user channels are joined, and how merge commands are
 *		constructed, this class works exactly the same as class Channel.
 *
 *		When a user attaches to a domain, each provider in the path from the
 *		Top Provider to the user will create an object of this class.  Unlike
 *		static and assigned channels, it is NOT necessary for the user to
 *		be joined to the channel for the channel to exist.  It is perfectly
 *		legal to have a user channel that no one is joined to.
 *
 *		The major distinguishing characteristic of user channels is that they
 *		know the user ID of the user they are associated with.  They will
 *		only allow that user to join the channel.  Furthermore, when the user
 *		leaves the usert channel, the LeaveRequest does not return a value
 *		asking to be deleted.  Anyone can send data on a user ID channel.
 *
 *		The merge channel command is constructed slightly differently for user
 *		channels, so that behavior is overridden here as well.
 *
 *	Caveats:
 *		None.
 *
 *	Author:
 *		James P. Galvin, Jr.
 */
#ifndef	_USERCHANNEL_
#define	_USERCHANNEL_

/*
 *	This is the class definition for the UserChannel class.
 */
class	UserChannel : public Channel
{
public:
	UserChannel (
			ChannelID			channel_id,
			CAttachment        *user_attachment,
			PDomain             local_provider,
			PConnection         top_provider,
			CChannelList2      *channel_list,
			CAttachmentList    *attachment_list);
	UserChannel (
			ChannelID			channel_id,
			CAttachment        *user_attachment,
			PDomain             local_provider,
			PConnection         top_provider,
			CChannelList2      *channel_list,
			CAttachmentList    *attachment_list,
			PConnection         pConn);
    virtual					~UserChannel ();
		virtual Channel_Type	GetChannelType ();
		virtual	BOOL    		IsValid ();
		virtual CAttachment *GetAttachment(void);
		virtual	Void			IssueMergeRequest ();
		virtual Void			ChannelJoinRequest (
										CAttachment        *originator,
										UserID				uidInitiator,
										ChannelID			channel_id);
		virtual Void			SendDataRequest (
										CAttachment        *originator,
										UINT				type,
										PDataPacket			data_packet);

private:

    CAttachment         *m_pUserAttachment;
};
typedef	UserChannel *			PUserChannel;

/*
 *	UserChannel (
 *			ChannelID			channel_id,
 *			PCommandTarget		user_attachment,
 *			PDomain     		local_provider,
 *			PConnection 		top_provider,
 *			PChannelList		channel_list,
 *			PAttachmentList		attachment_list)
 *
 *	Functional Description:
 *		This is the normal constructor for the UserChannel class.  It simply
 *		initializes the instance variables that identify the channel, the local
 *		provider, the top provider, and the user attachment.  The attachment
 *		list is empty by default (meaning that the user is not yet joined to
 *		its channel).
 *
 *		Upon successful construction of this object, an attach user confirm
 *		is automatically issued to the user.
 *
 *	Formal Parameters:
 *		channel_id (i)
 *			This is the ID of the channel object.  By keeping track of this
 *			internally, it doesn't have to be passed in for every operation.
 *		user_attachment (i)
 *			This is the attachment which leads to the user represented by this
 *			UserChannel object.  It does not matter if it is a local attachment
 *			or a remote attachment.  This is used to issue MCS commands (such
 *			as attach user confirm) to the user.
 *		local_provider (i)
 *			This is the identity of the local provider.  A UserChannel object
 *			needs this since it issues MCS commands on behalf of the local
 *			provider.
 *		top_provider (i)
 *			This is a pointer to the top provider.  This is used by the
 *			UserChannel object when it needs to issue a request to the Top
 *			Provider.
 *		channel_list (i)
 *			This is a pointer to the domain's channel list, which identifies
 *			all valid channels in the domain.  This is used by channel objects
 *			to validate user IDs.
 *		attachment_list (i)
 *			This is a pointer to the domain's attachment list, which identifies
 *			all valid attachments in the domain.  This is used by channel
 *			objects to validate joined attachments.
 *
 *	Return Value:
 *		None.
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

/*
 *	UserChannel (
 *			ChannelID			channel_id,
 *			PCommandTarget		user_attachment,
 *			PDomain     		local_provider,
 *			PConnection 		top_provider,
 *			PChannelList		channel_list,
 *			PAttachmentList		attachment_list,
 *			PCommandTarget		attachment)
 *
 *	Functional Description:
 *		This is a secondary version of the constructor that is used only during
 *		merge operations.  The only difference between this one and the one
 *		above is that this one allows the specification of an initial
 *		attachment.  This allows a UserChannel object to be constructed with the
 *		user already joined to the channel.  The initial attachment should be
 *		the same as the user attachment.
 *
 *		This version of the constructor will not issue an attach user confirm
 *		or a channel join confirm to the user.
 *
 *	Formal Parameters:
 *		channel_id (i)
 *			This is the ID of the channel object.  By keeping track of this
 *			internally, it doesn't have to be passed in for every operation.
 *		user_attachment (i)
 *			This is the attachment which leads to the user represented by this
 *			UserChannel object.  It does not matter if it is a local attachment
 *			or a remote attachment.  This is used to issue MCS commands (such
 *			as attach user confirm) to the user.
 *		local_provider (i)
 *			This is the identity of the local provider.  A UserChannel object
 *			needs this since it issues MCS commands on behalf of the local
 *			provider.
 *		top_provider (i)
 *			This is a pointer to the top provider.  This is used by the
 *			UserChannel object when it needs to issue a request to the Top
 *			Provider.
 *		channel_list (i)
 *			This is a pointer to the domain's channel list, which identifies
 *			all valid channels in the domain.  This is used by channel objects
 *			to validate user IDs.
 *		attachment_list (i)
 *			This is a pointer to the domain's attachment list, which identifies
 *			all valid attachments in the domain.  This is used by channel
 *			objects to validate joined attachments.
 *		attachment (i)
 *			This is the initial attachment for the channel.  A channel join
 *			confirm is NOT issued to the attachment.
 *
 *	Return Value:
 *		None.
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

/*
 *	~UserChannel ()
 *
 *	Functional Description:
 *		This is the UserChannel class destructor.  It does nothing at this time.
 *		The base class constructor takes care of clearing the attachment list.
 *
 *	Formal Parameters:
 *		None.
 *
 *	Return Value:
 *		None.
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

/*
 *	Channel_Type	GetChannelType ()
 *
 *	Functional Description:
 *		This virtual member function returns the type of the channel.  For this
 *		class it will always be USER_CHANNEL.
 *
 *	Formal Parameters:
 *		None.
 *
 *	Return Value:
 *		USER_CHANNEL
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */
/*
 *	BOOL    	IsValid ()
 *
 *	Functional Description:
 *		This function always returns TRUE since User ID channels are always
 *		valid (as long as the user is still attached).
 *
 *	Formal Parameters:
 *		None.
 *
 *	Return Value:
 *		TRUE
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

/*
 *	CAttachment *GetAttachment ()
 *
 *	Functional Description:
 *		This function is used to retrieve the attachment associated with the
 *		user represented by this object.  This is used by Domain objects when
 *		it is necessary to send an MCS command to a user, and it needs to know
 *		how to get it there.  That information is currently excapsulated within
 *		this class.
 *
 *	Formal Parameters:
 *		None.
 *
 *	Return Value:
 *		A pointer to the attachment that leads to the user represented by this
 *		object.
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

/*
 *	Void		IssueMergeRequest ()
 *
 *	Functional Description:
 *		This member function causes the UserChannel object to issue a merge
 *		request to the top provider.  It will pack the appropriate local
 *		information into the command.
 *
 *	Formal Parameters:
 *		None.
 *
 *	Return Value:
 *		None.
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

/*
 *	Void		ChannelJoinRequest (
 *						PCommandTarget		originator,
 *						UserID				uidInitiator,
 *						ChannelID			channel_id)
 *
 *	Functional Description:
 *		This function is invoked when a user tries to join the channel
 *		associated with a UserChannel object.  The originator of the request
 *		will only be permitted to join if their user ID matches that of the
 *		user with which this UserChannel object is associated.  If it does,
 *		then the originator will be permitted to join.
 *
 *		If this provider is not the Top Provider, then the request will be
 *		forwarded upward to the Top Provider.  If this is the Top Provider,
 *		the a channel join confirm will be issued back to the requesting
 *		user.
 *
 *	Formal Parameters:
 *		originator (i)
 *			This is the attachment of the user wishing to join the channel.
 *		uidInitiator (i)
 *			This is the user ID of the user joining the channel.  This must
 *			be the same as the user ID represented by the object, or the
 *			request will automatically be rejected.
 *		channel_id (i)
 *			This is the channel being acted upon.
 *
 *	Return Value:
 *		None.
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */
/*
 *	Void	SendDataRequest (
 *					PCommandTarget		originator,
 *					PDataPacket			data_packet)
 *
 *	Functional Description:
 *		This member function handles a send data request on the channel.  It
 *		determines where to send the data.  This differs from the base class
 *		implementation only in that it is unnecessary to send data upward
 *		if it is known that the user is in the sub-tree of the current
 *		provider.
 *
 *	Formal Parameters:
 *		originator (i)
 *			This is the attachment from which the data originated.
 *		data_packet (i)
 *			This is a pointer to a DataPacket object containing the channel
 *			ID, the User ID of the data sender, segmentation flags, priority of
 *			the data packet and a pointer to the packet to be sent.
 *
 *	Return Value:
 *		None.
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\remdsk\rds\t120\h\user.h ===
/*
 *	user.h
 *
 *	Copyright (c) 1993 - 1995 by DataBeam Corporation, Lexington, KY
 *
 *	Abstract:
 *		This is the interface file for the User class.  Instances of this class
 *		represent attachments between user applications and domains within MCS.
 *
 *		This class inherits from CommandTarget.  This means that all message
 *		traffic between this class and other CommandTarget classes is in MCS
 *		commands.  Not all commands need to be handled (some are not relevant
 *		for user attachments).  For example, a user attachment should never
 *		receive a SendDataRequest.  It should only receive indications,
 *		confirms, and ultimatums.
 *
 *		Messages coming from the application pass through one of these objects,
 *		where they are translated into MCS commands before being sent to the
 *		domain to which this user is attached.  This usually involves adding
 *		the correct user ID, as well as a fair amount of error checking and
 *		parameter validation.
 *
 *		It is worth noting that this class contains two types of public member
 *		functions.  The first type represent messages flowing from the user
 *		application into MCS.  All of these member functions are inherited from the
 *		IMCSSap interface.  These are converted as memntioned above, and sent
 *		into the appropriate domain if everything checks out.  The second type
 *		of public member function represents messages flowing from within MCS
 *		to the user application.  All of these member function are overrides
 *		of virtual functions defined in class CommandTarget, and are not
 *		prefixed with anything.
 *
 *		Messages coming from the domain are translated into T.122 indications
 *		and confirms, and sent to the proper application interface object via
 *		the owner callback mechanism.
 *
 *		A third duty of this class is to post indications and confirms to user
 *		applications using a client window.  The client must dispatch messages
 *		to receive these indications/confirms.  It also
 *		prevents a user application from having to worry about receiving an
 *		indication or confirm before they have even returned from the request
 *		that caused it.
 *
 *	Caveats:
 *		None.
 *
 *	Author:
 *		James P. Galvin, Jr.
 */

#ifndef	_USER_
#define	_USER_

/*
 *	Interface files.
 */
#include "pktcoder.h"
#include "imcsapp.h"
#include "attmnt.h"

/*
 *	These types are used to keep track of what users have attached to MCS
 *	within a given process, as well as pertinent information about that
 *	attachment.
 *
 *	BufferRetryInfo
 *		In cases where MCSSendDataRequest and MCSUniformSendDataRequest fail
 *		due to a lack of resources, this structure will be used to capture
 *		appropriate information such that follow-up resource level checks can
 *		be performed during timer events.
 */

typedef struct
{
	ULong					user_data_length;
	UINT_PTR				timer_id;
} BufferRetryInfo;
typedef BufferRetryInfo *		PBufferRetryInfo;

/*
 *	These are the owner callback functions that a user object can send to an
 *	object whose public interface is unknown to it.  The first one is sent to
 *	the controller when a user object detects the need to delete itself.  The
 *	rest are sent to an application interface object as part of communicating
 *	with the user application (the proper application interface object is
 *	identified to this class as one of its constructor parameters).
 *
 *	When an object instantiates a user object (or any other object that uses
 *	owner callbacks), it is accepting the responsibility of receiving and
 *	handling those callbacks.  For that reason, any object that issues owner
 *	callbacks will have those callbacks defined as part of the interface file
 *	(since they really are part of a bi-directional interface).
 *
 *	Each owner callback function, along with a description of how its parameters
 *	are packed, is described in the following section.
 */

/*
 *	This macro is used to pack callback parameters into a single long word
 *	for delivery to the user application.
 */
#define PACK_PARAMETER(l,h)	((ULong) (((UShort) (l)) | \
							(((ULong) ((UShort) (h))) << 16)))

/*
 *	TIMER_PROCEDURE_TIMEOUT
 *		This macro specifies the granularity, in milliseconds, of any timer
 *		which may be created to recheck resource levels following a call to
 *		MCSSendDataRequest or MCSUniformSendDataRequest which returned
 *		MCS_TRANSMIT_BUFFER_FULL.
 *	CLASS_NAME_LENGTH
 *		The class name of the window class for all User-related windows.  These
 *		are the client windows that receive messages related to MCS indications and
 *		confirms that have to be delivered to the client apps.
 */
#define TIMER_PROCEDURE_TIMEOUT			300
#define	CLASS_NAME_LENGTH				35

/*
 *	This is the function signature of the timer procedure.  Timer messages will
 *	be routed to this function as a result of timer events which have been set
 *	up to recheck resource levels.  This would happen following a call to either
 *	SendData or GetBuffer call which resulted in a return
 *	value of MCS_TRANSMIT_BUFFER_FULL.
 */
Void CALLBACK TimerProc (HWND, UINT, UINT, DWORD);

/*	Client window procedure declarations
 *
 *	UserWindowProc
 *		Declaration of the window procedure used to deliver all MCS messages
 *		to MCS apps (clients).  The MCS main thread sends msgs to a client
 *		window with this window procedure.  The window procedure is then
 *		responsible to deliver the callback to the MCS client.
 */
LRESULT CALLBACK	UserWindowProc (HWND, UINT, WPARAM, LPARAM);

// Data packet queue
class CDataPktQueue : public CQueue
{
    DEFINE_CQUEUE(CDataPktQueue, PDataPacket)
};

// timer user object list
class CTimerUserList2 : public CList2
{
    DEFINE_CLIST2(CTimerUserList2, PUser, UINT_PTR) // timerID
};

// memory and buffer list
class CMemoryBufferList2 : public CList2
{
    DEFINE_CLIST2(CMemoryBufferList2, PMemory, LPVOID)
};

/*
 *	This is the actual class definition for the User class.  It inherits from
 *	CommandTarget (which in turn inherits from Object).  It has only one
 *	constructor, which tells the newly created object who it is, who the
 *	controller is, and who the proper application interface object is.  It also
 *	has a destructor, to clean up after itself.  Most importantly, it has
 *	one public member function for each MCS command that it must handle.
 */
class User: public CAttachment, public CRefCount, public IMCSSap
{
	friend Void CALLBACK TimerProc (HWND, UINT, UINT, DWORD);
	friend LRESULT CALLBACK UserWindowProc (HWND, UINT, WPARAM, LPARAM);
	public:
						User (PDomain, PMCSError);
		virtual			~User ();

		static BOOL		InitializeClass (void);
		static void		CleanupClass (void);

		/*	-------  IMCSSap interface --------	*/
		MCSAPI		 	ReleaseInterface(void);

		MCSAPI			GetBuffer (UINT, PVoid *);
		MCSAPI_(void)	FreeBuffer (PVoid);
		MCSAPI			ChannelJoin (ChannelID);
		MCSAPI			ChannelLeave (ChannelID);
		MCSAPI			ChannelConvene ();
		MCSAPI			ChannelDisband (ChannelID);
		MCSAPI			ChannelAdmit (ChannelID, PUserID, UINT);
		MCSAPI			SendData (DataRequestType, ChannelID, Priority, unsigned char *, ULong, SendDataFlags);
		MCSAPI			TokenGrab (TokenID);
		MCSAPI			TokenInhibit (TokenID);
		MCSAPI			TokenGive (TokenID, UserID);
		MCSAPI			TokenGiveResponse (TokenID, Result);
		MCSAPI			TokenPlease (TokenID);
		MCSAPI			TokenRelease (TokenID);
		MCSAPI			TokenTest (TokenID);
				
#ifdef USE_CHANNEL_EXPEL_REQUEST
		MCSError		MCSChannelExpelRequest (ChannelID, PMemory, UINT);
#endif // USE_CHANNEL_EXPEL_REQUEST

				void	SetDomainParameters (PDomainParameters);
        virtual void    PlumbDomainIndication(ULONG height_limit) { };
		virtual	void	PurgeChannelsIndication (CUidList *, CChannelIDList *);
        virtual void    PurgeTokensIndication(PDomain, CTokenIDList *) { };
		virtual void	DisconnectProviderUltimatum (Reason);
		virtual	void	AttachUserConfirm (Result, UserID);
		virtual	void	DetachUserIndication (Reason, CUidList *);
		virtual	void	ChannelJoinConfirm (Result, UserID, ChannelID, ChannelID);
				void	ChannelLeaveIndication (Reason, ChannelID);
		virtual	void	ChannelConveneConfirm (Result, UserID, ChannelID);
		virtual	void	ChannelDisbandIndication (ChannelID);
		virtual	void	ChannelAdmitIndication (UserID, ChannelID, CUidList *);
		virtual	void	ChannelExpelIndication (ChannelID, CUidList *);
		virtual	void	SendDataIndication (UINT, PDataPacket);
		virtual	void	TokenGrabConfirm (Result, UserID, TokenID, TokenStatus);
		virtual	void	TokenInhibitConfirm (Result, UserID, TokenID, TokenStatus);
		virtual	void	TokenGiveIndication (PTokenGiveRecord);
		virtual	void	TokenGiveConfirm (Result, UserID, TokenID, TokenStatus);
		virtual	void	TokenPleaseIndication (UserID, TokenID);
		        void	TokenReleaseIndication (Reason, TokenID);
		virtual	void	TokenReleaseConfirm (Result, UserID, TokenID, TokenStatus);
		virtual	void	TokenTestConfirm (UserID, TokenID, TokenStatus);
		virtual	void	MergeDomainIndication (MergeStatus);
				void	RegisterUserAttachment (MCSCallBack, PVoid, UINT);
				void	IssueDataIndication (UINT, PDataPacket);


	private:
		MCSError		ValidateUserRequest ();
		void			CreateRetryTimer (ULong);
		MCSError		ChannelJLCD (int, ChannelID);
		void			ChannelConfInd (UINT, ChannelID, UINT);
		MCSError		TokenGIRPT (int, TokenID);
		void			TokenConfInd (UINT, TokenID, UINT);
		void			PurgeMessageQueue ();

	// Static member variables
	static CTimerUserList2 *s_pTimerUserList2;
	static HINSTANCE		s_hInstance;
	
		PDomain				m_pDomain;
		UserID				User_ID;
		UserID				m_originalUser_ID;
		BOOL				Merge_In_Progress;
		BOOL				Deletion_Pending;
		ULong				Maximum_User_Data_Length;
		HWND				m_hWnd;

		MCSCallBack			m_MCSCallback;
		PVoid				m_UserDefined;
		BOOL				m_fDisconnectInDataLoss;
		BOOL				m_fFreeDataIndBuffer;
		CDataPktQueue		m_DataPktQueue;
		CDataPktQueue		m_PostMsgPendingQueue;
		CMemoryBufferList2	m_DataIndMemoryBuf2;
		PBufferRetryInfo	m_BufferRetryInfo;
};

/*
 *	User (PCommandTarget		top_provider)
 *
 *	Functional Description:
 *		This is the constructor for the user object.  Its primary purpose is
 *		to "insert" itself into the layered structure built by the controller.
 *		To do this it must register itself with the objects above and below it.
 *
 *		It first registers itself with the application interface object
 *		identified as one of the parameters.  This assures that any traffic
 *		from the application will get to this object correctly.
 *
 *		It then issues an attach user request to the domain object identified
 *		by another of the parameters.  This informs the domain of the users
 *		presence and also kicks off the process of attaching to that domain.
 *		Note that the object is not really attached to the domain until it
 *		receives a successful attach user confirm.
 *
 *	Formal Parameters:
 *		top_provider (i)
 *			This is a pointer to the domain object to which this user should
 *			attach.
 *
 *	Return Value:
 *		None.
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

/*
 *	~User ()
 *
 *	Functional Description:
 *		This is the destructor for the user class.  It detaches itself from the
 *		objects above and below it, and frees any outstanding resources that
 *		it may holding in conjunction with unsent user messages.
 *
 *	Formal Parameters:
 *		None.
 *
 *	Return Value:
 *		None.
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

/*
 *	MCSError	DetachUser ()
 *
 *	Functional Description:
 *		This request comes from the application interface object in response
 *		to the same request from a user application.  This object can then
 *		re-package the request as an MCS command and send it to the domain
 *		object.  It will also cause the user object to destroy itself.
 *
 *	Formal Parameters:
 *		None.
 *
 *	Return Value:
 *		MCS_NO_ERROR
 *			Everything worked fine.
 *		MCS_TRANSMIT_BUFFER_FULL
 *			The request could not be processed due to a resource shortage
 *			within MCS.  The application is responsible for re-trying the
 *			request at a later time.
 *		MCS_DOMAIN_MERGING
 *			This operation could not be performed due to a local merge operation
 *			in progress.  The user application must retry at a later time.
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

/*
 *	MCSError	ChannelJoin (
 *						ChannelID			channel_id)
 *
 *	Functional Description:
 *		This request comes from the application interface object in response
 *		to the same request from a user application.  This object can then
 *		re-package the request as an MCS command and send it to the domain
 *		object.
 *
 *	Formal Parameters:
 *		channel_id (i)
 *			This is the channel that the user application wishes to join.
 *
 *	Return Value:
 *		MCS_NO_ERROR
 *			Everything worked fine.
 *		MCS_TRANSMIT_BUFFER_FULL
 *			The request could not be processed due to a resource shortage
 *			within MCS.  The application is responsible for re-trying the
 *			request at a later time.
 *		MCS_USER_NOT_ATTACHED
 *			The user is not attached to the domain.  This could indicate that
 *			the user application issued a request without waiting for the
 *			attach user confirm.
 *		MCS_DOMAIN_MERGING
 *			This operation could not be performed due to a local merge operation
 *			in progress.  The user application must retry at a later time.
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

/*
 *	MCSError	ChannelLeave (
 *						ChannelID			channel_id)
 *
 *	Functional Description:
 *		This request comes from the application interface object in response
 *		to the same request from a user application.  This object can then
 *		re-package the request as an MCS command and send it to the domain
 *		object.
 *
 *	Formal Parameters:
 *		channel_id (i)
 *			This is the channel that the user application wishes to leave.
 *
 *	Return Value:
 *		MCS_NO_ERROR
 *			Everything worked fine.
 *		MCS_TRANSMIT_BUFFER_FULL
 *			The request could not be processed due to a resource shortage
 *			within MCS.  The application is responsible for re-trying the
 *			request at a later time.
 *		MCS_USER_NOT_ATTACHED
 *			The user is not attached to the domain.  This could indicate that
 *			the user application issued a request without waiting for the
 *			attach user confirm.
 *		MCS_DOMAIN_MERGING
 *			This operation could not be performed due to a local merge operation
 *			in progress.  The user application must retry at a later time.
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

/*
 *	MCSError	ChannelConvene ()
 *
 *	Functional Description:
 *		This request comes from the application interface object in response
 *		to the same request from a user application.  This object can then
 *		re-package the request as an MCS command and send it to the domain
 *		object.
 *
 *	Formal Parameters:
 *		None.
 *
 *	Return Value:
 *		MCS_NO_ERROR
 *			Everything worked fine.
 *		MCS_TRANSMIT_BUFFER_FULL
 *			The request could not be processed due to a resource shortage
 *			within MCS.  The application is responsible for re-trying the
 *			request at a later time.
 *		MCS_USER_NOT_ATTACHED
 *			The user is not attached to the domain.  This could indicate that
 *			the user application issued a request without waiting for the
 *			attach user confirm.
 *		MCS_DOMAIN_MERGING
 *			This operation could not be performed due to a local merge operation
 *			in progress.  The user application must retry at a later time.
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

/*
 *	MCSError	ChannelDisband (
 *						ChannelID			channel_id)
 *
 *	Functional Description:
 *		This request comes from the application interface object in response
 *		to the same request from a user application.  This object can then
 *		re-package the request as an MCS command and send it to the domain
 *		object.
 *
 *	Formal Parameters:
 *		channel_id (i)
 *			This is the channel that the user wishes to disband.
 *
 *	Return Value:
 *		MCS_NO_ERROR
 *			Everything worked fine.
 *		MCS_TRANSMIT_BUFFER_FULL
 *			The request could not be processed due to a resource shortage
 *			within MCS.  The application is responsible for re-trying the
 *			request at a later time.
 *		MCS_USER_NOT_ATTACHED
 *			The user is not attached to the domain.  This could indicate that
 *			the user application issued a request without waiting for the
 *			attach user confirm.
 *		MCS_DOMAIN_MERGING
 *			This operation could not be performed due to a local merge operation
 *			in progress.  The user application must retry at a later time.
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

/*
 *	MCSError	ChannelAdmit (
 *						ChannelID			channel_id,
 *						PUserID				user_id_list,
 *						UINT				user_id_count)
 *
 *	Functional Description:
 *		This request comes from the application interface object in response
 *		to the same request from a user application.  This object can then
 *		re-package the request as an MCS command and send it to the domain
 *		object.
 *
 *	Formal Parameters:
 *		channel_id (i)
 *			This is the private channel for which the user wishes to expand
 *			the authorized user list.
 *		user_id_list (i)
 *			This is an array containing the user IDs of the users to be added
 *			to the authorized user list.
 *		user_id_count (i)
 *			This is the number of user IDs in the above array.
 *
 *	Return Value:
 *		MCS_NO_ERROR
 *			Everything worked fine.
 *		MCS_TRANSMIT_BUFFER_FULL
 *			The request could not be processed due to a resource shortage
 *			within MCS.  The application is responsible for re-trying the
 *			request at a later time.
 *		MCS_USER_NOT_ATTACHED
 *			The user is not attached to the domain.  This could indicate that
 *			the user application issued a request without waiting for the
 *			attach user confirm.
 *		MCS_DOMAIN_MERGING
 *			This operation could not be performed due to a local merge operation
 *			in progress.  The user application must retry at a later time.
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

/*
 *	MCSError	ChannelExpel (
 *						ChannelID			channel_id,
 *						PUserID				user_id_list,
 *						UINT				user_id_count)
 *
 *	Functional Description:
 *		This request comes from the application interface object in response
 *		to the same request from a user application.  This object can then
 *		re-package the request as an MCS command and send it to the domain
 *		object.
 *
 *	Formal Parameters:
 *		channel_id (i)
 *			This is the private channel for which the user wishes to shrink
 *			the authorized user list.
 *		user_id_list (i)
 *			This is an array containing the user IDs of the users to be removed
 *			from the authorized user list.
 *		user_id_count (i)
 *			This is the number of user IDs in the above array.
 *
 *	Return Value:
 *		MCS_NO_ERROR
 *			Everything worked fine.
 *		MCS_TRANSMIT_BUFFER_FULL
 *			The request could not be processed due to a resource shortage
 *			within MCS.  The application is responsible for re-trying the
 *			request at a later time.
 *		MCS_USER_NOT_ATTACHED
 *			The user is not attached to the domain.  This could indicate that
 *			the user application issued a request without waiting for the
 *			attach user confirm.
 *		MCS_DOMAIN_MERGING
 *			This operation could not be performed due to a local merge operation
 *			in progress.  The user application must retry at a later time.
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

/*
 *	MCSError	SendData (
 *						ChannelID			channel_id,
 *						Priority			priority,
 *						PUChar				user_data,
 *						ULong				user_data_length)
 *
 *	Functional Description:
 *		This request comes from the application interface object in response
 *		to the same request from a user application.  This object can then
 *		re-package the request as an MCS command and send it to the domain
 *		object.
 *
 *	Formal Parameters:
 *		channel_id (i)
 *			This is the channel that the user application wishes to transmit
 *			data on.
 *		priority (i)
 *			This is the priority at which the data is to be transmitted.
 *		user_data (i)
 *			This is the address of the data to be transmitted.
 *		user_data_length (i)
 *			This is the length of the data to be transmitted.
 *
 *	Return Value:
 *		MCS_NO_ERROR
 *			Everything worked fine.
 *		MCS_TRANSMIT_BUFFER_FULL
 *			The request has failed because the required memory could not be
 *			allocated.  It is the responsibility of the user application to
 *			repeat the request at a later time.
 *		MCS_USER_NOT_ATTACHED
 *			The user is not attached to the domain.  This could indicate that
 *			the user application issued a request without waiting for the
 *			attach user confirm.
 *		MCS_DOMAIN_MERGING
 *			This operation could not be performed due to a local merge operation
 *			in progress.  The user application must retry at a later time.
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */
/*
 *	MCSError	TokenGrab (
 *						TokenID				token_id)
 *
 *	Functional Description:
 *		This request comes from the application interface object in response
 *		to the same request from a user application.  This object can then
 *		re-package the request as an MCS command and send it to the domain
 *		object.
 *
 *	Formal Parameters:
 *		token_id (i)
 *			This is the token the user application wishes to grab.
 *
 *	Return Value:
 *		MCS_NO_ERROR
 *			Everything worked fine.
 *		MCS_TRANSMIT_BUFFER_FULL
 *			The request could not be processed due to a resource shortage
 *			within MCS.  The application is responsible for re-trying the
 *			request at a later time.
 *		MCS_INVALID_PARAMETER
 *			The user attempted to perform an operation on token 0, which is not
 *			a valid token.
 *		MCS_USER_NOT_ATTACHED
 *			The user is not attached to the domain.  This could indicate that
 *			the user application issued a request without waiting for the
 *			attach user confirm.
 *		MCS_DOMAIN_MERGING
 *			This operation could not be performed due to a local merge operation
 *			in progress.  The user application must retry at a later time.
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

/*
 *	MCSError	TokenInhibit (
 *						TokenID				token_id)
 *
 *	Functional Description:
 *		This request comes from the application interface object in response
 *		to the same request from a user application.  This object can then
 *		re-package the request as an MCS command and send it to the domain
 *		object.
 *
 *	Formal Parameters:
 *		token_id (i)
 *			This is the token the user application wishes to inhibit.
 *
 *	Return Value:
 *		MCS_NO_ERROR
 *			Everything worked fine.
 *		MCS_TRANSMIT_BUFFER_FULL
 *			The request could not be processed due to a resource shortage
 *			within MCS.  The application is responsible for re-trying the
 *			request at a later time.
 *		MCS_INVALID_PARAMETER
 *			The user attempted to perform an operation on token 0, which is not
 *			a valid token.
 *		MCS_USER_NOT_ATTACHED
 *			The user is not attached to the domain.  This could indicate that
 *			the user application issued a request without waiting for the
 *			attach user confirm.
 *		MCS_DOMAIN_MERGING
 *			This operation could not be performed due to a local merge operation
 *			in progress.  The user application must retry at a later time.
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

/*
 *	MCSError	TokenGive (
 *						TokenID				token_id,
 *						UserID				receiver_id)
 *
 *	Functional Description:
 *		This request comes from the application interface object in response
 *		to the same request from a user application.  This object can then
 *		re-package the request as an MCS command and send it to the domain
 *		object.
 *
 *	Formal Parameters:
 *		token_id (i)
 *			This is the token the user application wishes to give away.
 *		receiver_id (i)
 *			This is the ID of the user to receive the token.
 *
 *	Return Value:
 *		MCS_NO_ERROR
 *			Everything worked fine.
 *		MCS_TRANSMIT_BUFFER_FULL
 *			The request could not be processed due to a resource shortage
 *			within MCS.  The application is responsible for re-trying the
 *			request at a later time.
 *		MCS_INVALID_PARAMETER
 *			The user attempted to perform an operation on token 0, which is not
 *			a valid token.
 *		MCS_USER_NOT_ATTACHED
 *			The user is not attached to the domain.  This could indicate that
 *			the user application issued a request without waiting for the
 *			attach user confirm.
 *		MCS_DOMAIN_MERGING
 *			This operation could not be performed due to a local merge operation
 *			in progress.  The user application must retry at a later time.
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

/*
 *	MCSError	TokenGiveResponse (
 *						TokenID				token_id,
 *						Result				result)
 *
 *	Functional Description:
 *		This request comes from the application interface object in response
 *		to the same request from a user application.  This object can then
 *		re-package the request as an MCS command and send it to the domain
 *		object.
 *
 *	Formal Parameters:
 *		token_id (i)
 *			This is the token that the user application is either accepting or
 *			rejecting in response to a previous give indication from another
 *			user.
 *		result (i)
 *			This parameter specifies whether or not the token was accepted.
 *			Success indicates acceptance while anything else indicates that the
 *			token was not accepted.
 *
 *	Return Value:
 *		MCS_NO_ERROR
 *			Everything worked fine.
 *		MCS_TRANSMIT_BUFFER_FULL
 *			The request could not be processed due to a resource shortage
 *			within MCS.  The application is responsible for re-trying the
 *			request at a later time.
 *		MCS_INVALID_PARAMETER
 *			The user attempted to perform an operation on token 0, which is not
 *			a valid token.
 *		MCS_USER_NOT_ATTACHED
 *			The user is not attached to the domain.  This could indicate that
 *			the user application issued a request without waiting for the
 *			attach user confirm.
 *		MCS_DOMAIN_MERGING
 *			This operation could not be performed due to a local merge operation
 *			in progress.  The user application must retry at a later time.
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

/*
 *	MCSError	TokenPlease (
 *						TokenID				token_id)
 *
 *	Functional Description:
 *		This request comes from the application interface object in response
 *		to the same request from a user application.  This object can then
 *		re-package the request as an MCS command and send it to the domain
 *		object.
 *
 *	Formal Parameters:
 *		token_id (i)
 *			This is the token the user application wishes to ask for.
 *
 *	Return Value:
 *		MCS_NO_ERROR
 *			Everything worked fine.
 *		MCS_TRANSMIT_BUFFER_FULL
 *			The request could not be processed due to a resource shortage
 *			within MCS.  The application is responsible for re-trying the
 *			request at a later time.
 *		MCS_INVALID_PARAMETER
 *			The user attempted to perform an operation on token 0, which is not
 *			a valid token.
 *		MCS_USER_NOT_ATTACHED
 *			The user is not attached to the domain.  This could indicate that
 *			the user application issued a request without waiting for the
 *			attach user confirm.
 *		MCS_DOMAIN_MERGING
 *			This operation could not be performed due to a local merge operation
 *			in progress.  The user application must retry at a later time.
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

/*
 *	MCSError	TokenRelease (
 *						TokenID				token_id)
 *
 *	Functional Description:
 *		This request comes from the application interface object in response
 *		to the same request from a user application.  This object can then
 *		re-package the request as an MCS command and send it to the domain
 *		object.
 *
 *	Formal Parameters:
 *		token_id (i)
 *			This is the token the user application wishes to release.
 *
 *	Return Value:
 *		MCS_NO_ERROR
 *			Everything worked fine.
 *		MCS_TRANSMIT_BUFFER_FULL
 *			The request could not be processed due to a resource shortage
 *			within MCS.  The application is responsible for re-trying the
 *			request at a later time.
 *		MCS_INVALID_PARAMETER
 *			The user attempted to perform an operation on token 0, which is not
 *			a valid token.
 *		MCS_USER_NOT_ATTACHED
 *			The user is not attached to the domain.  This could indicate that
 *			the user application issued a request without waiting for the
 *			attach user confirm.
 *		MCS_DOMAIN_MERGING
 *			This operation could not be performed due to a local merge operation
 *			in progress.  The user application must retry at a later time.
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

/*
 *	MCSError	TokenTest(
 *						TokenID				token_id)
 *
 *	Functional Description:
 *		This request comes from the application interface object in response
 *		to the same request from a user application.  This object can then
 *		re-package the request as an MCS command and send it to the domain
 *		object.
 *
 *	Formal Parameters:
 *		token_id (i)
 *			This is the token the user application wishes to test the state of.
 *
 *	Return Value:
 *		MCS_NO_ERROR
 *			Everything worked fine.
 *		MCS_TRANSMIT_BUFFER_FULL
 *			The request could not be processed due to a resource shortage
 *			within MCS.  The application is responsible for re-trying the
 *			request at a later time.
 *		MCS_INVALID_PARAMETER
 *			The user attempted to perform an operation on token 0, which is not
 *			a valid token.
 *		MCS_USER_NOT_ATTACHED
 *			The user is not attached to the domain.  This could indicate that
 *			the user application issued a request without waiting for the
 *			attach user confirm.
 *		MCS_DOMAIN_MERGING
 *			This operation could not be performed due to a local merge operation
 *			in progress.  The user application must retry at a later time.
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

/*
 *	Void	SetDomainParameters (
 *					PDomainParameters	domain_parameters)
 *
 *	Functional Description:
 *		This member function is called whenever the domain parameters change
 *		as the result of accepting a first connection.  It informs the user
 *		object of a change in the maximum PDU size, which is used when creating
 *		outbound data PDUs.
 *
 *	Formal Parameters:
 *		domain_parameters (i)
 *			Pointer to a structure that contains the current domain parameters
 *			(those that are in use).
 *
 *	Return Value:
 *		None.
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

/*
 *	Void		PlumbDomainIndication (
 *						PCommandTarget		originator,
 *						ULong				height_limit)
 *
 *	Functional Description:
 *		This command is issued by the domain object during a plumb domain
 *		operation.  This is not relevant to user objects, and should be ignored.
 *
 *	Formal Parameters:
 *		originator (i)
 *			This identifies the CommandTarget from which the command came (which
 *			should be the domain object).
 *		height_limit (i)
 *			This is height value passed through during the plumb operation.
 *
 *	Return Value:
 *		None.
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

/*
 *	Void		PurgeChannelsIndication (
 *						PCommandTarget		originator,
 *						CUidList           *purge_user_list,
 *						CChannelIDList     *purge_channel_list)
 *
 *	Functional Description:
 *		This command is issued by the domain object when purging channels
 *		from the lower domain during a domain merge operation.
 *
 *		The user object will issue one MCS_DETACH_USER_INDICATION object for
 *		each user in the user list.  Furthermore, if the user objects finds
 *		its own user ID in the list, it will destroy itself.
 *
 *	Formal Parameters:
 *		originator (i)
 *			This identifies the CommandTarget from which the command came (which
 *			should be the domain object).
 *		purge_user_list (i)
 *			This is a list of user IDs that are to be purged from the lower
 *			domain.
 *		purge_channel_list (i)
 *			This is a list of channel IDs that are to be purged from the lower
 *			domain.
 *
 *	Return Value:
 *		None.
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

/*
 *	Void	PurgeTokensIndication (
 *					PCommandTarget		originator,
 *					CTokenIDList       *token_id_list)
 *
 *	Functional Description:
 *		This command is issued by the domain object when purging tokens from
 *		the lower domain during a domain merge operation.  IT is not relevant
 *		to a user object, and is therefore ignored.
 *
 *	Formal Parameters:
 *		originator (i)
 *			This identifies the CommandTarget from which the command came (which
 *			should be the domain object).
 *		token_id (i)
 *			This is the ID of the token that is being purged.
 *
 *	Return Value:
 *		None.
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

/*
 *	Void	DisconnectProviderUltimatum (
 *					PCommandTarget		originator,
 *					Reason				reason)
 *
 *	Functional Description:
 *		This command is issued by the domain object when it is necessary to
 *		force a user from the domain.  This usually happens in response to
 *		the purging of an entire domain (either this user was in the bottom
 *		of a disconnected domain or the domain was deleted locally by user
 *		request).
 *
 *		If the user was already attached to the domain, this will result in a
 *		DETACH_USER_INDICATION with the local user ID.  Otherwise this will
 *		result is an ATTACH_USER_CONFIRM with a result of UNSPECIFIED_FAILURE.
 *
 *	Formal Parameters:
 *		originator (i)
 *			This identifies the CommandTarget from which the command came (which
 *			should be the domain object).
 *		reason (i)
 *			This is the reason parameter to be issued to the local user
 *			application.  See "mcatmcs.h" for a complete list of possible reaons.
 *
 *	Return Value:
 *		None.
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

/*
 *	Void	AttachUserConfirm (
 *					PCommandTarget		originator,
 *					Result				result,
 *					UserID				uidInitiator)
 *
 *	Functional Description:
 *		This command is issued by the domain object in response to the
 *		attach user request issued by this object during construction.  If the
 *		result is successful, then this user is now attached and may request
 *		MCS services through this attachment.
 *
 *		An ATTACH_USER_CONFIRM will be issued to the user application.  If the
 *		result is not successful, this object will delete itself.
 *
 *	Formal Parameters:
 *		originator (i)
 *			This identifies the CommandTarget from which the command came (which
 *			should be the domain object).
 *		result (i)
 *			This is the result of the attach request.
 *		uidInitiator (i)
 *			If the result was successful, this is the new user ID associated
 *			with this attachment.
 *
 *	Return Value:
 *		None.
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

/*
 *	Void	DetachUserIndication (
 *					PCommandTarget		originator,
 *					Reason				reason,
 *					CUidList           *user_id_list)
 *
 *	Functional Description:
 *		This command is issued by the domain object when one or more users leave
 *		the domain.
 *
 *		An MCS_DETACH_USER_INDICATION is issued to the user application for each
 *		user in the list.  Furthermore, if the user finds its own ID in the
 *		list, then it will destroy itself.
 *
 *	Formal Parameters:
 *		originator (i)
 *			This identifies the CommandTarget from which the command came (which
 *			should be the domain object).
 *		reason (i)
 *			This is the reason for the detachment.  Possible values are listed
 *			in "mcatmcs.h".
 *		user_id_list (i)
 *			This is a list user IDs of the users that are leaving.
 *
 *	Return Value:
 *		None.
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

/*
 *	Void	ChannelJoinConfirm (
 *					PCommandTarget		originator,
 *					Result				result,
 *					UserID				uidInitiator,
 *					ChannelID			requested_id,
 *					ChannelID			channel_id)
 *
 *	Functional Description:
 *		This command is issued by the domain object in response to a previous
 *		channel join request.
 *
 *		A CHANNEL_JOIN_CONFIRM is issued to the user application.  Note that a
 *		user is not really considered to be joined to a channel until a
 *		successful confirm is received.
 *
 *	Formal Parameters:
 *		originator (i)
 *			This identifies the CommandTarget from which the command came (which
 *			should be the domain object).
 *		result (i)
 *			This is the result from the join request.  If successful, then the
 *			user is now joined to the channel.
 *		uidInitiator (i)
 *			This is the user ID of the requestor.  It will be the same as the
 *			local user ID (or else this command would not have gotten here).
 *		requested_id (i)
 *			This is the ID of the channel that the user originally requested
 *			to join.  This will differ from the ID of the channel actually
 *			joined only if this ID is 0 (which identifies a request to join an
 *			assigned channel).
 *		channel_id (i)
 *			This is the channel that is now joined.  This is important for
 *			two reasons.  First, it is possible for a user to have more than
 *			one outstanding join request, in which case this parameter
 *			identifies which channel this confirm is for.  Second, if the
 *			request is for channel 0 (zero), then this parameter identifies
 *			which assigned channel the user has successfully joined.
 *
 *	Return Value:
 *		None.
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

/*
 *	Void	ChannelLeaveIndication (
 *					PCommandTarget		originator,
 *					Reason				reason,
 *					ChannelID			channel_id)
 *
 *	Functional Description:
 *		This command is issued by the domain object when a user loses its right
 *		to use a channel.
 *
 *		A CHANNEL_LEAVE_INDICATION is issued to the user application.
 *
 *	Formal Parameters:
 *		originator (i)
 *			This identifies the CommandTarget from which the command came (which
 *			should be the domain object).
 *		reason (i)
 *			This is the reason for the lost channel.  Possible values are listed
 *			in "mcatmcs.h".
 *		channel (i)
 *			This is the channel that the user can no longer use.
 *
 *	Return Value:
 *		None.
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

/*
 *	Void		ChannelConveneConfirm (
 *					PCommandTarget		originator,
 *					Result				result,
 *					UserID				uidInitiator,
 *					ChannelID			channel_id)
 *
 *	Functional Description:
 *		This command is issued by the domain object in response to a previous
 *		channel convene request.
 *
 *		A CHANNEL_CONVENE_CONFIRM is issued to the user application.
 *
 *	Formal Parameters:
 *		originator (i)
 *			This identifies the CommandTarget from which the command came (which
 *			should be the domain object).
 *		result (i)
 *			This is the result from the convene request.  If successful, then
 *			a private channel has been created, with this user as the manager.
 *		uidInitiator (i)
 *			This is the user ID of the requestor.  It will be the same as the
 *			local user ID (or else this command would not have gotten here).
 *		channel_id (i)
 *			This is the channel ID for the newly created private channel.
 *
 *	Return Value:
 *		None.
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

/*
 *	Void		ChannelDisbandIndication (
 *					PCommandTarget		originator,
 *					ChannelID			channel_id)
 *
 *	Functional Description:
 *		This command is issued by the domain object to the manager of a private
 *		channel when MCS determines the need to disband the channel.  This will
 *		usually be done only if the channel is purged during a domain merger.
 *
 *		A CHANNEL_DISBAND_INDICATION is issued to the user application.
 *
 *	Formal Parameters:
 *		originator (i)
 *			This identifies the CommandTarget from which the command came (which
 *			should be the domain object).
 *		channel_id (i)
 *			This is the channel ID of the private channel that is being
 *			disbanded.
 *
 *	Return Value:
 *		None.
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

/*
 *	Void		ChannelAdmitIndication (
 *						PCommandTarget		originator,
 *						UserID				uidInitiator,
 *						ChannelID			channel_id,
 *						CUidList           *user_id_list)
 *
 *	Functional Description:
 *		This command is issued by the domain object when a user is admitted to
 *		a private channel by the manager of that channel.  It informs the user
 *		that the channel can be used.
 *
 *		A CHANNEL_ADMIT_INDICATION is issued to the user application.
 *
 *	Formal Parameters:
 *		originator (i)
 *			This identifies the CommandTarget from which the command came (which
 *			should be the domain object).
 *		uidInitiator (i)
 *			This is the user ID of the private channel manager.
 *		channel_id (i)
 *			This is the channel ID of the private channel to which the user has
 *			been admitted.
 *		user_id_list (i)
 *			This is a container holding the IDs of the users that have been
 *			admitted.  By the time this reaches a particular user, that user
 *			should be the only one in the list (since the list is broken apart
 *			and forwarded in the direction of the contained users, recursively).
 *
 *	Return Value:
 *		None.
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

/*
 *	Void		ChannelExpelIndication (
 *						PCommandTarget		originator,
 *						ChannelID			channel_id,
 *						CUidList           *user_id_list)
 *
 *	Functional Description:
 *		This command is issued by the domain object when a user is expelled from
 *		a private channel by the manager of that channel.  It informs the user
 *		that the channel can no longer be used.
 *
 *		A CHANNEL_EXPEL_INDICATION is issued to the user application.
 *
 *	Formal Parameters:
 *		originator (i)
 *			This identifies the CommandTarget from which the command came (which
 *			should be the domain object).
 *		channel_id (i)
 *			This is the channel ID of the private channel from which the user
 *			has been expelled.
 *		user_id_list (i)
 *			This is a container holding the IDs of the users that have been
 *			expelled.  By the time this reaches a particular user, that user
 *			should be the only one in the list (since the list is broken apart
 *			and forwarded in the direction of the contained users, recursively).
 *
 *	Return Value:
 *		None.
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

/*
 *	Void	SendDataIndication (
 *					PCommandTarget		originator,
 *					UINT				message_type,
 *					PDataPacket			data_packet)
 *
 *	Functional Description:
 *		This command is issued by the domain object when non-uniform data
 *		data is received on a channel to which this user is joined.
 *
 *		A SEND_DATA_INDICATION is issued to the user application.
 *
 *	Formal Parameters:
 *		originator (i)
 *			This identifies the CommandTarget from which the command came (which
 *			should be the domain object).
 *		message_type (i)
 *			normal or uniform send data indication
 *		data_packet (i)
 *			This is a pointer to a DataPacket object containing the channel
 *			ID, the User ID of the data sender, segmentation flags, priority of
 *			the data packet and a pointer to the packet to be sent.
 *
 *	Return Value:
 *		None.
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */
/*
 *	Void	TokenGrabConfirm (
 *					PCommandTarget		originator,
 *					Result				result,
 *					UserID				uidInitiator,
 *					TokenID				token_id,
 *					TokenStatus			token_status)
 *
 *	Functional Description:
 *		This command is issued by the domain object in response to a previous
 *		token grab request.
 *
 *		A TOKEN_GRAB_CONFIRM is issued to the user application.
 *
 *	Formal Parameters:
 *		originator (i)
 *			This identifies the CommandTarget from which the command came (which
 *			should be the domain object).
 *		result (i)
 *			This is the result of the grab request.  If successful, the user
 *			now exclusively owns the token.
 *		uidInitiator (i)
 *			This is the user ID of the user that made the grab request.  This
 *			will be the same as the local user ID (or else this command would
 *			not have gotten here).
 *		token_id (i)
 *			This is the ID of the token which the grab confirm is for.  It
 *			is possible to have more than one outstanding grab request, so this
 *			parameter tells the user application which request has been
 *			satisfied by this confirm.
 *		token_status (i)
 *			This is the status of the token at the time the Top Provider
 *			serviced the grab request.  This will be SELF_GRABBED if the grab
 *			request was successful.  It will be something else if not (see
 *			"mcatmcs.h" for a list of possible token status values).
 *
 *	Return Value:
 *		None.
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

/*
 *	Void	TokenInhibitConfirm (
 *					PCommandTarget		originator,
 *					Result				result,
 *					UserID				uidInitiator,
 *					TokenID				token_id,
 *					TokenStatus			token_status)
 *
 *	Functional Description:
 *		This command is issued by the domain object in response to a previous
 *		token inhibit request.
 *
 *		A TOKEN_INHIBIT_CONFIRM is issued to the user application.
 *
 *	Formal Parameters:
 *		originator (i)
 *			This identifies the CommandTarget from which the command came (which
 *			should be the domain object).
 *		result (i)
 *			This is the result of the inhibit request.  If successful, the user
 *			now non-exclusively owns the token.
 *		uidInitiator (i)
 *			This is the user ID of the user that made the inhibit request.  This
 *			will be the same as the local user ID (or else this command would
 *			not have gotten here).
 *		token_id (i)
 *			This is the ID of the token which the inihibit confirm is for.
 *			It is possible to have more than one outstanding inihibit request,
 *			so this parameter tells the user application which request has been
 *			satisfied by this confirm.
 *		token_status (i)
 *			This is the status of the token at the time the Top Provider
 *			serviced the inhibit request.  This will be SELF_INHIBITED if the
 *			inhibit request was successful.  It will be something else if not
 *			(see "mcatmcs.h" for a list of possible token status values).
 *
 *	Return Value:
 *		None.
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

/*
 *	Void		TokenGiveIndication (
 *						PCommandTarget		originator,
 *						PTokenGiveRecord	pTokenGiveRec)
 *
 *	Functional Description:
 *		This command is issued by the domain object in response to a remote
 *		token give request (with the local user listed as the desired receiver).
 *
 *		A TOKEN_GIVE_INDICATION is issued to the user application.
 *
 *	Formal Parameters:
 *		originator (i)
 *			This identifies the CommandTarget from which the command came (which
 *			should be the domain object).
 *		pTokenGiveRec (i)
 *			This is the address of a structure containing the following information:
 *			The ID of the user attempting to give away the token.
 *			The ID of the token being given.
 *			The ID of the user that the token is being given to.
 *
 *	Return Value:
 *		None.
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

/*
 *	Void		TokenGiveConfirm (
 *						PCommandTarget		originator,
 *						Result				result,
 *						UserID				uidInitiator,
 *						TokenID				token_id,
 *						TokenStatus			token_status)
 *
 *	Functional Description:
 *		This command is issued by the domain object in response to a previous
 *		token give request.
 *
 *		A TOKEN_GIVE_CONFIRM is issued to the user application.
 *
 *	Formal Parameters:
 *		originator (i)
 *			This identifies the CommandTarget from which the command came (which
 *			should be the domain object).
 *		result (i)
 *			This is the result of the give request.  If successful, the user
 *			no longer owns the token.
 *		uidInitiator (i)
 *			This is the user ID of the user that made the give request.  This
 *			will be the same as the local user ID (or else this command would
 *			not have gotten here).
 *		token_id (i)
 *			This is the ID of the token which the give confirm is for.
 *		token_status (i)
 *			This is the status of the token at the time the Top Provider
 *			serviced the give request.
 *
 *	Return Value:
 *		None.
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

/*
 *	Void		TokenPleaseIndication (
 *						PCommandTarget		originator,
 *						UserID				uidInitiator,
 *						TokenID				token_id)
 *
 *	Functional Description:
 *		This command is issued by the domain object to all owners of a token
 *		when a user issues a token please request for that token.
 *
 *		A TOKEN_PLEASE_INDICATION is issued to the user application.
 *
 *	Formal Parameters:
 *		originator (i)
 *			This identifies the CommandTarget from which the command came (which
 *			should be the domain object).
 *		uidInitiator (i)
 *			This is the user ID of the user that made the please request.
 *		token_id (i)
 *			This is the ID of the token which the please request is for.
 *
 *	Return Value:
 *		None.
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

/*
 *	Void	TokenReleaseIndication (
 *					PCommandTarget		originator,
 *					Reason				reason,
 *					TokenID				token_id)
 *
 *	Functional Description:
 *		This command is issued by the domain object when a token is taken
 *		away from its current owner.
 *
 *		A TOKEN_RELEASE_INDICATION is issued to the user application.
 *
 *	Formal Parameters:
 *		originator (i)
 *			This identifies the CommandTarget from which the command came (which
 *			should be the domain object).
 *		reason (i)
 *			This is the reason the token is being taken away.
 *		token_id (i)
 *			This is the ID of the token that is being taken away.
 *
 *	Return Value:
 *		None.
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

/*
 *	Void	TokenReleaseConfirm (
 *					PCommandTarget		originator,
 *					Result				result,
 *					UserID				uidInitiator,
 *					TokenID				token_id,
 *					TokenStatus			token_status)
 *
 *	Functional Description:
 *		This command is issued by the domain object in response to a previous
 *		token release request.
 *
 *		A TOKEN_RELEASE_CONFIRM is issued to the user application.
 *
 *	Formal Parameters:
 *		originator (i)
 *			This identifies the CommandTarget from which the command came (which
 *			should be the domain object).
 *		result (i)
 *			This is the result of the release request.  If successful, the user
 *			no longer owns the token (if it ever did)
 *		uidInitiator (i)
 *			This is the user ID of the user that made the release request.  This
 *			will be the same as the local user ID (or else this command would
 *			not have gotten here).
 *		token_id (i)
 *			This is the ID of the token which the release confirm is for.
 *			It is possible to have more than one outstanding release request,
 *			so this parameter tells the user application which request has been
 *			satisfied by this confirm.
 *		token_status (i)
 *			This is the status of the token at the time the Top Provider
 *			serviced the release request.  This will be NOT_IN_USE or
 *			OTHER_INHIBITED if the release request was successful.  It will be
 *			something else if not (see "mcatmcs.h" for a list of possible token
 *			status values).
 *
 *	Return Value:
 *		None.
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

/*
 *	Void	TokenTestConfirm (
 *					PCommandTarget		originator,
 *					UserID				uidInitiator,
 *					TokenID				token_id,
 *					TokenStatus			token_status)
 *
 *	Functional Description:
 *		This command is issued by the domain object in response to a previous
 *		token test request.
 *
 *		A TOKEN_TEST_CONFIRM is issued to the user application.
 *
 *	Formal Parameters:
 *		originator (i)
 *			This identifies the CommandTarget from which the command came (which
 *			should be the domain object).
 *		uidInitiator (i)
 *			This is the user ID of the user that made the test request.  This
 *			will be the same as the local user ID (or else this command would
 *			not have gotten here).
 *		token_id (i)
 *			This is the ID of the token which the test confirm is for.
 *			It is possible to have more than one outstanding test request,
 *			so this parameter tells the user application which request has been
 *			satisfied by this confirm.
 *		token_status (i)
 *			This is the status of the token at the time the Top Provider
 *			serviced the test request (see "mcatmcs.h" for a list of possible
 *			token status values).
 *
 *	Return Value:
 *		None.
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

/*
 *	Void	MergeDomainIndication (
 *					PCommandTarget		originator,
 *					MergeStatus			merge_status)
 *
 *	Functional Description:
 *		This command is issued by a domain when it begins a merge operation.
 *		It is issued again when the merge operation is complete.
 *
 *		A MERGE_DOMAIN_INDICATION is issued to the user application.
 *
 *	Formal Parameters:
 *		originator (i)
 *			This identifies the CommandTarget from which the command came (which
 *			should be the domain object).
 *		merge_status (i)
 *			This is the current merge status.  It will indicate either that the
 *			merge operation is in progress, or that it is complete.
 *
 *	Return Value:
 *		None.
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

/*
 *	Void		FlushMessageQueue (
 *						Void)
 *
 *	Functional Description:
 *		This function is periodically called by the controller to allocate a
 *		time slice to the user object.  It is during this time slice that this
 *		object will issue its queued messages to the user application.
 *
 *	Formal Parameters:
 *		None.
 *
 *	Return Value:
 *		None.
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

#endif

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\remdsk\rds\t120\mst120\appsap.cpp ===
#include "precomp.h"
DEBUG_FILEZONE(ZONE_T120_SAP);
/*
 *	appsap.cpp
 *
 *	Copyright (c) 1995 by DataBeam Corporation, Lexington, KY
 *
 *	Abstract:
 *
 *	Protected Instance Variables:
 *		None.
 *
 *	Caveats:
 *		None.
 *
 *	Author:
 *		blp
 */

#include "appsap.h"
#include "conf.h"
#include "gcontrol.h"


GCCError WINAPI GCC_CreateAppSap(IGCCAppSap **ppIAppSap, LPVOID pUserData, LPFN_APP_SAP_CB pfnCallback)
{
    GCCError rc;

    if (NULL != ppIAppSap && NULL != pfnCallback)
    {
        if (NULL != g_pGCCController)
        {
            DBG_SAVE_FILE_LINE
            if (NULL != (*ppIAppSap = (IGCCAppSap *) new CAppSap(pUserData, pfnCallback, &rc)))
            {
                if (GCC_NO_ERROR != rc)
                {
                    (*ppIAppSap)->ReleaseInterface(); // free the interface in case of error
                }
            }
            else
            {
                ERROR_OUT(("GCC_CreateAppSap: can't create IAppSap."));
                rc = GCC_ALLOCATION_FAILURE;
            }
        }
        else
        {
            WARNING_OUT(("GCC_CreateAppSap: GCC Provider is not initialized."));
            rc = GCC_NOT_INITIALIZED;
        }
    }
    else
    {
        ERROR_OUT(("GCC_CreateAppSap: either or both pointers are null"));
        rc = GCC_INVALID_PARAMETER;
    }

    return rc;
}


/*
 * Macros defining the number of handles which may be allocated.
 */
#define		MINIMUM_NUMBER_OF_ALLOCATED_HANDLES		1
#define		MAXIMUM_NUMBER_OF_ALLOCATED_HANDLES		1024

/*
 *	CAppSap()
 *
 *	Public Function Description:
 *		This is the constructor for the CAppSap class.  It initializes instance
 *		variables and registers with the new application.
 */
CAppSap::
CAppSap
(
    LPVOID              pAppData,
    LPFN_APP_SAP_CB     pfnCallback,
    PGCCError           pRetCode
)
:
    CBaseSap(MAKE_STAMP_ID('A','S','a','p')),
    m_pAppData(pAppData),
    m_pfnCallback(pfnCallback)
{
    ASSERT(NULL != pfnCallback);
    ASSERT(NULL != g_pGCCController);

    //
    // We just created a window in the constructor of CBaseSap.
    // Double check the window is created successfully.
    //
    if (NULL != m_hwndNotify)
    {
        //
        // Make sure the gcc provider does not go away randomly.
        //
        ::EnterCriticalSection(&g_csGCCProvider);
        g_pGCCController->AddRef();
        g_pGCCController->RegisterAppSap(this);
        ::LeaveCriticalSection(&g_csGCCProvider);

        *pRetCode = GCC_NO_ERROR;
    }
    else
    {
        ERROR_OUT(("CAppSap::CAppSap: can't create window, win32_err=%u", ::GetLastError()));
        *pRetCode = GCC_ALLOCATION_FAILURE;
    }
}


/*
 *	~AppSap ()
 *
 *	Public Function Description:
 *		This is the destructor for the CAppSap class.  It is called when the 
 *		controller marks the CAppSap to be deleted.  This occurs when either
 *		the CAppSap asks to be deleted due to an "unregister request" 
 *		issued from the client application, or when there is an error
 *		condition in the CAppSap.
 */
CAppSap::
~CAppSap ( void )
{
    //
    // LONCHANC: This Release() must be outside of the GCC critical section
    // because the GCC Controller can delete this critical section in
    // its destructor.
    //
    g_pGCCController->Release();
}


void CAppSap::
ReleaseInterface ( void )
{
    ASSERT(NULL != g_pGCCController);

    //
    // It is ok for the gcc provider to go away now.
    //
    ::EnterCriticalSection(&g_csGCCProvider);
    g_pGCCController->UnRegisterAppSap(this);
    ::LeaveCriticalSection(&g_csGCCProvider);

    //
    // Reset the app related data
    //
    m_pAppData = NULL;
    m_pfnCallback = NULL;

    //
    // Remove any message in the queue.
    //
    PurgeMessageQueue();

    //
    // Release this object now.
    //
    Release();
}


void CAppSap::
PostAppSapMsg ( GCCAppSapMsgEx *pAppSapMsgEx )
{
    ASSERT(NULL != m_hwndNotify);
    ::PostMessage(m_hwndNotify,
                  ASAPMSG_BASE + (UINT) pAppSapMsgEx->Msg.eMsgType,
                  (WPARAM) pAppSapMsgEx,
                  (LPARAM) this);
}


/*
 *	AppEnroll()
 *
 *	Public Function Description:
 *		This routine is called when an application wants to enroll in a 
 *		conference.  The controller is notified of the enrollment request.
 */
GCCError CAppSap::
AppEnroll
(
    GCCConfID           nConfID,
    GCCEnrollRequest    *pReq,
    GCCRequestTag       *pnReqTag
)
{
    GCCError    rc;
    CConf       *pConf;

    DebugEntry(CAppSap::AppEnroll);

    // sanity check
    if (NULL == pReq || NULL == pnReqTag)
    {
        rc = GCC_INVALID_PARAMETER;
        goto MyExit;
    }

    TRACE_OUT_EX(ZONE_T120_APP_ROSTER,
            ("CAppSap::AppEnroll: confID=%u, enrolled?=%u, active?=%u\r\n",
            (UINT) nConfID, (UINT) pReq->fEnroll, (UINT) pReq->fEnrollActively));

    // create the request id
    *pnReqTag = GenerateRequestTag();

    // find the corresponding conference
    if (NULL == (pConf = g_pGCCController->GetConfObject(nConfID)))
    {
        rc = GCC_INVALID_CONFERENCE;
        goto MyExit;
    }

	// check to make sure that the application has a valid uid and
	// session key if it is enrolling.
	if (pReq->fEnroll)
	{
		if (pReq->fEnrollActively)
		{
			if (pReq->nUserID < MINIMUM_USER_ID_VALUE)
			{
				rc = GCC_INVALID_MCS_USER_ID;
				goto MyExit;
			}
		}
		else if (pReq->nUserID < MINIMUM_USER_ID_VALUE)
		{
			// we must make sure that this is zero if it is invalid and
			// the user is enrolling inactively.
			pReq->nUserID = GCC_INVALID_UID;
		}

		if (NULL == pReq->pSessionKey)
		{
			rc = GCC_BAD_SESSION_KEY;
			goto MyExit;
		}
	}

    ::EnterCriticalSection(&g_csGCCProvider);
    rc = pConf->AppEnrollRequest(this, pReq, *pnReqTag);
    ::LeaveCriticalSection(&g_csGCCProvider);

MyExit:

    DebugExitINT(CAppSap::AppEnroll, rc);
    return rc;
}


GCCError CAppSap::
AppInvoke
(
    GCCConfID                 nConfID,
    GCCAppProtEntityList      *pApeList,
    GCCSimpleNodeList         *pNodeList,
    GCCRequestTag             *pnReqTag
)
{
    return CBaseSap::AppInvoke(nConfID, pApeList, pNodeList, pnReqTag);
}


GCCError CAppSap::
AppRosterInquire
(
    GCCConfID                  nConfID,
    GCCSessionKey              *pSessionKey,
    GCCAppSapMsg               **ppMsg
)
{
    return CBaseSap::AppRosterInquire(nConfID, pSessionKey, (GCCAppSapMsgEx **) ppMsg);
}


BOOL CAppSap::
IsThisNodeTopProvider ( GCCConfID nConfID )
{
    return CBaseSap::IsThisNodeTopProvider(nConfID);
}


GCCNodeID CAppSap::
GetTopProvider ( GCCConfID nConfID )
{
    return CBaseSap::GetTopProvider(nConfID);
}


GCCError CAppSap::
ConfRosterInquire(GCCConfID nConfID, GCCAppSapMsg **ppMsg)
{
    return CBaseSap::ConfRosterInquire(nConfID, (GCCAppSapMsgEx **) ppMsg);
}


GCCError CAppSap::
ConductorInquire ( GCCConfID nConfID )
{
    return CBaseSap::ConductorInquire(nConfID);
}


/*
 *	RegisterChannel()
 *
 *	Public Function Description:
 *		This routine is called when an application wishes to register a 
 *		channel.  The call is routed to the appropriate conference object.
 */
GCCError CAppSap::
RegisterChannel
(
    GCCConfID           nConfID,
    GCCRegistryKey      *pRegKey,
    ChannelID           nChnlID
)
{
	GCCError    rc;
	CConf       *pConf;

    DebugEntry(CAppSap::RegisterChannel);

    if (NULL == pRegKey)
    {
        rc = GCC_INVALID_PARAMETER;
        goto MyExit;
    }

    /*
	**	If the desired conference exists, call it in order to register the
	**	channel.  Report an error if the desired conference does not exist.
	*/
	if (NULL == (pConf = g_pGCCController->GetConfObject(nConfID)))
	{
        WARNING_OUT(("CAppSap::RegisterChannel: invalid conf id=%u", (UINT) nConfID));
		rc = GCC_INVALID_CONFERENCE;
        goto MyExit;
    }

    ::EnterCriticalSection(&g_csGCCProvider);
    rc = (nChnlID != 0) ? pConf->RegistryRegisterChannelRequest(pRegKey, nChnlID, this) :
                          GCC_INVALID_CHANNEL;
    ::LeaveCriticalSection(&g_csGCCProvider);
    if (GCC_NO_ERROR != rc)
    {
        ERROR_OUT(("CAppSap::RegisterChannel: can't register channel, rc=%u", (UINT) rc));
        // goto MyExit;
    }

MyExit:

    DebugExitINT(CAppSap::RegisterChannel, rc);
	return rc;
}


/*
 *	RegistryAssignToken()
 *
 *	Public Function Description:
 *		This routine is called when an application wishes to assign a 
 *		token.  The call is routed to the appropriate conference object.
 */
GCCError CAppSap::
RegistryAssignToken
(
    GCCConfID           nConfID,
    GCCRegistryKey      *pRegKey
)
{
	GCCError    rc;
	CConf       *pConf;

    DebugEntry(CAppSap::RegistryAssignToken);

    if (NULL == pRegKey)
    {
        rc = GCC_INVALID_PARAMETER;
        goto MyExit;
    }

	/*
	**	If the desired conference exists, call it in order to assign the
	**	token.  Report an error if the desired conference does not exist.
	*/
	if (NULL == (pConf = g_pGCCController->GetConfObject(nConfID)))
	{
        WARNING_OUT(("CAppSap::RegistryAssignToken: invalid conf id=%u", (UINT) nConfID));
		rc = GCC_INVALID_CONFERENCE;
        goto MyExit;
    }

    ::EnterCriticalSection(&g_csGCCProvider);
    rc = pConf->RegistryAssignTokenRequest(pRegKey, this);
    ::LeaveCriticalSection(&g_csGCCProvider);
    if (GCC_NO_ERROR != rc)
    {
        ERROR_OUT(("CAppSap::RegistryAssignToken: can't assign token, rc=%u", (UINT) rc));
        // goto MyExit;
    }

MyExit:

    DebugExitINT(CAppSap::RegistryAssignToken, rc);
	return rc;
}

/*
 *	RegistrySetParameter()
 *
 *	Public Function Description:
 *		This routine is called when an application wishes to set a 
 *		parameter.  The call is routed to the appropriate conference object.
 */
GCCError CAppSap::
RegistrySetParameter
(
    GCCConfID              nConfID,
    GCCRegistryKey         *pRegKey,
    LPOSTR                 poszParameter,
    GCCModificationRights  eRights
)
{
	GCCError    rc;
	CConf       *pConf;

    DebugEntry(CAppSap::RegistrySetParameter);

    if (NULL == pRegKey || NULL == poszParameter)
    {
        rc = GCC_INVALID_PARAMETER;
        goto MyExit;
    }

	/*
	**	If the desired conference exists, call it in order to set the
	**	parameter.  Report an error if the desired conference does not exist.
	*/
	if (NULL == (pConf = g_pGCCController->GetConfObject(nConfID)))
	{
        WARNING_OUT(("CAppSap::RegistrySetParameter: invalid conf id=%u", (UINT) nConfID));
		rc = GCC_INVALID_CONFERENCE;
        goto MyExit;
    }

    switch (eRights)
    {
    case GCC_OWNER_RIGHTS:
    case GCC_SESSION_RIGHTS:
    case GCC_PUBLIC_RIGHTS:
    case GCC_NO_MODIFICATION_RIGHTS_SPECIFIED:
        ::EnterCriticalSection(&g_csGCCProvider);
        rc = pConf->RegistrySetParameterRequest(pRegKey, poszParameter, eRights, this);
        ::LeaveCriticalSection(&g_csGCCProvider);
        if (GCC_NO_ERROR != rc)
        {
            ERROR_OUT(("CAppSap::RegistrySetParameter: can't set param, rc=%u", (UINT) rc));
            // goto MyExit;
        }
        break;
    default:
        rc = GCC_INVALID_MODIFICATION_RIGHTS;
        break;
	}

MyExit:

    DebugExitINT(CAppSap::RegistrySetParameter, rc);
	return rc;
}

/*
 *	RegistryRetrieveEntry()
 *
 *	Public Function Description:
 *		This routine is called when an application wishes to retrieve a registry 
 *		entry.  The call is routed to the appropriate conference object.
 */
GCCError CAppSap::
RegistryRetrieveEntry
(
    GCCConfID           nConfID,
    GCCRegistryKey      *pRegKey
)
{
	GCCError    rc;
	CConf       *pConf;

    DebugEntry(CAppSap::RegistryRetrieveEntry);

    if (NULL == pRegKey)
    {
        rc = GCC_INVALID_PARAMETER;
        goto MyExit;
    }

	/*
	**	If the desired conference exists, call it in order to retrieve the
	**	registry entry.  Report an error if the desired conference does not 
	**	exist.
	*/
	if (NULL == (pConf = g_pGCCController->GetConfObject(nConfID)))
	{
        WARNING_OUT(("CAppSap::RegistryRetrieveEntry: invalid conf id=%u", (UINT) nConfID));
		rc = GCC_INVALID_CONFERENCE;
        goto MyExit;
    }

    ::EnterCriticalSection(&g_csGCCProvider);
	rc = pConf->RegistryRetrieveEntryRequest(pRegKey, this);
    ::LeaveCriticalSection(&g_csGCCProvider);
    if (GCC_NO_ERROR != rc)
    {
        ERROR_OUT(("CAppSap::RegistryRetrieveEntry: can't retrieve entry, rc=%u", (UINT) rc));
        // goto MyExit;
    }

MyExit:

    DebugExitINT(CAppSap::RegistryRetrieveEntry, rc);
	return rc;
}

/*
 *	RegistryDeleteEntry()
 *
 *	Public Function Description:
 *		This routine is called when an application wishes to delete a registry 
 *		entry.  The call is routed to the appropriate conference object.
 */
GCCError CAppSap::
RegistryDeleteEntry
(
    GCCConfID           nConfID,
    GCCRegistryKey      *pRegKey
)
{
	GCCError    rc;
	CConf       *pConf;

    DebugEntry(IAppSap::RegistryDeleteEntry);

    if (NULL == pRegKey)
    {
		ERROR_OUT(("CAppSap::RegistryDeleteEntry: null pRegKey"));
        rc = GCC_INVALID_PARAMETER;
        goto MyExit;
    }

	/*
	**	If the desired conference exists, call it in order to delete the
	**	desired registry entry.  Report an error if the desired conference does
	**	not exist.
	*/
	if (NULL == (pConf = g_pGCCController->GetConfObject(nConfID)))
	{
        TRACE_OUT(("CAppSap::RegistryDeleteEntry: invalid conf id=%u", (UINT) nConfID));
		rc = GCC_INVALID_CONFERENCE;
        goto MyExit;
    }

    ::EnterCriticalSection(&g_csGCCProvider);
	rc = pConf->RegistryDeleteEntryRequest(pRegKey, this);
    ::LeaveCriticalSection(&g_csGCCProvider);
    if (GCC_NO_ERROR != rc)
    {
        WARNING_OUT(("CAppSap::RegistryDeleteEntry: can't delete entry, rc=%u", (UINT) rc));
        // goto MyExit;
    }

MyExit:

    DebugExitINT(CAppSap::RegistryDeleteEntry, rc);
	return rc;
}

/*
 *	RegistryMonitor()
 *
 *	Public Function Description:
 *		This routine is called when an application wishes to monitor a 
 *		particular registry entry.  The call is routed to the appropriate 
 *		conference object.
 */
GCCError CAppSap::
RegistryMonitor
(
    GCCConfID           nConfID,
    BOOL                fEnalbeDelivery,
    GCCRegistryKey      *pRegKey
)
{
	GCCError    rc;
	CConf       *pConf;

    DebugEntry(IAppSap::RegistryMonitor);

    if (NULL == pRegKey)
    {
        rc = GCC_INVALID_PARAMETER;
        goto MyExit;
    }

	/*
	**	If the desired conference exists, call it in order to monitor the
	**	appropriate registry entry.  Report an error if the desired conference
	**	does not exist.
	*/
	if (NULL == (pConf = g_pGCCController->GetConfObject(nConfID)))
	{
        WARNING_OUT(("CAppSap::RegistryMonitor: invalid conf id=%u", (UINT) nConfID));
		rc = GCC_INVALID_CONFERENCE;
        goto MyExit;
    }

    ::EnterCriticalSection(&g_csGCCProvider);
	rc = pConf->RegistryMonitorRequest(fEnalbeDelivery, pRegKey, this);
    ::LeaveCriticalSection(&g_csGCCProvider);
    if (GCC_NO_ERROR != rc)
    {
        ERROR_OUT(("CAppSap::RegistryMonitor: can't monitor the registry, rc=%u", (UINT) rc));
        // goto MyExit;
    }

MyExit:

    DebugExitINT(CAppSap::RegistryMonitor, rc);
	return rc;
}

/*
 *	RegistryAllocateHandle()
 *
 *	Public Function Description:
 *		This routine is called when an application wishes to allocate one or 
 *		more handles.  The call is routed to the appropriate conference object.
 */
GCCError CAppSap::
RegistryAllocateHandle
(
    GCCConfID           nConfID,
    ULONG               cHandles
)
{
	GCCError    rc;
	CConf       *pConf;

    DebugEntry(CAppSap::RegistryAllocateHandle);

	/*
	**	If the desired conference exists, call it in order to allocate the
	**	handle(s).  Report an error if the desired conference does not exist or
	**	if the number of handles wishing to be allocated is not within the
	**	allowable range.
	*/
	if (NULL == (pConf = g_pGCCController->GetConfObject(nConfID)))
	{
        WARNING_OUT(("CAppSap::RegistryAllocateHandle: invalid conf id=%u", (UINT) nConfID));
		rc = GCC_INVALID_CONFERENCE;
        goto MyExit;
    }

    ::EnterCriticalSection(&g_csGCCProvider);
	rc = ((cHandles >= MINIMUM_NUMBER_OF_ALLOCATED_HANDLES) &&
          (cHandles <= MAXIMUM_NUMBER_OF_ALLOCATED_HANDLES)) ?
            pConf->RegistryAllocateHandleRequest(cHandles, this) :
            GCC_BAD_NUMBER_OF_HANDLES;
    ::LeaveCriticalSection(&g_csGCCProvider);
    if (GCC_NO_ERROR != rc)
    {
        ERROR_OUT(("CAppSap::RegistryAllocateHandle: can't allocate handles, cHandles=%u, rc=%u", (UINT) cHandles, (UINT) rc));
        // goto MyExit;
    }

MyExit:

    DebugExitINT(CAppSap::RegistryAllocateHandle, rc);
    return rc;
}

/*
 *	The following routines are all Command Target Calls
 */
 
/*
 *	PermissionToEnrollIndication ()
 *
 *	Public Function Description:
 *		This routine is called by the Controller when it wishes to send an
 *		indication to the user application notifying it of a "permission to 
 *		enroll" event.  This does not mean that permission to enroll is
 *		necessarily granted to the application.
 */
GCCError CAppSap::
PermissionToEnrollIndication
(
    GCCConfID           nConfID,
    BOOL                fGranted
)
{
    GCCError rc;

    DebugEntry(CAppSap: PermissionToEnrollIndication);
    TRACE_OUT_EX(ZONE_T120_APP_ROSTER, ("CAppSap::PermissionToEnrollIndication: "
                    "confID=%u, granted?=%u\r\n",
                    (UINT) nConfID, (UINT) fGranted));

    DBG_SAVE_FILE_LINE
    GCCAppSapMsgEx *pMsgEx = new GCCAppSapMsgEx(GCC_PERMIT_TO_ENROLL_INDICATION);
    if (NULL != pMsgEx)
    {
        pMsgEx->Msg.nConfID = nConfID;
        pMsgEx->Msg.AppPermissionToEnrollInd.nConfID = nConfID;
        pMsgEx->Msg.AppPermissionToEnrollInd.fPermissionGranted = fGranted;
        PostAppSapMsg(pMsgEx);
        rc = GCC_NO_ERROR;
    }
    else
    {
        ERROR_OUT(("CAppSap: PermissionToEnrollIndication: can't create GCCAppSapMsgEx"));
        rc = GCC_ALLOCATION_FAILURE;
    }

    DebugExitINT(CAppSap: PermissionToEnrollIndication, rc);
    return rc;
}

/*
 *	AppEnrollConfirm ()
 *
 *	Public Function Description:
 *		This routine is called by the CConf object when it wishes
 *		to send an enrollment confirmation to the user application.
 */
GCCError CAppSap::
AppEnrollConfirm ( GCCAppEnrollConfirm *pConfirm )
{
    GCCError rc;

    DebugEntry(CAppSap::AppEnrollConfirm);

    DBG_SAVE_FILE_LINE
    GCCAppSapMsgEx *pMsgEx = new GCCAppSapMsgEx(GCC_ENROLL_CONFIRM);
    if (NULL != pMsgEx)
    {
        pMsgEx->Msg.nConfID = pConfirm->nConfID;
        pMsgEx->Msg.AppEnrollConfirm = *pConfirm;

        PostAppSapMsg(pMsgEx);
        rc = GCC_NO_ERROR;
    }
    else
    {
        ERROR_OUT(("CAppSap::AppEnrollConfirm: can't create GCCAppSapMsgEx"));
        rc = GCC_ALLOCATION_FAILURE;
    }

    DebugExitINT(CAppSap: AppEnrollConfirm, rc);
    return rc;
}

/*
 *	RegistryConfirm ()
 *
 *	Public Function Description:
 *		This command target routine is called by the CConf object when it
 *		wishes to send an registry confirmation to the user application.
 */
GCCError CAppSap::
RegistryConfirm
(
    GCCConfID               nConfID,
    GCCMessageType          eMsgType,
    CRegKeyContainer        *pRegKey,
    CRegItem                *pRegItem,
    GCCModificationRights   eRights,
    GCCNodeID               nidOwner,
    GCCEntityID             eidOwner,
    BOOL                    fDeliveryEnabled,
    GCCResult               nResult
)
{
    GCCError                rc;

    DebugEntry(CAppSap::RegistryConfirm);

    DBG_SAVE_FILE_LINE
    GCCAppSapMsgEx *pMsgEx = new GCCAppSapMsgEx(eMsgType);
    if (NULL == pMsgEx)
    {
        ERROR_OUT(("CAppSap::RegistryConfirm: can't create GCCAppSapMsgEx"));
        rc = GCC_ALLOCATION_FAILURE;
        goto MyExit;
    }

    pMsgEx->Msg.nConfID = nConfID;

    if (NULL != pRegKey)
    {
        rc = pRegKey->CreateRegistryKeyData(&(pMsgEx->Msg.RegistryConfirm.pRegKey));
        if (GCC_NO_ERROR != rc)
        {
            ERROR_OUT(("CAppSap::RegistryConfirm: can't get registry key data, rc=%u", (UINT) rc));
            goto MyExit;
        }
    }

    if (NULL != pRegItem)
    {
        rc = pRegItem->CreateRegistryItemData(&(pMsgEx->Msg.RegistryConfirm.pRegItem));
        if (GCC_NO_ERROR != rc)
        {
            ERROR_OUT(("CAppSap::RegistryConfirm: can't get registry item data, rc=%u", (UINT) rc));
            goto MyExit;
        }
    }

    if (GCC_INVALID_NID != nidOwner)
    {
        pMsgEx->Msg.RegistryConfirm.EntryOwner.entry_is_owned = TRUE;
        pMsgEx->Msg.RegistryConfirm.EntryOwner.owner_node_id = nidOwner;
        pMsgEx->Msg.RegistryConfirm.EntryOwner.owner_entity_id = eidOwner;
    }

    pMsgEx->Msg.RegistryConfirm.nConfID = nConfID;
    pMsgEx->Msg.RegistryConfirm.eRights = eRights;
    pMsgEx->Msg.RegistryConfirm.nResult = nResult;
    pMsgEx->Msg.RegistryConfirm.fDeliveryEnabled = fDeliveryEnabled; // for monitor only

    PostAppSapMsg(pMsgEx);
    rc = GCC_NO_ERROR;

MyExit:

    if (GCC_NO_ERROR != rc)
    {
        delete pMsgEx;
    }

    DebugExitINT(CAppSap::RegistryConfirm, rc);
    return rc;
}


/*
 *	RegistryMonitorIndication()
 *
 *	Public Function Description
 *		This command target routine is called by the CConf object when it
 *		wishes to send a Registry monitor indication to the user application.
 */


/*
 *	RegistryAllocateHandleConfirm()
 *
 *	Public Function Description:
 *		This command target routine is called by the CConf object when it
 *		wishes to send a handle allocation confirmation to the user application.
 */
GCCError CAppSap::
RegistryAllocateHandleConfirm
(
    GCCConfID       nConfID,
    ULONG           cHandles,
    ULONG           nFirstHandle,
    GCCResult       nResult
)
{
    GCCError                     rc;

    DebugEntry(CAppSap::RegistryAllocateHandleConfirm);

    DBG_SAVE_FILE_LINE
    GCCAppSapMsgEx *pMsgEx = new GCCAppSapMsgEx(GCC_ALLOCATE_HANDLE_CONFIRM);
    if (NULL != pMsgEx)
    {
        pMsgEx->Msg.nConfID = nConfID;
        pMsgEx->Msg.RegAllocHandleConfirm.nConfID = nConfID;
        pMsgEx->Msg.RegAllocHandleConfirm.cHandles = cHandles;
        pMsgEx->Msg.RegAllocHandleConfirm.nFirstHandle = nFirstHandle;
        pMsgEx->Msg.RegAllocHandleConfirm.nResult = nResult;

        PostAppSapMsg(pMsgEx);
        rc = GCC_NO_ERROR;
    }
    else
    {
        ERROR_OUT(("CAppSap::RegistryAllocateHandleConfirm: can't create GCCAppSapMsgEx"));
        rc = GCC_ALLOCATION_FAILURE;
    }

    DebugExitINT(CAppSap::RegistryAllocateHandleConfirm, rc);
    return rc;
}



void CAppSapList::
DeleteList ( void )
{
    CAppSap *pAppSap;
    while (NULL != (pAppSap = Get()))
    {
        pAppSap->Release();
    }
}


void CAppSapEidList2::
DeleteList ( void )
{
    CAppSap *pAppSap;
    while (NULL != (pAppSap = Get()))
    {
        pAppSap->Release();
    }
}


/* 
 *	ConfRosterInquireConfirm()
 *
 *	Public Function Description
 *		This routine is called in order to return a requested conference
 *		roster to an application or the node controller.
 */
GCCError CAppSap::
ConfRosterInquireConfirm
(
    GCCConfID                   nConfID,
    PGCCConferenceName          pConfName,
    LPSTR                       pszConfModifier,
    LPWSTR                      pwszConfDescriptor,
    CConfRoster                 *pConfRoster,
    GCCResult                   nResult,
    GCCAppSapMsgEx              **ppMsgExToRet
)
{
    GCCError  rc;
    BOOL      fLock = FALSE;
    UINT      cbDataSize;

    DebugEntry(CAppSap::ConfRosterInquireConfirm);

    DBG_SAVE_FILE_LINE
    GCCAppSapMsgEx *pMsgEx = new GCCAppSapMsgEx(GCC_ROSTER_INQUIRE_CONFIRM);
    if (NULL == pMsgEx)
    {
        ERROR_OUT(("CAppSap::ConfRosterInquireConfirm: can't create GCCAppSapMsgEx"));
        rc = GCC_ALLOCATION_FAILURE;
        goto MyExit;
    }

    pMsgEx->Msg.nConfID = nConfID;

    pMsgEx->Msg.ConfRosterInquireConfirm.nConfID = nConfID;
    pMsgEx->Msg.ConfRosterInquireConfirm.nResult = nResult;
    pMsgEx->Msg.ConfRosterInquireConfirm.ConfName.numeric_string = ::My_strdupA(pConfName->numeric_string);
    pMsgEx->Msg.ConfRosterInquireConfirm.ConfName.text_string = ::My_strdupW(pConfName->text_string);
    pMsgEx->Msg.ConfRosterInquireConfirm.pszConfModifier = ::My_strdupA(pszConfModifier);
    pMsgEx->Msg.ConfRosterInquireConfirm.pwszConfDescriptor = ::My_strdupW(pwszConfDescriptor);

    /*
     * Lock the data for the conference roster.  The lock call will 
     * return the length of the data to be serialized for the roster so
     * add that	length to the total memory block size and allocate the 
     * memory block.
     */
    fLock = TRUE;
    cbDataSize = pConfRoster->LockConferenceRoster();
    if (0 != cbDataSize)
    {
        DBG_SAVE_FILE_LINE
        pMsgEx->Msg.ConfRosterInquireConfirm.pConfRoster = (PGCCConfRoster) new char[cbDataSize];
        if (NULL == pMsgEx->Msg.ConfRosterInquireConfirm.pConfRoster)
        {
            ERROR_OUT(("CAppSap::ConfRosterInquireConfirm: can't create conf roster buffer"));
            rc = GCC_ALLOCATION_FAILURE;
            goto MyExit;
        }

        /*
        * Retrieve the conference roster data from the roster object.
        * The roster object will serialize any referenced data into 
        * the memory block passed in to the "Get" call.
        */
        pConfRoster->GetConfRoster(&(pMsgEx->Msg.ConfRosterInquireConfirm.pConfRoster),
                                   (LPBYTE) pMsgEx->Msg.ConfRosterInquireConfirm.pConfRoster);
    }

    if (NULL != ppMsgExToRet)
    {
        *ppMsgExToRet = pMsgEx;
    }
    else
    {
        PostAppSapMsg(pMsgEx);
    }

    rc = GCC_NO_ERROR;

MyExit:

    if (fLock)
    {
        pConfRoster->UnLockConferenceRoster();
    }

    if (GCC_NO_ERROR != rc)
    {
        delete pMsgEx;
    }

    DebugExitINT(CAppSap::ConfRosterInquireConfirm, rc);
    return rc;
}


/*
 *	AppRosterInquireConfirm()
 *
 *	Public Function Description
 *		This routine is called in order to return a requested list of
 *		application rosters to an application or the node controller.
 */
GCCError CAppSap::
AppRosterInquireConfirm
(
    GCCConfID           nConfID,
    CAppRosterMsg       *pAppRosterMsg,
    GCCResult           nResult,
    GCCAppSapMsgEx      **ppMsgEx
)
{
    GCCError    rc;

    DebugEntry(CAppSap::AppRosterInquireConfirm);

    DBG_SAVE_FILE_LINE
    GCCAppSapMsgEx *pMsgEx = new GCCAppSapMsgEx(GCC_APP_ROSTER_INQUIRE_CONFIRM);
    if (NULL == pMsgEx)
    {
        ERROR_OUT(("CAppSap::AppRosterInquireConfirm: can't create GCCAppSapMsgEx"));
        rc = GCC_ALLOCATION_FAILURE;
        goto MyExit;
    }
    pMsgEx->Msg.nConfID = nConfID;

    /*
    * Lock the data for the roster message and retrieve the data.
    */
    rc = pAppRosterMsg->LockApplicationRosterMessage();
    if (GCC_NO_ERROR != rc)
    {
        ERROR_OUT(("CAppSap::AppRosterInquireConfirm: can't lock app roster message, rc=%u", (UINT) rc));
        goto MyExit;
    }

    rc = pAppRosterMsg->GetAppRosterMsg((LPBYTE *) &(pMsgEx->Msg.AppRosterInquireConfirm.apAppRosters),
                                        &(pMsgEx->Msg.AppRosterInquireConfirm.cRosters));
    if (GCC_NO_ERROR != rc)
    {
        ERROR_OUT(("CAppSap::AppRosterInquireConfirm: can't get app roster message, rc=%u", (UINT) rc));
        pAppRosterMsg->UnLockApplicationRosterMessage();
        goto MyExit;
    }

    // fill in the roster information
    pMsgEx->Msg.AppRosterInquireConfirm.pReserved = (LPVOID) pAppRosterMsg;
    pMsgEx->Msg.AppRosterInquireConfirm.nConfID = nConfID;
    pMsgEx->Msg.AppRosterInquireConfirm.nResult = nResult;

    if (NULL != ppMsgEx)
    {
        *ppMsgEx = pMsgEx;
    }
    else
    {
        PostAppSapMsg(pMsgEx);
    }

    rc = GCC_NO_ERROR;

MyExit:

    if (GCC_NO_ERROR != rc)
    {
        delete pMsgEx;
    }

    DebugExitINT(CAppSap::AppRosterInquireConfirm, rc);
    return rc;
}


void CAppSap::
FreeAppSapMsg ( GCCAppSapMsg *pMsg )
{
    GCCAppSapMsgEx *pMsgEx = (GCCAppSapMsgEx *) pMsg;
    ASSERT((LPVOID) pMsgEx == (LPVOID) pMsg);
    delete pMsgEx;
}


/* 
 *	AppInvokeConfirm ()
 *
 *	Public Function Description
 *		This routine is called in order to confirm a call requesting application
 *		invocation.
 */
GCCError CAppSap::
AppInvokeConfirm
(
    GCCConfID                       nConfID,
    CInvokeSpecifierListContainer   *pInvokeList,
    GCCResult                       nResult,
    GCCRequestTag                   nReqTag
)
{
    GCCError                rc;

    DebugEntry(CAppSap::AppInvokeConfirm);

    DBG_SAVE_FILE_LINE
    GCCAppSapMsgEx *pMsgEx = new GCCAppSapMsgEx(GCC_APPLICATION_INVOKE_CONFIRM);
    if (NULL != pMsgEx)
    {
        pMsgEx->Msg.nConfID = nConfID;
        pMsgEx->Msg.AppInvokeConfirm.nConfID = nConfID;
        pMsgEx->Msg.AppInvokeConfirm.nResult = nResult;
        pMsgEx->Msg.AppInvokeConfirm.nReqTag = nReqTag;

        PostAppSapMsg(pMsgEx);
        rc = GCC_NO_ERROR;
    }
    else
    {
        ERROR_OUT(("CAppSap::AppInvokeConfirm: can't create GCCAppSapMsgEx"));
        rc = GCC_ALLOCATION_FAILURE;
    }

    DebugExitINT(CAppSap::AppInvokeConfirm, rc);
    return rc;
}


/* 
 *	AppInvokeIndication()
 *
 *	Public Function Description
 *		This routine is called in order to send an indication to an application
 *		or node controller that a request for application invocation has been
 *		made.
 */
GCCError CAppSap::
AppInvokeIndication
(
    GCCConfID                       nConfID,
    CInvokeSpecifierListContainer   *pInvokeList,
    GCCNodeID                       nidInvoker
)
{
    GCCError            rc;
    UINT                cbDataSize;
    BOOL                fLock = FALSE;

    DebugEntry(CAppSap::AppInvokeIndication);

    DBG_SAVE_FILE_LINE
    GCCAppSapMsgEx *pMsgEx = new GCCAppSapMsgEx(GCC_APPLICATION_INVOKE_INDICATION);
    if (NULL == pMsgEx)
    {
        ERROR_OUT(("CAppSap::AppInvokeIndication: can't create GCCAppSapMsgEx"));
        rc = GCC_ALLOCATION_FAILURE;
        goto MyExit;
    }
    pMsgEx->Msg.nConfID = nConfID;

    fLock = TRUE;
    cbDataSize = pInvokeList->LockApplicationInvokeSpecifierList();
    if (0 != cbDataSize)
    {
        DBG_SAVE_FILE_LINE
        pMsgEx->Msg.AppInvokeInd.ApeList.apApes = (PGCCAppProtocolEntity *) new char[cbDataSize];
        if (NULL == pMsgEx->Msg.AppInvokeInd.ApeList.apApes)
        {
            ERROR_OUT(("CAppSap::AppInvokeIndication: can't create ape list"));
            rc = GCC_ALLOCATION_FAILURE;
            goto MyExit;
        }

        pInvokeList->GetApplicationInvokeSpecifierList(
                            &(pMsgEx->Msg.AppInvokeInd.ApeList.cApes),
                            (LPBYTE) pMsgEx->Msg.AppInvokeInd.ApeList.apApes);
    }

    pMsgEx->Msg.AppInvokeInd.nConfID = nConfID;
    pMsgEx->Msg.AppInvokeInd.nidInvoker = nidInvoker;

    PostAppSapMsg(pMsgEx);

    rc = GCC_NO_ERROR;

MyExit:

    if (fLock)
    {
        pInvokeList->UnLockApplicationInvokeSpecifierList();
    }

    if (GCC_NO_ERROR != rc)
    {
        delete pMsgEx;
    }

    DebugExitINT(CAppSap::AppInvokeIndication, rc);
    return rc;
}


/*
 *	AppRosterReportIndication ()
 *
 *	Public Function Description
 *		This routine is called in order to indicate to applications and the
 *		node controller that the list of application rosters has been updated.
 */
GCCError CAppSap::
AppRosterReportIndication
(
    GCCConfID           nConfID,
    CAppRosterMsg       *pAppRosterMsg
)
{
    GCCError    rc;

    DebugEntry(CAppSap::AppRosterReportIndication);

    DBG_SAVE_FILE_LINE
    GCCAppSapMsgEx *pMsgEx = new GCCAppSapMsgEx(GCC_APP_ROSTER_REPORT_INDICATION);
    if (NULL == pMsgEx)
    {
        ERROR_OUT(("CAppSap::AppRosterReportIndication: can't create GCCAppSapMsgEx"));
        rc = GCC_ALLOCATION_FAILURE;
        goto MyExit;
    }
    pMsgEx->Msg.nConfID = nConfID;

    /*
    * Lock the data for the roster message and retrieve the data.
    */
    rc = pAppRosterMsg->LockApplicationRosterMessage();
    if (GCC_NO_ERROR != rc)
    {
        ERROR_OUT(("CAppSap::AppRosterReportIndication: can't lock app roster message, rc=%u", (UINT) rc));
        goto MyExit;
    }

    rc = pAppRosterMsg->GetAppRosterMsg((LPBYTE *) &(pMsgEx->Msg.AppRosterReportInd.apAppRosters),
                                        &(pMsgEx->Msg.AppRosterReportInd.cRosters));
    if (GCC_NO_ERROR != rc)
    {
        ERROR_OUT(("CAppSap::AppRosterReportIndication: can't get app roster message, rc=%u", (UINT) rc));
        pAppRosterMsg->UnLockApplicationRosterMessage();
        goto MyExit;
    }

    // fill in the roster information
    pMsgEx->Msg.AppRosterReportInd.pReserved = (LPVOID) pAppRosterMsg;
    pMsgEx->Msg.AppRosterReportInd.nConfID = nConfID;

    PostAppSapMsg(pMsgEx);

    rc = GCC_NO_ERROR;

MyExit:

    if (GCC_NO_ERROR != rc)
    {
        delete pMsgEx;
    }

    DebugExitINT(CAppSap::AppRosterReportIndication, rc);
    return rc;
}


/*
 *	ConductorInquireConfirm ()
 *
 *	Public Function Description
 *		This routine is called in order to return conductorship information
 *		which has been requested.
 *
 */
GCCError CAppSap::
ConductorInquireConfirm
(
    GCCNodeID           nidConductor,
    GCCResult           nResult,
    BOOL                fGranted,
    BOOL                fConducted,
    GCCConfID           nConfID
)
{
    GCCError                    rc;

    DebugEntry(CAppSap::ConductorInquireConfirm);

    DBG_SAVE_FILE_LINE
    GCCAppSapMsgEx *pMsgEx = new GCCAppSapMsgEx(GCC_CONDUCT_INQUIRE_CONFIRM);
    if (NULL != pMsgEx)
    {
        pMsgEx->Msg.nConfID = nConfID;
        pMsgEx->Msg.ConductorInquireConfirm.nConfID = nConfID;
        pMsgEx->Msg.ConductorInquireConfirm.fConducted = fConducted;
        pMsgEx->Msg.ConductorInquireConfirm.nidConductor = nidConductor;
        pMsgEx->Msg.ConductorInquireConfirm.fGranted = fGranted;
        pMsgEx->Msg.ConductorInquireConfirm.nResult = nResult;

        PostAppSapMsg(pMsgEx);
        rc = GCC_NO_ERROR;
    }
    else
    {
        ERROR_OUT(("CAppSap::ConductorInquireConfirm: can't create GCCAppSapMsgEx"));
        rc = GCC_ALLOCATION_FAILURE;
    }

    DebugExitINT(CAppSap::ConductorInquireConfirm, rc);
    return rc;
}



/* 
 *	ConductorPermitGrantIndication ()
 *
 *	Public Function Description
 *		This routine is called in order to send an indication to an application
 *		or node controller that a request for permission from the conductor
 *		has been made.
 */
GCCError CAppSap::
ConductorPermitGrantIndication
(
    GCCConfID           nConfID,
    UINT                cGranted,
    GCCNodeID           *aGranted,
    UINT                cWaiting,
    GCCNodeID           *aWaiting,
    BOOL                fThisNodeIsGranted
)
{
    GCCError                            rc;
    UINT                                cbDataSize = 0;

    DebugEntry(CAppSap::ConductorPermitGrantIndication);

    cbDataSize = (0 != cGranted || 0 != cWaiting) ?
                    (ROUNDTOBOUNDARY(sizeof(GCCNodeID)) * cGranted) +
                    (ROUNDTOBOUNDARY(sizeof(GCCNodeID)) * cWaiting) :
                    0;

    DBG_SAVE_FILE_LINE
    GCCAppSapMsgEx *pMsgEx = new GCCAppSapMsgEx(GCC_CONDUCT_GRANT_INDICATION);
    if (NULL != pMsgEx)
    {
        pMsgEx->Msg.nConfID = nConfID;

        if (cbDataSize > 0)
        {
        	DBG_SAVE_FILE_LINE
            pMsgEx->Msg.ConductorPermitGrantInd.pReserved = (LPVOID) new char[cbDataSize];
            if (NULL == pMsgEx->Msg.ConductorPermitGrantInd.pReserved)
            {
                ERROR_OUT(("CAppSap::ConductorPermitGrantIndication: can't allocate buffer, cbDataSize=%u", (UINT) cbDataSize));
                goto MyExit;
            }
        }

        pMsgEx->Msg.ConductorPermitGrantInd.nConfID = nConfID;
        pMsgEx->Msg.ConductorPermitGrantInd.Granted.cNodes = cGranted;
        if (0 != cGranted)
        {
            pMsgEx->Msg.ConductorPermitGrantInd.Granted.aNodeIDs =
                            (GCCNodeID *) pMsgEx->Msg.ConductorPermitGrantInd.pReserved;
            ::CopyMemory(pMsgEx->Msg.ConductorPermitGrantInd.Granted.aNodeIDs,
                         aGranted,
                         sizeof(GCCNodeID) * cGranted);
        }

        pMsgEx->Msg.ConductorPermitGrantInd.Waiting.cNodes = cWaiting;
        if (0 != cWaiting)
        {
            pMsgEx->Msg.ConductorPermitGrantInd.Waiting.aNodeIDs =
                            (GCCNodeID *) ((LPBYTE) pMsgEx->Msg.ConductorPermitGrantInd.pReserved +
                                           (ROUNDTOBOUNDARY(sizeof(GCCNodeID)) * cGranted));
            ::CopyMemory(pMsgEx->Msg.ConductorPermitGrantInd.Waiting.aNodeIDs,
                         aWaiting,
                         sizeof(GCCNodeID) * cWaiting);
        }
        pMsgEx->Msg.ConductorPermitGrantInd.fThisNodeIsGranted = fThisNodeIsGranted;

        PostAppSapMsg(pMsgEx);
        rc = GCC_NO_ERROR;
    }
    else
    {
        ERROR_OUT(("CAppSap::ConductorPermitGrantIndication: can't create GCCAppSapMsgEx"));
        rc = GCC_ALLOCATION_FAILURE;
    }

MyExit:

    if (GCC_NO_ERROR != rc)
    {
        delete pMsgEx;
    }

    DebugExitINT(CAppSap::ConductorPermitGrantIndication, rc);
    return rc;
}


/*
 *	ConductorAssignIndication ()
 *
 *	Public Function Description
 *		This routine is called in order to send an indication to an application
 *		or node controller that a request has been made to assign conductorship.
 */
GCCError CAppSap::
ConductorAssignIndication
(
    GCCNodeID           nidConductor,
    GCCConfID           nConfID
)
{
    GCCError                 rc;

    DebugEntry(CAppSap::ConductorAssignIndication);

    DBG_SAVE_FILE_LINE
    GCCAppSapMsgEx *pMsgEx = new GCCAppSapMsgEx(GCC_CONDUCT_ASSIGN_INDICATION);
    if (NULL != pMsgEx)
    {
        pMsgEx->Msg.nConfID = nConfID;
        pMsgEx->Msg.ConductorAssignInd.nConfID = nConfID;
        pMsgEx->Msg.ConductorAssignInd.nidConductor = nidConductor;

        PostAppSapMsg(pMsgEx);
        rc = GCC_NO_ERROR;
    }
    else
    {
        ERROR_OUT(("CAppSap::ConductorPermitGrantIndication: can't create GCCAppSapMsgEx"));
        rc = GCC_ALLOCATION_FAILURE;
    }

    DebugExitINT(CAppSap::ConductorAssignIndication, rc);
    return rc;
}

/*
 *	ConductorReleaseIndication ()
 *
 *	Public Function Description
 *		This routine is called in order to send an indication to an application
 *		or node controller that a request for releasing conductorship has been
 *		made.
 */
GCCError CAppSap::
ConductorReleaseIndication ( GCCConfID nConfID )
{
    GCCError    rc;

    DebugEntry(CAppSap::ConductorReleaseIndication);

    DBG_SAVE_FILE_LINE
    GCCAppSapMsgEx *pMsgEx = new GCCAppSapMsgEx(GCC_CONDUCT_RELEASE_INDICATION);
    if (NULL != pMsgEx)
    {
        pMsgEx->Msg.nConfID = nConfID;
        pMsgEx->Msg.ConductorReleaseInd.nConfID = nConfID;

        PostAppSapMsg(pMsgEx);
        rc = GCC_NO_ERROR;
    }
    else
    {
        ERROR_OUT(("CAppSap::ConductorReleaseIndication: can't create GCCAppSapMsgEx"));
        rc = GCC_ALLOCATION_FAILURE;
    }

    DebugExitINT(CAppSap::ConductorReleaseIndication, rc);
    return rc;
}


void CAppSap::
NotifyProc ( GCCAppSapMsgEx *pAppSapMsgEx )
{
    if (NULL != m_pfnCallback)
    {
        pAppSapMsgEx->Msg.pAppData = m_pAppData;
        (*m_pfnCallback)(&(pAppSapMsgEx->Msg));
    }
    delete pAppSapMsgEx;
}










//
// The following is for GCCAppSapMsgEx structure
//


GCCAppSapMsgEx::
GCCAppSapMsgEx ( GCCMessageType eMsgType )
{
    ::ZeroMemory(&Msg, sizeof(Msg));
    Msg.eMsgType = eMsgType;
}

GCCAppSapMsgEx::
~GCCAppSapMsgEx ( void )
{
    switch (Msg.eMsgType)
    {
    // 
    // Application Roster related callbacks
    //

    case GCC_PERMIT_TO_ENROLL_INDICATION:
    case GCC_ENROLL_CONFIRM:
    case GCC_APPLICATION_INVOKE_CONFIRM:
        //
        // No need to free anything
        //
        break;

    case GCC_APP_ROSTER_REPORT_INDICATION:
        if (NULL != Msg.AppRosterReportInd.pReserved)
        {
            //
            // App roster report is also sent to control sap.
            //
            ::EnterCriticalSection(&g_csGCCProvider);
            ((CAppRosterMsg *) Msg.AppRosterReportInd.pReserved)->UnLockApplicationRosterMessage();
            ::LeaveCriticalSection(&g_csGCCProvider);
        }
        break;

    case GCC_APP_ROSTER_INQUIRE_CONFIRM:
        if (NULL != Msg.AppRosterInquireConfirm.pReserved)
        {
            ((CAppRosterMsg *) Msg.AppRosterInquireConfirm.pReserved)->UnLockApplicationRosterMessage();
        }
        break;

    case GCC_APPLICATION_INVOKE_INDICATION:
        delete Msg.AppInvokeInd.ApeList.apApes;
        break;

    //
    // Conference Roster related callbacks
    //

    case GCC_ROSTER_INQUIRE_CONFIRM:
        delete Msg.ConfRosterInquireConfirm.ConfName.numeric_string;
        delete Msg.ConfRosterInquireConfirm.ConfName.text_string;
        delete Msg.ConfRosterInquireConfirm.pszConfModifier;
        delete Msg.ConfRosterInquireConfirm.pwszConfDescriptor;
        delete Msg.ConfRosterInquireConfirm.pConfRoster;
        break;

    //
    // Application Registry related callbacks
    //
    
    case GCC_REGISTER_CHANNEL_CONFIRM:
    case GCC_ASSIGN_TOKEN_CONFIRM:
    case GCC_RETRIEVE_ENTRY_CONFIRM:
    case GCC_DELETE_ENTRY_CONFIRM:
    case GCC_SET_PARAMETER_CONFIRM:
    case GCC_MONITOR_INDICATION:
    case GCC_MONITOR_CONFIRM:
        delete Msg.RegistryConfirm.pRegKey;
        delete Msg.RegistryConfirm.pRegItem;
        break;

    case GCC_ALLOCATE_HANDLE_CONFIRM:
        //
        // No need to free anything
        //
        break;

    //
    // Conductorship related callbacks
    //

    case GCC_CONDUCT_ASSIGN_INDICATION:
    case GCC_CONDUCT_RELEASE_INDICATION:
    case GCC_CONDUCT_INQUIRE_CONFIRM:
        //
        // No need to free anything
        //
        break;

    case GCC_CONDUCT_GRANT_INDICATION:
        delete Msg.ConductorPermitGrantInd.pReserved;
        break;

    default:
        ERROR_OUT(("GCCAppSapMsgEx::~GCCAppSapMsgEx: unknown msg type=%u", (UINT) Msg.eMsgType));
        break;
    }
}


void CAppSap::
PurgeMessageQueue(void)
{
    MSG     msg;

    /*
     *	This loop calls PeekMessage to go through all the messages in the thread's
     *	queue that were posted by the main MCS thread.  It removes these
     *	messages and frees the resources that they consume.
     */
    while (PeekMessage(&msg, m_hwndNotify, ASAPMSG_BASE, ASAPMSG_BASE + MSG_RANGE, PM_REMOVE))
    {
        if (msg.message == WM_QUIT)
        {
            // Repost the quit
            PostQuitMessage(0);
            break;
        }

        ASSERT(this == (CAppSap *) msg.lParam);
        delete (GCCAppSapMsgEx *) msg.wParam;
    }

    // Destroy the window; we do not need it anymore
    if (NULL != m_hwndNotify)
    {
        ::DestroyWindow(m_hwndNotify);
        m_hwndNotify = NULL;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\remdsk\rds\t120\mst120\arostmgr.cpp ===
#include "precomp.h"
DEBUG_FILEZONE(ZONE_T120_APP_ROSTER);
/*
 *	arostmgr.cpp
 *
 *	Copyright (c) 1995 by DataBeam Corporation, Lexington, KY
 *
 *	Abstract:
 *		This is the implementation file for the Application Roster
 *		Manager Class.
 *
 *		SEE THE INTERFACE FILE FOR A MORE DETAILED DESCRIPION OF THIS CLASS.
 *
 *	Private Instance Variables
 *		m_nConfID
 *			The conference ID associated with this roster manager.  Used
 *			when delivering roster update messages.
 *		m_fTopProvider
 *			Flag indicating if this is a top provider node for this conference.
 *		m_pMcsUserObject
 *			This is the user attachment object associated with this conference.	
 *		m_AppSapEidList2
 *			This list maintains all of the command target pointers for each
 *			of the enrolled APEs.  This list is used to deliver roster 
 *			update messages.
 *		m_pConf
 *			Pointer to object that will receive all owner callback messages
 *			delivered from the application roster manager.
 *		m_GlobalRosterList
 *			This list maintains pointers to all the global application rosters.
 *		m_LocalRosterList
 *			This list maintains pointers to all the local application rosters.
 *			This list will not be used if this is a Top Provider node.
 *		m_RosterDeleteList
 *			This list is used to hold any application rosters that have
 *			been marked to be deleted (usually when they become empty).  We
 *			don't delete immediately to allow messages and PDUs to be processed
 *			before deletion.
 *		m_pSessionKey
 *			This is the session key used to hold the protocol key associated
 *			with this application roster manager.
 *
 *	Caveats:
 *		None
 *
 *	Author:
 *		blp
 */


#include "arostmgr.h"
#include "arostmsg.h"
#include "appsap.h"
#include "csap.h"
#include "conf.h"


/*
 *	CAppRosterMgr	()
 *
 *	Public Function Description
 *	when pGccSessKey is not NULL
 *		This is the application roster manager constructor. It is responsible 
 *		for initializing all the instance variables used by this class.
 *		This constructor is used when the initial roster data that is
 *		availble comes from local API data.
 *
 *	when pSessKey is not NULL
 *		This is the application roster manager constructor. It is responsible 
 *		for initializing all the instance variables used by this class.
 *		This constructor is used when the initial roster data that is
 *		availble comes from remote PDU data.
 *		This constructor handles a number of different possiblities:
 *			For Non Top Providers:
 *				1)	A refresh received from the top provider.
 *				2)	An update from a node below this one.
 *
 *			For the Top Provider:
 *				1)	An Update from a lower node
 */
CAppRosterMgr::CAppRosterMgr(
					PGCCSessionKey			pGccSessKey,
					PSessionKey				pPduSessKey,
					GCCConfID   			nConfID,
					PMCSUser				pMcsUserObject,
					CConf					*pConf,
					PGCCError				pRetCode)
:
    CRefCount(MAKE_STAMP_ID('A','R','M','r')),
	m_nConfID(nConfID),
	// m_fTopProvider(FALSE),
	m_pMcsUserObject(pMcsUserObject),
	m_AppSapEidList2(DESIRED_MAX_APP_SAP_ITEMS),
	m_pConf(pConf)
{
	GCCError rc = GCC_NO_ERROR;

	DebugEntry(CAppRosterMgr::CAppRosterMgr);

	//	Determine if this is a top provider node
	m_fTopProvider = (m_pMcsUserObject->GetTopNodeID() == m_pMcsUserObject->GetMyNodeID());

	/*
	**	Set up this roster managers session key which will be used to 
	**	determine whether or not to process a roster request or update.
	*/
	if (NULL != pGccSessKey)
	{
		ASSERT(NULL == pPduSessKey);
		DBG_SAVE_FILE_LINE
		m_pSessionKey = new CSessKeyContainer(pGccSessKey, &rc);
	}
	else
	if (NULL != pPduSessKey)
	{
		DBG_SAVE_FILE_LINE
		m_pSessionKey = new CSessKeyContainer(pPduSessKey, &rc);
	}
	else
	{
		ERROR_OUT(("CAppRosterMgr::CAppRosterMgr: invalid session key"));
		rc = GCC_BAD_SESSION_KEY;
		goto MyExit;
	}

	if (NULL == m_pSessionKey || GCC_NO_ERROR != rc)
	{
		ERROR_OUT(("CAppRosterMgr::CAppRosterMgr: can't create session key"));
		rc = GCC_ALLOCATION_FAILURE;
		// we do the cleanup in the destructor
		goto MyExit;
    }

	ASSERT(GCC_NO_ERROR == rc);

MyExit:

	DebugExitINT(CAppRosterMgr:;CAppRosterMgr, rc);

	*pRetCode = rc;
}

/*
 *	~CAppRosterMgr()
 *
 *	Public Function Description
 *		This is the application roster manager destructor.  It is used to
 *		free up all memory associated with this class.
 */
CAppRosterMgr::~CAppRosterMgr(void)
{
	m_GlobalRosterList.DeleteList();
	m_LocalRosterList.DeleteList();
	m_RosterDeleteList.DeleteList();

	if (NULL != m_pSessionKey)
	{
	    m_pSessionKey->Release();
	}
}


/*
 *	GCCError	EnrollRequest	()
 *
 *	Public Function Description
 *		This routine is called whenever an APE wishes to enroll with the
 *		conference in a specific session.  This routine can be used to
 *		either add a new record or replace a currently existing record.
 */
GCCError CAppRosterMgr::
EnrollRequest(GCCEnrollRequest *pReq, GCCEntityID eid, GCCNodeID nid, CAppSap *pAppSap)
{
	GCCError			rc = GCC_NO_ERROR;
	CAppRoster			*pAppRoster = NULL;
	BOOL				perform_add_record;
	BOOL				maintain_pdu_data;

	DebugEntry(CAppRosterMgr::EnrollRequest);

	/*
	**	First we must make sure that the default version of this session
	**	key matches this application roster manager's
	*/
	if (! IsThisSessionKeyValid(pReq->pSessionKey))
	{
	    rc = GCC_BAD_SESSION_KEY;
	    goto MyExit;
	}

	//	Now save the App SAP so we can send roster report indications
	if (! m_AppSapEidList2.Find(eid))
	{
		m_AppSapEidList2.Append(eid, pAppSap);
		perform_add_record = TRUE;
	}
	else
    {
		perform_add_record = FALSE;
    }

	/*
	**	Next we must make sure that the global application roster (and 
	**	local for non top providers) that matches this session key exist.
	**	If they don't exists then create them here.
	*/
	pAppRoster = GetApplicationRoster(pReq->pSessionKey, &m_GlobalRosterList);
	if (pAppRoster == NULL)
	{
		maintain_pdu_data = m_fTopProvider;

		/*
		**	Here we create the global default application rosters.  If
		**	this is the Top Provider we DO maintain PDU data within the
		**	roster.
		*/
		DBG_SAVE_FILE_LINE
		pAppRoster = new CAppRoster(pReq->pSessionKey,
									NULL,	// pSessKey
									this,	// pOwnerObject
									m_fTopProvider,// fTopProvider
									FALSE,	// fLocalRoster
									maintain_pdu_data,	// fMaintainPduBuffer
									&rc);
		if ((pAppRoster != NULL) && (rc == GCC_NO_ERROR))
		{
			m_GlobalRosterList.Append(pAppRoster);
		}
		else
		{
		    rc = GCC_ALLOCATION_FAILURE;
		    goto MyExit;
		}
	}

	if (! m_fTopProvider)
	{
		pAppRoster = GetApplicationRoster(pReq->pSessionKey, &m_LocalRosterList);
		if (pAppRoster == NULL)
		{
			//	Here we create the local default application rosters.
			DBG_SAVE_FILE_LINE
			pAppRoster = new CAppRoster(pReq->pSessionKey,
										NULL,	// pSessKey
										this,	// pOwnerObject
										m_fTopProvider,// fTopProvider
										TRUE,	// fLocalRoster
										TRUE,	// fMaintainPduBuffer
										&rc);
			if ((pAppRoster != NULL) && (rc == GCC_NO_ERROR))
			{
				m_LocalRosterList.Append(pAppRoster);
			}
			else
			{
				rc = GCC_ALLOCATION_FAILURE;
				goto MyExit;
			}
		}
	}

//
// LONCHANC: Something wrong here. roster_ptr could be either
// the one in the global list or the one in the local list.
// Should we add records to both roster_ptr???
//
// LONCHANC: It seems to me that only the local list has records in non-top provider.
// On the other hand, only the global list has the record in top provider.
// cf. UnEnrollRequest().
//

    if (perform_add_record)
    {
    	//	Add the new record to the roster
    	rc = pAppRoster->AddRecord(pReq, nid, eid);
    	if (GCC_NO_ERROR != rc)
    	{
    		ERROR_OUT(("AppRosterManager::EnrollRequest: can't add record"));
    	}
    }
    else
    {
    	rc = pAppRoster->ReplaceRecord(pReq, nid, eid);
    	if (GCC_NO_ERROR != rc)
    	{
    		ERROR_OUT(("AppRosterManager::EnrollRequest: can't repalce record"));
    	}
    }

    // zero out the roster pointer because it should no be freed
    // in case of adding or replacing a record.
    // because the roster pointer has been added to the list,
    // it will be freed later.
	pAppRoster = NULL;

MyExit:

    if (GCC_NO_ERROR != rc)
    {
		if (pAppRoster != NULL)
        {
			pAppRoster->Release();
        }
    }

	DebugExitINT(CAppRosterMgr::EnrollRequest, rc);
	return rc;
}

/*
 *	GCCError	UnEnrollRequest	()
 *
 *	Public Function Description
 *		This routine is called whenever an APE wishes to unenroll from the
 *		conference (or a specific session).
 */
GCCError		CAppRosterMgr::UnEnrollRequest (
													PGCCSessionKey	session_key,
													EntityID		entity_id)
{
	GCCError				rc = GCC_NO_ERROR;
	CAppRoster				*application_roster = NULL;
	CAppRosterList			*roster_list;

	DebugEntry(CAppRosterMgr::UnEnrollRequest);

	//	Is this a valid session key for the application roster manager
	if (IsThisSessionKeyValid (session_key) == FALSE)
		rc = GCC_INVALID_PARAMETER;
	else if (m_AppSapEidList2.Remove(entity_id))
	{
		//	Now find the affected roster
		roster_list = m_fTopProvider ? &m_GlobalRosterList : &m_LocalRosterList;
 
		application_roster = GetApplicationRoster (	session_key, roster_list);
		//	Now unenroll from the specified roster 
		if (application_roster != NULL)
		{
			rc = application_roster->RemoveRecord(
												m_pMcsUserObject->GetMyNodeID(),
								 				entity_id);
		}
		else
			rc = GCC_BAD_SESSION_KEY;
	}
	else
		rc = GCC_APP_NOT_ENROLLED;

	DebugExitINT(CAppRosterMgr::UnEnrollRequest, rc);

    return rc;
}

/*
 *	GCCError	ProcessRosterUpdateIndicationPDU ()
 *
 *	Public Function Description
 *		This routine processes an incomming roster update PDU.  It is
 *		responsible for passing the PDU on to the right application roster.
 */
GCCError	CAppRosterMgr::ProcessRosterUpdateIndicationPDU(
					PSetOfApplicationInformation	set_of_application_info,
					UserID							sender_id)
{
	GCCError				rc = GCC_NO_ERROR;
	CAppRosterList			*roster_list;
	CAppRoster				*application_roster;
	BOOL					maintain_pdu_buffer;
	BOOL					is_local_roster;

	DebugEntry(CAppRosterMgr::ProcessRosterUpdateIndicationPDU);

	/*
	**	First make sure that the session key contained in the current
	**	set of application information is valid for this application roster 
	**	manager.
	*/ 
	if (IsThisSessionKeyPDUValid(&set_of_application_info->value.session_key))
	{
		/*
		**	Now search for the appropriate application roster.  If it is not 
		**	found we must create it here.
		*/

        //
		// LONCHANC:
		// (1) If top provider, add default application roster to the global roster list.
		// (2) If non-top provider, we do not create both the local and global version of the 
		// application roster for this particular session key.
		// instead, We create only the appropriate one here 
		// and wait until we receive either a refresh from the 
		// top provider or an update from a node below this one 
		// in the connection hierarchy (or an application 
		// enroll) before creating the other.
		// (3) If this PDU was sent from below this node it 
		// must be an update of the local roster so save 
		// the roster in the local roster list.
        //
		roster_list = (m_fTopProvider || (sender_id == m_pMcsUserObject->GetTopNodeID())) ?
						&m_GlobalRosterList : &m_LocalRosterList;
 
		application_roster = GetApplicationRosterFromPDU (
									&set_of_application_info->value.session_key,
									roster_list);
		if (application_roster != NULL)
		{
			rc = application_roster->
								ProcessRosterUpdateIndicationPDU(
												set_of_application_info,
												sender_id);
		}
		else
		{
			//	First determine the characteristics of this roster
			if (m_fTopProvider)
			{
				maintain_pdu_buffer = TRUE;
				is_local_roster = FALSE;
			}
			else if (sender_id == m_pMcsUserObject->GetTopNodeID())
			{
				maintain_pdu_buffer = FALSE;
				is_local_roster = FALSE;
			}
			else
			{
				maintain_pdu_buffer = TRUE;
				is_local_roster = TRUE;
			}

			//	Create the application roster from the passed in PDU.	
			DBG_SAVE_FILE_LINE
			application_roster = new CAppRoster(NULL,	// pGccSessKey
												&set_of_application_info->value.session_key,	// pSessKey
												this,	// pOwnerObject
												m_fTopProvider,// fTopProvider
												is_local_roster,// fLocalRoster
												maintain_pdu_buffer,// fMaintainPduBuffer
												&rc);
			if ((application_roster != NULL) && (rc == GCC_NO_ERROR))
			{
				//	Process the PDU with the created application roster.
				rc = application_roster->
								ProcessRosterUpdateIndicationPDU(
							        					set_of_application_info,
							                            sender_id);
				if (rc == GCC_NO_ERROR)
				{
					roster_list->Append(application_roster);
				}
			}
			else 
			{
				if (application_roster != NULL)
                {
					application_roster->Release();
                }
				else
                {
					rc = GCC_ALLOCATION_FAILURE;
                }
			}
		}
	}
	else
	{
		ERROR_OUT(("AppRosterManager::ProcessRosterUpdateIndicationPDU:"
					"ASSERTION: Application Information is not valid"));
		rc = GCC_INVALID_PARAMETER;
	}

	DebugExitINT(CAppRosterMgr::ProcessRosterUpdateIndicationPDU, rc);

	return rc;
}

/*
 *	PSetOfApplicationInformation	FlushRosterUpdateIndication ()
 *
 *	Public Function Description
 *		This routine is used to access any PDU data that might currently be
 *		queued inside the application rosters managed by this application
 *		roster manager.  It also is responsible for flushing any queued 
 *		roster update messages if necessary.
 */
PSetOfApplicationInformation
CAppRosterMgr::FlushRosterUpdateIndication(
						PSetOfApplicationInformation *	set_of_information,
						PGCCError						rc)
{
	PSetOfApplicationInformation	pOld = NULL, pCurr;
	CAppRosterList					*roster_list;
	CAppRoster						*lpAppRoster;

	DebugEntry(CAppRosterMgr::FlushRosterUpdateIndication);

	/*
	**	First we deal with flushing the PDU data. We iterate through the
	**	appropriate list (Global if the Top Provider and Local if not the
	**	Top Provider) and get any PDU data associated with each of these.
	**	Note that some of these may not contain any PDU data.
	*/
	*rc = GCC_NO_ERROR;
	*set_of_information = NULL;

	roster_list = m_fTopProvider ? &m_GlobalRosterList : &m_LocalRosterList;

	roster_list->Reset();
	while (NULL != (lpAppRoster = roster_list->Iterate()))
	{
		lpAppRoster->FlushRosterUpdateIndicationPDU(&pCurr);
		if (pCurr != NULL)
		{
			if (*set_of_information == NULL)
				*set_of_information = pCurr;
			else
				pOld->next = pCurr;

			(pOld = pCurr)->next = NULL;
		}
	}

	/*
	**	Next we deal with delivering the application roster update messages.
	**	We first check to see if any of the global rosters have changed.  If
	**	none have changed, we will not deliver a roster update indication.
	*/
	m_GlobalRosterList.Reset();
	while (NULL != (lpAppRoster = m_GlobalRosterList.Iterate()))
	{
		if (lpAppRoster->HasRosterChanged())
		{
			TRACE_OUT(("AppRosterManager::FlushRosterUpdateIndication:Roster HAS Changed"));
			*rc = SendRosterReportMessage ();
			break;
		}
	}

	/*
	**	Cleanup and reset any application rosters after the above flush is 
	**	completed.  This takes care of removing any rosters that have become
	**	empty.  It also resets the rosters which takes care of resetting all
	**	the internal instance variables to their appropriate initial state.
	*/
	CleanupApplicationRosterLists ();

	DebugExitPTR(CAppRosterMgr::FlushRosterUpdateIndication, pOld);

//
// LONCHANC: Yes, we need to return the last item in the list such that
// we can continue to grow the list.
// In fact, the next call to FlushRosterUpdateIndication() will have
// &pOld as the input argument.
// It is quite tricky.
//
// Please note that pOld is initialized to NULL.
//

	return (pOld); 
}

/*
 *	PSetOfApplicationInformation	GetFullRosterRefreshPDU ()
 *
 *	Public Function Description
 *		This routine is used to obtain a complete roster refresh of all the
 *		rosters maintained by this roster manger.
 */
PSetOfApplicationInformation
				CAppRosterMgr::GetFullRosterRefreshPDU (
						PSetOfApplicationInformation	*	set_of_information,
						PGCCError							rc)
{
	PSetOfApplicationInformation	new_set_of_information = NULL;

	DebugEntry(CAppRosterMgr::GetFullRosterRefreshPDU);

	if (m_fTopProvider)
	{
		CAppRoster			*lpAppRoster;

		*rc = GCC_NO_ERROR;
		*set_of_information = NULL;

		/*
		**	First we must tell all the application rosters to build the
		**	a full refresh PDU internally.
		*/
		m_GlobalRosterList.Reset();
		while (NULL != (lpAppRoster = m_GlobalRosterList.Iterate()))
		{
			*rc = lpAppRoster->BuildFullRefreshPDU();
			if (GCC_NO_ERROR != *rc)
			{
				return NULL;
			}
		}

		/*
		**	Now we flush all the refreshes.  Note that this also takes care
		**	of delivering any queued application roster update messages.
		*/	
		new_set_of_information = FlushRosterUpdateIndication (set_of_information, rc);
	}
	else
		*rc = GCC_INVALID_PARAMETER;

	DebugExitPTR(CAppRosterMgr::GetFullRosterRefreshPDU, new_set_of_information);

	return (new_set_of_information); 
}

/*
 *	Boolean	IsThisYourSessionKey ()
 *
 *	Public Function Description
 *		This routine is used to determine if the specified "API" session key is
 *		associated with this application roster manager.
 */


/*
 *	Boolean	IsThisYourSessionKeyPDU ()
 *
 *	Public Function Description
 *		This routine is used to determine if the specified "PDU" session key is
 *		associated with this application roster manager.
 */


/*
 *	GCCError	RemoveEntityReference ()
 *
 *	Public Function Description
 *		This routine is used to remove the specified APE entity from the 
 *		session it is enrolled with.  Note that this routine is only used
 *		to remove local entity references.
 */								
GCCError	CAppRosterMgr::RemoveEntityReference(EntityID entity_id)
{
	GCCError				rc = GCC_NO_ERROR;
	CAppRosterList			*roster_list;

	DebugEntry(CAppRosterMgr::RemoveEntityReference);

	/*
	**	First remove this entity from the command target list if it is valid.
	**	We then iterate through all the rosters until we determine which
	**	roster holds the record associated with this entity.
	*/
	if (m_AppSapEidList2.Remove(entity_id))
	{
		CAppRoster			*lpAppRoster;

		/*
		**	Now get the affected roster.  Note that if this is not the
		**	top provider we wait for the full refresh to update the
		**	global roster.
		*/
		roster_list = m_fTopProvider ? &m_GlobalRosterList : &m_LocalRosterList;

		/*
		**	Try to delete this record from every roster in the list.
		**	Break when the correct roster is found.
		*/
		roster_list->Reset();
		while (NULL != (lpAppRoster = roster_list->Iterate()))
		{
			rc = lpAppRoster->RemoveRecord(m_pMcsUserObject->GetMyNodeID(), entity_id);
			if (rc == GCC_NO_ERROR)
				break;
		}
	}
	else
		rc = GCC_APP_NOT_ENROLLED;

	DebugExitINT(CAppRosterMgr::RemoveEntityReference, rc);

	return rc;
}

/*
 *	GCCError	RemoveUserReference	()
 *
 *	Public Function Description
 *		This routine is used to remove all references associated with the
 *		node defined by the detached user.
 */								
GCCError	CAppRosterMgr::RemoveUserReference(
									UserID				detached_user)
{
	GCCError				rc = GCC_NO_ERROR;
	GCCError				error_value;
	CAppRosterList			*roster_list;
	CAppRoster				*lpAppRoster;

	DebugEntry(CAppRosterMgr::RemoveUserReference);

	/*
	**	Now get the affected roster.  Note that if this is not the
	**	top provider we wait for the full refresh to update the
	**	global roster.
	*/
	roster_list = m_fTopProvider ? &m_GlobalRosterList : &m_LocalRosterList;

	//	Try to delete this user from every roster in the list
	roster_list->Reset();
	while (NULL != (lpAppRoster = roster_list->Iterate()))
	{
		error_value = lpAppRoster->RemoveUserReference (detached_user);
		if ((error_value != GCC_NO_ERROR) && 
			(error_value != GCC_INVALID_PARAMETER))
		{
			rc = error_value;
			WARNING_OUT(("AppRosterManager::RemoveUserReference:"
						"FATAL error occured while removing user reference."));
			break;
		}
	}

	DebugExitINT(CAppRosterMgr::RemoveUserReference, rc);

	return rc;
}

/*
 *	Boolean	IsEntityEnrolled ()
 *
 *	Public Function Description
 *		This routine informs the caller if the specified entity is enrolled
 *		with any sessions managed by this application roster manager.
 */
BOOL	CAppRosterMgr::IsEntityEnrolled(EntityID application_entity)
{
	BOOL						rc = TRUE;
	CAppRosterList				*application_roster_list;
	CAppRoster					*lpAppRoster;

	DebugEntry(CAppRosterMgr::IsEntityEnrolled);

	application_roster_list = m_fTopProvider ? &m_GlobalRosterList : &m_LocalRosterList;

	application_roster_list->Reset();
	while (NULL != (lpAppRoster = application_roster_list->Iterate()))
	{
		if (lpAppRoster->DoesRecordExist(m_pMcsUserObject->GetMyNodeID(), application_entity))
		{
			rc = TRUE;
			break;
		}
	}

	DebugExitBOOL(AppRosterManager:IsEntityEnrolled, rc);

	return rc;
}

/*
 *	GCCError	ApplicationRosterInquire	()
 *
 *	Public Function Description
 *		This routine fills in an application roster message with either
 *		a single roster (if a session other than the default is specified)
 *		or the complete list of "Global" rosters contained by this roster
 *		manager (if the specified session key is NULL or the session ID is
 *		zero.
 */
GCCError	CAppRosterMgr::ApplicationRosterInquire (
						PGCCSessionKey			session_key,
						CAppRosterMsg			*roster_message)
{
	GCCError				rc = GCC_NO_ERROR;
	CAppRoster				*application_roster = NULL;
	CSessKeyContainer       *pSessKeyData;

	DebugEntry(CAppRosterMgr::ApplicationRosterInquire);

	if (session_key != NULL)
	{
		if (session_key->session_id != 0)
		{
			/*
			**	Here we try to find the specific application roster that was
			**	requested.
			*/
			DBG_SAVE_FILE_LINE
			pSessKeyData = new CSessKeyContainer(session_key, &rc);
			if ((pSessKeyData != NULL) && (rc == GCC_NO_ERROR))
			{
				CAppRoster *lpAppRoster;
				m_GlobalRosterList.Reset();
				while (NULL != (lpAppRoster = m_GlobalRosterList.Iterate()))
				{
					CSessKeyContainer *pTempSessKeyData = lpAppRoster->GetSessionKey();
					if (*pTempSessKeyData == *pSessKeyData)
					{
						application_roster = lpAppRoster;
						break;
					}
				}
			}

			if (pSessKeyData != NULL)
			{
				pSessKeyData->Release();
				if (application_roster == NULL)
				{
					rc = GCC_NO_SUCH_APPLICATION;
				}
			}
			else
			{
				rc = GCC_ALLOCATION_FAILURE;
			}
		}
	}

	if (rc == GCC_NO_ERROR)
	{
		if (application_roster != NULL)
		{
			roster_message->AddRosterToMessage(application_roster);
		}
		else
		{
			CAppRoster *lpAppRoster;
			m_GlobalRosterList.Reset();
			while (NULL != (lpAppRoster = m_GlobalRosterList.Iterate()))
			{
				roster_message->AddRosterToMessage(lpAppRoster);
			}
		}
	}

	DebugExitINT(AppRosterManager:ApplicationRosterInquire, rc);
	return rc;
}

/*
 *	BOOL		IsAPEEnrolled	()
 *
 *	Public Function Description
 *		This function determines if the specified APE is enrolled with
 *		any session in the list.  It does not worry about a specific
 *		session.
 */
BOOL		CAppRosterMgr::IsAPEEnrolled(
						UserID							node_id,
						EntityID						entity_id)
{
	BOOL				rc = FALSE;
	CAppRoster			*lpAppRoster;

	DebugEntry(CAppRosterMgr::IsAPEEnrolled);

	/*
	**	First get a single session key.  Note that it makes no difference
	**	where the key comes from because we are only goin to be comparing
	**	the base object key.
	*/
	m_GlobalRosterList.Reset();
	while (NULL != (lpAppRoster = m_GlobalRosterList.Iterate()))
	{
		if (lpAppRoster->DoesRecordExist (node_id, entity_id))
		{
			rc = TRUE;
			break;
		}
	}

	DebugExitBOOL(AppRosterManager:IsAPEEnrolled, rc);

	return rc;
}

/*
 *	BOOL		IsAPEEnrolled	()
 *
 *	Public Function Description
 *		This function determines if the specified APE is enrolled with
 *		a specific session in the list.
 */
BOOL		CAppRosterMgr::IsAPEEnrolled(
						CSessKeyContainer   		    *session_key_data,
						UserID							node_id,
						EntityID						entity_id)
{
	BOOL				rc = FALSE;
	CAppRoster			*lpAppRoster;

	DebugEntry(CAppRosterMgr::IsAPEEnrolled);

	/*
	**	First get a single session key.  Note that it makes no difference
	**	where the key comes from because we are only goin to be comparing
	**	the base object key.
	*/
	m_GlobalRosterList.Reset();
	while (NULL != (lpAppRoster = m_GlobalRosterList.Iterate()))
	{
		//	We are looking for a session key match
		if (*(lpAppRoster->GetSessionKey()) == *session_key_data)
		{
			//	If a match was found check to see if record exist
			rc = lpAppRoster->DoesRecordExist (node_id, entity_id);
		}
	}

	DebugExitBOOL(AppRosterManager:IsAPEEnrolled, rc);

	return rc;
}

/*
 *	GCCError	IsEmpty	()
 *
 *	Public Function Description
 *		This routine determines if this application roster managfer contains
 *		any application rosters.
 */
BOOL CAppRosterMgr::IsEmpty(void)
{
	return (m_GlobalRosterList.IsEmpty() && m_LocalRosterList.IsEmpty()) ?
					TRUE : FALSE;
}

/*
 *	GCCError	SendRosterReportMessage	()
 *
 *	Private Function Description
 *		This routine is responsible for sending the application roster
 *		update indications to the application SAPs.
 *
 *	Formal Parameters:
 *		None.
 *
 *	Return Value
 *		GCC_NO_ERROR 			-	No error occured.
 *		GCC_ALLOCATION_FAILURE	-	A resource error occured.
 *
 *  Side Effects
 *		None.
 *
 *	Caveats:
 *		We send indications for all rosters. Even roster that don't currently
 *		contain records.  
 */
GCCError CAppRosterMgr::
SendRosterReportMessage(void)
{
	GCCError					rc = GCC_NO_ERROR;
	CAppRosterMsg				*roster_message;

	DebugEntry(CAppRosterMgr::SendRosterReportMessage);

	if (! m_GlobalRosterList.IsEmpty())
	{
		//	First allocate the roster message
		DBG_SAVE_FILE_LINE
		roster_message = new CAppRosterMsg();
		if (roster_message != NULL)
		{
			CAppRoster			*lpAppRoster;

			m_GlobalRosterList.Reset();
			while (NULL != (lpAppRoster = m_GlobalRosterList.Iterate()))
			{
				roster_message->AddRosterToMessage(lpAppRoster);
			}

			/*
			**	Here we iterate through the complete list of application 
			**	saps to send the roster report indication.  Note that
			**	we used the sent list to avoid sending the same roster
			**	update to a single SAP more than once.  Note that since
			**	this sent list is defined as a local instance variable,
			**	it automatically is cleaned up after each roster update.
			**
			**	Note also that we iterate on a temporary list here in case
			**	an application unenrolls (usually due to a resource error)
			**	during this callback.  We must protect the rogue wave 
			**	iterator.
			*/
			CAppSap *pAppSap;
			CAppSapList SentList;
			CAppSapEidList2 ToSendList(m_AppSapEidList2);
			ToSendList.Reset();
			while (NULL != (pAppSap = ToSendList.Iterate()))
			{
				if (! SentList.Find(pAppSap))
				{
					/*
					**	Hold on to this sap so that we don't send to it 
					**	again for this update.
					*/
					SentList.Append(pAppSap);

					//	Here we actually deliver the roster update.
					pAppSap->AppRosterReportIndication(m_nConfID, roster_message);
				}
			}

			/*
			**	Here we send the roster report indication to the
			**	controler sap.
			*/
			g_pControlSap->AppRosterReportIndication(m_nConfID, roster_message);

			/*
			**	Here we free up the roster message.  Note that if this
			**	message got locked in the roster report indication calls
			**	this free will not delete the roster memory.
			*/
			roster_message->Release();
		}
		else
			rc = GCC_ALLOCATION_FAILURE;
	}

	DebugExitINT(AppRosterManager::SendRosterReportMessage, rc);

	return rc;
}

/*
 *	CAppRoster *GetApplicationRoster ()
 *
 *	Private Function Description
 *		This routine is responsible for returning the application pointer
 *		associated with the specified session key.
 *
 *	Formal Parameters:
 *		session_key	-	Session key associated with roster to return.
 *		roster_list	-	Roster list to search.
 *
 *	Return Value
 *		Either NULL	if roster does not exists in list or a pointer to
 *		the appropriate application roster.
 *		
 *  Side Effects
 *		None.
 *
 *	Caveats:
 *		None.
 */
CAppRoster * CAppRosterMgr::GetApplicationRoster (	
						PGCCSessionKey			session_key,
						CAppRosterList			*roster_list)
{
	GCCError				rc;
	CAppRoster				*application_roster = NULL;
	CAppRoster				*lpAppRoster;
	CSessKeyContainer	    *pTempSessKeyData;

	DebugEntry(CAppRosterMgr::GetApplicationRoster);

	//	First create a temporary session key for comparison purposes
	DBG_SAVE_FILE_LINE
	pTempSessKeyData = new CSessKeyContainer(session_key, &rc);
	if (pTempSessKeyData != NULL && GCC_NO_ERROR == rc)
	{
		//	Now find the affected roster

		//
		// LONCHANC: The following line is totally wrong!!!
		// we passed in roster_list, but now we overwrite it right here???
		// Commented out the following line.
		//      roster_list = m_fTopProvider ? &m_GlobalRosterList : &m_LocalRosterList;
		//

		roster_list->Reset();
		while (NULL != (lpAppRoster = roster_list->Iterate()))
		{
			if(*lpAppRoster->GetSessionKey() == *pTempSessKeyData)
			{
				application_roster = lpAppRoster;
				break;
			}
		}

		pTempSessKeyData->Release();
	}

	DebugExitPTR(AppRosterManager::GetApplicationRoster, application_roster);
	return (application_roster);
}

/*
 *	CAppRoster * GetApplicationRosterFromPDU ()
 *
 *	Private Function Description
 *		This routine is responsible for returning the application pointer
 *		associated with the specified session key PDU.
 *
 *	Formal Parameters:
 *		session_key	-	Session key PDU associated with roster to return.
 *		roster_list	-	Roster list to search.
 *
 *	Return Value
 *		Either NULL	if roster does not exists in list or a pointer to
 *		the appropriate application roster.
 *		
 *  Side Effects
 *		None.
 *
 *	Caveats:
 *		None.
 */
CAppRoster * CAppRosterMgr::GetApplicationRosterFromPDU (	
						PSessionKey				session_key,
						CAppRosterList			*roster_list)
{
	CSessKeyContainer		    *session_key_data;
	CAppRoster					*pAppRoster;

	DebugEntry(CAppRosterMgr::GetApplicationRosterFromPDU);

	roster_list->Reset();
	while (NULL != (pAppRoster = roster_list->Iterate()))
	{
		session_key_data = pAppRoster->GetSessionKey();
		if (session_key_data->IsThisYourSessionKeyPDU (session_key))
		{
			break;
		}
	}

	DebugExitPTR(CAppRosterMgr::GetApplicationRosterFromPDU, pAppRoster);

	return pAppRoster;
}

/*
 *	BOOL IsThisSessionKeyValid ()
 *
 *	Private Function Description
 *		This routine is responsible for determining if the specified
 *		session key's application protocol key matches this application
 *		roster manager's. This routine works on API data.
 *
 *	Formal Parameters:
 *		session_key	-	Session key to check.
 *
 *	Return Value
 *		TRUE	-	If we have a match.
 *		FALSE	-	If we do NOT have a match.
 *		
 *  Side Effects
 *		None.
 *
 *	Caveats:
 *		None.
 */


/*
 *	BOOL IsThisSessionKeyPDUValid ()
 *
 *	Private Function Description
 *		This routine is responsible for determining if the specified
 *		session key's application protocol key matches this application
 *		roster manager's.  This routine works on PDU data.
 *
 *	Formal Parameters:
 *		session_key	-	Session key to check.
 *
 *	Return Value
 *		TRUE	-	If we have a match.
 *		FALSE	-	If we do NOT have a match.
 *		
 *  Side Effects
 *		None.
 *
 *	Caveats:
 *		None.
 */


/*
 *	void		CleanupApplicationRosterLists ()
 *
 *	Private Function Description
 *		This routine is responsible for cleaning up any empty application
 *		rosters.  It also resets all the application rosters back to their
 *		neutral state so that any new updates will be handled  correctly.
 *
 *	Formal Parameters:
 *		None.
 *
 *	Return Value
 *		None.
 *		
 *  Side Effects
 *		An owner callback will occur when the roster becomes empty.
 *
 *	Caveats:
 *		This routine does not actually delete the empty rosters until it
 *		is placed in the delete list.  Instead it places the rosters into the
 *		list of deleted rosters which causes them to be deleted the next time
 *		this routine is called (or when the object is destructed).
 */
void	CAppRosterMgr::CleanupApplicationRosterLists(void)
{
	CAppRoster			*lpAppRoster;

	DebugEntry(CAppRosterMgr::CleanupApplicationRosterLists);

	/*
	**	First we iterate through the list of deleted rosters and delete
	**	each entry in it.
	*/
	m_RosterDeleteList.DeleteList();

	/*
	**	Next we iterate through all the rosters and remove any that
	**	contain no application records. Here instead of deleting the
	**	roster we move the roster into the delete list.  We cannot do
	**	the delete here because it is possible that PDU data owned by the
	**	roster being deleted may be used after the Flush is called (or 
	**	after this routine is called).  Therefore, we save it in the delete
	**	list and delete it next time we enter this routine.
	*/

	//	Start with the Global Application Roster List
	m_GlobalRosterList.Reset();
	while (NULL != (lpAppRoster = m_GlobalRosterList.Iterate()))
	{
		if (lpAppRoster->GetNumberOfApplicationRecords() == 0)
		{
            //
            // Here we clean up any "dangling" entries in the application
            // registry by removing all the entries that contain the
            // session key associated with the roster that is being deleted.
            // Note that this is only done when a Global roster list is
            //removed.
            //
            CRegistry *pAppReg = m_pConf->GetRegistry();
            pAppReg->RemoveSessionKeyReference(lpAppRoster->GetSessionKey());

			m_GlobalRosterList.Remove(lpAppRoster);
			m_RosterDeleteList.Append(lpAppRoster);

			TRACE_OUT(("AppRosterMgr: Cleanup: Deleting Global Roster"));

			/*
			**	Since you can not delete a list entry while iterating on it
			**	we must reset the iterator every time an entry is removed.
			*/
			m_GlobalRosterList.Reset();
		}
		else
		{
			/*
			**	Here we reset the application roster to its neutral state.
			**	This affects the nodes added and nodes removed flags.
			*/
			lpAppRoster->ResetApplicationRoster();
		}
	}

	//	Next deal with the Local Application Roster List
	if (! m_fTopProvider)
	{
		m_LocalRosterList.Reset();
		while (NULL != (lpAppRoster = m_LocalRosterList.Iterate()))
		{
			if (lpAppRoster->GetNumberOfApplicationRecords() == 0)
			{
				m_LocalRosterList.Remove(lpAppRoster);
				m_RosterDeleteList.Append(lpAppRoster);

				TRACE_OUT(("AppRosterMgr: Cleanup: Deleting Local Roster"));

				/*
				**	Since you can not delete a list entry while iterating on it
				**	we must reset the iterator every time an entry is removed.
				*/
				m_LocalRosterList.Reset();
			}
			else
			{
				/*
				**	Here we reset the application roster to its neutral state.
				**	This affects the nodes added and nodes removed flags.
				*/
				lpAppRoster->ResetApplicationRoster();
			}
		}
	}
	
	DebugExitVOID(CAppRosterMgr::CleanupApplicationRosterLists);
}

/*
 *	void DeleteRosterRecord ()
 *
 *	Public Function Description
 *		This function overides the base class function and is used to
 *		receive all owner callback information from the application
 *		rosters owned by this object.
 */
void CAppRosterMgr::
DeleteRosterRecord
(
    GCCNodeID       nidRecordToDelete,
    GCCEntityID     eidRecordToDelete
)
{
    //
    // Here we remove ownership from any registry entries associated
    // with the record that was deleted.  Note that since the entity
    // id must be unique for all the APEs at a node (as stated by
    // T.124) there is no need to include the session key to determine
    // which registry entries to clean up.
    //
    CRegistry *pAppReg = m_pConf->GetRegistry();
    pAppReg->RemoveEntityOwnership(nidRecordToDelete, eidRecordToDelete);
}


void CAppRosterMgrList::DeleteList(void)
{
    CAppRosterMgr *pAppRosterMgr;
    while (NULL != (pAppRosterMgr = Get()))
    {
        pAppRosterMgr->Release();
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\remdsk\rds\t120\mst120\arost.cpp ===
#include "precomp.h"
DEBUG_FILEZONE(ZONE_T120_APP_ROSTER);
/*
 *	arost.cpp
 *
 *	Copyright (c) 1995 by DataBeam Corporation, Lexington, KY
 *
 *	Abstract:
 *		This is the implementation file for the Application Roster Class. This
 *		class maintains the application roster, builds roster update and
 *		refresh PDUs and manages the capabilities list which is part of the
 *		application roster.
 *
 *		This class makes use of a number of Rogue Wave lists to maintain the
 *		roster entries and the capabilities list.  The lists are organized in
 *		such a way that the heirarchy of the conference can be maintained.  This
 *		is important to perform the necessary operations required by the T.124
 *		specification.  In general, there is a main "Roster_Record_List" that
 *		maintains a list of "AppRosterRecords". The list is indexed by the
 *		GCC user ID where each record in the list holds a list of application
 *		records (or entities) at that node, a list of capabilities for each
 *		"entity" and a list of sub-nodes (the GCC user IDs of all the nodes
 *		below this one in the connection hierarchy).  The Roster_Record_List
 *		only holds entries for immediately connected nodes.
 *
 *		SEE INTERFACE FILE FOR A MORE DETAILED ABSTRACT
 *
 *	Private Instance Variables:
 *		m_pAppRosterMgr
 *			Pointer to the object that will receive all owner callbacks.
 *		m_cbDataMemory
 *			This is the number of bytes required to hold the data associated
 *			with a roster update message.  This is calculated on a lock.
 *		m_fTopProvider
 *			Flag indicating if the node where this roster lives is the top
 *			provider.
 *		m_fLocalRoster
 *			Flag indicating if the roster data is associated with a local
 *			roster (maintaining intermediate node data) or global roster (
 *			(maintaining roster data for the whole conference).
 *		m_pSessionKey
 *			Pointer to a session key object that holds the session key
 *			associated with this roster.
 *		m_nInstance
 *			The current instance of the roster.  This number will change
 *			whenever the roster is updated.
 *		m_fRosterHasChanged
 *			Flag indicating if the roster has changed since the last reset.
 *		m_fPeerEntitiesAdded
 *			Flag indicating if any APE records have been added to the
 *			application roster since the last reset.
 *		m_fPeerEntitiesRemoved
 *			Flag indicating if any APE records have been deleted from the
 *			application roster since the last reset.
 *		m_fCapabilitiesHaveChanged
 *			Flag indicating if the capabilities has changed since the last
 *			reset.
 *		m_NodeRecordList2
 *			List which contains all the application roster's node records.
 *		m_CollapsedCapListForAllNodes
 *			List which contains all the application roster's collapsed
 *			capabilities.
 *		m_fMaintainPduBuffer
 *			Flag indicating if it is necessary for this roster object to
 *			maintain internal PDU data.  Won't be necessary for global rosters
 *			at subordinate nodes.
 *		m_fPduIsFlushed
 *			Flag indicating if the PDU that currently exists has been flushed.
 *		m_SetOfAppInfo
 *			Pointer to internal PDU data.
 *		m_pSetOfAppRecordUpdates
 *			This instance variable keeps up with the current record update so
 *			that it will not be necessary to search the entire list updates
 *			each a new update is added to the internal PDU.
 *
 *	Caveats:
 *		None.
 *
 *	Author:
 *		blp
 */

#include "arost.h"
#include "arostmgr.h"
#include "clists.h"


/*
**	The maximum length the application data for a non-collapsed capablity
**	can be.
*/
#define	MAXIMUM_APPLICATION_DATA_LENGTH				255

/*
 *	AppRosterRecord	()
 *
 *	Public Function Description
 *		Constructor definition to instantiate the hash list dictionaries that
 *		are used in an AppRosterRecord.  This constructor is needed to allow
 *		the AppRosterRecord structure to be directly instantiated with hash
 *		list.
 */
APP_NODE_RECORD::APP_NODE_RECORD(void) :
	AppRecordList(DESIRED_MAX_APP_RECORDS),
	ListOfAppCapItemList2(DESIRED_MAX_CAP_LISTS),
	SubNodeList2(DESIRED_MAX_NODES)
{}


/*
 *	CAppRoster	()
 *
 *	Public Function Description
 *	When pGccSessKey is not NULL
 *		This constructor is used to create an empty application roster. Note
 *		that the session key for the roster must be passed in to the
 *		constructor.
 *
 *	When pSessKey is not NULL
 *		This constructor builds a roster based on an indication pdu.
 *		Application Roster objects may exist at nodes which do not have
 *		applications to perform the necessary operations required by T.124
 */
CAppRoster::CAppRoster (	
			PGCCSessionKey				pGccSessKey,// create an empty app roster
			PSessionKey					pPduSessKey,// build an app roster based on an indication pdu
			CAppRosterMgr				*pAppRosterMgr,
			BOOL						fTopProvider,
			BOOL						fLocalRoster,
			BOOL						fMaintainPduBuffer,
			PGCCError					pRetCode)
:
    CRefCount(MAKE_STAMP_ID('A','R','s','t')),
	m_nInstance(0),
	m_pAppRosterMgr(pAppRosterMgr),
	m_cbDataMemory(0),
	m_fTopProvider(fTopProvider),
	m_fLocalRoster(fLocalRoster),
	m_pSessionKey(NULL),
	m_fRosterHasChanged(FALSE),
	m_fPeerEntitiesAdded(FALSE),
	m_fPeerEntitiesRemoved(FALSE),
	m_fCapabilitiesHaveChanged(FALSE),
	m_NodeRecordList2(DESIRED_MAX_NODES),
	m_fMaintainPduBuffer(fMaintainPduBuffer),
	m_fPduIsFlushed(FALSE),
	m_pSetOfAppRecordUpdates(NULL)
{
	DebugEntry(CAppRoster::CAppRoster);

	GCCError rc = GCC_NO_ERROR;

	ZeroMemory(&m_SetOfAppInfo, sizeof(m_SetOfAppInfo));

	/*
	**	Here we store the session key of the roster.
	*/
	if (NULL != pGccSessKey)
	{
		ASSERT(NULL == pPduSessKey);
		DBG_SAVE_FILE_LINE
		m_pSessionKey = new CSessKeyContainer(pGccSessKey, &rc);
	}
	else
	if (NULL != pPduSessKey)
	{
		DBG_SAVE_FILE_LINE
		m_pSessionKey = new CSessKeyContainer(pPduSessKey, &rc);
	}
	else
	{
		ERROR_OUT(("CAppRoster::CAppRoster: invalid session key"));
		rc = GCC_BAD_SESSION_KEY;
		goto MyExit;
	}

	if (NULL == m_pSessionKey || GCC_NO_ERROR != rc)
	{
		ERROR_OUT(("CAppRoster::CAppRoster: can't create session key"));
		rc = GCC_ALLOCATION_FAILURE;
		// we do the cleanup in the destructor
		goto MyExit;
	}

	//	Initialize the PDU structure to be no change.
	m_SetOfAppInfo.value.application_record_list.choice = APPLICATION_NO_CHANGE_CHOSEN;
	m_SetOfAppInfo.value.application_capabilities_list.choice = CAPABILITY_NO_CHANGE_CHOSEN;

	/*
	**	Here we go ahead and set up the session key portion of the
	**	PDU so we don't have to worry about it later.
	*/
	if (m_fMaintainPduBuffer)
	{
		rc = m_pSessionKey->GetSessionKeyDataPDU(&m_SetOfAppInfo.value.session_key);
	}

	ASSERT(GCC_NO_ERROR == rc);

MyExit:

	DebugExitINT(CAppRoster:;CAppRoster, rc);

	*pRetCode = rc;
}


/*
 *	~CAppRoster	()
 *
 *	Public Function Description:
 *		The destructor for the CAppRoster class is used to clean up
 *		any memory allocated during the life of the object.
 */
CAppRoster::~CAppRoster(void)
{
	/*
	 * Free up all memory associated with the roster record list.
	 */
	ClearNodeRecordList();

	//	Clear the Collapsed Capabilities List.
	m_CollapsedCapListForAllNodes.DeleteList();

	/*
	 * Free up any outstanding PDU data.
	 */
	if (m_fMaintainPduBuffer)
	{
		FreeRosterUpdateIndicationPDU();
	}

	/*
	 * Free any memory associated with the session key..
	 */
	if (NULL != m_pSessionKey)
	{
	    m_pSessionKey->Release();
	}
}


/*
 * Utilities that operate on roster update PDU strucutures.
 */

/*
 *	GCCError	FlushRosterUpdateIndicationPDU ()
 *
 *	Public Function Description
 *		This routine is used to access any PDU data that might currently be
 *		queued inside the application roster.  PDU data is queued whenever
 *		a request is made to the application roster that affects its
 *		internal information base.
 */
void CAppRoster::FlushRosterUpdateIndicationPDU(PSetOfApplicationInformation *pSetOfAppInfo)
{
	DebugEntry(CAppRoster::FlushRosterUpdateIndicationPDU);

	/*
	**	If this roster has already been flushed we will NOT allow the same
	**	PDU to be flushed again.  Instead we delete the previously flushed
	**	PDU and set the flag back to unflushed.  If another flush comes in
	**	before a PDU is built NULL will be returned in the application
	**	information pointer.
	*/	
	if (m_fPduIsFlushed)
	{
		FreeRosterUpdateIndicationPDU();
		m_fPduIsFlushed = FALSE;
	}

	if ((m_SetOfAppInfo.value.application_record_list.choice != APPLICATION_NO_CHANGE_CHOSEN) ||
		(m_SetOfAppInfo.value.application_capabilities_list.choice != CAPABILITY_NO_CHANGE_CHOSEN))
	{
		if (m_SetOfAppInfo.value.application_record_list.choice == APPLICATION_NO_CHANGE_CHOSEN)
		{
			TRACE_OUT(("CAppRoster::FlushRosterUpdateIndicationPDU:"
						"Sending APPLICATION_NO_CHANGE_CHOSEN PDU"));
		}

		/*
		**	This section of the code sets up all the variables that don't
		**	pertain to the record list or the caps list.  Note that the
		**	session key PDU data was set up in the constructor.  Also note that
		**	the record list data and capabilities list data should be set up
		**	before this routine is called if there is any PDU traffic to issue.	
		*/
		m_SetOfAppInfo.next = NULL;
		m_SetOfAppInfo.value.roster_instance_number = (USHORT) m_nInstance;
		m_SetOfAppInfo.value.peer_entities_are_added = (ASN1bool_t)m_fPeerEntitiesAdded;
		m_SetOfAppInfo.value.peer_entities_are_removed = (ASN1bool_t)m_fPeerEntitiesRemoved;

		/*
		**	Here we set up the pointer to the whole PDU structure associated
		**	with this application roster.
		*/
		*pSetOfAppInfo = &m_SetOfAppInfo;

		/*
		**	Setting this to true will cause the PDU data to be freed up the
		**	next time the roster object is entered insuring that new PDU
		**	data will be created.
		*/
		m_fPduIsFlushed = TRUE;
	}
	else
	{
		*pSetOfAppInfo = NULL;
	}
}


/*
 *	GCCError	BuildFullRefreshPDU ()
 *
 *	Public Function Description
 *		This routine is responsible for generating a full application roster
 *		refresh PDU.
 */
GCCError CAppRoster::BuildFullRefreshPDU(void)
{
	GCCError	rc;

	DebugEntry(CAppRoster::BuildFullRefreshPDU);

	/*
	**	Free up the old PDU data here if it is being maintained and the
	**	PDU has been flushed.  Note that we also set the PDU is flushed boolean
	**	back to FALSE so that the new PDU will be maintained until it is
	**	flushed.
	*/
	if (m_fPduIsFlushed)
	{
		FreeRosterUpdateIndicationPDU ();
		m_fPduIsFlushed = FALSE;
	}

	rc = BuildApplicationRecordListPDU (APP_FULL_REFRESH, 0, 0);
	if (rc == GCC_NO_ERROR)
	{
		BuildSetOfCapabilityRefreshesPDU ();
	}

	return rc;
}


/*
 *	GCCError	BuildApplicationRecordListPDU ()
 *
 *	Private Function Description
 *		This routine creates an application roster update indication
 *		PDU based on the passed in parameters. Memory used after this
 *		routine is called is still owned by this object and will be
 *		freed the next time this objects internal information base is
 *		modified.
 *
 *	Formal Parameters:
 *		update_type		-	What type of update are we building.
 *		user_id			-	node id of record to update.
 *		entity_id		-	entity id of record to update.
 *
 *	Return Value
 *		GCC_NO_ERROR			-	No error occured.
 *		GCC_INVALID_PARAMETER	-	Parameter passed in is invalid.
 *		GCC_ALLOCATION_FAILURE	-	A resource error occured.
 *
 *  Side Effects
 *		None.
 *
 *	Caveats
 *		None.
 */
GCCError CAppRoster::BuildApplicationRecordListPDU (
						APP_ROSTER_UPDATE_TYPE			update_type,
						UserID							user_id,
						EntityID						entity_id)
{
	GCCError	rc = GCC_NO_ERROR;

	DebugEntry(CAppRoster::BuildApplicationRecordListPDU);

	if (m_fMaintainPduBuffer)
	{
		/*
		**	Note here that the top provider node always sends a full refresh
		**	PDU so there is no need to pay any attention to update type in
		**	this case.
		*/
		if ((update_type == APP_FULL_REFRESH) || m_fTopProvider)
		{
			/*
			**	First check to see if a refresh was already processed since the
			**	last PDU was flushed.  If so we must free up the last refresh in
			**	preperation for the new one built here.  Otherwise, if we have
			**	already started building an update this is not currently
			**	supported and is considered an error here.
			*/
			if (m_SetOfAppInfo.value.application_record_list.choice == APPLICATION_RECORD_REFRESH_CHOSEN)
			{
				FreeSetOfRefreshesPDU();
			}
			else
			if (m_SetOfAppInfo.value.application_record_list.choice == APPLICATION_RECORD_UPDATE_CHOSEN)
			{
				ERROR_OUT(("CAppRoster::BuildApplicationRecordListPDU:"
							"ASSERTION: building refresh when update exists"));
				return GCC_INVALID_PARAMETER;
			}

			//	This routine fills in the complete record list at this node.
			rc = BuildSetOfRefreshesPDU();
			if (rc == GCC_NO_ERROR)
			{
				m_SetOfAppInfo.value.application_record_list.choice = APPLICATION_RECORD_REFRESH_CHOSEN;
			}
		}
		else
		if (update_type != APP_NO_CHANGE)
		{
			/*
			**	Here if there has already been a refresh PDU built we flag this
			**	as an error since we do not support both types of application
			**	information at the same time.
			*/
			if (m_SetOfAppInfo.value.application_record_list.choice == APPLICATION_RECORD_REFRESH_CHOSEN)
			{
				ERROR_OUT(("CAppRoster::BuildApplicationRecordListPDU:"
							"ASSERTION: building update when refresh exists"));
				return GCC_INVALID_PARAMETER;
			}

			//	This routine fills in the specified update.
			rc = BuildSetOfUpdatesPDU(update_type, user_id, entity_id);
			if (rc == GCC_NO_ERROR)
			{
				/*
				**	If the first set of updates has not been used yet we
				**	initialize it here with the first update.
				*/
				if (m_SetOfAppInfo.value.application_record_list.choice == APPLICATION_NO_CHANGE_CHOSEN)
				{
					ASSERT(NULL != m_pSetOfAppRecordUpdates);
					m_SetOfAppInfo.value.application_record_list.u.application_record_update =
								m_pSetOfAppRecordUpdates;
					m_SetOfAppInfo.value.application_record_list.choice = APPLICATION_RECORD_UPDATE_CHOSEN;
				}
			}
		}
	}

	return rc;
}


/*
 *	GCCError	BuildSetOfRefreshesPDU	()
 *
 *	Private Function Description
 *		This member function fills in the PDU with the entire set of roster
 *		entries at this node.  This is typically called when the Top Provider is
 *		broadcasting a full refresh of the application roster.
 *
 *	Formal Parameters
 *		none
 *
 *	Return Value
 *		GCC_NO_ERROR - On Success
 *		GCC_ALLOCATION_FAILURE - On resource failure
 *
 *	Side Effects
 *		none
 *
 *	Caveats
 *		none
 */
GCCError CAppRoster::BuildSetOfRefreshesPDU(void)
{
	GCCError							rc = GCC_ALLOCATION_FAILURE;
	PSetOfApplicationRecordRefreshes	pNewAppRecordRefreshes;
	PSetOfApplicationRecordRefreshes	pOldAppRecordRefreshes = NULL;
	APP_NODE_RECORD						*lpAppNodeRecord;
	APP_RECORD  					    *lpAppRecData;
	CAppRecordList2						*lpAppRecDataList;
	UserID								uid, uid2;
	EntityID							eid;

	DebugEntry(CAppRoster::BuildSetOfRefreshesPDU);

	m_SetOfAppInfo.value.application_record_list.u.application_record_refresh = NULL;

	m_NodeRecordList2.Reset();
	while (NULL != (lpAppNodeRecord = m_NodeRecordList2.Iterate(&uid)))
	{
		/*
		**	First we iterate through this nodes application record list. This
		**	encodes all the records local to this node. After this, all the
		**	sub nodes within this roster record will be encoded.
		*/
		lpAppNodeRecord->AppRecordList.Reset();
		while (NULL != (lpAppRecData = lpAppNodeRecord->AppRecordList.Iterate(&eid)))
		{
			DBG_SAVE_FILE_LINE
			pNewAppRecordRefreshes = new SetOfApplicationRecordRefreshes;
			if (NULL == pNewAppRecordRefreshes)
			{
				goto MyExit;
			}

			if (m_SetOfAppInfo.value.application_record_list.u.application_record_refresh == NULL)
			{
				m_SetOfAppInfo.value.application_record_list.u.application_record_refresh = pNewAppRecordRefreshes;
			}
			else
			{
				pOldAppRecordRefreshes->next = pNewAppRecordRefreshes;
			}
	
			(pOldAppRecordRefreshes = pNewAppRecordRefreshes)->next = NULL;
			pNewAppRecordRefreshes->value.node_id = uid;
			pNewAppRecordRefreshes->value.entity_id = eid;

			//	Fill in the application record.
			rc = BuildApplicationRecordPDU(lpAppRecData,
	            			&pNewAppRecordRefreshes->value.application_record);
			if (GCC_NO_ERROR != rc)
			{
				goto MyExit;
			}
		}

		//	This section of the code copies the sub node records.
		lpAppNodeRecord->SubNodeList2.Reset();
		while (NULL != (lpAppRecDataList = lpAppNodeRecord->SubNodeList2.Iterate(&uid2)))
		{
			lpAppRecDataList->Reset();
			while (NULL != (lpAppRecData = lpAppRecDataList->Iterate(&eid)))
			{
				DBG_SAVE_FILE_LINE
				pNewAppRecordRefreshes = new SetOfApplicationRecordRefreshes;
				if (NULL == pNewAppRecordRefreshes)
				{
					goto MyExit;
				}

				/*
				**	We must again check for null because it is possible
				**	to have an application roster with sub node records
				**	but no application records.
				*/
				if (m_SetOfAppInfo.value.application_record_list.u.application_record_refresh == NULL)
				{
					m_SetOfAppInfo.value.application_record_list.u.application_record_refresh = pNewAppRecordRefreshes;
				}
				else
				{
					pOldAppRecordRefreshes->next = pNewAppRecordRefreshes;
				}
		
				(pOldAppRecordRefreshes = pNewAppRecordRefreshes)->next = NULL;
				pNewAppRecordRefreshes->value.node_id = uid2;
				pNewAppRecordRefreshes->value.entity_id = eid;

				//	Fill in the application record.
				rc = BuildApplicationRecordPDU (lpAppRecData,
	                	&pNewAppRecordRefreshes->value.application_record);
				if (GCC_NO_ERROR != rc)
				{
					goto MyExit;
				}
			}
		}
	}

	rc = GCC_NO_ERROR;

MyExit:

	return rc;
}


/*
 *	GCCError	BuildSetOfUpdatesPDU	()
 *
 *	Private Function Description
 *		This routine builds a single update based on the update type specified
 *		in the passed in parameter.
 *
 *	Formal Parameters
 *		update_type - 	(i)	Either APP_REPLACE_RECORD, APP_DELETE_RECORD, or
 *							APP_ADD_RECORD.
 *		node_id -		(i)	The node id of the update PDU record to build.
 *		entity_id 		(i) The entity id of the update PDU record to build.
 *
 *	Return Value
 *		GCC_NO_ERROR - On Success
 *		GCC_ALLOCATION_FAILURE - On resource failure
 *		GCC_NO_SUCH_APPLICATION - If the specified record doesn't exist
 *
 *	Side Effects
 *		none
 *
 *	Caveats
 *		none
 */
GCCError CAppRoster::BuildSetOfUpdatesPDU(
						APP_ROSTER_UPDATE_TYPE				update_type,
						UserID								node_id,
						EntityID							entity_id)
{
	GCCError					rc = GCC_NO_ERROR;
	CAppRecordList2				*pAppRecordList;
	APP_RECORD  			    *pAppRecord = NULL;
	APP_NODE_RECORD				*node_record;

	DebugEntry(CAppRoster::BuildSetOfUpdatesPDU);

	/*
	**	We must first determine the pointer to the application record
	**	specified by the passed in user id and entity_id. We only do
	**	this search if the update type is not APP_DELETE_RECORD.
	*/
	if (update_type != APP_DELETE_RECORD)
	{
		if (NULL != (node_record = m_NodeRecordList2.Find(node_id)))
		{
			//	Get a pointer to the application record from the entity id.
			pAppRecord = node_record->AppRecordList.Find(entity_id);
		}
		else
		{
			//	Here we iterate through the sub-node list looking for the record
			m_NodeRecordList2.Reset();
			while(NULL != (node_record = m_NodeRecordList2.Iterate()))
			{
				if (NULL != (pAppRecordList = node_record->SubNodeList2.Find(node_id)))
				{
					pAppRecord = pAppRecordList->Find(entity_id);
					break;
				}
			}
		}
	}

	/*
	**	Now if the application record was found or the update type is delete
	**	record we go ahead and encode the PDU here.
	*/
	if ((pAppRecord != NULL) || (update_type == APP_DELETE_RECORD))
	{
		/*
		**	Here the record update will be NULL if it is the first record
		**	update being encoded. Otherwise we must bump the record to the
		**	next set of updates.
		*/
		DBG_SAVE_FILE_LINE
		PSetOfApplicationRecordUpdates pUpdates = new SetOfApplicationRecordUpdates;
		if (NULL == pUpdates)
		{
			return GCC_ALLOCATION_FAILURE;
		}
		pUpdates->next = NULL;

		if (m_pSetOfAppRecordUpdates == NULL)
		{
			m_pSetOfAppRecordUpdates = pUpdates;
		}
		else
		{
		    //
			// LONCHANC: right now, append the new one.
			// but, can we prepend the new one???
			//
			PSetOfApplicationRecordUpdates p;
			for (p = m_pSetOfAppRecordUpdates; NULL != p->next; p = p->next)
				;
			p->next = pUpdates;
		}

		/*
		 * This routine only returns one record.
		 */
		pUpdates->value.node_id = node_id;
		pUpdates->value.entity_id = entity_id;

		switch (update_type)
		{
		case APP_ADD_RECORD:
			pUpdates->value.application_update.choice = APPLICATION_ADD_RECORD_CHOSEN;

			BuildApplicationRecordPDU(pAppRecord,
					&(pUpdates->value.application_update.u.application_add_record));
			break;
		case APP_REPLACE_RECORD:
			pUpdates->value.application_update.choice = APPLICATION_REPLACE_RECORD_CHOSEN;

			rc = BuildApplicationRecordPDU(pAppRecord,
					&(pUpdates->value.application_update.u.application_replace_record));
			break;
		default:
			/*
			 * The record does not have to be filled in for this case.
			 */
			pUpdates->value.application_update.choice = APPLICATION_REMOVE_RECORD_CHOSEN;
			break;
		}
	}
	else
	{
		WARNING_OUT(("CAppRoster::BuildSetOfUpdatesPDU: Assertion:"
					"No applicaton record found for PDU"));
		rc = GCC_NO_SUCH_APPLICATION;
	}

	return rc;
}


/*
 *	GCCError	BuildApplicationRecordPDU ()
 *
 *	Private Function Description
 *		This routine build a single application record for a PDU. A pointer to
 *		the record is passed in to the routine.
 *
 *	Formal Parameters
 *		application_record - 		(i)	Record to be encoded.
 *		application_record_pdu -	(i)	PDU to fill in.
 *
 *	Return Value
 *		GCC_NO_ERROR 			- On Success
 *		GCC_ALLOCATION_FAILURE	- A resource error occured.
 *
 *	Side Effects
 *		none
 *
 *	Caveats
 *		none
 */
GCCError CAppRoster::BuildApplicationRecordPDU(
							APP_RECORD  		    *pAppRecord,
							PApplicationRecord		pAppRecordPdu)
{
	GCCError	rc = GCC_NO_ERROR;

	DebugEntry(CAppRoster::BuildApplicationRecordPDU);

	pAppRecordPdu->bit_mask = 0;

	if (! pAppRecord->non_collapsed_caps_list.IsEmpty())
	{
		pAppRecordPdu->bit_mask |= NON_COLLAPSING_CAPABILITIES_PRESENT;
		
		rc = BuildSetOfNonCollapsingCapabilitiesPDU(
								&pAppRecordPdu->non_collapsing_capabilities,
								&pAppRecord->non_collapsed_caps_list);
		if (GCC_NO_ERROR != rc)
		{
			goto MyExit;
		}
	}

	//	Fill in the startup channel type if it is specified
	if (pAppRecord->startup_channel_type != MCS_NO_CHANNEL_TYPE_SPECIFIED)
	{
		pAppRecordPdu->bit_mask |= RECORD_STARTUP_CHANNEL_PRESENT;
		pAppRecordPdu->record_startup_channel = (ChannelType) pAppRecord->startup_channel_type;
	}

	//	Fill in the application user id if one is specified
	if (pAppRecord->application_user_id	!= 0)
	{
		pAppRecordPdu->bit_mask |= APPLICATION_USER_ID_PRESENT;
		pAppRecordPdu->application_user_id = pAppRecord->application_user_id;
	}

	//	Fill in the required fields
	pAppRecordPdu->application_is_active = (ASN1bool_t)pAppRecord->is_enrolled_actively;
	pAppRecordPdu->is_conducting_capable = (ASN1bool_t)pAppRecord->is_conducting_capable;

	ASSERT(GCC_NO_ERROR == rc);

MyExit:

	return rc;
}


/*
 *	GCCError	BuildSetOfCapabilityRefreshesPDU	()
 *
 *	Private Function Description
 *		This routine builds a PDU structure with the complete set of
 *		capabilities maintained at this node.
 *
 *	Formal Parameters
 *		None
 *
 *	Return Value
 *		GCC_NO_ERROR - On Success
 *		GCC_ALLOCATIONFAILURE - On resource failure
 *
 *	Side Effects
 *		None
 *
 *	Caveats
 *		The standard allows us to send a zero length set of capabilities when
 *		an application leaves that previously had capabilites.
 */
GCCError CAppRoster::BuildSetOfCapabilityRefreshesPDU(void)
{
	GCCError								rc = GCC_ALLOCATION_FAILURE;
	PSetOfApplicationCapabilityRefreshes	pNew;
	PSetOfApplicationCapabilityRefreshes	pOld = NULL;

	DebugEntry(CAppRoster::BuildSetOfCapabilityRefreshesPDU);

	if (m_fMaintainPduBuffer)
	{
		APP_CAP_ITEM		*lpAppCapData;
		/*
		**	We must first free up any previously built PDU data associated
		**	with a capability refresh.
		*/
		if (m_SetOfAppInfo.value.application_capabilities_list.choice == APPLICATION_CAPABILITY_REFRESH_CHOSEN)
		{
			FreeSetOfCapabilityRefreshesPDU ();
		}

		m_SetOfAppInfo.value.application_capabilities_list.choice = APPLICATION_CAPABILITY_REFRESH_CHOSEN;
		m_SetOfAppInfo.value.application_capabilities_list.u.application_capability_refresh = NULL;

		//	Iterate through the complete list of capabilities.
		m_CollapsedCapListForAllNodes.Reset();
		while (NULL != (lpAppCapData = m_CollapsedCapListForAllNodes.Iterate()))
		{
			DBG_SAVE_FILE_LINE
			pNew = new SetOfApplicationCapabilityRefreshes;
			if (NULL == pNew)
			{
				goto MyExit;
			}

			/*
			**	If the set of capability refreshes pointer is equal to NULL
			**	we are at the first capability. Here we need to save the
			**	pointer to the first capability.
			*/
			if (m_SetOfAppInfo.value.application_capabilities_list.u.
					application_capability_refresh == NULL)
			{
				m_SetOfAppInfo.value.application_capabilities_list.u.
					application_capability_refresh = pNew;
			}
			else
			{
				pOld->next = pNew;
			}

			/*
			**	This is used to set the next pointer if another record
			**	exists after this one.
			*/
			/*
			 * This will get filled in later if there is another record.
			 */
			(pOld = pNew)->next = NULL;

			//	Fill in the capability identifier
			rc = lpAppCapData->pCapID->GetCapabilityIdentifierDataPDU(
							&pNew->value.capability_id);
			if (GCC_NO_ERROR != rc)
			{
				goto MyExit;
			}
		
			//	Fill in the capability choice from the GCC capability class.
			pNew->value.capability_class.choice = (USHORT) lpAppCapData->eCapType;

			//	Note that nothing is filled in for a logical capability.
			if (lpAppCapData->eCapType == GCC_UNSIGNED_MINIMUM_CAPABILITY)
			{
				pNew->value.capability_class.u.unsigned_minimum =
						lpAppCapData->nUnsignedMinimum;
			}
			else if (lpAppCapData->eCapType == GCC_UNSIGNED_MAXIMUM_CAPABILITY)
			{
				pNew->value.capability_class.u.unsigned_maximum =
						lpAppCapData->nUnsignedMaximum;
			}

			//	Fill in number of entities regardless of capability type.
			pNew->value.number_of_entities = lpAppCapData->cEntries;
		}
	}

	rc = GCC_NO_ERROR;

MyExit:

	return rc;
}


/*
 *	ApplicationRosterError	BuildSetOfNonCollapsingCapabilitiesPDU ()
 *
 *	Private Function Description
 *		This routine builds a PDU structure for the non collapsing capabilities
 *		list associated passed in.
 *
 *	Formal Parameters
 *		pSetOfCaps				-	(o)	PDU structure to fill in
 *		capabilities_list		-	(i)	Source non-collapsing capabilities.
 *
 *	Return Value
 *		GCC_NO_ERROR - On Success
 *		GCC_ALLOCATIONFAILURE - On resource failure
 *
 *	Side Effects
 *		None
 *
 *	Caveats
 *		None
 */
GCCError CAppRoster::BuildSetOfNonCollapsingCapabilitiesPDU(
				PSetOfNonCollapsingCapabilities	*pSetOfCaps,
				CAppCapItemList					*pAppCapItemList)
{
	GCCError							rc = GCC_ALLOCATION_FAILURE;
	PSetOfNonCollapsingCapabilities		new_set_of_capabilities;
	PSetOfNonCollapsingCapabilities		old_set_of_capabilities;
	APP_CAP_ITEM						*lpAppCapData;

	DebugEntry(CAppRoster::BuildSetOfNonCollapsingCapabilitiesPDU);

	*pSetOfCaps = NULL;
	old_set_of_capabilities = NULL;	//	Setting this to NULL removes warning

	/*
	 * Iterate through the complete list of capabilities.
	 */
	pAppCapItemList->Reset();
	while (NULL != (lpAppCapData = pAppCapItemList->Iterate()))
	{
		DBG_SAVE_FILE_LINE
		new_set_of_capabilities = new SetOfNonCollapsingCapabilities;
		if (NULL == new_set_of_capabilities)
		{
			goto MyExit;
		}

		/*
		**	If the passed in pointer is equal to NULL we are at the first
		**	capability. Here we need to save the pointer to the first
		**	capability in the passed in pointer.
		*/
		if (*pSetOfCaps == NULL)
		{
			*pSetOfCaps = new_set_of_capabilities;
		}
		else
		{
			old_set_of_capabilities->next = new_set_of_capabilities;
		}

		/*
		**	This is used to set the next pointer if another record exists
		**	after this one.
		*/
		old_set_of_capabilities = new_set_of_capabilities;

		/*
		 * This will get filled in later if there is another record.
		 */
		new_set_of_capabilities->next = NULL;

		new_set_of_capabilities->value.bit_mask = 0;

		//	Fill in the capability identifier									
		rc = lpAppCapData->pCapID->GetCapabilityIdentifierDataPDU(
							&new_set_of_capabilities->value.capability_id);
		if (GCC_NO_ERROR != rc)
		{
			goto MyExit;
		}

		if ((lpAppCapData->poszAppData != NULL) && (rc == GCC_NO_ERROR))
		{
			new_set_of_capabilities->value.bit_mask |= APPLICATION_DATA_PRESENT;

			new_set_of_capabilities->value.application_data.length =
					lpAppCapData->poszAppData->length;

			new_set_of_capabilities->value.application_data.value =
					lpAppCapData->poszAppData->value;
		}
	}

	rc = GCC_NO_ERROR;

MyExit:

    return rc;
}


/*
 * These routines are used to free up a roster update indication PDU.
 */

/*
 *	void	FreeRosterUpdateIndicationPDU ()
 *
 *	Private Function Description
 *		This routine frees up all the internal data allocated to hold the roster
 *		update PDU.
 *
 *	Formal Parameters
 *		None
 *
 *	Return Value
 *		None
 *
 *	Side Effects
 *		None
 *
 *	Caveats
 *		Note that the session key PDU data is not freed.  Since this data will
 *		not change through out the life of this application roster object
 *		we just use the same session id PDU data for every roster update
 *		indication.
 */
void CAppRoster::FreeRosterUpdateIndicationPDU(void)
{
	DebugEntry(CAppRoster::FreeRosterUpdateIndicationPDU);

	switch (m_SetOfAppInfo.value.application_record_list.choice)
	{
	case APPLICATION_RECORD_REFRESH_CHOSEN:
		FreeSetOfRefreshesPDU ();
		break;
	case APPLICATION_RECORD_UPDATE_CHOSEN:
		FreeSetOfUpdatesPDU ();
		break;
	}

	//	Free the PDU data associated with the capability list if one exists.
	if (m_SetOfAppInfo.value.application_capabilities_list.choice == APPLICATION_CAPABILITY_REFRESH_CHOSEN)
	{
		FreeSetOfCapabilityRefreshesPDU ();
	}
	
	m_SetOfAppInfo.value.application_record_list.choice = APPLICATION_NO_CHANGE_CHOSEN;
	m_SetOfAppInfo.value.application_capabilities_list.choice = CAPABILITY_NO_CHANGE_CHOSEN;
	m_pSetOfAppRecordUpdates = NULL;
}


/*
 *	void	FreeSetOfRefreshesPDU	()
 *
 *	Private Function Description
 *		This routine Frees all the memory associated with a set
 *		of application record refreshes.
 *
 *	Formal Parameters
 *		none
 *
 *	Return Value
 *		none
 *
 *	Side Effects
 *		none
 *
 *	Caveats
 *		none
 */
void CAppRoster::FreeSetOfRefreshesPDU(void)
{
	PSetOfApplicationRecordRefreshes		pCurr, pNext;

	DebugEntry(CAppRoster::FreeSetOfRefreshesPDU);

	for (pCurr = m_SetOfAppInfo.value.application_record_list.u.application_record_refresh;
			NULL != pCurr;
			pCurr = pNext)
	{
		pNext = pCurr->next;

		//	Free up any non-collapsing capabilities data
		if (pCurr->value.application_record.bit_mask & NON_COLLAPSING_CAPABILITIES_PRESENT)
		{
			FreeSetOfNonCollapsingCapabilitiesPDU(pCurr->value.application_record.non_collapsing_capabilities);
		}

		//	Delete the actual record refresh
		delete pCurr;
	}
	m_SetOfAppInfo.value.application_record_list.u.application_record_refresh = NULL;
}


/*
 *	void	FreeSetOfUpdatesPDU	()
 *
 *	Private Function Description
 *		This routine frees the memory associated with a complete set
 *		application roster updates.
 *
 *	Formal Parameters
 *		none
 *
 *	Return Value
 *		none
 *
 *	Side Effects
 *		none
 *
 *	Caveats
 *		none
 */
void CAppRoster::FreeSetOfUpdatesPDU(void)
{
	PSetOfApplicationRecordUpdates		pCurr, pNext;
	PApplicationRecord					application_record;

	DebugEntry(CAppRoster::FreeSetOfUpdatesPDU);

	for (pCurr = m_SetOfAppInfo.value.application_record_list.u.application_record_update;
			NULL != pCurr;
			pCurr = pNext)
	{
		// remember the next one because we will free the current one
		pNext = pCurr->next;

		//	Free up any non-collapsing capabilities data
		switch(pCurr->value.application_update.choice)
		{
		case APPLICATION_ADD_RECORD_CHOSEN:
			application_record = &pCurr->value.application_update.u.application_add_record;
			break;
		case APPLICATION_REPLACE_RECORD_CHOSEN:
			application_record = &pCurr->value.application_update.u.application_replace_record;
			break;
		default:
			application_record = NULL;
			break;
		}

		if (application_record != NULL)
		{
			if (application_record->bit_mask & NON_COLLAPSING_CAPABILITIES_PRESENT)
			{
				FreeSetOfNonCollapsingCapabilitiesPDU(application_record->non_collapsing_capabilities);
			}
		}

		//	Delete the actual update structure
		delete pCurr;
	}
    m_SetOfAppInfo.value.application_record_list.u.application_record_update = NULL;
}


/*
 *	void	FreeSetOfCapabilityRefreshesPDU	()
 *
 *	Private Function Description
 *		This routine frees all the memory associated with the capability PDU.
 *
 *	Formal Parameters
 *		capability_refresh -	(i)	Capabilities to be freed.
 *
 *	Return Value
 *		none
 *
 *	Side Effects
 *		none
 *
 *	Caveats
 *		Note that the capability id PDU data is not freed here.  Since this
 *		data should not change through out the life of this object we don't
 *		bother freeing and regenerating it.
 */
void CAppRoster::FreeSetOfCapabilityRefreshesPDU(void)
{
	PSetOfApplicationCapabilityRefreshes		pCurr, pNext;

	for (pCurr = m_SetOfAppInfo.value.application_capabilities_list.u.application_capability_refresh;
			NULL != pCurr;
			pCurr = pNext)
	{
		pNext = pCurr->next;
		delete pCurr;
	}
}


/*
 *	void	FreeSetOfNonCollapsingCapabilitiesPDU	()
 *
 *	Private Function Description
 *		This routine frees all the memory associated with the
 *		non-collapsed capability PDU.
 *
 *	Formal Parameters
 *		capability_refresh -	(i)	Non-Collapsed Capabilities to be freed.
 *
 *	Return Value
 *		none
 *
 *	Side Effects
 *		none
 *
 *	Caveats
 *		Note that the capability id PDU data is not freed here.  Since this
 *		data should not change through out the life of this object we don't
 *		bother freeing and regenerating it.
 */
void CAppRoster::FreeSetOfNonCollapsingCapabilitiesPDU (
						PSetOfNonCollapsingCapabilities		capability_refresh)
{
	PSetOfNonCollapsingCapabilities		pCurr, pNext;

	for (pCurr = capability_refresh; NULL != pCurr; pCurr = pNext)
	{
		pNext = pCurr->next;
		delete pCurr;
	}
}


/*
 * These routines process roster update indication PDUs.
 */

/*
 *	ApplicationRosterError	ProcessRosterUpdateIndicationPDU	()
 *
 *	Public Function Description
 *		This routine is responsible for processing the decoded PDU data.
 *		It essentially changes the application roster object's internal database
 *		based on the information in the structure.
 */
GCCError CAppRoster::ProcessRosterUpdateIndicationPDU (
						PSetOfApplicationInformation  	application_information,
                        UserID							sender_id)
{
	GCCError	rc = GCC_NO_ERROR;

	DebugEntry(CAppRoster::ProcessRosterUpdateIndicationPDU);

	/*
	**	Free up the old PDU data here if it is being maintained and the
	**	PDU has been flushed.  Note that we also set the PDU is flushed boolean
	**	back to FALSE so that the new PDU will be maintained until it is
	**	flushed.
	*/
	if (m_fPduIsFlushed)
	{
		FreeRosterUpdateIndicationPDU ();
		m_fPduIsFlushed = FALSE;
	}

	/*
	**	Now check the application key to make sure we have a match. If
	**	not, return with no change.
	*/
	if (! m_pSessionKey->IsThisYourSessionKeyPDU(&application_information->value.session_key))
	{
		WARNING_OUT(("CAppRoster::ProcessRosterUpdateIndicationPDU:GCC_BAD_SESSION_KEY"));
		rc = GCC_BAD_SESSION_KEY;
		goto MyExit;
	}

	/*
	**	If this is a roster update and refresh is chosen we must
	**	clear out the entire list and rebuild it.
	*/
	if (application_information->value.application_record_list.choice != APPLICATION_NO_CHANGE_CHOSEN)
	{
		//	The roster is about to change
		m_fRosterHasChanged = TRUE;

		/*
		**	If this node is the top provider or this roster is local and
		**	only used to propogate PDUs up toward the top provider,
		**	we increment the instance number. If it is not we get the
		**	instance number out of the PDU.
		*/
		if (m_fTopProvider || m_fLocalRoster)
		{
			m_nInstance++;
		}
		else
		{
			m_nInstance = application_information->value.roster_instance_number;
		}
		
		/*
		**	Here if either of these booleans is already TRUE we do not
		**	want to write over them with this PDU data.  Therefore, we
		**	check for FALSE before we do anything with them.
		*/
		if (! m_fPeerEntitiesAdded)
		{
			m_fPeerEntitiesAdded = application_information->value.peer_entities_are_added;
		}

		if (! m_fPeerEntitiesRemoved)
		{
			m_fPeerEntitiesRemoved = application_information->value.peer_entities_are_removed;
		}

		if (application_information->value.application_record_list.choice == APPLICATION_RECORD_REFRESH_CHOSEN)
		{
			TRACE_OUT(("CAppRoster::ProcessRosterUpdateIndicationPDU:ProcessSetOfRefreshesPDU"));
			rc = ProcessSetOfRefreshesPDU(
							application_information->value.application_record_list.u.application_record_refresh,
							sender_id);
		}
		else
		{
			TRACE_OUT(("CAppRoster::ProcessRosterUpdateIndicationPDU:ProcessSetOfUpdatesPDU"));
			rc = ProcessSetOfUpdatesPDU(
							application_information->value.application_record_list.u.application_record_update,
							sender_id);
		}
		if (GCC_NO_ERROR != rc)
		{
			goto MyExit;
		}
	}
	else
	{
		ERROR_OUT(("AppRoster::ProcessRosterUpdateIndicationPDU:ASSERTION: NO Change PDU received"));
	}

	//	Process the capabilities list portion of the PDU.
	if (application_information->value.application_capabilities_list.choice == APPLICATION_CAPABILITY_REFRESH_CHOSEN)
	{
		//	Set flag to show that change has occured.
		m_fCapabilitiesHaveChanged = TRUE;

		/*
		**	We will store the new capabilities in the roster record
		**	associated with the sender id.  Note that it is possible for
		**	this roster record to contain an empty application record list
		**	if the sending node has no enrolled applications.
		*/
		rc = ProcessSetOfCapabilityRefreshesPDU(
						application_information->value.application_capabilities_list.u.application_capability_refresh,
						sender_id);
	}
	else
	{
		ASSERT(GCC_NO_ERROR == rc);
	}

MyExit:

	return rc;
}


/*
 *	GCCError	ProcessSetOfRefreshesPDU	()
 *
 *	Private Function Description
 *		This routine processes a set of record refreshes. It is responsible
 *		for managing the creation (or update) of all affected application
 *		records. The roster list built from a refresh PDU does not maintain the
 *		hierarchy of the conference since it is not important at this point.
 *		Refreshes are issued as broacast from the Top Provider down to the
 *		sub-ordinate nodes.
 *
 *	Formal Parameters
 *		record_refresh 	-	(i) Set of record refresh PDUs to be processed.
 *		sender_id		-	(i)	Node id of node that sent the update.
 *
 *	Return Value
 *		GCC_NO_ERROR - On Success
 *		GCC_ALLOCATION_FAILURE - On resource failure
 *
 *	Side Effects
 *		none
 *
 *	Caveate
 *		none
 */
GCCError CAppRoster::ProcessSetOfRefreshesPDU(
							PSetOfApplicationRecordRefreshes	record_refresh,
							UserID								sender_id)
{
	GCCError							rc = GCC_ALLOCATION_FAILURE;
	PSetOfApplicationRecordRefreshes	pCurr;
	APP_RECORD  					    *app_record;
	APP_NODE_RECORD						*node_record;
	CAppRecordList2						*record_list;
	UserID								node_id;
	EntityID							entity_id;

	DebugEntry(CAppRoster::ProcessSetOfRefreshesPDU);

	if (record_refresh != NULL)
	{
		//	Clear out the node record for the sender id	
		ClearNodeRecordFromList (sender_id);

		/*
		** 	Create the node record for the sender id passed into this routine.
		**	Note that if the sender of this refresh is the Top Provider
		**	all nodes below the top provider are contained in the sub node
		**	list of the Top Provider's node record.	
		*/
		DBG_SAVE_FILE_LINE
		node_record = new APP_NODE_RECORD;
		if (NULL == node_record)
		{
			goto MyExit;
		}

		m_NodeRecordList2.Append(sender_id, node_record);

		for (pCurr = record_refresh; NULL != pCurr; pCurr = pCurr->next)
		{
			node_id = pCurr->value.node_id;
			entity_id = pCurr->value.entity_id;

			if (sender_id != node_id)
			{
				//	Get or create the sub node record list	
				if (NULL == (record_list = node_record->SubNodeList2.Find(node_id)))
				{
					DBG_SAVE_FILE_LINE
					record_list = new CAppRecordList2(DESIRED_MAX_APP_RECORDS);
					if (NULL == record_list)
					{
						goto MyExit;
					}
					node_record->SubNodeList2.Append(node_id, record_list);
				}
			}
			else
			{
				/*
				**	Here we set up the pointer to the record list.  This
				**	list is the node records application list which
				**	means that this list contains the application records
				**	associated with the sender's node.
				*/
				record_list = &node_record->AppRecordList;
			}

			//	Now	create and fill in the new application record.
			DBG_SAVE_FILE_LINE
			app_record = new APP_RECORD;
			if (NULL == app_record)
			{
				goto MyExit;
			}

			rc = ProcessApplicationRecordPDU(app_record, &pCurr->value.application_record);
			if (GCC_NO_ERROR != rc)
			{
				goto MyExit;
			}

			record_list->Append(entity_id, app_record);
		} // for
	}
	else
	{
		//	This roster no longer contains any entries so clear the list!!!
		ClearNodeRecordList ();
	}

	/*
	**	Build a full refresh PDU here if no errors occured while processing
	**	the refresh PDU.									
	*/
	rc = BuildApplicationRecordListPDU (APP_FULL_REFRESH, 0, 0);

MyExit:

	return rc;
}


/*
 *	GCCError	ProcessSetOfUpdatesPDU	()
 *
 *	Private Function Description
 *		This routine processes a set of roster updates.  It iterates through
 *		the complete list of updates making all necessary changes to the
 *		internal information base and building the appropriate PDU.
 *
 *	Formal Parameters
 *		record_update -	(i) set of updates PDU to be processed
 *		sender_id -		(i)	gcc user id of node that sent the update
 *
 *	Return Value
 *		APP_ROSTER_NO_ERROR - On Success
 *		APP_ROSTER_RESOURCE_ERROR - On resource failure
 *
 *	Side Effects
 *		none
 *
 *	Caveate
 *		none
 */
GCCError CAppRoster::ProcessSetOfUpdatesPDU(
					  		PSetOfApplicationRecordUpdates		record_update,
					  		UserID								sender_id)
{
	GCCError							rc = GCC_ALLOCATION_FAILURE;
	PSetOfApplicationRecordUpdates		pCurr;
	UserID								node_id;
	EntityID							entity_id;
	PApplicationRecord					pdu_record;
	APP_RECORD  					    *application_record = NULL;
	APP_NODE_RECORD						*node_record;
	CAppRecordList2						*record_list;
	APP_ROSTER_UPDATE_TYPE				update_type;

	DebugEntry(CAppRoster::ProcessSetOfUpdatesPDU);

	if (record_update != NULL)
	{
		for (pCurr = record_update; NULL != pCurr; pCurr = pCurr->next)
		{
			node_id = pCurr->value.node_id;
			entity_id = pCurr->value.entity_id;

			switch(pCurr->value.application_update.choice)
			{
			case APPLICATION_ADD_RECORD_CHOSEN:
				pdu_record = &(pCurr->value.application_update.u.application_add_record);
				update_type = APP_ADD_RECORD;
				break;
			case APPLICATION_REPLACE_RECORD_CHOSEN:
				DeleteRecord (node_id, entity_id, FALSE);
				pdu_record = &(pCurr->value.application_update.u.application_replace_record);
				update_type = APP_REPLACE_RECORD;
				break;
			default: //	Remove record
				/*
				**	Inform the owner that a record was delete while processing
				**	this PDU so that it can perform any necessary cleanup.
				*/
				m_pAppRosterMgr->DeleteRosterRecord(node_id, entity_id);

				DeleteRecord (node_id, entity_id, TRUE);
				pdu_record = NULL;
				update_type = APP_DELETE_RECORD;
				break;
			}

			/*
			**	First get the roster record and if one does not exist for this
			**	app record create it. After that we will create the application
			**	record and put it into the correct slot in the application
			**	roster record.
			*/
			if (pdu_record != NULL)
			{
				/*
				**	First find the correct node record and if it does not
				**	exist create it.
				*/
				if (NULL == (node_record = m_NodeRecordList2.Find(sender_id)))
				{
					DBG_SAVE_FILE_LINE
					node_record = new APP_NODE_RECORD;
					if (NULL == node_record)
					{
						goto MyExit;
					}

					m_NodeRecordList2.Append(sender_id, node_record);
				}

				/*
				**	If the user and sender id is the same then the record
				**	will be contained in the app_record_list. Otherwise, it
				**	will be maintained in the sub-node list.
				*/

				/*
				**	If the sender_id equals the node id being processed
				**	use the application record list instead of the sub
				**	node list.
				*/
				if (sender_id != node_id)
				{
					/*	
					**	Find the correct node list and create it if it does
					**	not exists. This list holds lists of all the
					**	application	peer entities at a node.
					*/
					if (NULL == (record_list = node_record->SubNodeList2.Find(node_id)))
					{
						DBG_SAVE_FILE_LINE
						record_list = new CAppRecordList2(DESIRED_MAX_APP_RECORDS);
						if (NULL == record_list)
						{
							goto MyExit;
						}

						node_record->SubNodeList2.Append(node_id, record_list);
					}
				}
				else
				{
					record_list = &node_record->AppRecordList;
				}

				//	Now fill in the application record
				DBG_SAVE_FILE_LINE
				application_record = new APP_RECORD;
				if (NULL == application_record)
				{
					goto MyExit;
				}

				record_list->Append(entity_id, application_record);
				rc = ProcessApplicationRecordPDU(application_record, pdu_record);
				if (GCC_NO_ERROR != rc)
				{
					goto MyExit;
				}
			} // if
			
			/*
			**	Here we add this update to our PDU and jump to the next update
			**	in the PDU currently being processed.
			*/
			rc = BuildApplicationRecordListPDU (	update_type,
															node_id,
															entity_id);
			if (rc != GCC_NO_ERROR)
			{
				goto MyExit;
			}

			/*
			**	If the capabilities changed during the above processing
			**	we must	create a new collapsed capabilities list and
			**	build a new capability refresh PDU.
			*/
			if (m_fCapabilitiesHaveChanged)
			{
				MakeCollapsedCapabilitiesList();
				rc = BuildSetOfCapabilityRefreshesPDU ();
				if (rc != GCC_NO_ERROR)
				{
					goto MyExit;
				}
			}
		} // for
	} // if

	rc = GCC_NO_ERROR;

MyExit:

	return rc;
}


/*
 *	GCCError	ProcessApplicationRecordPDU ()
 *
 *	Private Function Description
 *		This routine is responsible for decoding the Application Record
 *		portion of the roster update pdu.
 *
 *	Formal Parameters
 *		application_record -	This is the internal destination app record.
 *		pdu_record - 			Source PDU data
 *
 *	Return Value
 *		GCC_NO_ERROR - On Success
 *		GCC_ALLOCATION_FAILURE - On resource failure
 *
 *	Side Effects
 *		none
 *
 *	Caveats
 *		none
 */
GCCError CAppRoster::ProcessApplicationRecordPDU (
									APP_RECORD  	        *application_record,
									PApplicationRecord		pdu_record)
{
	GCCError	rc = GCC_NO_ERROR;

	DebugEntry(CAppRoster::ProcessApplicationRecordPDU);

	application_record->is_enrolled_actively = pdu_record->application_is_active;
	application_record->is_conducting_capable = pdu_record->is_conducting_capable;

	if (pdu_record->bit_mask & RECORD_STARTUP_CHANNEL_PRESENT)
	{
		application_record->startup_channel_type =
						(MCSChannelType)pdu_record->record_startup_channel;
	}
	else
		application_record->startup_channel_type= MCS_NO_CHANNEL_TYPE_SPECIFIED;

	if (pdu_record->bit_mask & APPLICATION_USER_ID_PRESENT)
	{
		application_record->application_user_id =
												pdu_record->application_user_id;
	}
	else
		application_record->application_user_id = 0;

	if (pdu_record->bit_mask & NON_COLLAPSING_CAPABILITIES_PRESENT)
	{
		rc = ProcessNonCollapsingCapabilitiesPDU (
								&application_record->non_collapsed_caps_list,
								pdu_record->non_collapsing_capabilities);
	}

	return rc;
}


/*
 *	GCCError	ProcessSetOfCapabilityRefreshesPDU	()
 *
 *	Private Function Description
 *		This routine is responsible for decoding the capabilities portion
 *		of an roster update PDU.
 *
 *	Formal Parameters
 *		capability_refresh -	(i) set of capabilities PDU to be processed
 *		sender_id -				(i)	gcc user id of node that sent the update
 *
 *	Return Value
 *		GCC_NO_ERROR 			- On Success
 *		GCC_ALLOCATION_FAILURE 	- On resource failure
 *
 *	Side Effects
 *		none
 *
 *	Caveats
 *		This routine does handle NULL for the capability refresh which means
 *		that the capabilities delivered no longer exists.
 */
GCCError CAppRoster::ProcessSetOfCapabilityRefreshesPDU(
						PSetOfApplicationCapabilityRefreshes	capability_refresh,
                   		UserID									sender_id)
{
	GCCError								rc = GCC_NO_ERROR;
	PSetOfApplicationCapabilityRefreshes	pCurr;
	CAppCapItemList							*pAppCapList;
	APP_CAP_ITEM							*pAppCapItem;
	APP_NODE_RECORD							*node_record;

	DebugEntry(CAppRoster::ProcessSetOfCapabilityRefreshesPDU);

	if (NULL == (node_record = m_NodeRecordList2.Find(sender_id)))
	{
		DBG_SAVE_FILE_LINE
		node_record = new APP_NODE_RECORD;
		if (NULL == node_record)
		{
			return GCC_ALLOCATION_FAILURE;
		}

		m_NodeRecordList2.Append(sender_id, node_record);
	}

	// get collapsed cap list ptr
	pAppCapList = &node_record->CollapsedCapList;

	//	Clear out all the old capabilities from this list.
	pAppCapList->DeleteList();

	//	Begin processing the PDU.
	for (pCurr = capability_refresh; NULL != pCurr; pCurr = pCurr->next)
	{
		ASSERT(GCC_NO_ERROR == rc);

		//	Create and fill in the new capability.
		DBG_SAVE_FILE_LINE
		pAppCapItem = new APP_CAP_ITEM((GCCCapabilityType) pCurr->value.capability_class.choice);
		if (NULL == pAppCapItem)
		{
			return GCC_ALLOCATION_FAILURE;
		}

		//	Create the capability ID
		DBG_SAVE_FILE_LINE
		pAppCapItem->pCapID = new CCapIDContainer(&pCurr->value.capability_id, &rc);
		if (NULL == pAppCapItem->pCapID)
		{
			rc = GCC_ALLOCATION_FAILURE;
		}
		if (GCC_NO_ERROR != rc)
		{
			delete pAppCapItem;
			return rc;
		}

		// append this cap to the collapsed cap list
		pAppCapList->Append(pAppCapItem);

		/*	
		**	Note that a logical type's value is maintained as
		**	number of entities.
		*/
		if (pCurr->value.capability_class.choice == UNSIGNED_MINIMUM_CHOSEN)
		{
			pAppCapItem->nUnsignedMinimum = pCurr->value.capability_class.u.unsigned_minimum;
		}
		else
		if (pCurr->value.capability_class.choice == UNSIGNED_MAXIMUM_CHOSEN)
		{
			pAppCapItem->nUnsignedMaximum = pCurr->value.capability_class.u.unsigned_maximum;
		}

		pAppCapItem->cEntries = pCurr->value.number_of_entities;
	} // for

	//	This forces a new capabilities list to be calculated.
	MakeCollapsedCapabilitiesList();

	/*
	**	Here we build the new PDU data associated with this refresh of the
	**	capability list.
	*/
	return BuildSetOfCapabilityRefreshesPDU();
}


/*
 *	GCCError	ProcessNonCollapsingCapabilitiesPDU	()
 *
 *	Private Function Description
 *		This routine is responsible for decoding the non-collapsing capabilities
 *		portion of a roster record PDU.
 *
 *	Formal Parameters
 *		non_collapsed_caps_list -	(o) Pointer to list to fill in with new
 *										non-collapsed caps.
 *		pSetOfCaps -		(i)	non-collapsed PDU data
 *
 *	Return Value
 *		GCC_NO_ERROR 			- On Success
 *		GCC_ALLOCATION_FAILURE 	- On resource failure
 *
 *	Side Effects
 *		none
 *
 *	Caveats
 *		none
 */
GCCError CAppRoster::ProcessNonCollapsingCapabilitiesPDU (
					CAppCapItemList						*non_collapsed_caps_list,
					PSetOfNonCollapsingCapabilities		pSetOfCaps)
{
	GCCError						rc = GCC_NO_ERROR;
	PSetOfNonCollapsingCapabilities	pCurr;
	APP_CAP_ITEM					*pAppCapItem;

	DebugEntry(CAppRoster::ProcessNonCollapsingCapsPDU);

	for (pCurr = pSetOfCaps; NULL != pCurr; pCurr = pCurr->next)
	{
	    //
		// LONCHANC: The following cap data does not have a type???
		// for now, set it to zero.
		//
		DBG_SAVE_FILE_LINE
		pAppCapItem = new APP_CAP_ITEM((GCCCapabilityType)0);
		if (NULL == pAppCapItem)
		{
			rc = GCC_ALLOCATION_FAILURE;
			goto MyExit;
		}

		DBG_SAVE_FILE_LINE
		pAppCapItem->pCapID = new CCapIDContainer(&pCurr->value.capability_id, &rc);
		if (NULL == pAppCapItem->pCapID)
		{
			rc = GCC_ALLOCATION_FAILURE;
		}
		if (rc != GCC_NO_ERROR)
		{
			goto MyExit;
		}

		if (pCurr->value.bit_mask & APPLICATION_DATA_PRESENT)
		{
			if (NULL == (pAppCapItem->poszAppData = ::My_strdupO2(
									pCurr->value.application_data.value,
									pCurr->value.application_data.length)))
			{
				rc = GCC_ALLOCATION_FAILURE;
				goto MyExit;
			}
		}

		non_collapsed_caps_list->Append(pAppCapItem);
	} // for

	ASSERT(GCC_NO_ERROR == rc);

MyExit:

    if (GCC_NO_ERROR != rc)
    {
        delete pAppCapItem;
    }

	return rc;
}


/*
 * Utilities that operate on conference records.
 */

/*
 *	UINT	LockApplicationRoster	()
 *
 *	Public Function Description
 *		This routine is used to lock a GCCApplicationRoster and to determine the
 *		amount of memory necessary to hold the data referenced by the "API"
 *		application roster structure.  The GCCApplicationRoster is used in
 *		indications to applications at the local node.
 */
UINT CAppRoster::LockApplicationRoster(void)
{
	UINT						number_of_records = 0;
	UINT						number_of_capabilities = 0;
	APP_NODE_RECORD				*lpAppNodeRecord;
	APP_RECORD  			    *lpAppRecData;
	APP_CAP_ITEM				*lpAppCapData;
	CAppRecordList2				*lpAppRecDataList;

	DebugEntry(CAppRoster::LockApplicationRoster);

	/*
	 * If this is the first time this routine is called, determine the size of
	 * the memory required to hold the data referenced by the application
	 * roster structure.  Otherwise, just increment the lock count.
	 */
	if (Lock() == 1)
	{
		/*
		 * Lock the data for the session key held within the roster.  This lock
		 * call returns the size of the memory required to hold the session key
		 * data, rounded to an even multiple of four-bytes.
		 */
		m_cbDataMemory = m_pSessionKey->LockSessionKeyData();

		/*
	     * First calculate the total number of records. This count is used to
		 * determine the space necessary to hold the records. Note that we must
		 * count both the application record list and the sub-node list.
	     */
		m_NodeRecordList2.Reset();
	 	while (NULL != (lpAppNodeRecord = m_NodeRecordList2.Iterate()))
		{
			/*
			 * Add the application records at this node to the count.
			 */
			number_of_records += lpAppNodeRecord->AppRecordList.GetCount();
		
			/*
			 * Next count the sub node records.
			 */
			if (! lpAppNodeRecord->SubNodeList2.IsEmpty())
			{
				lpAppNodeRecord->SubNodeList2.Reset();
				while (NULL != (lpAppRecDataList = lpAppNodeRecord->SubNodeList2.Iterate()))
				{
					number_of_records += lpAppRecDataList->GetCount();
				}
			}
		}

		/*
		 * Now determine the amount of memory necessary to hold all of the
		 * pointers to the application records as well as the actual
		 * GCCApplicationRecord structures.
		 */
		m_cbDataMemory += number_of_records *
				(sizeof(PGCCApplicationRecord) +
				ROUNDTOBOUNDARY( sizeof(GCCApplicationRecord)) );
		
		m_NodeRecordList2.Reset();
	   	while (NULL != (lpAppNodeRecord = m_NodeRecordList2.Iterate()))
		{
			/*
			 * Iterate through this node's record list, determining the amount
			 * of memory necessary to hold the pointers to the non-collapsing
			 * capabilities as well as the capability ID data and octet string
			 * data associated with each non-collapsing capability.
			 */
			lpAppNodeRecord->AppRecordList.Reset();
			while (NULL != (lpAppRecData = lpAppNodeRecord->AppRecordList.Iterate()))
			{
				/*
				 * Set up an iterator for the list of non-collapsing
				 * capabilities held within each application roster.
				 */
				lpAppRecData->non_collapsed_caps_list.Reset();
				number_of_capabilities += lpAppRecData->non_collapsed_caps_list.GetCount();

				while (NULL != (lpAppCapData = lpAppRecData->non_collapsed_caps_list.Iterate()))
				{
					/*
					 * Lock the data for each capability ID.  The lock call
					 * returns the length of the data referenced by each
					 * capability ID rounded to occupy an even multiple of
					 * four-bytes.
					 */
					m_cbDataMemory += lpAppCapData->pCapID->LockCapabilityIdentifierData();

					/*
					 * Add up the space required to hold the application data
					 * octet strings if they are present.  Make sure there is
					 * enough space for each octet string to occupy an even
					 * multiple of four bytes.  Add room to hold the actual
					 * octet string structure also since the capability
					 * structure only contains a pointer to a OSTR.
					 */
					if (lpAppCapData->poszAppData != NULL)
					{
						m_cbDataMemory += ROUNDTOBOUNDARY(sizeof(OSTR));
						m_cbDataMemory += ROUNDTOBOUNDARY(lpAppCapData->poszAppData->length);
					}
				}
			}

			/*
			 * Iterate through this node's sub-node record list, determining the
			 * amount of memory necessary to hold the pointers to the
			 * non-collapsing capabilities as well as the capability ID data and
			 * octet string	data associated with each non-collapsing capability.
			 */
			lpAppNodeRecord->SubNodeList2.Reset();
			while (NULL != (lpAppRecDataList = lpAppNodeRecord->SubNodeList2.Iterate()))
			{
				lpAppRecDataList->Reset();
				while (NULL != (lpAppRecData = lpAppRecDataList->Iterate()))
				{
					/*
					 * Set up an iterator for the list of non-collapsing
					 * capabilities held within each application roster.
					 */
					number_of_capabilities += lpAppRecData->non_collapsed_caps_list.GetCount();

					lpAppRecData->non_collapsed_caps_list.Reset();
					while (NULL != (lpAppCapData = lpAppRecData->non_collapsed_caps_list.Iterate()))
					{
						/*
						 * Lock the data for each capability ID.  The lock call
						 * returns the length of the data referenced by each
						 * capability ID fixed up to occupy an even multiple of
						 * four-bytes.
						 */
						m_cbDataMemory += lpAppCapData->pCapID->LockCapabilityIdentifierData();
					
						/*
						 * Add up the space required to hold the application
						 * data octet strings if they are present.  Make sure
						 * there is	enough space for each octet string to occupy
						 * an even multiple of four bytes.  Add room to hold the
						 * actual octet string structure also since the
						 * capability structure only contains a pointer to a OSTR
						 */
						if (lpAppCapData->poszAppData != NULL)
						{
							m_cbDataMemory += ROUNDTOBOUNDARY(sizeof(OSTR));
							m_cbDataMemory += ROUNDTOBOUNDARY(lpAppCapData->poszAppData->length);
						}
					}
				}
			}
		}

		/*
		 * Determine the amount of memory necessary to hold all of the pointers
		 * to the non-collapsing capabilities as well as the actual
		 * GCCNonCollapsingCapability structures.
		 */
		m_cbDataMemory += number_of_capabilities *
				(sizeof (PGCCNonCollapsingCapability) +
				ROUNDTOBOUNDARY( sizeof(GCCNonCollapsingCapability)) );

		/*
		 * Add the amount of memory necessary to hold the string data associated
		 * with each capability ID.
		 */
		m_CollapsedCapListForAllNodes.Reset();
		while (NULL != (lpAppCapData = m_CollapsedCapListForAllNodes.Iterate()))
		{
			m_cbDataMemory += lpAppCapData->pCapID->LockCapabilityIdentifierData();
		}

		/*
		 * Add the memory to hold the application capability pointers
		 * and structures.
		 */
		number_of_capabilities = m_CollapsedCapListForAllNodes.GetCount();

		m_cbDataMemory += number_of_capabilities *
				(sizeof (PGCCApplicationCapability) +
				ROUNDTOBOUNDARY( sizeof(GCCApplicationCapability)) );
	}

	return m_cbDataMemory;
}


/*
 *	UINT	GetAppRoster()
 *
 *	Public Function Description
 *		This routine is used to obtain a pointer to the GCCApplicatonRoster.
 *		This routine should not be called before LockApplicationRoster is
 *		called. LockApplicationRoster will create the GCCApplicationRoster in
 *		the memory provided.  The GCCApplicationRoster is what is delivered to
 * 		the end user Application SAP.
 */
UINT CAppRoster::GetAppRoster(
						PGCCApplicationRoster		pGccAppRoster,
						LPBYTE						pData)
{
	UINT rc;

	DebugEntry(CAppRoster::GetAppRoster);

	if (GetLockCount() > 0)
	{
        UINT data_length;

	    /*
	     * Fill in the output length parameter which indicates how much data
	     * referenced outside the structure will be written.
	     */
        rc = m_cbDataMemory;

        /*
		 * Get the data associated with the roster's session key and save
		 * the length of the data written into memory.
		 */
		data_length = m_pSessionKey->GetGCCSessionKeyData(&pGccAppRoster->session_key, pData);

		/*
		 * Move the memory pointer past the data associated with the
		 * session key.
		 */
		pData += data_length;

		/*
		 * Fill in other roster structure elements.
		 */
		pGccAppRoster->application_roster_was_changed = m_fRosterHasChanged;
		pGccAppRoster->instance_number = (USHORT) m_nInstance;
		pGccAppRoster->nodes_were_added = m_fPeerEntitiesAdded;
		pGccAppRoster->nodes_were_removed = m_fPeerEntitiesRemoved;
		pGccAppRoster->capabilities_were_changed = m_fCapabilitiesHaveChanged;

		/*
		 * Fill in the full set of application roster records.
		 */
		data_length = GetApplicationRecords(pGccAppRoster,	pData);

		/*
		 * Move the memory pointer past the application records and their
		 * associated data.  Get the full set of application capabilities.
		 */
		pData += data_length;

		data_length = GetCapabilitiesList(pGccAppRoster, pData);
	}
	else
	{
		ERROR_OUT(("CAppRoster::GetAppRoster: Error data not locked"));
        rc = 0;
	}

	return rc;
}


/*
 *	void	UnLockApplicationRoster	()
 *
 *	Public Function Description
 *		This member function is responsible for unlocking the data locked for
 *		the "API" application roster after the lock count goes to zero.
 */
void CAppRoster::UnLockApplicationRoster()
{
	DebugEntry(CAppRoster::UnLockApplicationRoster);

    if (Unlock(FALSE) == 0)
	{
        // reset the size
        m_cbDataMemory = 0;

        // free up all the memory locked for "API" data.
	    APP_NODE_RECORD				*lpAppNodeRecord;
	    APP_RECORD  			    *lpAppRecData;
	    APP_CAP_ITEM				*lpAppCapData;
	    CAppRecordList2				*lpAppRecDataList;

        // unlock session key data
        m_pSessionKey->UnLockSessionKeyData();

        // iterate through all the node records
	    m_NodeRecordList2.Reset();
	    while (NULL != (lpAppNodeRecord = m_NodeRecordList2.Iterate()))
	    {
		    // iterate through this node's record list
		    lpAppNodeRecord->AppRecordList.Reset();
		    while (NULL != (lpAppRecData = lpAppNodeRecord->AppRecordList.Iterate()))
		    {
			    // set up an iterator for the list of non-collapsing
			    // capabilities held within each application roster.
			    lpAppRecData->non_collapsed_caps_list.Reset();
			    while (NULL != (lpAppCapData = lpAppRecData->non_collapsed_caps_list.Iterate()))
			    {
				    lpAppCapData->pCapID->UnLockCapabilityIdentifierData();
			    }
		    }

		    // iterate through this node's sub-node record list
		    lpAppNodeRecord->SubNodeList2.Reset();
		    while (NULL != (lpAppRecDataList = lpAppNodeRecord->SubNodeList2.Iterate()))
		    {
			    lpAppRecDataList->Reset();
			    while (NULL != (lpAppRecData = lpAppRecDataList->Iterate()))
			    {
				    // set up an iterator for the list of non-collapsing
				    // capabilities held within each application roster.
				    lpAppRecData->non_collapsed_caps_list.Reset();
				    while (NULL != (lpAppCapData = lpAppRecData->non_collapsed_caps_list.Iterate()))
				    {
					    lpAppCapData->pCapID->UnLockCapabilityIdentifierData();
				    }
			    }
		    }
	    }

        // iterate through collapsed caps
	    m_CollapsedCapListForAllNodes.Reset();
	    while (NULL != (lpAppCapData = m_CollapsedCapListForAllNodes.Iterate()))
	    {
		    lpAppCapData->pCapID->UnLockCapabilityIdentifierData();
	    }
	}

    // we have to call Release() because we used Unlock(FALSE)
    Release();
}


/*
 *	UINT	GetApplicationRecords	()
 *
 *	Private Function Description
 *		This routine inserts the complete set of application roster records
 *		into the passed in application roster structure.
 *
 *	Formal Parameters
 *		gcc_roster 	-	(o) GCCApplicationRoster to be filled in.
 *		memory		-	(o) Location in memory to begin writing records.
 *
 *	Return Value
 *		The total amount of data written into memory.
 *
 *	Side Effects
 *		The memory pointer passed in will be advanced by the amount of memory
 *		necessary to hold the application records and their data.
 *
 *	Caveats
 *		none
 */
UINT CAppRoster::GetApplicationRecords(
						PGCCApplicationRoster		gcc_roster,
						LPBYTE						memory)
{
	UINT							data_length = 0;
	UINT							record_count = 0;
	PGCCApplicationRecord			gcc_record;
	UINT							capability_data_length;
	APP_NODE_RECORD					*lpAppNodeRec;
	CAppRecordList2					*lpAppRecDataList;
	APP_RECORD  				    *lpAppRecData;
    UserID                          uid, uid2;
	EntityID						eid;

	DebugEntry(CAppRoster::GetApplicationRecords);

	/*
	 * Initialize the number of records in the roster to zero.
	 */
	gcc_roster->number_of_records = 0;

	/*
     * First calculate the total number of records. This count is used to
	 * allocate the space necessary to hold the record pointers. Note that we
	 * must count both the application record list and the sub-node list.
     */
	m_NodeRecordList2.Reset();
	while (NULL != (lpAppNodeRec = m_NodeRecordList2.Iterate()))
	{
		/*
		 * Add the number of application records at this node to the count.
		 */
		gcc_roster->number_of_records += (USHORT) (lpAppNodeRec->AppRecordList.GetCount());

		/*
		 * Next add the number of sub node entries.
		 */
		if (! lpAppNodeRec->SubNodeList2.IsEmpty())
		{
			lpAppNodeRec->SubNodeList2.Reset();
			while (NULL != (lpAppRecDataList = lpAppNodeRec->SubNodeList2.Iterate()))
			{
				gcc_roster->number_of_records += (USHORT) (lpAppRecDataList->GetCount());
			}
		}
	}

	if (gcc_roster->number_of_records != 0)
	{
		/*
		 * Fill in the roster's pointer to the list of application record
		 * pointers.  The pointer list will begin at the memory location passed
		 * into this routine.
		 */
		gcc_roster->application_record_list = (PGCCApplicationRecord *)memory;

		/*
		 * Move the memory pointer past the list of record pointers.  This is
		 * where the first application record will be written.
		 */
		memory += gcc_roster->number_of_records * sizeof(PGCCApplicationRecord);

		/*
		 * Add to the data length the amount of memory necessary to hold the
		 * application record pointers.  Go ahead and add the amount of memory
		 * necessary to hold all of the GCCApplicationRecord structures.
		 */
		data_length += gcc_roster->number_of_records *
				            (sizeof(PGCCApplicationRecord) +
                             ROUNDTOBOUNDARY(sizeof(GCCApplicationRecord)));
		
		record_count = 0;
		m_NodeRecordList2.Reset();
	   	while (NULL != (lpAppNodeRec = m_NodeRecordList2.Iterate(&uid)))
		{
			/*
			 * Iterate through this node's record list, building an "API"
			 * application record for each record in the list.
			 */
			lpAppNodeRec->AppRecordList.Reset();
			while (NULL != (lpAppRecData = lpAppNodeRec->AppRecordList.Iterate(&eid)))
			{
				/*
				 * Set the application record pointer equal to the location in
				 * memory where it will be written.
				 */
				gcc_record = (PGCCApplicationRecord)memory;

				/*
				 * Save the pointer to the application record in the roster's
				 * list of record pointers.
				 */
				gcc_roster->application_record_list[record_count] = gcc_record;

				/*
				 * Get the GCC node ID from the node iterator.
				 */
				gcc_record->node_id = uid;

				/*
				 * Get the Entity ID from the record iterator.
				 */
				gcc_record->entity_id = eid;

				/*
				 * Fill in other application record elements.
				 */
				gcc_record->is_enrolled_actively = lpAppRecData->is_enrolled_actively;
				gcc_record->is_conducting_capable =	lpAppRecData->is_conducting_capable;
				gcc_record->startup_channel_type = lpAppRecData->startup_channel_type;
				gcc_record->application_user_id = lpAppRecData->application_user_id;

				/*
				 * Advance the memory pointer past the application record
				 * structure.  This is where the list of non-collapsing
				 * capabilities pointers will begin.  Round the memory location
				 * off to fall on an even four-byte boundary.
				 */
				memory += ROUNDTOBOUNDARY(sizeof(GCCApplicationRecord));

				/*
				 * Fill in the non-collapsing capabilities for this application
				 * record.
				 */
				capability_data_length = GetNonCollapsedCapabilitiesList(
											gcc_record,
											&lpAppRecData->non_collapsed_caps_list,
											memory);

				/*
				 * Add the amount of memory necessary to hold the list of
				 * capabilities and associated data to the overall length and
				 * move the memory pointer past the capabilities data.
				 */
				memory += capability_data_length;
				data_length += capability_data_length;

				/*
				 * Increment the record list array counter.
				 */
				record_count++;
			}
			
			/*
			 * Iterate through this node's sub-node record list, building an
			 * "API" application record for each record in the list.
			 */
			lpAppNodeRec->SubNodeList2.Reset();
			while (NULL != (lpAppRecDataList = lpAppNodeRec->SubNodeList2.Iterate(&uid2)))
			{
				/*
				 * Iterate through this node's record list.
				 */
				lpAppRecDataList->Reset();
				while (NULL != (lpAppRecData = lpAppRecDataList->Iterate(&eid)))
				{
					/*
					 * Set the application record pointer equal to the location
					 * in memory where it will be written.
					 */
					gcc_record = (PGCCApplicationRecord)memory;

					/*
					 * Save the pointer to the application record in the
					 * roster's list of record pointers.
					 */
					gcc_roster->application_record_list[record_count] = gcc_record;

					/*
					 * Get the node ID from the sub_node_iterator.
					 */
					gcc_record->node_id = uid2;

					/*
					 * Get the entity ID from the record_iterator.
					 */
					gcc_record->entity_id = eid;

					/*
					 * Fill in other application record elements.
					 */
					gcc_record->is_enrolled_actively = lpAppRecData->is_enrolled_actively;
					gcc_record->is_conducting_capable = lpAppRecData->is_conducting_capable;
					gcc_record->startup_channel_type = lpAppRecData->startup_channel_type;
					gcc_record->application_user_id = lpAppRecData->application_user_id;

					/*
					 * Advance the memory pointer past the application record
					 * structure.  This is where the list of non-collapsing
					 * capabilities pointers will begin.  Round the memory
					 * location	off to fall on an even four-byte boundary.
					 */
					memory += ROUNDTOBOUNDARY(sizeof(GCCApplicationRecord));

					/*
					 * Fill in the non-collapsing capabilities for this
					 * application record.  The memory pointer will be advanced
					 * past the capabilities list and data.
					 */
					capability_data_length = GetNonCollapsedCapabilitiesList(
													gcc_record,
													&lpAppRecData->non_collapsed_caps_list,
													memory);

					/*
					 * Add the amount of memory necessary to hold the list of
					 * capabilities and associated data to the overall length.
					 */
					memory += capability_data_length;
					data_length += capability_data_length;

					/*
					 * Increment the record list array counter.
					 */
					record_count++;
				}
			}
		}
	}
	else
	{
		/*
		 * There were no application records so set the pointer to the list
		 * of records to NULL and the data_length return value to zero.
		 */
		gcc_roster->application_record_list = NULL;
		data_length = 0;
	}

	return (data_length);
}


/*
 *	UINT	GetCapabilitiesList	()
 *
 *	Private Function Description
 *		This routine fills in the capabilities portion of the
 *		GCCAppicationRoster structure.
 *
 *	Formal Parameters
 *		gcc_roster -	(o) GCCApplicationRoster to be filled in
 *		memory		-	(o) Location in memory to begin writing records.
 *
 *	Return Value
 *		The total amount of data written into memory.
 *
 *	Side Effects
 *		none
 *
 *	Caveats
 *		none
 */
UINT CAppRoster::GetCapabilitiesList(
						PGCCApplicationRoster	gcc_roster,
						LPBYTE					memory)
{
	UINT								data_length = 0;
	UINT								capability_id_data_length = 0;
	UINT								capability_count;
	PGCCApplicationCapability			gcc_capability;
	APP_CAP_ITEM						*lpAppCapData;

	DebugEntry(CAppRoster::GetCapabilitiesList);

	/*
	 * Retrieve the number of capabilities for this roster and fill in any that
	 * are present.
	 */
	gcc_roster->number_of_capabilities = (USHORT) m_CollapsedCapListForAllNodes.GetCount();

	if (gcc_roster->number_of_capabilities != 0)
	{
		/*
		 * Fill in the roster's pointer to the list of application capability
		 * pointers.  The pointer list will begin at the memory location passed
		 * into this routine.
		 */
		gcc_roster->capabilities_list = (PGCCApplicationCapability *)memory;

		/*
		 * Move the memory pointer past the list of capability pointers.  This
		 * is where the first application capability structure will be written.
		 */
		memory += (Int)(gcc_roster->number_of_capabilities *
				sizeof(PGCCApplicationCapability));

		/*
		 * Add to the data length the amount of memory necessary to hold the
		 * application capability pointers.  Go ahead and add the amount of
		 * memory necessary to hold all of the GCCApplicationCapability
		 * structures.
		 */
		data_length += gcc_roster->number_of_capabilities *
				(sizeof(PGCCApplicationCapability) +
				ROUNDTOBOUNDARY ( sizeof(GCCApplicationCapability)) );

		capability_count = 0;
		m_CollapsedCapListForAllNodes.Reset();
	   	while (NULL != (lpAppCapData = m_CollapsedCapListForAllNodes.Iterate()))
		{
			/*
			 * Set the application capability pointer equal to the
			 * location in memory where it will be written.
			 */
			gcc_capability = (PGCCApplicationCapability)memory;
				
			/*
			 * Save the pointer to the application capability in the roster's
			 * list of application capability pointers.
			 */
			gcc_roster->capabilities_list[capability_count] =
													gcc_capability;
			
			/*
			 * Advance the memory pointer past the application capability
			 * structure.  This is where the string data for the capability ID
			 * will be written.  Ensure that the memory pointer falls on an
			 * even four-byte boundary.
			 */
			memory += (Int)(ROUNDTOBOUNDARY(sizeof(GCCApplicationCapability)));

			/*
			 * Retrieve the capability ID information from the internal
			 * CapabilityIDData object.  The length returned by this call will
			 * have already been rounded to an even multiple of four bytes.
			 */
			capability_id_data_length = lpAppCapData->pCapID->GetGCCCapabilityIDData(
												&gcc_capability->capability_id,
												memory);

			/*
			 * Advance the memory pointer past the string data written into
			 * memory by the capability ID object.  Add the length of the string
			 * data to the overall capability length.
			 */
			memory += (Int)capability_id_data_length;
			data_length += capability_id_data_length;

			/*
			 * Now fill in the rest of the capability.
			 */
			gcc_capability->capability_class.eType =lpAppCapData->eCapType;

			if (gcc_capability->capability_class.eType ==
									GCC_UNSIGNED_MINIMUM_CAPABILITY)
			{
				gcc_capability->capability_class.nMinOrMax = lpAppCapData->nUnsignedMinimum;
			}
			else if (gcc_capability->capability_class.eType == GCC_UNSIGNED_MAXIMUM_CAPABILITY)
			{
				gcc_capability->capability_class.nMinOrMax = lpAppCapData->nUnsignedMaximum;
			}

			gcc_capability->number_of_entities = lpAppCapData->cEntries;

			/*
			 * Increment the capability ID array counter.
			 */
			capability_count++;
		}
	}
	else
	{
		gcc_roster->capabilities_list = NULL;
	}

	return (data_length);
}


/*
 *	UINT	GetNonCollapsedCapabilitiesList	()
 *
 *	Private Function Description:
 *		This routine is used to fill in the "API" non-collapsing capabilities
 * 		portion of a GCCApplicationRoster from the data which is stored
 *		internally by this class.
 *
 *	Formal Parameters
 *		gcc_record	-		(o)		The application record to be filled in.
 *		pAppCapItemList 	(i)		The internal capabilities data.
 *		memory				(i/o)	The memory location to begin writing data.
 *
 *	Return Value
 *		The total amount of data written into memory.
 *
 *	Side Effects
 *		The memory pointer passed in will be advanced by the amount of memory
 *		necessary to hold the capabilities and their data.
 *
 *	Caveats
 *		none
 */
UINT CAppRoster::GetNonCollapsedCapabilitiesList(
					PGCCApplicationRecord				gcc_record,
					CAppCapItemList    					*pAppCapItemList,
					LPBYTE								memory)
{
	UINT								capability_count;
	PGCCNonCollapsingCapability			gcc_capability;
	APP_CAP_ITEM						*lpAppCapData;
	UINT								capability_id_length = 0;
	UINT								capability_data_length = 0;

	DebugEntry(CAppRoster::GetNonCollapsedCapabilitiesList);

	/*
	 * Get the number of non-collapsed capabilities.
	 */
	gcc_record->number_of_non_collapsed_caps = (USHORT) pAppCapItemList->GetCount();

	if (gcc_record->number_of_non_collapsed_caps != 0)
	{
		/*
		 * Fill in the record's pointer to the list of non-collapsing
		 * capabilities	pointers.  The pointer list will begin at the memory
		 * location passed into this routine.
		 */
		gcc_record->non_collapsed_caps_list = (PGCCNonCollapsingCapability *)memory;

		/*
		 * Move the memory pointer past the list of capability pointers.  This
		 * is where the first capability structure will be written.
		 */
		memory += (Int)(gcc_record->number_of_non_collapsed_caps *
				sizeof(PGCCNonCollapsingCapability));

		/*
		 * Add to the data length the amount of memory necessary to hold the
		 * capability pointers.  Go ahead and add the amount of memory necessary
		 * to hold all of the GCCNonCollapsingCapability structures.
		 */
		capability_data_length = gcc_record->number_of_non_collapsed_caps *
				(sizeof(PGCCNonCollapsingCapability) +
				ROUNDTOBOUNDARY(sizeof (GCCNonCollapsingCapability)));

		/*
		 * Iterate through this record's capabilities list, building an "API"
		 * non-collapsing capability for each capability in the list.
		 */
		capability_count = 0;
		pAppCapItemList->Reset();
		while (NULL != (lpAppCapData = pAppCapItemList->Iterate()))
		{
			/*
			 * Set the capability pointer equal to the location in memory where
			 * it will be written.
			 */
			gcc_capability = (PGCCNonCollapsingCapability)memory;

			/*
			 * Save the pointer to the capability in the record's list of
			 * capability pointers.
			 */
			gcc_record->non_collapsed_caps_list[capability_count] = gcc_capability;

			/*
			 * Move the memory pointer past the capability ID structure.  This
			 * is where the data associated with the structure will be written.
			 * Retrieve the capability ID data from the internal object, saving
			 * it in the "API" capability ID structure.
			 */
			memory += (Int)ROUNDTOBOUNDARY(sizeof(GCCNonCollapsingCapability));

			capability_id_length = lpAppCapData->pCapID->GetGCCCapabilityIDData(
							&gcc_capability->capability_id,	memory);

			/*
			 * Add to the data length the amount of memory necessary to hold the
			 * capability ID data.
			 */
			capability_data_length += capability_id_length;

			/*
			 * Move the memory pointer past the data filled in for the
			 * capability ID.  This is where the application data OSTR
			 * contained in the non-collapsing capability will be written, if
			 * one exists.  Note that the capability contains a pointer to a
			 * OSTR and therefore the OSTR structure as well
			 * as the string data must be written into memory.
			 */
			memory += capability_id_length;

			if (lpAppCapData->poszAppData != NULL)
			{
				/*
				 * Set the application data structure pointer equal to the
				 * location in memory where	it will be written.
				 */
				gcc_capability->application_data = (LPOSTR) memory;
				gcc_capability->application_data->length = lpAppCapData->poszAppData->length;

				/*
				 * Move the memory pointer past the OSTR structure
				 * and round it off to an even four-byte boundary.  This is
				 * where the actual string data will be written so set the
				 * structure string pointer equal to that location.
				 */
				memory += ROUNDTOBOUNDARY(sizeof(OSTR));
				gcc_capability->application_data->value =(LPBYTE)memory;

				/*
				 * Copy the actual application string data into memory.
				 */
				::CopyMemory(gcc_capability->application_data->value,
							lpAppCapData->poszAppData->value,
							lpAppCapData->poszAppData->length);

				/*
				 * Add to the data length the amount of memory necessary to
				 * hold the	application data structure and string.  The lengths
				 * will need to be aligned on a four-byte boundary	before
				 * adding them to the total length.
				 */
				capability_data_length += ROUNDTOBOUNDARY(sizeof(OSTR));
				capability_data_length += ROUNDTOBOUNDARY(gcc_capability->application_data->length);

				/*
				 * Move the memory pointer past the application string data.
				 * The memory pointer is then fixed up to ensure that it falls
				 * on an even four-byte boundary.
				 */
				memory += ROUNDTOBOUNDARY(lpAppCapData->poszAppData->length);
			}
			else
			{
				gcc_capability->application_data = NULL;
			}

			/*
			 * Increment the capability array counter.
			 */
			capability_count++;
		}
	}
	else
	{
		gcc_record->non_collapsed_caps_list = NULL;
		capability_data_length = 0;
	}

	return (capability_data_length);
}


/*
 *	void	FreeApplicationRosterData	()
 *
 *	Private Function Description:
 *		This routine is used to free up any data which was locked for an "API"
 *		application roster.
 *
 *	Formal Parameters
 *		none
 *
 *	Return Value
 *		none
 *
 *	Side Effects
 *		none
 *
 *	Caveats
 *		none
 */
void CAppRoster::FreeApplicationRosterData(void)
{
	APP_NODE_RECORD			*lpAppNodeRec;
	APP_RECORD  		    *lpAppRecData;
	APP_CAP_ITEM			*lpAppCapData;
	CAppRecordList2			*lpAppRecDataList;

	DebugEntry(CAppRoster::FreeApplicationRosterData);

	m_pSessionKey->UnLockSessionKeyData();

	/*
	 * Unlock the data associated with each non-collapsed capability by
	 * iterating through the list of application records at each node as well as
	 * the list of sub-node records at each node, calling "UnLock" for each
	 * CapabilityIDData associated with each cabability.
	 */
	m_NodeRecordList2.Reset();
	while (NULL != (lpAppNodeRec = m_NodeRecordList2.Iterate()))
	{
		lpAppNodeRec->AppRecordList.Reset();
		while (NULL != (lpAppRecData = lpAppNodeRec->AppRecordList.Iterate()))
		{
			lpAppRecData->non_collapsed_caps_list.Reset();
			while (NULL != (lpAppCapData = lpAppRecData->non_collapsed_caps_list.Iterate()))
			{
				lpAppCapData->pCapID->UnLockCapabilityIdentifierData ();
			}
		}

		lpAppNodeRec->SubNodeList2.Reset();
		while (NULL != (lpAppRecDataList = lpAppNodeRec->SubNodeList2.Iterate()))
		{
			lpAppRecDataList->Reset();
			while (NULL != (lpAppRecData = lpAppRecDataList->Iterate()))
			{
				lpAppRecData->non_collapsed_caps_list.Reset();
				while (NULL != (lpAppCapData = lpAppRecData->non_collapsed_caps_list.Iterate()))
				{
					lpAppCapData->pCapID->UnLockCapabilityIdentifierData();
				}
			}
		}
	}

	/*
	 * Iterate through the list of collapsed capabilities, unlocking the data
	 * for each CapabilityIDData object associated with each capability.
	 */
	m_CollapsedCapListForAllNodes.Reset();
	while (NULL != (lpAppCapData = m_CollapsedCapListForAllNodes.Iterate()))
	{
		lpAppCapData->pCapID->UnLockCapabilityIdentifierData();
	}
}


/*
 *	GCCError	AddRecord ()
 *
 *	Public Function Description
 *		This member function is responsible for inserting a new application
 *		record into the Roster. This routine will return a failure if the
 *		application record already exist.
 *
 *	Caveats
 *		Note that it is possible for a roster record (not application record)
 *		to already exist at this node if this is the second application
 *		entity to enroll at this node.
 */
GCCError CAppRoster::
AddRecord(GCCEnrollRequest *pReq, GCCNodeID nid, GCCEntityID eid)
{
	GCCError							rc = GCC_NO_ERROR;
	APP_NODE_RECORD						*node_record;
	APP_RECORD  					    *pAppRecord;
	CAppCapItemList						*pAppCapItemList;

	DebugEntry(CAppRoster::AddRecord);

	if (m_fPduIsFlushed)
	{
		FreeRosterUpdateIndicationPDU ();
		m_fPduIsFlushed = FALSE;
	}

	/*
	 * First create a roster entry for this user ID if one does not exists.
	 */
	if (NULL == (node_record = m_NodeRecordList2.Find(nid)))
	{
		DBG_SAVE_FILE_LINE
		node_record = new APP_NODE_RECORD;
		if (node_record != NULL)
		{
			m_NodeRecordList2.Append(nid, node_record);
		}
		else
		{
			ERROR_OUT(("CAppRoster: AddRecord: Resource Error Occured"));
			rc = GCC_ALLOCATION_FAILURE;
			goto MyExit;
		}
	}
	else
	{
		WARNING_OUT(("CAppRoster: AddRecord: Node Record is found"));
	}

	/*
	 * Check to make sure that the application record does not already exist..
	 */
	if ((NULL != node_record->AppRecordList.Find(eid)) ||
		(NULL != node_record->ListOfAppCapItemList2.Find(eid)))
	{
		WARNING_OUT(("AppRoster: AddRecord: Record already exists"));
		rc = GCC_INVALID_PARAMETER;
		goto MyExit;
	}

	//	Next create a record entry in the roster's app_record_list.
	DBG_SAVE_FILE_LINE
	pAppRecord = new APP_RECORD;
	if (NULL == pAppRecord)
	{
	    ERROR_OUT(("CAppRoster: AddRecord: can't create APP_RECORD"));
		rc = GCC_ALLOCATION_FAILURE;
		goto MyExit;
	}

	/*
	**	Here we must determine if an entry already exists at this
	**	node.  If so, only one entry can be conducting capable at a
	**	node.  Therefore, we set this variable based on this.  We use
	**	the "was_conducting_capable" variable to keep up with the
	**	original state incase the conducting capable node leaves the
	**	conference.
	*/
	pAppRecord->is_conducting_capable = pReq->fConductingCapable;

	APP_RECORD *p;
	node_record->AppRecordList.Reset();
	while (NULL != (p = node_record->AppRecordList.Iterate()))
	{
		if (p->is_conducting_capable)
		{
			pAppRecord->is_conducting_capable = FALSE;
			break;
		}
	}

	pAppRecord->was_conducting_capable = pReq->fConductingCapable;
	pAppRecord->is_enrolled_actively = pReq->fEnrollActively;
	pAppRecord->startup_channel_type = pReq->nStartupChannelType;
	pAppRecord->application_user_id = pReq->nUserID;

	if (pReq->cNonCollapsedCaps != 0)
	{
		rc = AddNonCollapsedCapabilities (
					&pAppRecord->non_collapsed_caps_list,
					pReq->cNonCollapsedCaps,
					pReq->apNonCollapsedCaps);
	    if (GCC_NO_ERROR != rc)
	    {
	        ERROR_OUT(("CAppRoster::AddRecord: can't add non collapsed caps, rc=%u", (UINT) rc));
	        delete pAppRecord;
	        goto MyExit;
	    }
	}

	//	Add the new record to the list of records at this node
	node_record->AppRecordList.Append(eid, pAppRecord);

    // from now on, we cannot free pAppRecord in case of error,
    // because it is now in the app record list.

	//	Increment the instance number.
	m_nInstance++;
	m_fPeerEntitiesAdded = TRUE;
	m_fRosterHasChanged = TRUE;

	//	Add an update to the PDU.
	rc = BuildApplicationRecordListPDU(APP_ADD_RECORD, nid, eid);
	if (GCC_NO_ERROR != rc)
	{
        ERROR_OUT(("CAppRoster::AddRecord: can't build app record list, rc=%u", (UINT) rc));
        goto MyExit;
	}

	if (pReq->cCollapsedCaps != 0)
	{
		/*
		**	Create a new capabilities list and insert it into the roster
		**	record list of capabilities.
		*/
		DBG_SAVE_FILE_LINE
		pAppCapItemList = new CAppCapItemList;
		if (NULL == pAppCapItemList)
		{
		    ERROR_OUT(("CAppRoster::AddRecord: can't create CAppCapItemList"));
			rc = GCC_ALLOCATION_FAILURE;
			goto MyExit;
		}

		rc = AddCollapsableCapabilities(pAppCapItemList,
										pReq->cCollapsedCaps,
										pReq->apCollapsedCaps);
		if (GCC_NO_ERROR != rc)
		{
		    ERROR_OUT(("CAppRoster::AddRecord: can't add collapsable caps, rc=%u", (UINT) rc));
		    delete pAppCapItemList;
		    goto MyExit;
		}

		//	Add list of capabilities to list at this node
		node_record->ListOfAppCapItemList2.Append(eid, pAppCapItemList);
		m_fCapabilitiesHaveChanged = TRUE;

        // from now on, we cannot free pAppCapItemList in case of error,
        // because it is now in the app cap item list

		//	Rebuild the collapsed capabilities list.
		MakeCollapsedCapabilitiesList();

		//	Build the capabilities refresh portion of the PDU.
		rc = BuildSetOfCapabilityRefreshesPDU();
		if (GCC_NO_ERROR != rc)
		{
		    ERROR_OUT(("CAppRoster::AddRecord: can't build set of cap refresh, rc=%u", (UINT) rc));
		    goto MyExit;
		}
	}

MyExit:

	DebugExitINT(CAppRoster::AddRecord, rc);
	return rc;
}


/*
 *	GCCError	AddCollapsableCapabilities ()
 *
 *	Private Function Description
 *		This routine takes API collapsed capabilities list data passed in
 *		through a local request and converts it to internal collapsed
 *		capabillities.
 *
 *	Formal Parameters
 *		pAppCapItemList     	-	(o)	Pointer to internal capabilites list
 *										to fill in.
 *		number_of_capabilities	-	(i)	Number of capabilities in the source
 *										list.
 *		capabilities_list		-	(i)	Pointer to source capabilities list.
 *
 *	Return Value
 *		GCC_NO_ERROR			-	No error occured.
 *		GCC_ALLOCATION_FAILURE	-	A resource error occured.
 *
 *	Side Effects
 *		The collapsed capabilities will be recalculated at this node after
 *		all the new caps are added.
 *
 *	Caveats
 *		none
 */
GCCError CAppRoster::AddCollapsableCapabilities (
		CAppCapItemList				*pAppCapItemList,
		UINT						number_of_capabilities,
		PGCCApplicationCapability	*capabilities_list)
{
	GCCError			rc = GCC_NO_ERROR;
	APP_CAP_ITEM		*pAppCapItem;
	UINT				i;
	BOOL    			capability_already_exists;

	DebugEntry(CAppRoster::AddCollapsableCapabilities);

	for (i = 0; i < number_of_capabilities; i++)
	{
		DBG_SAVE_FILE_LINE
		pAppCapItem = new APP_CAP_ITEM((GCCCapabilityType)
							capabilities_list[i]->capability_class.eType);
		if (pAppCapItem != NULL)
		{
			DBG_SAVE_FILE_LINE
			pAppCapItem->pCapID = new CCapIDContainer(&capabilities_list[i]->capability_id, &rc);
			if ((pAppCapItem->pCapID != NULL) && (rc == GCC_NO_ERROR))
			{
				APP_CAP_ITEM		*lpAppCapData;
				/*
				**	Here we check to make sure that this capability id does
				**	not alreay exists in the list.
				*/
				capability_already_exists = FALSE;
				pAppCapItemList->Reset();
				while (NULL != (lpAppCapData = pAppCapItemList->Iterate()))
				{
					if (*lpAppCapData->pCapID == *pAppCapItem->pCapID)
					{
						capability_already_exists = TRUE;
						delete pAppCapItem;
						break;
					}
				}

				if (capability_already_exists == FALSE)
				{	
					if (capabilities_list[i]->capability_class.eType ==
											GCC_UNSIGNED_MINIMUM_CAPABILITY)
					{
						pAppCapItem->nUnsignedMinimum =
								capabilities_list[i]->capability_class.nMinOrMax;
					}
					else if	(capabilities_list[i]->capability_class.eType
										== GCC_UNSIGNED_MAXIMUM_CAPABILITY)
					{
						pAppCapItem->nUnsignedMaximum = capabilities_list[i]->capability_class.nMinOrMax;
					}

					//	Since we have yet to collapse the capabilities set to 1
					pAppCapItem->cEntries = 1;

					//	Add this capability to the list
					pAppCapItemList->Append(pAppCapItem);
				}
			}
			else if (pAppCapItem->pCapID == NULL)
			{
				rc = GCC_ALLOCATION_FAILURE;
				goto MyExit;
			}
			else
			{
			    goto MyExit;
			}
		}
		else
		{
			rc = GCC_ALLOCATION_FAILURE;
			goto MyExit;
		}
	}

MyExit:

    if (GCC_NO_ERROR != rc)
    {
        delete pAppCapItem;
    }

	return rc;
}

/*
 *	GCCError	AddNonCollapsedCapabilities ()
 *
 *	Private Function Description
 *		This routine takes API non-collapsed capabilities list data passed in
 *		through a local request and converts it to internal non-collapsed
 *		capabillities.
 *
 *	Formal Parameters
 *		pAppCapItemList     	-	(o)	Pointer to internal non-collapsed
 *										capabilites list to fill in.
 *		number_of_capabilities	-	(i)	Number of non-collapsed capabilities in
 *										the source list.
 *		capabilities_list		-	(i)	Pointer to source non-collapsed
 *										capabilities list.
 *
 *	Return Value
 *		GCC_NO_ERROR					-	No error occured.
 *		GCC_INVALID_NON_COLLAPSED_CAP	-	Invalid non-collapsed capability.
 *		GCC_ALLOCATION_FAILURE			-	A resource error occured.
 *
 *	Side Effects
 *		none
 *
 *	Caveats
 *		none
 */
GCCError CAppRoster::AddNonCollapsedCapabilities (
				CAppCapItemList				*pAppCapItemList,
				UINT						number_of_capabilities,
				PGCCNonCollapsingCapability	*capabilities_list)
{
	GCCError			rc = GCC_NO_ERROR;
	APP_CAP_ITEM		*pAppCapItem;
	UINT				i;

	DebugEntry(CAppRoster::AddNonCollapsedCapabilities);

	for (i = 0; i < number_of_capabilities; i++)
	{
	    //
		// LONCHANC: Cap type is not set here.
		// for now, it is zero.
		//
		DBG_SAVE_FILE_LINE
		pAppCapItem = new APP_CAP_ITEM((GCCCapabilityType) 0);
		if (pAppCapItem != NULL)
		{
			DBG_SAVE_FILE_LINE
			pAppCapItem->pCapID = new CCapIDContainer(&capabilities_list[i]->capability_id, &rc);
			if (pAppCapItem->pCapID != NULL)
			{
				if (capabilities_list[i]->application_data != NULL)
				{
					if (NULL == (pAppCapItem->poszAppData = ::My_strdupO2(
							capabilities_list[i]->application_data->value,
							capabilities_list[i]->application_data->length)))
					{
						rc = GCC_ALLOCATION_FAILURE;
						goto MyExit;
					}
					else if (pAppCapItem->poszAppData->length > MAXIMUM_APPLICATION_DATA_LENGTH)
					{
						rc = GCC_INVALID_NON_COLLAPSED_CAP;
						goto MyExit;
					}
				}

				//	Add this capability to the list if no errors
				pAppCapItemList->Append(pAppCapItem);
			}
			else if (pAppCapItem->pCapID == NULL)
			{
				rc = GCC_ALLOCATION_FAILURE;
				goto MyExit;
			}
			else
			{
			    goto MyExit;
			}
		}
		else
		{
			rc = GCC_ALLOCATION_FAILURE;
			goto MyExit;
	    }
	}

MyExit:

    if (GCC_NO_ERROR != rc)
    {
        delete pAppCapItem;
    }

	return rc;
}


/*
 *	GCCError	RemoveRecord ()
 *
 *	Public Function Description
 *		This member function completely removes the specified record from the
 *		application roster.  This includes any capabilities associated with
 *		this record. It also takes care of keeping the Instance number and
 *		added and removed flags up to date.
 */
GCCError CAppRoster::RemoveRecord(GCCNodeID nid, GCCEntityID eid)
{
	GCCError				rc;
	APP_RECORD  		    *pAppRecord;
	APP_NODE_RECORD			*node_record;

	DebugEntry(CAppRoster::RemoveRecord);

	if (m_fPduIsFlushed)
	{
		FreeRosterUpdateIndicationPDU ();
		m_fPduIsFlushed = FALSE;
	}

	//	First see if the record is contained in the Roster_Record_List.
	if (NULL == (node_record = m_NodeRecordList2.Find(nid)))
	{
	    TRACE_OUT(("CAppRoster::RemoveRecord: can't find node record, nid=%u", (UINT) nid));
		rc = GCC_INVALID_PARAMETER;
		goto MyExit;
	}

	if (NULL == (pAppRecord = node_record->AppRecordList.Find(eid)))
	{
	    TRACE_OUT(("CAppRoster::RemoveRecord: can't find app record, eid=%u", (UINT) eid));
		rc = GCC_INVALID_PARAMETER;
		goto MyExit;
	}

	/*
	**	Here we must determine if any of the remaining APEs at this
	**	node should become conducting capable based on their role
	**	at the time they enrolled.  We only do this if the record
	**	that is being deleted was conducting capabile.
	*/
	if (pAppRecord->is_conducting_capable)
	{
		APP_RECORD  *p;
		EntityID    eid2;

		node_record->AppRecordList.Reset();
		while (NULL != (p = node_record->AppRecordList.Iterate(&eid2)))
		{
			/*
			**	Here we only deal with record entries other than the
			**	one being removed.
			*/
			if (eid2 != eid)
			{
				if (p->was_conducting_capable)
				{
					p->is_conducting_capable = TRUE;
					/*
					**	Set up the update PDU for this conducting
					**	capable change.
					*/
					rc = BuildApplicationRecordListPDU(APP_REPLACE_RECORD, nid, eid2);
					if (GCC_NO_ERROR != rc)
					{
                        ERROR_OUT(("CAppRoster::RemoveRecord: can't build app record list, rc=%u", (UINT) rc));
					    goto MyExit;
					}
					break;
				}
			}
		}
	}

	//	Now delete the record
	rc = DeleteRecord(nid, eid, TRUE);
	if (GCC_NO_ERROR != rc)
	{
	    WARNING_OUT(("CAppRoster::RemoveRecord: can't delete record, rc=%u", (UINT) rc));
        goto MyExit;
	}

	//	Increment the instance number.
	m_nInstance++;
	m_fPeerEntitiesRemoved = TRUE;
	m_fRosterHasChanged = TRUE;

	//	Add an update to the PDU.
	rc = BuildApplicationRecordListPDU(APP_DELETE_RECORD, nid, eid);
	if (GCC_NO_ERROR != rc)
	{
	    ERROR_OUT(("CAppRoster::RemoveRecord: can't build app record list, rc=%u", (UINT) rc));
        goto MyExit;
	}

	/*
	**	If the capabilities changed during the above processing
	**	we must	create a new collapsed capabilities list and
	**	build a new capability refresh PDU.
	*/
	if (m_fCapabilitiesHaveChanged)
	{
		MakeCollapsedCapabilitiesList();
		rc = BuildSetOfCapabilityRefreshesPDU();
		if (GCC_NO_ERROR != rc)
		{
    	    ERROR_OUT(("CAppRoster::RemoveRecord: can't build set of cap refreshes, rc=%u", (UINT) rc));
            goto MyExit;
		}
	}

MyExit:

	DebugExitINT(CAppRoster::RemoveRecord, rc);
	return rc;
}


/*
 *	GCCError	ReplaceRecord	()
 *
 *	Public Function Description
 *		This routine completely replaces the specified record's parameters
 *		with the new parameters passed in.  This includes the capabilities.
 */
GCCError CAppRoster::
ReplaceRecord(GCCEnrollRequest *pReq, GCCNodeID nid, GCCEntityID eid)
{
	GCCError				rc = GCC_NO_ERROR;
	BOOL    				capable_node_found;
	APP_NODE_RECORD			*node_record;
	APP_RECORD  		    *pAppRecord, *p;
	APP_CAP_ITEM			*lpAppCapData;
	CAppCapItemList         NonCollCapsList;

	DebugEntry(CAppRoster::ReplaceRecord);

	if (m_fPduIsFlushed)
	{
		FreeRosterUpdateIndicationPDU ();
		m_fPduIsFlushed = FALSE;
	}

	/*
	**	First determine if the node record does actually already exists. If not
	**	we return an error here.
	*/
	if (NULL == (node_record = m_NodeRecordList2.Find(nid)))
	{
	    ERROR_OUT(("CAppRoster::ReplaceRecord: can't find the node record for nid=%u", (UINT) nid));
		rc = GCC_INVALID_PARAMETER;
		goto MyExit;
	}

    // make sure the app record exists. if not, return an error
	if (NULL == (pAppRecord = node_record->AppRecordList.Find(eid)))
	{
	    ERROR_OUT(("CAppRoster::ReplaceRecord: can't find the app record for eid=%u", (UINT) eid));
		rc = GCC_INVALID_PARAMETER;
		goto MyExit;
	}

	/*
	**	First check to make sure that we can build the new record before
	**	replacing the old record.  The only entry we need to wory about
	**	here are the non-collapsing capabilities.
	*/
	if (pReq->cNonCollapsedCaps != 0)
	{
		rc = AddNonCollapsedCapabilities(&NonCollCapsList,
		                                pReq->cNonCollapsedCaps,
                                        pReq->apNonCollapsedCaps);
		if (GCC_NO_ERROR != rc)
		{
    	    ERROR_OUT(("CAppRoster::ReplaceRecord: can't add non collapsed caps, rc=%u", (UINT) rc));
    		goto MyExit;
		}
	}

	//	Now replace the record entries.
	pAppRecord->is_enrolled_actively = pReq->fEnrollActively;
	pAppRecord->was_conducting_capable = pReq->fConductingCapable;
	pAppRecord->startup_channel_type = pReq->nStartupChannelType;
	pAppRecord->application_user_id = pReq->nUserID;

	/*
	**	If the is conducting capable flag that was passed in was set
	**	to FALSE we can go ahead and set the internal is conducting
	**	capable flag to FALSE regardless of what the previous
	**	setting was.  If it was passed in TRUE we leave the previous
	**	setting alone.
	*/
	if (pAppRecord->was_conducting_capable == FALSE)
	{
		pAppRecord->is_conducting_capable = FALSE;
	}

	/*
	**	Here we delete the old non-collapsed capabilites and then
	**	add the new ones.
	*/
	if (! pAppRecord->non_collapsed_caps_list.IsEmpty())
	{
		pAppRecord->non_collapsed_caps_list.DeleteList();
		pAppRecord->non_collapsed_caps_list.Clear();
	}

	//	Copy the new non collapsed capabilities if any exists.
	if (pReq->cNonCollapsedCaps != 0)
	{
        while (NULL != (lpAppCapData = NonCollCapsList.Get()))
        {
            pAppRecord->non_collapsed_caps_list.Append(lpAppCapData);
        }
	}

    //
    // handling collapsing cap list
    //

	m_nInstance++;
	m_fRosterHasChanged = TRUE;
	rc = BuildApplicationRecordListPDU(APP_REPLACE_RECORD, nid, eid);
	if (rc != GCC_NO_ERROR)
	{
	    ERROR_OUT(("CAppRoster::ReplaceRecord: can't build app record list, rc=%u", (UINT) rc));
	    goto MyExi