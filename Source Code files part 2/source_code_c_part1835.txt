lete _pSoftkbdUIWnd;


    _pSoftkbdUIWnd = new CSoftkbdUIWnd(this, g_hInst, UIWINDOW_TOPMOST | UIWINDOW_WSDLGFRAME | UIWINDOW_HABITATINSCREEN);

    if ( _pSoftkbdUIWnd != NULL )
    {
        _pSoftkbdUIWnd->Initialize( );
        _pSoftkbdUIWnd->_CreateSoftkbdWindow(hOwner, Titlebar_type, xPos, yPos, width, height);
        
    }

    _iShow = 0;

CleanUp:
    return hr;
}

/*******************************************************************************
 *
 * Method function:  DestroySoftKeyboardWindow(  )                                        
 *
 * Destroy the soft keyboard window
 * 
 *
/********************************************************************************/

STDMETHODIMP CSoftKbd::DestroySoftKeyboardWindow()
{

    if ( _pSoftkbdUIWnd != NULL )
    {
        delete _pSoftkbdUIWnd;
        _pSoftkbdUIWnd = NULL;
    }

    return S_OK;
}

/*******************************************************************************
 *
 * Method function:  GetSoftKeyboardPosSize(  )                                        
 *
 * Return current soft keyboard window size and scrren position
 *
/********************************************************************************/

STDMETHODIMP CSoftKbd::GetSoftKeyboardPosSize(POINT *lpStartPoint, WORD *lpwidth, WORD *lpheight)
{

    HRESULT   hr;

    hr = S_OK;

    if ( _pSoftkbdUIWnd == NULL )
    {
    	hr = E_FAIL;
    	return hr;
    }

    if ( (lpStartPoint == NULL ) || ( lpwidth == NULL) || ( lpheight == NULL) )
    {
    	hr = E_FAIL;
    	return hr;
    }

    lpStartPoint->x = _xReal;
    lpStartPoint->y = _yReal;

    *lpwidth = (WORD)_widthReal;
    *lpheight = (WORD)_heightReal;

    return hr;
}

/*******************************************************************************
 *
 * Method function:  GetSoftKeyboardColors(  )                                        
 *
 * Return all different kinds of soft keyboard window colors.
 *
/********************************************************************************/

STDMETHODIMP CSoftKbd::GetSoftKeyboardColors(COLORTYPE colorType, COLORREF *lpColor)
{

    HRESULT   hr;

    hr = S_OK;

    if ( _pSoftkbdUIWnd == NULL )
    {
    	hr = E_FAIL;
    	return hr;
    }

    if ( lpColor == NULL )
    {
    	hr = E_FAIL;
    	return hr;
    }

    *lpColor = _color[colorType];

    return hr;
}

/*******************************************************************************
 *
 * Method function:  GetSoftKeyboardTypeMode(  )                                        
 *
 * Return current Soft keyboard 's typing mode.
 * this is for On Screen Keyboard.
 * 
 *
/********************************************************************************/

STDMETHODIMP CSoftKbd::GetSoftKeyboardTypeMode(TYPEMODE *lpTypeMode)
{
    HRESULT   hr;

    hr = S_OK;

    if ( _pSoftkbdUIWnd == NULL )
    {
    	hr = E_FAIL;
    	return hr;
    }

    if ( lpTypeMode == NULL )
    {
    	hr = E_FAIL;
    	return hr;
    }

    // 
    //

    return hr;
}

/*******************************************************************************
 *
 * Method function:  GetSoftKeyboardTextFont(  )                                        
 *
 * Return current soft keyboard label font data.
 * 
 *
/********************************************************************************/

STDMETHODIMP CSoftKbd::GetSoftKeyboardTextFont(LOGFONTW  *pLogFont)
{

    HRESULT   hr;

    hr = S_OK;

    if ( _pSoftkbdUIWnd == NULL )
    {
    	hr = E_FAIL;
    	return hr;
    }


    if ( pLogFont == NULL )
    {
    	hr = E_FAIL;
    	return hr;
    }

    if ( _plfTextFont )
    {
        CopyMemory(pLogFont, _plfTextFont, sizeof(LOGFONTW) );
    }
    else
        hr = S_FALSE;

    return hr;
}

STDMETHODIMP CSoftKbd::SetSoftKeyboardPosSize(POINT StartPoint, WORD width, WORD height)
{
    HRESULT   hr;

    hr = S_OK;

    if ( _pSoftkbdUIWnd == NULL )
    {
    	hr = E_FAIL;
    	return hr;
    }

    _xReal = StartPoint.x;
    _yReal = StartPoint.y;

    if ( width > 0 ) 
       _widthReal = width;

    if ( height > 0 )
       _heightReal = height;

    //
    // generate realKbdLayout
    //
    CHECKHR(_GenerateRealKbdLayout( ));

    _pSoftkbdUIWnd->Move(_xReal, _yReal, _widthReal, _heightReal);

    if ( _iShow & SOFTKBD_SHOW )
    {
         CHECKHR(ShowSoftKeyboard(_iShow));
    }

CleanUp:

    return hr;
}

STDMETHODIMP CSoftKbd::SetSoftKeyboardColors(COLORTYPE colorType, COLORREF Color)
{
    HRESULT   hr;

    hr = S_OK;

    if ( _pSoftkbdUIWnd == NULL )
    {
    	hr = E_FAIL;
    	return hr;
    }

    _color[colorType] = Color;

    if ( _iShow & SOFTKBD_SHOW )
    {
         CHECKHR(ShowSoftKeyboard(_iShow));
    }

CleanUp:

    return hr;
}

STDMETHODIMP CSoftKbd::SetSoftKeyboardTypeMode(TYPEMODE TypeMode)
{
    HRESULT   hr;

    hr = S_OK;

    if ( _pSoftkbdUIWnd == NULL )
    {
    	hr = E_FAIL;
    	return hr;
    }


    //
    //  Set type mode 
    //

    if ( _iShow & SOFTKBD_SHOW )
    {
         CHECKHR(ShowSoftKeyboard(_iShow));
    }

CleanUp:

    return hr;
}

STDMETHODIMP CSoftKbd::SetSoftKeyboardTextFont(LOGFONTW  *pLogFont)
{
    HRESULT   hr;

    hr = S_OK;

    if ( _pSoftkbdUIWnd == NULL )
    {
    	hr = E_FAIL;
    	return hr;
    }

    if ( pLogFont == NULL )
        return E_INVALIDARG;

    //
    // set font data
    //

    if ( _plfTextFont == NULL )
        _plfTextFont = (LOGFONTW  *)cicMemAllocClear( sizeof(LOGFONTW) );

    if ( _plfTextFont )
    {
        CopyMemory( _plfTextFont, pLogFont, sizeof(LOGFONTW) );

        _pSoftkbdUIWnd->UpdateFont( _plfTextFont );

        if ( _iShow & SOFTKBD_SHOW )
        {
            _pSoftkbdUIWnd->CallOnPaint( );
        }
    }
    else
        hr = E_OUTOFMEMORY;

    return hr;
}

STDMETHODIMP CSoftKbd::ShowKeysForKeyScanMode(KEYID *lpKeyID, INT iKeyNum, BOOL fHighL)
{
    HRESULT   hr;

    hr = S_OK;

    if ( _pSoftkbdUIWnd == NULL )
    {
    	hr = E_FAIL;
    	return hr;
    }



    return hr;
}

/*******************************************************************************
 *
 * Method function:  UnadviseSoftKeyboardEventSink(  )                                        
 *
 * Unadvise the previously advised soft keyboard event sink interface.
 *
/********************************************************************************/

STDMETHODIMP CSoftKbd::UnadviseSoftKeyboardEventSink(/*[in] */DWORD dwCookie)
{

    HRESULT         hr;
    KBDLAYOUTDES    *pKbdLayout;


    hr = S_OK;

    // we assume dwCookie stands for the real soft keyboard Id.

    if ( dwCookie == 0 )
    {
    	hr = E_FAIL;
    	return hr;
    }

    if ( dwCookie == DWCOOKIE_SFTKBDWNDES )
    {
         SafeReleaseClear( _pskbdwndes );
    	 return hr;
    }

    // Try to find the soft keyboard layout.

    pKbdLayout = _lpKbdLayoutDesList;

    while ( pKbdLayout != NULL ) {

    	if ( pKbdLayout->wKbdLayoutID == dwCookie )
    		break;

    	pKbdLayout = pKbdLayout->pNext;

    }

    
    if ( pKbdLayout == NULL ) 
    {
    	// 
    	// Cannot find this keyboard layout
    	//
    	hr = E_FAIL;
    	return hr;
    }


    if ( pKbdLayout->pskbes == NULL ) 
    {
    	// this event sink has not be registered.

    	hr = E_FAIL;

    	return hr;
    }

    SafeReleaseClear(pKbdLayout->pskbes);
    

    return hr;

}

/*******************************************************************************
 *
 * Method function:  AdviseSoftKeyboardEventSink(  )                                        
 *
 * Register soft keyboard event sink interface for the client of this component
 * 
 *
/********************************************************************************/

STDMETHODIMP CSoftKbd::AdviseSoftKeyboardEventSink(/*[in] */DWORD dwKeyboardId, /*[in]*/ REFIID riid, IUnknown *punk, /*[out] */DWORD *pdwCookie)
{

    HRESULT         hr;
    KBDLAYOUTDES    *pKbdLayout;

    *pdwCookie = 0;

    if ( ! IsEqualIID(riid, IID_ISoftKeyboardEventSink) && ! IsEqualIID(riid, IID_ISoftKbdWindowEventSink) )
    	return E_UNEXPECTED;


    if  ( IsEqualIID(riid, IID_ISoftKbdWindowEventSink) )
    {

        if ( _pskbdwndes != NULL )
    		return E_FAIL;

        CHECKHR(punk->QueryInterface(riid, (void **)&_pskbdwndes) );

    	if ( pdwCookie != NULL )
    		*pdwCookie = DWCOOKIE_SFTKBDWNDES;

    	return hr;
    }

    // check to see if specified soft keyboard layout is already generated.  

    pKbdLayout = _lpKbdLayoutDesList;

    while ( pKbdLayout != NULL ) {

    	if ( pKbdLayout->wKbdLayoutID == dwKeyboardId )
    		break;

    	pKbdLayout = pKbdLayout->pNext;

    }

    
    if ( pKbdLayout == NULL ) 
    {
    	// 
    	// Cannot find this keyboard layout
    	//
    	hr = E_FAIL;
    	return hr;
    }


    CHECKHR(punk->QueryInterface(riid, (void **)&(pKbdLayout->pskbes)) );

    if ( pdwCookie != NULL )
      *pdwCookie = dwKeyboardId;

CleanUp:
    return hr == S_OK ? S_OK : E_UNEXPECTED;

    
}

HRESULT CSoftKbd::_HandleTitleBarEvent( DWORD  dwId )
{

    HRESULT   hr = S_OK;

    // dwId stands for IconId or CloseId.

    // So far, we handle close button event only.

    if (dwId == KID_CLOSE)
    {
        if  (_pskbdwndes != NULL)
    		hr = _pskbdwndes->OnWindowClose( );
    }

    return hr;
}

HRESULT CSoftKbd::_HandleKeySelection(KEYID keyId)
{
    HRESULT        hr = S_OK;
    int            uKeyIndex, i;
    KBDLAYOUT     *realKbdLayout=NULL;
    KBDLAYOUTDES  *lpCurKbdLayout=NULL;
    ACTIVELABEL   *CurLabel=NULL;
    BOOL           fModifierSpecial = FALSE;
    
    lpCurKbdLayout = _lpCurKbdLayout;

    if ( lpCurKbdLayout == NULL ) return hr;

    // Get the KeyIndex in the current layout's key description

    realKbdLayout = &(lpCurKbdLayout->kbdLayout);

    if ( realKbdLayout == NULL ) return hr;

    CurLabel = _CurLabel;

    uKeyIndex = -1;

    for ( i=0; i<realKbdLayout->wNumberOfKeys; i++) {

        if ( keyId == realKbdLayout->lpKeyDes[i].keyId )
        {
            uKeyIndex = i;
            break;
        }
    }


    if ( uKeyIndex ==  -1 )
    {
        // It is not a legal key, it is impossible, we just stop here.
        return E_FAIL;
    }

    // set the modifier status

    MODIFYTYPE  tModifier;

    tModifier = realKbdLayout->lpKeyDes[uKeyIndex].tModifier;

    if ( tModifier != none ) 
    {
           lpCurKbdLayout->ModifierStatus ^= (1 << tModifier);
    }

    if (lpCurKbdLayout->pskbes != NULL )
    {

      int    j;
      WCHAR  *lpszLabel;
      WORD   wNumOfKeys;

      wNumOfKeys = realKbdLayout->wNumberOfKeys;


      // Try to get the label text for this key.

      for ( j=0; j< wNumOfKeys; j++ ) 
      {

          if ( CurLabel[j].keyId == keyId )
          {

             lpszLabel = CurLabel[j].lpLabelText;
             break;
          }

      }

      // Notify the client of key event.

      (lpCurKbdLayout->pskbes)->OnKeySelection(keyId, lpszLabel);

    }
    else 
    {
       // there is no event sink registered for this keyboard layout.
       // this must be a standard keyboard layout.

       // we will just simuate key stroke event for this key.

       if ( realKbdLayout->fStandard == TRUE )
       {

   	      BYTE        bVk, bScan;
   		  int         j, jIndex;
   		  BOOL        fExtendKey, fPictureKey;
          PICTUREKEY  *pPictureKeys;

   	      switch ( _wCurKbdLayoutID ) {

   	      case SOFTKBD_JPN_STANDARD :
   	      case SOFTKBD_JPN_ENHANCE  :
       	         pPictureKeys = gJpnPictureKeys;
   		         break;

   	      case SOFTKBD_US_STANDARD   :
   	      case SOFTKBD_US_ENHANCE    :
   	      case SOFTKBD_EURO_STANDARD :
   	      case SOFTKBD_EURO_ENHANCE  : 

                  pPictureKeys = gPictureKeys;
   		         break;
   		  }

   		  fPictureKey = FALSE;

   		  for ( j=0; j<NUM_PICTURE_KEYS; j++)
   		  {

   			  if ( pPictureKeys[j].uScanCode == keyId )
   			  {
   				  // This is a picture key.
   				  // it may be a extended key.

   				  jIndex = j;

   				  fPictureKey = TRUE;

   				  break;
   			  }

   		      if ( pPictureKeys[j].uScanCode == 0 )
   			  {
   			      // This is the last item in pPictureKeys.
   			      break;
   			  }

   		  }


   		  fExtendKey = FALSE;

   		  if ( fPictureKey )
   		  {
   			  if ( (keyId & 0xFF00) == 0xE000 )
   			  {
   				  fExtendKey = TRUE;
                  bScan = (BYTE)(keyId & 0x000000ff);
   			  }
              else
              {
                  fExtendKey = FALSE;
                  bScan = (BYTE)(keyId);
              }

   			  bVk = (BYTE)(pPictureKeys[jIndex].uVkey);

   			  if ( bVk == 0 )
   	             bVk = (BYTE)MapVirtualKeyEx((UINT)bScan, 1, lpCurKbdLayout->CurhKl);
    			 
   		  }
   		  else
   		  {

   		     bScan = (BYTE)keyId;
   	         bVk = (BYTE)MapVirtualKeyEx((UINT)bScan, 1, lpCurKbdLayout->CurhKl);
   		  }

   		  if ( tModifier == none ) 
   		  {

   			  if ( fExtendKey )
   			  {
   				  keybd_event(bVk, bScan, (DWORD)KEYEVENTF_EXTENDEDKEY, 0);
   				  keybd_event(bVk, bScan, (DWORD)(KEYEVENTF_EXTENDEDKEY | KEYEVENTF_KEYUP), 0);
   			  }
   			  else
   			  {
                  keybd_event(bVk, bScan, 0, 0);
  		          keybd_event(bVk, bScan, (DWORD)KEYEVENTF_KEYUP, 0);
   			  }

   			  // if the Shift Key is pressed, we need to release this key.
                
   			  if ( lpCurKbdLayout->ModifierStatus & MODIFIER_SHIFT)
   			  {
   			  	  fModifierSpecial = TRUE;
   				  lpCurKbdLayout->ModifierStatus &= ~((WORD)MODIFIER_SHIFT);
   				  // simulate the SHIFT-UP key event.

   				  keybd_event((BYTE)VK_SHIFT, (BYTE)KID_LSHFT, (DWORD)KEYEVENTF_KEYUP, 0);

   			  }

   			  // if the Ctrl Key is pressed, we need to release this key.
                
   			  if ( lpCurKbdLayout->ModifierStatus & MODIFIER_CTRL)
   			  {
   			  	  fModifierSpecial = TRUE;
   				  lpCurKbdLayout->ModifierStatus &= ~((WORD)MODIFIER_CTRL);
   				  // simulate the SHIFT-UP key event.

   				  keybd_event((BYTE)VK_CONTROL, (BYTE)KID_CTRL, (DWORD)KEYEVENTF_KEYUP, 0);

   			  }

   			  // if the Shift Key is pressed, we need to release this key.
            
   			  if ( lpCurKbdLayout->ModifierStatus & MODIFIER_ALT)
   			  {
   			  	  fModifierSpecial = TRUE;
   				  lpCurKbdLayout->ModifierStatus &= ~((WORD)MODIFIER_ALT);
   				  // simulate the SHIFT-UP key event.

   				  keybd_event((BYTE)VK_MENU, (BYTE)KID_ALT, (DWORD)KEYEVENTF_KEYUP, 0);

   			  }
   			  // if the Right Alt Key is pressed, we need to release this key.
            
   			  if ( lpCurKbdLayout->ModifierStatus & MODIFIER_ALTGR)
   			  {
   			  	  fModifierSpecial = TRUE;
   				  lpCurKbdLayout->ModifierStatus &= ~((WORD)MODIFIER_ALTGR);
   				  // simulate the SHIFT-UP key event.

   				  keybd_event((BYTE)VK_RMENU, (BYTE)KID_RALT, (DWORD)KEYEVENTF_KEYUP, 0);
   			  }

   		  }
   		  else
   		  {
   			  // specially handle Caps Lock
   			  if ( keyId == KID_CAPS ) 
   			  {
   				  // this is a togglable key
                  keybd_event(bVk, bScan, 0, 0);
                  keybd_event(bVk, bScan, (DWORD)KEYEVENTF_KEYUP, 0);
   			  }
              else if  (keyId == KID_KANA) 
              {
                  BYTE  pKeyState[256];

                  memset(pKeyState, 0, sizeof(pKeyState) );

                  if ( lpCurKbdLayout->ModifierStatus & (1 << tModifier) )
                      pKeyState[VK_KANA] = 0x01;
                  SetKeyboardState(pKeyState);
              }
   			  else
   			  {

   				  if ( lpCurKbdLayout->ModifierStatus & (1 << tModifier) ) {
   				     // This key is pressed now
   					  keybd_event(bVk, bScan, 0, 0);
                         
   				  }
   			      else
   				  {
   				  // This key is released now

                      keybd_event(bVk, bScan, (DWORD)KEYEVENTF_KEYUP, 0);
   				  }
   			  }
   		  }
   	   }
    }
    	  

    if ( (realKbdLayout->lpKeyDes[uKeyIndex].tModifier != none) || fModifierSpecial )
    {
       if ( realKbdLayout->fStandard == TRUE ) 
       {

           DWORD iModiCombState;
           DWORD iTmp;

           switch ( _wCurKbdLayoutID )  {

           case SOFTKBD_US_STANDARD   :
           case SOFTKBD_US_ENHANCE    :
                // this is for US Standard keyboard.
                // others may need to handle separately.

                iModiCombState = (lpCurKbdLayout->ModifierStatus) & (MODIFIER_CAPSLOCK | MODIFIER_SHIFT);
                iModiCombState = iModiCombState >> 1;

                // bit1 for Caps.
                // bit2 for Shift
                break;

           case SOFTKBD_EURO_STANDARD :
           case SOFTKBD_EURO_ENHANCE  :
                // this is for Euro 102 standard keyboard.
	            // How to map ModifierStatus -> CurModiState.
        
                // bit 1 for Caps, bit2 for Shift, bit3 for AltGr.

                iModiCombState = (lpCurKbdLayout->ModifierStatus) & ( MODIFIER_CAPSLOCK | MODIFIER_SHIFT );
                iModiCombState = iModiCombState >> 1;

	            iTmp = (lpCurKbdLayout->ModifierStatus) & MODIFIER_ALTGR;
	            iTmp = iTmp >> 4;

	            iModiCombState += iTmp;

	            break;
 
           case SOFTKBD_JPN_STANDARD  :
           case SOFTKBD_JPN_ENHANCE   :

	            // How to map ModifierStatus -> CurModiState.

                iModiCombState = (lpCurKbdLayout->ModifierStatus) & ( MODIFIER_CAPSLOCK | MODIFIER_SHIFT );
                iModiCombState = iModiCombState >> 1;

	            iTmp = (lpCurKbdLayout->ModifierStatus) & (MODIFIER_ALT | MODIFIER_KANA);
	            iTmp = iTmp >> 2;

	            iModiCombState += iTmp;

	            break;
           }


           SetKeyboardLabelTextCombination(iModiCombState);
           ShowSoftKeyboard(TRUE);

       }

    }

    return hr;

}

/*******************************************************************************
 *
 *  Method function: _UnicodeToUtf8( )
 *
 *  Convert unicode characters to UTF8.
 *
 *  Result is NULL terminated if sufficient space in result
 *   buffer is available.
 * 
 * Arguments:
 *
 *   pwUnicode   -- ptr to start of unicode buffer
 *   cchUnicode  -- length of unicode buffer
 *   pchResult   -- ptr to start of result buffer for UTF8 chars
 *   cchResult   -- length of result buffer
 *
 * Return Value:
 *
 *   Count of UTF8 characters in result, if successful.
 *   0 on error.  GetLastError() has error code.
 * 
 *
/********************************************************************************/

DWORD   CSoftKbd::_UnicodeToUtf8(PWCHAR pwUnicode, DWORD cchUnicode, PCHAR  pchResult, DWORD  cchResult)
{

    WCHAR   wch;                // current unicode character being converted
    DWORD   lengthUtf8 = 0;     // length of UTF8 result string
    WORD    lowSurrogate;
    DWORD   surrogateDword;


    //
    //  loop converting unicode chars until run out or error
    //

    Assert( cchUnicode > 0 );

    while ( cchUnicode-- )
    {
        wch = *pwUnicode++;

        //
        //  ASCII character (7 bits or less) -- converts to directly
        //

        if ( wch < 0x80 )
        {
            lengthUtf8++;

            if ( pchResult )
            {
                if ( lengthUtf8 >= cchResult )
                {
                    goto OutOfBuffer;
                }
                *pchResult++ = (CHAR)wch;
            }
            continue;
        }

        //
        //  wide character less than 0x07ff (11bits) converts to two bytes
        //      - upper 5 bits in first byte
        //      - lower 6 bits in secondar byte
        //

        else if ( wch <= UTF8_2_MAX )
        {
            lengthUtf8 += 2;

            if ( pchResult )
            {
                if ( lengthUtf8 >= cchResult )
                {
                    goto OutOfBuffer;
                }
                *pchResult++ = UTF8_1ST_OF_2 | wch >> 6;
                *pchResult++ = UTF8_TRAIL    | LOW6BITS( (UCHAR)wch );
            }
            continue;
        }

        //
        //  surrogate pair
        //      - if have high surrogate followed by low surrogate then
        //          process as surrogate pair
        //      - otherwise treat character as ordinary unicode "three-byte"
        //          character, by falling through to below
        //

        else if ( wch >= HIGH_SURROGATE_START &&
                  wch <= HIGH_SURROGATE_END &&
                  cchUnicode &&
                  (lowSurrogate = *pwUnicode) &&
                  lowSurrogate >= LOW_SURROGATE_START &&
                  lowSurrogate <= LOW_SURROGATE_END )
        {
            //  have a surrogate pair
            //      - pull up next unicode character (low surrogate of pair)
            //      - make full DWORD surrogate pair
            //      - then lay out four UTF8 bytes
            //          1st of four, then three trail bytes
            //              0x1111xxxx
            //              0x10xxxxxx
            //              0x10xxxxxx
            //              0x10xxxxxx

            pwUnicode++;
            cchUnicode--;
            lengthUtf8 += 4;

            if ( pchResult )
            {
                if ( lengthUtf8 >= cchResult )
                {
                    goto OutOfBuffer;
                }
                surrogateDword = (((wch-0xD800) << 10) + (lowSurrogate - 0xDC00) + 0x10000);

                *pchResult++ = UTF8_1ST_OF_4 | (UCHAR) (surrogateDword >> 18);
                *pchResult++ = UTF8_TRAIL    | (UCHAR) LOW6BITS(surrogateDword >> 12);
                *pchResult++ = UTF8_TRAIL    | (UCHAR) LOW6BITS(surrogateDword >> 6);
                *pchResult++ = UTF8_TRAIL    | (UCHAR) LOW6BITS(surrogateDword);

            }
        }

        //
        //  wide character (non-zero in top 5 bits) converts to three bytes
        //      - top 4 bits in first byte
        //      - middle 6 bits in second byte
        //      - low 6 bits in third byte
        //

        else
        {
            lengthUtf8 += 3;

            if ( pchResult )
            {
                if ( lengthUtf8 >= cchResult )
                {
                    goto OutOfBuffer;
                }
                *pchResult++ = UTF8_1ST_OF_3 | (wch >> 12);
                *pchResult++ = UTF8_TRAIL    | LOW6BITS( wch >> 6 );
                *pchResult++ = UTF8_TRAIL    | LOW6BITS( wch );
            }
        }
    }

    //
    //  NULL terminate buffer
    //  return UTF8 character count
    //

    if ( pchResult && lengthUtf8 < cchResult )
    {
        *pchResult = 0;
    }
    return( lengthUtf8 );

OutOfBuffer:

    SetLastError( ERROR_INSUFFICIENT_BUFFER );
    return( 0 );

}

/*******************************************************************************
 *
 * Method function _Utf8ToUnicode( ) 
 *
 * Convert UTF8 characters to unicode.
 *
 *   Result is NULL terminated if sufficient space in result
 *   buffer is available.
 * Arguments:
 *
 *   pwResult    -- ptr to start of result buffer for unicode chars
 *   cwResult    -- length of result buffer in WCHAR
 *   pwUtf8      -- ptr to start of UTF8 buffer
 *   cchUtf8     -- length of UTF8 buffer
 *
 * Return Value:
 *   Count of unicode characters in result, if successful.
 *   0 on error.  GetLastError() has error code.
 *
 *******************************************************************************/

DWORD   CSoftKbd::_Utf8ToUnicode(PCHAR  pchUtf8,   DWORD cchUtf8,    PWCHAR pwResult,  DWORD  cwResult)
{
    CHAR    ch;                     // current UTF8 character
    WCHAR   wch;                    // current unicode character
    DWORD   trailCount = 0;         // count of UTF8 trail bytes to follow
    DWORD   lengthUnicode = 0;      // length of unicode result string
    BOOL    bsurrogatePair = FALSE;
    DWORD   surrogateDword;


    //
    //  loop converting UTF8 chars until run out or error
    //

    Assert( cchUtf8 > 0 );

    while ( cchUtf8-- )
    {
        ch = *pchUtf8++;


        //
        //  ASCII character -- just copy
        //

        if ( BIT7(ch) == 0 )
        {
            lengthUnicode++;
            if ( pwResult )
            {
                if ( lengthUnicode >= cwResult )
                {
                   goto OutOfBuffer;
                }
                *pwResult++ = (WCHAR)ch;
            }
            continue;
        }

        //
        //  UTF8 trail byte
        //      - if not expected, error
        //      - otherwise shift unicode character 6 bits and
        //          copy in lower six bits of UTF8
        //      - if last UTF8 byte, copy result to unicode string
        //

        else if ( BIT6(ch) == 0 )
        {
            if ( trailCount == 0 )
            {
                goto InvalidUtf8;
            }

            if ( !bsurrogatePair )
            {
                wch <<= 6;
                wch |= LOW6BITS( ch );

                if ( --trailCount == 0 )
                {
                    lengthUnicode++;
                    if ( pwResult )
                    {
                        if ( lengthUnicode >= cwResult )
                        {
                            goto OutOfBuffer;
                        }
                        *pwResult++ = wch;
                    }
                }
                continue;
            }

            //  surrogate pair
            //      - same as above EXCEPT build two unicode chars
            //      from surrogateDword

            else
            {
                surrogateDword <<= 6;
                surrogateDword |= LOW6BITS( ch );

                if ( --trailCount == 0 )
                {
                    lengthUnicode += 2;

                    if ( pwResult )
                    {
                        if ( lengthUnicode >= cwResult )
                        {
                            goto OutOfBuffer;
                        }
                        surrogateDword -= 0x10000;
                        *pwResult++ = (WCHAR) ((surrogateDword >> 10) + HIGH_SURROGATE_START);
                        *pwResult++ = (WCHAR) ((surrogateDword & 0x3ff) + LOW_SURROGATE_START);
                    }
                    bsurrogatePair = FALSE;
                }
            }

        }

        //
        //  UTF8 lead byte
        //      - if currently in extension, error

        else
        {
            if ( trailCount != 0 )
            {
                goto InvalidUtf8;
            }

            //  first of two byte character (110xxxxx)

            if ( BIT5(ch) == 0 )
            {
                trailCount = 1;
                wch = LOW5BITS(ch);
                continue;
            }

            //  first of three byte character (1110xxxx)

            else if ( BIT4(ch) == 0 )
            {
                trailCount = 2;
                wch = LOW4BITS(ch);
                continue;
            }

            //  first of four byte surrogate pair (11110xxx)

            else if ( BIT3(ch) == 0 )
            {
                trailCount = 3;
                surrogateDword = LOW4BITS(ch);
                bsurrogatePair = TRUE;
            }

            else
            {
                goto InvalidUtf8;
            }
        }
    }

    //  catch if hit end in the middle of UTF8 multi-byte character

    if ( trailCount )
    {
        goto InvalidUtf8;
    }

    //
    //  NULL terminate buffer
    //  return the number of Unicode characters written.
    //

    if ( pwResult  &&  lengthUnicode < cwResult )
    {
        *pwResult = 0;
    }
    return( lengthUnicode );

OutOfBuffer:

    SetLastError( ERROR_INSUFFICIENT_BUFFER );
    return( 0 );

InvalidUtf8:

    SetLastError( ERROR_INVALID_DATA );
    return( 0 );

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\ctf\softkbd\nui.cpp ===
/**************************************************************************\
* Module Name: nui.cpp
*
* Copyright (c) 1985 - 2000, Microsoft Corporation
*
*  Lang Bar Items for  Soft Keyboard TIP.
*
* History:
*         28-March-2000  weibz     Created
\**************************************************************************/

#include "private.h"
#include "slbarid.h"
#include "globals.h"
#include "softkbdimx.h"
#include "nui.h"
#include "xstring.h"
#include "immxutil.h"
#include "helpers.h"
#include "mui.h"
#include "computil.h"


//+---------------------------------------------------------------------------
//
// ctor
//
//----------------------------------------------------------------------------

CLBarItem::CLBarItem(CSoftkbdIMX *pimx)
{

    WCHAR   wszToolTipText[MAX_PATH];

    Dbg_MemSetThisName(TEXT("CLBarItem"));

    LoadStringWrapW(g_hInst, IDS_SFTKBD_TIP_TEXT, wszToolTipText, MAX_PATH);

    InitNuiInfo(CLSID_SoftkbdIMX,
                GUID_LBI_SOFTKBDIMX_MODE,
                TF_LBI_STYLE_BTN_TOGGLE | TF_LBI_STYLE_SHOWNINTRAY, 
                0, 
                wszToolTipText);

    _pimx = pimx;

    SetToolTip(wszToolTipText);
    SetText(wszToolTipText);
    UpdateToggle();
}

//+---------------------------------------------------------------------------
//
// dtor
//
//----------------------------------------------------------------------------

CLBarItem::~CLBarItem()
{
}

//+---------------------------------------------------------------------------
//
// GetIcon
//
//----------------------------------------------------------------------------

STDAPI CLBarItem::GetIcon(HICON *phIcon)
{
    BOOL fOn = FALSE;

    fOn = _pimx->GetSoftKBDOnOff( );

    *phIcon = LoadSmIcon(g_hInst, MAKEINTRESOURCE(ID_ICON_STANDARD));

    return S_OK;
}


//+---------------------------------------------------------------------------
//
// OnLButtonUp
//
//----------------------------------------------------------------------------

HRESULT CLBarItem::OnLButtonUp(const POINT pt, const RECT *prcArea)
{
     return ToggleCompartmentDWORD(_pimx->_GetId(), 
                                   _pimx->_tim, 
                                   GUID_COMPARTMENT_HANDWRITING_OPENCLOSE, 
                                   FALSE);
}

//+---------------------------------------------------------------------------
//
// UpdateToggle
//
//----------------------------------------------------------------------------

void CLBarItem::UpdateToggle()
{
    DWORD dwHWState = 0;

    GetCompartmentDWORD(_pimx->_tim, 
                        GUID_COMPARTMENT_HANDWRITING_OPENCLOSE, 
                        &dwHWState,
                        FALSE);

    SetOrClearStatus(TF_LBI_STATUS_BTN_TOGGLED, dwHWState);
    if (_plbiSink)
        _plbiSink->OnUpdate(TF_LBI_STATUS);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\ctf\softkbd\softkbdc.h ===
/**************************************************************************\
* Module Name: softkbdc.h
*
* Copyright (c) 1985 - 2000, Microsoft Corporation
*
* Declaration of CSoftKbd 
*
* History:
*         28-March-2000  weibz     Created
\**************************************************************************/

#ifndef __SOFTKBDC_H_
#define __SOFTKBDC_H_

#include "resource.h"       

#include <windows.h>
#include "globals.h"
#include "SoftKbd.h"
#include "msxml.h"
#include "helpers.h"

#define   MAX_KEY_NUM   256

#define   NON_KEYBOARD  -1

#define   IdTimer_MonitorMouse  0x1000
#define   MONITORMOUSE_ELAPSE   8000

// we assume no keyboard has more than 256 keys

#define   KID_ICON          0x100
#define   KID_CLOSE         0x101

#define   DWCOOKIE_SFTKBDWNDES   0x2000

extern HINSTANCE  g_hInst;

#define  LABEL_TEXT    1
#define  LABEL_PICTURE 2

#define  LABEL_DISP_ACTIVE  1
#define  LABEL_DISP_GRAY    2

typedef struct tagActiveLabel {  // label for current active state.
    KEYID      keyId;
    WCHAR     *lpLabelText;
    WORD       LabelType;
    WORD       LabelDisp;
} ACTIVELABEL, *PACTIVELABEL;
 
typedef struct tagKeyLabels {  // labels for all states.
    KEYID     keyId;
    WORD      wNumModComb; // number of modifier combination states.
    BSTR      *lppLabelText;
    WORD      *lpLabelType;
    WORD      *lpLabelDisp;
                           // Every lppLabelText maps to one lpLabelType 
} KEYLABELS, *PKEYLABELS, FAR * LPKEYLABELS;

typedef struct tagKeyMap {

   WORD       wNumModComb;    // number of modifier combination states.
   WORD       wNumOfKeys;
   WCHAR      wszResource[MAX_PATH];  // Keep the resource file path if
                                      // any key has picture as its label
                                      //
   KEYLABELS  lpKeyLabels[MAX_KEY_NUM];

   HKL        hKl;
   struct tagKeyMap  *pNext;

} KEYMAP, *PKEYMAP, FAR * LPKEYMAP;

typedef struct tagKEYDES {

    KEYID       keyId;
    WORD        wLeft;  // relative to the left-top point of the layout window described in KEYBOARD.
    WORD        wTop;
    WORD        wWidth;
    WORD        wHeight;
    MODIFYTYPE  tModifier;
} KEYDES, FAR  * LPKEYDES;

typedef struct tagKbdLayout {

    WORD      wLeft;
    WORD      wTop;
    WORD      wWidth;
    WORD      wHeight;
    WORD      wMarginWidth;
    WORD      wMarginHeight;
    BOOL      fStandard;  // TRUE means this is a standard keyboard;
                          // FALSE means a user-defined keyboard layout.

    WORD      wNumberOfKeys;
    KEYDES    lpKeyDes[MAX_KEY_NUM];
   
} KBDLAYOUT, *PKBDLAYOUT, FAR * LPKBDLAYOUT;


typedef struct tagKbdLayoutDes {

    DWORD     wKbdLayoutID;
    WCHAR     KbdLayoutDesFile[MAX_PATH];
    ISoftKeyboardEventSink  *pskbes;
                  // Soft Keyboard Event Sink should be per Soft Keyboard.
    WORD     ModifierStatus;   // Every bit stands for one modifier's status
                               //
                               // CapsLock bit 1
                               // Shift    bit 2
                               // Ctrl     bit 3
                               // Alt      bit 4
                               // Kana     bit 5
                               // NumLock  bit 6
                               //
                               // Etc.
    KBDLAYOUT kbdLayout;

    KEYMAP    *lpKeyMapList;

    DWORD     CurModiState;
    HKL       CurhKl;

    struct tagKbdLayoutDes  *pNext;

} KBDLAYOUTDES, * PKBDLAYOUTDES, FAR * LPKBDLAYOUTDES;


class CSoftkbdUIWnd;

/////////////////////////////////////////////////////////////////////////////
// CSoftKbd
class CSoftKbd : 
    public CComObjectRoot_CreateInstance<CSoftKbd>,
    public ISoftKbd
{
public:
    CSoftKbd();
    ~CSoftKbd();

BEGIN_COM_MAP_IMMX(CSoftKbd)
    COM_INTERFACE_ENTRY(ISoftKbd)
END_COM_MAP_IMMX()

// ISoftKbd
public:

    STDMETHOD(Initialize)();
    STDMETHOD(EnumSoftKeyBoard)(/*[in]*/ LANGID langid, /*[out]*/ DWORD *lpdwKeyboard);
    STDMETHOD(SelectSoftKeyboard)(/*[in]*/ DWORD  dwKeyboardId);
    STDMETHOD(CreateSoftKeyboardLayoutFromXMLFile)(/*[in, string]*/ WCHAR  *lpszKeyboardDesFile, /*[in]*/ INT  szFileStrLen, /*[out]*/ DWORD *pdwLayoutCookie);
    STDMETHOD(CreateSoftKeyboardLayoutFromResource)(/*[in]*/ WCHAR *lpszResFile, /*[in, string] */ WCHAR  *lpszResType, /*[in, string] */ WCHAR *lpszXMLResString, /*[out] */ DWORD *lpdwLayoutCookie);
    STDMETHOD(ShowSoftKeyboard)(/*[in]*/ INT iShow);
    STDMETHOD(SetKeyboardLabelText)(/*[in]*/ HKL  hKl );
    STDMETHOD(SetKeyboardLabelTextCombination)(/*[in]*/ DWORD  nModifierCombination);
    STDMETHOD(CreateSoftKeyboardWindow)(/*[in]*/ HWND hOwner, /*in*/ TITLEBAR_TYPE Titlebar_type, /*[in]*/ INT xPos, /*[in]*/ INT yPos, /*[in]*/ INT width, /*[in]*/ INT height );
    STDMETHOD(DestroySoftKeyboardWindow)();
    STDMETHOD(GetSoftKeyboardPosSize)(/*[out]*/ POINT *lpStartPoint, /*[out]*/ WORD *lpwidth, /*[out]*/ WORD *lpheight);
    STDMETHOD(GetSoftKeyboardColors)(/*[in]*/ COLORTYPE  colorType,  /*[out]*/ COLORREF *lpColor);
    STDMETHOD(GetSoftKeyboardTypeMode)(/*[out]*/ TYPEMODE  *lpTypeMode);
    STDMETHOD(GetSoftKeyboardTextFont)(/*[out]*/ LOGFONTW  *pLogFont);
    STDMETHOD(SetSoftKeyboardPosSize)(/*[in]*/ POINT StartPoint, /*[in]*/ WORD width, /*[in]*/ WORD height);
    STDMETHOD(SetSoftKeyboardColors)(/*[in]*/ COLORTYPE  colorType, /*[in]*/ COLORREF Color);
    STDMETHOD(SetSoftKeyboardTypeMode)(/*[in]*/ TYPEMODE TypeMode);
    STDMETHOD(SetSoftKeyboardTextFont)(/*[in]*/ LOGFONTW  *pLogFont);
    STDMETHOD(ShowKeysForKeyScanMode)(/*[in]*/ KEYID  *lpKeyID, /*[in]*/ INT iKeyNum, /*[in]*/ BOOL fHighL);
    STDMETHOD(AdviseSoftKeyboardEventSink)(/* [in]*/DWORD dwKeyboardId,/*[in] */REFIID riid, /*[in, iid_is(riid)] */IUnknown *punk, /*[out] */DWORD *pdwCookie);
    STDMETHOD(UnadviseSoftKeyboardEventSink)(/*[in] */DWORD dwCookie);

    // Following public functions will be called by CSoftkbdUIWnd.

    HRESULT        _HandleKeySelection(KEYID keyId);
    HRESULT        _HandleTitleBarEvent( DWORD  dwId );

    KBDLAYOUTDES  *_GetCurKbdLayout( )   {  return _lpCurKbdLayout; }
    DWORD          _GetCurKbdLayoutID( ) {  return _wCurKbdLayoutID; }
    ACTIVELABEL   *_GetCurLabel(  )      {  return _CurLabel; }
    RECT          *_GetTitleBarRect( )   {  return &_TitleBarRect; }
    ISoftKbdWindowEventSink *_GetSoftKbdWndES( ) { return _pskbdwndes; }

private:    
    KBDLAYOUTDES  *_lpKbdLayoutDesList;
    KBDLAYOUTDES  *_lpCurKbdLayout;
    DWORD          _wCurKbdLayoutID;
    ACTIVELABEL    _CurLabel[MAX_KEY_NUM];
    HWND           _hOwner;
    CSoftkbdUIWnd *_pSoftkbdUIWnd;
    int            _xReal;
    int            _yReal;
    int            _widthReal;
    int            _heightReal;
    IXMLDOMDocument *_pDoc;

    COLORREF       _color[Max_color_Type];
    INT            _iShow;
    LOGFONTW       *_plfTextFont;

    WORD           _TitleButtonWidth;
    RECT           _TitleBarRect;
    TITLEBAR_TYPE  _TitleBar_Type;

    ISoftKbdWindowEventSink  *_pskbdwndes;

    HRESULT _CreateStandardSoftKbdLayout(DWORD  dwStdSoftKbdID, WCHAR  *wszStdResStr );
    HRESULT _GenerateRealKbdLayout( );
    HRESULT _SetStandardLabelText(LPBYTE pKeyState, KBDLAYOUT *realKbdLayut,
    									KEYMAP  *lpKeyMapList, int  iState);
    HRESULT _GenerateUSStandardLabel(  );
    HRESULT _GenerateUSEnhanceLabel(  );
    HRESULT _GenerateEuroStandardLabel(  );
    HRESULT _GenerateEuroEnhanceLabel(  );
    HRESULT _GenerateJpnStandardLabel(  );
    HRESULT _GenerateJpnEnhanceLabel(  );

    HRESULT _GenerateCurModiState(WORD *ModifierStatus, DWORD *CurModiState);

    HRESULT _GenerateMapDesFromSKD(BYTE *pMapTable, KEYMAP *lpKeyMapList);
    HRESULT _GenerateKeyboardLayoutFromSKD(BYTE  *lpszKeyboardDes, DWORD dwKbdLayoutID, KBDLAYOUTDES **lppKbdLayout);

    HRESULT _LoadDocumentSync(BSTR pBURL, BOOL   fFileName);
    HRESULT _ParseKeyboardLayout(BOOL   fFileName, WCHAR  *lpszKeyboardDesFile, DWORD dwKbdLayoutID, KBDLAYOUTDES **lppKbdLayout);
    HRESULT _ParseLayoutDescription(IXMLDOMNode *pLayoutChild,  KBDLAYOUT *pLayout);
    HRESULT _ParseMappingDescription(IXMLDOMNode *pLabelChild, KEYMAP *lpKeyMapList);
    HRESULT _GetXMLNodeValueWORD(IXMLDOMNode *pNode,  WORD  *lpWord);
    HRESULT _ParseOneKeyInLayout(IXMLDOMNode *pNode, KEYDES  *lpKeyDes);
    HRESULT _ParseOneKeyInLabel(IXMLDOMNode *pNode, KEYLABELS  *lpKeyLabels);

    DWORD   _UnicodeToUtf8(PWCHAR pwUnicode, DWORD cchUnicode, PCHAR  pchResult, DWORD  cchResult);
    DWORD   _Utf8ToUnicode(PCHAR  pchUtf8,   DWORD cchUtf8,    PWCHAR pwResult,  DWORD  cwResult);
};


// 
// Following are the definition for some XML node and attribute names.
//

#define   xSOFTKBDDES    L"softKbdDes"  

#define   xSOFTKBDTYPE   L"softkbdtype"
#define   xTCUSTOMIZED   L"customized"
#define   xTSTANDARD     L"standard"

#define   xWIDTH         L"width"
#define   xHEIGHT        L"height"
#define   xMARGIN_WIDTH  L"margin_width"
#define   xMARGIN_HEIGHT L"margin_height"
#define   xKEYNUMBER     L"keynumber"
#define   xKEY           L"key"

#define   xMODIFIER      L"modifier"
#define   xNONE          L"none"
#define   xCAPSLOCK      L"CapsLock"
#define   xSHIFT         L"Shift"
#define   xCTRL          L"Ctrl"
#define   xATL           L"Alt"
#define   xKANA          L"Kana"
#define   xALTGR         L"AltGr"
#define   xNUMLOCK       L"NumLock"

#define   xKEYID         L"keyid"
#define   xLEFT          L"left"
#define   xTOP           L"top"


#define   xVALIDSTATES   L"validstates"
#define   xKEYLABEL      L"keylabel"
#define   xLABELTEXT     L"labeltext"
#define   xLABELTYPE     L"labeltype"
#define   xTEXT          L"text"

#define   xLABELDISP     L"labeldisp"
#define   xGRAY          L"gray"
#define   xRESOURCEFILE  L"resourcefile"


//
//  Macros to simplify UTF8 conversions
//

#define UTF8_1ST_OF_2     0xc0      //  110x xxxx
#define UTF8_1ST_OF_3     0xe0      //  1110 xxxx
#define UTF8_1ST_OF_4     0xf0      //  1111 xxxx
#define UTF8_TRAIL        0x80      //  10xx xxxx

#define UTF8_2_MAX        0x07ff    //  max unicode character representable in
                                    //  in two byte UTF8

#define BIT7(ch)        ((ch) & 0x80)
#define BIT6(ch)        ((ch) & 0x40)
#define BIT5(ch)        ((ch) & 0x20)
#define BIT4(ch)        ((ch) & 0x10)
#define BIT3(ch)        ((ch) & 0x08)

#define LOW6BITS(ch)    ((ch) & 0x3f)
#define LOW5BITS(ch)    ((ch) & 0x1f)
#define LOW4BITS(ch)    ((ch) & 0x0f)


//
//  Surrogate pair support
//  Two unicode characters may be linked to form a surrogate pair.
//  And for some totally unknown reason, some person thought they
//  should travel in UTF8 as four bytes instead of six.
//  No one has any idea why this is true other than to complicate
//  the code.
//

#define HIGH_SURROGATE_START  0xd800
#define HIGH_SURROGATE_END    0xdbff
#define LOW_SURROGATE_START   0xdc00
#define LOW_SURROGATE_END     0xdfff



#endif //__SOFTKBDC_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\ctf\softkbd\softkbdes.cpp ===
/**************************************************************************\
* Module Name: softkbdes.cpp
*
* Copyright (c) 1985 - 2000, Microsoft Corporation
*
* Soft Keyboard Event Sink for the Symbol layout 
*
* History:
*         28-March-2000  weibz     Created
\**************************************************************************/

#include "private.h"
#include "globals.h"
#include "immxutil.h"
#include "proputil.h"
#include "helpers.h"
#include "editcb.h"
#include "dispattr.h"
#include "computil.h"
#include "regsvr.h"

#include "Softkbdimx.h"
#include "SoftKbdES.h"

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

CSoftKeyboardEventSink::CSoftKeyboardEventSink(CSoftkbdIMX *pSoftKbdIMX, 
                                               DWORD        dwSoftLayout)
{
     _pSoftKbdIMX = pSoftKbdIMX;
     _dwSoftLayout= dwSoftLayout;

     _fCaps = FALSE;
     _fShift= FALSE;
     
     _tid = pSoftKbdIMX->_tid;
     _tim = pSoftKbdIMX->_tim;

     _tim->AddRef( );
    
     _cRef = 1;
}

CSoftKeyboardEventSink::~CSoftKeyboardEventSink()
{

    SafeReleaseClear(_tim);

}


//+---------------------------------------------------------------------------
//
// IUnknown
//
//----------------------------------------------------------------------------

STDAPI CSoftKeyboardEventSink::QueryInterface(REFIID riid, void **ppvObj)
{
    *ppvObj = NULL;

    if (IsEqualIID(riid, IID_IUnknown) ||
        IsEqualIID(riid, IID_ISoftKeyboardEventSink))
    {
        *ppvObj = SAFECAST(this, CSoftKeyboardEventSink *);
    }

    if (*ppvObj)
    {
        AddRef();
        return S_OK;
    }

    return E_NOINTERFACE;
}

STDAPI_(ULONG) CSoftKeyboardEventSink::AddRef()
{
    return ++_cRef;
}

STDAPI_(ULONG) CSoftKeyboardEventSink::Release()
{
    long cr;

    cr = --_cRef;
    Assert(cr >= 0);

    if (cr == 0)
    {
        delete this;
    }

    return cr;
}

//
//  ISoftKeyboardEventSink
//


STDAPI CSoftKeyboardEventSink::OnKeySelection(KEYID KeySelected, WCHAR  *lpszLabel)
{

    ITfContext   *pic;
    HRESULT      hr;
    CEditSession *pes;

    hr = S_OK;

    switch ( KeySelected )
    {

      case  KID_CTRL  :
      case  KID_ALT   :
                      // doesn't handle
                      // just return
                     break;

      case  KID_CAPS  :

                     _fCaps = !_fCaps;

                     if ( _fCaps == _fShift )
                        // use state 0
                        (_pSoftKbdIMX->_KbdSymbol).dwCurLabel = 0; 

                     else
                        // use state 1

                        (_pSoftKbdIMX->_KbdSymbol).dwCurLabel = 1;

                     hr = SetCompartmentDWORD(_tid, _tim, GUID_COMPARTMENT_SOFTKBD_KBDLAYOUT, _dwSoftLayout, FALSE);

                     break;

      case  KID_LSHFT :
      case  KID_RSHFT :
                     
                     _fShift = !_fShift;

                     if ( _fCaps == _fShift )
                        // use state 0
                         
                        (_pSoftKbdIMX->_KbdSymbol).dwCurLabel = 0;

                     else
                        // use state 1

                        (_pSoftKbdIMX->_KbdSymbol).dwCurLabel = 1;

                     hr = SetCompartmentDWORD(_tid, _tim, GUID_COMPARTMENT_SOFTKBD_KBDLAYOUT, _dwSoftLayout, FALSE);

                     break;

      case  KID_F1  :
      case  KID_F2  :
      case  KID_F3  :
      case  KID_F4  :
      case  KID_F5  :
      case  KID_F6  :
      case  KID_F7  :
      case  KID_F8  :
      case  KID_F9  :
      case  KID_F10 :
      case  KID_F11 :
      case  KID_F12 :
      case  KID_TAB :

                      // simulate a key event and send to system.

      case  KID_ENTER :
      case  KID_ESC   :
      case  KID_SPACE :
      case  KID_BACK  :
      case  KID_UP    :
      case  KID_DOWN  :
      case  KID_LEFT  :
      case  KID_RIGHT :

    	  	  {

    		      BYTE        bVk, bScan;
    		      int         j, jIndex;
    		      KEYID       keyId;
    		      BOOL        fExtendKey, fPictureKey;

    		      keyId = KeySelected;
    		      fPictureKey = FALSE;

    		      for ( j=0; j<NUM_PICTURE_KEYS; j++)
    			  {

    			      if ( gPictureKeys[j].uScanCode == keyId )
    				  {
    				      // This is a picture key.
    				      // it may be a extended key.

    				     jIndex = j;

    				     fPictureKey = TRUE;

    				     break;
    				  }

    		          if ( gPictureKeys[j].uScanCode == 0 )
    				  {
    			         // This is the last item in gPictureKeys.
    			         break;
    				  }

    			  }


    		      fExtendKey = FALSE;

    		      if ( fPictureKey )
    			  {
    			      if ( (keyId & 0xFF00) == 0xE000 )
    				  {
    				      fExtendKey = TRUE;
                          bScan = (BYTE)(keyId & 0x000000ff);
    				  }
                      else
                          bScan = (BYTE)keyId;

     			      bVk = (BYTE)(gPictureKeys[jIndex].uVkey);
    			  }
    		      else
    			  {

    		         bScan = (BYTE)keyId;
    	             bVk = (BYTE)MapVirtualKeyEx((UINT)bScan, 1, 0);
    			  }

    		      if ( fExtendKey )
    			  {
    			     keybd_event(bVk, bScan, (DWORD)KEYEVENTF_EXTENDEDKEY, 0);
    			     keybd_event(bVk, bScan, (DWORD)(KEYEVENTF_EXTENDEDKEY | KEYEVENTF_KEYUP), 0);
    			  }
    		      else
    			  {
                     keybd_event(bVk, bScan, 0, 0);
    		         keybd_event(bVk, bScan, (DWORD)KEYEVENTF_KEYUP, 0);
    			  }

    		      break;
    		  }

      default         :


              if ( lpszLabel == NULL )
              {
                 hr = E_FAIL;

                 return hr;
              }

              pic = _pSoftKbdIMX->GetIC( );

              if ( pic == NULL )
              {
                  return hr;
              }

              if (pes = new CEditSession(CSoftkbdIMX::_EditSessionCallback))
              {

                 WCHAR   *lpLabel;
                 int     i, iLen;

                 iLen = (int) wcslen(lpszLabel);
                 lpLabel = (WCHAR *)cicMemAllocClear((iLen+1)*sizeof(WCHAR));
                
                 if ( lpLabel == NULL )
                 {
                    // not enough memory.

                    hr = E_OUTOFMEMORY;
                    return hr;
                 }

                 for ( i=0; i<iLen; i++)
                     lpLabel[i] = lpszLabel[i];

                 lpLabel[iLen] = L'\0';

                 pes->_state.u = ESCB_KEYLABEL;
                 pes->_state.pv = _pSoftKbdIMX;
                 pes->_state.wParam = (WPARAM)KeySelected;
                 pes->_state.lParam = (LPARAM)lpLabel;
                 pes->_state.pic = pic;
    	         pes->_state.pv1 = NULL;

                 pic->RequestEditSession(_pSoftKbdIMX->_tid, 
                                  pes, 
                                  TF_ES_READWRITE, 
                                  &hr);

                 if ( FAILED(hr) )
                 {
                     SafeFreePointer(lpLabel);
                 }

                 SafeRelease(pes);

              }
              else
    	         hr = E_FAIL;

    		  SafeRelease(pic);

              break;
    }
 
    return hr;

}


CSoftKbdWindowEventSink::CSoftKbdWindowEventSink(CSoftkbdIMX *pSoftKbdIMX) 
{
                                               
     _pSoftKbdIMX = pSoftKbdIMX;
   
     _cRef = 1;
}

CSoftKbdWindowEventSink::~CSoftKbdWindowEventSink()
{

}


//+---------------------------------------------------------------------------
//
// IUnknown
//
//----------------------------------------------------------------------------

STDAPI CSoftKbdWindowEventSink::QueryInterface(REFIID riid, void **ppvObj)
{
    *ppvObj = NULL;

    if (IsEqualIID(riid, IID_IUnknown) ||
        IsEqualIID(riid, IID_ISoftKbdWindowEventSink))
    {
        *ppvObj = SAFECAST(this, CSoftKbdWindowEventSink *);
    }

    if (*ppvObj)
    {
        AddRef();
        return S_OK;
    }

    return E_NOINTERFACE;
}

STDAPI_(ULONG) CSoftKbdWindowEventSink::AddRef()
{
    return ++_cRef;
}

STDAPI_(ULONG) CSoftKbdWindowEventSink::Release()
{
    long cr;

    cr = --_cRef;
    Assert(cr >= 0);

    if (cr == 0)
    {
        delete this;
    }

    return cr;
}

//
//  ISoftKbdWindowEventSink
//


STDAPI CSoftKbdWindowEventSink::OnWindowClose( )
{

    HRESULT   hr = S_OK;

    if ( _pSoftKbdIMX != NULL )
    	_pSoftKbdIMX->SetSoftKBDOnOff(FALSE);

    return hr;
}

STDAPI CSoftKbdWindowEventSink::OnWindowMove(int xWnd, int yWnd, int width, int height)
{

    HRESULT   hr = S_OK;

    if ( _pSoftKbdIMX != NULL )
        _pSoftKbdIMX->SetSoftKBDPosition(xWnd, yWnd);

// support size change later.
    UNREFERENCED_PARAMETER(width);
    UNREFERENCED_PARAMETER(height);

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\ctf\softkbd\softkbdes.h ===
// SoftKbdES.h: interface for the SoftKeyboardEventSink class.
//
//////////////////////////////////////////////////////////////////////
#ifndef __SOFTKBDES_H__
#define __SOFTKBDES_H__

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#include "softkbd.h"

class CSoftkbdIMX;


class CSoftKeyboardEventSink : public ISoftKeyboardEventSink  
{
public:
    CSoftKeyboardEventSink(CSoftkbdIMX *pSoftKbdIMX, DWORD dwSoftLayout);
    ~CSoftKeyboardEventSink();

    //
    // IUnknown methods
    //
    STDMETHODIMP QueryInterface(REFIID riid, void **ppvObj);
    STDMETHODIMP_(ULONG) AddRef(void);
    STDMETHODIMP_(ULONG) Release(void);

    //
    // ISoftKeyboardEventSink
    //

    STDMETHODIMP OnKeySelection(KEYID KeySelected, WCHAR  *lpszLabel);

//    void SetTidDim(TfClientId tid, ITfDocumentMgr *dim);
//    void ReleaseTidDim( );

private:

    long          _cRef;
    DWORD         _dwSoftLayout;
    CSoftkbdIMX  *_pSoftKbdIMX;
    BOOL          _fCaps;
    BOOL          _fShift;
    TfClientId    _tid;
    ITfThreadMgr *_tim;

};


class CSoftKbdWindowEventSink : public ISoftKbdWindowEventSink  
{
public:
    CSoftKbdWindowEventSink(CSoftkbdIMX *pSoftKbdIMX);
    ~CSoftKbdWindowEventSink();

    //
    // IUnknown methods
    //
    STDMETHODIMP QueryInterface(REFIID riid, void **ppvObj);
    STDMETHODIMP_(ULONG) AddRef(void);
    STDMETHODIMP_(ULONG) Release(void);

    //
    // ISoftKbdWindowEventSink
    //

    STDMETHODIMP OnWindowClose( );
    STDMETHODIMP OnWindowMove( int xWnd,int yWnd, int width, int height);

private:

    long          _cRef;
    CSoftkbdIMX  *_pSoftKbdIMX;
};
#endif //
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\ctf\softkbd\softkbdimx.cpp ===
/**************************************************************************\
* Module Name: softkbdimx.cpp
*
* Copyright (c) 1985 - 2000, Microsoft Corporation
*
* Implement TIP interface for Soft Keyboard Input. 
*
* History:
*         28-March-2000  weibz     Created
\**************************************************************************/

#include "private.h"
#include "softkbdimx.h"
#include "globals.h"
#include "immxutil.h"
#include "proputil.h"
#include "funcprv.h"
#include "helpers.h"
#include "editcb.h"
#include "dispattr.h"
#include "computil.h"
#include "timsink.h"
#include "ats.h"
#include "lpns.h"
#include "regsvr.h"

#include "softkbdes.h"

#include "mui.h"
#include "regimx.h"
#include "xstring.h"
#include "cregkey.h"

extern REGTIPLANGPROFILE c_rgProf[];

// Implementation of CSoftkbdRegistry.
//+---------------------------------------------------------------------------
//
// ctor
//
//----------------------------------------------------------------------------
CSoftkbdRegistry::CSoftkbdRegistry()
{
   extern void DllAddRef(void);

   m_fInitialized = FALSE;

   DllAddRef( );
}

//+---------------------------------------------------------------------------
//
// dtor
//
//----------------------------------------------------------------------------

CSoftkbdRegistry::~CSoftkbdRegistry()
{
    extern void DllRelease(void);

    if (m_rgLang.Count())
        m_rgLang.Clear();

    DllRelease();
}

// Generate the Current Lang Profile List from registry.

HRESULT CSoftkbdRegistry::_GenerateCurrentLangProfileList( )
{
    HRESULT hr = S_OK;
    CComPtr<IEnumTfLanguageProfiles>  cpEnumTfLangProf;

    if ( m_fInitialized == FALSE)
    {
        hr = CoCreateInstance(CLSID_TF_InputProcessorProfiles, NULL,
                              CLSCTX_INPROC_SERVER,
                              IID_ITfInputProcessorProfilesEx, (void**)&m_cpInputProcessorProfiles);

        // Load profile name from resource.
        LoadStringWrapW(g_hInst, IDS_SFTKBD_STANDARD_PROFILE, m_pwszStandard, 128);
        LoadStringWrapW(g_hInst, IDS_SFTKBD_SYMBOL_PROFILE, m_pwszSymbol, 128);

        char szFilePath[MAX_PATH];
        GetModuleFileName(g_hInst, szFilePath, ARRAYSIZE(szFilePath));
        StringCchCopyW(m_pwszIconFile, ARRAYSIZE(m_pwszIconFile), AtoW(szFilePath));

       if ( hr == S_OK )
            m_fInitialized = TRUE;
    }

    if (hr == S_OK)
    {
        LONG      lret = ERROR_SUCCESS;
        CMyRegKey regkey;

        if (m_rgLang.Count())
            m_rgLang.Clear();

        // Get the Language profile list for all languages.

        char  szSoftkbdLangProfKey[MAX_PATH];
        char  szClsidStr[64];

        StringCchCopyA(szSoftkbdLangProfKey, ARRAYSIZE(szSoftkbdLangProfKey), c_szCTFTIPKey);
        CLSIDToStringA(CLSID_SoftkbdIMX, szClsidStr);
        StringCchCatA(szSoftkbdLangProfKey, ARRAYSIZE(szSoftkbdLangProfKey), szClsidStr);
        StringCchCatA(szSoftkbdLangProfKey, ARRAYSIZE(szSoftkbdLangProfKey), "\\");
        StringCchCatA(szSoftkbdLangProfKey, ARRAYSIZE(szSoftkbdLangProfKey), c_szLanguageProfileKey);

		lret = regkey.Open(HKEY_LOCAL_MACHINE,
                           szSoftkbdLangProfKey,
                           KEY_READ);

        if ( ERROR_SUCCESS == lret )
        {
            char      szProfileName[MAX_PATH];
            char      szLangIdName[MAX_PATH];
            DWORD     dwIndex = 0;
            LANGID    langid;
            BOOL      fStandExist = FALSE;
            BOOL      fSymExist = FALSE;
            TCHAR     achClsidStd[CLSID_STRLEN+1];
            TCHAR     achClsidSym[CLSID_STRLEN+1];
            CMyRegKey  regLangKey;
            ULONG     ulCount = 0;

            CLSIDToStringA(c_guidProfile, achClsidStd);
            CLSIDToStringA(c_guidProfileSym, achClsidSym);

            // Enum the subkey for langid.

            while ( ERROR_SUCCESS == regkey.EnumKey(dwIndex, szLangIdName, ARRAYSIZE(szLangIdName)))
            {

        		lret = regLangKey.Open(regkey.m_hKey,
                                    szLangIdName,
                                    KEY_READ);

                if ( ERROR_SUCCESS == lret )
                {
                    char  *pLangStr;
                    int   iLangLen;
                    DWORD dwProfIndex;

                    pLangStr = szLangIdName;

		            if ( (tolower(pLangStr[0]) == '0')  && (tolower(pLangStr[1]) == 'x'))
			             pLangStr += 2;

		            iLangLen = strlen(pLangStr);
		            langid = 0;
		            for ( int i=0; i<iLangLen; i++)
		            {
			            WORD  wVchar;
                        char  cLower;

                        cLower = (char)tolower(pLangStr[i]);

            		    wVchar = 0;
            		    if ((cLower <= '9') && (cLower >= '0'))
				            wVchar = cLower - '0';

            	        if ((cLower <= 'f') && (cLower >= 'a' ))
				            wVchar = cLower - 'a' + 10;

			            langid = langid * 16 + wVchar;
		            }

                    fStandExist = fSymExist = FALSE;

                    dwProfIndex = 0;

                    while (!(fStandExist && fSymExist)
                        && ERROR_SUCCESS == regLangKey.EnumKey(dwProfIndex, szProfileName, ARRAYSIZE(szProfileName)))
                    {
                        
                        if ( !_stricmp(szProfileName, achClsidStd) )
                            fStandExist = TRUE;
                        else if ( !_stricmp(szProfileName, achClsidSym) )
                            fSymExist = TRUE;

                        dwProfIndex++;
                    }

                    if ( fStandExist && fSymExist )
                    {
                        LANGID  *pLang;
                        m_rgLang.Append(1);

                        pLang = m_rgLang.GetPtr(ulCount);
                        if ( pLang )
                        {   
                            ulCount ++;
                            *pLang = langid;
                        }
                    }
                    regLangKey.Close( );
                }
                dwIndex ++;
            }
        }
    }
    return hr;
}


// Add or Remove Language profile
HRESULT CSoftkbdRegistry::_SetSoftkbdTIP(LANGID  langid,  BOOL fEnable )
{
    HRESULT  hr = S_OK;
    ULONG    ulCount;
    BOOL     fAllLangExist = FALSE;
    BOOL     fLangExist = FALSE;
    LANGID  *pLangId = NULL;
    
    hr = _GenerateCurrentLangProfileList( );
    if ( hr != S_OK ) return hr;

    ulCount = m_rgLang.Count();
   
    if ( langid == 0  || langid == (LANGID)0xffff )
    {
        // Remove all the Profiles first.
        for (ULONG i=0; i<ulCount; i++)
        {
            pLangId = m_rgLang.GetPtr(i);
            if ( pLangId )           
            {
                hr = m_cpInputProcessorProfiles->RemoveLanguageProfile(CLSID_SoftkbdIMX,
                                                                  *pLangId,
                                                                  c_guidProfile);

                if (S_OK == hr)
                    hr = m_cpInputProcessorProfiles->RemoveLanguageProfile(CLSID_SoftkbdIMX,
                                                                    *pLangId,
                                                                    c_guidProfileSym);
            }
        }

        if ( fEnable  && hr == S_OK)  // Add this profile for all languages.
        {
                hr = m_cpInputProcessorProfiles->AddLanguageProfile(CLSID_SoftkbdIMX,
                                                               (LANGID)0xffff,
                                                               c_guidProfile,
                                                               m_pwszStandard,
                                                               wcslen(m_pwszStandard),
                                                               m_pwszIconFile,
                                                               wcslen(m_pwszIconFile),
                                                               0);

                if ( hr == S_OK )
                {
                   // Set DisplayName for MUI supporting
                   hr = m_cpInputProcessorProfiles->SetLanguageProfileDisplayName(CLSID_SoftkbdIMX,
                                                              (LANGID)0xffff,
                                                              c_guidProfile,
                                                              m_pwszIconFile,
                                                              wcslen(m_pwszIconFile),
                                                              IDS_SFTKBD_STANDARD_PROFILE );
                }
                                                               

                if ( hr == S_OK )
                {
                     hr = m_cpInputProcessorProfiles->AddLanguageProfile(CLSID_SoftkbdIMX,
                                                                (LANGID)0xffff,
                                                                c_guidProfileSym,
                                                                m_pwszSymbol,
                                                                wcslen(m_pwszSymbol),
                                                                m_pwszIconFile,
                                                                wcslen(m_pwszIconFile),
                                                                1);
                }

                if ( hr == S_OK )
                {
                   // Set DisplayName for MUI supporting
                   hr = m_cpInputProcessorProfiles->SetLanguageProfileDisplayName(CLSID_SoftkbdIMX,
                                                              (LANGID)0xffff,
                                                              c_guidProfileSym,
                                                              m_pwszIconFile,
                                                              wcslen(m_pwszIconFile),
                                                              IDS_SFTKBD_SYMBOL_PROFILE );
                }

         }

        return hr;
    }

    // Check to see if this profile is already there
    for (ULONG i=0; i<ulCount; i++)
    {
        if ( fAllLangExist && fLangExist )
            break;

        pLangId = m_rgLang.GetPtr(i);
        if ( pLangId )           
        {
            if ( *pLangId == (LANGID)0xffff)
                fAllLangExist = TRUE;

            if ( *pLangId == langid )
                fLangExist = TRUE;
        }
    }

    if ( fEnable )
    {
        if ( !fAllLangExist &&  !fLangExist )
        {
            hr = m_cpInputProcessorProfiles->AddLanguageProfile(CLSID_SoftkbdIMX,
                                                               langid,
                                                               c_guidProfile,
                                                               m_pwszStandard,
                                                               wcslen(m_pwszStandard),
                                                               m_pwszIconFile,
                                                               wcslen(m_pwszIconFile),
                                                               0);
            if ( hr == S_OK )
            {
               // Set DisplayName for MUI supporting
               hr = m_cpInputProcessorProfiles->SetLanguageProfileDisplayName(CLSID_SoftkbdIMX,
                                                          langid,
                                                          c_guidProfile,
                                                          m_pwszIconFile,
                                                          wcslen(m_pwszIconFile),
                                                          IDS_SFTKBD_STANDARD_PROFILE );
            }

            if ( hr == S_OK )
            {
                hr = m_cpInputProcessorProfiles->AddLanguageProfile(CLSID_SoftkbdIMX,
                                                               langid,
                                                               c_guidProfileSym,
                                                               m_pwszSymbol,
                                                               wcslen(m_pwszSymbol),
                                                               m_pwszIconFile,
                                                               wcslen(m_pwszIconFile),
                                                               1);
            }

            if ( hr == S_OK )
            {
               // Set DisplayName for MUI supporting
               hr = m_cpInputProcessorProfiles->SetLanguageProfileDisplayName(CLSID_SoftkbdIMX,
                                                          langid,
                                                          c_guidProfileSym,
                                                          m_pwszIconFile,
                                                          wcslen(m_pwszIconFile),
                                                          IDS_SFTKBD_SYMBOL_PROFILE );
            }

        }
    }
    else
    {
        // Remove  the specified or all Profiles.
        for (ULONG i=0; i<ulCount; i++)
        {
            pLangId = m_rgLang.GetPtr(i);
            if ( pLangId )           
            {
                if ( fAllLangExist )
                {
                    hr = m_cpInputProcessorProfiles->RemoveLanguageProfile(CLSID_SoftkbdIMX,
                                                                            *pLangId,
                                                                            c_guidProfile);

                    if ( S_OK == hr )
                        hr = m_cpInputProcessorProfiles->RemoveLanguageProfile(CLSID_SoftkbdIMX,
                                                                            *pLangId,
                                                                            c_guidProfileSym);
                }
                else if (  fLangExist )
                {
                    if ( *pLangId == langid )
                    {

                        hr = m_cpInputProcessorProfiles->RemoveLanguageProfile(CLSID_SoftkbdIMX,
                                                                                langid,
                                                                                c_guidProfile);
                        if ( S_OK == hr )
                            hr = m_cpInputProcessorProfiles->RemoveLanguageProfile(CLSID_SoftkbdIMX,
                                                                                langid,
                                                                                c_guidProfileSym);

                    }
                }
            }
        }
    }

    return hr;
}


HRESULT CSoftkbdRegistry::EnableSoftkbd(LANGID  langid )
{
    return _SetSoftkbdTIP(langid, TRUE);

}

HRESULT CSoftkbdRegistry::DisableSoftkbd(LANGID  langid )
{
    return _SetSoftkbdTIP(langid, FALSE);
}


//+---------------------------------------------------------------------------
//
// ctor
//
//----------------------------------------------------------------------------

CSoftkbdIMX::CSoftkbdIMX()
{
    extern void DllAddRef(void);

    _fInitialized = FALSE;
    _SoftKbd = NULL;

    _CurKbdType = KBDTYPE_NONE;
    _CurLayout = NON_LAYOUT;

    _tim = NULL;
    _dim = NULL;

    _pCes = NULL;

    DllAddRef();
}

//+---------------------------------------------------------------------------
//
// dtor
//
//----------------------------------------------------------------------------

CSoftkbdIMX::~CSoftkbdIMX()
{
    extern void DllRelease(void);

    if ( _SoftKbd != NULL )
    {

       _SoftKbd->DestroySoftKeyboardWindow( );
    }

    if ( _hOwnerWnd != NULL )
       DestroyWindow(_hOwnerWnd);

    _fInitialized = FALSE;

    if ( _SoftKbd != NULL )
    {
    	if ( _KbdSymbol.pskbdes != NULL )
    	{

    		_SoftKbd->UnadviseSoftKeyboardEventSink(_KbdSymbol.dwSkbdESCookie);
    		_SoftKbd->UnadviseSoftKeyboardEventSink(_dwsftkbdwndesCookie);

    		delete _psftkbdwndes;

    		delete _KbdSymbol.pskbdes;

    	}

    }

    if ( _pCes != NULL )
    {
    	_fOnOffSave = FALSE;

        _pCes->_Unadvise();
        SafeReleaseClear(_pCes);
    }

    SafeRelease(_SoftKbd);
    SafeRelease(_pFuncPrv);

    DllRelease();
}


//
// Only when GUID_COMPARTMENT_HANDWRITING_OPENCLOSE is set TRUE at the first
// time, this Initiliaze( ) could be called by the compartment event sink.
//

HRESULT  CSoftkbdIMX::Initialize( )
{

    HRESULT     hr;
    WCHAR       *lpSymXMLResStr = L"IDSKD_SYMLAYOUT";
    WCHAR       wszModuleFile[MAX_PATH];
    CHAR        szModuleFile[MAX_PATH];
    DWORD       dwFileLen;
    WNDCLASSEX  wndclass;
    INT         wScreenWidth, wScreenHeight;
    INT         left, top, width, height;  
    RECT        rcWork;


    hr = S_OK;

    if ( _fInitialized == TRUE )
    {
    	// Initialization is already done.

    	return hr;
    }


    if ( GetClassInfoEx( g_hInst, c_szIMXOwnerWndClass, &wndclass) == 0 )
    {
        memset(&wndclass, 0, sizeof(wndclass));
        wndclass.cbSize        = sizeof(wndclass);
        wndclass.style         = CS_HREDRAW | CS_VREDRAW ;
        wndclass.hInstance     = g_hInst;
        wndclass.hCursor       = LoadCursor(NULL, IDC_ARROW);

        wndclass.lpfnWndProc   = _OwnerWndProc;
        wndclass.lpszClassName = c_szIMXOwnerWndClass;
        RegisterClassEx(&wndclass);
    }

     _hOwnerWnd = CreateWindowEx(0, c_szIMXOwnerWndClass, TEXT(""), WS_DISABLED, 0, 0, 0, 0, NULL, 0, g_hInst, 0);

    	// PerfConsider: use a static ctor instead of ole32/class factory/etc.
    hr=CoCreateInstance(CLSID_SoftKbd, NULL, CLSCTX_INPROC_SERVER, IID_ISoftKbd, (void**)&_SoftKbd);


    if (FAILED(hr) )
    {
        // assert(0);
        return hr;
    }

    _SoftKbd->Initialize( );

    // initialize Standard soft layout and Symbol Soft Layout.

    _KbdStandard.dwSoftKbdLayout = SOFTKBD_US_STANDARD;
    _KbdStandard.fStandard       = TRUE;
    _KbdStandard.dwNumLabels     = 0;   // for standard, this field is not really used.
    _KbdStandard.dwCurLabel      = 0;
    _KbdStandard.pskbdes         = NULL; // standard layout doesn't supply sftkbd event sink.
    _KbdStandard.dwSkbdESCookie  = 0;

    _KbdSymbol.fStandard = FALSE;
    _KbdSymbol.dwNumLabels = 2;
    _KbdSymbol.dwCurLabel = 0;

    dwFileLen = GetModuleFileNameA(g_hInst, szModuleFile, MAX_PATH);
    
    if ( dwFileLen == 0 )
    {  
    	hr = E_FAIL;
    	goto CleanUp;
    } 

    MultiByteToWideChar(CP_ACP, 0, szModuleFile, -1,
    	                wszModuleFile, MAX_PATH);
    
    hr = _SoftKbd->CreateSoftKeyboardLayoutFromResource(wszModuleFile, L"SKDFILE", lpSymXMLResStr, 
                                                        &(_KbdSymbol.dwSoftKbdLayout) );

    CHECKHR(hr);


    _KbdSymbol.pskbdes = new  CSoftKeyboardEventSink(this, _KbdSymbol.dwSoftKbdLayout);

    if ( _KbdSymbol.pskbdes == NULL )
    {

    	hr = E_FAIL;
    	goto CleanUp;
    }

    hr = _SoftKbd->AdviseSoftKeyboardEventSink(_KbdSymbol.dwSoftKbdLayout,
                                          IID_ISoftKeyboardEventSink,
                                          _KbdSymbol.pskbdes,
                                          &(_KbdSymbol.dwSkbdESCookie) );


    CHECKHR(hr);

    _psftkbdwndes = new CSoftKbdWindowEventSink(this);

    if ( _psftkbdwndes == NULL )
    {

    	hr=E_FAIL;
    	goto CleanUp;
    }

    CHECKHR(_SoftKbd->AdviseSoftKeyboardEventSink(0,IID_ISoftKbdWindowEventSink,_psftkbdwndes, &(_dwsftkbdwndesCookie)) );

    _CurLayout = _KbdStandard.dwSoftKbdLayout;

    width = 400;
    height = 172;

    if ( S_OK != GetSoftKBDPosition( &left, &top ) )
    {
        // the compartment is not initialize.
        SystemParametersInfo(SPI_GETWORKAREA, 0, &rcWork, 0 );
        wScreenWidth = (INT)(rcWork.right - rcWork.left + 1);
        wScreenHeight = (INT)(rcWork.bottom - rcWork.top + 1);
        left = wScreenWidth - width -2;
        top = wScreenHeight - height - 1;
    }
 
    CHECKHR(_SoftKbd->CreateSoftKeyboardWindow(_hOwnerWnd,TITLEBAR_GRIPPER_BUTTON, left,top,width,height));

    SetSoftKBDPosition(left, top );

    if ( hr == S_OK ) 
    {
        LOGFONTW  lfTextFont;
        int iDpi;
        int iPoint;

        iDpi = 96;
        iPoint = 9;
        HDC hdc;
    
        hdc = CreateIC("DISPLAY", NULL, NULL, NULL);

        if (hdc)
        {
            iDpi = GetDeviceCaps(hdc, LOGPIXELSY);
            DeleteDC(hdc);

            memset(&lfTextFont, 0, sizeof(LOGFONTW) );
            lfTextFont.lfHeight = -iPoint * iDpi / 72;

            lfTextFont.lfWeight = 400;
            lfTextFont.lfOutPrecision = OUT_TT_ONLY_PRECIS;

            wcsncpy(lfTextFont.lfFaceName, L"Arial", ARRAYSIZE(lfTextFont.lfFaceName));
            lfTextFont.lfCharSet = 0;

            hr = _SoftKbd->SetSoftKeyboardTextFont(&lfTextFont);
        }
    }

    _fInitialized = TRUE;

    // or get the current layout from previous saved one.

CleanUp:

    return hr;

}


//+---------------------------------------------------------------------------
//
// OnSetThreadFocus
//
//----------------------------------------------------------------------------

STDAPI CSoftkbdIMX::OnSetThreadFocus()
{

    // Restore the ON/OFF status before KillThreadFocus( )

    if ( _SoftKbd != NULL )
    {

    	if ( _fOnOffSave ) 
        {
            // adjust the window position.
            int     xWnd, yWnd;
            WORD    width=0, height=0;
            POINT   OldPoint;
            HRESULT hr;

            _SoftKbd->GetSoftKeyboardPosSize(&OldPoint, &width, &height);
            hr = GetSoftKBDPosition(&xWnd, &yWnd);

            if ( hr == S_OK )
            {
                if ( (xWnd != OldPoint.x) || (yWnd != OldPoint.y) )
                {
                    POINT  NewPoint;

                    NewPoint.x = xWnd;
                    NewPoint.y = yWnd;
                    _SoftKbd->SetSoftKeyboardPosSize(NewPoint, width, height);
                }
            }

            _ShowSoftKBDWindow(TRUE);
        }
    	else
    		_SoftKbd->ShowSoftKeyboard(FALSE);
    }

    return S_OK;
}

//+---------------------------------------------------------------------------
//
// OnKillThreadFocus
//
//----------------------------------------------------------------------------

STDAPI CSoftkbdIMX::OnKillThreadFocus()
{


    // keep the ON/OFF status so that OnSetThreadFocus( ) can restore it later

    _fOnOffSave = GetSoftKBDOnOff( );

    if ( _SoftKbd != NULL )
    {
    	_SoftKbd->ShowSoftKeyboard( FALSE );
    }

    // release all the modifier keys  except lock keys.  that is , Shift, Alt, Ctrl, 
    keybd_event((BYTE)VK_SHIFT, (BYTE)KID_LSHFT, (DWORD)KEYEVENTF_KEYUP, 0);
    keybd_event((BYTE)VK_MENU,  (BYTE)KID_ALT, (DWORD)KEYEVENTF_KEYUP, 0);
    keybd_event((BYTE)VK_LMENU, (BYTE)KID_ALT, (DWORD)KEYEVENTF_KEYUP, 0);
    keybd_event((BYTE)VK_RMENU, (BYTE)KID_RALT, (DWORD)KEYEVENTF_KEYUP, 0);
    keybd_event((BYTE)VK_CONTROL, (BYTE)KID_CTRL, (DWORD)KEYEVENTF_KEYUP, 0);
        
    return S_OK;
}

//+---------------------------------------------------------------------------
//
// Activate
//
//----------------------------------------------------------------------------

STDAPI CSoftkbdIMX::Activate(ITfThreadMgr *ptim, TfClientId tid)
{
    ITfSource *source;
    ITfLangBarItemMgr *plbim = NULL;
    HRESULT hr;

    Assert(_tim == NULL);
    _tim = ptim;
    _tim->AddRef();

    _tid = tid;


    _pProfile = NULL;

    if (_tim->QueryInterface(IID_ITfSource, (void **)&source) == S_OK)
    {
        source->AdviseSink(IID_ITfThreadFocusSink, (ITfThreadFocusSink *)this, &_dwThreadFocusCookie);
        source->Release();
    }

    //
    // Add SoftKeyboard activate button into LangBarItemMgr.
    //
    if (FAILED(hr = GetService(_tim, IID_ITfLangBarItemMgr, (IUnknown **)&plbim)))
    {
        hr = E_FAIL;
        goto CleanUp;
    }

    if (!(_plbi = new CLBarItem(this)))
    {
        hr = E_OUTOFMEMORY;
        goto CleanUp;
    }

    plbim->AddItem(_plbi);


    //
    // get language ID.
    //
    _InitLangID();

    if ( (_timActiveLangSink = new CActiveLanguageProfileNotifySink(_AlsCallback, this)) == NULL )
    {
        Assert(0); 
        hr = E_FAIL;
        goto CleanUp;
    }

    _timActiveLangSink->_Advise(_tim);

    if ( (_timLangSink = new CLanguageProfileNotifySink(_LsCallback, this)) == NULL )
    {
        Assert(0); 
        hr = E_FAIL;
        goto CleanUp;
    }

    _timLangSink->_Advise(_pProfile);

    _pFuncPrv = new CFunctionProvider(this);

    if ( _pFuncPrv != NULL)
        _pFuncPrv->_Advise(_tim);


    // defaultly, hide the soft keyboard window.

    _fOnOffSave = FALSE;

    if (!(_pCes = new CCompartmentEventSink(_CompEventSinkCallback, this)))
    {
        hr = E_OUTOFMEMORY;
        CHECKHR(hr);
    }

    CHECKHR(_pCes->_Advise(_tim, GUID_COMPARTMENT_HANDWRITING_OPENCLOSE, FALSE));
    CHECKHR(_pCes->_Advise(_tim, GUID_COMPARTMENT_SOFTKBD_KBDLAYOUT, FALSE));

#if 0
    
    if (_tim->IsThreadFocus(&fThreadFocus) == S_OK && fThreadFocus)
    {
        // init any UI
        OnSetThreadFocus();
    }

#endif

    hr = S_OK;

CleanUp:
    SafeRelease(plbim);

    return hr;
}

//+---------------------------------------------------------------------------
//
// Deactivate
//
//----------------------------------------------------------------------------

STDAPI CSoftkbdIMX::Deactivate()
{
    ITfSource *source;
    ITfLangBarItemMgr *plbim = NULL;
//    BOOL fThreadFocus;
    HRESULT hr;


     if (_tim->QueryInterface(IID_ITfSource, (void **)&source) == S_OK)
    {
        source->UnadviseSink(_dwThreadFocusCookie);
        source->Release();
    }

    //
    // Clean up SoftKeyboard activate button into LangBarItemMgr.
    //
    if (SUCCEEDED(hr = GetService(_tim, IID_ITfLangBarItemMgr, (IUnknown **)&plbim)))
    {
        plbim->RemoveItem(_plbi);
        SafeReleaseClear(_plbi);
        SafeReleaseClear(plbim);
    }



    if ( _timActiveLangSink != NULL )
    {
        _timActiveLangSink->_Unadvise( );
        SafeReleaseClear(_timActiveLangSink);
    }

    if ( _timLangSink != NULL )
    {
        _timLangSink->_Unadvise( );
        SafeReleaseClear(_timLangSink);
    }
 
    if ( _pFuncPrv != NULL )
    {
       _pFuncPrv->_Unadvise(_tim);
       SafeReleaseClear(_pFuncPrv);
    }

    if ( _pCes != NULL )
    {

    	if ( _SoftKbd != NULL )
    		_SoftKbd->ShowSoftKeyboard(FALSE);
    	_fOnOffSave = FALSE;
    	_pCes->_Unadvise();
    	SafeReleaseClear(_pCes);
    }

    SafeReleaseClear(_pProfile);
    
    SafeReleaseClear(_tim);

    TFUninitLib_Thread(&_libTLS);

    hr = S_OK;


    return hr;
}


//+---------------------------------------------------------------------------
//
// GetIC
//
//----------------------------------------------------------------------------

ITfContext *CSoftkbdIMX::GetIC()
{
    ITfContext *pic = NULL;

    if (!_tim)
    {
       Assert(0);
       return NULL;
    }

    ITfDocumentMgr *pdim;
    if (SUCCEEDED(_tim->GetFocus(&pdim)) && pdim)
    {
        // otherwise grab the top of the stack
        pdim->GetTop(&pic);
        pdim->Release();
    }

    return pic;
}

//+---------------------------------------------------------------------------
//
// _OnOffToggle
//
//----------------------------------------------------------------------------

void CSoftkbdIMX::_OnOffToggle( )
{

    BOOL  fOn = GetSoftKBDOnOff( );

    SetSoftKBDOnOff(!fOn);

    _UpdateUI();
}


//+---------------------------------------------------------------------------
//
// _EditSessionCallback
//
//----------------------------------------------------------------------------

HRESULT CSoftkbdIMX::_InputKeyLabel(TfEditCookie ec, ITfContext *pic, WCHAR  *lpszLabel, UINT  nLabLen)
{
    HRESULT  hr = S_OK;
    ITfRange *pRange, *pSelection;

    if ( pic )
    {
       TF_STATUS ts;
       hr = pic->GetStatus(&ts);
       if ( (S_OK == hr) && (TF_SD_READONLY & ts.dwDynamicFlags) )
       {
           // Readonly Doc, just return here!
           return hr;
       }

       if (GetSelectionSimple(ec, pic, &pSelection) == S_OK)
       {
          if (SUCCEEDED(pSelection->Clone(&pRange)))
          {
              BOOL fInsertOk = FALSE;
              hr = pRange->AdjustForInsert(ec, nLabLen, &fInsertOk);
              if (S_OK == hr && fInsertOk)
              {
                  SetTextAndProperty(&_libTLS, ec, pic, pRange, lpszLabel, nLabLen, _langid, NULL);

                  _MySetSelectionSimple(ec, pic, pRange);
              }

              pRange->Release();
          }

          pSelection->Release();
       }
    }

    return hr;
}


HRESULT CSoftkbdIMX::_EditSessionCallback(TfEditCookie ec, CEditSession *pes)
{
    CSoftkbdIMX *_this;
    HRESULT      hr;


    hr = S_OK;

    switch (pes->_state.u)
    {

     	case ESCB_KEYLABEL :

    		{
    			WCHAR  *lpszLabel;
    			UINT   nLabLen;
    		
                lpszLabel = (WCHAR *)(pes->_state.lParam);

                if ( lpszLabel == NULL )
                {
                   hr = E_FAIL;
                   return hr;
                }

                nLabLen = wcslen(lpszLabel);

                _this = (CSoftkbdIMX *)pes->_state.pv;
                hr = _this->_InputKeyLabel(ec,
    		                          pes->_state.pic,
    				  		          lpszLabel,
    							      nLabLen);

               SafeFreePointer(lpszLabel);

    	       break;
    		}

    	default :
    		   break;
    
    }

    return hr;
}

//
// Show or Hide the soft keyboard window based on current setting.
//

HRESULT  CSoftkbdIMX::_ShowSoftKBDWindow( BOOL  fShow )
{

    HRESULT  hr;

    hr = S_OK;


    if ( fShow && ( _fInitialized == FALSE ) )
    	// call the initialize function 
    	// to get the ISoftKbd.
    {
    	Initialize( );

    }

    if ( _SoftKbd == NULL )
    {
    	hr = E_FAIL;
    	return hr;
    }

    if ( fShow ) {

    	DWORD   dwSoftLayout;

    	if ( _CurKbdType  == KBDTYPE_STANDARD ) 
    	{
    		// Standard soft kbd was selected.
            WORD   prmlangid;

            prmlangid = PRIMARYLANGID(_langid);

            switch ( prmlangid ) {

            case LANG_JAPANESE  :
    			// Lang JPN is activated.
    			// select the standard layout to J 106-k.
    			_KbdStandard.dwSoftKbdLayout = SOFTKBD_JPN_STANDARD;
                break;

            case LANG_AZERI   :
            case LANG_BELARUSIAN :
            case LANG_CHINESE :
            case LANG_KOREAN  :
            case LANG_RUSSIAN :
            case LANG_THAI    :
            case LANG_URDU    :
            case LANG_UZBEK   :
                _KbdStandard.dwSoftKbdLayout = SOFTKBD_US_STANDARD;
                break;

            case LANG_ENGLISH :
                if ( SUBLANGID(_langid) != SUBLANG_ENGLISH_US )
                    _KbdStandard.dwSoftKbdLayout = SOFTKBD_EURO_STANDARD;
                else
                    _KbdStandard.dwSoftKbdLayout = SOFTKBD_US_STANDARD;
                break;

            default           :
                _KbdStandard.dwSoftKbdLayout = SOFTKBD_EURO_STANDARD;
                break;
            }

    		// the current layout is standard layout.
    		// we need to set the correct standard layout id based on current lang profile.

    		dwSoftLayout = _KbdStandard.dwSoftKbdLayout;
    		_CurLayout = dwSoftLayout;

    		CHECKHR(_SoftKbd->SelectSoftKeyboard(dwSoftLayout));
    		CHECKHR(_SoftKbd->SetKeyboardLabelText(GetKeyboardLayout(0)));
    	}
    	else if ( _CurKbdType  == KBDTYPE_SYMBOL)
    	{
    		// This is symbol soft keyboard layout
    		//
    		DWORD   dwCurLabel;
    		dwSoftLayout = _KbdSymbol.dwSoftKbdLayout;
    		dwCurLabel = _KbdSymbol.dwCurLabel;
    		CHECKHR(_SoftKbd->SelectSoftKeyboard(dwSoftLayout));
    		CHECKHR(_SoftKbd->SetKeyboardLabelTextCombination(dwCurLabel));

    	}

    	// TIP is ON, so we need to show soft keyboard.
    	CHECKHR(_SoftKbd->ShowSoftKeyboard(TRUE));
    }
    else
    {
    	// TIP is going to close.
    	// close the soft keyboard window also.
    	CHECKHR(_SoftKbd->ShowSoftKeyboard(FALSE));
    }

CleanUp:

    return  hr;

}


//+---------------------------------------------------------------------------
//
// _CompEventSinkCallback
//
//----------------------------------------------------------------------------

HRESULT CSoftkbdIMX::_CompEventSinkCallback(void *pv, REFGUID rguid)
{
    CSoftkbdIMX *_this = (CSoftkbdIMX *)pv;
    BOOL        fOn;
    HRESULT     hr;


    hr = S_OK;

    if ( IsEqualGUID(rguid, GUID_COMPARTMENT_HANDWRITING_OPENCLOSE)  )
    {

    	fOn = _this->GetSoftKBDOnOff( );
        
    	CHECKHR(_this->_ShowSoftKBDWindow(fOn));

        //
        // Open/Close status was updated, we need to update Langbar button's
        // toggle state.
        //
    	_this->_plbi->UpdateToggle();

    }

    else if ( IsEqualGUID(rguid, GUID_COMPARTMENT_SOFTKBD_KBDLAYOUT) )
    {

    	DWORD   dwSoftLayout;

    	if ( _this->_SoftKbd == NULL )
    	{
    		hr = E_FAIL;
    		return hr;
    	}

    	dwSoftLayout = _this->GetSoftKBDLayout( );


    	_this->_CurLayout = dwSoftLayout;

    	if ( dwSoftLayout == (_this->_KbdStandard).dwSoftKbdLayout )
    	{
    		// this is standard layout.    
    		
    		_this->_CurKbdType  = KBDTYPE_STANDARD;

    		CHECKHR(_this->_SoftKbd->SelectSoftKeyboard(dwSoftLayout));

            CHECKHR(_this->_SoftKbd->SetKeyboardLabelText(GetKeyboardLayout(0)));

    	}
    	else if ( dwSoftLayout == (_this->_KbdSymbol).dwSoftKbdLayout )
    	{
    		// this is symbol layout.

    		DWORD   dwCurLabel;

    		_this->_CurKbdType  = KBDTYPE_SYMBOL;

    		dwCurLabel = (_this->_KbdSymbol).dwCurLabel;
           
    		CHECKHR(_this->_SoftKbd->SelectSoftKeyboard(dwSoftLayout));

    		CHECKHR(_this->_SoftKbd->SetKeyboardLabelTextCombination(dwCurLabel));

    	}

    	if ( _this->GetSoftKBDOnOff( ) ) 
    		CHECKHR(_this->_SoftKbd->ShowSoftKeyboard(TRUE));


    }

    _this->_UpdateUI();

CleanUp:
    return hr;
}

//+---------------------------------------------------------------------------
//
// _UpdateUI
//
//----------------------------------------------------------------------------

void CSoftkbdIMX::_UpdateUI()
{

}


//+---------------------------------------------------------------------------
//
// _MySetSelectionSimple
//
//----------------------------------------------------------------------------

HRESULT CSoftkbdIMX::_MySetSelectionSimple(TfEditCookie ec, ITfContext *pic, ITfRange *range)
{
    TF_SELECTION sel;

    sel.range = range;
    sel.style.ase = TF_AE_NONE;
    sel.style.fInterimChar = FALSE;

    range->Collapse(ec, TF_ANCHOR_END);

    return pic->SetSelection(ec, 1, &sel);
}

HRESULT CSoftkbdIMX::_LsCallback(BOOL fChanged, LANGID langid, BOOL *pfAccept, void *pv)
{
    HRESULT hr = S_OK;
    GUID   guidProfile;
    LANGID lang;

    TraceMsg(TF_GENERAL, "CSoftkbdIMX::_LsCallback is called, langid=%x fChanged=%d", langid, fChanged);

    CSoftkbdIMX *_this = (CSoftkbdIMX *)pv;

    if (!fChanged)
    {
        if ( pfAccept )
            *pfAccept = TRUE;
        return hr;
    }
  
    hr = _this->_pProfile->GetActiveLanguageProfile(CLSID_SoftkbdIMX, &lang, &guidProfile);

    if ( hr == S_OK )
    {
        _this->_langid = lang;

        if ( IsEqualGUID(guidProfile, c_guidProfile) ) 
        {
            // Standard soft kbd is selected.
            TraceMsg(TF_GENERAL, "Standard Softkbd is selected");
            _this->_CurKbdType  = KBDTYPE_STANDARD;
        }
        else if ( IsEqualGUID(guidProfile, c_guidProfileSym) )
        {
            // This is symbol soft keyboard layout
            //
            TraceMsg(TF_GENERAL, "Symbol Softkbd is selected");
            _this->_CurKbdType  = KBDTYPE_SYMBOL;
        }

        if ( (_this->GetSoftKBDOnOff( ) == TRUE) )
            _this->_ShowSoftKBDWindow(TRUE);   
    }

    return hr;
}


HRESULT CSoftkbdIMX::_AlsCallback(REFCLSID clsid, REFGUID guidProfile, BOOL fActivated, void *pv)
{

    HRESULT   hr;
    ITfInputProcessorProfiles  *pProfile = NULL;

    hr = S_OK;

    CSoftkbdIMX *_this = (CSoftkbdIMX *)pv;


    // if this is not for SoftKbdIMX  TIP,
    // we just ignore it.

    if (IsEqualGUID(clsid, CLSID_SoftkbdIMX))
    {
        // if this is not for our registered profile guid, just ignore it.
    
        if ( !IsEqualGUID(guidProfile, c_guidProfile) && !IsEqualGUID(guidProfile, c_guidProfileSym) )
            return hr;

        TraceMsg(TF_GENERAL, "CSoftkbdIMX::_AlsCallback is called for this tip fActivated=%d", fActivated);

        if ( fActivated == FALSE ) 
        {
            if ( _this->GetSoftKBDOnOff( ) )
            {
    	        if ( _this->_SoftKbd != NULL )
    		        (_this->_SoftKbd)->ShowSoftKeyboard(FALSE);
            }
            return hr;
        }

        if ( IsEqualGUID(guidProfile, c_guidProfile) ) 
        {
    	    // Standard soft kbd is selected.

            TraceMsg(TF_GENERAL, "Standard Softkbd is selected");

    	    _this->_CurKbdType  = KBDTYPE_STANDARD;

        }

        else if ( IsEqualGUID(guidProfile, c_guidProfileSym) )
        {
    	    // This is symbol soft keyboard layout
    	    //

            TraceMsg(TF_GENERAL, "Symbol Softkbd is selected");
    	    _this->_CurKbdType  = KBDTYPE_SYMBOL;

        }

        if ( (_this->GetSoftKBDOnOff( ) == TRUE) )
    	    _this->_ShowSoftKBDWindow(TRUE);   
    }
    else  if (IsEqualGUID(clsid, GUID_NULL))
    {
        // This is keyboard layout change without language change.
        if ( _this->GetSoftKBDOnOff( ) && fActivated)
        {
  	        _this->_ShowSoftKBDWindow(fActivated);
        }
    }
  
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\ctf\softkbd\softkbdimx.h ===
/**************************************************************************\
* Module Name: softkbdimx.cpp
*
* Copyright (c) 1985 - 2000, Microsoft Corporation
*
* Declaration of Soft Keyboard Input TIP class. 
*
* History:
*         28-March-2000  weibz     Created
\**************************************************************************/


#ifndef SOFTKBDIMX_H
#define SOFTKBDIMX_H

#include "private.h"
#include "globals.h"
#include "dap.h"
#include "computil.h"
#include "resource.h"
#include "softkbd.h"
#include "nui.h"
#include "immxutil.h"

class CCommandEventSink;
class CEditSession;
class CThreadMgrEventSink;
class CSoftKeyboardEventSink;
class CSoftKbdWindowEventSink;
class CFunctionProvider;
class CActiveLanguageProfileNotifySink;
class CLanguageProfileNotifySink;

#define ESCB_KEYLABEL                   10

#define NON_LAYOUT                      0

#define  KBDTYPE_NONE                   0
#define  KBDTYPE_STANDARD               1
#define  KBDTYPE_SYMBOL                 2 

typedef  struct tagSoftLayout
{
    DWORD   dwSoftKbdLayout;
    BOOL    fStandard;
    DWORD   dwNumLabels;  // Number of Label status. 
    DWORD   dwCurLabel;
    CSoftKeyboardEventSink  *pskbdes;
    DWORD   dwSkbdESCookie;
} SOFTLAYOUT;

class CSoftkbdIMX :
                   public CComObjectRoot_CreateInstance<CSoftkbdIMX>, 
                   public ITfTextInputProcessor,
                   public ITfThreadFocusSink,
                   public CDisplayAttributeProvider
{
public:
    CSoftkbdIMX();
    ~CSoftkbdIMX();

BEGIN_COM_MAP_IMMX(CSoftkbdIMX)
    COM_INTERFACE_ENTRY(ITfTextInputProcessor)
    COM_INTERFACE_ENTRY(ITfThreadFocusSink)
    COM_INTERFACE_ENTRY(ITfDisplayAttributeProvider)
END_COM_MAP_IMMX()

public:
    // ITfX methods
    STDMETHODIMP Activate(ITfThreadMgr *ptim, TfClientId tid);
    STDMETHODIMP Deactivate();

    // ITfThreadFocusSink
    STDMETHODIMP OnSetThreadFocus();
    STDMETHODIMP OnKillThreadFocus();

    static LRESULT CALLBACK _OwnerWndProc(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam) {
           return DefWindowProc(hWnd, uMsg, wParam, lParam);
    }

    void _OnOffToggle( );
    ITfContext *GetIC();
    HWND GetOwnerWnd() {return _hOwnerWnd;}

    HRESULT  Initialize( );

    BOOL     _fOnOffSave;

    BOOL GetSoftKBDOnOff(  )
    {

       DWORD dw;

       if (  _tim == NULL )
    	   return FALSE;

       GetCompartmentDWORD(_tim, GUID_COMPARTMENT_HANDWRITING_OPENCLOSE , &dw, FALSE);
       return dw ? TRUE : FALSE;

    }

    void SetSoftKBDOnOff( BOOL fOn )
    {

    	// check to see if the _SoftKbd and soft keyboard related members are initialized.
    	if ( _fInitialized == FALSE )
    	{
    		Initialize( );
    	}

    	if ( (_SoftKbd == NULL) || ( _tim == NULL) )
    		return;

    	if ( fOn == GetSoftKBDOnOff( ) )
           return;

    	SetCompartmentDWORD(_tid, _tim, GUID_COMPARTMENT_HANDWRITING_OPENCLOSE ,fOn ? 0x01 : 0x00 , FALSE);

  
    }

    DWORD  GetSoftKBDLayout( )
    {

       DWORD dw;

    	if ( (_SoftKbd == NULL) || ( _tim == NULL) )
    	   return NON_LAYOUT;

       GetCompartmentDWORD(_tim, GUID_COMPARTMENT_SOFTKBD_KBDLAYOUT, &dw, FALSE);

       return dw;

    }

    void  SetSoftKBDLayout(DWORD  dwKbdLayout)
    {
    	// check to see if the _SoftKbd and soft keyboard related members are initialized.
    	if ( _fInitialized == FALSE )
    	{
    		Initialize( );
    	}

    	if ( (_SoftKbd == NULL) || ( _tim == NULL) )
    		return;

        SetCompartmentDWORD(_tid, _tim, GUID_COMPARTMENT_SOFTKBD_KBDLAYOUT, dwKbdLayout , FALSE);

    }

    HRESULT GetSoftKBDPosition(int *xWnd, int *yWnd)
    {
        DWORD    dwPos;
        HRESULT  hr = S_OK;

    	if ( (_SoftKbd == NULL) || ( _tim == NULL) )
    		return E_FAIL;

        if ( !xWnd  || !yWnd )
            return E_FAIL;

       hr = GetCompartmentDWORD(_tim, GUID_COMPARTMENT_SOFTKBD_WNDPOSITION, &dwPos, TRUE);

       if ( hr == S_OK )
       {
            *xWnd = dwPos & 0x0000ffff;
            *yWnd = (dwPos >> 16) & 0x0000ffff;
            hr = S_OK;
       }
       else
       {
           *xWnd = 0;
           *yWnd = 0;
           hr = E_FAIL;
       }

       return hr;
    }

    void SetSoftKBDPosition(int  xWnd, int yWnd )
    {
        DWORD  dwPos;
        DWORD  left, top;

    	if ( (_SoftKbd == NULL) || ( _tim == NULL) )
    		return;

        if ( xWnd < 0 )
            left = 0;
        else
            left = (WORD)xWnd;

        if ( yWnd < 0 )
            top = 0;
        else
            top = (WORD)yWnd;

        dwPos = ((DWORD)top << 16) + left;

        SetCompartmentDWORD(_tid, _tim, GUID_COMPARTMENT_SOFTKBD_WNDPOSITION, dwPos, TRUE);

    }

    static HRESULT _EditSessionCallback(TfEditCookie ec, CEditSession *pes);

    ITfThreadMgr *_tim;

    TfClientId _GetId() { return _tid; }

    LANGID     _GetLangId( ) { return _langid; }

    ISoftKbd   *_SoftKbd;
    SOFTLAYOUT _KbdStandard;
    SOFTLAYOUT _KbdSymbol;
    DWORD      _CurLayout;
    DWORD      _CurKbdType;
    TfClientId _tid;
    ITfDocumentMgr *_dim;
    LANGID _langid;

    ITfInputProcessorProfiles  *_pProfile;

    void _InitLangID()
    {
  
    	ITfInputProcessorProfiles  *pProfile;

        _langid = 0x409;

    	if ( _pProfile == NULL )
    	{
           CoCreateInstance(CLSID_TF_InputProcessorProfiles,
                            NULL,
                            CLSCTX_INPROC_SERVER,
                            IID_ITfInputProcessorProfiles,
                            (void **) &_pProfile);
    	}

    	if ( _pProfile != NULL )
    	{
    		GUID guid;

    		pProfile = _pProfile;
    		pProfile->AddRef( );
              
            pProfile->GetActiveLanguageProfile(CLSID_SoftkbdIMX,
                                               &_langid,
                                               &guid);

    		pProfile->Release( );
          
    	} 
    	
    }

private:

    HRESULT _InputKeyLabel(TfEditCookie ec, ITfContext *pic, WCHAR  *lpszLabel, UINT  nLabLen);

    void _UpdateUI();

    HRESULT _MySetSelectionSimple(TfEditCookie ec, ITfContext *pic, ITfRange *range);

    HRESULT _ShowSoftKBDWindow( BOOL  fShow );
 
    
    HWND       _hOwnerWnd;
    CFunctionProvider *_pFuncPrv;

    static HRESULT _CompEventSinkCallback(void *pv, REFGUID rguid);

    // compartment (storage) event sink
    CCompartmentEventSink   *_pCes;
    
    UINT_PTR _uCurrentEditCookie;

    DWORD _dwThreadFocusCookie;

    static HRESULT _AlsCallback(REFCLSID clsid, REFGUID guidProfile, BOOL fActivated, void *pv);
    static HRESULT _LsCallback(BOOL fChanged, LANGID langid, BOOL *pfAccept, void *pv);

    CActiveLanguageProfileNotifySink  *_timActiveLangSink;
    CLanguageProfileNotifySink        *_timLangSink;

    CSoftKbdWindowEventSink            *_psftkbdwndes;
    DWORD                              _dwsftkbdwndesCookie;

    CLBarItem *_plbi;
     

    BOOL              _fInitialized;

    LIBTHREAD   _libTLS; // tls for the helper library. Since this object is apt threaded,
                         // all members are accessed in a single thread
                         // also, cicero will only create a single instance of this obj per thread
};

inline void SetThis(HWND hWnd, LPARAM lParam)
{
    SetWindowLongPtr(hWnd, GWLP_USERDATA, (UINT_PTR)((CREATESTRUCT *)lParam)->lpCreateParams);
}

inline CSoftkbdIMX *GetThis(HWND hWnd)
{
    CSoftkbdIMX *pIMX = (CSoftkbdIMX *)GetWindowLongPtr(hWnd, GWLP_USERDATA);

    Assert(pIMX != NULL);

    return pIMX;
}

 
class CSoftkbdRegistry :
                   public CComObjectRoot_CreateInstance<CSoftkbdRegistry>, 
                   public ITfSoftKbdRegistry
{
public:
    CSoftkbdRegistry();
    ~CSoftkbdRegistry();

BEGIN_COM_MAP_IMMX(CSoftkbdRegistry)
    COM_INTERFACE_ENTRY(ITfSoftKbdRegistry)
END_COM_MAP_IMMX()

public:
    // ITfSoftKbdRegistry
    STDMETHODIMP EnableSoftkbd(LANGID  langid );
    STDMETHODIMP DisableSoftkbd(LANGID langid );

private:

    HRESULT _SetSoftkbdTIP(LANGID langid,  BOOL  fEnable );
    HRESULT _GenerateCurrentLangProfileList( );

    BOOL    m_fInitialized;
    CComPtr<ITfInputProcessorProfilesEx> m_cpInputProcessorProfiles;
    CStructArray<LANGID>   m_rgLang;

    WCHAR   m_pwszStandard[128];
    WCHAR   m_pwszSymbol[128];
    WCHAR   m_pwszIconFile[MAX_PATH];
};

#endif // SOFTKBDIMX_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\ctf\softkbd\softkbdui.cpp ===
// 
// This is implementation of softkbd window UI.
//

#include "private.h"
#include "globals.h"

#include  "softkbdui.h"
#include  "maskbmp.h"
#include  "commctrl.h"
#include  "cuiutil.h"
#include  "immxutil.h"
#include  "cregkey.h"


HBITMAP MyLoadImage(HINSTANCE hInst, LPCSTR pResStr)
{
    HBITMAP hBmpRes;

    hBmpRes = (HBITMAP)LoadBitmap(hInst, pResStr);
    return hBmpRes;
}


/*   C O N V E R T  L O G  F O N T  W T O  A   */
/*------------------------------------------------------------------------------

    Convert LOGFONTW to LOGFONTA

------------------------------------------------------------------------------*/
void ConvertLogFontWtoA( CONST LOGFONTW *plfW, LOGFONTA *plfA )
{
    UINT cpg;

    plfA->lfHeight         = plfW->lfHeight;
    plfA->lfWidth          = plfW->lfWidth;
    plfA->lfEscapement     = plfW->lfEscapement;
    plfA->lfOrientation    = plfW->lfOrientation;
    plfA->lfWeight         = plfW->lfWeight;
    plfA->lfItalic         = plfW->lfItalic;
    plfA->lfUnderline      = plfW->lfUnderline;
    plfA->lfStrikeOut      = plfW->lfStrikeOut;
    plfA->lfCharSet        = plfW->lfCharSet;
    plfA->lfOutPrecision   = plfW->lfOutPrecision;
    plfA->lfClipPrecision  = plfW->lfClipPrecision;
    plfA->lfQuality        = plfW->lfQuality;
    plfA->lfPitchAndFamily = plfW->lfPitchAndFamily;

    DWORD dwChs = plfW->lfCharSet;
    CHARSETINFO ChsInfo = {0};

    if (dwChs != SYMBOL_CHARSET && TranslateCharsetInfo( &dwChs, &ChsInfo, TCI_SRCCHARSET )) 
    {
        cpg = ChsInfo.ciACP;
    }
    else
        cpg  = GetACP();

    WideCharToMultiByte( cpg, 
                         0, 
                         plfW->lfFaceName, 
                         -1, 
                         plfA->lfFaceName, 
                         ARRAYSIZE(plfA->lfFaceName),
                         NULL, 
                         NULL );

}



///////////////////////////////////////////////////////////////////////////////
//
//class CSoftkbdButton
//
///////////////////////////////////////////////////////////////////////////////

CSoftkbdButton::CSoftkbdButton(CUIFObject *pParent, DWORD dwID, const RECT *prc, DWORD dwStyle, KEYID keyId) : CUIFButton2 (pParent, dwID, prc, dwStyle)
{
    m_keyId = keyId;

    CUIFWindow *pUIWnd;
    pUIWnd = pParent->GetUIWnd( );

    m_hFont = pUIWnd->GetFont( );
}


CSoftkbdButton::~CSoftkbdButton( void )
{
    if ( m_hBmp )
    {
        ::DeleteObject( (HGDIOBJ) m_hBmp );
        m_hBmp = NULL;
    }

    if ( m_hBmpMask )
    {
        ::DeleteObject( (HGDIOBJ)m_hBmpMask );
        m_hBmpMask = NULL;
    }

    if ( m_hIcon )
    {
        ::DestroyIcon(m_hIcon);
        m_hIcon = NULL;
    }

}


HRESULT CSoftkbdButton::SetSoftkbdBtnBitmap(HINSTANCE hResDll, WCHAR  * wszBitmapStr)
{
    HRESULT    hr = S_OK;
    char       pBitmapAnsiName[MAX_PATH];
    HBITMAP    hBitMap;

    WideCharToMultiByte(CP_ACP, 0, wszBitmapStr, -1, pBitmapAnsiName, MAX_PATH, NULL, NULL);

    hBitMap = (HBITMAP) MyLoadImage(hResDll,  pBitmapAnsiName);

    if ( hBitMap == NULL )
    {

        if ( hResDll != g_hInst )
        {

           // cannot load it from client-supplied resource dll,
           // try our softkbd.dll to see if there is one internal bitmap for this label.

           hBitMap = (HBITMAP) MyLoadImage(g_hInst,  pBitmapAnsiName);

        }
    }

    if ( hBitMap == NULL )
    {
         hr = E_FAIL;
         return hr;
    }

    CMaskBitmap maskBmp(hBitMap);
            
    maskBmp.Init(GetSysColor(COLOR_BTNTEXT));
    SetBitmap( maskBmp.GetBmp() );
    SetBitmapMask( maskBmp.GetBmpMask() );

    ::DeleteObject(hBitMap);

    return hr;

};

HRESULT  CSoftkbdButton::ReleaseButtonResouce( )
{

    HRESULT  hr = S_OK;

    if ( m_hBmp )
    {
        ::DeleteObject( (HGDIOBJ) m_hBmp );
        m_hBmp = NULL;
    }

    if ( m_hBmpMask )
    {
        ::DeleteObject( (HGDIOBJ)m_hBmpMask );
        m_hBmpMask = NULL;
    }

    if ( m_hIcon )
    {
        ::DestroyIcon(m_hIcon);
        m_hIcon = NULL;
    }

    if (m_pwchText != NULL) {
        delete m_pwchText;
        m_pwchText = NULL;
    }

    return hr;
}

//////////////////////////////////////////////////////////////////////////////
//
//  CStaticBitmap
//
//////////////////////////////////////////////////////////////////////////////


CStaticBitmap::CStaticBitmap(CUIFObject *pParent, DWORD dwID, const RECT *prc, DWORD dwStyle) : CUIFObject(pParent, dwID, prc, dwStyle )
{
    m_hBmp = NULL;
    m_hBmpMask = NULL;
}

CStaticBitmap::~CStaticBitmap( void )
{

    if ( m_hBmp )
    {
        ::DeleteObject(m_hBmp);
        m_hBmp = NULL;
    }

    if ( m_hBmpMask )
    {
        ::DeleteObject(m_hBmpMask);
        m_hBmpMask = NULL;
    }

}

HRESULT  CStaticBitmap::SetStaticBitmap(HINSTANCE hResDll, WCHAR  * wszBitmapStr )
{
    HRESULT    hr = S_OK;
    char       pBitmapAnsiName[MAX_PATH];
    HBITMAP    hBitMap;

    WideCharToMultiByte(CP_ACP, 0, wszBitmapStr, -1, pBitmapAnsiName, MAX_PATH, NULL, NULL);

    hBitMap = (HBITMAP) MyLoadImage(hResDll, pBitmapAnsiName);

    if ( hBitMap == NULL )
    {

        if ( hResDll != g_hInst )
        {

           // cannot load it from client-supplied resource dll,
           // try our softkbd.dll to see if there is one internal bitmap for this label.

           hBitMap = (HBITMAP) MyLoadImage(g_hInst, pBitmapAnsiName);

        }
    }

    if ( hBitMap == NULL )
    {
         hr = E_FAIL;
         return hr;
    }

    CMaskBitmap maskBmp(hBitMap);
            
    maskBmp.Init(GetSysColor(COLOR_BTNTEXT));
    m_hBmp = maskBmp.GetBmp();
    m_hBmpMask = maskBmp.GetBmpMask();

    ::DeleteObject(hBitMap);

    return hr;
}

void CStaticBitmap::OnPaint( HDC hDC )
{

    if ( !hDC || !m_hBmp ||!m_hBmpMask )
        return;

    const RECT *prc = &GetRectRef();
    const int nWidth = prc->right - prc->left;
    const int nHeight= prc->bottom - prc->top;


    HBITMAP hBmp = CreateMaskBmp(&GetRectRef(),
                                 m_hBmp,
                                 m_hBmpMask,
                                 (HBRUSH)(COLOR_3DFACE + 1) , 0, 0);

    DrawState(hDC,
              NULL,
              NULL,
              (LPARAM)hBmp,
              0,
              prc->left,
              prc->top,
              nWidth,
              nHeight,
              DST_BITMAP);
 
    DeleteObject(hBmp);

}

//////////////////////////////////////////////////////////////////////////////
//
//  CTitleUIGripper
//
//////////////////////////////////////////////////////////////////////////////

void CTitleUIGripper::OnPaint(HDC hDC) {

    RECT rc ;

    if (GetRectRef().right-GetRectRef().left <= GetRectRef().bottom-GetRectRef().top) {

        ::SetRect(&rc, GetRectRef().left + 1, 
                       GetRectRef().top, 
                       GetRectRef().left + 4, 
                       GetRectRef().bottom);
    } else {
        ::SetRect(&rc, GetRectRef().left, 
                       GetRectRef().top + 1, 
                       GetRectRef().right, 
                       GetRectRef().top+4);
    }

    DrawEdge(hDC, &rc, BDR_RAISEDINNER, BF_RECT);
}


void CTitleUIGripper::OnLButtonUp( POINT pt )
{
    CSoftkbdUIWnd *pUIWnd;

    // call base class's member function first.
    CUIFGripper::OnLButtonUp(pt);

    pUIWnd = (CSoftkbdUIWnd *)GetUIWnd( );

    if ( pUIWnd != NULL )
    {
        // Notify the Window position move.
        pUIWnd->_OnWindowMove( );
    }

    return;
}

//////////////////////////////////////////////////////////////////////////////
//
// CTitleBarUIObj
//
//////////////////////////////////////////////////////////////////////////////

CTitleBarUIObj::CTitleBarUIObj(CUIFObject *pWndFrame, const RECT *prc, TITLEBAR_TYPE TitleBar_Type)
                           : CUIFObject(pWndFrame, 0, prc, 0)
{
    m_TitlebarType = TitleBar_Type;
    m_pCloseButton = NULL;
    m_pIconButton = NULL;

}


CTitleBarUIObj::~CTitleBarUIObj(void)
{
    HBITMAP  hBitmap;
    HBITMAP  hBitmapMask;

    if ( m_pCloseButton )
    {
        if (hBitmap=m_pCloseButton->GetBitmap()) {
            m_pCloseButton->SetBitmap((HBITMAP) NULL);
            ::DeleteObject(hBitmap);
        }

        if (hBitmapMask=m_pCloseButton->GetBitmapMask()) {
            m_pCloseButton->SetBitmapMask((HBITMAP) NULL);
            ::DeleteObject(hBitmapMask);
        }

    }
}

//----------------------------------------------------------------------------
HRESULT CTitleBarUIObj::_Init(WORD  wIconId,  WORD  wCloseId)
{
    
    HRESULT   hr = S_OK;
   
    RECT rectObj = {0,0,0,0};
    RECT rectGripper;

    if ( m_TitlebarType == TITLEBAR_NONE )
        return hr;

    GetRect(&rectGripper);
    rectObj = rectGripper;

    long lIconWidth=rectObj.bottom-rectObj.top + 1;

    this->m_pointPreferredSize.y=lIconWidth;

    if ( m_TitlebarType == TITLEBAR_GRIPPER_VERTI_ONLY )
    {

        // This is a vertical gripper only title bar.

        rectGripper.left += 2;
        rectGripper.right-= 2;

        rectGripper.top += 2;
        rectGripper.bottom -= 2;

        CUIFObject *pUIFObject=new CTitleUIGripper(this,&rectGripper);

        if ( !pUIFObject )
            return E_OUTOFMEMORY;

        pUIFObject->Initialize();
        this->AddUIObj(pUIFObject);

        return hr;
    }



    if ( m_TitlebarType == TITLEBAR_GRIPPER_HORIZ_ONLY )
    {

        // This is a Horizontal gripper only title bar.

        rectGripper.left  += 2;
        rectGripper.right -= 2;

        rectGripper.top += 2;
        rectGripper.bottom -= 2;

        CUIFObject *pUIFObject=new CTitleUIGripper(this,&rectGripper);
       
        if ( !pUIFObject )
            return E_OUTOFMEMORY;

        pUIFObject->Initialize();
        this->AddUIObj(pUIFObject);

        return hr;
    }

    if ( wIconId != 0 )
    {

        rectObj.right=rectObj.left+lIconWidth;
        m_pIconButton=new CStaticBitmap(this,wIconId,&rectObj,0);
        if (m_pIconButton)
        {
            m_pIconButton->Initialize();
            m_pIconButton->SetStaticBitmap(g_hInst, L"IDB_ICON");
            m_pIconButton->m_pointPreferredSize.x=lIconWidth;
            this->AddUIObj(m_pIconButton);
        }

        rectGripper.left = rectObj.right + 4;
    }

    if ( wCloseId != 0 )
    {

        rectObj.left=rectGripper.right - lIconWidth -1;
        rectObj.right=rectGripper.right;
        m_pCloseButton=new CSoftkbdButton(this,wCloseId,&rectObj,UIBUTTON_SUNKENONMOUSEDOWN | UIBUTTON_CENTER | UIBUTTON_VCENTER, 0);
        if (m_pCloseButton)
        {
            m_pCloseButton->Initialize();
            m_pCloseButton->SetSoftkbdBtnBitmap(g_hInst, L"IDB_CLOSE");
            m_pCloseButton->m_pointPreferredSize.x=lIconWidth;
            this->AddUIObj(m_pCloseButton);
        }

        rectGripper.right = rectObj.left - 4;

    }

    rectGripper.top += 3;

    CUIFObject *pUIFObject=new CTitleUIGripper(this,&rectGripper);
    if ( !pUIFObject )
       return E_OUTOFMEMORY;

    pUIFObject->Initialize();
    this->AddUIObj(pUIFObject);
   

    return hr;

}

///////////////////////////////////////////////////////////////////////////
//
// CSoftkbdUIWnd
//
///////////////////////////////////////////////////////////////////////////

CSoftkbdUIWnd::CSoftkbdUIWnd(CSoftKbd *pSoftKbd, HINSTANCE hInst,UINT uiWindowStyle) : CUIFWindow(hInst, uiWindowStyle)
{                  

    m_pSoftKbd = pSoftKbd;
    m_TitleBar = NULL;
    m_Titlebar_Type = TITLEBAR_NONE;
    m_bAlpha = 0;
    m_fShowAlphaBlend =TRUE; 
    m_hUserTextFont = NULL;

}


CSoftkbdUIWnd::~CSoftkbdUIWnd( )
{

    // if there is hwnd, detroy it and all the children objects.

    if ( m_hWnd  && IsWindow(m_hWnd) )
    {
        ::DestroyWindow( m_hWnd );
        m_hWnd = NULL;
    }

    if ( m_hUserTextFont )
    {
        SetFont((HFONT)NULL);
        DeleteObject(m_hUserTextFont);
        m_hUserTextFont = NULL;
    }
}

const TCHAR c_szCTFLangBar[] = TEXT("Software\\Microsoft\\CTF\\LangBar");
const TCHAR c_szTransparency[] = TEXT("Transparency");

// Get the Alpha Blending set value from registry:
//
//  HKCU\Software\Microsoft\CTF\LangBar:  Transparency : REG_DWORD
//
INT    CSoftkbdUIWnd::_GetAlphaSetFromReg( )
{
    LONG      lret = ERROR_SUCCESS;
    CMyRegKey regkey;
    DWORD     dw = 255;

    lret = regkey.Open(HKEY_CURRENT_USER,
                       c_szCTFLangBar,
                       KEY_READ);

    if (ERROR_SUCCESS == lret)
    {
        lret = regkey.QueryValue(dw, c_szTransparency);
        regkey.Close();
    }

    return (INT)dw;
}


LRESULT CSoftkbdUIWnd::OnObjectNotify(CUIFObject * pUIObj, DWORD dwCode, LPARAM lParam)
{

    KEYID  keyId;
    DWORD  dwObjId;

    UNREFERENCED_PARAMETER(dwCode);
    UNREFERENCED_PARAMETER(lParam);

    if ( m_pSoftKbd == NULL )
        return 0;

    dwObjId = pUIObj->GetID();

    if ( dwObjId != 0 )
    {
        // This is button object, not gripper object.
        CSoftkbdButton   *pButton;

        if ( dwCode == UIBUTTON_PRESSED )
        {

            pButton = (CSoftkbdButton * )pUIObj;

            if ( dwObjId <= MAX_KEY_NUM )
            {
                // regular keys in the keyboard layout.
                keyId = pButton->GetKeyId( );
                m_pSoftKbd->_HandleKeySelection(keyId); 
            }
            else
            {
                // Titlebar buttons
                m_pSoftKbd->_HandleTitleBarEvent(dwObjId);
            }
        }
    }

    return 0;
}

CUIFObject *CSoftkbdUIWnd::Initialize( void )
{
    //
    // Get the current active keyboard layout and register window class
    // not to send VK_PROCESSKEY by mouse down/up in Korean SoftKbd.
    // Related bug#472946 #495890
    //
    LANGID langId = LOWORD(HandleToUlong(GetKeyboardLayout(0)));

    if (PRIMARYLANGID(langId) == LANG_KOREAN)
    {
        //
        // Here register candidate window class.
        //
        WNDCLASSEX WndClass;
        LPCTSTR pszClassName = GetClassName();

        memset(&WndClass, 0, sizeof(WndClass));

        WndClass.cbSize = sizeof(WndClass);
        // Added CS_IME style not to send VK_PROCESSKEY for mouse down/up.
        WndClass.style         = CS_HREDRAW | CS_VREDRAW | CS_DBLCLKS | CS_IME;
    
        WndClass.lpfnWndProc   = WindowProcedure;
        WndClass.cbClsExtra    = 0;
        WndClass.cbWndExtra    = 8;
        WndClass.hInstance     = g_hInst;
        WndClass.hIcon         = NULL;
        WndClass.hCursor       = LoadCursor(NULL, IDC_ARROW);
        WndClass.hbrBackground = NULL;
        WndClass.lpszMenuName  = NULL;
        WndClass.lpszClassName = pszClassName;
        WndClass.hIconSm       = NULL;

        RegisterClassEx(&WndClass);
    }

    CUIFObject  *pUIObjRet;
	
    // call CUIFWindow::Initialize() to create tooltip window

    pUIObjRet = CUIFWindow::Initialize();

    return pUIObjRet;
}


HWND CSoftkbdUIWnd::_CreateSoftkbdWindow(HWND hOwner,  TITLEBAR_TYPE Titlebar_type, INT xPos, INT yPos,  INT width, INT height)
{

    HWND  hWnd;

    hWnd = CreateWnd(hOwner);

    Move(xPos, yPos, width, height);

    m_Titlebar_Type = Titlebar_type;

    return hWnd;

}


HRESULT CSoftkbdUIWnd::_GenerateWindowLayout( )
{

    HRESULT         hr=S_OK;
    int             i;
    KBDLAYOUT       *realKbdLayout=NULL;
    KBDLAYOUTDES    *lpCurKbdLayout=NULL;
    CSoftkbdButton  *pButton = NULL;
    int             nChild;


    if ( m_pSoftKbd ==  NULL )
        return E_FAIL;


    if ( (m_TitleBar == NULL) && ( m_Titlebar_Type != TITLEBAR_NONE) )
    {

        RECT   *prc;

        // Get the titlebar rect.

        prc = m_pSoftKbd->_GetTitleBarRect( );

        m_TitleBar = (CTitleBarUIObj  *) new CTitleBarUIObj(this, prc, m_Titlebar_Type);

        if ( m_TitleBar == NULL )
            return E_FAIL;

        m_TitleBar->Initialize( );

        m_TitleBar->_Init(KID_ICON, KID_CLOSE);
        AddUIObj(m_TitleBar);

    }

    // If there is any existing object in this window object, just delete all of them, except for Titlebar object

    nChild = m_ChildList.GetCount();
    for (i=nChild; i>0; i--) {

        CUIFObject  *pUIObj = m_ChildList.Get(i-1);

        if ( pUIObj->GetID( ) != 0 )
        {
            // This is not Gripper

            m_ChildList.Remove(pUIObj);
        
            delete pUIObj;
        }
    }

    // Add all the keys contained in current layout to this window object as its children objects.
    // every key should have already been calculated the correct position and size.

    lpCurKbdLayout = m_pSoftKbd->_GetCurKbdLayout( );

    if ( lpCurKbdLayout == NULL )
        return E_FAIL;

    realKbdLayout = &(lpCurKbdLayout->kbdLayout);

    if ( realKbdLayout == NULL ) return E_FAIL;

    for ( i=0; i<realKbdLayout->wNumberOfKeys; i++) {

        KEYID       keyId;
        RECT        keyRect={0,0,0,0};
        

        keyId = realKbdLayout->lpKeyDes[i].keyId; 

        keyRect.left   = realKbdLayout->lpKeyDes[i].wLeft;
        keyRect.top    = realKbdLayout->lpKeyDes[i].wTop;
        keyRect.right  = realKbdLayout->lpKeyDes[i].wWidth + keyRect.left - 1;
        keyRect.bottom = realKbdLayout->lpKeyDes[i].wHeight + keyRect.top - 1;

        if ( realKbdLayout->lpKeyDes[i].tModifier == none )
        {
            // This is a normal key
            pButton = new CSoftkbdButton(this, i+1, &keyRect, UIBUTTON_SUNKENONMOUSEDOWN | UIBUTTON_CENTER | UIBUTTON_VCENTER, keyId);
        }
        else
        {
            // This is toggle key,  Modifier key.
            pButton = new CSoftkbdButton(this, i+1, &keyRect, UIBUTTON_SUNKENONMOUSEDOWN | UIBUTTON_CENTER | UIBUTTON_VCENTER | UIBUTTON_TOGGLE, keyId);

        }

        Assert(pButton);

        if ( !pButton || !pButton->Initialize() )
        {

            // may need to release all created buttons.
            return E_FAIL;
        }

        // add this button to this window container.
        // button lable ( text or bitmap, or Icon ) will be set later when user selects modification status.

        AddUIObj(pButton);

    }

    return hr;
}


HRESULT CSoftkbdUIWnd::_SetKeyLabel( )
{

    HRESULT         hr=S_OK;
    CSoftkbdButton *pButton; 
    int             i, iIndex;
    ACTIVELABEL    *pCurLabel;
    KEYID           keyId;
    HINSTANCE       hResDll;
    KBDLAYOUTDES   *lpCurKbdLayout=NULL;
    KBDLAYOUT      *realKbdLayout=NULL;
    int            nChild;
    int            nCur;

    if ( m_pSoftKbd ==  NULL )
        return E_FAIL;

    lpCurKbdLayout = m_pSoftKbd->_GetCurKbdLayout( );

    if ( lpCurKbdLayout == NULL )
        return E_FAIL;

    realKbdLayout = &(lpCurKbdLayout->kbdLayout);

    if ( realKbdLayout == NULL ) return E_FAIL;

    if ( (lpCurKbdLayout->lpKeyMapList)->wszResource[0] == L'\0' )
    {
    	// 
    	// There is no separate dll to keep picture key.
    	// probably, it is a standard soft keyboard layout.
    	// so just use internal resource kept in this dll.
        //

    	hResDll = g_hInst;
    }
    else
    {
    	// There is a separate DLL to keep the bitmap resource.

    	CHAR  lpszAnsiResFile[MAX_PATH];

    	WideCharToMultiByte(CP_ACP, 0, (lpCurKbdLayout->lpKeyMapList)->wszResource, -1,
    		                lpszAnsiResFile, MAX_PATH, NULL, NULL );

    	hResDll = (HINSTANCE) LoadLibraryA( lpszAnsiResFile );

    	if ( hResDll == NULL )
    	{

    		Assert(hResDll!=NULL);
    		return E_FAIL;
    	}
    }

    // All the keys are already added to this window container.
    // we need to set the label ( text or picture) based on current m_pSoftKbd setting.

    pCurLabel = m_pSoftKbd->_GetCurLabel( );

    nChild = m_ChildList.GetCount();
    for (nCur = 0; nCur < nChild; nCur++) {

        DWORD  dwObjId;

        pButton = (CSoftkbdButton *)(m_ChildList.Get(nCur));
            
        dwObjId = pButton->GetID( );

        if ( dwObjId == 0 )
        {
            continue;
        }

        // Get the keyindex in CurLabel array.

        keyId = pButton->GetKeyId( );
        iIndex = -1;

        for ( i=0; i<MAX_KEY_NUM; i++ )
        {
            if ( pCurLabel[i].keyId == keyId )
            {
                iIndex = i;
                break;
            }
        }

        if ( iIndex == -1 )
        {
            // Cannot find this key,
            // return error.

            hr = E_FAIL;
            goto CleanUp;
        }


        // Found it, set the label
        //
        // if it is text key, call pButton->SetText( )
        // if it is picture key, call pButton->SetBitmap( )

        // Before we set the lable, we need to release all the previous resources
        // for this key button, so that we will not cause resource leak.

        pButton->ReleaseButtonResouce( );

        if ( pCurLabel[iIndex].LabelType == LABEL_TEXT )
            pButton->SetText( pCurLabel[iIndex].lpLabelText);
        else
        {
            pButton->SetSoftkbdBtnBitmap(hResDll, pCurLabel[iIndex].lpLabelText);
        }

        // if it is Disp_Active, call pButton->Enable(TRUE)
        // if it is gray key,  call pButton->Enable(FALSE)

        if ( pCurLabel[iIndex].LabelDisp == LABEL_DISP_ACTIVE )
        {
            pButton->Enable(TRUE);
        }
        else
        {
            pButton->Enable(FALSE);
        }

    	if ( realKbdLayout->lpKeyDes[dwObjId-1].tModifier != none )
    	{
    		// this is a modifier key ( Toggle key )
    		// check to see if this key is pressed.
    		MODIFYTYPE tModifier;

    		tModifier = realKbdLayout->lpKeyDes[dwObjId-1].tModifier;

    		if ( lpCurKbdLayout->ModifierStatus & (1 << tModifier) )
    		{
    			// this modifier key has been pressed.

                pButton->SetToggleState(TRUE);
    		}
            else
                pButton->SetToggleState(FALSE);
    	}
            
    }

CleanUp:
    //	Release the resource DLL if there is a separate one.

    if ( (lpCurKbdLayout->lpKeyMapList)->wszResource[0] != L'\0' )
    {

    	// There is a separate DLL to keep the bitmap resource.

    	FreeLibrary(hResDll);

    }

    return hr;
}


void CSoftkbdUIWnd::Show( INT  iShow )
{

    KBDLAYOUTDES   *lpCurKbdLayout=NULL;
    KBDLAYOUT      *realKbdLayout=NULL;
    int nChild;
    int i;

    if ( m_pSoftKbd ==  NULL )
        return;

    lpCurKbdLayout = m_pSoftKbd->_GetCurKbdLayout( );

    if ( lpCurKbdLayout == NULL )
        return;

    realKbdLayout = &(lpCurKbdLayout->kbdLayout);
    if ( realKbdLayout == NULL ) return;

    if ( !(iShow & SOFTKBD_SHOW)  || (iShow & SOFTKBD_DONT_SHOW_ALPHA_BLEND) )
       m_fShowAlphaBlend = FALSE;
    else
       m_fShowAlphaBlend = TRUE;
       

    m_bAlphaSet = _GetAlphaSetFromReg( );

    if ( iShow )
    {
        // check the togglable key's state.
        CSoftkbdButton *pButton; 

        nChild = m_ChildList.GetCount();
        for (i = 0; i < nChild; i++) {

            DWORD  dwObjId;
            pButton = (CSoftkbdButton *)m_ChildList.Get(i);
            dwObjId = pButton->GetID( );
            if ( dwObjId == 0 )
            {
                continue;
            }

    	    if ( realKbdLayout->lpKeyDes[dwObjId-1].tModifier != none )
    	    {
    		    // this is a modifier key ( Toggle key )
    		    // check to see if this key is pressed.
    		    MODIFYTYPE tModifier;
    
        		tModifier = realKbdLayout->lpKeyDes[dwObjId-1].tModifier;
    	    	if ( lpCurKbdLayout->ModifierStatus & (1 << tModifier) )
    		    {
    			    // this modifier key has been pressed.
                    pButton->SetToggleState(TRUE);
    		    }
                else
                    pButton->SetToggleState(FALSE);
    	    }
        }
    }

    CUIFWindow::Show((iShow & SOFTKBD_SHOW) ? TRUE : FALSE);

    POINT ptScrn;
   
    GetCursorPos(&ptScrn);
    if (WindowFromPoint(ptScrn) == GetWnd())
        SetAlpha(255);
    else
        SetAlpha(m_bAlphaSet);

    return;

}

void CSoftkbdUIWnd::UpdateFont( LOGFONTW  *plfFont )
{
    if ( !plfFont )
        return;

    HFONT    hNewFont;

    if ( IsOnNT( ) )
        hNewFont = CreateFontIndirectW( plfFont );
    else
    {
        LOGFONTA  lfTextFontA;
        ConvertLogFontWtoA(plfFont, &lfTextFontA);
        hNewFont = CreateFontIndirectA( &lfTextFontA );
    }

    if ( hNewFont )
    {
        SetFont(hNewFont);
        if ( m_hUserTextFont )
            DeleteObject( m_hUserTextFont );

        m_hUserTextFont = hNewFont;
    }
}


HRESULT CSoftkbdUIWnd::_OnWindowMove( )
{
    HRESULT   hr = S_OK;
    ISoftKbdWindowEventSink  *pskbdwndes;

    if ( m_pSoftKbd ==  NULL )
        return E_FAIL;

    pskbdwndes = m_pSoftKbd->_GetSoftKbdWndES( );

    if ( pskbdwndes != NULL )
    {
        pskbdwndes->AddRef( );
        hr = pskbdwndes->OnWindowMove(_xWnd, _yWnd, _nWidth, _nHeight);
        pskbdwndes->Release( );
    }

    return hr;
}


typedef BOOL (WINAPI * SETLAYERWINDOWATTRIBUTE)(HWND, COLORREF, BYTE, DWORD);
void CSoftkbdUIWnd::SetAlpha(INT bAlpha)
{
    if ( !m_fShowAlphaBlend )
       return;

    if ( m_bAlpha == bAlpha )
        return;

    if ( IsOnNT5() )
    {
        HINSTANCE hUser32;

        DWORD dwExStyle = GetWindowLong(GetWnd(), GWL_EXSTYLE);

        SetWindowLong(GetWnd(), GWL_EXSTYLE, dwExStyle | WS_EX_LAYERED);
        hUser32 = GetSystemModuleHandle(TEXT("user32.dll"));
        SETLAYERWINDOWATTRIBUTE  pfnSetLayeredWindowAttributes;
        if (pfnSetLayeredWindowAttributes = (SETLAYERWINDOWATTRIBUTE)GetProcAddress(hUser32, TEXT("SetLayeredWindowAttributes")))
            pfnSetLayeredWindowAttributes(GetWnd(), 0, (BYTE)bAlpha, LWA_ALPHA);

        m_bAlpha = bAlpha;
    }
    return;
}

void CSoftkbdUIWnd::HandleMouseMsg( UINT uMsg, POINT pt )
{
    POINT ptScrn = pt;
    ClientToScreen(GetWnd(), &ptScrn);
    if (WindowFromPoint(ptScrn) == GetWnd())
        SetAlpha(255);
    else
        SetAlpha(m_bAlphaSet);

    CUIFWindow::HandleMouseMsg(uMsg, pt);
}

void CSoftkbdUIWnd::OnMouseOutFromWindow( POINT pt )
{
    UNREFERENCED_PARAMETER(pt);
    SetAlpha(m_bAlphaSet);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\ctf\softkbd\softkbdui.h ===
//
// This is the header file of softkbd window ui.
//


#ifndef SOFTKBDUI_H
#define SOFTKBDUI_H

#include "private.h"
#include "globals.h"

#include "Softkbdc.h"

#include "cuiwnd.h"

class CSoftkbdUIWnd;

class CTitleUIGripper : public CUIFGripper
{
public:
    CTitleUIGripper( CUIFObject *pParent, const RECT *prc ) : CUIFGripper(pParent,prc) {};
    virtual void OnPaint(HDC hDC);
    virtual void OnLButtonUp( POINT pt );
};

class CSoftkbdButton : public CUIFButton2
{
public:
    CSoftkbdButton(CUIFObject *pParent, DWORD dwID, const RECT *prc, DWORD dwStyle, KEYID keyId);
    virtual ~CSoftkbdButton( void );

    HRESULT  SetSoftkbdBtnBitmap(HINSTANCE hResDll, WCHAR  * wszBitmapStr );
    KEYID    GetKeyId( )  {  return m_keyId; }
    HRESULT  ReleaseButtonResouce( );

private:
    KEYID    m_keyId;
};

class CStaticBitmap : public CUIFObject
{

public:
    CStaticBitmap(CUIFObject *pParent, DWORD dwID, const RECT *prc, DWORD dwStyle);
    virtual  ~CStaticBitmap( void );

    HRESULT   SetStaticBitmap(HINSTANCE hResDll, WCHAR  * wszBitmapStr );
    virtual void OnPaint( HDC hDC );

private:
    HBITMAP m_hBmp;
    HBITMAP m_hBmpMask;
};

class CTitleBarUIObj : public CUIFObject
{
public:
    CTitleBarUIObj(CUIFObject *pWndFrame, const RECT *prc, TITLEBAR_TYPE TitleBar_Type);
    virtual ~CTitleBarUIObj();

    HRESULT _Init(WORD  wIconId,  WORD  wCloseId);

private:
    CStaticBitmap    *m_pIconButton;
    CSoftkbdButton   *m_pCloseButton;
    TITLEBAR_TYPE     m_TitlebarType;
    
};

class CSoftkbdUIWnd : public CUIFWindow
{

public:
   
    CSoftkbdUIWnd(CSoftKbd *pSoftKbd, HINSTANCE hInst,UINT uiWindowStyle=UIWINDOW_TOPMOST | UIWINDOW_TOOLWINDOW | UIWINDOW_WSDLGFRAME);
    ~CSoftkbdUIWnd( );

    void Show( INT iShow );

    LPCTSTR GetClassName( void ) {
            return c_szSoftKbdUIWndClassName;
    }

    LRESULT OnObjectNotify(CUIFObject * pUIObj, DWORD dwCode, LPARAM lParam);
    HWND _CreateSoftkbdWindow(HWND hOwner,  TITLEBAR_TYPE Titlebar_type, INT xPos, INT yPos,  INT width, INT height);
    HRESULT _GenerateWindowLayout( );
    HRESULT _SetKeyLabel( );

    INT     _GetAlphaSetFromReg( );

    HRESULT _OnWindowMove( );

    void SetAlpha(INT bAlpha);
    void HandleMouseMsg( UINT uMsg, POINT pt );
    void OnMouseOutFromWindow( POINT pt );
    void UpdateFont( LOGFONTW  *plfFont );

    virtual CUIFObject *Initialize( void );

private:

    CSoftKbd        *m_pSoftKbd;
    CTitleBarUIObj  *m_TitleBar;

    HFONT           m_hUserTextFont;    // text font set by user.  
                                        // if user doesn't set text font, this member should be NULL, and DEFAULT_GUI_FONT
                                        // will be used.

    TITLEBAR_TYPE   m_Titlebar_Type;
    INT             m_bAlpha;
    BOOL            m_fShowAlphaBlend;
    INT             m_bAlphaSet;
};


#endif /* SOFTKBDUI_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\ctf\tipupd\resource.h ===
//
// resource.h
//

#ifndef RESOURCE_H_
#define RESOURCE_H_


//
// dialog ids
//
#define IDS_TIPUPD_TITLE                1000
#define IDS_TIP_NOCOMPONENTERR          1001


#define IDC_LIST_TIP                    2000
#define IDC_BUTTON_MORE                 2001
#define IDC_STATIC                        -1



//
// dialog ids
//
#define IDD_TIPUPD_DIALOG               3000



#endif // RESOURCE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\ctf\tipupd\private.h ===
//+---------------------------------------------------------------------------
//
//  File:       private.h
//
//  Contents:   Private header for aimmload project.
//
//----------------------------------------------------------------------------

#ifndef _PRIVATE_H_
#define _PRIVATE_H_

#define _OLEAUT32_

#include <windows.h>
#include <ccstock.h>
#include <debug.h>

#endif  // _PRIVATE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\ctf\tipupd\tipdlg.h ===
//
// TipDlg.h
//

#ifndef TIPDLG_H
#define TIPDLG_H

#include "private.h"
#include "commctrl.h"

//////////////////////////////////////////////////////////////////////////////
//
// CTipUpdDlg
//
//////////////////////////////////////////////////////////////////////////////

class CTipUpdDlg
{
public:
    CTipUpdDlg();
    ~CTipUpdDlg();

    int LoadTipUpdDlg(HINSTANCE hInst, HWND hWnd);

    static BOOL CALLBACK TipUpdDlgProc(HWND hDlg, UINT uMsg, WPARAM wParam, LPARAM lParam);

private:
    static void SetThis(HWND hWnd, LPARAM lParam)
    {
        SetWindowLongPtr(hWnd, DWLP_USER, (long)lParam);
    }

    static CTipUpdDlg *GetThis(HWND hWnd)
    {
        CTipUpdDlg *p = (CTipUpdDlg *)GetWindowLongPtr(hWnd, DWLP_USER);

        return p;
    }

    BOOL OnInitDlg(HWND hDlg);
    BOOL OnCommand(HWND hDlg, WPARAM wParam, LPARAM lParam);
    BOOL OnNotify(HWND hDlg, WPARAM wParam, LPARAM lParam);

    BOOL GetAvailableTips(UINT i, TCHAR *lpTipDesc);
    BOOL InstallSelectedTips(HWND hDlg);

    BOOL UpdateListView(HWND hDlg);
    BOOL ListViewItemChanged(HWND hDlg, NM_LISTVIEW *pLV);

    BOOL _fUpdating;

    HINSTANCE _hInst;
    
};

#endif // TIPDLG_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\ctf\tipupd\tipupd.cpp ===
//
// tipupd.cpp
//

#include "private.h"
#include "tipupd.h"
#include "tipdlg.h"



CTipUpdWnd *g_pTipUpdWnd;

HINSTANCE g_hInst;

HANDLE g_hInstanceMutext;

const TCHAR c_szTipUpdWndClass[] = TEXT("TipUpdWndClass");

BOOL CTipUpdWnd::_bWndClassRegistered = FALSE;


BOOL InitApp(HINSTANCE hInstance)
{
    g_hInstanceMutext = CreateMutex(NULL, FALSE, TEXT("TipUpdInstMutext"));

    if (GetLastError() == ERROR_ALREADY_EXISTS)
    {
        // another tipupd process is already running
        return FALSE;
    }

    g_hInst = hInstance;

    g_pTipUpdWnd = new CTipUpdWnd();

    if (!g_pTipUpdWnd)
        return FALSE;

    g_pTipUpdWnd->CreateWnd();

    return TRUE;
}

void UninitApp(void)
{
    delete g_pTipUpdWnd;

    CloseHandle(g_hInstanceMutext);
}

int WINAPI WinMain (HINSTANCE hInstance, HINSTANCE hPrevInstance, PSTR szCmdLine, int iCmdShow)
{
    MSG msg;

    if (!InitApp(hInstance))
    {
        return 0;
    }

    while (GetMessage(&msg, NULL, 0, 0))
    {
        TranslateMessage(&msg);
        DispatchMessage(&msg);
    }

    UninitApp();

    return msg.wParam;
}


//+---------------------------------------------------------------------------
//
// ctor
//
//----------------------------------------------------------------------------

CTipUpdWnd::CTipUpdWnd()
{
    _hWnd = NULL;

    if (!_bWndClassRegistered)
    {
        WNDCLASSEX wc;
        memset(&wc, 0, sizeof(wc));
        wc.cbSize = sizeof(wc);
        wc.style = CS_HREDRAW | CS_VREDRAW ;
        wc.hInstance = g_hInst;
        wc.hCursor = LoadCursor(NULL, IDC_ARROW);
        wc.lpfnWndProc = _TipUpdWndProc;
        wc.lpszClassName = c_szTipUpdWndClass;
        RegisterClassEx(&wc);
        _bWndClassRegistered = TRUE;
    }

}

//+---------------------------------------------------------------------------
//
// dtor
//
//----------------------------------------------------------------------------

CTipUpdWnd::~CTipUpdWnd()
{
}

//+---------------------------------------------------------------------------
//
// CreateWnd
//
//----------------------------------------------------------------------------

HWND CTipUpdWnd::CreateWnd()
{
    _hWnd = CreateWindowEx(0, c_szTipUpdWndClass, TEXT(""),
                           WS_DISABLED,
                           0, 0, 0, 0,
                           NULL, 0, g_hInst, 0);



    return _hWnd;
}

//+---------------------------------------------------------------------------
//
// _WndProc
//
//----------------------------------------------------------------------------

LRESULT CALLBACK CTipUpdWnd::_TipUpdWndProc(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    switch (uMsg)
    {
        case WM_CREATE:
            {
               CTipUpdDlg *pTipUpdDlg = new CTipUpdDlg;

               pTipUpdDlg->LoadTipUpdDlg(g_hInst, hWnd);

               delete pTipUpdDlg;
            }
            break;

        case WM_DESTROY:
            PostQuitMessage(0);
            break;

        default:
            return DefWindowProc(hWnd, uMsg, wParam, lParam);
    }

    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\ctf\tipupd\tipdlg.cpp ===
//
// tipbar.cpp
//

#include "private.h"
#include "tipdlg.h"
#include "resource.h"

#include <msi.h>


//
//  Tip installation GUID
//
#define TIPINSTALL_GUID         "{0009DB36-5810-43b0-BDF6-2DA5D618BEB9}"


//
//  Definition to load Office update URL
//
#define URL_OFFICE_UPDATE        TEXT("http://officeupdate.microsoft.com")
#define SHELLEXEC_COMMAND        TEXT("open")
#define IEXPLOREFILENAME         TEXT("iexplore.exe")




//////////////////////////////////////////////////////////////////////////////
//
// CTipUpdDlg
//
//////////////////////////////////////////////////////////////////////////////

//+---------------------------------------------------------------------------
//
// CTipUpdDlg::ctor
//
//----------------------------------------------------------------------------

CTipUpdDlg::CTipUpdDlg()
{
}

//+---------------------------------------------------------------------------
//
// CTipUpdDlg::dtor
//
//----------------------------------------------------------------------------

CTipUpdDlg::~CTipUpdDlg()
{
}

//+---------------------------------------------------------------------------
//
// CTipUpdDlg::DoModal
//
//----------------------------------------------------------------------------
int CTipUpdDlg::LoadTipUpdDlg(HINSTANCE hInst, HWND hWnd)
{
    InitCommonControls();

    _hInst = hInst;
    return DialogBoxParam(_hInst,
                          MAKEINTRESOURCE(IDD_TIPUPD_DIALOG),
                          hWnd,
                          TipUpdDlgProc,
                          (LPARAM) this);
}

//+---------------------------------------------------------------------------
//
// TipUpdDlgProc
//
//----------------------------------------------------------------------------

BOOL CALLBACK CTipUpdDlg::TipUpdDlgProc(HWND hDlg, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    switch (uMsg) 
    {
        case WM_INITDIALOG:
            SetThis(hDlg, lParam);

            GetThis(hDlg)->OnInitDlg(hDlg);
            GetThis(hDlg)->UpdateListView(hDlg);

            break;

        case WM_COMMAND:
            GetThis(hDlg)->OnCommand(hDlg, wParam, lParam);
            break;

        case WM_NOTIFY:
            return GetThis(hDlg)->OnNotify(hDlg, wParam, lParam);

        default:
            return FALSE;
    }

    return TRUE;

}


//+---------------------------------------------------------------------------
//
// OnInitDlg
//
//----------------------------------------------------------------------------

BOOL CTipUpdDlg::OnInitDlg(HWND hDlg)
{
    HWND hwndTipList;
    DWORD dwExStyle;
    LV_COLUMN Column;
    RECT rc;

    hwndTipList = GetDlgItem(hDlg, IDC_LIST_TIP);

    //
    // load Available Tips list from Darwin
    //

    GetClientRect(hwndTipList, &rc);
    Column.mask = LVCF_FMT | LVCF_TEXT | LVCF_WIDTH;
    Column.fmt = LVCFMT_LEFT;
    Column.cx = rc.right - GetSystemMetrics(SM_CYHSCROLL);
    Column.pszText = NULL;
    Column.cchTextMax = 0;
    Column.iSubItem = 0;
    ListView_InsertColumn(hwndTipList, 0, &Column);

    dwExStyle = ListView_GetExtendedListViewStyle(hwndTipList);
    ListView_SetExtendedListViewStyle(hwndTipList,
                                      dwExStyle |
                                       LVS_EX_CHECKBOXES |
                                       LVS_EX_FULLROWSELECT);

    return TRUE;
}

//+---------------------------------------------------------------------------
//
// UpdateListView
//
//----------------------------------------------------------------------------

BOOL CTipUpdDlg::UpdateListView(HWND hDlg)
{
    HWND hwndTipList;
    UINT i;
    TCHAR szTipDesc[MAX_PATH];
    BOOL fContinue = TRUE;

    _fUpdating = TRUE;

    hwndTipList = GetDlgItem(hDlg, IDC_LIST_TIP);

    ListView_DeleteAllItems(hwndTipList);

    for (i = 0; fContinue; i++)
    {
        LVITEM Item;
        Item.mask = LVIF_TEXT | LVIF_PARAM | LVIF_STATE;
        Item.iItem = 0;
        Item.iSubItem = 0;
        Item.state = 0;
        Item.stateMask = LVIS_STATEIMAGEMASK;
        Item.cchTextMax = 0;
        Item.iImage = 0;
        Item.lParam = (LPARAM)NULL;

        if (!(fContinue = GetAvailableTips(i, szTipDesc)))
            break;

        Item.pszText = szTipDesc;

        int nId = SendMessage(hwndTipList,
                          LVM_INSERTITEM,
                          0,
                          (LPARAM)&Item);

        ListView_SetCheckState(hwndTipList, nId, TRUE);
    }

    if (i == 0)
    {
        TCHAR szError[MAX_PATH];

        LoadString(_hInst, IDS_TIP_NOCOMPONENTERR, szError, MAX_PATH);
        MessageBox(hDlg, szError, NULL, MB_OK);
    }

    _fUpdating = FALSE;


    return TRUE;
}

//+---------------------------------------------------------------------------
//
// EnumAvailableTips
//
//----------------------------------------------------------------------------

BOOL CTipUpdDlg::GetAvailableTips(UINT i, TCHAR *lpTipDesc)
{
    BOOL fContinue = TRUE;
    UINT componentState;
    TCHAR szQualifier[MAX_PATH];
    DWORD cchQualifier;


    cchQualifier = sizeof(szQualifier) / sizeof(szQualifier[0]);
    componentState = MsiEnumComponentQualifiers(TIPINSTALL_GUID, i, szQualifier, &cchQualifier, NULL, NULL);

    if (componentState != ERROR_SUCCESS)
        return FALSE;

    // find the language ID
    // the string is formatted as 1033\xxxxxx
    // or						  1042
    {
        TCHAR szLangId[MAX_PATH];
        TCHAR *pSlash;

        lstrcpyn(szLangId, szQualifier, ARRAYSIZE(szLangId));
        pSlash = strchr(szLangId, '\\');

        if (pSlash)
            *pSlash = 0;

        lstrcpy(lpTipDesc, szLangId);
    }

    return TRUE;
}

//+---------------------------------------------------------------------------
//
// InstallSelectedTips
//
//----------------------------------------------------------------------------

BOOL CTipUpdDlg::InstallSelectedTips(HWND hDlg)
{
    INSTALLUILEVEL  iMsiOriginal;

    HWND hwndTipList;
    BOOL fContinue = TRUE;
    DWORD i;
    TCHAR szTipDesc[MAX_PATH];
    TCHAR szQualifier[MAX_PATH];
    TCHAR szPathBuf[MAX_PATH];
    DWORD cchPathBuf = sizeof(szQualifier) / sizeof(szQualifier[0]);
    UINT uItemCount;


    hwndTipList = GetDlgItem(hDlg, IDC_LIST_TIP);
    uItemCount = ListView_GetItemCount(hwndTipList);


    //iMsiOriginal = MsiSetInternalUI(INSTALLUILEVEL_DEFAULT, NULL);
    iMsiOriginal = MsiSetInternalUI(INSTALLUILEVEL_FULL, NULL);

    for (i=0; i < uItemCount; i++)
    {
        DWORD iResult = 0;
        LVITEM Item;

        if (!ListView_GetCheckState(hwndTipList, i))
            continue;

        Item.iSubItem = 0;
        Item.mask = LVIF_TEXT;
        Item.pszText = szTipDesc;
        Item.cchTextMax = MAX_PATH;

        int nId = SendMessage(hwndTipList,
                          LVM_GETITEMTEXTW,
                          i,
                          (LPARAM)&Item);

        if (!nId)
            continue;

        lstrcpy(szQualifier, szTipDesc);

        iResult = MsiProvideQualifiedComponent(TIPINSTALL_GUID,
                                                szQualifier,
                                                //INSTALLMODE_DEFAULT,
                                                INSTALLMODE_DEFAULT
                                                + REINSTALLMODE_FILEEQUALVERSION
                                                + REINSTALLMODE_MACHINEDATA
                                                + REINSTALLMODE_USERDATA
                                                + REINSTALLMODE_SHORTCUT,
                                                szPathBuf,
                                                &cchPathBuf);

        if ((iResult != ERROR_SUCCESS) && (iResult != ERROR_FILE_NOT_FOUND))
        {
            goto errorExit;
        }

    }

errorExit:
    MsiSetInternalUI(iMsiOriginal, NULL);

    return TRUE;
}

//+---------------------------------------------------------------------------
//
// OnCommand
//
//----------------------------------------------------------------------------

BOOL CTipUpdDlg::OnCommand(HWND hDlg, WPARAM wParam, LPARAM lParam)
{
    switch (LOWORD(wParam))
    {
        case IDC_BUTTON_MORE:
            {
            TCHAR szIexplore[MAX_PATH];


            ExpandEnvironmentStrings(IEXPLOREFILENAME, szIexplore, ARRAYSIZE(szIexplore));
            ShellExecute(NULL, SHELLEXEC_COMMAND, szIexplore, URL_OFFICE_UPDATE, NULL, SW_SHOWNORMAL);
            }
            break;

        case IDOK:
            InstallSelectedTips(hDlg);

        case IDCANCEL:
            EndDialog(hDlg, TRUE);
            SendMessage(GetParent(hDlg), WM_DESTROY, NULL, NULL);
            break;

        default:
            return FALSE;
    }

    return TRUE;
}


//+---------------------------------------------------------------------------
//
// ListViewItemChanged
//
//----------------------------------------------------------------------------

BOOL CTipUpdDlg::ListViewItemChanged(HWND hDlg, NM_LISTVIEW *pLV)
{
    HWND hwndTipList;
    BOOL bChecked;

    //
    //  Make sure it's a state change message.
    //
    if ((!(pLV->uChanged & LVIF_STATE)) ||
        ((pLV->uNewState & 0x3000) == 0))
    {
        return FALSE;
    }

    if (_fUpdating)
        return TRUE;

    hwndTipList = GetDlgItem(hDlg, IDC_LIST_TIP);
    bChecked = ListView_GetCheckState(hwndTipList, pLV->iItem) ? TRUE : FALSE;

    return TRUE;
}

//+---------------------------------------------------------------------------
//
// OnNotify
//
//----------------------------------------------------------------------------

BOOL CTipUpdDlg::OnNotify(HWND hDlg, WPARAM wParam, LPARAM lParam)
{
    switch (((LPNMHDR)lParam)->code) 
    {
        case LVN_ITEMCHANGED:
            ListViewItemChanged(hDlg,(NM_LISTVIEW *)lParam);
            break;

        default:
            return FALSE;
    }

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\ctf\tipupd\tipupd.h ===
//
// tipupd.h
//


#ifndef TIPUPD_H
#define TIPUPD_H


class CTipUpdWnd
{
public:
    CTipUpdWnd();
    ~CTipUpdWnd();

    HWND CreateWnd();
    HWND GetWnd() {return _hWnd;}
    void DestroyWnd() {DestroyWindow(_hWnd);}

private:
    static LRESULT CALLBACK _TipUpdWndProc(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam);

    static BOOL _bWndClassRegistered;
    HWND _hWnd;
};


#endif // TipUpd_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\ctf\uim\anchor.h ===
//
// anchor.h
//
// CAnchor
//

#ifndef ANCHOR_H
#define ANCHOR_H

#include "private.h"
#include "acp2anch.h"

class CAnchorRef;
class CACPWrap;

class CAnchor
{
public:
    CAnchor()
    { 
        Dbg_MemSetThisNameIDCounter(TEXT("CAnchor"), PERF_ANCHOR_COUNTER);
        Assert(_fNormalized == FALSE);
    }

    CACPWrap *_GetWrap()
    { 
        return _paw;   
    }

    BOOL _InsidePendingRange()
    {
        LONG ichDeltaStart;

        // if there's no pending delta range, we're not inside one
        if (!_paw->_IsPendingDelta())
            return FALSE;

        ichDeltaStart = _paw->_GetPendingDeltaAnchor()->_ich;

        // if the pending delta is negative, all anchor ich's are ascending
        if (_paw->_GetPendingDelta() < 0)
            return (_ich >= ichDeltaStart);

        // otherwise, there maybe overlapping anchor ichs like
        //    1, 3, 6 (delta start) 1, 3, 6, 10, ..
        //
        // so we can't always just test vs. ichDeltaStart.

        // we know the delta is positive, so an _ich less then the start ich
        // must not be in the pending range
        if (_ich < ichDeltaStart)
            return FALSE;

        // similarly, an ich >= ichDeltaStart + delta must be inside the range
        if (_ich >= ichDeltaStart + _paw->_GetPendingDelta())
            return TRUE;

        // if the ich matches the start of the pending delta, we can test vs.
        // the delta start anchor
        if (_ich == ichDeltaStart)
            return _paw->_GetPendingDeltaAnchor() == this;

        // if we get here, there's no way to tell just looking at this anchor
        // whether or not it's in the pending range -- its ich is legal
        // either way.  We have to bite the bullet and find its index in the
        // anchor array.
        return (_paw->_FindWithinPendingRange(_ich) == this);
    }

    int GetIch()
    { 
        return (_InsidePendingRange() ?  _ich + _paw->_GetPendingDelta() : _ich);
    }

    void SetACP(int ich) // careful, this method is very dangerous
    {
        Assert(ich >= 0);
        if (_InsidePendingRange())
        {
            _ich = ich - _paw->_GetPendingDelta();
        }
        else
        {
            _ich = ich;
        }
    }

    BOOL IsNormalized()
    {
        return _fNormalized;
    }

private:
    friend CACPWrap;

    CACPWrap *_paw;
    int _ich;               // offset of this anchor in the text stream, dangerous to change directly!
    CAnchorRef *_parFirst;  // list of ranges referencing this anchor
    BOOL _fNormalized : 1;
    DBG_ID_DECLARE;
};


#endif // ANCHOR_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\ctf\uim\anchor.cpp ===
//
// anchor.cpp
//
// CACPWrap
//

#include "private.h"
#include "anchor.h"
#include "globals.h"
#include "normal.h"
#include "anchoref.h"
#include "txtcache.h"

DBG_ID_INSTANCE(CAnchor);

//+---------------------------------------------------------------------------
//
// _NormalizeAnchor
//
//----------------------------------------------------------------------------

void CACPWrap::_NormalizeAnchor(CAnchor *pa)
{
    int iNew;
    int iCurrent;
    LONG acpNew;
    CAnchor *paInto;

    AssertPrivate(!pa->_fNormalized); // perf: we shouldn't normalize more than once

    Perf_IncCounter(PERF_LAZY_NORM);

    acpNew = Normalize(_ptsi, pa->GetIch());

    pa->_fNormalized = TRUE;

    if (acpNew == pa->GetIch())
        return;

    _Find(pa->GetIch(), &iCurrent);
    paInto = _Find(acpNew, &iNew);
    _Update(pa, acpNew, iCurrent, paInto, iNew);

    if (paInto == NULL)
    {
        // the target anchor didn't get merged, pretend it did
        paInto = pa;
    }
    else
    {
        // the target anchor got merged
        // need to set the norm bit for the anchor it got merged into
        paInto->_fNormalized = TRUE;
    }

    // we may have just skipped over anchors to the right of this one
    // handle those guys now
    while ((pa = _rgAnchors.Get(iCurrent)) != paInto)
    {
        Assert(pa->GetIch() < acpNew);

        _Merge(paInto, pa);
    }    

    _Dbg_AssertAnchors();
}

//+---------------------------------------------------------------------------
//
// _DragAnchors
//
//----------------------------------------------------------------------------

void CACPWrap::_DragAnchors(LONG acpFrom, LONG acpTo)
{
    CAnchor *paFrom;
    CAnchor *paTo;
    int iFrom;
    int iTo;
    int i;

    Assert(acpFrom > acpTo); // this method only handles dragging to the left

    _Find(acpFrom, &iFrom);
    if (iFrom < 0)
        return; // nothing to drag

    if (!_Find(acpTo, &iTo))
    {
        // if acpTo isn't occupied, drag to the next highest anchor
        iTo++;
    }

    if (iTo > iFrom)
        return; // nothing to drag, iTo and iFrom ref anchors to the left of acpTo

    // merge all the anchors into the left most
    paTo = _rgAnchors.Get(iTo);

    for (i=iFrom; i>iTo; i--)
    {
        paFrom = _rgAnchors.Get(i);
        Assert(paFrom->GetIch() > paTo->GetIch());

        _Merge(paTo, paFrom);
    }

    // if the left most anchor isn't already positioned, do that now
    paTo->SetACP(acpTo);

    _Dbg_AssertAnchors();
}

//+---------------------------------------------------------------------------
//
// _Insert
//
//----------------------------------------------------------------------------

HRESULT CACPWrap::_Insert(CAnchorRef *par, LONG ich)
{
    int i;
    CAnchor *pa;

    if ((pa = _Find(ich, &i)) == NULL)
    {
        // this ich isn't in the array, allocate a new anchor
        if ((pa = new CAnchor) == NULL)
            return E_OUTOFMEMORY;

        // and insert it into the array
        if (!_rgAnchors.Insert(i+1, 1))
        {
            delete pa;
            return E_FAIL;
        }

        // update _lPendingDeltaIndex
        if (i+1 <= _lPendingDeltaIndex)
        {
            _lPendingDeltaIndex++;
        }
        else
        {
            // new anchor is covered by a pending delta, so account for it
            ich -= _lPendingDelta;
        }

        pa->_paw = this;
        pa->_ich = ich;

        _rgAnchors.Set(i+1, pa);
    }

    return _Insert(par, pa);
}

//+---------------------------------------------------------------------------
//
// _Insert
//
//----------------------------------------------------------------------------

HRESULT CACPWrap::_Insert(CAnchorRef *par, CAnchor *pa)
{
    par->_pa = pa;
    par->_prev = NULL;
    par->_next = pa->_parFirst;
    if (pa->_parFirst)
    {
        Assert(pa->_parFirst->_prev == NULL);
        pa->_parFirst->_prev = par;
    }
    pa->_parFirst = par;

    return S_OK;
}

//+---------------------------------------------------------------------------
//
// Remove
//
//----------------------------------------------------------------------------

void CACPWrap::_Remove(CAnchorRef *parIn)
{
    CAnchor *pa = parIn->_pa;

    if (parIn->_prev != NULL)
    {
        // make the previous guy point past parIn
        parIn->_prev->_next = parIn->_next;
    }
    else
    {
        // this par is at the head of the list
        pa->_parFirst = parIn->_next;
    }
    if (parIn->_next != NULL)
    {
        parIn->_next->_prev = parIn->_prev;
    }

    if (pa->_parFirst == NULL)
    {
        // no more refs, delete the anchor
        _Delete(pa);
    }
}

//+---------------------------------------------------------------------------
//
// Remove
//
//----------------------------------------------------------------------------

void CACPWrap::_Delete(CAnchor *pa)
{
    int i;

    if (_Find(pa->GetIch(), &i) == pa)
    {
        _rgAnchors.Remove(i, 1);

        // update _lPendingDeltaIndex
        if (i < _lPendingDeltaIndex)
        {
            _lPendingDeltaIndex--;
        }
    }

    delete pa;
}

//+---------------------------------------------------------------------------
//
// Update
//
// Normalization is handled by the caller who needs to use Renormalize after
// calling this method.
//----------------------------------------------------------------------------

void CACPWrap::_Update(const TS_TEXTCHANGE *pdctc)
{
    int iStart;
    int ichEndOrg;
    int iEndOrg;
    int iEndNew;
    CAnchorRef *par;
    CAnchorRef **ppar;
    CAnchor *paStart;
    CAnchor *paEnd;
    CAnchor *paInto;
    BOOL fExactEndMatch;
    int dSize;
    int iDeltaStart;
    int ichStart = pdctc->acpStart;
    int ichEndOld = pdctc->acpOldEnd;
    int ichEndNew = pdctc->acpNewEnd;

    // always invalidate our text cache
    CProcessTextCache::Invalidate(_ptsi);

    Assert(ichStart >= 0);
    Assert(ichEndOld >= ichStart);
    Assert(ichEndNew >= ichStart);

    if (_rgAnchors.Count() == 0) // any anchors?
        return;

    dSize = ichEndNew - ichEndOld;

    if (dSize == 0)
        return;

    paStart = _Find(ichStart, &iStart);
    if (paStart == NULL)
    {
        iStart++; // return value was anchor closest to but less than ichStart

        if (iStart >= _rgAnchors.Count())
        {
            // there aren't any anchors >= iStart, so bail, nothing to do
            return;
        }

        paStart = _rgAnchors.Get(iStart);
        
        if (iStart == 0 && paStart->GetIch() > ichEndOld)
        {
            // the delta is to the left of all the ranges
            _AdjustIchs(0, dSize);
            _Dbg_AssertAnchors();
            return;
        }
    }
    paEnd = _Find(ichEndOld, &iEndOrg);
    if (paEnd == NULL)
    {
        Assert(iEndOrg >= 0); // there should be at least one anchor <= ichEndOld
                              // if we made it this far
        fExactEndMatch = FALSE;
        paEnd = _rgAnchors.Get(iEndOrg);
    }
    else
    {
        fExactEndMatch = TRUE;
    }

    if (dSize < 0)
    {
        // if dSize < 0, then gotta merge all the anchors between old, new pos
        if (paEnd->GetIch() > ichEndNew) // are there any anchors between old, new pos?
        {
            // track change history

            // drag the paEnd to its new position
            ichEndOrg = paEnd->GetIch();
            paInto = _Find(ichEndNew, &iEndNew);

            _TrackDelHistory(iEndOrg, fExactEndMatch, iEndNew, paInto != NULL);

            iEndNew = _Update(paEnd, ichEndNew, iEndOrg, paInto, iEndNew);
            _Find(ichEndOrg, &iEndOrg); // might be a prev anchor if paEnd got deleted in Update!

            while (iEndOrg > iEndNew)
            {
                // don't try to cache pointers, _rgAnchors might get realloc'd
                // during the _Merge!
                _Merge(_rgAnchors.Get(iEndNew), _rgAnchors.Get(iEndOrg));
                iEndOrg--;
            }

            iEndOrg = iEndNew; // for below
        }
        // iEndOrg was updated so let's start from next.
        iDeltaStart = iEndOrg + 1;
    }
    else // dSize > 0
    {
        // iEndOrg will be < iStart when the delta fits entirely between two existing anchors
        Assert(iEndOrg >= iStart || (iEndOrg == iStart - 1));
        iDeltaStart = (iEndOrg <= iStart) ? iEndOrg + 1 : iEndOrg;
    }

    // update all the following anchors
    _AdjustIchs(iDeltaStart, dSize);

    if (dSize > 0 && paStart == paEnd)
    {
        // Need to account for gravity in the case of an insert to a single anchor pos.
        // In practice, this means that we have to handle the anchor refs at the insertion
        // anchor individually -- some will want to shift left, others right.

        ppar = &paStart->_parFirst;
        while (par = *ppar)
        {
            if (par->_fForwardGravity)
            {
                // remove the ref from this anchor
                *ppar = par->_next;
                if (par->_next != NULL)
                {
                    par->_next->_prev = par->_prev;
                }

                // shove the ref over, it needs to be moved.  Insert adds to the head of the list
                // so this call is fast and in constant time.
                _Insert(par, paStart->GetIch() + dSize);
            }
            else
            {
                ppar = &par->_next;
            }
        }

        if (paStart->_parFirst == NULL)
        {
            // we cleaned this guy out!
            Assert(_rgAnchors.Get(iEndOrg) == paStart);
            _rgAnchors.Remove(iEndOrg, 1);
            delete paStart;
            // update _lPendingDeltaIndex
            if (iEndOrg < _lPendingDeltaIndex)
            {
                _lPendingDeltaIndex--;
            }
        }
    }

    _Dbg_AssertAnchors();
}

//+---------------------------------------------------------------------------
//
// _TrackDelHistory
//
//----------------------------------------------------------------------------

void CACPWrap::_TrackDelHistory(int iEndOrg, BOOL fExactEndOrgMatch, int iEndNew, BOOL fExactEndNewMatch)
{
    CAnchorRef *par;
    int i;

    Assert(iEndOrg >= iEndNew);

    if (fExactEndOrgMatch)
    {
        // all the anchoref's at iEndOrg get a preceding del
        for (par = _rgAnchors.Get(iEndOrg)->_parFirst; par != NULL; par = par->_next)
        {
            par->_dwHistory |= TS_CH_PRECEDING_DEL;
        }

        // if iEndOrg == iEndNew on entry, that's everything
        if (iEndOrg == iEndNew)
            return;

        iEndOrg--; // exclude this anchor from loop below
    }

    if (fExactEndNewMatch)
    {
        // all the anchoref's at iEndNew get a following del
        for (par = _rgAnchors.Get(iEndNew)->_parFirst; par != NULL; par = par->_next)
        {
            par->_dwHistory |= TS_CH_FOLLOWING_DEL;
        }
    }
    // exclude leftmost anchor from loop below
    // either we just handled it in the loop above or !fExactEndNewMatch
    // in which case it lies to the left of the affected anchors
    iEndNew++; 

    // the the anchoref's in between get both dels
    for (i=iEndNew; i<=iEndOrg; i++)
    {
        for (par = _rgAnchors.Get(i)->_parFirst; par != NULL; par = par->_next)
        {
            par->_dwHistory = (TS_CH_PRECEDING_DEL | TS_CH_FOLLOWING_DEL);
        }
    }
}

//+---------------------------------------------------------------------------
//
// _Update
//
// piInto gets loaded with the index of the anchor after the update.  If the
// index changed, pa is now bogus and a new pointer should be grabbed using
// the index.
//----------------------------------------------------------------------------

int CACPWrap::_Update(CAnchor *pa, int ichNew, int iOrg, CAnchor *paInto, int iInto)
{
    int i;

    Assert(pa->GetIch() != ichNew); // we are so hosed if this happens

    i = iInto;

    if (paInto != NULL)
    {
        // gotta do a merge
        _Merge(paInto, pa);
    }
    else
    {
        if (iInto != iOrg)
        {
            // move the entry in the array to the new position
            i = _rgAnchors.Move(iInto+1, iOrg);
        }

        // did we cross _lPendingDeltaIndex?
        if (i > _lPendingDeltaIndex)
        {
            // new position is in the pending range, adjust ich
            ichNew -= _lPendingDelta;
        }
        else if (iOrg >= _lPendingDeltaIndex && i <= _lPendingDeltaIndex) // shifting an anchor out of the pending range
        {
            // one less anchor in the pending range
            _lPendingDeltaIndex++;
        }

        // change the ich 
        _rgAnchors.Get(i)->_ich = ichNew;
    }

    _Dbg_AssertAnchors();

    return i;
}

//+---------------------------------------------------------------------------
//
// Renormalize
//
//----------------------------------------------------------------------------

void CACPWrap::_Renormalize(int ichStart, int ichEnd)
{
    CAnchor *pa;
    int iCurrent;
    int iEnd;
    BOOL fExactEndMatch;

    Perf_IncCounter(PERF_RENORMALIZE_COUNTER);

    if (_rgAnchors.Count() == 0)
        return;

    fExactEndMatch = (_Find(ichEnd, &iEnd) != NULL);
    if (iEnd < 0)
        return;

    if (ichStart == ichEnd)
    {
        if (!fExactEndMatch)
            return;
        // this can happen on deletions
        iCurrent = iEnd;
    }
    else if (_Find(ichStart, &iCurrent) == NULL)
    {
        iCurrent++; // we don't care about anchors < ichStart
    }
    Assert(iCurrent >= 0);

    for (;iCurrent <= iEnd; iCurrent++)
    {
        pa = _rgAnchors.Get(iCurrent);

        Assert(pa->GetIch() >= 0);
        Assert(pa->GetIch() >= ichStart);
        Assert(pa->GetIch() <= ichEnd);

        // we'll do the real work only when we have too...
        pa->_fNormalized = FALSE;
    }

    _Dbg_AssertAnchors();
}

//+---------------------------------------------------------------------------
//
// _Find
//
// If piOut != NULL then it is set to the index where ich was found, or the
// index of the next lower ich if ich isn't in the array.
// If there is no element in the array with a lower ich, returns offset -1.
//----------------------------------------------------------------------------

CAnchor *CACPWrap::_Find(int ich, int *piOut)
{
    CAnchor *paMatch;
    int iMin;
    int iMax;
    int iMid;
    LONG lPendingDeltaIch;

    iMin = 0;
    iMax = _rgAnchors.Count();

    // adjust search for pending delta range
    // values aren't consistent across the range boundary
    if (_lPendingDelta != 0 && _lPendingDeltaIndex < _rgAnchors.Count())
    {
        lPendingDeltaIch = _rgAnchors.Get(_lPendingDeltaIndex)->_ich;

        if (ich < lPendingDeltaIch + _lPendingDelta)
        {
            iMax = _lPendingDeltaIndex;
        }
        else if (ich > lPendingDeltaIch + _lPendingDelta)
        {
            iMin = _lPendingDeltaIndex+1;
            ich -= _lPendingDelta; // make the search below work
        }
        else
        {
            iMid = _lPendingDeltaIndex;
            paMatch = _rgAnchors.Get(_lPendingDeltaIndex);
            goto Exit;
        }
    }

    paMatch = _FindInnerLoop(ich, iMin, iMax, &iMid);

Exit:
    if (piOut != NULL)
    {
        if (paMatch == NULL && iMid >= 0)
        {
            // couldn't find a match, return the next lowest ich
            Assert(iMid == 0 || iMid == _lPendingDeltaIndex || _rgAnchors.Get(iMid-1)->_ich < ich);
            if (_rgAnchors.Get(iMid)->_ich > ich)
            {
                iMid--;
            }
        }
        *piOut = iMid;
    }

    return paMatch;
}

//+---------------------------------------------------------------------------
//
// _FindInnerLoop
//
//----------------------------------------------------------------------------

CAnchor *CACPWrap::_FindInnerLoop(LONG acp, int iMin, int iMax, int *piIndex)
{
    CAnchor *pa;
    CAnchor *paMatch;
    int iMid;

    paMatch = NULL;
    iMid = iMin - 1;

    while (iMin < iMax)
    {
        iMid = (iMin + iMax) / 2;
        pa = _rgAnchors.Get(iMid);
        Assert(pa != NULL);

        if (acp < pa->_ich)
        {
            iMax = iMid;
        }
        else if (acp > pa->_ich)
        {
            iMin = iMid + 1;
        }
        else // acp == pa->_ich
        {
            paMatch = pa;
            break;
        }
    }

    *piIndex = iMid;

    return paMatch;
}

//+---------------------------------------------------------------------------
//
// _Merge
//
//----------------------------------------------------------------------------

void CACPWrap::_Merge(CAnchor *paInto, CAnchor *paFrom)
{
    CAnchorRef *par;

    Assert(paInto != paFrom); // very bad!
    Assert(paInto->_parFirst != NULL); // should never have an anchor w/o any refs

    if (par = paFrom->_parFirst)
    {
        // update the anchor for the paFrom refs

        while (TRUE)
        {
            par->_pa = paInto;

            if (par->_next == NULL)
                break;

            par = par->_next;
        }

        // now par is the last ref in paFrom
        // shove all the refs in paFrom into paInto

        if (par != NULL)
        {
            Assert(par->_next == NULL);
            par->_next = paInto->_parFirst;
            Assert(paInto->_parFirst->_prev == NULL);
            paInto->_parFirst->_prev = par;
            paInto->_parFirst = paFrom->_parFirst;
        }
    }

    // and free the parFrom
    _Delete(paFrom);
}

//+---------------------------------------------------------------------------
//
// _Dbg_AssertAnchors
//
//----------------------------------------------------------------------------

#ifdef DEBUG

void CACPWrap::_Dbg_AssertAnchors()
{
    int i;
    int ichLast;
    CAnchor *pa;

    ichLast = -1;

    // assert that the anchor array has ascending ich's
    for (i=0; i<_rgAnchors.Count(); i++)
    {
        pa = _rgAnchors.Get(i);
        Assert(ichLast < pa->GetIch());
        ichLast = pa->GetIch();
    }
}

#endif // DEBUG

//+---------------------------------------------------------------------------
//
// _AdjustIchs
//
//----------------------------------------------------------------------------

void CACPWrap::_AdjustIchs(int iFirst, int dSize)
{
    CAnchor **ppaFirst;
    CAnchor **ppaLast;
    LONG dSizeAdjust;
    int iLastAnchor;

    Assert(dSize != 0);

    iLastAnchor = _rgAnchors.Count()-1;

    if (iFirst > iLastAnchor)
        return;

    if (_lPendingDelta == 0 ||             // no delta pending
        _lPendingDeltaIndex > iLastAnchor) // old pending anchors got deleted before update
    {
        // no pending delta, start a new one
        _lPendingDeltaIndex = iFirst;
        _lPendingDelta = dSize;
        return;
    }

    if (max(iFirst, _lPendingDeltaIndex) - min(iFirst, _lPendingDeltaIndex)
        > iLastAnchor / 2)
    {
        // adjust points are far apart, update the tail of the range
        if (iFirst > _lPendingDeltaIndex)
        {
            ppaFirst = _rgAnchors.GetPtr(iFirst);
            dSizeAdjust = dSize;
        }
        else
        {
            ppaFirst = _rgAnchors.GetPtr(_lPendingDeltaIndex);
            _lPendingDeltaIndex = iFirst;
            dSizeAdjust = _lPendingDelta;
            _lPendingDelta = dSize;
        }
        ppaLast = _rgAnchors.GetPtr(iLastAnchor);
    }
    else
    {
        // adjust points are close, update the head of the range
        if (iFirst > _lPendingDeltaIndex)
        {
            ppaFirst = _rgAnchors.GetPtr(_lPendingDeltaIndex);
            _lPendingDeltaIndex = iFirst;
            ppaLast = _rgAnchors.GetPtr(iFirst - 1);
            dSizeAdjust = _lPendingDelta;
        }
        else
        {
            ppaFirst = _rgAnchors.GetPtr(iFirst);
            ppaLast = _rgAnchors.GetPtr(_lPendingDeltaIndex-1);
            dSizeAdjust = dSize;
        }
        _lPendingDelta += dSize;
    }

    // do the real work
    while (ppaFirst <= ppaLast)
    {
        (*ppaFirst++)->_ich += dSizeAdjust;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\ctf\uim\anchoref.h ===
//
// anchoref.h
//
// CAnchorRef
//

#ifndef ANCHOREF_H
#define ANCHOREF_H

#include "private.h"
#include "memcache.h"
#include "acp2anch.h"
#include "anchor.h"

class CAnchorList;

extern const IID IID_PRIV_CANCHORREF;

// work around for new #define in mem.h
#undef new

class CAnchorRef : public IAnchor
{
public:
    DECLARE_CACHED_NEW;

    CAnchorRef()
    {
        Dbg_MemSetThisNameIDCounter(TEXT("CAnchorRef"), PERF_ANCHORREF_COUNTER);

        _cRef = 1;
        Assert(_dwHistory == 0);
        Assert(_pa == NULL);
    }
    ~CAnchorRef()
    {
        CACPWrap *paw;

        if (_pa != NULL) // NULL means something went wrong in _Init
        {
            paw = _pa->_GetWrap(); // we must cache this because _pa could be deleted in Remove
            paw->_Remove(this);
            paw->_OnAnchorRelease();
        }
    }

    BOOL _Init(CACPWrap *paw, LONG ich, TsGravity gravity)
    {
        _fForwardGravity = (gravity == TS_GR_FORWARD ? 1 : 0);

        return (paw->_Insert(this, ich) == S_OK);
    }
    BOOL _Init(CACPWrap *paw, CAnchor *pa, TsGravity gravity)
    {
        _fForwardGravity = (gravity == TS_GR_FORWARD ? 1 : 0);

        return (paw->_Insert(this, pa) == S_OK);
    }

    static void _InitClass();
    static void _UninitClass();

    //
    // IUnknown methods
    //
    STDMETHODIMP QueryInterface(REFIID riid, void **ppvObj);
    STDMETHODIMP_(ULONG) AddRef(void);
    STDMETHODIMP_(ULONG) Release(void);

    //
    // IAnchor
    //
    STDMETHODIMP SetGravity(TsGravity gravity);
    STDMETHODIMP GetGravity(TsGravity *pgravity);
    STDMETHODIMP IsEqual(IAnchor *paWith, BOOL *pfEqual);
    STDMETHODIMP Compare(IAnchor *paWith, LONG *plResult);
    STDMETHODIMP Shift(DWORD dwFlags, LONG cchReq, LONG *pcch, IAnchor *paHaltAnchor);
    STDMETHODIMP ShiftTo(IAnchor *paSite);
    STDMETHODIMP ShiftRegion(DWORD dwFlags, TsShiftDir dir, BOOL *pfNoRegion);
    STDMETHODIMP SetChangeHistoryMask(DWORD dwMask);
    STDMETHODIMP GetChangeHistory(DWORD *pdwHistory);
    STDMETHODIMP ClearChangeHistory();
    STDMETHODIMP Clone(IAnchor **ppaClone);

    LONG _GetACP()
    {
        _pa->_GetWrap()->_Dbg_AssertNoAppLock();
        return _pa->GetIch();
    }
    BOOL _SetACP(LONG acp);

    CAnchor *_GetAnchor()
    { 
        return _pa;
    }

    CACPWrap *_GetWrap()
    { 
        return _pa->_GetWrap();
    }

private:
    friend CACPWrap;

    CAnchor *_pa;
    CAnchorRef *_prev;
    CAnchorRef *_next;
    LONG _cRef;

    DWORD _fForwardGravity : 1;
    DWORD _dwHistory : 2;

    DBG_ID_DECLARE;
};

// retore mem.h trick
#ifdef DEBUG
#define new new(TEXT(__FILE__), __LINE__)
#endif // DEBUG

// this call doesn't AddRef the object!
inline CAnchorRef *GetCAnchorRef_NA(IAnchor *pa)
{
    CAnchorRef *par;

    pa->QueryInterface(IID_PRIV_CANCHORREF, (void **)&par);

    return par;
}

#endif // ANCHOREF_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\ctf\uim\acp2anch.cpp ===
//
// acp2anch.cpp
//

#include "private.h"
#include "acp2anch.h"
#include "ic.h"
#include "normal.h"
#include "ic.h"
#include "range.h"
#include "anchoref.h"
#include "txtcache.h"

/* 4eb058b0-34ae-11d3-a745-0050040ab407 */
const IID IID_PRIV_ACPWRAP = { 0x4eb058b0, 0x34ae, 0x11d3, {0xa7, 0x45, 0x00, 0x50, 0x04, 0x0a, 0xb4, 0x07} };

DBG_ID_INSTANCE(CLoaderACPWrap);
DBG_ID_INSTANCE(CACPWrap);

void NormalizeAnchor(CAnchorRef *par)
{
    CACPWrap *paw;
    CAnchor *pa;

    paw = par->_GetWrap();
    pa = par->_GetAnchor();

    if (!pa->IsNormalized())
    {
        paw->_NormalizeAnchor(pa);
    }
}

void NormalizeAnchor(IAnchor *pa)
{
    CAnchorRef *par;

    if ((par = GetCAnchorRef_NA(pa)) == NULL)
    {
        Assert(0); // should never get here
        return;
    }

    NormalizeAnchor(par);
}

//+---------------------------------------------------------------------------
//
// ctor
//
//----------------------------------------------------------------------------

CLoaderACPWrap::CLoaderACPWrap(ITfPersistentPropertyLoaderACP *loader)
{
    Dbg_MemSetThisNameIDCounter(TEXT("CLoaderACPWrap"), PERF_LOADERACP_COUNTER);

    _loader = loader;
    _loader->AddRef();
}

//+---------------------------------------------------------------------------
//
// dtor
//
//----------------------------------------------------------------------------

CLoaderACPWrap::~CLoaderACPWrap()
{
    _loader->Release();
}

//+---------------------------------------------------------------------------
//
// LoadProperty
//
//----------------------------------------------------------------------------

STDAPI CLoaderACPWrap::LoadProperty(const TF_PERSISTENT_PROPERTY_HEADER_ANCHOR *pHdr, IStream **ppStream)
{
    TF_PERSISTENT_PROPERTY_HEADER_ACP phacp;

    // always normalize before unserializing
    NormalizeAnchor(pHdr->paStart);
    NormalizeAnchor(pHdr->paEnd);

    if (!CACPWrap::_AnchorHdrToACP(pHdr, &phacp))
        return E_FAIL;

    return _loader->LoadProperty(&phacp, ppStream);
}

//+---------------------------------------------------------------------------
//
// ctor
//
//----------------------------------------------------------------------------

CACPWrap::CACPWrap(ITextStoreACP *ptsi)
{
    Dbg_MemSetThisNameIDCounter(TEXT("CACPWrap"), PERF_ACPWRAP_COUNTER);

    _ptsi = ptsi;
    ptsi->AddRef();
    _cRef = 1;
}

//+---------------------------------------------------------------------------
//
// dtor
//
//----------------------------------------------------------------------------

CACPWrap::~CACPWrap()
{
    Assert(_ptsi == NULL); // cleared in Release
    Assert(_rgAnchors.Count() == 0); // all anchors should be removed
}

//+---------------------------------------------------------------------------
//
// IUnknown
//
//----------------------------------------------------------------------------

STDAPI CACPWrap::QueryInterface(REFIID riid, void **ppvObj)
{
    *ppvObj = NULL;

    if (IsEqualIID(riid, IID_IUnknown) ||
        IsEqualIID(riid, IID_ITextStoreAnchor))
    {
        *ppvObj = SAFECAST(this, ITextStoreAnchor *);
    }
    else if (IsEqualIID(riid, IID_ITextStoreACPSink))
    {
        *ppvObj = SAFECAST(this, ITextStoreACPSink *);
    }
    else if (IsEqualIID(riid, IID_ITextStoreACPServices))
    {
        *ppvObj = SAFECAST(this, ITextStoreACPServices *);
    }
    else if (IsEqualIID(riid, IID_PRIV_ACPWRAP))
    {
        *ppvObj = SAFECAST(this, CACPWrap *);
    }
    else if (IsEqualIID(riid, IID_ITfMouseTrackerACP))
    {
        *ppvObj = SAFECAST(this, ITfMouseTrackerACP *);
    }
    else if (IsEqualIID(riid, IID_IServiceProvider))
    {
        *ppvObj = SAFECAST(this, IServiceProvider *);
    }

    if (*ppvObj)
    {
        AddRef();
        return S_OK;
    }

    return E_NOINTERFACE;
}

STDAPI_(ULONG) CACPWrap::AddRef()
{
    return ++_cRef;
}

STDAPI_(ULONG) CACPWrap::Release()
{
    _cRef--;
    Assert(_cRef >= 0);

    // nb: this obj has 2 ref counters:
    // _cRef -> external clients
    // _GetAnchorRef -> CAnchorRef's.
    // we won't delete until both reach 0
    if (_cRef == 0)
    {
        // clear out text cache before releasing _ptsi
        // the memory may be reallocated (this happened!) for a different text store
        CProcessTextCache::Invalidate(_ptsi);

        // disconnect the ITextStoreACP
        SafeReleaseClear(_ptsi);

        if (_GetAnchorRef() == 0) // internal ref count
        {
            delete this;
        }
        return 0;
    }

    return _cRef;
}

//+---------------------------------------------------------------------------
//
// OnTextChange
//
//----------------------------------------------------------------------------

STDAPI CACPWrap::OnTextChange(DWORD dwFlags, const TS_TEXTCHANGE *pChange)
{
    IAnchor *paStart = NULL;
    IAnchor *paEnd = NULL;
    HRESULT hr;
    HRESULT hr2;

    if (pChange == NULL)
        return E_INVALIDARG;

    if (_pic->_IsInEditSession())
    {
        Assert(0); // someone other than cicero is editing the doc while cicero holds a lock
        return TS_E_NOLOCK;
    }

#ifdef DEBUG
    _Dbg_fAppHasLock = TRUE;
#endif

    // we never call this internally, so the caller must be the app.
    // nb: we aren't normalizing the anchors here!  They can't be
    // normalized until the app releases its lock in OnLockReleased.
    // Not a bad thing for perf though!  We will merge spans before
    // normalizing...

    // Issue: we aren't handling the case like:
    // "----<a1>ABC<a2>" -> "XX<a1><a2>", where "-" is formatting and <a1> has backwards gravity, <a2> forwards
    // in this case we'd like to see "<a1>XX<a2>" as the final result

    if (pChange->acpStart == pChange->acpOldEnd &&
        pChange->acpOldEnd == pChange->acpNewEnd)
    {
        // nothing happened
        return S_OK;
    }

    hr = E_OUTOFMEMORY;

    if ((paStart = _CreateAnchorACP(pChange->acpStart, TS_GR_BACKWARD)) == NULL)
        goto Exit;
    if ((paEnd = _CreateAnchorACP(pChange->acpOldEnd, TS_GR_FORWARD)) == NULL)
    {
        paStart->Release();
        goto Exit;
    }

    _fInOnTextChange = TRUE; // this flag stops us from trying to normalize anchors

    // do the alist update
    _Update(pChange);

    hr = _pic->_OnTextChangeInternal(dwFlags, paStart, paEnd, OWN_ANCHORS);

    _fInOnTextChange = FALSE;

    // get a lock eventually so we can deal with the changes
    _ptsi->RequestLock(TS_LF_READ, &hr2);

Exit:
    return hr;
}

//+---------------------------------------------------------------------------
//
// OnSelectionChange
//
//----------------------------------------------------------------------------

STDAPI CACPWrap::OnSelectionChange()
{
    // we never call this internally, so the caller must be the app.
    return _ptss->OnSelectionChange();
}

//+---------------------------------------------------------------------------
//
// OnLockGranted
//
//----------------------------------------------------------------------------

STDAPI CACPWrap::OnLockGranted(DWORD dwLockFlags)
{
    int i;
    SPAN *pSpan;
    int cSpans;
    CAnchorRef *parStart;
    CAnchorRef *parEnd;
    CSpanSet *pSpanSet;

#ifdef DEBUG
    _Dbg_fAppHasLock = FALSE;
#endif

    // 
    // After IC is popped, we may be granted the lock...
    // 
    if (!_pic || !_pic->_GetEditRecord())
        return E_UNEXPECTED;

    // generally the pic's er can contain app or tip changes
    // BUT, it will never hold both at the same time.  And it will
    // only hold app changes (if any) when OnLockGranted is called
    pSpanSet = _pic->_GetEditRecord()->_GetTextSpanSet();

    // empty out our change cache
    if ((cSpans = pSpanSet->GetCount()) > 0)
    {
        // clean up the anchorlist!
        pSpan = pSpanSet->GetSpans();
        for (i=0; i<cSpans; i++)
        {
            parStart = GetCAnchorRef_NA(pSpan->paStart);
            parEnd = GetCAnchorRef_NA(pSpan->paEnd);

            _Renormalize(parStart->_GetACP(), parEnd->_GetACP());

            pSpan++;
        }
    }

    // then pass along the release to the uim
    return _ptss->OnLockGranted(dwLockFlags);
}

//+---------------------------------------------------------------------------
//
// OnLayoutChange
//
//----------------------------------------------------------------------------

STDAPI CACPWrap::OnLayoutChange(TsLayoutCode lcode, TsViewCookie vcView)
{
    return _ptss->OnLayoutChange(lcode, vcView);
}

//+---------------------------------------------------------------------------
//
// OnStatusChange
//
//----------------------------------------------------------------------------

STDAPI CACPWrap::OnStatusChange(DWORD dwFlags)
{
    return _ptss->OnStatusChange(dwFlags);
}

//+---------------------------------------------------------------------------
//
// OnStatusChange
//
//----------------------------------------------------------------------------

STDAPI CACPWrap::OnAttrsChange(LONG acpStart, LONG acpEnd, ULONG cAttrs, const TS_ATTRID *paAttrs)
{
    IAnchor *paStart = NULL;
    IAnchor *paEnd = NULL;
    HRESULT hr;

    hr = E_OUTOFMEMORY;

    if ((paStart = _CreateAnchorACP(acpStart, TS_GR_BACKWARD)) == NULL)
        goto Exit;
    if ((paEnd = _CreateAnchorACP(acpEnd, TS_GR_FORWARD)) == NULL)
        goto Exit;

    hr = _ptss->OnAttrsChange(paStart, paEnd, cAttrs, paAttrs);

Exit:
    SafeRelease(paStart);
    SafeRelease(paEnd);
    
    return hr;
}

//+---------------------------------------------------------------------------
//
// OnStartEditTransaction
//
//----------------------------------------------------------------------------

STDAPI CACPWrap::OnStartEditTransaction()
{
    return _ptss->OnStartEditTransaction();
}

//+---------------------------------------------------------------------------
//
// OnEndEditTransaction
//
//----------------------------------------------------------------------------

STDAPI CACPWrap::OnEndEditTransaction()
{
    return _ptss->OnEndEditTransaction();
}

//+---------------------------------------------------------------------------
//
// AdviseSink
//
//----------------------------------------------------------------------------

STDAPI CACPWrap::AdviseSink(REFIID riid, IUnknown *punk, DWORD dwMask)
{
    IServiceProvider *psp;
    HRESULT hr;

    Assert(_ptss == NULL);
    Assert(_pic == NULL);

    if (punk->QueryInterface(IID_ITextStoreAnchorSink, (void **)&_ptss) != S_OK)
        return E_FAIL;

    // use QueryService to get the ic since msaa may be wrapping it
    if (punk->QueryInterface(IID_IServiceProvider, (void **)&psp) != S_OK)
    {
        hr = E_FAIL;
        goto ErrorExit;
    }

    hr = psp->QueryService(GUID_SERVICE_TF, IID_PRIV_CINPUTCONTEXT, (void **)&_pic);

    psp->Release();

    if (hr != S_OK)
    {
        hr = E_FAIL;
        goto ErrorExit;
    }

    // advise our wrapped acp
    if ((hr = _ptsi->AdviseSink(IID_ITextStoreACPSink, SAFECAST(this, ITextStoreACPSink *), dwMask)) != S_OK)
        goto ErrorExit;

    return S_OK;

ErrorExit:
    SafeReleaseClear(_ptss);
    SafeReleaseClear(_pic);
    return hr;
}

//+---------------------------------------------------------------------------
//
// UnadviseSink
//
//----------------------------------------------------------------------------

STDAPI CACPWrap::UnadviseSink(IUnknown *punk)
{
    Assert(_ptss == punk); // we're dealing with cicero, this should always hold

    _ptsi->UnadviseSink(SAFECAST(this, ITextStoreACPSink *));

    SafeReleaseClear(_ptss);
    SafeReleaseClear(_pic);

    return S_OK;
}

//+---------------------------------------------------------------------------
//
// RequestLock
//
//----------------------------------------------------------------------------

STDAPI CACPWrap::RequestLock(DWORD dwLockFlags, HRESULT *phrSession)
{
    return _ptsi->RequestLock(dwLockFlags, phrSession);
}

//+---------------------------------------------------------------------------
//
// GetSelection
//
//----------------------------------------------------------------------------

STDAPI CACPWrap::GetSelection(ULONG ulIndex, ULONG ulCount, TS_SELECTION_ANCHOR *pSelection, ULONG *pcFetched)
{
    TS_SELECTION_ACP *pSelACP;
    HRESULT hr;
    ULONG i;
    TS_SELECTION_ACP sel;

    Assert(pcFetched != NULL); // caller should have caught this

    *pcFetched = 0;

    if (ulCount == 1)
    {
        pSelACP = &sel;
    }
    else if ((pSelACP = (TS_SELECTION_ACP *)cicMemAlloc(ulCount*sizeof(TS_SELECTION_ACP))) == NULL)
            return E_OUTOFMEMORY;

    hr = _ptsi->GetSelection(ulIndex, ulCount, pSelACP, pcFetched);

    if (hr != S_OK)
        goto Exit;

    _Dbg_AssertNoAppLock();

    for (i=0; i<*pcFetched; i++)
    {
        if ((pSelection[i].paStart = _CreateAnchorACP(pSelACP[i].acpStart, TS_GR_FORWARD)) == NULL ||
            (pSelection[i].paEnd = _CreateAnchorACP(pSelACP[i].acpEnd, TS_GR_BACKWARD)) == NULL)
        {
            SafeRelease(pSelection[i].paStart);
            while (i>0)
            {
                i--;
                pSelection[i].paStart->Release();
                pSelection[i].paEnd->Release();
            }
            hr = E_FAIL;
            goto Exit;
        }

        pSelection[i].style = pSelACP[i].style;
    }

Exit:
    if (pSelACP != &sel)
    {
        cicMemFree(pSelACP);
    }
    return hr;
}

//+---------------------------------------------------------------------------
//
// SetSelection
//
//----------------------------------------------------------------------------

STDAPI CACPWrap::SetSelection(ULONG ulCount, const TS_SELECTION_ANCHOR *pSelection)
{
    CAnchorRef *par;
    TS_SELECTION_ACP *pSelACP;
    ULONG i;
    HRESULT hr;
    TS_SELECTION_ACP sel;

    _Dbg_AssertNoAppLock();

    if (ulCount == 1)
    {
        pSelACP = &sel;
    }
    else if ((pSelACP = (TS_SELECTION_ACP *)cicMemAlloc(ulCount*sizeof(TS_SELECTION_ACP))) == NULL)
        return E_OUTOFMEMORY;

    hr = E_FAIL;

    for (i=0; i<ulCount; i++)
    {
        if ((par = GetCAnchorRef_NA(pSelection[i].paStart)) == NULL)
            goto Exit;
        pSelACP[i].acpStart = par->_GetACP();

        if (pSelection[i].paEnd == NULL)
        {
            // implies paEnd is same as paStart
            pSelACP[i].acpEnd = pSelACP[i].acpStart;
        }
        else
        {
            if ((par = GetCAnchorRef_NA(pSelection[i].paEnd)) == NULL)
                goto Exit;
            pSelACP[i].acpEnd = par->_GetACP();
        }

        pSelACP[i].style = pSelection[i].style;
    }

    hr = _ptsi->SetSelection(ulCount, pSelACP);

Exit:
    if (pSelACP != &sel)
    {
        cicMemFree(pSelACP);
    }
    return hr;
}

//+---------------------------------------------------------------------------
//
// GetText
//
//----------------------------------------------------------------------------

STDAPI CACPWrap::GetText(DWORD dwFlags, IAnchor *paStart, IAnchor *paEnd, WCHAR *pchText, ULONG cchReq, ULONG *pcch, BOOL fUpdateAnchor)
{
    CAnchorRef *parStart;
    CAnchorRef *parEnd;
    LONG acpStart;
    LONG acpEnd;
    LONG acpNext;
    ULONG cchTotal;
    ULONG cchAdjust;
    ULONG ulRunInfoOut;
    HRESULT hr;
    ULONG i;
    WCHAR ch;
    WCHAR *pchSrc;
    WCHAR *pchDst;
    TS_RUNINFO rgRunInfo[16];

    _Dbg_AssertNoAppLock();

    Perf_IncCounter(PERF_ACPWRAP_GETTEXT);

    // this upfront check for a nop saves us from
    //   1) copying non-existant text based on non-zero run-info
    //   2) repositioning the start anchor based on non-zero run-info
    if (cchReq == 0)
    {       
        *pcch = 0;
        return S_OK;
    }

    if ((parStart = GetCAnchorRef_NA(paStart)) == NULL)
        return E_FAIL;
    acpStart = parStart->_GetACP();

    acpEnd = -1;
    if (paEnd != NULL)
    {
        if ((parEnd = GetCAnchorRef_NA(paEnd)) == NULL)
        {
            hr = E_FAIL;
            goto Exit;
        }
        acpEnd = parEnd->_GetACP();
    }

    cchTotal = 0;

    while (TRUE)
    {
        Perf_IncCounter(PERF_ACPWRAP_GETTEXT_LOOP);
        hr = CProcessTextCache::GetText(_ptsi, acpStart, acpEnd, pchText, cchReq, pcch, rgRunInfo, ARRAYSIZE(rgRunInfo), &ulRunInfoOut, &acpNext);

        if (hr != S_OK)
            goto Exit;

        if (ulRunInfoOut == 0) // prevent a loop at eod
            break;

        // prune out any hidden text
        pchSrc = pchText;
        pchDst = pchText;

        for (i=0; i<ulRunInfoOut; i++)
        {
            switch (rgRunInfo[i].type)
            {
                case TS_RT_PLAIN:
                    Assert(pchDst != NULL);
                    if (pchSrc != pchDst)
                    {
                        memmove(pchDst, pchSrc, rgRunInfo[i].uCount*sizeof(WCHAR));
                    }
                    pchSrc += rgRunInfo[i].uCount;
                    pchDst += rgRunInfo[i].uCount;
                    break;

                case TS_RT_HIDDEN:
                    pchSrc += rgRunInfo[i].uCount;
                    *pcch -= rgRunInfo[i].uCount;
                    Assert((int)(*pcch) >= 0); // app bug if this is less than zero
                    break;

                case TS_RT_OPAQUE:
                    break;
            }
        }

        // prune out any TS_CHAR_REGIONs
        pchSrc = pchText;
        pchDst = pchText;

        for (i=0; i<*pcch; i++)
        {
            ch = *pchSrc;

            if (ch != TS_CHAR_REGION)
            {
                if (pchSrc != pchDst)
                {
                    *pchDst = ch;
                }
                pchDst++;
            }
            pchSrc++;        
        }

        // dec the count by the number of TS_CHAR_REGIONs we removed
        cchAdjust = *pcch - (ULONG)(pchSrc - pchDst);
        cchTotal += cchAdjust;

        // done?
        cchReq -= cchAdjust;
        if (cchReq <= 0)
            break;

        acpStart = acpNext;
        
        if (acpEnd >= 0 && acpStart >= acpEnd)
            break;

        pchText += cchAdjust;
    }

    *pcch = cchTotal;

    if (fUpdateAnchor)
    {
        parStart->_SetACP(acpNext);
    }

Exit:
    return hr;
}

//+---------------------------------------------------------------------------
//
// _PostInsertUpdate
//
//----------------------------------------------------------------------------

void CACPWrap::_PostInsertUpdate(LONG acpStart, LONG acpEnd, ULONG cch, const TS_TEXTCHANGE *ptsTextChange)
{
    Assert(ptsTextChange->acpStart <= acpStart); // bogus output from app?

    if (ptsTextChange->acpStart < acpStart &&
        cch > 0 &&
        acpStart != acpEnd)
    {
        // this is unusual.  The original text was like:
        //      ----ABC     "-" is formatting, we replace with "XX"
        //
        // the new text is like:
        //      XX          problem!
        // or possibly
        //      ----XX      no problem
        //
        // if "----ABC" -> "XX", then paStart will be placed after the ABC
        // because it was normalized to start with:
        //
        //      "----<paStart>ABC<paEnd>" -> "XX<paStart><paEnd>"
        //
        // We need to fix this up.
        _DragAnchors(acpStart, ptsTextChange->acpStart);
    }

    _Update(ptsTextChange);   
    _Renormalize(ptsTextChange->acpStart, ptsTextChange->acpNewEnd);
}

//+---------------------------------------------------------------------------
//
// SetText
//
//----------------------------------------------------------------------------

STDAPI CACPWrap::SetText(DWORD dwFlags, IAnchor *paStart, IAnchor *paEnd, const WCHAR *pchText, ULONG cch)
{
    CAnchorRef *parStart;
    CAnchorRef *parEnd;
    LONG acpStart;
    LONG acpEnd;
    TS_TEXTCHANGE dctc;
    HRESULT hr;

    _Dbg_AssertNoAppLock();

    if ((parStart = GetCAnchorRef_NA(paStart)) == NULL)
        return E_FAIL;
    acpStart = parStart->_GetACP();

    if ((parEnd = GetCAnchorRef_NA(paEnd)) == NULL)
        return E_FAIL;
    acpEnd = parEnd->_GetACP();

    // for perf, filter out the nop
    if (acpStart == acpEnd && cch == 0)
        return S_OK;

    // do the work
    hr = _ptsi->SetText(dwFlags, acpStart, acpEnd, pchText, cch, &dctc);

    // we'll handle the anchor updates -- the app won't give us an OnTextChange callback for our
    // own changes
    if (hr == S_OK)
    {
        _PostInsertUpdate(acpStart, acpEnd, cch, &dctc);
    }

    return hr;
}

//+---------------------------------------------------------------------------
//
// GetFormattedText
//
//----------------------------------------------------------------------------

STDAPI CACPWrap::GetFormattedText(IAnchor *paStart, IAnchor *paEnd, IDataObject **ppDataObject)
{
    CAnchorRef *par;
    LONG acpStart;
    LONG acpEnd;

    Assert(*ppDataObject == NULL);

    _Dbg_AssertNoAppLock();

    if ((par = GetCAnchorRef_NA(paStart)) == NULL)
        return E_FAIL;
    acpStart = par->_GetACP();

    if ((par = GetCAnchorRef_NA(paEnd)) == NULL)
        return E_FAIL;
    acpEnd = par->_GetACP();

    // do the work
    return _ptsi->GetFormattedText(acpStart, acpEnd, ppDataObject);
}

//+---------------------------------------------------------------------------
//
// GetEmbedded
//
//----------------------------------------------------------------------------

STDAPI CACPWrap::GetEmbedded(DWORD dwFlags, IAnchor *paPos, REFGUID rguidService, REFIID riid, IUnknown **ppunk)
{
    CAnchorRef *par;
    LONG acpPos;

    if (ppunk == NULL)
        return E_INVALIDARG;

    *ppunk = NULL;

    if (paPos == NULL)
        return E_INVALIDARG;

    if ((par = GetCAnchorRef_NA(paPos)) == NULL)
        return E_FAIL;

    if (!par->_GetAnchor()->IsNormalized())
    {
        // we need to be positioned just before the next char
        _NormalizeAnchor(par->_GetAnchor());
    }

    acpPos = par->_GetACP();

    if (!(dwFlags & TS_GEA_HIDDEN))
    {
        // skip past any hidden text
        acpPos = Normalize(_ptsi, acpPos, NORM_SKIP_HIDDEN);
    }

    return _ptsi->GetEmbedded(acpPos, rguidService, riid, ppunk);
}

//+---------------------------------------------------------------------------
//
// QueryInsertEmbedded
//
//----------------------------------------------------------------------------

STDAPI CACPWrap::QueryInsertEmbedded(const GUID *pguidService, const FORMATETC *pFormatEtc, BOOL *pfInsertable)
{
    return _ptsi->QueryInsertEmbedded(pguidService, pFormatEtc, pfInsertable);
}

//+---------------------------------------------------------------------------
//
// InsertEmbedded
//
//----------------------------------------------------------------------------

STDAPI CACPWrap::InsertEmbedded(DWORD dwFlags, IAnchor *paStart, IAnchor *paEnd, IDataObject *pDataObject)
{
    CAnchorRef *par;
    LONG acpStart;
    LONG acpEnd;
    TS_TEXTCHANGE dctc;
    HRESULT hr;

    if (paStart == NULL || paEnd == NULL || pDataObject == NULL)
        return E_INVALIDARG;

    if ((par = GetCAnchorRef_NA(paStart)) == NULL)
        return E_FAIL;
    acpStart = par->_GetACP();

    if ((par = GetCAnchorRef_NA(paEnd)) == NULL)
        return E_FAIL;
    acpEnd = par->_GetACP();

    hr =  _ptsi->InsertEmbedded(dwFlags, acpStart, acpEnd, pDataObject, &dctc);

    // we'll handle the anchor updates -- the app won't give us an OnTextChange callback for our
    // own changes
    if (hr == S_OK)
    {
        _PostInsertUpdate(acpStart, acpEnd, 1 /* cch */, &dctc);
    }

    return hr;
}

//+---------------------------------------------------------------------------
//
// GetStart
//
//----------------------------------------------------------------------------

STDAPI CACPWrap::GetStart(IAnchor **ppaStart)
{
    _Dbg_AssertNoAppLock();

    if (ppaStart == NULL)
        return E_INVALIDARG;

    *ppaStart = NULL;

    return (*ppaStart = _CreateAnchorACP(0, TS_GR_FORWARD)) ? S_OK : E_OUTOFMEMORY;
}

//+---------------------------------------------------------------------------
//
// GetEnd
//
//----------------------------------------------------------------------------

STDAPI CACPWrap::GetEnd(IAnchor **ppaEnd)
{
    LONG acpEnd;
    HRESULT hr;

    _Dbg_AssertNoAppLock();

    if (ppaEnd == NULL)
        return E_INVALIDARG;

    *ppaEnd = NULL;

    if (FAILED(hr = _ptsi->GetEndACP(&acpEnd)))
        return hr;

    return (*ppaEnd = _CreateAnchorACP(acpEnd, TS_GR_FORWARD)) ? S_OK : E_OUTOFMEMORY;
}

//+---------------------------------------------------------------------------
//
// GetStatus
//
//----------------------------------------------------------------------------

STDAPI CACPWrap::GetStatus(TS_STATUS *pdcs)
{
    return _ptsi->GetStatus(pdcs);
}

//+---------------------------------------------------------------------------
//
// QueryInsert
//
//----------------------------------------------------------------------------

STDAPI CACPWrap::QueryInsert(IAnchor *paTestStart, IAnchor *paTestEnd, ULONG cch, IAnchor **ppaResultStart, IAnchor **ppaResultEnd)
{
    LONG acpTestStart;
    LONG acpTestEnd;
    LONG acpResultStart;
    LONG acpResultEnd;
    CAnchorRef *par;
    HRESULT hr;

    if (ppaResultStart != NULL)
    {
        *ppaResultStart = NULL;
    }
    if (ppaResultEnd != NULL)
    {
        *ppaResultEnd = NULL;
    }
    if (ppaResultStart == NULL || ppaResultEnd == NULL)
        return E_INVALIDARG;

    if ((par = GetCAnchorRef_NA(paTestStart)) == NULL)
        return E_INVALIDARG;
    acpTestStart = par->_GetACP();

    if ((par = GetCAnchorRef_NA(paTestEnd)) == NULL)
        return E_INVALIDARG;
    acpTestEnd = par->_GetACP();

    hr = _ptsi->QueryInsert(acpTestStart, acpTestEnd, cch, &acpResultStart, &acpResultEnd);

    if (hr != S_OK)
        return E_FAIL;

    if (acpResultStart < 0)
    {
        *ppaResultStart = NULL;
    }
    else if ((*ppaResultStart = _CreateAnchorACP(acpResultStart, TS_GR_BACKWARD)) == NULL)
        return E_OUTOFMEMORY;

    if (acpResultEnd < 0)
    {
        *ppaResultEnd = NULL;
    }
    else if ((*ppaResultEnd = _CreateAnchorACP(acpResultEnd, TS_GR_FORWARD)) == NULL)
    {
        SafeRelease(*ppaResultStart);
        return E_OUTOFMEMORY;
    }

    return S_OK;
}

//+---------------------------------------------------------------------------
//
// GetAnchorFromPoint
//
//----------------------------------------------------------------------------

STDAPI CACPWrap::GetAnchorFromPoint(TsViewCookie vcView, const POINT *pt, DWORD dwFlags, IAnchor **ppaSite)
{
    LONG acp;

    if (ppaSite != NULL)
    {
        *ppaSite = NULL;
    }
    if (pt == NULL || ppaSite == NULL)
        return E_INVALIDARG;

    if (dwFlags & ~(GXFPF_ROUND_NEAREST | GXFPF_NEAREST))
        return E_INVALIDARG;

    if (FAILED(_ptsi->GetACPFromPoint(vcView, pt, dwFlags, &acp)))
        return E_FAIL;

    _Dbg_AssertNoAppLock();

    return (*ppaSite = _CreateAnchorACP(acp, TS_GR_FORWARD)) ? S_OK : E_OUTOFMEMORY;
}

//+---------------------------------------------------------------------------
//
// GetTextExt
//
//----------------------------------------------------------------------------

STDAPI CACPWrap::GetTextExt(TsViewCookie vcView, IAnchor *paStart, IAnchor *paEnd, RECT *prc, BOOL *pfClipped)
{
    CAnchorRef *par;
    LONG acpStart;
    LONG acpEnd;

    _Dbg_AssertNoAppLock();

    if (prc != NULL)
    {
        memset(prc, 0, sizeof(*prc));
    }
    if (pfClipped != NULL)
    {
        *pfClipped = FALSE;
    }
    if (paStart == NULL || paEnd == NULL || prc == NULL || pfClipped == NULL)
        return E_INVALIDARG;

    if ((par = GetCAnchorRef_NA(paStart)) == NULL)
        return E_FAIL;
    acpStart = par->_GetACP();

    if ((par = GetCAnchorRef_NA(paEnd)) == NULL)
        return E_FAIL;
    acpEnd = par->_GetACP();

    return _ptsi->GetTextExt(vcView, acpStart, acpEnd, prc, pfClipped);
}

//+---------------------------------------------------------------------------
//
// GetScreenExt
//
//----------------------------------------------------------------------------

STDAPI CACPWrap::GetScreenExt(TsViewCookie vcView, RECT *prc)
{
    if (prc == NULL)
        return E_INVALIDARG;

    return _ptsi->GetScreenExt(vcView, prc);
}

//+---------------------------------------------------------------------------
//
// GetWnd
//
//----------------------------------------------------------------------------

STDAPI CACPWrap::GetWnd(TsViewCookie vcView, HWND *phwnd)
{
    if (phwnd == NULL)
        return E_INVALIDARG;

    return _ptsi->GetWnd(vcView, phwnd);
}

//+---------------------------------------------------------------------------
//
// Serialize
//
//----------------------------------------------------------------------------

STDAPI CACPWrap::Serialize(ITfProperty *pProp, ITfRange *pRange, TF_PERSISTENT_PROPERTY_HEADER_ACP *pHdr, IStream *pStream)
{
#ifdef LATER
    // word won't grant us a sync lock here even though we need one
    SERIALIZE_ACP_PARAMS params;
    HRESULT hr;

    params.pWrap = this;
    params.pProp = pProp;
    params.pRange = pRange;
    params.pHdr = pHdr;
    params.pStream = pStream;

    // need a sync read lock to do our work
    if (_pic->_DoPseudoSyncEditSession(TF_ES_READ, PSEUDO_ESCB_SERIALIZE_ACP, &params, &hr) != S_OK)
    {
        Assert(0); // app won't give us a sync read lock
        return E_FAIL;
    }

    return hr;
#else
    return _Serialize(pProp, pRange, pHdr, pStream);
#endif
}

//+---------------------------------------------------------------------------
//
// _Serialize
//
//----------------------------------------------------------------------------

HRESULT CACPWrap::_Serialize(ITfProperty *pProp, ITfRange *pRange, TF_PERSISTENT_PROPERTY_HEADER_ACP *pHdr, IStream *pStream)
{
    TF_PERSISTENT_PROPERTY_HEADER_ANCHOR phanch;
    CProperty *pPropP = NULL;
    CRange *pRangeP;
    HRESULT hr = E_FAIL;

    if ((pPropP = GetCProperty(pProp)) == NULL)
        goto Exit;

    if ((pRangeP = GetCRange_NA(pRange)) == NULL)
        goto Exit;

    if (!VerifySameContext(_pic, pRangeP))
        goto Exit;

    hr = pPropP->_Serialize(pRangeP, &phanch, pStream);

    if (hr == S_OK)
    {
        if (!_AnchorHdrToACP(&phanch, pHdr))
        { 
            memset(pHdr, 0, sizeof(TF_PERSISTENT_PROPERTY_HEADER_ACP));
            hr = E_FAIL;
            Assert(0);
        }
    }
    else
    {
        memset(pHdr, 0, sizeof(TF_PERSISTENT_PROPERTY_HEADER_ACP));
    }

    Assert(pHdr->ichStart >= 0);
    Assert(pHdr->cch >= 0);

    SafeRelease(phanch.paStart);
    SafeRelease(phanch.paEnd);

Exit:
    SafeRelease(pPropP);

    return hr;
}

//+---------------------------------------------------------------------------
//
// Unserialize
//
//----------------------------------------------------------------------------

STDAPI CACPWrap::Unserialize(ITfProperty *pProp, const TF_PERSISTENT_PROPERTY_HEADER_ACP *pHdr, IStream *pStream, ITfPersistentPropertyLoaderACP *pLoaderACP)
{
    UNSERIALIZE_ACP_PARAMS params;
    HRESULT hr;

    params.pWrap = this;
    params.pProp = pProp;
    params.pHdr = pHdr;
    params.pStream = pStream;
    params.pLoaderACP = pLoaderACP;

    // need a sync read lock to do our work
    if (_pic->_DoPseudoSyncEditSession(TF_ES_READ, PSEUDO_ESCB_UNSERIALIZE_ACP, &params, &hr) != S_OK)
    {
        Assert(0); // app won't give us a sync read lock
        return E_FAIL;
    }

    return hr;
}

//+---------------------------------------------------------------------------
//
// _Unserialize
//
//----------------------------------------------------------------------------

HRESULT CACPWrap::_Unserialize(ITfProperty *pProp, const TF_PERSISTENT_PROPERTY_HEADER_ACP *pHdr, IStream *pStream, ITfPersistentPropertyLoaderACP *pLoaderACP)
{
    TF_PERSISTENT_PROPERTY_HEADER_ANCHOR hdrAnchor;
    CProperty *pPropP = NULL;
    CLoaderACPWrap *pLoader;
    HRESULT hr = E_FAIL;

    Assert(pHdr->ichStart >= 0);
    Assert(pHdr->cch > 0);

    hdrAnchor.paStart = NULL;
    hdrAnchor.paEnd = NULL;

    if (pHdr->ichStart < 0)
        goto Exit;

    if (pHdr->cch <= 0)
        goto Exit;

    if (_ACPHdrToAnchor(pHdr, &hdrAnchor) != S_OK)
    {
        Assert(0);
        goto Exit;
    }

    if ((pPropP = GetCProperty(pProp)) == NULL)
        goto Exit;

    pLoader = NULL;

    if (pLoaderACP != NULL &&
        (pLoader = new CLoaderACPWrap(pLoaderACP)) == NULL)
    {
        hr = E_OUTOFMEMORY;
        goto Exit;
    }

    hr = pPropP->_Unserialize(&hdrAnchor, pStream, pLoader);

    SafeRelease(pLoader);

Exit:
    SafeRelease(pPropP);
    SafeRelease(hdrAnchor.paStart);
    SafeRelease(hdrAnchor.paEnd);

    return hr;
}

//+---------------------------------------------------------------------------
//
// ForceLoadProperty
//
//----------------------------------------------------------------------------

STDAPI CACPWrap::ForceLoadProperty(ITfProperty *pProp)
{
    CProperty *pPropP;
    HRESULT hr;

    if ((pPropP = GetCProperty(pProp)) == NULL)
        return E_FAIL;

    hr = pPropP->ForceLoad();

    pPropP->Release();

    return hr;
}

//+---------------------------------------------------------------------------
//
// CreateRange
//
//----------------------------------------------------------------------------

STDAPI CACPWrap::CreateRange(LONG acpStart, LONG acpEnd, ITfRangeACP **ppRange)
{
    ITfRangeAnchor *rangeAnchor;
    CAnchorRef *paStart;
    CAnchorRef *paEnd;
    HRESULT hr;
    ITextStoreAnchorServices *pserv;

    if (ppRange == NULL)
        return E_INVALIDARG;

    *ppRange = NULL;
    hr = E_FAIL;
    paEnd = NULL;

    Perf_IncCounter(PERF_CREATERANGE_ACP);

    if ((paStart = _CreateAnchorACP(acpStart, TS_GR_BACKWARD)) == NULL)
        goto Exit;
    if ((paEnd = _CreateAnchorACP(acpEnd, TS_GR_BACKWARD)) == NULL)
        goto Exit;

    if ((hr = _ptss->QueryInterface(IID_ITextStoreAnchorServices, (void **)&pserv)) == S_OK)
    {
        hr = pserv->CreateRange(paStart, paEnd, &rangeAnchor);
        pserv->Release();
    }

    if (hr == S_OK)
    {
        *ppRange = (ITfRangeACP *)(CRange *)rangeAnchor;
    }

Exit:
    SafeRelease(paStart);
    SafeRelease(paEnd);

    return hr;
}

//+---------------------------------------------------------------------------
//
// _CreateAnchorACP
//
//----------------------------------------------------------------------------

CAnchorRef *CACPWrap::_CreateAnchorACP(LONG acp, TsGravity gravity)
{
    CAnchorRef *pa;

    if ((pa = new CAnchorRef) == NULL)
        return NULL;

    if (!pa->_Init(this, acp, gravity))
    {
        pa->Release();
        return NULL;
    }

    return pa;
}

//+---------------------------------------------------------------------------
//
// _CreateAnchorACP
//
//----------------------------------------------------------------------------

CAnchorRef *CACPWrap::_CreateAnchorAnchor(CAnchor *paAnchor, TsGravity gravity)
{
    CAnchorRef *pa;

    if ((pa = new CAnchorRef) == NULL)
        return NULL;

    if (!pa->_Init(this, paAnchor, gravity))
    {
        pa->Release();
        return NULL;
    }

    return pa;
}

//+---------------------------------------------------------------------------
//
// _ACPHdrToAnchor
//
//----------------------------------------------------------------------------

HRESULT CACPWrap::_ACPHdrToAnchor(const TF_PERSISTENT_PROPERTY_HEADER_ACP *pHdr, TF_PERSISTENT_PROPERTY_HEADER_ANCHOR *phanch)
{
    phanch->paStart = NULL;

    if ((phanch->paStart = _CreateAnchorACP(pHdr->ichStart, TS_GR_FORWARD)) == NULL)
        goto ExitError;
    if ((phanch->paEnd = _CreateAnchorACP(pHdr->ichStart + pHdr->cch, TS_GR_BACKWARD)) == NULL)
        goto ExitError;

    phanch->guidType = pHdr->guidType;
    phanch->cb = pHdr->cb;
    phanch->dwPrivate = pHdr->dwPrivate;
    phanch->clsidTIP = pHdr->clsidTIP;

    return S_OK;

ExitError:
    SafeRelease(phanch->paStart);
    return E_FAIL;
}

//+---------------------------------------------------------------------------
//
// _AnchorHdrToACP
//
//----------------------------------------------------------------------------

/* static */
BOOL CACPWrap::_AnchorHdrToACP(const TF_PERSISTENT_PROPERTY_HEADER_ANCHOR *phanch, TF_PERSISTENT_PROPERTY_HEADER_ACP *phacp)
{
    CAnchorRef *par;

    if ((par = GetCAnchorRef_NA(phanch->paStart)) == NULL)
        return FALSE;
    NormalizeAnchor(par);
    phacp->ichStart = par->_GetACP();

    if ((par = GetCAnchorRef_NA(phanch->paEnd)) == NULL)
        return FALSE;
    NormalizeAnchor(par);
    phacp->cch = par->_GetACP() - phacp->ichStart;

    phacp->guidType = phanch->guidType;
    phacp->cb = phanch->cb;
    phacp->dwPrivate = phanch->dwPrivate;
    phacp->clsidTIP = phanch->clsidTIP;

    return TRUE;
}

//+---------------------------------------------------------------------------
//
// RequestSupportedAttrs 
//
//----------------------------------------------------------------------------

STDAPI CACPWrap::RequestSupportedAttrs(DWORD dwFlags, ULONG cFilterAttrs, const TS_ATTRID *paFilterAttrs)
{
    return _ptsi->RequestSupportedAttrs(dwFlags, cFilterAttrs, paFilterAttrs);
}

//+---------------------------------------------------------------------------
//
// RequestAttrsAtPosition
//
//----------------------------------------------------------------------------

STDAPI CACPWrap::RequestAttrsAtPosition(IAnchor *paPos, ULONG cFilterAttrs, const TS_ATTRID *paFilterAttrs, DWORD dwFlags)
{
    CAnchorRef *par;
    LONG acpPos;

    if ((par = GetCAnchorRef_NA(paPos)) == NULL)
        return E_INVALIDARG;
    acpPos = par->_GetACP();

    return _ptsi->RequestAttrsAtPosition(acpPos, cFilterAttrs, paFilterAttrs, dwFlags);
}

//+---------------------------------------------------------------------------
//
// RequestAttrsTransitioningAtPosition
//
//----------------------------------------------------------------------------

STDAPI CACPWrap::RequestAttrsTransitioningAtPosition(IAnchor *paPos, ULONG cFilterAttrs, const TS_ATTRID *paFilterAttrs, DWORD dwFlags)
{
    CAnchorRef *par;
    LONG acpPos;

    if ((par = GetCAnchorRef_NA(paPos)) == NULL)
        return E_INVALIDARG;
    acpPos = par->_GetACP();

    return _ptsi->RequestAttrsTransitioningAtPosition(acpPos, cFilterAttrs, paFilterAttrs, dwFlags);
}

//+---------------------------------------------------------------------------
//
// FindNextAttrTransition
//
//----------------------------------------------------------------------------

STDAPI CACPWrap::FindNextAttrTransition(IAnchor *paStart, IAnchor *paHalt, ULONG cFilterAttrs, const TS_ATTRID *paFilterAttrs, DWORD dwFlags, BOOL *pfFound, LONG *plFoundOffset)
{
    CAnchorRef *parStart;
    CAnchorRef *parHalt;
    LONG acpStart;
    LONG acpHalt;
    LONG acpNext;
    HRESULT hr;

    if ((parStart = GetCAnchorRef_NA(paStart)) == NULL)
        return E_INVALIDARG;
    acpStart = parStart->_GetACP();

    acpHalt = -1;
    if (paHalt != NULL)
    {
        hr = E_INVALIDARG;
        if ((parHalt = GetCAnchorRef_NA(paHalt)) == NULL)
            goto Exit;
        acpHalt = parHalt->_GetACP();
    }

    hr = _ptsi->FindNextAttrTransition(acpStart, acpHalt, cFilterAttrs, paFilterAttrs, dwFlags, &acpNext, pfFound, plFoundOffset);

    if (hr == S_OK &&
        (dwFlags & TS_ATTR_FIND_UPDATESTART))
    {
        parStart->_SetACP(acpNext);
    }

Exit:
    return hr;
}

//+---------------------------------------------------------------------------
//
// RetrieveRequestedAttrs
//
//----------------------------------------------------------------------------

STDAPI CACPWrap::RetrieveRequestedAttrs(ULONG ulCount, TS_ATTRVAL *paAttrVals, ULONG *pcFetched)
{
    return _ptsi->RetrieveRequestedAttrs(ulCount, paAttrVals, pcFetched);
}

//+---------------------------------------------------------------------------
//
// AdviseMouseSink
//
//----------------------------------------------------------------------------

STDAPI CACPWrap::AdviseMouseSink(ITfRangeACP *range, ITfMouseSink *pSink, DWORD *pdwCookie)
{
    ITfMouseTrackerACP *pTrackerACP;
    HRESULT hr;

    if (pdwCookie == NULL)
        return E_INVALIDARG;

    *pdwCookie = 0;

    if (_ptsi->QueryInterface(IID_ITfMouseTrackerACP, (void **)&pTrackerACP) != S_OK)
        return E_NOTIMPL;

    hr = pTrackerACP->AdviseMouseSink(range, pSink, pdwCookie);

    pTrackerACP->Release();
    return hr;
}

//+---------------------------------------------------------------------------
//
// UnadviseMouseSink
//
//----------------------------------------------------------------------------

STDAPI CACPWrap::UnadviseMouseSink(DWORD dwCookie)
{
    ITfMouseTrackerACP *pTrackerACP;
    HRESULT hr;

    if (_ptsi->QueryInterface(IID_ITfMouseTrackerACP, (void **)&pTrackerACP) != S_OK)
        return E_NOTIMPL;

    hr = pTrackerACP->UnadviseMouseSink(dwCookie);

    pTrackerACP->Release();
    return hr;
}

//+---------------------------------------------------------------------------
//
// QueryService
//
//----------------------------------------------------------------------------

STDAPI CACPWrap::QueryService(REFGUID guidService, REFIID riid, void **ppv)
{
    IServiceProvider *psp;
    HRESULT hr;

    if (ppv == NULL)
        return E_INVALIDARG;

    *ppv = NULL;

    // SVC_E_NOSERVICE is proper return code for wrong service....
    // but it's not defined anywhere.  So use E_NOINTERFACE for both
    // cases as trident is rumored to do
    hr =  E_NOINTERFACE;

    if (IsEqualGUID(guidService, GUID_SERVICE_TF) &&
        IsEqualIID(riid, IID_PRIV_ACPWRAP))
    {
        *ppv = this;
        AddRef();
        hr = S_OK;
    }
    else if (_ptsi->QueryInterface(IID_IServiceProvider, (void **)&psp) == S_OK)
    {
        // we just pass the request along to the wrapped obj
        hr = psp->QueryService(guidService, riid, ppv);
        psp->Release();
    }

    return hr;
}

//+---------------------------------------------------------------------------
//
// GetActiveView
//
//----------------------------------------------------------------------------

STDAPI CACPWrap::GetActiveView(TsViewCookie *pvcView)
{
    if (pvcView == NULL)
        return E_INVALIDARG;

    return _ptsi->GetActiveView(pvcView);
}

//+---------------------------------------------------------------------------
//
// InsertTextAtSelection
//
//----------------------------------------------------------------------------

STDAPI CACPWrap::InsertTextAtSelection(DWORD dwFlags, const WCHAR *pchText, ULONG cch, IAnchor **ppaStart, IAnchor **ppaEnd)
{
    LONG acpStart;
    LONG acpEnd;
    TS_TEXTCHANGE dctc;
    HRESULT hr;

    _Dbg_AssertNoAppLock();

    Assert(ppaStart != NULL && ppaEnd != NULL);
    Assert((dwFlags & TS_IAS_QUERYONLY) || pchText != NULL); // caller should have already caught this
    Assert((dwFlags & TS_IAS_QUERYONLY) || cch > 0); // caller should have already caught this
    Assert((dwFlags & (TS_IAS_NOQUERY | TS_IAS_QUERYONLY)) != (TS_IAS_NOQUERY | TS_IAS_QUERYONLY));

    *ppaStart = NULL;
    *ppaEnd = NULL;

    hr = _ptsi->InsertTextAtSelection(dwFlags, pchText, cch, &acpStart, &acpEnd, &dctc);

    // we'll handle the anchor updates -- the app won't give us an OnTextChange callback for our
    // own changes
    if (hr != S_OK)
        return hr;

    if (!(dwFlags & TF_IAS_QUERYONLY))
    {
        _PostInsertUpdate(acpStart, acpEnd, cch, &dctc);
    }

    if (!(dwFlags & TF_IAS_NOQUERY))
    {
        if ((*ppaStart = _CreateAnchorACP(acpStart, TS_GR_BACKWARD)) == NULL)
            goto ExitError;
        if ((*ppaEnd = _CreateAnchorACP(acpEnd, TS_GR_FORWARD)) == NULL)
            goto ExitError;
    }

    return S_OK;

ExitError:
    SafeReleaseClear(*ppaStart);
    return E_FAIL;
}

//+---------------------------------------------------------------------------
//
// InsertEmbeddedAtSelection
//
//----------------------------------------------------------------------------

STDAPI CACPWrap::InsertEmbeddedAtSelection(DWORD dwFlags, IDataObject *pDataObject, IAnchor **ppaStart, IAnchor **ppaEnd)
{
    LONG acpStart;
    LONG acpEnd;
    TS_TEXTCHANGE dctc;
    HRESULT hr;

    _Dbg_AssertNoAppLock();

    Assert(ppaStart != NULL && ppaEnd != NULL);
    Assert((dwFlags & (TS_IAS_NOQUERY | TS_IAS_QUERYONLY)) != (TS_IAS_NOQUERY | TS_IAS_QUERYONLY));
    Assert((dwFlags & TS_IAS_QUERYONLY) || pDataObject == NULL);

    *ppaStart = NULL;
    *ppaEnd = NULL;

    hr = _ptsi->InsertEmbeddedAtSelection(dwFlags, pDataObject, &acpStart, &acpEnd, &dctc);

    // we'll handle the anchor updates -- the app won't give us an OnTextChange callback for our
    // own changes
    if (hr != S_OK)
        return hr;

    if (!(dwFlags & TF_IAS_QUERYONLY))
    {
        _PostInsertUpdate(acpStart, acpEnd, 1 /* cch */, &dctc);
    }

    if (!(dwFlags & TF_IAS_NOQUERY))
    {
        if ((*ppaStart = _CreateAnchorACP(acpStart, TS_GR_BACKWARD)) == NULL)
            goto ExitError;
        if ((*ppaEnd = _CreateAnchorACP(acpEnd, TS_GR_FORWARD)) == NULL)
            goto ExitError;
    }

    return S_OK;

ExitError:
    SafeReleaseClear(*ppaStart);
    return E_FAIL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\ctf\uim\api.cpp ===
//
// api.c
//

#include "private.h"
#include "tim.h"
#include "dim.h"
#include "dam.h"
#include "imelist.h"
#include "nuimgr.h"
#include "globals.h"
#include "assembly.h"
#include "timlist.h"
#include "catmgr.h"

extern "C" HRESULT WINAPI TF_GetThreadMgr(ITfThreadMgr **pptim)
{
    SYSTHREAD *psfn = GetSYSTHREAD();
    if (!psfn)
        return E_FAIL;

    if (pptim)
    {
        *pptim = psfn->ptim;
        if (*pptim)
            (*pptim)->AddRef(); 
    }
    return S_OK;
}

extern "C" HRESULT WINAPI TF_CreateThreadMgr(ITfThreadMgr **pptim)
{
    return CThreadInputMgr::CreateInstance(NULL, IID_ITfThreadMgr, (void **)pptim);
}

extern "C" HRESULT WINAPI TF_CreateDisplayAttributeMgr(ITfDisplayAttributeMgr **ppdam)
{
    return CDisplayAttributeMgr::CreateInstance(NULL, IID_ITfDisplayAttributeMgr, (void **)ppdam);
}

extern "C" HRESULT WINAPI TF_CreateLangBarMgr(ITfLangBarMgr **pplbm)
{
    return CLangBarMgr::CreateInstance(NULL, IID_ITfLangBarMgr, (void **)pplbm);
}

extern "C" HRESULT WINAPI TF_CreateInputProcessorProfiles(ITfInputProcessorProfiles **ppipp)
{
    return CInputProcessorProfiles::CreateInstance(NULL, IID_ITfInputProcessorProfiles, (void **)ppipp);
}

extern "C" HRESULT WINAPI TF_CreateLangBarItemMgr(ITfLangBarItemMgr **pplbim)
{
    return CLangBarItemMgr::CreateInstance(NULL, IID_ITfLangBarItemMgr, (void **)pplbim);
}

extern "C" HRESULT WINAPI TF_InvalidAssemblyListCache()
{
    if (!CAssemblyList::InvalidCache())
         return E_FAIL;

    SYSTHREAD *psfn = GetSYSTHREAD();
    if (!psfn)
        return E_FAIL;

    EnsureAssemblyList(psfn, TRUE);

    return S_OK;
}

extern "C" HRESULT WINAPI TF_InvalidAssemblyListCacheIfExist()
{
    // the only diff from TF_InvalidAssemblyListCache() is 
    // that we don't care if cache really exist
    //
    CAssemblyList::InvalidCache();

    SYSTHREAD *psfn = GetSYSTHREAD();
    if (!psfn)
        return E_FAIL;

    EnsureAssemblyList(psfn, TRUE);

    return S_OK;
}

extern "C" HRESULT WINAPI TF_PostAllThreadMsg(WPARAM wParam, DWORD dwFlags)
{
    ULONG ulNum;
    SYSTHREAD *psfn = GetSYSTHREAD();
    if (!psfn)
        return E_FAIL;

    EnsureTIMList(psfn);

    ulNum = g_timlist.GetNum();

    if (ulNum)
    {
        DWORD *pdw = new DWORD[ulNum + 1];
        if (pdw)
        {
            if (g_timlist.GetList(pdw,
                                  ulNum+1,
                                  &ulNum, 
                                  dwFlags,
                                  TLFlagFromTFPriv(wParam),
                                  TRUE))
            {
                ULONG ul;
                for (ul = 0; ul < ulNum; ul++)
                {
                    if (pdw[ul])
                        PostThreadMessage(pdw[ul], g_msgPrivate, wParam, 0);
                }
            }
            delete pdw;
        }
    }

    return S_OK;
}

extern "C" HRESULT WINAPI TF_CreateCategoryMgr(ITfCategoryMgr **ppCategoryMgr)
{
    return CCategoryMgr::CreateInstance(NULL, IID_ITfCategoryMgr, (void **)ppCategoryMgr);
}

extern "C" BOOL WINAPI TF_IsFullScreenWindowAcitvated()
{
    return GetSharedMemory()->fInFullScreen ? TRUE : FALSE;
}

extern "C" HRESULT WINAPI TF_GetGlobalCompartment(ITfCompartmentMgr **ppCompMgr)
{
    if (!ppCompMgr)
        return E_INVALIDARG;

    *ppCompMgr = NULL;

    SYSTHREAD *psfn = GetSYSTHREAD();

    EnsureGlobalCompartment(psfn);

    if (!psfn->_pGlobalCompMgr)
        return E_OUTOFMEMORY;

    if (EnsureTIMList(psfn))
        g_timlist.SetFlags(psfn->dwThreadId, TLF_GCOMPACTIVE);

    *ppCompMgr = psfn->_pGlobalCompMgr;
    psfn->_pGlobalCompMgr->AddRef();

    return S_OK;
}


extern "C" HRESULT WINAPI TF_CUASAppFix(LPCSTR lpCmdLine)
{
    if (!lpCmdLine)
        return E_INVALIDARG;

    if (!lstrcmpi(lpCmdLine, "DelayFirstActivateKeyboardLayout"))
    {
        g_dwAppCompatibility |= CIC_COMPAT_DELAYFIRSTACTIVATEKBDLAYOUT;
        return S_OK;
    }
    return E_INVALIDARG;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\ctf\uim\assembly.cpp ===
#include "private.h"
#include "globals.h"
#include "regsvr.h"
#include "catutil.h"
#include "cregkey.h"
#include "assembly.h"
#include "immxutil.h"
#include "osver.h"
#include "internat.h"
#include "cicmutex.h"
#include "imelist.h"
#include "tim.h"

extern CCicMutex g_mutexAsm;
extern char g_szAsmListCache[];

extern HRESULT g_EnumItemsInCategory(REFGUID rcatid, IEnumGUID **ppEnum);


//+---------------------------------------------------------------------------
//
// TF_GetLangIcon
//
//+---------------------------------------------------------------------------

HICON WINAPI TF_GetLangIcon(WORD langid , WCHAR *psz, UINT cchMax)
{
    if (psz)
    {
        SYSTHREAD *psfn = GetSYSTHREAD();
        CAssemblyList *pAsmList;
        *psz = L'\0';

        if (psfn && (pAsmList = EnsureAssemblyList(psfn)))
        {
            CAssembly *pAsm = pAsmList->FindAssemblyByLangId(langid);
            if (pAsm)
            {
                StringCchCopyW(psz, cchMax, pAsm->GetLangName());
            }
        }
    
    }

    return InatCreateIcon(langid);
}


//----------------------------------------------------------------------------
//
// GetSubstituteHKLfromKey
//
//----------------------------------------------------------------------------

HKL GetSubstituteHKLfromKey(CMyRegKey *pkey, LANGID langid)
{
    char sz[16];

    if (pkey->QueryValueCch(sz, c_szSubstitutehKL, ARRAYSIZE(sz)) != S_OK)
        return NULL;

    HKL hkl = NULL;
    if ((sz[0] == '0') && ((sz[1] == 'X') || (sz[1] == 'x')))
    {
        hkl = (HKL)IntToPtr(AsciiToNum(&sz[2]));
        if (LOWORD(HandleToLong(hkl)) != langid)
        {
            //
            // bad substitution.
            //
            Assert(0);
            hkl = 0;
        }
    }
    return hkl;
}


//////////////////////////////////////////////////////////////////////////////
//
// CAssembly
//
//////////////////////////////////////////////////////////////////////////////

//+---------------------------------------------------------------------------
//
// ctor
//
//----------------------------------------------------------------------------

CAssembly::CAssembly(LANGID langid)
{
    _langid = langid;

    if (IsOnNT())
    {
        if (!GetLocaleInfoW(MAKELCID(langid, SORT_DEFAULT), 
                              LOCALE_SLANGUAGE, 
                              _szLangName, 
                              ARRAYSIZE(_szLangName)))
        {
            StringCchCopyW(_szLangName, ARRAYSIZE(_szLangName), L"Unknown Language");
        }
        else
        {
            _szLangName[ARRAYSIZE(_szLangName)-1] = 0; // in case GetLocaleInfoW truncates
        }
    }
    else
    {
        char szLangName[64];
        if (GetLocaleInfo(MAKELCID(langid, SORT_DEFAULT), 
                              LOCALE_SLANGUAGE, 
                              szLangName, 
                              sizeof(szLangName)))
        {
            szLangName[ARRAYSIZE(szLangName)-1] = 0; // in case GetLocaleInfoW truncates
            StringCchCopyW(_szLangName, ARRAYSIZE(_szLangName), AtoW(szLangName));
        }
        else
        {
            StringCchCopyW(_szLangName, ARRAYSIZE(_szLangName), L"Unknown Language");
        }
    }

}

//+---------------------------------------------------------------------------
//
// dtor
//
//----------------------------------------------------------------------------

CAssembly::~CAssembly()
{
}

//+---------------------------------------------------------------------------
//
// IsFEIMEActive()
//
//----------------------------------------------------------------------------

BOOL CAssembly::IsFEIMEActive()
{
    int i;
    if (IsFELangId(GetLangId()))
    {
        for (i = 0; i < Count(); i++)
        {
            ASSEMBLYITEM *pItem = GetItem(i);
            if (pItem->fActive && IsPureIMEHKL(pItem->hkl))
            {
                Assert(IsEqualGUID(pItem->clsid, GUID_NULL));
                return TRUE;
            }
        }
    }

#ifdef CHECKFEIMESELECTED
    if (_fUnknownFEIMESelected)
        return TRUE;
#endif CHECKFEIMESELECTED

    return FALSE;
}

//+---------------------------------------------------------------------------
//
// FindItemByCategory
//
//----------------------------------------------------------------------------

ASSEMBLYITEM *CAssembly::FindItemByCategory(REFGUID catid)
{
     int nCnt = _rgAsmItem.Count();
     int i;
     if (IsEqualGUID(catid, GUID_NULL))
         return NULL;

     for (i = 0; i < nCnt; i++)
     {
         ASSEMBLYITEM *pItemTmp;
         pItemTmp = _rgAsmItem.GetPtr(i);

         if (IsEqualGUID(pItemTmp->catid, catid))
            return pItemTmp;
     }
     return NULL;
}

//+---------------------------------------------------------------------------
//
// FindActiveKeyboardItem
//
// Why do you call this if there is no FocusDIM? You should not do.
// fActive is not reliable if there is no FocusDIM. 
// Ser SetFocusDIMForAssembly(BOOL fSetFocus) in profiles.cpp. we don't
// change fActive but switch hKL when the focus moves to non DIM control.
//
//----------------------------------------------------------------------------

ASSEMBLYITEM *CAssembly::FindActiveKeyboardItem()
{
     int nCnt = _rgAsmItem.Count();
     int i;

     for (i = 0; i < nCnt; i++)
     {
         ASSEMBLYITEM *pItemTmp;
         pItemTmp = _rgAsmItem.GetPtr(i);

         if (!pItemTmp->fEnabled)
            continue;

         if (!pItemTmp->fActive)
            continue;

         if (IsEqualGUID(pItemTmp->catid, GUID_TFCAT_TIP_KEYBOARD))
            return pItemTmp;
     }
     return NULL;
}

//+---------------------------------------------------------------------------
//
// FindKeyboardLayoutItem
//
//----------------------------------------------------------------------------

ASSEMBLYITEM *CAssembly::FindKeyboardLayoutItem(HKL hkl)
{
     int nCnt = _rgAsmItem.Count();
     int i;

     for (i = 0; i < nCnt; i++)
     {
         ASSEMBLYITEM *pItemTmp;
         pItemTmp = _rgAsmItem.GetPtr(i);

         if (!IsEqualGUID(pItemTmp->clsid, GUID_NULL))
             continue;

         if (IsEqualGUID(pItemTmp->catid, GUID_TFCAT_TIP_KEYBOARD) &&
             (pItemTmp->hkl == hkl))
         {
             return pItemTmp;
         }
     }
     return NULL;
}

//+---------------------------------------------------------------------------
//
// FindItemByCategory2
//
//----------------------------------------------------------------------------

BOOL CAssembly::IsEnabledItemByCategory(REFGUID catid)
{
     int nCnt = _rgAsmItem.Count();
     int i;

     if (IsEqualGUID(catid, GUID_NULL))
         return FALSE;

     for (i = 0; i < nCnt; i++)
     {
         ASSEMBLYITEM *pItemTmp;
         pItemTmp = _rgAsmItem.GetPtr(i);

         if (!IsEqualGUID(pItemTmp->catid, catid) && pItemTmp->fEnabled)
            return TRUE;
     }
     return FALSE;
}

//+---------------------------------------------------------------------------
//
// IsEnabledItem
//
//----------------------------------------------------------------------------

BOOL CAssembly::IsEnabledItem()
{
     int nCnt = _rgAsmItem.Count();
     int i;

     for (i = 0; i < nCnt; i++)
     {
         ASSEMBLYITEM *pItemTmp;
         pItemTmp = _rgAsmItem.GetPtr(i);

         if (pItemTmp->fEnabled)
             return TRUE;
     }
     return FALSE;
}

//+---------------------------------------------------------------------------
//
// FindPureKbdTipItem
//
//----------------------------------------------------------------------------

ASSEMBLYITEM *CAssembly::FindPureKbdTipItem()
{
     int nCnt = _rgAsmItem.Count();
     int i;

     for (i = 0; i < nCnt; i++)
     {
         ASSEMBLYITEM *pItemTmp;
         pItemTmp = _rgAsmItem.GetPtr(i);

         if (IsEqualGUID(pItemTmp->catid, GUID_TFCAT_TIP_KEYBOARD) && !IsPureIMEHKL(pItemTmp->hkl))
            return pItemTmp;
     }
     return NULL;
}

//+---------------------------------------------------------------------------
//
// IsNonCiceroItem
//
//----------------------------------------------------------------------------

BOOL CAssembly::IsNonCiceroItem()
{
     int nCnt = _rgAsmItem.Count();
     int i;
     BOOL fFound = FALSE;

     for (i = 0; i < nCnt; i++)
     {
         ASSEMBLYITEM *pItemTmp;
         pItemTmp = _rgAsmItem.GetPtr(i);

         if (!pItemTmp->fEnabled)
             continue;

         if (!IsEqualGUID(pItemTmp->catid, GUID_TFCAT_TIP_KEYBOARD))
             continue;

         if (IsEqualGUID(pItemTmp->clsid, GUID_NULL))
         {
             if (IsFELangId(LOWORD((DWORD)(LONG_PTR)(HKL)pItemTmp->hkl)))
             {
                 if (!IsPureIMEHKL(pItemTmp->hkl))
                 {
                     // Assert(0);
                     continue;
                 }
             }

             return TRUE;
         }
     }
     return FALSE;
}

//+---------------------------------------------------------------------------
//
// IsEnabled
//
//----------------------------------------------------------------------------

BOOL CAssembly::IsEnabled(SYSTHREAD *psfn)
{
    CThreadInputMgr *ptim;
    ptim = CThreadInputMgr::_GetThisFromSYSTHREAD(psfn);

    if (!ptim || !ptim->_GetFocusDocInputMgr()) 
        return IsNonCiceroItem() ? TRUE : FALSE;

    return IsEnabledKeyboardItem(psfn);
}

//+---------------------------------------------------------------------------
//
// IsEnabledKeyboardItem
//
//----------------------------------------------------------------------------

BOOL CAssembly::IsEnabledKeyboardItem(SYSTHREAD *psfn)
{
    int nCnt = _rgAsmItem.Count();
    int i;
    BOOL fFound = FALSE;

    for (i = 0; i < nCnt; i++)
    {
        ASSEMBLYITEM *pItemTmp;
        pItemTmp = _rgAsmItem.GetPtr(i);

        if (!pItemTmp->fEnabled)
            continue;

        if (!IsEqualGUID(pItemTmp->catid, GUID_TFCAT_TIP_KEYBOARD))
            continue;

        fFound = TRUE;
        break;
    }

    return fFound;
}

//+---------------------------------------------------------------------------
//
// RebuildSubstitutedHKLList
//
//----------------------------------------------------------------------------

void CAssembly::RebuildSubstitutedHKLList()
{
    int i;
    _rghklSubstituted.Clear();

    for (i = 0; i < Count(); i++)
    {
        ASSEMBLYITEM *pItem = GetItem(i);

        if (!pItem->fEnabled)
            continue;

        if (!pItem->hklSubstitute)
            continue;

        if (IsEqualGUID(pItem->catid, GUID_TFCAT_TIP_KEYBOARD) &&
            !IsEqualGUID(pItem->clsid, GUID_NULL))
        {
            HKL *phkl = _rghklSubstituted.Append(1);
            if (phkl)
                *phkl = pItem->hklSubstitute;
        }
    }

}

//+---------------------------------------------------------------------------
//
// IsSubstitutedHKL
//
//----------------------------------------------------------------------------

BOOL CAssembly::IsSubstitutedHKL(HKL hkl)
{
    int nCnt = _rghklSubstituted.Count();
    int i;

    for (i = 0; i < nCnt; i++)
    {
        HKL *phkl = _rghklSubstituted.GetPtr(i);
        if (*phkl == hkl)
            return TRUE;
    }

    return FALSE;
}

//+---------------------------------------------------------------------------
//
// GetSubstituteItem
//
//----------------------------------------------------------------------------

ASSEMBLYITEM *CAssembly::GetSubstituteItem(HKL hKL)
{
    int i;
    BOOL fCheckActive = TRUE;

TryAgain:
    for (i = 0; i < Count(); i++)
    {
        ASSEMBLYITEM *pItem = GetItem(i);

        if (!pItem->fEnabled)
            continue;

        if (!pItem->hklSubstitute)
            continue;

        if (fCheckActive)
        {
            if (!pItem->fActive)
                continue;
        }

        if (IsEqualGUID(pItem->catid, GUID_TFCAT_TIP_KEYBOARD) &&
            !IsEqualGUID(pItem->clsid, GUID_NULL))
        {
            if (hKL == pItem->hklSubstitute)
            {
                return pItem;
            }
        }
    }

    if (fCheckActive)
    {
        fCheckActive = FALSE;
        goto TryAgain;
    }
    
    return NULL;
}

//////////////////////////////////////////////////////////////////////////////
//
// CDefaultProfiles
//
// This class is a database for the default profiles and this database is
// created from HKCU\Software\Microsoft\CTF\TIP
//
// however we need to respect the system default hKL setting. If the keyboard
// tip's profile has a substitute hKL and this is not the system default hKL
// we use the system default hKL as a default profile.
//
//////////////////////////////////////////////////////////////////////////////

class CDefaultProfiles
{
public:
    CDefaultProfiles(LANGID langid) 
    {
        _langid = langid;
    }

    ~CDefaultProfiles()
    {
        _rgDefProfiles.Clear();
    }

    BOOL Init(HKL *phkl);
    BOOL FilterProfiles(CAssembly *pAsm);

    typedef struct tag_DEFAULTPROFILE 
    {
        GUID  catid;
        CLSID clsid;
        GUID  guidProfile;
        HKL   hkl;
    } DEFAULTPROFILE;


    BOOL GetDefaultProfile(GUID catid, GUID *pclsid, GUID *pguidProfile, HKL *phkl);

    BOOL Append(GUID catid, CLSID clsid, GUID guidProfile, HKL hkl)
    {
        DEFAULTPROFILE defpro;
        DEFAULTPROFILE *pdefpro;

        int i;
        for (i = 0; i < _rgDefProfiles.Count(); i++)
        {
            pdefpro = _rgDefProfiles.GetPtr(i);
            if (!pdefpro)
            {
                Assert(0);
                return FALSE;
            }

            if (IsEqualGUID(catid, pdefpro->catid))
                return FALSE;
        }

        defpro.catid = catid;
        defpro.clsid = clsid;
        defpro.guidProfile = guidProfile;
        defpro.hkl = hkl;

        pdefpro = _rgDefProfiles.Append(1);
        if (!pdefpro)
            return FALSE;

        memcpy(pdefpro, &defpro, sizeof(defpro));
        return TRUE;
    }

private:
    BOOL GetSubstitutedItem(HKL hklSub, DEFAULTPROFILE *pdefpro);
    LANGID _langid;
    CStructArray<DEFAULTPROFILE> _rgDefProfiles;
};


//+---------------------------------------------------------------------------
//
// Init
//
//----------------------------------------------------------------------------

BOOL CDefaultProfiles::Init(HKL *phkl)
{
    CMyRegKey key;
    DWORD dw;
    char szKey[256];
    char szName[CLSID_STRLEN + 1];
    HKL hklDef = GetSystemDefaultHKL();
    BOOL fFoundKeyboardIteminDefLang = FALSE;
    DEFAULTPROFILE defpro;
    DEFAULTPROFILE *pdefpro;
    DWORD dwIndex;

    StringCopyArray(szKey, c_szAsmKey);
    StringCatArray(szKey, "\\");
    StringCchPrintf(szKey + lstrlen(szKey), ARRAYSIZE(szKey)-lstrlen(szKey), "0x%08x", _langid);

    if (key.Open(HKEY_CURRENT_USER, szKey, KEY_READ) != S_OK)
        goto Exit;

    dwIndex = 0;
    while (key.EnumKey(dwIndex, szKey, ARRAYSIZE(szKey)) == S_OK)
    {
        CMyRegKey subkey;

        if (subkey.Open(key, szKey, KEY_READ) != S_OK)
            goto Next;

        StringAToCLSID(szKey, &defpro.catid);

        //
        // retreive tip clsid.
        //
        if (subkey.QueryValueCch(szName, c_szDefault, ARRAYSIZE(szName)) != S_OK)
            goto Next;
        StringAToCLSID(szName, &defpro.clsid);

        //
        // retreive guid profile
        //
        if (subkey.QueryValueCch(szName, c_szProfile, ARRAYSIZE(szName)) != S_OK)
            goto Next;
        StringAToCLSID(szName, &defpro.guidProfile);

        if (subkey.QueryValue(dw, c_szKeyboardLayout) != S_OK)
            goto Next;

        //
        // check the hkl from registry is valid or not.
        //
        defpro.hkl = (HKL)IntToPtr(dw);
        if (defpro.hkl)
        {
            int i = 0;
            BOOL fFound = FALSE;
            while(phkl[i])
            {
                if (defpro.hkl == phkl[i])
                {
                    fFound = TRUE;
                    break;
                }
                i++;
            }
            if (!fFound)
                goto Next;
        }

        //
        // if the system default hKL does not matched with
        // the substite hKL of this profile, this profile can not be
        // default profile. Instead the system default hKL became a
        // default profile item.
        //
        if ((LOWORD(HandleToLong(hklDef)) == _langid) &&
            IsEqualGUID(defpro.catid, GUID_TFCAT_TIP_KEYBOARD))
        {
            char szTmp[256];
            HKL hklSubstitute = NULL;
            fFoundKeyboardIteminDefLang = TRUE;

            if (InitProfileRegKeyStr(szTmp,
                                     ARRAYSIZE(szTmp),
                                     defpro.clsid, 
                                     _langid, 
                                     defpro.guidProfile))
            {
                CMyRegKey keySubstitute;

                if (keySubstitute.Open(HKEY_LOCAL_MACHINE, szTmp, KEY_READ) == S_OK)
                {
                    hklSubstitute = GetSubstituteHKLfromKey(&keySubstitute, _langid);
                }
            }

            // Removed Chinese specific code for bug#427476
            if (IsEqualGUID(defpro.clsid, GUID_NULL) ||
                (hklSubstitute && (hklSubstitute != hklDef)))
            {
                defpro.clsid = CLSID_NULL;
                defpro.guidProfile = GUID_NULL;
                defpro.hkl = hklDef;
            }
        }

        pdefpro = _rgDefProfiles.Append(1);
        if (!pdefpro)
            return FALSE;

        memcpy(pdefpro, &defpro, sizeof(defpro));

#ifdef DEBUG
{
    char szDbgCatid[CLSID_STRLEN + 1];
    char szDbgClsid[CLSID_STRLEN + 1];
    char szDbgguidProfile[CLSID_STRLEN + 1];
    CLSIDToStringA(defpro.catid, szDbgCatid);
    CLSIDToStringA(defpro.clsid, szDbgClsid);
    CLSIDToStringA(defpro.guidProfile, szDbgguidProfile);
    TraceMsg(TF_GENERAL, "CDefaultProfiles:: langid %08x", _langid);
    TraceMsg(TF_GENERAL, "                   catid        %s", szDbgCatid);
    TraceMsg(TF_GENERAL, "                   clsid        %s", szDbgClsid);
    TraceMsg(TF_GENERAL, "                   guidProfile  %s", szDbgguidProfile);
    TraceMsg(TF_GENERAL, "                   hkl          %08x", (DWORD)HandleToLong(defpro.hkl));
}
#endif

Next:
        dwIndex++;
    }

Exit:
    if (LOWORD(HandleToLong(hklDef)) == _langid)
    {
        if (!fFoundKeyboardIteminDefLang)
        {
            //
            // Check if the default hkl is a substitute hKL of a TIP's 
            // profile.
            //
            if (!GetSubstitutedItem(hklDef, &defpro))
            {
                //
                // we could not find TIP profile. Use this hkl as a default 
                // item.
                //
                defpro.catid = GUID_TFCAT_TIP_KEYBOARD;
                defpro.clsid = CLSID_NULL;
                defpro.guidProfile = GUID_NULL;
                defpro.hkl = hklDef;
            }

            pdefpro = _rgDefProfiles.Append(1);
            if (!pdefpro)
                return FALSE;

            memcpy(pdefpro, &defpro, sizeof(defpro));
        }
    }

    return TRUE;
}

//+---------------------------------------------------------------------------
//
// GetSubstitutedItem
//
// this function walks HKLM\Software\Microsoft\CTF\TIPs to find the 
// TIP profile that uses hklSub as its substitute hKL.
//
//----------------------------------------------------------------------------

BOOL CDefaultProfiles::GetSubstitutedItem(HKL hklSub, DEFAULTPROFILE *pdefpro)
{
    CMyRegKey key;
    DWORD dwIndex;
    
    TCHAR szKey[256];
    TCHAR szSubKey[256];
    TCHAR szLangKey[256];
    TCHAR szValue[256];

    StringCopyArray(szKey, c_szCTFTIPKey);
    if (key.Open(HKEY_LOCAL_MACHINE, szKey, KEY_READ) != S_OK)
    {
        return FALSE;
    }

    // get all profiles from LanguageProfile registry.
    //
    dwIndex = 0;
    while (key.EnumKey(dwIndex, szSubKey, ARRAYSIZE(szSubKey)) == S_OK)
    {
        CMyRegKey subkey;
        CLSID clsid;
        StringAToCLSID(szSubKey, &clsid);

        if (StringCchPrintf(szSubKey + lstrlen(szSubKey), ARRAYSIZE(szSubKey), "\\%s", c_szLanguageProfileKey) != S_OK)
            goto Next0;

        if (subkey.Open(key, szSubKey, KEY_READ) != S_OK)
            goto Next0;

        DWORD dwIndexLang = 0;
        while (subkey.EnumKey(dwIndexLang, szLangKey, ARRAYSIZE(szLangKey)) == S_OK)
        {
            CMyRegKey langkey;
            LANGID langid;

            if ((szLangKey[0] != '0') || 
                ((szLangKey[1] != 'X') && (szLangKey[1] != 'x')))
                goto Next1;

            langid = (LANGID)AsciiToNum(&szLangKey[2]);

            //
            // The language ID does not meet the given hklSub.
            //
            if (langid != LANGIDFROMHKL(hklSub))
                goto Next1;

            if (langkey.Open(subkey, szLangKey, KEY_READ) != S_OK)
                goto Next1;

            DWORD dwProfileIndex = 0; 
            while (langkey.EnumKey(dwProfileIndex, szValue, ARRAYSIZE(szValue)) == S_OK)
            {
                 GUID guidProfile;
                 CRegKeyMUI keyProfile;
               
                 if (!StringAToCLSID(szValue, &guidProfile))
                     goto Next2;

                 if (keyProfile.Open(langkey, szValue, KEY_READ) == S_OK)
                 { 
                      if (hklSub == GetSubstituteHKLfromKey(&keyProfile, langid))
                      {
                          //
                          // ok, we found it. Assume it is Keyboard category.
                          //
                          pdefpro->catid = GUID_TFCAT_TIP_KEYBOARD;
                          pdefpro->clsid = clsid;
                          pdefpro->guidProfile = guidProfile;
                          pdefpro->hkl = 0;

                          return TRUE;
                      }
                }

Next2:
                 dwProfileIndex++;
            }
Next1:
            dwIndexLang++;
        }

Next0:
        dwIndex++;
    }

    return FALSE;
}

//+---------------------------------------------------------------------------
//
// FilterProfiles
//
//----------------------------------------------------------------------------

BOOL CDefaultProfiles::FilterProfiles(CAssembly *pAsm)
{
    int i;
    int j;
    Assert(_langid == pAsm->GetLangId());

    for (i = _rgDefProfiles.Count() - 1; i >= 0 ; i--)
    {
        DEFAULTPROFILE *pdefpro = _rgDefProfiles.GetPtr(i);
        if (!pdefpro)
        {
            Assert(0);
            return FALSE;
        }

        BOOL fFound = FALSE;

        for (j = 0; j < pAsm->Count(); j++)
        {
            ASSEMBLYITEM *pItem = pAsm->GetItem(j);

            if (IsEqualGUID(pItem->catid, pdefpro->catid) &&
                IsEqualGUID(pItem->clsid, pdefpro->clsid) &&
                IsEqualGUID(pItem->guidProfile, pdefpro->guidProfile))
            {
                fFound = pItem->fEnabled ? TRUE : FALSE;
                break;
            }

        }

        if (!fFound)
        {
            _rgDefProfiles.Remove(i, 1);
        }
    }

    return TRUE;
}

//+---------------------------------------------------------------------------
//
// GetDefaultProfile
//
//----------------------------------------------------------------------------

BOOL CDefaultProfiles::GetDefaultProfile(GUID catid, GUID *pclsid, GUID *pguidProfile, HKL *phkl)
{
    int i;
    for (i = 0; i < _rgDefProfiles.Count(); i++)
    {
        DEFAULTPROFILE *pdefpro = _rgDefProfiles.GetPtr(i);
        if (!pdefpro)
        {
            Assert(0);
            return FALSE;
        }

        if (IsEqualGUID(catid, pdefpro->catid))
        {
            *pclsid = pdefpro->clsid;
            *pguidProfile = pdefpro->guidProfile;
            *phkl = pdefpro->hkl;
            return TRUE;
        }
    }

    return FALSE;
}

//////////////////////////////////////////////////////////////////////////////
//
// CAssemblyList
//
//////////////////////////////////////////////////////////////////////////////

//+---------------------------------------------------------------------------
//
// ctor
//
//----------------------------------------------------------------------------

CAssemblyList::CAssemblyList()
{
}

//+---------------------------------------------------------------------------
//
// dtor
//
//----------------------------------------------------------------------------

CAssemblyList::~CAssemblyList()
{
    ClearAsms();
}

//+---------------------------------------------------------------------------
//
// ClearAsms
//
//----------------------------------------------------------------------------

void CAssemblyList::ClearAsms()
{
    int i = 0;
    while (i < _rgAsm.Count())
    {
        CAssembly *pAsm = _rgAsm.Get(i);
        delete pAsm;
        i++;
    }
    _rgAsm.Clear();
}


//+---------------------------------------------------------------------------
//
// FindAndCreateNewAssembly
//
//----------------------------------------------------------------------------

extern INATSYMBOL symInatSymbols[];

CAssembly *CAssemblyList::FindAndCreateNewAssembly(CPtrArray<CAssembly> *prgAsm,  CPtrArray<CAssembly> *prgNutralAsm, LANGID langid)
{
    CPtrArray<CAssembly> *prg;

    if (langid == 0xffff)
        prg = prgNutralAsm;
    else 
        prg = (langid & 0xfc00) ? prgAsm : prgNutralAsm;

    //
    // do we already have pAsm?
    //
    CAssembly *pAsm = FindAssemblyByLangIdInArray(prg, langid);
    if (pAsm == NULL)
    {
        pAsm = new CAssembly(langid);

        if (pAsm)
        {
            CAssembly **ppAsm;
            ppAsm = prg->Append(1);
            if (ppAsm)
            {
                *ppAsm = pAsm;
            }
            else
            {
                delete pAsm;
                pAsm = NULL;
            }
        }
    }
    return pAsm;
}

//+---------------------------------------------------------------------------
//
// AttachOriginalAssembly
//
//----------------------------------------------------------------------------

void CAssemblyList::AttachOriginalAssembly(CPtrArray<CAssembly> *prgAsmOrg)
{
    int i;
    int j;
    SYSTHREAD *psfn = GetSYSTHREAD();
    CAssembly *pAsm = FindAssemblyByLangId(GetCurrentAssemblyLangId(psfn));

    if (!pAsm)
        return;

    for (i = 0; i < prgAsmOrg->Count(); i++)
    {
        CAssembly *pAsmOrg = prgAsmOrg->Get(i);

        if (pAsm->GetLangId() == pAsmOrg->GetLangId())
        {
            for (j = 0; j < pAsm->Count(); j++)
            {
                int nId;
                ASSEMBLYITEM *pItem = pAsm->GetItem(j);

                if (!pItem)
                    continue;

                nId = pAsmOrg->Find(pItem);
                if (nId >= 0)
                {
                    ASSEMBLYITEM *pItemOrg;
                    pItemOrg = pAsmOrg->GetItem(nId);
                    BOOL fPrevActive = pItem->fActive;
                    if (pItemOrg && (pItemOrg->fActive))
                    {
                        pItem->fActive = pItemOrg->fActive;

                        //
                        // we need to deactivate all other item in the 
                        // category.
                        //
                        if (!fPrevActive && pItem->fActive)
                        {
                            for (int k = 0; k < pAsm->Count(); k++)
                            {
                                ASSEMBLYITEM *pItemTemp = pAsm->GetItem(k);
                                if (pItemTemp == pItem)
                                    continue;

                                if (IsEqualGUID(pItemTemp->catid, pItem->catid))
                                    pItemTemp->fActive = FALSE;
                            }
                        }
                    }
                }
            }

            break;
        }
    }
}

//+---------------------------------------------------------------------------
//
// Load
//
//----------------------------------------------------------------------------

extern INATSYMBOL symInatSymbols[];

HRESULT CAssemblyList::Load()
{
    CMyRegKey key;
    CMyRegKey key2;
    int nhkl;
    HKL *lphkl = NULL;
    HKL hklList[2];
    LANGID langid;
    int i;
    ASSEMBLYITEM ai;
    DWORD dwIndex;
    CAssembly *pAsm = NULL;
    BOOL fFoundActiveNoCic = FALSE;
    CPtrArray<CAssembly> *prgNutralAsm = NULL;
    IEnumGUID *pEnumCat = NULL;
    HRESULT hr;
    int nAsmCnt;
    CPtrArray<CAssembly> rgAsmOrg;
    
    TCHAR szKey[256];
    TCHAR szSubKey[256];
    TCHAR szLangKey[256];
    TCHAR szValue[256];

    //
    // backup original assembly in rgAsmOrg;
    //
    for (i = 0; i < _rgAsm.Count(); i++)
    {
        pAsm = _rgAsm.Get(i);
        if (pAsm)
        {
            CAssembly **ppAsm = rgAsmOrg.Append(1);
            if (ppAsm)
                *ppAsm = pAsm;
        }
    }
    _rgAsm.Clear();

#ifdef PROFILE_UPDATE_REGISTRY  // old code for tip setup.
    if (IsUpdated())
    {
        ClearUpdatedFlag();
    }
    else
#endif
    {
        if (LoadFromCache())
        {
            AttachOriginalAssembly(&rgAsmOrg);
            hr = S_OK;
            goto Exit;
        }
    }

    prgNutralAsm = new CPtrArray<CAssembly>;
    if (!prgNutralAsm)
    {
        hr = E_OUTOFMEMORY;
        goto Exit;
    }

    StringCopyArray(szKey, c_szCTFTIPKey);
    if (key.Open(HKEY_LOCAL_MACHINE, szKey, KEY_READ) != S_OK)
    {
        hr = E_FAIL;
        goto Exit;
    }

    nhkl = GetKeyboardLayoutList(0, NULL);
    if (nhkl)
    {
        lphkl = (HKL *)cicMemAllocClear(sizeof(HKL) * (nhkl + 1));
        GetKeyboardLayoutList(nhkl, lphkl);
    }
    else
    {
        hklList[0] = GetKeyboardLayout(NULL);
        hklList[1] = NULL;
        lphkl = hklList;
    }

    //
    //  clear Category cache
    //
    CCategoryMgr::FreeCatCache();

    hr = g_EnumItemsInCategory(GUID_TFCAT_CATEGORY_OF_TIP, &pEnumCat);
    if (FAILED(hr))
    {
        goto Exit;
    }

    //
    // Check all TIP CLSID under HKCU is valid TIP CLSIDs.
    //
    StringCopyArray(szKey, c_szCTFTIPKey);
    if (key2.Open(HKEY_CURRENT_USER, szKey, KEY_ALL_ACCESS) == S_OK)
    {
        dwIndex = 0;
        while (key2.EnumKey(dwIndex, szSubKey, ARRAYSIZE(szSubKey)) == S_OK)
        {
            CMyRegKey subkey;
            dwIndex++;

            //
            // if we could not open the subkey (CLSID key) in HKLM,
            // HKCU should not have the subkey.
            //
            if (subkey.Open(key, szSubKey, KEY_READ) != S_OK)
            {
                if (key2.RecurseDeleteKey(szSubKey) == S_OK)
                    dwIndex--;
            }
        }
    }

    //
    // get all profiles from LanguageProfile registry.
    //
    dwIndex = 0;
    while (key.EnumKey(dwIndex++, szSubKey, ARRAYSIZE(szSubKey)) == S_OK)
    {
        CMyRegKey subkey;
        CLSID clsid;
        StringAToCLSID(szSubKey, &clsid);

        if (StringCchPrintf(szSubKey + lstrlen(szSubKey), ARRAYSIZE(szSubKey), "\\%s", c_szLanguageProfileKey) != S_OK)
            continue;

        if (subkey.Open(key, szSubKey, KEY_READ) == S_OK)
        {
            DWORD dwIndexLang = 0;
            while (subkey.EnumKey(dwIndexLang, szLangKey, ARRAYSIZE(szLangKey)) == S_OK)
            {
                CMyRegKey langkey;

                if ((szLangKey[0] != '0') || 
                    ((szLangKey[1] != 'X') && (szLangKey[1] != 'x')))
                    goto Next;

                langid = (LANGID)AsciiToNum(&szLangKey[2]);

                //
                // do we already have pAsm?
                //
                pAsm = FindAndCreateNewAssembly(&_rgAsm,  prgNutralAsm, langid);
                if (pAsm == NULL)
                {
                    hr = E_OUTOFMEMORY;
                    goto Exit;
                }

                if (langkey.Open(subkey, szLangKey, KEY_READ) == S_OK)
                {
                    DWORD dwProfileIndex = 0; 
                    while (langkey.EnumKey(dwProfileIndex, szValue, ARRAYSIZE(szValue)) == S_OK)
                    {
                         GUID guidProfile;
                         CRegKeyMUI keyProfile;
                       
                         if (!StringAToCLSID(szValue, &guidProfile))
                             goto NextKey;

                         memset(&ai, 0, ai.GetAlignSize());
                         ai.InitIconIndex();
                         ai.clsid = clsid;
                         ai.fActive = FALSE;
                         GetTIPCategory(clsid, &ai.catid, pEnumCat);
                         ai.guidProfile = guidProfile;
                         ai.fEnabled = FALSE;
 
                         // we will assign proper hKL later.
                         ai.hkl = NULL;


                         hr = keyProfile.Open(langkey, szValue, KEY_READ);
                         if (hr == S_OK)
                         { 
                              ai.hklSubstitute = GetSubstituteHKLfromKey(&keyProfile, langid);

                              hr = keyProfile.QueryMUIValueW(ai.szProfile,
                                                             c_szDescriptionW,
                                                             c_szMUIDescriptionW,
                                                             ARRAYSIZE(ai.szProfile));
                              
                              DWORD dw;
                              if ((keyProfile.QueryValue(dw, c_szDisabledOnTransitory) == S_OK) && dw)
                                  ai.fDisabledOnTransitory = TRUE;
                         }

                         if (hr == S_OK)
                             pAsm->Add(&ai);
NextKey:
                         dwProfileIndex++;
                    }
                }
Next:
                dwIndexLang++;
            }

        }
    }

    //
    // check all assembly has KEYBOARD category.
    // If not, we load keyboard layout for the assembly.
    //
    nAsmCnt = _rgAsm.Count();
    for (i = 0; i < nAsmCnt; i++)
    {
        BOOL bLoaded;
        int j;

        CAssembly *pAsmTmp = _rgAsm.Get(i);
        if (pAsmTmp->FindItemByCategory(GUID_TFCAT_TIP_KEYBOARD))
           continue;

        LANGID langidTmp = pAsmTmp->GetLangId();

        //
        // we can not use IsEnabledItem() here. We have not updated
        // the enbaled status of Items yet.
        //
        // if (!pAsmTmp->IsEnabledItem())
        //     continue;
        //
        BOOL fFound = FALSE;
        for (j = 0; j < pAsmTmp->Count(); j++)
        {
            ASSEMBLYITEM *pItem = pAsmTmp->GetItem(j);
            if (pItem->fEnabled ||
                IsEnabledLanguageProfileFromReg(pItem->clsid, 
                                                pAsmTmp->_langid, 
                                                pItem->guidProfile))
            {
                fFound = TRUE;
                break;
            }
        }

        if (!fFound)
            continue;

        //
        // Load a proper keyboard layout....
        //
        GetProperHKL(langidTmp, lphkl, &bLoaded);

        if (bLoaded)
        {
            //
            // re-create the keyboard layout list.
            //
            nhkl = GetKeyboardLayoutList(0, NULL);
            if (nhkl)
            {
                if (lphkl && (lphkl != hklList))
                    cicMemFree(lphkl);
                lphkl = (HKL *)cicMemAllocClear(sizeof(HKL) * (nhkl + 1));
                GetKeyboardLayoutList(nhkl, lphkl);
            }
            else
            {
                hklList[0] = GetKeyboardLayout(NULL);
                hklList[1] = NULL;
                lphkl = hklList;
            }
        }
    }

    //
    // get all hKLs.
    //
    if (lphkl)
    {
        HKL *lphklCur = lphkl;
        DWORD *pdwPreload = NULL;
        UINT uPreloadCnt;

        //
        // load preload layouts infomation.
        //
        uPreloadCnt = GetPreloadListForNT(NULL, 0);
        if (uPreloadCnt)
        {
            Assert(IsOnNT());
            pdwPreload = new DWORD[uPreloadCnt];
            if (pdwPreload)
                GetPreloadListForNT(pdwPreload, uPreloadCnt);
        }

        while (*lphklCur)
        {
            BOOL fIsDefaultHKLinPreload = FALSE;
            WORD wLayout = HIWORD((DWORD)(LONG_PTR)(*lphklCur));
            langid = (LANGID)((DWORD)(LONG_PTR)(*lphklCur) & 0x0000ffff);
    
            //
            // do we already have pAsm?
            //
            pAsm = FindAndCreateNewAssembly(&_rgAsm,  prgNutralAsm, langid);
            if (pAsm == NULL)
            {
                hr = E_OUTOFMEMORY;
                goto Exit;
            }

            //
            // See Preload to check if this default hKL is real dummy or not.
            // The default FE layout is not a dummy hKL if it is in Preload
            // list.
            //
            if (IsFELangId(langid))
            {
                if (wLayout == (WORD)langid)
                {
                    UINT uCur;
                    for (uCur = 0; uCur < uPreloadCnt; uCur++)
                    {
                        //
                        // check if we have 0x00000411 in preload.
                        //
                        if (pdwPreload[uCur] == (DWORD)(wLayout))
                        {
                            fIsDefaultHKLinPreload = TRUE;
                            break;
                        }
                    }
                }
                else if ((wLayout & 0xf000) != 0xe000)
                {
                    fIsDefaultHKLinPreload = TRUE;
                }
            }

            //
            // we skip dummy FE hKL.
            //
            if (!IsFELangId(langid) || 
                IsPureIMEHKL(*lphklCur) ||
                fIsDefaultHKLinPreload ||
                !pAsm->FindPureKbdTipItem())
            {
                TF_InitMlngInfo();
                MLNGINFO mlInfo;
                if (pAsm == NULL)
                    pAsm = new CAssembly(langid);
    
                memset(&ai, 0, ai.GetAlignSize());
                ai.InitIconIndex();
                ai.hkl = *lphklCur;
                ai.clsid = GUID_NULL;
                ai.catid = GUID_TFCAT_TIP_KEYBOARD;
                ai.fActive = FALSE;
                ai.fEnabled = TRUE;
                if (GetMlngInfoByhKL(ai.hkl, &mlInfo) == -1)
                   mlInfo.SetDesc(L"");
    
                ai.guidProfile = GUID_NULL;
                StringCopyArrayW(ai.szProfile, mlInfo.GetDesc());

                pAsm->Add(&ai);
            }
            lphklCur++;
        }
       
        if (pdwPreload)
            delete pdwPreload;
    }

    //
    // filter neutral langiage assembly
    //
    while (prgNutralAsm->Count())
    {
        pAsm = prgNutralAsm->Get(0);
        langid = pAsm->GetLangId();

        Assert((langid == 0xffff) || !(langid & 0xFC00));

        //
        // find valid langid ang merge there.
        //
        for (i = 0; i < _rgAsm.Count(); i++)
        {
            CAssembly *pAsmDst = _rgAsm.Get(i);
            LANGID langidDst = pAsmDst->GetLangId();
            Assert(langidDst & 0xFC00);

            //
            // we found a valid langid.
            //
            if ((langid == 0xffff) || 
                (PRIMARYLANGID(langid) == PRIMARYLANGID(langidDst)))
            {
                int j;
                for (j = 0; j < pAsm->Count(); j++)
                {
                    ASSEMBLYITEM *pItem = pAsm->GetItem(j);
                    pItem->fActive = FALSE;
                    pItem->fActiveNoCic = FALSE;

                    // we will assign proper hKL later.
                    pItem->hkl = NULL;

                    pAsmDst->Add(pItem);
                }
            }
        }

        //
        // we don't need a neutral lang assembly.
        //
        prgNutralAsm->Remove(0, 1);
        delete pAsm;
    }

    //
    // It is time to decide this profile should be activated by default.
    //
    for (i = 0; i < _rgAsm.Count(); i++)
    {
        int j;
        pAsm = _rgAsm.Get(i);

        CDefaultProfiles defProfiles(pAsm->_langid);
        defProfiles.Init(lphkl);

        //
        // update Enable status.
        //
        // this must be done before filtering the default profiles.
        // disabled item should not be the default proble.
        //
        for (j = 0; j < pAsm->Count(); j++)
        {
            ASSEMBLYITEM *pItem = pAsm->GetItem(j);
            if (!pItem->fEnabled)
                pItem->fEnabled = IsEnabledLanguageProfileFromReg(pItem->clsid, 
                                                                  pAsm->_langid, 
                                                                  pItem->guidProfile);
        }


        //
        // check if the default profile is enabled.
        //
        defProfiles.FilterProfiles(pAsm);

        for (j = 0; j < pAsm->Count(); j++)
        {
            ASSEMBLYITEM *pItem = pAsm->GetItem(j);
            CLSID clsid;
            GUID guidProfile;
            HKL  hkl;

            //
            // If the item is not categoried, we activate it.
            //
            if (IsEqualGUID(pItem->catid, GUID_NULL))
            {
                pItem->fActive = TRUE;
                continue;
            }

            //
            // if this item is enabled, load proper hkl.
            //
            if (pItem->fEnabled && 
                IsEqualGUID(pItem->catid, GUID_TFCAT_TIP_KEYBOARD) &&
                !pItem->hkl)
                pItem->hkl = GetProperHKL(pAsm->_langid, lphkl, NULL);

            //
            // init fActivate to false by default.
            //
            pItem->fActive = FALSE;

            if (pItem->fEnabled)
            {
                //
                // GetDefaultProfile() may return NULL in hkl if someone calls
                // ITfInputProcessorProfiles::SetDefaultLanguageProfile() method
                // from outside. We should not check hkl value then.
                //
                if (defProfiles.GetDefaultProfile(pItem->catid, 
                                                  &clsid, 
                                                  &guidProfile, 
                                                  &hkl))
                {

                    //
                    // ok this item is not default profile.
                    //
                    if (!IsEqualCLSID(pItem->clsid, clsid) ||
                        !IsEqualCLSID(pItem->guidProfile, guidProfile) ||
                        (hkl && (pItem->hkl != hkl)))
                        continue;

                    pItem->fActive = TRUE;
                }
                else if (defProfiles.Append(pItem->catid,
                                            pItem->clsid,
                                            pItem->guidProfile,
                                            pItem->hkl))
                {
                        pItem->fActive = TRUE;
                }
            }
        }

#ifdef DEBUG
        for (j = 0; j < pAsm->Count(); j++)
        {
            ASSEMBLYITEM *pItem = pAsm->GetItem(j);
            int k;
            if (!pItem->fActive)
            {
                UINT uCnt = 0;

                for (k = 0; k < pAsm->Count(); k++)
                {
                    ASSEMBLYITEM *pItemTemp = pAsm->GetItem(k);
                    if (IsEqualGUID(pItemTemp->catid, pItem->catid))
                        uCnt += (pItemTemp->fActive) ? 1 : 0;
                }
                Assert(uCnt <= 1);
            }
        }
#endif
    }

    //
    // we should create cache before attaching the original assembly active
    // status.
    // AttachOriginalAssembly() is just for the current thread.
    //
    if (IsAsmCache())
        CreateCache(NULL);

    if (rgAsmOrg.Count())
        AttachOriginalAssembly(&rgAsmOrg);

    hr = S_OK;

Exit:

    if (lphkl && (lphkl != hklList))
        cicMemFree(lphkl);

 
    if (prgNutralAsm)
    {
        Assert(!prgNutralAsm->Count())
        delete prgNutralAsm;
    }

    if (pEnumCat)
        pEnumCat->Release();

    //
    // clean up original assemblies.
    //
    for (i = 0; i < rgAsmOrg.Count(); i++)
    {
        pAsm = rgAsmOrg.Get(i);
        delete pAsm;
    }
    rgAsmOrg.Clear();

    return hr;
}

//+---------------------------------------------------------------------------
//
// GetDefaultAssembly
//
//----------------------------------------------------------------------------

CAssembly *CAssemblyList::GetDefaultAssembly()
{
    CAssembly *pAsm = NULL;
    int nAsmCnt = _rgAsm.Count();
    DWORD langid;

    if (!nAsmCnt)
        return NULL;

    langid = (LANGID)LOWORD(HandleToLong(GetSystemDefaultHKL()));
    if (!langid)
        return _rgAsm.Get(0);

    int nCurAsm = 0;

    while (nCurAsm < nAsmCnt)
    {
        CAssembly *pAsmTmp = _rgAsm.Get(nCurAsm);
        if (pAsmTmp->_langid == langid)
        {
            pAsm = pAsmTmp;
            break;
        }
        nCurAsm++;
    }

    if (!pAsm)
        pAsm = _rgAsm.Get(0);

    return pAsm;
}

//+---------------------------------------------------------------------------
//
// CreateCache
//
//----------------------------------------------------------------------------


typedef struct tag_ASSEMBLY_ROOT
{
    DWORD    dwAssemblyCount;
    // ASSEMBLYHDR[]

    static size_t   GetAlignSize() { return Align(sizeof(struct tag_ASSEMBLY_ROOT)); }
} ASSEMBLY_ROOT;

typedef struct tag_ASSEMBLYHDR 
{
    DWORD dwCnt;
    LANGID langid;
    // ASSEMBLYITEM[]

    static size_t   GetAlignSize() { return Align(sizeof(struct tag_ASSEMBLYHDR)); }
} ASSEMBLYHDR;

CCicFileMapping *g_pcfmAsmCache = NULL;

BOOL EnsureAsmCacheFileMap()
{
    if (!g_pcfmAsmCache)
        g_pcfmAsmCache = new CCicFileMapping();

    return g_pcfmAsmCache ? TRUE : FALSE;
}

BOOL UninitAsmCacheFileMap()
{
    if (g_pcfmAsmCache)
    {
        delete g_pcfmAsmCache;
        g_pcfmAsmCache = NULL;
    }
    return TRUE;
}

BOOL IsAsmCache()
{
    return g_pcfmAsmCache ? TRUE : FALSE;
}

//+---------------------------------------------------------------------------
//
// CreateCache
//
//----------------------------------------------------------------------------

BOOL CAssemblyList::CreateCache(SECURITY_ATTRIBUTES *psa)
{
    int nAsmCnt = _rgAsm.Count();
    int nCurAsm = 0;
    HANDLE hfm = NULL;
    DWORD cbSize = 0;
    BYTE *pv;
    BOOL bRet = FALSE;

    if (!g_pcfmAsmCache)
        return TRUE;

    if (!g_pcfmAsmCache->Enter())
        return FALSE;

    g_pcfmAsmCache->Close();

    g_pcfmAsmCache->Init(g_szAsmListCache, &g_mutexAsm);

    //
    // ASSEMBLY_ROOT, ASSEMBLYHDR and ASSEMBLYITEM
    //
    // When calc next data struc pointer, should not use sizeof()
    // because need adjust data alignment for 64/32bit on IA64.
    // Please use GetAlignSize() method instead of sizeof().
    //

    cbSize += ASSEMBLY_ROOT::GetAlignSize();
    while (nCurAsm < nAsmCnt)
    {
        CAssembly *pAsm = _rgAsm.Get(nCurAsm);
        cbSize += ASSEMBLYHDR::GetAlignSize();
        cbSize += (pAsm->Count() * ASSEMBLYITEM::GetAlignSize());
        nCurAsm++;
    }

    pv = (BYTE *)g_pcfmAsmCache->Create(psa, cbSize, NULL);
    if (!pv)
        goto Exit;

    ASSEMBLY_ROOT* pasm_root = (ASSEMBLY_ROOT*) pv;
    pasm_root->dwAssemblyCount = nAsmCnt;
    pv += ASSEMBLY_ROOT::GetAlignSize();

    nCurAsm = 0;
    while (nCurAsm < nAsmCnt)
    {
        ASSEMBLYHDR *pAsmHdr;
        CAssembly *pAsm = _rgAsm.Get(nCurAsm);

        pAsmHdr = (ASSEMBLYHDR *)pv;
        pAsmHdr->dwCnt = pAsm->Count();
        pAsmHdr->langid = pAsm->GetLangId();
    
        pv += ASSEMBLYHDR::GetAlignSize();

        int nItemCnt = pAsm->Count();
        int nCurItem = 0;

        while (nCurItem < nItemCnt)
        {
            ASSEMBLYITEM *pItem = pAsm->GetItem(nCurItem);

            memcpy(pv, pItem, ASSEMBLYITEM::GetAlignSize());
            pv += ASSEMBLYITEM::GetAlignSize();

            nCurItem++;
        }

        nCurAsm++;
    }

    bRet = TRUE;

Exit:

    g_pcfmAsmCache->Leave();
    return bRet;
}

//+---------------------------------------------------------------------------
//
// LoadFromCache
//
//----------------------------------------------------------------------------

BOOL CAssemblyList::LoadFromCache()
{
    HANDLE hfm = NULL;
    BYTE *pv;
    int nAsmCnt;
    int nCurAsm = 0;
    BOOL bRet = FALSE;

    CCicFileMapping cfm(g_szAsmListCache, &g_mutexAsm);

    if (!cfm.Enter())
        return FALSE;

    pv = (BYTE *)cfm.Open();
    if (!pv)
        goto Exit;

    //
    // ASSEMBLY_ROOT, ASSEMBLYHDR and ASSEMBLYITEM
    //
    // When calc next data struc pointer, should not use sizeof()
    // because need adjust data alignment for 64/32bit on IA64.
    // Please use GetAlignSize() method instead of sizeof().
    //

    cfm.Flush(ASSEMBLY_ROOT::GetAlignSize());

    ASSEMBLY_ROOT* pasm_root = (ASSEMBLY_ROOT*) pv;
    nAsmCnt = pasm_root->dwAssemblyCount;
    pv += ASSEMBLY_ROOT::GetAlignSize();

    if (!nAsmCnt)
        goto Exit;

    while (nCurAsm < nAsmCnt)
    {
        ASSEMBLYHDR *pAsmHdr;
        CAssembly *pAsm;
        int nItemCnt;
        int nCurItem = 0;

        pAsmHdr = (ASSEMBLYHDR *)pv;
        nItemCnt = pAsmHdr->dwCnt;
 
        pAsm = new CAssembly(pAsmHdr->langid);
        pv += ASSEMBLYHDR::GetAlignSize();

        while (nCurItem < nItemCnt)
        {
            ASSEMBLYITEM *pItem = (ASSEMBLYITEM *)pv;
            pItem->InitIconIndex();

            if (pAsm)
                pAsm->Add(pItem);

            pv += ASSEMBLYITEM::GetAlignSize();
            nCurItem++;
        }

        if (pAsm)
        {
            CAssembly **ppAsm;
            ppAsm = _rgAsm.Append(1);
            if (ppAsm)
            {
                *ppAsm = pAsm;
            }
            else
            {
                delete pAsm;
            }

        }

        nCurAsm++;
    }

    bRet = TRUE;
Exit:
    cfm.Leave();
    return bRet;
}

//+---------------------------------------------------------------------------
//
// InvalidCache
//
//----------------------------------------------------------------------------

BOOL CAssemblyList::InvalidCache()
{
    HANDLE hfm = NULL;
    DWORD *pv;
    BOOL bRet = FALSE;

    CCicFileMapping cfm(g_szAsmListCache, &g_mutexAsm);

    if (!cfm.Enter())
        return FALSE;

    pv = (DWORD *)cfm.Open();
    if (!pv)
        goto Exit;

    //
    // ASSEMBLY_ROOT, ASSEMBLYHDR and ASSEMBLYITEM
    //
    // When calc next data struc pointer, should not use sizeof()
    // because need adjust data alignment for 64/32bit on IA64.
    // Please use GetAlignSize() method instead of sizeof().
    //

    if (pv)
    {
        ASSEMBLY_ROOT* pasm_root = (ASSEMBLY_ROOT*) pv;
        pasm_root->dwAssemblyCount = 0;

        cfm.Flush(ASSEMBLY_ROOT::GetAlignSize());
        bRet = TRUE;
    }

Exit:
    cfm.Leave();
    return bRet;
}

//+---------------------------------------------------------------------------
//
// SetDefaultTIPInAssemblyForCache
//
//----------------------------------------------------------------------------

BOOL CAssemblyList::SetDefaultTIPInAssemblyForCache(LANGID langid, REFGUID catid, REFCLSID clsid, HKL hKL, REFGUID guidProfile)
{
    BYTE *pv;
    int nAsmCnt;
    int nCurAsm = 0;
    BOOL bRet = FALSE;

    CCicFileMapping cfm(g_szAsmListCache, &g_mutexAsm);

    if (!cfm.Enter())
        return FALSE;

    pv = (BYTE *)cfm.Open();
    if (!pv)
        goto Exit;

    //
    // ASSEMBLY_ROOT, ASSEMBLYHDR and ASSEMBLYITEM
    //
    // When calc next data struc pointer, should not use sizeof()
    // because need adjust data alignment for 64/32bit on IA64.
    // Please use GetAlignSize() method instead of sizeof().
    //

    ASSEMBLY_ROOT* pasm_root = (ASSEMBLY_ROOT*) pv;
    nAsmCnt = pasm_root->dwAssemblyCount;
    pv += ASSEMBLY_ROOT::GetAlignSize();

    if (!nAsmCnt)
        goto Exit;

    while (nCurAsm < nAsmCnt)
    {
        ASSEMBLYHDR *pAsmHdr;
        int nItemCnt;
        int nCurItem = 0;

        pAsmHdr = (ASSEMBLYHDR *)pv;
        BOOL fTargetLang = (pAsmHdr->langid == langid) ? TRUE : FALSE;

        nItemCnt = pAsmHdr->dwCnt;
        pv += ASSEMBLYHDR::GetAlignSize();

        while (nCurItem < nItemCnt)
        {
            if (fTargetLang)
            {
                ASSEMBLYITEM *pItem = (ASSEMBLYITEM *)pv;

                if (IsEqualGUID(pItem->catid, catid))
                {
                    if (IsEqualGUID(pItem->clsid, clsid) &&
                        IsEqualGUID(pItem->guidProfile, guidProfile) &&
                        (!hKL || (hKL == pItem->hkl)))
                    {
                        pItem->fActive = TRUE;
                    }
                    else
                    { 
                        pItem->fActive = FALSE;
                    }
                }
            }

            pv += ASSEMBLYITEM::GetAlignSize();
            nCurItem++;
        }

        if (fTargetLang)
            break;

        nCurAsm++;
    }

    bRet = TRUE;

Exit:
    cfm.Leave();
    return bRet;
}

#ifdef PROFILE_UPDATE_REGISTRY  // old code for tip setup.
//+---------------------------------------------------------------------------
//
// IsUpdated
//
//----------------------------------------------------------------------------

BOOL CAssemblyList::IsUpdated()
{
    CMyRegKey key;

    if (key.Open(HKEY_LOCAL_MACHINE, c_szCTFKey, KEY_READ) != S_OK)
        return FALSE;

    char szName[16];
    DWORD dwCnt = sizeof(szName);
    if (key.QueryValue(szName, c_szUpdateProfile, &dwCnt) != S_OK)
        return FALSE;

    return (szName[0] == '1') ? TRUE : FALSE;
}

//+---------------------------------------------------------------------------
//
// ClearUpdatedFlag
//
//----------------------------------------------------------------------------

BOOL CAssemblyList::ClearUpdatedFlag()
{
    CMyRegKey key;

    if (key.Open(HKEY_LOCAL_MACHINE, c_szCTFKey) != S_OK)
        return FALSE;

    if (key.DeleteValue(c_szUpdateProfile) != S_OK)
        return FALSE;

    return TRUE;
}
#endif

//+---------------------------------------------------------------------------
//
// CheckLangSupport
//
//----------------------------------------------------------------------------

BOOL CAssemblyList::CheckLangSupport(REFCLSID rclsid, LANGID langid)
{
    CMyRegKey key;
    TCHAR szKey[256];
    TCHAR szLang[256];
    int i = 0;


    StringCopyArray(szKey, c_szCTFTIPKey);
    CLSIDToStringA(rclsid, szKey + lstrlen(szKey));
    StringCatArray(szKey, "\\");
    StringCatArray(szKey, c_szLanguageProfileKey);

    if (key.Open(HKEY_LOCAL_MACHINE, szKey, KEY_READ) == S_OK)
    {
        CMyRegKey subkey;

        //
        // Check a valid language id.
        //
        StringCchPrintf(szLang, ARRAYSIZE(szLang), "0x%08x", LOWORD(langid));
        StringCopyArray(szKey, szLang);
        if (subkey.Open(key, szKey, KEY_READ) == S_OK)
            return TRUE;

        //
        // Check a primary language id.
        //
        StringCchPrintf(szLang, ARRAYSIZE(szLang), "0x%08x", LOWORD(PRIMARYLANGID(langid)));
        StringCopyArray(szKey, szLang);
        if (subkey.Open(key, szKey, KEY_READ) == S_OK)
            return TRUE;

        //
        // Check a neutral language id.
        //
        StringCchPrintf(szLang, ARRAYSIZE(szLang), "0x0000ffff");
        StringCopyArray(szKey, szLang);
        if (subkey.Open(key, szKey, KEY_READ) == S_OK)
            return TRUE;
    }

    return FALSE;
}

//+---------------------------------------------------------------------------
//
// GetTIPCategory
//
//----------------------------------------------------------------------------

BOOL CAssemblyList::GetTIPCategory(REFCLSID clsid, GUID *pcatid, IEnumGUID *pEnumCat)
{
    HRESULT hr;
    BOOL fFound = FALSE;

    *pcatid = GUID_NULL;
    hr = pEnumCat->Reset();

    if (SUCCEEDED(hr))
    {
        GUID guidCat;
        while (!fFound && (pEnumCat->Next(1, &guidCat, NULL) == S_OK))
        {
            IEnumGUID *pEnumTip;
            hr = g_EnumItemsInCategory(guidCat, &pEnumTip);
            if (SUCCEEDED(hr) && pEnumTip)
            {
                GUID guidTip;
                while (!fFound && (pEnumTip->Next(1, &guidTip, NULL) == S_OK))
                {
                    if (IsEqualGUID(clsid, guidTip))
                    {
                        *pcatid = guidCat;
                        fFound = TRUE;
                    }
                }
                pEnumTip->Release();
            }
        }
    
    }

    return fFound;
}

//+---------------------------------------------------------------------------
//
// GetDefaultTIPInAssembly
//
//----------------------------------------------------------------------------

BOOL CAssemblyList::GetDefaultTIPInAssembly(LANGID langid, REFGUID catid, CLSID *pclsid, HKL *phKL, GUID *pguidProfile)
{
    CMyRegKey key;
    DWORD dw;
    char szKey[256];
    char szName[CLSID_STRLEN + 1];


    StringCopyArray(szKey, c_szAsmKey);
    StringCatArray(szKey, "\\");
    StringCchPrintf(szKey + lstrlen(szKey), ARRAYSIZE(szKey) - lstrlen(szKey), "0x%08x", langid);
    StringCatArray(szKey, "\\");
    CLSIDToStringA(catid, szKey + lstrlen(szKey));

    *pclsid = GUID_NULL;

    if (key.Open(HKEY_CURRENT_USER, szKey, KEY_READ) != S_OK)
        return FALSE;

    if (key.QueryValueCch(szName, c_szDefault, ARRAYSIZE(szName)) != S_OK)
        return FALSE;

    StringAToCLSID(szName, pclsid);

    if (key.QueryValueCch(szName, c_szProfile, ARRAYSIZE(szName)) != S_OK)
        return FALSE;

    StringAToCLSID(szName, pguidProfile);

    if (phKL)
    {
        *phKL = NULL;

        if (key.QueryValue(dw, c_szKeyboardLayout) != S_OK)
            return FALSE;

        *phKL = (HKL)IntToPtr(dw);
    }

    return TRUE;
}

//+---------------------------------------------------------------------------
//
// SetDefaultTIPInAssemblyInternal
//
//----------------------------------------------------------------------------

BOOL CAssemblyList::SetDefaultTIPInAssemblyInternal(CAssembly *pAsm, ASSEMBLYITEM *pItem, BOOL fChangeDefault)
{
    ASSEMBLYITEM *pItemSub = NULL;
    BOOL bRet = FALSE;
    
    Assert(!pItem->hkl || (pAsm->GetLangId() == LOWORD((DWORD)(LONG_PTR)(HKL)pItem->hkl)));

    //
    // If given hKL is substituted hKL, we set the original TIP as a default.
    //
    if (IsEqualGUID(pItem->catid, GUID_TFCAT_TIP_KEYBOARD))
    {
#if 0
        //
        // Chienese platform special. We don't set the new default keyboard.
        //
        if (IsChinesePlatform())
        {
            return TRUE;
        }

        pItemSub = pAsm->GetSubstituteItem(pItem->hkl);

        if (fChangeDefault)
        {
            //
            // try to change the system default hKL.
            //
            // When TIP that has substitute HKL is selected.
            //   if the language of the system default hKL is same, 
            //   set the hKL.
            //
            // When IME is selected.
            //   if the language of the system default hKL is same, set it.
            //
            HKL hklNewDef = IsPureIMEHKL(pItem->hkl) ? pItem->hkl : (IsPureIMEHKL(pItem->hklSubstitute) ? pItem->hklSubstitute : pItem->hkl);
            if (!IsFELangId(LOWORD((WORD)(LONG_PTR)(HKL)pItem->hkl)) || hklNewDef)
            {
                HKL hklDef = GetSystemDefaultHKL();
                if ((hklDef != hklNewDef) && 
                    (LOWORD((WORD)(LONG_PTR)hklDef) == LOWORD((WORD)(LONG_PTR)hklNewDef)))
                {
                    SetSystemDefaultHKL(hklNewDef);
                }
            }
        }
#else
        HKL hklDef = GetSystemDefaultHKL();
        if (pAsm->GetLangId() == LANGIDFROMHKL(hklDef))
        {
            //
            // Now we can set the default layout directly from CPL instead of 
            // just set language(bug#353989)
            //
            return TRUE;
        }

        pItemSub = pAsm->GetSubstituteItem(pItem->hkl);
#endif

    }

    if (pItemSub)
    {
        bRet = SetDefaultTIPInAssembly(pAsm->GetLangId(), 
                                       pItemSub->catid, 
                                       pItemSub->clsid, 
                                       pItemSub->hkl, 
                                       pItemSub->guidProfile);
    }
    else
    {
        bRet = SetDefaultTIPInAssembly(pAsm->GetLangId(), 
                                       pItem->catid, 
                                       pItem->clsid, 
                                       pItem->hkl, 
                                       pItem->guidProfile);
    }


    return bRet;
}


//+---------------------------------------------------------------------------
//
// SetDefaultTIPInAssembly
//
//----------------------------------------------------------------------------

BOOL CAssemblyList::SetDefaultTIPInAssembly(LANGID langid, REFGUID catid, REFCLSID clsid, HKL hKL, REFGUID guidProfile)
{
    CMyRegKey key;
    char szKey[256];
    char szName[256];

    StringCopyArray(szKey, c_szAsmKey);
    StringCatArray(szKey, "\\");
    StringCchPrintf(szKey + lstrlen(szKey), ARRAYSIZE(szKey) - lstrlen(szKey), "0x%08x", langid);
    StringCatArray(szKey, "\\");
    CLSIDToStringA(catid, szKey + lstrlen(szKey));

    if (key.Create(HKEY_CURRENT_USER, szKey) != S_OK)
        return FALSE;

    CLSIDToStringA(clsid, szName);
    if (key.SetValue(szName, c_szDefault) != S_OK)
        return FALSE;

    CLSIDToStringA(guidProfile, szName);
    if (key.SetValue(szName, c_szProfile) != S_OK)
        return FALSE;

    if (key.SetValue((DWORD)(ULONG_PTR)hKL, c_szKeyboardLayout) != S_OK)
        return FALSE;

    return TRUE;
}

//+---------------------------------------------------------------------------
//
// IsFEDummyKL
//
//----------------------------------------------------------------------------

BOOL CAssemblyList::IsFEDummyKL(HKL hkl)
{
    char szProfile[256];
    char szDummyProfile[256];
    static HKL hkl411Dummy = 0;
    static HKL hkl404Dummy = 0;
    static HKL hkl412Dummy = 0;
    static HKL hkl804Dummy = 0;
    HKL *phklDummy = NULL;
    BOOL bRet = FALSE;

    //
    // we don't use DummyHKL under NT.
    //
    if (IsOnNT())
        return FALSE;

    switch (LANGIDFROMLCID(hkl))
    {
        case 0x411: phklDummy = &hkl411Dummy; break;
        case 0x412: phklDummy = &hkl412Dummy; break;
        case 0x404: phklDummy = &hkl404Dummy; break;
        case 0x804: phklDummy = &hkl804Dummy; break;
        default:
           return FALSE;
    }

    if (!ImmGetDescription(hkl, szProfile, ARRAYSIZE(szProfile)))
    {
        return FALSE;
    }

    CicEnterCriticalSection(g_cs);

    if (*phklDummy)
    {
        bRet = (*phklDummy == hkl) ? TRUE : FALSE;
    }
    else
    {
        StringCchPrintf(szDummyProfile, ARRAYSIZE(szDummyProfile), "hkl%04x", LOWORD((DWORD)(UINT_PTR)hkl));
        if (!lstrcmp(szDummyProfile, szProfile))
        {
            *phklDummy = hkl;
            bRet = TRUE;
        }
    }

    CicLeaveCriticalSection(g_cs);

    return bRet;
}

//+---------------------------------------------------------------------------
//
// CheckKeyboardLayoutReg
//
//
// Hack for IMM32 hard code for "kbdjp.kbd" for Japanese hKL.
// If ImmInstallIME() fails, we try it after patching registry key.
//
//----------------------------------------------------------------------------

HKL CheckKeyboardLayoutReg(LANGID langid)
{
    CMyRegKey key;
    DWORD dwIndex;
    TCHAR szValue[MAX_PATH];

    //
    // This is just for Win9x Kor,CHT,CHS
    //
    if (IsOnNT())
        return NULL;

    if ((g_uACP != 936) && (g_uACP != 949) && (g_uACP != 950))
        return NULL;

    //
    // This is for HKL0411 only.
    //
    if (langid != 0x0411)
        return NULL;

    if (key.Open(HKEY_LOCAL_MACHINE, c_szKeyboardLayoutKey, KEY_READ) != S_OK)
        return NULL;

    dwIndex = 0;
    while (key.EnumKey(dwIndex, szValue, ARRAYSIZE(szValue)) == S_OK)
    {
        CMyRegKey keyHKL;
        TCHAR szName[13];

        if (keyHKL.Open(key, szValue, KEY_ALL_ACCESS) != S_OK)
            goto Next;

        if (keyHKL.QueryValueCch(szName, c_szIMEFile, ARRAYSIZE(szName)) != S_OK)
            goto Next;

        if (!lstrcmpi(szName, "hkl0411.dll"))
        {
            //
            // patch LayoutFile to kbdus.kbd and load the keyboard layout.
            //

            if (keyHKL.SetValue(c_szKbdUSName, c_szLayoutFile) != S_OK)
                return NULL;
            
            return LoadKeyboardLayout(szValue, KLF_NOTELLSHELL);
        }
Next:
        dwIndex++;
    }

    return NULL;
}

//+---------------------------------------------------------------------------
//
// GetProperHKL
//
//----------------------------------------------------------------------------

HKL CAssemblyList::GetProperHKL(LANGID langid, HKL *lphkl, BOOL *pfLoaded)
{
    char szhkl[16];
    HKL hkl = NULL;
    BOOL fFELang = IsFELangId(langid) ? TRUE : FALSE;

    if (pfLoaded)
        *pfLoaded = FALSE;

    if (lphkl)
    {
        while (*lphkl)
        {
            if (langid == (LANGID)((DWORD)(UINT_PTR)(*lphkl) & 0x0000ffff))
            {
                //
                // Under FE language, we have a specialcase.
                //
                if (fFELang)
                {
                    //
                    // Dummy HKL should be used.
                    //
                    if (IsIMEHKL(*lphkl))
                    {
                        if (IsFEDummyKL(*lphkl))
                        {
                            hkl = *lphkl;
                            break;
                        }
                        goto Next;
                    }
    
                    //
                    // We strongly want to use a primary hKL for FE.
                    //
                    if ((HIWORD((DWORD)(UINT_PTR)*lphkl) != langid))
                        goto Next;
                }
    
                hkl = *lphkl;
                break;
            }
Next:
            lphkl++;
        }
    }

    //
    // if we could find any, return.
    //
    if (hkl)
       return hkl;

    if (!IsOnNT() && IsOnFE() && IsFELangId(langid))
    {
        char szSys[MAX_PATH];
        char szDll[MAX_PATH];
        char szLayout[16];
        
        GetSystemDirectory(szSys, sizeof(szSys));
        StringCchPrintf(szDll, ARRAYSIZE(szDll),"%s\\hkl%04x.dll", szSys, langid);
        StringCchPrintf(szLayout, ARRAYSIZE(szLayout),"hkl%04x", langid);

        hkl = ImmInstallIME(szDll, szLayout);
        if (!hkl)
        {
            hkl = CheckKeyboardLayoutReg(langid);
            if (hkl)
            {
#if 0
                RemoveFEDummyHKLFromPreloadReg(hkl);
#endif
                goto Exit;
            }

            //
            // error to load Dummy hKL. 
            // we just use a primary English language.
            //
            StringCchPrintf(szhkl, ARRAYSIZE(szhkl),"%08x", 0x0409);
            hkl = LoadKeyboardLayout(szhkl, KLF_NOTELLSHELL);
        }
#if 0
        else
        {
            //
            // check the dummy HKL from Preload section of registry and remove
            // it since ImmInstallIME automatically add hkl to Preload section.
            //
            RemoveFEDummyHKLFromPreloadReg(hkl);
        }
#endif

        goto Exit;
    }

    StringCchPrintf(szhkl, ARRAYSIZE(szhkl),"%08x", langid);
    hkl = LoadKeyboardLayout(szhkl, KLF_NOTELLSHELL);

    //
    // if we fail to create a hKL for langid, check this registry entry.
    //
    // HKLM\SYSTEM\CurrentControlSet\Control\Keyboard Layouts\[langid]
    // 
    // without the key, it fails to create a default keyboard layout.
    //
    Assert(LOWORD(hkl) == langid);

    //
    // if hkl has NULL value and the current langid is FE, then we try to add
    // the default keyboard layout in the system.
    //
    if (IsFELangId(langid) && ((LOWORD(hkl) != langid) || IsPureIMEHKL(hkl)))
    {
        char szKey[256];
        CMyRegKey key;

        if (IsOn98orNT5())
            StringCopyArray(szKey, c_szLocaleInfo);
        else
            StringCopyArray(szKey, c_szLocaleInfoNT4);

        //
        // see if the user has Administrative privileges by checking for
        // write permission to the registry key(NLS path).
        //
        if (key.Open(HKEY_LOCAL_MACHINE, szKey, KEY_WRITE) != S_OK)
            goto Exit;
        else
        {
           StringCopyArray(szKey, c_szKeyboardLayoutKey);

           StringCchPrintf(szhkl, ARRAYSIZE(szhkl), "%08x", langid);
           StringCatArray(szKey, szhkl);

           //
           // create new keyboard layout registry key and value.
           //
           if (key.Create(HKEY_LOCAL_MACHINE, szKey) == S_OK)
           {
               char szKbdName[256];

               if (IsOnNT())
                   StringCopyArray(szKbdName, c_szKbdUSNameNT);
               else
                   StringCopyArray(szKbdName, c_szKbdUSName);

               if (key.SetValue(szKbdName, c_szLayoutFile) == S_OK)
               {
                   //
                   // now try to reload keyboard layout again.
                   //
                   hkl = LoadKeyboardLayout(szhkl, KLF_NOTELLSHELL);
               }
           }
        }
    }

Exit:
    if (hkl && pfLoaded)
        *pfLoaded = TRUE;

    return hkl;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\ctf\uim\acp2anch.h ===
//
// acp2anch.h
//

#ifndef ACP2ANCH_H
#define ACP2ANCH_H

#include "private.h"
#include "strary.h"
#include "ptrary.h"

class CInputContext;
class CAnchorRef;
class CAnchor;
class CACPWrap;

extern const IID IID_PRIV_ACPWRAP;

// PSEUDO_ESCB_SERIALIZE_ACP params
typedef struct _SERIALIZE_ACP_PARAMS
{
    CACPWrap *pWrap;
    ITfProperty *pProp;
    ITfRange *pRange;
    TF_PERSISTENT_PROPERTY_HEADER_ACP *pHdr;
    IStream *pStream;
} SERIALIZE_ACP_PARAMS;

// PSEUDO_ESCB_UNSERIALIZE_ACP params
typedef struct _UNSERIALIZE_ACP_PARAMS
{
    CACPWrap *pWrap;
    ITfProperty *pProp;
    const TF_PERSISTENT_PROPERTY_HEADER_ACP *pHdr;
    IStream *pStream;
    ITfPersistentPropertyLoaderACP *pLoaderACP;
} UNSERIALIZE_ACP_PARAMS;

//////////////////////////////////////////////////////////////////////////////
//
// CLoaderACPWrap
//
//////////////////////////////////////////////////////////////////////////////

class CLoaderACPWrap : public ITfPersistentPropertyLoaderAnchor,
                       public CComObjectRootImmx
{
public:
    CLoaderACPWrap(ITfPersistentPropertyLoaderACP *loader);
    ~CLoaderACPWrap();

    BEGIN_COM_MAP_IMMX(CLoaderACPWrap)
        COM_INTERFACE_ENTRY(ITfPersistentPropertyLoaderAnchor)
    END_COM_MAP_IMMX()

    IMMX_OBJECT_IUNKNOWN_FOR_ATL()

    // ITfPersistentPropertyLoaderACP
    STDMETHODIMP LoadProperty(const TF_PERSISTENT_PROPERTY_HEADER_ANCHOR *pHdr, IStream **ppStream);

private:
    ITfPersistentPropertyLoaderACP *_loader;
    DBG_ID_DECLARE;
};

//////////////////////////////////////////////////////////////////////////////
//
// CACPWrap
//
//////////////////////////////////////////////////////////////////////////////

class CACPWrap : public ITextStoreAnchor,
                 public ITextStoreACPSink,
                 public ITextStoreACPServices,
                 public ITfMouseTrackerACP,
                 public IServiceProvider
{
public:
    CACPWrap(ITextStoreACP *ptsi);
    ~CACPWrap();

    //
    // IUnknown methods
    //
    STDMETHODIMP QueryInterface(REFIID riid, void **ppvObj);
    STDMETHODIMP_(ULONG) AddRef(void);
    STDMETHODIMP_(ULONG) Release(void);

    // ITextStoreACPSink
    STDMETHODIMP OnTextChange(DWORD dwFlags, const TS_TEXTCHANGE *pChange);
    STDMETHODIMP OnSelectionChange();
    STDMETHODIMP OnLayoutChange(TsLayoutCode lcode, TsViewCookie vcView);
    STDMETHODIMP OnStatusChange(DWORD dwFlags);
    STDMETHODIMP OnAttrsChange(LONG acpStart, LONG acpEnd, ULONG cAttrs, const TS_ATTRID *paAttrs);
    STDMETHODIMP OnLockGranted(DWORD dwLockFlags);
    STDMETHODIMP OnStartEditTransaction();
    STDMETHODIMP OnEndEditTransaction();

    // ITextStoreACPServices
    STDMETHODIMP Serialize(ITfProperty *pProp, ITfRange *pRange, TF_PERSISTENT_PROPERTY_HEADER_ACP *pHdr, IStream *pStream);
    STDMETHODIMP ForceLoadProperty(ITfProperty *pProp);
    STDMETHODIMP Unserialize(ITfProperty *pProp, const TF_PERSISTENT_PROPERTY_HEADER_ACP *pHdr, IStream *pStream, ITfPersistentPropertyLoaderACP *pLoader);
    STDMETHODIMP CreateRange(LONG acpStart, LONG acpEnd, ITfRangeACP **ppRange);

    // ITextStoreAnchor
    STDMETHODIMP AdviseSink(REFIID riid, IUnknown *punk, DWORD dwMask);
    STDMETHODIMP UnadviseSink(IUnknown *punk);
    STDMETHODIMP RequestLock(DWORD dwLockFlags, HRESULT *phrSession);
    STDMETHODIMP GetStatus(TS_STATUS *pdcs);
    STDMETHODIMP QueryInsert(IAnchor *paTestStart, IAnchor *paTestEnd, ULONG cch, IAnchor **ppaResultStart, IAnchor **ppaResultEnd);
    STDMETHODIMP GetSelection(ULONG ulIndex, ULONG ulCount, TS_SELECTION_ANCHOR *pSelection, ULONG *pcFetched);
    STDMETHODIMP SetSelection(ULONG ulCount, const TS_SELECTION_ANCHOR *pSelection);
    STDMETHODIMP GetText(DWORD dwFlags, IAnchor *paStart, IAnchor *paEnd, WCHAR *pchText, ULONG cchReq, ULONG *pcch, BOOL fUpdateAnchor);
    STDMETHODIMP SetText(DWORD dwFlags, IAnchor *paStart, IAnchor *paEnd, const WCHAR *pchText, ULONG cch);
    STDMETHODIMP GetFormattedText(IAnchor *paStart, IAnchor *paEnd, IDataObject **ppDataObject);
    STDMETHODIMP GetEmbedded(DWORD dwFlags, IAnchor *paPos, REFGUID rguidService, REFIID riid, IUnknown **ppunk);
    STDMETHODIMP QueryInsertEmbedded(const GUID *pguidService, const FORMATETC *pFormatEtc, BOOL *pfInsertable);
    STDMETHODIMP InsertEmbedded(DWORD dwFlags, IAnchor *paStart, IAnchor *paEnd, IDataObject *pDataObject);
    STDMETHODIMP RequestSupportedAttrs (DWORD dwFlags, ULONG cFilterAttrs, const TS_ATTRID *paFilterAttrs);
    STDMETHODIMP RequestAttrsAtPosition(IAnchor *paPos, ULONG cFilterAttrs, const TS_ATTRID *paFilterAttrs, DWORD dwFlags);
    STDMETHODIMP RequestAttrsTransitioningAtPosition(IAnchor *paPos, ULONG cFilterAttrs, const TS_ATTRID *paFilterAttrs, DWORD dwFlags);
    STDMETHODIMP FindNextAttrTransition(IAnchor *paStart, IAnchor *paHalt, ULONG cFilterAttrs, const TS_ATTRID *paFilterAttrs, DWORD dwFlags, BOOL *pfFound, LONG *plFoundOffset);
    STDMETHODIMP RetrieveRequestedAttrs(ULONG ulCount, TS_ATTRVAL *paAttrVals, ULONG *pcFetched);
    STDMETHODIMP GetStart(IAnchor **ppaStart);
    STDMETHODIMP GetEnd(IAnchor **ppaEnd);
    STDMETHODIMP GetActiveView(TsViewCookie *pvcView);
    STDMETHODIMP GetAnchorFromPoint(TsViewCookie vcView, const POINT *pt, DWORD dwFlags, IAnchor **ppaSite);
    STDMETHODIMP GetTextExt(TsViewCookie vcView, IAnchor *paStart, IAnchor *paEnd, RECT *prc, BOOL *pfClipped);
    STDMETHODIMP GetScreenExt(TsViewCookie vcView, RECT *prc);
    STDMETHODIMP GetWnd(TsViewCookie vcView, HWND *phwnd);
    STDMETHODIMP InsertTextAtSelection(DWORD dwFlags, const WCHAR *pchText, ULONG cch, IAnchor **ppaStart, IAnchor **ppaEnd);
    STDMETHODIMP InsertEmbeddedAtSelection(DWORD dwFlags, IDataObject *pDataObject, IAnchor **ppaStart, IAnchor **ppaEnd);

    // ITfMouseTrackerACP
    STDMETHODIMP AdviseMouseSink(ITfRangeACP *range, ITfMouseSink *pSink, DWORD *pdwCookie);
    STDMETHODIMP UnadviseMouseSink(DWORD dwCookie);

    // IServiceProvider
    STDMETHODIMP QueryService(REFGUID guidService, REFIID riid, void **ppv);

    HRESULT _Serialize(ITfProperty *pProp, ITfRange *pRange, TF_PERSISTENT_PROPERTY_HEADER_ACP *pHdr, IStream *pStream);
    HRESULT _Unserialize(ITfProperty *pProp, const TF_PERSISTENT_PROPERTY_HEADER_ACP *pHdr, IStream *pStream, ITfPersistentPropertyLoaderACP *pLoader);

    void _OnLockReleased();

    CAnchorRef *_CreateAnchorACP(LONG acp, TsGravity gravity);
    CAnchorRef *_CreateAnchorAnchor(CAnchor *pa, TsGravity gravity);

    ITextStoreACP *_GetTSI() { return _ptsi; }

    void _Dbg_AssertNoAppLock()
    {
#ifdef DEBUG
        Assert(!_Dbg_fAppHasLock); // if we get here, it means the app has called OnTextChange
                                   // and someone (prob. the app) is trying to use a range object before calling
                                   // OnLockGranted (cicero will have asked for a lock inside OnTextChange).
#endif
    }

    HRESULT _ACPHdrToAnchor(const TF_PERSISTENT_PROPERTY_HEADER_ACP *pHdr, TF_PERSISTENT_PROPERTY_HEADER_ANCHOR *phanch);

    void _OnAnchorRelease()
    {
        if (_cRef == 0 && _GetAnchorRef() == 0)
        {
            delete this;
        }
    }

    BOOL _IsDisconnected() { return (_ptsi == NULL); }

    CInputContext *_GetContext()
    {
        return _pic;
    }

    void _NormalizeAnchor(CAnchor *pa);

    BOOL _InOnTextChange()
    {
        return _fInOnTextChange;
    }

private:
    friend CLoaderACPWrap;
    friend CAnchor;
    friend CAnchorRef;

    void _PostInsertUpdate(LONG acpStart, LONG acpEnd, ULONG cch, const TS_TEXTCHANGE *ptsTextChange);

    static BOOL _AnchorHdrToACP(const TF_PERSISTENT_PROPERTY_HEADER_ANCHOR *phanch, TF_PERSISTENT_PROPERTY_HEADER_ACP *phacp);

    LONG _GetAnchorRef() { return _GetCount(); }

    CAnchor *_FindWithinPendingRange(LONG acp)
    {
        int iIndex;

        Assert(_lPendingDelta != 0);
        Assert(_lPendingDeltaIndex < _rgAnchors.Count());
        return _FindInnerLoop(acp, _lPendingDeltaIndex+1, _rgAnchors.Count(), &iIndex);
    }
    HRESULT _Insert(CAnchorRef *par, LONG ich);
    HRESULT _Insert(CAnchorRef *par, CAnchor *pa);
    void _Remove(CAnchorRef *par);
    void _Update(const TS_TEXTCHANGE *pdctc);
    void _Renormalize(int ichStart, int ichEnd);
    LONG _GetCount() { return _rgAnchors.Count(); }
    void _DragAnchors(LONG acpFrom, LONG acpTo);
    LONG _GetPendingDelta()
    {
        return _lPendingDelta;
    }
    LONG _GetPendingDeltaIndex()
    {
        return _lPendingDeltaIndex;
    }
    CAnchor *_GetPendingDeltaAnchor()
    {
        return _rgAnchors.Get(_lPendingDeltaIndex);
    }
    BOOL _IsPendingDelta()
    {
        return _lPendingDelta != 0 && _lPendingDeltaIndex < _rgAnchors.Count();
    }
    CAnchor *_Find(int ich, int *piOut = NULL);
    CAnchor *_FindInnerLoop(LONG acp, int iMin, int iMax, int *piIndex);
    int _Update(CAnchor *pa, int ichNew, int iOrg, CAnchor *paInto, int iInto);
    void _Merge(CAnchor *paInto, CAnchor *paFrom);
    void _Delete(CAnchor *pa);
    void _AdjustIchs(int iFirst, int dSize);
    void _TrackDelHistory(int iEndOrg, BOOL fExactEndOrgMatch, int iEndNew, BOOL fExactEndNewMatch);
#ifdef DEBUG
    void _Dbg_AssertAnchors();
#else
    void _Dbg_AssertAnchors() {}
#endif

    BOOL _fInOnTextChange : 1; // TRUE if we're inside OnTextChange

    CPtrArray<CAnchor> _rgAnchors;
    LONG _lPendingDeltaIndex;
    LONG _lPendingDelta;

    ITextStoreACP *_ptsi;
    ITextStoreAnchorSink *_ptss;
    CInputContext *_pic;
    LONG _cRef;

#ifdef DEBUG
    BOOL _Dbg_fAppHasLock;
#endif

    DBG_ID_DECLARE;
};

#endif // ACP2ANCH_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\ctf\uim\anchoref.cpp ===
//
// anchoref.cpp
//
// CAnchorRef
//

#include "private.h"
#include "anchoref.h"
#include "anchor.h"
#include "acp2anch.h"
#include "globals.h"
#include "normal.h"
#include "memcache.h"
#include "ic.h"
#include "txtcache.h"

/* 9135f8f0-38e6-11d3-a745-0050040ab407 */
const IID IID_PRIV_CANCHORREF = { 0x9135f8f0, 0x38e6, 0x11d3, {0xa7, 0x45, 0x00, 0x50, 0x04, 0x0a, 0xb4, 0x07} };

DBG_ID_INSTANCE(CAnchorRef);

MEMCACHE *CAnchorRef::_s_pMemCache = NULL;

//+---------------------------------------------------------------------------
//
// _InitClass
//
//----------------------------------------------------------------------------

/* static */
void CAnchorRef::_InitClass()
{
    _s_pMemCache = MemCache_New(128);
}

//+---------------------------------------------------------------------------
//
// _UninitClass
//
//----------------------------------------------------------------------------

/* static */
void CAnchorRef::_UninitClass()
{
    if (_s_pMemCache == NULL)
        return;

    MemCache_Delete(_s_pMemCache);
    _s_pMemCache = NULL;
}

//+---------------------------------------------------------------------------
//
// IUnknown
//
//----------------------------------------------------------------------------

STDAPI CAnchorRef::QueryInterface(REFIID riid, void **ppvObj)
{
    if (&riid == &IID_PRIV_CANCHORREF ||
        IsEqualIID(riid, IID_PRIV_CANCHORREF))
    {
        *ppvObj = SAFECAST(this, CAnchorRef *);
        return S_OK; // No AddRef for IID_PRIV_CANCHORREF!  this is a private IID....
    }

    *ppvObj = NULL;

    if (IsEqualIID(riid, IID_IUnknown) ||
        IsEqualIID(riid, IID_IAnchor))
    {
        *ppvObj = SAFECAST(this, IAnchor *);
    }

    if (*ppvObj)
    {
        AddRef();
        return S_OK;
    }

    return E_NOINTERFACE;
}

STDAPI_(ULONG) CAnchorRef::AddRef()
{
    return ++_cRef;
}

STDAPI_(ULONG) CAnchorRef::Release()
{
    _cRef--;
    Assert(_cRef >= 0);

    if (_cRef == 0)
    {
        delete this;
        return 0;
    }

    return _cRef;
}

//+---------------------------------------------------------------------------
//
// SetGravity
//
//----------------------------------------------------------------------------

STDAPI CAnchorRef::SetGravity(TsGravity gravity)
{
    _fForwardGravity = (gravity == TS_GR_FORWARD ? 1 : 0);
    return S_OK;
}

//+---------------------------------------------------------------------------
//
// GetGravity
//
//----------------------------------------------------------------------------

STDAPI CAnchorRef::GetGravity(TsGravity *pgravity)
{
    if (pgravity == NULL)
        return E_INVALIDARG;

    *pgravity = _fForwardGravity ? TS_GR_FORWARD : TS_GR_BACKWARD;
    return S_OK;
}

//+---------------------------------------------------------------------------
//
// IsEqual
//
//----------------------------------------------------------------------------

STDAPI CAnchorRef::IsEqual(IAnchor *paWith, BOOL *pfEqual)
{
    LONG lResult;
    HRESULT hr;
    
    if (pfEqual == NULL)
        return E_INVALIDARG;

    *pfEqual = FALSE;

    // in our implementation, Compare is no less efficient, so just use that
    if ((hr = Compare(paWith, &lResult)) == S_OK)
    {
        *pfEqual = (lResult == 0);
    }

    return hr;    
}

//+---------------------------------------------------------------------------
//
// Compare
//
//----------------------------------------------------------------------------

STDAPI CAnchorRef::Compare(IAnchor *paWith, LONG *plResult)
{
    CAnchorRef *parWith;
    LONG acpThis;
    LONG acpWith;
    CACPWrap *paw;

    if (plResult == NULL)
        return E_INVALIDARG;

    //_paw->_Dbg_AssertNoAppLock(); // can't assert this because we use it legitimately while updating the span set

    *plResult = 0;

    if ((parWith = GetCAnchorRef_NA(paWith)) == NULL)
        return E_FAIL;

    // quick test for equality
    // we still need to check for equality again below because of normalization
    if (_pa == parWith->_pa)
    {
        Assert(*plResult == 0);
        return S_OK;
    }

    acpThis = _pa->GetIch();
    acpWith = parWith->_pa->GetIch();

    paw = _pa->_GetWrap();

    // we can't do a compare if either anchor is un-normalized
    // except when the app holds the lock (in which case we're being called from
    // a span set update which does not need to be normalized)
    if (!paw->_InOnTextChange())
    {
        // we only actually have to normalize the anchor to the left
        if (acpThis < acpWith)
        {
            if (!_pa->IsNormalized())
            {
                paw->_NormalizeAnchor(_pa);
                acpThis = _pa->GetIch();
                acpWith = parWith->_pa->GetIch();
            }
        }
        else if (acpThis > acpWith)
        {
            if (!parWith->_pa->IsNormalized())
            {
                paw->_NormalizeAnchor(parWith->_pa);
                acpThis = _pa->GetIch();
                acpWith = parWith->_pa->GetIch();
            }
        }
    }

    if (acpThis < acpWith)
    {
        *plResult = -1;
    }
    else if (acpThis > acpWith)
    {
        *plResult = +1;
    }
    else
    {
        Assert(*plResult == 0);
    }

    return S_OK;
}

//+---------------------------------------------------------------------------
//
// Shift
//
//----------------------------------------------------------------------------

STDAPI CAnchorRef::Shift(DWORD dwFlags, LONG cchReq, LONG *pcch, IAnchor *paHaltAnchor)
{
    CAnchorRef *parHaltAnchor;
    CACPWrap *paw;
    LONG acpHalt;
    LONG acpThis;
    LONG dacp;
    HRESULT hr;

    Perf_IncCounter(PERF_ANCHOR_SHIFT);

    if (dwFlags & ~(TS_SHIFT_COUNT_HIDDEN | TS_SHIFT_HALT_HIDDEN | TS_SHIFT_HALT_VISIBLE | TS_SHIFT_COUNT_ONLY))
        return E_INVALIDARG;

    if ((dwFlags & (TS_SHIFT_HALT_HIDDEN | TS_SHIFT_HALT_VISIBLE)) == (TS_SHIFT_HALT_HIDDEN | TS_SHIFT_HALT_VISIBLE))
        return E_INVALIDARG; // illegal to set both flags

    if (dwFlags & (TS_SHIFT_COUNT_HIDDEN | TS_SHIFT_HALT_HIDDEN | TS_SHIFT_HALT_VISIBLE))
        return E_NOTIMPL; // Issue: should support these

    if (pcch == NULL)
        return E_INVALIDARG;

    paw = _pa->_GetWrap();

    paw->_Dbg_AssertNoAppLock();

    if (paw->_IsDisconnected())
    {
        *pcch = 0;
        return TF_E_DISCONNECTED;
    }

    *pcch = cchReq; // assume success

    if (cchReq == 0)
        return S_OK;

    acpThis = _pa->GetIch();
    hr = E_FAIL;

    if (paHaltAnchor != NULL)
    {
        if ((parHaltAnchor = GetCAnchorRef_NA(paHaltAnchor)) == NULL)
            goto Exit;
        acpHalt = parHaltAnchor->_pa->GetIch();

        // return now if the halt is our base acp
        // (we treat acpHalt == acpThis as a nop below, anything
        // more ticky has problems with over/underflow)
        if (acpHalt == acpThis)
        {
            *pcch = 0;
            return S_OK;
        }
    }
    else
    {
        // nop the acpHalt
        acpHalt = acpThis;
    }

    // we can initially bound cchReq by pretending acpHalt
    // is plain text, an upper bound
    if (cchReq < 0 && acpHalt < acpThis)
    {
        cchReq = max(cchReq, acpHalt - acpThis);
    }
    else if (cchReq > 0 && acpHalt > acpThis)
    {
        cchReq = min(cchReq, acpHalt - acpThis);
    }

    // do the expensive work
    if (FAILED(hr = AppTextOffset(paw->_GetTSI(), acpThis, cchReq, &dacp, ATO_SKIP_HIDDEN)))
        goto Exit;

    // now we can clip percisely
    if (cchReq < 0 && acpHalt < acpThis)
    {
        dacp = max(dacp, acpHalt - acpThis);
        hr = S_FALSE;
    }
    else if (cchReq > 0 && acpHalt > acpThis)
    {
        dacp = min(dacp, acpHalt - acpThis);
        hr = S_FALSE;
    }

    if (hr == S_FALSE)
    {
        // nb: if we remembered whether or not we actually truncated cchReq above
        // before and/or after the AppTextOffset call, we could avoid always calling
        // PlainTextOffset when paHaltAnchor != NULL

        // request got clipped, need to find the plain count
        PlainTextOffset(paw->_GetTSI(), acpThis, dacp, pcch); // perf: we could get this info by modifying AppTextOffset
    }

    if (!(dwFlags & TS_SHIFT_COUNT_ONLY))
    {
        hr = _SetACP(acpThis + dacp) ? S_OK : E_FAIL;
    }
    else
    {
        // caller doesn't want the anchor updated, just wants a count
        hr = S_OK;
    }

Exit:
    if (FAILED(hr))
    {
        *pcch = 0;
    }

    // return value should never exceed what the caller requested!
    Assert((cchReq >= 0 && *pcch <= cchReq) || (cchReq < 0 && *pcch >= cchReq));

    return hr;
}

//+---------------------------------------------------------------------------
//
// ShiftTo
//
//----------------------------------------------------------------------------

STDAPI CAnchorRef::ShiftTo(IAnchor *paSite)
{
    CAnchorRef *parSite;
    LONG acpSite;

    if (paSite == NULL)
        return E_INVALIDARG;

    //_paw->_Dbg_AssertNoAppLock(); // can't assert this because we use it legitimately while updating the span set

    if ((parSite = GetCAnchorRef_NA(paSite)) == NULL)
        return E_FAIL;

    acpSite = parSite->_pa->GetIch();
    
    return _SetACP(acpSite) ? S_OK : E_FAIL;
}

//+---------------------------------------------------------------------------
//
// ShiftRegion
//
//----------------------------------------------------------------------------

STDAPI CAnchorRef::ShiftRegion(DWORD dwFlags, TsShiftDir dir, BOOL *pfNoRegion)
{
    LONG acp;
    ULONG cch;
    LONG i;
    ULONG ulRunInfoOut;
    LONG acpNext;
    ITextStoreACP *ptsi;
    CACPWrap *paw;
    WCHAR ch;
    DWORD dwATO;

    Perf_IncCounter(PERF_SHIFTREG_COUNTER);

    if (pfNoRegion == NULL)
        return E_INVALIDARG;

    *pfNoRegion = TRUE;

    if (dwFlags & ~(TS_SHIFT_COUNT_HIDDEN | TS_SHIFT_COUNT_ONLY))
        return E_INVALIDARG;

    paw = _pa->_GetWrap();

    if (paw->_IsDisconnected())
        return TF_E_DISCONNECTED;

    acp = _GetACP();
    ptsi = paw->_GetTSI();

    if (dir == TS_SD_BACKWARD)
    {
        // scan backwards for the preceding char
        dwATO = ATO_IGNORE_REGIONS | ((dwFlags & TS_SHIFT_COUNT_HIDDEN) ? 0 : ATO_SKIP_HIDDEN);
        if (FAILED(AppTextOffset(ptsi, acp, -1, &i, dwATO)))
            return E_FAIL;

        if (i == 0) // bod
            return S_OK;

        acp += i;
    }
    else
    {
        // normalize this guy so we can just test the next char
        if (!_pa->IsNormalized())
        {
            paw->_NormalizeAnchor(_pa);
            acp = _GetACP();
        }
        // skip past any hidden text
        if (!(dwFlags & TS_SHIFT_COUNT_HIDDEN))
        {
            acp = Normalize(paw->_GetTSI(), acp, NORM_SKIP_HIDDEN);
        }
    }

    // insure we're next to a TS_CHAR_REGION
    Perf_IncCounter(PERF_ANCHOR_REGION_GETTEXT);
    if (CProcessTextCache::GetText(ptsi, acp, -1, &ch, 1, &cch, NULL, 0, &ulRunInfoOut, &acpNext) != S_OK)
        return E_FAIL;

    if (cch == 0) // eod
        return S_OK;

    if (ch != TS_CHAR_REGION)
        return S_OK; // no region, so just report that in pfNoRegion

    if (!(dwFlags & TS_SHIFT_COUNT_ONLY)) // does caller want us to move the anchor?
    {
        if (dir == TS_SD_FORWARD)
        {
            // skip over the TS_CHAR_REGION
            acp += 1;
        }

        if (!_SetACP(acp))
            return E_FAIL;
    }

    *pfNoRegion = FALSE;
    return S_OK;
}

//+---------------------------------------------------------------------------
//
// SetChangeHistoryMask
//
//----------------------------------------------------------------------------

STDAPI CAnchorRef::SetChangeHistoryMask(DWORD dwMask)
{
    Assert(0); // Issue: todo
    return E_NOTIMPL;
}

//+---------------------------------------------------------------------------
//
// GetChangeHistory
//
//----------------------------------------------------------------------------

STDAPI CAnchorRef::GetChangeHistory(DWORD *pdwHistory)
{
    if (pdwHistory == NULL)
        return E_INVALIDARG;

    *pdwHistory = _dwHistory;

    return S_OK;
}

//+---------------------------------------------------------------------------
//
// ClearChangeHistory
//
//----------------------------------------------------------------------------

STDAPI CAnchorRef::ClearChangeHistory()
{
    _dwHistory = 0;

    return S_OK;
}

//+---------------------------------------------------------------------------
//
// Clone
//
//----------------------------------------------------------------------------

STDAPI CAnchorRef::Clone(IAnchor **ppaClone)
{
    if (ppaClone == NULL)
        return E_INVALIDARG;

    *ppaClone = _pa->_GetWrap()->_CreateAnchorAnchor(_pa, _fForwardGravity ? TS_GR_FORWARD : TS_GR_BACKWARD);

    return (*ppaClone != NULL) ? S_OK : E_FAIL;
}

//+---------------------------------------------------------------------------
//
// _SetACP
//
//----------------------------------------------------------------------------

BOOL CAnchorRef::_SetACP(LONG acp)
{
    CACPWrap *paw;

    if (_pa->GetIch() == acp)
        return TRUE; // already positioned here

    paw = _pa->_GetWrap();

    paw->_Remove(this);
    if (FAILED(paw->_Insert(this, acp)))
    {
        // Issue:
        // we need to add a method the CACPWrap
        // that swaps a CAnchorRef, preserving the old
        // value if a new one cannot be inserted (prob.
        // because memory is low).
        Assert(0); // we have no code to handle this!
        return FALSE;
    }

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\ctf\uim\attr.cpp ===
//
// attr.cpp
//

#include "private.h"
#include "attr.h"
#include "ic.h"
#include "saa.h"
#include "erfa.h"
#include "epval.h"
#include "immxutil.h"
#include "range.h"

//+---------------------------------------------------------------------------
//
// CalcAppPropertyTrackerAnchors
//
// NB: an empty range will result in a single anchor at the range pos.
//----------------------------------------------------------------------------

CSharedAnchorArray *CalcAppPropertyTrackerAnchors(ITextStoreAnchor *ptsi, ITfRange *rangeSuper, ULONG cGUIDs, const GUID *prgGUIDs)
{
    CSharedAnchorArray *prgAnchors;
    CRange *rangeScan;
    IAnchor *paPrevTrans;
    IAnchor **ppa;
    BOOL fRet;
    BOOL fFound;
    LONG lFoundOffset;
    HRESULT hr;

    if ((rangeScan = GetCRange_NA(rangeSuper)) == NULL)
        return NULL;

    if ((prgAnchors = new CSharedAnchorArray) == NULL)
        return NULL;

    fRet = FALSE;

    if (rangeScan->_GetStart()->Clone(&paPrevTrans) != S_OK)
    {
        paPrevTrans = NULL;
        goto Exit;
    }

    // now scan down the length of the range, building up a list
    while (TRUE)
    {
        // we've just found the end point of this run
        if (!prgAnchors->Append(1))
            goto Exit;
        ppa = prgAnchors->GetPtr(prgAnchors->Count()-1);
        if (paPrevTrans->Clone(ppa) != S_OK)
            goto Exit;

        if (cGUIDs == 0) // no transition for zero GUIDs, just do the end anchor Clone outside the loop
            break;

        hr = ptsi->FindNextAttrTransition(paPrevTrans, rangeScan->_GetEnd(), cGUIDs, prgGUIDs, TS_ATTR_FIND_UPDATESTART, &fFound, &lFoundOffset);

        if (hr != S_OK)
            goto Exit;

        // no more property spans?
        if (!fFound)
            break;

        // stop when we hit the end of the range
        if (IsEqualAnchor(paPrevTrans, rangeScan->_GetEnd()))
            break;
    }

    if (!IsEqualAnchor(rangeScan->_GetStart(), rangeScan->_GetEnd()))
    {
        // add a final anchor at the end of the range
        if (!prgAnchors->Append(1))
            goto Exit;
        ppa = prgAnchors->GetPtr(prgAnchors->Count()-1);
        if (rangeScan->_GetEnd()->Clone(ppa) != S_OK)
            goto Exit;
    }
    
    // shrink the array down to size, it won't be modified again
    prgAnchors->CompactSize();

    fRet = TRUE;

Exit:
    if (!fRet)
    {
        prgAnchors->_Release();
        prgAnchors = NULL;
    }
    else
    {
        Assert(prgAnchors != NULL);
    }
    SafeRelease(paPrevTrans);
    return prgAnchors;
}

//+---------------------------------------------------------------------------
//
// GetDefaultValue
//
//----------------------------------------------------------------------------

HRESULT GetDefaultValue(ITextStoreAnchor *ptsi, REFGUID guidType, VARIANT *pvarValue)
{
    TS_ATTRVAL av;
    ULONG cFetched;
    HRESULT hr;

    Assert(pvarValue != NULL);

    // VT_EMPTY for unsupported attrib/error
    QuickVariantInit(pvarValue);

    hr = ptsi->RequestSupportedAttrs(TS_ATTR_FIND_WANT_VALUE, 1, &guidType);
    if (hr != S_OK)
    {
        return (hr == E_NOTIMPL) ? E_NOTIMPL : E_FAIL;
    }

    if (ptsi->RetrieveRequestedAttrs(1, &av, &cFetched) == S_OK &&
           cFetched == 1)
    {
        Assert(IsEqualGUID(av.idAttr, guidType));
        *pvarValue = av.varValue; // caller owns it now
    }
    else
    {
        // the aimm layer will sometimes stop supporting an attribute
        // it has two sink callback points, the one for reconversion doesn't
        // handle attributes.
        // we'll just return VT_EMPTY
        Assert(pvarValue->vt == VT_EMPTY);
    }

    return S_OK;
}

//+---------------------------------------------------------------------------
//
// FillAppValueArray
//
//----------------------------------------------------------------------------

HRESULT FillAppValueArray(ITextStoreAnchor *ptsi, CRange *range, TF_PROPERTYVAL *rgPropVal, ULONG cGUIDs, const GUID *prgGUIDs)
{
    ULONG i;
    ULONG j;
    ULONG iNext;
    ULONG cMissing;
    TS_ATTRVAL *prgVals;
    ULONG cFetched;
    HRESULT hr;

    if (cGUIDs == 0)
        return S_OK;

    if ((prgVals = (TS_ATTRVAL *)cicMemAlloc(cGUIDs*sizeof(TS_ATTRVAL))) == NULL)
        return E_OUTOFMEMORY;

    hr = ptsi->RequestAttrsAtPosition(range->_GetStart(), cGUIDs, prgGUIDs, 0);
    if (hr != S_OK)
        goto Exit;

    hr = ptsi->RetrieveRequestedAttrs(cGUIDs, prgVals, &cFetched);
    if (hr != S_OK)
        goto Exit;

    // copy over the values in prgVals
    for (i=0; i<cFetched; i++)
    {
        rgPropVal[i].guidId = prgVals[i].idAttr;
        rgPropVal[i].varValue = prgVals[i].varValue; // we take ownership, no VariantCopy
    }

    // figure out what was missing
    cMissing = cGUIDs - cFetched;

    if (cMissing == 0)
        goto Exit;

    iNext = cFetched; // index of first missing guid

    // perf: this is O(n^2), we could do a sort or something...
    for (i=0; i<cGUIDs; i++)
    {
        for (j=0; j<cFetched; j++)
        {
            if (IsEqualGUID(prgVals[j].idAttr, prgGUIDs[i]))
                break;
        }

        if (j < cFetched)
            continue;

        // found a missing GUID, need to get the default value
        hr = GetDefaultValue(ptsi, prgGUIDs[i], &rgPropVal[iNext].varValue);
        if (hr != S_OK)
        {
            Assert(0); // why did we fail?
            QuickVariantInit(&rgPropVal[iNext].varValue);
        }

        rgPropVal[iNext].guidId = prgGUIDs[i];

        if (--cMissing == 0) // anything left to look for?
            break;
        iNext++;
    }

Exit:
    cicMemFree(prgVals);
    return hr;
}

//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////
//
// CEnumAppPropRanges
//
//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////

class CEnumAppPropRanges : public CEnumRangesFromAnchorsBase
{
public:
    CEnumAppPropRanges()
    { 
        Dbg_MemSetThisNameIDCounter(TEXT("CEnumAppPropRanges"), PERF_ENUMAPPPROP_COUNTER);
    }

    BOOL _Init(CInputContext *pic, ITfRange *rangeSuper, REFGUID rguid);

private:
    DBG_ID_DECLARE;
};

DBG_ID_INSTANCE(CEnumAppPropRanges);

//+---------------------------------------------------------------------------
//
// _Init
//
// Scan the superset range and build up a list of covered ranges.
//
//----------------------------------------------------------------------------

BOOL CEnumAppPropRanges::_Init(CInputContext *pic, ITfRange *rangeSuper, REFGUID rguid)
{
    Assert(_iCur == 0);
    Assert(_pic == NULL);
    Assert(_prgAnchors == NULL);

    _prgAnchors = CalcAppPropertyTrackerAnchors(pic->_GetTSI(), rangeSuper, 1, &rguid);

    if (_prgAnchors == NULL)
        return FALSE;

    _pic = pic;
    _pic->AddRef();

    return TRUE;
}

//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////
//
// CAppProperty
//
//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////

class CAppProperty : public ITfReadOnlyProperty,
                     public CComObjectRootImmx
{
public:
    CAppProperty(CInputContext *pic, REFGUID guid);
    ~CAppProperty();

    BEGIN_COM_MAP_IMMX(CAppProperty)
        COM_INTERFACE_ENTRY(ITfReadOnlyProperty)
    END_COM_MAP_IMMX()

    IMMX_OBJECT_IUNKNOWN_FOR_ATL()

    // ITfReadOnlyProperty
    STDMETHODIMP GetType(GUID *pguid);
    STDMETHODIMP EnumRanges(TfEditCookie ec, IEnumTfRanges **ppEnum, ITfRange *pTargetRange);
    STDMETHODIMP GetValue(TfEditCookie ec, ITfRange *pRange, VARIANT *pvarValue);
    STDMETHODIMP GetContext(ITfContext **ppContext);

private:
    BOOL _IsValidEditCookie(TfEditCookie ec, DWORD dwFlags)
    {
        return _pic->_IsValidEditCookie(ec, dwFlags);
    }

    CInputContext *_pic;
    GUID _guid;
    DBG_ID_DECLARE;
};

DBG_ID_INSTANCE(CAppProperty);

//+---------------------------------------------------------------------------
//
// ctor
//
//----------------------------------------------------------------------------

CAppProperty::CAppProperty(CInputContext *pic, REFGUID guid)
{
    Dbg_MemSetThisNameIDCounter(TEXT("CAppProperty"), PERF_APPPROP_COUNTER);

    _pic = pic;
    _pic->AddRef();
    _guid = guid;
}

//+---------------------------------------------------------------------------
//
// dtor
//
//----------------------------------------------------------------------------

CAppProperty::~CAppProperty()
{
    _pic->Release();
}

//+---------------------------------------------------------------------------
//
// GetType
//
//----------------------------------------------------------------------------

STDAPI CAppProperty::GetType(GUID *pguid)
{
    if (pguid == NULL)
        return E_INVALIDARG;

    *pguid = _guid;

    return S_OK;
}

//+---------------------------------------------------------------------------
//
// EnumRanges
//
//----------------------------------------------------------------------------

STDAPI CAppProperty::EnumRanges(TfEditCookie ec, IEnumTfRanges **ppEnum, ITfRange *pTargetRange)
{
    CEnumAppPropRanges *pEnum;

    if (ppEnum == NULL)
        return E_INVALIDARG;

    *ppEnum = NULL;

    if (!_IsValidEditCookie(ec, TF_ES_READ))
    {
        Assert(0);
        return TF_E_NOLOCK;
    }

    // nb: unlike ITfProperty, ITfReadOnlyProperty does not accept pTargetRange == NULL!
    if (pTargetRange == NULL)
        return E_INVALIDARG;

    // make sure ic, range are in the same context
    if (!VerifySameContext(_pic, pTargetRange))
        return E_INVALIDARG;

    pEnum = new CEnumAppPropRanges;

    if (pEnum == NULL)
        return E_OUTOFMEMORY;

    if (!pEnum->_Init(_pic, pTargetRange, _guid))
    {
        pEnum->Release();
        return E_FAIL;
    }

    *ppEnum = pEnum;
    return S_OK;
}

//+---------------------------------------------------------------------------
//
// GetValue
//
//----------------------------------------------------------------------------

STDAPI CAppProperty::GetValue(TfEditCookie ec, ITfRange *pRange, VARIANT *pvarValue)
{
    TS_ATTRVAL av;
    HRESULT hr;
    CRange *range;
    ULONG cFetched;
    ITextStoreAnchor *ptsi;

    if (pvarValue == NULL)
        return E_INVALIDARG;

    QuickVariantInit(pvarValue);

    if (!_IsValidEditCookie(ec, TF_ES_READ))
    {
        Assert(0);
        return TF_E_NOLOCK;
    }

    if (pRange == NULL)
        return E_INVALIDARG; // supporting "whole doc" behavior too expensive!

    if ((range = GetCRange_NA(pRange)) == NULL)
        return E_INVALIDARG;

    if (!VerifySameContext(_pic, range))
        return E_INVALIDARG;

    ptsi = _pic->_GetTSI();

    // we always return the value at the start anchor
    hr = ptsi->RequestAttrsAtPosition(range->_GetStart(), 1, &_guid, 0);

    if (hr != S_OK)
        return E_FAIL;

    QuickVariantInit(&av.varValue);

    // just return the single VARIANT value directly
    if (ptsi->RetrieveRequestedAttrs(1, &av, &cFetched) != S_OK)
        return E_FAIL;

    if (cFetched == 0)
    {
        // default value
        return GetDefaultValue(_pic->_GetTSI(), _guid, pvarValue);
    }

    *pvarValue = av.varValue; // caller takes ownership

    return S_OK;
}

//+---------------------------------------------------------------------------
//
// GetContext
//
//----------------------------------------------------------------------------

STDAPI CAppProperty::GetContext(ITfContext **ppContext)
{
    if (ppContext == NULL)
        return E_INVALIDARG;

    *ppContext = _pic;
    (*ppContext)->AddRef();
    return S_OK;
}

//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////
//
// CInputContext
//
//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////

//+---------------------------------------------------------------------------
//
// GetAppProperty
//
//----------------------------------------------------------------------------

STDAPI CInputContext::GetAppProperty(REFGUID guidProp, ITfReadOnlyProperty **ppProp)
{
    CAppProperty *prop;
    TS_ATTRVAL av;
    ULONG cFetched;
    BOOL fUnsupported;
    HRESULT hr;

    if (ppProp == NULL)
        return E_INVALIDARG;

    *ppProp = NULL;

    if (!_IsConnected())
        return TF_E_DISCONNECTED;

    //
    // if we have a mapping property, it will be returned.
    //
    APPPROPMAP *pMap = FindMapAppProperty(guidProp);
    if (pMap)
    {
        CProperty *pProp;
        if (SUCCEEDED(_GetProperty(pMap->guidProp, &pProp)))
        {
            *ppProp = (ITfReadOnlyProperty *)pProp;
            return S_OK;
        }
    }

    // does the app support this property?
    fUnsupported = TRUE;

    if ((hr = _ptsi->RequestSupportedAttrs(0, 1, &guidProp)) != S_OK)
    {
        return (hr == E_NOTIMPL) ? E_NOTIMPL : E_FAIL;
    }

    QuickVariantInit(&av.varValue);

    if (_ptsi->RetrieveRequestedAttrs(1, &av, &cFetched) == S_OK &&
        cFetched == 1)
    {
        if (IsEqualGUID(av.idAttr, guidProp)) // paranoia
        {
            fUnsupported = FALSE;
        }
        else
        {
            Assert(0); // bad out param!
        }
    }

    if (fUnsupported)
    {
        return S_FALSE;
    }

    if ((prop = new CAppProperty(this, guidProp)) == NULL)
        return E_OUTOFMEMORY;

    *ppProp = prop;

    return S_OK;
}

//+---------------------------------------------------------------------------
//
// MapAppProperty
//
//----------------------------------------------------------------------------

STDAPI CInputContext::MapAppProperty(REFGUID guidAppProp, REFGUID guidProp)
{
    APPPROPMAP *pMap;

    //
    // overwrite the mapping guidProp.
    //
    if (pMap = FindMapAppProperty(guidAppProp))
    {
        pMap->guidProp = guidProp;
        return S_OK;
    }
 
    pMap = _rgAppPropMap.Append(1);
    if (!pMap)
        return E_OUTOFMEMORY;

    pMap->guidAppProp = guidAppProp;
    pMap->guidProp = guidProp;
    return S_OK;
}

//+---------------------------------------------------------------------------
//
// FindMapProp
//
//----------------------------------------------------------------------------

CInputContext::APPPROPMAP *CInputContext::FindMapAppProperty(REFGUID guidAppProp)
{
    int i;
    for (i = 0; i < _rgAppPropMap.Count(); i++)
    {
        APPPROPMAP *pMap = _rgAppPropMap.GetPtr(i);
        if (IsEqualGUID(pMap->guidAppProp, guidAppProp))
            return pMap;
    }
    return NULL;
}

//+---------------------------------------------------------------------------
//
// GetMappedAppProperty
//
//----------------------------------------------------------------------------

HRESULT CInputContext::GetMappedAppProperty(REFGUID guidProp, CProperty **ppProp)
{
    if (!_IsConnected())
        return TF_E_DISCONNECTED;

    //
    // if we have a mapping property, it will be returned.
    //
    APPPROPMAP *pMap = FindMapAppProperty(guidProp);
    if (pMap)
    {
        if (SUCCEEDED(_GetProperty(pMap->guidProp, ppProp)))
        {
            return S_OK;
        }
    }
    return E_FAIL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\ctf\uim\assembly.h ===
//
// assembly.h
//

#ifndef ASSEMBLY_H
#define ASSEMBLY_H

#include "strary.h"
#include "ptrary.h"

class CAssemblyList;

#define MAX_LANGPROFILENAME      256

typedef struct tag_ASSEMBLYITEM 
{
    CLSID clsid;
    GUID  catid;
    GUID  guidProfile;
    CAlignWinHKL   hkl;
    CAlignWinHKL   hklSubstitute;
    BOOL  fActive : 1;
    BOOL  fActiveNoCic : 1;
    BOOL  fEnabled : 1;
    BOOL  fInitIconIndex : 1;
    BOOL  fSkipToActivate : 1;
    BOOL  fSkipToNotify : 1;
    BOOL  fDisabledOnTransitory : 1;
    ULONG uIconIndex;
    WCHAR szProfile[MAX_LANGPROFILENAME];

    void InitIconIndex()
    {
        uIconIndex = (ULONG)(-1);
        fInitIconIndex = FALSE;
    }

    BOOL IsEqual(tag_ASSEMBLYITEM *pItem)
    {
        return IsEqual(pItem->hkl, pItem->clsid, pItem->guidProfile);
    }

    BOOL IsEqual(HKL hklIn, REFCLSID rclsidIn, REFGUID rguidProfileIn)
    {
        if ((hkl == hklIn) &&
             IsEqualGUID(clsid, rclsidIn) &&
             IsEqualGUID(guidProfile, rguidProfileIn))
            return TRUE;

        return FALSE;
    }

    static size_t   GetAlignSize() { return Align(sizeof(struct tag_ASSEMBLYITEM)); }
} ASSEMBLYITEM;


//////////////////////////////////////////////////////////////////////////////
//
// CAssembly
//
//////////////////////////////////////////////////////////////////////////////

class CAssembly
{
public:
    CAssembly(const TCHAR *pszName);
    CAssembly(LANGID langid);
    ~CAssembly();

    BOOL IsEnabled(SYSTHREAD *psfn);
    BOOL IsNonCiceroItem();
    BOOL IsEnabledKeyboardItem(SYSTHREAD *psfn);
    WCHAR *GetLangName() {return _szLangName;}
    LANGID GetLangId() {return _langid;}
    int Count() {return _rgAsmItem.Count();}
    ASSEMBLYITEM *GetItem(int nId)
    {
         return _rgAsmItem.GetPtr(nId);
    }
    BOOL IsFEIMEActive();

    void RebuildSubstitutedHKLList();
    BOOL IsSubstitutedHKL(HKL hkl);
    void ClearSubstitutedHKLList()
    {
        _rghklSubstituted.Clear();
    }
    ASSEMBLYITEM *GetSubstituteItem(HKL hKL);
    ASSEMBLYITEM *FindActiveKeyboardItem();
    ASSEMBLYITEM *FindKeyboardLayoutItem(HKL hkl);

#ifdef CHECKFEIMESELECTED
    BOOL _fUnknownFEIMESelected;
#endif

private:
friend CAssemblyList;
    ASSEMBLYITEM *FindItemByCategory(REFGUID catid);
    ASSEMBLYITEM *FindPureKbdTipItem();
    BOOL IsEnabledItemByCategory(REFGUID catid);
    BOOL IsEnabledItem();

    int Find(ASSEMBLYITEM *pItem)
    {
         ASSEMBLYITEM *pItemTmp;
         int nCnt = _rgAsmItem.Count();
         int i;
         for (i = 0; i < nCnt; i++)
         {
             pItemTmp = _rgAsmItem.GetPtr(i);

             if (pItemTmp->IsEqual(pItem))
                 return i;
         }
         return -1;
    }
    void Add(ASSEMBLYITEM *pItem)
    {
         ASSEMBLYITEM *pItemTmp;
         if (Find(pItem) >= 0)
             return;

         pItemTmp = _rgAsmItem.Append(1);
         if (pItemTmp)
             *pItemTmp = *pItem;
    }

    void Remove(ASSEMBLYITEM *pItem)
    {
         int nId = Find(pItem);
         if (nId >= 0)
         {
             _rgAsmItem.Remove(nId, 1);
         }
    }

    LANGID _langid;
    WCHAR _szLangName[64];

    CStructArray<ASSEMBLYITEM> _rgAsmItem;
    CStructArray<HKL> _rghklSubstituted;
};

//////////////////////////////////////////////////////////////////////////////
//
// CAssemblyList
//
//////////////////////////////////////////////////////////////////////////////

class CAssemblyList
{
public:
    CAssemblyList();
    ~CAssemblyList();

    void ClearAsms();
    HRESULT Load();
    CAssembly *GetDefaultAssembly();
    void AttachOriginalAssembly(CPtrArray<CAssembly> *prgAsmOrg);

    int Count() {return _rgAsm.Count();}
    CAssembly *GetAssembly(int nId)
    {
         return _rgAsm.Get(nId);
    }

    CAssembly *FindAssemblyByLangId(LANGID langid)
    {
        return FindAssemblyByLangIdInArray(&_rgAsm, langid);
    }

    static CAssembly *FindAssemblyByLangIdInArray(CPtrArray<CAssembly> *rgAsm, LANGID langid)
    {
        int nCnt = rgAsm->Count();
        int i;
        for (i = 0; i < nCnt; i++)
        {
            CAssembly *pAsm = rgAsm->Get(i);
            if (pAsm->_langid == langid)
               return pAsm;
        }
        return NULL;
    }

    BOOL LoadFromCache();
    BOOL SetDefaultTIPInAssemblyInternal(CAssembly *pAsm, ASSEMBLYITEM *pItem, BOOL fChangeDefault);

    static BOOL SetDefaultTIPInAssemblyForCache(LANGID langid, REFGUID catid, REFCLSID clsid, HKL hKL, REFGUID guidProfile);
    static BOOL InvalidCache();

#ifdef PROFILE_UPDATE_REGISTRY  // old code for tip setup.
    static BOOL IsUpdated();
    static BOOL ClearUpdatedFlag();
#endif

    static BOOL GetDefaultTIPInAssembly(LANGID langid, REFGUID catid, CLSID *pclsid, HKL* phKL, GUID *pguidProfile);
    static BOOL SetDefaultTIPInAssembly(LANGID langid, REFGUID catid, REFCLSID clsid, HKL hKL, REFGUID guidProfile);
    static BOOL IsFEDummyKL(HKL hkl);
    static HKL GetProperHKL(LANGID langid, HKL *lphkl, BOOL *pfLoaded);
    static BOOL CheckLangSupport(REFCLSID rclsid, LANGID langid);

private:
    BOOL CreateCache(SECURITY_ATTRIBUTES *psa);
    static BOOL GetTIPCategory(REFCLSID clsid, GUID *pcatid, IEnumGUID *pEnumCat);

    CPtrArray<CAssembly> _rgAsm;
    static CAssembly *FindAndCreateNewAssembly(CPtrArray<CAssembly> *prgAsm,  CPtrArray<CAssembly> *prgNutralAsm, LANGID langid);

};

inline BOOL IsIMEHKL(HKL hkl)
{
   return ((((DWORD)(LONG_PTR)hkl) & 0xf0000000) == 0xe0000000) ? TRUE : FALSE;
}

inline BOOL IsFELangId(LANGID langid)
{
    if ((langid == 0x411) ||
        (langid == 0x404) ||
        (langid == 0x412) ||
        (langid == 0x804))
    {
        return TRUE;
    }
    return FALSE;
}


inline BOOL IsPureIMEHKL(HKL hkl)
{
    if (!IsIMEHKL(hkl))
        return FALSE;

    return CAssemblyList::IsFEDummyKL(hkl) ? FALSE : TRUE;
}

BOOL EnsureAsmCacheFileMap();
BOOL UninitAsmCacheFileMap();
BOOL IsAsmCache();

#endif // ASSEMBLY_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\ctf\uim\attr.h ===
//
// attr.h
//

#ifndef ATTR_H
#define ATTR_H

class CSharedAnchorArray;
class CRange;
class CInputContext;

CSharedAnchorArray *CalcCicPropertyTrackerAnchors(CInputContext *pic, IAnchor *paStart, IAnchor *paEnd, ULONG cGUIDATOMs, const TfGuidAtom *prgGUIDATOMs);
CSharedAnchorArray *CalcAppPropertyTrackerAnchors(ITextStoreAnchor *ptsi, ITfRange *rangeSuper, ULONG cGUIDs, const GUID *prgGUIDs);
HRESULT FillAppValueArray(ITextStoreAnchor *ptsi, CRange *pRange, TF_PROPERTYVAL *rgPropVal, ULONG cGUIDs, const GUID *prgGUIDs);

#endif// ATTR_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\ctf\uim\catmgr.cpp ===
//
// catmgr.cpp
//

#include "private.h"
#include "globals.h"
#include "regsvr.h"
#include "xstring.h"
#include "cregkey.h"
#include "catmgr.h"

CCatGUIDTbl *CCategoryMgr::_pCatGUIDTbl = NULL;

const TCHAR c_szCategoryKey[] = TEXT("Category\\");
const TCHAR c_szDescription[] = TEXT("Description");
const WCHAR c_wszDescription[] = L"Description";
const TCHAR c_szCategory[] = TEXT("Category\\"); // Category to item mapping
const TCHAR c_szItem[] = TEXT("Item\\");         // Item to category mapping
const TCHAR c_szGuid[] = TEXT("Guid%d"); 
const TCHAR c_szDword[] = TEXT("Dword"); 
const TCHAR c_szNULL[] = TEXT(""); 

DBG_ID_INSTANCE(CCategoryMgr);
DBG_ID_INSTANCE(CEnumCategories);

inline BOOL GetCatKey(REFCLSID rclsid, REFGUID rcatid, LPSTR pszKey, int cchKey, LPCSTR pszItem)
{
    int cchFinal;
    int cchTipKey;
    int cchCatKey;
    int cchItem;

    cchTipKey = lstrlen(c_szCTFTIPKey);
    cchCatKey = lstrlen(c_szCategoryKey);
    cchItem = lstrlen(pszItem);

    cchFinal = cchTipKey +
               CLSID_STRLEN +             // rclsid
               1 +                        // '\\'
               cchCatKey +
               cchItem +
               CLSID_STRLEN +
               1;                         // '\0'

    if (cchFinal > cchKey)
    {
        if (cchKey > 0)
        {
            pszKey[0] = '\0';
        }
        return FALSE;
    }

    StringCchCopy(pszKey, cchKey, c_szCTFTIPKey);
    CLSIDToStringA(rclsid, pszKey + cchTipKey);
    StringCchPrintf(pszKey + cchTipKey + CLSID_STRLEN, cchKey - cchTipKey - CLSID_STRLEN, "\\%s%s", c_szCategoryKey, pszItem);
    CLSIDToStringA(rcatid, pszKey + cchTipKey + CLSID_STRLEN + 1 + cchCatKey + cchItem);

    return TRUE;
}

//
// for inatlib.
//
HRESULT g_EnumItemsInCategory(REFGUID rcatid, IEnumGUID **ppEnum)
{
    return CCategoryMgr::s_EnumItemsInCategory(rcatid, ppEnum);
}



//////////////////////////////////////////////////////////////////////////////
//
// CCatGUIDTbl
//
//////////////////////////////////////////////////////////////////////////////

//+---------------------------------------------------------------------------
//
// add
//
//----------------------------------------------------------------------------

TfGuidAtom CCatGUIDTbl::Add(REFGUID rguid)
{
    UINT uId = _HashFunc(rguid);
    UINT iCnt;
  
    if (!_prgCatGUID[uId])
    {
        _prgCatGUID[uId] = new CStructArray<CATGUIDITEM>;
        if (!_prgCatGUID[uId])
            return TF_INVALID_GUIDATOM;
    }

    iCnt = _prgCatGUID[uId]->Count();
    if (!ValidGUIDARRAYCount(iCnt))
    {
         Assert(0);
         return TF_INVALID_GUIDATOM;
    }

    if (!_prgCatGUID[uId]->Insert(iCnt, 1))
    {
         return TF_INVALID_GUIDATOM;
    }

    CATGUIDITEM *pItem = _prgCatGUID[uId]->GetPtr(iCnt);

    pItem->guid = rguid;
    pItem->rgGuidAry[CAT_FORWARD] = NULL;
    pItem->rgGuidAry[CAT_BACKWARD] = NULL;

    return MAKEGUIDATOM(iCnt, uId);
}

//+---------------------------------------------------------------------------
//
// FindGuid
//
//----------------------------------------------------------------------------

TfGuidAtom CCatGUIDTbl::FindGuid(REFGUID rguid)
{
    UINT uId = _HashFunc(rguid);
    int nCnt;
    int i;

    if (!_prgCatGUID[uId])
        return TF_INVALID_GUIDATOM;

    nCnt = _prgCatGUID[uId]->Count();

    if (!ValidGUIDARRAYCount(nCnt))
    {
        Assert(0);
        return TF_INVALID_GUIDATOM;
    }

    for (i = 0; i < nCnt; i++)
    {
        CATGUIDITEM *pItem = _prgCatGUID[uId]->GetPtr(i);
        if (IsEqualGUID(pItem->guid, rguid))
        {
            return MAKEGUIDATOM(i, uId);
        }
    }
    return TF_INVALID_GUIDATOM;
}

//+---------------------------------------------------------------------------
//
// GetGuid
//
//----------------------------------------------------------------------------

CATGUIDITEM *CCatGUIDTbl::GetGUID(TfGuidAtom atom)
{
    UINT uId = HASHIDFROMGUIDATOM(atom);
    int nCnt = IDFROMGUIDATOM(atom);

    if (!ValidGUIDHash(uId))
        return NULL;

    if ((!_prgCatGUID[uId]) || (nCnt >= _prgCatGUID[uId]->Count()))
        return NULL;

    return _prgCatGUID[uId]->GetPtr(nCnt);
}

//////////////////////////////////////////////////////////////////////////////
//
// CCategoryMgr
//
//////////////////////////////////////////////////////////////////////////////

//+---------------------------------------------------------------------------
//
// ctor
//
//----------------------------------------------------------------------------

CCategoryMgr::CCategoryMgr()
{
    Dbg_MemSetThisNameIDCounter(TEXT("CCategoryMgr"), PERF_CATMGR_COUNTER);
}

//+---------------------------------------------------------------------------
//
// dtor
//
//----------------------------------------------------------------------------

CCategoryMgr::~CCategoryMgr()
{
}

//+---------------------------------------------------------------------------
//
// InitGlobal
//
//----------------------------------------------------------------------------

BOOL CCategoryMgr::InitGlobal()
{
    if (!_pCatGUIDTbl)
        _pCatGUIDTbl = new CCatGUIDTbl;

    return _pCatGUIDTbl ? TRUE : FALSE;
}

//----------------------------------------------------------------------------
//
// RegisterCategory
//
//----------------------------------------------------------------------------

STDAPI CCategoryMgr::RegisterCategory(REFCLSID rclsid, REFGUID rcatid, REFGUID rguid)
{
    return s_RegisterCategory(rclsid, rcatid, rguid);
}

HRESULT CCategoryMgr::s_RegisterCategory(REFCLSID rclsid, REFGUID rcatid, REFGUID rguid)
{
    HRESULT hr;

    //
    // create forward link from category to guids.
    //
    if (FAILED(hr = _InternalRegisterCategory(rclsid, rcatid, rguid, CAT_FORWARD)))
        return hr;

    //
    // create backward link from guid to categories.
    //
    if (FAILED(hr = _InternalRegisterCategory(rclsid, rguid, rcatid, CAT_BACKWARD)))
    {
        _InternalUnregisterCategory(rclsid, rcatid, rguid, CAT_FORWARD);
        return hr;
    }

    return S_OK;
}

//----------------------------------------------------------------------------
//
// UnregisterCategory
//
//----------------------------------------------------------------------------

STDAPI CCategoryMgr::UnregisterCategory(REFCLSID rclsid, REFGUID rcatid, REFGUID rguid)
{
    return s_UnregisterCategory(rclsid, rcatid, rguid);
}

HRESULT CCategoryMgr::s_UnregisterCategory(REFCLSID rclsid, REFGUID rcatid, REFGUID rguid)
{
    HRESULT hr;

    //
    // remove forward link from category to guids.
    //
    if (FAILED(hr = _InternalUnregisterCategory(rclsid, rcatid, rguid, CAT_FORWARD)))
        return hr;

    //
    // remove backward link from guid to categories.
    //
    if (FAILED(hr = _InternalUnregisterCategory(rclsid, rguid, rcatid, CAT_BACKWARD)))
    {
        _InternalRegisterCategory(rclsid, rcatid, rguid, CAT_FORWARD);
        return hr;
    }

    return S_OK;
}

//----------------------------------------------------------------------------
//
// EnumCategoriesInItem
//
//----------------------------------------------------------------------------

STDAPI CCategoryMgr::EnumCategoriesInItem(REFGUID rguid, IEnumGUID **ppEnum)
{
    return _InternalEnumCategories(rguid, ppEnum, CAT_BACKWARD);
}

HRESULT CCategoryMgr::s_EnumCategoriesInItem(REFGUID rguid, IEnumGUID **ppEnum)
{
    return _InternalEnumCategories(rguid, ppEnum, CAT_BACKWARD);
}

//----------------------------------------------------------------------------
//
// EnumItemsinCategory
//
//----------------------------------------------------------------------------

STDAPI CCategoryMgr::EnumItemsInCategory(REFGUID rcatid, IEnumGUID **ppEnum)
{
    return _InternalEnumCategories(rcatid, ppEnum, CAT_FORWARD);
}

HRESULT CCategoryMgr::s_EnumItemsInCategory(REFGUID rcatid, IEnumGUID **ppEnum)
{
    return _InternalEnumCategories(rcatid, ppEnum, CAT_FORWARD);
}

//----------------------------------------------------------------------------
//
// FindClosestCategory
//
//----------------------------------------------------------------------------

HRESULT CCategoryMgr::FindClosestCategory(REFGUID rguid, GUID *pcatid, const GUID **ppcatidList, ULONG ulCount)
{
    return s_FindClosestCategory(rguid, pcatid, ppcatidList, ulCount);
}

HRESULT CCategoryMgr::s_FindClosestCategory(REFGUID rguid, GUID *pcatid, const GUID **ppcatidList, ULONG ulCount)
{
//    GUID catid = GUID_NULL;

    if (!pcatid)
        return E_INVALIDARG;
    
    if (!ppcatidList || !ulCount)
    {
        return _GetFirstCategory(rguid, pcatid);
    }

    for (ULONG ul = 0; ul < ulCount; ul++)
    {
        if (!ppcatidList[ul])
            return E_INVALIDARG;
    }

    return _InternalFindClosestCategory(rguid, 
                                        rguid, 
                                        pcatid, 
                                        ppcatidList, 
                                        ulCount);
}

//----------------------------------------------------------------------------
//
// _GetFirstCategory
//
//----------------------------------------------------------------------------

HRESULT CCategoryMgr::_GetFirstCategory(REFGUID rguid, GUID *pcatid)
{
    HRESULT hr;
    IEnumGUID *pEnum;

    if (SUCCEEDED(hr = _InternalEnumCategories(rguid, &pEnum, CAT_BACKWARD)))
    {
        // we return S_FALSE if we can not find it and return GUID_NULL.
        hr = pEnum->Next(1, pcatid, NULL);
        if (hr != S_OK)
            *pcatid = GUID_NULL;

        pEnum->Release();
    }
    return hr;
}

//----------------------------------------------------------------------------
//
// _InternalFindClosestCategory
//
//----------------------------------------------------------------------------

HRESULT CCategoryMgr::_InternalFindClosestCategory(REFGUID rguidOrg, REFGUID rguid, GUID *pcatid, const GUID **ppcatidList, ULONG ulCount)
{
    HRESULT hr;
    ULONG ul;
    IEnumGUID *pEnum = NULL;
    GUID catid = GUID_NULL;

    Assert(ppcatidList);
    Assert(ulCount);

    *pcatid = GUID_NULL;

    for (ul = 0; ul < ulCount; ul++)
    {
        if (IsEqualGUID(*ppcatidList[ul], rguid))
        {
            *pcatid = rguid;
            hr = S_OK;
            goto Exit;
        }
    }

    //
    // we don't return error. We return success and GUID_NULL.
    //
    hr = _InternalEnumCategories(rguid, &pEnum, CAT_BACKWARD);
    if (hr != S_OK)
    {
        hr = S_OK;
        goto Exit;
    }

    while (pEnum->Next(1, &catid, NULL) == S_OK)
    {
        if (IsEqualGUID(rguidOrg, catid))
        {
            // finally the original guid is categorized by itself.
            // it may cause infinte loop so bail it out.
            hr = S_OK;
            goto Exit;
        }

        _InternalFindClosestCategory(rguidOrg, 
                                     catid, 
                                     pcatid, 
                                     ppcatidList, 
                                     ulCount);

        if (!IsEqualGUID(*pcatid, GUID_NULL))
        {
            hr = S_OK;
            goto Exit;
        }
    }

Exit:
    SafeRelease(pEnum);
    return hr;
}


//----------------------------------------------------------------------------
//
// RegisterGUIDDesription
//
//----------------------------------------------------------------------------

STDAPI CCategoryMgr::RegisterGUIDDescription(REFCLSID rclsid, REFGUID rguid, const WCHAR *pchDesc, ULONG cch)
{
    if (!pchDesc && cch)
        return E_INVALIDARG;
 
    return s_RegisterGUIDDescription(rclsid, rguid, WCHtoWSZ(pchDesc, cch));
}

HRESULT CCategoryMgr::s_RegisterGUIDDescription(REFCLSID rclsid, REFGUID rguid, WCHAR *pszDesc)
{
    TCHAR szKey[256];
    CMyRegKey key;
    
    if (!GetCatKey(rclsid, rguid, szKey, ARRAYSIZE(szKey), c_szItem))
        return E_FAIL;

    if (key.Create(HKEY_LOCAL_MACHINE, szKey) != S_OK)
        return E_FAIL;

    key.SetValueW(pszDesc, c_wszDescription);

    return S_OK;
}

//----------------------------------------------------------------------------
//
// UnregisterGUIDDesription
//
//----------------------------------------------------------------------------

STDAPI CCategoryMgr::UnregisterGUIDDescription(REFCLSID rclsid, REFGUID rguid)
{
    return s_UnregisterGUIDDescription(rclsid, rguid);
}

HRESULT CCategoryMgr::s_UnregisterGUIDDescription(REFCLSID rclsid, REFGUID rguid)
{
    TCHAR szKey[256];
    CMyRegKey key;
    
    if (!GetCatKey(rclsid, rguid, szKey, ARRAYSIZE(szKey), c_szItem))
        return E_FAIL;

    if (key.Open(HKEY_LOCAL_MACHINE, szKey, KEY_ALL_ACCESS) != S_OK)
        return E_FAIL;

    key.DeleteValueW(c_wszDescription);

    return S_OK;
}

//----------------------------------------------------------------------------
//
// GetGUIDDescription
//
//----------------------------------------------------------------------------

STDAPI CCategoryMgr::GetGUIDDescription(REFGUID rguid, BSTR *pbstrDesc)
{
    return s_GetGUIDDescription(rguid, pbstrDesc);
}

HRESULT CCategoryMgr::s_GetGUIDDescription(REFGUID rguid, BSTR *pbstrDesc)
{
    return s_GetGUIDValue(rguid, c_szDescriptionW, pbstrDesc);
}

HRESULT CCategoryMgr::s_GetGUIDValue(REFGUID rguid, const WCHAR* pszValue, BSTR *pbstrDesc)
{
    WCHAR *psz = NULL;
    CMyRegKey keyImx;
    HRESULT hr = E_FAIL;
    int cch;
    TCHAR szSubKey[256]; // nb: we can merge szSubKey and szTemp if we switch to a UNICODE build
    WCHAR szTemp[256];

    if (!pbstrDesc)
        return E_INVALIDARG;

    *pbstrDesc = NULL;
    
    if (keyImx.Open(HKEY_LOCAL_MACHINE, c_szCTFTIPKey, KEY_READ) != S_OK)
        return hr;

    DWORD dwIndex = 0;

    while (keyImx.EnumKey(dwIndex++, szSubKey, ARRAYSIZE(szSubKey)) == S_OK)
    {
        CMyRegKey key;

        if (StringCchPrintf(szSubKey + lstrlen(szSubKey), ARRAYSIZE(szSubKey), "\\%s%s", c_szCategoryKey, c_szItem) != S_OK)
            continue;

        cch = lstrlen(szSubKey);

        if (cch + CLSID_STRLEN + 1 > ARRAYSIZE(szSubKey))
            continue;

        CLSIDToStringA(rguid, szSubKey + cch);

        if (key.Open(keyImx, szSubKey, KEY_READ) != S_OK)
            continue;

        if (key.QueryValueCchW(szTemp, pszValue, ARRAYSIZE(szTemp)) == S_OK)
        {
            *pbstrDesc = SysAllocString(szTemp);
            hr = *pbstrDesc != NULL ? S_OK : E_OUTOFMEMORY;
        }

        // this was the matching key, so no point in continue successful query or not
        break;
    }

    return hr;
}


//----------------------------------------------------------------------------
//
// RegisterGUIDDesription
//
//----------------------------------------------------------------------------

STDAPI CCategoryMgr::RegisterGUIDDWORD(REFCLSID rclsid, REFGUID rguid, DWORD dw)
{
    return s_RegisterGUIDDWORD(rclsid, rguid, dw);
}

HRESULT CCategoryMgr::s_RegisterGUIDDWORD(REFCLSID rclsid, REFGUID rguid, DWORD dw)
{ 
    TCHAR szKey[256];
    CMyRegKey key;
    
    if (!GetCatKey(rclsid, rguid, szKey, ARRAYSIZE(szKey), c_szItem))
        return E_FAIL;

    if (key.Create(HKEY_LOCAL_MACHINE, szKey) != S_OK)
        return E_FAIL;

    key.SetValue(dw, c_szDword);
    return S_OK;
}

//----------------------------------------------------------------------------
//
// UnregisterGUIDDesription
//
//----------------------------------------------------------------------------

STDAPI CCategoryMgr::UnregisterGUIDDWORD(REFCLSID rclsid, REFGUID rguid)
{
    return s_UnregisterGUIDDWORD(rclsid, rguid);
}

HRESULT CCategoryMgr::s_UnregisterGUIDDWORD(REFCLSID rclsid, REFGUID rguid)
{ 
    TCHAR szKey[256];
    CMyRegKey key;
    
    if (!GetCatKey(rclsid, rguid, szKey, ARRAYSIZE(szKey), c_szItem))
        return E_FAIL;

    if (key.Open(HKEY_LOCAL_MACHINE, szKey, KEY_ALL_ACCESS) != S_OK)
        return E_FAIL;

    key.DeleteValue(c_szDword);
    return S_OK;
}

//----------------------------------------------------------------------------
//
// GetGUIDDWORD
//
//----------------------------------------------------------------------------

STDAPI CCategoryMgr::GetGUIDDWORD(REFGUID rguid, DWORD *pdw)
{
    return s_GetGUIDDWORD(rguid, pdw);
}

HRESULT CCategoryMgr::s_GetGUIDDWORD(REFGUID rguid, DWORD *pdw)
{
    CMyRegKey keyImx;
    int cch;
    HRESULT hr = E_FAIL;

    if (!pdw)
        return E_INVALIDARG;

    *pdw = 0;
    
    if (keyImx.Open(HKEY_LOCAL_MACHINE, c_szCTFTIPKey, KEY_READ) != S_OK)
        return hr;

    DWORD dwIndex = 0;
    TCHAR szSubKey[256];
    while (keyImx.EnumKey(dwIndex++, szSubKey, ARRAYSIZE(szSubKey)) == S_OK)
    {
        CMyRegKey key;

        if (StringCchPrintf(szSubKey + lstrlen(szSubKey), ARRAYSIZE(szSubKey), "\\%s%s", c_szCategoryKey, c_szItem) != S_OK)
            continue;

        cch = lstrlen(szSubKey);

        if (cch + CLSID_STRLEN + 1 > ARRAYSIZE(szSubKey))
            continue;

        CLSIDToStringA(rguid, szSubKey + cch);

        if (key.Open(keyImx, szSubKey, KEY_READ) != S_OK)
            continue;

        if (key.QueryValue(*pdw, c_szDword) == S_OK)
        {
            hr = S_OK;
            break;
        }
    }

    return hr;
}

//----------------------------------------------------------------------------
//
// RegisterProvider
//
//----------------------------------------------------------------------------

STDAPI CCategoryMgr::RegisterGUID(REFGUID rguid, TfGuidAtom *pguidatom)
{
    return s_RegisterGUID(rguid, pguidatom);
}

HRESULT CCategoryMgr::s_RegisterGUID(REFGUID rguid, TfGuidAtom *pguidatom)
{
    TfGuidAtom guidatom;
    HRESULT hr = E_FAIL;

    CicEnterCriticalSection(g_cs);

    if (InitGlobal())
    {
        if ((guidatom = _pCatGUIDTbl->FindGuid(rguid)) != TF_INVALID_GUIDATOM)
        {
            *pguidatom = guidatom;
            hr =  S_OK;
        }
        else if ((guidatom = _pCatGUIDTbl->Add(rguid)) != TF_INVALID_GUIDATOM)
        {
            *pguidatom = guidatom;
            hr =  S_OK;
        }
    }

    CicLeaveCriticalSection(g_cs);

    return hr;
}

//----------------------------------------------------------------------------
//
// GetGUID
//
//----------------------------------------------------------------------------

STDAPI CCategoryMgr::GetGUID(TfGuidAtom guidatom, GUID *pguid)
{
    return s_GetGUID(guidatom, pguid);
}

HRESULT CCategoryMgr::s_GetGUID(TfGuidAtom guidatom, GUID *pguid)
{
    CATGUIDITEM *pItem;
    HRESULT hr = E_FAIL;

    if (!pguid)
        return E_INVALIDARG;

    CicEnterCriticalSection(g_cs);

    if (InitGlobal())
    {
        pItem = _pCatGUIDTbl->GetGUID(guidatom);
        if (!pItem)
        {
            *pguid = GUID_NULL;
            goto Exit;
        }

        *pguid = pItem->guid;
        hr = S_OK;
    }

Exit:
    CicLeaveCriticalSection(g_cs);
  
    return hr;
}

//----------------------------------------------------------------------------
//
// IsEqualTfGuidAtom
//
//----------------------------------------------------------------------------

STDAPI CCategoryMgr::IsEqualTfGuidAtom(TfGuidAtom guidatom, REFGUID rguid, BOOL *pfEqual)
{
    return s_IsEqualTfGuidAtom(guidatom, rguid, pfEqual);
}

HRESULT CCategoryMgr::s_IsEqualTfGuidAtom(TfGuidAtom guidatom, REFGUID rguid, BOOL *pfEqual)
{
    HRESULT hr = E_FAIL;
    CATGUIDITEM *pItem;

    if (pfEqual == NULL)
        return E_INVALIDARG;

    *pfEqual = FALSE;

    CicEnterCriticalSection(g_cs);

    if (InitGlobal())
    {
        if (pItem = _pCatGUIDTbl->GetGUID(guidatom))
        {
            *pfEqual = IsEqualGUID(pItem->guid, rguid);
            hr = S_OK;
        }
    }

    CicLeaveCriticalSection(g_cs);
    return hr;
}

//----------------------------------------------------------------------------
//
// InternalRegisterCategory
//
//----------------------------------------------------------------------------

HRESULT CCategoryMgr::_InternalRegisterCategory(REFCLSID rclsid, REFGUID rcatid, REFGUID rguid, CATDIRECTION catdir)
{
    TCHAR szKey[256];
    CONST TCHAR *pszForward = (catdir == CAT_FORWARD) ? c_szCategory : c_szItem;
    CMyRegKey key;
    CMyRegKey keySub;
    
    if (!GetCatKey(rclsid, rcatid, szKey, ARRAYSIZE(szKey), pszForward))
        return E_FAIL;

    if (key.Create(HKEY_LOCAL_MACHINE, szKey) != S_OK)
        return E_FAIL;

    //
    // we add this guid and save it.
    //
    char szValue[CLSID_STRLEN + 1];
    CLSIDToStringA(rguid, szValue);
    keySub.Create(key, szValue);
    _FlushGuidArrayCache(rguid, catdir);

    return S_OK;
}

//----------------------------------------------------------------------------
//
// UnregisterCategory
//
//----------------------------------------------------------------------------

HRESULT CCategoryMgr::_InternalUnregisterCategory(REFCLSID rclsid, REFGUID rcatid, REFGUID rguid, CATDIRECTION catdir)
{
    TCHAR szKey[256];
    CONST TCHAR *pszForward = (catdir == CAT_FORWARD) ? c_szCategory : c_szItem;
    CMyRegKey key;
    
    if (!GetCatKey(rclsid, rcatid, szKey, ARRAYSIZE(szKey), pszForward))
        return E_FAIL;

    if (key.Open(HKEY_LOCAL_MACHINE, szKey, KEY_ALL_ACCESS) != S_OK)
        return E_FAIL;

    DWORD dwIndex = 0;
    char szValue[CLSID_STRLEN + 1];

    CLSIDToStringA(rguid, szValue);
    key.RecurseDeleteKey(szValue);
    _FlushGuidArrayCache(rguid, catdir);

    return S_OK;
}

//----------------------------------------------------------------------------
//
// _FlushGuidArrayCache
//
//----------------------------------------------------------------------------

void CCategoryMgr::_FlushGuidArrayCache(REFGUID rguid, CATDIRECTION catdir)
{
    TfGuidAtom guidatom;
    CATGUIDITEM *pItem;

    CicEnterCriticalSection(g_cs);

    if (!_pCatGUIDTbl)
        goto Exit;

    guidatom = _pCatGUIDTbl->FindGuid(rguid);
    if (guidatom == TF_INVALID_GUIDATOM)
        goto Exit;

    pItem = _pCatGUIDTbl->GetGUID(guidatom);
    if (!pItem)
    {
        Assert(0);
        goto Exit;
    }

    SGA_Release(pItem->rgGuidAry[catdir]);
    pItem->rgGuidAry[catdir] = NULL;

Exit:
    CicLeaveCriticalSection(g_cs);
}

//----------------------------------------------------------------------------
//
// _InternalEnumCategories
//
//----------------------------------------------------------------------------

HRESULT CCategoryMgr::_InternalEnumCategories(REFGUID rguid, IEnumGUID **ppEnum, CATDIRECTION catdir)
{
    CEnumCategories *pEnum;

    if (!ppEnum)
        return E_INVALIDARG;

    pEnum = new CEnumCategories();

    if (!pEnum)
        return E_OUTOFMEMORY;

    if (pEnum->_Init(rguid, catdir))
        *ppEnum = pEnum;
    else
        SafeReleaseClear(pEnum);

    return pEnum ? S_OK : E_FAIL;
}

//////////////////////////////////////////////////////////////////////////////
//
// CEnumCategories
//
//////////////////////////////////////////////////////////////////////////////

//+---------------------------------------------------------------------------
//
// ctor
//
//----------------------------------------------------------------------------

CEnumCategories::CEnumCategories()
{
    Dbg_MemSetThisNameIDCounter(TEXT("CEnumCategories"), PERF_ENUMCAT_COUNTER);
}

//+---------------------------------------------------------------------------
//
// Init
//
//----------------------------------------------------------------------------

BOOL CEnumCategories::_Init(REFGUID rcatid, CATDIRECTION catdir)
{
    int cch;
    int nCnt = 0;
    BOOL bRet = FALSE;
    CMyRegKey keyImx;
    TfGuidAtom guidatom;
    CATGUIDITEM *pItem;
    CONST TCHAR *pszForward = (catdir == CAT_FORWARD) ? c_szCategory : c_szItem;
    DWORD dwIndex = 0;
    TCHAR szSubKey[256];
    ULONG cGuidMax = 64;
    ULONG cGuidCurrent = 0;

    CicEnterCriticalSection(g_cs);

    if (!CCategoryMgr::InitGlobal())
        goto LeaveCrtSec;

    guidatom = CCategoryMgr::_pCatGUIDTbl->FindGuid(rcatid);
    if (guidatom == TF_INVALID_GUIDATOM)
    {
        guidatom = CCategoryMgr::_pCatGUIDTbl->Add(rcatid);

        if (guidatom == TF_INVALID_GUIDATOM)
            goto LeaveCrtSec;
    }

    pItem = CCategoryMgr::_pCatGUIDTbl->GetGUID(guidatom);
    Assert(pItem);

    if (_pga = pItem->rgGuidAry[catdir])
    {
        // already have this GUID cached, just reference it
        SGA_AddRef(_pga);

        bRet = TRUE;
        goto LeaveCrtSec;
    }

    _pga = SGA_Alloc(cGuidMax);
    if (!_pga)
        goto LeaveCrtSec;

    _pga->cRef = 1;

    if (keyImx.Open(HKEY_LOCAL_MACHINE, c_szCTFTIPKey, KEY_READ) != S_OK)
        goto LeaveCrtSec;

    while (keyImx.EnumKey(dwIndex++, szSubKey, ARRAYSIZE(szSubKey)) == S_OK)
    {
        CMyRegKey key;

        if (StringCchPrintf(szSubKey + lstrlen(szSubKey), ARRAYSIZE(szSubKey), "\\%s%s", c_szCategoryKey, pszForward) != S_OK)
            continue;

        cch = lstrlen(szSubKey);

        if (cch + CLSID_STRLEN + 1 > ARRAYSIZE(szSubKey))
            continue;

        CLSIDToStringA(rcatid, szSubKey + cch);

        if (key.Open(keyImx, szSubKey, KEY_READ) != S_OK)
            continue;

        DWORD dwSize = 0;
        DWORD dwIndex2 = 0;
        char szValueName[CLSID_STRLEN + 1];
        while (key.EnumKey(dwIndex2++, szValueName, ARRAYSIZE(szValueName)) == S_OK)
        {
            if (lstrlen(szValueName) == CLSID_STRLEN)
            {
                if (cGuidCurrent >= cGuidMax)
                {
                    cGuidMax += 64;
                    if (!SGA_ReAlloc(&_pga, cGuidMax))
                        goto LeaveCrtSec;
                }
                StringAToCLSID(szValueName, &_pga->rgGuid[cGuidCurrent]);
                cGuidCurrent++;
            }
        }
    }

    // free up unused memory
    if (!SGA_ReAlloc(&_pga, cGuidCurrent))
        goto LeaveCrtSec;

    bRet = TRUE;
    _pga->cGuid = cGuidCurrent;

    // put this array in the cache
    pItem->rgGuidAry[catdir] = _pga;
    SGA_AddRef(pItem->rgGuidAry[catdir]);

LeaveCrtSec:
    CicLeaveCriticalSection(g_cs);

    return bRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\ctf\uim\crtfree.cpp ===
#include "private.h"

#define CPP_FUNCTIONS
#include "icrtfree.h" // Code to help free modules from the bondage and tyranny of CRT libraries
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\ctf\uim\catmgr.h ===
//
// catmgr.h
//

#ifndef CATMGR_H
#define CATMGR_H

#include "private.h"
#include "strary.h"
#include "enumguid.h"

//////////////////////////////////////////////////////////////////////////////
//
// CCatGUIDTbl
//
//////////////////////////////////////////////////////////////////////////////

#define CATGUID_HASHSIZE 31
#define ValidGUIDHash(hashid)       (hashid < CATGUID_HASHSIZE)
#define ValidGUIDARRAYCount(cnt)    (cnt < 0x07ffffff)
#define MAKEGUIDATOM(cnt, hashid)   (cnt * 32 | (hashid + 1))
#define HASHIDFROMGUIDATOM(atom)    ((atom & 0x1f) - 1)
#define IDFROMGUIDATOM(atom)        (atom / 32)

typedef enum { CAT_FORWARD  = 0x0,
               CAT_BACKWARD = 0x1
             } CATDIRECTION;

typedef struct tag_CATGUIDITEM {
    GUID guid;
    SHARED_GUID_ARRAY *rgGuidAry[2];
} CATGUIDITEM;

class CCatGUIDTbl
{
public:
    CCatGUIDTbl() {}
    ~CCatGUIDTbl() 
    { 
        for (int i = 0; i < CATGUID_HASHSIZE; i++)
        {
            if (_prgCatGUID[i])
            {
                int nCnt = _prgCatGUID[i]->Count();
                for (int j = 0; j < nCnt; j++)
                {
                    CATGUIDITEM *pItem = _prgCatGUID[i]->GetPtr(j);
                    SGA_Release(pItem->rgGuidAry[CAT_FORWARD]);
                    SGA_Release(pItem->rgGuidAry[CAT_BACKWARD]);
                }
                delete _prgCatGUID[i];
            }
        }
    }

    void FreeCatCache()
    { 
        for (int i = 0; i < CATGUID_HASHSIZE; i++)
        {
            if (_prgCatGUID[i])
            {
                int nCnt = _prgCatGUID[i]->Count();
                for (int j = 0; j < nCnt; j++)
                {
                    CATGUIDITEM *pItem = _prgCatGUID[i]->GetPtr(j);
                    SGA_Release(pItem->rgGuidAry[CAT_FORWARD]);
                    SGA_Release(pItem->rgGuidAry[CAT_BACKWARD]);
                    pItem->rgGuidAry[CAT_FORWARD] = NULL;
                    pItem->rgGuidAry[CAT_BACKWARD] = NULL;
                }
            }
        }
    }

    TfGuidAtom Add(REFGUID rguid);
    TfGuidAtom FindGuid(REFGUID rguid);
    CATGUIDITEM *GetGUID(TfGuidAtom atom);

private:
    UINT _HashFunc(REFGUID rguid) 
    { 
        return (DWORD)rguid.Data1 % CATGUID_HASHSIZE;
    }

    CStructArray<CATGUIDITEM> *_prgCatGUID[CATGUID_HASHSIZE];
};

//////////////////////////////////////////////////////////////////////////////
//
// CCategoryMgr
//
//////////////////////////////////////////////////////////////////////////////

// perf: this class doesn't really need CComObjectRootImmx, it is stateless

class CCategoryMgr : 
      public ITfCategoryMgr,
      public CComObjectRoot_CreateInstance<CCategoryMgr>
{
public:
    CCategoryMgr();
    ~CCategoryMgr();

    BEGIN_COM_MAP_IMMX(CCategoryMgr)
        COM_INTERFACE_ENTRY(ITfCategoryMgr)
    END_COM_MAP_IMMX()

    //
    // ITfCategoryMgr
    //
    STDMETHODIMP RegisterCategory(REFCLSID rclsid, REFGUID rcatid, REFGUID rguid);
    STDMETHODIMP UnregisterCategory(REFCLSID rclsid, REFGUID rcatid, REFGUID rguid);
    STDMETHODIMP EnumCategoriesInItem(REFGUID rguid, IEnumGUID **ppEnum);
    STDMETHODIMP EnumItemsInCategory(REFGUID rcatid, IEnumGUID **ppEnum);
    STDMETHODIMP FindClosestCategory(REFGUID rguid, GUID *pcatid, const GUID **ppcatidList, ULONG ulCount);
    STDMETHODIMP RegisterGUIDDescription(REFCLSID rclsid, REFGUID rguid, const WCHAR *pchDesc, ULONG cch);
    STDMETHODIMP UnregisterGUIDDescription(REFCLSID rclsid, REFGUID rguid);
    STDMETHODIMP GetGUIDDescription(REFGUID rguid, BSTR *pbstrDesc);
    STDMETHODIMP RegisterGUIDDWORD(REFCLSID rclsid, REFGUID rguid, DWORD dw);
    STDMETHODIMP UnregisterGUIDDWORD(REFCLSID rclsid, REFGUID rguid);
    STDMETHODIMP GetGUIDDWORD(REFGUID rguid, DWORD *pdw);
    STDMETHODIMP RegisterGUID(REFGUID rguid, TfGuidAtom *pguidatom);
    STDMETHODIMP GetGUID(TfGuidAtom guidatom, GUID *pguid);
    STDMETHODIMP IsEqualTfGuidAtom(TfGuidAtom guidatom, REFGUID rguid, BOOL *pfEqual);

    static BOOL InitGlobal();
    static BOOL s_IsValidGUIDATOM(TfGuidAtom guidatom)
    {
        if (!_pCatGUIDTbl)
            return FALSE;

        return _pCatGUIDTbl->GetGUID(guidatom) ? TRUE : FALSE;
    }

    static void UninitGlobal()
    {
        if (_pCatGUIDTbl)
            delete _pCatGUIDTbl;
        _pCatGUIDTbl = NULL;
    }

    static void FreeCatCache()
    {
        CicEnterCriticalSection(g_cs);

        if (_pCatGUIDTbl)
            _pCatGUIDTbl->FreeCatCache();

        CicLeaveCriticalSection(g_cs);
    }

    static HRESULT s_RegisterCategory(REFCLSID rclsid, REFGUID rcatid, REFGUID rguid);
    static HRESULT s_UnregisterCategory(REFCLSID rclsid, REFGUID rcatid, REFGUID rguid);
    static HRESULT s_EnumCategoriesInItem(REFGUID rguid, IEnumGUID **ppEnum);
    static HRESULT s_EnumItemsInCategory(REFGUID rcatid, IEnumGUID **ppEnum);
    static HRESULT s_RegisterGUID(REFGUID rguid, TfGuidAtom *pguidatom);
    static HRESULT s_GetGUID(TfGuidAtom guidatom, GUID *pguid);
    static HRESULT s_IsEqualTfGuidAtom(TfGuidAtom guidatom, REFGUID rguid, BOOL *pfEqual);
    static HRESULT s_FindClosestCategory(REFGUID rguid, GUID *pcatid, const GUID **ppcatidList, ULONG ulCount);

    static HRESULT s_RegisterGUIDDescription(REFCLSID rclsid, REFGUID rguid, WCHAR *pszDesc);
    static HRESULT s_UnregisterGUIDDescription(REFCLSID rclsid, REFGUID rguid);
    static HRESULT s_GetGUIDDescription(REFGUID rguid, BSTR *pbstrDesc);
    static HRESULT s_GetGUIDValue(REFGUID rguid, const WCHAR* pszValue, BSTR *pbstrDesc);
    static HRESULT s_RegisterGUIDDWORD(REFCLSID rclsid, REFGUID rguid, DWORD dw);
    static HRESULT s_UnregisterGUIDDWORD(REFCLSID rclsid, REFGUID rguid);
    static HRESULT s_GetGUIDDWORD(REFGUID rguid, DWORD *pdw);

    static CCatGUIDTbl *_pCatGUIDTbl;
private:

    static HRESULT _InternalRegisterCategory(REFCLSID rclsid, REFGUID rcatid, REFGUID rguid, CATDIRECTION catdir);
    static HRESULT _InternalUnregisterCategory(REFCLSID rclsid, REFGUID rcatid, REFGUID rguid, CATDIRECTION catdir);
    static HRESULT _InternalEnumCategories(REFGUID rguid, IEnumGUID **ppEnum, CATDIRECTION catdir);

    static HRESULT _InternalFindClosestCategory(REFGUID rguidOrg, REFGUID rguid, GUID *pcatid, const GUID **ppcatidList, ULONG ulCount);
    static HRESULT _GetFirstCategory(REFGUID rguid, GUID *pcatid);

    static void _FlushGuidArrayCache(REFGUID rguid, CATDIRECTION catdir);

    DBG_ID_DECLARE;
};


//////////////////////////////////////////////////////////////////////////////
//
// CEnumCategories
//
//////////////////////////////////////////////////////////////////////////////

class CEnumCategories : public CEnumGuid
{
public:
    CEnumCategories();
    BOOL _Init(REFGUID rcatid, CATDIRECTION catdir);
    DBG_ID_DECLARE;
};


#endif // CATMGR_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\ctf\uim\compart.cpp ===
//
// compart.cpp
//


#include "private.h"
#include "globals.h"
#include "regsvr.h"
#include "compart.h"
#include "helpers.h"
#include "thdutil.h"
#include "tim.h"
#include "cicmutex.h"
#include "timlist.h"
#include "cregkey.h"

/* e575186e-71a8-4ef4-90da-14ed705e7df2 */
extern const IID IID_PRIV_CCOMPARTMENTMGR = {
    0xe575186e,
    0x71a8,
    0x4ef4,
    {0x90, 0xda, 0x14, 0xed, 0x70, 0x5e, 0x7d, 0xf2}
  };

/* 8b05c1ad-adf0-4a78-a3e2-d38cae3e28be */
extern const IID IID_PRIV_CGLOBALCOMPARTMENT = {
    0x8b05c1ad,
    0xadf0,
    0x4a78,
    {0xa3, 0xe2, 0xd3, 0x8c, 0xae, 0x3e, 0x28, 0xbe}
  };


DBG_ID_INSTANCE(CCompartment);
DBG_ID_INSTANCE(CCompartmentMgr);
DBG_ID_INSTANCE(CEnumCompartment);
DBG_ID_INSTANCE(CGlobalCompartment);

extern CCicMutex g_mutexCompart;

//+---------------------------------------------------------------------------
//
// EnsureGlobalCompartment
//
//----------------------------------------------------------------------------

BOOL EnsureGlobalCompartment(SYSTHREAD *psfn)
{
    if (psfn->_pGlobalCompMgr)
        return TRUE;

    psfn->_pGlobalCompMgr = new CGlobalCompartmentMgr(g_gaApp);

    if (psfn->_pGlobalCompMgr)
    {
        if (g_gcomplist.Init(psfn))
            return TRUE;

        delete psfn->_pGlobalCompMgr;
        psfn->_pGlobalCompMgr = NULL;
    }
    return FALSE;
}

//+---------------------------------------------------------------------------
//
//  GetCompartmentDWORD
//
//----------------------------------------------------------------------------

HRESULT MyGetCompartmentDWORD(CCompartmentMgr *pCompMgr, REFGUID rguid, DWORD *pdw)
{
    HRESULT hr;
    ITfCompartment *pComp;
    VARIANT var;

    if (!pCompMgr)
        return E_FAIL;

    *pdw = 0;
    if (SUCCEEDED(hr = pCompMgr->GetCompartment(rguid, &pComp)))
    {
        hr = pComp->GetValue(&var);
        if (hr == S_OK)
        {
            Assert(var.vt == VT_I4);
            *pdw = var.lVal;
            // no need to VariantClear because VT_I4
        }
        
        pComp->Release();
    }

    return hr;
}

//+---------------------------------------------------------------------------
//
//  SetCompartmentDWORD
//
//----------------------------------------------------------------------------

HRESULT MySetCompartmentDWORD(TfClientId tid, CCompartmentMgr *pCompMgr, REFGUID rguid, DWORD dw)
{
    HRESULT hr;
    ITfCompartment *pComp;
    VARIANT var;

    if (!pCompMgr)
        return E_FAIL;

    if (SUCCEEDED(hr = pCompMgr->GetCompartment(rguid, &pComp)))
    {
        var.vt = VT_I4;
        var.lVal = dw;
        hr = pComp->SetValue(tid, &var);
        pComp->Release();
    }

    return hr;
}

//+---------------------------------------------------------------------------
//
//  ToggleCompartmentDWORD
//
//  Toggle DWORD value between 0 and 1.
//
//----------------------------------------------------------------------------

HRESULT MyToggleCompartmentDWORD(TfClientId tid, CCompartmentMgr *pCompMgr, REFGUID rguid, DWORD *pdwOld)
{
    ITfCompartment *pComp;
    VARIANT var;
    DWORD dw = 0;
    HRESULT hr = E_FAIL;

    if (!pCompMgr)
        return E_FAIL;

    if (pCompMgr->GetCompartment(rguid, &pComp) == S_OK)
    {
        if (SUCCEEDED(pComp->GetValue(&var)))
        {
            if (var.vt == VT_EMPTY)
            {
                // compartment is uninitialized
                var.vt = VT_I4;
                var.lVal = 0;
            }
            else
            {
                Assert(var.vt == VT_I4);
            }

            var.lVal = (var.lVal == 0) ? 1 : 0;
            // no need to VariantClear because VT_I4

            if ((hr = pComp->SetValue(tid, &var)) == S_OK)
            {
                dw = var.lVal;
            }
        }

        pComp->Release();
    }

    if (pdwOld)
        *pdwOld = dw;

    return hr;
}

//////////////////////////////////////////////////////////////////////////////
//
// CCompartmentMgr
//
//////////////////////////////////////////////////////////////////////////////

//+---------------------------------------------------------------------------
//
// ctor
//
//----------------------------------------------------------------------------

CCompartmentMgr::CCompartmentMgr(TfClientId tidOwner, COMPTYPE cType)
{
    Dbg_MemSetThisNameIDCounter(TEXT("CCompartmentMgr"), PERF_COMPARTMGR_COUNTER);

    _tidOwner = tidOwner;
    _cType = cType;
}

//+---------------------------------------------------------------------------
//
// dtor
//
//----------------------------------------------------------------------------

CCompartmentMgr::~CCompartmentMgr()
{
    CleanUp();
}

//+---------------------------------------------------------------------------
//
// CleanUp
//
//----------------------------------------------------------------------------

void CCompartmentMgr::CleanUp()
{
    int nCnt = _rgCompartment.Count();
    int i;

    for (i = 0; i < nCnt; i++)
    {
        CCompartmentBase *pComp = _rgCompartment.Get(i);
        pComp->Invalid();
        pComp->Release();
    }
    _rgCompartment.Clear();
}

//+---------------------------------------------------------------------------
//
// GetCompartment
//
//----------------------------------------------------------------------------

STDAPI CCompartmentMgr::GetCompartment(REFGUID rguid, ITfCompartment **ppcomp)
{
    CCompartmentBase *pComp;

    if (!ppcomp)
        return E_INVALIDARG;

    *ppcomp = NULL;

    pComp = _Get(rguid);
    if (!pComp)
        return E_OUTOFMEMORY;

    *ppcomp = pComp;
    pComp->AddRef();

    return S_OK;
}

//+---------------------------------------------------------------------------
//
// ClearCompartment
//
//----------------------------------------------------------------------------

STDAPI CCompartmentMgr::ClearCompartment(TfClientId tid, REFGUID rguid)
{
    TfGuidAtom guidatom;
    CCompartmentBase *pComp;
    int iInsert;
    HRESULT hr;

    if (FAILED(hr = MyRegisterGUID(rguid, &guidatom)))
        return hr;

    pComp = _Find(guidatom, &iInsert);

    if (!pComp)
        return CONNECT_E_NOCONNECTION;

    if (pComp->_GetAccess() & CA_ONLYOWNERSET)
    {
        if (_tidOwner != tid)
            return E_UNEXPECTED;
    }

    _rgCompartment.Remove(iInsert, 1);
    pComp->Invalid();
    pComp->Release();

    return S_OK;
}

//+---------------------------------------------------------------------------
//
// EnumCompartment
//
//----------------------------------------------------------------------------

STDAPI CCompartmentMgr::EnumCompartments(IEnumGUID **ppEnum)
{
    CEnumCompartment *pEnum;

    if (!ppEnum)
        return E_INVALIDARG;

    pEnum = new CEnumCompartment();

    if (!pEnum)
        return E_OUTOFMEMORY;

    if (pEnum->_Init(&_rgCompartment))
        *ppEnum = pEnum;
    else
        SafeReleaseClear(pEnum);

    return pEnum ? S_OK : E_FAIL;
}

//+---------------------------------------------------------------------------
//
// _Find
//
//----------------------------------------------------------------------------

CCompartmentBase *CCompartmentMgr::_Find(TfGuidAtom guidatom, int *piOut)
{
    CCompartmentBase *pComp;
    CCompartmentBase *pCompMatch;
    int iMin;
    int iMax;
    int iMid;

    pCompMatch = NULL;
    iMid = -1;
    iMin = 0;
    iMax = _rgCompartment.Count();

    while (iMin < iMax)
    {
        iMid = (iMin + iMax) / 2;
        pComp = _rgCompartment.Get(iMid);
        Assert(pComp != NULL);

        if (guidatom < pComp->GetGuidAtom())
        {
            iMax = iMid;
        }
        else if (guidatom > pComp->GetGuidAtom())
        {
            iMin = iMid + 1;
        }
        else // guidatom == pComp->GetGuidAtom().
        {
            pCompMatch = pComp;
            break;
        }
    }

    if (!pCompMatch)
    {
        if (iMid >= 0)
        {
            CCompartmentBase *pCompTmp = _rgCompartment.Get(iMid);
            if (pCompTmp->GetGuidAtom() < guidatom)
            {
                iMid++;
            }
        }
    }

    if (piOut)
        *piOut = iMid;

    return pCompMatch;
}

//+---------------------------------------------------------------------------
//
// _Get
//
//----------------------------------------------------------------------------

CCompartmentBase *CCompartmentMgr::_Get(REFGUID rguid)
{
    CCompartmentBase *pComp;
    int iInsert;
    TfGuidAtom guidatom;

    if (FAILED(MyRegisterGUID(rguid, &guidatom)))
        return NULL;

    pComp = _Find(guidatom, &iInsert);

    if (!pComp)
    {
        TfPropertyType proptype = TF_PT_NONE;

        //
        // system predefined compartments does not allow any other type.
        //
        if ((IsEqualGUID(rguid, GUID_COMPARTMENT_KEYBOARD_DISABLED)) ||
            (IsEqualGUID(rguid, GUID_COMPARTMENT_HANDWRITING_OPENCLOSE)) ||
            (IsEqualGUID(rguid, GUID_COMPARTMENT_SPEECH_OPENCLOSE)))
        {
            proptype = TF_PT_DWORD;
        }

        if (_cType == COMPTYPE_GLOBAL)
            pComp = new CGlobalCompartment(this, rguid, guidatom, proptype);
        else
            pComp = new CCompartment(this, guidatom, proptype);
       
        if (pComp)
        {
            if (iInsert < 0)
                iInsert = 0;

            if (_rgCompartment.Insert(iInsert, 1))
            {
               _rgCompartment.Set(iInsert, pComp);
            }
            else
            {
                delete pComp;
                pComp = NULL;
            }
        }
    }

    return pComp;
}

//+---------------------------------------------------------------------------
//
// NotifyGlobalCompartmentChange
//
//----------------------------------------------------------------------------

void CCompartmentMgr::NotifyGlobalCompartmentChange(DWORD dwId)
{
    Assert(_cType == COMPTYPE_GLOBAL);

    int nCnt = _rgCompartment.Count();

    for (int i = 0; i < nCnt; i++)
    {
        CCompartmentBase *pComp = _rgCompartment.Get(i);
        if (dwId == pComp->GetId())
        {
            pComp->MakeNotify();
            break;
        }
    }
}

//////////////////////////////////////////////////////////////////////////////
//
// CGlobalCompartmenMgr
//
//////////////////////////////////////////////////////////////////////////////

STDAPI CGlobalCompartmentMgr::QueryInterface(REFIID riid, void **ppvObj)
{
    *ppvObj = NULL;

    if (IsEqualIID(riid, IID_IUnknown) ||
        IsEqualIID(riid, IID_ITfCompartmentMgr))
    {
        *ppvObj = SAFECAST(this, ITfCompartmentMgr *);
    }

    if (*ppvObj)
    {
        return S_OK;
    }

    return E_NOINTERFACE;
    
}

ULONG CGlobalCompartmentMgr::AddRef(void)
{
    _cRef++;
    return _cRef;
}

ULONG CGlobalCompartmentMgr::Release(void)
{
    _cRef--;
    if (_cRef <= 0)
    {
        //
        // Calller may call Release() more than AddRef()..
        // We should not call TIM::Release() at this time.
        //
        Assert(0)

        return 0;
    }

    return _cRef;
}

//////////////////////////////////////////////////////////////////////////////
//
// CEnumCompartment
//
//////////////////////////////////////////////////////////////////////////////

//+---------------------------------------------------------------------------
//
// ctor
//
//----------------------------------------------------------------------------

CEnumCompartment::CEnumCompartment()
{
    Dbg_MemSetThisNameIDCounter(TEXT("CEnumCompartment"), PERF_ENUMCOMPART_COUNTER);
}

//+---------------------------------------------------------------------------
//
// Init
//
//----------------------------------------------------------------------------

BOOL CEnumCompartment::_Init(CPtrArray<CCompartmentBase> *prgComp)
{
    int nCnt = prgComp->Count();
    int i;
    BOOL fRet = FALSE;

    CicEnterCriticalSection(g_cs);

    _pga = SGA_Init(nCnt, NULL);

    if (_pga == NULL)
        goto Exit;

    for (i = 0; i < nCnt; i++)
    {
        CCompartmentBase *pComp = prgComp->Get(i);

        if (FAILED((MyGetGUID(pComp->GetGuidAtom(), &_pga->rgGuid[i]))))
            goto Exit;
    }

    fRet = TRUE;

Exit:
    CicLeaveCriticalSection(g_cs);
    return fRet;
}

//////////////////////////////////////////////////////////////////////////////
//
// CCompartmentBase
//
//////////////////////////////////////////////////////////////////////////////

const COMPARTMENTACCESS CCompartmentBase::_c_ca[] = {
    {&GUID_COMPARTMENT_KEYBOARD_DISABLED,    CA_ONLYOWNERSET},
    {NULL, 0}
};
CCompartmentBase::CCompartmentBase(CCompartmentMgr *pCompMgr, TfGuidAtom guidatom, TfPropertyType proptype)
{
    Assert(!_fInvalid);

    _guidatom = guidatom;
    _proptype = proptype;
    _pCompMgr = pCompMgr;

    int n = 0;
    while (_c_ca[n].pguid)
    {
        if (MyIsEqualTfGuidAtom(guidatom,  *_c_ca[n].pguid))
        {
            _dwAccess =  _c_ca[n].dwAccess;
        }
        n++;
    }
}


//////////////////////////////////////////////////////////////////////////////
//
// CCompartment
//
//////////////////////////////////////////////////////////////////////////////

//+---------------------------------------------------------------------------
//
// ctor
//
//----------------------------------------------------------------------------

CCompartment::CCompartment(CCompartmentMgr *pCompMgr, TfGuidAtom guidatom, TfPropertyType proptype)
             :CCompartmentBase(pCompMgr, guidatom, proptype)
{
    Dbg_MemSetThisNameIDCounter(TEXT("CCompartment"), PERF_COMPART_COUNTER);
}

//+---------------------------------------------------------------------------
//
// dtor
//
//----------------------------------------------------------------------------

CCompartment::~CCompartment()
{
    if (_prop.type == TF_PT_UNKNOWN)
    {
        //
        // #489905
        //
        // we can not call sink anymore after DLL_PROCESS_DETACH.
        //
        if (!DllShutdownInProgress())
            _prop.punk->Release();
    }
    else if (_prop.type == TF_PT_BSTR)
        SysFreeString(_prop.bstr);
}

//+---------------------------------------------------------------------------
//
// Advise
//
//----------------------------------------------------------------------------

HRESULT CCompartment::AdviseSink(REFIID riid, IUnknown *punk, DWORD *pdwCookie)
{
    const IID *rgiid;

    rgiid = &IID_ITfCompartmentEventSink;

    return GenericAdviseSink(riid, 
                             punk, 
                             &rgiid, 
                             &_rgCompartmentSink, 
                             1, 
                             pdwCookie);
}

//+---------------------------------------------------------------------------
//
// Unadvise
//
//----------------------------------------------------------------------------

HRESULT CCompartment::UnadviseSink(DWORD dwCookie)
{
    return GenericUnadviseSink(&_rgCompartmentSink, 1, dwCookie);
}

//+---------------------------------------------------------------------------
//
// GetValue
//
//----------------------------------------------------------------------------

HRESULT CCompartment::GetValue(VARIANT *pvarValue)
{
    HRESULT hr;

    if (_fInvalid)
    {
        Assert(0);
        return E_UNEXPECTED;
    }

    if (pvarValue == NULL)
        return E_INVALIDARG;

    QuickVariantInit(pvarValue);

    hr = TfPropToVariant(pvarValue, &_prop, ADDREF);

    if (hr != S_OK)
        return hr;

    return (pvarValue->vt == VT_EMPTY) ? S_FALSE : S_OK;
}

//+---------------------------------------------------------------------------
//
// SetValue
//
//----------------------------------------------------------------------------

HRESULT CCompartment::SetValue(TfClientId tid, const VARIANT *pvarValue)
{
    HRESULT hr;

    if (_fInvalid)
    {
        Assert(0);
        return E_UNEXPECTED;
    }

    if (_fInSet)
        return E_UNEXPECTED;

    if (pvarValue == NULL)
        return E_INVALIDARG;

    if (!IsValidCiceroVarType(pvarValue->vt))
        return E_INVALIDARG;

    if (pvarValue->vt == VT_EMPTY)
        return E_INVALIDARG;

    if (_GetAccess() & CA_ONLYOWNERSET)
    {
        if (_GetMgr()->_GetTIPOwner() != tid)
            return E_UNEXPECTED;
    }

    hr = VariantToTfProp(&_prop, pvarValue, ADDREF, FALSE);

    if (hr != S_OK)
        return hr;

    int i;
    int nCnt = _rgCompartmentSink.Count(); 
    if (nCnt)
    {
        GUID guid;
        if (FAILED(MyGetGUID(_guidatom, &guid)))
        {
            return E_FAIL;
            Assert(0);
        }

        _fInSet = TRUE;
        for (i = 0; i < nCnt; i++)
        {
            ((ITfCompartmentEventSink *)_rgCompartmentSink.GetPtr(i)->pSink)->OnChange(guid);
        }
        _fInSet = FALSE;
    }

    return S_OK;     
}

//////////////////////////////////////////////////////////////////////////////
//
// CGlobalCompartment
//
//////////////////////////////////////////////////////////////////////////////

//+---------------------------------------------------------------------------
//
// ctor
//
//----------------------------------------------------------------------------

CGlobalCompartment::CGlobalCompartment(CCompartmentMgr *pCompMgr, REFGUID rguid, TfGuidAtom guidatom, TfPropertyType proptype)
                   :CCompartmentBase(pCompMgr, guidatom, proptype)
{
    Dbg_MemSetThisNameIDCounter(TEXT("CGlobalCompartment"), PERF_GLOBCOMPART_COUNTER);
    _dwId = (DWORD)(-1);
    _guidCompart = rguid;
}

//+---------------------------------------------------------------------------
//
// dtor
//
//----------------------------------------------------------------------------

CGlobalCompartment::~CGlobalCompartment()
{
}

//+---------------------------------------------------------------------------
//
// Advise
//
//----------------------------------------------------------------------------

HRESULT CGlobalCompartment::AdviseSink(REFIID riid, IUnknown *punk, DWORD *pdwCookie)
{
    const IID *rgiid;

    if (_dwId == (DWORD)(-1))
    {
        _dwId = g_gcomplist.GetId(_guidCompart);
        if (_dwId == (DWORD)(-1))
        {
            TFPROPERTY prop;
            memset(&prop, 0, sizeof(prop));
            _dwId = g_gcomplist.SetProperty(_guidCompart, &prop);
            if (_dwId == (DWORD)(-1))
                return E_FAIL;
        }
    }

    rgiid = &IID_ITfCompartmentEventSink;

    return GenericAdviseSink(riid, 
                             punk, 
                             &rgiid, 
                             &_rgCompartmentSink, 
                             1, 
                             pdwCookie);
}

//+---------------------------------------------------------------------------
//
// Unadvise
//
//----------------------------------------------------------------------------

HRESULT CGlobalCompartment::UnadviseSink(DWORD dwCookie)
{
    return GenericUnadviseSink(&_rgCompartmentSink, 1, dwCookie);
}

//+---------------------------------------------------------------------------
//
// GetValue
//
//----------------------------------------------------------------------------

HRESULT CGlobalCompartment::GetValue(VARIANT *pvarValue)
{
    HRESULT hr;
    TFPROPERTY prop;

    if (_fInvalid)
    {
        Assert(0);
        return E_UNEXPECTED;
    }

    if (pvarValue == NULL)
        return E_INVALIDARG;

    QuickVariantInit(pvarValue);

    if (_dwId == (DWORD)(-1))
    {
        _dwId = g_gcomplist.GetId(_guidCompart);
    }

    memset(&prop, 0, sizeof(TFPROPERTY));
    if (_dwId != (DWORD)(-1))
        g_gcomplist.GetProperty(_guidCompart, &prop);
       

    Assert(prop.type != TF_PT_UNKNOWN);

    hr = TfPropToVariant(pvarValue, &prop, ADDREF);

    if (hr != S_OK)
        return hr;

    return (pvarValue->vt == VT_EMPTY) ? S_FALSE : S_OK;
}

//+---------------------------------------------------------------------------
//
// SetValue
//
//----------------------------------------------------------------------------

HRESULT CGlobalCompartment::SetValue(TfClientId tid, const VARIANT *pvarValue)
{
    HRESULT hr;
    TFPROPERTY prop;

    if (_fInvalid)
    {
        Assert(0);
        return E_UNEXPECTED;
    }

    if (_fInSet)
        return E_UNEXPECTED;

    if (pvarValue == NULL)
        return E_INVALIDARG;

    if (!IsValidCiceroVarType(pvarValue->vt))
        return E_INVALIDARG;

    if (_GetAccess() & CA_ONLYOWNERSET)
    {
        if (_GetMgr()->_GetTIPOwner() != tid)
            return E_UNEXPECTED;
    }

    if (pvarValue->vt == VT_UNKNOWN)
    {
        Assert(0);
        return E_INVALIDARG;
    }

    hr = VariantToTfProp(&prop, pvarValue, NO_ADDREF, FALSE);

    if (hr != S_OK)
        return hr;

    _dwId = g_gcomplist.SetProperty(_guidCompart, &prop);
    if (_dwId == (DWORD)(-1))
        return E_FAIL;

    hr = (prop.type != TF_PT_NONE) ? S_OK : E_FAIL;

    if (SUCCEEDED(hr))
    {
        //
        // make a notify to the sinks of the current thread.
        //
        if (!MakeNotify())
            return E_FAIL;
        PostTimListMessage(TLF_GCOMPACTIVE,
                           0, 
                           g_msgPrivate, 
                           TFPRIV_GLOBALCOMPARTMENTSYNC,
                           _dwId);

    }

    return hr;     
}

//+---------------------------------------------------------------------------
//
// EnumThreadProc
//
//----------------------------------------------------------------------------

BOOL CGlobalCompartment::EnumThreadProc(DWORD dwThreadId, DWORD dwProcessId, void *pv)
{
    if (dwThreadId != GetCurrentThreadId())
    {
        CGlobalCompartment *_this = (CGlobalCompartment *)pv;

        PostThreadMessage(dwThreadId, 
                          g_msgPrivate, 
                          TFPRIV_GLOBALCOMPARTMENTSYNC,
                          _this->_dwId);
    }
    return FALSE;
}

//+---------------------------------------------------------------------------
//
// MakeNotify
//
//----------------------------------------------------------------------------

BOOL CGlobalCompartment::MakeNotify()
{
    int i;
    int nCnt = _rgCompartmentSink.Count(); 
    if (nCnt)
    {
        GUID guid;
        if (FAILED(MyGetGUID(_guidatom, &guid)))
        {
            Assert(0);
            return FALSE;
        }

        _fInSet = TRUE;
        for (i = 0; i < nCnt; i++)
        {
            ((ITfCompartmentEventSink *)_rgCompartmentSink.GetPtr(i)->pSink)->OnChange(guid);
        }
        _fInSet = FALSE;
    }

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\ctf\uim\compose.cpp ===
//
// compose.cpp
//

#include "private.h"
#include "compose.h"
#include "ic.h"
#include "range.h"
#include "globals.h"
#include "immxutil.h"
#include "sunka.h"

//////////////////////////////////////////////////////////////////////////////
//
// CEnumCompositionView
//
//////////////////////////////////////////////////////////////////////////////

class CEnumCompositionView : public IEnumITfCompositionView,
                             public CEnumUnknown,
                             public CComObjectRootImmx
{
public:
    CEnumCompositionView()
    { 
        Dbg_MemSetThisNameID(TEXT("CEnumCompositionView"));
    }

    BOOL _Init(CComposition *pFirst, CComposition *pHalt);

    BEGIN_COM_MAP_IMMX(CEnumCompositionView)
        COM_INTERFACE_ENTRY(IEnumITfCompositionView)
    END_COM_MAP_IMMX()

    IMMX_OBJECT_IUNKNOWN_FOR_ATL()

    DECLARE_SUNKA_ENUM(IEnumITfCompositionView, CEnumCompositionView, ITfCompositionView)

private:
    DBG_ID_DECLARE;
};

DBG_ID_INSTANCE(CEnumCompositionView);

//+---------------------------------------------------------------------------
//
// _Init
//
//----------------------------------------------------------------------------

BOOL CEnumCompositionView::_Init(CComposition *pFirst, CComposition *pHalt)
{
    CComposition *pComposition;
    ULONG i;
    ULONG cViews;

    Assert(pFirst != NULL || pHalt == NULL);

    cViews = 0;

    // get count
    for (pComposition = pFirst; pComposition != pHalt; pComposition = pComposition->_GetNext())
    {
        cViews++;
    }

    if ((_prgUnk = SUA_Alloc(cViews)) == NULL)
        return FALSE;

    _iCur = 0;
    _prgUnk->cRef = 1;
    _prgUnk->cUnk = cViews;

    for (i=0, pComposition = pFirst; pComposition != pHalt; i++, pComposition = pComposition->_GetNext())
    {
        _prgUnk->rgUnk[i] = (ITfCompositionView *)pComposition;
        _prgUnk->rgUnk[i]->AddRef();
    }

    return TRUE;
}

//////////////////////////////////////////////////////////////////////////////
//
// CComposition
//
//////////////////////////////////////////////////////////////////////////////

/* 3ab2f54c-5357-4759-82c1-bbfe73f44dcc */
const IID IID_PRIV_CCOMPOSITION = { 0x3ab2f54c, 0x5357, 0x4759, {0x82, 0xc1, 0xbb, 0xfe, 0x73, 0xf4, 0x4d, 0xcc} };

inline CComposition *GetCComposition_NA(IUnknown *punk)
{
    CComposition *pComposition;

    if (punk->QueryInterface(IID_PRIV_CCOMPOSITION, (void **)&pComposition) != S_OK || pComposition == NULL)
        return NULL;

    pComposition->Release();

    return pComposition;
}

DBG_ID_INSTANCE(CComposition);

//+---------------------------------------------------------------------------
//
// _Init
//
//----------------------------------------------------------------------------

BOOL CComposition::_Init(TfClientId tid, CInputContext *pic, IAnchor *paStart, IAnchor *paEnd, ITfCompositionSink *pSink)
{
    Assert(_paStart == NULL);
    Assert(_paEnd == NULL);

    if (paStart->Clone(&_paStart) != S_OK || _paStart == NULL)
    {
        _paStart = NULL;
        goto ExitError;
    }
    if (paEnd->Clone(&_paEnd) != S_OK || _paEnd == NULL)
    {
        _paEnd = NULL;
        goto ExitError;
    }

    _tid = tid;

    _pic = pic;
    _pic->AddRef();

    _pSink = pSink;
    if (_pSink)
    {
        _pSink->AddRef();
    }

    return TRUE;

ExitError:
    SafeReleaseClear(_paStart);
    SafeReleaseClear(_paEnd);

    return FALSE;
}

//+---------------------------------------------------------------------------
//
// _Uninit
//
//----------------------------------------------------------------------------

void CComposition::_Uninit()
{
    SafeReleaseClear(_pSink);
    SafeReleaseClear(_pic);
    SafeReleaseClear(_paStart);
    SafeReleaseClear(_paEnd);
}

//+---------------------------------------------------------------------------
//
// GetOwnerClsid
//
//----------------------------------------------------------------------------

STDAPI CComposition::GetOwnerClsid(CLSID *pclsid)
{
    if (pclsid == NULL)
        return E_INVALIDARG;

    if (_IsTerminated())
    {
        memset(pclsid, 0, sizeof(*pclsid));
        return E_UNEXPECTED;
    }

    return (MyGetGUID(_tid, pclsid) == S_OK ? S_OK : E_FAIL);
}

//+---------------------------------------------------------------------------
//
// GetRange
//
//----------------------------------------------------------------------------

STDAPI CComposition::GetRange(ITfRange **ppRange)
{
    CRange *range;

    if (ppRange == NULL)
        return E_INVALIDARG;

    *ppRange = NULL;

    if (_IsTerminated())
        return E_UNEXPECTED;

    if ((range = new CRange) == NULL)
        return E_OUTOFMEMORY;

    if (!range->_InitWithDefaultGravity(_pic, COPY_ANCHORS, _paStart, _paEnd))
    {
        range->Release();
        return E_FAIL;
    }

    *ppRange = (ITfRangeAnchor *)range;

    return S_OK;
}

//+---------------------------------------------------------------------------
//
// ShiftStart
//
//----------------------------------------------------------------------------

STDAPI CComposition::ShiftStart(TfEditCookie ec, ITfRange *pNewStart)
{
    CRange *rangeNewStart;
    CRange *range;
    IAnchor *paStartNew;
    IAnchor *paClearStart;
    IAnchor *paClearEnd;

    if (_IsTerminated())
        return E_UNEXPECTED;

    if (!_pic->_IsValidEditCookie(ec, TF_ES_READWRITE))
    {
        Assert(0);
        return TF_E_NOLOCK;
    }

    if ((rangeNewStart = GetCRange_NA(pNewStart)) == NULL)
        return E_INVALIDARG;

    if (!VerifySameContext(_pic, rangeNewStart))
        return E_INVALIDARG;

    paStartNew = rangeNewStart->_GetStart();

    if (CompareAnchors(paStartNew, _paStart) <= 0)
    {
        paClearStart = paStartNew;
        paClearEnd = _paStart;

        // Set GUID_PROP_COMPOSING
        _SetComposing(ec, paClearStart, paClearEnd);
    }
    else
    {
        paClearStart = _paStart;
        paClearEnd = paStartNew;

        // check for crossed anchors
        if (CompareAnchors(_paEnd, paStartNew) < 0)
            return E_INVALIDARG;

        // clear GUID_PROP_COMPOSING
        _ClearComposing(ec, paClearStart, paClearEnd);
    }


    if (_pic->_GetOwnerCompositionSink() != NULL)
    {
        // notify the app
        if (range = new CRange)
        {
            // make sure the end anchor is positioned correctly
            if (range->_InitWithDefaultGravity(_pic, COPY_ANCHORS, paStartNew, _paEnd))
            {
                _pic->_GetOwnerCompositionSink()->OnUpdateComposition(this, (ITfRangeAnchor *)range);
            }
            range->Release();
        }
    }

    if (_paStart->ShiftTo(paStartNew) != S_OK)
        return E_FAIL;

    return S_OK;        
}

//+---------------------------------------------------------------------------
//
// ShiftEnd
//
//----------------------------------------------------------------------------

STDAPI CComposition::ShiftEnd(TfEditCookie ec, ITfRange *pNewEnd)
{
    CRange *rangeNewEnd;
    CRange *range;
    IAnchor *paEndNew;
    IAnchor *paClearStart;
    IAnchor *paClearEnd;

    if (_IsTerminated())
        return E_UNEXPECTED;

    if (!_pic->_IsValidEditCookie(ec, TF_ES_READWRITE))
    {
        Assert(0);
        return TF_E_NOLOCK;
    }

    if ((rangeNewEnd = GetCRange_NA(pNewEnd)) == NULL)
        return E_INVALIDARG;

    if (!VerifySameContext(_pic, rangeNewEnd))
        return E_INVALIDARG;

    paEndNew = rangeNewEnd->_GetEnd();

    if (CompareAnchors(paEndNew, _paEnd) >= 0)
    {
        paClearStart = _paEnd;
        paClearEnd = paEndNew;

        // Set GUID_PROP_COMPOSING
        _SetComposing(ec, paClearStart, paClearEnd);
    }
    else
    {
        paClearStart = paEndNew;
        paClearEnd = _paEnd;

        // check for crossed anchors
        if (CompareAnchors(_paStart, paEndNew) > 0)
            return E_INVALIDARG;

        // clear GUID_PROP_COMPOSING
        _ClearComposing(ec, paClearStart, paClearEnd);

    }

    // notify the app
    if (_pic->_GetOwnerCompositionSink() != NULL)
    {
        if (range = new CRange)
        {
            // make sure the end anchor is positioned correctly
            if (range->_InitWithDefaultGravity(_pic, COPY_ANCHORS, _paStart, paEndNew))
            {
                _pic->_GetOwnerCompositionSink()->OnUpdateComposition(this, (ITfRangeAnchor *)range);
            }
            range->Release();
        }
    }

    if (_paEnd->ShiftTo(paEndNew) != S_OK)
        return E_FAIL;

    return S_OK;        
}

//+---------------------------------------------------------------------------
//
// EndComposition
//
// Called by the TIP.
//----------------------------------------------------------------------------

STDAPI CComposition::EndComposition(TfEditCookie ec)
{
    if (_IsTerminated())
        return E_UNEXPECTED;

    if (!_pic->_IsValidEditCookie(ec, TF_ES_READWRITE))
    {
        Assert(0);
        return TF_E_NOLOCK;
    }

    if (_tid != _pic->_GetClientInEditSession(ec))
    {
        Assert(0); // caller doesn't own the composition
        return E_UNEXPECTED;
    }

    if (!_pic->_EnterCompositionOp())
        return E_UNEXPECTED; // reentrant with another write op

    // notify the app
    if (_pic->_GetOwnerCompositionSink() != NULL)
    {
        _pic->_GetOwnerCompositionSink()->OnEndComposition(this);
    }

    // take this guy off the list of compositions
    if (_RemoveFromCompositionList(_pic->_GetCompositionListPtr()))
    {
        // clear GUID_PROP_COMPOSING
        _ClearComposing(ec, _paStart, _paEnd);
    }
    else
    {
        Assert(0); // shouldn't get here
    }

    _pic->_LeaveCompositionOp();

    _Uninit();

    return S_OK;
}

//+---------------------------------------------------------------------------
//
// _Terminate
//
// Called by Cicero or the app.  Caller should already have removed this
// composition from _pCompositionList to catch reentrancy during notifications.
//----------------------------------------------------------------------------

void CComposition::_Terminate(TfEditCookie ec)
{
    // notify the tip
    _SendOnTerminated(ec, _tid);

    // #507778 OnCompositionTerminated() clear _pic by CComposition::_Uninit().
    if (_pic)
    {
        // notify the app
        if (_pic->_GetOwnerCompositionSink() != NULL)
        {
            _pic->_GetOwnerCompositionSink()->OnEndComposition(this);
        }
    }

    // clear GUID_PROP_COMPOSING
    _ClearComposing(ec, _paStart, _paEnd);

    // kill this composition!
    _Uninit();
}


//+---------------------------------------------------------------------------
//
// _SendOnTerminated
//
//----------------------------------------------------------------------------

void CComposition::_SendOnTerminated(TfEditCookie ec, TfClientId tidForEditSession)
{
    TfClientId tidTmp;

    // _pSink is NULL for default SetText compositions
    if (_pSink == NULL)
        return;

    if (tidForEditSession == _pic->_GetClientInEditSession(ec))
    {
        // we can skip all the exceptional stuff if all the edits
        // will belong to the current lock holder
        // this happens when a tip calls StartComposition for a
        // second composition and cicero needs to term the first
        _pSink->OnCompositionTerminated(ec, this);
    }
    else
    {
        // let everyone know about changes so far
        // the tip we're about to call may need this info
        _pic->_NotifyEndEdit();

        // play some games: this is an exceptional case where we may be allowing a
        // reentrant edit sess.  Need to hack the ec to reflect the composition owner.
        tidTmp = _pic->_SetRawClientInEditSession(tidForEditSession);

        // notify the tip
        _pSink->OnCompositionTerminated(ec, this);
        // #507778 OnCompositionTerminated() clear _pic by CComposition::_Uninit().
        if (! _pic)
            return;

        // let everyone know about changes the terminator made
        _pic->_NotifyEndEdit();

        // put things back the way we found them
        _pic->_SetRawClientInEditSession(tidTmp);
    }
}

//+---------------------------------------------------------------------------
//
// _AddToCompositionList
//
//----------------------------------------------------------------------------

void CComposition::_AddToCompositionList(CComposition **ppCompositionList)
{
    _next = *ppCompositionList;
    *ppCompositionList = this;
    AddRef();
}

//+---------------------------------------------------------------------------
//
// _RemoveFromCompositionList
//
//----------------------------------------------------------------------------

BOOL CComposition::_RemoveFromCompositionList(CComposition **ppCompositionList)
{
    CComposition *pComposition;

    // I don't expect many compositions, so this method uses a simple
    // scan.  We could do something more elaborate for perf if necessary.
    while (pComposition = *ppCompositionList)
    {
        if (pComposition == this)
        {
            *ppCompositionList = _next;
            Release(); // safe because caller already holds ref
            return TRUE;
        }
        ppCompositionList = &pComposition->_next;
    }

    return FALSE;
}

//+---------------------------------------------------------------------------
//
// _AddToCompositionList
//
//----------------------------------------------------------------------------

/* static */
IRC CComposition::_IsRangeCovered(CInputContext *pic, TfClientId tid,
                                  IAnchor *paStart, IAnchor *paEnd,
                                  CComposition **ppComposition /* not AddRef'd! */)
{
    CComposition *pComposition;
    IRC irc = IRC_NO_OWNEDCOMPOSITIONS;

    *ppComposition = NULL;

    for (pComposition = pic->_GetCompositionList(); pComposition != NULL; pComposition = pComposition->_next)
    {
        if (pComposition->_tid == tid)
        {
            irc = IRC_OUTSIDE;

            if (CompareAnchors(paStart, pComposition->_paStart) >= 0 &&
                CompareAnchors(paEnd, pComposition->_paEnd) <= 0)
            {
                *ppComposition = pComposition;
                irc = IRC_COVERED;
                break;
            }
        }
    }

    return irc;
}

//+---------------------------------------------------------------------------
//
// _ClearComposing
//
//----------------------------------------------------------------------------

void CComposition::_ClearComposing(TfEditCookie ec, IAnchor *paStart, IAnchor *paEnd)
{
    CProperty *property;

    Assert(!_IsTerminated());

    // #507778 OnCompositionTerminated() clear _pic by CComposition::_Uninit().
    if (! _pic)
        return;

    if (_pic->_GetProperty(GUID_PROP_COMPOSING, &property) != S_OK)
        return;

    property->_ClearInternal(ec, paStart, paEnd);

    property->Release();
}

//+---------------------------------------------------------------------------
//
// _SetComposing
//
//----------------------------------------------------------------------------

void CComposition::_SetComposing(TfEditCookie ec, IAnchor *paStart, IAnchor *paEnd)
{
    CProperty *property;

    if (IsEqualAnchor(paStart, paEnd))
        return;

    if (_pic->_GetProperty(GUID_PROP_COMPOSING, &property) == S_OK)
    {
        VARIANT var;
        var.vt = VT_I4;
        var.lVal = TRUE;

        property->_SetDataInternal(ec, paStart, paEnd, &var);

        property->Release();
    }
}

//////////////////////////////////////////////////////////////////////////////
//
// CInputContext
//
//////////////////////////////////////////////////////////////////////////////

//+---------------------------------------------------------------------------
//
// StartComposition
//
//----------------------------------------------------------------------------

STDAPI CInputContext::StartComposition(TfEditCookie ec, ITfRange *pCompositionRange,
                                       ITfCompositionSink *pSink, ITfComposition **ppComposition)
{
    CRange *range;
    CComposition *pComposition;
    HRESULT hr;

    if (ppComposition == NULL)
        return E_INVALIDARG;

    *ppComposition = NULL;

    if (pCompositionRange == NULL || pSink == NULL)
        return E_INVALIDARG;

    if ((range = GetCRange_NA(pCompositionRange)) == NULL)
        return E_INVALIDARG;

    if (!VerifySameContext(this, range))
        return E_INVALIDARG;

    if (!_IsConnected())
        return TF_E_DISCONNECTED;

    if (!_IsValidEditCookie(ec, TF_ES_READWRITE))
    {
        Assert(0);
        return TF_E_NOLOCK;
    }

    hr = _StartComposition(ec, range->_GetStart(), range->_GetEnd(), pSink, &pComposition);

    *ppComposition = pComposition;

    return hr;
}

//+---------------------------------------------------------------------------
//
// _StartComposition
//
// Internal, allow pSink to be NULL, skips verification tests.
//----------------------------------------------------------------------------

HRESULT CInputContext::_StartComposition(TfEditCookie ec, IAnchor *paStart, IAnchor *paEnd,
                                         ITfCompositionSink *pSink, CComposition **ppComposition)
{
    BOOL fOk;
    CComposition *pComposition;
    CComposition *pCompositionRef;
    CProperty *property;
    VARIANT var;
    HRESULT hr;

    *ppComposition = NULL;

    if (!_EnterCompositionOp())
        return E_UNEXPECTED; // reentrant with another write op

    hr = S_OK;

    if ((pComposition = new CComposition) == NULL)
    {
        hr = E_OUTOFMEMORY;
        goto Exit;
    }

    if (!pComposition->_Init(_GetClientInEditSession(ec), this, paStart, paEnd, pSink))
    {
        hr = E_FAIL;
        goto Exit;
    }

    //
    // AIMM1.2 expect multiple compositon object. SetText() without creating 
    // its own composition object should not clear out TIP's composition.
    //
    // cicero 1.0 -------
    // all of our clients only allow a single composition.  Let's enforce this behavior
    // to protect cicero 1.0 tips in the future.
    // kill any existing composition before starting a new one:
    // if (_pCompositionList != NULL)
    // {
    //     pCompositionRef = _pCompositionList;
    //     pCompositionRef->AddRef();
    //     _TerminateCompositionWithLock(pCompositionRef, ec);
    //     pCompositionRef->Release();
    //     Assert(_pCompositionList == NULL);
    // }
    // cicero 1.0 -------
    //

    if (_pOwnerComposeSink == NULL) // app may not care about compositions
    {
        fOk = TRUE;
    }
    else
    {
        if (_pOwnerComposeSink->OnStartComposition(pComposition, &fOk) != S_OK)
        {
            hr = E_FAIL;
            goto Exit;
        }

        if (!fOk)
        {
            if (_pCompositionList == NULL)
                goto Exit; // no current compositions, nothing else to try

            // terminate current composition and try again
            pCompositionRef = _pCompositionList; // only ref might be in list, so protect the obj
            pCompositionRef->AddRef();

            _TerminateCompositionWithLock(pCompositionRef, ec);

            pCompositionRef->Release();

            if (_pOwnerComposeSink->OnStartComposition(pComposition, &fOk) != S_OK)
            {
                hr = E_FAIL;
                goto Exit;
            }
           
            if (!fOk)
                goto Exit; // we give up
        }
    }

    // set composition property over existing text
    if (!IsEqualAnchor(paStart, paEnd) &&
        _GetProperty(GUID_PROP_COMPOSING, &property) == S_OK)
    {
        var.vt = VT_I4;
        var.lVal = TRUE;

        property->_SetDataInternal(ec, paStart, paEnd, &var);

        property->Release();
    }

    pComposition->_AddToCompositionList(&_pCompositionList);

    *ppComposition = pComposition;

Exit:
    if (hr != S_OK || !fOk)
    {
        SafeRelease(pComposition);
    }

    _LeaveCompositionOp();

    return hr;
}

//+---------------------------------------------------------------------------
//
// EnumCompositions
//
//----------------------------------------------------------------------------

STDAPI CInputContext::EnumCompositions(IEnumITfCompositionView **ppEnum)
{
    CEnumCompositionView *pEnum;

    if (ppEnum == NULL)
        return E_INVALIDARG;

    *ppEnum = NULL;

    if (!_IsConnected())
        return TF_E_DISCONNECTED;

    if ((pEnum = new CEnumCompositionView) == NULL)
        return E_OUTOFMEMORY;

    if (!pEnum->_Init(_pCompositionList, NULL))
    {
        pEnum->Release();
        return E_FAIL;
    }

    *ppEnum = pEnum;
    return S_OK;
}

//+---------------------------------------------------------------------------
//
// FindComposition
//
//----------------------------------------------------------------------------

STDAPI CInputContext::FindComposition(TfEditCookie ec, ITfRange *pTestRange,
                                      IEnumITfCompositionView **ppEnum)
{
    CComposition *pFirstComp;
    CComposition *pHaltComp;
    CRange *rangeTest;
    CEnumCompositionView *pEnum;

    if (ppEnum == NULL)
        return E_INVALIDARG;

    *ppEnum = NULL;

    if (!_IsConnected())
        return TF_E_DISCONNECTED;

    if (!_IsValidEditCookie(ec, TF_ES_READ))
    {
        Assert(0);
        return TF_E_NOLOCK;
    }

    if (pTestRange == NULL)
    {
        return EnumCompositions(ppEnum);
    }

    if ((rangeTest = GetCRange_NA(pTestRange)) == NULL)
        return E_INVALIDARG;

    if (!VerifySameContext(this, rangeTest))
        return E_INVALIDARG;

    // search thru the list, finding anything covered by the range
    pFirstComp = NULL;
    for (pHaltComp = _pCompositionList; pHaltComp != NULL; pHaltComp = pHaltComp->_GetNext())
    {
        if (CompareAnchors(rangeTest->_GetEnd(), pHaltComp->_GetStart()) < 0)
            break;

        if (pFirstComp == NULL)
        {
            if (CompareAnchors(rangeTest->_GetStart(), pHaltComp->_GetEnd()) <= 0)
            {
                pFirstComp = pHaltComp;
            }
        }
    }
    if (pFirstComp == NULL)
    {
        // the enum _Init assumes pFirstComp == NULL -> pHaltComp == NULL
        pHaltComp = NULL;
    }

    if ((pEnum = new CEnumCompositionView) == NULL)
        return E_OUTOFMEMORY;

    if (!pEnum->_Init(pFirstComp, pHaltComp))
    {
        pEnum->Release();
        return E_FAIL;
    }

    *ppEnum = pEnum;
    return S_OK;
}

//+---------------------------------------------------------------------------
//
// TakeOwnership
//
//----------------------------------------------------------------------------

STDAPI CInputContext::TakeOwnership(TfEditCookie ec, ITfCompositionView *pComposition,
                                    ITfCompositionSink *pSink, ITfComposition **ppComposition)
{
    if (ppComposition == NULL)
        return E_INVALIDARG;

    *ppComposition = NULL;

#ifndef UNTESTED_UNUSED

    Assert(0); // no one should be calling this
    return E_NOTIMPL;

#else

    CComposition *composition;
    TfClientId tidPrev;

    if (pComposition == NULL || pSink == NULL)
        return E_INVALIDARG;

    if ((composition = GetCComposition_NA(pComposition)) == NULL)
        return E_INVALIDARG;

    if (composition->_IsTerminated())
        return E_INVALIDARG; // it's dead!

    if (!_IsConnected())
        return TF_E_DISCONNECTED;

    if (!_IsValidEditCookie(ec, TF_ES_READWRITE))
    {
        Assert(0);
        return TF_E_NOLOCK;
    }

    if (!_EnterCompositionOp())
        return E_UNEXPECTED; // reentrant with another write op

    // switch the owner
    tidPrev = composition->_SetOwner(_GetClientInEditSession(ec));

    // let the old owner know something happened
    composition->_SendOnTerminated(ec, tidPrev);

    // switch the sink
    composition->_SetSink(pSink);

    _LeaveCompositionOp();

    return S_OK;
#endif // UNTESTED_UNUSED
}

//+---------------------------------------------------------------------------
//
// TerminateComposition
//
//----------------------------------------------------------------------------

STDAPI CInputContext::TerminateComposition(ITfCompositionView *pComposition)
{
    HRESULT hr;

    if (!_IsConnected())
        return TF_E_DISCONNECTED;

    // don't let this happen while we hold a lock
    // the usual scenario: word freaks out and tries to cancel the composition inside a SetText call
    // let's give them an error code to help debug
    if (_IsInEditSession() && _GetTIPOwner() != _tidInEditSession)
    {
        Assert(0); // someone's trying to abort a composition without a lock, or they don't own the ic
        return TF_E_NOLOCK; // meaning the caller doesn't hold the lock
    }

    if (pComposition == NULL && _pCompositionList == NULL)
        return S_OK; // no compositions to terminate, we check later, but check here so we don't fail on read-only docs and for perf

    if (!_EnterCompositionOp())
        return E_UNEXPECTED; // reentrant with another write op

    // need to ask for a lock (call originates with app)
    if (_DoPseudoSyncEditSession(TF_ES_READWRITE, PSEUDO_ESCB_TERMCOMPOSITION, pComposition, &hr) != S_OK || hr != S_OK)
    {
        Assert(0);
        hr = E_FAIL;
    }

    _LeaveCompositionOp();

    return hr;
}

//+---------------------------------------------------------------------------
//
// _TerminateCompositionWithLock
//
//----------------------------------------------------------------------------

HRESULT CInputContext::_TerminateCompositionWithLock(ITfCompositionView *pComposition, TfEditCookie ec)
{
    CComposition *composition;

    Assert(ec != TF_INVALID_EDIT_COOKIE);

    if (pComposition == NULL && _pCompositionList == NULL)
        return S_OK; // no compositions to terminate

    while (TRUE)
    {
        if (pComposition == NULL)
        {
            composition = _pCompositionList;
            composition->AddRef();
        }
        else
        {
            if ((composition = GetCComposition_NA(pComposition)) == NULL)
                return E_INVALIDARG;

            if (composition->_IsTerminated())
                return E_INVALIDARG;
        }

        composition->_Terminate(ec);

        if (!composition->_RemoveFromCompositionList(&_pCompositionList))
        {
            // how did this guy get off the list w/o termination?
            Assert(0); // should never get here
            return E_FAIL;
        }

        if (pComposition != NULL)
            break;

        composition->Release();

        if (_pCompositionList == NULL)
            break;
    }

    return S_OK;
}

//+---------------------------------------------------------------------------
//
// _AbortCompositions
//
// Called on an ic pop. TIPs do not get a notification because we cannot
// guarantee a lock.
//----------------------------------------------------------------------------

void CInputContext::_AbortCompositions()
{
    CComposition *pComposition;

    while (_pCompositionList != NULL)
    {
        // notify the app
        if (_GetOwnerCompositionSink() != NULL)
        {
            _GetOwnerCompositionSink()->OnEndComposition(_pCompositionList);
        }

        // we won't notify the tip because he can't get a lock here
        // but there's enough info later to cleanup any state in the ic pop notify
        
        _pCompositionList->_Die();

        pComposition = _pCompositionList->_GetNext();
        _pCompositionList->Release();
        _pCompositionList = pComposition;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\ctf\uim\compart.h ===
//
// compart.h
//

#ifndef COMPART_H
#define COMPART_H

#include "globals.h"
#include "sink.h"
#include "enumguid.h"
#include "ptrary.h"
#include "strary.h"
#include "tfprop.h"
#include "memcache.h"
#include "gcompart.h"

extern const IID IID_PRIV_CCOMPARTMENTMGR;
extern const IID IID_PRIV_CGLOBALCOMPARTMENT;

class CThreadInputMgr;
class CCompartmentMgr;
class CCompartmentMgrOwner;
class CCompartmentBase;

typedef enum {
      COMPTYPE_GLOBAL = 0,
      COMPTYPE_TIM    = 1,
      COMPTYPE_DIM    = 2,
      COMPTYPE_IC     = 3,
} COMPTYPE;

typedef struct tag_COMPARTMENTACCESS {
    const GUID *pguid;
    DWORD dwAccess;
} COMPARTMENTACCESS;

#define CA_ONLYOWNERSET     0x0001

//////////////////////////////////////////////////////////////////////////////
//
// Helpers
//
//////////////////////////////////////////////////////////////////////////////

inline CCompartmentMgr *GetCCompartmentMgr(IUnknown *punk)
{
    CCompartmentMgr *compmgr;

    punk->QueryInterface(IID_PRIV_CCOMPARTMENTMGR, (void **)&compmgr);

    return compmgr;
}

BOOL EnsureGlobalCompartment(SYSTHREAD *psfn);
HRESULT MyToggleCompartmentDWORD(TfClientId tid, CCompartmentMgr *pCompMgr, REFGUID rguid, DWORD *pdwOld);
HRESULT MyGetCompartmentDWORD(CCompartmentMgr *pCompMgr, REFGUID rguid, DWORD *pdw);
HRESULT MySetCompartmentDWORD(TfClientId tid, CCompartmentMgr *pCompMgr, REFGUID rguid, DWORD dw);

//////////////////////////////////////////////////////////////////////////////
//
// CEnumCompartment
//
//////////////////////////////////////////////////////////////////////////////

class CEnumCompartment : public CEnumGuid
{
public:
    CEnumCompartment();
    BOOL _Init(CPtrArray<CCompartmentBase> *prgComp);
    DBG_ID_DECLARE;
};


//////////////////////////////////////////////////////////////////////////////
//
// CCompartmentBase
//
//////////////////////////////////////////////////////////////////////////////

class __declspec(novtable) CCompartmentBase : public ITfCompartment,
                                              public ITfSource
{
public:
    CCompartmentBase(CCompartmentMgr *pCompMgr, TfGuidAtom guidatom, TfPropertyType proptype);
    virtual ~CCompartmentBase() {}

    //
    // IUnknown methods
    //
    virtual STDMETHODIMP QueryInterface(REFIID riid, void **ppvObj) = 0;
    virtual STDMETHODIMP_(ULONG) AddRef(void) = 0;
    virtual STDMETHODIMP_(ULONG) Release(void) = 0;

    //
    // ITfCompartment
    //
    virtual STDMETHODIMP SetValue(TfClientId tid, const VARIANT *pvarValue) = 0;
    virtual STDMETHODIMP GetValue(VARIANT *pvarValue) = 0;

    //
    // ITfSource
    //
    virtual STDMETHODIMP AdviseSink(REFIID refiid, IUnknown *punk, DWORD *pdwCookie) = 0;
    virtual STDMETHODIMP UnadviseSink(DWORD dwCookie) = 0;

    TfGuidAtom GetGuidAtom() {return _guidatom;}
    TfPropertyType GetpropType() {return _proptype;}

    virtual DWORD GetId() {Assert(0); return 0;}
    virtual BOOL MakeNotify() {Assert(0); return FALSE;}

    BOOL IsValidType(TfPropertyType proptype)
    {
        if (_proptype == TF_PT_NONE)
            return TRUE;

        return _proptype == proptype;
    }

    CCompartmentMgr *_GetMgr() {return _pCompMgr;}
    DWORD _GetAccess() {return _dwAccess;}
    void Invalid() {_fInvalid = TRUE;};
    
protected:
    static const COMPARTMENTACCESS _c_ca[];
    DWORD _dwAccess;
    TfGuidAtom _guidatom;
    TfPropertyType _proptype;
    BOOL _fInvalid;
    CCompartmentMgr *_pCompMgr;
};

//////////////////////////////////////////////////////////////////////////////
//
// CCompartment
//
//////////////////////////////////////////////////////////////////////////////

class CCompartment :  public CCompartmentBase,
                      public CComObjectRootImmx
{
public:
    CCompartment(CCompartmentMgr *pCompMgr, TfGuidAtom guidatom, TfPropertyType proptype);
    ~CCompartment();

    BEGIN_COM_MAP_IMMX(CCompartment)
        COM_INTERFACE_ENTRY(ITfCompartment)
        COM_INTERFACE_ENTRY(ITfSource)
    END_COM_MAP_IMMX()

    IMMX_OBJECT_IUNKNOWN_FOR_ATL()

    // ITfCompartment
    STDMETHODIMP SetValue(TfClientId tid, const VARIANT *pvarValue);
    STDMETHODIMP GetValue(VARIANT *pvarValue);

    // ITfSource
    STDMETHODIMP AdviseSink(REFIID refiid, IUnknown *punk, DWORD *pdwCookie);
    STDMETHODIMP UnadviseSink(DWORD dwCookie);

    CStructArray<GENERICSINK> _rgCompartmentSink; 

private:
    TFPROPERTY _prop;
    BOOL _fInSet;
    DBG_ID_DECLARE;
};



//////////////////////////////////////////////////////////////////////////////
//
// CGlobalCompartment
//
//////////////////////////////////////////////////////////////////////////////

class CGlobalCompartment :  public CCompartmentBase,
                            public CComObjectRootImmx_InternalReference
{
public:
    CGlobalCompartment(CCompartmentMgr *pCompMgr, REFGUID rguid, TfGuidAtom guidatom, TfPropertyType proptype);
    ~CGlobalCompartment();

    BEGIN_COM_MAP_IMMX(CGlobalCompartment)
        COM_INTERFACE_ENTRY(ITfCompartment)
        COM_INTERFACE_ENTRY(ITfSource)
    END_COM_MAP_IMMX()

    IMMX_OBJECT_IUNKNOWN_FOR_ATL()

    // ITfCompartment
    STDMETHODIMP SetValue(TfClientId tid, const VARIANT *pvarValue);
    STDMETHODIMP GetValue(VARIANT *pvarValue);

    // ITfSource
    STDMETHODIMP AdviseSink(REFIID refiid, IUnknown *punk, DWORD *pdwCookie);
    STDMETHODIMP UnadviseSink(DWORD dwCookie);

    CStructArray<GENERICSINK> _rgCompartmentSink;
    BOOL MakeNotify();

    DWORD GetId() {return _dwId;}

private:
    static BOOL EnumThreadProc(DWORD dwThreadId, DWORD dwProcessId, void *pv);
    DWORD _dwId;
    BOOL _fInSet;
    GUID _guidCompart;
    DBG_ID_DECLARE;
};

inline CGlobalCompartment *GetCGlobalCompartment(IUnknown *punk)
{
    CGlobalCompartment *comp;

    punk->QueryInterface(IID_PRIV_CGLOBALCOMPARTMENT, (void **)&comp);

    return comp;
}

//////////////////////////////////////////////////////////////////////////////
//
// CCompartmentMgr
//
//////////////////////////////////////////////////////////////////////////////

class __declspec(novtable) CCompartmentMgr : public ITfCompartmentMgr
{
public:
    CCompartmentMgr(TfClientId tidOwner, COMPTYPE cType);
    virtual ~CCompartmentMgr();

    //
    // IUnknown methods
    //
    virtual STDMETHODIMP QueryInterface(REFIID riid, void **ppvObj) = 0;
    virtual STDMETHODIMP_(ULONG) AddRef(void) = 0;
    virtual STDMETHODIMP_(ULONG) Release(void) = 0;

    STDMETHODIMP GetCompartment(REFGUID rguid, ITfCompartment **ppcomp);
    STDMETHODIMP ClearCompartment(TfClientId tid, REFGUID rguid);
    STDMETHODIMP EnumCompartments(IEnumGUID **ppEnum);

    void NotifyGlobalCompartmentChange(DWORD dwId);
    void CleanUp();

    TfClientId _GetTIPOwner() { return _tidOwner; }

private:
    CCompartmentBase *_Find(TfGuidAtom guidatom, int *piOut);
    CCompartmentBase *_Get(REFGUID rguid);

    COMPTYPE _cType;
    CPtrArray<CCompartmentBase> _rgCompartment;
    TfClientId _tidOwner;

    DBG_ID_DECLARE;
};

//////////////////////////////////////////////////////////////////////////////
//
// CGlobalCompartmentMgr
//
//////////////////////////////////////////////////////////////////////////////

class CGlobalCompartmentMgr :  public CCompartmentMgr
{
public:
    CGlobalCompartmentMgr(TfClientId tidOwner) : CCompartmentMgr(tidOwner, COMPTYPE_GLOBAL) 
    {
        _cRef = 1;
    }

    ~CGlobalCompartmentMgr() {}

    //
    // IUnknown methods
    //
    STDMETHODIMP QueryInterface(REFIID riid, void **ppvObj);
    STDMETHODIMP_(ULONG) AddRef(void);
    STDMETHODIMP_(ULONG) Release(void);
private:
    int _cRef;
};


#endif COMPART_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\ctf\uim\compose.h ===
//
// compose.h
//

#ifndef COMPOSE_H
#define COMPOSE_H

class CRange;
class CInputContext;

// return type for _IsRangeCovered method
typedef enum { IRC_COVERED, IRC_OUTSIDE, IRC_NO_OWNEDCOMPOSITIONS } IRC;

extern const IID IID_PRIV_CCOMPOSITION;

class CComposition : public ITfCompositionView,
                     public ITfComposition,
                     public CComObjectRootImmx
{
public:
    CComposition() { Dbg_MemSetThisNameID(TEXT("CComposition")); }
    ~CComposition() { _Uninit(); }

    BOOL _Init(TfClientId tid, CInputContext *pic, IAnchor *paStart, IAnchor *paEnd, ITfCompositionSink *pSink);

    BEGIN_COM_MAP_IMMX(CComposition)
        COM_INTERFACE_ENTRY_IID(IID_PRIV_CCOMPOSITION, CComposition)
        COM_INTERFACE_ENTRY(ITfCompositionView)
        COM_INTERFACE_ENTRY(ITfComposition)
    END_COM_MAP_IMMX()

    IMMX_OBJECT_IUNKNOWN_FOR_ATL()

    // ITfCompositionView
    STDMETHODIMP GetOwnerClsid(CLSID *pclsid);
    STDMETHODIMP GetRange(ITfRange **ppRange);

    // ITfComposition
    //STDMETHODIMP GetRange(ITfRange **ppRange);
    STDMETHODIMP ShiftStart(TfEditCookie ecWrite, ITfRange *pNewStart);
    STDMETHODIMP ShiftEnd(TfEditCookie ecWrite, ITfRange *pNewEnd);
    STDMETHODIMP EndComposition(TfEditCookie ecWrite);

    void _AddToCompositionList(CComposition **ppCompositionList);
    BOOL _RemoveFromCompositionList(CComposition **ppCompositionList);

    BOOL _IsTerminated() { return _pic == NULL; }

    void _Terminate(TfEditCookie ec);

    void _SendOnTerminated(TfEditCookie ec, TfClientId tidForEditSession);

    TfClientId _GetOwner() { return _tid; }

    TfClientId _SetOwner(TfClientId tid)
    {
        TfClientId tidTmp = _tid;
        _tid = tid;
        return tidTmp;
    }

    void _SetSink(ITfCompositionSink *pSink)
    {
        SafeRelease(_pSink);
        _pSink = pSink;
        _pSink->AddRef();
    }

    static IRC _IsRangeCovered(CInputContext *pic, TfClientId tid, IAnchor *paStart, IAnchor *paEnd, CComposition **ppComposition);

    IAnchor *_GetStart() { return _paStart; }
    IAnchor *_GetEnd() { return _paEnd; }

    CComposition *_GetNext() { return _next; }

    void _Die() { _Uninit(); }

private:
    
    void _ClearComposing(TfEditCookie ec, IAnchor *paStart, IAnchor *paEnd);
    void _SetComposing(TfEditCookie ec, IAnchor *paStart, IAnchor *paEnd);

    void _Uninit();

    TfClientId _tid;
    CInputContext *_pic;
    IAnchor *_paStart;
    IAnchor *_paEnd;
    ITfCompositionSink *_pSink;
    CComposition *_next;
    DBG_ID_DECLARE;
};

#endif // COMPOSE_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\ctf\uim\dam.h ===
//
// dam.h
//

#ifndef DAM_H
#define DAM_H

#include "private.h"
#include "ptrary.h"
#include "strary.h"
#include "enumguid.h"
#include "sunka.h"
#include "globals.h"

extern const IID IID_CDisplayAttributeMgr; // private iid for CDisplayAttributeMgr pointer

typedef struct tagDISPATTRGUID {
    CLSID clsid;
    TfGuidAtom gaClsid;
    GUID guid;
    TfGuidAtom gaGuid;
} DISPATTRGUID;

#define StaticCacheInit() CDispAttrGuidCache::StaticInit()

class CDispAttrGuidCache;
extern CDispAttrGuidCache *g_pDispAttrGuidCache;

//////////////////////////////////////////////////////////////////////////////
//
// CRenderMarkupCollection
//
//////////////////////////////////////////////////////////////////////////////

class CRenderMarkupCollection
{
public:
    CRenderMarkupCollection();

    void _Advise(ITfTextInputProcessor *tip, TfGuidAtom gaTip);
    void _Unadvise(TfGuidAtom gaTip);

    int _Count()
    {
        return _rgGUIDAtom.Count();
    }
    const TfGuidAtom *_GetAtoms()
    {
        return _rgGUIDAtom.GetPtr(0);
    }
    TfGuidAtom _GetAtom(int i)
    {
        return *_rgGUIDAtom.GetPtr(i);
    }

    BOOL _IsInCollection(REFGUID rguidProperty);

private:
    typedef struct
    {
        ULONG uPriority;
        TfGuidAtom gaTip;
    } MARKUP_DATA;

    // these are parallel arrays
    // they aren't merged because we want to use CalcCicPropertyTrackerAnchors
    // which takes a flat array of TfGuidAtoms
    CStructArray<TfGuidAtom> _rgGUIDAtom;
    CStructArray<MARKUP_DATA> _rgOther;
};


//////////////////////////////////////////////////////////////////////////////
//
// CDispAttrGuidCache
//
//////////////////////////////////////////////////////////////////////////////

class CDispAttrGuidCache
{
public:
    CDispAttrGuidCache() {}

    static void StaticUnInit();
    static void StaticInit();
    BOOL Add(REFCLSID clsid, REFGUID guid);
    void Remove(TfGuidAtom guidatom);
    void RemoveClsid(TfGuidAtom guidatom);
    BOOL Get(TfGuidAtom guidatom, DISPATTRGUID *pDisp);
    BOOL InternalGet(TfGuidAtom guidatom, DISPATTRGUID *pDisp);
    BOOL IsClsid(TfGuidAtom gaClsid);
    HRESULT Save();
    HRESULT Load();
    void Clear() {_rgDispAttrGuid.Clear(); Save();}

private:
    CStructArray<DISPATTRGUID> _rgDispAttrGuid;
};

//////////////////////////////////////////////////////////////////////////////
//
// CDisplayAttributeMgr
//
//////////////////////////////////////////////////////////////////////////////

typedef struct tagDAPROVIDERMAP {
    TfGuidAtom gaClsid;
    ITfDisplayAttributeProvider *pPrv;
} DAPROVIDERMAP;

class CDisplayAttributeMgr : 
      public ITfDisplayAttributeMgr,
      public ITfDisplayAttributeCollectionMgr,
      public CComObjectRoot_CreateSingletonInstance<CDisplayAttributeMgr>
{
public:
    CDisplayAttributeMgr();
    ~CDisplayAttributeMgr();

    BEGIN_COM_MAP_IMMX(CDisplayAttributeMgr)
        COM_INTERFACE_ENTRY(ITfDisplayAttributeMgr)
        COM_INTERFACE_ENTRY(ITfDisplayAttributeCollectionMgr)
        COM_INTERFACE_ENTRY_IID(IID_CDisplayAttributeMgr, CDisplayAttributeMgr)
    END_COM_MAP_IMMX()

    //
    // ITfDisplayAttributeMgr
    //
    STDMETHODIMP OnUpdateInfo();
    STDMETHODIMP EnumDisplayAttributeInfo(IEnumTfDisplayAttributeInfo **ppEnum);
    STDMETHODIMP GetDisplayAttributeInfo(REFGUID guid, ITfDisplayAttributeInfo **ppInfo, CLSID *pclsid);

    // ITfDisplayAttributeCollectionMgr
    STDMETHODIMP EnumCollections(IEnumTfCollection **ppEnum);

    static HRESULT StaticRegisterProperty(REFGUID guidProp, WCHAR *pszName);

    CRenderMarkupCollection *_GetMarkupCollection()
    {
        return &_rgMarkupCollection;
    }

    static void _AdviseMarkupCollection(ITfTextInputProcessor *tip, TfGuidAtom gaTip)
    {
        CDisplayAttributeMgr *pDisplayAttrMgr;

        if (CDisplayAttributeMgr::CreateInstance(NULL, IID_CDisplayAttributeMgr, (void **)&pDisplayAttrMgr) != S_OK)
            return;

        pDisplayAttrMgr->_rgMarkupCollection._Advise(tip, gaTip);
    
        pDisplayAttrMgr->Release();
    }

    static void _UnadviseMarkupCollection(TfGuidAtom gaTip)
    {
        CDisplayAttributeMgr *pDisplayAttrMgr;

        if (CDisplayAttributeMgr::CreateInstance(NULL, IID_CDisplayAttributeMgr, (void **)&pDisplayAttrMgr) != S_OK)
            return;

        pDisplayAttrMgr->_rgMarkupCollection._Unadvise(gaTip);

        pDisplayAttrMgr->Release();
    }

    static BOOL _IsInCollection(REFGUID rguidProperty)
    {
        CDisplayAttributeMgr *pDisplayAttrMgr;
        BOOL fRet;

        if (CDisplayAttributeMgr::CreateInstance(NULL, IID_CDisplayAttributeMgr, (void **)&pDisplayAttrMgr) != S_OK)
            return FALSE;

        fRet = pDisplayAttrMgr->_rgMarkupCollection._IsInCollection(rguidProperty);

        pDisplayAttrMgr->Release();

        return fRet;
    }

    static CDisplayAttributeMgr *_GetThis() 
    { 
        SYSTHREAD *psfn = GetSYSTHREAD();
        if (!psfn)
            return NULL;
        return psfn->pdam;
    }

private:

    static BOOL _SetThis(CDisplayAttributeMgr *_this)
    { 
        SYSTHREAD *psfn = GetSYSTHREAD();
        if (!psfn)
            return FALSE;

        psfn->pdam = _this;
        return TRUE;
    }


    static HRESULT _RegisterGUID(const TCHAR *pszKey, REFGUID rguid, WCHAR *pszName, ULONG cchName);
    static HRESULT _UnregisterGUID(const TCHAR *pszKey, REFGUID rguid);

    CStructArray<DAPROVIDERMAP> _rgDaPrv;

    CRenderMarkupCollection _rgMarkupCollection;

    static BOOL EnumThreadProc(DWORD dwThread, DWORD dwProcessId, void *pv);

    DBG_ID_DECLARE;
};

//////////////////////////////////////////////////////////////////////////////
//
// CEnumDisplayAttributeInfo
//
//////////////////////////////////////////////////////////////////////////////

class CEnumDisplayAttributeInfo : public IEnumTfDisplayAttributeInfo,
                                  public CEnumUnknown,
                                  public CComObjectRootImmx
{
public:
    CEnumDisplayAttributeInfo();

    BEGIN_COM_MAP_IMMX(CEnumDisplayAttributeInfo)
        COM_INTERFACE_ENTRY(IEnumTfDisplayAttributeInfo)
    END_COM_MAP_IMMX()

    IMMX_OBJECT_IUNKNOWN_FOR_ATL()

    DECLARE_SUNKA_ENUM(IEnumTfDisplayAttributeInfo, CEnumDisplayAttributeInfo, ITfDisplayAttributeInfo)

    BOOL Init();

private:
    DBG_ID_DECLARE;
};



#endif //DAM_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\ctf\uim\dam.cpp ===
//
// dam.cpp
//

#include "private.h"
#include "tlhelp32.h"
#include "globals.h"
#include "dam.h"
#include "tim.h"
#include "thdutil.h"
#include "timlist.h"

// get CLSID_STRLEN
#include "regsvr.h"

/* ff4619e8-ea5e-43e5-b308-11cd26ab6b3a */
const IID IID_CDisplayAttributeMgr = { 0xff4619e8, 0xea5e, 0x43e5, {0xb3, 0x08, 0x11, 0xcd, 0x26, 0xab, 0x6b, 0x3a} };

const TCHAR c_szDAMCacheKey[] = TEXT("SOFTWARE\\Microsoft\\CTF\\DisplayAttributeCache\\");
const TCHAR c_szDAMNumValue[] = TEXT("CheckNum");

CDispAttrGuidCache *g_pDispAttrGuidCache = NULL;

//
// from aimm1.2\win32\aimmdap.cpp
//
/* 503286E2-5D2A-4D3D-B0D1-EE50D843B79D */
const CLSID CLSID_CAImmDAP = {
    0x503286E2,
    0x5D2A,
    0x4D3D,
    {0xB0, 0xD1, 0xEE, 0x50, 0xD8, 0x43, 0xB7, 0x9D}
  };


DBG_ID_INSTANCE(CDisplayAttributeMgr);
DBG_ID_INSTANCE(CEnumDisplayAttributeInfo);

//////////////////////////////////////////////////////////////////////////////
//
// CDispAttrGuidCache
//
//////////////////////////////////////////////////////////////////////////////

//+---------------------------------------------------------------------------
//
// StaticUnInit
//
// Caller must hold mutex.
//----------------------------------------------------------------------------

void CDispAttrGuidCache::StaticUnInit()
{
    Assert(ISINDLLMAIN()); // for mutex

    if (g_pDispAttrGuidCache)
        delete g_pDispAttrGuidCache;
     g_pDispAttrGuidCache = NULL;
}


//+---------------------------------------------------------------------------
//
// StaticInit
//
//----------------------------------------------------------------------------

void CDispAttrGuidCache::StaticInit()
{
    CicEnterCriticalSection(g_cs);

    if (!g_pDispAttrGuidCache)
    {
        g_pDispAttrGuidCache = new CDispAttrGuidCache();

        if (g_pDispAttrGuidCache)
            g_pDispAttrGuidCache->Load();
    }

    CicLeaveCriticalSection(g_cs);
}

//+---------------------------------------------------------------------------
//
// Add
//
//----------------------------------------------------------------------------

BOOL CDispAttrGuidCache::Add(REFCLSID clsid, REFGUID guid)
{
    BOOL bRet = FALSE;
    TfGuidAtom gaGuid;
    TfGuidAtom gaClsid;

    if (FAILED(MyRegisterGUID(clsid, &gaClsid)))
        return bRet;

    if (FAILED(MyRegisterGUID(guid, &gaGuid)))
        return bRet;
    
    CicEnterCriticalSection(g_cs);

    if (!Get(gaGuid, NULL))
    {
        DISPATTRGUID *pGuid;

        if (!_rgDispAttrGuid.Insert(0, 1))
        {
            goto Exit;
        }

        pGuid = _rgDispAttrGuid.GetPtr(0);
        pGuid->clsid = clsid;
        pGuid->gaClsid = gaClsid;
        pGuid->guid = guid;
        pGuid->gaGuid = gaGuid;
    }
    bRet = TRUE;

Exit:
    CicLeaveCriticalSection(g_cs);

    return bRet;
}

//+---------------------------------------------------------------------------
//
// Remove
//
//----------------------------------------------------------------------------

void CDispAttrGuidCache::Remove(TfGuidAtom guidatom)
{
    int nCnt = _rgDispAttrGuid.Count();
    int i;

    for (i = 0; i < nCnt; i++)
    {
        DISPATTRGUID *pGuid = _rgDispAttrGuid.GetPtr(i);
        if (pGuid->gaGuid == guidatom)
        {
            _rgDispAttrGuid.Remove(i, 1);
            return;
        }
    }
}

//+---------------------------------------------------------------------------
//
// RemoveClsid
//
//----------------------------------------------------------------------------

void CDispAttrGuidCache::RemoveClsid(TfGuidAtom guidatom)
{
    int nCnt = _rgDispAttrGuid.Count();
    int i;

    i = 0;
    while (i < nCnt)
    {
        DISPATTRGUID *pGuid = _rgDispAttrGuid.GetPtr(i);
        if (pGuid->gaClsid == guidatom)
        {
            _rgDispAttrGuid.Remove(i, 1);
            nCnt--;
            continue;
        }
        i++;
    }
}

//+---------------------------------------------------------------------------
//
// Get
//
//----------------------------------------------------------------------------

BOOL CDispAttrGuidCache::Get(TfGuidAtom guidatom, DISPATTRGUID *pDisp)
{
    BOOL bRet;
    CicEnterCriticalSection(g_cs);
    bRet = InternalGet(guidatom, pDisp);
    CicLeaveCriticalSection(g_cs);
    return bRet;
}

//+---------------------------------------------------------------------------
//
// InternalGet
//
//----------------------------------------------------------------------------

BOOL CDispAttrGuidCache::InternalGet(TfGuidAtom guidatom, DISPATTRGUID *pDisp)
{
    int nCnt;
    int i;
    BOOL bRet = FALSE;

    nCnt = _rgDispAttrGuid.Count();
    DISPATTRGUID *pGuid = _rgDispAttrGuid.GetPtr(0);

    for (i = 0; i < nCnt; i++)
    {
        if (pGuid->gaGuid == guidatom)
        {
            if (pDisp)
                *pDisp = *pGuid;
            bRet = TRUE;
            goto Exit;
        }
        pGuid++;
    }
Exit:
    return bRet;
}

//+---------------------------------------------------------------------------
//
// IsClsid
//
//----------------------------------------------------------------------------

BOOL CDispAttrGuidCache::IsClsid(TfGuidAtom gaClsid)
{
    BOOL bRet = FALSE;
    int nCnt;
    int i;
    DISPATTRGUID *pGuid;

    CicEnterCriticalSection(g_cs);

    pGuid = _rgDispAttrGuid.GetPtr(0);
    nCnt = _rgDispAttrGuid.Count();

    for (i = 0; i < nCnt; i++)
    {
        if (pGuid->gaClsid == gaClsid)
        {
            bRet = TRUE;
            break;
        }
        pGuid++;
    }

    CicLeaveCriticalSection(g_cs);

    return bRet;
}

//+---------------------------------------------------------------------------
//
// Save
//
//----------------------------------------------------------------------------

HRESULT CDispAttrGuidCache::Save()
{
    DWORD dw;
    HKEY hKeyDAM;
    DISPATTRGUID *pDAG;
    int nCnt;

    if (RegCreateKeyEx(HKEY_LOCAL_MACHINE, c_szDAMCacheKey, 0, NULL, 
                       REG_OPTION_NON_VOLATILE,
                       KEY_ALL_ACCESS, 
                       NULL, 
                       &hKeyDAM, 
                       &dw) != ERROR_SUCCESS)
    {
        return E_FAIL;
    }
    
    nCnt = _rgDispAttrGuid.Count();

    if (nCnt)
    {
       pDAG = _rgDispAttrGuid.GetPtr(0);

       RegSetValueEx(hKeyDAM, NULL, 0, REG_BINARY, 
                     (CONST BYTE *)pDAG, sizeof(DISPATTRGUID) * nCnt);

       RegSetValueEx(hKeyDAM, c_szDAMNumValue, 0, REG_DWORD,
                        (LPBYTE)&nCnt, sizeof(DWORD));
    }
    else
    {
       RegDeleteValue(hKeyDAM, NULL);
       RegDeleteValue(hKeyDAM, c_szDAMNumValue);
    }
    
    RegCloseKey(hKeyDAM);


    return S_OK;
}

//+---------------------------------------------------------------------------
//
// Load
//
//----------------------------------------------------------------------------

HRESULT CDispAttrGuidCache::Load()
{
    HKEY hKeyDAM;
    HRESULT hr = E_FAIL;

    if (RegOpenKeyEx(HKEY_LOCAL_MACHINE, c_szDAMCacheKey, 0,
                     KEY_READ, &hKeyDAM) != ERROR_SUCCESS)
    {
        return hr;
    }

    
    Assert(_rgDispAttrGuid.Count() == 0);

    DWORD dwType = REG_DWORD;
    DWORD dwSize = sizeof(DWORD);
    DWORD dwCntReg = 0;

    //
    // Issue: should be removed before release.
    // we changed the size of structre so old chace does not match with
    // new one. Check the size of structure.
    //
    if (RegQueryValueEx(hKeyDAM, c_szDAMNumValue, 0, &dwType, 
                        (LPBYTE)&dwCntReg, &dwSize) != ERROR_SUCCESS)
        dwCntReg = 0;

    dwType = REG_BINARY;

    if (RegQueryValueEx(hKeyDAM, NULL, 0, &dwType, 
                        NULL, &dwSize) == ERROR_SUCCESS)
    {
         DWORD i;
         DWORD dwCnt = dwSize / sizeof(DISPATTRGUID);

         if (dwCnt != dwCntReg)
             goto Exit;

         _rgDispAttrGuid.Insert(0, dwCnt);
         DISPATTRGUID *pDAG = _rgDispAttrGuid.GetPtr(0);
         RegQueryValueEx(hKeyDAM, NULL, 0, &dwType, (BYTE *)pDAG, &dwSize);

         for (i = 0; i < dwCnt; i++)
         {
              if (FAILED(MyRegisterGUID(pDAG[i].clsid, &pDAG[i].gaClsid)))
                  goto Exit;

              if (FAILED(MyRegisterGUID(pDAG[i].guid, &pDAG[i].gaGuid)))
                  goto Exit;
         }
    }
    
    hr = S_OK;
Exit:
    RegCloseKey(hKeyDAM);

    return hr;
}

//////////////////////////////////////////////////////////////////////////////
//
// CDisplayAttributeMgr
//
//////////////////////////////////////////////////////////////////////////////

//+---------------------------------------------------------------------------
//
// ctor
//
//----------------------------------------------------------------------------

CDisplayAttributeMgr::CDisplayAttributeMgr()
{
    Dbg_MemSetThisNameID(TEXT("CDisplayAttributeMgr"));
    _SetThis(this);
}

//+---------------------------------------------------------------------------
//
// dtor
//
//----------------------------------------------------------------------------

CDisplayAttributeMgr::~CDisplayAttributeMgr()
{
    int nCnt = _rgDaPrv.Count();

    if (nCnt)
    {
        DAPROVIDERMAP *pDaPrv;
        pDaPrv = _rgDaPrv.GetPtr(0);

        while(nCnt--)
        {
            pDaPrv->pPrv->Release();
            pDaPrv++;
        }
    }
    _SetThis(NULL); // clear out singleton tls
}

//----------------------------------------------------------------------------
//
// OnUndateinfo
//
//  Use kernel32 or ntdll directly to enumerate all threads, because
//  we don't have global TIM list. 
//
//----------------------------------------------------------------------------


HRESULT CDisplayAttributeMgr::OnUpdateInfo()
{
    PostTimListMessage(TLF_TIMACTIVE,
                       0,
                       g_msgPrivate, 
                       TFPRIV_UPDATEDISPATTR, 
                       0);
    return S_OK;
}

//----------------------------------------------------------------------------
//
// EnumThreadProc
//
//----------------------------------------------------------------------------

BOOL CDisplayAttributeMgr::EnumThreadProc(DWORD dwThread, DWORD dwProcessId, void *pv)
{
    PostThreadMessage(dwThread, g_msgPrivate, TFPRIV_UPDATEDISPATTR, 0);
    return FALSE;
}

//----------------------------------------------------------------------------
//
// EnumDisplayAttributeInfo
//
//----------------------------------------------------------------------------

HRESULT CDisplayAttributeMgr::EnumDisplayAttributeInfo(IEnumTfDisplayAttributeInfo **ppEnum)
{
    CEnumDisplayAttributeInfo *pEnum;

    if (!ppEnum)
        return E_INVALIDARG;

    pEnum = new CEnumDisplayAttributeInfo();

    if (!pEnum)
        return E_OUTOFMEMORY;

    if (pEnum->Init())
        *ppEnum = pEnum;
    else
        SafeReleaseClear(pEnum);

    return pEnum ? S_OK : E_FAIL;
}

//----------------------------------------------------------------------------
//
// GetDisplayAttributeInfo
//
//----------------------------------------------------------------------------

HRESULT CDisplayAttributeMgr::GetDisplayAttributeInfo(REFGUID guid, ITfDisplayAttributeInfo **ppInfo, CLSID *pclsid)
{
    CLSID clsid;
    ITfDisplayAttributeProvider *pProvider;
    HRESULT hr = E_FAIL;

    StaticCacheInit();

    if (ppInfo)
        *ppInfo = NULL;

    if (g_pDispAttrGuidCache)
    {
        DISPATTRGUID dag;
        TfGuidAtom gaGuid;

        if (FAILED(MyRegisterGUID(guid, &gaGuid)))
            return hr;

        if (g_pDispAttrGuidCache->Get(gaGuid, &dag))
        {
            if (ppInfo)
            {
                DAPROVIDERMAP *pDaPrv;
                int i;
                int nCnt = _rgDaPrv.Count();
                BOOL bFound = FALSE;

                for (i = 0; i < nCnt; i++)
                {
                    pDaPrv = _rgDaPrv.GetPtr(i);
                    if (pDaPrv->gaClsid == dag.gaClsid)
                    {
                        Assert(pDaPrv->pPrv);
                        hr = pDaPrv->pPrv->GetDisplayAttributeInfo(guid, ppInfo);
                        bFound = TRUE;
                        break;
                    }
                }

                if (!bFound &&
                    SUCCEEDED(CoCreateInstance(dag.clsid,
                                               NULL, 
                                               CLSCTX_INPROC_SERVER, 
                                               IID_ITfDisplayAttributeProvider, 
                                               (void**)&pProvider)))
                {
    
                    hr = pProvider->GetDisplayAttributeInfo(guid, ppInfo);

                    if (_rgDaPrv.Insert(nCnt, 1))
                    {
                        pDaPrv = _rgDaPrv.GetPtr(nCnt);
                        pDaPrv->gaClsid = dag.gaClsid;
                        pDaPrv->pPrv = pProvider;
                    }
                    else
                        pProvider->Release();
                }
            }
            else
            {
                hr = S_OK;
            }
    
            if (SUCCEEDED(hr))
            {
                if (pclsid)
                    *pclsid = dag.clsid;
                return hr;
            }

            //
            // someone removed DisplayAttribute Info. So we clear the cache.
            //
            g_pDispAttrGuidCache->Clear();
        }
    }


    IEnumGUID *pEnumGUID;

    if (FAILED(MyEnumItemsInCategory(GUID_TFCAT_DISPLAYATTRIBUTEPROVIDER, &pEnumGUID)))
        return E_FAIL;

    DWORD dwIndex = 0;
    BOOL fFound = FALSE;
    CThreadInputMgr *ptim = CThreadInputMgr::_GetThis();

    if (ptim == NULL)
        goto Exit;

    while (!fFound &&  (pEnumGUID->Next(1, &clsid, NULL) == S_OK))
    {
        if (!IsEqualCLSID(clsid, CLSID_CAImmDAP) &&
            (ptim->_IsActiveInputProcessor(clsid) != S_OK))
            continue;

        //
        // Issue: 
        //
        // we may want to load only providers that are enabled in this 
        // thread. Use CIMEList to check if tips is enabled.
        //
        if (SUCCEEDED(CoCreateInstance(clsid,
                                       NULL, 
                                       CLSCTX_INPROC_SERVER, 
                                       IID_ITfDisplayAttributeProvider, 
                                       (void**)&pProvider)))
        {
            IEnumTfDisplayAttributeInfo *pEnumDAI;

            if (SUCCEEDED(pProvider->EnumDisplayAttributeInfo(&pEnumDAI)))
            {
                ITfDisplayAttributeInfo *pInfo;

                while (pEnumDAI->Next(1, &pInfo, NULL) == S_OK)
                {
                    GUID guidTemp;
                    if (SUCCEEDED(pInfo->GetGUID(&guidTemp)))
                    { 
                        if (g_pDispAttrGuidCache)
                            g_pDispAttrGuidCache->Add(clsid, guidTemp);

                        if (IsEqualGUID(guidTemp, guid))
                        {

                            if (ppInfo)
                                *ppInfo = pInfo;
                            if (pclsid)
                                *pclsid = clsid;

                            fFound = TRUE;
                            hr = S_OK;
                            break;
                        }
                    }
                    pInfo->Release();
                }
                pEnumDAI->Release();
            }

            pProvider->Release();
        }

    }

Exit:
    pEnumGUID->Release();

    if (g_pDispAttrGuidCache)
        g_pDispAttrGuidCache->Save();

    return hr;
}

//----------------------------------------------------------------------------
//
// RegisterGUID
//
//----------------------------------------------------------------------------

HRESULT CDisplayAttributeMgr::_RegisterGUID(const TCHAR *pszKey, REFGUID rguid, WCHAR *pszDesc, ULONG cchDesc)
{
    DWORD dw;
    HKEY hKeyDAM;
    HKEY hKeyItem;
    TCHAR achGuid[CLSID_STRLEN+1];

    if (RegCreateKeyEx(HKEY_LOCAL_MACHINE, pszKey, 0, NULL, 
                       REG_OPTION_NON_VOLATILE,
                       KEY_ALL_ACCESS, 
                       NULL, 
                       &hKeyDAM, 
                       &dw) != ERROR_SUCCESS)
    {
        return E_FAIL;
    }

    CLSIDToStringA(rguid, achGuid);

    if (RegCreateKeyEx(hKeyDAM, achGuid, 0, NULL, 
                       REG_OPTION_NON_VOLATILE,
                       KEY_ALL_ACCESS, 
                       NULL, 
                       &hKeyItem, 
                       &dw) == ERROR_SUCCESS)
    {
        int cchDescA = cchDesc * sizeof(WCHAR) + 1;
        char *pszDescA = new char[cchDescA];
        if (pszDescA)
        {
            cchDescA = WideCharToMultiByte(CP_ACP, 0, 
                                           pszDesc, wcslen(pszDesc), 
                                           pszDescA, cchDescA, 
                                           NULL, NULL);
            *(pszDescA + cchDescA) = L'\0';

            RegSetValueEx(hKeyItem, TEXT("Description"), 0, REG_SZ, 
                          (CONST BYTE *)pszDescA, cchDescA);

            delete pszDescA;
        }
        RegCloseKey(hKeyItem);
    }
    RegCloseKey(hKeyDAM);


    return S_OK;
}

//----------------------------------------------------------------------------
//
// UnregisterGUID
//
//----------------------------------------------------------------------------

HRESULT CDisplayAttributeMgr::_UnregisterGUID(const TCHAR *pszKey, REFGUID rguid)
{
    DWORD dw;
    HKEY hKeyDAM;
    TCHAR achGuid[CLSID_STRLEN+1];

    if (RegCreateKeyEx(HKEY_LOCAL_MACHINE,  pszKey, 0, NULL, 
                       REG_OPTION_NON_VOLATILE,
                       KEY_ALL_ACCESS, 
                       NULL, 
                       &hKeyDAM, 
                       &dw) != ERROR_SUCCESS)
    {
        return E_FAIL;
    }

    CLSIDToStringA(rguid, achGuid);

    RegDeleteKey(hKeyDAM, achGuid);

    RegCloseKey(hKeyDAM);


    return S_OK;
}

//////////////////////////////////////////////////////////////////////////////
//
// CEnumDisplayAttributeInfo
//
//////////////////////////////////////////////////////////////////////////////

//+---------------------------------------------------------------------------
//
// ctor
//
//----------------------------------------------------------------------------

CEnumDisplayAttributeInfo::CEnumDisplayAttributeInfo()
{
    Dbg_MemSetThisNameID(TEXT("CEnumDisplayAttributeInfo"));
}

//+---------------------------------------------------------------------------
//
// Init
//
//----------------------------------------------------------------------------

BOOL CEnumDisplayAttributeInfo::Init()
{
    IEnumGUID *pEnumGUID;
    CLSID clsid;
    ULONG uDAMax;
    BOOL fRet;

    StaticCacheInit();

    if (FAILED(MyEnumItemsInCategory(GUID_TFCAT_DISPLAYATTRIBUTEPROVIDER, &pEnumGUID)))
        return FALSE;

    fRet = FALSE;

    if ((_prgUnk = SUA_Alloc(1)) == NULL)
        goto Exit;

    _prgUnk->cRef = 1;
    _prgUnk->cUnk = 0;
    uDAMax = 1;

    while (pEnumGUID->Next(1, &clsid, NULL) == S_OK)
    {
        ITfDisplayAttributeProvider *pProvider;
        //
        // Issue: 
        //
        // we may want to load only providers that are enabled in this 
        // thread. Use CIMEList to check if tips is enabled.
        //
        if (SUCCEEDED(CoCreateInstance(clsid,
                                       NULL, 
                                       CLSCTX_INPROC_SERVER, 
                                       IID_ITfDisplayAttributeProvider, 
                                       (void**)&pProvider)))
        {
            IEnumTfDisplayAttributeInfo *pEnum;
            if (SUCCEEDED(pProvider->EnumDisplayAttributeInfo(&pEnum)))
            {
                ITfDisplayAttributeInfo *pInfo;

                while (pEnum->Next(1, &pInfo, NULL) == S_OK)
                {
                    GUID guidTemp;
                    if (SUCCEEDED(pInfo->GetGUID(&guidTemp)))
                    { 
                        if (g_pDispAttrGuidCache)
                            g_pDispAttrGuidCache->Add(clsid, guidTemp);
                    }

                    if (_prgUnk->cUnk >= uDAMax)
                    {
                        // need a bigger array
                        uDAMax *= 2;
                        if (!SUA_ReAlloc(&_prgUnk, uDAMax))
                        {
                            pInfo->Release();
                            SUA_Release(_prgUnk);
                            _prgUnk = NULL;
                            goto Exit;
                        }
                    }

                    _prgUnk->rgUnk[_prgUnk->cUnk++] = pInfo;
                }

                pEnum->Release();
            }

            pProvider->Release();
        }
    }

    if (uDAMax > _prgUnk->cUnk)
    {
        // free up unused mem
        SUA_ReAlloc(&_prgUnk, _prgUnk->cUnk);
    }

    fRet = TRUE;

Exit:
    pEnumGUID->Release();

    if (g_pDispAttrGuidCache)
        g_pDispAttrGuidCache->Save();

    return fRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\ctf\uim\debug.c ===
//
//

// This file cannot be compiled as a C++ file, otherwise the linker
// will bail on unresolved externals (even with extern "C" wrapping 
// this).

#include "private.h"

// Define some things for debug.h
//
#define SZ_DEBUGINI     "cicero.ini"
#define SZ_DEBUGSECTION "MSCTF"
#ifndef _WIN64
#define SZ_MODULE       "MSCTF  "
#else
#define SZ_MODULE       "MSCTF64"
#endif
#define DECLARE_DEBUG
#include <debug.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\ctf\uim\dim.cpp ===
//
// CDocumentInputManager.cpp
//

#include "private.h"
#include "dim.h"
#include "globals.h"
#include "tim.h"
#include "emptyic.h"

DBG_ID_INSTANCE(CDocumentInputManager);

/* dca73cc8-e2ed-48c4-8b25-ba2e9908095f */
extern const IID IID_PRIV_CDIM = { 0xdca73cc8, 0xe2ed, 0x48c4, {0x8b, 0x25, 0xba, 0x2e, 0x99, 0x08, 0x09, 0x5f} };
                
//+---------------------------------------------------------------------------
//
// ctor
//
//----------------------------------------------------------------------------

CDocumentInputManager::CDocumentInputManager()
                      : CCompartmentMgr(g_gaApp /* Issue */, COMPTYPE_DIM)
{
    Dbg_MemSetThisNameID(TEXT("CDocumentInputManager"));

    Assert(_peic == NULL);
    _iStack = -1;
}


//+---------------------------------------------------------------------------
//
// dtor
//
//----------------------------------------------------------------------------

CDocumentInputManager::~CDocumentInputManager()
{
    // stack should have been cleared in CThreadInputMgr::RemoveDocumentInputMgr
    Assert(_iStack == -1);

    SafeRelease(_peic);

    //
    // remove this from dim ptr array of TIM.
    //
    CThreadInputMgr *tim;
    if (tim = CThreadInputMgr::_GetThis())
    {
        int i = 0;
        int nCnt = tim->_rgdim.Count();
        CDocumentInputManager **ppdim = tim->_rgdim.GetPtr(0);
        while (i < nCnt)
        {
            if (*ppdim == this)
            {
                tim->_rgdim.Remove(i, 1);
                break;
            }
            i++;
            ppdim++;
        }

        tim->GetDimWndMap()->_Remove(this);
    }

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\ctf\uim\delay.cpp ===
//
// delay.cpp
//
// Delay load imported functions for perf.
//

#include "private.h"
#include "globals.h"

extern "C" BOOL WINAPI ImmSetHotKey(IN DWORD, IN UINT, IN UINT, IN HKL);

CCicCriticalSectionStatic g_csDelayLoad;

FARPROC GetFn(HINSTANCE *phInst, TCHAR *pchLib, TCHAR *pchFunc, BOOL fCheckModule)
{
    Assert(g_dwThreadDllMain != GetCurrentThreadId());

    if (*phInst == 0)
    {
#ifdef DEBUG
        if (!IsOnFE() && !IsOnNT5() && lstrcmp(pchLib, TEXT("imm32.dll")) == 0)
        {
            // what in the heck are we doing loading imm32 on a non-fe system?!
            Assert(0);
        }
#endif
        if (fCheckModule)
        {
            Assert(0);
            return NULL;
        }

        EnterCriticalSection(g_csDelayLoad);

        // need to check again after entering crit sec
        if (*phInst == 0)
        {
            *phInst = LoadSystemLibrary(pchLib);
        }

        LeaveCriticalSection(g_csDelayLoad);

        if (*phInst == 0)
        {
            Assert(0);
            return NULL;
        }
    }

    return GetProcAddress(*phInst, pchFunc);
}

#define DELAYLOAD(_hInst, _DllName, _CallConv, _FuncName, _Args1, _Args2, _RetType, _ErrVal, _CheckModule)   \
_RetType _CallConv _FuncName _Args1                                           \
{                                                                             \
    static FARPROC pfn = NULL;                                                \
                                                                              \
    if (pfn == NULL || _hInst == NULL)                                        \
    {                                                                         \
        pfn = GetFn(&_hInst, #_DllName, #_FuncName, _CheckModule);            \
                                                                              \
        if (pfn == NULL)                                                      \
        {                                                                     \
            Assert(0);                                                        \
            return (_RetType) _ErrVal;                                        \
        }                                                                     \
    }                                                                         \
                                                                              \
    return ((_RetType (_CallConv *)_Args1) (pfn)) _Args2;                     \
}

#define INIT_LOAD(_hInst, _DllName, _CallConv, _FuncName, _Args1, _Args2, _RetType, _ErrVal, _CheckModule)   \
static FARPROC g_pfn_ ## _FuncName ##  = NULL;                                \
void Init_ ## _FuncName ##()                                                  \
{                                                                             \
    if (g_pfn_ ##_FuncName ## == NULL )                                       \
    {                                                                         \
        g_pfn_ ##_FuncName ## = GetProcAddress(_hInst, #_FuncName);           \
                                                                              \
    }                                                                         \
                                                                              \
}                                                                             \
_RetType _CallConv _FuncName _Args1                                           \
{                                                                             \
                                                                              \
    if (!g_pfn_ ## _FuncName ##)                                              \
            return (_RetType) _ErrVal;                                        \
    return ((_RetType (_CallConv *)_Args1) (g_pfn_ ## _FuncName ##)) _Args2;  \
}

//
// imm32.dll
//

HINSTANCE g_hImm32 = 0;

#define IMM32LOAD(_FuncName, _Args1, _Args2, _RetType, _ErrVal, _CheckModule) \
    INIT_LOAD(g_hImm32, imm32.dll, WINAPI, _FuncName, _Args1, _Args2, _RetType, _ErrVal, _CheckModule)


IMM32LOAD( CtfImmCoUninitialize, (void), (), void, FALSE, TRUE)
IMM32LOAD( CtfImmLastEnabledWndDestroy, (LPARAM lParam), (lParam), HRESULT, S_FALSE, TRUE)
IMM32LOAD( CtfImmSetCiceroStartInThread, (BOOL fSet), (fSet), HRESULT, S_FALSE, TRUE)
IMM32LOAD( CtfImmIsCiceroStartedInThread, (void), (), BOOL, FALSE, TRUE)
IMM32LOAD( CtfImmIsCiceroEnabled, (void), (), BOOL, FALSE, TRUE)
IMM32LOAD( CtfImmIsTextFrameServiceDisabled, (void), (), BOOL, FALSE, TRUE)
IMM32LOAD( CtfImmEnterCoInitCountSkipMode, (void), (), BOOL, FALSE, TRUE)
IMM32LOAD( CtfImmLeaveCoInitCountSkipMode, (void), (), BOOL, FALSE, TRUE)

IMM32LOAD( ImmGetDefaultIMEWnd, (HWND hWnd), (hWnd), HWND, 0, FALSE)
IMM32LOAD( ImmReleaseContext, (HWND hWnd, HIMC hIMC), (hWnd, hIMC), BOOL, FALSE, FALSE)
IMM32LOAD( ImmNotifyIME, (HIMC hIMC, DWORD dwAction, DWORD dwIndex, DWORD dwValue), (hIMC, dwAction, dwIndex, dwValue), BOOL, FALSE, FALSE)
IMM32LOAD( ImmSetConversionStatus, (HIMC hIMC, DWORD dw1, DWORD dw2), (hIMC, dw1, dw2), BOOL, FALSE, FALSE)
IMM32LOAD( ImmGetConversionStatus, (HIMC hIMC, LPDWORD pdw1, LPDWORD pdw2), (hIMC, pdw1, pdw2), BOOL, FALSE, FALSE)
IMM32LOAD( ImmGetProperty, (HKL hKL, DWORD dw), (hKL, dw), DWORD, 0, FALSE)
IMM32LOAD( ImmGetOpenStatus, (HIMC hIMC), (hIMC), BOOL, FALSE, FALSE)
IMM32LOAD( ImmGetContext, (HWND hWnd), (hWnd), HIMC, 0, FALSE)
IMM32LOAD( ImmSetOpenStatus, (HIMC hIMC, BOOL f), (hIMC, f), BOOL, FALSE, FALSE)
IMM32LOAD( ImmInstallIMEA, (LPCSTR lpszIMEFileName, LPCSTR lpszLayoutText), (lpszIMEFileName, lpszLayoutText), HKL, 0, FALSE)
IMM32LOAD( ImmGetDescriptionA, (HKL hKL, LPSTR psz, UINT uBufLen), (hKL, psz, uBufLen), UINT, 0, FALSE)
IMM32LOAD( ImmGetDescriptionW, (HKL hKL, LPWSTR psz, UINT uBufLen), (hKL, psz, uBufLen), UINT, 0, FALSE)
IMM32LOAD( ImmGetIMEFileNameA, (HKL hKL, LPSTR lpszFileName, UINT uBufLen), (hKL, lpszFileName, uBufLen), UINT, 0, FALSE)
IMM32LOAD( ImmGetIMEFileNameW, (HKL hKL, LPWSTR lpszFileName, UINT uBufLen), (hKL, lpszFileName, uBufLen), UINT, 0, FALSE)
IMM32LOAD( ImmSetHotKey, (DWORD dwId, UINT uModifiers, UINT uVkey, HKL hkl), (dwId, uModifiers, uVkey, hkl), BOOL, FALSE, FALSE)

#ifdef UNUSED_IMM32_APIS

IMM32LOAD( ImmCreateIMCC, (DWORD dw), (dw), HIMCC, FALSE, FALSE)
IMM32LOAD( ImmIsUIMessageA, (HWND hWnd, UINT u, WPARAM wParam, LPARAM lParam), (hWnd, u, wParam, lParam), BOOL, FALSE, FALSE)
IMM32LOAD( ImmIsUIMessageW, (HWND hWnd, UINT u, WPARAM wParam, LPARAM lParam), (hWnd, u, wParam, lParam), BOOL, FALSE, FALSE)
IMM32LOAD( ImmGetVirtualKey, (HWND hWnd), (hWnd), UINT, VK_PROCESSKEY, FALSE)
IMM32LOAD( ImmSetCompositionWindow, (HIMC hIMC, LPCOMPOSITIONFORM pCF), (hIMC, pCF), BOOL, FALSE, FALSE)
IMM32LOAD( ImmConfigureIMEA, (HKL hKL, HWND hWnd, DWORD dw, LPVOID pv), (hKL, hWnd, dw, pv), BOOL, FALSE, FALSE)
IMM32LOAD( ImmConfigureIMEW, (HKL hKL, HWND hWnd, DWORD dw, LPVOID pv), (hKL, hWnd, dw, pv), BOOL, FALSE, FALSE)
IMM32LOAD( ImmDestroyContext, (HIMC hIMC), (hIMC), BOOL, FALSE, FALSE)
IMM32LOAD( ImmAssociateContext, (HWND hWnd, HIMC hIMC), (hWnd, hIMC), HIMC, 0, FALSE)
IMM32LOAD( ImmEscapeA, (HKL hKL, HIMC hIMC, UINT u, LPVOID pv), (hKL, hIMC, u, pv), LRESULT, 0, FALSE)
IMM32LOAD( ImmEscapeW, (HKL hKL, HIMC hIMC, UINT u, LPVOID pv), (hKL, hIMC, u, pv), LRESULT, 0, FALSE)
IMM32LOAD( ImmIsIME, (HKL hKL), (hKL), BOOL, FALSE, FALSE)
IMM32LOAD( ImmCreateContext, (void), (), HIMC, 0, FALSE)
IMM32LOAD( ImmGetCompositionFontA, (HIMC hIMC, LPLOGFONTA plf), (hIMC, plf), BOOL, FALSE, FALSE)
IMM32LOAD( ImmGetCompositionFontW, (HIMC hIMC, LPLOGFONTW plf), (hIMC, plf), BOOL, FALSE, FALSE)
IMM32LOAD( ImmGetCandidateWindow, (HIMC hIMC, DWORD dw, LPCANDIDATEFORM pCF), (hIMC, dw, pCF), BOOL, FALSE, FALSE)
IMM32LOAD( ImmGetCandidateListA, (HIMC hIMC, DWORD dwIndex, LPCANDIDATELIST lpCandList, DWORD dwBufLen), (hIMC, dwIndex, lpCandList, dwBufLen), DWORD, 0, FALSE)
IMM32LOAD( ImmGetCandidateListW, (HIMC hIMC, DWORD dwIndex, LPCANDIDATELIST lpCandList, DWORD dwBufLen), (hIMC, dwIndex, lpCandList, dwBufLen), DWORD, 0, FALSE)
IMM32LOAD( ImmGetCandidateListCountA, (HIMC hIMC, LPDWORD lpdwListCount), (hIMC, lpdwListCount), DWORD, 0, FALSE)
IMM32LOAD( ImmGetCandidateListCountW, (HIMC hIMC, LPDWORD lpdwListCount), (hIMC, lpdwListCount), DWORD, 0, FALSE)
IMM32LOAD( ImmGetCompositionStringA, (HIMC hIMC, DWORD dw1, LPVOID pv, DWORD dw2), (hIMC, dw1, pv, dw2), LONG, 0, FALSE)
IMM32LOAD( ImmGetCompositionStringW, (HIMC hIMC, DWORD dw1, LPVOID pv, DWORD dw2), (hIMC, dw1, pv, dw2), LONG, 0, FALSE)
IMM32LOAD( ImmGetCompositionWindow, (HIMC hIMC, LPCOMPOSITIONFORM pCF), (hIMC, pCF), BOOL, FALSE, FALSE)
IMM32LOAD( ImmGetConversionListA, (HKL hKL, HIMC hIMC, LPCSTR psz, LPCANDIDATELIST pCL, DWORD dwBufLen, UINT uFlag), (hKL, hIMC, psz, pCL, dwBufLen, uFlag), DWORD, 0, FALSE)
IMM32LOAD( ImmGetConversionListW, (HKL hKL, HIMC hIMC, LPCWSTR psz, LPCANDIDATELIST pCL, DWORD dwBufLen, UINT uFlag), (hKL, hIMC, psz, pCL, dwBufLen, uFlag), DWORD, 0, FALSE)
IMM32LOAD( ImmGetStatusWindowPos, (HIMC hIMC, LPPOINT lpptPos), (hIMC, lpptPos), BOOL, FALSE, FALSE)
IMM32LOAD( ImmSetStatusWindowPos, (HIMC hIMC, LPPOINT lpptPos), (hIMC, lpptPos), BOOL, FALSE, FALSE)
IMM32LOAD( ImmGetIMCCSize, (HIMCC hIMCC), (hIMCC), DWORD, 0, FALSE)
IMM32LOAD( ImmReSizeIMCC, (HIMCC hIMCC, DWORD dw), (hIMCC, dw), HIMCC, 0, FALSE)
IMM32LOAD( ImmUnlockIMCC, (HIMCC hIMCC), (hIMCC), BOOL, FALSE, FALSE)
IMM32LOAD( ImmLockIMCC, (HIMCC hIMCC), (hIMCC), LPVOID, NULL, FALSE)
IMM32LOAD( ImmDestroyIMCC, (HIMCC hIMCC), (hIMCC), HIMCC, hIMCC, FALSE)
IMM32LOAD( ImmUnlockIMC, (HIMC hIMC), (hIMC), BOOL, FALSE, FALSE)
IMM32LOAD( ImmLockIMC, (HIMC hIMC), (hIMC), LPINPUTCONTEXT, NULL, FALSE)
IMM32LOAD( ImmSetCompositionStringA, (HIMC hIMC, DWORD dwIndex, LPCVOID lpComp, DWORD dw1, LPCVOID lpRead, DWORD dw2), (hIMC, dwIndex, lpComp, dw1, lpRead, dw2), BOOL, FALSE, FALSE)
IMM32LOAD( ImmSetCompositionStringW, (HIMC hIMC, DWORD dwIndex, LPCVOID lpComp, DWORD dw1, LPCVOID lpRead, DWORD dw2), (hIMC, dwIndex, lpComp, dw1, lpRead, dw2), BOOL, FALSE, FALSE)
IMM32LOAD( ImmSetCompositionFontA, (HIMC hIMC, LPLOGFONTA plf), (hIMC, plf), BOOL, FALSE, FALSE)
IMM32LOAD( ImmSetCompositionFontW, (HIMC hIMC, LPLOGFONTW plf), (hIMC, plf), BOOL, FALSE, FALSE)
IMM32LOAD( ImmSetCandidateWindow, (HIMC hIMC, LPCANDIDATEFORM pCF), (hIMC, pCF), BOOL, FALSE, FALSE)
IMM32LOAD( ImmRegisterWordA, (HKL hKL, LPCSTR lpszReading, DWORD dw, LPCSTR lpszRegister), (hKL, lpszReading, dw, lpszRegister), BOOL, FALSE, FALSE)
IMM32LOAD( ImmRegisterWordW, (HKL hKL, LPCWSTR lpszReading, DWORD dw, LPCWSTR lpszRegister), (hKL, lpszReading, dw, lpszRegister), BOOL, FALSE, FALSE)
IMM32LOAD( ImmUnregisterWordA, (HKL hKL, LPCSTR lpszReading, DWORD dw, LPCSTR lpszUnregister), (hKL, lpszReading, dw, lpszUnregister), BOOL, FALSE, FALSE)
IMM32LOAD( ImmUnregisterWordW, (HKL hKL, LPCWSTR lpszReading, DWORD dw, LPCWSTR lpszUnregister), (hKL, lpszReading, dw, lpszUnregister), BOOL, FALSE, FALSE)
IMM32LOAD( ImmGetRegisterWordStyleA, (HKL hKL, UINT nItem, LPSTYLEBUFA lpStyleBuf), (hKL, nItem, lpStyleBuf), UINT, 0, FALSE)
IMM32LOAD( ImmGetRegisterWordStyleW, (HKL hKL, UINT nItem, LPSTYLEBUFW lpStyleBuf), (hKL, nItem, lpStyleBuf), UINT, 0, FALSE)
IMM32LOAD( ImmSimulateHotKey, (HWND hWnd, DWORD dwHotKeyID), (hWnd, dwHotKeyID), BOOL, FALSE, FALSE)
IMM32LOAD( ImmGetGuideLineA, (HIMC hIMC, DWORD dwIndex, LPSTR lpBuf, DWORD dwBufLen), (hIMC, dwIndex, lpBuf, dwBufLen), DWORD, 0, FALSE)
IMM32LOAD( ImmGetGuideLineW, (HIMC hIMC, DWORD dwIndex, LPWSTR lpBuf, DWORD dwBufLen), (hIMC, dwIndex, lpBuf, dwBufLen), DWORD, 0, FALSE)
IMM32LOAD( ImmGetIMEFileNameA, (HKL hKL, LPSTR lpszFileName, UINT uBufLen), (hKL, lpszFileName, uBufLen), UINT, 0, FALSE)
IMM32LOAD( ImmGetIMEFileNameW, (HKL hKL, LPWSTR lpszFileName, UINT uBufLen), (hKL, lpszFileName, uBufLen), UINT, 0, FALSE)
IMM32LOAD( ImmAssociateContextEx, (HWND hWnd, HIMC hIMC, DWORD dwFlags), (hWnd, hIMC, dwFlags), BOOL, FALSE, FALSE)
IMM32LOAD( ImmDisableIME, (DWORD dwId), (dwId), BOOL, FALSE, FALSE)
IMM32LOAD( ImmGetImeMenuItemsA, (HIMC hIMC, DWORD dwFlags, DWORD dwType, IMEMENUITEMINFOA *pImeParentMenu, IMEMENUITEMINFOA *pImeMenu, DWORD dwSize), (hIMC, dwFlags, dwType, pImeParentMenu, pImeMenu, dwSize), DWORD, 0, FALSE)
IMM32LOAD( ImmGetImeMenuItemsW, (HIMC hIMC, DWORD dwFlags, DWORD dwType, IMEMENUITEMINFOW *pImeParentMenu, IMEMENUITEMINFOW *pImeMenu, DWORD dwSize), (hIMC, dwFlags, dwType, pImeParentMenu, pImeMenu, dwSize), DWORD, 0, FALSE)
IMM32LOAD( ImmRequestMessageA, (HIMC hIMC, WPARAM wParam, LPARAM lParam), (hIMC, wParam, lParam), LRESULT, 0, FALSE)
IMM32LOAD( ImmRequestMessageW, (HIMC hIMC, WPARAM wParam, LPARAM lParam), (hIMC, wParam, lParam), LRESULT, 0, FALSE)

#endif // UNUSED_IMM32_APIS

//
// shell32.dll
//

HINSTANCE g_hShell32 = 0;

UINT STDAPICALLTYPE Internal_ExtractIconExA(LPCTSTR lpszFile, int nIconIndex, HICON *phiconLarge, HICON *phiconSmall, UINT nIcons)
{
    static FARPROC pfn = NULL;

    if (pfn == NULL || g_hShell32 == NULL)
    {
        pfn = GetFn(&g_hShell32, "shell32.dll", "ExtractIconExA", FALSE);

        if (pfn == NULL)
        {
            Assert(0);
            return 0;
        }
    }

    return ((UINT (STDAPICALLTYPE *)(LPCTSTR lpszFile, int nIconIndex, HICON *phiconLarge, HICON *phiconSmall, UINT nIcons))(pfn))(lpszFile, nIconIndex, phiconLarge, phiconSmall, nIcons);
}

HINSTANCE g_hShlwapi = 0;

HRESULT STDAPICALLTYPE Internal_SHLoadRegUIStringW(HKEY hkey, LPCWSTR pszValue, LPWSTR pszOutBuf, UINT cchOutBuf)
{
    static FARPROC pfn = NULL;

    if (pfn == NULL || g_hShlwapi == NULL)
    {
#if 0
        if (g_hShlwapi == 0)
        {
            EnterCriticalSection(g_csDelayLoad);
            if (g_hShlwapi == 0)
            {
                g_hShlwapi = LoadSystemLibrary("shlwapi.dll");
            }
            LeaveCriticalSection(g_csDelayLoad);

            if (g_hShlwapi == 0)
            {
                Assert(0);
                return E_FAIL;
            }
        }

        pfn = GetProcAddress(g_hShlwapi, (LPSTR) 439);
#else
        pfn = GetFn(&g_hShlwapi, "shlwapi.dll", (LPSTR)439, FALSE);
#endif

        if (pfn == NULL)
        {
            Assert(0);
            return E_FAIL;
        }
    }

    return ((HRESULT (STDAPICALLTYPE *)(HKEY hkey, LPCWSTR pszValue, LPWSTR pszOutBuf, UINT cchOutBuf))(pfn))(hkey, pszValue, pszOutBuf, cchOutBuf);
}

//
// ole32
//
HINSTANCE g_hOle32 = 0;

HRESULT STDAPICALLTYPE Internal_CoCreateInstance(REFCLSID rclsid, LPUNKNOWN punkOuter, DWORD dwClsContext, REFIID riid, LPVOID *ppv)
{
    static FARPROC pfn = NULL;

    if (pfn == NULL || g_hOle32 == NULL)
    {
        pfn = GetFn(&g_hOle32, "ole32.dll", "CoCreateInstance", FALSE);

        if (pfn == NULL)
        {
            Assert(0);
            if (ppv != NULL)
            {
                *ppv = NULL;
            }
            return E_FAIL;
        }
    }

    return ((HRESULT (STDAPICALLTYPE *)(REFCLSID rclsid, LPUNKNOWN punkOuter, DWORD dwClsContext, REFIID riid, LPVOID *ppv))(pfn))(rclsid, punkOuter, dwClsContext, riid, ppv);
}

LPVOID STDAPICALLTYPE Internal_CoTaskMemAlloc(ULONG cb)
{
    static FARPROC pfn = NULL;

    if (pfn == NULL || g_hOle32 == NULL)
    {
        pfn = GetFn(&g_hOle32, "ole32.dll", "CoTaskMemAlloc", FALSE);

        if (pfn == NULL)
        {
            Assert(0);
            return NULL;
        }
    }

    return ((LPVOID (STDAPICALLTYPE *)(ULONG cb))(pfn))(cb);
}

LPVOID STDAPICALLTYPE Internal_CoTaskMemRealloc(LPVOID pv, ULONG cb)
{
    static FARPROC pfn = NULL;

    if (pfn == NULL || g_hOle32 == NULL)
    {
        pfn = GetFn(&g_hOle32, "ole32.dll", "CoTaskMemRealloc", FALSE);

        if (pfn == NULL)
        {
            Assert(0);
            return NULL;
        }
    }

    return ((LPVOID (STDAPICALLTYPE *)(LPVOID pv, ULONG cb))(pfn))(pv, cb);
}

void STDAPICALLTYPE Internal_CoTaskMemFree(void *pv)
{
    static FARPROC pfn = NULL;

    if (pfn == NULL || g_hOle32 == NULL)
    {
        pfn = GetFn(&g_hOle32, "ole32.dll", "CoTaskMemFree", FALSE);

        if (pfn == NULL)
        {
            Assert(0);
            return;
        }
    }

    ((void (STDAPICALLTYPE *)(void *pv))(pfn))(pv);
}

void STDAPICALLTYPE Internal_ReleaseStgMedium(STGMEDIUM *pMedium)
{
    static FARPROC pfn = NULL;

    if (pfn == NULL || g_hOle32 == NULL)
    {
        pfn = GetFn(&g_hOle32, "ole32.dll", "ReleaseStgMedium", FALSE);

        if (pfn == NULL)
        {
            Assert(0);
            return;
        }
    }

    ((void (STDAPICALLTYPE *)(STGMEDIUM *pMedium))(pfn))(pMedium);
}

#pragma warning(disable: 4715)  //  not all control paths return a value
HRESULT STDAPICALLTYPE Internal_CoInitialize(void *pv)
{
    static FARPROC pfn = NULL;

    if (pfn == NULL || g_hOle32 == NULL)
    {
        pfn = GetFn(&g_hOle32, "ole32.dll", "CoInitialize", FALSE);

        if (pfn == NULL)
        {
            Assert(0);
            return E_FAIL;
        }
    }

    ((HRESULT (STDAPICALLTYPE *)(void *pv))(pfn))(pv);
}

HRESULT STDAPICALLTYPE Internal_CoUninitialize(void)
{
    static FARPROC pfn = NULL;

    if (pfn == NULL || g_hOle32 == NULL)
    {
        pfn = GetFn(&g_hOle32, "ole32.dll", "CoUninitialize", FALSE);

        if (pfn == NULL)
        {
            Assert(0);
            return E_FAIL;
        }
    }

    ((HRESULT (STDAPICALLTYPE *)(void))(pfn))();
}
#pragma warning(3: 4715)  //  not all control paths return a value

void InitDelayedLibs()
{
    //
    // This is called in DllMain(). Don't do LoadLibrary().
    //
    g_hImm32 = GetSystemModuleHandle("imm32.dll");

    Init_CtfImmCoUninitialize();
    Init_CtfImmLastEnabledWndDestroy();
    Init_CtfImmSetCiceroStartInThread();
    Init_CtfImmIsCiceroStartedInThread();
    Init_CtfImmIsCiceroEnabled();
    Init_CtfImmIsTextFrameServiceDisabled();
    Init_CtfImmEnterCoInitCountSkipMode();
    Init_CtfImmLeaveCoInitCountSkipMode();
    Init_ImmGetDefaultIMEWnd();
    Init_ImmReleaseContext();
    Init_ImmNotifyIME();
    Init_ImmSetConversionStatus();
    Init_ImmGetConversionStatus();
    Init_ImmGetProperty();
    Init_ImmGetOpenStatus();
    Init_ImmGetContext();
    Init_ImmSetOpenStatus();
    Init_ImmInstallIMEA();
    Init_ImmGetDescriptionA();
    Init_ImmGetDescriptionW();
    Init_ImmGetIMEFileNameA();
    Init_ImmGetIMEFileNameW();
    Init_ImmSetHotKey();
}

void ReleaseDelayedLibs()
{
    EnterCriticalSection(g_csDelayLoad);

    if (g_hShell32 != NULL)
    {
        FreeLibrary(g_hShell32);
        g_hShell32 = NULL;
    }

    if (g_hShlwapi != NULL)
    {
        FreeLibrary(g_hShlwapi);
        g_hShlwapi = NULL;
    }

    if (g_hOle32 != NULL)
    {
        FreeLibrary(g_hOle32);
        g_hOle32 = NULL;
    }

    LeaveCriticalSection(g_csDelayLoad);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\ctf\uim\delay.h ===
//
// delay.h
//

#ifndef DELAY_H
#define DELAY_H

//
// imm32
//

void WINAPI CtfImmCoUninitialize();
HRESULT WINAPI CtfImmLastEnabledWndDestroy(LPARAM lParam);
HRESULT WINAPI CtfImmSetCiceroStartInThread(BOOL fSet);
BOOL WINAPI CtfImmEnterCoInitCountSkipMode();
BOOL WINAPI CtfImmLeaveCoInitCountSkipMode();

//
// shell32
//

UINT STDAPICALLTYPE Internal_ExtractIconExA(LPCTSTR lpszFile, int nIconIndex, HICON *phiconLarge, HICON *phiconSmall, UINT nIcons);
#define ExtractIconExA Internal_ExtractIconExA

//
// shwapi
//

HRESULT STDAPICALLTYPE Internal_SHLoadRegUIStringW(HKEY hkey, LPCWSTR pszValue, LPWSTR pszOutBuf, UINT cchOutBuf);
#define SHLoadRegUIStringW Internal_SHLoadRegUIStringW

//
// ole32
//

HRESULT STDAPICALLTYPE Internal_CoCreateInstance(REFCLSID rclsid, LPUNKNOWN punkOuter, DWORD dwClsContext, REFIID riid, LPVOID *ppv);
#define CoCreateInstance Internal_CoCreateInstance

void STDAPICALLTYPE Internal_ReleaseStgMedium(STGMEDIUM *pMedium);
#define ReleaseStgMedium Internal_ReleaseStgMedium

LPVOID STDAPICALLTYPE Internal_CoTaskMemAlloc(ULONG cb);
#define CoTaskMemAlloc Internal_CoTaskMemAlloc

LPVOID STDAPICALLTYPE Internal_CoTaskMemRealloc(LPVOID pv, ULONG cb);
#define CoTaskMemRealloc Internal_CoTaskMemRealloc

void STDAPICALLTYPE Internal_CoTaskMemFree(void *pv);
#define CoTaskMemFree Internal_CoTaskMemFree

HRESULT STDAPICALLTYPE Internal_CoInitialize(void *pv);
#define CoInitialize Internal_CoInitialize

HRESULT STDAPICALLTYPE Internal_CoUninitialize(void);
#define CoUninitialize Internal_CoUninitialize

void InitDelayedLibs();

#endif // DELAY_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\ctf\uim\dim.h ===
//
// dim.h
//

#ifndef DIM_H
#define DIM_H

#include "private.h"
#include "compart.h"

#define ICS_STACK_SIZE 2

class CInputContext;
class CEmptyInputContext;

extern const IID IID_PRIV_CDIM;

class CDocumentInputManager : public ITfDocumentMgr,
                              public CCompartmentMgr,
                              public CComObjectRootImmx
{
public:
    CDocumentInputManager();
    ~CDocumentInputManager();

    BEGIN_COM_MAP_IMMX(CDocumentInputManager)
        COM_INTERFACE_ENTRY(ITfDocumentMgr)
        COM_INTERFACE_ENTRY(ITfCompartmentMgr)
        COM_INTERFACE_ENTRY_IID(IID_PRIV_CDIM, CDocumentInputManager)
    END_COM_MAP_IMMX()

    IMMX_OBJECT_IUNKNOWN_FOR_ATL()

    //
    // ITfDocumentManager
    //
    STDMETHODIMP CreateContext(TfClientId tid, DWORD dwFlags, IUnknown *punk, ITfContext **ppic, TfEditCookie *pecTextStore);
    STDMETHODIMP Push(ITfContext *pic);
    STDMETHODIMP Pop(DWORD dwFlags);
    STDMETHODIMP GetTop(ITfContext **ppic);
    STDMETHODIMP GetBase(ITfContext **ppBase);
    STDMETHODIMP EnumContexts(IEnumTfContexts **ppEnum);

    BOOL _Pop(CThreadInputMgr *tim);

    HRESULT _GetContext(int iStack, ITfContext **ppic);

    CInputContext *_GetTopIC();

    int _GetCurrentStack() { return _iStack; }

    CInputContext *_GetIC(int iStack)
    {
         if (iStack < 0)
             return NULL;
         if (iStack > _iStack)
             return NULL;

         return _Stack[iStack];
    }

private:
    CInputContext *_Stack[ICS_STACK_SIZE];
    int _iStack;
    BOOL _fPoppingStack : 1;

    CEmptyInputContext *_peic;

    DBG_ID_DECLARE;
};

inline CDocumentInputManager *GetCDocumentInputMgr(IUnknown *punk)
{
    CDocumentInputManager *dim;

    punk->QueryInterface(IID_PRIV_CDIM, (void **)&dim);

    return dim;
}

#endif // DIM_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\ctf\uim\default.cpp ===
//
// default.cpp
//

#include "private.h"
#include "globals.h"
#include "imelist.h"
#include "tim.h"
#include "nuimgr.h"
#include "nuihkl.h"
#include "nuictrl.h"
#include "catmgr.h"
#include "imelist.h"
#include "ptrary.h"
#include "ic.h"
#include "assembly.h"
#include "profiles.h"
#include "imelist.h"
#include "ithdmshl.h"
#include "marshal.h"
#include "mstub.h"
#include "smblock.h"
#include "timlist.h"
#include "thdutil.h"
#include "utb.h"
#include "mui.h"
#include "hotkey.h"
#include "profiles.h"
#include "lbaddin.h"
#include "cregkey.h"

CPtrArray<SYSTHREAD> *g_rgSysThread = NULL;

BOOL IsConsoleWindow(HWND hWnd);
void InitThreadHook(DWORD dwThreadId);
void UninitThreadHooks(SYSTHREAD *psfn);
void DestroyMarshalWindow(SYSTHREAD* psfn, HWND hwnd);
UINT _CBTHook(int nCode, WPARAM wParam, LPARAM lParam);
UINT _ShellProc(int nCode, WPARAM wParam, LPARAM lParam);
UINT _GetMsgHook(WPARAM wParam, LPARAM lParam);
UINT _KeyboardHook(WPARAM wParam, LPARAM lParam);

// crazy workaround for a system bug
// sometimes our hook procs will be called after
// we are detached.  By this time we've unmapped
// our shared memory, so keep around a local copy.
static HHOOK s_hSysShellHook = 0;

static HHOOK s_hSysGetMsgHook = 0;
static HHOOK s_hSysCBTHook = 0;

// handling old input CPL
static BOOL g_fLoadedCPLName = FALSE;
static BOOL g_fCHWin9x = FALSE;
static BOOL g_fCHNT4 = FALSE;

TCHAR g_szKbdCPLName[128];
TCHAR g_szKbdCPLTitle[128];
TCHAR g_szWinCHCPLName[128];
TCHAR g_szWinCHCPLTitle[128];
TCHAR g_szNTCPLName[128];
TCHAR g_szNTCPLTitle[128];
TCHAR g_szOldCPLMsg[256];
TCHAR g_szCPLButton[128];
TCHAR g_szCPLGroupBox[128];
TCHAR g_szCHNT4CPLName[128];
TCHAR g_szCHNT4CPLTitle1[128];
TCHAR g_szCHNT4CPLTitle2[128];
TCHAR g_szCH9xKbdCPLTitle[128];

const CHAR c_szIntlCPLFetchClass[] = "IntlNewInputLocaleWndlClass";

// CPL window name and input locale tab title name RC ids
#define NTCPLNAMEID         1
#define NTCPLTITLEID        107
#define WINCPLNAMEID        102
//#define WINCPLTITLEID       42
#define WINCPLTITLEID       104
#define WINCPLCHNAMEID      112
#define WINCPLCHTITLEID     107
#define CHNT4CPLNAMEID      64
#define CHNT4CPLTITLEID1     1
#define CHNT4CPLTITLEID2     2

// CPL file names
#define MAINCPL             TEXT("main.cpl")
#define INTLCPL             TEXT("intl.cpl")
#define CHIMECPL            TEXT("cime.cpl")

inline int SafeGetWindowText(HWND hWnd, LPTSTR szString, int nMaxCount)
{
    int iRet;
    
    iRet = GetWindowText(hWnd, szString, nMaxCount);
    if (nMaxCount > 0)
    {
        // make sure the string is NULL terminated
        // we're not supposed to have to do this, but we're seeing a bug
        // where GetWindowText won't NULL terminate the string if it
        // occupies the whole buffer.
        if (iRet < nMaxCount && iRet >= 0)
        {
            szString[iRet] = 0;
        }
        else
        {
            szString[nMaxCount-1] = 0;
        }
    }

    return iRet;
}

//+---------------------------------------------------------------------------
//
// InitStaticHooks
//
//+---------------------------------------------------------------------------

void InitStaticHooks()
{
    Assert(GetSharedMemory() != NULL);

#if 1
    if (GetSharedMemory() == NULL && ! IsSharedMemoryCreated())
    {
        // Shared memory already closed.
        return;
    }
#endif

    s_hSysShellHook         = GetSharedMemory()->hSysShellHook.GetHandle(g_bOnWow64);

    s_hSysGetMsgHook   = GetSharedMemory()->hSysGetMsgHook.GetHandle(g_bOnWow64);
    s_hSysCBTHook      = GetSharedMemory()->hSysCBTHook.GetHandle(g_bOnWow64);
}

//+---------------------------------------------------------------------------
//
// FindSYSTHREAD
//
//+---------------------------------------------------------------------------

SYSTHREAD *FindSYSTHREAD()
{
    SYSTHREAD *psfn;

    if (g_dwTLSIndex == (DWORD)-1)
        return NULL;

    psfn = (SYSTHREAD *)TlsGetValue(g_dwTLSIndex);

    return psfn;
}

//+---------------------------------------------------------------------------
//
// GetSYSTHREAD
//
//+---------------------------------------------------------------------------

SYSTHREAD *GetSYSTHREAD()
{
    SYSTHREAD *psfn;

    if (g_dwTLSIndex == (DWORD)-1)
        return NULL;

    psfn = (SYSTHREAD *)TlsGetValue(g_dwTLSIndex);

    if (!psfn)
    {
        //
        // we don't allocate psfn after detached.
        //
        if (g_fDllProcessDetached)
            return NULL;

        psfn = (SYSTHREAD *)cicMemAllocClear(sizeof(SYSTHREAD));
        if (!TlsSetValue(g_dwTLSIndex, psfn))
        {
            cicMemFree(psfn);
            psfn = NULL;
        }

        if (psfn)
        {
            psfn->dwThreadId = GetCurrentThreadId();
            psfn->dwProcessId = GetCurrentProcessId();

            CicEnterCriticalSection(g_csInDllMain);

            if (!g_rgSysThread)
                g_rgSysThread = new CPtrArray<SYSTHREAD>;
            
            if (g_rgSysThread)
            {
                if (g_rgSysThread->Insert(0, 1))
                    g_rgSysThread->Set(0, psfn);
            }

            CicLeaveCriticalSection(g_csInDllMain);

            //
            // init nModalLangBarId
            //
            psfn->nModalLangBarId = -1;
            EnsureTIMList(psfn);
        }
    }

    return psfn;
}


//+---------------------------------------------------------------------------
//
// FreeSYSTHREAD2
//
//+---------------------------------------------------------------------------

void FreeSYSTHREAD2(SYSTHREAD *psfn)
{
    Assert(psfn); // it's caller's responsibility to pass in a valid psfn
    Assert(psfn->ptim == NULL); // someone leaked us?
    Assert(psfn->pipp == NULL); // someone leaked us?
    Assert(psfn->pdam == NULL); // someone leaked us?

    UninitThreadHooks(psfn);

    UninitLangBarAddIns(psfn);
    delete psfn->_pGlobalCompMgr;
    psfn->_pGlobalCompMgr = NULL;

    if (psfn->plbim)
    {
        psfn->plbim->_RemoveSystemItems(psfn);
    }

    FreeMarshaledStubs(psfn);

    if (psfn->plbim)
    {
        TraceMsg(TF_GENERAL, "FreeSYSTHREAD2 clean up plbim");
        //
        // Clean up a pointer that is marshalled to UTB.
        //
        delete psfn->plbim;
        psfn->plbim = NULL;
    }

    if (psfn->ptim)
        psfn->ptim->ClearLangBarItemMgr();

    CicEnterCriticalSection(g_csInDllMain);

    if (g_rgSysThread)
    {
        int nCnt = g_rgSysThread->Count();
        while (nCnt)
        {
            nCnt--;
            if (g_rgSysThread->Get(nCnt) == psfn)
            {
                g_rgSysThread->Remove(nCnt, 1);
                break;
            }
        }
    }

    CicLeaveCriticalSection(g_csInDllMain);

    if (psfn->pAsmList)
    {
        delete psfn->pAsmList;
        psfn->pAsmList = NULL;
    }

    //
    // remove the timlist entry for the current thread.
    //
    psfn->pti = NULL;
    g_timlist.RemoveThread(psfn->dwThreadId);

    DestroySharedHeap(psfn);
    DestroySharedBlocks(psfn);

    cicMemFree(psfn);
}

void FreeSYSTHREAD()
{
    SYSTHREAD *psfn = (SYSTHREAD *)TlsGetValue(g_dwTLSIndex);
    if (psfn)
    {
        //
        // don't call ClearLangBarAddIns in FreeSYSTHREAD2.
        // it is not safe to call this in DllMain(PROCESS_DETACH).
        //
        ClearLangBarAddIns(psfn, CLSID_NULL);

        FreeSYSTHREAD2(psfn);
        TlsSetValue(g_dwTLSIndex, NULL);
    }
}

//+---------------------------------------------------------------------------
//
// EnsureAssemblyList
//
//+---------------------------------------------------------------------------

CAssemblyList *EnsureAssemblyList(SYSTHREAD *psfn, BOOL fUpdate)
{
    if (!fUpdate && psfn->pAsmList)
        return psfn->pAsmList;

    if (!psfn->pAsmList)
        psfn->pAsmList = new CAssemblyList;

    if (psfn->pAsmList)
    {
        psfn->pAsmList->Load();

        UpdateSystemLangBarItems(psfn, NULL, TRUE);

        if (psfn->plbim && psfn->plbim->_GetLBarItemCtrl())
            psfn->plbim->_GetLBarItemCtrl()->_AsmListUpdated(TRUE);

    }

    return psfn->pAsmList;
}

//+---------------------------------------------------------------------------
//
// UpdateRegIMXHandler()
//
//+---------------------------------------------------------------------------

void UpdateRegIMXHandler()
{
    SYSTHREAD *psfn = GetSYSTHREAD();

    //
    //  clear Category cache
    //
    CCategoryMgr::FreeCatCache();

    TF_InitMlngInfo();

    //
    //  Update Assembly list
    //
    if (psfn && psfn->pAsmList)
    {
        EnsureAssemblyList(psfn, TRUE);

        if (!psfn->pAsmList->FindAssemblyByLangId(GetCurrentAssemblyLangId(psfn)))
        {
            CAssembly *pAsm = psfn->pAsmList->GetAssembly(0);
            if (pAsm)
                ActivateAssembly(pAsm->GetLangId(), ACTASM_NONE);
        }
    }
}

//+---------------------------------------------------------------------------
//
// GetCurrentAssemblyLangid
//
//+---------------------------------------------------------------------------

LANGID GetCurrentAssemblyLangId(SYSTHREAD *psfn)
{
    if (!psfn)
    {
        psfn = GetSYSTHREAD();
        if (!psfn)
            return 0;
    }

    if (!psfn->langidCurrent)
    {
        HKL hKL = GetKeyboardLayout(NULL);
        psfn->langidPrev = psfn->langidCurrent;
        psfn->langidCurrent = LANGIDFROMHKL(hKL);
    }

    return psfn->langidCurrent;
}

//+---------------------------------------------------------------------------
//
// SetCurrentAssemblyLangid
//
//+---------------------------------------------------------------------------

void SetCurrentAssemblyLangId(SYSTHREAD *psfn, LANGID langid)
{
    psfn->langidPrev = psfn->langidCurrent;
    psfn->langidCurrent = langid;
}

//+---------------------------------------------------------------------------
//
// CheckVisibleWindowEnumProc
//
// find any other visible window in the thread.
//
//+---------------------------------------------------------------------------

typedef struct tag_CHECKVISIBLEWND {
    BOOL fVisibleFound;
    HWND hwndBeingDestroyed;
    HWND hwndMarshal;
} CHECKVISIBLEWND;

BOOL CheckVisibleWindowEnumProc(HWND hwnd, LPARAM lParam)
{
    CHECKVISIBLEWND *pcmw = (CHECKVISIBLEWND *)lParam;
    LONG_PTR style;

    //
    // skip itself.
    //
    if (pcmw->hwndMarshal == hwnd)
        return TRUE;

    //
    // skip one being destroyed.
    //
    if (pcmw->hwndBeingDestroyed == hwnd)
        return TRUE;

    //
    // skip IME windows.
    //
    style = GetClassLongPtr(hwnd, GCL_STYLE);
    if (style & CS_IME)
        return TRUE;

    //
    // skip disable windows if it is not NT4.
    //
    // we disabled code on NT4 because mashaling window is not in HWND_MSG.
    //
    if (IsOnNT5())
    {
        style = GetWindowLongPtr(hwnd, GWL_STYLE);
        if (style & WS_DISABLED)
            return TRUE;
    }

    //
    // skip in visible windows.
    //
    if (!IsWindowVisible(hwnd))
        return TRUE;

    //
    // skip in destroy windows.
    //

    // #624872
    // This is private user32 function.
    // Due to dead lock of LdrpLoaderLock, we don't use delay load.
    if (IsWindowInDestroy(hwnd))
        return TRUE;

    //
    // ok, we found visible window and stop enumerating.
    //
    pcmw->fVisibleFound = TRUE;

    return FALSE;
}

#ifdef CUAS_ENABLE
//+---------------------------------------------------------------------------
//
// CheckNoWindowEnumProc
//
// find any other window in the thread.
//
//+---------------------------------------------------------------------------

typedef struct tag_CHECKNOWND {
    BOOL fWindowFound;
    HWND hwndBeingDestroyed;
} CHECKNOWND;

BOOL CheckNoWindowEnumProc(HWND hwnd, LPARAM lParam)
{
    CHECKNOWND *pcmw = (CHECKNOWND *)lParam;

    //
    // skip one being destroyed.
    //
    if (pcmw->hwndBeingDestroyed == hwnd)
        return TRUE;

    //
    // ok, we found window and stop enumerating.
    //
    pcmw->fWindowFound = TRUE;

    return FALSE;
}
#endif // CUAS_ENABLE


//+---------------------------------------------------------------------------
//
// IsConsoleWindow
//
//+---------------------------------------------------------------------------

#define CONSOLE_WINDOW_CLASS     TEXT("ConsoleWindowClass")

BOOL IsConsoleWindow(HWND hWnd)
{
    if (IsOnNT())
    {
        int n;
        char szClass[33];

        n = GetClassName(hWnd, szClass, sizeof(szClass)-1);

        szClass[n] = TEXT('\0');

        if (lstrcmp(szClass, CONSOLE_WINDOW_CLASS) == 0)
        {
            return TRUE;
        }
    }

    return FALSE;
}

//+---------------------------------------------------------------------------
//
// Input_EnumChildWndProc
//
// disable all controls that is in legacy keyboard property page.
//+---------------------------------------------------------------------------

BOOL CALLBACK Input_EnumChildWndProc(HWND hwnd, LPARAM lParam)
{

    EnableWindow(hwnd, FALSE);
    ShowWindow(hwnd, SW_HIDE);

    return TRUE;
}

//+---------------------------------------------------------------------------
//
// IntlCPLFetchWndProc
//
//+---------------------------------------------------------------------------

LRESULT CALLBACK IntlCPLFetchWndProc(HWND hwnd, UINT message, WPARAM wParam, LPARAM lParam)
{
    switch (message)
    {
        case (WM_CREATE) :
        {
            HWND hwndStatic;
            HWND hwndButton;
            HWND hwndGroup;
            RECT rc;
            HFONT hFont;

            GetWindowRect(hwnd, &rc);

            hwndGroup = CreateWindow(TEXT("button"), g_szCPLGroupBox,
                                      WS_CHILD | WS_VISIBLE | BS_GROUPBOX,
                                      0, 0, 0, 0,
                                      hwnd, NULL, g_hInst, NULL
                                      );
            MoveWindow(hwndGroup, 0, 0, rc.right-rc.left-20, 110, TRUE);

            hwndStatic = CreateWindow(TEXT("static"), g_szOldCPLMsg,
                                      WS_CHILD | WS_VISIBLE | SS_LEFT,
                                      0, 0, 0, 0,
                                      hwnd, NULL, g_hInst, NULL
                                      );
            MoveWindow(hwndStatic, 50, 20, rc.right-rc.left-80, 50, TRUE);

            hwndButton = CreateWindow(TEXT("button"), g_szCPLButton,
                                      WS_CHILD | WS_VISIBLE | WS_TABSTOP | BS_DEFPUSHBUTTON,
                                      0, 0, 0, 0,
                                      hwnd, NULL, g_hInst, NULL
                                      );
            MoveWindow(hwndButton, 50, 75, 100, 25, TRUE);

            hFont = (HFONT) GetStockObject(DEFAULT_GUI_FONT);

            SendMessage(hwndGroup, WM_SETFONT, (WPARAM)hFont, TRUE);
            SendMessage(hwndStatic, WM_SETFONT, (WPARAM)hFont, TRUE);
            SendMessage(hwndButton, WM_SETFONT, (WPARAM)hFont, TRUE);

            return FALSE;
        }

        case (WM_COMMAND) :
        {
            switch (LOWORD(wParam))
            {
                case ( BN_CLICKED ):
                    TF_RunInputCPL();

                    return FALSE;

                default:
                    break;
            }
        }

        case (WM_PAINT) :
        {
            HDC hdc;
            HICON hIcon;
            PAINTSTRUCT ps;

            hdc = BeginPaint(hwnd, &ps);

            if (hIcon = LoadIcon(g_hInst, MAKEINTRESOURCE(ID_ICON_TEXT_SERVICE)))
            {
                DrawIconEx(hdc, 10, 20, hIcon, 32, 32, 0, NULL, DI_NORMAL);
                ReleaseDC(hwnd, hdc);
            }
            EndPaint(hwnd, &ps);

            return FALSE;
        }
    }

    return DefWindowProc(hwnd, message, wParam, lParam);

}

//+---------------------------------------------------------------------------
//
// CreateCPLFetchWindow
//
// Creating the fetch window to bring up the new Text Service cpl.
//+---------------------------------------------------------------------------

void CreateCPLFetchWindow(HWND hwnd)
{
    RECT rc;
    HWND hwndCPLFetch;
    WNDCLASSEX wndclass;

    if (!(hwndCPLFetch = FindWindowEx(hwnd, NULL, c_szIntlCPLFetchClass, NULL)))
    {
        EnumChildWindows(hwnd, (WNDENUMPROC)Input_EnumChildWndProc, 0);

        GetWindowRect(hwnd, &rc);

        memset(&wndclass, 0, sizeof(wndclass));
        wndclass.cbSize        = sizeof(wndclass);
        wndclass.style         = CS_HREDRAW | CS_VREDRAW ;
        wndclass.hInstance     = g_hInst;
        wndclass.hCursor       = LoadCursor(NULL, IDC_ARROW);
        wndclass.lpfnWndProc   = IntlCPLFetchWndProc;
        wndclass.lpszClassName = c_szIntlCPLFetchClass;
        RegisterClassEx(&wndclass);


        hwndCPLFetch = CreateWindowEx(0, c_szIntlCPLFetchClass, "",
                                WS_VISIBLE | WS_CHILD | WS_TABSTOP,
                                rc.left, rc.top, rc.right-rc.left, rc.bottom-rc.top,
                                hwnd, NULL, g_hInst, NULL
                                );

        MoveWindow(hwndCPLFetch, 10, 10, rc.right-rc.left-10, rc.bottom-rc.top-10, TRUE);
        ShowWindow(hwndCPLFetch, SW_SHOW);
    }
}

//+---------------------------------------------------------------------------
//
// Intl_EnumChildWndProc
//
// filtering the legacy keyboard property page.
//+---------------------------------------------------------------------------

BOOL CALLBACK Intl_EnumChildWndProc(HWND hwnd, LPARAM lParam)
{
    TCHAR szWndName[MAX_PATH];
    TCHAR szKbdPage[MAX_PATH];

    if (GetCurrentThreadId() != GetWindowThreadProcessId(hwnd, NULL))
        return TRUE;

    SafeGetWindowText(hwnd, szWndName, MAX_PATH);

    if (*szWndName == TEXT('\0'))
        return TRUE;

    if (IsOnNT())
        StringCopyArray(szKbdPage, g_szNTCPLTitle);
    else
    {
        LONG_PTR lpWndHandle;

        if (lstrcmp(szWndName, g_szKbdCPLTitle) == 0)
            return FALSE;

        //
        // Thunk call isn't good way to load 16bit module from here.
        // So look up the window instance handle to determine keyboard
        // "Language" tab window.
        // This is Win9x specification and we can detect 32bit handle instance
        // from HIWORD value form GWLP_HINSTANCE.
        //
        lpWndHandle = GetWindowLongPtr(hwnd, GWLP_HINSTANCE);

        if (HIWORD((DWORD) (LONG_PTR) lpWndHandle) != 0)
            return FALSE;

        StringCopyArray(szKbdPage, g_szKbdCPLTitle);
    }

    if ((lstrcmp(szWndName, szKbdPage) == 0) ||
        (!IsOnNT() && lstrcmp(szWndName, szKbdPage) != 0))
    {
        CreateCPLFetchWindow(hwnd);
        return FALSE;
    }

    return TRUE;
}

//+---------------------------------------------------------------------------
//
// Intl_CH9xIMEEnumChildWndProc
//
// filtering the chinese Win9x special IME layout setting cpl.
//+---------------------------------------------------------------------------

BOOL CALLBACK Intl_CH9xIMEEnumChildWndProc(HWND hwnd, LPARAM lParam)
{
    TCHAR szWndName[MAX_PATH];
    TCHAR szKbdPage[MAX_PATH];
    LONG_PTR lpWndHandle;

    if (GetCurrentThreadId() != GetWindowThreadProcessId(hwnd, NULL))
        return TRUE;

    SafeGetWindowText(hwnd, szWndName, MAX_PATH);

    if (*szWndName == TEXT('\0'))
        return TRUE;

    if (lstrcmp(szWndName, g_szKbdCPLTitle) == 0)
        return FALSE;

    //
    // Thunk call isn't good way to load 16bit module from here.
    // So look up the window instance handle to determine keyboard
    // "Language" tab window.
    // This is Win9x specification and we can detect 32bit handle instance
    // from HIWORD value form GWLP_HINSTANCE.
    //
    lpWndHandle = GetWindowLongPtr(hwnd, GWLP_HINSTANCE);

    //if (HIWORD((DWORD) (LONG_PTR) lpWndHandle) != 0 &&
    //    (lstrcmp(szWndName, g_szCH9xKbdCPLTitle) != 0))
    // Need to show up Chinese IME hotkey setting pages
    if (HIWORD((DWORD) (LONG_PTR) lpWndHandle) != 0)
        return FALSE;

    StringCopyArray(szKbdPage, g_szKbdCPLTitle);

    if (!IsOnNT() && lstrcmp(szWndName, szKbdPage) != 0)
    {
        CreateCPLFetchWindow(hwnd);
        return FALSE;
    }

    return TRUE;
}

//+---------------------------------------------------------------------------
//
// Intl_CHEnumChildWndProc
//
// filtering the chinese NT4 special IME layout setting cpl.
//+---------------------------------------------------------------------------

BOOL CALLBACK Intl_CHEnumChildWndProc(HWND hwnd, LPARAM lParam)
{
    TCHAR szWndName[MAX_PATH];

    if (GetCurrentThreadId() != GetWindowThreadProcessId(hwnd, NULL))
        return TRUE;

    SafeGetWindowText(hwnd, szWndName, MAX_PATH);

    if (*szWndName == TEXT('\0'))
        return TRUE;

    //if ((lstrcmp(szWndName, g_szCHNT4CPLTitle1) == 0) ||
    //    (lstrcmp(szWndName, g_szCHNT4CPLTitle2) == 0))
    // Need to show up Chinese IME hotkey setting pages
    if ((lstrcmp(szWndName, g_szCHNT4CPLTitle1) == 0))
    {
        CreateCPLFetchWindow(hwnd);
        return FALSE;
    }

    return TRUE;
}

//+---------------------------------------------------------------------------
//
// GetDialogCaptionTitle
//
//+---------------------------------------------------------------------------

BOOL GetDialogCaptionTitle(HINSTANCE hInst, LPCTSTR lpName, LPTSTR lpTitle, int cchTitleMax)
{
    BOOL bRet = FALSE;
    HRSRC hrsrc = NULL;

    hrsrc = FindResourceA(hInst, lpName, RT_DIALOG);

    if (hrsrc)
    {
        PVOID pTemp;
        DWORD dwCodePage;
        LANGID langRes = 0;
        UINT dwTitleOffset;
        TCHAR szCodePage[10];

        pTemp = (PVOID)LoadResource(hInst, (HRSRC)hrsrc);

        if (pTemp == NULL)
            goto Exit;

        if (*((char *)pTemp) == 1)
            dwTitleOffset = sizeof(DLGTEMPLATEEX) + 4;
        else
            dwTitleOffset = sizeof(DLGTEMPLATE) + 4;

        langRes = GetPlatformResourceLangID();

        if (GetLocaleInfo(MAKELCID(langRes, SORT_DEFAULT),
                          LOCALE_IDEFAULTANSICODEPAGE,
                          szCodePage,
                          ARRAYSIZE(szCodePage)))
        {
            szCodePage[ARRAYSIZE(szCodePage)-1] = 0;
            if (!AsciiToNumDec(szCodePage, &dwCodePage))
            {
                dwCodePage = GetACP();
            }
        }
        else
            dwCodePage = GetACP();

        if (WideCharToMultiByte(dwCodePage, NULL,
                                (LPCWSTR)((char *)pTemp + dwTitleOffset), -1,
                                lpTitle, cchTitleMax,
                                NULL, NULL))
            bRet = TRUE;
    }

Exit:
    return bRet;
}


//+---------------------------------------------------------------------------
//
// CheckLegacyInputCPL
//
//+---------------------------------------------------------------------------

void CheckLegacyInputCPL(HWND hwndFore)
{
    if (hwndFore && !IsOnNT51())
    {
        TCHAR szWndName[MAX_PATH];
        TCHAR szWndName2[MAX_PATH];
        TCHAR szWndName3[MAX_PATH];

        //
        // Load legacy keyboard cpl name and tab titles.
        //
        if (!g_fLoadedCPLName)
        {
             HANDLE hrsrc = NULL;
             HINSTANCE hIntlInst = NULL;
             HINSTANCE hMainInst = NULL;
             HINSTANCE hCHIMEInst = NULL;

             //
             //  Get the default CPL input locale Tab title name string
             //
             if (!LoadString(g_hInst, IDS_CPL_WIN9X_KBDCPLTITLE, g_szKbdCPLTitle, sizeof(g_szKbdCPLTitle)))
                 StringCopyArray(g_szKbdCPLTitle, TEXT("Speed"));

             if (!LoadString(g_hInst, IDS_CPL_WINNT_KBDCPLTITLE, g_szNTCPLTitle, sizeof(g_szNTCPLTitle)))
                 StringCopyArray(g_szNTCPLTitle, TEXT("Input Locales"));

             //
             //  Load CPL files to read CPL name and titles
             //
             hMainInst = LoadSystemLibraryEx(MAINCPL, NULL, LOAD_LIBRARY_AS_DATAFILE);

             hIntlInst = LoadSystemLibraryEx(INTLCPL, NULL, LOAD_LIBRARY_AS_DATAFILE);

             if (!LoadString(hMainInst, WINCPLNAMEID, g_szKbdCPLName, sizeof(g_szKbdCPLName)))
                 StringCopyArray(g_szKbdCPLName, TEXT("Keyboard Properties"));

             if (IsOnNT())
             {
                 if (!LoadString(hIntlInst, NTCPLNAMEID, g_szNTCPLName, sizeof(g_szNTCPLName)))
                     StringCopyArray(g_szNTCPLName, TEXT("Regional Options"));

                 if (!GetDialogCaptionTitle(hIntlInst, (LPTSTR)(LONG_PTR)NTCPLTITLEID, g_szNTCPLTitle, ARRAYSIZE(g_szNTCPLTitle)))
                     StringCopyArray(g_szNTCPLTitle, TEXT("Input Locales"));

                 if (!IsOnNT5())
                 {
                     switch (GetACP())
                     {
                        case 936:
                        case 950:

                            hCHIMEInst = LoadSystemLibraryEx(CHIMECPL, NULL, LOAD_LIBRARY_AS_DATAFILE);

                            if (!LoadString(hCHIMEInst, CHNT4CPLNAMEID, g_szCHNT4CPLName, sizeof(g_szCHNT4CPLName)))
                                *g_szCHNT4CPLName = TEXT('\0');

                            if (!GetDialogCaptionTitle(hCHIMEInst, (LPTSTR)(LONG_PTR)CHNT4CPLTITLEID1, g_szCHNT4CPLTitle1, ARRAYSIZE(g_szCHNT4CPLTitle1)))
                                *g_szCHNT4CPLTitle1 = TEXT('\0');

                            if (!GetDialogCaptionTitle(hCHIMEInst, (LPTSTR)(LONG_PTR)CHNT4CPLTITLEID2, g_szCHNT4CPLTitle2, ARRAYSIZE(g_szCHNT4CPLTitle2)))
                                *g_szCHNT4CPLTitle2 = TEXT('\0');

                            g_fCHNT4 = TRUE;
                            break;
                     }
                 }
             }
             else
             {
                 switch (GetACP())
                 {
                    case 936:
                    case 950:
                        if (!LoadString(hMainInst, WINCPLCHNAMEID, g_szWinCHCPLName, sizeof(g_szWinCHCPLName)))
                            *g_szWinCHCPLName = TEXT('\0');

                        if (!GetDialogCaptionTitle(hMainInst, (LPTSTR)(LONG_PTR)WINCPLCHTITLEID, g_szCH9xKbdCPLTitle, ARRAYSIZE(g_szCH9xKbdCPLTitle)))
                            *g_szCH9xKbdCPLTitle = TEXT('\0');

                        g_fCHWin9x = TRUE;
                        break;
                 }

                 if (!GetDialogCaptionTitle(hMainInst, (LPTSTR)(LONG_PTR)WINCPLTITLEID, g_szKbdCPLTitle, ARRAYSIZE(g_szKbdCPLTitle)))
                     StringCopyArray(g_szKbdCPLTitle, TEXT("Speed"));
             }

             if (hMainInst)
                 FreeLibrary(hMainInst);

             if (hIntlInst)
                 FreeLibrary(hIntlInst);

             if (hCHIMEInst)
                 FreeLibrary(hCHIMEInst);

             if (!LoadString(g_hInst, IDS_CPL_INPUT_DISABLED, g_szOldCPLMsg, sizeof(g_szOldCPLMsg)))
                 StringCopyArray(g_szOldCPLMsg, TEXT("This dialog has been updated. \r\n\r\nPlease use the Text Input Settings applet in the Control Panel."));

             if (!LoadString(g_hInst, IDS_CPL_INPUT_CHAANGE_BTN, g_szCPLButton, sizeof(g_szCPLButton)))
                 StringCopyArray(g_szCPLButton, TEXT("&Change..."));

             if (!LoadString(g_hInst, IDS_CPL_INPUT_GROUPBOX, g_szCPLGroupBox, sizeof(g_szCPLGroupBox)))
                 StringCopyArray(g_szCPLGroupBox, TEXT("Input Languages and Methods"));

             g_fLoadedCPLName = TRUE;
        }

        if (GetCurrentThreadId() != GetWindowThreadProcessId(hwndFore, NULL))
            return;

        SafeGetWindowText(hwndFore, szWndName, MAX_PATH);
        StringCopyArray(szWndName2, szWndName);
        StringCopyArray(szWndName3, szWndName);

        int nSize = lstrlen(g_szNTCPLName);
        *(szWndName3 + min(ARRAYSIZE(szWndName3), nSize)) = TEXT('\0');

        if (IsOnNT() && *szWndName3 && lstrcmp(szWndName3, g_szNTCPLName) == 0)
        {
            EnumChildWindows(hwndFore, (WNDENUMPROC)Intl_EnumChildWndProc, 0);
            return;
        }

        nSize = lstrlen(g_szKbdCPLName);
        *(szWndName + min(ARRAYSIZE(szWndName), nSize)) = TEXT('\0');

        if (*szWndName && lstrcmp(szWndName, g_szKbdCPLName) == 0)
        {
            if (!IsOnNT() && !FindWindowEx(hwndFore, NULL, NULL, g_szKbdCPLTitle))
                return;

            EnumChildWindows(hwndFore, (WNDENUMPROC)Intl_EnumChildWndProc, 0);
            return;
        }

        if (g_fCHWin9x)
        {
            nSize = lstrlen(g_szWinCHCPLName);

            *(szWndName2 + min(ARRAYSIZE(szWndName2), nSize)) = TEXT('\0');

            if (*g_szWinCHCPLName && lstrcmp(szWndName2, g_szWinCHCPLName) == 0)
            {
                if (FindWindowEx(hwndFore, NULL, NULL, g_szWinCHCPLName))
                    EnumChildWindows(hwndFore, (WNDENUMPROC)Intl_CH9xIMEEnumChildWndProc, 0);
            }
        }

        if (g_fCHNT4)
        {
            nSize = lstrlen(g_szCHNT4CPLName);

            *(szWndName2 + min(ARRAYSIZE(szWndName2), nSize)) = TEXT('\0');

            if (*g_szCHNT4CPLName && lstrcmp(szWndName2, g_szCHNT4CPLName) == 0)
            {
                if (FindWindowEx(hwndFore, NULL, NULL, g_szCHNT4CPLName))
                    EnumChildWindows(hwndFore, (WNDENUMPROC)Intl_CHEnumChildWndProc, 0);
            }
        }
    }
}


//+---------------------------------------------------------------------------
//
// OnForegroundChanged
//
//+---------------------------------------------------------------------------

BOOL IsParentWindow(HWND hwnd, HWND hwndParent)
{
    while (hwnd)
    {
        if (hwnd == hwndParent)
            return TRUE;

        hwnd = GetParent(hwnd);
    }
    return FALSE;
}

//+---------------------------------------------------------------------------
//
// OnForegroundChanged
//
//+---------------------------------------------------------------------------

BOOL OnForegroundChanged(HWND hwndFocus)
{
    HWND hwndFore;

    if (!hwndFocus)
        hwndFocus = GetFocus();

    hwndFore = GetForegroundWindow();

    TraceMsg(TF_GENERAL, "OnForegroundChanged %x %x %x", GetCurrentThreadId(), hwndFore, hwndFocus);

    //
    // if foreground window is NULL
    //    OR foregrond window is minimized
    //    OR focus window is notify tray window,
    //
    //   we keep the previous status.
    //
    if (!hwndFore || 
        IsIconic(hwndFore) || 
        IsNotifyTrayWnd(hwndFocus ? hwndFocus : hwndFore))
    {
        return FALSE;
    }


    //
    // we want to update both SharedMem->hwndForegorundPrev and 
    // SharedMem->dwFocusThreadPrev, if the foregorund window was changed.
    //
    if (hwndFore != GetSharedMemory()->hwndForeground)
    {
        GetSharedMemory()->hwndForegroundPrev = GetSharedMemory()->hwndForeground;
        GetSharedMemory()->dwFocusThreadPrev = GetSharedMemory()->dwFocusThread;
    }

    GetSharedMemory()->hwndForeground = hwndFore;
    if (hwndFocus)
    {
        DWORD dwFocusThread;
        DWORD dwFocusProcess;

        dwFocusThread = GetWindowThreadProcessId(hwndFocus, &dwFocusProcess);

        if (hwndFore && 
            (dwFocusThread != GetWindowThreadProcessId(hwndFore, NULL)))
        {
            if (!IsParentWindow(hwndFocus, hwndFore))
                return FALSE;
        }

        //
        // Even the foregorund window was not changed, we may need to check
        // the thread of focus window. New focus window is in different
        // thread. Then we need to make TFPRIV_ONSETTHREADFOCUS message.
        //

        DWORD dwFocusThreadPrev = GetSharedMemory()->dwFocusThread;
        GetSharedMemory()->dwFocusThread = dwFocusThread;
        GetSharedMemory()->dwFocusProcess = dwFocusProcess;

        if (dwFocusThreadPrev != GetSharedMemory()->dwFocusThread)
            GetSharedMemory()->dwFocusThreadPrev = dwFocusThreadPrev;
    }
    else if (hwndFore)
    {
        //
        // The focus window is not in the current thread... So at first we 
        // try to get the thread id of the foreground window.
        // The focus window may not be in the foreground window's thread. But
        // it is ok, as long as we track the focus in the focus thread.
        //
        GetSharedMemory()->dwFocusThread = GetWindowThreadProcessId(GetSharedMemory()->hwndForeground, &GetSharedMemory()->dwFocusProcess);
    }
    else
    {
        GetSharedMemory()->dwFocusThread = 0;
        GetSharedMemory()->dwFocusProcess = 0;
    }

    if (GetSharedMemory()->dwFocusThread != GetSharedMemory()->dwLastFocusSinkThread)
    {
        //
        // Perf:
        //
        // See SysGetMsgProc()!
        // Now, only thread that has TIM needs to receive 
        // TFPRIV_ONKILLTHREADFOCUS or TF_PRIV_ONSETTHREADFOCUS.
        // We should check the target thread has TIM or not. So we can
        // save the number of these post messages.
        //

        if (GetSharedMemory()->dwFocusThreadPrev != 0)
        {
            PostThreadMessage(GetSharedMemory()->dwFocusThreadPrev, 
                              g_msgPrivate, 
                              TFPRIV_ONKILLTHREADFOCUS, 
                              0);
        }

        if (GetSharedMemory()->dwFocusThread != 0)
        {
            PostThreadMessage(GetSharedMemory()->dwFocusThread, 
                              g_msgPrivate, 
                              TFPRIV_ONSETTHREADFOCUS, 
                              0);

        }

        GetSharedMemory()->dwLastFocusSinkThread = GetSharedMemory()->dwFocusThread;
    }

    //
    // Checking legacy keyboard CPL.
    //
    CheckLegacyInputCPL(hwndFore);

    return TRUE;
}

//+---------------------------------------------------------------------------
//
// OnIMENotify
//
//+---------------------------------------------------------------------------

void OnIMENotify()
{
    SYSTHREAD *psfn;

    if (psfn = GetSYSTHREAD())
    {
        if (psfn->plbim && psfn->plbim->_GetLBarItemWin32IME())
        {
            psfn->plbim->_GetLBarItemWin32IME()->UpdateIMEIcon();
        }
    }
}

#ifdef CHECKFEIMESELECTED
//+---------------------------------------------------------------------------
//
// CheckFEIMESelected
//
// This function checks the current selected FEIME is active in Cicero
// Assembly. If it is not activated, we calls ActivateAssemblyItem().
//
//+---------------------------------------------------------------------------


void CheckFEIMESelected(SYSTHREAD *psfn, HKL hKL)
{
    int i;
    CAssembly *pAsm;
    BOOL fFound;

    Assert(psfn);

    if (!psfn->pAsmList)
        return;

    if (!IsPureIMEHKL(hKL))
        return;

    pAsm = psfn->pAsmList->FindAssemblyByLangId(LANGIDFROMHKL(hKL));
    if (!pAsm)
        return;

    //
    // Windows #311672 
    //
    // EUDCEDIT.EXE calls ActivateKeyboardLayout() to activate IME hKL.
    // Cicero should not break the API on WinXP. Skip SmartVoice hardcode.
    //
    //
#if 0
    //
    // SmartVoice Hack
    // 
    //  we want to remove this smart voice hack section to solve
    //  general ActivateKayboardLayout() problem. However Office10 wants
    //  the safest fix for this problem. So we check SmartVoice IME here
    //  to minimize the rish of CheckFEIMESelected() call.
    //
    {
        static const char c_szSmartVoiceIME[] = "smartv20.ime";
        char szIMEFile[MAX_PATH];
        if (!ImmGetIMEFileNameA(hKL, szIMEFile, sizeof(szIMEFile)))
            return;

        if (lstrcmpi(szIMEFile, c_szSmartVoiceIME))
            return;
    }
#endif

    //
    // check if the hKL is substituted by the activate Item.
    //
    // We try to find the active Item first.
    //
    for (i = 0; i < pAsm->Count(); i++)
    {
        ASSEMBLYITEM *pItem = pAsm->GetItem(i);

        if (!pItem)
            continue;

        if (!IsEqualGUID(pItem->catid, GUID_TFCAT_TIP_KEYBOARD))
            continue;

        if (!pItem->fEnabled)
            continue;

        if (!pItem->fActive)
            continue;

        if (pItem->hklSubstitute == hKL)
        {
            //
            // #383710 OfficeXP's RichEd20.dll calls ActivateKeyboardlayout()
            // with Korean IME hKL even though it is running on AIMM mode.
            // we need to adjust the assembly item.
            //
            CThreadInputMgr *ptim = psfn->ptim;
            if (ptim)
            {
                if (ptim->_GetFocusDocInputMgr()) 
                {
                    ActivateAssemblyItem(psfn, LANGIDFROMHKL(hKL), pItem, 0);
                }
                else
                {
                    //
                    // we could not have a chance to sync the current hKL
                    // init hklBeingActivated and try when DIM gets the focus.
                    //
                    psfn->hklBeingActivated = NULL;
                }
            }
            return;
        }
    }

    //
    // Ok we could not find active Item with hKL as its substitute hKL.
    // Let's find it from non-active Item, too.
    //
    if (psfn->ptim && psfn->ptim->_GetFocusDocInputMgr()) 
    {
        for (i = 0; i < pAsm->Count(); i++)
        {
            ASSEMBLYITEM *pItem = pAsm->GetItem(i);

            if (!pItem)
                continue;

            if (!IsEqualGUID(pItem->catid, GUID_TFCAT_TIP_KEYBOARD))
                continue;

            if (!pItem->fEnabled)
                continue;

            if (pItem->hklSubstitute == hKL)
            {
                ActivateAssemblyItem(psfn, LANGIDFROMHKL(hKL), pItem, 0);
                return;
            }
        }
    }


    fFound = FALSE;
    for (i = 0; i < pAsm->Count(); i++)
    {
        ASSEMBLYITEM *pItem;
        pItem= pAsm->GetItem(i);

        if (!pItem)
            continue;

        if (!IsEqualGUID(pItem->catid, GUID_TFCAT_TIP_KEYBOARD))
            continue;

        if (pItem->hkl != hKL)
            continue;

        fFound = TRUE;
        if (!pItem->fActive)
        {
            //
            // This item is not activated.
            // Call ActivateAssemblyItem() now and return.
            //
            ActivateAssemblyItem(psfn, LANGIDFROMHKL(hKL), pItem, 0);
            return;
        }
    }

    //
    // we could not find the activated hKL in our Asmlist.
    //
    if (!fFound)
    {
        UnknownFEIMESelected(LANGIDFROMHKL(hKL));
    }
}
#endif CHECKFEIMESELECTED

//+---------------------------------------------------------------------------
//
// OnShellLanguage
//
//+---------------------------------------------------------------------------
void OnShellLanguage(HKL hKL)
{
    SYSTHREAD *psfn;

    HWND hwndFore = GetForegroundWindow();
    if (IsConsoleWindow(hwndFore))
    {
        DWORD dwThreadId = GetWindowThreadProcessId(hwndFore, NULL);

        g_timlist.SetConsoleHKL(dwThreadId, hKL);

        if (OnForegroundChanged(NULL))
            MakeSetFocusNotify(g_msgSetFocus, 0, 0);

        MakeSetFocusNotify(g_msgLBUpdate, 
                           TF_LBU_NTCONSOLELANGCHANGE, 
                           (LPARAM)hKL);
        return;
    }

    psfn = GetSYSTHREAD();
    if (!psfn)
        return;

    if (psfn->hklBeingActivated == hKL)
        psfn->hklBeingActivated = NULL;


    if (LANGIDFROMHKL(hKL) != GetCurrentAssemblyLangId(psfn))
    {
        //
        // if it is in Cicero aware and the hKL does not match with
        // current assembly, someone else might call ActivateKayboardLayout().
        // we need to change the current assembly right away..
        //
        // ActivateAssembly(LANGIDFROMHKL(hKL), ACTASM_ONSHELLLANGCHANGE);
        //

        //
        // WM_INPUTLANGCHNAGEREQUEST is being queued now.
        // Post another message to confirm the hKL.
        //
        PostThreadMessage(GetCurrentThreadId(),
                          g_msgPrivate,
                          TFPRIV_POSTINPUTCHANGEREQUEST,
                          0);
    }
    else
    {
        if (psfn->plbim)
             UpdateSystemLangBarItems(psfn, 
                                      hKL, 
                                      !psfn->plbim->InAssemblyChange());

    }

    if (IsPureIMEHKL(hKL))
    {
        OnIMENotify();

        //
        // Temp rolling back SmartVoice (Cic#4580) fix. Since we got some
        // regression like Cic#4713 and so on.
        //
#ifdef CHECKFEIMESELECTED
        //
        // check this hkl is activated in Cicero Assembly.
        //
        CheckFEIMESelected(psfn, hKL);
#endif
    }
}

//+---------------------------------------------------------------------------
//
// UninitThread
//
//+---------------------------------------------------------------------------

typedef HRESULT (*PFNCTFIMETHREADDETACH)(void);

void UninitThread()
{
    DWORD dwThreadId = GetCurrentThreadId();
    SYSTHREAD *psfn = FindSYSTHREAD();

    if (psfn)
        psfn->fCUASDllDetachInOtherOrMe = TRUE;

//  g_SharedMemory.Close();

#if 1
    if (GetSharedMemory() == NULL && ! IsSharedMemoryCreated())
    {
        // Shared memory already closed.
        return;
    }
#endif

    if (GetSharedMemory()->dwFocusThread == dwThreadId)
    {
        GetSharedMemory()->dwFocusThread  = 0;
        GetSharedMemory()->dwFocusProcess  = 0;
        GetSharedMemory()->hwndForeground = NULL;
    }

    if (GetSharedMemory()->dwFocusThreadPrev == dwThreadId)
    {
        GetSharedMemory()->hwndForegroundPrev = NULL;
        GetSharedMemory()->dwFocusThreadPrev = 0;
    }

    if (GetSharedMemory()->dwLastFocusSinkThread == dwThreadId)
    {
        GetSharedMemory()->dwLastFocusSinkThread = 0;
    }

    //
    // Issue: 
    //
    // UninitThread() is called from DLL_THREAD_DETACH so 
    // we should not call MakeSetFocusNotify() because it uses 
    // ciritical section and could cause dead lock.
    //
    MakeSetFocusNotify(g_msgThreadTerminate, 0, (LPARAM)dwThreadId);


    if (psfn && GetSystemMetrics(SM_SHUTTINGDOWN))
    {
        psfn->fUninitThreadOnShuttingDown = TRUE;
    }

    //
    // Tell msctfime that msctf's thread_detach is being called.
    // So it can deactivate TIM now. If we don't do this now,
    // it may deactivate TIM afte msctf's thread detach is called.
    //
    if (g_fCUAS && g_szCUASImeFile[0])
    {
        HINSTANCE hInstMsctfime;

        hInstMsctfime = GetSystemModuleHandle(g_szCUASImeFile);
        if (hInstMsctfime)
        {
            PFNCTFIMETHREADDETACH pfn = NULL;
            pfn = (PFNCTFIMETHREADDETACH)GetProcAddress(hInstMsctfime,
                                                        "CtfImeThreadDetach");
            if (pfn)
                pfn();
        }
    }

}

//+---------------------------------------------------------------------------
//
// SysShellProc
//
//+---------------------------------------------------------------------------

LRESULT CALLBACK SysShellProc(int nCode, WPARAM wParam, LPARAM lParam)
{
    TraceMsg(TF_GENERAL, "SysShellProc %x %x %x", nCode, wParam, lParam);
    HHOOK hHook;

    if (g_fDllProcessDetached)
    {
        hHook = s_hSysShellHook;
        goto Exit;
    }

    _try
    {
        hHook = GetSharedMemory()->hSysShellHook.GetHandle(g_bOnWow64);

        _ShellProc(nCode, wParam, lParam);
    }
    _except(CicExceptionFilter(GetExceptionInformation()))
    {
        Assert(0);
    }

Exit:
    return CallNextHookEx(hHook, nCode, wParam, lParam);
}

//+---------------------------------------------------------------------------
//
// _ShellProc
//
//+---------------------------------------------------------------------------

UINT _ShellProc(int nCode, WPARAM wParam, LPARAM lParam)
{
    HWND hwndActive;

    //
    // give AIMM the Shell events.
    //
    CThreadInputMgr *ptim;
    SYSTHREAD *psfn;
    if (psfn = GetSYSTHREAD())
    {
        if (ptim = psfn->ptim)
        {
            if (ptim->GetSysHookSink())
            {
                ptim->GetSysHookSink()->OnSysShellProc(nCode, wParam, lParam);
            }
        }
    }

    switch (nCode)
    {
        case HSHELL_LANGUAGE:
            OnShellLanguage((HKL)lParam);
            break;

        case HSHELL_WINDOWACTIVATED:
            //TraceMsg(TF_GENERAL, "SysShellProc: HSHELL_WINDOWACTIVATED %x", GetCurrentThreadId());
            GetSharedMemory()->fInFullScreen = lParam ? TRUE : FALSE;

            hwndActive = GetActiveWindow();
            if (hwndActive && 
                (GetWindowThreadProcessId(hwndActive, NULL) == GetCurrentThreadId()))
            {
                if (OnForegroundChanged(NULL))
                    MakeSetFocusNotify(g_msgSetFocus, 0, 0);
            }
            else 
            {
                hwndActive = GetForegroundWindow();
                goto CheckConsole;
            }
            break;

        case HSHELL_WINDOWCREATED:
            hwndActive = (HWND)wParam;
CheckConsole:
            if (hwndActive && IsOnNT() && IsConsoleWindow(hwndActive))
            {
                DWORD dwProcessId;
                DWORD dwThreadId = GetWindowThreadProcessId(hwndActive, 
                                                            &dwProcessId);

                if ((nCode == HSHELL_WINDOWCREATED) ||
                     !(g_timlist.GetFlags(dwThreadId) & TLF_NTCONSOLE))
                    g_timlist.AddThreadProcess(dwThreadId, 
                                               dwProcessId, 
                                               NULL, 
                                               TLF_NTCONSOLE);

                if (OnForegroundChanged(NULL))
                {
                    HKL hklConsole = g_timlist.GetConsoleHKL(dwThreadId);
                    if (!hklConsole)
                    {
                        hklConsole = GetKeyboardLayout(dwThreadId);
                        g_timlist.SetConsoleHKL(dwThreadId, hklConsole);
                    }
                    MakeSetFocusNotify(g_msgSetFocus, 0, 0);
                    MakeSetFocusNotify(g_msgLBUpdate, 
                                       TF_LBU_NTCONSOLELANGCHANGE, 
                                       (LPARAM) (HKL)hklConsole);
                }
            }
            break;

    }

    return 1;
}

//+---------------------------------------------------------------------------
//
// OnSetWindowFocus()
//
//+---------------------------------------------------------------------------

void OnSetWindowFocus(SYSTHREAD *psfn, HWND hwnd)
{
    CThreadInputMgr *ptim;
    Assert(psfn)

    if (psfn->hklDelayActive)
    {
        ActivateKeyboardLayout(psfn->hklDelayActive, 0);
        psfn->hklDelayActive = NULL;
    }

    if (ptim = psfn->ptim)
    {
        if (hwnd)
        {
            if (ptim->GetSysHookSink())
                ptim->GetSysHookSink()->OnPreFocusDIM(hwnd);

            Assert(GetWindowThreadProcessId(hwnd, NULL) == GetCurrentThreadId());
            CDocumentInputManager *pdim;

            pdim = ptim->_GetAssoc(hwnd);

            //
            // we don't want to clear focus dim if there is no
            // foreground window.
            //
            if (pdim || GetForegroundWindow())
            {
                // focus dim will be clear if pdim is NULL.
                ptim->_SetFocus(pdim, TRUE);
            }
        }
    }

    //
    // update foregorund window handle and thread id.
    // Because shell hook is posted event, we need to update
    // before MakeSetFocusNotify. Otherwise we miss timing to 
    // update them.
    //
    // We can not call GetFocus() since it may return
    // the previous focus during CBT hook.
    // When the focus moves back from embedded OLE server,
    // GetFocus() may get the the OLE server's window handle.
    //
    if (OnForegroundChanged(hwnd))
    {
        //
        // If hwndFocus is NULL, focus is moved to other thread.
        //
        MakeSetFocusNotify(g_msgSetFocus, 0, 0);
    }

}

//+---------------------------------------------------------------------------
//
// OnSetWindowFocusHandler()
//
//+---------------------------------------------------------------------------

void OnSetWindowFocusHandler(SYSTHREAD *psfn, MSG *pmsg)
{
    if (!psfn)
        return;

    //
    // We're destroying the marhacl window right now. We don't have
    // any more visible windows.
    //
    if (psfn->uDestroyingMarshalWnd)
    {
        goto Exit;
    }

    HWND hwndFocus = GetFocus();
    if (hwndFocus)
    {
        //
        // review review
        //
        // Don't we need to call 
        // OnForegroundChanged() if psfn->hwndBegin
        // gFocued() is NULL?
        // Maybe no, OnForegroundChanged() is 
        // called in activatewindow.
        //
        if (psfn->hwndBeingFocused == hwndFocus)
        {
            OnSetWindowFocus(psfn, hwndFocus);
        }
        else 
        {
            //
            // #476100
            //
            // if we miss this, we need to post
            // TFPRIV_ONSETWINDOWFOCUS again.
            // Because the focus thread might processed
            // this meesage already and it does not
            // call OnSetWindowFocus().
            //
            DWORD dwFocusWndThread = GetWindowThreadProcessId(hwndFocus, NULL);
            if (psfn->dwThreadId != dwFocusWndThread)
            {
                PostThreadMessage(dwFocusWndThread,
                                  g_msgPrivate, 
                                  TFPRIV_ONSETWINDOWFOCUS,  
                                  (LPARAM)-1);
            }
            else if (pmsg->lParam == (LPARAM)-2)
            {
                if (psfn->ptim && psfn->ptim->_GetFocusDocInputMgr())
                {
                    HWND hwndAssoc;

                    hwndAssoc = psfn->ptim->_GetAssoced(psfn->ptim->_GetFocusDocInputMgr());
                    //
                    // lParam is -2 because the SetFocus(dim) is already 
                    // called. 
                    // hwndAssoc is NULL. Now we're in Cicero aware.
                    //
                    // So we just do OnForegroundChanged(). Don't call
                    // OnSetWindowFocus().
                    //
                    // Bug#623920 - Don't need to check up hwndAssoc since the current focus
                    // window has the right dim value and also need to update language bar even
                    // with hwndAssoc
                    //
                    //if (!hwndAssoc)
                    //
                    {
                        if (OnForegroundChanged(hwndFocus))
                        {
                            MakeSetFocusNotify(g_msgSetFocus, 0, 0);
                        }
                    }
                }
            }
            else if ((pmsg->lParam == (LPARAM)-1) ||
                     (psfn->dwThreadId == GetWindowThreadProcessId(GetForegroundWindow(), NULL)))
            {
                //
                // #479926
                //
                // The first SetFocus() in the thread
                // may break the order of CBT hook
                // because xxxSetFocus() calls
                // xxxActivateWindow() and this cause
                // another xxxSetFocus(). After 
                // xxxActivateWindow() returns
                // the first xxxSetFocus() updates
                // the spwndFocus.
                //
                // see ntuser\kernel\focusact.c
                //
                // Now we need to hack. We're 100% sure
                // if the focus window and the fore-
                // ground window is in same thread,
                // we can do _SetFocus(dim).
                // but if focusdim does not have a associated window,
                // Cicero App might call SetFocus() already. Then
                // we don't do anything.
                //
                if (psfn->ptim && psfn->ptim->_GetFocusDocInputMgr())
                {
                    HWND hwndAssoc;

                    hwndAssoc = psfn->ptim->_GetAssoced(psfn->ptim->_GetFocusDocInputMgr());
                    if (hwndAssoc && hwndFocus != hwndAssoc)
                        OnSetWindowFocus(psfn, hwndFocus);
                }
                else if (!psfn->ptim ||
                          psfn->ptim->_IsNoFirstSetFocusAfterActivated() ||
                          psfn->ptim->_IsInternalFocusedDim())
                {
                    OnSetWindowFocus(psfn, hwndFocus);
                }
            }
        }

    }


    //
    // try to update Kana status every time 
    // focus changes.
    //
    //
    // when the focus is changed, we need to make
    // notification again.
    //
    psfn->fInitCapsKanaIndicator = FALSE; 
    StartKanaCapsUpdateTimer(psfn);

Exit:
    psfn->hwndBeingFocused = NULL;
    psfn->fSetWindowFocusPosted = FALSE;
}

//--------------------------------------------------------------------------
//
//  IsPostedMessage
//
//--------------------------------------------------------------------------

__inline BOOL IsPostedMessage()
{
    DWORD dwQueueStatus = GetQueueStatus(QS_POSTMESSAGE);
    return (HIWORD(dwQueueStatus) & QS_POSTMESSAGE) ? TRUE : FALSE;
}
//--------------------------------------------------------------------------
//
//  RemovePrivateMessage
//
//--------------------------------------------------------------------------

void RemovePrivateMessage(SYSTHREAD *psfn, HWND hwnd, UINT uMsg)
{
    MSG msg;
    UINT nQuitCode;
    BOOL fQuitReceived = FALSE;
    DWORD dwPMFlags = PM_REMOVE | PM_NOYIELD;

    if (!IsPostedMessage())
        return;


    //
    // Cic#4666 PostPet v1.12 fault.
    // PostPet.exe cause av when it receives its internal message in 
    // CBT_DESTROYWINDOW hook when it is terminated.
    // At this time, the child thread is calling SendMessage() to the window
    // in the main thread. So calling PeekMessage() may receive the message
    // and pass it to PostPet window.
    //
    // I found Win98 has a bug in PM_QS_POSTMESSAGE. Win98's PeekMessage()
    // handles the message that is sent from other thread without
    // PM_QS_SENDMESSAGE. 
    //
    // If we has to fix this problem on Win98, I think it is better to have
    // another compatibility flag so we can skip this PeekMessage() in
    // PostPet.exe. In PostPet.exe, it is ok not to clean queue since
    // this happens only app termination.
    //
    if (IsOnNT5())
        dwPMFlags |= PM_QS_POSTMESSAGE;

    while (PeekMessage(&msg, hwnd, uMsg, uMsg, dwPMFlags ))
    {
        if (msg.message == WM_QUIT)
        {
            nQuitCode = (UINT)(msg.wParam);
            fQuitReceived = TRUE;
            break;
        }

        //
        // should we dispatch the message to the marshal window?
        //
#if 0
        //
        // Cic#4869
        //
        // we don't want to dispatch this message to marshal window.
        // This HCBT_DESTROYWINDOW may be in OLEAUT32.DLL's DllMain() and
        // dispatching this message could cause the reentry to OLEAUT32's
        // DLLMain() because we do delay load.
        //

        //
        // dispatch if this message is for marshal window.
        //
        if (psfn->hwndMarshal && (psfn->hwndMarshal == msg.hwnd))
        {
            DispatchMessage(&msg);
        }
#endif

        //
        // Cic#4699
        //
        // Exception MSUIM.Msg.MuiMgrDirtyUpdate private message.
        // If we get this message, reset CLangBarItemMgr::_fDirtyUpdateHandling
        //
        if (psfn->hwndMarshal && (psfn->hwndMarshal == msg.hwnd) &&
            msg.message == g_msgNuiMgrDirtyUpdate &&
            psfn->plbim)
        {
            psfn->plbim->ResetDirtyUpdate();
        }

    }

    if (fQuitReceived)
        PostQuitMessage(nQuitCode);

}


//+---------------------------------------------------------------------------
//
// CheckQueueOnLastWindowDestroyed()
//
// Super EnumWindow hack.
//
// When the last visible window in the thread is destroyed.
//
//  1. we destroy the marshal worker window on NT4. (Cic #658)
//    Because some application may found Cic marshal window 
//    by calling EnumWindow.
//    
//
//  2. we need to clean up the thread queue. (Cic #3080)
//    Because some application calls GetMessage() or PeekMessage()
//    with specific window handle or message soour private messages
//    remain in the queue. Then WM_QUIT message won't be handled..
//
// this is not complete solution but at least we can avoid
// the ghost windows or remained message in the queue.
//
//+---------------------------------------------------------------------------

void CheckQueueOnLastWindowDestroyed(SYSTHREAD *psfn, HWND hwnd)
{
    BOOL fOnNT4;

    //
    // we don't have to do this on ctfmon process.
    //
    if (psfn->fCTFMON)
        return;

    //
    // check if it's nt4.
    //
    fOnNT4 = (IsOnNT() && !IsOnNT5()) ? TRUE : FALSE;

#if 0
    if (!fOnNT4)
    {
        //
        // If there is no posted message, we don't have to do this.
        // EnumThreadWindow() is slow....
        //
        if (!IsPostedMessage())
            return;
    }
#endif

    LONG_PTR style = GetWindowLongPtr(hwnd, GWL_STYLE);
    if (style & WS_CHILD) 
        return;

    if (hwnd == psfn->hwndMarshal)
        return;

    //
    // skip IME windows.
    //
    style = GetClassLongPtr(hwnd, GCL_STYLE);
    if (style & CS_IME)
        return;


    //
    // check the focus window first. 
    //
    // if there is a focus window and it is not a child
    // of the window that is being destroyed, we don't 
    // have to destroy marshal window.
    //
    HWND hwndTmp = GetFocus();
    if (hwndTmp && 
        (GetCurrentThreadId() != GetWindowThreadProcessId(hwndTmp, NULL)))
        hwndTmp = NULL;

    if (hwndTmp)
    {
        BOOL fParentFound = FALSE;
        do {
            if (hwndTmp == hwnd)
                fParentFound = TRUE;

            hwndTmp = GetParent(hwndTmp);
        } while(hwndTmp);

        if (!fParentFound)
            return;
    }

    CHECKVISIBLEWND cmw;
    cmw.hwndMarshal = psfn->hwndMarshal;
    cmw.hwndBeingDestroyed = hwnd;
    cmw.fVisibleFound = FALSE;
    EnumThreadWindows(psfn->dwThreadId,
                      CheckVisibleWindowEnumProc,
                      (LPARAM)&cmw);

    if (!cmw.fVisibleFound)
    {
        BOOL fInDestroyingMarshalWnd = FALSE;
        if (psfn->uDestroyingMarshalWnd)
            fInDestroyingMarshalWnd = TRUE;

        psfn->uDestroyingMarshalWnd++;

        DestroyMarshalWindow(psfn, hwnd);

#ifdef CUAS_ENABLE
        //
        // Under CUAS, we need to deactivate TIM to destroy all TIP's window
        // when there is no visible window in this thread.
        // And we destroy the default IME window so we can restore TIM for 
        // CUAS when the default IME window is created again in this thread.
        // There is no way to know if the default IME window finds another
        // top level window if it is created during DestroyWindow().
        //
        if (CtfImmIsCiceroEnabled() && 
            !CtfImmIsTextFrameServiceDisabled() &&
            !psfn->fCUASInCreateDummyWnd &&
            !psfn->fDeactivatingTIP)
        {
            if (!psfn->fCUASInCtfImmLastEnabledWndDestroy)
            {
                psfn->fCUASInCtfImmLastEnabledWndDestroy = TRUE;

                CtfImmLastEnabledWndDestroy(0);

                if (!(InSendMessageEx(NULL) & ISMEX_SEND))
                    CtfImmCoUninitialize();

                psfn->fCUASInCtfImmLastEnabledWndDestroy = FALSE;
            }

            if (!fInDestroyingMarshalWnd)
            {
                HWND hwndImmDef = ImmGetDefaultIMEWnd(hwnd);
                if (hwndImmDef)
                {
                    DestroyWindow(hwndImmDef);
                }
            }

            psfn->fCUASNoVisibleWindowChecked = TRUE;
        }
#endif CUAS_ENABLE

        psfn->uDestroyingMarshalWnd--;
    }
}

void DestroyMarshalWindow(SYSTHREAD* psfn, HWND hwnd)
{
    BOOL fOnNT4;

    if (IsPostedMessage())
    {
        if (psfn->hwndMarshal)
            RemovePrivateMessage(psfn, psfn->hwndMarshal, 0);

        RemovePrivateMessage(psfn, NULL, g_msgPrivate);
        RemovePrivateMessage(psfn, NULL, g_msgRpcSendReceive);
        RemovePrivateMessage(psfn, NULL, g_msgThreadMarshal);
        RemovePrivateMessage(psfn, NULL, g_msgStubCleanUp);
    }

    //
    // #339621
    //
    // This is rare but. We need to clear ShareMem->dwFocusThread and
    // dwFocusProcess. Otherwise we will get another PostThreadMessage()
    // with TFPRIV_ONKILLTHREADFOCUS later. And SQL setup hungs.
    //
    if (GetSharedMemory()->dwFocusThread == psfn->dwThreadId)
        GetSharedMemory()->dwFocusThread = 0;

    if (GetSharedMemory()->dwFocusProcess == psfn->dwProcessId)
        GetSharedMemory()->dwFocusProcess = 0;

    //
    // check if it's nt4.
    //
    fOnNT4 = (IsOnNT() && !IsOnNT5()) ? TRUE : FALSE;

    if (fOnNT4 && IsWindow(psfn->hwndMarshal))
    {
        DestroyWindow(psfn->hwndMarshal);
        psfn->hwndMarshal = NULL;
    }
}

//+---------------------------------------------------------------------------
//
// CreateDummyWndForDefIMEWnd
//
//+---------------------------------------------------------------------------

#ifdef CUAS_ENABLE
BOOL g_fCDWRegistered = FALSE;
const CHAR c_szDummyWndForDefIMEWnd[] = "CicDUmmyWndForDefIMEWnd";

//+---------------------------------------------------------------------------
//
// CicDummyForDefIMEWndProc
//
// This needs to be user mode wndproc. Otherwise system does not create
// a default IME window
//
//+---------------------------------------------------------------------------

LRESULT CALLBACK CicDummyForDefIMEWndProc(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    return DefWindowProc(hWnd, uMsg, wParam, lParam);
}

void CreateDummyWndForDefIMEWnd()
{
    HWND hwnd;

    if (!g_fCDWRegistered)
    {
        WNDCLASSEX wndclass;

        memset(&wndclass, 0, sizeof(wndclass));
        wndclass.cbSize        = sizeof(wndclass);
        wndclass.style         = CS_HREDRAW | CS_VREDRAW ;
        wndclass.hInstance     = g_hInst;
        wndclass.hCursor       = NULL;
        wndclass.lpfnWndProc   = CicDummyForDefIMEWndProc;
        wndclass.lpszClassName = c_szDummyWndForDefIMEWnd;

        if (RegisterClassEx(&wndclass))
           g_fCDWRegistered = TRUE;
    }


    //
    // call CraeteWindow() to create a default IME window.
    //
    hwnd = CreateWindowEx(0, c_szDummyWndForDefIMEWnd, NULL,
                          WS_POPUP,
                          0,0,0,0,
                          NULL, NULL, g_hInst, NULL);
    if (hwnd)
        DestroyWindow(hwnd);

}
#endif // CUAS_ENABLE

#ifdef CUAS_ENABLE
//+---------------------------------------------------------------------------
//
// UninitThreadHooksIfNoWindow()
//
// When the last window in the thread is destroyed.
// Unhook thread local hook for SetThreadDesktop().
//
//+---------------------------------------------------------------------------

void UninitThreadHooksIfNoWindow(SYSTHREAD* psfn, HWND hwnd)
{
    CHECKNOWND cmw;
    cmw.hwndBeingDestroyed = hwnd;
    cmw.fWindowFound = FALSE;
    EnumThreadWindows(psfn->dwThreadId,
                      CheckNoWindowEnumProc,
                      (LPARAM)&cmw);

    if (! cmw.fWindowFound)
    {
        DestroyMarshalWindow(psfn, hwnd);
        if (IsWindow(psfn->hwndMarshal))
        {
            DestroyWindow(psfn->hwndMarshal);
            psfn->hwndMarshal = NULL;
        }
        UninitThreadHooks(psfn);
    }
}
#endif // CUAS_ENABLE

//+---------------------------------------------------------------------------
//
// SysCBTProc
//
//+---------------------------------------------------------------------------

LRESULT CALLBACK SysCBTProc(int nCode, WPARAM wParam, LPARAM lParam)
{
    SYSTHREAD *psfn;
    HHOOK hHook;

    if (g_fDllProcessDetached)
    {
        hHook = s_hSysCBTHook;
        goto Exit;
    }

    _try
    {
        hHook = GetSharedMemory()->hSysCBTHook.GetHandle(g_bOnWow64);

        InitThreadHook(GetCurrentThreadId());

        switch (nCode)
        {
            case HCBT_CREATEWND:
                    if ((psfn = GetSYSTHREAD()) &&
                        psfn->hklDelayActive)
                    {
                        if (ActivateKeyboardLayout(psfn->hklDelayActive, 0))
                            psfn->hklDelayActive = NULL;
                    }
                    break;

            case HCBT_ACTIVATE:
                    _CBTHook(HCBT_ACTIVATE, wParam, lParam);
                    break;

            case HCBT_SETFOCUS:
                    _CBTHook(HCBT_SETFOCUS, wParam, lParam);
                    break;

            case HCBT_DESTROYWND:
                    if (psfn = GetSYSTHREAD())
                    {
                        CheckQueueOnLastWindowDestroyed(psfn, (HWND)wParam);
#ifdef CUAS_ENABLE
                        UninitThreadHooksIfNoWindow(psfn, (HWND)wParam);
#endif // CUAS_ENABLE
                    }

                    break;
        }
    }
    _except(CicExceptionFilter(GetExceptionInformation()))
    {
        Assert(0);
    }

Exit:
    return CallNextHookEx(hHook, nCode, wParam, lParam);
}

UINT _CBTHook(int nCode, WPARAM wParam, LPARAM lParam)
{
    SYSTHREAD *psfn;

    switch (nCode)
    {
        case HCBT_ACTIVATE:
                if (wParam)
                {
                    if (((HWND)wParam == GetForegroundWindow()) &&
                        OnForegroundChanged(NULL))
                            MakeSetFocusNotify(g_msgSetFocus, 0, 0);
                }
                break;

        case HCBT_SETFOCUS:
                if (psfn = GetSYSTHREAD())
                {
#ifdef CUAS_ENABLE
                    //
                    // Cic#5254
                    //
                    // After we detect no more visible window,
                    // some window could become visible. 
                    // Since we destroyed the default IME window,
                    // we need to recreate it.
                    //
                    // Here is a hack to do. Call a dummy CreateWindow()
                    // to create a default IME window in this thread.
                    //
                    if (psfn->fCUASNoVisibleWindowChecked)
                    {
                        psfn->fCUASInCreateDummyWnd = TRUE;
                        CreateDummyWndForDefIMEWnd();
                        psfn->fCUASInCreateDummyWnd = FALSE;
                        psfn->fCUASNoVisibleWindowChecked = FALSE;
                    }
#endif

                    psfn->hwndBeingFocused = (HWND)wParam;

                    if (!psfn->fSetWindowFocusPosted)
                    {
                        PostThreadMessage(GetCurrentThreadId(), 
                                          g_msgPrivate, 
                                          TFPRIV_ONSETWINDOWFOCUS,  
                                          (LPARAM)wParam);
                        psfn->fSetWindowFocusPosted = TRUE;
                    }
                }
                break;
    }

    return 1;
}

//+---------------------------------------------------------------------------
//
// RemoveThisMessage
//
//+---------------------------------------------------------------------------

BOOL RemoveThisMessage(MSG *pmsg)
{
    MSG msg;
    SYSTHREAD *psfn;

    if (psfn = GetSYSTHREAD())
    {
        if (psfn->uMsgRemoved)
        {
            Assert(psfn->uMsgRemoved == pmsg->message);
            // Assert(psfn->dwMsgTime == pmsg->time);
            return TRUE;
        }

        Assert(!psfn->uMsgRemoved);
        psfn->uMsgRemoved = pmsg->message;
        psfn->dwMsgTime = pmsg->time;
    }

    PeekMessage(&msg, NULL, pmsg->message, pmsg->message, PM_REMOVE | PM_NOYIELD);

    return FALSE;
}

//+---------------------------------------------------------------------------
//
//  HandledThisMessage
//
//+---------------------------------------------------------------------------

void FinishThisMessage(MSG *pmsg)
{
    SYSTHREAD *psfn;

    if (psfn = GetSYSTHREAD())
    {
        psfn->uMsgRemoved = 0;
        psfn->dwMsgTime = 0;
    }
}

//+---------------------------------------------------------------------------
//
//  PostInputChangeRequestHandler()
//
//  this is the function that is called by TFPRIV_POSTINPUTCHANGEREQUEST.
//  We need to confirm the current hKL mathes with Cicero assembly language.
//  And we need to check the substitute hKL is selected on Cicero control.
//
//+---------------------------------------------------------------------------

void PostInputChangeRequestHandler()
{
    SYSTHREAD *psfn = GetSYSTHREAD();

    if (!psfn)
        return;

    //
    // If the current hKL does not match with
    // Cicero assembly language, we call 
    // ActivateAssembly() to sync to the current 
    // hKL. Someone accepted this language change.
    //
    HKL hKL = GetKeyboardLayout(0);

    if (LANGIDFROMHKL(hKL) != GetCurrentAssemblyLangId(psfn))
    {
        //
        // #494602, Corel Draw 10 calls LoadKeyboardLayout and ActivateKeyboardLayout.
        // If specified hKL doesn't exist in our assembly list, then should update.
        //
        if (! IsPureIMEHKL(hKL) && psfn->pAsmList)
        {
            CAssembly *pAsm = psfn->pAsmList->FindAssemblyByLangId(LANGIDFROMHKL(hKL));
            if (! pAsm)
            {
                CAssemblyList::InvalidCache();
                EnsureAssemblyList(psfn, TRUE);
            }
        }

        ActivateAssembly(LANGIDFROMHKL(hKL), ACTASM_NONE);
    }
    else
    {
        CThreadInputMgr *ptim = psfn->ptim;
        if (ptim && ptim->_GetFocusDocInputMgr()) 
        {
            ASSEMBLYITEM *pItem = NULL;

            if (psfn->pAsmList)
            {
                CAssembly *pAsm = psfn->pAsmList->FindAssemblyByLangId(LANGIDFROMHKL(hKL));
                if (pAsm)
                    pItem = pAsm->GetSubstituteItem(hKL);
            }

            if (pItem)
                ActivateAssemblyItem(psfn, LANGIDFROMHKL(hKL), pItem, AAIF_CHANGEDEFAULT);
        }
    }
}

//+---------------------------------------------------------------------------
//
// InputLangChangeHandler
//
//+---------------------------------------------------------------------------

void InputLangChangeHandler(MSG *pmsg)
{
    SYSTHREAD *psfn;
    IMM32HOTKEY *pHotKey;
    HKL hKL = GetKeyboardLayout(0);
    psfn = GetSYSTHREAD();

    if (psfn)
        psfn->hklBeingActivated = NULL;

    if (IsInLangChangeHotkeyStatus())
    { 
        pmsg->message = WM_NULL;
        return;
    }

    if (pHotKey = IsInImmHotkeyStatus(psfn, LANGIDFROMHKL(hKL)))
    {
        //
        // if we're hooking in IMM32's HotKey, we need to skip 
        // this INPUTLANGUAGECHANGEREQUEST.
        //
        pmsg->message = WM_NULL;
#ifdef SIMULATE_EATENKEYS
        CancelImmHotkey(psfn, pmsg->hwnd, pHotKey);
#endif

        //
        // Chinese IME-NONIME toggle Hack for NT.
        //
        // On Win9x, we're using real IME as a dummy hKL of CH-Tips.
        // we can forward the hotkey request to Assembly here.
        //
        if ((pHotKey->dwId == IME_CHOTKEY_IME_NONIME_TOGGLE) ||
            (pHotKey->dwId == IME_THOTKEY_IME_NONIME_TOGGLE))
        {
            if (!IsOnNT())
            {
                PostThreadMessage(GetCurrentThreadId(), 
                                  g_msgPrivate, 
                                  TFPRIV_ACTIVATELANG,  
                                  0x0409);
        
            }
            else
            {
                ToggleCHImeNoIme(psfn, LANGIDFROMHKL(hKL), LANGIDFROMHKL(hKL));
            }
        }
    }

    //
    // WM_INPUTLANGCHNAGEREQUEST is being queued now.
    // Post another message to confirm the hKL.
    //
    PostThreadMessage(GetCurrentThreadId(),
                      g_msgPrivate,
                      TFPRIV_POSTINPUTCHANGEREQUEST,
                      0);
}

//+---------------------------------------------------------------------------
//
// _InsideLoaderLock
//
//+---------------------------------------------------------------------------

BOOL _InsideLoaderLock()
{
    return (NtCurrentTeb()->ClientId.UniqueThread ==
           ((PRTL_CRITICAL_SECTION)(NtCurrentPeb()->LoaderLock))->OwningThread);
}

//+---------------------------------------------------------------------------
//
// _OwnedLoaderLockBySomeone
//
//+---------------------------------------------------------------------------

BOOL _OwnedLoaderLockBySomeone()
{
    return ((PRTL_CRITICAL_SECTION)(NtCurrentPeb()->LoaderLock))->OwningThread ? TRUE : FALSE;
}


LONG WINAPI CicExceptionFilter(struct _EXCEPTION_POINTERS *pExceptionInfo)
{
    (LONG)RtlUnhandledExceptionFilter(pExceptionInfo);
    return(EXCEPTION_EXECUTE_HANDLER);
}


//+---------------------------------------------------------------------------
//
// SysGetMsgProc
//
//+---------------------------------------------------------------------------

LRESULT CALLBACK SysGetMsgProc(int nCode, WPARAM wParam, LPARAM lParam)
{
    HHOOK hHook;

    if (g_fDllProcessDetached)
    {
        hHook = s_hSysGetMsgHook;
        goto Exit;
    }

    _try 
    {
        hHook = GetSharedMemory()->hSysGetMsgHook.GetHandle(g_bOnWow64);

        if (nCode == HC_ACTION && (wParam & PM_REMOVE)) // bug 29656: sometimes w/ word wParam is set to PM_REMOVE | PM_NOYIELD
        {                                               // PM_NOYIELD is meaningless in win32 and sould be ignored
            _GetMsgHook(wParam, lParam);
        }
    }
    _except(CicExceptionFilter(GetExceptionInformation()))
    {
        Assert(0);
    }

Exit:
    return CallNextHookEx(hHook, nCode, wParam, lParam);
}

UINT _GetMsgHook(WPARAM wParam, LPARAM lParam)
{
    MSG *pmsg;
    UINT uMsg;
    CThreadInputMgr *ptim;
    SYSTHREAD *psfn;

    pmsg = (MSG *)lParam;
    uMsg = pmsg->message;

    switch (uMsg)
    {
        case WM_ACTIVATEAPP:
            TraceMsg(TF_GENERAL, "SysGetMsgProc: WM_ACTIVATEAPP %x %x", GetCurrentThreadId(), pmsg->wParam);
            if (pmsg->wParam)
            {
                OnForegroundChanged(NULL);
            }
            break;

        case WM_INPUTLANGCHANGEREQUEST:
            InputLangChangeHandler(pmsg);
            break;

        default:                
            if (uMsg == g_msgPrivate)
            {
                psfn = GetSYSTHREAD();
                if (psfn && psfn->pti)
                {
                    DWORD dwFlags = TLFlagFromTFPriv(pmsg->wParam);
                    psfn->pti->dwFlags &= ~dwFlags;
                }

                switch (LOWORD(pmsg->wParam))
                {
                    case TFPRIV_ONSETWINDOWFOCUS:
                        OnSetWindowFocusHandler(psfn, pmsg);
                        break;

                    case TFPRIV_ONKILLTHREADFOCUS:
                        //
                        // #497764
                        //
                        // PENJPN.DLL calls LoadImage() in ThreadFocusSink.
                        // But it needs loader lock because it calls 
                        // GetModuleFileName().
                        //
                        // So we can not call ThreadFocusSink while someone 
                        // holds the loader lock.
                        //
                        if (_OwnedLoaderLockBySomeone() && !_InsideLoaderLock())
                        {
                            Assert(0);
                            DWORD dwCurrentThread = GetCurrentThreadId();
                            if (GetSharedMemory()->dwFocusThread != dwCurrentThread)
                            {
                                PostThreadMessage(dwCurrentThread,
                                                  g_msgPrivate, 
                                                  TFPRIV_ONKILLTHREADFOCUS,
                                                  0);
                            }
                            break;
                        }
                        // fall through...
                    case TFPRIV_ONSETTHREADFOCUS:
                        if (psfn && (ptim = CThreadInputMgr::_GetThisFromSYSTHREAD(psfn)))
                        {
                            ptim->_OnThreadFocus(pmsg->wParam == TFPRIV_ONSETTHREADFOCUS);
                        }
                        break;

                    case TFPRIV_UPDATEDISPATTR:
                        if (psfn && (ptim = CThreadInputMgr::_GetThisFromSYSTHREAD(psfn)))
                        {
                            ptim->UpdateDispAttr();
                        }
                        break;

                    case TFPRIV_LANGCHANGE:
                        if (psfn && psfn->plbim && psfn->plbim->_GetLBarItemCtrl())
                        {
                            BOOL bRet = ActivateNextAssembly((BOOL)(pmsg->lParam));
                        }
                        break;

                    case TFPRIV_KEYTIPCHANGE:
                        if (psfn && psfn->plbim && psfn->plbim->_GetLBarItemCtrl())
                        {
                            ActivateNextKeyTip((BOOL)(pmsg->lParam));
                        }
                        break;

                    case TFPRIV_GLOBALCOMPARTMENTSYNC:
                        if (psfn)
                        {
                            if (psfn->_pGlobalCompMgr)
                                psfn->_pGlobalCompMgr->NotifyGlobalCompartmentChange((DWORD)(pmsg->lParam));
                        }
                        break;

                    case TFPRIV_SETMODALLBAR:
                        SetModalLBarId(HIWORD((DWORD)pmsg->lParam),
                                       LOWORD((DWORD)pmsg->lParam));
                        break;

                    case TFPRIV_RELEASEMODALLBAR:
                        SetModalLBarId(-1, -1);
                        break;

                    case TFPRIV_UPDATE_REG_KBDTOGGLE:
                        InitLangChangeHotKey();
                        break;

                    case TFPRIV_UPDATE_REG_IMX:
                        UpdateRegIMXHandler();
                        break;

                     case TFPRIV_REGISTEREDNEWLANGBAR:
//                        TraceMsg(TF_GENERAL, "TFPRIV_REGISTEREDNEWLANGBAR current thread %x", GetCurrentThreadId());
                        MakeSetFocusNotify(g_msgSetFocus, 0, 0);
                        break;

                     case TFPRIV_SYSCOLORCHANGED:
                        if (psfn)
                            FlushIconIndex(psfn);

                        break;

                     case TFPRIV_LOCKREQ:
                        if (psfn)
                        {
                            psfn->_fLockRequestPosted = FALSE;
                            CInputContext::_PostponeLockRequestCallback(psfn, NULL);
                        }
                        break;

                     case TFPRIV_POSTINPUTCHANGEREQUEST:
                         PostInputChangeRequestHandler();
                         break;

                     case TFPRIV_LANGBARCLOSED:
                         LangBarClosed();
                         break;

                     case TFPRIV_ACTIVATELANG:
                         ActivateAssembly((LANGID)pmsg->lParam, ACTASM_NONE);
                         break;

                     case TFPRIV_ENABLE_MSAA:
                         if (psfn && (ptim = CThreadInputMgr::_GetThisFromSYSTHREAD(psfn)))
                         {
                            ptim->_InitMSAA();
                         }
                         break;

                     case TFPRIV_DISABLE_MSAA:
                         if (psfn && (ptim = CThreadInputMgr::_GetThisFromSYSTHREAD(psfn)))
                         {
                             ptim->_UninitMSAA();
                         }
                         break;
                }
            }
            else if ((uMsg == g_msgSetFocus) ||
                     (uMsg == g_msgThreadTerminate) ||
                     (uMsg == g_msgThreadItemChange) ||
                     (uMsg == g_msgShowFloating) ||
                     (uMsg == g_msgLBUpdate))
            {
                SetFocusNotifyHandler(uMsg, pmsg->wParam, pmsg->lParam);
            }
            else if (uMsg == g_msgLBarModal)
            {
                DispatchModalLBar((DWORD)pmsg->wParam, pmsg->lParam);
            }
#ifdef DEBUG
            else if ((uMsg == g_msgRpcSendReceive) ||
#ifdef POINTER_MARSHAL
                     (uMsg == g_msgPointerMarshal) ||
#endif //  POINTER_MARSHAL
                     (uMsg == g_msgThreadMarshal) ||
                     (uMsg == g_msgStubCleanUp)) 
            {
                 if (!pmsg->hwnd)
                 {
                     Assert(0);
                 }
            }
#endif


            break;
    }

    return 1;
}

//+---------------------------------------------------------------------------
//
// StartKanaCapsUpdateTimer
//
//+---------------------------------------------------------------------------

void StartKanaCapsUpdateTimer(SYSTHREAD *psfn)
{
    if (GetCurrentAssemblyLangId(psfn) != 0x0411)
        return;

    if (!IsWindow(psfn->hwndMarshal))
        return;

    SetTimer(psfn->hwndMarshal, MARSHALWND_TIMER_UPDATEKANACAPS, 300, NULL);
}

//+---------------------------------------------------------------------------
//
// KanaCapsUpdate
//
//+---------------------------------------------------------------------------

void KanaCapsUpdate(SYSTHREAD *psfn)
{
    static SHORT g_sCaps = 0;
    static SHORT g_sKana = 0;

    if (GetCurrentAssemblyLangId(psfn) != 0x0411)
        return;

    SHORT sCaps = g_sCaps;
    SHORT sKana = g_sKana;
    g_sCaps = GetKeyState(VK_CAPITAL) & 0x01;
    g_sKana = GetKeyState(VK_KANA) & 0x01;

    //
    // if psfn->fInitCapsKanaIndicator is true, it is enough to make a
    // notification only when status is changed.
    //
    if ((sCaps != g_sCaps) || 
        (sKana != g_sKana) ||
        !psfn->fInitCapsKanaIndicator)
    {
        MakeSetFocusNotify(g_msgLBUpdate, TF_LBU_CAPSKANAKEY, 
                           (LPARAM)((g_sCaps ? TF_LBUF_CAPS : 0) | 
                                    (g_sKana ? TF_LBUF_KANA : 0)));

        psfn->fInitCapsKanaIndicator = TRUE; 
    }
}

//+---------------------------------------------------------------------------
//
// CheckKoreanMouseClick
//
//+---------------------------------------------------------------------------

BOOL CheckKoreanMouseClick(SYSTHREAD *psfn, WPARAM wParam, LPARAM lParam)
{
    //
    //  check KeyUp and VK_PROCESSKEY
    //
    if (!(HIWORD(lParam) & KF_UP) || ((wParam & 0xff) != VK_PROCESSKEY))
        return FALSE;

    //
    //  if the current language is not 0x412, return.
    //
    if (GetCurrentAssemblyLangId(psfn) != 0x412)
        return FALSE;

    //
    //  If toolbar is clicked, we eat this VK_PROCESSKEY.
    //
    POINT pt;
    HWND hwnd;
    if (!GetCursorPos(&pt))
        return FALSE;

    hwnd = WindowFromPoint(pt);
    if (!hwnd)
        return FALSE;

    DWORD dwTimFlags = g_timlist.GetFlags(GetWindowThreadProcessId(hwnd, NULL));

    return (dwTimFlags & TLF_CTFMONPROCESS) ? TRUE : FALSE;
}

//+---------------------------------------------------------------------------
//
// IsJapaneseNonIMEVKKANJI
//
//+---------------------------------------------------------------------------

BOOL IsJapaneseNonIMEVKKANJI(WPARAM wParam)
{
    if ((wParam & 0xff) != VK_KANJI)
        return FALSE;

    HKL hkl = GetKeyboardLayout(0);
    if (IsPureIMEHKL(hkl))
        return FALSE;

    if (PRIMARYLANGID(LANGIDFROMHKL(hkl)) != LANG_JAPANESE)
        return FALSE;

    return TRUE;
}

//+---------------------------------------------------------------------------
//
// IsKoreanNonIMEVKJUNJA
//
//+---------------------------------------------------------------------------

BOOL IsKoreanNonIMEVKJUNJA(WPARAM wParam)
{
    if ((wParam & 0xff) != VK_JUNJA)
        return FALSE;

    HKL hkl = GetKeyboardLayout(0);
    if (IsPureIMEHKL(hkl))
        return FALSE;

    if (PRIMARYLANGID(LANGIDFROMHKL(hkl)) != LANG_KOREAN)
        return FALSE;

    return TRUE;
}

//+---------------------------------------------------------------------------
//
// ThreadKeyboardProc
//
//+---------------------------------------------------------------------------

//
// Workaround for global keyboard hook
//
// On IA64 platform, Cicero install two global keyboard hooks which is 64bit and 32bit code.
// When any keyboard event occur on one apps instance, there two global keyboard hook procedure
// (SysKeyboardProc) called from win32k xxxCallHook2.
// If xxxCallHook2 detect different instance between current and receiver which is 64bit and 32bit, 
// this function notify by InterSendMsg.
//
LRESULT CALLBACK ThreadKeyboardProc(int nCode, WPARAM wParam, LPARAM lParam)
{
    HHOOK hHook = NULL;
    UINT ret = 0;
    SYSTHREAD *psfn = GetSYSTHREAD();

    if (psfn)
        hHook = psfn->hThreadKeyboardHook;

    if (g_fDllProcessDetached)
        goto Exit;

    if (nCode == HC_ACTION)
    {
        _try
        {
            ret = _KeyboardHook(wParam, lParam);
        }
        _except(CicExceptionFilter(GetExceptionInformation()))
        {
            Assert(0);
        }
    }

Exit:
    if ((ret == 0) && hHook)
        return CallNextHookEx(hHook, nCode, wParam, lParam);
    else
        return ret;
}

UINT _KeyboardHook(WPARAM wParam, LPARAM lParam)
{
    SYSTHREAD *psfn = GetSYSTHREAD();
    CThreadInputMgr *ptim = NULL;
    BOOL fEaten;
    HRESULT hr;

    if (psfn)
        ptim = CThreadInputMgr::_GetThisFromSYSTHREAD(psfn);

    //
    // If we're in Modal Lang bar mode (menu is shown.), 
    // we want to eat keys.
    //
    if (HandleModalLBar((HIWORD(lParam) & KF_UP) ? WM_KEYUP : WM_KEYDOWN,
                         wParam, lParam))
        return 1;


    if (CheckKoreanMouseClick(psfn, wParam, lParam))
        return 1;

    UpdateModifiers(wParam, lParam);

    if ((HIWORD(lParam) & KF_UP))
        StartKanaCapsUpdateTimer(psfn);

    if (psfn)
    {
        if (CheckLangChangeHotKey(psfn, wParam, lParam))
        {
            //
            // Cic#4645 We need to forward this key envent ot the next hook.
            // mstsc.exe (TS client) needs it.
            //
            return 0;
            // goto Exit;
            // return 1;
        }
    }

    //
    // On CUAS, Imm32's Hotkey is simulated in ImmProcessKey
    //
    if (!psfn || !CtfImmIsCiceroStartedInThread())
        CheckImm32HotKey(wParam, lParam);

    if (HandleDBEKeys(wParam, lParam))
    {
        //
        // #519671
        //
        // If there is a focus DIM and the current asm item is not Japanese
        // TIP, we switch the assembly to Japanese TIP and open it.
        //
        // we do this after calling HandleDBEKeys(). So TIP's keyboard
        // event sink for VK_KANJI won't be called.
        //
        if (IsJapaneseNonIMEVKKANJI(wParam))
            ToggleJImeNoIme(psfn);

        //
        // Cic#4645 We need to forward this key envent ot the next hook.
        // mstsc.exe (TS client) needs it.
        //
        return 0;
        // goto Exit;
        // return 1;
    }

    if (ptim)
    {
        ptim->_NotifyKeyTraceEventSink(wParam, lParam);

        if (ptim->_ProcessHotKey(wParam, lParam, TSH_SYSHOTKEY, FALSE, FALSE))
            return 1;

        //
        // give AIMM the key events.
        //
        if (ptim->GetSysHookSink())
        {
            hr = ptim->GetSysHookSink()->OnSysKeyboardProc(wParam, lParam);
            if (hr == S_OK)
                return 1;
        }

        //
        // At last we can call KeyStrokemMgr.
        //
        if (!ptim->_AppWantsKeystrokes() &&
            ptim->_IsKeystrokeFeedEnabled() &&
            wParam != VK_PROCESSKEY &&
            (!(HIWORD(lParam) & (KF_MENUMODE | KF_ALTDOWN)) || IsKoreanNonIMEVKJUNJA(wParam)))
        {
            hr = (HIWORD(lParam) & KF_UP) ? ptim->KeyUp(wParam, lParam, &fEaten) :
                                            ptim->KeyDown(wParam, lParam, &fEaten);

            if (hr == S_OK && fEaten)
                return 1;
        }

        //
        // F10 SysKeyDown work arround.
        //
        // KSMGR won't be called on WM_SYSKEYDOWN/UP. So we foward F10
        // through AsynKeyHandler to support SyncLock in KS callback.
        //
        // we don't have to do this if there is no foreground keyboard tip.
        //
        if (((wParam & 0xff) == VK_F10) &&
            (ptim->GetForegroundKeyboardTip() != TF_INVALID_GUIDATOM))
        {
            fEaten = FALSE;
            if (ptim->_AsyncKeyHandler(wParam, 
                                       lParam, 
                                       TIM_AKH_SIMULATEKEYMSGS, 
                                       &fEaten) && fEaten)
                return 1;
        }
    }

    return 0;
}

//+---------------------------------------------------------------------------
//
// ThreadMouseProc
//
//+---------------------------------------------------------------------------

LRESULT CALLBACK ThreadMouseProc(int nCode, WPARAM wParam, LPARAM lParam)
{
    HHOOK hHook = NULL;
    SYSTHREAD *psfn = GetSYSTHREAD();

    if (psfn)
        hHook = psfn->hThreadMouseHook;

    if (g_fDllProcessDetached)
        goto Exit;

    if (nCode == HC_ACTION)
    {
        BOOL bRet = FALSE;
        if ((wParam  == WM_MOUSEMOVE) || (wParam == WM_NCMOUSEMOVE))
            goto Exit;

        _try
        {
            bRet = HandleModalLBar((UINT)wParam, 0,
                                MAKELPARAM(((MOUSEHOOKSTRUCT *)lParam)->pt.x,
                                           ((MOUSEHOOKSTRUCT *)lParam)->pt.y));
        }
        _except(CicExceptionFilter(GetExceptionInformation()))
        {
            Assert(0);
        }

        if (bRet)
            return 1;
    }

Exit:
    if (hHook)
        return CallNextHookEx(hHook, nCode, wParam, lParam);
    else
        return 0;
}

//+---------------------------------------------------------------------------
//
// UninitHooks
//
//+---------------------------------------------------------------------------

void UninitHooks()
{
    HHOOK _h;

    if ( (_h = GetSharedMemory()->hSysShellHook.GetHandle(g_bOnWow64)) != NULL)
    {
        UnhookWindowsHookEx(_h);
        GetSharedMemory()->hSysShellHook.SetHandle(g_bOnWow64, NULL);
    }

    if ( (_h = GetSharedMemory()->hSysCBTHook.GetHandle(g_bOnWow64)) != NULL)
    {
        UnhookWindowsHookEx(_h);
        GetSharedMemory()->hSysCBTHook.SetHandle(g_bOnWow64, NULL);
    }

    if ( (_h = GetSharedMemory()->hSysGetMsgHook.GetHandle(g_bOnWow64)) != NULL)
    {
        UnhookWindowsHookEx(_h);
        GetSharedMemory()->hSysGetMsgHook.SetHandle(g_bOnWow64, NULL);
    }
}

//+---------------------------------------------------------------------------
//
// InitHooks
//
//+---------------------------------------------------------------------------

void InitHooks()
{
    Assert(! GetSharedMemory()->hSysShellHook.GetHandle(g_bOnWow64));
    GetSharedMemory()->hSysShellHook.SetHandle(g_bOnWow64, SetWindowsHookEx(WH_SHELL, SysShellProc, g_hInst, 0));

    //
    // nb:     we could move GetMsgHook to per-thread hook if we get rid of
    //         TFPRIV_MARSHALINTERFACE for non-cicero apps.
    //         TFPRIV_MARSHALINTERFACE is necesary because Tipbar does not
    //         know if the target thread has TIM. If there is no TIP or
    //         the GetMsgHook, the tipbar waits until timeout.
    //         To solve this problem, we must have TIM's thread list
    //         in shared mem. Maybe we should do this.
    //
    Assert(! GetSharedMemory()->hSysGetMsgHook.GetHandle(g_bOnWow64));
    if (IsOnNT())
    {
        // we need a W hook on NT to work-around an os dbcs/unicode translation bug (4243)
        GetSharedMemory()->hSysGetMsgHook.SetHandle(g_bOnWow64, SetWindowsHookExW(WH_GETMESSAGE, SysGetMsgProc, g_hInst, 0));
    }
    else
    {
        GetSharedMemory()->hSysGetMsgHook.SetHandle(g_bOnWow64, SetWindowsHookExA(WH_GETMESSAGE, SysGetMsgProc, g_hInst, 0));
    }

    Assert(! GetSharedMemory()->hSysCBTHook.GetHandle(g_bOnWow64));
    GetSharedMemory()->hSysCBTHook.SetHandle(g_bOnWow64, SetWindowsHookEx(WH_CBT, SysCBTProc, g_hInst, 0));

    InitStaticHooks();
}

//+---------------------------------------------------------------------------
//
// InitThreadHooks
//
//+---------------------------------------------------------------------------

void InitThreadHook(DWORD dwThreadId)
{
    SYSTHREAD *psfn = GetSYSTHREAD();
    if (!psfn)
        return;

    if (psfn->hThreadKeyboardHook && psfn->hThreadMouseHook)
        return;

    PVOID pvLdrLockCookie = NULL;
    ULONG ulLockState = 0;

    // make sure that no one else owns the loader lock because we
    //  could otherwise deadlock
    LdrLockLoaderLock(LDR_LOCK_LOADER_LOCK_FLAG_TRY_ONLY, &ulLockState, 
                      &pvLdrLockCookie);
    if (ulLockState == LDR_LOCK_LOADER_LOCK_DISPOSITION_LOCK_ACQUIRED)
    {
        __try {
            if (!psfn->hThreadKeyboardHook)
            {
                //
                // Install Local keyboard hook with hMod value.
                // win32k mantain hMod ref count even another global hook 
                // detached.
                //
                psfn->hThreadKeyboardHook = SetWindowsHookEx(WH_KEYBOARD, ThreadKeyboardProc, g_hInst, dwThreadId);

            }
            if (!psfn->hThreadMouseHook)
            {
                //
                // Install Local keyboard hook with hMod value.
                // win32k mantain hMod ref count even another global hook 
                // detached.
                //
                psfn->hThreadMouseHook = SetWindowsHookEx(WH_MOUSE, ThreadMouseProc, g_hInst, dwThreadId);
            }

        }
        _except(CicExceptionFilter(GetExceptionInformation()))
        {
        }
        LdrUnlockLoaderLock(0, pvLdrLockCookie);
    }

}

//+---------------------------------------------------------------------------
//
// UninitThreadHooks
//
//+---------------------------------------------------------------------------

void UninitThreadHooks(SYSTHREAD *psfn)
{
    if (!psfn)
        return;

    if (psfn->hThreadKeyboardHook)
    {
        UnhookWindowsHookEx(psfn->hThreadKeyboardHook);
        psfn->hThreadKeyboardHook = NULL;
    }
    if (psfn->hThreadMouseHook)
    {
        UnhookWindowsHookEx(psfn->hThreadMouseHook);
        psfn->hThreadMouseHook = NULL;
    }
}

//+---------------------------------------------------------------------------
//
// TF_InitSystem
//
// Called by ctfmon on a single thread.
//+---------------------------------------------------------------------------

extern "C" BOOL WINAPI TF_InitSystem(void)
{
    SYSTHREAD *psfn;

    g_fCTFMONProcess = TRUE;
    g_timlist.Init(TRUE);
    if (psfn = GetSYSTHREAD())
    {
        g_gcomplist.Init(psfn);

        EnsureAsmCacheFileMap();
        EnsureAssemblyList(psfn);
        psfn->fCTFMON = TRUE;
    }

    InitHooks();

    return TRUE;
}

//+---------------------------------------------------------------------------
//
// TF_UninitSystem
//
// Called by ctfmon on a single thread.
//+---------------------------------------------------------------------------

extern "C" BOOL WINAPI TF_UninitSystem(void)
{
    CThreadMarshalWnd::DestroyAll();

    UninitAsmCacheFileMap();

    g_timlist.Uninit();

    SYSTHREAD *psfn = FindSYSTHREAD();
    g_gcomplist.Uninit(psfn);

    UninitHooks();

    return TRUE;
}


//+---------------------------------------------------------------------------
//
// TF_InitThreadSystem
//
//+---------------------------------------------------------------------------

BOOL TF_InitThreadSystem(void)
{
    DWORD dwThreadId = GetCurrentThreadId();

    //
    // we should not see the timlist entry of this thread. This thread
    // is starting now.
    // the thread with same ID was terminated incorrectly so there was no
    // chance to clean timlist up.
    //

    if (g_timlist.IsThreadId(dwThreadId))
    {
        g_timlist.RemoveThread(dwThreadId);
    }

    return TRUE;
}

//+---------------------------------------------------------------------------
//
// TF_UninitThreadSystem
//
//+---------------------------------------------------------------------------

BOOL TF_UninitThreadSystem(void)
{
    SYSTHREAD *psfn = FindSYSTHREAD();

    g_gcomplist.Uninit(psfn);

    FreeSYSTHREAD();

    return TRUE;
}

//+---------------------------------------------------------------------------
//
// UninitProcess()
//
//+---------------------------------------------------------------------------

void UninitProcess()
{
    DWORD dwProcessId = GetCurrentProcessId();

    //
    // FreeSYSTHREAD2() removes psfn from PtrArray.
    //
    if (g_rgSysThread)
    {

        while(g_rgSysThread->Count())
        {
            SYSTHREAD *psfn = g_rgSysThread->Get(0);
            if (psfn)
                FreeSYSTHREAD2(psfn);
        }
        delete g_rgSysThread;
        g_rgSysThread = NULL;

    }

    //
    // remove all timlist entries for the current process.
    //
    g_timlist.RemoveProcess(dwProcessId);


    CCategoryMgr::UninitGlobal();
}

//+---------------------------------------------------------------------------
//
// InitAppCompatFlags
//
//+---------------------------------------------------------------------------

BOOL InitAppCompatFlags()
{
    TCHAR szAppCompatKey[MAX_PATH];
    TCHAR szFileName[MAX_PATH];
    if (::GetModuleFileName(NULL,            // handle to module
                            szFileName,      // file name of module
                            sizeof(szFileName)/sizeof(TCHAR)) == 0)
        return FALSE;

    TCHAR  szModuleName[MAX_PATH];
    LPTSTR pszFilePart = NULL;
    ::GetFullPathName(szFileName,            // file name
                      sizeof(szModuleName)/sizeof(TCHAR),
                      szModuleName,          // path buffer
                      &pszFilePart);         // address of file name in path

    if (pszFilePart == NULL)
        return FALSE;


    StringCopyArray(szAppCompatKey, c_szAppCompat);
    StringCatArray(szAppCompatKey, pszFilePart);
    CMyRegKey key;
    if (key.Open(HKEY_LOCAL_MACHINE, szAppCompatKey, KEY_READ) == S_OK)
    {
        DWORD dw;
        if (key.QueryValue(dw, c_szCompatibility) == S_OK)
            g_dwAppCompatibility = dw;
    }

    //
    // Ciero #4605
    //
    // hack for 16bit apps on Win9x platform.
    // all 16bit apps shrare one PPI (process info) and this means that
    // there is one main thread for WaitForInputIdle() for all 16 bit apps.
    // so we stop using WaitForInputIdle().
    //
    if (!IsOnNT())
    {
        if (!lstrcmpi(pszFilePart, "kernel32.dll"))
            g_dwAppCompatibility |= CIC_COMPAT_NOWAITFORINPUTIDLEONWIN9X;
    }

    return TRUE;
}

//+---------------------------------------------------------------------------
//
// InitCUASFlag
//
//+---------------------------------------------------------------------------

void InitCUASFlag()
{
    CMyRegKey key;
    CMyRegKey keyIMM;
    if (key.Open(HKEY_LOCAL_MACHINE, c_szCtfShared, KEY_READ) == S_OK)
    {
        DWORD dw;
        if (key.QueryValue(dw, c_szCUAS) == S_OK)
            g_fCUAS = dw ? TRUE : FALSE;
    }

    g_szCUASImeFile[0] = '\0';
    if (g_fCUAS)
    {
        if (keyIMM.Open(HKEY_LOCAL_MACHINE, c_szIMMKey, KEY_READ) == S_OK)
        {
            TCHAR szCUASImeFile[16];
            if (keyIMM.QueryValueCch(szCUASImeFile, c_szCUASIMEFile, ARRAYSIZE(szCUASImeFile)) == S_OK)
                lstrcpy(g_szCUASImeFile, szCUASImeFile);
        }
    }

}

//+---------------------------------------------------------------------------
//
// TF_DllDetachInOther
//
//+---------------------------------------------------------------------------

extern "C" BOOL WINAPI TF_DllDetachInOther()
{
    SYSTHREAD *psfn = FindSYSTHREAD();

    if (psfn)
        psfn->fCUASDllDetachInOtherOrMe = TRUE;

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\ctf\uim\editrec.cpp ===
//
// editrec.cpp
//

#include "private.h"
#include "editrec.h"
#include "ic.h"
#include "enumss.h"

DBG_ID_INSTANCE(CEditRecord);

//+---------------------------------------------------------------------------
//
// ctor
//
//----------------------------------------------------------------------------

CEditRecord::CEditRecord(CInputContext *pic)
{
    Dbg_MemSetThisNameIDCounter(TEXT("CEditRecord"), PERF_EDITREC_COUNTER);

    Assert(_fSelChanged == FALSE);

    _pic = pic;
    _pic->AddRef();
}

//+---------------------------------------------------------------------------
//
// dtor
//
//----------------------------------------------------------------------------

CEditRecord::~CEditRecord()
{
    int i;
    PROPSPAN *pps;

    _pic->Release();

    for (i=0; i<_rgssProperties.Count(); i++)
    {
        pps = (PROPSPAN *)_rgssProperties.GetPtr(i);
        delete pps->pss;
    }
}

//+---------------------------------------------------------------------------
//
// GetSelectionStatus
//
//----------------------------------------------------------------------------

STDAPI CEditRecord::GetSelectionStatus(BOOL *pfChanged)
{
    if (pfChanged == NULL)
        return E_INVALIDARG;

    *pfChanged = _fSelChanged;
    return S_OK;
}

//+---------------------------------------------------------------------------
//
// GetTextAndPropertyUpdates
//
//----------------------------------------------------------------------------

STDAPI CEditRecord::GetTextAndPropertyUpdates(DWORD dwFlags, const GUID **rgProperties, ULONG cProperties, IEnumTfRanges **ppEnumProp)
{
    CEnumSpanSetRanges *pssAccumulate;
    CSpanSet *pssCurrent;
    ULONG i;

    if (ppEnumProp == NULL)
        return E_INVALIDARG;

    *ppEnumProp = NULL;

    if (dwFlags & ~TF_GTP_INCL_TEXT)
        return E_INVALIDARG;

    if (!(dwFlags & TF_GTP_INCL_TEXT) &&
        (rgProperties == NULL || cProperties < 1))
    {
        return E_INVALIDARG;
    }

    if ((pssAccumulate = new CEnumSpanSetRanges(_pic)) == NULL)
        return E_OUTOFMEMORY;

    if (dwFlags & TF_GTP_INCL_TEXT)
    {
        pssAccumulate->_Merge(&_ssText);
    }

    for (i=0; i<cProperties; i++)
    {
        if ((pssCurrent = _FindPropertySpanSet(*rgProperties[i])) == NULL)
            continue;

        pssAccumulate->_Merge(pssCurrent);
    }

    *ppEnumProp = pssAccumulate;
    return S_OK;
}

//+---------------------------------------------------------------------------
//
// _AddProperty
//
//----------------------------------------------------------------------------

BOOL CEditRecord::_AddProperty(TfGuidAtom gaType, CSpanSet *pss)
{
    int i;
    PROPSPAN *pps;

    pps = _FindProperty(gaType, &i);
    Assert(pps == NULL); // property should not already have been added

    return _InsertProperty(gaType, pss, i+1, FALSE);
}

//+---------------------------------------------------------------------------
//
// _FindCreateAppAttr
//
//----------------------------------------------------------------------------

CSpanSet *CEditRecord::_FindCreateAppAttr(TfGuidAtom gaType)
{
    int i;
    PROPSPAN *pps;
    CSpanSet *pss;

    pps = _FindProperty(gaType, &i);

    if (pps != NULL)
    {
        return pps->pss;
    }

    if ((pss = new CSpanSet) == NULL)
        return FALSE;

    if (!_InsertProperty(gaType, pss, i+1, TRUE))
    {
        delete pss;
        return NULL;
    }

    return pss;
}

//+---------------------------------------------------------------------------
//
// _InsertProperty
//
//----------------------------------------------------------------------------

BOOL CEditRecord::_InsertProperty(TfGuidAtom gaType, CSpanSet *pss, int i, BOOL fAppProperty)
{
    PROPSPAN *pps;

    if (!_rgssProperties.Insert(i, 1))
        return FALSE;

    pps = _rgssProperties.GetPtr(i);

    pps->gaType = gaType;
    pps->fAppProperty = fAppProperty;
    pps->pss = pss;

    return TRUE;
}

//+---------------------------------------------------------------------------
//
// _FindProperty
//
//----------------------------------------------------------------------------

PROPSPAN *CEditRecord::_FindProperty(TfGuidAtom gaType, int *piOut)
{
    PROPSPAN *ps;
    PROPSPAN *psMatch;
    int iMin;
    int iMax;
    int iMid;

    //
    // Issue: we should have a generic bsort function
    // instead of all this code dup!
    //

    psMatch = NULL;
    iMid = -1;
    iMin = 0;
    iMax = _rgssProperties.Count();

    while (iMin < iMax)
    {
        iMid = (iMin + iMax) / 2;
        ps = _rgssProperties.GetPtr(iMid);
        Assert(ps != NULL);

        if (gaType < ps->gaType)
        {
            iMax = iMid;
        }
        else if (gaType > ps->gaType)
        {
            iMin = iMid + 1;
        }
        else // match!
        {
            psMatch = ps;
            break;
        }
    }

    if (piOut != NULL)
    {
        if (psMatch == NULL && _rgssProperties.Count() > 0)
        {
            // couldn't find a match, return the next lowest span
            Assert(iMid == 0 || _rgssProperties.GetPtr(iMid-1)->gaType < gaType);
            if (_rgssProperties.GetPtr(iMid)->gaType > gaType)
            {
                iMid--;
            }
        }
        *piOut = iMid;
    }

    return psMatch;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\ctf\uim\dllmain.cpp ===
//
// dllmain.cpp
//

#include "private.h"
#include "globals.h"
#include "tim.h"
#include "imelist.h"
#include "utb.h"
#include "dam.h"
#include "catmgr.h"
#include "nuimgr.h"
#include "profiles.h"
#include "internat.h"
#include "acp2anch.h"
#include "cicmutex.h"
#include "strary.h"
#include "range.h"
#include "compart.h"
#include "marshal.h"
#include "timlist.h"
#include "gcompart.h"
#include "mui.h"
#include "anchoref.h"
#include "hotkey.h"
#include "lbaddin.h"

extern "C" BOOL WINAPI _CRT_INIT(HINSTANCE, DWORD, LPVOID);

extern HINSTANCE g_hOle32;

extern CCicCriticalSectionStatic g_csDelayLoad;;

#ifdef DEBUG
void dbg_RangeDump(ITfRange *pRange);
#endif

extern void UninitThread(void);

extern void RegisterMarshalWndClass();

CCicMutex g_mutexLBES;
CCicMutex g_mutexCompart;
CCicMutex g_mutexAsm;
CCicMutex g_mutexLayouts;
CCicMutex g_mutexTMD;
extern void UninitLayoutMappedFile();

char g_szAsmListCache[MAX_PATH];
char g_szTimListCache[MAX_PATH];
char g_szLayoutsCache[MAX_PATH];

//
// Hack for Office10 BVT.
//
// MSACCESS 10 Debug version (CMallocSpy) shows MsgBox after DLL is detached 
// from process.
// Showing MsgBox calls window Hook so Hook entry is called then.
// Need to check the DLL was already detached.
//
BOOL g_fDllProcessDetached = FALSE;
DWORD g_dwThreadDllMain = 0;
void InitStaticHooks();

BOOL g_bOnWow64;


BOOL gf_CRT_INIT    = FALSE;
BOOL gfSharedMemory = FALSE;


//+---------------------------------------------------------------------------
//
// ProcessAttach
//
//----------------------------------------------------------------------------

BOOL ProcessAttach(HINSTANCE hInstance)
{
    CcshellGetDebugFlags();

    Perf_Init();

#ifdef DEBUG
    //
    // Do you know how to link non-used function??
    //
    dbg_RangeDump(NULL);
#endif

#ifndef NOCLIB
    gf_CRT_INIT = TRUE;
#endif

    if (!g_cs.Init())
        return FALSE;

    if (!g_csInDllMain.Init())
        return FALSE;

    if (!g_csDelayLoad.Init())
        return FALSE;

    g_bOnWow64 = RunningOnWow64();

    Dbg_MemInit( ! g_bOnWow64 ? TEXT("MSCTF") : TEXT("MSCTF(wow64)"), g_rgPerfObjCounters);

    g_hInst = hInstance;
    g_hklDefault = GetKeyboardLayout(0);

    g_dwTLSIndex = TlsAlloc();
    if (g_dwTLSIndex == TLS_OUT_OF_INDEXES)
        return FALSE;

    g_msgPrivate = RegisterWindowMessage(TEXT("MSUIM.Msg.Private"));
    if (!g_msgPrivate)
        return FALSE;

    g_msgSetFocus = RegisterWindowMessage(TEXT("MSUIM.Msg.SetFocus"));
    if (!g_msgSetFocus)
        return FALSE;

    g_msgThreadTerminate = RegisterWindowMessage(TEXT("MSUIM.Msg.ThreadTerminate"));
    if (!g_msgThreadTerminate)
        return FALSE;

    g_msgThreadItemChange = RegisterWindowMessage(TEXT("MSUIM.Msg.ThreadItemChange"));
    if (!g_msgThreadItemChange)
        return FALSE;

    g_msgLBarModal = RegisterWindowMessage(TEXT("MSUIM.Msg.LangBarModal"));
    if (!g_msgLBarModal)
        return FALSE;

    g_msgRpcSendReceive = RegisterWindowMessage(TEXT("MSUIM.Msg.RpcSendReceive"));
    if (!g_msgRpcSendReceive)
        return FALSE;

    g_msgThreadMarshal = RegisterWindowMessage(TEXT("MSUIM.Msg.ThreadMarshal"));
    if (!g_msgThreadMarshal)
        return FALSE;

    g_msgCheckThreadInputIdel = RegisterWindowMessage(TEXT("MSUIM.Msg.CheckThreadInputIdel"));
    if (!g_msgCheckThreadInputIdel)
        return FALSE;

    g_msgStubCleanUp = RegisterWindowMessage(TEXT("MSUIM.Msg.StubCleanUp"));
    if (!g_msgStubCleanUp)
        return FALSE;

    g_msgShowFloating = RegisterWindowMessage(TEXT("MSUIM.Msg.ShowFloating"));
    if (!g_msgShowFloating)
        return FALSE;

    g_msgLBUpdate = RegisterWindowMessage(TEXT("MSUIM.Msg.LBUpdate"));
    if (!g_msgLBUpdate)
        return FALSE;

    g_msgNuiMgrDirtyUpdate = RegisterWindowMessage(TEXT("MSUIM.Msg.MuiMgrDirtyUpdate"));
    if (!g_msgNuiMgrDirtyUpdate)
        return FALSE;

    InitOSVer();

    //
    // get imm32's hmodule.
    //
    InitDelayedLibs();

    InitUniqueString();

    g_SharedMemory.BaseInit();
    if (!g_SharedMemory.Start())
        return FALSE;

    gfSharedMemory = TRUE;

    InitAppCompatFlags();
    InitCUASFlag();

    g_rglbes = new CStructArray<LBAREVENTSINKLOCAL>;
    if (!g_rglbes)
        return FALSE;

    RegisterMarshalWndClass();

    GetDesktopUniqueNameArray(TEXT("CTF.AsmListCache.FMP"), g_szAsmListCache);
    GetDesktopUniqueNameArray(TEXT("CTF.TimListCache.FMP"), g_szTimListCache);
    GetDesktopUniqueNameArray(TEXT("CTF.LayoutsCache.FMP"), g_szLayoutsCache);

    TCHAR ach[MAX_PATH];

    GetDesktopUniqueNameArray(TEXT("CTF.LBES.Mutex"), ach);
    if (!g_mutexLBES.Init(NULL, ach))
        return FALSE;

    GetDesktopUniqueNameArray(TEXT("CTF.Compart.Mutex"), ach);
    if (!g_mutexCompart.Init(NULL, ach))
        return FALSE;

    GetDesktopUniqueNameArray(TEXT("CTF.Asm.Mutex"), ach);
    if (!g_mutexAsm.Init(NULL, ach))
        return FALSE;

    GetDesktopUniqueNameArray(TEXT("CTF.Layouts.Mutex"), ach);
    if (!g_mutexLayouts.Init(NULL, ach))
        return FALSE;

    GetDesktopUniqueNameArray(TEXT("CTF.TMD.Mutex"), ach);
    if (!g_mutexTMD.Init(NULL, ach))
        return FALSE;

    InitLangChangeHotKey();

    CRange::_InitClass();

    CAnchorRef::_InitClass();

    dbg_InitMarshalTimeOut();

    MuiLoadResource(hInstance, TEXT("msctf.dll"));

    CheckAnchorStores();

    return TRUE;
}

//+---------------------------------------------------------------------------
//
// ProcessDetach
//
//----------------------------------------------------------------------------

void ProcessDetach(HINSTANCE hInstance)
{
#ifndef NOCLIB
    if (gf_CRT_INIT)
    {
#endif
        if (gfSharedMemory)
        {
            //
            // If _Module.m_nLockCnt != 0, then TFUninitLib() doesn't calls from DllUninit().
            // So critical section of g_csIMLib never deleted.
            //
            if (DllRefCount() != 0)
            {
                TFUninitLib();
            }

            CRange::_UninitClass();
            CAnchorRef::_UninitClass();

            MuiClearResource();
        }

        UninitINAT();
        CDispAttrGuidCache::StaticUnInit();

        UninitThread();

        //
        // clean up all marshal window in this thread.
        //
        CThreadMarshalWnd::ClearMarshalWndProc(GetCurrentProcessId());

        TF_UninitThreadSystem();

        UninitProcess();
        if (g_dwTLSIndex != TLS_OUT_OF_INDEXES)
            TlsFree(g_dwTLSIndex);
        g_dwTLSIndex = TLS_OUT_OF_INDEXES;

        if (g_rglbes)
            delete g_rglbes;

        g_rglbes = NULL;

        g_gcomplist.CleanUp();
        g_timlist.CleanUp();
        Dbg_MemUninit();

        g_cs.Delete();
        g_csInDllMain.Delete();
        g_csDelayLoad.Delete();

        if (gfSharedMemory)
        {
            g_mutexLBES.Uninit();
            g_mutexCompart.Uninit();
            g_mutexAsm.Uninit();

            //
            // call UninitLayoutMappedFile before uninitializing the mutex.
            //
            UninitLayoutMappedFile();
            g_mutexLayouts.Uninit();

            g_mutexTMD.Uninit();

            InitStaticHooks(); // must happen before we uninit shared memory
            g_SharedMemory.Close();
        }
        g_SharedMemory.Finalize();

#ifndef NOCLIB
    }

    if (g_fDllProcessDetached)
    {
        // why were we called twice?
        Assert(0);
    }
#endif

    Assert(DllRefCount() == 0); // leaked something?

    g_fDllProcessDetached = TRUE;
}

//+---------------------------------------------------------------------------
//
// DllMain
//
//----------------------------------------------------------------------------

BOOL WINAPI DllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID pvReserved)
{
    BOOL bRet = TRUE;
    g_dwThreadDllMain = GetCurrentThreadId();

    switch (dwReason)
    {
        case DLL_PROCESS_ATTACH:
            //
            // Now real DllEntry point is _DllMainCRTStartup.
            // _DllMainCRTStartup does not call our DllMain(DLL_PROCESS_DETACH)
            // if our DllMain(DLL_PROCESS_ATTACH) fails.
            // So we have to clean this up.
            //
            if (!ProcessAttach(hInstance))
            {
                ProcessDetach(hInstance);
                bRet = FALSE;
                break;
            }

            //
            // fall thru
            //

            //
            // to call TF_InitThreadSystem(), make sure we have not initialized
            // timlist yet.
            //
            Assert(!g_timlist.IsInitialized());

        case DLL_THREAD_ATTACH:
            TF_InitThreadSystem();
            break;

        case DLL_THREAD_DETACH:
            UninitThread();
            TF_UninitThreadSystem();
            break;

        case DLL_PROCESS_DETACH:
            ProcessDetach(hInstance);
            break;
    }

    g_dwThreadDllMain = 0;
    return bRet;
}

#ifdef DEBUG
//+---------------------------------------------------------------------------
//
// dbg_RangeDump
//
//----------------------------------------------------------------------------

void dbg_RangeDump(ITfRange *pRange)
{
    WCHAR ach[256];
    ULONG cch;
    char  ch[256];
    ULONG cch1 = ARRAYSIZE(ch);

    if (!pRange)
        return;    

    pRange->GetText(BACKDOOR_EDIT_COOKIE, 0, ach, ARRAYSIZE(ach), &cch);
    ach[cch] = L'\0';
    
    TraceMsg(TF_GENERAL, "dbg_RangeDump");
    TraceMsg(TF_GENERAL, "\tpRange:       %x", (UINT_PTR)pRange);
    cch1 = WideCharToMultiByte(CP_ACP, 0, ach, -1, ch, sizeof(ch)-1, NULL, NULL);
    ch[cch1] = '\0';
    TraceMsg(TF_GENERAL, "\t%s", ch);

    char sz[512];
    sz[0] = '\0';
    for (UINT i = 0; i < cch; i++)
    {
         StringCchPrintf(sz, ARRAYSIZE(sz), "%s%04x ", sz, ach[i]);
    }
    TraceMsg(TF_GENERAL, "\t%s", sz);
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\ctf\uim\editrec.h ===
//
// editrec.h
//

#ifndef EDITREC_H
#define EDITREC_H

#include "private.h"
#include "spans.h"
#include "strary.h"
#include "globals.h"

typedef struct
{
    TfGuidAtom gaType;
    BOOL fAppProperty;
    CSpanSet *pss;
} PROPSPAN;

class CInputContext;

class CEditRecord : public ITfEditRecord,
                    public CComObjectRootImmx
{
public:
    CEditRecord(CInputContext *pic);
    ~CEditRecord();

    BEGIN_COM_MAP_IMMX(CEditRecord)
        COM_INTERFACE_ENTRY(ITfEditRecord)
    END_COM_MAP_IMMX()

    IMMX_OBJECT_IUNKNOWN_FOR_ATL()

    // ITfEditRecord
    STDMETHODIMP GetSelectionStatus(BOOL *pfChanged);
    STDMETHODIMP GetTextAndPropertyUpdates(DWORD dwFlags, const GUID **rgProperties, ULONG cProperties, IEnumTfRanges **ppEnumProp);

    BOOL _GetSelectionStatus() { return _fSelChanged; }
    void _SetSelectionStatus() { _fSelChanged = TRUE; }

    CSpanSet *_GetTextSpanSet() { return &_ssText; }

    BOOL _AddProperty(TfGuidAtom gaType, CSpanSet *pss);
    CSpanSet *_FindCreateAppAttr(TfGuidAtom gaType);

    BOOL _SecondRef()
    {
        return (m_dwRef > 1);
    }

    BOOL _IsEmpty()
    {
        return (!_fSelChanged) &&
               (_ssText.GetCount() == 0) &&
               (_rgssProperties.Count() == 0); // prop ss are only added if non-empty
    }

    void _Reset()
    {
        int i;
        PROPSPAN *pps;

        _fSelChanged = FALSE;
        _ssText.Reset();

        for (i=0; i<_rgssProperties.Count(); i++)
        {
            pps = (PROPSPAN *)_rgssProperties.GetPtr(i);
            // nb: caller takes ownership of cicero property span sets, we just free the pointer array
            if (pps->fAppProperty)
            {
                delete pps->pss;
            }
        }
        _rgssProperties.Clear(); // perf: use Reset?
    }

private:

    BOOL _InsertProperty(TfGuidAtom gaType, CSpanSet *pss, int i, BOOL fAppProperty);

    PROPSPAN *_FindProperty(TfGuidAtom gaType, int *piOut);
    int _FindPropertySpanIndex(TfGuidAtom gaType)
    {
        int i;

        _FindProperty(gaType, &i);
        return i;
    }
    CSpanSet *_FindPropertySpanSet(REFGUID rguid)
    {
        TfGuidAtom guidatom;
        PROPSPAN *pps;

        MyRegisterGUID(rguid, &guidatom);
        pps = _FindProperty(guidatom, NULL);

        return (pps == NULL) ? NULL : pps->pss;
    }

    CInputContext *_pic;
    CSpanSet _ssText;
    BOOL _fSelChanged;
    CStructArray<PROPSPAN> _rgssProperties;

    DBG_ID_DECLARE;
};

#endif // EDITREC_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\ctf\uim\enumdim.h ===
//
// enumdim.h
//

#ifndef ENUMDIM_H
#define ENUMDIM_H

#include "sunka.h"
#include "tim.h"

class CThreadInputMgr;

class CEnumDocumentInputMgrs : public IEnumTfDocumentMgrs,
                               public CEnumUnknown,
                               public CComObjectRootImmx
{
public:
    CEnumDocumentInputMgrs()
    {
        Dbg_MemSetThisNameID(TEXT("CEnumDocumentInputMgrs"));
    }

    BEGIN_COM_MAP_IMMX(CEnumDocumentInputMgrs)
        COM_INTERFACE_ENTRY(IEnumTfDocumentMgrs)
    END_COM_MAP_IMMX()

    IMMX_OBJECT_IUNKNOWN_FOR_ATL()

    DECLARE_SUNKA_ENUM(IEnumTfDocumentMgrs, CEnumDocumentInputMgrs, ITfDocumentMgr)

    BOOL _Init(CThreadInputMgr *tim)
    {
        _iCur = 0;

        return (_prgUnk = SUA_Init(tim->_rgdim.Count(), (IUnknown **)tim->_rgdim.GetPtr(0))) != NULL;
    }

private:
    DBG_ID_DECLARE;
};


#endif // ENUMDIM_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\ctf\uim\emptyic.h ===
//
// emptyic.h
//

#ifndef EMPTYIC_H
#define EMPTYIC_H

#include "private.h"
#include "globals.h"
#include "compart.h"

class CDocumentInputManager;
class CEmptyInputContext;
CEmptyInputContext *EnsureEmptyContext();


//////////////////////////////////////////////////////////////////////////////
//
// CEmptyInputContext
//
//////////////////////////////////////////////////////////////////////////////

class CEmptyInputContext : public ITfContext,
                           public CCompartmentMgr,
                           public CComObjectRootImmx
{
public:
    CEmptyInputContext(CDocumentInputManager *dim);
    ~CEmptyInputContext();

    BEGIN_COM_MAP_IMMX(CEmptyInputContext)
        COM_INTERFACE_ENTRY(ITfContext)
        COM_INTERFACE_ENTRY(ITfCompartmentMgr)
    END_COM_MAP_IMMX()

    IMMX_OBJECT_IUNKNOWN_FOR_ATL()

    //
    // ITfContext
    //
    STDMETHODIMP RequestEditSession(TfClientId tid, ITfEditSession *pes, DWORD dwFlags, HRESULT *phrSession);
    STDMETHODIMP InWriteSession(TfClientId tid, BOOL *pfWriteSession);
    STDMETHODIMP GetSelection(TfEditCookie ec, ULONG ulIndex, ULONG ulCount, TF_SELECTION *pSelection, ULONG *pcFetched);
    STDMETHODIMP SetSelection(TfEditCookie ec, ULONG ulCount, const TF_SELECTION *pSelection);
    STDMETHODIMP GetStart(TfEditCookie ec, ITfRange **ppStart);
    STDMETHODIMP GetEnd(TfEditCookie ec, ITfRange **ppEnd);
    STDMETHODIMP GetStatus(TS_STATUS *pdcs);
    STDMETHODIMP GetActiveView(ITfContextView **ppView);
    STDMETHODIMP EnumViews(IEnumTfContextViews **ppEnum);
    STDMETHODIMP GetProperty(REFGUID guidProp, ITfProperty **ppv);

    STDMETHODIMP GetAppProperty(REFGUID guidProp, ITfReadOnlyProperty **ppProp);
    STDMETHODIMP TrackProperties(const GUID **pguidProp, ULONG cProp, const GUID **pguidAppProp, ULONG cAppProp, ITfReadOnlyProperty **ppPropX);

    STDMETHODIMP EnumProperties(IEnumTfProperties **ppEnum);
    STDMETHODIMP GetDocumentMgr(ITfDocumentMgr **ppDoc);
    STDMETHODIMP CreateRangeBackup(TfEditCookie ec, ITfRange *pRange, ITfRangeBackup **ppBackup);

    HRESULT Init();

private:
    CDocumentInputManager *_dim;

    DBG_ID_DECLARE;
};


#endif // EMPTYIC_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\ctf\uim\emptyic.cpp ===
//
// emptyic.cpp
//

#include "private.h"
#include "emptyic.h"
#include "globals.h"
#include "compart.h"
#include "dim.h"

DBG_ID_INSTANCE(CEmptyInputContext);


//+---------------------------------------------------------------------------
//
// ctor
//
//----------------------------------------------------------------------------

CEmptyInputContext::CEmptyInputContext(CDocumentInputManager *dim)
                      : CCompartmentMgr(TF_INVALID_GUIDATOM, COMPTYPE_IC)
{
    Dbg_MemSetThisNameIDCounter(TEXT("CEmptyInputContext"), PERF_CONTEXT_COUNTER);

    _dim = dim;
}

//+---------------------------------------------------------------------------
//
// dtor
//
//----------------------------------------------------------------------------

CEmptyInputContext::~CEmptyInputContext()
{
}

//+---------------------------------------------------------------------------
//
// Init
//
//----------------------------------------------------------------------------

HRESULT CEmptyInputContext::Init()
{
    HRESULT hr = MySetCompartmentDWORD(TF_INVALID_GUIDATOM, this, GUID_COMPARTMENT_EMPTYCONTEXT, 1);
    return hr;
}

//+---------------------------------------------------------------------------
//
// GetDocumentMgr
//
//----------------------------------------------------------------------------

STDAPI CEmptyInputContext::RequestEditSession(TfClientId tid, ITfEditSession *pes, DWORD dwFlags, HRESULT *phrSession)
{
    if (phrSession)
        *phrSession = TF_E_EMPTYCONTEXT;

    return TF_E_EMPTYCONTEXT;
}

//+---------------------------------------------------------------------------
//
// GetDocumentMgr
//
//----------------------------------------------------------------------------

STDAPI CEmptyInputContext::InWriteSession(TfClientId tid, BOOL *pfWriteSession)
{
    if (pfWriteSession)
        *pfWriteSession = FALSE;

    return TF_E_EMPTYCONTEXT;
}

//+---------------------------------------------------------------------------
//
// GetDocumentMgr
//
//----------------------------------------------------------------------------

STDAPI CEmptyInputContext::GetSelection(TfEditCookie ec, ULONG ulIndex, ULONG ulCount, TF_SELECTION *pSelection, ULONG *pcFetched)
{
    if (pSelection)
        memset(pSelection, 0, sizeof(TF_SELECTION));

    if (pcFetched)
        *pcFetched = 0;

    return TF_E_EMPTYCONTEXT;
}

//+---------------------------------------------------------------------------
//
// GetDocumentMgr
//
//----------------------------------------------------------------------------

STDAPI CEmptyInputContext::SetSelection(TfEditCookie ec, ULONG ulCount, const TF_SELECTION *pSelection)
{
    return TF_E_EMPTYCONTEXT;
}

//+---------------------------------------------------------------------------
//
// GetDocumentMgr
//
//----------------------------------------------------------------------------

STDAPI CEmptyInputContext::GetStart(TfEditCookie ec, ITfRange **ppStart)
{
    if (ppStart)
        *ppStart = NULL;
    return TF_E_EMPTYCONTEXT;
}

//+---------------------------------------------------------------------------
//
// GetDocumentMgr
//
//----------------------------------------------------------------------------

STDAPI CEmptyInputContext::GetEnd(TfEditCookie ec, ITfRange **ppEnd)
{
    if (ppEnd)
        *ppEnd = NULL;
    return TF_E_EMPTYCONTEXT;
}

//+---------------------------------------------------------------------------
//
// GetDocumentMgr
//
//----------------------------------------------------------------------------

STDAPI CEmptyInputContext::GetStatus(TS_STATUS *pdcs)
{
    if (pdcs)
        memset(pdcs, 0, sizeof(TS_STATUS));

    return TF_E_EMPTYCONTEXT;
}

//+---------------------------------------------------------------------------
//
// GetDocumentMgr
//
//----------------------------------------------------------------------------

STDAPI CEmptyInputContext::GetActiveView(ITfContextView **ppView)
{
    if (ppView)
        *ppView = NULL;
    return TF_E_EMPTYCONTEXT;
}

//+---------------------------------------------------------------------------
//
// GetDocumentMgr
//
//----------------------------------------------------------------------------

STDAPI CEmptyInputContext::EnumViews(IEnumTfContextViews **ppEnum)
{
    if (ppEnum)
        *ppEnum = NULL;
    return TF_E_EMPTYCONTEXT;
}

//+---------------------------------------------------------------------------
//
// GetDocumentMgr
//
//----------------------------------------------------------------------------

STDAPI CEmptyInputContext::GetProperty(REFGUID guidProp, ITfProperty **ppv)
{
    if (ppv)
        *ppv = NULL;
    return TF_E_EMPTYCONTEXT;
}

//+---------------------------------------------------------------------------
//
// GetDocumentMgr
//
//----------------------------------------------------------------------------


STDAPI CEmptyInputContext::GetAppProperty(REFGUID guidProp, ITfReadOnlyProperty **ppProp)
{
    if (ppProp)
        *ppProp = NULL;
    return TF_E_EMPTYCONTEXT;
}

//+---------------------------------------------------------------------------
//
// GetDocumentMgr
//
//----------------------------------------------------------------------------

STDAPI CEmptyInputContext::TrackProperties(const GUID **pguidProp, ULONG cProp, const GUID **pguidAppProp, ULONG cAppProp, ITfReadOnlyProperty **ppPropX)
{
    if (ppPropX)
        *ppPropX = NULL;

    return TF_E_EMPTYCONTEXT;
}

//+---------------------------------------------------------------------------
//
// GetDocumentMgr
//
//----------------------------------------------------------------------------


STDAPI CEmptyInputContext::EnumProperties(IEnumTfProperties **ppEnum)
{
    if (ppEnum)
        *ppEnum = NULL;

    return TF_E_EMPTYCONTEXT;
}

//+---------------------------------------------------------------------------
//
// GetDocumentMgr
//
//----------------------------------------------------------------------------

STDAPI CEmptyInputContext::GetDocumentMgr(ITfDocumentMgr **ppDm)
{
    if (ppDm == NULL)
        return E_INVALIDARG;

    *ppDm = _dim;
    if (*ppDm)
        (*ppDm)->AddRef();

    return S_OK;
}

//+---------------------------------------------------------------------------
//
// GetDocumentMgr
//
//----------------------------------------------------------------------------

STDAPI CEmptyInputContext::CreateRangeBackup(TfEditCookie ec, ITfRange *pRange, ITfRangeBackup **ppBackup)
{
    if (ppBackup)
        *ppBackup = NULL;

    return TF_E_EMPTYCONTEXT;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\ctf\uim\enumfnpr.cpp ===
//
// enumfnpr.cpp
//

#include "private.h"
#include "enumfnpr.h"
#include "tim.h"

DBG_ID_INSTANCE(CEnumFunctionProviders);

//+---------------------------------------------------------------------------
//
// _Init
//
//----------------------------------------------------------------------------

BOOL CEnumFunctionProviders::_Init(CThreadInputMgr *tim)
{
    ULONG uCount;
    ULONG i;
    const CTip *tip;

    uCount = 0;

    for (i=0; i<tim->_GetTIPCount(); i++)
    {
        if (tim->_GetCTip(i)->_pFuncProvider != NULL)
        {
            uCount++;
        }
    }

    if ((_prgUnk = SUA_Alloc(uCount)) == NULL)
        return FALSE;

    _iCur = 0;
    _prgUnk->cRef = 1;
    _prgUnk->cUnk = 0;

    for (i=0; i<tim->_GetTIPCount(); i++)
    {
        tip = tim->_GetCTip(i);

        if (tip->_pFuncProvider != NULL)
        {
            _prgUnk->rgUnk[_prgUnk->cUnk] = tip->_pFuncProvider;
            _prgUnk->rgUnk[_prgUnk->cUnk]->AddRef();
            _prgUnk->cUnk++;
        }
    }
    Assert(_prgUnk->cUnk == uCount);

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\ctf\uim\enumguid.cpp ===
//
// enumguid.cpp
//

#include "private.h"
#include "globals.h"
#include "enumguid.h"

DBG_ID_INSTANCE(CEnumGuid);

//////////////////////////////////////////////////////////////////////////////
//
// CEnumGuid
//
//////////////////////////////////////////////////////////////////////////////

//+---------------------------------------------------------------------------
//
// ctor
//
//----------------------------------------------------------------------------

CEnumGuid::CEnumGuid()
{
    Dbg_MemSetThisNameID(TEXT("CEnumGuid"));
    Assert(_nCur == 0);
    Assert(_pga == 0);
}

//+---------------------------------------------------------------------------
//
// dtor
//
//----------------------------------------------------------------------------

CEnumGuid::~CEnumGuid()
{
    CicEnterCriticalSection(g_cs);
    SGA_Release(_pga);
    CicLeaveCriticalSection(g_cs);
}

//+---------------------------------------------------------------------------
//
// Clone
//
//----------------------------------------------------------------------------

STDAPI CEnumGuid::Clone(IEnumGUID **ppClone)
{
    CEnumGuid *pClone;
    HRESULT hr = E_FAIL;

    if (ppClone == NULL)
        return E_INVALIDARG;

    CicEnterCriticalSection(g_cs);

    *ppClone = NULL;

    if ((pClone = new CEnumGuid) == NULL)
    {
        hr = E_OUTOFMEMORY;
        goto Exit;
    }

    pClone->_nCur = _nCur;
    pClone->_pga = _pga;
    SGA_AddRef(pClone->_pga);

    *ppClone = pClone;

    CicLeaveCriticalSection(g_cs);
    hr = S_OK;

Exit:
    return S_OK;
}

//+---------------------------------------------------------------------------
//
// Next
//
//----------------------------------------------------------------------------

STDAPI CEnumGuid::Next(ULONG ulCount, GUID *pguid, ULONG *pcFetched)
{
    ULONG cFetched = 0;

    Assert(pguid);

    CicEnterCriticalSection(g_cs);

    while (cFetched < ulCount)
    {
        if ((ULONG)_nCur >= _pga->cGuid)
            break;

        *pguid = _pga->rgGuid[_nCur];

        _nCur++;
        pguid++;
        cFetched++;
    }

    CicLeaveCriticalSection(g_cs);

    if (pcFetched)
        *pcFetched = cFetched;

    return (cFetched == ulCount) ? S_OK : S_FALSE;
}

//+---------------------------------------------------------------------------
//
// Reset
//
//----------------------------------------------------------------------------

STDAPI CEnumGuid::Reset()
{
    _nCur = 0;
    return S_OK;
}

//+---------------------------------------------------------------------------
//
// Skip
//
//----------------------------------------------------------------------------

STDAPI CEnumGuid::Skip(ULONG ulCount)
{
    HRESULT hr = S_OK;

    _nCur += ulCount;

    CicEnterCriticalSection(g_cs);

    if ((ULONG)_nCur >= _pga->cGuid)
    {
        _nCur = _pga->cGuid; // prevent overflow for repeated calls
        hr =  S_FALSE;
    }

    CicLeaveCriticalSection(g_cs);

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\ctf\uim\enumguid.h ===
//
// enumguid.h
//

#ifndef ENUMGUID_H
#define ENUMGUID_H

#include "private.h"
#include "comcat.h"

// I would love to make this a class,
// but I can't get the compiler to accept a run-time template arg
typedef struct _SHARED_GUID_ARRAY
{
    ULONG cRef;
    ULONG cGuid;
    GUID rgGuid[1]; // one or more...
} SHARED_GUID_ARRAY;

inline void SGA_AddRef(SHARED_GUID_ARRAY *pga)
{
    pga->cRef++;
}

inline void SGA_Release(SHARED_GUID_ARRAY *pga)
{
    if (pga == NULL)
        return;

    Assert(pga->cRef > 0);
    if (--pga->cRef == 0)
    {
        cicMemFree(pga);
    }
}

inline SHARED_GUID_ARRAY *SGA_Alloc(ULONG cGuid)
{
    return (SHARED_GUID_ARRAY *)cicMemAlloc(sizeof(SHARED_GUID_ARRAY)+sizeof(GUID)*cGuid-sizeof(GUID));
}

inline BOOL SGA_ReAlloc(SHARED_GUID_ARRAY **ppga, ULONG cGuid)
{
    SHARED_GUID_ARRAY *pga;

    pga = (SHARED_GUID_ARRAY *)cicMemReAlloc(*ppga, sizeof(SHARED_GUID_ARRAY)+sizeof(GUID)*cGuid-sizeof(GUID));
    
    if (pga != NULL)
    {
        *ppga = pga;
        return TRUE;
    }

    return FALSE;
}

inline SHARED_GUID_ARRAY *SGA_Init(ULONG cGuid, const GUID *prgGuid)
{
    SHARED_GUID_ARRAY *pga;

    pga = SGA_Alloc(cGuid);

    if (pga == NULL)
        return NULL;

    pga->cRef = 1;
    pga->cGuid = cGuid;

    if (prgGuid != NULL)
    {
        memcpy(pga->rgGuid, prgGuid, cGuid*sizeof(GUID));
    }

    return pga;
}

class CEnumGuid : public IEnumGUID,
                  public CComObjectRootImmx
{
public:
    CEnumGuid();
    virtual ~CEnumGuid();

    BEGIN_COM_MAP_IMMX(CEnumGuid)
        COM_INTERFACE_ENTRY(IEnumGUID)
    END_COM_MAP_IMMX()

    IMMX_OBJECT_IUNKNOWN_FOR_ATL()

    // derived class supplies an _Init() method here
    // It must initialize:
    //      _nCur
    //      _pga
    //
    // the default dtor will clean these guys up.

    virtual BOOL _Init(ULONG cGuid, const GUID *prgGuid)
    {
        _pga = SGA_Init(cGuid, prgGuid);

        return (_pga != NULL);
    }

    STDMETHODIMP Clone(IEnumGUID **pClone);
    STDMETHODIMP Next(ULONG ulCount, GUID *pguid, ULONG *pcFetched);
    STDMETHODIMP Reset();
    STDMETHODIMP Skip(ULONG ulCount);

protected:
    int _nCur;
    SHARED_GUID_ARRAY *_pga;

    DBG_ID_DECLARE;
};

#endif // ENUMGUID_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\ctf\uim\enumfnpr.h ===
//
// enumfnpr.h
//

#ifndef ENUMFNPR_H
#define ENUMFNPR_H

#include "ptrary.h"
#include "sunka.h"

class CThreadInputMgr;

class CEnumFunctionProviders : public IEnumTfFunctionProviders,
                               public CEnumUnknown,
                               public CComObjectRootImmx
{
public:
    CEnumFunctionProviders()
    {
        Dbg_MemSetThisNameID(TEXT("CEnumFunctionProviders"));
    }

    BEGIN_COM_MAP_IMMX(CEnumFunctionProviders)
        COM_INTERFACE_ENTRY(IEnumTfFunctionProviders)
    END_COM_MAP_IMMX()

    IMMX_OBJECT_IUNKNOWN_FOR_ATL()

    DECLARE_SUNKA_ENUM(IEnumTfFunctionProviders, CEnumFunctionProviders, ITfFunctionProvider)

    BOOL _Init(CThreadInputMgr *tim);

private:
    DBG_ID_DECLARE;
};


#endif // ENUMFNPR_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\ctf\uim\enumic.cpp ===
//
// enumdim.cpp
//

#include "private.h"
#include "enumic.h"
#include "dim.h"
#include "ic.h"

DBG_ID_INSTANCE(CEnumInputContexts);

//+---------------------------------------------------------------------------
//
// ctor
//
//----------------------------------------------------------------------------

CEnumInputContexts::CEnumInputContexts()
{
    Dbg_MemSetThisNameID(TEXT("CEnumInputContexts"));

    Assert(_rgContexts[0] == NULL);
    Assert(_rgContexts[1] == NULL);
}
 

//+---------------------------------------------------------------------------
//
// dtor
//
//----------------------------------------------------------------------------

CEnumInputContexts::~CEnumInputContexts()
{
    SafeRelease(_rgContexts[0]);
    SafeRelease(_rgContexts[1]);
}

//+---------------------------------------------------------------------------
//
// _Init
//
//----------------------------------------------------------------------------

BOOL CEnumInputContexts::_Init(CDocumentInputManager *pdim)
{
    int i;

    Assert(_iCur == 0);
    _iCount = pdim->_GetCurrentStack() + 1;

    for (i=0; i<_iCount; i++)
    {
        _rgContexts[i] = pdim->_GetIC(i);

        if (_rgContexts[i] == NULL)
            goto ExitError;

        _rgContexts[i]->AddRef();
    }

    return TRUE;

ExitError:
    SafeRelease(_rgContexts[0]);
    Assert(_rgContexts[1] == NULL);
    return FALSE;
}
 
//+---------------------------------------------------------------------------
//
// Next
//
//----------------------------------------------------------------------------

STDAPI CEnumInputContexts::Next(ULONG ulCount, ITfContext **ppic, ULONG *pcFetched)
{
    ULONG cFetched = 0;

    if (pcFetched != NULL)
    {
        *pcFetched = 0;
    }

    if (ppic == NULL && ulCount > 0)
        return E_INVALIDARG;
    
    while (cFetched < ulCount)
    {
        if (_iCur >= _iCount)
            break;

        *ppic = _rgContexts[_iCur];
        (*ppic)->AddRef();

        ppic++;
        _iCur++;
        cFetched++;
    }

    if (pcFetched != NULL)
    {
        *pcFetched = cFetched;
    }

    return (cFetched == ulCount) ? S_OK : S_FALSE;
}

//+---------------------------------------------------------------------------
//
// Clone
//
//----------------------------------------------------------------------------

STDAPI CEnumInputContexts::Clone(IEnumTfContexts **ppEnum)
{
    CEnumInputContexts *ec;
    int i;

    ec = new CEnumInputContexts;

    if (ec == NULL)
        return E_OUTOFMEMORY;

    ec->_iCur = _iCur;
    ec->_iCount = _iCount;

    for (i=0; i<_iCount; i++)
    {
        ec->_rgContexts[i] = _rgContexts[i];
        ec->_rgContexts[i]->AddRef();
    }

    *ppEnum = ec;

    return S_OK;
}

//+---------------------------------------------------------------------------
//
// Reset
//
//----------------------------------------------------------------------------

STDAPI CEnumInputContexts::Reset()
{
    _iCur = 0;
    return S_OK;
}

//+---------------------------------------------------------------------------
//
// Skip
//
//----------------------------------------------------------------------------

STDAPI CEnumInputContexts::Skip(ULONG ulCount)
{    
    // protect against overflow
    if (_iCur >= 2)
        return S_FALSE;
    ulCount = min(ulCount, 2);

    _iCur += ulCount;

    return (_iCur <= _iCount) ? S_OK : S_FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\ctf\uim\enumic.h ===
//
// enumic.h
//

#ifndef ENUMIC_H
#define ENUMIC_H


class CDocumentInputManager;

class CEnumInputContexts : public IEnumTfContexts,
                           public CComObjectRootImmx
{
public:
    CEnumInputContexts();
    ~CEnumInputContexts();

    BOOL _Init(CDocumentInputManager *pdim);

    BEGIN_COM_MAP_IMMX(CEnumInputContexts)
        COM_INTERFACE_ENTRY(IEnumTfContexts)
    END_COM_MAP_IMMX()

    IMMX_OBJECT_IUNKNOWN_FOR_ATL()

    //
    // IEnumTfContexts
    //
    STDMETHODIMP Clone(IEnumTfContexts **ppEnum);
    STDMETHODIMP Next(ULONG ulCount, ITfContext **ppic, ULONG *pcFetch);
    STDMETHODIMP Reset();
    STDMETHODIMP Skip(ULONG ulCount);

private:
    ITfContext *_rgContexts[2];
    int _iCur;
    int _iCount;

    DBG_ID_DECLARE;
};


#endif // ENUMIC_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\ctf\uim\enumprop.h ===
//
// enumprop.h
//

#ifndef ENUMPROP_H
#define ENUMPROP_H

#include "erfa.h"

class CEnumPropertyRanges : public CEnumRangesFromAnchorsBase
{
public:
    CEnumPropertyRanges()
    { 
        Dbg_MemSetThisNameIDCounter(TEXT("CEnumPropertyRanges"), PERF_ENUMPROPRANGE_COUNTER);
    }

    BOOL _Init(CInputContext *pic, IAnchor *paStart, IAnchor *paEnd, CProperty *pProperty);

private:
    DBG_ID_DECLARE;
};

#endif // ENUMPROP_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\ctf\uim\enumss.h ===
//
// enumss.h
//
// CEnumSpanSetRanges
//

#ifndef ENUMSS_H
#define ENUMSS_H

#include "private.h"
#include "spans.h"
#include "ic.h"

class CEnumSpanSetRanges : private CSpanSet,
                           public IEnumTfRanges,
                           public CComObjectRootImmx
{
public:
    CEnumSpanSetRanges(CInputContext *pic);
    ~CEnumSpanSetRanges();

    BEGIN_COM_MAP_IMMX(CEnumSpanSetRanges)
        COM_INTERFACE_ENTRY(IEnumTfRanges)
    END_COM_MAP_IMMX()

    IMMX_OBJECT_IUNKNOWN_FOR_ATL()

    // IEnumTfRanges
    STDMETHODIMP Clone(IEnumTfRanges **ppEnum);
    STDMETHODIMP Next(ULONG ulCount, ITfRange **ppRange, ULONG *pcFetched);
    STDMETHODIMP Reset();
    STDMETHODIMP Skip(ULONG ulCount);

    void _Merge(CSpanSet *pss);

private:
    CInputContext *_pic;
    int _iCur;

    DBG_ID_DECLARE;
};

#endif // ENUMSS_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\ctf\uim\epval.cpp ===
//
// epval.cpp
//
// CEnumPropertyValue
//

#include "private.h"
#include "epval.h"

DBG_ID_INSTANCE(CEnumPropertyValue);

//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////
//
// SHARED_TFPROPERTYVAL_ARRAY
//
//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////

//+---------------------------------------------------------------------------
//
// SAA_New
//
//----------------------------------------------------------------------------

SHARED_TFPROPERTYVAL_ARRAY *SAA_New(ULONG cAttrVals)
{
    SHARED_TFPROPERTYVAL_ARRAY *paa;

    paa = (SHARED_TFPROPERTYVAL_ARRAY *)cicMemAlloc(sizeof(SHARED_TFPROPERTYVAL_ARRAY)+sizeof(TF_PROPERTYVAL)*cAttrVals-sizeof(TF_PROPERTYVAL));

    if (paa != NULL)
    {
        paa->cRef = 1;
        paa->cAttrVals = cAttrVals;
        // clear out the attrs so VariantClear is safe
        memset(paa->rgAttrVals, 0, cAttrVals*sizeof(TF_PROPERTYVAL));
    }

    return paa;
}

//+---------------------------------------------------------------------------
//
// SAA_Release
//
//----------------------------------------------------------------------------

void SAA_Release(SHARED_TFPROPERTYVAL_ARRAY *paa)
{
    ULONG i;

    Assert(paa->cRef > 0);
    if (--paa->cRef == 0)
    {
        for (i=0; i<paa->cAttrVals; i++)
        {
            VariantClear(&paa->rgAttrVals[i].varValue);
        }
        cicMemFree(paa);
    }
}

//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////
//
// CEnumPropertyValue
//
//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////

//+---------------------------------------------------------------------------
//
// Clone
//
//----------------------------------------------------------------------------

STDAPI CEnumPropertyValue::Clone(IEnumTfPropertyValue **ppEnum)
{
    CEnumPropertyValue *pClone;

    if (ppEnum == NULL)
        return E_INVALIDARG;

    *ppEnum = NULL;

    if ((pClone = new CEnumPropertyValue) == NULL)
        return E_OUTOFMEMORY;

    pClone->_ulCur = _ulCur;

    pClone->_paa = _paa;
    SAA_AddRef(pClone->_paa);

    *ppEnum = pClone;
    return S_OK;
}

//+---------------------------------------------------------------------------
//
// Next
//
//----------------------------------------------------------------------------

STDAPI CEnumPropertyValue::Next(ULONG ulCount, TF_PROPERTYVAL *prgValues, ULONG *pcFetched)
{
    ULONG cFetched;
    ULONG ulCurOld;
    ULONG ulSize;

    if (pcFetched == NULL)
    {
        pcFetched = &cFetched;
    }
    *pcFetched = 0;
    ulCurOld = _ulCur;

    if (ulCount > 0 && prgValues == NULL)
        return E_INVALIDARG;

    ulSize = _paa->cAttrVals;

    while (_ulCur < ulSize && *pcFetched < ulCount)
    {
        QuickVariantInit(&prgValues->varValue);

        prgValues->guidId = _paa->rgAttrVals[_ulCur].guidId;

        if (VariantCopy(&prgValues->varValue, &_paa->rgAttrVals[_ulCur].varValue) != S_OK)
            goto ErrorExit;

        prgValues++;
        *pcFetched = *pcFetched + 1;
        _ulCur++;
    }

    return *pcFetched == ulCount ? S_OK : S_FALSE;

ErrorExit:
    while (--_ulCur > ulCurOld)
    {
        prgValues--;
        VariantClear(&prgValues->varValue);
    }
    return E_OUTOFMEMORY;
}

//+---------------------------------------------------------------------------
//
// Reset
//
//----------------------------------------------------------------------------

STDAPI CEnumPropertyValue::Reset()
{
    _ulCur = 0;
    return S_OK;
}

//+---------------------------------------------------------------------------
//
// Skip
//
//----------------------------------------------------------------------------

STDAPI CEnumPropertyValue::Skip(ULONG ulCount)
{
    _ulCur += ulCount;
    
    return (_ulCur < _paa->cAttrVals) ? S_OK : S_FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\ctf\uim\enumprop.cpp ===
//
// enumprop.cpp
//

#include "private.h"
#include "ic.h"
#include "enumprop.h"
#include "range.h"
#include "attr.h"
#include "saa.h"

DBG_ID_INSTANCE(CEnumPropertyRanges);

//+---------------------------------------------------------------------------
//
// _Init
//
//----------------------------------------------------------------------------

BOOL CEnumPropertyRanges::_Init(CInputContext *pic, IAnchor *paStart, IAnchor *paEnd, CProperty *pProperty)
{
    TfGuidAtom atom;
    LONG cSpans;    

    Assert(_iCur == 0);
    Assert(_pic == NULL);
    Assert(_prgAnchors == NULL);

    cSpans = pProperty->GetPropNum();

    if (cSpans == 0)
    {
        // special case the no spans case since paStart, paEnd may be NULL
        _prgAnchors = new CSharedAnchorArray;
    }
    else
    {
        // property has one or more spans

        if (paStart == NULL)
        {
            Assert(paEnd == NULL);
            // CalcCicPropertyTrackerAnchors won't accept NULL, get that here
            // NULL means enum all spans
            paStart = pProperty->QuickGetPropList(0)->_paStart;
            paEnd = pProperty->QuickGetPropList(cSpans-1)->_paEnd;
        }

        atom = pProperty->GetPropGuidAtom();

        _prgAnchors = CalcCicPropertyTrackerAnchors(pic, paStart, paEnd, 1, &atom);
    }

    if (_prgAnchors == NULL)
        return FALSE; // out of memory

    _pic = pic;
    _pic->AddRef();

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\ctf\uim\epval.h ===
//
// epval.h
//
// CEnumPropertyValBase
//

#ifndef EPVAL_H
#define EPVAL_H

//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////
//
// SHARED_TFPROPERTYVAL_ARRAY
//
// I would love to make this a class,
// but I can't get the compiler to accept a run-time template arg
//
//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////

typedef struct _SHARED_TFPROPERTYVAL_ARRAY
{
    ULONG cRef;
    ULONG cAttrVals;
    TF_PROPERTYVAL rgAttrVals[1]; // 1 or more...
} SHARED_TFPROPERTYVAL_ARRAY;

SHARED_TFPROPERTYVAL_ARRAY *SAA_New(ULONG cAttrVals);

inline void SAA_AddRef(SHARED_TFPROPERTYVAL_ARRAY *paa)
{
    paa->cRef++;
}

void SAA_Release(SHARED_TFPROPERTYVAL_ARRAY *paa);

//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////
//
// CEnumPropertyValue
//
//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////

class CEnumPropertyValue : public IEnumTfPropertyValue,
                           public CComObjectRootImmx
{
public:
    CEnumPropertyValue(SHARED_TFPROPERTYVAL_ARRAY *paa) 
    {
        Dbg_MemSetThisNameID(TEXT("CEnumPropertyValue"));
        Assert(_ulCur == 0);
        _paa = paa;
        SAA_AddRef(paa);
    }
    ~CEnumPropertyValue()
    { 
        if (_paa != NULL)
        {
            SAA_Release(_paa);
        }
    }

    BEGIN_COM_MAP_IMMX(CEnumPropertyValue)
        COM_INTERFACE_ENTRY(IEnumTfPropertyValue)
    END_COM_MAP_IMMX()

    IMMX_OBJECT_IUNKNOWN_FOR_ATL()

    // IEnumTfAppPropertyValue
    STDMETHODIMP Clone(IEnumTfPropertyValue **ppEnum);
    STDMETHODIMP Next(ULONG ulCount, TF_PROPERTYVAL *rgValues, ULONG *pcFetched);
    STDMETHODIMP Reset();
    STDMETHODIMP Skip(ULONG ulCount);

private:
    CEnumPropertyValue() { Dbg_MemSetThisNameID(TEXT("CEnumPropertyValue")); }

    ULONG _ulCur;
    SHARED_TFPROPERTYVAL_ARRAY *_paa;
    DBG_ID_DECLARE;
};

#endif // EPVAL_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\ctf\uim\enumss.cpp ===
//
// enumss.cpp
//
// CEnumSpanSetRanges
//

#include "private.h"
#include "enumss.h"
#include "range.h"

DBG_ID_INSTANCE(CEnumSpanSetRanges);

//+---------------------------------------------------------------------------
//
// ctor
//
//----------------------------------------------------------------------------

CEnumSpanSetRanges::CEnumSpanSetRanges(CInputContext *pic)
{
    Dbg_MemSetThisNameID(TEXT("CEnumSpanSetRanges"));
    
    _pic = pic;
    _pic->AddRef();
}

//+---------------------------------------------------------------------------
//
// dtor
//
//----------------------------------------------------------------------------

CEnumSpanSetRanges::~CEnumSpanSetRanges()
{
    _pic->Release();
}

//+---------------------------------------------------------------------------
//
// Clone
//
//----------------------------------------------------------------------------

STDAPI CEnumSpanSetRanges::Clone(IEnumTfRanges **ppEnum)
{
    CEnumSpanSetRanges *pClone;
    SPAN *pSpanSrc;
    SPAN *pSpanDst;
    int i;

    if (ppEnum == NULL)
        return E_INVALIDARG;

    *ppEnum = NULL;

    if ((pClone = new CEnumSpanSetRanges(_pic)) == NULL)
        return E_OUTOFMEMORY;

    pClone->_iCur = _iCur;

    i = 0;

    if (!pClone->_rgSpans.Insert(0, _rgSpans.Count()))
        goto ErrorExit;

    for (; i<_rgSpans.Count(); i++)
    {
        pSpanDst = pClone->_rgSpans.GetPtr(i);
        pSpanSrc = _rgSpans.GetPtr(i);

        pSpanDst->paStart = pSpanDst->paEnd = NULL;

        if (pSpanSrc->paStart->Clone(&pSpanDst->paStart)!= S_OK)
            goto ErrorExit;
        if (pSpanSrc->paEnd->Clone(&pSpanDst->paEnd) != S_OK)
            goto ErrorExit;
        pSpanDst->dwFlags = pSpanSrc->dwFlags;
    }

    *ppEnum = pClone;
    return S_OK;

ErrorExit:
    for (; i>=0; i--)
    {
        pSpanDst = pClone->_rgSpans.GetPtr(i);

        if (pSpanDst != NULL)
        {
            SafeRelease(pSpanDst->paStart);
            SafeRelease(pSpanDst->paEnd);
        }
    }
    pClone->Release();
    return E_OUTOFMEMORY;
}

//+---------------------------------------------------------------------------
//
// Next
//
//----------------------------------------------------------------------------

STDAPI CEnumSpanSetRanges::Next(ULONG ulCount, ITfRange **ppRange, ULONG *pcFetched)
{
    ULONG cFetched;
    CRange *range;
    SPAN *pSpan;
    int iCurOld;

    if (pcFetched == NULL)
    {
        pcFetched = &cFetched;
    }
    *pcFetched = 0;
    iCurOld = _iCur;

    if (ulCount > 0 && ppRange == NULL)
        return E_INVALIDARG;

    while (_iCur < _rgSpans.Count() && *pcFetched < ulCount)
    {
        pSpan = _rgSpans.GetPtr(_iCur);

        if ((range = new CRange) == NULL)
            goto ErrorExit;
        if (!range->_InitWithDefaultGravity(_pic, COPY_ANCHORS, pSpan->paStart, pSpan->paEnd))
        {
            range->Release();
            goto ErrorExit;
        }

        *ppRange++ = (ITfRangeAnchor *)range;
        *pcFetched = *pcFetched + 1;
        _iCur++;
    }

    return *pcFetched == ulCount ? S_OK : S_FALSE;

ErrorExit:
    while (--_iCur > iCurOld)
    {
        (*--ppRange)->Release();
    }
    return E_OUTOFMEMORY;
}

//+---------------------------------------------------------------------------
//
// Reset
//
//----------------------------------------------------------------------------

STDAPI CEnumSpanSetRanges::Reset()
{
    _iCur = 0;
    return S_OK;
}

//+---------------------------------------------------------------------------
//
// Skip
//
//----------------------------------------------------------------------------

STDAPI CEnumSpanSetRanges::Skip(ULONG ulCount)
{
    _iCur += ulCount;
    
    return (_iCur > _rgSpans.Count()) ? S_FALSE : S_OK;
}

//+---------------------------------------------------------------------------
//
// _Merge
//
//----------------------------------------------------------------------------

void CEnumSpanSetRanges::_Merge(CSpanSet *pss)
{
    int i;
    SPAN *rgSpans;

    //
    // perf: this method could be much more efficient -> O(n log n) -> O(n)
    // we could take advantage of the fact that we are always
    // adding new spans _that are already ordered_.
    //

    // get rid of any NULL/NULL spans -> covers entire doc
    //
    // perf: wait to normalize until all _Merge calls are done!
    //
    if (!pss->Normalize(_pic->_GetTSI()))
    {
        Assert(0); // doh!
        return;
    }

    rgSpans = pss->GetSpans();

    for (i=0; i<pss->GetCount();i++)
    {
        Add(0, rgSpans[i].paStart, rgSpans[i].paEnd, COPY_ANCHORS);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\ctf\uim\erfa.cpp ===
//
// erfa.cpp
//
// CEnumRangesFromAnchorsBase
//
// Base class for range enumerators.
//

#include "private.h"
#include "erfa.h"
#include "saa.h"
#include "ic.h"
#include "range.h"
#include "immxutil.h"

//+---------------------------------------------------------------------------
//
// dtor
//
//----------------------------------------------------------------------------

CEnumRangesFromAnchorsBase::~CEnumRangesFromAnchorsBase()
{
    SafeRelease(_pic);

    if (_prgAnchors != NULL)
    {
        _prgAnchors->_Release();
    }
}

//+---------------------------------------------------------------------------
//
// Clone
//
//----------------------------------------------------------------------------

STDAPI CEnumRangesFromAnchorsBase::Clone(IEnumTfRanges **ppEnum)
{
    CEnumRangesFromAnchorsBase *pClone;

    if (ppEnum == NULL)
        return E_INVALIDARG;

    *ppEnum = NULL;

    if ((pClone = new CEnumRangesFromAnchorsBase) == NULL)
        return E_OUTOFMEMORY;

    pClone->_iCur = _iCur;

    pClone->_prgAnchors = _prgAnchors;
    pClone->_prgAnchors->_AddRef();

    pClone->_pic = _pic;
    pClone->_pic->AddRef();

    *ppEnum = pClone;
    return S_OK;
}

//+---------------------------------------------------------------------------
//
// Next
//
//----------------------------------------------------------------------------

STDAPI CEnumRangesFromAnchorsBase::Next(ULONG ulCount, ITfRange **ppRange, ULONG *pcFetched)
{
    ULONG cFetched;
    CRange *range;
    IAnchor *paPrev;
    IAnchor *pa;
    int iCurOld;

    if (pcFetched == NULL)
    {
        pcFetched = &cFetched;
    }
    *pcFetched = 0;
    iCurOld = _iCur;

    if (ulCount > 0 && ppRange == NULL)
        return E_INVALIDARG;

    // special case empty enum, or 1 anchor enum
    if (_prgAnchors->Count() < 2)
    {
        if (_prgAnchors->Count() == 0 || _iCur > 0)
        {
            return S_FALSE;
        }
        // when we have a single anchor in the enum, need to handle it carefully
        if ((range = new CRange) == NULL)
            return E_OUTOFMEMORY;
        if (!range->_InitWithDefaultGravity(_pic, COPY_ANCHORS, _prgAnchors->Get(0), _prgAnchors->Get(0)))
        {
            range->Release();
            return E_FAIL;
        }

        *ppRange = (ITfRangeAnchor *)range;
        *pcFetched = 1;
        _iCur = 1;
        goto Exit;
    }

    paPrev = _prgAnchors->Get(_iCur);

    while (_iCur < _prgAnchors->Count()-1 && *pcFetched < ulCount)
    {
        pa = _prgAnchors->Get(_iCur+1);

        if ((range = new CRange) == NULL)
            goto ErrorExit;
        if (!range->_InitWithDefaultGravity(_pic, COPY_ANCHORS, paPrev, pa))
        {
            range->Release();
            goto ErrorExit;
        }

        // we should never be returning empty ranges, since currently this base
        // class is only used for property enums and property spans are never
        // empty.
        // Similarly, paPrev should always precede pa.
        Assert(CompareAnchors(paPrev, pa) < 0);

        *ppRange++ = (ITfRangeAnchor *)range;
        *pcFetched = *pcFetched + 1;
        _iCur++;
        paPrev = pa;
    }

Exit:
    return *pcFetched == ulCount ? S_OK : S_FALSE;

ErrorExit:
    while (--_iCur > iCurOld) // Issue: just return what we have, rather than freeing everything
    {
        (*--ppRange)->Release();
    }
    return E_OUTOFMEMORY;
}

//+---------------------------------------------------------------------------
//
// Reset
//
//----------------------------------------------------------------------------

STDAPI CEnumRangesFromAnchorsBase::Reset()
{
    _iCur = 0;
    return S_OK;
}

//+---------------------------------------------------------------------------
//
// Skip
//
//----------------------------------------------------------------------------

STDAPI CEnumRangesFromAnchorsBase::Skip(ULONG ulCount)
{
    _iCur += ulCount;
    
    return (_iCur > _prgAnchors->Count()-1) ? S_FALSE : S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\ctf\uim\erfa.h ===
//
// erfa.h
//
// CEnumRangesFromAnchorsBase
//
// Base class for range enumerators.
//

#ifndef ERFA_H
#define ERFA_H

class CInputContext;
class CSharedAnchorArray;

class __declspec(novtable) CEnumRangesFromAnchorsBase : public IEnumTfRanges,
                                                        public CComObjectRootImmx
{
public:
    CEnumRangesFromAnchorsBase() {}
    virtual ~CEnumRangesFromAnchorsBase();

    BEGIN_COM_MAP_IMMX(CEnumRangesFromAnchorsBase)
        COM_INTERFACE_ENTRY(IEnumTfRanges)
    END_COM_MAP_IMMX()

    IMMX_OBJECT_IUNKNOWN_FOR_ATL()

    // derived class supplies an _Init() method here
    // It must initialize:
    //      _pic
    //      _iCur
    //      _prgAnchors
    //
    // the default dtor will clean these guys up.

    // IEnumTfRanges
    STDMETHODIMP Clone(IEnumTfRanges **ppEnum);
    STDMETHODIMP Next(ULONG ulCount, ITfRange **ppRange, ULONG *pcFetched);
    STDMETHODIMP Reset();
    STDMETHODIMP Skip(ULONG ulCount);

protected:
    CInputContext *_pic;
    int _iCur;
    CSharedAnchorArray *_prgAnchors;
};

#endif // ERFA_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\ctf\uim\fnrecon.h ===
//
// fnrecon.h
//

#ifndef FNRECON_H
#define FNRECON_H

#include "private.h"
#include "immlist.h"
#include "ctffunc.h"

class CFunctionProvider;
class CEditSession;
class CRange;
class CInputContext;

HRESULT GrowEmptyRangeByOneCallback(TfEditCookie ec, ITfRange *range);

class CFunction;

typedef struct tag_BUILDOWNERRANGELISTQUEUEINFO
{
    CFunction *pFunc;
    ITfRange *pRange; 
} BUILDOWNERRANGELISTQUEUEINFO;

//
// for PSEUDO_ESCB_SHIFTENDTORANGE
//
typedef struct tag_SHIFTENDTORANGEQUEUEITEM
{
    ITfRange *pRange;
    ITfRange *pRangeTo;
    TfAnchor aPos;
} SHIFTENDTORANGEQUEUEITEM;

//
// for PSEUDO_ESCB_GETSELECTION
//
typedef struct tag_GETSELECTIONQUEUEITEM
{
    ITfRange **ppRange;
} GETSELECTIONQUEUEITEM;

//
// for PSEUDO_ESCB_GETWHOLEDOCRANGE
//
typedef struct tag_GETWHOLEDOCRANGE
{
    ITfRange **ppRange;
} GETWHOLEDOCRANGE;

//////////////////////////////////////////////////////////////////////////////
//
// CRangeOwnerList
//
//////////////////////////////////////////////////////////////////////////////

class CRangeOwnerList : public CPtrCicListItem<CRangeOwnerList>
{
public:
     CRangeOwnerList(TfGuidAtom guidOwner, ITfRange *pRange, BOOL bDupOwner) 
     {
         _pRange = pRange;
         _pRange->AddRef();
         _guidOwner = guidOwner;
         _bDupOwner = bDupOwner;
     }

     ~CRangeOwnerList()
     {
         _pRange->Release();
         SafeRelease(_pConvRange);
     }

     ITfRange *_pRange;
     TfGuidAtom _guidOwner;
     BOOL _bDupOwner;
     ITfRange *_pConvRange;
};

//////////////////////////////////////////////////////////////////////////////
//
// CFunction
//
//////////////////////////////////////////////////////////////////////////////

class __declspec(novtable) CFunction : public CComObjectRootImmx
{
public:
    CFunction(CFunctionProvider *pFuncPrv);
    ~CFunction();

    HRESULT BuildOwnerRangeListCallback(TfEditCookie ec, CInputContext *pic, ITfRange *pRange);
protected:
    void CleanUpOwnerRange();
    BOOL BuildOwnerRangeList(CInputContext *pic, ITfRange *pRange);


    CFunctionProvider *_pFuncPrv;
    CPtrCicList<CRangeOwnerList> _listRangeOwner;
};

//////////////////////////////////////////////////////////////////////////////
//
// CFnReconversion
//
//////////////////////////////////////////////////////////////////////////////

class CFnReconversion : public ITfFnReconversion,
                        public CFunction
{
public:
    CFnReconversion(CFunctionProvider *pFuncPrv);
    ~CFnReconversion();

    BEGIN_COM_MAP_IMMX(CFnReconversion)
        COM_INTERFACE_ENTRY(ITfFnReconversion)
        COM_INTERFACE_ENTRY(ITfFunction)
    END_COM_MAP_IMMX()

    IMMX_OBJECT_IUNKNOWN_FOR_ATL()

    //
    // ITfFunction
    //
    STDMETHODIMP GetDisplayName(BSTR *pbstrCand);

    //
    // ITfFnReconversion
    //
    STDMETHODIMP GetReconversion(ITfRange *pRange, ITfCandidateList **ppCandList);
    STDMETHODIMP QueryRange(ITfRange *pRange, ITfRange **ppNewRange, BOOL *pfConvertable);
    STDMETHODIMP Reconvert(ITfRange *pRange);


private:
    typedef enum { RF_GETRECONVERSION,
                   RF_RECONVERT,
                   RF_QUERYRECONVERT } RECONVFUNC;
    HRESULT Internal_GetReconversion(ITfRange *pRange, ITfCandidateList **ppCandList, ITfRange **ppNewRange, RECONVFUNC rf, BOOL *pfConvertable);
    HRESULT QueryAndGetFunction(CInputContext *pic, ITfRange *pRange, ITfFnReconversion **ppFunc, ITfRange **ppRange);

    ITfFnReconversion *_pReconvCache;
};

//////////////////////////////////////////////////////////////////////////////
//
// CFnAbort
//
//////////////////////////////////////////////////////////////////////////////

class CFnAbort : public ITfFnAbort,
                 public CFunction
{
public:
    CFnAbort(CFunctionProvider *pFuncPrv);
    ~CFnAbort();

    BEGIN_COM_MAP_IMMX(CFnAbort)
        COM_INTERFACE_ENTRY(ITfFnAbort)
        COM_INTERFACE_ENTRY(ITfFunction)
    END_COM_MAP_IMMX()

    IMMX_OBJECT_IUNKNOWN_FOR_ATL()

    //
    // ITfFunction
    //
    STDMETHODIMP GetDisplayName(BSTR *pbstrCand);

    //
    // ITfFnAbort
    //
    STDMETHODIMP Abort(ITfContext *pic);
};

#endif // FNRECON_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\ctf\uim\focusnfy.cpp ===
//
// focusnfy.cpp
//
#include "private.h"
#include "globals.h"
#include "thdutil.h"
#include "cicmutex.h"
#include "tim.h"
#include "internat.h"
#include "marshal.h"
#include "catmgr.h"
#include "timlist.h"
#include "ithdmshl.h"
#include "marshal.h"
#include "shlapip.h"

const DWORD TF_LBESF_GLOBAL   = 0x0001;
const DWORD TF_LBSMI_FILTERCURRENTTHREAD = 0x0001;

LPVOID SharedAlloc(UINT cbSize,DWORD dwProcessId,HANDLE *pProcessHandle);
VOID SharedFree(LPVOID lpv,HANDLE hProcess);

CStructArray<LBAREVENTSINKLOCAL> *g_rglbes = NULL;
extern CCicMutex g_mutexLBES;

void CallFocusNotifySink(ITfLangBarEventSink *pSink, UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL fLocalSink, DWORD dwSinkCookie);


// --------------------------------------------------------------------------
//
//  FindLBES
//
// --------------------------------------------------------------------------
int FindLBES()
{
    int nId = -1;

    for (nId = 0; nId < MAX_LPES_NUM; nId++)
    {
        if (!(GetSharedMemory()->lbes[nId].m_dwFlags & LBESF_INUSE))
            break;

        if (!g_timlist.IsThreadId(GetSharedMemory()->lbes[nId].m_dwThreadId))
        {
            //
            // Bug#354475 - Explorer can call deskband(msutb.dll module)
            // directly before loading the ctfmon.exe process. In this case,
            // explorer tray window thread didn't recognized by g_timlist.
            // Since shared block memory didn't create yet. So checking the
            // tray window thread and keep up language bar event sink for
            // language deskband support.
            //
            // Bug#370802
            //  we can not cache the window handle because explorer could
            //  crash. And we don't have a window to track "TaskbarCreated"
            //  message. The shell message is boradcasted by SendNotifyMessage()
            //  with HWMD_BROADCASTR. So the marshal window can not get it.
            //
            HWND hwndTray;
            DWORD dwThreadIdTray = 0;

            hwndTray = FindWindow(TEXT(WNDCLASS_TRAYNOTIFY), NULL);

            if (hwndTray)
                dwThreadIdTray = GetWindowThreadProcessId(hwndTray, NULL);

            if (!dwThreadIdTray ||
                dwThreadIdTray != GetSharedMemory()->lbes[nId].m_dwThreadId)
                break;
        }
    }

    if (nId == MAX_LPES_NUM)
    {
        nId = -1;
    }

    return nId;
}


// --------------------------------------------------------------------------
//
//  IntrnalRegisterLangBarNotifySink
//
// --------------------------------------------------------------------------

HRESULT RegisterLangBarNotifySink(ITfLangBarEventSink *pSink, HWND hwnd, DWORD dwFlags, DWORD *pdwCookie)
{
    HRESULT hr = E_FAIL;
    int nId;

    //
    // Bugbug#376500 - When CPL runs ctfmon.exe with deskband status, ThreadId
    // list doesn't include ctfmon thread, so need to make sure thread id list.
    //
    SYSTHREAD *psfn = GetSYSTHREAD();
    if (psfn)
        EnsureTIMList(psfn);

    if (!(dwFlags & TF_LBESF_GLOBAL))
    {
        int nCnt;
        LBAREVENTSINKLOCAL *plbes;

        //
        // Local LangBarEventSink
        //
        CicEnterCriticalSection(g_csInDllMain);

        nCnt = g_rglbes->Count();
        if (g_rglbes->Insert(nCnt,1))
        {
            plbes = g_rglbes->GetPtr(nCnt);

            plbes->m_pSink = pSink;
            pSink->AddRef();

            plbes->lb.m_dwThreadId = GetCurrentThreadId();
            plbes->lb.m_dwProcessId = GetCurrentProcessId();
            plbes->lb.m_dwCookie = GetSharedMemory()->dwlbesCookie++;
            plbes->lb.m_dwLangBarFlags = dwFlags;
            *pdwCookie = plbes->lb.m_dwCookie;
            plbes->lb.m_hWnd = hwnd;
            plbes->lb.m_dwFlags = LBESF_INUSE;
            hr = S_OK;
        }

        CicLeaveCriticalSection(g_csInDllMain);
    }
    else 
    {
        if (psfn)
        {
            CCicMutexHelper mutexhlp(&g_mutexLBES);
            //
            // Global LangBarEventSink
            //
            if (mutexhlp.Enter())
            {
                if ((nId = FindLBES()) != -1)
                {
                    GetSharedMemory()->lbes[nId].m_dwThreadId = GetCurrentThreadId();
                    GetSharedMemory()->lbes[nId].m_dwProcessId = GetCurrentProcessId();
                    GetSharedMemory()->lbes[nId].m_dwCookie = GetSharedMemory()->dwlbesCookie++;
                    GetSharedMemory()->lbes[nId].m_dwLangBarFlags = dwFlags;
                    *pdwCookie = GetSharedMemory()->lbes[nId].m_dwCookie;
                    GetSharedMemory()->lbes[nId].m_hWnd = hwnd;
                    GetSharedMemory()->lbes[nId].m_dwFlags = LBESF_INUSE;

                    psfn->_pLangBarEventSink = pSink;
                    pSink->AddRef();
                    psfn->_dwLangBarEventCookie = *pdwCookie;

                    hr = S_OK;
                }
                mutexhlp.Leave();
            }
        }
    }

    return hr;
}

// --------------------------------------------------------------------------
//
//  UnregisterLangBarNotifySink
//
// --------------------------------------------------------------------------

HRESULT UnregisterLangBarNotifySink(DWORD dwCookie)
{
    DWORD dwThreadId = GetCurrentThreadId();
    DWORD dwProcessId = GetCurrentProcessId();
    HRESULT hr = E_FAIL;
    int nId;
    int nCnt;
    SYSTHREAD *psfn = GetSYSTHREAD();
    CCicMutexHelper mutexhlp(&g_mutexLBES);
    BOOL fUnregistereGlobalSink = FALSE;

    //
    // Local LangBarEventSink
    //
    CicEnterCriticalSection(g_csInDllMain);

    nCnt = g_rglbes->Count();
    for (nId = 0; nId < nCnt; nId++)
    {
        LBAREVENTSINKLOCAL *plbes;
        plbes = g_rglbes->GetPtr(nId);

        if ((plbes->lb.m_dwCookie == dwCookie) &&
            (plbes->lb.m_dwThreadId == dwThreadId) &&
            (plbes->lb.m_dwProcessId == dwProcessId))
        {
            //
            // if the process of msutb.dll is killed, pSink is bogus pointer. 
            // And this is expected in the unusuall case.
            //
            _try {
                plbes->m_pSink->Release();
            }
            _except(CicExceptionFilter(GetExceptionInformation())) {
                // Assert(0);
            }
            plbes->m_pSink = NULL;
            g_rglbes->Remove(nId, 1);
            hr = S_OK;
            goto ExitCrit;
        }
    }

ExitCrit:
    CicLeaveCriticalSection(g_csInDllMain);

    if (SUCCEEDED(hr))
        goto Exit;

    if (!psfn)
        goto Exit;

    //
    // Global LangBarEventSink
    //
    if (mutexhlp.Enter())
    {
        for (nId = 0; nId < MAX_LPES_NUM; nId++)
        {
            if ((GetSharedMemory()->lbes[nId].m_dwCookie == dwCookie) &&
                (GetSharedMemory()->lbes[nId].m_dwThreadId == dwThreadId) &&
                (GetSharedMemory()->lbes[nId].m_dwProcessId == dwProcessId) &&
                (GetSharedMemory()->lbes[nId].m_dwCookie == psfn->_dwLangBarEventCookie))
            {
                //
                // if the process of msutb.dll is killed, pSink is bogus pointer. 
                // And this is expected in the unusuall case.
                //
                _try {
                    psfn->_pLangBarEventSink->Release();
                }
                _except(CicExceptionFilter(GetExceptionInformation())) {
                    // Assert(0);
                }

                psfn->_pLangBarEventSink=NULL;
                psfn->_dwLangBarEventCookie=NULL;

                GetSharedMemory()->lbes[nId].m_dwCookie = 0;
                GetSharedMemory()->lbes[nId].m_dwThreadId = 0;
                GetSharedMemory()->lbes[nId].m_dwProcessId = 0;
                GetSharedMemory()->lbes[nId].m_dwFlags = 0;
                fUnregistereGlobalSink = TRUE;
                hr = S_OK;
                goto ExitMutex;
            }
        }
ExitMutex:
        mutexhlp.Leave();
    }

    //
    // clean up all amrshaling stubs.
    //
    if (fUnregistereGlobalSink)
        FreeMarshaledStubs(psfn);

Exit:
    return hr;
}

// -------------------------------------------------------------------------
//
//  TLFlagFromMsg
//
// -------------------------------------------------------------------------

DWORD TLFlagFromMsg(UINT uMsg)
{
    if (uMsg == g_msgSetFocus)
        return LBESF_SETFOCUSINQUEUE;

    return 0;
}

// --------------------------------------------------------------------------
//
//  MakeSetFocusNotify
//
// --------------------------------------------------------------------------

void MakeSetFocusNotify(UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    int nId;
    DWORD dwCurThreadId = GetCurrentThreadId();
    int nCnt;
    DWORD dwPostThread[MAX_LPES_NUM];
    CCicMutexHelper mutexhlp(&g_mutexLBES);
    DWORD dwMsgMaskFlag = TLFlagFromMsg(uMsg);

    if (uMsg == g_msgSetFocus)
    {
        SYSTHREAD *psfn = GetSYSTHREAD();
        TF_InitMlngInfo();
        CCategoryMgr::InitGlobal();
        EnsureAssemblyList(psfn);
        EnsureMarshalWnd();
        //EnsureLangBarItemMgr(psfn);
        EnsureTIMList(psfn);

        //
        // I think this is a bogus assert, but it is better to catch the case
        // to find another case this happen rather than OLE embedded apps.
        //
        // Assert(dwCurThreadId == GetSharedMemory()->dwFocusThread);

        TraceMsg(TF_GENERAL, "Make SetFocus notify  %x", dwCurThreadId);
    }

    //
    // Local LangBarEventSink
    //
    CicEnterCriticalSection(g_csInDllMain);

    nCnt = g_rglbes->Count();
    for (nId = 0; nId < nCnt; nId++)
    {
        LBAREVENTSINKLOCAL *plbes;
        DWORD dwThreadId;


        plbes = g_rglbes->GetPtr(nId);
        Assert(!(plbes->lb.m_dwLangBarFlags & TF_LBESF_GLOBAL));
        dwThreadId = plbes->lb.m_dwThreadId;


        if (dwThreadId != dwCurThreadId)
            continue;

        Assert(plbes->lb.m_dwFlags & LBESF_INUSE);

        if (!(plbes->lb.m_dwFlags & dwMsgMaskFlag))
        {
            PostThreadMessage(dwThreadId, uMsg, 0, lParam);

            //
            // set message mask.
            //
            plbes->lb.m_dwFlags |= dwMsgMaskFlag;
        }
    }

    CicLeaveCriticalSection(g_csInDllMain);

    //
    // Global LangBarEventSink
    //
    BOOL fInDllMain = ISINDLLMAIN();
    if (fInDllMain || mutexhlp.Enter())
    {
        BOOL fPost = FALSE;

        for (nId = 0; nId < MAX_LPES_NUM; nId++)
        {
            DWORD dwFlags = GetSharedMemory()->lbes[nId].m_dwFlags;

            // init array.
            dwPostThread[nId] = 0;

            if (!(dwFlags & LBESF_INUSE))
                continue;

            DWORD dwTargetProcessId = g_timlist.GetProcessId(GetSharedMemory()->lbes[nId].m_dwThreadId);
            if (dwTargetProcessId && (GetSharedMemory()->lbes[nId].m_dwProcessId != dwTargetProcessId))
            {
                // 
                // thread on the process is gone without cleaninglbes.
                // 
                Assert(0);
                GetSharedMemory()->lbes[nId].m_dwFlags &= ~LBESF_INUSE;
                continue;
            }


            Assert(GetSharedMemory()->lbes[nId].m_dwLangBarFlags & TF_LBESF_GLOBAL);

            //
            // Check the msg mask bit so there won't be duplicated messages.
            //
            if (dwFlags & dwMsgMaskFlag)
                continue;

            //
            // avoid from posting exactly same messages into the queue.
            //
            if ((GetSharedMemory()->lbes[nId].m_lastmsg.uMsg == uMsg) &&
                (GetSharedMemory()->lbes[nId].m_lastmsg.wParam == wParam) &&
                (GetSharedMemory()->lbes[nId].m_lastmsg.lParam == lParam))
                continue;

            fPost = TRUE;
            dwPostThread[nId] = GetSharedMemory()->lbes[nId].m_dwThreadId;

            //
            // set message mask.
            //
            GetSharedMemory()->lbes[nId].m_dwFlags |= dwMsgMaskFlag;

            //
            // update last posted message.
            //
            GetSharedMemory()->lbes[nId].m_lastmsg.uMsg = uMsg;
            GetSharedMemory()->lbes[nId].m_lastmsg.wParam = wParam;
            GetSharedMemory()->lbes[nId].m_lastmsg.lParam = lParam;
   
        }

        if (fPost) 
        {
            for (nId = 0; nId < MAX_LPES_NUM; nId++)
            {
                if (dwPostThread[nId])
                    PostThreadMessage(dwPostThread[nId], uMsg, wParam, lParam);
            }
        }

        if (!fInDllMain)
            mutexhlp.Leave();
    }
}

//+---------------------------------------------------------------------------
//
// GetThreadInputIdle()
//
//----------------------------------------------------------------------------

DWORD GetThreadInputIdle(DWORD dwProcessId, DWORD dwThreadId)
{
    DWORD dwRet = 0;

    HANDLE hProcess = OpenProcess(PROCESS_ALL_ACCESS,
                                  FALSE, dwProcessId);
    if (hProcess)
    {
        dwRet = WaitForInputIdle(hProcess, 0);
        CloseHandle(hProcess);
    }

    return dwRet;
}

// --------------------------------------------------------------------------
//
//  NotifyTryAgain
//
// --------------------------------------------------------------------------

BOOL NotifyTryAgain(DWORD dwProcessId, DWORD dwThreadId)
{
     if (IsOnNT())
     {
         if (!CicIs16bitTask(dwProcessId, dwThreadId))
         {
             DWORD dwRet = GetThreadInputIdle(dwProcessId, dwThreadId);
             if (dwRet && (dwRet != WAIT_FAILED))
                 return TRUE;
         }
     }
     else 
     {
         DWORD dwThreadFlags = 0;
         if (TF_GetThreadFlags(dwThreadId, &dwThreadFlags, NULL, NULL))
         {
             if (dwThreadFlags & TLF_NOWAITFORINPUTIDLEONWIN9X)
                 return FALSE;
         }

         DWORD dwRet = GetThreadInputIdle(dwProcessId, dwThreadId);
         if (dwRet && (dwRet != WAIT_FAILED))
             return TRUE;
     }
     return FALSE;
}

// --------------------------------------------------------------------------
//
//  SetFocusNotifyHandler
//
// --------------------------------------------------------------------------

void SetFocusNotifyHandler(UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    int nId;
    DWORD dwCurThreadId = GetCurrentThreadId();
    DWORD dwCurProcessId = GetCurrentProcessId();
    int nCnt;
    ITfLangBarEventSink *pSinkLocal = NULL;
    ITfLangBarEventSink *pSinkGlobal = NULL;
    DWORD dwSinkCookie = 0;
    DWORD dwMsgMaskFlag = TLFlagFromMsg(uMsg);
    MSG msg;
    SYSTHREAD *psfn = GetSYSTHREAD();

    if (PeekMessage(&msg, NULL, uMsg, uMsg, PM_NOREMOVE | PM_NOYIELD))
    {
        if ((msg.message == uMsg) &&
            (msg.wParam == wParam) &&
            (msg.lParam == lParam))
        return;
    }

    if ((uMsg == g_msgThreadTerminate) && psfn)
    {
        FreeMarshaledStubsForThread(psfn, (DWORD)lParam);
    }

    //
    // Local LangBarEventSink
    //
    CicEnterCriticalSection(g_csInDllMain);

    nCnt = g_rglbes->Count();
    for (nId = 0; nId < nCnt; nId++)
    {
        LBAREVENTSINKLOCAL *plbes = g_rglbes->GetPtr(nId);

        Assert(!(plbes->lb.m_dwLangBarFlags & TF_LBESF_GLOBAL));

        if (plbes->lb.m_dwThreadId == dwCurThreadId)
        {
            pSinkLocal = plbes->m_pSink;

            dwSinkCookie = plbes->lb.m_dwCookie;

            //
            // clear message mask.
            //
            plbes->lb.m_dwFlags &= ~dwMsgMaskFlag;

            break;
        }
    }
    CicLeaveCriticalSection(g_csInDllMain);



    if (psfn)
    {
        CCicMutexHelper mutexhlp(&g_mutexLBES);
        //
        // Global LangBarEventSink
        //
        if (mutexhlp.Enter())
        {
            for (nId = 0; nId < MAX_LPES_NUM; nId++)
            {
                if ((GetSharedMemory()->lbes[nId].m_dwFlags & LBESF_INUSE) &&
                    (GetSharedMemory()->lbes[nId].m_dwThreadId == dwCurThreadId) &&
                    (GetSharedMemory()->lbes[nId].m_dwProcessId == dwCurProcessId) &&
                    (GetSharedMemory()->lbes[nId].m_dwCookie == psfn->_dwLangBarEventCookie))
                {
                    pSinkGlobal = psfn->_pLangBarEventSink;

                    dwSinkCookie = GetSharedMemory()->lbes[nId].m_dwCookie;

                    //
                    // clear message mask.
                    //
                    GetSharedMemory()->lbes[nId].m_dwFlags &= ~dwMsgMaskFlag;

                    //
                    // clear last posted message.
                    //
                    GetSharedMemory()->lbes[nId].m_lastmsg.uMsg = 0;
                    GetSharedMemory()->lbes[nId].m_lastmsg.wParam = 0;
                    GetSharedMemory()->lbes[nId].m_lastmsg.lParam = 0;
                    break;
                }
            }
            mutexhlp.Leave();
        }
    }

    if (pSinkLocal)
        CallFocusNotifySink(pSinkLocal, uMsg, wParam, lParam, TRUE, dwSinkCookie);

    if (pSinkGlobal)
        CallFocusNotifySink(pSinkGlobal, uMsg, wParam, lParam, FALSE, dwSinkCookie);
}

// --------------------------------------------------------------------------
//
//  CallFocusNotifySink
//
// --------------------------------------------------------------------------

void CallFocusNotifySink(ITfLangBarEventSink *pSink, UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL fLocalSink, DWORD dwSinkCookie)
{
    DWORD dwCurThreadId = GetCurrentThreadId();
    DWORD dwCurProcessId = GetCurrentProcessId();
    SYSTHREAD *psfn;
   
    if (uMsg == g_msgSetFocus)
    {
        DWORD dwActiveThreadId;
        dwActiveThreadId = GetSharedMemory()->dwFocusThread;
        if (g_timlist.IsThreadId(dwActiveThreadId))
        {
            DWORD dwProcessId = GetSharedMemory()->dwFocusProcess;
            if (dwProcessId != dwCurProcessId)
            {
#if 0
                if (NotifyTryAgain(dwProcessId, dwActiveThreadId))
                {
                    HWND hwndMarshal;
                    if (hwndMarshal = EnsureMarshalWnd())
                    {
                        KillTimer(hwndMarshal, MARSHALWND_TIMER_WAITFORINPUTIDLEFORSETFOCUS);
                        SetTimer(hwndMarshal, 
                                 MARSHALWND_TIMER_WAITFORINPUTIDLEFORSETFOCUS,
                                 100, NULL);
                    }
                    goto Exit;
                }
#endif
            }
            if ((!fLocalSink || dwActiveThreadId == dwCurThreadId) &&
                (psfn = GetSYSTHREAD()))
            {
                psfn->fInmsgSetFocus = TRUE;
                _try {
                    pSink->OnSetFocus(dwActiveThreadId);
                }
                _except(CicExceptionFilter(GetExceptionInformation())) {
                    //
                    // On NT5, if we get an exception in MsgHookProc,
                    // it is unhooked by system. To keep the hook,
                    // we handle any excpeiton here.
                    //
                    Assert(0);

                    //
                    // Then we enregister the Sink. Don't use it any more.
                    //
                    // UnregisterLangBarNotifySink(dwSinkCookie);
                }
                psfn->fInmsgSetFocus = FALSE;
            }
        }
    }
    else if (uMsg == g_msgThreadTerminate)
    {            
        if (!fLocalSink && // skip this call for local sinks, they should already be unadvised
            (psfn = GetSYSTHREAD()))
        {
            psfn->fInmsgThreadTerminate = TRUE;
            _try {
                pSink->OnThreadTerminate((DWORD)lParam);
            }
            _except(CicExceptionFilter(GetExceptionInformation())) {
                //
                // On NT5, if we get an exception in MsgHookProc,
                // it is unhooked by system. To keep the hook,
                // we handle any excpeiton here.
                //
                Assert(0);

                //
                // Then we enregister the Sink. Don't use it any more.
                //
                // UnregisterLangBarNotifySink(dwSinkCookie);
            }
            psfn->fInmsgThreadTerminate = FALSE;
        }
    }
    else if (uMsg == g_msgThreadItemChange)
    {
        if (g_timlist.IsThreadId((DWORD)lParam) &&
            (psfn = GetSYSTHREAD()))
        {
            DWORD dwProcessId;

            if (psfn->fInmsgThreadItemChange)
                goto Exit;

            if ((DWORD)lParam == GetSharedMemory()->dwFocusThread)
                dwProcessId = GetSharedMemory()->dwFocusProcess;
            else 
                dwProcessId = g_timlist.GetProcessId((DWORD)lParam);

#if 0
            if (dwProcessId != dwCurProcessId)
            {
                if (NotifyTryAgain(dwProcessId, (DWORD)lParam))
                {
                    PostThreadMessage(dwCurThreadId,uMsg, 0, lParam);
                    goto Exit;
                }
            }
#endif

            psfn->fInmsgThreadItemChange = TRUE;
            _try {
                pSink->OnThreadItemChange((DWORD)lParam);
            }
            _except(CicExceptionFilter(GetExceptionInformation())) {
                //
                // On NT5, if we get an exception in MsgHookProc,
                // it is unhooked by system. To keep the hook,
                // we handle any excpeiton here.
                //
                Assert(0);

                //
                // Then we enregister the Sink. Don't use it any more.
                //
                // UnregisterLangBarNotifySink(dwSinkCookie);
            }
            psfn->fInmsgThreadItemChange = FALSE;
        }
    }
    else if (uMsg == g_msgShowFloating)
    {
        _try {
            pSink->ShowFloating((DWORD)lParam);
        }
        _except(CicExceptionFilter(GetExceptionInformation())) {
            //
            // On NT5, if we get an exception in MsgHookProc,
            // it is unhooked by system. To keep the hook,
            // we handle any excpeiton here.
            //
            Assert(0);

            //
            // Then we enregister the Sink. Don't use it any more.
            //
            // UnregisterLangBarNotifySink(dwSinkCookie);
        }
    }
    else if (uMsg == g_msgLBUpdate)
    {
        _try {
            ITfLangBarEventSink_P *pSinkP;
            if (SUCCEEDED(pSink->QueryInterface(IID_ITfLangBarEventSink_P, (void **)&pSinkP)) && pSinkP)
            {
                pSinkP->OnLangBarUpdate((DWORD)wParam, lParam);
                pSinkP->Release();
            }
        }
        _except(CicExceptionFilter(GetExceptionInformation())) {
            //
            // On NT5, if we get an exception in MsgHookProc,
            // it is unhooked by system. To keep the hook,
            // we handle any excpeiton here.
            //
            Assert(0);

            //
            // Then we enregister the Sink. Don't use it any more.
            //
            // UnregisterLangBarNotifySink(dwSinkCookie);
        }
    }

Exit:
    return;
}


// --------------------------------------------------------------------------
//
//  SetModalLBarSink
//
// --------------------------------------------------------------------------

void SetModalLBarSink(DWORD dwTargetThreadId, BOOL fSet, DWORD dwFlags)
{
    int nId;
    CCicMutexHelper mutexhlp(&g_mutexLBES);

    Assert(!(0xffff0000 & dwFlags));

    //
    // Global LangBarEventSink
    //
    if (mutexhlp.Enter())
    {
        for (nId = 0; nId < MAX_LPES_NUM; nId++)
        {
            if (GetSharedMemory()->lbes[nId].m_dwThreadId == GetCurrentThreadId())
            {
                LPARAM lParam  = (LPARAM)((nId << 16) + (dwFlags & 0xffff));
                PostThreadMessage(dwTargetThreadId,
                                  g_msgPrivate, 
                                  fSet ? TFPRIV_SETMODALLBAR : TFPRIV_RELEASEMODALLBAR,
                                  (LPARAM)lParam);
                break;
            }
        }
        mutexhlp.Leave();
    }
}

// --------------------------------------------------------------------------
//
//  SetModalLBarId
//
// --------------------------------------------------------------------------

void SetModalLBarId(int nId, DWORD dwFlags)
{
     SYSTHREAD *psfn;

     if (psfn = GetSYSTHREAD())
     {
         psfn->nModalLangBarId = nId;
         psfn->dwModalLangBarFlags = dwFlags;
     }
}

// --------------------------------------------------------------------------
//
//  HandlModalLBar
//
// --------------------------------------------------------------------------

BOOL HandleModalLBar(UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    SYSTHREAD *psfn = GetSYSTHREAD();
    DWORD dwThreadId = 0;

    if (psfn == NULL)
        return FALSE;

    if (psfn->nModalLangBarId == -1)
         return FALSE;

    if ((((uMsg >= WM_NCMOUSEMOVE) && (uMsg <= WM_NCMBUTTONDBLCLK)) ||
         ((uMsg >= WM_MOUSEFIRST) && (uMsg <= WM_MOUSELAST)))  &&
        (psfn->dwModalLangBarFlags & TF_LBSMI_FILTERCURRENTTHREAD))
    {
         POINT pt = {LOWORD((DWORD)lParam), HIWORD((DWORD)lParam)};
         HWND hwnd = WindowFromPoint(pt);
         if (GetCurrentThreadId() == GetWindowThreadProcessId(hwnd, NULL))
             return FALSE;
    }

    CCicMutexHelper mutexhlp(&g_mutexLBES);
    //
    // Global LangBarEventSink
    //
    if (mutexhlp.Enter())
    {
        if (GetSharedMemory()->lbes[psfn->nModalLangBarId].m_dwFlags & LBESF_INUSE)
            dwThreadId = GetSharedMemory()->lbes[psfn->nModalLangBarId].m_dwThreadId;

        mutexhlp.Leave();
    }

    if (!dwThreadId)
    {
        psfn->nModalLangBarId = -1;
        return FALSE;
    }
    
    Assert(g_timlist.IsThreadId(dwThreadId));

    //
    // Here, we will lost HIWORD(uMsg) and HIWORD(wParam).
    //
    // if we need scan code for WM_KEYxxx, message. we need to put it 
    // HIBYTE(LOWORD(wParam))
    //
    PostThreadMessage(dwThreadId,
                      g_msgLBarModal, 
                      (WPARAM)((LOWORD(uMsg) << 16) | LOWORD(wParam)),
                      lParam);
    return TRUE;
}

// --------------------------------------------------------------------------
//
//  DispatchModalLBar
//
// --------------------------------------------------------------------------

BOOL DispatchModalLBar(WPARAM wParam, LPARAM lParam)
{
    int nId;

    SYSTHREAD *psfn = GetSYSTHREAD();
    if (!psfn)
        return FALSE;

    DWORD dwCurThreadId = GetCurrentThreadId();
    DWORD dwCurProcessId = GetCurrentProcessId();
    ITfLangBarEventSink *pSink = NULL;

    //
    // we don't need to check Local LangBarEventSink
    //

    CCicMutexHelper mutexhlp(&g_mutexLBES);
    //
    // Global LangBarEventSink
    //
    if (mutexhlp.Enter())
    {
        for (nId = 0; nId < MAX_LPES_NUM; nId++)
        {
            if ((GetSharedMemory()->lbes[nId].m_dwFlags & LBESF_INUSE) &&
                (GetSharedMemory()->lbes[nId].m_dwThreadId == dwCurThreadId) &&
                (GetSharedMemory()->lbes[nId].m_dwProcessId == dwCurProcessId) &&
                (GetSharedMemory()->lbes[nId].m_dwCookie == psfn->_dwLangBarEventCookie))
            {
                pSink = psfn->_pLangBarEventSink;
                break;
            }
        }
        mutexhlp.Leave();
    }
   
    if (pSink)
    {
        //
        // restore uMsg and wParam from posted wParam.
        //
       
        _try {
            pSink->OnModalInput(GetSharedMemory()->dwFocusThread,
                                (UINT)HIWORD(wParam),
                                (WPARAM)LOWORD(wParam),
                                lParam);
        }
        _except(CicExceptionFilter(GetExceptionInformation())) {
            Assert(0);
        }
    }
    return TRUE;
}

// --------------------------------------------------------------------------
//
//  ThreadGetItemFloatingRect
//
// --------------------------------------------------------------------------

HRESULT ThreadGetItemFloatingRect(DWORD dwThreadId, REFGUID rguid, RECT *prc)
{
    SYSTHREAD *psfn = GetSYSTHREAD();
    if (!psfn)
        return E_FAIL;

    DWORD dwCurThreadId = GetCurrentThreadId();
    DWORD dwCurProcessId = GetCurrentProcessId();
    ITfLangBarEventSink *pSink = NULL;
    DWORD dwThreadIdSink = 0;
    int nId;

    CCicMutexHelper mutexhlp(&g_mutexLBES);
    //
    // Global LangBarEventSink
    //
    if (mutexhlp.Enter())
    {
        for (nId = 0; nId < MAX_LPES_NUM; nId++)
        {
            if (GetSharedMemory()->lbes[nId].m_dwFlags & LBESF_INUSE)
            {
                if (!dwThreadIdSink)
                    dwThreadIdSink = GetSharedMemory()->lbes[nId].m_dwThreadId;

                if ((GetSharedMemory()->lbes[nId].m_dwThreadId == dwCurThreadId) &&
                    (GetSharedMemory()->lbes[nId].m_dwProcessId == dwCurProcessId) &&
                    (GetSharedMemory()->lbes[nId].m_dwCookie == psfn->_dwLangBarEventCookie))
                {
                    pSink = psfn->_pLangBarEventSink;
                    break;
                }
            }
        }
        mutexhlp.Leave();
    }

    if (pSink)
        return pSink->GetItemFloatingRect(dwThreadId, rguid, prc);

    HRESULT hrRet = E_FAIL;
    if (dwThreadIdSink)
    {
        ITfLangBarItemMgr *plbim;

        if ((GetThreadUIManager(dwThreadIdSink, &plbim, NULL) == S_OK) && plbim)
        {
            hrRet = plbim->GetItemFloatingRect(dwThreadId, rguid, prc);
            plbim->Release();
        }
    }

    return hrRet;
}

// --------------------------------------------------------------------------
//
//  IsCTFMONBusy
//
// --------------------------------------------------------------------------

const TCHAR c_szLoaderWndClass[] = TEXT("CicLoaderWndClass");

BOOL IsCTFMONBusy()
{
    HWND hwndLoader = NULL;
    DWORD dwProcessId;
    DWORD dwThreadId;

    hwndLoader = FindWindow(c_szLoaderWndClass, NULL);

    if (!hwndLoader)
        return FALSE;

    dwThreadId = GetWindowThreadProcessId(hwndLoader, &dwProcessId);

    if (!dwThreadId)
        return FALSE;

    return NotifyTryAgain(dwProcessId, dwThreadId);
}

// --------------------------------------------------------------------------
//
//  IsInPopupMenuMode
//
// --------------------------------------------------------------------------

BOOL IsInPopupMenuMode()
{
    //
    // bug: 399755
    //
    // when the popup menu is being shown, the OLE RPC and Cicero marshalling
    // get blocked the thread. We should postpone plbim->OnUpdateHandler().
    //

    DWORD dwThreadId = GetCurrentThreadId();
    GUITHREADINFO gti;
    gti.cbSize = sizeof(GUITHREADINFO);

    if (!GetGUIThreadInfo(dwThreadId, &gti))
        return FALSE;


    return (gti.flags & GUI_POPUPMENUMODE) ? TRUE : FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\ctf\uim\funcprv.cpp ===
//
// funcprv.cpp
//

#include "private.h"
#include "globals.h"
#include "funcprv.h"
#include "fnrecon.h"
#include "helpers.h"
#include "immxutil.h"
#include "ic.h"

DBG_ID_INSTANCE(CFunctionProvider);

//////////////////////////////////////////////////////////////////////////////
//
// CFunctionProvider
//
//////////////////////////////////////////////////////////////////////////////

//+---------------------------------------------------------------------------
//
// ctor
//
//----------------------------------------------------------------------------

CFunctionProvider::CFunctionProvider()
{
    Dbg_MemSetThisNameID(TEXT("CFunctionProvider"));

    _cRef = 1;
}

//+---------------------------------------------------------------------------
//
// dtor
//
//----------------------------------------------------------------------------

CFunctionProvider::~CFunctionProvider()
{
}


//+---------------------------------------------------------------------------
//
// GetType
//
//----------------------------------------------------------------------------

STDAPI CFunctionProvider::GetType(GUID *pguid)
{
    *pguid = GUID_SYSTEM_FUNCTIONPROVIDER;
    return S_OK;
}

//+---------------------------------------------------------------------------
//
// GetDescription
//
//----------------------------------------------------------------------------

STDAPI CFunctionProvider::GetDescription(BSTR *pbstrDesc)
{
    *pbstrDesc = SysAllocString(L"System Function Provider");
    return *pbstrDesc != NULL ? S_OK : E_OUTOFMEMORY;
}

//+---------------------------------------------------------------------------
//
// GetFunction
//
//----------------------------------------------------------------------------

STDAPI CFunctionProvider::GetFunction(REFGUID rguid, REFIID riid, IUnknown **ppunk)
{
    if (!ppunk)
        return E_INVALIDARG;

    *ppunk = NULL;

    if (!IsEqualIID(rguid, GUID_NULL))
        return E_UNEXPECTED;

    if (IsEqualIID(riid, IID_ITfFnReconversion))
    {
        CFnReconversion *pReconv = new CFnReconversion(this);
        pReconv->QueryInterface(IID_IUnknown, (void **)ppunk);
        pReconv->Release();
    }
    else if (IsEqualIID(riid, IID_ITfFnAbort))
    {
        *ppunk = new CFnAbort(this);
    }

    if (*ppunk)
        return S_OK;

    return E_NOINTERFACE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\ctf\uim\gcompart.cpp ===
//
// gcompart.cpp
//

#include "private.h"
#include "globals.h"
#include "gcompart.h"
#include "cregkey.h"
#include "thdutil.h"
#include "regsvr.h"

CGCompartList g_gcomplist;

CSharedBlock *CGCompartList::_psb = NULL;
ULONG CGCompartList::_ulCommitSize = INITIAL_GCOMPART_SIZE;
LONG CGCompartList::_nRef = -1;
BOOL CGCompartList::_fCreate = FALSE;

//////////////////////////////////////////////////////////////////////////////
//
// CGCompartList
//
//////////////////////////////////////////////////////////////////////////////

//--------------------------------------------------------------------------
//
//  Init
//
//--------------------------------------------------------------------------

BOOL CGCompartList::Init(SYSTHREAD *psfn)
{
    static const char c_szGCompartList[] = "MSCTF.GCompartList";
    BOOL bRet = FALSE;
    BOOL bAlreadyExist = FALSE;


    if (!psfn)
        return FALSE;

    Assert(!psfn->fInitGlobalCompartment);

    CicEnterCriticalSection(g_csInDllMain);

    if (++_nRef)
    {
        bRet = TRUE;
        goto Exit;
    }

    _psb = new CSharedBlockNT(c_szGCompartList, 0, TRUE);

    if (!_psb)
    {
        Assert(0);
        goto Exit;
    }

    HRESULT hr = _psb->Init(NULL, 0x40000, _ulCommitSize, NULL, TRUE, &bAlreadyExist);
    if (FAILED(hr))
    {
        Assert(0);
        goto Exit;
    }

    if (!bAlreadyExist)
    {
       Start();
    }

    bRet = TRUE;
Exit:
    if (!bRet)
    {
        _nRef--;
        if (_psb)
            delete _psb;

        _psb = NULL;
    }

    CicLeaveCriticalSection(g_csInDllMain);

    if (bRet)
        psfn->fInitGlobalCompartment = TRUE;

    return bRet;
}

//--------------------------------------------------------------------------
//
//  Start
//
//--------------------------------------------------------------------------

BOOL CGCompartList::Start()
{
    GLOBALCOMPARTMENTLIST *pgcl;

    if (!_psb)
    {
        Assert(0);
        return FALSE;
    }

    _fCreate = TRUE;
    CMyRegKey key;
    CMyRegKey keyLM;
    DWORD ulNum = 0;
    char szSubKey[MAX_PATH];
    pgcl = (GLOBALCOMPARTMENTLIST *)_psb->GetBase();

    keyLM.Open(HKEY_LOCAL_MACHINE, c_szCompartKey, KEY_READ);

    if (key.Open(HKEY_CURRENT_USER, c_szCompartKey, KEY_READ) == S_OK)
    {
        DWORD dwIndex = 0;
        while (key.EnumKey(dwIndex, szSubKey, ARRAYSIZE(szSubKey)) == S_OK)
        {
            CMyRegKey subkey;
            CMyRegKey subkeyLM;
            CLSID clsid;
            if (!StringAToCLSID(szSubKey, &clsid))
               continue;

            DWORD dwReqSize = ((ulNum + 1) * sizeof(GLOBALCOMPARTMENT)) +
                              sizeof(GLOBALCOMPARTMENTLIST);

            if (_ulCommitSize < dwReqSize)
            {
                dwReqSize *= 2;
                if (FAILED(_psb->Commit(dwReqSize)))
                    goto Exit;

                _ulCommitSize = dwReqSize;
            }

            if (subkey.Open(key, szSubKey, KEY_READ) == S_OK)
            {
                DWORD dwNonInit = 0;
                if ((HKEY)keyLM && 
                    subkeyLM.Open(keyLM, szSubKey, KEY_READ) == S_OK)
                {
                    if (subkeyLM.QueryValue(dwNonInit, c_szNonInit) != S_OK)
                        dwNonInit = 0;
                }

                if (!dwNonInit)
                {
                    GLOBALCOMPARTMENT *pgc = &pgcl->rgGCompart[ulNum];
                    DWORD dwCount = sizeof(GLOBALCOMPARTMENT);
                    if (subkey.QueryBinaryValue(pgc, 
                                            dwCount,
                                            c_szGlobalCompartment) == S_OK)
                        ulNum++;
                }

            }

            dwIndex++;
        }
    }
    pgcl->ulNum = ulNum;

Exit:
    return TRUE;
}

//--------------------------------------------------------------------------
//
//  UnInit
//
//--------------------------------------------------------------------------

BOOL CGCompartList::Uninit(SYSTHREAD *psfn)
{
    if (!psfn)
        return FALSE;

    if (!_psb)
        return TRUE;

    if (_fCreate)
    {
        CMyRegKey key;
        if (key.Create(HKEY_CURRENT_USER, c_szCompartKey) == S_OK)
        {
            char szSubKey[MAX_PATH];
            ULONG i;
            GLOBALCOMPARTMENTLIST *pgcl;

            pgcl = (GLOBALCOMPARTMENTLIST *)_psb->GetBase();

            for (i = 0; i < pgcl->ulNum; i++)
            {
                GLOBALCOMPARTMENT *pgc = &pgcl->rgGCompart[i];
                CMyRegKey subkey;
                CLSIDToStringA(pgc->guid, szSubKey);
                if (subkey.Create(key, szSubKey) == S_OK)
                {
                    subkey.SetBinaryValue(pgc, 
                                          sizeof(GLOBALCOMPARTMENT), 
                                          c_szGlobalCompartment);
                }
            }
        }
    }

    if (!psfn->fInitGlobalCompartment)
        return TRUE;

    CicEnterCriticalSection(g_csInDllMain);

    if (--_nRef >= 0)
        goto Exit;

    if (_psb)
        delete _psb;

    _psb = NULL;

Exit:
    CicLeaveCriticalSection(g_csInDllMain);

    psfn->fInitGlobalCompartment = FALSE;

    return TRUE;
}

//--------------------------------------------------------------------------
//
//  SetProperty
//
//--------------------------------------------------------------------------

CGCompartList::GLOBALCOMPARTMENT *CGCompartList::FindProperty(REFGUID guid)
{
    GLOBALCOMPARTMENTLIST *pgcl = (GLOBALCOMPARTMENTLIST *)_psb->GetBase();
    UINT i;
    GLOBALCOMPARTMENT *pgc = NULL;

    if (!pgcl)
    {
        Assert(0);
        return NULL;
    }

    for (i = 0; i < pgcl->ulNum; i++)
    {
        GLOBALCOMPARTMENT *pgcTemp = &pgcl->rgGCompart[i];
        if (IsEqualGUID(pgcTemp->guid, guid))
        {
            pgc = pgcTemp;
            break;
        }
    }

    return pgc;
}

//--------------------------------------------------------------------------
//
//  SetProperty
//
//--------------------------------------------------------------------------

DWORD CGCompartList::SetProperty(REFGUID guid, TFPROPERTY *pProp)
{
    DWORD dwRet = (DWORD)(-1);
    GLOBALCOMPARTMENTLIST *pgcl;
    GLOBALCOMPARTMENT *pgc;

    if (!Enter())
        return dwRet;

    pgcl = (GLOBALCOMPARTMENTLIST *)_psb->GetBase();
    if (!pgcl)
    {
        Assert(0);
        return dwRet;
    }

    pgc = FindProperty(guid);

    if (!pgc)
    {

        if (_ulCommitSize <  sizeof(GLOBALCOMPARTMENTLIST) + (pgcl->ulNum * sizeof(DWORD)))
        {
            _ulCommitSize = sizeof(GLOBALCOMPARTMENTLIST) + (pgcl->ulNum * sizeof(DWORD));
            _ulCommitSize += INITIAL_GCOMPART_SIZE;
            if (FAILED(_psb->Commit(_ulCommitSize)))
            {
                Assert(0);
                goto Exit;
            }
        }
        pgc = &pgcl->rgGCompart[pgcl->ulNum];
        pgc->guid = guid;
        pgcl->ulNum++;
    }

    pgc->gprop.type = pProp->type;
    switch (pgc->gprop.type)
    {
        case TF_PT_DWORD:
             pgc->gprop.dw = pProp->dw;
             break;

        case TF_PT_GUID:
             MyGetGUID(pProp->guidatom, &pgc->gprop.guid);
             break;

        case TF_PT_NONE:
             break;

        default:
             Assert(0);
             break;
    }

    dwRet = CALCID(pgc, pgcl);
    
Exit:
    Leave();
    return dwRet;
}

//--------------------------------------------------------------------------
//
//  GetProperty
//
//--------------------------------------------------------------------------

BOOL CGCompartList::GetProperty(REFGUID guid, TFPROPERTY *pProp)
{
    BOOL bRet = FALSE;
    GLOBALCOMPARTMENT *pgc;

    if (!Enter())
        return bRet;

    pgc = FindProperty(guid);

    if (!pgc)
    {
        goto Exit;
    }

    pProp->type = pgc->gprop.type;
    switch (pgc->gprop.type)
    {
        case TF_PT_DWORD:
             pProp->dw = pgc->gprop.dw;
             break;

        case TF_PT_GUID:
             MyRegisterGUID(pgc->gprop.guid, &pProp->guidatom);
             break;

        case TF_PT_NONE:
             break;

        default:
             Assert(0);
             break;
    }
    
    bRet = TRUE;
Exit:
    Leave();
    return bRet;
}

//--------------------------------------------------------------------------
//
//  GetId
//
//--------------------------------------------------------------------------

DWORD CGCompartList::GetId(REFGUID guid)
{
    DWORD dwRet = (DWORD)(-1);
    GLOBALCOMPARTMENTLIST *pgcl;
    GLOBALCOMPARTMENT *pgc;

    if (!Enter())
        return dwRet;

    pgcl = (GLOBALCOMPARTMENTLIST *)_psb->GetBase();
    pgc = FindProperty(guid);

    if (pgc)
    {
        dwRet = CALCID(pgc, pgcl);
    }

    Leave();
    return dwRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\ctf\uim\fnrecon.cpp ===
//
// reconv.cpp
//

#include "private.h"
#include "globals.h"
#include "tim.h"
#include "ic.h"
#include "helpers.h"
#include "fnrecon.h"
#include "funcprv.h"
#include "ptrary.h"
#include "immxutil.h"
#include "proputil.h"
#include "rprop.h"
#include "range.h"

//+---------------------------------------------------------------------------
//
// ::GrowEmptyRangeByOne
//
// Helper to enlarge empty ranges by shifting the end anchor + 1.
//
//----------------------------------------------------------------------------

HRESULT GrowEmptyRangeByOne(CInputContext *pic, ITfRange *range)
{
    HRESULT hr = S_OK;

    if (pic->_DoPseudoSyncEditSession(TF_ES_READ, PSEUDO_ESCB_GROWRANGE, range, &hr) != S_OK || hr != S_OK)
    {
        Assert(0);
    }

    return hr;
}

HRESULT GrowEmptyRangeByOneCallback(TfEditCookie ec, ITfRange *range)
{
    BOOL fEmpty;
    LONG l;
    HRESULT hr = S_OK;

    //
    // Check the length of the given range.
    // If the given range is 0 length, we try to find the owner of
    // the next char.
    //
    range->IsEmpty(ec, &fEmpty);
    if (fEmpty)
    {
        hr = range->ShiftEnd(ec, +1, &l, NULL);
    }

    return hr;
}


//////////////////////////////////////////////////////////////////////////////
//
// CFunction
//
//////////////////////////////////////////////////////////////////////////////

//+---------------------------------------------------------------------------
//
// ctor
//
//----------------------------------------------------------------------------

CFunction::CFunction(CFunctionProvider *pFuncPrv)
{
    _pFuncPrv = pFuncPrv;
    _pFuncPrv->AddRef();
}

//+---------------------------------------------------------------------------
//
// dtor
//
//----------------------------------------------------------------------------

CFunction::~CFunction()
{
    SafeRelease(_pFuncPrv);
    CleanUpOwnerRange();
}

//+---------------------------------------------------------------------------
//
// CleanUpOwnerRange
//
//----------------------------------------------------------------------------

void CFunction::CleanUpOwnerRange()
{
    CRangeOwnerList *pRangeOwner;
    while (pRangeOwner = _listRangeOwner.GetFirst())
    {
        _listRangeOwner.Remove(pRangeOwner);
        delete pRangeOwner;
    }
}

//+---------------------------------------------------------------------------
//
// BuildOwnerRangeList
//
//----------------------------------------------------------------------------

BOOL CFunction::BuildOwnerRangeList(CInputContext *pic, ITfRange *pRange)
{
    HRESULT hr = S_OK;
    BUILDOWNERRANGELISTQUEUEINFO qInfo;
    BOOL bRet = TRUE;

    qInfo.pFunc = this;
    qInfo.pRange = pRange;

    if (pic->_DoPseudoSyncEditSession(TF_ES_READ, PSEUDO_ESCB_BUILDOWNERRANGELIST, &qInfo, &hr) != S_OK || hr != S_OK)
    {
        Assert(0);
        bRet = FALSE;
    }

    return bRet;
}

//+---------------------------------------------------------------------------
//
// BuildOwnerRangeListCallback
//
//----------------------------------------------------------------------------

HRESULT CFunction::BuildOwnerRangeListCallback(TfEditCookie ec, CInputContext *pic, ITfRange *pRange)
{
    CProperty *pProp;
    IEnumTfRanges *pEnumPropRange;
    CRange *pRangeP = NULL;
    HRESULT hr = E_FAIL;

    if (pic->_pPropTextOwner == NULL)
        goto ExitOk;

    pProp = pic->_pPropTextOwner;
   
    CleanUpOwnerRange();

    //
    // if pRange is NULL, we build owner list for entire dcoument.
    // we will enumerate all property ranges.
    //
    if (pRange)
    {
        if ((pRangeP = GetCRange_NA(pRange)) == NULL)
            goto Exit;
    }

    if (SUCCEEDED(pProp->EnumRanges(ec, &pEnumPropRange, pRange)))
    {
        ITfRange *pPropRange;
        while (pEnumPropRange->Next(1, &pPropRange, NULL) == S_OK)
        {
            TfGuidAtom guidOwner;
            CRangeOwnerList *pRangeOwner;
            ITfRange *pRangeTmp;
            CRange *pRangeTmpP;
            BOOL bKnownOwner = FALSE;

            pPropRange->Clone(&pRangeTmp);

            GetGUIDPropertyData(ec, pProp, pPropRange, &guidOwner);

            //
            // check if this guidOwner already appeared in the range.
            //
            pRangeOwner = _listRangeOwner.GetFirst();
            while(pRangeOwner)
            {
                if (guidOwner == pRangeOwner->_guidOwner)
                {
                    bKnownOwner = TRUE;
                }
                pRangeOwner = pRangeOwner->GetNext();
            }

            //
            // get CRange.
            //
            if ((pRangeTmpP = GetCRange_NA(pRangeTmp)) == NULL)
                goto NoCRange;

            //
            // if pRangeP is NULL, we build owner list for entire document.
            // So we don't have to adjust pRangeTmp.
            //
            if (pRangeP)
            {
                if (CompareAnchors(pRangeTmpP->_GetStart(), pRangeP->_GetStart()) < 0)
                {
                    // move pRangeTmp's start to match pRange
                    pRangeTmpP->_GetStart()->ShiftTo(pRangeP->_GetStart());
                    // insure pRangeTmp's end is no greater than pRange's end
                    if (CompareAnchors(pRangeTmpP->_GetEnd(), pRangeP->_GetEnd()) > 0)
                    {
                        pRangeTmpP->_GetEnd()->ShiftTo(pRangeP->_GetEnd());
                    }
                }
                else if (CompareAnchors(pRangeTmpP->_GetEnd(), pRangeP->_GetEnd()) > 0)
                {
                    pRangeTmpP->_GetEnd()->ShiftTo(pRangeP->_GetEnd());
                }
            }

            pRangeOwner = new CRangeOwnerList(guidOwner, pRangeTmp, bKnownOwner);
            _listRangeOwner.Add(pRangeOwner);

NoCRange:
            pPropRange->Release();
            pRangeTmp->Release();
        }
        pEnumPropRange->Release();
    }

ExitOk:
    hr = S_OK;

Exit:
    return hr;
}


//////////////////////////////////////////////////////////////////////////////
//
// CFnReconversion
//
//////////////////////////////////////////////////////////////////////////////

//+---------------------------------------------------------------------------
//
// ctor
//
//----------------------------------------------------------------------------

CFnReconversion::CFnReconversion(CFunctionProvider *pFuncPrv) :CFunction(pFuncPrv)
{
    _pReconvCache = NULL;
}

//+---------------------------------------------------------------------------
//
// dtor
//
//----------------------------------------------------------------------------

CFnReconversion::~CFnReconversion()
{
    SafeRelease(_pReconvCache);
}

//+---------------------------------------------------------------------------
//
// GetDisplayName
//
//----------------------------------------------------------------------------

STDAPI CFnReconversion::GetDisplayName(BSTR *pbstrName)
{
    *pbstrName = SysAllocString(L"Reconversion");
    return *pbstrName != NULL ? S_OK : E_OUTOFMEMORY;
}

//+---------------------------------------------------------------------------
//
// CFnReconversion::GetReconversion
//
//----------------------------------------------------------------------------

STDAPI CFnReconversion::GetReconversion(ITfRange *pRange, ITfCandidateList **ppCandList)
{
    if (ppCandList == NULL)
        return E_INVALIDARG;

    *ppCandList = NULL;

    if (pRange == NULL)
        return E_INVALIDARG;

    return Internal_GetReconversion(pRange, ppCandList, NULL, RF_GETRECONVERSION, NULL);
}

//+---------------------------------------------------------------------------
//
// CFnReconversion::QueryRange
//
//----------------------------------------------------------------------------

STDAPI CFnReconversion::QueryRange(ITfRange *pRange, ITfRange **ppNewRange, BOOL *pfConvertable)
{
    if (ppNewRange != NULL)
    {
        *ppNewRange = NULL;
    }
    if (pfConvertable != NULL)
    {
        *pfConvertable = FALSE;
    }
    if (pRange == NULL ||
        ppNewRange == NULL ||
        pfConvertable == NULL)
    {
        return E_INVALIDARG;
    }

    return Internal_GetReconversion(pRange, NULL, ppNewRange, RF_QUERYRECONVERT, pfConvertable);
}

//+---------------------------------------------------------------------------
//
// CFnReconversion::Reconvert
//
//----------------------------------------------------------------------------

STDAPI CFnReconversion::Reconvert(ITfRange *pRange)
{
    if (pRange == NULL)
        return E_INVALIDARG;

    return Internal_GetReconversion(pRange, NULL, NULL, RF_RECONVERT, NULL);
}



//+---------------------------------------------------------------------------
//
// CFnReconversion::Internal_GetReconversion
//
//----------------------------------------------------------------------------

HRESULT CFnReconversion::Internal_GetReconversion(ITfRange *pRange, ITfCandidateList **ppCandList, ITfRange **ppNewRange, RECONVFUNC rf, BOOL *pfConvertable)
{
    BOOL bReleaseCache = FALSE;
    HRESULT hr = E_FAIL;
    ITfRange *pRangeTmp = NULL;
    ITfRange *pNewRange = NULL;
    ITfContext *pic = NULL;

    if (FAILED(pRange->Clone(&pRangeTmp)))
        goto Exit;

    if (FAILED(pRangeTmp->GetContext(&pic)))
        goto Exit;

    //
    // when RF_QUERYRECONVERT, we alwasy create new Reconv cache.
    // we will keep using this chace unless another RF_QUERYRECONVERT comes.
    //
    if (rf == RF_QUERYRECONVERT)
        SafeReleaseClear(_pReconvCache);

    if (!_pReconvCache)
    {
        CInputContext *pcic = GetCInputContext(pic);
        if (pcic)
        {
            QueryAndGetFunction(pcic, pRangeTmp, &_pReconvCache, &pNewRange);
            pcic->Release();
        }

        //
        // when it's not RF_QUERYRECONVERT and there was no cache, 
        // we don't hold the reconv cache.
        //
        if (rf != RF_QUERYRECONVERT)
            bReleaseCache = TRUE;
    }

    if (!_pReconvCache)
    {
        hr = S_OK;
        goto Exit;
    }

    switch (rf)
    {
        case RF_GETRECONVERSION:
            if ((hr = _pReconvCache->GetReconversion(pRangeTmp, ppCandList)) != S_OK)
            {
                *ppCandList = NULL;
            }
            break;

        case RF_RECONVERT:
            hr = _pReconvCache->Reconvert(pRangeTmp);
            break;

        case RF_QUERYRECONVERT:
            if (!pNewRange)
            {
                if ((hr = _pReconvCache->QueryRange(pRangeTmp, ppNewRange, pfConvertable)) != S_OK)
                {
                    *ppNewRange = NULL;
                    *pfConvertable = FALSE;
                }
            }
            else
            {
                *ppNewRange = pNewRange;
                (*ppNewRange)->AddRef();
                *pfConvertable = TRUE;
                hr = S_OK;
            }
            break;
    }

    Assert(hr == S_OK);

Exit:
    if (bReleaseCache || FAILED(hr))
        SafeReleaseClear(_pReconvCache);

    SafeRelease(pRangeTmp);
    SafeRelease(pNewRange);
    SafeRelease(pic);
    return hr;
}

//+---------------------------------------------------------------------------
//
// ctor
//
//----------------------------------------------------------------------------

HRESULT CFnReconversion::QueryAndGetFunction(CInputContext *pic, ITfRange *pRange, ITfFnReconversion **ppFunc, ITfRange **ppRange)
{
    IEnumTfFunctionProviders *pEnumFuncPrv;
    ITfFunctionProvider *pFuncPrv;
    CRangeOwnerList *pRangeOwner;
    HRESULT hr = E_FAIL;
    ITfRange *pRangeTmp = NULL;
    CThreadInputMgr *ptim;

    *ppFunc = NULL;

    if ((ptim = CThreadInputMgr::_GetThis()) == NULL)
        goto Exit;

    if (pRange)
    {
        //
        // To find the properr function provider, we use pRangeTmp.
        //
        if (FAILED(pRange->Clone(&pRangeTmp)))
            goto Exit;

        //
        // Check the length of the given range.
        // If the given range is 0 length, we try to find the owner of
        // the next char.
        //
        if (GrowEmptyRangeByOne(pic, pRangeTmp) != S_OK)
            goto Exit;
    }

    if (!BuildOwnerRangeList(pic, pRangeTmp))
        goto Exit;

    pRangeOwner = _listRangeOwner.GetFirst();

    if (pRangeOwner)
    {
        GUID guid;

        if (SUCCEEDED(MyGetGUID(pRangeOwner->_guidOwner, &guid)))
        {
            CTip *ptip;

            //
            // A way to get the TextOwner's reconversion function.
            //
            //   - find a function provider of the ower.
            //   - Do QI the text owner TIP.
            //   - CoCreate the text onwer CLSID.
            //
            if (SUCCEEDED(ptim->GetFunctionProvider(guid, &pFuncPrv)))
            {
                hr = pFuncPrv->GetFunction(GUID_NULL, 
                                           IID_ITfFnReconversion, 
                                           (IUnknown **)ppFunc);

                SafeReleaseClear(pFuncPrv);
            }
            else if (ptim->_GetCTipfromGUIDATOM(pRangeOwner->_guidOwner, &ptip) && ptip->_pTip)
            {
                hr = ptip->_pTip->QueryInterface(IID_ITfFnReconversion, 
                                                 (void **)ppFunc);
            }
            else 
            {
                hr = CoCreateInstance(guid,
                                      NULL, 
                                      CLSCTX_INPROC_SERVER, 
                                      IID_ITfFnReconversion, 
                                      (void**)ppFunc);
                
            }

            if (FAILED(hr))
                *ppFunc = NULL;
        }
    }

    //
    // if there is no owner or the owner of the first range does not
    // have ITfFunction, we may find someone who has 
    // ITfFunction.
    //
    if (!(*ppFunc) && 
        SUCCEEDED(ptim->EnumFunctionProviders(&pEnumFuncPrv)))
    {
        while (!(*ppFunc) && pEnumFuncPrv->Next(1, &pFuncPrv, NULL) == S_OK)
        {
            GUID guid;

            BOOL fSkip = TRUE;
            if (SUCCEEDED(pFuncPrv->GetType(&guid)))
            {
                 if (!IsEqualGUID(guid, GUID_SYSTEM_FUNCTIONPROVIDER))
                     fSkip = FALSE;
            }

            if(!fSkip)
            {
                hr = pFuncPrv->GetFunction(GUID_NULL, IID_ITfFnReconversion, (IUnknown **)ppFunc);

                if ((SUCCEEDED(hr) && *ppFunc))
                {
                    BOOL fConvertable = FALSE;
                    hr = (*ppFunc)->QueryRange(pRange, ppRange, &fConvertable);
                    if (FAILED(hr) || !fConvertable)
                    {
                       (*ppFunc)->Release();
                       *ppFunc = NULL;
                    }
                }                
            }
            SafeReleaseClear(pFuncPrv);
        }
        pEnumFuncPrv->Release();
    }

Exit:
    SafeRelease(pRangeTmp);
    return (*ppFunc) ? S_OK : E_FAIL;
}

//////////////////////////////////////////////////////////////////////////////
//
// CFnAbort
//
//////////////////////////////////////////////////////////////////////////////

//+---------------------------------------------------------------------------
//
// ctor
//
//----------------------------------------------------------------------------

CFnAbort::CFnAbort(CFunctionProvider *pFuncPrv) : CFunction(pFuncPrv)
{
}

//+---------------------------------------------------------------------------
//
// dtor
//
//----------------------------------------------------------------------------

CFnAbort::~CFnAbort()
{
}

//+---------------------------------------------------------------------------
//
// GetDisplayName
//
//----------------------------------------------------------------------------

STDAPI CFnAbort::GetDisplayName(BSTR *pbstrName)
{
    *pbstrName = SysAllocString(L"Abort");
    return *pbstrName != NULL ? S_OK : E_OUTOFMEMORY;
}

//+---------------------------------------------------------------------------
//
// CFnAbort::Abort
//
//----------------------------------------------------------------------------

STDAPI CFnAbort::Abort(ITfContext *pic)
{
    CThreadInputMgr *ptim;
    HRESULT hr = E_FAIL;
    int i;
    int nCnt;

    if (!pic)
        return E_INVALIDARG;

    if ((ptim = CThreadInputMgr::_GetThis()) == NULL)
        goto Exit;

    //
    // notify all tips with ITfFnAbort to abort any pending conversion.
    //
    nCnt = ptim->_GetTIPCount();
    for (i = 0; i < nCnt; i++)
    {
        ITfFnAbort *pAbort;
        const CTip *ptip = ptim->_GetCTip(i);

        if (!ptip->_pFuncProvider)
            continue;

        if (SUCCEEDED(ptip->_pFuncProvider->GetFunction(GUID_NULL, 
                                                        IID_ITfFnAbort, 
                                                        (IUnknown  **)&pAbort)))
        {
            pAbort->Abort(pic);
            pAbort->Release();
        }
    }

    hr = S_OK;
Exit:
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\ctf\uim\funcprv.h ===
//
// funcprv.h
//

#ifndef FUNCPRV_H
#define FUNCPRV_H

#include "private.h"

class CInputContext;

class CFunctionProvider : public ITfFunctionProvider,
                          public CComObjectRootImmx
{
public:
    CFunctionProvider();
    ~CFunctionProvider();

    BEGIN_COM_MAP_IMMX(CFunctionProvider)
        COM_INTERFACE_ENTRY(ITfFunctionProvider)
    END_COM_MAP_IMMX()

    IMMX_OBJECT_IUNKNOWN_FOR_ATL()

    //
    // ITfFunctionProvider
    //
    STDMETHODIMP GetType(GUID *pguid);
    STDMETHODIMP GetDescription(BSTR *pbstrDesc);
    STDMETHODIMP GetFunction(REFGUID rguid, REFIID riid, IUnknown **ppunk);

private:
    DWORD _dwCookie;

    long _cRef;
    DBG_ID_DECLARE;
};

#endif // FUNCPRV_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\ctf\uim\gcompart.h ===
//
// gcompart.h
//

#ifndef GCOMPART_H
#define GCOMPART_H

#include "private.h"
#include "tfprop.h"
#include "smblock.h"

#define INITIAL_GCOMPART_SIZE 0x10000

class CGCompartList;
extern CGCompartList g_gcomplist;

#define CALCID(pgc, pgcl) (DWORD)(DWORD_PTR)((BYTE *)pgc - (BYTE *)&pgcl->rgGCompart[0]) / sizeof(GLOBALCOMPARTMENT)

class CGCompartList
{
public:
    void CleanUp()
    {
        if (_psb)
            delete _psb;

        _psb = NULL;
    }

    BOOL Enter()
    {
        if (!_psb || !_psb->GetBase())
            return FALSE;
        
        if (ISINDLLMAIN())
            return TRUE;

        if (!_psb->GetMutex() || !_psb->GetMutex()->Enter())
            return FALSE;

        return TRUE;
    }

    void Leave()
    {
        if (ISINDLLMAIN())
            return;

        _psb->GetMutex()->Leave();
    }

    typedef struct tag_GLOBALCOMPARTMENTPROP {
         TfPropertyType type;
         union {
             GUID guid;
             DWORD dw;
         };
    } GLOBALCOMPARTMENTPROP;

    typedef struct tag_GLOBALCOMPARTMENT {
         GUID guid;
         DWORD dwId;
         LONG cRef;
         GLOBALCOMPARTMENTPROP gprop;
    } GLOBALCOMPARTMENT;

    typedef struct tag_GLOBALCOMPARTMENTLIST {
        ULONG ulNum;
        GLOBALCOMPARTMENT rgGCompart[1];
    } GLOBALCOMPARTMENTLIST;

    BOOL Init(SYSTHREAD *psfn);
    BOOL Start();
    BOOL Uninit(SYSTHREAD *psfn);
    DWORD SetProperty(REFGUID guid, TFPROPERTY *pProp);
    BOOL GetProperty(REFGUID guid, TFPROPERTY *pProp);
    DWORD GetId(REFGUID guid);

private:
    GLOBALCOMPARTMENT *FindProperty(REFGUID guid);

    static CSharedBlock *_psb;
    static ULONG _ulCommitSize;
    static LONG _nRef;
    static BOOL _fCreate;
};


#endif // GCOMPART_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\ctf\uim\globals.cpp ===
//+---------------------------------------------------------------------------
//
//  File:       globals.cpp
//
//  Contents:   Global variables.
//
//----------------------------------------------------------------------------

#include "private.h"
#include "globals.h"

HINSTANCE g_hInst = NULL;

// used by COM server
HINSTANCE GetServerHINSTANCE(void)
{
    return g_hInst;
}

DWORD g_dwTLSIndex = TLS_OUT_OF_INDEXES;

DECLARE_OSVER()

CCiceroSharedMem g_SharedMemory;

HKL g_hklDefault;

// registered messages
UINT g_msgPrivate;

//
// private message for SetFocusNotifySink
//
UINT g_msgSetFocus;
UINT g_msgThreadTerminate;
UINT g_msgThreadItemChange;

//
// private message for Modal LangBar
//
UINT g_msgLBarModal;

UINT g_msgRpcSendReceive;
UINT g_msgThreadMarshal;
UINT g_msgCheckThreadInputIdel;
#ifdef POINTER_MARSHAL
UINT g_msgPointerMarshal;
#endif
UINT g_msgStubCleanUp;
UINT g_msgShowFloating;
UINT g_msgLBUpdate;
UINT g_msgNuiMgrDirtyUpdate;

//
// g_csInDllMain.
//  
//    We should try not to use Thread Synchronizaion. However we got some
//    race condition in stress testing so we need it.
//    g_csInDllMain just protect the section that could be touched from
//    DllMain so that we need to be very careful for the critical section.
//    We can not call some Kernel API (LoadLibrary, CreateProcess and so on) 
//    there.
//
CCicCriticalSectionStatic g_csInDllMain;

CCicCriticalSectionStatic g_cs;

// for combase
CRITICAL_SECTION *GetServerCritSec(void)
{
    return g_cs;
}

#ifdef DEBUG
// for tracking last owner of g_cs
const TCHAR *g_szMutexEnterFile = NULL;
int g_iMutexEnterLine = -1;
#endif // DEBUG

TfGuidAtom g_gaApp;
TfGuidAtom g_gaSystem;

BOOL g_fCTFMONProcess = FALSE;
BOOL g_fCUAS = FALSE;
TCHAR g_szCUASImeFile[16];

//
// application compatibility flag
//
DWORD g_dwAppCompatibility = 0;


/* 626761ad-78d2-44d2-be8b-752cf122acec */
const GUID GUID_APPLICATION = { 0x626761ad, 0x78d2, 0x44d2, {0xbe, 0x8b, 0x75, 0x2c, 0xf1, 0x22, 0xac, 0xec} };
/* 78cb5b0e-26ed-4fcc-854c-77e8f3d1aa80 */
const GUID GUID_SYSTEM = { 0x78cb5b0e, 0x26ed, 0x4fcc, {0x85, 0x4c, 0x77, 0xe8, 0xf3, 0xd1, 0xaa, 0x80} };

const TCHAR c_szCTFKey[] =           TEXT("SOFTWARE\\Microsoft\\CTF\\");
const TCHAR c_szTIPKey[] =           TEXT("TIP");
const TCHAR c_szCTFTIPKey[] =        TEXT("SOFTWARE\\Microsoft\\CTF\\TIP\\");
const TCHAR c_szLangBarKey[] =       TEXT("SOFTWARE\\Microsoft\\CTF\\LangBar\\");
const WCHAR c_szDescriptionW[] =     L"Description";
const WCHAR c_szMUIDescriptionW[] =  L"Display Description";
const WCHAR c_szEnableW[] =          L"Enable";
const TCHAR c_szEnable[] =           TEXT("Enable");
const TCHAR c_szDisabledOnTransitory[] = TEXT("DisabledOnTransitory");
const TCHAR c_szAsmKey[] =           TEXT("SOFTWARE\\Microsoft\\CTF\\Assemblies");
const TCHAR c_szCompartKey[] =       TEXT("SOFTWARE\\Microsoft\\CTF\\Compartment");
const TCHAR c_szGlobalCompartment[] = TEXT("GlobalCompartment");
const TCHAR c_szNonInit[] =          TEXT("NonInit");
const TCHAR c_szDefault[] =          TEXT("Default");
const TCHAR c_szProfile[] =          TEXT("Profile");
const WCHAR c_szProfileW[] =         L"Profile";
const TCHAR c_szDefaultAsmName[] =   TEXT("Default Assembly");
const TCHAR c_szUpdateProfile[] =    TEXT("UpdateProfile");
const TCHAR c_szAssembly[] =         TEXT("Assemblies");
const TCHAR c_szLanguageProfileKey[] = TEXT("LanguageProfile\\");
const TCHAR c_szSubstitutehKL[] =      TEXT("SubstituteLayout");
const TCHAR c_szKeyboardLayout[] =   TEXT("KeyboardLayout");
const WCHAR c_szIconFileW[] =        L"IconFile";
const TCHAR c_szIconIndex[] =        TEXT("IconIndex");
const WCHAR c_szIconIndexW[] =       L"IconIndex";
const TCHAR c_szShowStatus[] =       TEXT("ShowStatus");
const TCHAR c_szLabel[] =            TEXT("Label");
const TCHAR c_szTransparency[] =     TEXT("Transparency");
const TCHAR c_szExtraIconsOnMinimized[] =     TEXT("ExtraIconsOnMinimized");
const TCHAR c_szLocaleInfo[] =       TEXT("SYSTEM\\CurrentControlSet\\Control\\Nls\\Locale");
const TCHAR c_szLocaleInfoNT4[] =    TEXT("SYSTEM\\CurrentControlSet\\Control\\Nls\\Language");
const TCHAR c_szKeyboardLayoutKey[] =   TEXT("SYSTEM\\CurrentControlSet\\Control\\Keyboard Layouts\\");
const TCHAR c_szKbdUSNameNT[] =      TEXT("kbdus.dll");
const TCHAR c_szKbdUSName[] =        TEXT("kbdus.kbd");
const TCHAR c_szLayoutFile[] =       TEXT("layout file");
const TCHAR c_szIMEFile[] =          TEXT("IME file");
const TCHAR c_szRunInputCPLCmdLine[] =  TEXT("RunDll32.exe shell32.dll,Control_RunDLL %s");
const TCHAR c_szRunInputCPL[]        =  TEXT("input.cpl");
const TCHAR c_szRunInputCPLOnWin9x[] =  TEXT("input98.cpl");
const TCHAR c_szRunInputCPLOnNT51[]  =  TEXT("input.dll");
const TCHAR c_szHHEXELANGBARCHM[]    = TEXT("hh.exe langbar.chm");
const TCHAR c_szHHEXE[]              = TEXT("hh.exe");

// marshal window class
const TCHAR c_szCicMarshalClass[] = "CicMarshalWndClass";
const TCHAR c_szCicMarshalWnd[] = "CicMarshalWnd";
const TCHAR c_szAppCompat[] =       TEXT("SOFTWARE\\Microsoft\\CTF\\Compatibility\\");
const TCHAR c_szCompatibility[] = TEXT("Compatibility");
const TCHAR c_szCtfShared[] =  TEXT("SOFTWARE\\Microsoft\\CTF\\SystemShared\\");
const TCHAR c_szCUAS[] =  TEXT("CUAS");
const TCHAR c_szIMMKey[] = TEXT("Software\\Microsoft\\Windows NT\\CurrentVersion\\IMM");
const TCHAR c_szCUASIMEFile[] =  TEXT("IME File");

//+---------------------------------------------------------------------------
//
// CheckAnchorStores
//
//----------------------------------------------------------------------------

// if set TRUE, we don't ask for ITextStoreAnchor during context creation
BOOL g_fNoITextStoreAnchor = TRUE;

void CheckAnchorStores()
{
    HKEY hKeyCTF;
    DWORD cb;
    DWORD dwEnable;

    if (RegOpenKeyEx(HKEY_LOCAL_MACHINE, c_szCTFKey, NULL, KEY_READ, &hKeyCTF) != ERROR_SUCCESS)
        return;

    cb = sizeof(DWORD);

    if (RegQueryValueEx(hKeyCTF, TEXT("EnableAnchorContext"), NULL, NULL, (BYTE *)&dwEnable, &cb) == ERROR_SUCCESS &&
        cb == sizeof(DWORD) &&
        dwEnable == 1)
    {
        g_fNoITextStoreAnchor = FALSE;
    }

    RegCloseKey(hKeyCTF);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\ctf\uim\globals.h ===
//+---------------------------------------------------------------------------
//
//  File:       globals.h
//
//  Contents:   Global variable declarations.
//
//----------------------------------------------------------------------------

#ifndef GLOBALS_H
#define GLOBALS_H

#include "private.h"
#include "resource.h"
#include "ptrary.h"
#include "strary.h"
#include "cicmutex.h"
#include "tfpriv.h"
#include "ctflbui.h"

void CheckAnchorStores();
extern BOOL g_fNoITextStoreAnchor;

inline size_t Align(size_t a)
{
     //
     // Alignment width should be 8 BYTES for IA64 wow64 platform
     // even x86 build enviroment.
     //
     return (size_t) ((a + 7) & ~7);
}

#ifndef StringCopyArray
#define StringCopyArray(Dstr, Sstr)     StringCchCopy((Dstr), ARRAYSIZE(Dstr), (Sstr))
#endif

#ifndef StringCopyArrayA
#define StringCopyArrayA(Dstr, Sstr)    StringCchCopyA((Dstr), ARRAYSIZE(Dstr), (Sstr))
#endif

#ifndef StringCopyArrayW
#define StringCopyArrayW(Dstr, Sstr)    StringCchCopyW((Dstr), ARRAYSIZE(Dstr), (Sstr))
#endif

#ifndef StringCatArray
#define StringCatArray(Dstr, Sstr)     StringCchCat((Dstr), ARRAYSIZE(Dstr), (Sstr))
#endif

#ifndef StringCatArrayA
#define StringCatArrayA(Dstr, Sstr)    StringCchCatA((Dstr), ARRAYSIZE(Dstr), (Sstr))
#endif

#ifndef StringCatArrayW
#define StringCatArrayW(Dstr, Sstr)    StringCchCatW((Dstr), ARRAYSIZE(Dstr), (Sstr))
#endif


#define LANGIDFROMHKL(x) LANGID(LOWORD(HandleToLong(x)))

#define BACKDOOR_EDIT_COOKIE    ((DWORD)1) // 0 is TF_INVALID_EDIT_COOKIE

#define EC_MIN                  (BACKDOOR_EDIT_COOKIE + 1) // minimum value to avoid collisions with reserved values


//
// timer ids for marshaling window
//
#define MARSHALWND_TIMER_UPDATEKANACAPS      1
#define MARSHALWND_TIMER_NUIMGRDIRTYUPDATE   2
#define MARSHALWND_TIMER_WAITFORINPUTIDLEFORSETFOCUS   3

//
// alignment for platforms.
//
#define CIC_ALIGNMENT 7

extern TfGuidAtom g_gaApp;
extern TfGuidAtom g_gaSystem;

extern BOOL g_fCTFMONProcess;
extern BOOL g_fCUAS;
extern TCHAR g_szCUASImeFile[];

extern DWORD g_dwThreadDllMain;
#define ISINDLLMAIN() ((g_dwThreadDllMain == GetCurrentThreadId()) ? TRUE : FALSE)

extern CCicCriticalSectionStatic g_cs;
extern CCicCriticalSectionStatic g_csInDllMain;

#ifndef DEBUG

#define CicEnterCriticalSection(lpCriticalSection)  EnterCriticalSection(lpCriticalSection)

#else // DEBUG

extern const TCHAR *g_szMutexEnterFile;
extern int g_iMutexEnterLine;

//
// In debug, you can see the file/line number where g_cs was last entered
// by checking g_szMutexEnterFile and g_iMutexEnterLine.
//
#define CicEnterCriticalSection(lpCriticalSection)              \
{                                                               \
    Assert((g_dwThreadDllMain != GetCurrentThreadId()) ||       \
           (lpCriticalSection == (CRITICAL_SECTION *)g_csInDllMain));              \
                                                                \
    EnterCriticalSection(lpCriticalSection);                    \
                                                                \
    if (lpCriticalSection == (CRITICAL_SECTION *)g_cs)                             \
    {                                                           \
        g_szMutexEnterFile = __FILE__;                          \
        g_iMutexEnterLine = __LINE__;                           \
        /* need the InterlockedXXX to keep retail from optimizing away the assignment */ \
        InterlockedIncrement((long *)&g_szMutexEnterFile);      \
        InterlockedDecrement((long *)&g_szMutexEnterFile);      \
        InterlockedIncrement((long *)&g_iMutexEnterLine);       \
        InterlockedDecrement((long *)&g_iMutexEnterLine);       \
    }                                                           \
}

#endif // DEBUG

inline void CicLeaveCriticalSection(LPCRITICAL_SECTION lpCriticalSection)
{
    Assert((g_dwThreadDllMain != GetCurrentThreadId()) || 
           (lpCriticalSection == (CRITICAL_SECTION *)g_csInDllMain));

    LeaveCriticalSection(lpCriticalSection);
}

extern HKL g_hklDefault;

extern const GUID GUID_APPLICATION;
extern const GUID GUID_SYSTEM;

//
// application compatibility flag
//
//
#define CIC_COMPAT_NOWAITFORINPUTIDLEONWIN9X   0x00000001
#define CIC_COMPAT_DELAYFIRSTACTIVATEKBDLAYOUT 0x00000002
extern DWORD g_dwAppCompatibility;
#define CicTestAppCompat(x)   ((g_dwAppCompatibility & (x)) ? TRUE : FALSE)
extern BOOL InitAppCompatFlags();
extern void InitCUASFlag();

extern const TCHAR c_szCTFKey[];
extern const TCHAR c_szTIPKey[];
extern const TCHAR c_szCTFTIPKey[];
extern const TCHAR c_szLangBarKey[];
extern const WCHAR c_szDescriptionW[];
extern const WCHAR c_szMUIDescriptionW[];
extern const WCHAR c_szEnableW[];
extern const TCHAR c_szEnable[];
extern const TCHAR c_szDisabledOnTransitory[];
extern const TCHAR c_szAsmKey[];
extern const TCHAR c_szCompartKey[];
extern const TCHAR c_szGlobalCompartment[];
extern const TCHAR c_szNonInit[];
extern const TCHAR c_szDefault[];
extern const TCHAR c_szProfile[];
extern const WCHAR c_szProfileW[];
extern const TCHAR c_szDefaultAsmName[];
extern const TCHAR c_szUpdateProfile[];
extern const TCHAR c_szAssembly[];
extern const TCHAR c_szLanguageProfileKey[];
extern const TCHAR c_szSubstitutehKL[];
extern const TCHAR c_szKeybaordLayout[];
extern const WCHAR c_szIconFileW[];
extern const TCHAR c_szIconIndex[];
extern const WCHAR c_szIconIndexW[];
extern const TCHAR c_szShowStatus[];
extern const TCHAR c_szLabel[];
extern const TCHAR c_szTransparency[];
extern const TCHAR c_szExtraIconsOnMinimized[];
extern const TCHAR c_szLocaleInfo[];
extern const TCHAR c_szLocaleInfoNT4[];
extern const TCHAR c_szKeyboardLayout[];
extern const TCHAR c_szKeyboardLayoutKey[];
extern const TCHAR c_szKbdUSNameNT[];
extern const TCHAR c_szKbdUSName[];
extern const TCHAR c_szLayoutFile[];
extern const TCHAR c_szIMEFile[];
extern const TCHAR c_szRunInputCPLCmdLine[];
extern const TCHAR c_szRunInputCPL[];
extern const TCHAR c_szRunInputCPLOnWin9x[];
extern const TCHAR c_szRunInputCPLOnNT51[];
extern const TCHAR c_szCicMarshalClass[];
extern const TCHAR c_szCicMarshalWnd[];
extern const TCHAR c_szHHEXELANGBARCHM[];
extern const TCHAR c_szHHEXE[];
extern const TCHAR c_szAppCompat[];
extern const TCHAR c_szCompatibility[];
extern const TCHAR c_szCtfShared[];
extern const TCHAR c_szCUAS[];
extern const TCHAR c_szIMMKey[];
extern const TCHAR c_szCUASIMEFile[];


extern HINSTANCE g_hInst;
extern DWORD g_dwTLSIndex;

class CThreadInputMgr;
class CLangBarItemMgr;
class CLangBarMgr;
class CLBarItemCtrl;
class CLBarItemHelp;
class CLBarItemReconv;
class CLBarItemWin32IME;
class CLBarItemDeviceType;
class CDisplayAttributeMgr;
class CInputProcessorProfiles;
class CAssemblyList;
class CStub;
class CSharedHeap;
class CSharedBlock;
class CInputContext;
class CGlobalCompartmentMgr;

typedef struct tag_LANGBARADDIN {
    GUID  _guid;
    CLSID _clsid;
    ITfLangBarAddIn *_plbai;
    HINSTANCE _hInst;
    BOOL _fStarted : 1;
    BOOL _fEnabled : 1;
    WCHAR _wszFilePath[MAX_PATH];
} LANGBARADDIN;

typedef enum { COPY_ANCHORS, OWN_ANCHORS } AnchorOwnership;

typedef struct tag_TL_THREADINFO {
    DWORD dwThreadId;
    DWORD dwProcessId;
    DWORD dwFlags;

    //
    // handle of marshal worker window.
    //
    CAlignWinHandle<HWND>  hwndMarshal;

    //
    // now this thread is being called by Stub.
    //
    ULONG ulInMarshal;

    //
    // now this thread is waiting for marshaling reply from the thread.
    //
    DWORD dwMarshalWaitingThread;

    DWORD dwTickTime;

    //
    // Store the keyboard layout of console app here.
    //
    CAlignWinHKL  hklConsole;

} TL_THREADINFO;

typedef struct
{
    CThreadInputMgr *ptim;
    CLangBarItemMgr *plbim;
    CDisplayAttributeMgr *pdam;
    CInputProcessorProfiles *pipp;

    DWORD dwThreadId;
    DWORD dwProcessId;

    UINT uMsgRemoved;
    DWORD dwMsgTime;

    CAssemblyList *pAsmList;
    LANGID langidCurrent;
    LANGID langidPrev;
    BOOL bInImeNoImeToggle : 1;

    BOOL bLangToggleReady : 1;    // Lang hotkey toggle flag.
    BOOL bKeyTipToggleReady : 1;  // Lang hotkey toggle flag.
    int  nModalLangBarId;
    int  dwModalLangBarFlags;

    ULONG ulMshlCnt;
    HWND  hwndMarshal;

    CPtrArray<CStub> *prgStub;

    CSharedHeap *psheap;
    CPtrArray<CSharedBlock> *prgThreadMem;

    HKL hklDelayActive;
    HKL hklBeingActivated;

    //
    // delay focus DIM change.
    // Cicero saves the last focused window here in CBT hook. And actual
    // _SetFocus() will be done in TFPRIV_ONSETWIDOWFOCUS.
    //
    HWND hwndBeingFocused;
    BOOL fSetWindowFocusPosted : 1;

    BOOL fCTFMON : 1;
    BOOL fInmsgSetFocus : 1;
    BOOL fInmsgThreadItemChange : 1;
    BOOL fInmsgThreadTerminate : 1;
    BOOL fInActivateAssembly : 1;
    BOOL fInitCapsKanaIndicator : 1;
    BOOL fRemovingInputLangChangeReq : 1;
    BOOL fInitGlobalCompartment : 1;
    BOOL fStopImm32HandlerInHook : 1;
    BOOL fStopLangHotkeyHandlerInHook : 1;

    //
    // CUAS
    //
    BOOL fCUASInCtfImmLastEnabledWndDestroy : 1;
    BOOL fCUASNoVisibleWindowChecked : 1;
    BOOL fCUASInCreateDummyWnd : 1;
    BOOL fCUASDllDetachInOtherOrMe : 1;
    BOOL fUninitThreadOnShuttingDown : 1;
    BOOL fDeactivatingTIP : 1;

    ULONG uDestroyingMarshalWnd;

    TL_THREADINFO *pti;

    //
    // Workaround for global keyboard hook
    //
    HHOOK hThreadKeyboardHook;
    HHOOK hThreadMouseHook;

    //
    // For CH IME-NonIME toggle hotkey
    //
    LANGID langidPrevForCHHotkey;
    GUID   guidPrevProfileForCHHotkey;
    HKL   hklPrevForCHHotkey;

    DWORD _dwLockRequestICRef;
    DWORD _fLockRequestPosted;

    CGlobalCompartmentMgr *_pGlobalCompMgr;
    CAlignWinHandle<HWND>  hwndOleMainThread;

    CPtrArray<LANGBARADDIN> *prgLBAddIn;
    BOOL fLBAddInLoaded;

    ITfLangBarEventSink    *_pLangBarEventSink;
    DWORD                  _dwLangBarEventCookie;

} SYSTHREAD;

extern SYSTHREAD *GetSYSTHREAD();
extern SYSTHREAD *FindSYSTHREAD();
extern void FreeSYSTHREAD();

class CCatGUIDTbl;
extern CCatGUIDTbl *g_pCatGUIDTbl;

class CTimList;
extern CTimList g_timlist;

// registered messages
extern UINT g_msgPrivate;
extern UINT g_msgSetFocus;
extern UINT g_msgThreadTerminate;
extern UINT g_msgThreadItemChange;
extern UINT g_msgLBarModal;
extern UINT g_msgRpcSendReceive;
extern UINT g_msgThreadMarshal;
extern UINT g_msgCheckThreadInputIdel;
#ifdef POINTER_MARSHAL
extern UINT g_msgPointerMarshal;
#endif
extern UINT g_msgStubCleanUp;
extern UINT g_msgShowFloating;
extern UINT g_msgLBUpdate;
extern UINT g_msgNuiMgrDirtyUpdate;

extern HWND g_hwndLastForeground;
extern DWORD g_dwThreadLastFocus;

#define TF_S_GENERALPROPSTORE        MAKE_HRESULT(SEVERITY_SUCCESS, FACILITY_ITF, 0x0401)
#define TF_S_PROPSTOREPROXY          MAKE_HRESULT(SEVERITY_SUCCESS, FACILITY_ITF, 0x0402)

//
// default.cpp
//
extern LONG WINAPI CicExceptionFilter(struct _EXCEPTION_POINTERS *pExceptionInfo);
extern CAssemblyList *EnsureAssemblyList(SYSTHREAD *psfn, BOOL fUpdate = FALSE);
extern LANGID GetCurrentAssemblyLangId(SYSTHREAD *psfn);
extern void SetCurrentAssemblyLangId(SYSTHREAD *psfn, LANGID langid);
extern BOOL TF_InitThreadSystem(void);
extern BOOL TF_UninitThreadSystem(void);
extern void UninitProcess();
extern BOOL OnForegroundChanged(HWND hwndFocus);
extern void OnIMENotify();
extern void KanaCapsUpdate(SYSTHREAD *psfn);
extern void StartKanaCapsUpdateTimer(SYSTHREAD *psfn);
BOOL InitUniqueString();
void GetDesktopUniqueName(const TCHAR *pszPrefix, TCHAR *pch, ULONG cchPch);
BOOL IsMsctfEnabledUser();

#define GetDesktopUniqueNameArray(prefix, buf)    \
GetDesktopUniqueName((prefix), buf, ARRAYSIZE(buf));

//
// ithdmshl.cpp and focusnfy.cpp
//
void SetFocusNotifyHandler(UINT uMsg, WPARAM wParam, LPARAM lParam);
void MakeSetFocusNotify(UINT uMsg, WPARAM wParam, LPARAM lParam);
void SetModalLBarSink(DWORD dwTargetThreadId, BOOL fSet, DWORD dwFlags);
void SetModalLBarId(int nId, DWORD dwFlags);
BOOL HandleModalLBar(UINT uMsg, WPARAM wParam, LPARAM lParam);
BOOL DispatchModalLBar(WPARAM wParam, LPARAM lParam);
HRESULT ThreadGetItemFloatingRect(DWORD dwThreadId, REFGUID rguid, RECT *prc);
BOOL InitSharedHeap();
BOOL DestroySharedHeap();
BOOL IsCTFMONBusy();
BOOL IsInPopupMenuMode();

//
// nuihkl.cpp
//
BOOL GetFontSig(HWND hwnd, HKL hKL);
void PostInputLangRequest(SYSTHREAD *psfn, HKL hkl, BOOL fUsePost);
void FlushIconIndex(SYSTHREAD *psfn);

//
// imelist.h
//
BOOL InitProfileRegKeyStr(char *psz, ULONG cchMax, REFCLSID rclsid, LANGID langid, REFGUID guidProfile);

#include "catmgr.h"
inline BOOL MyIsEqualTfGuidAtom(TfGuidAtom guidatom, REFGUID rguid)
{
    BOOL fEqual;

    CCategoryMgr::s_IsEqualTfGuidAtom(guidatom, rguid, &fEqual);

    return fEqual;
}

inline HRESULT MyGetGUID(TfGuidAtom guidatom, GUID *pguid)
{
    return CCategoryMgr::s_GetGUID(guidatom, pguid);
}

inline HRESULT MyRegisterCategory(REFGUID rcatid, REFGUID rguid)
{
    return CCategoryMgr::s_RegisterCategory(GUID_SYSTEM, rcatid, rguid);
}

inline HRESULT MyUnregisterCategory(REFGUID rcatid, REFGUID rguid)
{
    return CCategoryMgr::s_UnregisterCategory(GUID_SYSTEM, rcatid, rguid);
}

inline HRESULT MyRegisterGUID(REFGUID rguid, TfGuidAtom *pguidatom)
{
    return CCategoryMgr::s_RegisterGUID(rguid, pguidatom);
}

inline HRESULT MyRegisterGUIDDescription(REFGUID rguid, WCHAR *psz)
{
    return CCategoryMgr::s_RegisterGUIDDescription(GUID_SYSTEM, rguid, psz);
}

inline HRESULT MyUnregisterGUIDDescription(REFGUID rguid)
{
    return CCategoryMgr::s_UnregisterGUIDDescription(GUID_SYSTEM, rguid);
}

inline HRESULT MyGetGUIDDescription(REFGUID rguid, BSTR *pbstr)
{
    return CCategoryMgr::s_GetGUIDDescription(rguid, pbstr);
}

inline HRESULT MyGetGUIDValue(REFGUID rguid, const WCHAR *psz, BSTR *pbstr)
{
    return CCategoryMgr::s_GetGUIDValue(rguid, psz, pbstr);
}

inline HRESULT MyRegisterGUIDDWORD(REFGUID rguid, DWORD dw)
{
    return CCategoryMgr::s_RegisterGUIDDWORD(GUID_SYSTEM, rguid, dw);
}

inline HRESULT MyUnregisterGUIDDWORD(REFGUID rguid)
{
    return CCategoryMgr::s_UnregisterGUIDDWORD(GUID_SYSTEM, rguid);
}

inline HRESULT MyGetGUIDDWORD(REFGUID rguid, DWORD *pdw)
{
    return CCategoryMgr::s_GetGUIDDWORD(rguid, pdw);
}

inline BOOL MyIsValidGUIDATOM(TfGuidAtom guidatom)
{
    return CCategoryMgr::s_IsValidGUIDATOM(guidatom);
}

inline HRESULT MyEnumItemsInCategory(REFGUID rcatid, IEnumGUID **ppEnum)
{
    return CCategoryMgr::s_EnumItemsInCategory(rcatid, ppEnum);
}

typedef struct tag_LBESLASTMSG {
   UINT uMsg;
   CAlignPointer<WPARAM> wParam;
   CAlignPointer<LPARAM> lParam;
} LBESLASTMSG;

typedef struct tag_LBAREVENTSINK {
   DWORD                  m_dwProcessId;
   DWORD                  m_dwThreadId;
   DWORD                  m_dwCookie;
   DWORD                  m_dwLangBarFlags;
   DWORD                  m_dwFlags;
   CAlignWinHandle<HWND>  m_hWnd;       // window handle to avoid notification.
   LBESLASTMSG            m_lastmsg;
} LBAREVENTSINK;

typedef struct tag_LBAREVENTSINKLOCAL {
   ITfLangBarEventSink* m_pSink;
   LBAREVENTSINK lb;
} LBAREVENTSINKLOCAL;

#define LBESF_INUSE              0x00000001
#define LBESF_SETFOCUSINQUEUE    0x00000002

extern CStructArray<LBAREVENTSINKLOCAL> *g_rglbes;


extern BOOL g_fDllProcessDetached;
extern BOOL g_bOnWow64;

typedef struct {
   BOOL   m_fInUse;
   DWORD  m_dwThreadId;
   DWORD  m_dwSrcThreadId;
   GUID   m_iid;
   CAlignPointer<LRESULT>  m_ref;
   union {
       DWORD    m_dwType;
       struct {
            //
            // IUnknown pointer used only own process.
            // Other process distingush exists interface.
            //
            CNativeOrWow64_Pointer<IUnknown*> m_punk;

            ULONG    m_ulStubId;
            DWORD    m_dwStubTime;
       };
   };
   TCHAR m_szName[_MAX_PATH];
   TCHAR m_szNameConnection[_MAX_PATH];
} THREADMARSHALINTERFACEDATA;

#define CBBUFFERSIZE       0x80 // 0x80 is enough for NUI manager

typedef struct {
   BOOL  m_fInUse;
   DWORD m_dwSize;
   BYTE  m_bBuffer[CBBUFFERSIZE];
} BUFFER, *PBUFFER;


//
// All shared memory for msctf.dll must live in this struct, it will
// be stored in a filemapping.
//
// Use GetSharedMemory()->myData to access shared memory.
//

typedef struct
{
    //
    // Issue:
    //
    // max number of the threads that can initialize marshaled interface same time.
    // 5 is enough??
    //
    #define NUM_TMD 5

    THREADMARSHALINTERFACEDATA tmd[NUM_TMD];

    //
    // The current focus thread, proccess and foreground window.
    //
    DWORD dwFocusThread;
    DWORD dwFocusProcess;
    CAlignWinHandle<HWND> hwndForeground;

    //
    // The previous focus thread, proccess and foreground window.
    //
    DWORD dwFocusThreadPrev;
    CAlignWinHandle<HWND> hwndForegroundPrev;


    //
    // The last thread of ITfThreadFocusSink
    //
    DWORD dwLastFocusSinkThread;

    //
    // Native/WOW6432 system hook
    //
    CNativeOrWow64_WinHandle<HHOOK> hSysShellHook;

    CNativeOrWow64_WinHandle<HHOOK> hSysGetMsgHook;
    CNativeOrWow64_WinHandle<HHOOK> hSysCBTHook;

    //
    // track shell hook WINDOWACTIVATE
    //
    BOOL fInFullScreen;

    //
    // Issue:
    //
    // we must take care of more Sinks.
    //
    #define MAX_LPES_NUM 5

    LBAREVENTSINK lbes[MAX_LPES_NUM];
    DWORD         dwlbesCookie;


    LONG    cProcessesMinus1;
    CAlignWinHandle<HANDLE>  hheapShared;    // Only use on Windows95/98 platform

    // MSAA activation ref count
    LONG    cMSAARef; // inited to -1 for win95 InterlockedIncrement compat

    DWORD dwPrevShowFloatingStatus;
} SHAREMEM;

class CCiceroSharedMem : public CCicFileMappingStatic
{
public:
    BOOL Start()
    {
        BOOL fAlreadyExists;
        TCHAR ach[MAX_PATH];

        GetDesktopUniqueName(TEXT("CiceroSharedMem"), ach, ARRAYSIZE(ach));

        Init(ach, NULL);
        // Init(TEXT("CiceroSharedMem"), NULL);

        if (Create(NULL, sizeof(SHAREMEM), &fAlreadyExists) == NULL)
            return FALSE;

        if (!fAlreadyExists)
        {
            // by default, every member initialize to 0

            // initialize other members here
            ((SHAREMEM *)_pv)->cProcessesMinus1 = -1;
            ((SHAREMEM *)_pv)->cMSAARef = -1;
        }

        return TRUE;
    }

    SHAREMEM *GetPtr() { return (SHAREMEM *)_pv; }

private:
};

extern CCiceroSharedMem g_SharedMemory;

inline SHAREMEM *GetSharedMemory() { return g_SharedMemory.GetPtr(); }
inline BOOL      IsSharedMemoryCreated() { return g_SharedMemory.IsCreated(); }

inline BOOL IsChinesePlatform()
{
    if (g_uACP == 936) 
        return TRUE;

    if (g_uACP == 950) 
        return TRUE;

    return FALSE;
}

#endif // GLOBALS_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\ctf\uim\hotkey.cpp ===
//
// hotkey.cpp
//

#include "private.h"
#include "tim.h"
#include "dim.h"
#include "ic.h"
#include "hotkey.h"
#include "nuictrl.h"
#include "nuihkl.h"
#include "cregkey.h"
#include "ime.h"
#include "ctffunc.h"
#include "profiles.h"


#define TF_MOD_ALL (TF_MOD_ALT |                    \
                    TF_MOD_CONTROL |                \
                    TF_MOD_SHIFT |                  \
                    TF_MOD_RALT |                   \
                    TF_MOD_RCONTROL |               \
                    TF_MOD_RSHIFT |                 \
                    TF_MOD_LALT |                   \
                    TF_MOD_LCONTROL |               \
                    TF_MOD_LSHIFT |                 \
                    TF_MOD_ON_KEYUP |               \
                    TF_MOD_IGNORE_ALL_MODIFIER |    \
                    TF_MOD_WIN |                    \
                    TF_MOD_LWIN |                   \
                    TF_MOD_RWIN)

static const TCHAR c_szKbdToggleKey[]  = TEXT("Keyboard Layout\\Toggle");
static const TCHAR c_szHotKey[] = TEXT("Control Panel\\Input Method\\Hot Keys");
static const TCHAR c_szModifiers[] = TEXT("Key Modifiers");
static const TCHAR c_szVKey[] = TEXT("Virtual Key");

UINT g_uLangHotKeyModifiers = 0;
UINT g_uLangHotKeyVKey[2] = {0,0};
UINT g_uKeyTipHotKeyModifiers = 0;
UINT g_uKeyTipHotKeyVKey[2] = {0,0};
UINT g_uModifiers = 0;

#define CHSLANGID MAKELANGID(LANG_CHINESE, SUBLANG_CHINESE_SIMPLIFIED)
#define CHTLANGID MAKELANGID(LANG_CHINESE, SUBLANG_CHINESE_TRADITIONAL)

//
// default IMM32 hotkeys.
//
// we use these default hotkey values if there is no entry in
// HKCU\Control Panel\Input Method\Hot Keys.
//
//

IMM32HOTKEY   g_ImmHotKeys411[] = {
 {IME_JHOTKEY_CLOSE_OPEN             , VK_KANJI, TF_MOD_IGNORE_ALL_MODIFIER, FALSE},
 {0                                  ,  0,  0, FALSE}
};

IMM32HOTKEY   g_ImmHotKeys412[] = {
 {IME_KHOTKEY_SHAPE_TOGGLE           , -1, -1, FALSE},
 {IME_KHOTKEY_HANJACONVERT           , -1, -1, FALSE},
 {IME_KHOTKEY_ENGLISH                , -1, -1, FALSE},
 {0                                  ,  0,  0, FALSE}
};

IMM32HOTKEY   g_ImmHotKeys804[] = {
 {IME_CHOTKEY_IME_NONIME_TOGGLE      , VK_SPACE, TF_MOD_CONTROL, FALSE},
 {IME_CHOTKEY_SHAPE_TOGGLE           , VK_SPACE, TF_MOD_SHIFT,   FALSE},
 {IME_CHOTKEY_SYMBOL_TOGGLE          , -1, -1, FALSE},
 {0                                  ,  0,  0, FALSE}
};

IMM32HOTKEY   g_ImmHotKeys404[] = {
 {IME_THOTKEY_IME_NONIME_TOGGLE      , VK_SPACE, TF_MOD_CONTROL, FALSE},
 {IME_THOTKEY_SHAPE_TOGGLE           , VK_SPACE, TF_MOD_SHIFT,   FALSE},
 {IME_THOTKEY_SYMBOL_TOGGLE          , -1, -1, FALSE},
 {IME_ITHOTKEY_RESEND_RESULTSTR      , -1, -1, FALSE},
 {IME_ITHOTKEY_PREVIOUS_COMPOSITION  , -1, -1, FALSE},
 {IME_ITHOTKEY_UISTYLE_TOGGLE        , -1, -1, FALSE},
 {IME_ITHOTKEY_RECONVERTSTRING       , -1, -1, FALSE},
 {0                                  ,  0,  0, FALSE}
};

//////////////////////////////////////////////////////////////////////////////
//
// CAsyncProcessHotKeyQueueItem
//
//////////////////////////////////////////////////////////////////////////////

class CAsyncProcessHotKeyQueueItem : public CAsyncQueueItem
{
public:
    CAsyncProcessHotKeyQueueItem(WPARAM wParam, LPARAM lParam, TimSysHotkey tsh, BOOL fTest, BOOL fSync) : CAsyncQueueItem(fSync)
    {
        _wParam = wParam;
        _lParam = lParam;
        _tsh = tsh;
        _fTest = fTest;
    }

    HRESULT DoDispatch(CInputContext *pic)
    {
        CThreadInputMgr *ptim = CThreadInputMgr::_GetThis();
        if (!ptim)
        {
            Assert(0);
            return E_FAIL;
        }

        ptim->_SyncProcessHotKey(_wParam, _lParam, _tsh, _fTest);
        return S_OK;
    }

private:
    WPARAM _wParam;
    LPARAM _lParam;
    TimSysHotkey _tsh;
    BOOL _fTest;
};

//////////////////////////////////////////////////////////////////////////////
//
// MSCTF default hotkeys.
//
//////////////////////////////////////////////////////////////////////////////

typedef struct tag_DEFAULTHOTKEY
{
    const GUID   *pguid;
    UINT         uId;
    TF_PRESERVEDKEY prekey;
    TfGuidAtom   guidatom;
} DEFAULTHOTKEY;

/* 61847d8e-29ff-11d4-97a9-00105a2799b5 */
const GUID GUID_DEFHOTKEY_CORRECTION = { 
    0x61847d8e,
    0x29ff,
    0x11d4,
    {0x97, 0xa9, 0x00, 0x10, 0x5a, 0x27, 0x99, 0xb5}
  };

/* 61847d8f-29ff-11d4-97a9-00105a2799b5 */
const GUID GUID_DEFHOTKEY_VOICE = { 
    0x61847d8f,
    0x29ff,
    0x11d4,
    {0x97, 0xa9, 0x00, 0x10, 0x5a, 0x27, 0x99, 0xb5}
  };

/* 61847d90-29ff-11d4-97a9-00105a2799b5 */
const GUID GUID_DEFHOTKEY_TOGGLE = { 
    0x61847d90,
    0x29ff,
    0x11d4,
    {0x97, 0xa9, 0x00, 0x10, 0x5a, 0x27, 0x99, 0xb5}
  };

/* 61847d91-29ff-11d4-97a9-00105a2799b5 */
const GUID GUID_DEFHOTKEY_HANDWRITE = {
    0x61847d91,
    0x29ff,
    0x11d4,
    {0x97, 0xa9, 0x00, 0x10, 0x5a, 0x27, 0x99, 0xb5}
  };

#define DHID_CORRECTION 0
#define DHID_VOICE      1
#define DHID_TOGGLE     2
#define DHID_HANDWRITE  3
#define DEFHOTKEYNUM    4

DEFAULTHOTKEY g_DefHotKeys[] = {
    {&GUID_DEFHOTKEY_CORRECTION,  DHID_CORRECTION, {'C',TF_MOD_WIN}, TF_INVALID_GUIDATOM},
    {&GUID_DEFHOTKEY_VOICE,       DHID_VOICE,      {'V',TF_MOD_WIN}, TF_INVALID_GUIDATOM},
    {&GUID_DEFHOTKEY_TOGGLE,      DHID_TOGGLE,     {'T',TF_MOD_WIN}, TF_INVALID_GUIDATOM},
    {&GUID_DEFHOTKEY_HANDWRITE,   DHID_HANDWRITE,  {'H',TF_MOD_WIN}, TF_INVALID_GUIDATOM},
};


//+---------------------------------------------------------------------------
//
// InitDefaultHotkeys
//
//----------------------------------------------------------------------------

HRESULT CThreadInputMgr::InitDefaultHotkeys()
{
    int i;
   
    for (i = 0; i < DEFHOTKEYNUM; i++)
    {
        CHotKey *pHotKey;
        HRESULT hr;
        hr = InternalPreserveKey(NULL, 
                            *g_DefHotKeys[i].pguid,
                            &g_DefHotKeys[i].prekey,
                            NULL, 0, 0, &pHotKey);

        if (SUCCEEDED(hr) && pHotKey)
            g_DefHotKeys[i].guidatom = pHotKey->_guidatom;
    }
    return S_OK;
}

//+---------------------------------------------------------------------------
//
// UninitDefaultHotkeys
//
//----------------------------------------------------------------------------

HRESULT CThreadInputMgr::UninitDefaultHotkeys()
{
    int i;
    for (i = 0; i < DEFHOTKEYNUM; i++)
    {
        UnpreserveKey(*g_DefHotKeys[i].pguid,
                      &g_DefHotKeys[i].prekey);
    }
    return S_OK;
}

//+---------------------------------------------------------------------------
//
// PreserveKey
//
//----------------------------------------------------------------------------

HRESULT CThreadInputMgr::PreserveKey(TfClientId tid, REFGUID rguid, const TF_PRESERVEDKEY *pprekey, const WCHAR *pchDesc, ULONG cchDesc)
{
    CTip *ctip;

    if (!_GetCTipfromGUIDATOM(tid, &ctip))
        return E_INVALIDARG;

    return InternalPreserveKey(ctip, rguid, pprekey, pchDesc, cchDesc, 0, NULL);
}

//+---------------------------------------------------------------------------
//
// PreserveKeyEx
//
//----------------------------------------------------------------------------

HRESULT CThreadInputMgr::PreserveKeyEx(TfClientId tid, REFGUID rguid, const TF_PRESERVEDKEY *pprekey, const WCHAR *pchDesc, ULONG cchDesc, DWORD dwFlags)
{
    CTip *ctip;

    if (!_GetCTipfromGUIDATOM(tid, &ctip))
        return E_INVALIDARG;

    return InternalPreserveKey(ctip, rguid, pprekey, pchDesc, cchDesc, dwFlags, NULL);
}

//+---------------------------------------------------------------------------
//
// InternalPreserveKey
//
//----------------------------------------------------------------------------

HRESULT CThreadInputMgr::InternalPreserveKey(CTip *ctip, REFGUID rguid, const TF_PRESERVEDKEY *pprekey, const WCHAR *pchDesc, ULONG cchDesc, DWORD dwFlags, CHotKey **ppHotKey)
{
    CHotKey *pHotKey = NULL;
    int nCnt;
    HRESULT hr = E_FAIL;

    if (!pprekey)
        return E_INVALIDARG;

    if (pprekey->uVKey > 0xff)
    {
        hr =  E_INVALIDARG;
        goto Exit;
    }

    if (ctip && _IsThisHotKey(ctip->_guidatom, pprekey))
    {
        hr =  TF_E_ALREADY_EXISTS;
        goto Exit;
    }

    if (!(pHotKey = new CHotKey()))
    {
        hr = E_OUTOFMEMORY;
        goto Exit;
    }

    if (!pHotKey->Init(ctip ? ctip->_guidatom : g_gaSystem, pprekey, rguid, dwFlags))
    {
        hr = E_FAIL;
        goto Exit;
    }

    if (!pHotKey->SetDesc(pchDesc, cchDesc))
    {
        hr = E_OUTOFMEMORY;
        goto Exit;
    }

    if (!_rgHotKey[pprekey->uVKey])
    {
        if (!(_rgHotKey[pprekey->uVKey] = new CPtrArray<CHotKey>))
        {
            hr = E_OUTOFMEMORY;
            goto Exit;
        }
    }

    //
    // Insert this to VKey list
    //
    nCnt = _rgHotKey[pprekey->uVKey]->Count();
    if (!_rgHotKey[pprekey->uVKey]->Insert(nCnt, 1))
    {
        hr = E_OUTOFMEMORY;
        goto Exit;
    }
    _rgHotKey[pprekey->uVKey]->Set(nCnt, pHotKey);

    //
    // Insert this to CTip list
    //
    if (ctip)
    {
        nCnt = ctip->_rgHotKey.Count();
        if (!ctip->_rgHotKey.Insert(nCnt, 1))
        {
            hr = E_OUTOFMEMORY;
            goto Exit;
        }
        ctip->_rgHotKey.Set(nCnt, pHotKey);
    }

    hr = S_OK;
    _OnPreservedKeyUpdate(pHotKey);

Exit:
    if (pHotKey && (hr != S_OK))
    {
        delete pHotKey;
    }

    if (ppHotKey)
        *ppHotKey = (hr == S_OK) ? pHotKey : NULL;

    return hr;
}

//+---------------------------------------------------------------------------
//
// _IsThisHotKey
//
//----------------------------------------------------------------------------

BOOL CThreadInputMgr::_IsThisHotKey(TfClientId tid, const TF_PRESERVEDKEY *pprekey)
{
    int nCnt;
    int i;

    if (!_rgHotKey[pprekey->uVKey])
        return FALSE;
    
    nCnt = _rgHotKey[pprekey->uVKey]->Count();
    for (i = 0; i < nCnt; i++)
    {
        CHotKey *pHotKey;
        pHotKey = _rgHotKey[pprekey->uVKey]->Get(i);
        Assert(pHotKey);
        Assert(pHotKey->_prekey.uVKey == pprekey->uVKey);

        if (!pHotKey->IsValidTID(tid))
            continue;

        if (pHotKey->_prekey.uModifiers == pprekey->uModifiers)
            return TRUE;
    }

    return FALSE;
}

//+---------------------------------------------------------------------------
//
// UnregisterHotKey
//
//----------------------------------------------------------------------------

HRESULT CThreadInputMgr::UnpreserveKey(REFGUID rguid, const TF_PRESERVEDKEY *pprekey)
{
    int i;
    BOOL bFound = FALSE;
    HRESULT hr = CONNECT_E_NOCONNECTION;
    CTip *ctip = NULL;
    TfGuidAtom guidatom;
    CHotKey *pHotKey = NULL;
    int nCnt;

    if (FAILED(MyRegisterGUID(rguid, &guidatom)))
        return E_INVALIDARG;

    if (!_rgHotKey[pprekey->uVKey])
        return hr;

    nCnt = _rgHotKey[pprekey->uVKey]->Count();
    Assert(nCnt); // this should not be 0.

    for (i = 0; i < nCnt; i++)
    {
        pHotKey = _rgHotKey[pprekey->uVKey]->Get(i);

        if (pHotKey->_guidatom == guidatom)
        {
            //
            // Remove this from VKey list.
            //
            _rgHotKey[pprekey->uVKey]->Remove(i, 1);

            if (!ctip && (pHotKey->GetTID() != g_gaSystem))
                _GetCTipfromGUIDATOM(pHotKey->GetTID(), &ctip);

            //
            // Remove this from CTip list.
            //
            if (ctip)
            {
                int nCntTid = ctip->_rgHotKey.Count();
                int k;
                for (k = 0; k < nCntTid; k++)
                {
                    if (pHotKey == ctip->_rgHotKey.Get(k))
                    {
                         ctip->_rgHotKey.Remove(k, 1);
                         break;
                    }
                }
            }

            // 
            // if there is no hotkey in this vkey, delete ptrary.
            // 
            if (!_rgHotKey[pprekey->uVKey]->Count())
            {
                delete _rgHotKey[pprekey->uVKey];
                _rgHotKey[pprekey->uVKey] = NULL;
            }

            // 
            // make a notification.
            // 
            _OnPreservedKeyUpdate(pHotKey);

            // 
            // delete it.
            // 
            delete pHotKey;

            hr = S_OK;
            break;
        }
    }

    return hr;
}


//+---------------------------------------------------------------------------
//
// _ProcessHotKey
//
//----------------------------------------------------------------------------

BOOL CThreadInputMgr::_ProcessHotKey(WPARAM wParam, LPARAM lParam, TimSysHotkey tsh, BOOL fTest, BOOL fSync)
{
    UINT uVKey = (UINT)wParam & 0xff;
    CAsyncProcessHotKeyQueueItem *pAsyncProcessHotKeyQueueItem;
    CHotKey *pHotKey;
    BOOL bRet;
    HRESULT hr;

    if (!_rgHotKey[uVKey])
        return FALSE;
    
    if (!_FindHotKeyByTID(TF_INVALID_GUIDATOM, 
                          wParam, 
                          lParam, 
                          &pHotKey, 
                          tsh, 
                          g_uModifiers))
        return FALSE;

    if (!pHotKey)
        return FALSE;

    if (!pHotKey->IsNoDimNeeded() && !_pFocusDocInputMgr)
        return FALSE;

    if (!_pFocusDocInputMgr || (_pFocusDocInputMgr->_GetCurrentStack() < 0))
    {
        //
        // we may need to invoke system hotkey under Empty DIM.
        //
        BOOL fEaten = FALSE;

        if (fTest)
            fEaten = TRUE;
        else
        {
            GUID guid;
            if (SUCCEEDED(MyGetGUID(pHotKey->_guidatom, &guid)))
                _CallSimulatePreservedKey(pHotKey, NULL, guid, &fEaten);
        }

        return fEaten;
    }

    //
    // Issue:
    //
    // We don't know which IC in the focus DIM will handle the hotkey yet.
    // because the selection is changed by the application so we need to get ec
    // to update the current selection pos. We do call GetSelection
    // inside the root IC's lock. So it might be failed if hotkey's target
    // is TOP IC.
    //
    CInputContext *pic = _pFocusDocInputMgr->_GetIC(0);

    pAsyncProcessHotKeyQueueItem = new CAsyncProcessHotKeyQueueItem(wParam, lParam, tsh, fTest, fSync);
    if (!pAsyncProcessHotKeyQueueItem)
        return FALSE;
    
    hr = S_OK;

    bRet = TRUE;
    if ((pic->_QueueItem(pAsyncProcessHotKeyQueueItem->GetItem(), FALSE, &hr) != S_OK) || FAILED(hr))
    {
        Assert(0);
        bRet = FALSE;
    }

    pAsyncProcessHotKeyQueueItem->_Release();
    return bRet;
}

//+---------------------------------------------------------------------------
//
// _SyncProcessHotKey
//
//----------------------------------------------------------------------------

BOOL CThreadInputMgr::_SyncProcessHotKey(WPARAM wParam, LPARAM lParam, TimSysHotkey tsh, BOOL fTest)
{
    CHotKey *pHotKey;
    CInputContext *pic;
    UINT uVKey = (UINT)wParam & 0xff;
    BOOL fEaten = FALSE;

    if (!_pFocusDocInputMgr)
        return FALSE;

    if (!_rgHotKey[uVKey])
        return FALSE;

    if (_FindHotKeyAndIC(wParam, lParam, &pHotKey, &pic, tsh, g_uModifiers))
    {
        if (fTest)
            fEaten = TRUE;
        else
        {
            GUID guid;
            if (SUCCEEDED(MyGetGUID(pHotKey->_guidatom, &guid)))
                _CallSimulatePreservedKey(pHotKey, pic,  guid, &fEaten);
        }
    }

    return fEaten;
}

//+---------------------------------------------------------------------------
//
// _FindHotKeyByTiD
//
//----------------------------------------------------------------------------

BOOL CThreadInputMgr::_FindHotKeyByTID(TfClientId tid, WPARAM wParam, LPARAM lParam, CHotKey **ppHotKey, TimSysHotkey tsh, UINT uModCurrent)
{
    UINT uVKey = (UINT)wParam & 0xff;
    int nCnt;
    int i;
    CHotKey *pHotKey;

    Assert(_rgHotKey[uVKey]);
    
    nCnt = _rgHotKey[uVKey]->Count();
    for (i = 0; i < nCnt; i++)
    {
        pHotKey = _rgHotKey[uVKey]->Get(i);
        Assert(pHotKey);
        Assert(pHotKey->_prekey.uVKey == uVKey);

        if ((tid != TF_INVALID_GUIDATOM) && !pHotKey->IsValidTID(tid))
            continue;

        switch (tsh)
        {
            case TSH_SYSHOTKEY:
                if (!pHotKey->IsSysHotkey())
                    continue;
                break;

            case TSH_NONSYSHOTKEY:
                if (pHotKey->IsSysHotkey())
                    continue;
                break;

            case TSH_DONTCARE:
                break;

            default:
                Assert(0);
                break;
        }

        if ((pHotKey->_prekey.uModifiers & TF_MOD_ON_KEYUP) != 
                       ((lParam & 0x80000000) ? (UINT)TF_MOD_ON_KEYUP : 0))
            continue;

        if (ModifiersCheck(uModCurrent, pHotKey->_prekey.uModifiers))
        {
            if (ppHotKey)
                *ppHotKey = pHotKey;
            return TRUE;
        }
    }

    return FALSE;
}

//+---------------------------------------------------------------------------
//
// _FindHotkeyIC
//
//----------------------------------------------------------------------------

BOOL CThreadInputMgr::_FindHotKeyAndIC(WPARAM wParam, LPARAM lParam, CHotKey **ppHotKey, CInputContext **ppic, TimSysHotkey tsh, UINT uModCurrent)
{
    int iStack;

    Assert(_pFocusDocInputMgr);

    iStack = _pFocusDocInputMgr->_GetCurrentStack();
    if (iStack < 0)
        return FALSE;

    while (iStack >= 0)
    {
        CInputContext *pic = _pFocusDocInputMgr->_GetIC(iStack);
        if (_FindHotKeyInIC(wParam, lParam, ppHotKey, pic, tsh, uModCurrent))
        { 
            if (ppic)
                *ppic = pic;
            return TRUE;
        }
        iStack--;
    }
    return FALSE;
}

//+---------------------------------------------------------------------------
//
// _FindHotkey
//
//----------------------------------------------------------------------------

BOOL CThreadInputMgr::_FindHotKeyInIC(WPARAM wParam, LPARAM lParam, CHotKey **ppHotKey, CInputContext *pic, TimSysHotkey tsh, UINT uModCurrent)
{
    TfClientId tid;

    pic->_UpdateKeyEventFilter();

    //
    // try left side of the selection.
    //
    if ((tid = pic->_gaKeyEventFilterTIP[LEFT_FILTERTIP]) != TF_INVALID_GUIDATOM)
    {
        if (_FindHotKeyByTID(tid, wParam, lParam, ppHotKey, tsh, uModCurrent))
        { 
            return TRUE;
        }
    }

    //
    // try right side of the selection.
    //
    if ((tid = pic->_gaKeyEventFilterTIP[RIGHT_FILTERTIP]) != TF_INVALID_GUIDATOM)
    {
        if (_FindHotKeyByTID(tid, wParam, lParam, ppHotKey, tsh, uModCurrent))
        {     
            return TRUE;
        }
    }

    //
    // try foreground tip.
    //
    if ((_tidForeground != TF_INVALID_GUIDATOM) || (tsh == TSH_SYSHOTKEY))
    {
        if (_FindHotKeyByTID(_tidForeground, wParam, lParam, ppHotKey, tsh, uModCurrent))
        { 
            return TRUE;
        }
    }

    //
    // we may have a system hotkey that matched with the wParm and lParam.
    //
    if (_FindHotKeyByTID(TF_INVALID_GUIDATOM, wParam, lParam, ppHotKey, TSH_SYSHOTKEY, uModCurrent))
    { 
        return TRUE;
    }

    return FALSE;
}

//+---------------------------------------------------------------------------
//
// CallKeyEventSink
//
//----------------------------------------------------------------------------

HRESULT CThreadInputMgr::_CallSimulatePreservedKey(CHotKey *pHotKey, CInputContext *pic, REFGUID rguid, BOOL *pfEaten)
{
    ITfKeyEventSink *pSink;
    CTip *ctip;

    //
    // This is tip's Preserved key.
    //
    if (pHotKey->GetTID() != g_gaSystem)
    {
        if (!pHotKey->IsNoDimNeeded() && !pic)
            return S_FALSE;

        if (!_GetCTipfromGUIDATOM(pHotKey->GetTID(), &ctip))
            return E_INVALIDARG;

        if (!(pSink = ctip->_pKeyEventSink))
            return S_FALSE;

        return pSink->OnPreservedKey(pic, rguid, pfEaten);
    }


    UINT uId = -1;
    int i;
    HRESULT hr = S_OK;

    for (i = 0; i < DEFHOTKEYNUM; i++)
    {
        if (g_DefHotKeys[i].guidatom == pHotKey->_guidatom)
        {
            uId = g_DefHotKeys[i].uId;
            break;
        }
    }

    switch (g_DefHotKeys[i].uId)
    {
        case DHID_CORRECTION:
            //
            // simulate Reconversion Button.
            //
            hr = AsyncReconversion();
            break;

        case DHID_VOICE:
            hr = MyToggleCompartmentDWORD(g_gaSystem, 
                                          GetGlobalComp(), 
                                          GUID_COMPARTMENT_SPEECH_OPENCLOSE,
                                          NULL);
            if (hr == S_OK)
                *pfEaten = TRUE;

            break;

        case DHID_HANDWRITE:
            hr = MyToggleCompartmentDWORD(g_gaSystem, 
                                          this,
                                          GUID_COMPARTMENT_HANDWRITING_OPENCLOSE,
                                          NULL);
            if (hr == S_OK)
                *pfEaten = TRUE;

            break;

        case DHID_TOGGLE:

            DWORD dwMicOn;

            if (FAILED(MyGetCompartmentDWORD(GetGlobalComp(), 
                                  GUID_COMPARTMENT_SPEECH_OPENCLOSE,
                                  &dwMicOn)))
            {
                hr = E_FAIL;
                break;
            }

            if ( dwMicOn )
            {
                DWORD dwSpeechStatus;
            
                if (FAILED(MyGetCompartmentDWORD(GetGlobalComp(), 
                                      GUID_COMPARTMENT_SPEECH_GLOBALSTATE,
                                      &dwSpeechStatus)))
                {
                    hr = E_FAIL;
                    break;
                }

                if ((dwSpeechStatus & (TF_DICTATION_ON | TF_COMMANDING_ON)) == 0 )
                {
                    // Both dictation and voice command are OFF
                    // After toggled, we set dictation ON.
                    dwSpeechStatus |= TF_DICTATION_ON;
                }
                else
                {
                    dwSpeechStatus ^= TF_DICTATION_ON;
                    dwSpeechStatus ^= TF_COMMANDING_ON;
                }

                hr = MySetCompartmentDWORD(g_gaSystem,
                                  GetGlobalComp(), 
                                  GUID_COMPARTMENT_SPEECH_GLOBALSTATE, 
                                  dwSpeechStatus);

            }

            if (hr == S_OK)
                *pfEaten = TRUE;

            break;

        default:
            Assert(0);
            hr = E_FAIL;
            break;
    }

    return hr;
}

//+---------------------------------------------------------------------------
//
// GetPreservedKey
//
//----------------------------------------------------------------------------

STDAPI CThreadInputMgr::GetPreservedKey(ITfContext *pic, const TF_PRESERVEDKEY *pprekey, GUID *pguid)
{
    CHotKey *pHotKey;
    CInputContext *pcic;
    HRESULT hr = S_FALSE; // we return S_FALE, if there is no proper keys.

    if (!pguid)
        return E_INVALIDARG;

    *pguid = GUID_NULL;

    if (!pprekey)
        return E_INVALIDARG;

    if (pprekey->uVKey >= ARRAYSIZE(_rgHotKey))
        return E_INVALIDARG;

    if (pprekey->uModifiers & ~TF_MOD_ALL)
        return E_INVALIDARG;

    if (!pic)
        return E_INVALIDARG;

    if (!(pcic = GetCInputContext(pic)))
        return E_INVALIDARG;

    if (!_rgHotKey[pprekey->uVKey])
        goto Exit;

    //
    // we always get KeyUp preserve key first.
    //
    if (_FindHotKeyInIC(pprekey->uVKey, 0x80000000, &pHotKey, pcic, TSH_DONTCARE,  pprekey->uModifiers))
    {
        hr = MyGetGUID(pHotKey->_guidatom, pguid);
    }
    else if (_FindHotKeyInIC(pprekey->uVKey, 0x0, &pHotKey, pcic, TSH_DONTCARE,  pprekey->uModifiers))
    {
        hr = MyGetGUID(pHotKey->_guidatom, pguid);
    }

Exit:
    SafeRelease(pcic);
    return hr;
}

//+---------------------------------------------------------------------------
//
// isPreservedKeyInfo
//
//----------------------------------------------------------------------------

STDAPI CThreadInputMgr::IsPreservedKey(REFGUID rguid, const TF_PRESERVEDKEY *pprekey, BOOL *pfRegistered)
{
    TfGuidAtom guidatom;
    int i;
    int nCnt;

    if (!pfRegistered)
        return E_INVALIDARG;

    *pfRegistered = FALSE;

    if (!pprekey)
        return E_INVALIDARG;

    if (pprekey->uVKey >= ARRAYSIZE(_rgHotKey))
        return E_INVALIDARG;

    if (pprekey->uModifiers & ~TF_MOD_ALL)
        return E_INVALIDARG;

    if (FAILED(MyRegisterGUID(rguid, &guidatom)))
        return E_FAIL;

    if (!_rgHotKey[pprekey->uVKey])
        return S_FALSE;
    
    nCnt = _rgHotKey[pprekey->uVKey]->Count();
    for (i = 0; i < nCnt; i++)
    {
        CHotKey *pHotKey = _rgHotKey[pprekey->uVKey]->Get(i);
        if ((guidatom == pHotKey->_guidatom) &&
            (pprekey->uModifiers == pHotKey->_prekey.uModifiers))
        {
            *pfRegistered = TRUE;
            return S_OK;
        }
    }

    return S_FALSE;
}

//+---------------------------------------------------------------------------
//
// GetPreservedKeyInfoInternal
//
//----------------------------------------------------------------------------

BOOL CThreadInputMgr::_GetFirstPreservedKey(REFGUID rguid, CHotKey **ppHotKey)
{
    UINT uVKey;
    TfGuidAtom guidatom;

    if (FAILED(MyRegisterGUID(rguid, &guidatom)))
        return FALSE;
    
    for (uVKey = 0; uVKey < 256; uVKey++)
    {
        int nCnt;
        int i;

        if (!_rgHotKey[uVKey])
            continue;

        nCnt = _rgHotKey[uVKey]->Count();
        for (i = 0; i < nCnt; i++)
        {
            CHotKey *pHotKey = _rgHotKey[uVKey]->Get(i);
            if (guidatom == pHotKey->_guidatom)
            {
                *ppHotKey = pHotKey;
                return TRUE;
            }
        }
    }

    return FALSE;
}

//+---------------------------------------------------------------------------
//
// SimulatePreservedKey
//
//----------------------------------------------------------------------------

STDAPI CThreadInputMgr::SimulatePreservedKey(ITfContext *pic, REFGUID rguid, BOOL *pfEaten)
{
    CInputContext *pcic;
    CHotKey *pHotKey;
    HRESULT hr;
  
    if (!pfEaten)
        return E_INVALIDARG;

    if (!(pcic = GetCInputContext(pic)))
        return E_INVALIDARG;

    hr = S_OK;
    *pfEaten = FALSE;

    if (_GetFirstPreservedKey(rguid, &pHotKey))
    {
        //
        // we always get KeyUp preserve key first.
        //
        if (_FindHotKeyInIC(pHotKey->_prekey.uVKey, 
                             0x80000000, 
                             NULL,
                             pcic, 
                             TSH_DONTCARE,  
                             pHotKey->_prekey.uModifiers))
        {
            hr = _CallSimulatePreservedKey(pHotKey, pcic, rguid, pfEaten);
        }
        else if (_FindHotKeyInIC(pHotKey->_prekey.uVKey, 
                                  0x0, 
                                  NULL,
                                  pcic, 
                                  TSH_DONTCARE,  
                                  pHotKey->_prekey.uModifiers))
        {
            hr = _CallSimulatePreservedKey(pHotKey, pcic, rguid, pfEaten);
        }

    }

    SafeRelease(pcic);
    return hr;
}

//+---------------------------------------------------------------------------
//
// _OnPreservedKeyUpdate
//
//----------------------------------------------------------------------------

HRESULT CThreadInputMgr::_OnPreservedKeyUpdate(CHotKey *pHotKey)
{
    CStructArray<GENERICSINK> *pSinks = _GetPreservedKeyNotifySinks();
    int i;

    //
    // we don't make a notification for system default hotkeys.
    //
    if (pHotKey->GetTID() == g_gaSystem)
        return S_OK;

    for (i = 0; i < pSinks->Count(); i++)
    {
        ((ITfPreservedKeyNotifySink *)pSinks->GetPtr(i)->pSink)->OnUpdated(&pHotKey->_prekey);
    }

    return S_OK;
}

//+---------------------------------------------------------------------------
//
// SetPreservedKeyDescription
//
//----------------------------------------------------------------------------

STDAPI CThreadInputMgr::SetPreservedKeyDescription(REFGUID rguid, const WCHAR *pchDesc, ULONG cchDesc)
{
    CHotKey *pHotKey;
    if (!_GetFirstPreservedKey(rguid, &pHotKey))
        return E_INVALIDARG;

    if (!pHotKey->SetDesc(pchDesc, cchDesc))
        return E_FAIL;

    _OnPreservedKeyUpdate(pHotKey);
    return S_OK;
}

//+---------------------------------------------------------------------------
//
// GetPreservedKeyDescription
//
//----------------------------------------------------------------------------

STDAPI CThreadInputMgr::GetPreservedKeyDescription(REFGUID rguid, BSTR *pbstrDesc)
{
    CHotKey *pHotKey;
    if (!_GetFirstPreservedKey(rguid, &pHotKey))
        return E_INVALIDARG;

    if (!pHotKey->GetDesc(pbstrDesc))
        return E_FAIL;

    return S_OK;
}

//////////////////////////////////////////////////////////////////////////////
//
// Static Functions
//
//////////////////////////////////////////////////////////////////////////////

#define IsAlt(u)     ((u & TF_MOD_ALT) ? 1 : 0)
#define IsShift(u)   ((u & TF_MOD_SHIFT) ? 1 : 0)
#define IsControl(u) ((u & TF_MOD_CONTROL) ? 1 : 0)
#define IsWin(u)     ((u & TF_MOD_WIN) ? 1 : 0)


#define CheckMod(m0, m1, mod)                                \
     if (m1 & TF_MOD_ ## mod ##)                             \
     {                                                       \
         if (!(m0 & TF_MOD_ ## mod ##))                      \
             return FALSE;                                   \
     }                                                       \
     else                                                    \
     {                                                       \
         if ((m1 ^ m0) & TF_MOD_RL ## mod ##)                \
             return FALSE;                                   \
     }                                             

//+---------------------------------------------------------------------------
//
// ModifiersCheck
//
//----------------------------------------------------------------------------
BOOL ModifiersCheck(UINT uModCurrent, UINT uMod)
{
     uMod &= ~TF_MOD_ON_KEYUP;

     if (uMod & TF_MOD_IGNORE_ALL_MODIFIER)
         return TRUE;

     if (uModCurrent == uMod)
         return TRUE;

     if (uModCurrent && !uMod)
         return FALSE;

     CheckMod(uModCurrent, uMod, ALT);
     CheckMod(uModCurrent, uMod, SHIFT);
     CheckMod(uModCurrent, uMod, CONTROL);
     CheckMod(uModCurrent, uMod, WIN);

     return TRUE;
}

//+---------------------------------------------------------------------------
//
// InitLangChangeHotKey
//
//----------------------------------------------------------------------------

BOOL InitLangChangeHotKey()
{
    CMyRegKey key;
    TCHAR sz[2] = TEXT("3");
    TCHAR sz2[2] = TEXT("3");

    if (key.Open(HKEY_CURRENT_USER, c_szKbdToggleKey, KEY_READ) == S_OK)
    {
        if (key.QueryValueCch(sz, TEXT("Language Hotkey"), ARRAYSIZE(sz)) != S_OK)
        {
            if (key.QueryValueCch(sz, IsOnNT() ? TEXT("Hotkey") : NULL, ARRAYSIZE(sz)) != S_OK)
            {
                sz[0] = TEXT('1');
                sz[1] = TEXT('\0');
            }

            if (PRIMARYLANGID(LANGIDFROMLCID(GetSystemDefaultLCID())) == LANG_CHINESE)
            {
                sz[0] = TEXT('1');
                sz[1] = TEXT('\0');
            }
        }
        if (key.QueryValueCch(sz2, TEXT("Layout Hotkey"), ARRAYSIZE(sz)) != S_OK)
        {
            if (lstrcmp(sz, TEXT("2")) == 0)
            {
                sz2[0] = TEXT('1');
                sz2[1] = TEXT('\0');
            }
            else
            {
                sz2[0] = TEXT('2');
                sz2[1] = TEXT('\0');
            }

            if (GetSystemMetrics(SM_MIDEASTENABLED))
            {
                sz2[0] = TEXT('3');
                sz2[1] = TEXT('\0');
            }
        }
    }

    //
    // if lang and layout hotkey is the same key, let's disable the layout hotkey
    //
    if (lstrcmp(sz, sz2) == 0)
    {
        if (lstrcmp(sz, TEXT("1")) == 0)
        {
            sz2[0] = TEXT('2');
            sz2[1] = TEXT('\0');
        }
        else if (lstrcmp(sz, TEXT("2")) == 0)
        {
            sz2[0] = TEXT('1');
            sz2[1] = TEXT('\0');
        }
        else
        {
            sz2[0] = TEXT('3');
            sz2[1] = TEXT('\0');
        }
    }

    CicEnterCriticalSection(g_csInDllMain);

    switch (sz[0])
    {
        case ( TEXT('1') ) :
        default:
        {
            g_uLangHotKeyModifiers = TF_MOD_ALT | TF_MOD_SHIFT;
            g_uLangHotKeyVKey[0] = VK_SHIFT;
            g_uLangHotKeyVKey[1] = VK_MENU;
            break;
        }
        case ( TEXT('2') ) :
        {
            g_uLangHotKeyModifiers = TF_MOD_CONTROL | TF_MOD_SHIFT;
            g_uLangHotKeyVKey[0] = VK_SHIFT;
            g_uLangHotKeyVKey[1] = VK_CONTROL;
            break;
        }
        case ( TEXT('3') ) :
        {
            g_uLangHotKeyModifiers = 0;
            g_uLangHotKeyVKey[0] = 0;
            g_uLangHotKeyVKey[1] = 0;
            break;
        }
        case ( TEXT('4') ) :
        {
            g_uLangHotKeyModifiers = 0;
            g_uLangHotKeyVKey[0] = CHAR_GRAVE;
            g_uLangHotKeyVKey[1] = 0;
            break;
        }
    }

    //
    // Set the layout switch hotkey.
    //
    switch (sz2[0])
    {
        case ( TEXT('1') ) :
        default:
        {
            g_uKeyTipHotKeyModifiers = TF_MOD_LALT | TF_MOD_SHIFT;
            g_uKeyTipHotKeyVKey[0] = VK_SHIFT;
            g_uKeyTipHotKeyVKey[1] = VK_MENU;
            break;
        }
        case ( TEXT('2') ) :
        {
            g_uKeyTipHotKeyModifiers = TF_MOD_CONTROL | TF_MOD_SHIFT;
            g_uKeyTipHotKeyVKey[0] = VK_SHIFT;
            g_uKeyTipHotKeyVKey[1] = VK_CONTROL;
            break;
        }
        case ( TEXT('3') ) :
        {
            g_uKeyTipHotKeyModifiers = 0;
            g_uKeyTipHotKeyVKey[0] = 0;
            g_uKeyTipHotKeyVKey[1] = 0;
            break;
        }
        case ( TEXT('4') ) :
        {
            g_uKeyTipHotKeyModifiers = 0;
            g_uKeyTipHotKeyVKey[0] = VK_GRAVE;
            g_uKeyTipHotKeyVKey[1] = 0;
            break;
        }
    }

    CicLeaveCriticalSection(g_csInDllMain);

    return TRUE;
}

//+---------------------------------------------------------------------------
//
// UpdateModifiers
//
//----------------------------------------------------------------------------

BOOL UpdateModifiers(WPARAM wParam, LPARAM lParam)
{
    SHORT sksMenu = GetKeyState(VK_MENU);
    SHORT sksCtrl = GetKeyState(VK_CONTROL);
    SHORT sksShft = GetKeyState(VK_SHIFT);
    SHORT sksLWin = GetKeyState(VK_LWIN);
    SHORT sksRWin = GetKeyState(VK_RWIN);

    CicEnterCriticalSection(g_cs);
    switch (wParam & 0xff)
    {
        case VK_MENU:
            if (sksMenu & 0x8000)
            {
                if (lParam & 0x01000000)
                    g_uModifiers |= (TF_MOD_RALT | TF_MOD_ALT);
                else
                    g_uModifiers |= (TF_MOD_LALT | TF_MOD_ALT);
            }
            break;

        case VK_CONTROL:
            if (sksCtrl & 0x8000)
            {
                if (lParam & 0x01000000)
                    g_uModifiers |= (TF_MOD_RCONTROL | TF_MOD_CONTROL);
                else
                    g_uModifiers |= (TF_MOD_LCONTROL | TF_MOD_CONTROL);
            }
            break;

        case VK_SHIFT:
            if (sksShft & 0x8000)
            {
                if (((lParam >> 16) & 0x00ff) == 0x36)
                    g_uModifiers |= (TF_MOD_RSHIFT | TF_MOD_SHIFT);
                else
                    g_uModifiers |= (TF_MOD_LSHIFT | TF_MOD_SHIFT);
            }
            break;

        case VK_LWIN:
            if (sksLWin & 0x8000)
                g_uModifiers |= (TF_MOD_LWIN | TF_MOD_WIN);
            break;

        case VK_RWIN:
            if (sksRWin & 0x8000)
                g_uModifiers |= (TF_MOD_RWIN | TF_MOD_WIN);
            break;
    }

    if (!(sksMenu & 0x8000))
        g_uModifiers &= ~TF_MOD_ALLALT;
    if (!(sksCtrl & 0x8000))
        g_uModifiers &= ~TF_MOD_ALLCONTROL;
    if (!(sksShft & 0x8000))
        g_uModifiers &= ~TF_MOD_ALLSHIFT;
    if (!(sksRWin & 0x8000))
        g_uModifiers &= ~TF_MOD_RWIN;
    if (!(sksLWin & 0x8000))
        g_uModifiers &= ~TF_MOD_LWIN;
    if (!(sksRWin & 0x8000) && !(sksLWin & 0x8000))
        g_uModifiers &= ~TF_MOD_WIN;

    CicLeaveCriticalSection(g_cs);

    return TRUE;
}

//+---------------------------------------------------------------------------
//
// IsInLangChangeHotkeyStatus
//
// This function check the current keyboard status is in LangChange hotkey.
// This will be a trigger to eat WM_INPUTLANGUAGECHANGEREQUEST that was
// genereated by System. This is a fallback code because sometimes we
// could not eat the message in CheckLangChangeHotKey() (inside keyboard hook).
//
//----------------------------------------------------------------------------

BOOL IsInLangChangeHotkeyStatus()
{
    //
    // we don't need this hack on NT.
    //
    if (IsOnNT())
        return FALSE;


    //
    // this Modifiers patch works for only Key-Down time hotkey.
    // this hack does not work for Key-Up time hotkey.
    //
#if 0
    //
    // patch Shift status for g_uModifiers. 
    // we might not be able to catch up the current keystatus because
    // sytstem could eat Shift key and no keyboard hook was called.
    //
    if (GetKeyState(VK_SHIFT) & 0x8000)
        g_uModifiers |= TF_MOD_SHIFT;
    else
        g_uModifiers &= ~TF_MOD_ALLSHIFT;
#endif

    if (g_uLangHotKeyModifiers &&
        ModifiersCheck(g_uModifiers, g_uLangHotKeyModifiers))
        return TRUE;

    if (g_uKeyTipHotKeyModifiers &&
        ModifiersCheck(g_uModifiers, g_uKeyTipHotKeyModifiers))
        return TRUE;

    return FALSE;
}

//+---------------------------------------------------------------------------
//
// CheckLangChangeHotKey
//
//----------------------------------------------------------------------------

BOOL CheckLangChangeHotKey(SYSTHREAD *psfn, WPARAM wParam, LPARAM lParam)
{
    BOOL fLangHotKeys;
    BOOL fKeyTipHotKeys;

    if (psfn == NULL)
        return FALSE;

    //
    // we don't care about reperted key down.
    //
    if ((lParam & 0xffff) > 1)
        return FALSE;

    //
    // If we are not interested in the VKey (wParam), 
    // clear bToggleReady up and don't eat it.
    //
    if ((g_uLangHotKeyVKey[0] != wParam) &&
        (g_uLangHotKeyVKey[1] != wParam))
    {
        if (psfn->bLangToggleReady)
        {
            psfn->bLangToggleReady = FALSE;
        }

        fLangHotKeys = FALSE;
    }
    else
    {
        fLangHotKeys = TRUE;
    }

    if ((g_uKeyTipHotKeyVKey[0] != wParam) &&
        (g_uKeyTipHotKeyVKey[1] != wParam))
    {
        if (psfn->bKeyTipToggleReady)
        {
            psfn->bKeyTipToggleReady = FALSE;
        }

        fKeyTipHotKeys = FALSE;
    }
    else
    {
        fKeyTipHotKeys = TRUE;
    }

    if (fLangHotKeys && !psfn->bLangToggleReady)
    {
        if (!(lParam & 0x80000000))
        {
            if (g_uLangHotKeyModifiers &&
                ModifiersCheck(g_uModifiers, g_uLangHotKeyModifiers))
            {
                //
                // we will change assembly at next key up.
                //
                psfn->bLangToggleReady = TRUE;

                //
                // we always eat Language change hotkey to stop system
                // to change hKL.
                //
                return FALSE;
            }
        }
    }

    if (fKeyTipHotKeys && !psfn->bKeyTipToggleReady)
    {
        if (!(lParam & 0x80000000))
        {
            if (g_uKeyTipHotKeyModifiers &&
                ModifiersCheck(g_uModifiers, g_uKeyTipHotKeyModifiers))
            {
                if (GetKeyboardItemNum() >= 2)
                {
                    //
                    // we will change assembly at next key up.
                    //
                    psfn->bKeyTipToggleReady = TRUE;

                    //
                    // we don't want to eat KeyTip change hotkey if there is 
                    // only one keyboard item in this language.
                    // Ctrl+Shift is used by apps.
                    //
                    return FALSE;
                }
            }
            else if (wParam == VK_GRAVE && g_uKeyTipHotKeyVKey[0] == wParam)
            {
                //
                // we will change assembly at next key up.
                //
                psfn->bKeyTipToggleReady = TRUE;

                return TRUE;
            }
        }
    }

    if (!(lParam & 0x80000000))
    {
        //
        // want to eat Grave Accent if it is a layout switching hotkey for ME.
        //
        if (g_uKeyTipHotKeyVKey[0] == wParam && wParam == VK_GRAVE)
            return TRUE;
        else
            return FALSE;
    }

    BOOL bLangToggleReady = psfn->bLangToggleReady;
    BOOL bKeyTipToggleReady = psfn->bKeyTipToggleReady;
    psfn->bLangToggleReady = FALSE;
    psfn->bKeyTipToggleReady = FALSE;

    if (bLangToggleReady)
    {

        //
        // remove all WM_INPUTLANGCHANGEREQUEST message.
        //
        MSG msg;
        while(PeekMessage(&msg, NULL,
                          WM_INPUTLANGCHANGEREQUEST, 
                          WM_INPUTLANGCHANGEREQUEST,
                          PM_REMOVE));

        if (g_uLangHotKeyVKey[0] == VK_SHIFT)
        {
            BOOL bRightShift = FALSE;
            if ((((wParam & 0xff) == VK_SHIFT) && 
                                (((lParam >> 16) & 0x00ff) == 0x36)) ||
                  (g_uModifiers & TF_MOD_RSHIFT))
                bRightShift = TRUE;

            PostThreadMessage(GetCurrentThreadId(), 
                              g_msgPrivate, 
                              TFPRIV_LANGCHANGE,  
                              bRightShift);
            return TRUE;
        }
        else if (g_uLangHotKeyVKey[0] == CHAR_GRAVE)
        {
            //
            // Issue: we need to do something for Thai.
            //
            return TRUE;
        }
    }
    else if (bKeyTipToggleReady)
    {
        //
        // remove all WM_INPUTLANGCHANGEREQUEST message.
        //
        MSG msg;
        while(PeekMessage(&msg, NULL,
                          WM_INPUTLANGCHANGEREQUEST, 
                          WM_INPUTLANGCHANGEREQUEST,
                          PM_REMOVE));

        if (g_uKeyTipHotKeyVKey[0] == VK_SHIFT)
        {
            BOOL bRightShift = FALSE;
            if ((((wParam & 0xff) == VK_SHIFT) && 
                                (((lParam >> 16) & 0x00ff) == 0x36)) ||
                  (g_uModifiers & TF_MOD_RSHIFT))
                bRightShift = TRUE;

            PostThreadMessage(GetCurrentThreadId(), 
                              g_msgPrivate, 
                              TFPRIV_KEYTIPCHANGE,  
                              bRightShift);
            return TRUE;
        }
        else if (g_uKeyTipHotKeyVKey[0] == VK_GRAVE)
        {
            // checking for Middle East(Arabic or Hebrew) layout hotkey to
            // support the third hotkey value(Grave Accent) instead of Ctrl+Shift
            // or Alt+Shift.

            PostThreadMessage(GetCurrentThreadId(),
                              g_msgPrivate,
                              TFPRIV_KEYTIPCHANGE,
                              FALSE);

            return TRUE;
        }
    }

    return FALSE;
}

//+---------------------------------------------------------------------------
//
// Imm32ModtoCicMod
//
//----------------------------------------------------------------------------

UINT Imm32ModtoCicMod(UINT uImm32Mod)
{
    UINT uMod = 0;
    if ((uImm32Mod & (MOD_LEFT | MOD_RIGHT)) == (MOD_LEFT | MOD_RIGHT))
         uImm32Mod &=  ~(MOD_LEFT | MOD_RIGHT);

    if (uImm32Mod & MOD_LEFT)
    {
        if (uImm32Mod & MOD_ALT)     uMod |= TF_MOD_LALT;  
        if (uImm32Mod & MOD_CONTROL) uMod |= TF_MOD_LCONTROL;
        if (uImm32Mod & MOD_SHIFT)   uMod |= TF_MOD_LSHIFT;
    }
    else if (uImm32Mod & MOD_RIGHT)
    {
        if (uImm32Mod & MOD_ALT)     uMod |= TF_MOD_RALT;  
        if (uImm32Mod & MOD_CONTROL) uMod |= TF_MOD_RCONTROL;
        if (uImm32Mod & MOD_SHIFT)   uMod |= TF_MOD_RSHIFT;
    }
    else
    {
        if (uImm32Mod & MOD_ALT)     uMod |= TF_MOD_ALT;  
        if (uImm32Mod & MOD_CONTROL) uMod |= TF_MOD_CONTROL;
        if (uImm32Mod & MOD_SHIFT)   uMod |= TF_MOD_SHIFT;
    }
 
    if (uImm32Mod & MOD_ON_KEYUP)   uMod |= TF_MOD_ON_KEYUP;
    if (uImm32Mod & MOD_IGNORE_ALL_MODIFIER)   uMod |= TF_MOD_IGNORE_ALL_MODIFIER;

    return uMod;
}


//+---------------------------------------------------------------------------
//
// LoadImmHotkeyFromReg
//
//----------------------------------------------------------------------------

BOOL LoadImmHotkeyFromReg(IMM32HOTKEY *pHotKey)
{
    CMyRegKey key;
    UINT uMod;
    DWORD dw;
    TCHAR szKey[256];

    pHotKey->fInit = TRUE;

    StringCchPrintf(szKey, ARRAYSIZE(szKey),"%s\\%08x", c_szHotKey, pHotKey->dwId);
    if (key.Open(HKEY_CURRENT_USER, szKey, KEY_READ) != S_OK)
        goto Exit;

    pHotKey->uVKey = (UINT)-2;
    dw = sizeof(DWORD);
    key.QueryBinaryValue(&uMod, dw, c_szModifiers);
    dw = sizeof(DWORD);
    key.QueryBinaryValue(&pHotKey->uVKey, dw, c_szVKey);

    pHotKey->uModifiers = Imm32ModtoCicMod(uMod);

Exit:
    return TRUE;
}

//+---------------------------------------------------------------------------
//
// GetImmHotKeyTable()
//
//----------------------------------------------------------------------------

IMM32HOTKEY *GetImmHotKeyTable(LANGID langid)
{
   IMM32HOTKEY *pHotKeys;

    switch (langid)
    {
        case 0x0411: pHotKeys = g_ImmHotKeys411; break;
        case 0x0412: pHotKeys = g_ImmHotKeys412; break;
        case 0x0404: pHotKeys = g_ImmHotKeys404; break;
        case 0x0804: pHotKeys = g_ImmHotKeys804; break;
        default:
            switch (g_uACP)
            {
                case 932: pHotKeys = g_ImmHotKeys411; break;
                case 936: pHotKeys = g_ImmHotKeys804; break;
                case 949: pHotKeys = g_ImmHotKeys412; break;
                case 950: pHotKeys = g_ImmHotKeys404; break;
            }
            return NULL;
    }
    return pHotKeys;
}

//+---------------------------------------------------------------------------
//
// IsImmHotkey
//
//----------------------------------------------------------------------------

IMM32HOTKEY *IsImmHotkey(UINT uVKey, BOOL fUp, UINT uModifiers, LANGID langid)
{
    int i = 0;
    BOOL bRet = FALSE;
    IMM32HOTKEY *pHotKeys;
    IMM32HOTKEY *pHotKeyRet = NULL;

    pHotKeys = GetImmHotKeyTable(langid);
    if (!pHotKeys)
        return NULL;

    CicEnterCriticalSection(g_cs);

    while (pHotKeys[i].dwId)
    {
         if (!pHotKeys[i].fInit)
             LoadImmHotkeyFromReg(&pHotKeys[i]);

         if ((pHotKeys[i].uVKey == uVKey) && 
             pHotKeys[i].uModifiers &&
             ModifiersCheck(uModifiers, pHotKeys[i].uModifiers))
         {
             pHotKeyRet = &pHotKeys[i];

             if ((pHotKeyRet->uModifiers & TF_MOD_ON_KEYUP) && !fUp)
                pHotKeyRet = NULL;
             else if (!(pHotKeyRet->uModifiers & TF_MOD_ON_KEYUP) && fUp)
                pHotKeyRet = NULL;

             goto Exit;
         }

         i++;
    }

Exit:
    CicLeaveCriticalSection(g_cs);
    return pHotKeyRet;
}

//+---------------------------------------------------------------------------
//
// IsInImmHotkeyStatus
//
// 
// This function check the current keyboard status is in IMM32's hotkey.
// This will be a trigger to eat WM_INPUTLANGUAGECHANGEREQUEST that was
// genereated by IMM32. This is a fallback code because sometimes we
// could not eat the message in CheckImm32HotKey() (inside keyboard hook).
//
//----------------------------------------------------------------------------

IMM32HOTKEY *IsInImmHotkeyStatus(SYSTHREAD *psfn, LANGID langid)
{
    int i = 0;
    IMM32HOTKEY *pHotKeys;
    IMM32HOTKEY *pHotKeyRet = NULL;
    BYTE bkey[256];
    UINT uModifiers;

    if (!psfn)
        return NULL;

    if (psfn->fRemovingInputLangChangeReq)
        return NULL;

    if (!psfn->ptim)
        return NULL;

    if (!psfn->ptim->_GetFocusDocInputMgr())
        return NULL;

    if (!GetKeyboardState(bkey))
        return NULL;

    pHotKeys = GetImmHotKeyTable(langid);
    if (!pHotKeys)
        return NULL;

    uModifiers = 0;
    if (bkey[VK_MENU] & 0x80)
       uModifiers |= TF_MOD_ALT;

    if (bkey[VK_CONTROL] & 0x80)
       uModifiers |= TF_MOD_CONTROL;

    if (bkey[VK_SHIFT] & 0x80)
       uModifiers |= TF_MOD_SHIFT;

    CicEnterCriticalSection(g_cs);
    
    while (pHotKeys[i].dwId)
    {
         if (!pHotKeys[i].fInit)
             LoadImmHotkeyFromReg(&pHotKeys[i]);

         if ((bkey[pHotKeys[i].uVKey & 0xff] & 0x80) &&
             pHotKeys[i].uModifiers &&
             ModifiersCheck(uModifiers, pHotKeys[i].uModifiers))
         {
             pHotKeyRet = &pHotKeys[i];

             if (pHotKeyRet->uModifiers & TF_MOD_ON_KEYUP)
                  pHotKeyRet = NULL;

             goto Exit;
         }

         i++;
    }

Exit:
    CicLeaveCriticalSection(g_cs);
    return pHotKeyRet;
}

//+---------------------------------------------------------------------------
//
// CancelImmHotkey
//
//----------------------------------------------------------------------------

#ifdef SIMULATE_EATENKEYS
BOOL CancelImmHotkey(SYSTHREAD *psfn, HWND hwnd, IMM32HOTKEY *pHotKey)
{
    UINT uMsg;

    if (pHotKey->uModifiers & TF_MOD_ON_KEYUP)
        uMsg = WM_KEYUP;
    else
        uMsg = WM_KEYDOWN;

    PostMessage(hwnd, uMsg, (WPARAM)pHotKey->uVKey, 0);

    return TRUE;
}
#endif

//+---------------------------------------------------------------------------
//
// void ToggleCHImeNoIme
//
//----------------------------------------------------------------------------

BOOL ToggleCHImeNoIme(SYSTHREAD *psfn, LANGID langidCur, LANGID langid)
{
    int i;
    LANGID langidPrev;
    GUID guidPrevProfile;
    HKL hklPrev;
    BOOL fCiceroClient= FALSE;

    CAssemblyList *pAsmList;
    CAssembly *pAsm;
    ASSEMBLYITEM *pItem;

    pAsmList = EnsureAssemblyList(psfn);
    if (!pAsmList)
        return FALSE;

    langidPrev = psfn->langidPrevForCHHotkey;
    guidPrevProfile = psfn->guidPrevProfileForCHHotkey;
    hklPrev = psfn->hklPrevForCHHotkey;
    psfn->guidPrevProfileForCHHotkey = GUID_NULL;
    psfn->langidPrevForCHHotkey = 0;
    psfn->hklPrevForCHHotkey = 0;

    pAsm = pAsmList->FindAssemblyByLangId(langidCur);
    if (!pAsm)
        return FALSE;

    if (psfn->ptim && psfn->ptim->_GetFocusDocInputMgr()) 
        fCiceroClient = TRUE;

    if (fCiceroClient)
    {
        pItem = pAsm->FindActiveKeyboardItem();
        if (!pItem)
            return FALSE;
    }
    else
    {
        pItem = pAsm->FindKeyboardLayoutItem(GetKeyboardLayout(0));
        if (!pItem)
            return FALSE;
    }

    if (!IsEqualGUID(pItem->clsid, GUID_NULL) || IsPureIMEHKL(pItem->hkl))
    {
        //
        // Not the current active keyboard item is TIP or IME.
        //

        psfn->guidPrevProfileForCHHotkey = pItem->guidProfile;
        psfn->hklPrevForCHHotkey = pItem->hkl;
        psfn->langidPrevForCHHotkey = langid;

        for (i = 0; i < pAsm->Count(); i++)
        {
            pItem = pAsm->GetItem(i);
            if (!pItem)
                continue;

            if (IsEqualGUID(pItem->catid, GUID_TFCAT_TIP_KEYBOARD) &&
                IsEqualGUID(pItem->clsid, GUID_NULL) &&
                !IsPureIMEHKL(pItem->hkl))
            {
                ActivateAssemblyItem(psfn, 
                                     langidCur, 
                                     pItem, 
                                     AAIF_CHANGEDEFAULT);
                return TRUE;
            }
        }

        PostThreadMessage(GetCurrentThreadId(), 
                          g_msgPrivate, 
                          TFPRIV_ACTIVATELANG,  
                          0x0409);

        return TRUE;
    }
    else
    {
        BOOL fActivateFirstIME = FALSE;
        BOOL fCheckItem = FALSE;

        if (langidCur != langid)
            ActivateAssembly(langid, ACTASM_NONE);

        pAsm = pAsmList->FindAssemblyByLangId(langid);
        if (!pAsm)
            return FALSE;

        if ((langidPrev == langid) &&
            (!IsEqualGUID(guidPrevProfile, GUID_NULL) ||
            IsPureIMEHKL(hklPrev)))
        {
             fCheckItem = TRUE;
        }
        else if (!langidPrev && 
                 IsEqualGUID(guidPrevProfile, GUID_NULL) &&
                 !hklPrev)
        {
             fActivateFirstIME = TRUE;
        }

        if (fActivateFirstIME)
        {
             return ActivateNextKeyTip(FALSE);
        }

        for (i = 0; i < pAsm->Count(); i++)
        {
            pItem = pAsm->GetItem(i);
            if (!pItem)
                continue;

            if (!IsEqualGUID(pItem->catid, GUID_TFCAT_TIP_KEYBOARD))
                continue;

            //
            // Bug#494617 - Check the item is enabled or not.
            //
            if (!pItem->fEnabled)
                continue;

            if (fCheckItem)
            {
                 if ((!IsEqualGUID(guidPrevProfile, GUID_NULL) &&
                      IsEqualGUID(pItem->guidProfile, guidPrevProfile)) ||
                     (IsPureIMEHKL(hklPrev) && (hklPrev == pItem->hkl)))
                 {
                     ActivateAssemblyItem(psfn, 
                                          langid, 
                                          pItem, 
                                          AAIF_CHANGEDEFAULT);
                     return TRUE;
                 }
            }
            else if (!IsEqualGUID(pItem->guidProfile, GUID_NULL))
            { 
                 ActivateAssemblyItem(psfn, 
                                      langid, 
                                      pItem, 
                                      AAIF_CHANGEDEFAULT);
                 return TRUE;
            }
        }
    }

    return FALSE;
}

//////////////////////////////////////////////////////////////////////////////
//
// CAsyncOpenKeyboardTip
//
//////////////////////////////////////////////////////////////////////////////

class CAsyncOpenKeyboardTip : public CAsyncQueueItem
{
public:
    CAsyncOpenKeyboardTip(CThreadInputMgr *ptim, BOOL fSync) : CAsyncQueueItem(fSync)
    {
        _ptim = ptim;
    }

    HRESULT DoDispatch(CInputContext *pic)
    {
        if (!_ptim)
        {
            Assert(0);
            return E_FAIL;
        }

        MySetCompartmentDWORD(g_gaSystem, 
                              _ptim,
                              GUID_COMPARTMENT_KEYBOARD_OPENCLOSE,
                              TRUE);
                                  
        return S_OK;
    }

private:
    CThreadInputMgr *_ptim;
};

//+---------------------------------------------------------------------------
//
// void ToggleJImeNoIme
//
//----------------------------------------------------------------------------

BOOL ToggleJImeNoIme(SYSTHREAD *psfn)
{
    int i;
    CAssemblyList *pAsmList;
    CAssembly *pAsm;
    ASSEMBLYITEM *pItem;

    if (!psfn)
        return FALSE;

    if (!psfn->ptim)
        return FALSE;

    //
    // if there is no Focus DIM, we don't have to do this.
    //
    if (!psfn->ptim->_GetFocusDocInputMgr())
        return FALSE;

    pAsmList = EnsureAssemblyList(psfn);
    if (!pAsmList)
        return FALSE;

    pAsm = pAsmList->FindAssemblyByLangId(0x0411);
    if (!pAsm)
        return FALSE;

    pItem = pAsm->FindActiveKeyboardItem();
    if (!pItem)
        return FALSE;

    if (!IsEqualGUID(pItem->clsid, GUID_NULL))
        return FALSE;

    if (IsPureIMEHKL(pItem->hkl))
        return FALSE;


    ASSEMBLYITEM *pItemNew = NULL;
    for (i = 0; i < pAsm->Count(); i++)
    {
        ASSEMBLYITEM *pItemTemp;
        pItemTemp = pAsm->GetItem(i);
        if (!pItemTemp)
            continue;

        if (pItemTemp == pItem)
            continue;

        if (!IsEqualGUID(pItemTemp->catid, GUID_TFCAT_TIP_KEYBOARD))
            continue;

        if (!IsEqualGUID(pItemTemp->clsid, GUID_NULL))
        {
            pItemNew = pItemTemp;
            break;
        }

        if (IsPureIMEHKL(pItemTemp->hkl))
        {
            pItemNew = pItemTemp;
            break;
        }
    }

    if (pItemNew)
    {
        ActivateAssemblyItem(psfn, 
                             0x0411, 
                             pItemNew, 
                             AAIF_CHANGEDEFAULT);


        //
        // Open Keyboard TIP.
        //
        CInputContext *pic = NULL;
        pic = psfn->ptim->_GetFocusDocInputMgr()->_GetIC(0);
        if (pic)
        {
            CAsyncOpenKeyboardTip  *pAsyncOpenKeyboardTip;
            pAsyncOpenKeyboardTip = new CAsyncOpenKeyboardTip(psfn->ptim, FALSE);
            if (pAsyncOpenKeyboardTip)
            {
                HRESULT hr = S_OK;

                if ((pic->_QueueItem(pAsyncOpenKeyboardTip->GetItem(), FALSE, &hr) != S_OK) || FAILED(hr))
                {
                    Assert(0);
                }

                pAsyncOpenKeyboardTip->_Release();
            }
        }
    }

    return TRUE;
}



//+---------------------------------------------------------------------------
//
// CheckImm32HotKey
//
//----------------------------------------------------------------------------

BOOL CheckImm32HotKey(WPARAM wParam, LPARAM lParam)
{
    HKL hKL;
    SYSTHREAD *psfn = GetSYSTHREAD();
    IMM32HOTKEY *pHotKey;
    BOOL bRet = FALSE;

    if (psfn == NULL)
        return FALSE;

    //
    // If there is no tim, let system change hKL.
    //
    if (!psfn->ptim)
        return FALSE;

    //
    // If there is focus dim, we need to handle it.
    // If there is no focus dim, but msctfime can eat the hotkey,
    // we need to do this instead of system.
    //
    if (!psfn->ptim->_GetFocusDocInputMgr())
    {
        if (!CtfImmIsCiceroStartedInThread())
            return FALSE;
    }

    hKL = GetKeyboardLayout(NULL);

    pHotKey = IsImmHotkey((UINT)wParam & 0xff, 
                          (HIWORD(lParam) & KF_UP) ? TRUE : FALSE,
                          g_uModifiers, 
                          (LANGID)LOWORD((UINT_PTR)hKL));

    if (!pHotKey)
    {
        //
        // Chinese IME-NONIME toggle Hack for NT.
        //
        // On NT, we're using non IME as a dummy hKL of CH-Tips.
        // we need to simulate HotKey.
        //
        LANGID langidPrev = psfn->langidPrev;

        //
        // If the Chinese IME-NONIME toggle has never been done in this thread
        // and the current thread locale is Chinese, let's try to do
        // IME-NONIME toggle.
        //
        if ((langidPrev != CHTLANGID) && 
            (langidPrev != CHSLANGID) &&
             !psfn->langidPrevForCHHotkey)
        {
            LANGID langidThread = LANGIDFROMLCID(GetThreadLocale());
            if ((langidThread == CHTLANGID) || (langidThread == CHSLANGID))
                langidPrev = langidThread;
        }

        if (IsOnNT() &&
            ((langidPrev == CHTLANGID) || (langidPrev == CHSLANGID)))
        {
            pHotKey = IsImmHotkey((UINT)wParam & 0xff, 
                                  (HIWORD(lParam) & KF_UP) ? TRUE : FALSE,
                                  g_uModifiers, 
                                  langidPrev);

            if (pHotKey)
            {
                //
                // if it is a IME-NONIME toggle hotkey
                // we need to simulate it.
                //
                if ((pHotKey->dwId == IME_CHOTKEY_IME_NONIME_TOGGLE) ||
                    (pHotKey->dwId == IME_THOTKEY_IME_NONIME_TOGGLE))
                {
                    bRet = ToggleCHImeNoIme(psfn,  
                                     LANGIDFROMHKL(hKL),
                                     langidPrev);

                    //
                    // On CUAS, Imm32's Hotkey is simulated in ImmProcessKey
                    // So this function is called there.
                    // We don't need this Toggle status hack.
                    //
                    if (!CtfImmIsCiceroStartedInThread()) 
                       psfn->bInImeNoImeToggle = TRUE;
                }
            }
        }

        return bRet;
    }

    //
    // remove all WM_INPUTLANGCHANGEREQUEST message.
    //
    // sometimes, this can not catch the IMM32's language change. We 
    // fallback hack for them in default.cpp's WM_INPUTLANGCHANGEREQUEST
    // handler. Check IsInImmHotKeyStatus() and CancelImmHotkey().
    //
    MSG msg;
    ULONG ulQuitCode;
    BOOL fQuitReceived = FALSE;

    psfn->fRemovingInputLangChangeReq = TRUE;

    while(PeekMessage(&msg, NULL,
                      WM_INPUTLANGCHANGEREQUEST, 
                      WM_INPUTLANGCHANGEREQUEST,
                      PM_REMOVE))
    {
        if (msg.message == WM_QUIT)
        {
            ulQuitCode = (ULONG)(msg.wParam);
            fQuitReceived = TRUE;
        }
    }

    if (fQuitReceived)
        PostQuitMessage(ulQuitCode);
   
    psfn->fRemovingInputLangChangeReq = FALSE;

    //
    // Chinese IME-NONIME toggle Hack for NT.
    //
    // On NT, we're using non IME as a dummy hKL of CH-Tips.
    // we need to simulate HotKey.
    //
    if (IsOnNT() && !psfn->bInImeNoImeToggle)
    {
        if ((pHotKey->dwId == IME_CHOTKEY_IME_NONIME_TOGGLE) ||
            (pHotKey->dwId == IME_THOTKEY_IME_NONIME_TOGGLE))
        {
            bRet = ToggleCHImeNoIme(psfn, LANGIDFROMHKL(hKL), LANGIDFROMHKL(hKL));
        }
    }
    psfn->bInImeNoImeToggle = FALSE;

    return bRet;
}

//////////////////////////////////////////////////////////////////////////////
//
// CAsyncProcessDBEKeyQueueItem
//
//////////////////////////////////////////////////////////////////////////////

class CAsyncProcessDBEKeyQueueItem : public CAsyncQueueItem
{
public:
    CAsyncProcessDBEKeyQueueItem(CThreadInputMgr *ptim, WPARAM wParam, LPARAM lParam, BOOL fTest, BOOL fSync) : CAsyncQueueItem(fSync)
    {
        _wParam = wParam;
        _lParam = lParam;
        _fTest = fTest;
        _ptim = ptim;
    }

    HRESULT DoDispatch(CInputContext *pic)
    {
        if (!_ptim)
        {
            Assert(0);
            return E_FAIL;
        }

        BOOL fEaten;

        return _ptim->_KeyStroke((_lParam & 0x80000000) ? KS_UP : KS_DOWN, 
                                  _wParam, 
                                  _lParam, 
                                  &fEaten, 
                                  _fTest,
                                  TF_KEY_INTERNAL);
                                  
    }

private:
    WPARAM _wParam;
    LPARAM _lParam;
    BOOL _fTest;
    CThreadInputMgr *_ptim;
};

//+---------------------------------------------------------------------------
//
// HandleDBEKeys
//
//----------------------------------------------------------------------------

BOOL HandleDBEKeys(WPARAM wParam, LPARAM lParam)
{
    SYSTHREAD *psfn = GetSYSTHREAD();
    CThreadInputMgr *ptim;
    LANGID langid;

    //
    // only Japanese layout has DBE keys.
    //
    langid = GetCurrentAssemblyLangId(psfn);
    if (langid != 0x0411)
        return FALSE;

    //
    // no need to forward this on non Cicero apps.
    //
    if (!(ptim = CThreadInputMgr::_GetThisFromSYSTHREAD(psfn)))
        return FALSE;

    if (!ptim->_GetFocusDocInputMgr())
        return FALSE;

    //
    // if ALT is not held, app can forward this to TIPs.
    //
    if (!(g_uModifiers & TF_MOD_ALT))
        return FALSE;

    UINT uVKey = (UINT)wParam & 0xff;
    BOOL fRet = FALSE;

    switch (uVKey)
    {
        case VK_DBE_ALPHANUMERIC:
        case VK_DBE_KATAKANA:
        case VK_DBE_HIRAGANA:
        case VK_DBE_SBCSCHAR:
        case VK_DBE_DBCSCHAR:
        case VK_DBE_ROMAN:
        case VK_DBE_NOROMAN:
        case VK_DBE_CODEINPUT:
        case VK_DBE_NOCODEINPUT:
        case VK_DBE_ENTERWORDREGISTERMODE:
        case VK_DBE_ENTERIMECONFIGMODE:
        case VK_DBE_ENTERDLGCONVERSIONMODE:
        case VK_DBE_DETERMINESTRING:
        case VK_DBE_FLUSHSTRING:
        case VK_CONVERT:
        case VK_KANJI:
            

            //
            // Issue:
            //
            // We don't know which IC in the focus DIM will handle the hotkey yet.
            // because the selection is changed by the application so we need to get ec
            // to update the current selection pos. We do call GetSelection
            // inside the root IC's lock. So it might be failed if hotkey's target
            // is TOP IC.
            //
            CInputContext *pic = ptim->_GetFocusDocInputMgr()->_GetIC(0);

            if (!pic)
                return FALSE;

            CAsyncProcessDBEKeyQueueItem  *pAsyncProcessDBEKeyQueueItem;
            pAsyncProcessDBEKeyQueueItem = new CAsyncProcessDBEKeyQueueItem(ptim, wParam, lParam, FALSE, FALSE);
            if (!pAsyncProcessDBEKeyQueueItem)
                return FALSE;
    
            HRESULT hr = S_OK;

            fRet = TRUE;
            if ((pic->_QueueItem(pAsyncProcessDBEKeyQueueItem->GetItem(), FALSE, &hr) != S_OK) || FAILED(hr))
            {
                Assert(0);
                fRet = FALSE;
            }

            pAsyncProcessDBEKeyQueueItem->_Release();
            break;
    }

    return fRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\ctf\uim\hotkey.h ===
//
// hotkey.h
//
// CHotKey
//


#ifndef HOTKEY_H
#define HOTKEY_H

#include "private.h"

#define TF_MOD_ALLALT     (TF_MOD_RALT | TF_MOD_LALT | TF_MOD_ALT)
#define TF_MOD_ALLCONTROL (TF_MOD_RCONTROL | TF_MOD_LCONTROL | TF_MOD_CONTROL)
#define TF_MOD_ALLSHIFT   (TF_MOD_RSHIFT | TF_MOD_LSHIFT | TF_MOD_SHIFT)
#define TF_MOD_RLALT     (TF_MOD_RALT | TF_MOD_LALT)
#define TF_MOD_RLCONTROL (TF_MOD_RCONTROL | TF_MOD_LCONTROL)
#define TF_MOD_RLSHIFT   (TF_MOD_RSHIFT | TF_MOD_LSHIFT)

//
// internal WIN modifiers
//
#define TF_MOD_WIN                          0x00010000
#define TF_MOD_RWIN                         0x00020000
#define TF_MOD_LWIN                         0x00040000
#define TF_MOD_RLWIN   (TF_MOD_RWIN | TF_MOD_LWIN)

#define CHAR_GRAVE           TEXT('`')

#define VK_GRAVE            0xC0

//////////////////////////////////////////////////////////////////////////////
//
// CHotKey
//
//////////////////////////////////////////////////////////////////////////////

class CHotKey
{
public:
     CHotKey()
     {
     }

     BOOL Init (TfClientId tid, const TF_PRESERVEDKEY *pprekey, REFGUID rguid, DWORD dwFlags)
     {
         _tid = tid;
         _prekey = *pprekey;
         _dwFlags = dwFlags;

         if (_prekey.uVKey == VK_F10)
              _fAlt = TRUE;
         else if (_prekey.uVKey == VK_MENU)
              _fAlt = TRUE;
         else if (_prekey.uModifiers & (TF_MOD_RALT | TF_MOD_LALT | TF_MOD_ALT))
              _fAlt = TRUE;
         else
              _fAlt = FALSE;

         if (_prekey.uModifiers & (TF_MOD_RWIN | TF_MOD_LWIN | TF_MOD_WIN))
              _fWin = TRUE;
         else
              _fWin = FALSE;

         if (FAILED(MyRegisterGUID(rguid, &_guidatom)))
             return FALSE;

         return TRUE;
     }

     ~CHotKey()
     {
         if (_pszDesc)
             delete _pszDesc;
     }

     BOOL SetDesc(const WCHAR *pchDesc, ULONG cchDesc)
     {
         if (_pszDesc)
         {
             delete _pszDesc;
             _pszDesc = NULL;
         }

         if (!cchDesc)
             return TRUE;

         _pszDesc = new WCHAR[cchDesc + 1];
         if (!_pszDesc)
             return FALSE;

         memcpy(_pszDesc, pchDesc, sizeof(WCHAR) * cchDesc);
         return TRUE;
     }

     BOOL GetDesc(BSTR *pbstr)
     {
         *pbstr = SysAllocString(_pszDesc);
         return (*pbstr) ? TRUE : FALSE;
     }

     BOOL IsNoDimNeeded()
     {
         return (_dwFlags & TF_PKEX_NONEEDDIM) ? TRUE : FALSE;
     }

     BOOL IsSysHotkey()
     {
         if (_fAlt)
             return TRUE;

         if (_fWin)
             return TRUE;

         if (_dwFlags & TF_PKEX_SYSHOTKEY)
             return TRUE;

         return FALSE;
     }

     TF_PRESERVEDKEY _prekey;
     TfGuidAtom _guidatom;
     BOOL _fAlt;
     BOOL _fWin;
     DWORD _dwFlags;
     WCHAR *_pszDesc;

     BOOL IsValidTID(TfClientId tid)
     {
         if (_tid == tid)
             return TRUE;

         if (_tid == g_gaSystem)
             return TRUE;

         return FALSE;
     }

     TfClientId GetTID() {return _tid;}
private:
     TfClientId _tid;
};



typedef struct tag_IMM32HOTKEY {
    DWORD  dwId;
    UINT   uVKey;
    UINT   uModifiers;
    BOOL   fInit;
} IMM32HOTKEY;

BOOL ModifiersCheck(UINT uModSrc, UINT uMod);
BOOL InitLangChangeHotKey();
BOOL UpdateModifiers(WPARAM wParam, LPARAM lParam);
BOOL IsInLangChangeHotkeyStatus();
BOOL CheckLangChangeHotKey(SYSTHREAD *psfn, WPARAM wParam, LPARAM lParam);
BOOL CheckImm32HotKey(WPARAM wParam, LPARAM lParam);
BOOL HandleDBEKeys(WPARAM wParam, LPARAM lParam);
IMM32HOTKEY *IsInImmHotkeyStatus(SYSTHREAD *psfn, LANGID langid);
BOOL CancelImmHotkey(SYSTHREAD *psfn, HWND hwnd, IMM32HOTKEY *pHotKey);
BOOL ToggleCHImeNoIme(SYSTHREAD *psfn, LANGID langidCur, LANGID langid);
BOOL ToggleJImeNoIme(SYSTHREAD *psfn);

#endif // HOTKEY_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\ctf\uim\ic.h ===
//
// ic.h
//

#ifndef IC_H
#define IC_H

#include "private.h"
#include "globals.h"
#include "rprop.h"
#include "editrec.h"
#include "strary.h"
#include "compart.h"

#define TF_ES_INEDITSESSION          0x80000000
#define TF_ES_INNOTIFY               0x40000000
#define TF_ES_WRITE                  (TF_ES_READWRITE & ~TF_ES_READ)
#define TF_ES_PROPERTY_WRITE         (TF_ES_READ_PROPERTY_WRITE & ~TF_ES_READ)
#define TF_ES_ALL_ACCESS_BITS        (TF_ES_READWRITE | TF_ES_READ_PROPERTY_WRITE)

#define IC_NUM_CONNECTIONPTS        5
// these are indices into _rgSinks, must match CInputContext::_c_rgConnectionIIDs
#define IC_SINK_ITfTextEditSink                     0
#define IC_SINK_ITfTextLayoutSink                   1
#define IC_SINK_ITfStatusSink                       2
#define IC_SINK_ITfStartReconversionNotifySink      3
#define IC_SINK_ITfEditTransactionSink              4

class CRange;
class CProperty;
class CThreadInputMgr;
class CFunctionProvider;
class CFunction;
class CContextView;
class CComposition;
class CDocumentInputManager;
class CInputContext;

extern const IID IID_PRIV_CINPUTCONTEXT;

#define LEFT_FILTERTIP    0
#define RIGHT_FILTERTIP   1

typedef struct _CLEANUPSINK
{
    TfClientId tid;
    ITfCleanupContextSink *pSink;
} CLEANUPSINK;

//////////////////////////////////////////////////////////////////////////////
//
// QUEUE_ITEM structures
//
//////////////////////////////////////////////////////////////////////////////

typedef enum { QI_ADDREF, QI_DISPATCH, QI_FREE } QiCallbackCode;

struct _TS_QUEUE_ITEM;

typedef HRESULT (*QI_CALLBACK)(CInputContext *pic, struct _TS_QUEUE_ITEM *pItem, QiCallbackCode qiCode);

typedef struct _EDITSESSION
{
    TfClientId tid;
    ITfEditSession *pes;
} EDITSESSION;

typedef struct _PSEUDO_EDITSESSION
{
    ULONG uCode;
    void *pvState;
} PSEUDO_EDITSESSION;

class CAsyncQueueItem;
typedef struct _ASYNCQUEUE_EDITSESSION
{
    CAsyncQueueItem *paqi;
} ASYNCQUEUE_EDITSESSION;

typedef struct _TS_QUEUE_ITEM
{
    QI_CALLBACK pfnCallback;
    DWORD dwFlags; // TF_ES_READWRITE | TF_ES_READ | TF_ES_WRITE | TF_ES_SYNC
    
    union
    {
        // state for edit sessions
        EDITSESSION es;

        PSEUDO_EDITSESSION pes;

        ASYNCQUEUE_EDITSESSION aqe;

        // other state...
    } state;
} TS_QUEUE_ITEM;

//
// PSEUDO_EDITSESSION callback codes
//
#define PSEUDO_ESCB_TERMCOMPOSITION       0
#define PSEUDO_ESCB_UPDATEKEYEVENTFILTER  1
#define PSEUDO_ESCB_GROWRANGE             2
#define PSEUDO_ESCB_BUILDOWNERRANGELIST   3
#define PSEUDO_ESCB_SHIFTENDTORANGE       4
#define PSEUDO_ESCB_GETSELECTION          5
#define PSEUDO_ESCB_SERIALIZE_ACP         6
#define PSEUDO_ESCB_SERIALIZE_ANCHOR      7
#define PSEUDO_ESCB_UNSERIALIZE_ACP       8
#define PSEUDO_ESCB_UNSERIALIZE_ANCHOR    9
#define PSEUDO_ESCB_GETWHOLEDOCRANGE      10

typedef struct _SERIALIZE_ANCHOR_PARAMS
{
    CProperty *pProp;
    CRange *pRange;
    TF_PERSISTENT_PROPERTY_HEADER_ANCHOR *pHdr;
    IStream *pStream;
} SERIALIZE_ANCHOR_PARAMS;

typedef struct _UNSERIALIZE_ANCHOR_PARAMS
{
    CProperty *pProp;
    const TF_PERSISTENT_PROPERTY_HEADER_ANCHOR *pHdr;
    IStream *pStream;
    ITfPersistentPropertyLoaderAnchor *pLoader;
} UNSERIALIZE_ANCHOR_PARAMS;

//////////////////////////////////////////////////////////////////////////////
//
// CAsyncQueueItem
//
//////////////////////////////////////////////////////////////////////////////

class CAsyncQueueItem
{
public:
    CAsyncQueueItem(BOOL fSync = FALSE)
    {
        _item.pfnCallback = _EditSessionQiCallback;
        _item.dwFlags = TF_ES_READWRITE | (fSync ? TF_ES_SYNC : 0);
        _item.state.aqe.paqi = this;

        _cRef = 1;
    }

    virtual ~CAsyncQueueItem() {};

    static HRESULT _EditSessionQiCallback(CInputContext *pic, struct _TS_QUEUE_ITEM *pItem, QiCallbackCode qiCode);

    virtual HRESULT DoDispatch(CInputContext *pic) = 0;

    void _CheckReadOnly(CInputContext *pic);

    TS_QUEUE_ITEM *GetItem()
    {
        return &_item;
    }

    LONG _AddRef() 
    {
        _cRef++;
        return _cRef;
    }

    LONG _Release() 
    {
        LONG ret = --_cRef;
        if (!_cRef)
            delete this;

        return ret;
    }

private:
    LONG _cRef;
    TS_QUEUE_ITEM _item;
};

//////////////////////////////////////////////////////////////////////////////
//
// CInputContext
//
//////////////////////////////////////////////////////////////////////////////

class CInputContext : public ITfContext_P,
                      public ITfQueryEmbedded,
                      public ITfInsertAtSelection,
                      public ITfContextOwnerServices,
                      public ITfContextOwnerCompositionServices,
                      public ITfSource,
                      public ITfSourceSingle,
                      public ITextStoreAnchorSink,
                      public ITextStoreAnchorServices,
                      public ITfMouseTracker,
                      public IServiceProvider,
                      public ITfContextRenderingMarkup,
                      public CCompartmentMgr,
                      public CComObjectRootImmx
{
public:
    CInputContext(TfClientId tid);
    ~CInputContext();

    BEGIN_COM_MAP_IMMX(CInputContext)
        COM_INTERFACE_ENTRY_IID(IID_PRIV_CINPUTCONTEXT, CInputContext)
        COM_INTERFACE_ENTRY(ITfContext)
        COM_INTERFACE_ENTRY(ITfContext_P)
        COM_INTERFACE_ENTRY(ITfQueryEmbedded)
        COM_INTERFACE_ENTRY(ITfInsertAtSelection)
        COM_INTERFACE_ENTRY(ITfContextComposition)
        COM_INTERFACE_ENTRY(ITfContextOwnerCompositionServices)
        COM_INTERFACE_ENTRY(ITfSource)
        COM_INTERFACE_ENTRY(ITfSourceSingle)
        COM_INTERFACE_ENTRY(ITextStoreAnchorSink)
        COM_INTERFACE_ENTRY(ITextStoreAnchorServices)
        COM_INTERFACE_ENTRY(ITfCompartmentMgr)
        COM_INTERFACE_ENTRY(ITfContextOwnerServices) // Issue: it would be nice if this was only avail w/ cicero def text store
                                                          // COM_INTERFACE_ENTRY_FUNC
        COM_INTERFACE_ENTRY(ITfMouseTracker)
        COM_INTERFACE_ENTRY(IServiceProvider)
        COM_INTERFACE_ENTRY(ITfContextRenderingMarkup)
    END_COM_MAP_IMMX()

    IMMX_OBJECT_IUNKNOWN_FOR_ATL()

    //
    // ITfContext
    //
    STDMETHODIMP RequestEditSession(TfClientId tid, ITfEditSession *pes, DWORD dwFlags, HRESULT *phrSession);
    STDMETHODIMP InWriteSession(TfClientId tid, BOOL *pfWriteSession);
    STDMETHODIMP GetSelection(TfEditCookie ec, ULONG ulIndex, ULONG ulCount, TF_SELECTION *pSelection, ULONG *pcFetched);
    STDMETHODIMP SetSelection(TfEditCookie ec, ULONG ulCount, const TF_SELECTION *pSelection);
    STDMETHODIMP GetStart(TfEditCookie ec, ITfRange **ppStart);
    STDMETHODIMP GetEnd(TfEditCookie ec, ITfRange **ppEnd);
    STDMETHODIMP GetStatus(TS_STATUS *pdcs);
    STDMETHODIMP GetActiveView(ITfContextView **ppView);
    STDMETHODIMP EnumViews(IEnumTfContextViews **ppEnum);
    STDMETHODIMP GetProperty(REFGUID guidProp, ITfProperty **ppv);

    STDMETHODIMP GetAppProperty(REFGUID guidProp, ITfReadOnlyProperty **ppProp);
    STDMETHODIMP TrackProperties(const GUID **pguidProp, ULONG cProp, const GUID **pguidAppProp, ULONG cAppProp, ITfReadOnlyProperty **ppPropX);

    STDMETHODIMP EnumProperties(IEnumTfProperties **ppEnum);
    STDMETHODIMP GetDocumentMgr(ITfDocumentMgr **ppDoc);
    STDMETHODIMP CreateRangeBackup(TfEditCookie ec, ITfRange *pRange, ITfRangeBackup **ppBackup);

    // ITfQueryEmbedded
    STDMETHODIMP QueryInsertEmbedded(const GUID *pguidService, const FORMATETC *pFormatEtc, BOOL *pfInsertable);

    // ITfInsertAtSelection
    STDMETHODIMP InsertTextAtSelection(TfEditCookie ec, DWORD dwFlags, const WCHAR *pchText, LONG cch, ITfRange **ppRange);
    STDMETHODIMP InsertEmbeddedAtSelection(TfEditCookie ec, DWORD dwFlags, IDataObject *pDataObject, ITfRange **ppRange);

    // ITfContextOwnerServices
    STDMETHODIMP OnLayoutChange();
    //STDMETHODIMP OnStatusChange(); // use ITextStoreAnchorSink::OnStatusChange
    STDMETHODIMP OnAttributeChange(REFGUID rguidAttribute);
    STDMETHODIMP Serialize(ITfProperty *pProp, ITfRange *pRange, TF_PERSISTENT_PROPERTY_HEADER_ACP *pHdr, IStream *pStream);
    STDMETHODIMP Unserialize(ITfProperty *pProp, const TF_PERSISTENT_PROPERTY_HEADER_ACP *pHdr, IStream *pStream, ITfPersistentPropertyLoaderACP *pLoader);
    STDMETHODIMP ForceLoadProperty(ITfProperty *pProp);
    STDMETHODIMP CreateRange(LONG acpStart, LONG acpEnd, ITfRangeACP **ppRange);

    // ITfContextComposition
    STDMETHODIMP StartComposition(TfEditCookie ecWrite, ITfRange *pCompositionRange, ITfCompositionSink *pSink, ITfComposition **ppComposition);
    STDMETHODIMP EnumCompositions(IEnumITfCompositionView **ppEnum);
    STDMETHODIMP FindComposition(TfEditCookie ecRead, ITfRange *pTestRange, IEnumITfCompositionView **ppEnum);
    STDMETHODIMP TakeOwnership(TfEditCookie ecWrite, ITfCompositionView *pComposition, ITfCompositionSink *pSink, ITfComposition **ppComposition);

    // ITfContextOwnerCompositionServices
    STDMETHODIMP TerminateComposition(ITfCompositionView *pComposition);

    // ITfSource
    STDMETHODIMP AdviseSink(REFIID riid, IUnknown *punk, DWORD *pdwCookie);
    STDMETHODIMP UnadviseSink(DWORD dwCookie);

    // ITfSourceSingle
    STDMETHODIMP AdviseSingleSink(TfClientId tid, REFIID riid, IUnknown *punk);
    STDMETHODIMP UnadviseSingleSink(TfClientId tid, REFIID riid);

    // ITextStoreAnchorSink
    STDMETHODIMP OnTextChange(DWORD dwFlags, IAnchor *paStart, IAnchor *paEnd);
    STDMETHODIMP OnSelectionChange();
    STDMETHODIMP OnLayoutChange(TsLayoutCode lcode, TsViewCookie vcView);
    STDMETHODIMP OnStatusChange(DWORD dwFlags);
    STDMETHODIMP OnAttrsChange(IAnchor *paStart, IAnchor *paEnd, ULONG cAttrs, const TS_ATTRID *paAttrs);
    STDMETHODIMP OnLockGranted(DWORD dwLockFlags);
    STDMETHODIMP OnStartEditTransaction();
    STDMETHODIMP OnEndEditTransaction();

    // ITextStoreAnchorServices
    STDMETHODIMP Serialize(ITfProperty *pProp, ITfRange *pRange, TF_PERSISTENT_PROPERTY_HEADER_ANCHOR *pHdr, IStream *pStream);
    STDMETHODIMP Unserialize(ITfProperty *pProp, const TF_PERSISTENT_PROPERTY_HEADER_ANCHOR *pHdr, IStream *pStream, ITfPersistentPropertyLoaderAnchor *pLoader);
    STDMETHODIMP CreateRange(IAnchor *paStart, IAnchor *paEnd, ITfRangeAnchor **ppRange);

    // ITfMouseTracker
    STDMETHODIMP AdviseMouseSink(ITfRange *range, ITfMouseSink *pSink, DWORD *pdwCookie);
    STDMETHODIMP UnadviseMouseSink(DWORD dwCookie);

    // IServiceProvider
    STDMETHODIMP QueryService(REFGUID guidService, REFIID riid, void **ppv);

    // ITfContextRenderingMarkup
    STDMETHODIMP GetRenderingMarkup(TfEditCookie ec, DWORD dwFlags, ITfRange *pRangeCover, IEnumTfRenderingMarkup **ppEnum);
    STDMETHODIMP FindNextRenderingMarkup(TfEditCookie ec, DWORD dwFlags, ITfRange *pRangeQuery, TfAnchor tfAnchorQuery,
                                         ITfRange **ppRangeFound, TF_RENDERINGMARKUP *ptfRenderingMarkup);

    // ITfContext_P
    STDMETHODIMP MapAppProperty(REFGUID guidAppProp, REFGUID guidProp);
    STDMETHODIMP EnableLockRequestPosting(BOOL fEnable);


    HRESULT _Init(CThreadInputMgr *tim, CDocumentInputManager *dm, ITextStoreAnchor *ptsi, ITfContextOwnerCompositionSink *pOwnerComposeSink);

    void _Pushed();
    void _Popped();

    void _AdviseSinks();
    void _UnadviseSinks(CThreadInputMgr *tim);

    void _UpdateKeyEventFilter();
    HRESULT _UpdateKeyEventFilterCallback(TfEditCookie ec);

    HRESULT _GetProperty(REFGUID rguidProp, CProperty **ppv);

    BOOL _NotifyEndEdit(void);

    CProperty *_FindProperty(REFGUID rguidProp)
    {
        TfGuidAtom ga;

        if (MyRegisterGUID(rguidProp, &ga) != S_OK)
            return NULL;

        return _FindProperty(ga);
    }
    CProperty *_FindProperty(TfGuidAtom gaProp);

    void _PropertyTextUpdate(DWORD dwFlags, IAnchor *paStart, IAnchor *paEnd);
    CProperty *_GetFirstProperty() { return _pPropList; }

    CProperty *_pPropList;

    BOOL _IsCiceroTSI() { return _fCiceroTSI; }

    ITextStoreAnchor *_GetTSI() { return _ptsi; }
    ITextStoreAnchor *_GetAATSI() { return _pMSAAState ? _pMSAAState->pAADoc : NULL; }

    BOOL _IsInEditSession() { return (_dwEditSessionFlags & TF_ES_INEDITSESSION); }
    BOOL _IsConnected() { return _dm ? TRUE : FALSE; }

    BOOL _IsValidEditCookie(TfEditCookie ec, DWORD dwFlags)
    { 
        Assert(dwFlags & TF_ES_READ); // minimum access...

        if (ec == BACKDOOR_EDIT_COOKIE)
        {
            Assert(!(dwFlags & (TF_ES_WRITE | TF_ES_PROPERTY_WRITE))); // app is trying to use def ec with write operation
            return !(dwFlags & (TF_ES_WRITE | TF_ES_PROPERTY_WRITE)); // app can read anything it wants
        }

        Assert(_ec != TF_INVALID_EDIT_COOKIE); // must always return FALSE for TF_INVALID_EDIT_COOKIE...
        Assert(!(_dwEditSessionFlags & TF_ES_WRITE) || (_dwEditSessionFlags & TF_ES_PROPERTY_WRITE)); // write implies property write 

        return (ec == _ec &&
                (_dwEditSessionFlags & TF_ES_INEDITSESSION) &&
                (!(dwFlags & TF_ES_WRITE) || (_dwEditSessionFlags & TF_ES_WRITE))) &&
                (!(dwFlags & TF_ES_PROPERTY_WRITE) || (_dwEditSessionFlags & TF_ES_PROPERTY_WRITE));
    }

    void _IncLastLockReleaseID() { _dwLastLockReleaseID++; /* Issue: handle wrap-around */ }
    DWORD _GetLastLockReleaseID() { return _dwLastLockReleaseID; }

    CDocumentInputManager *_GetDm() { return _dm; }

    CEditRecord *_GetEditRecord() { return _pEditRecord; }
    HRESULT _OnTextChangeInternal(DWORD dwFlags, IAnchor *paStart, IAnchor *paEnd, AnchorOwnership ao);

    CProperty *GetTextOwnerProperty();

    TfClientId _GetClientInEditSession(TfEditCookie ec) { return ec == BACKDOOR_EDIT_COOKIE ? g_gaApp : _tidInEditSession; }
    TfClientId _SetRawClientInEditSession(TfClientId tid)
    {
        TfClientId tidTmp = _tidInEditSession;
        _tidInEditSession = tid;
        return tidTmp;
    }

    CStructArray<GENERICSINK> *_GetTextEditSinks() { return &_rgSinks[IC_SINK_ITfTextEditSink]; }
    CStructArray<GENERICSINK> *_GetTextLayoutSinks() { return &_rgSinks[IC_SINK_ITfTextLayoutSink]; }
    CStructArray<GENERICSINK> *_GetStatusSinks() { return &_rgSinks[IC_SINK_ITfStatusSink]; }
    CStructArray<GENERICSINK> *_GetStartReconversionNotifySinks() { return &_rgSinks[IC_SINK_ITfStartReconversionNotifySink]; }
    CStructArray<GENERICSINK> *_GetEditTransactionSink() { return &_rgSinks[IC_SINK_ITfEditTransactionSink]; }
    CStructArray<CLEANUPSINK> *_GetCleanupSinks() { return &_rgCleanupSinks; }

    BOOL _AppSupportsCompositions() { return _pCompositionList != NULL; }
    CComposition *_GetCompositionList() { return _pCompositionList; }
    CComposition **_GetCompositionListPtr() { return &_pCompositionList; }
    ITfContextOwnerCompositionSink *_GetOwnerCompositionSink() { return _pOwnerComposeSink; }
    BOOL _DoesAppSupportCompositions() { return _pOwnerComposeSink != NULL; }
    BOOL _EnterCompositionOp()
    {
        return (_fInCompositionOp ? FALSE : (_fInCompositionOp = TRUE));
    }
    void _LeaveCompositionOp()
    {
        Assert(_fInCompositionOp);
        _fInCompositionOp = FALSE;
    }

    HRESULT _StartComposition(TfEditCookie ecWrite, IAnchor *paStart, IAnchor *paEnd, ITfCompositionSink *pSink, CComposition **ppComposition);
    HRESULT _TerminateCompositionWithLock(ITfCompositionView *pComposition, TfEditCookie ec);
    void _AbortCompositions();

    static void _PostponeLockRequestCallback(SYSTHREAD *psfn, CInputContext *pic);

    HRESULT _DoPseudoSyncEditSession(DWORD dwFlags, ULONG uCode, void *pvState, HRESULT *phrSession)
    {
        TS_QUEUE_ITEM item;

        item.pfnCallback = _PseudoSyncEditSessionQiCallback;
        item.dwFlags = dwFlags | TF_ES_SYNC;
        item.state.pes.uCode = uCode;
        item.state.pes.pvState = pvState;

        return _QueueItem(&item, FALSE, phrSession);
    }
    HRESULT _QueueItem(TS_QUEUE_ITEM *pItem, BOOL fForceAsync, HRESULT *phrSession);

    BOOL _ContextNeedsCleanup(const GUID *pCatId, LANGID langid, CStructArray<TfClientId> **pprgClientIds);
    void _CleanupContext(CStructArray<TfClientId> *prgClientIds);

    HRESULT GetMappedAppProperty(REFGUID guidProp, CProperty **ppProp);

private:

    friend CThreadInputMgr;
    friend CRange;
    friend CProperty;
    friend CFunction;

    typedef struct _IAS_OBJ
    {
        enum { IAS_TEXT, IAS_DATAOBJ } type;
        union
        {
            struct
            {
                const WCHAR *pchText;
                LONG cch;
            } text;
            struct
            {
                IDataObject *pDataObject;
            } obj;
        } state;
    } IAS_OBJ;

    HRESULT _InsertXAtSelection(TfEditCookie ec, DWORD dwFlags, IAS_OBJ *pObj, ITfRange **ppRange);
    void _DoPostTextEditNotifications(CComposition *pComposition, TfEditCookie ec, DWORD dwFlags, ULONG cchInserted, IAnchor *paStart, IAnchor *paEnd, CRange *range);
    BOOL _InsertXAtSelectionAggressive(TfEditCookie ec, DWORD dwFlags, IAS_OBJ *pObj, IAnchor **ppaStart, IAnchor **ppaEnd);

    int _GetCleanupListIndex(TfClientId tid);

    HRESULT _UnadviseOwnerSink();

    HRESULT _GetStartOrEnd(TfEditCookie ec, BOOL fStart, ITfRange **ppStart);

    BOOL _SynchAppChanges(DWORD dwLockFlags);
    HRESULT _EmptyLockQueue(DWORD dwLockFlags, BOOL fAppChangesSent);
    void _AbortQueueItems();
    void _PostponeLockRequest(DWORD dwFlags);

    HRESULT _DispatchQueueItem(TS_QUEUE_ITEM *pItem)
    {
        return pItem->pfnCallback(this, pItem, QI_DISPATCH);
    }
    void _ReleaseQueueItem(TS_QUEUE_ITEM *pItem)
    {
        pItem->pfnCallback(this, pItem, QI_FREE);
    }
    void _AddRefQueueItem(TS_QUEUE_ITEM *pItem)
    {
        pItem->pfnCallback(this, pItem, QI_ADDREF);
    }

    HRESULT _DoEditSession(TfClientId tid, ITfEditSession *pes, DWORD dwFlags);
    static HRESULT _EditSessionQiCallback(CInputContext *pic, TS_QUEUE_ITEM *pItem, QiCallbackCode qiCode);
    static HRESULT _PseudoSyncEditSessionQiCallback(CInputContext *pic, TS_QUEUE_ITEM *pItem, QiCallbackCode qiCode);

    HRESULT _OnSelectionChangeInternal(BOOL fAppChange);
    HRESULT _OnLayoutChangeInternal(TsLayoutCode lcode, TsViewCookie vcView);
    HRESULT _OnStatusChangeInternal();

    void _MarkDirtyRanges(IAnchor *paStart, IAnchor *paEnd);
    TFPROPERTYSTYLE _GetPropStyle(REFGUID rguidProp);

    void _IncEditCookie()
    {
        _ec++;

        // avoid reserved values!
        if (_ec == 0)
        {
            _ec = EC_MIN;
        }
    }

    void _Dbg_AssertNoSyncQueueItems()
    {
#ifdef DEBUG
        for (int i=0; i<_rgLockQueue.Count(); i++)
        {
            Assert((_rgLockQueue.GetPtr(i)->dwFlags & TF_ES_SYNC) == 0);
        }
#endif // DEBUG
    }

    CDocumentInputManager *_dm;

    ITextStoreAnchor *_ptsi;
    BOOL _fCiceroTSI;

    DWORD _dwLastLockReleaseID;

    TfEditCookie _ec;
    int _cEditRef;
    DWORD _dwEditSessionFlags;
    BOOL _fLockHeld; // perf: redundant with _dwlt?
    DWORD _dwlt; // perf: only need 2 bits
    TfClientId _tidInEditSession;
    DWORD _dwPendingLockRequest; // perf: only need 2 bits

    CEditRecord *_pEditRecord;
    BOOL EnsureEditRecord()
    {
       if (!_pEditRecord)
           _pEditRecord = new CEditRecord(this);

       return  _pEditRecord ? TRUE : FALSE;
    }
    BOOL _fLayoutChanged;
    BOOL _fStatusChanged; // perf: redundant w/ _dwStatusChangedFlags?
    DWORD _dwStatusChangedFlags;

    // array of TIP guidatom for both left and right side of the caret.
    TfGuidAtom _gaKeyEventFilterTIP[2];
    BOOL _fInvalidKeyEventFilterTIP;

    ITfContextKeyEventSink *_pICKbdSink;

    DWORD _dwSysFuncPrvCookie; // system function provider cookie

    //
    // TextOwner Property cache
    //
    CProperty *_pPropTextOwner;

    static const GUID *_c_rgPropStyle[];

    CStructArray<TS_QUEUE_ITEM> _rgLockQueue;

    static const IID *_c_rgConnectionIIDs[IC_NUM_CONNECTIONPTS];
    CStructArray<GENERICSINK> _rgSinks[IC_NUM_CONNECTIONPTS];
    CStructArray<CLEANUPSINK> _rgCleanupSinks;

    CStructArray<SPAN> _rgAppTextChanges;

    CComposition *_pCompositionList;

    CRange *_pOnChangeRanges; // ranges with ITfRangeChange sinks

    CContextView *_pActiveView;

    ITfContextOwnerCompositionSink *_pOwnerComposeSink; // may be NULL, be careful

    LONG _cRefEditTransaction;

    BOOL _fInCompositionOp : 1; // TRUE if we're inside a write modification to a composition (ceate, terminate, etc.)
    BOOL _fInUnserialize : 1; // TRUE if we're inside a property _Unserialize

    //
    // App Property Map
    //
    typedef struct _APPPROPMAP
    {
        GUID guidAppProp;
        GUID guidProp;
    } APPPROPMAP;
    CStructArray<APPPROPMAP> _rgAppPropMap;
    APPPROPMAP *FindMapAppProperty(REFGUID guidAppProp);

    //
    // disable PostThreadMessage for LoackRequest.
    //
    ULONG _nLockReqPostDisableRef;

    // aa stuff
    //
    void _InitMSAAHook(IAccServerDocMgr *pAAAdaptor);
    void _UninitMSAAHook(IAccServerDocMgr *pAAAdaptor);

    typedef struct
    {
        ITextStoreAnchor *ptsiOrg; // the original, unwrapped ptsi
        ITextStoreAnchor *pAADoc;  // the wrapped ITextStoreAnchor passed to _pAAAdaptor
    } MSAA_STATE;

    MSAA_STATE *_pMSAAState; // use a struct since we rarely use msaa
    //
    // end aa stuff

#ifdef DEBUG
    BOOL _dbg_fInOnLockGranted;
#endif

    DBG_ID_DECLARE;
};

inline CInputContext *GetCInputContext(IUnknown *punk)
{
    CInputContext *pic;

    punk->QueryInterface(IID_PRIV_CINPUTCONTEXT, (void **)&pic);

    return pic;
}

//+---------------------------------------------------------------------------
//
// SafeRequestLock
//
// ITextStoreAnchor::RequestLock wrapper.
//
// Normally each CInputContext holds a ref to a text store in its _ptsi member.
// But, it's possible that some crazy tip will Pop the context inside a
// RequestLock call, which releases and clears _ptsi.  This will likely crash
// the ptsi code, since after OnLockGranted, the object will be freed.
// So we protect the app by AddRef'ing the ptsi before the RequestLock call.
//----------------------------------------------------------------------------

inline HRESULT SafeRequestLock(ITextStoreAnchor *ptsi, DWORD dwLockFlags, HRESULT *phrSession)
{
    HRESULT hr;

    ptsi->AddRef(); // protect pointer in case someone Pops this context inside the RequestLock

    hr = ptsi->RequestLock(dwLockFlags, phrSession);

    ptsi->Release();

    return hr;
}

#endif // IC_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\ctf\uim\ics.cpp ===
//
// ics.cpp
//

#include "private.h"
#include "tim.h"
#include "dim.h"
#include "ic.h"
#include "emptyic.h"
#include "acp2anch.h"
#include "enumic.h"

//+---------------------------------------------------------------------------
//
// GetTop
//
//----------------------------------------------------------------------------

STDAPI CDocumentInputManager::GetTop(ITfContext **ppic)
{
    return _GetContext(_iStack, ppic);
}

//+---------------------------------------------------------------------------
//
// GetBase
//
//----------------------------------------------------------------------------

STDAPI CDocumentInputManager::GetBase(ITfContext **ppic)
{
    return _GetContext(0, ppic);
}

//+---------------------------------------------------------------------------
//
// _GetContext
//
//----------------------------------------------------------------------------

HRESULT CDocumentInputManager::_GetContext(int iStack, ITfContext **ppic)
{
    if (ppic == NULL)
        return E_INVALIDARG;

    *ppic = NULL;

    if (_iStack == -1)
    {
        Assert(iStack == 0 || iStack == -1); // caller should be GetBottom or internal using _iStack...
        if (!_peic)
        {
            _peic = new CEmptyInputContext(this);

            if (_peic == NULL)
                return E_OUTOFMEMORY;

            if (FAILED(_peic->Init()))
            {
                SafeReleaseClear(_peic);
                return E_FAIL;
            }
        }

        *ppic = _peic;
    }
    else
    {
        Assert(iStack >= 0 && iStack <= _iStack);
        *ppic = _Stack[iStack];
    }
    Assert(*ppic);
    
    (*ppic)->AddRef();

    return S_OK;
}

//+---------------------------------------------------------------------------
//
// CreateContext
//
//----------------------------------------------------------------------------

// this is a constant we removed before cicero ship, but office10 still uses it
// it can be ignored, but it must be accepted as legal
#define TF_PLAINTEXTTSI 0x1

STDAPI CDocumentInputManager::CreateContext(TfClientId tid, DWORD dwFlags, IUnknown *punk, ITfContext **ppic, TfEditCookie *pecTextStore)
{
    CInputContext *pic;
    ITextStoreAnchor *ptsi;
    ITextStoreACP *ptsiACP;
    CThreadInputMgr *tim;
    ITfContextOwnerCompositionSink *pOwnerComposeSink;
    HRESULT hr;

    if (pecTextStore != NULL)
    {
        *pecTextStore = TF_INVALID_EDIT_COOKIE;
    }
    if (ppic != NULL)
    {
        *ppic = NULL;
    }

    if (ppic == NULL || pecTextStore == NULL)
        return E_INVALIDARG;

    if (dwFlags & ~TF_PLAINTEXTTSI)
        return E_INVALIDARG;

    if ((tim = CThreadInputMgr::_GetThis()) == NULL)
        return E_FAIL;

    if (!tim->_IsValidTfClientId(tid))
        return E_INVALIDARG;

    ptsi = NULL;
    pOwnerComposeSink = NULL;

    if (punk != NULL)
    {
        if (g_fNoITextStoreAnchor ||
            punk->QueryInterface(IID_ITextStoreAnchor, (void **)&ptsi) != S_OK ||
            ptsi == NULL)
        {
            if (punk->QueryInterface(IID_ITextStoreACP, (void **)&ptsiACP) != S_OK || ptsiACP == NULL)
            {                
                ptsiACP = NULL;
            }
            else
            {
                ptsi = new CACPWrap(ptsiACP);
                ptsiACP->Release();

                if (ptsi == NULL)
                    return E_OUTOFMEMORY;
            }
        }

        if (punk->QueryInterface(IID_ITfContextOwnerCompositionSink, (void **)&pOwnerComposeSink) != S_OK)
        {
            pOwnerComposeSink = NULL;
        }
    }

    if ((pic = new CInputContext(tid)) == NULL)
    {
        hr = E_OUTOFMEMORY;
        goto Exit;
    }

    if (pic->_Init(tim, this, ptsi, pOwnerComposeSink) != S_OK)
    {
        pic->Release();
        hr = E_FAIL;
        goto Exit;
    }

    *ppic = pic;

    if (ptsi != NULL)
    {
        // caller is doing the ITextStore, so return a back door ec
        *pecTextStore = BACKDOOR_EDIT_COOKIE;
    }

    hr = S_OK;

Exit:
    SafeRelease(ptsi);
    SafeRelease(pOwnerComposeSink);

    return hr;
}

//+---------------------------------------------------------------------------
//
// Push
//
//----------------------------------------------------------------------------

STDAPI CDocumentInputManager::Push(ITfContext *pic)
{
    CInputContext *pcic;

    if (pic == NULL)
        return E_INVALIDARG;

    if (_iStack == ICS_STACK_SIZE - 1)
        return TF_E_STACKFULL;

    pcic = GetCInputContext(pic);
    if (!pcic)
        return E_INVALIDARG;
    
    if (_fPoppingStack)
        return E_UNEXPECTED;

    // we don't need AddRef here, GetCInputContext did AddRef().
    _Stack[++_iStack] = pcic;

    pcic->_AdviseSinks();

    // if it's the first push, we call a notification.
    if (_iStack == 0)
    {
        CThreadInputMgr *tim;
        if ((tim = CThreadInputMgr::_GetThis()) == NULL)
            return E_FAIL;

        tim->_NotifyCallbacks(TIM_INITDIM, this, NULL);
    }

    pcic->_Pushed();

    return S_OK;
}

//+---------------------------------------------------------------------------
//
// Pop
//
//----------------------------------------------------------------------------

STDAPI CDocumentInputManager::Pop(DWORD dwFlags)
{
    CThreadInputMgr *tim;
    if (dwFlags & ~TF_POPF_ALL)
        return E_INVALIDARG;

    if (_iStack == -1)
        return E_FAIL;

    if (_fPoppingStack)
        return E_UNEXPECTED;

    if ((tim = CThreadInputMgr::_GetThis()) == NULL)
        return E_FAIL;

    if (!(dwFlags & TF_POPF_ALL))
    {
        if (!_iStack)
           return E_FAIL;

        _Pop(tim); 
    }
    else
    {
        while(_iStack >= 0)
        { 
            _Pop(tim);
        }

        // clear the focus if this guy has it
        if (tim->_GetFocusDocInputMgr() == this)
        {
            tim->_SetFocus(NULL, TRUE);
        }

        tim->_NotifyCallbacks(TIM_UNINITDIM, this, NULL);
    }

    return S_OK;
}

//+---------------------------------------------------------------------------
//
// _Pop
//
//----------------------------------------------------------------------------

BOOL CDocumentInputManager::_Pop(CThreadInputMgr *tim)
{
    CInputContext *pic;

    Assert(_iStack >= 0);

    pic = _Stack[_iStack];

    // don't let anyone mess with the stack while we adjust it
    _fPoppingStack = TRUE;

    // call _Popped() to release properties and compartments.
    // must do this before _UnadviseSinks while the ITextStore
    // has not yet been released
    pic->_Popped();

    pic->_UnadviseSinks(tim);
    pic->Release();

    _fPoppingStack = FALSE;

    _iStack--;

    return TRUE;
}

//+---------------------------------------------------------------------------
//
// EnumInputContexts
//
//----------------------------------------------------------------------------

STDAPI CDocumentInputManager::EnumContexts(IEnumTfContexts **ppEnum)
{
    CEnumInputContexts *pEnum;

    pEnum = new CEnumInputContexts();
    if (!pEnum)
        return E_OUTOFMEMORY;

    if (!pEnum->_Init(this))
    {
        pEnum->Release();
        return E_FAIL;
    }

    *ppEnum = pEnum;

    return S_OK;
}

//+---------------------------------------------------------------------------
//
// _GetTopIC
//
//----------------------------------------------------------------------------

CInputContext *CDocumentInputManager::_GetTopIC()
{
    if (_iStack == -1)
        return NULL;

    return _Stack[_iStack];
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\ctf\uim\icclean.cpp ===
//
// icclean.cpp
//

#include "private.h"
#include "tim.h"
#include "ic.h"
#include "compose.h"
#include "assembly.h"

class CCleanupShared
{
public:
    CCleanupShared(POSTCLEANUPCALLBACK pfnPostCleanup, LONG_PTR lPrivate)
    {
        _cRef = 1;
        _pfnPostCleanup = pfnPostCleanup;
        _lPrivate = lPrivate;
    }

    ~CCleanupShared()
    {
        SYSTHREAD *psfn = GetSYSTHREAD();
        if (psfn == NULL)
            return;

        if (psfn->ptim != NULL)
        {
            psfn->ptim->_SendEndCleanupNotifications();
        }

        if (_pfnPostCleanup != NULL)
        {
            _pfnPostCleanup(FALSE, _lPrivate);
        }

        if (psfn->ptim != NULL)
        {
            psfn->ptim->_HandlePendingCleanupContext();
        }
    }

    void _AddRef()
    {
        _cRef++;
    }

    LONG _Release()
    {
        LONG cRef = --_cRef;

        if (_cRef == 0)
        {
            delete this;
        }

        return cRef;
    }

private:
    LONG _cRef;
    POSTCLEANUPCALLBACK _pfnPostCleanup;
    LONG_PTR _lPrivate;
};

class CCleanupQueueItem : public CAsyncQueueItem
{
public:
    CCleanupQueueItem(BOOL fSync, CCleanupShared *pcs, CStructArray<TfClientId> *prgClientIds) : CAsyncQueueItem(fSync)
    {
        _prgClientIds = prgClientIds;
        if (!fSync)
        {
            _pcs = pcs;
            _pcs->_AddRef();
        }
    }

    ~CCleanupQueueItem()
    {
        delete _prgClientIds;
        _CheckCleanupShared();
    }

    HRESULT DoDispatch(CInputContext *pic);

private:
    void _CheckCleanupShared()
    {
        // last queue item?
        if (_pcs != NULL)
        {
            _pcs->_Release();
            _pcs = NULL;
        }
    }

    CStructArray<TfClientId> *_prgClientIds;
    CCleanupShared *_pcs;
};

//+---------------------------------------------------------------------------
//
// DoDispatch
//
//----------------------------------------------------------------------------

HRESULT CCleanupQueueItem::DoDispatch(CInputContext *pic)
{
    pic->_CleanupContext(_prgClientIds);

    // if this was the last pending lock, let the caller know
    _CheckCleanupShared();

    return S_OK;
}

//+---------------------------------------------------------------------------
//
// _CleanupContext
//
//----------------------------------------------------------------------------

void CInputContext::_CleanupContext(CStructArray<TfClientId> *prgClientIds)
{
    int i;
    int j;
    CLEANUPSINK *pSink;

    Assert(!(_dwEditSessionFlags & TF_ES_INEDITSESSION)); // shouldn't get this far
    Assert(_tidInEditSession == TF_CLIENTID_NULL); // there should never be another session in progress -- this is not a reentrant func

    _dwEditSessionFlags = (TF_ES_INEDITSESSION | TF_ES_READWRITE | TF_ES_PROPERTY_WRITE);

    //
    // call any tips that want to cleanup
    //
    for (i=0; i<_rgCleanupSinks.Count(); i++)
    {
        pSink = _rgCleanupSinks.GetPtr(i);

        if (prgClientIds != NULL)
        {
            // we only want to call sinks with client ids on this list...
            for (j=0; j<prgClientIds->Count(); j++)
            {
                if (*prgClientIds->GetPtr(j) == pSink->tid)
                    break;
            }
            // if we didn't find the sink's tid, skip it
            if (j == prgClientIds->Count())
                continue;
        }

        _tidInEditSession = pSink->tid;

        pSink->pSink->OnCleanupContext(_ec, this);

        _NotifyEndEdit();
        _IncEditCookie(); // next edit cookie value
    }

    _dwEditSessionFlags = 0;
    _tidInEditSession = TF_CLIENTID_NULL;

    //
    // wipe any left over compositions
    //
    TerminateComposition(NULL);
    Assert(_pCompositionList == NULL);
}

//+---------------------------------------------------------------------------
//
// _GetCleanupListIndex
//
//----------------------------------------------------------------------------

int CInputContext::_GetCleanupListIndex(TfClientId tid)
{
    int i;

    for (i=0; i<_rgCleanupSinks.Count(); i++)
    {
        if (_rgCleanupSinks.GetPtr(i)->tid == tid)
            return i;
    }

    return -1;
}

//+---------------------------------------------------------------------------
//
// _ContextNeedsCleanup
//
//----------------------------------------------------------------------------

BOOL CInputContext::_ContextNeedsCleanup(const GUID *pCatId, LANGID langid, CStructArray<TfClientId> **pprgClientIds)
{
    int i;
    int j;
    CLEANUPSINK *pSink;
    SYSTHREAD *psfn;
    CAssemblyList *pAsmList;
    CAssembly *pAsm;
    ASSEMBLYITEM *pAsmItem;
    TfGuidAtom gaAsmItem;
    TfClientId *ptid;

    *pprgClientIds = NULL; // NULL means "all"

    // any cleanup sinks?
    if (pCatId == NULL)
        return (_pCompositionList != NULL || _rgCleanupSinks.Count() > 0);

    if ((psfn = GetSYSTHREAD()) == NULL)
        goto Exit;

    if ((pAsmList = EnsureAssemblyList(psfn)) == NULL)
        goto Exit;

    if ((pAsm = pAsmList->FindAssemblyByLangId(langid)) == NULL)
        goto Exit;

    // need to lookup each sink in the assembly list
    // if we can find a tip in the list with a matching
    // catid, then we need to lock this ic

    for (i=0; i<_rgCleanupSinks.Count(); i++)
    {
        pSink = _rgCleanupSinks.GetPtr(i);

        for (j=0; j<pAsm->Count(); j++)
        {
            pAsmItem = pAsm->GetItem(j);

            if ((MyRegisterGUID(pAsmItem->clsid, &gaAsmItem) == S_OK &&
                 gaAsmItem == pSink->tid) ||
                (g_gaApp == pSink->tid))
            {
                if (*pprgClientIds == NULL)
                {
                    // need to alloc the [out] array of client ids
                    if ((*pprgClientIds = new CStructArray<TfClientId>) == NULL)
                        return FALSE;
                }

                ptid = (*pprgClientIds)->Append(1);

                if (ptid != NULL)
                {
                    *ptid = pSink->tid;
                }

                break;
            }
        }
    }

Exit:
    return (_pCompositionList != NULL || *pprgClientIds != NULL);
}

//+---------------------------------------------------------------------------
//
// _HandlePendingCleanupContext
//
//----------------------------------------------------------------------------

void CThreadInputMgr::_HandlePendingCleanupContext()
{
    Assert(_fPendingCleanupContext);
    _fPendingCleanupContext = FALSE;

    if (_pPendingCleanupContext == NULL)
        return;

    CLEANUPCONTEXT *pcc = _pPendingCleanupContext;

    _pPendingCleanupContext = NULL;
    _CleanupContextsWorker(pcc);

    cicMemFree(pcc);
}

//+---------------------------------------------------------------------------
//
// _CleanupContexts
//
//----------------------------------------------------------------------------

void CThreadInputMgr::_CleanupContexts(CLEANUPCONTEXT *pcc)
{
    if (pcc->fSync && _fPendingCleanupContext)
    {
        // this can happen from Deactivate
        // can't interrupt another cleanup synchronously, abort the request
        if (pcc->pfnPostCleanup != NULL)
        {
            pcc->pfnPostCleanup(TRUE, pcc->lPrivate);
        }
        return;
    }

    if (_pPendingCleanupContext != NULL)
    {
        // abort the callback and free the pending cleanup
        if (_pPendingCleanupContext->pfnPostCleanup != NULL)
        {
            _pPendingCleanupContext->pfnPostCleanup(TRUE, _pPendingCleanupContext->lPrivate);
        }
        cicMemFree(_pPendingCleanupContext);
        _pPendingCleanupContext = NULL;
    }

    if (!_fPendingCleanupContext)
    {
        _CleanupContextsWorker(pcc);
        return;
    }

    // we've interrupted a cleanup in progress

    // allocate some space for the params
    if ((_pPendingCleanupContext = (CLEANUPCONTEXT *)cicMemAlloc(sizeof(CLEANUPCONTEXT))) == NULL)
    {
        if (pcc->pfnPostCleanup != NULL)
        {
            // abort the cleanup
            pcc->pfnPostCleanup(TRUE, pcc->lPrivate);
        }
        return;
    }

    *_pPendingCleanupContext = *pcc;
}

//+---------------------------------------------------------------------------
//
// _CleanupContexts
//
//----------------------------------------------------------------------------

void CThreadInputMgr::_CleanupContextsWorker(CLEANUPCONTEXT *pcc)
{
    int iDim;
    int iContext;
    CDocumentInputManager *dim;
    CInputContext *pic;
    CCleanupQueueItem *pItem;
    HRESULT hr;
    CCleanupShared *pcs;
    CStructArray<TfClientId> *prgClientIds;

    _fPendingCleanupContext = TRUE;
    pcs = NULL;

    _CalcAndSendBeginCleanupNotifications(pcc);

    // enum all the ic's on this thread
    for (iDim = 0; iDim < _rgdim.Count(); iDim++)
    {
        dim = _rgdim.Get(iDim);

        for (iContext = 0; iContext <= dim->_GetCurrentStack(); iContext++)
        {
            pic = dim->_GetIC(iContext);

            if (!pic->_ContextNeedsCleanup(pcc->pCatId, pcc->langid, &prgClientIds))
                continue;

            if (!pcc->fSync && pcs == NULL)
            {
                // allocate a shared counter
                if ((pcs = new CCleanupShared(pcc->pfnPostCleanup, pcc->lPrivate)) == NULL)
                {
                    delete prgClientIds;
                    return;
                }
            }

            // queue an async callback
            if (pItem = new CCleanupQueueItem(pcc->fSync, pcs, prgClientIds))
            {
                pItem->_CheckReadOnly(pic);

                if (pic->_QueueItem(pItem->GetItem(), FALSE, &hr) != S_OK)
                {
                    Assert(0); // couldn't get app lock
                }

                pItem->_Release();
            }
        }
    }

    if (pcs == NULL)
    {
        // we didn't need to allocate any shared ref (either no ic's, or lock reqs were sync only)
        _SendEndCleanupNotifications();

        if (pcc->pfnPostCleanup != NULL)
        {
            pcc->pfnPostCleanup(FALSE, pcc->lPrivate);
        }
        _HandlePendingCleanupContext();
    }
    else
    {
        // release our ref
        pcs->_Release();
    }
}

//+---------------------------------------------------------------------------
//
// _CalcAndSendBeginCleanupNotifications
//
//----------------------------------------------------------------------------

void CThreadInputMgr::_CalcAndSendBeginCleanupNotifications(CLEANUPCONTEXT *pcc)
{
    UINT i;
    int j;
    int iDim;
    int iContext;
    CDocumentInputManager *dim;
    CInputContext *pic;
    CTip *tip;
    CStructArray<TfClientId> *prgClientIds;

    // first clear the _fNeedCleanupCall for all tips
    for (i=0; i<_GetTIPCount(); i++)
    {
        _rgTip.Get(i)->_fNeedCleanupCall = FALSE;
    }

    // now set the flag where appropriate
    // enum all the ic's on this thread
    for (iDim = 0; iDim < _rgdim.Count(); iDim++)
    {
        dim = _rgdim.Get(iDim);

        for (iContext = 0; iContext <= dim->_GetCurrentStack(); iContext++)
        {
            pic = dim->_GetIC(iContext);

            if (!pic->_ContextNeedsCleanup(pcc->pCatId, pcc->langid, &prgClientIds))
                continue;

            for (i=0; i<_GetTIPCount(); i++)
            {
                tip = _rgTip.Get(i);

                if (tip->_pCleanupDurationSink == NULL)
                    continue; // no sink, no notification

                if (prgClientIds == NULL)
                {
                    // all sinks on this ic need callbacks
                    for (j=0; j<pic->_GetCleanupSinks()->Count(); j++)
                    {
                        if (pic->_GetCleanupSinks()->GetPtr(j)->tid == tip->_guidatom)
                        {
                            tip->_fNeedCleanupCall = TRUE;
                            break;
                        }
                    }
                }
                else
                {
                    // just the tips in prgClientIds need callbacks
                    for (j=0; j<prgClientIds->Count(); j++)
                    {
                        if (*prgClientIds->GetPtr(j) == tip->_guidatom)
                        {
                            tip->_fNeedCleanupCall = TRUE;
                            break;
                        }
                    }
                }
            }

            delete prgClientIds;
        }
    }

    // now send the notifications
    for (i=0; i<_GetTIPCount(); i++)
    {
        tip = _rgTip.Get(i);

        if (tip->_fNeedCleanupCall)
        {
            Assert(tip->_pCleanupDurationSink != NULL);
            tip->_pCleanupDurationSink->OnStartCleanupContext();
        }
    }
}

//+---------------------------------------------------------------------------
//
// _SendEndCleanupNotifications
//
//----------------------------------------------------------------------------

void CThreadInputMgr::_SendEndCleanupNotifications()
{
    CTip *tip;
    UINT i;

    for (i=0; i<_GetTIPCount(); i++)
    {
        tip = _rgTip.Get(i);

        if (tip->_fNeedCleanupCall)
        {
            if (tip->_pCleanupDurationSink != NULL)
            {
                tip->_pCleanupDurationSink->OnEndCleanupContext();
            }
            tip->_fNeedCleanupCall = FALSE;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\ctf\uim\ic.cpp ===
//
// ic.cpp
//

#include "private.h"
#include "ic.h"
#include "range.h"
#include "tim.h"
#include "prop.h"
#include "tsi.h"
#include "rprop.h"
#include "funcprv.h"
#include "immxutil.h"
#include "acp2anch.h"
#include "dim.h"
#include "rangebk.h"
#include "view.h"
#include "compose.h"
#include "anchoref.h"
#include "dam.h"

#define TW_ICOWNERSINK_COOKIE 0x80000000 // high bit must be set to avoid conflict with GenericAdviseSink!
#define TW_ICKBDSINK_COOKIE   0x80000001 // high bit must be set to avoid conflict with GenericAdviseSink!

DBG_ID_INSTANCE(CInputContext);

/* 12e53b1b-7d7f-40bd-8f88-4603ee40cf58 */
extern const IID IID_PRIV_CINPUTCONTEXT = { 0x12e53b1b, 0x7d7f, 0x40bd, {0x8f, 0x88, 0x46, 0x03, 0xee, 0x40, 0xcf, 0x58} };

const IID *CInputContext::_c_rgConnectionIIDs[IC_NUM_CONNECTIONPTS] =
{
    &IID_ITfTextEditSink,
    &IID_ITfTextLayoutSink,
    &IID_ITfStatusSink,
    &IID_ITfStartReconversionNotifySink,
    &IID_ITfEditTransactionSink,
};

//+---------------------------------------------------------------------------
//
// ctor
//
//----------------------------------------------------------------------------

CInputContext::CInputContext(TfClientId tid)
              : CCompartmentMgr(tid, COMPTYPE_IC)
{
    Dbg_MemSetThisNameIDCounter(TEXT("CInputContext"), PERF_CONTEXT_COUNTER);

    // we sometimes use _dwLastLockReleaseID-1, which must still be > IGNORE_LAST_LOCKRELEASED
    // Issue: need to handle wrap-around case
    _dwLastLockReleaseID = (DWORD)((int)IGNORE_LAST_LOCKRELEASED + 2);
}


//+---------------------------------------------------------------------------
//
// _Init
//
//----------------------------------------------------------------------------

HRESULT CInputContext::_Init(CThreadInputMgr *tim,
                             CDocumentInputManager *dm, ITextStoreAnchor *ptsi,
                             ITfContextOwnerCompositionSink *pOwnerComposeSink)
{
    CTextStoreImpl *ptsiACP;

    _dm = dm; // no need to AddRef, cleared when the dm dies

    // scramble the _ec a bit to help debug calling EditSession on the wrong ic
    _ec = (TfEditCookie)((DWORD)(UINT_PTR)this<<8);
    if (_ec < EC_MIN) // for portability, win32 pointers can't have values this low
    {
        _ec = EC_MIN;
    }

    if (ptsi == NULL)
    {
        if ((ptsiACP = new CTextStoreImpl(this)) == NULL)
            return E_OUTOFMEMORY;

        _ptsi = new CACPWrap(ptsiACP);
        ptsiACP->Release();

        if (_ptsi == NULL)
            return E_OUTOFMEMORY;

        _fCiceroTSI = TRUE;
    }
    else
    {
        _ptsi = ptsi;
        _ptsi->AddRef();

        Assert(_fCiceroTSI == FALSE);
    }

    _pOwnerComposeSink = pOwnerComposeSink;
    if (_pOwnerComposeSink != NULL)
    {
        _pOwnerComposeSink->AddRef();
    }

    Assert(_pMSAAState == NULL);
    if (tim->_IsMSAAEnabled())
    {
        _InitMSAAHook(tim->_GetAAAdaptor());
    }

    Assert(_dwEditSessionFlags == 0);
    Assert(_dbg_fInOnLockGranted == FALSE);

    Assert(_fLayoutChanged == FALSE);
    Assert(_dwStatusChangedFlags == 0);
    Assert(_fStatusChanged == FALSE);

    _tidInEditSession = TF_CLIENTID_NULL;

    Assert(_pPropTextOwner == NULL);
    _dwSysFuncPrvCookie = GENERIC_ERROR_COOKIE;

    _gaKeyEventFilterTIP[LEFT_FILTERTIP] = TF_INVALID_GUIDATOM;
    _gaKeyEventFilterTIP[RIGHT_FILTERTIP] = TF_INVALID_GUIDATOM;
    _fInvalidKeyEventFilterTIP = TRUE;

    _pEditRecord = new CEditRecord(this); // perf: delay load
    if (!_pEditRecord)
        return E_OUTOFMEMORY;

    Assert(_pActiveView == NULL);

    return S_OK;
}

//+---------------------------------------------------------------------------
//
// dtor
//
//----------------------------------------------------------------------------

CInputContext::~CInputContext()
{
    CProperty *pProp;
    int i;
    SPAN *span;

    // being paranoid...these should be NULL
    Assert(_pICKbdSink == NULL);

    // nix any allocated properties
    while (_pPropList != NULL)
    {
        pProp = _pPropList;
        _pPropList = _pPropList->_pNext;
        delete pProp;
    }

    // nix any cached app changes
    for (i=0; i<_rgAppTextChanges.Count(); i++)
    {
        span = _rgAppTextChanges.GetPtr(i);
        span->paStart->Release();
        span->paEnd->Release();
    }

    Assert(_pMSAAState == NULL); // should have already cleaned up msaa hook

    Assert(_pOwnerComposeSink == NULL); // should cleared in _UnadviseSinks
    SafeRelease(_pOwnerComposeSink);

    Assert(_ptsi == NULL); // should be NULL, cleared in _UnadviseSinks
    SafeRelease(_ptsi);

    Assert(_pCompositionList == NULL); // all compositions should be terminated
    Assert(_rgLockQueue.Count() == 0); // all queue items should be freed

    //
    // all pending flag should be cleared 
    // Otherwise psfn->_dwfLockRequestICRef could be broken..
    //
    Assert(_dwPendingLockRequest == 0); 
}

//+---------------------------------------------------------------------------
//
// _AdviseSinks
//
// Called when this ic is pushed.
//
//----------------------------------------------------------------------------

void CInputContext::_AdviseSinks()
{
    if (_ptsi != NULL)
    {
        // attach our ITextStoreAnchorSink
        _ptsi->AdviseSink(IID_ITextStoreAnchorSink, SAFECAST(this, ITextStoreAnchorSink *), TS_AS_ALL_SINKS);
    }
}

//+---------------------------------------------------------------------------
//
// _UnadviseSinks
//
// Called when this ic is popped.
// All references to the ITextStore impl should be released here.
//
//----------------------------------------------------------------------------

void CInputContext::_UnadviseSinks(CThreadInputMgr *tim)
{
    // kill any compositions
    _AbortCompositions();

    SafeReleaseClear(_pEditRecord);
    SafeReleaseClear(_pActiveView);

    // for now just skip any pending edit sessions
    // do this here in case any of the edit sessions
    // have a ref to this ic
    
    _AbortQueueItems();

    if (_ptsi != NULL)
    {
        // detach our ITextStoreAnchorSink
        _ptsi->UnadviseSink(SAFECAST(this, ITextStoreAnchorSink *));
        // if there is an ic owner sink, unadvise it now while we still can
        // this is to help buggy clients
        _UnadviseOwnerSink();

        // if we're msaa hooked, unhook now
        // must do this before Releasing _ptsi
        if (_pMSAAState != NULL)
        {
            Assert(tim->_GetAAAdaptor() != NULL);
            _UninitMSAAHook(tim->_GetAAAdaptor());
        }

        // and let the ptsi go
        _ptsi->Release();
        _ptsi = NULL;
    }

    SafeReleaseClear(_pOwnerComposeSink);

    // our owning doc is no longer valid
    _dm = NULL;
}

//+---------------------------------------------------------------------------
//
// AdviseSink
//
//----------------------------------------------------------------------------

STDAPI CInputContext::AdviseSink(REFIID riid, IUnknown *punk, DWORD *pdwCookie)
{
    ITfContextOwner *pICOwnerSink;
    CTextStoreImpl *ptsi;
    IServiceProvider *psp;
    HRESULT hr;

    if (pdwCookie == NULL)
        return E_INVALIDARG;

    *pdwCookie = GENERIC_ERROR_COOKIE;

    if (punk == NULL)
        return E_INVALIDARG;

    if (!_IsConnected())
        return TF_E_DISCONNECTED;

    if (IsEqualIID(riid, IID_ITfContextOwner))
    {
        // there can be only one ic owner sink, so special case it
        if (!_IsCiceroTSI())
        {
            Assert(0); // sink should only used for def tsi
            return E_UNEXPECTED;
        }

        // use QueryService to get the tsi since msaa may be wrapping it
        if (_ptsi->QueryInterface(IID_IServiceProvider, (void **)&psp) != S_OK)
        {
            Assert(0);
            return E_UNEXPECTED;
        }

        hr = psp->QueryService(GUID_SERVICE_TF, IID_PRIV_CTSI, (void **)&ptsi);

        psp->Release();

        if (hr != S_OK)
        {
            Assert(0);
            return E_UNEXPECTED;
        }

        pICOwnerSink = NULL;

        if (ptsi->_HasOwner())
        {
            hr = CONNECT_E_ADVISELIMIT;
            goto ExitOwner;
        }

        if (FAILED(punk->QueryInterface(IID_ITfContextOwner, 
                                        (void **)&pICOwnerSink)))
        {
            hr = E_UNEXPECTED;
            goto ExitOwner;
        }

        ptsi->_AdviseOwner(pICOwnerSink);

ExitOwner:
        ptsi->Release();
        SafeRelease(pICOwnerSink);

        if (hr == S_OK)
        {
            *pdwCookie = TW_ICOWNERSINK_COOKIE;
        }

        return hr;
    }
    else if (IsEqualIID(riid, IID_ITfContextKeyEventSink))
    {
        // there can be only one ic kbd sink, so special case it
        if (_pICKbdSink != NULL)
            return CONNECT_E_ADVISELIMIT;

        if (FAILED(punk->QueryInterface(IID_ITfContextKeyEventSink, 
                                        (void **)&_pICKbdSink)))
            return E_UNEXPECTED;

        *pdwCookie = TW_ICKBDSINK_COOKIE;

        return S_OK;
    }

    return GenericAdviseSink(riid, punk, _c_rgConnectionIIDs, _rgSinks, IC_NUM_CONNECTIONPTS, pdwCookie);
}

//+---------------------------------------------------------------------------
//
// UnadviseSink
//
//----------------------------------------------------------------------------

STDAPI CInputContext::UnadviseSink(DWORD dwCookie)
{
    if (dwCookie == TW_ICOWNERSINK_COOKIE)
    {
        // there can be only one ic owner sink, so special case it
        return _UnadviseOwnerSink();
    }
    else if (dwCookie == TW_ICKBDSINK_COOKIE)
    {
        // there can be only one ic owner sink, so special case it
        if (_pICKbdSink == NULL)
            return CONNECT_E_NOCONNECTION;

        SafeReleaseClear(_pICKbdSink);
        return S_OK;
    }

    return GenericUnadviseSink(_rgSinks, IC_NUM_CONNECTIONPTS, dwCookie);
}

//+---------------------------------------------------------------------------
//
// AdviseSingleSink
//
//----------------------------------------------------------------------------

STDAPI CInputContext::AdviseSingleSink(TfClientId tid, REFIID riid, IUnknown *punk)
{
    CTip *ctip;
    CLEANUPSINK *pCleanup;
    CThreadInputMgr *tim;
    ITfCleanupContextSink *pSink;

    if (punk == NULL)
        return E_INVALIDARG;

    if ((tim = CThreadInputMgr::_GetThis()) == NULL)
        return E_FAIL;

    if (!tim->_GetCTipfromGUIDATOM(tid, &ctip) && (tid != g_gaApp))
        return E_INVALIDARG;

    if (IsEqualIID(riid, IID_ITfCleanupContextSink))
    {
        if (_GetCleanupListIndex(tid) >= 0)
             return CONNECT_E_ADVISELIMIT;

        if (punk->QueryInterface(IID_ITfCleanupContextSink, (void **)&pSink) != S_OK)
            return E_NOINTERFACE;

        if ((pCleanup = _rgCleanupSinks.Append(1)) == NULL)
        {
            pSink->Release();
            return E_OUTOFMEMORY;
        }

        pCleanup->tid = tid;
        pCleanup->pSink = pSink;

        return S_OK;
    }

    return CONNECT_E_CANNOTCONNECT;
}

//+---------------------------------------------------------------------------
//
// UnadviseSingleSink
//
//----------------------------------------------------------------------------

STDAPI CInputContext::UnadviseSingleSink(TfClientId tid, REFIID riid)
{
    int i;

    if (IsEqualIID(riid, IID_ITfCleanupContextSink))
    {
        if ((i = _GetCleanupListIndex(tid)) < 0)
             return CONNECT_E_NOCONNECTION;

        _rgCleanupSinks.GetPtr(i)->pSink->Release();
        _rgCleanupSinks.Remove(i, 1);

        return S_OK;
    }

    return CONNECT_E_NOCONNECTION;
}

//+---------------------------------------------------------------------------
//
// _UnadviseOwnerSink
//
//----------------------------------------------------------------------------

HRESULT CInputContext::_UnadviseOwnerSink()
{
    IServiceProvider *psp;
    CTextStoreImpl *ptsi;
    HRESULT hr;

    if (!_IsCiceroTSI())
        return E_UNEXPECTED; // only our default tsi can accept an owner sink

    if (!_IsConnected()) // _ptsi is not safe if disconnected
        return TF_E_DISCONNECTED;

    // use QueryService to get the tsi since msaa may be wrapping it
    if (_ptsi->QueryInterface(IID_IServiceProvider, (void **)&psp) != S_OK)
    {
        Assert(0);
        return E_UNEXPECTED;
    }

    hr = psp->QueryService(GUID_SERVICE_TF, IID_PRIV_CTSI, (void **)&ptsi);

    psp->Release();

    if (hr != S_OK)
    {
        Assert(0);
        return E_UNEXPECTED;
    }

    if (!ptsi->_HasOwner())
    {
        hr = CONNECT_E_NOCONNECTION;
        goto Exit;
    }

    ptsi->_UnadviseOwner();

    hr = S_OK;

Exit:
    ptsi->Release();
    return hr;
}

//+---------------------------------------------------------------------------
//
// GetProperty
//
//----------------------------------------------------------------------------

STDAPI CInputContext::GetProperty(REFGUID rguidProp, ITfProperty **ppv)
{
    CProperty *property;
    HRESULT hr;

    if (!_IsConnected())
        return TF_E_DISCONNECTED;

    hr = _GetProperty(rguidProp, &property);

    *ppv = property;
    return hr;
}

//+---------------------------------------------------------------------------
//
// _GetProperty
//
//----------------------------------------------------------------------------

HRESULT CInputContext::_GetProperty(REFGUID rguidProp, CProperty **ppv)
{
    CProperty *pProp = _FindProperty(rguidProp);
    DWORD dwAuthority = PROPA_NONE;
    TFPROPERTYSTYLE propStyle;
    DWORD dwPropFlags;

    if (ppv == NULL)
        return E_INVALIDARG;

    *ppv = pProp;

    if (pProp != NULL)
    {
        (*ppv)->AddRef();
        return S_OK;
    }

    //
    // Overwrite propstyle for known properties.
    //
    if (IsEqualGUID(rguidProp, GUID_PROP_ATTRIBUTE))
    {
        propStyle = TFPROPSTYLE_STATIC;
        dwAuthority = PROPA_FOCUSRANGE | PROPA_TEXTOWNER | PROPA_WONT_SERIALZE;
        dwPropFlags = PROPF_VTI4TOGUIDATOM;
    }
    else if (IsEqualGUID(rguidProp, GUID_PROP_READING))
    {
        propStyle = TFPROPSTYLE_CUSTOM;
        dwPropFlags = 0;
    }
    else if (IsEqualGUID(rguidProp, GUID_PROP_COMPOSING))
    {
        propStyle = TFPROPSTYLE_STATICCOMPACT;
        dwAuthority = PROPA_READONLY | PROPA_WONT_SERIALZE;
        dwPropFlags = 0;
    }
    else if (IsEqualGUID(rguidProp, GUID_PROP_LANGID))
    {
        propStyle = TFPROPSTYLE_STATICCOMPACT;
        dwPropFlags = 0;
    }
    else if (IsEqualGUID(rguidProp, GUID_PROP_TEXTOWNER))
    {
        propStyle = TFPROPSTYLE_STATICCOMPACT;
        dwAuthority = PROPA_TEXTOWNER;
        dwPropFlags = PROPF_ACCEPTCORRECTION | PROPF_VTI4TOGUIDATOM;
    }
    else
    {
        propStyle = _GetPropStyle(rguidProp);
        dwPropFlags = 0;

        // nb: after a property is created, the PROPF_MARKUP_COLLECTION is never
        // again set.  We make sure to call ITfDisplayAttributeCollectionProvider::GetCollection
        // before activating tips that use the property GUID.
        if (CDisplayAttributeMgr::_IsInCollection(rguidProp))
        {
            dwPropFlags = PROPF_MARKUP_COLLECTION;
        }
    }
 
    //
    //  Allow NULL propStyle for only predefined properties.
    //  Check the property style is correct.
    //
    if (!propStyle)
    { 
        Assert(0);
        return E_FAIL;
    }

    pProp = new CProperty(this, rguidProp, propStyle, dwAuthority, dwPropFlags);

    if (pProp)
    {
        pProp->_pNext = _pPropList;
        _pPropList = pProp;

        // Update _pPropTextOner now.
        if (IsEqualGUID(rguidProp, GUID_PROP_TEXTOWNER))
             _pPropTextOwner = pProp;
    }

    if (*ppv = pProp)
    {
        (*ppv)->AddRef();
        return S_OK;
    }

    return E_OUTOFMEMORY;
}

//+---------------------------------------------------------------------------
//
// GetTextOwnerProperty
//
//----------------------------------------------------------------------------

CProperty *CInputContext::GetTextOwnerProperty()
{
    ITfProperty *prop;

    // GetProperty initializes _pPropTextOwner.

    if (!_pPropTextOwner)
    {
        GetProperty(GUID_PROP_TEXTOWNER, &prop);
        SafeRelease(prop);
    }

    Assert(_pPropTextOwner);
    return _pPropTextOwner;
}

//+---------------------------------------------------------------------------
//
// _FindProperty
//
//----------------------------------------------------------------------------

CProperty *CInputContext::_FindProperty(TfGuidAtom gaProp)
{
    CProperty *pProp = _pPropList;

    // perf: should this be faster?
    while (pProp)
    {
         if (pProp->GetPropGuidAtom() == gaProp)
             return pProp;

         pProp = pProp->_pNext;
    }

    return NULL;
}

//+---------------------------------------------------------------------------
//
// _PropertyTextUpdate
//
//----------------------------------------------------------------------------

void CInputContext::_PropertyTextUpdate(DWORD dwFlags, IAnchor *paStart, IAnchor *paEnd)
{
    CProperty *pProp = _pPropList;
    DWORD dwPrevESFlag = _dwEditSessionFlags;

    _dwEditSessionFlags |= TF_ES_INNOTIFY;

    while (pProp)
    {
        // clear the values over the edited text
        pProp->Clear(paStart, paEnd, dwFlags, TRUE /* fTextUpdate */);

        if (pProp->GetPropStyle() == TFPROPSTYLE_STATICCOMPACT ||
            pProp->GetPropStyle() == TFPROPSTYLE_CUSTOM_COMPACT)
        {
            pProp->Defrag(paStart, paEnd);
        }

        pProp = pProp->_pNext;
    }

    _dwEditSessionFlags = dwPrevESFlag;
}

//+---------------------------------------------------------------------------
//
// _GetStartOrEnd
//
//----------------------------------------------------------------------------

HRESULT CInputContext::_GetStartOrEnd(TfEditCookie ec, BOOL fStart, ITfRange **ppStart)
{
    CRange *range;
    IAnchor *paStart;
    IAnchor *paEnd;
    HRESULT hr;

    if (ppStart == NULL)
        return E_INVALIDARG;

    *ppStart = NULL;

    if (!_IsConnected())
        return TF_E_DISCONNECTED;

    if (!_IsValidEditCookie(ec, TF_ES_READ))
    {
        Assert(0);
        return TF_E_NOLOCK;
    }

    hr = fStart ? _ptsi->GetStart(&paStart) : _ptsi->GetEnd(&paStart);

    if (hr == E_NOTIMPL)
        return E_NOTIMPL;
    if (hr != S_OK)
        return E_FAIL;

    hr = E_FAIL;

    if (FAILED(paStart->Clone(&paEnd)))
        goto Exit;

    if ((range = new CRange) == NULL)
    {
        hr = E_OUTOFMEMORY;
        goto Exit;
    }
    if (!range->_InitWithDefaultGravity(this, OWN_ANCHORS, paStart, paEnd))
    {
        range->Release();
        goto Exit;
    }

    *ppStart = (ITfRangeAnchor *)range;

    hr = S_OK;

Exit:
    if (hr != S_OK)
    {
        SafeRelease(paStart);
        SafeRelease(paEnd);
    }

    return hr;
}

//+---------------------------------------------------------------------------
//
// CreateRange
//
//----------------------------------------------------------------------------

STDAPI CInputContext::CreateRange(IAnchor *paStart, IAnchor *paEnd, ITfRangeAnchor **ppRange)
{
    CRange *range;

    if (ppRange == NULL)
        return E_INVALIDARG;

    *ppRange = NULL;

    if (paStart == NULL || paEnd == NULL)
        return E_INVALIDARG;

    if (CompareAnchors(paStart, paEnd) > 0)
        return E_INVALIDARG;

    if ((range = new CRange) == NULL)
        return E_OUTOFMEMORY;

    if (!range->_InitWithDefaultGravity(this, COPY_ANCHORS, paStart, paEnd))
    {
        range->Release();
        return E_FAIL;
    }

    *ppRange = range;

    return S_OK;
}

//+---------------------------------------------------------------------------
//
// CreateRange
//
//----------------------------------------------------------------------------

STDAPI CInputContext::CreateRange(LONG acpStart, LONG acpEnd, ITfRangeACP **ppRange)
{
    IServiceProvider *psp;
    CRange *range;
    CACPWrap *pACPWrap;
    IAnchor *paStart;
    IAnchor *paEnd;
    HRESULT hr;

    if (ppRange == NULL)
        return E_INVALIDARG;

    pACPWrap = NULL;
    *ppRange = NULL;
    paEnd = NULL;
    hr = E_FAIL;

    if (acpStart > acpEnd)
        return E_INVALIDARG;

    if (_ptsi->QueryInterface(IID_IServiceProvider, (void **)&psp) == S_OK)
    {
        if (psp->QueryService(GUID_SERVICE_TF, IID_PRIV_ACPWRAP, (void **)&pACPWrap) == S_OK)
        {
            // the actual impl is acp based, so this is easy
            if ((paStart = pACPWrap->_CreateAnchorACP(acpStart, TS_GR_BACKWARD)) == NULL)
                goto Exit;
            if ((paEnd = pACPWrap->_CreateAnchorACP(acpEnd, TS_GR_FORWARD)) == NULL)
                goto Exit;
        }
        else
        {
            // in case QueryService sets it on failure to garbage...
            pACPWrap = NULL;
        }
        psp->Release();
    }

    if (paEnd == NULL) // failure above?
    {
        Assert(0); // who's calling this?
        // caller should know whether or not it has an acp text store.
        // we don't, so we won't support this case.
        hr = E_FAIL;
        goto Exit;
    }

    if ((range = new CRange) == NULL)
    {
        hr = E_OUTOFMEMORY;
        goto Exit;
    }

    if (!range->_InitWithDefaultGravity(this, OWN_ANCHORS, paStart, paEnd))
    {
        range->Release();
        goto Exit;
    }

    *ppRange = range;

    hr = S_OK;

Exit:
    SafeRelease(pACPWrap);
    if (hr != S_OK)
    {
        SafeRelease(paStart);
        SafeRelease(paEnd);
    }
    return hr;
}

//+---------------------------------------------------------------------------
//
// _Pushed
//
//----------------------------------------------------------------------------

void CInputContext::_Pushed()
{
    CThreadInputMgr *tim;
    if ((tim = CThreadInputMgr::_GetThis()) != NULL)
        tim->_NotifyCallbacks(TIM_INITIC, NULL, this);
}

//+---------------------------------------------------------------------------
//
// _Popped
//
//----------------------------------------------------------------------------

void CInputContext::_Popped()
{
    CThreadInputMgr *tim;
    if ((tim = CThreadInputMgr::_GetThis()) != NULL)
        tim->_NotifyCallbacks(TIM_UNINITIC, NULL, this);

    //
    // We release all properties and property stores.
    //
    CProperty *pProp;

    while (_pPropList != NULL)
    {
        pProp = _pPropList;
        _pPropList = _pPropList->_pNext;
        pProp->Release();
    }
    // we just free up the cached text property, so make sure
    // we don't try to use it later!
    _pPropTextOwner = NULL;

    //
    // We release all compartments.
    //
    CleanUp();
}

//+---------------------------------------------------------------------------
//
// _GetPropStyle
//
//----------------------------------------------------------------------------

const GUID *CInputContext::_c_rgPropStyle[] =
{
    &GUID_TFCAT_PROPSTYLE_CUSTOM,
    // {0x24af3031,0x852d,0x40a2,{0xbc,0x09,0x89,0x92,0x89,0x8c,0xe7,0x22}},
    &GUID_TFCAT_PROPSTYLE_STATIC,
    // {0x565fb8d8,0x6bd4,0x4ca1,{0xb2,0x23,0x0f,0x2c,0xcb,0x8f,0x4f,0x96}},
    &GUID_TFCAT_PROPSTYLE_STATICCOMPACT,
    // {0x85f9794b,0x4d19,0x40d8,{0x88,0x64,0x4e,0x74,0x73,0x71,0xa6,0x6d}}
    &GUID_TFCAT_PROPSTYLE_CUSTOM_COMPACT,
};

TFPROPERTYSTYLE CInputContext::_GetPropStyle(REFGUID rguidProp)
{
    GUID guidStyle = GUID_NULL;

    CCategoryMgr::s_FindClosestCategory(rguidProp, 
                                        &guidStyle, 
                                        _c_rgPropStyle, 
                                        ARRAYSIZE(_c_rgPropStyle));

    if (IsEqualGUID(guidStyle, GUID_TFCAT_PROPSTYLE_CUSTOM))
        return TFPROPSTYLE_CUSTOM;
    else if (IsEqualGUID(guidStyle, GUID_TFCAT_PROPSTYLE_STATIC))
        return TFPROPSTYLE_STATIC;
    else if (IsEqualGUID(guidStyle, GUID_TFCAT_PROPSTYLE_STATICCOMPACT))
        return TFPROPSTYLE_STATICCOMPACT;
    else if (IsEqualGUID(guidStyle, GUID_TFCAT_PROPSTYLE_CUSTOM_COMPACT))
        return TFPROPSTYLE_CUSTOM_COMPACT;

    return TFPROPSTYLE_NULL;
}

//+---------------------------------------------------------------------------
//
// Serialize
//
//----------------------------------------------------------------------------

STDAPI CInputContext::Serialize(ITfProperty *pProp, ITfRange *pRange, TF_PERSISTENT_PROPERTY_HEADER_ACP *pHdr, IStream *pStream)
{
    ITextStoreACPServices *ptss;
    HRESULT hr;

    if (pHdr == NULL)
        return E_INVALIDARG;

    memset(pHdr, 0, sizeof(*pHdr));

    if (!_IsCiceroTSI())
        return E_UNEXPECTED;

    if (_ptsi->QueryInterface(IID_ITextStoreACPServices, (void **)&ptss) != S_OK)
        return E_FAIL;

    hr = ptss->Serialize(pProp, pRange, pHdr, pStream);

    ptss->Release();

    return hr;
}

//+---------------------------------------------------------------------------
//
// Unserialize
//
//----------------------------------------------------------------------------

STDAPI CInputContext::Unserialize(ITfProperty *pProp, const TF_PERSISTENT_PROPERTY_HEADER_ACP *pHdr, IStream *pStream, ITfPersistentPropertyLoaderACP *pLoader)
{
    ITextStoreACPServices *ptss;
    HRESULT hr;

    if (!_IsCiceroTSI())
        return E_UNEXPECTED;

    if (_ptsi->QueryInterface(IID_ITextStoreACPServices, (void **)&ptss) != S_OK)
        return E_FAIL;

    hr = ptss->Unserialize(pProp, pHdr, pStream, pLoader);

    ptss->Release();

    return hr;
}


//+---------------------------------------------------------------------------
//
// GetDocumentMgr
//
//----------------------------------------------------------------------------

STDAPI CInputContext::GetDocumentMgr(ITfDocumentMgr **ppDm)
{
    CDocumentInputManager *dm;

    if (ppDm == NULL)
        return E_INVALIDARG;

    *ppDm = NULL;

    if ((dm = _GetDm()) == NULL)
        return S_FALSE; // the ic has been popped

    *ppDm = dm;
    (*ppDm)->AddRef();

    return S_OK;
}

//+---------------------------------------------------------------------------
//
// EnumProperties
//
//----------------------------------------------------------------------------

STDAPI CInputContext::EnumProperties(IEnumTfProperties **ppEnum)
{
    CEnumProperties *pEnum;

    if (ppEnum == NULL)
        return E_INVALIDARG;

    *ppEnum = NULL;

    if (!_IsConnected())
        return TF_E_DISCONNECTED;

    pEnum = new CEnumProperties;

    if (!pEnum)
        return E_OUTOFMEMORY;

    if (!pEnum->_Init(this))
        return E_FAIL;

    *ppEnum = pEnum;

    return S_OK;
}
//+---------------------------------------------------------------------------
//
// GetStart
//
//----------------------------------------------------------------------------

STDAPI CInputContext::GetStart(TfEditCookie ec, ITfRange **ppStart)
{
    return _GetStartOrEnd(ec, TRUE, ppStart);
}

//+---------------------------------------------------------------------------
//
// GetEnd
//
//----------------------------------------------------------------------------

STDAPI CInputContext::GetEnd(TfEditCookie ec, ITfRange **ppEnd)
{
    return _GetStartOrEnd(ec, FALSE, ppEnd);
}

//+---------------------------------------------------------------------------
//
// GetStatus
//
//----------------------------------------------------------------------------

STDAPI CInputContext::GetStatus(TS_STATUS *pdcs)
{
    if (pdcs == NULL)
        return E_INVALIDARG;

    memset(pdcs, 0, sizeof(*pdcs));

    if (!_IsConnected())
        return TF_E_DISCONNECTED;

    return _GetTSI()->GetStatus(pdcs);
}

//+---------------------------------------------------------------------------
//
// CreateRangeBackup
//
//----------------------------------------------------------------------------

STDAPI CInputContext::CreateRangeBackup(TfEditCookie ec, ITfRange *pRange, ITfRangeBackup **ppBackup)
{
    CRangeBackup *pRangeBackup;
    CRange *range;
    HRESULT hr;

    if (!ppBackup)
        return E_INVALIDARG;

    *ppBackup = NULL;

    if (!_IsConnected())
        return TF_E_DISCONNECTED;

    if (!_IsValidEditCookie(ec, TF_ES_READ))
    {
        Assert(0);
        return TF_E_NOLOCK;
    }
   
    if (!pRange)
        return E_INVALIDARG;

    if ((range = GetCRange_NA(pRange)) == NULL)
        return E_INVALIDARG;

    if (!VerifySameContext(this, range))
        return E_INVALIDARG;

    range->_QuickCheckCrossedAnchors();

    pRangeBackup = new CRangeBackup(this);
    if (!pRangeBackup)
        return E_OUTOFMEMORY;

    if (FAILED(hr = pRangeBackup->Init(ec, range)))
    {
        pRangeBackup->Clear();
        pRangeBackup->Release();
        return E_FAIL;
    }

    *ppBackup = pRangeBackup;
    return hr;
}

//+---------------------------------------------------------------------------
//
// QueryService
//
//----------------------------------------------------------------------------

STDAPI CInputContext::QueryService(REFGUID guidService, REFIID riid, void **ppv)
{
    IServiceProvider *psp;
    HRESULT hr;

    if (ppv == NULL)
        return E_INVALIDARG;

    *ppv = NULL;

    if (IsEqualGUID(guidService, GUID_SERVICE_TEXTSTORE) &&
        IsEqualIID(riid, IID_IServiceProvider))
    {
        // caller wants to talk to the text store
        if (_ptsi == NULL)
            return E_FAIL;

        // we use an extra level of indirection, asking the IServiceProvider for an IServiceProvider
        // because we want to leave the app free to not expose the ITextStore object
        // otherwise tips could QI the IServiceProvider for ITextStore

        if (_ptsi->QueryInterface(IID_IServiceProvider, (void **)&psp) != S_OK || psp == NULL)
            return E_FAIL;

        hr = psp->QueryService(GUID_SERVICE_TEXTSTORE, IID_IServiceProvider, ppv);

        psp->Release();

        return hr;
    }

    if (!IsEqualGUID(guidService, GUID_SERVICE_TF) ||
        !IsEqualIID(riid, IID_PRIV_CINPUTCONTEXT))
    {
        // SVC_E_NOSERVICE is proper return code for wrong service....
        // but it's not defined anywhere.  So use E_NOINTERFACE for both
        // cases as trident is rumored to do
        return E_NOINTERFACE;
    }

    *ppv = this;
    AddRef();

    return S_OK;
}

//+---------------------------------------------------------------------------
//
// AdviseMouseSink
//
//----------------------------------------------------------------------------

STDAPI CInputContext::AdviseMouseSink(ITfRange *range, ITfMouseSink *pSink, DWORD *pdwCookie)
{
    CRange *pCRange;
    CRange *pClone;
    ITfMouseTrackerAnchor *pTrackerAnchor;
    ITfMouseTrackerACP *pTrackerACP;
    HRESULT hr;

    if (pdwCookie == NULL)
        return E_INVALIDARG;

    *pdwCookie = 0;

    if (range == NULL || pSink == NULL)
        return E_INVALIDARG;

    if ((pCRange = GetCRange_NA(range)) == NULL)
        return E_INVALIDARG;

    if (!VerifySameContext(this, pCRange))
        return E_INVALIDARG;

    if (!_IsConnected())
        return TF_E_DISCONNECTED;

    pTrackerACP = NULL;

    if (_ptsi->QueryInterface(IID_ITfMouseTrackerAnchor, (void **)&pTrackerAnchor) != S_OK)
    {
        pTrackerAnchor = NULL;
        // we also try IID_ITfMouseTrackerACP for the benefit of wrapped implementations who
        // just want to forward the request off to an ACP app
        if (_ptsi->QueryInterface(IID_ITfMouseTrackerACP, (void **)&pTrackerACP) != S_OK)
            return E_NOTIMPL;
    }

    hr = E_FAIL;

    // need to pass on a clone, so app can hang onto range/anchors
    if ((pClone = pCRange->_Clone()) == NULL)
        goto Exit;

    hr = (pTrackerAnchor != NULL) ?
         pTrackerAnchor->AdviseMouseSink(pClone->_GetStart(), pClone->_GetEnd(), pSink, pdwCookie) :
         pTrackerACP->AdviseMouseSink((ITfRangeACP *)pClone, pSink, pdwCookie);

    pClone->Release();

Exit:
    SafeRelease(pTrackerAnchor);
    SafeRelease(pTrackerACP);

    return hr;
}

//+---------------------------------------------------------------------------
//
// UnadviseMouseSink
//
//----------------------------------------------------------------------------

STDAPI CInputContext::UnadviseMouseSink(DWORD dwCookie)
{
    ITfMouseTrackerAnchor *pTrackerAnchor;
    ITfMouseTrackerACP *pTrackerACP;
    HRESULT hr;

    if (!_IsConnected())
        return TF_E_DISCONNECTED;

    if (_ptsi->QueryInterface(IID_ITfMouseTrackerAnchor, (void **)&pTrackerAnchor) == S_OK)
    {
        hr = pTrackerAnchor->UnadviseMouseSink(dwCookie);
        pTrackerAnchor->Release();
    }
    else if (_ptsi->QueryInterface(IID_ITfMouseTrackerACP, (void **)&pTrackerACP) == S_OK)
    {
        // we also try IID_ITfMouseTrackerACP for the benefit of wrapped implementations who
        // just want to forward the request off to an ACP app
        hr = pTrackerACP->UnadviseMouseSink(dwCookie);
        pTrackerACP->Release();
    }
    else
    {
        hr = E_NOTIMPL;
    }

    return hr;
}

//+---------------------------------------------------------------------------
//
// GetActiveView
//
//----------------------------------------------------------------------------

STDAPI CInputContext::GetActiveView(ITfContextView **ppView)
{
    CContextView *pView;
    TsViewCookie vcActiveView;
    HRESULT hr;

    if (ppView == NULL)
        return E_INVALIDARG;

    *ppView = NULL;

    if (!_IsConnected())
        return TF_E_DISCONNECTED;

    hr = _ptsi->GetActiveView(&vcActiveView);

    if (hr != S_OK)
    {
        Assert(0); // why did it fail?

        if (hr != E_NOTIMPL)
            return E_FAIL;

        // for E_NOTIMPL, we will assume a single view and supply
        // a constant value here
        vcActiveView = 0;
    }

    // Issue: for now, just supporting an active view
    // need to to handle COM identity correctly for mult views
    if (_pActiveView == NULL)
    {
        if ((_pActiveView = new CContextView(this, vcActiveView)) == NULL)
            return E_OUTOFMEMORY;
    }

    pView = _pActiveView;
    pView->AddRef();

    *ppView = pView;

    return S_OK;
}

//+---------------------------------------------------------------------------
//
// EnumView
//
//----------------------------------------------------------------------------

STDAPI CInputContext::EnumViews(IEnumTfContextViews **ppEnum)
{
    if (ppEnum == NULL)
        return E_INVALIDARG;

    *ppEnum = NULL;

    if (!_IsConnected())
        return TF_E_DISCONNECTED;

    // Issue: support this
    Assert(0);
    return E_NOTIMPL;
}

//+---------------------------------------------------------------------------
//
// QueryInsertEmbedded
//
//----------------------------------------------------------------------------

STDAPI CInputContext::QueryInsertEmbedded(const GUID *pguidService, const FORMATETC *pFormatEtc, BOOL *pfInsertable)
{
    if (pfInsertable == NULL)
        return E_INVALIDARG;

    *pfInsertable = FALSE;

    if (!_IsConnected())
        return TF_E_DISCONNECTED;

    return _ptsi->QueryInsertEmbedded(pguidService, pFormatEtc, pfInsertable);
}

//+---------------------------------------------------------------------------
//
// InsertTextAtSelection
//
//----------------------------------------------------------------------------

STDAPI CInputContext::InsertTextAtSelection(TfEditCookie ec, DWORD dwFlags,
                                            const WCHAR *pchText, LONG cch,
                                            ITfRange **ppRange)
{
    IAS_OBJ iasobj;

    iasobj.type = IAS_OBJ::IAS_TEXT;
    iasobj.state.text.pchText = pchText;
    iasobj.state.text.cch = cch;

    return _InsertXAtSelection(ec, dwFlags, &iasobj, ppRange);
}

//+---------------------------------------------------------------------------
//
// InsertEmbeddedAtSelection
//
//----------------------------------------------------------------------------

STDAPI CInputContext::InsertEmbeddedAtSelection(TfEditCookie ec, DWORD dwFlags,
                                                IDataObject *pDataObject,
                                                ITfRange **ppRange)
{
    IAS_OBJ iasobj;

    iasobj.type = IAS_OBJ::IAS_DATAOBJ;
    iasobj.state.obj.pDataObject = pDataObject;

    return _InsertXAtSelection(ec, dwFlags, &iasobj, ppRange);
}

//+---------------------------------------------------------------------------
//
// _InsertXAtSelection
//
//----------------------------------------------------------------------------

HRESULT CInputContext::_InsertXAtSelection(TfEditCookie ec, DWORD dwFlags,
                                           IAS_OBJ *pObj,
                                           ITfRange **ppRange)
{
    IAnchor *paStart;
    IAnchor *paEnd;
    CRange *range;
    CComposition *pComposition;
    HRESULT hr;
    BOOL fNoDefaultComposition;

    if (ppRange == NULL)
        return E_INVALIDARG;

    *ppRange = NULL;

    if (pObj->type == IAS_OBJ::IAS_TEXT)
    {
        if (pObj->state.text.pchText == NULL && pObj->state.text.cch != 0)
            return E_INVALIDARG;

        if (!(dwFlags & TS_IAS_QUERYONLY) && (pObj->state.text.pchText == NULL || pObj->state.text.cch == 0))
            return E_INVALIDARG;
    }
    else
    {
        Assert(pObj->type == IAS_OBJ::IAS_DATAOBJ);
        if (!(dwFlags & TS_IAS_QUERYONLY) && pObj->state.obj.pDataObject == NULL)
            return E_INVALIDARG;
    }

    if ((dwFlags & (TS_IAS_NOQUERY | TS_IAS_QUERYONLY)) == (TS_IAS_NOQUERY | TS_IAS_QUERYONLY))
        return E_INVALIDARG;

    if ((dwFlags & ~(TS_IAS_NOQUERY | TS_IAS_QUERYONLY | TF_IAS_NO_DEFAULT_COMPOSITION)) != 0)
        return E_INVALIDARG;

    if (!_IsConnected())
        return TF_E_DISCONNECTED;

    if (!_IsValidEditCookie(ec, (dwFlags & TF_IAS_QUERYONLY) ? TF_ES_READ : TF_ES_READWRITE))
    {
        Assert(0);
        return TF_E_NOLOCK;
    }

    // we need to clear out the TF_IAS_NO_DEFAULT_COMPOSITION bit because it is not legal
    // for ITextStore methods
    fNoDefaultComposition = (dwFlags & TF_IAS_NO_DEFAULT_COMPOSITION);
    dwFlags &= ~TF_IAS_NO_DEFAULT_COMPOSITION;

    if (pObj->type == IAS_OBJ::IAS_TEXT)
    {
        if (pObj->state.text.cch < 0)
        {
            pObj->state.text.cch = wcslen(pObj->state.text.pchText);
        }

        hr = _ptsi->InsertTextAtSelection(dwFlags, pObj->state.text.pchText, pObj->state.text.cch, &paStart, &paEnd);
    }
    else
    {
        Assert(pObj->type == IAS_OBJ::IAS_DATAOBJ);

        hr = _ptsi->InsertEmbeddedAtSelection(dwFlags, pObj->state.obj.pDataObject, &paStart, &paEnd);
    }

    if (hr == S_OK)
    {
        if (!(dwFlags & TS_IAS_QUERYONLY))
        {
            CComposition::_IsRangeCovered(this, _GetClientInEditSession(ec), paStart, paEnd, &pComposition);

            _DoPostTextEditNotifications(pComposition, ec, 0, 1, paStart, paEnd, NULL);

            // try to start a composition
            // any active compositions?
            if (!fNoDefaultComposition && pComposition == NULL)
            {
                // not covered, need to (try to) create a composition
                hr = _StartComposition(ec, paStart, paEnd, NULL, &pComposition);

                if (hr == S_OK && pComposition != NULL)
                {
                    // we just wanted to set the composing property, so end this one immediately
                    pComposition->EndComposition(ec);
                    pComposition->Release();
                }
            }
        }
    }
    else
    {
        // the InsertAtSelection call failed in the app
        switch (hr)
        {
            case TS_E_NOSELECTION:
            case TS_E_READONLY:
                return hr;

            case E_NOTIMPL:
                // the app hasn't implemented InsertAtSelection, so we'll fake it using GetSelection/SetText
                if (!_InsertXAtSelectionAggressive(ec, dwFlags, pObj, &paStart, &paEnd))
                    return E_FAIL;
                break;

            default:
                return E_FAIL;
        }
    }

    if (!(dwFlags & TF_IAS_NOQUERY))
    {
        if (paStart == NULL || paEnd == NULL)
        {
            Assert(0); // text store returning bogus values
            return E_FAIL;
        }

        if ((range = new CRange) == NULL)
            return E_OUTOFMEMORY;

        if (!range->_InitWithDefaultGravity(this, OWN_ANCHORS, paStart, paEnd))
        {
            range->Release();
            return E_FAIL;
        }

        *ppRange = (ITfRangeAnchor *)range;
    }

    return S_OK;
}

//+---------------------------------------------------------------------------
//
// _InsertXAtSelectionAggressive
//
//----------------------------------------------------------------------------

BOOL CInputContext::_InsertXAtSelectionAggressive(TfEditCookie ec, DWORD dwFlags, IAS_OBJ *pObj, IAnchor **ppaStart, IAnchor **ppaEnd)
{
    CRange *range;
    TF_SELECTION sel;
    ULONG pcFetched;
    HRESULT hr;

    // this is more expensive then using ITextStore methods directly, but by using a CRange we
    // get all the composition/notification code for free

    if (GetSelection(ec, TF_DEFAULT_SELECTION, 1, &sel, &pcFetched) != S_OK)
        return FALSE;

    hr = E_FAIL;

    if (pcFetched != 1)
        goto Exit;

    if (dwFlags & TS_IAS_QUERYONLY)
    {
        hr = S_OK;
        goto OutParams;
    }

    if (pObj->type == IAS_OBJ::IAS_TEXT)
    {
        hr = sel.range->SetText(ec, 0, pObj->state.text.pchText, pObj->state.text.cch);
    }
    else
    {
        Assert(pObj->type == IAS_OBJ::IAS_DATAOBJ);

        hr = sel.range->InsertEmbedded(ec, 0, pObj->state.obj.pDataObject);
    }

    if (hr == S_OK)
    {
OutParams:
        range = GetCRange_NA(sel.range);

        *ppaStart = range->_GetStart();
        (*ppaStart)->AddRef();
        *ppaEnd = range->_GetEnd();
        (*ppaEnd)->AddRef();
    }

Exit:
    sel.range->Release();

    return (hr == S_OK);
}


//+---------------------------------------------------------------------------
//
// _DoPostTextEditNotifications
//
//----------------------------------------------------------------------------

void CInputContext::_DoPostTextEditNotifications(CComposition *pComposition, 
                                                 TfEditCookie ec, DWORD dwFlags,
                                                 ULONG cchInserted,
                                                 IAnchor *paStart, IAnchor *paEnd,
                                                 CRange *range)
{
    CProperty *property;
    VARIANT var;

    if (range != NULL)
    {
        Assert(paStart == NULL);
        Assert(paEnd == NULL);
        paStart = range->_GetStart();
        paEnd = range->_GetEnd();
    }

    if (cchInserted > 0)
    {
        // an insert could have crossed some anchors
        _IncLastLockReleaseID(); // force a re-check for everyone!
        if (range != NULL)
        {
            range->_QuickCheckCrossedAnchors(); // and check this guy right away
        }
    }

    // the app won't notify us about changes we initiate, so do that now
    _OnTextChangeInternal(dwFlags, paStart, paEnd, COPY_ANCHORS);

    // let properties know about the update
    _PropertyTextUpdate(dwFlags, paStart, paEnd);

    // Set text owner property
    if (cchInserted > 0
        && !IsEqualAnchor(paStart, paEnd))
    {
        // text owner property
        TfClientId tid = _GetClientInEditSession(ec);
        if ((tid != g_gaApp) && (tid != g_gaSystem) && 
            (property = GetTextOwnerProperty()))
        {
            var.vt = VT_I4;
            var.lVal = tid;

            Assert(var.lVal != TF_CLIENTID_NULL);

            property->_SetDataInternal(ec, paStart, paEnd, &var);
        }

        // composition property
        if (range != NULL &&
            _GetProperty(GUID_PROP_COMPOSING, &property) == S_OK) // perf: consider caching property ptr
        {
            var.vt = VT_I4;
            var.lVal = TRUE;

            property->_SetDataInternal(ec, paStart, paEnd, &var);

            property->Release();
        }
    }

    // composition update
    if (pComposition != NULL && _GetOwnerCompositionSink() != NULL)
    {
        _GetOwnerCompositionSink()->OnUpdateComposition(pComposition, NULL);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\ctf\uim\imecls.h ===
//
// imecls.h
//

#ifndef IMECLS_H
#define IMECLS_H

#include "private.h"
#include "globals.h"


//////////////////////////////////////////////////////////////////////////////
//
// misc func
//
//////////////////////////////////////////////////////////////////////////////

BOOL CheckExistingImeClassWnd(SYSTHREAD *psfn);
BOOL UninitImeClassWndOnProcess();

//////////////////////////////////////////////////////////////////////////////
//
// CSysImeClassWnd
//
//////////////////////////////////////////////////////////////////////////////

class CSysImeClassWnd
{
public:
    CSysImeClassWnd();
    ~CSysImeClassWnd();

    static BOOL CheclExistingImeClassWnd(SYSTHREAD *psfn);
    static BOOL IsImeClassWnd(HWND hwnd);
    BOOL Init(HWND hwnd);

    static LRESULT WndProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam);

    HWND GetWnd() {return _hwnd;}
    void Start();
    void Stop();


private:
    HWND    _hwnd;
    WNDPROC _pfn;

    DBG_ID_DECLARE;
};

//////////////////////////////////////////////////////////////////////////////
//
// CSysImeClassWndArray
//
//////////////////////////////////////////////////////////////////////////////

class CSysImeClassWndArray : public CPtrArray<CSysImeClassWnd>
{
public:
    CSysImeClassWndArray();

    BOOL StartSubclass();
    BOOL StopSubclass();
    CSysImeClassWnd *Find(HWND hwnd);
    void Remove(CSysImeClassWnd *picw);
    void RemoveAll();

private:
    DBG_ID_DECLARE;
};


#endif  // IMECLS_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\ctf\uim\imecls.cpp ===
//
// imecls.cpp
//

#include "private.h"
#include "imecls.h"

DBG_ID_INSTANCE(CSysImeClassWnd);
DBG_ID_INSTANCE(CSysImeClassWndArray);

#define IMECLASSNAME TEXT("ime")

//////////////////////////////////////////////////////////////////////////////
//
// misc func
//
//////////////////////////////////////////////////////////////////////////////

//+---------------------------------------------------------------------------
//
// CheckExistingImeClassWnd
//
//----------------------------------------------------------------------------

BOOL CheckExistingImeClassWnd(SYSTHREAD *psfn)
{
#ifdef USE_IMECLASS_SUBCLASS
    if (!psfn->prgImeClassWnd)
    {
        HWND hwnd = NULL;
        DWORD dwCurThreadId = GetCurrentThreadId();

        while (hwnd = FindWindowEx(NULL, hwnd, IMECLASSNAME, NULL))
        {
            DWORD dwThreadId = GetWindowThreadProcessId(hwnd, NULL);
            if (dwThreadId != dwCurThreadId)
                continue;

            CSysImeClassWnd *picw = new CSysImeClassWnd();
            picw->Init(hwnd);
        }
    }

    if (!psfn->prgImeClassWnd)
        return TRUE;

    if (GetFocus())
        psfn->prgImeClassWnd->StartSubclass();
#endif

    return TRUE;
}

//+---------------------------------------------------------------------------
//
// UninitImeClassWndOnProcess
//
//----------------------------------------------------------------------------

BOOL UninitImeClassWndOnProcess()
{
    HWND hwnd = NULL;
    DWORD dwCurProcessId = GetCurrentProcessId();

    while (hwnd = FindWindowEx(NULL, hwnd, IMECLASSNAME, NULL))
    {
        DWORD dwProcessId;
        DWORD dwThreadId = GetWindowThreadProcessId(hwnd, &dwProcessId);
        if (dwProcessId != dwCurProcessId)
            continue;

        //
        // Set the wndproc pointer back to original WndProc.
        //
        // some other subclass window may keep my WndProc pointer.
        // but msctf.dll may be unloaded from memory so we don't want to 
        // call him to set the wndproc pointer back to our Wndproc pointer.
        // The pointer will be bogus.
        //
        WNDPROC pfn = (WNDPROC)GetClassLongPtr(hwnd, GCLP_WNDPROC);
        if (pfn != (WNDPROC)GetWindowLongPtr(hwnd, GWLP_WNDPROC))
            SetWindowLongPtr(hwnd, GWLP_WNDPROC, (LONG_PTR)pfn);
    }

    return TRUE;
}

//////////////////////////////////////////////////////////////////////////////
//
// CSysImeClassWnd
//
//////////////////////////////////////////////////////////////////////////////

//+---------------------------------------------------------------------------
//
// ctor
//
//----------------------------------------------------------------------------

CSysImeClassWnd::CSysImeClassWnd()
{
    Dbg_MemSetThisNameID(TEXT("CSysImeClassWnd"));
}

//+---------------------------------------------------------------------------
//
// dtor
//
//----------------------------------------------------------------------------

CSysImeClassWnd::~CSysImeClassWnd()
{
    if (IsWindow(_hwnd))
    {
        Stop();

        if (_pfn)
        {
            //
            // Set the wndproc pointer back to original WndProc.
            //
            // some other subclass window may keep my WndProc pointer.
            // but msctf.dll may be unloaded from memory so we don't want to 
            // call him to set the wndproc pointer back to our Wndproc pointer.
            // The pointer will be bogus.
            //
            WNDPROC pfnOrgImeWndProc;
            pfnOrgImeWndProc = (WNDPROC)GetClassLongPtr(_hwnd, GCLP_WNDPROC);
            SetWindowLongPtr(_hwnd, GWLP_WNDPROC, (LONG_PTR)pfnOrgImeWndProc);
            _pfn = NULL;
        }
    }
}

//+---------------------------------------------------------------------------
//
// IsImeClassWnd
//
//----------------------------------------------------------------------------

BOOL CSysImeClassWnd::IsImeClassWnd(HWND hwnd)
{
    char szCls[6];

    if (!GetClassName(hwnd, szCls, sizeof(szCls)))
        return FALSE;

    return lstrcmpi(szCls, IMECLASSNAME) ? FALSE : TRUE;
}


//+---------------------------------------------------------------------------
//
// Init
//
//----------------------------------------------------------------------------

BOOL CSysImeClassWnd::Init(HWND hwnd)
{
    SYSTHREAD *psfn = GetSYSTHREAD();

    if (psfn == NULL)
        return FALSE;

    if (!psfn->prgImeClassWnd)
    {
        psfn->prgImeClassWnd = new CSysImeClassWndArray();
        if (!psfn->prgImeClassWnd)
            return FALSE;
    }

    CSysImeClassWnd **ppicw = psfn->prgImeClassWnd->Append(1);
    if (!ppicw)
        return FALSE;

    *ppicw = this;

    _hwnd = hwnd;
    _pfn = NULL;
    
    return TRUE;
}

//+---------------------------------------------------------------------------
//
// Start
//
//----------------------------------------------------------------------------

void CSysImeClassWnd::Start()
{
    Assert(IsWindow(_hwnd));
    if (_pfn)
        return;

    _pfn = (WNDPROC)SetWindowLongPtr(_hwnd, GWLP_WNDPROC, (LONG_PTR)WndProc);
}

//+---------------------------------------------------------------------------
//
// Stop
//
//----------------------------------------------------------------------------

void CSysImeClassWnd::Stop()
{
    Assert(IsWindow(_hwnd));
    WNDPROC pfnCur;
    if (!_pfn)
        return;

    //
    // unfortunately, we can not restore the wndproc pointer always.
    // someone else subclassed it after we did.
    //
    pfnCur = (WNDPROC)GetWindowLongPtr(_hwnd, GWLP_WNDPROC);
    if (pfnCur == WndProc)
    {
        SetWindowLongPtr(_hwnd, GWLP_WNDPROC, (LONG_PTR)_pfn);
        _pfn = NULL;
    }
}

//+---------------------------------------------------------------------------
//
// WndProc
//
//----------------------------------------------------------------------------

LRESULT CSysImeClassWnd::WndProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    LRESULT lRet;
    SYSTHREAD *psfn = GetSYSTHREAD();

    if (!psfn || !psfn->prgImeClassWnd)
    {
        Assert(0);
        return 0;
    }

    CSysImeClassWnd *_this = psfn->prgImeClassWnd->Find(hwnd);
    if (!_this)
    {
#ifdef DEBUG
        if ((uMsg != WM_DESTROY) && (uMsg != WM_NCDESTROY))
        {
            Assert(0);
        }
#endif
        return 0;
    }

    WNDPROC pfn = _this->_pfn;
    if (!pfn)
    {
        Assert(0);
        return 0;
    }

    switch (uMsg)
    {
#if 0
        //
        // we have a fall back logic to set the original window proc back
        // if we can not restore the window proc correctly.
        // so we don't have to do paranoid subclassing here.
        //
        case WM_IME_SELECT:
        case WM_IME_SETCONTEXT:
             _this->Stop();
             lRet = CallWindowProc(pfn, hwnd, uMsg, wParam, lParam);
             _this->Start();
             return lRet;
#endif

        case WM_IME_NOTIFY:
            if ((wParam == IMN_SETOPENSTATUS) ||
                (wParam == IMN_SETCONVERSIONMODE))
                OnIMENotify();
             break;

        case WM_DESTROY:
             lRet = CallWindowProc(pfn, hwnd, uMsg, wParam, lParam);
             psfn->prgImeClassWnd->Remove(_this);
             return lRet;

    }

    return CallWindowProc(pfn, hwnd, uMsg, wParam, lParam);
}

//////////////////////////////////////////////////////////////////////////////
//
// CSysImeClassWndArray
//
//////////////////////////////////////////////////////////////////////////////

//+---------------------------------------------------------------------------
//
// ctor
//
//----------------------------------------------------------------------------

CSysImeClassWndArray::CSysImeClassWndArray()
{
    Dbg_MemSetThisNameID(TEXT("CSysImeClassWndArray"));
}

//+---------------------------------------------------------------------------
//
// StartSubClass
//
//----------------------------------------------------------------------------

BOOL CSysImeClassWndArray::StartSubclass()
{
    for (int i = 0; i < Count(); i++)
    {
        CSysImeClassWnd *picw = Get(i);
        picw->Start();
    }
    return TRUE;
}

//+---------------------------------------------------------------------------
//
// StopSubClass
//
//----------------------------------------------------------------------------

BOOL CSysImeClassWndArray::StopSubclass()
{
    for (int i = 0; i < Count(); i++)
    {
        CSysImeClassWnd *picw = Get(i);
        picw->Stop();
    }
    return TRUE;
}

//+---------------------------------------------------------------------------
//
// Find
//
//----------------------------------------------------------------------------

CSysImeClassWnd *CSysImeClassWndArray::Find(HWND hwnd)
{
    for (int i = 0; i < Count(); i++)
    {
        CSysImeClassWnd *picw = Get(i);
        if (picw->GetWnd() == hwnd)
            return picw;
    }
    return NULL;
}

//+---------------------------------------------------------------------------
//
// Remove
//
//----------------------------------------------------------------------------

void CSysImeClassWndArray::Remove(CSysImeClassWnd *picw)
{
    for (int i = 0; i < Count(); i++)
    {
        if (picw == Get(i))
        {
            CPtrArray<CSysImeClassWnd>::Remove(i, 1);
            delete picw;
            break;
        }
    }
}

//+---------------------------------------------------------------------------
//
// RemoveAll
//
//----------------------------------------------------------------------------

void CSysImeClassWndArray::RemoveAll()
{
    for (int i = 0; i < Count(); i++)
    {
        CSysImeClassWnd *picw = Get(i);
        delete picw;
    }
    Clear();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\ctf\uim\imelist.cpp ===
//
// immstat.cpp
//

#include "private.h"
#include "cregkey.h"
#include "imelist.h"
#include "regsvr.h"
#include "tim.h"
#include "immxutil.h"
#include "assembly.h"
#include "thdutil.h"
#include "internat.h"



DBG_ID_INSTANCE(CInputProcessorProfiles);

//+---------------------------------------------------------------------------
//
// MyGetTIPCategory
//
//----------------------------------------------------------------------------

BOOL MyGetTIPCategory(REFCLSID clsid, GUID *pcatid)
{
    IEnumGUID *pEnumCat;
    HRESULT hr;
    BOOL fFound = FALSE;

    *pcatid = GUID_NULL;

    hr = MyEnumItemsInCategory(GUID_TFCAT_CATEGORY_OF_TIP, &pEnumCat);
    if (SUCCEEDED(hr) && pEnumCat)
    {
        GUID guidCat;
        while (!fFound && (pEnumCat->Next(1, &guidCat, NULL) == S_OK))
        {
            IEnumGUID *pEnumTip;
            hr = MyEnumItemsInCategory(guidCat, &pEnumTip);
            if (SUCCEEDED(hr) && pEnumTip)
            {
                GUID guidTip;
                while (!fFound && (pEnumTip->Next(1, &guidTip, NULL) == S_OK))
                {
                    if (IsEqualGUID(clsid, guidTip))
                    {
                        *pcatid = guidCat;
                        fFound = TRUE;
                    }
                }
                pEnumTip->Release();
            }
        }
    
        pEnumCat->Release();
    }

    return fFound;
}

//+---------------------------------------------------------------------------
//
// GetProfileIconInfo
//
//----------------------------------------------------------------------------

HRESULT GetProfileIconInfo(REFCLSID rclsid,
                          LANGID langid,
                          REFGUID guidProfile,
                          WCHAR *pszFileName,
                          int cchFileNameMax,
                          ULONG *puIconIndex)
{
    CMyRegKey keyTmp;
    CMyRegKey key;
    char szTmp[256];

    StringCopyArray(szTmp, c_szCTFTIPKey);
    CLSIDToStringA(rclsid, szTmp + lstrlen(szTmp));
    StringCatArray(szTmp, "\\");
    StringCatArray(szTmp, c_szLanguageProfileKey);
    StringCchPrintf(szTmp + lstrlen(szTmp), ARRAYSIZE(szTmp)-lstrlen(szTmp), "0x%08x", langid);

    if (keyTmp.Open(HKEY_LOCAL_MACHINE, szTmp, KEY_READ) != S_OK)
        return E_FAIL;

    CLSIDToStringA(guidProfile, szTmp);
    if (key.Open(keyTmp, szTmp, KEY_READ) != S_OK)
        return E_FAIL;

    key.QueryValueCchW(pszFileName, c_szIconFileW, cchFileNameMax);
    key.QueryValue((DWORD &)*puIconIndex, c_szIconIndex);

    return S_OK;
}

//+---------------------------------------------------------------------------
//
// InitProfileRegKeyStr
//
//----------------------------------------------------------------------------

BOOL InitProfileRegKeyStr(char *psz, ULONG cchMax, REFCLSID rclsid, LANGID langid, REFGUID guidProfile)
{
    ULONG cch;

    if (StringCchCopy(psz, cchMax, c_szCTFTIPKey) != S_OK)
        return FALSE;

    cch = lstrlen(psz);
    if (cch + CLSID_STRLEN + 1 >= cchMax)
        return FALSE;

    CLSIDToStringA(rclsid, psz + cch);

    psz += cch + CLSID_STRLEN;
    cchMax -= cch + CLSID_STRLEN;
    Assert(cchMax > 0);

    if (StringCchPrintf(psz, cchMax, "\\%s0x%08x\\", c_szLanguageProfileKey, langid) != S_OK)
        return FALSE;

    cch = lstrlen(psz);
    if (cch + CLSID_STRLEN + 1 >= cchMax)
        return FALSE;

    CLSIDToStringA(guidProfile, psz + cch);

    return TRUE;
}

//+---------------------------------------------------------------------------
//
// EnableLanguageProfileForReg
//
//----------------------------------------------------------------------------

HRESULT EnableLanguageProfileForReg(REFCLSID rclsid, LANGID langid, REFGUID guidProfile, BOOL fEnable)
{
    CMyRegKey key;
    char szTmp[256];

    if (!InitProfileRegKeyStr(szTmp, ARRAYSIZE(szTmp), rclsid, langid, guidProfile))
        return E_FAIL;

    if (key.Create(HKEY_CURRENT_USER, szTmp) != S_OK)
        return E_FAIL;

    if (key.SetValue((DWORD)(fEnable ? 1 : 0), c_szEnable) != S_OK)
        return E_FAIL;

    return S_OK;
}

//+---------------------------------------------------------------------------
//
// IsEnabledLanguageProfileFromReg
//
//----------------------------------------------------------------------------

BOOL IsEnabledLanguageProfileFromReg(REFCLSID rclsid, LANGID langid, REFGUID guidProfile)
{
    CMyRegKey key;
    char szTmp[256];
    CMyRegKey keyLM;
    DWORD dw;

    if (!InitProfileRegKeyStr(szTmp, ARRAYSIZE(szTmp), rclsid, langid, guidProfile))
        return TRUE;

    //
    // we just check the Current User setting at first.
    //
    if (key.Open(HKEY_CURRENT_USER, szTmp, KEY_READ) == S_OK)
    {
        if (key.QueryValue(dw, c_szEnable) == S_OK)
         return dw ? TRUE : FALSE;
    }

    //
    // If this current user does not have a setting,
    // we just check the default value to see Local Machine setting.
    //
    if (keyLM.Open(HKEY_LOCAL_MACHINE, szTmp, KEY_READ) == S_OK)
    {
        if (keyLM.QueryValue(dw, c_szEnable) == S_OK)
            return dw ? TRUE : FALSE;
    }
    else
    {
        //
        // Check a neutral language id.
        //
        if (!InitProfileRegKeyStr(szTmp, ARRAYSIZE(szTmp), rclsid, LOWORD(PRIMARYLANGID(langid)), guidProfile))
            return TRUE;

        if (keyLM.Open(HKEY_LOCAL_MACHINE, szTmp, KEY_READ) == S_OK)
        {
            if (keyLM.QueryValue(dw, c_szEnable) == S_OK)
                return dw ? TRUE : FALSE;
        }
        else
        {
            //
            // Check a neutral language id.
            //
            if (!InitProfileRegKeyStr(szTmp, ARRAYSIZE(szTmp), rclsid, 0x0000ffff, guidProfile))
                return TRUE;

            if (keyLM.Open(HKEY_LOCAL_MACHINE, szTmp, KEY_READ) == S_OK)
            {
                if (keyLM.QueryValue(dw, c_szEnable) == S_OK)
                    return dw ? TRUE : FALSE;
            }
        }
    }

    return TRUE;
}

//////////////////////////////////////////////////////////////////////////////
//
// CInputProcessorProfiles
//
//////////////////////////////////////////////////////////////////////////////

//+---------------------------------------------------------------------------
//
// ctor
//
//----------------------------------------------------------------------------

CInputProcessorProfiles::CInputProcessorProfiles()
{
    Assert(_GetThis() == NULL);
    _SetThis(this); // save a pointer to this in TLS
}

//+---------------------------------------------------------------------------
//
// dtor
//
//----------------------------------------------------------------------------

CInputProcessorProfiles::~CInputProcessorProfiles()
{
    _SetThis(NULL); // clear pointer to this in TLS
}

//+---------------------------------------------------------------------------
//
// EnumInputProcessors
//
//----------------------------------------------------------------------------

STDAPI CInputProcessorProfiles::EnumInputProcessorInfo(IEnumGUID **ppEnum)
{
    CEnumGuid *pEnum;
    CLSID *pImxClsid;
    ULONG nNumImx;

    if (!ppEnum)
        return E_INVALIDARG;

    if (!_GetTIPRegister(&pImxClsid, &nNumImx))
        return E_FAIL;

    pEnum = new CEnumGuid;

    if (!pEnum)
    {
        delete pImxClsid;
        return E_OUTOFMEMORY;
    }

    if (pEnum->_Init(nNumImx, pImxClsid))
        *ppEnum = pEnum;
    else
        SafeReleaseClear(pEnum);

    delete pImxClsid;

    return pEnum ? S_OK : E_FAIL;
}

//+---------------------------------------------------------------------------
//
// Register
//
//----------------------------------------------------------------------------

STDAPI CInputProcessorProfiles::Register(REFCLSID rclsid)
{
    CMyRegKey key;
    TCHAR szKey[256];

    StringCopyArray(szKey, c_szCTFTIPKey);
    CLSIDToStringA(rclsid, szKey + lstrlen(szKey));

    if (key.Create(HKEY_LOCAL_MACHINE, szKey) != S_OK)
        return E_FAIL;

    key.SetValueW(L"1", c_szEnableW);

    return S_OK;
}

//+---------------------------------------------------------------------------
//
// Unregister
//
//----------------------------------------------------------------------------

STDAPI CInputProcessorProfiles::Unregister(REFCLSID rclsid)
{
    CMyRegKey key;
    TCHAR szKey[256];
    TCHAR szSubKey[256];

    StringCopyArray(szKey, c_szCTFTIPKey);

    if (key.Open(HKEY_LOCAL_MACHINE, szKey, KEY_ALL_ACCESS) != S_OK)
        return E_FAIL;

    CLSIDToStringA(rclsid, szSubKey);

    key.RecurseDeleteKey(szSubKey);

    return S_OK;
}

//+---------------------------------------------------------------------------
//
// _UpdateTIPRegister
//
//----------------------------------------------------------------------------

BOOL CInputProcessorProfiles::_GetTIPRegister(CLSID **prgclsid, ULONG *pulCount)
{
    CMyRegKey key;
    CLSID *pImxClsid;
    ULONG nNumImx;
    TCHAR szKey[256];

    StringCopyArray(szKey, c_szCTFTIPKey);
    if (key.Open(HKEY_LOCAL_MACHINE, szKey, KEY_READ) != S_OK)
        return FALSE;

    nNumImx = (int)key.GetNumSubKeys();

    if ((pImxClsid = new CLSID[nNumImx]) == NULL)
        return FALSE;

    CLSID *pclsid = pImxClsid;
    DWORD dwIndex = 0;
    TCHAR achClsid[CLSID_STRLEN+1];
    while (key.EnumKey(dwIndex, achClsid, ARRAYSIZE(achClsid)) == S_OK)
    {
        StringAToCLSID(achClsid, pclsid);
        pclsid++;
        dwIndex++;
    }

    *prgclsid = pImxClsid;
    *pulCount = nNumImx;

    return TRUE;
}


//+---------------------------------------------------------------------------
//
// AddLanguageProfile
//
//----------------------------------------------------------------------------

STDAPI CInputProcessorProfiles::AddLanguageProfile(REFCLSID rclsid,
                                                   LANGID langid,
                                                   REFGUID guidProfile,
                                                   const WCHAR *pchProfile,
                                                   ULONG cch,
                                                   const WCHAR *pchFile,
                                                   ULONG cchFile,
                                                   ULONG uIconIndex)
{
    CMyRegKey keyTmp;
    CMyRegKey key;
    char szTmp[256];

    if (!pchProfile)
       return E_INVALIDARG;

    StringCopyArray(szTmp, c_szCTFTIPKey);
    CLSIDToStringA(rclsid, szTmp + lstrlen(szTmp));
    StringCatArray(szTmp, "\\");
    StringCatArray(szTmp, c_szLanguageProfileKey);
    StringCchPrintf(szTmp + lstrlen(szTmp), ARRAYSIZE(szTmp)-lstrlen(szTmp), "0x%08x", langid);

    if (keyTmp.Create(HKEY_LOCAL_MACHINE, szTmp) != S_OK)
        return E_FAIL;

    CLSIDToStringA(guidProfile, szTmp);
    if (key.Create(keyTmp, szTmp) != S_OK)
        return E_FAIL;

    key.SetValueW(WCHtoWSZ(pchProfile, cch), c_szDescriptionW);

    if (pchFile)
    {
        key.SetValueW(WCHtoWSZ(pchFile, cchFile), c_szIconFileW);
        key.SetValue(uIconIndex, c_szIconIndex);
    }

    CAssemblyList::InvalidCache();
    return S_OK;
}

//+---------------------------------------------------------------------------
//
// SetLanguageProfileDisplayName
//
//----------------------------------------------------------------------------

STDAPI CInputProcessorProfiles::SetLanguageProfileDisplayName(REFCLSID rclsid,
                                               LANGID langid,
                                               REFGUID guidProfile,
                                               const WCHAR *pchFile,
                                               ULONG cchFile,
                                               ULONG uResId)
{
    CMyRegKey keyTmp;
    CMyRegKey key;
    char szTmp[MAX_PATH];
    WCHAR wszTmp[MAX_PATH];
    WCHAR wszResId[MAX_PATH];

    if (!pchFile)
       return E_INVALIDARG;

    StringCopyArray(szTmp, c_szCTFTIPKey);
    CLSIDToStringA(rclsid, szTmp + lstrlen(szTmp));
    StringCatArray(szTmp, "\\");
    StringCatArray(szTmp, c_szLanguageProfileKey);
    StringCchPrintf(szTmp + lstrlen(szTmp), ARRAYSIZE(szTmp)-lstrlen(szTmp), "0x%08x", langid);

    if (keyTmp.Create(HKEY_LOCAL_MACHINE, szTmp) != S_OK)
        return E_FAIL;

    CLSIDToStringA(guidProfile, szTmp);
    if (key.Create(keyTmp, szTmp) != S_OK)
        return E_FAIL;

    //
    // make "@[filename],-ResId" string 
    //
    StringCopyArrayW(wszTmp, L"@");
    StringCatArrayW(wszTmp, WCHtoWSZ(pchFile, cchFile));
    StringCatArrayW(wszTmp, L",-");
    StringCchPrintfW(wszResId, ARRAYSIZE(wszResId), L"%u", uResId);
    StringCatArrayW(wszTmp, wszResId);

    key.SetValueW(wszTmp, c_szMUIDescriptionW);

    CAssemblyList::InvalidCache();
    return S_OK;
}

//+---------------------------------------------------------------------------
//
// RemoveLanguageProfile
//
//----------------------------------------------------------------------------

STDAPI CInputProcessorProfiles::RemoveLanguageProfile(REFCLSID rclsid,
                                                      LANGID langid,
                                                      REFGUID guidProfile)
{
    CMyRegKey key;
    TCHAR szKey[256];

    StringCopyArray(szKey, c_szCTFTIPKey);
    CLSIDToStringA(rclsid, szKey + lstrlen(szKey));
    StringCatArray(szKey, "\\");
    StringCatArray(szKey, c_szLanguageProfileKey);
    StringCchPrintf(szKey + lstrlen(szKey), ARRAYSIZE(szKey)-lstrlen(szKey), "0x%08x", langid);

    if (key.Open(HKEY_LOCAL_MACHINE, szKey, KEY_ALL_ACCESS) != S_OK)
        return E_FAIL;

    CLSIDToStringA(guidProfile, szKey);
    key.RecurseDeleteKey(szKey);


    CAssemblyList::InvalidCache();
    return S_OK;
}

//+---------------------------------------------------------------------------
//
// GetDefaultLanguageProfile
//
// Which GetActiveLanguageProfile() or GetDefaultLanguageProfile() should
// we use?
//
// WARNING!!!
//
// This function is not FocusDIM sensetive. So we sould not call any function
// to check TIM or FocusDIM.
//
// If you want to care about TIM and FocusDIM, try GetActiveLanguageProfile.
//
//----------------------------------------------------------------------------

STDAPI CInputProcessorProfiles::GetDefaultLanguageProfile(LANGID langid, REFGUID catid, CLSID *pclsid, GUID *pguidProfile)
{
    CAssemblyList *pAsmList;
    SYSTHREAD *psfn = GetSYSTHREAD();
    if (!psfn)
        return E_FAIL;

    CAssembly *pAsm;
    int nCnt;
    int i;
    ASSEMBLYITEM *pItem;
    BOOL fFound;

    if (!pclsid)
        return E_INVALIDARG;

    *pclsid = CLSID_NULL;

    if (!pguidProfile)
        return E_INVALIDARG;

    *pguidProfile = GUID_NULL;

    if (!langid)
        return E_INVALIDARG;

    pAsmList = EnsureAssemblyList(psfn);
    if (!pAsmList)
         return E_FAIL;

    pAsm = pAsmList->FindAssemblyByLangId(langid);
    if (!pAsm)
         return E_FAIL;

    pItem = NULL;
    fFound = FALSE;
    nCnt = pAsm->Count();
    for (i = 0; i < nCnt; i++)
    {
        pItem = pAsm->GetItem(i);

        if (!pItem->fEnabled)
            continue;

        if (pItem->fActive && IsEqualGUID(catid, pItem->catid))
        {
            *pclsid = pItem->clsid;
            *pguidProfile = pItem->guidProfile;
            fFound = TRUE;
            break;
        }
    }

    if (!fFound)
    {
        return S_FALSE;
    }

    if (IsEqualCLSID(*pclsid, CLSID_NULL))
    {
        Assert(pItem);
        *((DWORD *)pguidProfile) =  (DWORD)(UINT_PTR)(HKL)(pItem->hkl);
    }

    return S_OK;
}

//+---------------------------------------------------------------------------
//
// SetDefault
//
//----------------------------------------------------------------------------

STDAPI CInputProcessorProfiles::SetDefaultLanguageProfile(LANGID langid, REFCLSID rclsid, REFGUID guidProfile)
{
    GUID catid;

    if (IsEqualGUID(rclsid, GUID_NULL))
        return E_INVALIDARG;

    if (IsEqualGUID(guidProfile, GUID_NULL))
        return E_INVALIDARG;

    if (!MyGetTIPCategory(rclsid, &catid))
        return E_FAIL;

    if (!CAssemblyList::SetDefaultTIPInAssembly(langid, catid, rclsid, NULL, guidProfile))
        return E_FAIL;

    if (IsEqualGUID(catid, GUID_TFCAT_TIP_KEYBOARD))
    {
        HKL hklSystem;
        if (!SystemParametersInfo( SPI_GETDEFAULTINPUTLANG,
                                   0,
                                   (LPVOID)((LPDWORD)&hklSystem),
                                   0 ))
        {
            hklSystem = NULL;
        }

        HKL hkl = NULL;
        HRESULT hr;
        hr = GetSubstituteKeyboardLayout(rclsid, langid, guidProfile, &hkl);
        if ((hr == S_OK) && 
            (LANGIDFROMHKL(hklSystem) == LANGIDFROMHKL(hkl)) && 
            IsPureIMEHKL(hkl))
        {
            SetSystemDefaultHKL(hkl);
        }
    }

    return S_OK;
}

//+---------------------------------------------------------------------------
//
// GetLanguageProfileDescription
//
//----------------------------------------------------------------------------

STDAPI CInputProcessorProfiles::GetLanguageProfileDescription(REFCLSID clsid, 
                                                              LANGID langid,
                                                              REFGUID guidProfile,
                                                              BSTR *pbstr)
{
    CMyRegKey keyTmp;
    CRegKeyMUI key;
    char szTmp[256];
    UINT uTmpSize ;
    WCHAR  szProfile[MAX_PATH];

    if (!pbstr)
       return E_INVALIDARG;

    StringCopyArray(szTmp, c_szCTFTIPKey);
    CLSIDToStringA(clsid, szTmp + lstrlen(szTmp));
    StringCatArray(szTmp, "\\");
    StringCatArray(szTmp, c_szLanguageProfileKey);
    uTmpSize = lstrlen(szTmp);
    StringCchPrintf(szTmp + uTmpSize, ARRAYSIZE(szTmp)-uTmpSize,"0x%08x", langid);

    if (keyTmp.Open(HKEY_LOCAL_MACHINE, szTmp, KEY_READ) != S_OK)
    {
        //
        // Check a neutral language id.
        //
        StringCchPrintf(szTmp + uTmpSize, ARRAYSIZE(szTmp)-uTmpSize, "0x%08x", LOWORD(PRIMARYLANGID(langid)));

        if (keyTmp.Open(HKEY_LOCAL_MACHINE, szTmp, KEY_READ) != S_OK)
        {
            //
            // Check a neutral language id.
            //
            StringCchPrintf(szTmp + uTmpSize, ARRAYSIZE(szTmp)-uTmpSize, "0x0000ffff");

            if (keyTmp.Open(HKEY_LOCAL_MACHINE, szTmp, KEY_READ) != S_OK)
                return E_FAIL;
        }
    }

    CLSIDToStringA(guidProfile, szTmp);
    if (key.Open(keyTmp, szTmp, KEY_READ) != S_OK)
        return E_FAIL;

    if (key.QueryMUIValueW(szProfile, c_szDescriptionW, c_szMUIDescriptionW, ARRAYSIZE(szProfile)) != S_OK)
        return E_FAIL;

    *pbstr = SysAllocString(szProfile);
    return *pbstr != NULL ? S_OK : E_OUTOFMEMORY;
}

//+---------------------------------------------------------------------------
//
// EnableLanguageProfile
//
//----------------------------------------------------------------------------

STDAPI CInputProcessorProfiles::EnableLanguageProfile(REFCLSID rclsid, LANGID langid, REFGUID guidProfile, BOOL fEnable)
{
    HRESULT hr;
    CAssembly *pAsm;
    CAssemblyList *pAsmList;
    SYSTHREAD *psfn = GetSYSTHREAD();
    int nCnt;
    int i;

    if (psfn == NULL)
        return E_FAIL;

    pAsmList = EnsureAssemblyList(psfn);
    if (!pAsmList)
         return E_FAIL;

    pAsm = pAsmList->FindAssemblyByLangId(langid);
    if (!pAsm)
         return E_FAIL;

    nCnt = pAsm->Count();
    for (i = 0; i < nCnt; i++)
    {
        ASSEMBLYITEM *pItem = pAsm->GetItem(i);
        if (IsEqualGUID(guidProfile, pItem->guidProfile))
        {
#if 0
            //
            // we can not dsable the active profile.
            //
            if (pItem->fActive)
                return E_FAIL;
#endif

            break;
        }
    }

    hr = EnableLanguageProfileForReg(rclsid, langid, guidProfile, fEnable);

    return hr;
}

//+---------------------------------------------------------------------------
//
// IsEnabledLanguageProfile
//
//----------------------------------------------------------------------------

STDAPI CInputProcessorProfiles::IsEnabledLanguageProfile(REFCLSID rclsid, LANGID langid, REFGUID guidProfile, BOOL *pfEnable)
{
    if (!pfEnable)
        return E_INVALIDARG;

    *pfEnable = IsEnabledLanguageProfileFromReg(rclsid, langid, guidProfile);

    return S_OK;
}

//+---------------------------------------------------------------------------
//
// EnalbeLanguageprofileByDefault
//
//----------------------------------------------------------------------------

STDAPI CInputProcessorProfiles::EnableLanguageProfileByDefault(REFCLSID rclsid, LANGID langid, REFGUID guidProfile, BOOL fEnable)
{
    CMyRegKey key;
    char szTmp[256];

    if (!InitProfileRegKeyStr(szTmp, ARRAYSIZE(szTmp), rclsid, langid, guidProfile))
        return E_FAIL;

    if (key.Create(HKEY_LOCAL_MACHINE, szTmp) != S_OK)
        return E_FAIL;

    if (key.SetValue((DWORD)(fEnable ? 1 : 0), c_szEnable) != S_OK)
        return E_FAIL;

    return S_OK;
}

//+---------------------------------------------------------------------------
//
// SubstituteKeyboardLayout
//
//----------------------------------------------------------------------------

STDAPI CInputProcessorProfiles::SubstituteKeyboardLayout(REFCLSID rclsid, LANGID langid, REFGUID guidProfile, HKL hKL)
{
    CMyRegKey key;
    char szTmp[256];

    if (!InitProfileRegKeyStr(szTmp, ARRAYSIZE(szTmp), rclsid, langid, guidProfile))
        return E_FAIL;

    if (key.Create(HKEY_LOCAL_MACHINE, szTmp) != S_OK)
        return E_FAIL;

    StringCchPrintf(szTmp, ARRAYSIZE(szTmp), "0x%08x", (DWORD)(ULONG_PTR)hKL);
    if (key.SetValue(szTmp, c_szSubstitutehKL) != S_OK)
        return E_FAIL;

    return S_OK;
}

//+---------------------------------------------------------------------------
//
// CInputProcessorProfiles::GetSubstituteKeyboardLayout
//
//----------------------------------------------------------------------------

STDAPI CInputProcessorProfiles::GetSubstituteKeyboardLayout(REFCLSID rclsid, LANGID langid, REFGUID guidProfile, HKL *phKL)
{
    CMyRegKey key;
    char szTmp[256];

    if (!phKL)
        return E_INVALIDARG;

    *phKL = NULL;

    if (!InitProfileRegKeyStr(szTmp, ARRAYSIZE(szTmp), rclsid, langid, guidProfile))
        return E_FAIL;

    if (key.Open(HKEY_LOCAL_MACHINE, szTmp, KEY_READ) != S_OK)
        return E_FAIL;

    if (key.QueryValueCch(szTmp, c_szSubstitutehKL, ARRAYSIZE(szTmp)) != S_OK)
    {
        //
        // some tips do not have SubstituteLayout.
        //
        return S_FALSE;
    }

    HKL hkl = NULL;
    if ((szTmp[0] == '0') && ((szTmp[1] == 'X') || (szTmp[1] == 'x')))
        hkl = (HKL)IntToPtr(AsciiToNum(&szTmp[2]));

    *phKL = hkl;

    return hkl ? S_OK : S_FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\ctf\uim\imemenu.cpp ===
//------------------------------------------------------------------------
//
// imemenu.cpp
//
//------------------------------------------------------------------------

#include "private.h"
#include "resource.h"
#include "globals.h"
#include "imemenu.h"


#define GetpMyMenuItem(pMenu) ((PMYMENUITEM)((LPBYTE)pMenu + sizeof(MENULIST)))

typedef DWORD (WINAPI *PFNIMMGETIMEMENUITEMS)(HIMC, DWORD, DWORD, LPIMEMENUITEMINFO, LPIMEMENUITEMINFO, DWORD);

// since I don't have the memphis lib, do a load library

static const TCHAR c_szImmLib[] = TEXT("IMM32");
static const TCHAR c_szImmGetImeMenuItems[] = TEXT("ImmGetImeMenuItemsA");
PFNIMMGETIMEMENUITEMS g_pfnImmGetImeMenuItems = NULL; 

//
// Max and Min number of MYMENUITEM if our shared heap.
//

/**********************************************************************/
/*                                                                    */
/* GetImeMenuProc()                                                   */
/*                                                                    */
/**********************************************************************/

BOOL CWin32ImeMenu::GetImeMenuProp()
{
    if (g_pfnImmGetImeMenuItems)
        return TRUE;

    if (IsOnFE() || IsOnNT5())
    {
        HINSTANCE hInstImm;
        hInstImm = GetSystemModuleHandle(c_szImmLib);
        if (hInstImm)
            g_pfnImmGetImeMenuItems = (PFNIMMGETIMEMENUITEMS)GetProcAddress(hInstImm, c_szImmGetImeMenuItems);
    }

    return g_pfnImmGetImeMenuItems ? TRUE : FALSE;
}


/**********************************************************************/
/*                                                                    */
/* AddMenuList()                                                      */
/*                                                                    */
/**********************************************************************/

BOOL CWin32ImeMenu::AddMenuList(PMENULIST pMenu)
{
    PMENULIST pMenuPrev, pMenuNext;

    if (!_pMenuHdr)
    {        
        if ((_pMenuHdr = (PMENULIST)cicMemAllocClear(sizeof(MENULIST))) == NULL)
            return FALSE;
        _pMenuHdr->pPrev = _pMenuHdr;
        _pMenuHdr->pNext = _pMenuHdr;
    }

    pMenuPrev = _pMenuHdr->pPrev;
    pMenuNext = pMenuPrev->pNext;
    pMenu->pNext = pMenuPrev->pNext;
    pMenu->pPrev = pMenuNext->pPrev;
    pMenuPrev->pNext = pMenu;
    pMenuNext->pPrev = pMenu;

    _nMenuList++;
    return TRUE;
}

/**********************************************************************/
/*                                                                    */
/* DeleteMenuList()                                                   */
/*                                                                    */
/**********************************************************************/
void CWin32ImeMenu::DeleteMenuList(PMENULIST pMenu)
{
    PMENULIST pMenuPrev, pMenuNext;

    if (pMenu == _pMenuHdr) {
#ifdef DEBUG
        OutputDebugString("DeleteMenu: should not delete header");
#endif
        return;
    }
    pMenuPrev = pMenu->pPrev;
    pMenuNext = pMenu->pNext;
    pMenuPrev->pNext = pMenu->pNext;
    pMenuNext->pPrev = pMenu->pPrev;

    _nMenuList--;

    if (_nMenuList < 0)
    {
#ifdef DEBUG
        OutputDebugString("DeleteMenu: _nMenuList is zero");
#endif
        _nMenuList = 0;
    }

    cicMemFree(pMenu);
}

/**********************************************************************/
/*                                                                    */
/* DeleteAllMenuList()                                                */
/*                                                                    */
/**********************************************************************/
void CWin32ImeMenu::DeleteAllMenuList()
{
   PMENULIST pMenu, pMenuNext;

   if (!_pMenuHdr)
       return;

   pMenu = _pMenuHdr->pNext;

   if (pMenu == _pMenuHdr)
       return;

   while (pMenu != _pMenuHdr)
   {
       pMenuNext = pMenu->pNext;
       DeleteMenuList(pMenu);
       pMenu = pMenuNext;
   }

    if (_nMenuList > 0)
    {
#ifdef DEBUG
        OutputDebugString("DeleteAllMenu: _nMenuList is not zero");
#endif
        _nMenuList = 0;
    }

   return;
}


/**********************************************************************/
/*                                                                    */
/* AllocMenuList()                                                    */
/*                                                                    */
/**********************************************************************/
PMENULIST CWin32ImeMenu::AllocMenuList(DWORD dwNum)
{
    PMENULIST pMenu;

    pMenu = (PMENULIST)cicMemAllocClear(sizeof(MENULIST) + sizeof(MYMENUITEM) * dwNum);

    if (pMenu)
    {
        AddMenuList(pMenu);
        pMenu->dwNum = dwNum;
    }

    return pMenu;

}

/**********************************************************************/
/*                                                                    */
/* SetMyMenuItem()                                                    */
/*                                                                    */
/**********************************************************************/
void CWin32ImeMenu::SetMyMenuItem(HWND hWnd, HIMC hIMC, LPIMEMENUITEMINFO lpIme, BOOL fRight, PMYMENUITEM pMyMenuItem)
{
    FillMemory((PVOID)pMyMenuItem, sizeof(MYMENUITEM), 0);

    pMyMenuItem->imii = *lpIme;

    if (lpIme->fType & IMFT_SUBMENU)
    {
        //
        // If lpIme has SubMenu, we need to create another MENULIST.
        //
        pMyMenuItem->pmlSubMenu = CreateImeMenu(hWnd, hIMC, lpIme, fRight);
    }

    pMyMenuItem->nMenuID = IDM_CUSTOM_MENU_START + _nMenuCnt;

}

/**********************************************************************/
/*                                                                    */
/* CreateImeMenu()                                                    */
/*                                                                    */
/**********************************************************************/
PMENULIST CWin32ImeMenu::CreateImeMenu(HWND hWnd, HIMC hIMC, LPIMEMENUITEMINFO lpImeParentMenu, BOOL fRight)
{
    DWORD dwSize, dwNum, dwI;
    LPIMEMENUITEMINFO lpImeMenu;
    PMENULIST pMenu;
    PMYMENUITEM pMyMenuItem;
    
    if (!GetImeMenuProp())
        return NULL;

    dwNum = g_pfnImmGetImeMenuItems(hIMC, fRight ? IGIMIF_RIGHTMENU : 0, 
                                 IGIMII_CMODE |
                                 IGIMII_SMODE |
                                 IGIMII_CONFIGURE |
                                 IGIMII_TOOLS |
                                 IGIMII_HELP |
                                 IGIMII_OTHER,
                                 lpImeParentMenu, NULL, 0);

    if (!dwNum)
        return 0;

    pMenu = AllocMenuList(dwNum);

    if (!pMenu)
        return 0;

    pMyMenuItem = GetpMyMenuItem(pMenu);

    dwSize = dwNum * sizeof(IMEMENUITEMINFO);

    lpImeMenu = (LPIMEMENUITEMINFO)GlobalAlloc(GPTR, dwSize);

    if (!lpImeMenu)
        return 0;

    dwNum = g_pfnImmGetImeMenuItems(hIMC, fRight ? IGIMIF_RIGHTMENU : 0, 
                                 IGIMII_CMODE |
                                 IGIMII_SMODE |
                                 IGIMII_CONFIGURE |
                                 IGIMII_TOOLS |
                                 IGIMII_HELP |
                                 IGIMII_OTHER,
                                 lpImeParentMenu, lpImeMenu, dwSize);
    
    // Setup this MENULIST.
    for (dwI = 0 ; dwI < dwNum; dwI++)
    {
        SetMyMenuItem(hWnd, hIMC, lpImeMenu + dwI, fRight, pMyMenuItem + dwI);
        _nMenuCnt++;
    }

    GlobalFree((HANDLE)lpImeMenu);

    return pMenu;
}

/**********************************************************************/
/*                                                                    */
/* GetIMEMenu()                                                       */
/*                                                                    */
/**********************************************************************/
BOOL CWin32ImeMenu::GetIMEMenu(HWND hWnd, HIMC hIMC, BOOL fRight)
{
    // Init sequent number.
    _nMenuCnt = 0;

    CreateImeMenu(hWnd, hIMC, NULL, fRight);

    return TRUE;
}

/**********************************************************************/
/*                                                                    */
/* FillMenuItemInfo()                                                 */
/*                                                                    */
/**********************************************************************/
void CWin32ImeMenu::FillMenuItemInfo(LPMENUITEMINFO lpmii, PMYMENUITEM pMyMenuItem, BOOL fRight)
{
    FillMemory((PVOID)lpmii, sizeof(MENUITEMINFO), 0);
    lpmii->cbSize = sizeof(MENUITEMINFO);
    lpmii->fMask = 0;

    // Set fType;
    if (pMyMenuItem->imii.fType)
    {
        if (IsOnNT5())
           lpmii->fMask |= MIIM_FTYPE;
        else
           lpmii->fMask |= MIIM_TYPE;
        lpmii->fType = 0;

        if (pMyMenuItem->imii.fType & IMFT_RADIOCHECK)
            lpmii->fType |= MFT_RADIOCHECK;

        if (pMyMenuItem->imii.fType & IMFT_SEPARATOR)
            lpmii->fType |= MFT_SEPARATOR;

    }

    lpmii->fMask |= MIIM_ID;
    lpmii->wID = pMyMenuItem->nMenuID;

    if (pMyMenuItem->imii.fType & IMFT_SUBMENU)
    {
        //
        // If lpIme has SubMenu, we need to create another Popup Menu.
        //
        lpmii->fMask |= MIIM_SUBMENU;
        lpmii->hSubMenu = CreatePopupMenu();
        BuildIMEMenuItems(lpmii->hSubMenu, pMyMenuItem->pmlSubMenu, fRight);
    }

    lpmii->fMask |= MIIM_STATE;
    lpmii->fState = pMyMenuItem->imii.fState;

    if (pMyMenuItem->imii.hbmpChecked &&  pMyMenuItem->imii.hbmpUnchecked)
    {
       lpmii->fMask |= MIIM_CHECKMARKS;
       lpmii->hbmpChecked = pMyMenuItem->imii.hbmpChecked;
       lpmii->hbmpUnchecked = pMyMenuItem->imii.hbmpUnchecked;
    }
    

    lpmii->fMask |= MIIM_DATA;
    lpmii->dwItemData = pMyMenuItem->imii.dwItemData;

    if (pMyMenuItem->imii.hbmpItem)
    {
       lpmii->fMask |= MIIM_BITMAP;
       lpmii->hbmpItem = pMyMenuItem->imii.hbmpItem;
    }

    if (lstrlen(pMyMenuItem->imii.szString))
    {
        lpmii->fMask |= MIIM_STRING;
        lpmii->dwTypeData = pMyMenuItem->imii.szString;
        lpmii->cch = lstrlen(pMyMenuItem->imii.szString);
    }
}

/**********************************************************************/
/*                                                                    */
/* GetDefaultImeMenuItem()                                                     */
/*                                                                    */
/**********************************************************************/
int CWin32ImeMenu::GetDefaultImeMenuItem()
{
    PMENULIST pMenu;
    DWORD dwI;
    PMYMENUITEM pMyMenuItem;


    if (!_pMenuHdr)
        return 0;

    pMenu = _pMenuHdr->pNext;

    if (pMenu == _pMenuHdr)
        return 0;

    if (!pMenu->dwNum)
        return 0;

    pMyMenuItem = GetpMyMenuItem(pMenu);

    for (dwI = 0 ; dwI < pMenu->dwNum; dwI++)
    {
        if (pMyMenuItem->imii.fState & IMFS_DEFAULT)
            return pMyMenuItem->imii.wID;

        pMyMenuItem++;
    }
    return 0;

}

/**********************************************************************/
/*                                                                    */
/* BuildIMEMenuItems()                                                */
/*                                                                    */
/**********************************************************************/
BOOL CWin32ImeMenu::BuildIMEMenuItems(HMENU hMenu, PMENULIST pMenu, BOOL fRight)
{
    DWORD dwI;
    MENUITEMINFO mii;
    PMYMENUITEM pMyMenuItem;

    if (!pMenu || !pMenu->dwNum)
        return FALSE;

    pMyMenuItem = GetpMyMenuItem(pMenu);

    for (dwI = 0 ; dwI < pMenu->dwNum; dwI++)
    {
        FillMenuItemInfo(&mii, pMyMenuItem + dwI, fRight);
        InsertMenuItem(hMenu, dwI, TRUE, (MENUITEMINFO *)&mii);
    }

    return TRUE;
}

/**********************************************************************/
/*                                                                    */
/* BuildIMEMenu()                                                     */
/*                                                                    */
/**********************************************************************/
BOOL CWin32ImeMenu::BuildIMEMenu(HMENU hMenu, BOOL fRight)
{
    PMENULIST pMenu;

    if (!_pMenuHdr)
        return FALSE;

    pMenu = _pMenuHdr->pNext;

    if (pMenu == _pMenuHdr)
        return FALSE;

    return BuildIMEMenuItems(hMenu, pMenu, fRight);
}

/**********************************************************************/
/*                                                                    */
/* GetIMEMenuItemID()                                                 */
/*                                                                    */
/**********************************************************************/
UINT CWin32ImeMenu::GetIMEMenuItemID(int nMenuID)
{
    DWORD dwI;
    PMENULIST pMenu, pMenuNext;
    PMYMENUITEM pMyMenuItem;
    UINT uRet = 0;

    if (!_pMenuHdr)
        goto Exit;

    pMenu = _pMenuHdr->pNext;

    if (pMenu == _pMenuHdr)
        goto Exit;

    while (pMenu != _pMenuHdr)
    {
        pMenuNext = pMenu->pNext;
        pMyMenuItem = GetpMyMenuItem(pMenu);

        for (dwI = 0; dwI < pMenu->dwNum; dwI ++)
        {
            if (pMyMenuItem->nMenuID == nMenuID)
            {
                uRet = pMyMenuItem->imii.wID;
                goto Exit;
            }

            pMyMenuItem++;
        } 
        pMenu = pMenuNext;
    }

Exit:
    return uRet;
}

/**********************************************************************/
/*                                                                    */
/* GetIMEMenuItemData()                                               */
/*                                                                    */
/**********************************************************************/
DWORD CWin32ImeMenu::GetIMEMenuItemData(int nImeMenuID)
{
    DWORD dwI;
    PMENULIST pMenu, pMenuNext;
    PMYMENUITEM pMyMenuItem;
    DWORD dwRet = 0;

    if (!_pMenuHdr)
        goto Exit;

    pMenu = _pMenuHdr->pNext;

    if (pMenu == _pMenuHdr)
        goto Exit;

    while (pMenu != _pMenuHdr)
    {
        pMenuNext = pMenu->pNext;
        pMyMenuItem = GetpMyMenuItem(pMenu);

        for (dwI = 0; dwI < pMenu->dwNum; dwI ++)
        {
            if (pMyMenuItem->imii.wID == (UINT)nImeMenuID)
            {
                dwRet = pMyMenuItem->imii.dwItemData;
                goto Exit;
            }

            pMyMenuItem++;
        } 
        pMenu = pMenuNext;
    }

Exit:
    return dwRet;
}

/**********************************************************************/
/*                                                                    */
/* DestroyIMEMenu()                                                   */
/*                                                                    */
/**********************************************************************/
void CWin32ImeMenu::DestroyIMEMenu()
{
    DeleteAllMenuList();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\ctf\uim\init.cpp ===
//
// init.cpp
//

#include "private.h"
#include "globals.h"
#include "immxutil.h"
#include "mui.h"

extern void ReleaseDelayedLibs();

//+---------------------------------------------------------------------------
//
// DllInit
//
// Called on our first CoCreate.  Use this function to do initialization that
// would be unsafe during process attach, like anything requiring a LoadLibrary.
//
//----------------------------------------------------------------------------
BOOL DllInit(void)
{
    BOOL fRet = TRUE;

    CicEnterCriticalSection(GetServerCritSec());

    if (DllRefCount() != 1)
        goto Exit;

    fRet = TFInitLib_PrivateForCiceroOnly(Internal_CoCreateInstance);

Exit:
    CicLeaveCriticalSection(GetServerCritSec());

    return fRet;
}

//+---------------------------------------------------------------------------
//
// DllUninit
//
// Called after the dll ref count drops to zero.  Use this function to do
// uninitialization that would be unsafe during process detach, like
// FreeLibrary calls, COM Releases, or mutexing.
//
//----------------------------------------------------------------------------

void DllUninit(void)
{
    CicEnterCriticalSection(GetServerCritSec());

    if (DllRefCount() != 0)
        goto Exit;

    TFUninitLib();
    ReleaseDelayedLibs();
    MuiFlushDlls(g_hInst);

Exit:
    CicLeaveCriticalSection(GetServerCritSec());
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\ctf\uim\imelist.h ===
//
// imelist.h
//


#ifndef TFELIST_H
#define TFELIST_H

#include "globals.h"
#include "enumguid.h"
#include "sink.h"

HRESULT GetProfileIconInfo(REFCLSID rclsid,
                          LANGID langid,
                          REFGUID guidProfile,
                          WCHAR *pszFileName,
                          int cchFileNameMax,
                          ULONG *puIconIndex);

HRESULT EnableLanguageProfileForReg(REFCLSID rclsid, LANGID langid, REFGUID guidProfile, BOOL fEnable);
BOOL IsEnabledLanguageProfileFromReg(REFCLSID rclsid, LANGID langid, REFGUID guidProfile);

//////////////////////////////////////////////////////////////////////////////
//
// CInputProcessorProfiles
//
//////////////////////////////////////////////////////////////////////////////

class CInputProcessorProfiles : public ITfInputProcessorProfilesEx,
                                public ITfInputProcessorProfileSubstituteLayout,
                                public ITfSource,
                                public CComObjectRoot_CreateSingletonInstance<CInputProcessorProfiles>
{
public:
    CInputProcessorProfiles();
    ~CInputProcessorProfiles();

    BEGIN_COM_MAP_IMMX(CInputProcessorProfiles)
        COM_INTERFACE_ENTRY(ITfInputProcessorProfiles)
        COM_INTERFACE_ENTRY(ITfInputProcessorProfilesEx)
        COM_INTERFACE_ENTRY(ITfInputProcessorProfileSubstituteLayout)
        COM_INTERFACE_ENTRY(ITfSource)
    END_COM_MAP_IMMX()

    // ITfInputProcessorProfiles
    STDMETHODIMP Register(REFCLSID clsid);

    STDMETHODIMP Unregister(REFCLSID clsid);

    STDMETHODIMP AddLanguageProfile(REFCLSID rclsid,
                                    LANGID langid,
                                    REFGUID guidProfile,
                                    const WCHAR *pchProfile,
                                    ULONG cch,
                                    const WCHAR *pchFile,
                                    ULONG cchFile,
                                    ULONG uIconIndex);

    STDMETHODIMP RemoveLanguageProfile(REFCLSID rclsid,
                                       LANGID langid,
                                       REFGUID guidProfile);

    STDMETHODIMP EnumInputProcessorInfo(IEnumGUID **ppEnum);

    STDMETHODIMP GetDefaultLanguageProfile(LANGID langid, 
                                           REFGUID catid, 
                                           CLSID *pclsid,
                                           GUID *pguidProfile);

    STDMETHODIMP SetDefaultLanguageProfile(LANGID langid, 
                                           REFCLSID rclsid, 
                                           REFGUID guidProfile);

    STDMETHODIMP ActivateLanguageProfile(REFCLSID rclsid, 
                                         LANGID langid, 
                                         REFGUID guidProfile);

    STDMETHODIMP GetActiveLanguageProfile(REFCLSID clsid, 
                                          LANGID *plangid, 
                                          GUID *pguidProfile);

    STDMETHODIMP GetLanguageProfileDescription(REFCLSID clsid, 
                                               LANGID langid, 
                                               REFGUID guidProfile,
                                               BSTR *pbstr);

    STDMETHODIMP GetCurrentLanguage(LANGID *plangid);

    STDMETHODIMP ChangeCurrentLanguage(LANGID langid);

    STDMETHODIMP GetLanguageList(LANGID **pplangid, ULONG *pulCount);

    STDMETHODIMP EnumLanguageProfiles(LANGID langid, 
                                      IEnumTfLanguageProfiles **ppEnum);

    STDMETHODIMP EnableLanguageProfile(REFCLSID rclsid,
                                       LANGID langid,
                                       REFGUID guidProfile,
                                       BOOL fEnable);

    STDMETHODIMP IsEnabledLanguageProfile(REFCLSID rclsid,
                                          LANGID langid,
                                          REFGUID guidProfile,
                                          BOOL *pfEnable);

    STDMETHODIMP EnableLanguageProfileByDefault(REFCLSID rclsid,
                                                LANGID langid,
                                                REFGUID guidProfile,
                                                BOOL fEnable);

    STDMETHODIMP SubstituteKeyboardLayout(REFCLSID rclsid,
                                          LANGID langid,
                                          REFGUID guidProfile,
                                          HKL hKL);

    // ITfInputProcessorProfiles
    STDMETHODIMP SetLanguageProfileDisplayName(REFCLSID rclsid,
                                               LANGID langid,
                                               REFGUID guidProfile,
                                               const WCHAR *pchFile,
                                               ULONG cchFile,
                                               ULONG uResId);


    // ITfInputProcessorProfileSubstituteLayout
    STDMETHODIMP GetSubstituteKeyboardLayout(REFCLSID rclsid,
                                             LANGID langid,
                                             REFGUID guidProfile,
                                             HKL *phKL);


    // ITfSource
    STDMETHODIMP AdviseSink(REFIID riid, IUnknown *punk, DWORD *puCookie);
    STDMETHODIMP UnadviseSink(DWORD dwCookie);

    BOOL _OnLanguageChange(BOOL fChanged, LANGID langid);

    static CInputProcessorProfiles *_GetThis() 
    { 
        SYSTHREAD *psfn = GetSYSTHREAD();
        if (!psfn)
            return NULL;
        return psfn->pipp;
    }

    static BOOL _SetThis(CInputProcessorProfiles *_this)
    { 
        SYSTHREAD *psfn = GetSYSTHREAD();
        if (!psfn)
            return FALSE;

        Assert(psfn->pipp == NULL || _this == NULL);
        psfn->pipp = _this;
        return TRUE;
    }

private:
    CStructArray<GENERICSINK> _rgNotifySinks; // ITfLanguageProfilesNotifySink
    BOOL _GetTIPRegister(CLSID **prgclsid, ULONG *pulCount);

    DBG_ID_DECLARE;
};

#endif // TFELIST_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\ctf\uim\internat.cpp ===
#include "private.h"
#include "globals.h"
#include "internat.h"
#include "strary.h"
#include "xstring.h"
#include "immxutil.h"
#include "cregkey.h"
#include "cmydc.h"
#include "assembly.h"

CStructArray<MLNGINFO> *g_pMlngInfo = NULL;


const TCHAR c_szDefaultUserPreload[] = TEXT(".DEFAULT\\Keyboard Layout\\Preload");
const TCHAR c_szPreload[] = TEXT("Keyboard Layout\\Preload");
const TCHAR c_szSubst[] = TEXT("Keyboard Layout\\Substitutes");

//////////////////////////////////////////////////////////////////////////////
//
// CStaticIconList
//
//////////////////////////////////////////////////////////////////////////////

class CStaticIconList
{
public:
    void Init(int cx, int cy);
    void RemoveAll(BOOL fInUninit);

    BOOL IsInited()
    {
        return _cx != 0;
    }

    int AddIcon(HICON hicon);
    HICON ExtractIcon(int i);
    void GetIconSize(int *cx, int *cy);
    int GetImageCount();

private:
    static int _cx;
    static int _cy;
    static CStructArray<HICON> *_prgIcons;
};

CStaticIconList g_IconList;
int CStaticIconList::_cx = 0;
int CStaticIconList::_cy = 0;
CStructArray<HICON> *CStaticIconList::_prgIcons = NULL;


//+---------------------------------------------------------------------------
//
// Init
//
//----------------------------------------------------------------------------

inline void CStaticIconList::Init(int cx, int cy)
{
    CicEnterCriticalSection(g_cs);
    _cx = cx;
    _cy = cy;
    CicLeaveCriticalSection(g_cs);
}

//+---------------------------------------------------------------------------
//
// RemoveAll
//
//----------------------------------------------------------------------------

void CStaticIconList::RemoveAll(BOOL fInUninit)
{
    int i;

    //
    // don't have to enter g_cs if we're in DllMain(PROCESS_DETATCH).
    //
    if (!fInUninit)
        CicEnterCriticalSection(g_cs);

    if (_prgIcons == NULL)
        goto Exit;

    for (i=0; i<_prgIcons->Count(); i++)
    {
        DestroyIcon(*_prgIcons->GetPtr(i));
    }

    delete _prgIcons;
    _prgIcons = NULL;

Exit:
    if (!fInUninit)
        CicLeaveCriticalSection(g_cs);
}

//+---------------------------------------------------------------------------
//
// AddIcon
//
//----------------------------------------------------------------------------

inline int CStaticIconList::AddIcon(HICON hicon)
{
    HICON hIconCopy;
    HICON *pIconDst;
    int nRet = -1;

    CicEnterCriticalSection(g_cs);

    if (!_prgIcons)
        _prgIcons = new CStructArray<HICON>;

    if (!_prgIcons)
        goto Exit;

    if ((pIconDst = _prgIcons->Append(1)) == NULL)
        goto Exit;

    if ((hIconCopy = CopyIcon(hicon)) == 0)
    {
        _prgIcons->Remove(_prgIcons->Count()-1, 1);
        goto Exit;
    }

    *pIconDst = hIconCopy;

    nRet = _prgIcons->Count()-1;

Exit:
    CicLeaveCriticalSection(g_cs);

    return nRet;
}

//+---------------------------------------------------------------------------
//
// ExtractIcon
//
//----------------------------------------------------------------------------

inline HICON CStaticIconList::ExtractIcon(int i)
{
    HICON hIcon = NULL;

    CicEnterCriticalSection(g_cs);

    if (!_prgIcons)
        goto Exit;

    if (i >= _prgIcons->Count() || i < 0)
        goto Exit;

    hIcon =  CopyIcon(*_prgIcons->GetPtr(i));
Exit:
    CicLeaveCriticalSection(g_cs);

    return hIcon;
}

//+---------------------------------------------------------------------------
//
// GetIconSize
//
//----------------------------------------------------------------------------

inline void CStaticIconList::GetIconSize(int *cx, int *cy)
{
    CicEnterCriticalSection(g_cs);
    *cx = _cx;
    *cy = _cy;
    CicLeaveCriticalSection(g_cs);
}

//+---------------------------------------------------------------------------
//
// GetImageCount
//
//----------------------------------------------------------------------------

inline int CStaticIconList::GetImageCount()
{
    int nRet = 0;

    CicEnterCriticalSection(g_cs);

    if (_prgIcons == NULL)
        goto Exit;

    nRet =  _prgIcons->Count();

Exit:
    CicLeaveCriticalSection(g_cs);

    return nRet;
}

//////////////////////////////////////////////////////////////////////////////
//
// UninitINAT
//
//////////////////////////////////////////////////////////////////////////////
    
void UninitINAT()
{
    g_IconList.RemoveAll(TRUE);

    if (g_pMlngInfo)
    {
        delete g_pMlngInfo;
        g_pMlngInfo = NULL;
    }
}

//////////////////////////////////////////////////////////////////////////////
//
// InterNAT icon APIs
//
//////////////////////////////////////////////////////////////////////////////

#if 0
//
// ISO 639:1988 Code.
//
//
// Under NT, we use GetLocaleInfoNTString(). It returns ISO 3166.
//
INATSYMBOL symInatSymbols[] = 
{
    {0x0436, "AF"},     // Afrikaans
    {0x041c, "SQ"},     // Albanian
    {0x0401, "AR"},     // Arabic
    {0x042d, "EU"},     // Basque
    {0x0423, "BE"},     // Byelorus
    {0x0402, "BG"},     // Bulgaria
    {0x0403, "CA"},     // Catalan
    {0x0404, "CH"},     // China #1
    {0x0804, "CH"},     // China #2
//#ifdef WINDOWS_PE
#if 1
    {0x041a, "HR"},     // Croatian
#else
    {0x041a, "SH"},     // Croatian
#endif
    {0x0405, "CZ"},     // Czech
    {0x0406, "DA"},     // Danish
    {0x0413, "NL"},     // Dutch
    {0x0813, "NL"},     // Dutch
    {0x0409, "EN"},     // English
    {0x0809, "EN"},     // English
    {0x0c09, "EN"},     // English
    {0x1009, "EN"},     // English
    {0x1409, "EN"},     // English
    {0x1809, "EN"},     // English
    {0x0425, "ET"},     // Estonian
    {0x0429, "FA"},     // Farsi
    {0x040b, "FI"},     // Finnish
    {0x040c, "FR"},     // French
    {0x080c, "FR"},     // French
    {0x0c0c, "FR"},     // French
    {0x0407, "DE"},     // German
    {0x0807, "DE"},     // German
    {0x0c07, "DE"},     // German
    {0x1007, "DE"},     // German
    {0x1407, "DE"},     // German
    {0x0408, "GR"},     // Greek
    {0x040d, "HE"},     // Hebrew
    {0x040e, "HU"},     // Hungary
    {0x040f, "IS"},     // Iceland
    {0x0421, "BA"},     // Indonesia
    {0x0410, "IT"},     // Italy
    {0x0810, "IT"},     // Italy
    {0x0411, "JA"},     // Japan
    {0x0412, "KO"},     // Korea
    {0x0426, "LV"},     // Latvian
    {0x0427, "LT"},     // Lithuanian
    {0x042f, "MK"},     // Former Yugoslav Republic of Macedonia
    {0x0414, "NO"},     // Norway
    {0x0814, "NO"},     // Norway
    {0x0415, "PL"},     // Poland
    {0x0416, "PT"},     // Portugal
    {0x0816, "PT"},     // Portugal
    {0x0417, "RM"},     // Rhaeto
    {0x0418, "RO"},     // Romanian
    {0x0818, "RO"},     // Romanian
    {0x0419, "RU"},     // Russian
    {0x0819, "RU"},     // Russian
    {0x081a, "SR"},     // Serbian
//#ifdef WINDOWS_PE
#if 1
    {0x0c1a, "SR"},     // Serbian
#endif
    {0x041b, "SK"},     // Slovakian
    {0x0424, "SL"},     // Slovenian
    {0x042e, "SB"},     // Sorbian
    {0x040a, "ES"},     // Spanish
    {0x080a, "ES"},     // Spanish
    {0x0c0a, "ES"},     // Spanish
    {0x041d, "SV"},     // Swedish
    {0x041e, "TH"},     // Thai
    {0x041f, "TR"},     // Turkish
    {0x0422, "UK"},     // Ukranian
    {0x0420, "UR"},     // Urdu
    {0x0033, "VE"},     // Venda
    {0x042a, "VN"},     // Vietnamese
    {0x0034, "XH"},     // Xhosa
    {0x0035, "ZU"},     // Zulu
    {0x002b, "ST"},     // Sutu
    {0x002e, "TS"},     // Tsona
    {0x002f, "TN"},     // Tswana
    {0x0000, "??"}
} ;

#define NSYMBOLS ((sizeof(symInatSymbols) / sizeof(INATSYMBOL))-1)
#endif

static const TCHAR c_szLayoutPath[] = TEXT("SYSTEM\\CurrentControlSet\\Control\\Keyboard Layouts");
static const TCHAR c_szLayoutText[] = TEXT("layout text");
static const TCHAR c_szLayoutID[]   = TEXT("layout id");

static const WCHAR c_szMUILayoutTextW[] = L"Layout Display Name";
static const WCHAR c_szLayoutTextW[] = L"layout text";

static const char c_szNamesPath[] = "system\\currentcontrolset\\control\\nls\\Locale";


//+---------------------------------------------------------------------------
//
// GetLocaleInfoString
//
// this is not a general wrapper for GetLocaleInfo!  
// LCTYPE must be LOCALE_SABBREVLANGNAME or LOCALE_SLANGUAGE.
//
//----------------------------------------------------------------------------

int GetLocaleInfoString(LCID lcid, LCTYPE lcType, char *psz, int cch)
{
    WCHAR achW[64];

    Assert((lcType & LOCALE_SLANGUAGE) || (lcType & LOCALE_SABBREVLANGNAME));

    if (IsOnNT())
    {
        if (GetLocaleInfoW(lcid, lcType, achW, ARRAYSIZE(achW)))
        {
            return WideCharToMultiByte(CP_ACP, 0, achW, -1, psz, cch, NULL, NULL);
        }
    }
    else
    {
        return GetLocaleInfo(lcid, lcType, psz, cch);
    }

    return 0;
}


//+---------------------------------------------------------------------------
//
// InatCreateIcon
//
//+---------------------------------------------------------------------------

HICON InatCreateIcon(WORD langID)
{
    LOGFONT  lf;
    UINT cxSmIcon;
    UINT cySmIcon;

    cxSmIcon = GetSystemMetrics( SM_CXSMICON );
    cySmIcon = GetSystemMetrics( SM_CYSMICON );

    if( !SystemParametersInfo(SPI_GETICONTITLELOGFONT, sizeof(LOGFONT), &lf, 0))
        return NULL;

    if (cySmIcon < GetPhysicalFontHeight(lf))
    {
        lf.lfHeight = 0 - ((int)cySmIcon * 7 / 10);
        lf.lfWidth = 0;
    }

    return InatCreateIconBySize(langID, cxSmIcon, cySmIcon, &lf);
}


//+---------------------------------------------------------------------------
//
// InatCreateIconBySize
//
//+---------------------------------------------------------------------------

HICON InatCreateIconBySize(WORD langID, int cxSmIcon, int cySmIcon, LOGFONT *plf)
{
    HBITMAP  hbmColour;
    HBITMAP  hbmMono;
    HBITMAP  hbmOld;
    HICON    hicon = NULL;
    ICONINFO ii;
    RECT     rc;
    DWORD    rgbText;
    DWORD    rgbBk = 0;
    HDC      hdc;
    HDC      hdcScreen;
    HFONT    hfont;
    HFONT hfontOld;
    TCHAR szData[20];


    //
    //  Get the indicator by using the first 2 characters of the
    //  abbreviated language name.
    //
    if (GetLocaleInfoString( MAKELCID(langID, SORT_DEFAULT),
                       LOCALE_SABBREVLANGNAME | LOCALE_NOUSEROVERRIDE,
                       szData,
                       sizeof(szData) / sizeof(TCHAR) ))
    {
        //
        //  Make Uppercase
        //
        if (!IsOnNT())
        {
            szData[0] -= 0x20;
            szData[1] -= 0x20;
        }
        //
        //  Only use the first two characters.
        //
        szData[2] = TEXT('\0');
    }
    else
    {
        //
        //  Id wasn't found.  Use question marks.
        //
        szData[0] = TEXT('?');
        szData[1] = TEXT('?');
        szData[2] = TEXT('\0');
    }

    if( (hfont = CreateFontIndirect(plf)) )
    {
        hdcScreen = GetDC(NULL);
        hdc       = CreateCompatibleDC(hdcScreen);
        hbmColour = CreateCompatibleBitmap(hdcScreen, cxSmIcon, cySmIcon);
        ReleaseDC( NULL, hdcScreen);
        if (hbmColour && hdc)
        {
            hbmMono = CreateBitmap(cxSmIcon, cySmIcon, 1, 1, NULL);
            if (hbmMono)
            {
                hbmOld    = (HBITMAP)SelectObject( hdc, hbmColour);
                rc.left   = 0;
                rc.top    = 0;
                rc.right  = cxSmIcon;
                rc.bottom = cySmIcon;
    
                rgbBk = SetBkColor(hdc, GetSysColor(COLOR_HIGHLIGHT));
                rgbText = SetTextColor(hdc, GetSysColor(COLOR_HIGHLIGHTTEXT));

                ExtTextOut( hdc, rc.left, rc.top, ETO_OPAQUE, &rc, "", 0, NULL);

                hfontOld = (HFONT)SelectObject( hdc, hfont);
                DrawText(hdc, 
                     szData,
                     2, 
                     &rc, 
                     DT_CENTER | DT_VCENTER | DT_SINGLELINE);

                SelectObject( hdc, hbmMono);
                PatBlt(hdc, 0, 0, cxSmIcon, cySmIcon, BLACKNESS);

                ii.fIcon    = TRUE;
                ii.xHotspot = 0;
                ii.yHotspot = 0;
                ii.hbmColor = hbmColour;
                ii.hbmMask  = hbmMono;
                hicon       = CreateIconIndirect(&ii);

                SelectObject(hdc, hbmOld);
                DeleteObject(hbmMono);
                SelectObject(hdc, hfontOld);
            }
        }
        DeleteObject(hbmColour);
        DeleteDC(hdc);
        DeleteObject(hfont);
    }

    return hicon;
}

//+---------------------------------------------------------------------------
//
// GetIconFromFile
//
//+---------------------------------------------------------------------------

HICON GetIconFromFile(int cx, int cy, WCHAR *lpszFileName, UINT uIconIndex)
{
    return GetIconFromFileA(cx, cy, WtoA(lpszFileName), uIconIndex);
}

//+---------------------------------------------------------------------------
//
// GetIconFromFileA
//
//+---------------------------------------------------------------------------

HICON GetIconFromFileA(int cx, int cy, char *lpszFileName, UINT uIconIndex)
{
    HICON hicon = NULL;

    if (cx > GetSystemMetrics(SM_CXSMICON))
    {
        ExtractIconEx(lpszFileName, uIconIndex, &hicon, NULL, 1);
    }
    else
    {
        ExtractIconEx(lpszFileName, uIconIndex, NULL, &hicon, 1);
    }

    return hicon;
}

//+---------------------------------------------------------------------------
//
// CLayoutsSharedMem
//
//+---------------------------------------------------------------------------

extern CCicMutex g_mutexLayouts;
extern char g_szLayoutsCache[];

class CLayoutsSharedMem : public CCicFileMappingStatic
{
public:
    void Init()
    {
        CCicFileMappingStatic::Init(g_szLayoutsCache, &g_mutexLayouts);
    }

    BOOL Start(UINT nNum)
    {
        BOOL fAlreadyExists;

        if (Create(NULL, sizeof(LAYOUT) * nNum, &fAlreadyExists) == NULL)
            return FALSE;

        return TRUE;
    }

    LAYOUT *GetPtr() { return (LAYOUT *)_pv; }
};

CLayoutsSharedMem g_smLayouts;

//+---------------------------------------------------------------------------
//
// UninitLayoutMappedFile();
//
//----------------------------------------------------------------------------

void UninitLayoutMappedFile()
{
    g_smLayouts.Uninit();
}

//+---------------------------------------------------------------------------
//
// LoadKeyboardLayouts
//
//----------------------------------------------------------------------------

BOOL LoadKeyboardLayouts()
{
    CMyRegKey key;
    DWORD dwIndex;
    BOOL bRet = FALSE;
    TCHAR szValue[MAX_PATH];           // language id (number)
    WCHAR szValueW[MAX_PATH];
    TCHAR szData[MAX_PATH];            // language name
    CStructArray<LAYOUT> *pLayouts = NULL;
    LAYOUT *pLayout;
    BOOL bLoadedLayout;

    pLayouts = new CStructArray<LAYOUT>;
    if (!pLayouts)
        return FALSE;

    //
    //  Now read all the locales from the registry.
    //
    if (key.Open(HKEY_LOCAL_MACHINE, c_szLayoutPath, KEY_READ) != ERROR_SUCCESS)
    {
        goto Exit;
    }

    dwIndex = 0;
    szValue[0] = TEXT('\0');
    while (key.EnumKey(dwIndex, szValue, ARRAYSIZE(szValue)) == ERROR_SUCCESS)
    {
        CRegKeyMUI key1;

        pLayout = pLayouts->Append(1);
        if (!pLayout)
            goto Exit;

        pLayout->dwID = AsciiToNum(szValue);

        if (StringCchPrintf(szData, ARRAYSIZE(szData), "%s\\%s", c_szLayoutPath, szValue) != S_OK)
            goto Next;

        if (key1.Open(HKEY_LOCAL_MACHINE, szData, KEY_READ) == S_OK)
        {
            //
            //  Get the layout name.
            //
            szValue[0] = TEXT('\0');
            bLoadedLayout = FALSE;

            if (IsOnNT())
            {
                szValueW[0] = 0;

                if (key1.QueryValueCchW(szValueW,
                                     c_szMUILayoutTextW,
                                     ARRAYSIZE(szValueW)) == S_OK)
                {
                    bLoadedLayout = TRUE;
                }
                else if (key1.QueryValueCchW(szValueW,
                                          c_szLayoutTextW,
                                          ARRAYSIZE(szValueW)) == S_OK)
                {
                    bLoadedLayout = TRUE;
                }

                if (bLoadedLayout)
                {
                    wcsncpy(pLayout->wszText,
                            szValueW,
                            ARRAYSIZE(pLayout->wszText));
                }
            }
            else
            {
                if (key1.QueryValueCch(szValue,
                                    c_szLayoutText,
                                    ARRAYSIZE(szValue)) == S_OK)
                {
                    wcsncpy(pLayout->wszText,
                            AtoW(szValue),
                            ARRAYSIZE(pLayout->wszText));

                    bLoadedLayout = TRUE;
                }
            }

            if (bLoadedLayout)
            {
                szValue[0] = TEXT('\0');
                pLayout->iSpecialID = 0;

                if (key1.QueryValueCch(szValue,
                                    c_szLayoutID,
                                    ARRAYSIZE(szValue)) == S_OK)

                {
                    //
                    //  This may not exist!
                    //
                    pLayout->iSpecialID = (UINT)AsciiToNum(szValue);
                }
            }
        }
Next:
        dwIndex++;
        szValue[0] = TEXT('\0');
    } 

    pLayout = pLayouts->Append(1);
    if (!pLayout)
        goto Exit;

    memset(pLayout, 0, sizeof(LAYOUT));

    if (!g_smLayouts.Enter())
        goto Exit;

    g_smLayouts.Close();

    if (g_smLayouts.Start(pLayouts->Count()))
    {
        if (g_smLayouts.GetPtr())
        {
            memcpy(g_smLayouts.GetPtr(), 
                   pLayouts->GetPtr(0), 
                   pLayouts->Count() * sizeof(LAYOUT));
            bRet = TRUE;
        }
    }
    g_smLayouts.Leave();

Exit:

    if (pLayouts)
        delete pLayouts;

    return bRet;
}

//+---------------------------------------------------------------------------
//
//  FindLayoutEntry
//
//  Gets the name of the given layout.
//
//+---------------------------------------------------------------------------

UINT FindLayoutEntry( LAYOUT *pLayout, DWORD dwLayout )
{
    UINT ctr = 0;
    UINT id;
    WORD wLayout = HIWORD(dwLayout);
    BOOL bIsIME = ((HIWORD(dwLayout) & 0xf000) == 0xe000) ? TRUE : FALSE;

    //
    //  Find the layout in the global structure.
    //
    if ((wLayout & 0xf000) == 0xf000)
    {
        //
        //  Layout is special, need to search for the ID
        //  number.
        //
        id = wLayout & 0x0fff;
        ctr = 0;
        while (pLayout[ctr].dwID)
        {
            if (id == pLayout[ctr].iSpecialID)
            {
                break;
            }
            ctr++;
        }
    }
    else
    {
        ctr = 0;
        while (pLayout[ctr].dwID)
        {
            //
            // If it is IME, needs to be DWORD comparison.
            //
            if (IsOnFE() && bIsIME && (dwLayout == pLayout[ctr].dwID))
            {
                break;
            }
            else if (wLayout == LOWORD(pLayout[ctr].dwID))
            {
                break;
            }
            ctr++;
        }
    }

    return ctr;
}

//+---------------------------------------------------------------------------
//
//  GetKbdLayoutName
//
//  Gets the name of the given layout.
//
//+---------------------------------------------------------------------------

void GetKbdLayoutName( DWORD dwLayout, WCHAR *pBuffer, int nBufSize)
{
    UINT ctr;
    LAYOUT *pLayout;

    *pBuffer = L'\0';

    if (!g_smLayouts.Enter())
        return;

    g_smLayouts.Close();
    g_smLayouts.Init();
    if (!g_smLayouts.Open())
    {
        if (!LoadKeyboardLayouts())
        {
            Assert(0);
        }
    }

    pLayout = g_smLayouts.GetPtr();
    if (!pLayout)
        goto Exit;

    ctr = FindLayoutEntry( pLayout, dwLayout );

    //
    //  Make sure there is a match.  If not, then simply return without
    //  copying anything.
    //
    if (pLayout[ctr].dwID)
    {
        //
        //  Separate the Input Locale name and the Layout name with " - ".
        //
#ifdef ATTACH_LAYOUTNAME
        pBuffer[0] = L' ';
        pBuffer[1] = L'-';
        pBuffer[2] = L' ';

        wcsncpy(pBuffer + 3, pLayout[ctr].wszText, nBufSize - 3);
#else
        wcsncpy(pBuffer, pLayout[ctr].wszText, nBufSize);
#endif
    }

Exit:
    g_smLayouts.Leave();
}

//+---------------------------------------------------------------------------
//
//  GetKbdLayoutId
//
//  Gets the name of the given layout.
//
//+---------------------------------------------------------------------------

DWORD GetKbdLayoutId( DWORD dwLayout)
{
    UINT ctr;
    DWORD dwId = 0;
    LAYOUT *pLayout;

    if (!g_smLayouts.Enter())
        return 0;

    g_smLayouts.Close();
    g_smLayouts.Init();
    if (!g_smLayouts.Open())
        LoadKeyboardLayouts();

    pLayout = g_smLayouts.GetPtr();
    if (!pLayout)
        goto Exit;

    ctr = FindLayoutEntry( pLayout, dwLayout );

    //
    //  Make sure there is a match.  If not, then simply return without
    //  copying anything.
    //
    dwId = pLayout[ctr].dwID;

Exit:
    g_smLayouts.Leave();

    return dwId;
}

//+---------------------------------------------------------------------------
//
// GetLocaleInfoString
//
// this is not a general wrapper for GetLocaleInfo!  
// LCTYPE must be LOCALE_SABBREVLANGNAME or LOCALE_SLANGUAGE.
//
//----------------------------------------------------------------------------
ULONG GetLocaleInfoString(HKL hKL, WCHAR *pszRegText, int nSize)
{
    ULONG cb = 0;
    DWORD dwRegValue = (DWORD)((LONG_PTR)(hKL) & 0x0000FFFF);

    *pszRegText = L'\0';

    if (IsOnNT())
    {
        if (!GetLocaleInfoW(dwRegValue, LOCALE_SLANGUAGE, pszRegText, nSize))
        {
            *pszRegText = L'\0';
        }

        //
        //  Attach the Layout name if it's not the default.
        //
        if (HIWORD(hKL) != LOWORD(hKL))
        {
#ifdef ATTACH_LAYOUTNAME
            WCHAR *pszRT = pszRegText + wcslen(pszRegText);
            //
            // Pass DWORD value for IME.
            //
            GetKbdLayoutName((DWORD)(LONG_PTR)hKL, 
                              pszRT,
                              nSize - (DWORD)(pszRT - pszRegText));
#else
            GetKbdLayoutName((DWORD)(LONG_PTR)hKL, pszRegText, nSize);
#endif
        }

    }
    else
    {
        CMyRegKey key;
        char szRegKey[128];
        char szRegText[128];
        StringCchPrintf(szRegKey, ARRAYSIZE(szRegKey),"%8.8lx", (DWORD)dwRegValue);

        *pszRegText = '\0';
        if(key.Open(HKEY_LOCAL_MACHINE,c_szNamesPath, KEY_READ)==ERROR_SUCCESS)
        {
            if(key.QueryValueCch(szRegText, szRegKey, ARRAYSIZE(szRegText)) == ERROR_SUCCESS)
            {
                DWORD dwLen = MultiByteToWideChar(CP_ACP, 
                                                  MB_ERR_INVALID_CHARS, 
                                                  szRegText, 
                                                  lstrlen(szRegText), 
                                                  pszRegText, 
                                                  nSize-1);
                pszRegText[dwLen] = L'\0';
            }
        }

    }

    return wcslen(pszRegText);
}

//+---------------------------------------------------------------------------
//
// GetHKLDescription
//
//
//----------------------------------------------------------------------------
int GetHKLDesctription(HKL hKL, WCHAR *pszDesc, int cchDesc, WCHAR *pszIMEFile, int cchIMEFile)
{
    DWORD dwIMEDesc = 0;

    if (IsIMEHKL(hKL))
    {
        HKEY hkey;
        DWORD dwIMELayout;
        TCHAR szIMELayout[MAX_PATH];
        TCHAR szIMELayoutPath[MAX_PATH];

        dwIMELayout = GetSubstitute(hKL);
        StringCchPrintf(szIMELayout, ARRAYSIZE(szIMELayout), "%8.8lx", dwIMELayout);

        StringCopyArray(szIMELayoutPath, c_szLayoutPath);
        StringCatArray(szIMELayoutPath, TEXT("\\"));
        StringCatArray(szIMELayoutPath, szIMELayout);

        if (RegOpenKeyEx(HKEY_LOCAL_MACHINE, szIMELayoutPath, 0, KEY_READ, &hkey)
            == ERROR_SUCCESS)
        {
            if (SHLoadRegUIStringW(hkey,
                                   c_szMUILayoutTextW,
                                   pszDesc, cchDesc) == S_OK)
            {
                dwIMEDesc = wcslen(pszDesc);
            }
            RegCloseKey(hkey);
        }

        if (!dwIMEDesc)
        {
            dwIMEDesc = ImmGetDescriptionW(hKL,pszDesc,cchDesc);
            if (!dwIMEDesc)
                pszDesc[0] = L'\0';
        }
    }

    if (dwIMEDesc == 0)
    {
        GetLocaleInfoString(hKL, pszDesc, cchDesc);
        pszIMEFile[0] = L'\0';
    }
    else 
    {
        if (!ImmGetIMEFileNameW(hKL, pszIMEFile, cchIMEFile))
            pszIMEFile[0] = L'\0';
    }

    return wcslen(pszDesc);
}

//////////////////////////////////////////////////////////////////////////////
//
// MLNGINFO List
//
//////////////////////////////////////////////////////////////////////////////

//---------------------------------------------------------------------------
//
// MlngInfoCount()
//
//---------------------------------------------------------------------------
int WINAPI TF_MlngInfoCount()
{
    if (!g_pMlngInfo)
        return 0;

    return g_pMlngInfo->Count();
}

//---------------------------------------------------------------------------
//
// GetMlngInfo()
//
//---------------------------------------------------------------------------
BOOL GetMlngInfo(int n, MLNGINFO *pmlInfo)
{
    BOOL bRet = FALSE;
    MLNGINFO *pml;

    if (!g_pMlngInfo)
        return FALSE;

    CicEnterCriticalSection(g_cs);

    Assert(g_pMlngInfo);

    if (n >= g_pMlngInfo->Count())
        goto Exit;

    pml = g_pMlngInfo->GetPtr(n);
    if (!pml)
        goto Exit;

    *pmlInfo = *pml;
    bRet = TRUE;

Exit:
    CicLeaveCriticalSection(g_cs);
    return bRet;
}

//---------------------------------------------------------------------------
//
// GetMlngInfoByhKL()
//
//---------------------------------------------------------------------------
int GetMlngInfoByhKL(HKL hKL, MLNGINFO *pmlInfo)
{
    int nRet = -1;
    MLNGINFO *pml;

    if (!g_pMlngInfo)
        return 0;

    CicEnterCriticalSection(g_cs);

    int nCnt = g_pMlngInfo->Count();
    int i; 

    for (i = 0; i < nCnt; i++)
    {
        pml = g_pMlngInfo->GetPtr(i);
        if (pml->hKL == hKL)
        {
            *pmlInfo = *pml;
            nRet = i;
            break;
        }
    }

    CicLeaveCriticalSection(g_cs);
    return nRet;
}

//+---------------------------------------------------------------------------
//
// CheckMlngInfo
//
// return TRUE, if MlangInfo needs to be updated.
//
//----------------------------------------------------------------------------

BOOL CheckMlngInfo()
{
    int    iLangs;
    BOOL   bRet = FALSE;
    HKL    *pLanguages = NULL;

    if (!g_pMlngInfo)
        return TRUE;

    iLangs = GetKeyboardLayoutList((UINT)0, (HKL FAR *)NULL);

    if (iLangs != TF_MlngInfoCount())
        return TRUE;

    if (iLangs)
    {
        int i;
        pLanguages = (HKL *)cicMemAlloc(iLangs * sizeof(HKL));
        if (!pLanguages)
            goto Exit;

        GetKeyboardLayoutList(iLangs, (HKL FAR *)pLanguages);
        for (i = 0; i < iLangs; i++)
        {
            MLNGINFO *pMlngInfo =  g_pMlngInfo->GetPtr(i);
            if (pMlngInfo->hKL != pLanguages[i])
            {
                bRet = TRUE;
                goto Exit;
            }
        }
    }
Exit:
    if (pLanguages)
        cicMemFree(pLanguages);
    return bRet;
}

//---------------------------------------------------------------------------
//
// void DestroyMlngInfo()
//
//---------------------------------------------------------------------------

void DestroyMlngInfo()
{
    if (g_pMlngInfo)
    {
        while (g_pMlngInfo->Count())
        {
            g_pMlngInfo->Remove(0, 1);
        }
        delete g_pMlngInfo;
        g_pMlngInfo = NULL;
    }
}

//---------------------------------------------------------------------------
//
// void CreateMLlngInfo()
//
//---------------------------------------------------------------------------

void CreateMlngInfo()
{
    HKL         *pLanguages;
    UINT        uCount;
    UINT        uLangs;
    MLNGINFO    *pMlngInfo;
    BOOL        fNeedInd = FALSE;

    uLangs = GetKeyboardLayoutList((UINT)0, (HKL FAR *)NULL);

    if (!g_pMlngInfo)
        g_pMlngInfo = new CStructArray<MLNGINFO>;

    if (!g_pMlngInfo)
        return;

    if (!EnsureIconImageList())
    {
        return;
    }

    pLanguages = (HKL *)cicMemAllocClear(uLangs * sizeof(HKL));
    if (!pLanguages)
        return;

    GetKeyboardLayoutList(uLangs, (HKL FAR *)pLanguages);

    //
    // pLanguages contains all the HKLs in the system
    // Put everything together in the DPA and Image List
    //
    for (uCount = 0; uCount < uLangs; uCount++)
    {
        pMlngInfo = g_pMlngInfo->Append(1);
        if (pMlngInfo)
        {
            pMlngInfo->hKL = pLanguages[uCount];
            pMlngInfo->fInitIcon = FALSE;
            pMlngInfo->fInitDesc = FALSE;
        }

    }

    cicMemFree(pLanguages);
}

//---------------------------------------------------------------------------
//
// void InitDesc
//
//---------------------------------------------------------------------------

void MLNGINFO::InitDesc()
{
    MLNGINFO *pml;

    if (fInitDesc)
        return;

    WCHAR       szRegText[256];
    WCHAR       szIMEFile[256];

    GetHKLDesctription(hKL,
                       szRegText, ARRAYSIZE(szRegText),
                       szIMEFile, ARRAYSIZE(szIMEFile));

    fInitDesc = TRUE;
    SetDesc(szRegText);

    CicEnterCriticalSection(g_cs);

    Assert(g_pMlngInfo);

    int nCnt = g_pMlngInfo->Count();
    int i; 

    for (i = 0; i < nCnt; i++)
    {
        pml = g_pMlngInfo->GetPtr(i);
        if (pml->hKL == hKL)
        {
            pml->fInitDesc = TRUE;
            pml->SetDesc(szRegText);
            break;
        }
    }

    CicLeaveCriticalSection(g_cs);
    return;
}

//---------------------------------------------------------------------------
//
// void InitIcon
//
//---------------------------------------------------------------------------

void MLNGINFO::InitIcon()
{
    HICON       hIcon;

    if (fInitIcon)
        return;

    WCHAR       szRegText[256];
    WCHAR       szIMEFile[256];

    GetHKLDesctription(hKL,
                       szRegText, ARRAYSIZE(szRegText),
                       szIMEFile, ARRAYSIZE(szIMEFile));

    fInitDesc = TRUE;
    SetDesc(szRegText);

    if (wcslen(szIMEFile))
    {
        int cx, cy;

        InatGetIconSize(&cx, &cy);
        if ((hIcon = GetIconFromFile(cx, cy, szIMEFile, 0)) == 0)
        {
            goto GetLangIcon;                
        }
    }
    else // for non-ime layout
    {
GetLangIcon:
        hIcon = InatCreateIcon(LOWORD((DWORD)(UINT_PTR)hKL));
    }

    if (hIcon)
    {
        nIconIndex = InatAddIcon(hIcon);
        DestroyIcon(hIcon);
    }

    MLNGINFO *pml;

    CicEnterCriticalSection(g_cs);

    Assert(g_pMlngInfo);

    int nCnt = g_pMlngInfo->Count();
    int i; 

    for (i = 0; i < nCnt; i++)
    {
        pml = g_pMlngInfo->GetPtr(i);
        if (pml->hKL == hKL)
        {
            pml->fInitDesc = TRUE;
            pml->fInitIcon = TRUE;
            pml->nIconIndex = nIconIndex;
            pml->SetDesc(szRegText);
            break;
        }
    }

    CicLeaveCriticalSection(g_cs);
    return;
}

//---------------------------------------------------------------------------
//
// void TF_InitMLlngInfo()
//
//---------------------------------------------------------------------------

void WINAPI TF_InitMlngInfo()
{
    CicEnterCriticalSection(g_cs);

    if (CheckMlngInfo())
    {
        DestroyMlngInfo();
        CreateMlngInfo();
    }

    CicLeaveCriticalSection(g_cs);
}

//---------------------------------------------------------------------------
//
// void TF_InitMLlngHKL()
//
//---------------------------------------------------------------------------

BOOL TF_GetMlngHKL(int nId, HKL *phkl, WCHAR *psz, UINT cch)
{
    BOOL bRet = FALSE;
    MLNGINFO *pml;

    CicEnterCriticalSection(g_cs);

    Assert(g_pMlngInfo);

    if (nId >= g_pMlngInfo->Count())
        goto Exit;

    pml = g_pMlngInfo->GetPtr(nId);
    if (!pml)
        goto Exit;

    if (phkl)
        *phkl = pml->hKL;

    if (psz)
        wcsncpy(psz, pml->GetDesc(), cch);

    bRet = TRUE;

Exit:
    CicLeaveCriticalSection(g_cs);
    return bRet;
}

//---------------------------------------------------------------------------
//
// void TF_GetMlngIconIndex()
//
//---------------------------------------------------------------------------

UINT WINAPI TF_GetMlngIconIndex(int nId)
{
    UINT uIconIndex = (UINT)-1;
    MLNGINFO *pml;

    CicEnterCriticalSection(g_cs);

    Assert(g_pMlngInfo);

    if (nId >= g_pMlngInfo->Count())
        goto Exit;

    pml = g_pMlngInfo->GetPtr(nId);
    if (!pml)
        goto Exit;

    uIconIndex = pml->GetIconIndex();

Exit:
    CicLeaveCriticalSection(g_cs);
    return uIconIndex;
}

//---------------------------------------------------------------------------
//
// void ClearMlngIconIndex()
//
//---------------------------------------------------------------------------

void ClearMlngIconIndex()
{
    int i;
    CicEnterCriticalSection(g_cs);

    Assert(g_pMlngInfo);

    for (i = 0; i < g_pMlngInfo->Count(); i++)
    {
        MLNGINFO *pml;
        pml = g_pMlngInfo->GetPtr(i);
        if (!pml)
            goto Exit;

        pml->ClearIconIndex();
    }

Exit:
    CicLeaveCriticalSection(g_cs);
    return;
}

//////////////////////////////////////////////////////////////////////////////
//
// IconImageList
//
//////////////////////////////////////////////////////////////////////////////


//---------------------------------------------------------------------------
//
// EnsureIconImageList
//
//---------------------------------------------------------------------------

BOOL EnsureIconImageList()
{
    if (g_IconList.IsInited())
        return TRUE;

    g_IconList.Init(GetSystemMetrics(SM_CXSMICON), GetSystemMetrics(SM_CYSMICON));

    return TRUE;
}

//---------------------------------------------------------------------------
//
// InatAddIcon
//
//---------------------------------------------------------------------------

UINT InatAddIcon(HICON hIcon)
{
    if (!EnsureIconImageList())
         return -1;

    return g_IconList.AddIcon(hIcon);
}

//---------------------------------------------------------------------------
//
// InatExtractIcon
//
//---------------------------------------------------------------------------

HICON WINAPI TF_InatExtractIcon(UINT uId)
{
    return g_IconList.ExtractIcon(uId);
}

//---------------------------------------------------------------------------
//
// InatGetIconSize
//
//---------------------------------------------------------------------------

BOOL InatGetIconSize(int *pcx, int *pcy)
{
    g_IconList.GetIconSize(pcx, pcy);
    return TRUE;
}

//---------------------------------------------------------------------------
//
// InatGetImageCount
//
//---------------------------------------------------------------------------

BOOL InatGetImageCount()
{
    return g_IconList.GetImageCount();
}

//---------------------------------------------------------------------------
//
// InatRemoveAll
//
//---------------------------------------------------------------------------

void InatRemoveAll()
{
    if (!g_IconList.IsInited())
         return;

    g_IconList.RemoveAll(FALSE);

    return;
}

//////////////////////////////////////////////////////////////////////////////
//
// HKL API
//
//////////////////////////////////////////////////////////////////////////////

//-----------------------------------------------------------------------------
//
// CPreloadRegKey
//
//-----------------------------------------------------------------------------

class CPreloadRegKey : public CMyRegKey
{
public:
    HRESULT Open(BOOL fDefaultUser = FALSE) 
    {
        if (fDefaultUser)
            return CMyRegKey::Open(HKEY_USERS, c_szDefaultUserPreload, KEY_ALL_ACCESS);
        else
            return CMyRegKey::Open(HKEY_CURRENT_USER, c_szPreload, KEY_ALL_ACCESS);
    }

    HKL Get(int n)
    {
        char szValue[16];
        char szValueName[16];
        StringCchPrintf(szValueName, ARRAYSIZE(szValueName), "%d", n);

        if (IsOnNT())
        {
            if (QueryValueCch(szValue, szValueName, ARRAYSIZE(szValue)) != S_OK)
                return NULL;
        }
        else
        {
            CMyRegKey keySub;
            if (keySub.Open(m_hKey, szValueName, KEY_READ) != S_OK)
                return NULL;

            if (keySub.QueryValueCch(szValue, NULL, ARRAYSIZE(szValue)) != S_OK)
                return NULL;
        }

        return (HKL)(LONG_PTR)AsciiToNum(szValue);
    }

    void Set(int n, HKL hkl)
    {
        char szValue[16];
        char szValueName[16];
        StringCchPrintf(szValueName, ARRAYSIZE(szValueName), "%d", n);
        NumToA((DWORD)(LONG_PTR)hkl, szValue);

        if (IsOnNT())
        {
            SetValue(szValue, szValueName);
        }
        else
        {
            CMyRegKey keySub;
            if (keySub.Open(m_hKey, szValueName, KEY_ALL_ACCESS) == S_OK)
                keySub.SetValue(szValue, (LPSTR)NULL);

        }
        return;
    }

    void Delete(int n)
    {
        char szValueName[16];
        StringCchPrintf(szValueName, ARRAYSIZE(szValueName), "%d", n);

        if (IsOnNT())
        {
            DeleteValue(szValueName);
        }
        else
        {
            DeleteSubKey(szValueName);

        }
        return;
    }
};


//+---------------------------------------------------------------------------
//
// GetSubstitute
//
//----------------------------------------------------------------------------

DWORD GetSubstitute(HKL hKL)
{
    CMyRegKey key;
    DWORD dwIndex = 0;
    TCHAR szValue[16];
    TCHAR szValueName[64];
    DWORD dwLayout = HandleToLong(hKL);

    //
    // it's IME.
    //
    if ((dwLayout & 0xf0000000) == 0xe0000000)
        return dwLayout;

    //
    // it's default layout.
    //
    if (HIWORD(dwLayout) == LOWORD(dwLayout))
        dwLayout &= 0x0000FFFF;
    else if ((dwLayout & 0xf0000000) == 0xf0000000)
        dwLayout = GetKbdLayoutId(dwLayout);

    if (key.Open(HKEY_CURRENT_USER, c_szSubst, KEY_READ) != S_OK)
        return dwLayout;

    if (IsOnNT())
    {
        while (key.EnumValue(dwIndex, szValueName, ARRAYSIZE(szValueName)) == S_OK)
        {
            if (key.QueryValueCch(szValue, szValueName, ARRAYSIZE(szValue)) == S_OK)
            {
                if ((dwLayout & 0x0FFFFFFF) == AsciiToNum(szValue))
                {
                    return AsciiToNum(szValueName);
                }
            }
            dwIndex++;
        }
    }
    else
    {
        while (key.EnumKey(dwIndex, szValueName, ARRAYSIZE(szValueName)) == S_OK)
        {
            CMyRegKey keySub;
            if (keySub.Open(key, szValueName, KEY_READ) == S_OK)
            {
                if (key.QueryValueCch(szValue, NULL, ARRAYSIZE(szValue)) == S_OK)
                {
                    if ((dwLayout & 0x0FFFFFFF) == AsciiToNum(szValue))
                    {
                        return AsciiToNum(szValueName);
                    }
                }
            }
            dwIndex++;
        }
    }

    return dwLayout;
}

//+---------------------------------------------------------------------------
//
// SetSystemDefaultHKL
//
//----------------------------------------------------------------------------

BOOL SetSystemDefaultHKL(HKL hkl)
{
    CPreloadRegKey key;
    int n;
    HKL hklFirst;
    BOOL bRet = FALSE;
    DWORD dwLayout;

    if (key.Open() != S_OK)
        return bRet;

    dwLayout = GetSubstitute(hkl);

    n = 1;
    while(1)
    {
        HKL hklCur;
        hklCur = key.Get(n);
        if (!hklCur)
            break;

        if (n == 1)
            hklFirst = hklCur;

        if (hklCur == LongToHandle(dwLayout))
        {
            bRet = TRUE;
            if (n != 1)
            {
                key.Set(n, hklFirst);
                key.Set(1, hklCur);

            }
            bRet = SystemParametersInfo( SPI_SETDEFAULTINPUTLANG,
                                         0,
                                         (LPVOID)((LPDWORD)&hkl),
                                         0 );

            Assert(bRet);
            break;
        }

        n++;
    }
 
    return bRet;
}

//+---------------------------------------------------------------------------
//
// GetPreloadListForNT()
//
//----------------------------------------------------------------------------

UINT GetPreloadListForNT(DWORD *pdw, UINT uBufSize)
{
    CMyRegKey key;
    CMyRegKey key1;
    char szValue[16];
    char szSubstValue[16];
    char szName[16];
    UINT uRet = 0;

    //
    // this function support only NT.
    // win9x has different formation for Preload registry. Each layout is key.
    //
    if (!IsOnNT())
        return 0;
 
    if (key.Open(HKEY_CURRENT_USER, c_szPreload, KEY_READ) != S_OK)
        return uRet;

    key1.Open(HKEY_CURRENT_USER, c_szSubst, KEY_READ);

    if (!pdw)
        uBufSize = 1000;

    while (uRet < uBufSize)
    {
        BOOL fUseSubst = FALSE;
        StringCchPrintf(szName, ARRAYSIZE(szName), "%d", uRet + 1);
        if (key.QueryValueCch(szValue, szName, ARRAYSIZE(szValue)) != S_OK)
            return uRet;

        if ((HKEY)key1)
        {
            if (key1.QueryValueCch(szSubstValue, szValue, ARRAYSIZE(szSubstValue)) == S_OK)
               fUseSubst = TRUE;

        }

        if (pdw)
        {
            *pdw = AsciiToNum(fUseSubst ? szSubstValue : szValue);
            pdw++;
        }

        uRet++;
    }

    return uRet;
}

#ifdef LATER_TO_CHECK_DUMMYHKL

//+---------------------------------------------------------------------------
//
// RemoveFEDummyHKLFromPreloadReg()
//
//----------------------------------------------------------------------------

void RemoveFEDummyHKLFromPreloadReg(HKL hkl, BOOL fDefaultUser)
{
    CPreloadRegKey key;
    BOOL fReset = FALSE;
    UINT uCount;
    UINT uMatch = 0;

    if (key.Open(fDefaultUser) != S_OK)
        return;

    uCount = 1;

    while(uCount < 1000)
    {
        HKL hklCur;
        hklCur = key.Get(uCount);
        if (!hklCur)
            break;

        if (hklCur == hkl)
        {
            uMatch++;
            uCount++;
            fReset = TRUE;
            continue;
        }

        if (fReset && uMatch)
        {
            if (uCount <= uMatch)
            {
                Assert(0);
                return;
            }

            //
            // reset the hkl orders from preload section
            //
            key.Set(uCount-uMatch, hklCur);
        }

        uCount++;
    }

    while (fReset && uMatch && uCount)
    {
        if  (uCount <= uMatch || (uCount - uMatch) <= 1)
        {
            Assert(0);
            return;
        }

        //
        // remove the dummy hkl from preload section
        //
        key.Delete(uCount - uMatch);

        uMatch--;
    }

    return;
}

//+---------------------------------------------------------------------------
//
// RemoveFEDummyHKLs
//
// This function cleans up the FE Dummy HKLs that were added on Win9x.
// This is called during update setup to Whistler.
//
//----------------------------------------------------------------------------

void RemoveFEDummyHKLs()
{
    CMyRegKey key;
    DWORD dwIndex;
    TCHAR szValue[MAX_PATH]; 

    //
    //  Now read all the locales from the registry.
    //
    if (key.Open(HKEY_LOCAL_MACHINE, c_szLayoutPath) != ERROR_SUCCESS)
    {
        return;
    }

    dwIndex = 0;
    szValue[0] = TEXT('\0');
    while (key.EnumKey(dwIndex, szValue, ARRAYSIZE(szValue)) == ERROR_SUCCESS)
    {
        BOOL fDelete = FALSE;
        CRegKeyMUI key1;

        if ((szValue[0] != 'e') && (szValue[0] != 'E'))
            goto Next;

        if (key1.Open(key, szValue) == S_OK)
        {
            TCHAR szValueLayoutText[MAX_PATH];

            //
            //  Get the layout text.
            //
            szValueLayoutText[0] = TEXT('\0');

            if (key1.QueryValueCch(szValueLayoutText, c_szLayoutText, ARRAYSIZE(szValueLayoutText)) == S_OK)
            {
                char szDummyProfile[256];
                DWORD dw = AsciiToNum(szValue);
                StringCchPrintf(szDummyProfile, ARRAYSIZE(szDummyProfile), "hkl%04x", LOWORD(dw));
                if (!lstrcmpi(szDummyProfile, szValueLayoutText))
                {
                    fDelete = TRUE;

                    //
                    // Remove dummy HKL from Preload of HKCU and HKU\.DEFAULT.
                    // We may need to enum all users in HKU\.DEFAULT. 
                    //
                    RemoveFEDummyHKLFromPreloadReg((HKL)LongToHandle(dw), TRUE);
                    RemoveFEDummyHKLFromPreloadReg((HKL)LongToHandle(dw), FALSE);
                }
            }

            key1.Close();
        }

        if (fDelete)
        {
            key.RecurseDeleteKey(szValue);
        }
        else
        {
Next:
            dwIndex++;
        }

        szValue[0] = TEXT('\0');
    } 

    return;
}

#endif LATER_TO_CHECK_DUMMYHKL
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\ctf\uim\imemenu.h ===
//
// imemenu.h
//

#ifndef TFEMENU_H
#define TFEMENU_H

typedef struct _tagMENULIST {
    struct _tagMENULIST * pPrev;
    struct _tagMENULIST * pNext;
    DWORD dwNum;
} MENULIST;
typedef MENULIST *PMENULIST;

typedef struct _tagMYMENUITEM {
    IMEMENUITEMINFO imii;
    int nMenuID;
    struct _tagMENULIST * pmlSubMenu;
} MYMENUITEM;
typedef MYMENUITEM *PMYMENUITEM;

class CWin32ImeMenu 
{
public:
    CWin32ImeMenu() {}
    ~CWin32ImeMenu()
    {
        DestroyIMEMenu();
    }

    BOOL GetIMEMenu(HWND hWnd, HIMC hIMC, BOOL fRight);
    BOOL BuildIMEMenu(HMENU hMenu, BOOL fRight);
    UINT GetIMEMenuItemID(int nMenuID);
    DWORD GetIMEMenuItemData(int nImeMenuID);

private:
    BOOL GetImeMenuProp();
    BOOL AddMenuList(PMENULIST pMenu);
    void DeleteMenuList(PMENULIST pMenu);
    void DeleteAllMenuList();
    PMENULIST AllocMenuList(DWORD dwNum);
    void SetMyMenuItem(HWND hWnd, HIMC hIMC, LPIMEMENUITEMINFO lpIme, BOOL fRight, PMYMENUITEM pMyMenuItem);
    PMENULIST CreateImeMenu(HWND hWnd, HIMC hIMC, LPIMEMENUITEMINFO lpImeParentMenu, BOOL fRight);
    void FillMenuItemInfo(LPMENUITEMINFO lpmii, PMYMENUITEM pMyMenuItem, BOOL fRight);
    int GetDefaultImeMenuItem();
    BOOL BuildIMEMenuItems(HMENU hMenu, PMENULIST pMenu, BOOL fRight);
    void DestroyIMEMenu();

    PMENULIST _pMenuHdr;       // Header of pMenuList
    int _nMenuList;            // number of pMenuList
    int _nMenuCnt;             // Sequence Number for TFE Menu Items
};

#endif // TFEMENU_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\ctf\uim\ithdmshl.h ===
//+---------------------------------------------------------------------------
//
//  File:       globals.h
//
//  Contents:   Global variable declarations.
//
//----------------------------------------------------------------------------

#ifndef ITHDMSHL_H
#define ITHDMSHL_H

#define MP_MARSHALINTERFACE              0
#define MP_UNMARSHALINTERFACEERROR       1

HRESULT GetThreadMarshalInterface(DWORD dwThreadId, DWORD dwType, REFIID riid, IUnknown **ppunk);
HRESULT GetThreadUIManager(DWORD dwThreadId, ITfLangBarItemMgr **pplbi, DWORD *pdwThreadId);
HRESULT GetInputProcessorProfiles(DWORD dwThreadId, ITfInputProcessorProfiles **ppaip, DWORD *pdwThreadId);
HRESULT ThreadMarshalInterfaceHandler(int nId);
HRESULT ThreadUnMarshalInterfaceErrorHandler(int nId);

#endif // ITHDMSHL_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\ctf\uim\ithdmshl.cpp ===
//
// ithdmshl.cpp
//
#include "private.h"
#include "globals.h"
#include "tim.h"
#include "immxutil.h"
#include "nuihkl.h"
#include "nuictrl.h"
#include "cicmutex.h"
#include "ithdmshl.h"
#include "marshal.h"
#include "mproxy.h"
#include "thdutil.h"

LRESULT MyMarshalInterface(REFIID riid, BOOL fSameThread, LPUNKNOWN punk);
HRESULT MyUnmarshalInterface(LRESULT ref, REFIID riid, BOOL fSameThread, void **ppvObject);

#define SZTHREADMIEVENT  __TEXT("CTF.ThreadMarshalInterfaceEvent.%08X.%08X.%08X")
#define SZTHREADMICEVENT  __TEXT("CTF.ThreadMIConnectionEvent.%08X.%08X.%08X")

#define MITYPE_LANGBARITEMMGR    1
#define MITYPE_TMQI              2

extern CCicMutex g_mutexTMD;

// --------------------------------------------------------------------------
//
//  GetTIMInterfaceFromTYPE
//
// --------------------------------------------------------------------------

HRESULT GetTIMInrterfaceFromTYPE(DWORD dwType, REFIID riid, void **ppv)
{
    HRESULT hr = E_FAIL;
    CThreadInputMgr *ptim;

    switch (dwType)
    {
        case MITYPE_LANGBARITEMMGR:
            hr = TF_CreateLangBarItemMgr((ITfLangBarItemMgr **)ppv);
            break;

        case MITYPE_TMQI:
            if ((ptim = CThreadInputMgr::_GetThis()) == NULL)
                break;

            hr = ptim->QueryInterface(riid, ppv);
            break;
    }

    return hr;
}

// --------------------------------------------------------------------------
//
//  FindTmd
//
// --------------------------------------------------------------------------

int FindTmd()
{
    int nId;
    BOOL fFound = FALSE;

    if (g_mutexTMD.Enter())
    {
        for (nId = 0; nId < NUM_TMD; nId++)
        {
            if (!(GetSharedMemory()->tmd[nId].m_fInUse))
            {
                GetSharedMemory()->tmd[nId].m_fInUse = TRUE;
                fFound = TRUE;
                break;
            }
        }
        Assert(fFound);
        g_mutexTMD.Leave();
    }

    return fFound ? nId : -1;
}

// --------------------------------------------------------------------------
//
//  GetThreadMarshallInterface()
//
// --------------------------------------------------------------------------

HRESULT GetThreadMarshalInterface(DWORD dwThreadId, DWORD dwType, REFIID riid, IUnknown **ppunk)
{
    DWORD dwCurThreadId  = GetCurrentThreadId();
    HRESULT hr = E_FAIL;
    int nId = -1;
    CCicEvent event;
    CCicEvent eventc;
    SYSTHREAD *psfn;
    ULONG ulMshlCnt;
    CThreadMarshalWnd tmw;
    BOOL fSendReceiveConnection = FALSE;

    *ppunk = NULL;

    if ((psfn = GetSYSTHREAD()) == NULL)
        return E_FAIL;

    CModalLoop modalloop(psfn);

    ulMshlCnt = psfn->ulMshlCnt++;

    if (!EnsureMarshalWnd())
        return E_FAIL;

    if (dwCurThreadId == dwThreadId)
    {
        return GetTIMInrterfaceFromTYPE(dwType, riid, (void **)ppunk);
    }

    nId = FindTmd();
    if (nId == -1)
        goto Exit;

    wsprintf(GetSharedMemory()->tmd[nId].m_szName, SZTHREADMIEVENT, dwCurThreadId, nId, ulMshlCnt);
    wsprintf(GetSharedMemory()->tmd[nId].m_szNameConnection, SZTHREADMICEVENT, dwCurThreadId, nId, ulMshlCnt);

    GetSharedMemory()->tmd[nId].m_iid = riid;
    GetSharedMemory()->tmd[nId].m_dwThreadId = dwThreadId;
    GetSharedMemory()->tmd[nId].m_dwSrcThreadId = dwCurThreadId;
    GetSharedMemory()->tmd[nId].m_dwType = dwType;
    GetSharedMemory()->tmd[nId].m_ref = E_FAIL;

    tmw.Init(dwThreadId);

    if (!event.Create(NULL, GetSharedMemory()->tmd[nId].m_szName))
    {
        hr = E_FAIL;
        goto Exit;
    }

    if (!eventc.Create(NULL, GetSharedMemory()->tmd[nId].m_szNameConnection))
    {
        hr = E_FAIL;
        goto Exit;
    }

    if (!tmw.PostMarshalThreadMessage(g_msgThreadMarshal, 
                                      MP_MARSHALINTERFACE, 
                                      (LPARAM)nId))
    {
        GetSharedMemory()->tmd[nId].m_ref = E_FAIL;
        goto SkipWaiting;
    }

    if (GetSharedMemory()->tmd[nId].m_fInUse)
    {
        CCicTimer timer(10000);
        DWORD dwWaitFlags = QS_DEFAULTWAITFLAG;
        while (!timer.IsTimerAtZero())
        {
            if (!fSendReceiveConnection &&
                 timer.IsTimerPass(DEFAULTMARSHALCONNECTIONTIMEOUT))
            { 
                DWORD dwReason = eventc.EventCheck();
                if (dwReason != WAIT_OBJECT_0)
                {
                    hr = E_FAIL;
                    break;
                }
                fSendReceiveConnection = TRUE;
            }

            hr = modalloop.BlockFn(&event, dwThreadId, dwWaitFlags);
       
            if (hr == S_OK)
                goto SkipWaiting;

            if (FAILED(hr))
                break;
        }

        TraceMsg(TF_GENERAL, "ThreadMarshal Time Out");
        goto Exit;
    }

SkipWaiting:
    if (FAILED(GetSharedMemory()->tmd[nId].m_ref))
        goto Exit;

    hr = CicCoUnmarshalInterface(GetSharedMemory()->tmd[nId].m_iid, 
                                 dwThreadId, 
                                 GetSharedMemory()->tmd[nId].m_ulStubId, 
                                 GetSharedMemory()->tmd[nId].m_dwStubTime, 
                                 (void **)ppunk);

Exit:
    if (nId != -1)
        GetSharedMemory()->tmd[nId].m_fInUse = FALSE;

    return hr;
}


// --------------------------------------------------------------------------
//
//  ThreadMarshallInterfaceHandler()
//
// --------------------------------------------------------------------------

HRESULT ThreadMarshalInterfaceHandler(int nId)
{
    HRESULT hr;
    IUnknown *punk;

    if ((nId < 0) || (nId >= NUM_TMD))
        return E_FAIL;

    CCicEvent eventc;
    if (eventc.Open(GetSharedMemory()->tmd[nId].m_szNameConnection))
        eventc.Set();

    EnsureMarshalWnd();

    hr = GetTIMInrterfaceFromTYPE(GetSharedMemory()->tmd[nId].m_dwType, 
                                  GetSharedMemory()->tmd[nId].m_iid, (void **)&punk);
    if (FAILED(hr))
        goto Exit;

    hr = CicCoMarshalInterface(GetSharedMemory()->tmd[nId].m_iid, 
                               punk, 
                               &GetSharedMemory()->tmd[nId].m_ulStubId, 
                               &GetSharedMemory()->tmd[nId].m_dwStubTime,
                               GetSharedMemory()->tmd[nId].m_dwSrcThreadId);

    GetSharedMemory()->tmd[nId].m_ref = hr;

    punk->Release();
 
Exit:
    CCicEvent event;
    if (event.Open(GetSharedMemory()->tmd[nId].m_szName))
        event.Set();

    return hr;
}

// --------------------------------------------------------------------------
//
//  GetThreadUIManager
//
// --------------------------------------------------------------------------

HRESULT GetThreadUIManager(DWORD dwThreadId, ITfLangBarItemMgr **pplbi, DWORD *pdwThreadId)
{
    if (!dwThreadId)
        dwThreadId = GetSharedMemory()->dwFocusThread;

    if (pdwThreadId)
        *pdwThreadId = dwThreadId;

    return GetThreadMarshalInterface(dwThreadId, 
                                        MITYPE_LANGBARITEMMGR, 
                                        IID_ITfLangBarItemMgr,
                                        (IUnknown **)pplbi);
}

// --------------------------------------------------------------------------
//
//  GetActivateInputProcessor
//
// --------------------------------------------------------------------------

HRESULT GetInputProcessorProfiles(DWORD dwThreadId, ITfInputProcessorProfiles **ppaip, DWORD *pdwThreadId)
{
    if (!dwThreadId)
        dwThreadId = GetSharedMemory()->dwFocusThread;

    if (pdwThreadId)
        *pdwThreadId = dwThreadId;

    return GetThreadMarshalInterface(dwThreadId, 
                                        MITYPE_TMQI, 
                                        IID_ITfInputProcessorProfiles,
                                        (IUnknown **)ppaip);
}

// --------------------------------------------------------------------------
//
//  ThreadUnMarshallInterfaceErrorHandler()
//
// --------------------------------------------------------------------------

HRESULT ThreadUnMarshalInterfaceErrorHandler(int nId)
{
    HRESULT hr;
    IUnknown *punk;

    hr = CicCoUnmarshalInterface(GetSharedMemory()->tmd[nId].m_iid, 
                                 GetSharedMemory()->tmd[nId].m_dwThreadId, 
                                 GetSharedMemory()->tmd[nId].m_ulStubId, 
                                 GetSharedMemory()->tmd[nId].m_dwStubTime, 
                                 (void **)&punk);
    if (SUCCEEDED(hr))
         punk->Release();
 
    GetSharedMemory()->tmd[nId].m_fInUse = FALSE;
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\ctf\uim\internat.h ===
//
// internat.h
//

#ifndef INTERNAT_H
#define INTERNAT_H

#include "private.h"
#include "commctrl.h"
#include "regsvr.h"
#include "inatlib.h"
#include "cregkey.h"

void UninitINAT();

//-----------------------------------------------------------------------------
//
// INTERNAT Icon APIs
//
//-----------------------------------------------------------------------------

//
//  For Keyboard Layout info. NT4
//
typedef struct
{
    DWORD dwID;                     // numeric id
    UINT iSpecialID;                // i.e. 0xf001 for dvorak etc
    WCHAR wszText[64];

} LAYOUT, *LPLAYOUT;

typedef struct 
{
    UINT idx ;
    char chars[4];
} INATSYMBOL;


int GetLocaleInfoString(LCID lcid, LCTYPE lcType, char *psz, int cch);
ULONG GetLocaleInfoString(HKL hKL, WCHAR *pszRegText, int nSize);
int GetHKLDesctription(HKL hKL, WCHAR *pszDesc, int cchDesc, WCHAR *pszIMEFile, int cchIMEFile);
HICON InatCreateIcon(WORD langID );
HICON InatCreateIconBySize(WORD langID, int cxSmIcon, int cySmIcon, LOGFONT *plf);
HICON GetIconFromFile(int cx, int cy, WCHAR *lpszFileName, UINT uIconIndex);
HICON GetIconFromFileA(int cx, int cy, char *lpszFileName, UINT uIconIndex);

//-----------------------------------------------------------------------------
//
// MLNGINFO APIs
//
//-----------------------------------------------------------------------------

typedef struct
{
    HKL         hKL;
    BOOL        fInitDesc;
    BOOL        fInitIcon;

    void SetDesc(WCHAR *psz)
    {
        StringCchCopyW(szDesc, ARRAYSIZE(szDesc), psz);
    }

    WCHAR *GetDesc()
    {
        if (!fInitDesc)
            InitDesc();

        return szDesc;
    }

    int GetIconIndex()
    {
        if (!fInitIcon)
            InitIcon();

        return nIconIndex;
    }

    void ClearIconIndex()
    {
        fInitIcon = FALSE;
        nIconIndex = -1;
    }

    void InitDesc();
    void InitIcon();

private:
    int      nIconIndex;
    WCHAR    szDesc[128];
} MLNGINFO;

HIMAGELIST GetMlngImageList();
BOOL GetMlngInfo(int n, MLNGINFO *pmlInfo);
int GetMlngInfoByhKL(HKL hKL, MLNGINFO *pmlInfo);
void ClearMlngIconIndex();

//-----------------------------------------------------------------------------
//
// IconList APIs
//
//-----------------------------------------------------------------------------

BOOL EnsureIconImageList();
UINT InatAddIcon(HICON hIcon);
BOOL InatGetIconSize(int *pcx, int *pcy);
BOOL InatGetImageCount();
void InatRemoveAll();


//-----------------------------------------------------------------------------
//
// HKLAPIs
//
//-----------------------------------------------------------------------------

HKL GetSystemDefaultHKL();
BOOL SetSystemDefaultHKL(HKL hKL);
UINT GetPreloadListForNT(DWORD *pdw, UINT uBufSize);
DWORD GetSubstitute(HKL hKL);

#ifdef LATER_TO_CHECK_DUMMYHKL
void RemoveFEDummyHKLFromPreloadReg(HKL hkl, BOOL fDefaultUser);
void RemoveFEDummyHKLs();
#endif LATER_TO_CHECK_DUMMYHKL


/////////////////////////////////////////////////////////////////////////////
// 
// CRegUIName
// 
/////////////////////////////////////////////////////////////////////////////

class CRegKeyMUI : public CMyRegKey
{
public:
    LONG QueryValueCch(LPTSTR szValue, LPCTSTR lpszValueName, ULONG cchValue)
    {
        LONG lRes;
        LPTSTR lpValue;
        DWORD index;
        WCHAR szTmpW[MAX_PATH];

        lRes = CMyRegKey::QueryValueCch(szValue, lpszValueName, cchValue);

        if (lRes != S_OK || szValue[0] != '@')
            return lRes;

        lpValue = szValue;
        index = 0;

        while (*lpValue != '\0' && index < cchValue)
        {
            if (*lpValue == ',')
            {
                lRes = SHLoadRegUIStringW(m_hKey, AtoW(lpszValueName), szTmpW, ARRAYSIZE(szTmpW));
                StringCchCopy(szValue, cchValue, WtoA(szTmpW, ARRAYSIZE(szTmpW)));
                break;
            }

            lpValue++;
            index++;
        }

        return lRes;
    }

    LONG QueryValueCchW(WCHAR *szValue, const WCHAR *lpszValueName, ULONG cchValue)
    {
        LONG lRes;
        LPWSTR lpValue;
        DWORD index;

        lRes = CMyRegKey::QueryValueCchW(szValue, lpszValueName, cchValue);

        if (lRes != S_OK || szValue[0] != L'@')
            return lRes;
        
        lpValue = szValue;
        index = 0;

        while (*lpValue && index < cchValue)
        {
            if (*lpValue == L',')
            {
                lRes = SHLoadRegUIStringW(m_hKey, lpszValueName, szValue, cchValue);
                break;
            }

            lpValue++;
            index++;
        }

        return lRes;
    }

    LONG QueryMUIValueW(WCHAR *szValue, const WCHAR *lpszValueName, const WCHAR *lpszMUIName, ULONG cchValue)
    {
        LONG lRes;

        lRes = SHLoadRegUIStringW(m_hKey, lpszMUIName, szValue, cchValue);

        if (lRes == S_OK)
        {
            return lRes;
        }
        else
        {
            return CMyRegKey::QueryValueCchW(szValue, lpszValueName, cchValue);
        }
    }
};


#endif //  INTERNAT_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\ctf\uim\lbaddin.h ===
//
// lbaddin.h
//

#ifndef LBADDIN_H
#define LBADDIN_H


BOOL ClearLangBarAddIns(SYSTHREAD *psfn, REFCLSID rclsid);
void InitLangBarAddInArray();
BOOL LoadLangBarAddIns(SYSTHREAD *psfn);
void UpdateLangBarAddIns();
void UninitLangBarAddIns(SYSTHREAD *psfn);


#endif LBADDIN_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\ctf\uim\ksmgr.cpp ===
//
// ksmgr.cpp
//

#include "private.h"
#include "dim.h"
#include "tim.h"
#include "ic.h"
#include "computil.h"

//////////////////////////////////////////////////////////////////////////////
//
// CAsyncProcessKeyQueueItem
//
//////////////////////////////////////////////////////////////////////////////

class CAsyncProcessKeyQueueItem : public CAsyncQueueItem
{
public:
    CAsyncProcessKeyQueueItem(WPARAM wParam, LPARAM lParam, DWORD dwFlags, BOOL *pfEaten) : CAsyncQueueItem(dwFlags & TIM_AKH_SYNC ? TRUE : FALSE)
    {
        _wParam = wParam;
        _lParam = lParam;
        if ((dwFlags & TIM_AKH_SYNC) && pfEaten)
            _pfEaten = pfEaten;
        else
        {
            if (pfEaten)
                *pfEaten = TRUE;

            _pfEaten = &_fEaten;
        }

        _dwFlags = dwFlags;
    }

    HRESULT DoDispatch(CInputContext *pic)
    {
        CThreadInputMgr *ptim = CThreadInputMgr::_GetThis();
        if (!ptim)
        {
            Assert(0);
            return E_FAIL;
        }

        if (HIWORD(_lParam) & KF_UP)
        {
            ptim->TestKeyUp(_wParam, _lParam, _pfEaten);
            if (*_pfEaten && !(_dwFlags & TIM_AKH_TESTONLY))
                ptim->KeyUp(_wParam, _lParam, _pfEaten);
        }
        else
        {
            ptim->TestKeyDown(_wParam, _lParam, _pfEaten);
            if (*_pfEaten && !(_dwFlags & TIM_AKH_TESTONLY))
                ptim->KeyDown(_wParam, _lParam, _pfEaten);
        }

        //
        // We needs to simulate keydown message because
        // we might return *pfEaten = TRUE;
        //    When it is async,
        //    When it was not eaten by keystroke mgr.
        //    When it has TIM_AKH_SIMULATEKEYMSG
        //
        if (!(_dwFlags & TIM_AKH_SYNC) &&
            !*_pfEaten && 
            (_dwFlags & TIM_AKH_SIMULATEKEYMSGS))
        {
            UINT uMsg = WM_KEYDOWN;

            // key up msg?
            if (HIWORD(_lParam) & KF_UP)
                uMsg++;

            // sys key msg?
            if (HIWORD(_lParam) & (KF_MENUMODE | KF_ALTDOWN))
                uMsg |= 0x04;

            PostMessage(GetFocus(), uMsg, _wParam, _lParam);
        }

        return S_OK;
    }

private:
    WPARAM _wParam;
    LPARAM _lParam;
    BOOL *_pfEaten;
    BOOL _fEaten;
    BOOL _dwFlags;
};

//+---------------------------------------------------------------------------
//
// _AsyncKeyHandler
//
//----------------------------------------------------------------------------

BOOL CThreadInputMgr::_AsyncKeyHandler(WPARAM wParam, LPARAM lParam, DWORD dwFlags, BOOL *pfEaten)
{
    CAsyncProcessKeyQueueItem *pAsyncProcessKeyQueueItem;
    BOOL bRet;
    HRESULT hr;

    if (!_pFocusDocInputMgr)
        return FALSE;

    if (_pFocusDocInputMgr->_GetCurrentStack() < 0)
        return FALSE;

    //
    // Issue:
    //
    // We don't know which IC in the focus DIM will handle the hotkey yet.
    // because the selection is changed by the application so we need to get ec
    // to update the current selection pos. We do call GetSelection
    // inside the root IC's lock. So it might be failed if hotkey's target
    // is TOP IC.
    //
    CInputContext *pic = _pFocusDocInputMgr->_GetIC(0);

    pAsyncProcessKeyQueueItem = new CAsyncProcessKeyQueueItem(wParam, lParam, dwFlags, pfEaten);
    if (!pAsyncProcessKeyQueueItem)
        return FALSE;
    
    hr = S_OK;

    bRet = TRUE;
    if ((pic->_QueueItem(pAsyncProcessKeyQueueItem->GetItem(), FALSE, &hr) != S_OK) || FAILED(hr))
    {
        Assert(0);
        bRet = FALSE;
    }

    pAsyncProcessKeyQueueItem->_Release();
    return bRet;
}

//+---------------------------------------------------------------------------
//
// AdviseSink
//
//----------------------------------------------------------------------------

STDAPI CThreadInputMgr::AdviseKeyEventSink(TfClientId tid, ITfKeyEventSink *pSink, BOOL fForeground)
{
    CTip *ctip;

    if (!_GetCTipfromGUIDATOM(tid, &ctip))
        return E_INVALIDARG;

    if (ctip->_pKeyEventSink != NULL)
        return CONNECT_E_ADVISELIMIT;

    ctip->_pKeyEventSink = pSink;
    ctip->_pKeyEventSink->AddRef();
    ctip->_fForegroundKeyEventSink = fForeground;

    //
    // overwrite the foreground tip.
    //
    if (fForeground)
        _SetForeground(tid);

    return S_OK;
}

//+---------------------------------------------------------------------------
//
// UnadviseSink
//
//----------------------------------------------------------------------------

STDAPI CThreadInputMgr::UnadviseKeyEventSink(TfClientId tid)
{
    CTip *ctip;

    if (!_GetCTipfromGUIDATOM(tid, &ctip))
        return E_INVALIDARG;

    if (ctip->_pKeyEventSink == NULL)
        return CONNECT_E_NOCONNECTION;

    SafeReleaseClear(ctip->_pKeyEventSink);

    if (_tidForeground == tid)
    {
        _SetForeground(TF_INVALID_GUIDATOM);
    }

    return S_OK;
}


//+---------------------------------------------------------------------------
//
// GetForeground
//
//----------------------------------------------------------------------------

STDAPI CThreadInputMgr::GetForeground(CLSID *pclsid)
{
    if (!pclsid)
        return E_INVALIDARG;

    *pclsid = GUID_NULL;

    if (_tidForeground == TF_INVALID_GUIDATOM)
        return S_FALSE;

    return MyGetGUID(_tidForeground, pclsid);
}

//+---------------------------------------------------------------------------
//
// SetForeground
//
//----------------------------------------------------------------------------

HRESULT CThreadInputMgr::_SetForeground(TfClientId tid)
{
    HRESULT hr;
    CTip *ctip;
    CTip *ctipForeground;

    ctip = NULL;

    if (tid != TF_INVALID_GUIDATOM)
    {
        _GetCTipfromGUIDATOM(tid, &ctip);
    }

    if (ctip)
    {
        if (ctip->_pKeyEventSink == NULL || !ctip->_fForegroundKeyEventSink)
        {
            hr = E_INVALIDARG;
            goto Exit;
        }
    }
             
    hr = S_OK;

    if (_tidForeground != TF_INVALID_GUIDATOM)
    {
        if (_tidForeground == tid)
            goto Exit;

        _GetCTipfromGUIDATOM(_tidForeground, &ctipForeground);
        Assert(ctipForeground != NULL);

        if (ctipForeground->_pKeyEventSink != NULL) // might be NULL if we got here from ITfKeyEventMgr::Unadvise
        {
            ctipForeground->_pKeyEventSink->OnSetFocus(FALSE);
        }

        _tidForeground = 0;
    }

    if (ctip != NULL)
    {
        if (ctip->_pKeyEventSink == NULL || !ctip->_fForegroundKeyEventSink)
        {
            // highly unlikely, but the tip Unadvise'd when we called OnSetFocus(FALSE) on the old foreground tip
            hr = E_FAIL;
            goto Exit;
        }

        _tidForeground = tid;

        ctip->_pKeyEventSink->OnSetFocus(TRUE);
    }

Exit:
    return hr;
}

//+---------------------------------------------------------------------------
//
// TestKeyDown
//
//----------------------------------------------------------------------------

HRESULT CThreadInputMgr::TestKeyDown(WPARAM wParam, LPARAM lParam, BOOL *pfEaten)
{
    HRESULT hr;

    Perf_StartStroke(PERF_STROKE_TESTDOWN);

    hr = _KeyStroke(KS_DOWN_TEST, wParam, lParam, pfEaten, TRUE, 0);

    Perf_EndStroke(PERF_STROKE_TESTDOWN);

    return hr;
}

//+---------------------------------------------------------------------------
//
// KeyDown
//
//----------------------------------------------------------------------------

HRESULT CThreadInputMgr::KeyDown(WPARAM wParam, LPARAM lParam, BOOL *pfEaten)
{
    HRESULT hr;

    Perf_IncCounter(PERF_KEYDOWN_COUNT);
    Perf_StartStroke(PERF_STROKE_DOWN);

    hr = _KeyStroke(KS_DOWN, wParam, lParam, pfEaten, TRUE, 0);

    Perf_EndStroke(PERF_STROKE_DOWN);

    return hr;
}

//+---------------------------------------------------------------------------
//
// TestKeyUp
//
//----------------------------------------------------------------------------

HRESULT CThreadInputMgr::TestKeyUp(WPARAM wParam, LPARAM lParam, BOOL *pfEaten)
{
    HRESULT hr;

    Perf_StartStroke(PERF_STROKE_TESTUP);

    hr = _KeyStroke(KS_UP_TEST, wParam, lParam, pfEaten, TRUE, 0);

    Perf_EndStroke(PERF_STROKE_TESTUP);

    return hr;
}

//+---------------------------------------------------------------------------
//
// KeyUp
//
//----------------------------------------------------------------------------

HRESULT CThreadInputMgr::KeyUp(WPARAM wParam, LPARAM lParam, BOOL *pfEaten)
{
    HRESULT hr;

    Perf_StartStroke(PERF_STROKE_UP);

    hr = _KeyStroke(KS_UP, wParam, lParam, pfEaten, TRUE, 0);

    Perf_EndStroke(PERF_STROKE_UP);

    return hr;
}

//+---------------------------------------------------------------------------
//
// KeyDownUpEx
//
//----------------------------------------------------------------------------

HRESULT CThreadInputMgr::KeyDownUpEx(WPARAM wParam, LPARAM lParam, DWORD dwFlags, BOOL *pfEaten)
{
    HRESULT hr;

    if (HIWORD(lParam) & KF_UP)
    {
        if (dwFlags & TF_KEY_TEST)
        {
            Perf_StartStroke(PERF_STROKE_TESTUP);
            hr = _KeyStroke(KS_UP_TEST, wParam, lParam, pfEaten, TRUE, dwFlags);
            Perf_EndStroke(PERF_STROKE_TESTUP);
        }
        else
        {
            Perf_StartStroke(PERF_STROKE_UP);
            hr = _KeyStroke(KS_UP, wParam, lParam, pfEaten, TRUE, dwFlags);
            Perf_EndStroke(PERF_STROKE_UP);
        }
    }
    else
    {
        if (dwFlags & TF_KEY_TEST)
        {
            Perf_StartStroke(PERF_STROKE_TESTDOWN);
            hr = _KeyStroke(KS_DOWN_TEST, wParam, lParam, pfEaten, TRUE, dwFlags);
            Perf_EndStroke(PERF_STROKE_TESTDOWN);
        }
        else
        {
            Perf_IncCounter(PERF_KEYDOWN_COUNT);
            Perf_StartStroke(PERF_STROKE_DOWN);
            hr = _KeyStroke(KS_DOWN, wParam, lParam, pfEaten, TRUE, dwFlags);
            Perf_EndStroke(PERF_STROKE_DOWN);
        }
    }

    return hr;
}

//+---------------------------------------------------------------------------
//
// KeyStroke
//
//----------------------------------------------------------------------------

HRESULT CThreadInputMgr::_KeyStroke(KSEnum ksenum, WPARAM wParam, LPARAM lParam, BOOL *pfEaten, BOOL fSync, DWORD dwFlags)
{
    CInputContext *pic;
    int iStack;
    HRESULT hr;
    ITfDocumentMgr *pdim;
    int i;

    if (pfEaten == NULL)
        return E_INVALIDARG;

    hr = S_OK;
    *pfEaten = FALSE;

    if (_pFocusDocInputMgr == NULL) // no focus ic?
    {
        return S_OK;
    }

    pdim = _GetFocusDocInputMgr();

    if (!(dwFlags & TF_KEY_INTERNAL))
    {
        if (!(dwFlags & TF_KEY_MSCTFIME) && (pdim && _IsMsctfimeDim(pdim)))
        {
            return S_OK;
        }
    }

    if (_CheckPreservedKey(ksenum, wParam, lParam, fSync))
    {
        *pfEaten = TRUE;
        return S_OK;
    }

    iStack = _pFocusDocInputMgr->_GetCurrentStack();

    if (iStack < 0)
        goto Exit;

    while (iStack >= 0)
    {
        pic = _pFocusDocInputMgr->_GetIC(iStack);

        pic->_UpdateKeyEventFilter();

        // try left/right side of the selection.
        for (i=LEFT_FILTERTIP; i<=RIGHT_FILTERTIP; i++)
        {
            hr = _CallKeyEventSinkNotForeground(pic->_gaKeyEventFilterTIP[i], 
                                                pic, ksenum, wParam, lParam, pfEaten);

            if (hr == S_OK && *pfEaten)
                goto Exit;

            // _CallKeyEventSinkNotForeground returns "error" codes on valid input
            // this just means, keep going
            hr = S_OK; // keep trying other sinks if there's an error
            *pfEaten = FALSE;

            if (_pFocusDocInputMgr->_GetCurrentStack() < iStack)
                goto NextIC;
        }

        // try foreground tip.
        if (_tidForeground != TF_INVALID_GUIDATOM)
        {
            hr = _CallKeyEventSink(_tidForeground, 
                                   pic, ksenum, wParam, lParam, pfEaten);

            if (hr == S_OK && *pfEaten)
                break;

            hr = S_OK; // keep trying other sinks if there's an error
            *pfEaten = FALSE;

            if (_pFocusDocInputMgr == NULL)
            {
                // this can happen if the app is buggy and switches the focus
                // inside a SetText or whatever call (perhaps to bring up an
                // error dialog, etc.).
                hr = E_UNEXPECTED;
                goto Exit;
            }

            if (_pFocusDocInputMgr->_GetCurrentStack() < iStack)
               goto NextIC;
        }

        if (pic->_pICKbdSink)
        {
            switch (ksenum)
            {
                case KS_DOWN:
                    hr = pic->_pICKbdSink->OnKeyDown(wParam, lParam, pfEaten);
                    break;
                case KS_UP:
                    hr = pic->_pICKbdSink->OnKeyUp(wParam, lParam, pfEaten);
                    break;
                case KS_DOWN_TEST:
                    hr = pic->_pICKbdSink->OnTestKeyDown(wParam, lParam, pfEaten);
                    break;
                case KS_UP_TEST:
                    hr = pic->_pICKbdSink->OnTestKeyUp(wParam, lParam, pfEaten);
                    break;
            }

            if (hr == S_OK && *pfEaten)
                break;

            hr = S_OK; // keep trying other sinks if there's an error
            *pfEaten = FALSE;
        }

NextIC:
        iStack--;
        if (_pFocusDocInputMgr->_GetCurrentStack() < iStack)
        {
            iStack  = _pFocusDocInputMgr->_GetCurrentStack();
        }
    }

Exit:
    return hr;
}

//+---------------------------------------------------------------------------
//
// CallKeyEventSinkNotForeground
//
//----------------------------------------------------------------------------
HRESULT CThreadInputMgr::_CallKeyEventSinkNotForeground(TfClientId tid, CInputContext *pic, KSEnum ksenum, WPARAM wParam, LPARAM lParam, BOOL *pfEaten)
{
    CTip *ctip;

    if (tid == _tidForeground)
        return E_INVALIDARG;

    if (!_GetCTipfromGUIDATOM(tid, &ctip))
        return E_INVALIDARG;

    if (ctip->_fForegroundKeyEventSink ||
        ctip->_pKeyEventSink == NULL)
    {
        return E_INVALIDARG;
    }

    return _CallKeyEventSink(tid, pic, ksenum, wParam, lParam, pfEaten);
}

//+---------------------------------------------------------------------------
//
// CallKeyEventSink
//
//----------------------------------------------------------------------------


HRESULT CThreadInputMgr::_CallKeyEventSink(TfClientId tid, CInputContext *pic, KSEnum ksenum, WPARAM wParam, LPARAM lParam, BOOL *pfEaten)
{
    ITfKeyEventSink *pSink;
    CTip *ctip;
    HRESULT hr;

    if (!_GetCTipfromGUIDATOM(tid, &ctip))
        return E_INVALIDARG;

    if (!(pSink = ctip->_pKeyEventSink))
        return S_FALSE;

    switch (ksenum)
    {
        case KS_DOWN:
            hr = pSink->OnKeyDown(pic, wParam, lParam, pfEaten);
            break;
        case KS_DOWN_TEST:
            hr = pSink->OnTestKeyDown(pic, wParam, lParam, pfEaten);
            break;
        case KS_UP:
            hr = pSink->OnKeyUp(pic, wParam, lParam, pfEaten);
            break;
        case KS_UP_TEST:
            hr = pSink->OnTestKeyUp(pic, wParam, lParam, pfEaten);
            break;
        default:
            Assert(0);
            hr = E_FAIL;
            break;
    }

    return hr;
}

//+---------------------------------------------------------------------------
//
// CheckPreservedKey
//
//----------------------------------------------------------------------------

BOOL CThreadInputMgr::_CheckPreservedKey(KSEnum ksenum, WPARAM wParam, LPARAM lParam, BOOL fSync)
{
    BOOL bRet = FALSE;
    switch (ksenum)
    {
        case KS_DOWN:
            if (!(lParam & 0x80000000))
                bRet = _ProcessHotKey(wParam, lParam, TSH_NONSYSHOTKEY, FALSE, fSync);
            break;
        case KS_DOWN_TEST:
            if (!(lParam & 0x80000000))
                bRet = _ProcessHotKey(wParam, lParam, TSH_NONSYSHOTKEY, TRUE, fSync);
            break;
        case KS_UP:
            if (lParam & 0x80000000)
                bRet = _ProcessHotKey(wParam, lParam, TSH_NONSYSHOTKEY, FALSE, fSync);
            break;
        case KS_UP_TEST:
            if (lParam & 0x80000000)
                bRet = _ProcessHotKey(wParam, lParam, TSH_NONSYSHOTKEY, TRUE, fSync);
            break;
        default:
            Assert(0);
            break;
    }

    return bRet;
}


//+---------------------------------------------------------------------------
//
// _NotifyKeyTraceEventSink
//
//----------------------------------------------------------------------------

void CThreadInputMgr::_NotifyKeyTraceEventSink(WPARAM wParam, LPARAM lParam)
{
    CStructArray<GENERICSINK> *rgKeyTraceEventSinks;
    int i;

    rgKeyTraceEventSinks = _GetKeyTraceEventSinks();

    for (i=0; i<rgKeyTraceEventSinks->Count(); i++)
    {
        if (lParam & 0x80000000)
            ((ITfKeyTraceEventSink *)rgKeyTraceEventSinks->GetPtr(i)->pSink)->OnKeyTraceUp(wParam, lParam);
        else
            ((ITfKeyTraceEventSink *)rgKeyTraceEventSinks->GetPtr(i)->pSink)->OnKeyTraceDown(wParam, lParam);
    }
}


//+---------------------------------------------------------------------------
//
// _IsMsctfimeDim
//
//----------------------------------------------------------------------------

BOOL CThreadInputMgr::_IsMsctfimeDim(ITfDocumentMgr *pdim)
{
    // Get GUID_COMPARTMENT_CTFIME_DIMFLAGS from ..\msctfime\globals.cpp
    const GUID GUID_COMPARTMENT_CTFIME_DIMFLAGS = {0xa94c5fd2, 0xc471, 0x4031, {0x95, 0x46, 0x70, 0x9c, 0x17, 0x30, 0x0c, 0xb9}};

    HRESULT hr;
    DWORD dwFlags;

    hr = GetCompartmentDWORD(pdim, GUID_COMPARTMENT_CTFIME_DIMFLAGS,
                             &dwFlags, FALSE);
                
    if (SUCCEEDED(hr))
    {
        // Check COMPDIMFLAG_OWNEDDIM(0x0001).
        return (dwFlags & 0x0001) ? TRUE : FALSE;
    }

    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\ctf\uim\marshal.h ===
//
// marshal.h
//

#ifndef MARSHAL_H
#define MARSHAL_H

#include "private.h"
#include "globals.h"
#include "cicmutex.h"
#include "winuserp.h"
#include "systhrd.h"
#include "smblock.h"
#include "cregkey.h"

#define DEFAULTMARSHALTIMEOUT 30000
#define DEFAULTMARSHALCONNECTIONTIMEOUT 2000


#ifdef QS_RAWINPUT
#define QS_ALLINPUT400  (QS_ALLINPUT & ~QS_RAWINPUT)
#else
#define QS_ALLINPUT400  (QS_ALLINPUT)
#endif
#define QS_DEFAULTWAITFLAG (QS_ALLINPUT400 | QS_TRANSFER | QS_ALLPOSTMESSAGE)

#ifdef DEBUG
extern ULONG g_ulMarshalTimeOut;
#define MARSHALTIMEOUT g_ulMarshalTimeOut


const TCHAR c_szMarshal[] = TEXT("SOFTWARE\\Microsoft\\CTF\\Marshal\\");
const TCHAR c_szTimeOut[] = TEXT("TimeOut");
__inline void dbg_InitMarshalTimeOut()
{
    CMyRegKey key;
    DWORD dw;

    if (key.Open(HKEY_CURRENT_USER, c_szMarshal, KEY_READ) != S_OK)
       return;

    if (key.QueryValue(dw, c_szTimeOut) != S_OK)
       return;

    g_ulMarshalTimeOut = (ULONG)dw;
}

#else
#define MARSHALTIMEOUT DEFAULTMARSHALTIMEOUT
#define dbg_InitMarshalTimeOut()
#endif

#define SZMARSHALINTERFACEFILEMAP __TEXT("MSCTF.MarshalInterface.FileMap.")
#define SZRPCSENDRECEIVEEVENT     __TEXT("MSCTF.SendReceive.Event.")
#define SZRPCSENDRECEIVECONNECTIONEVENT     __TEXT("MSCTF.SendReceiveConection.Event.")

HRESULT CicCoMarshalInterface(REFIID riid, IUnknown *punk, ULONG *pulStubId, DWORD *pdwStubTime, DWORD dwSrcThreadId);
HRESULT CicCoUnmarshalInterface(REFIID riid, DWORD dwStubThreadId, ULONG ulStubId, DWORD dwStubTIme, void **ppv);
void HandleSendReceiveMsg(DWORD dwSrcThreadId, ULONG ulCnt);

void FreeMarshaledStubs(SYSTHREAD *psfn);
void FreeMarshaledStubsForThread(SYSTHREAD *psfn, DWORD dwThread);
void StubCleanUp(ULONG ulStubId);

//////////////////////////////////////////////////////////////////////////////
//
// MARSHALINTERFACE structure
//
//////////////////////////////////////////////////////////////////////////////

typedef struct tag_MARSHALINTERFACE 
{
    IID       iid;
    DWORD     dwStubTime;
} MARSHALINTERFACE;

//////////////////////////////////////////////////////////////////////////////
//
// MARSHALPARAM structure
//
//////////////////////////////////////////////////////////////////////////////

#define MPARAM_IN               0x000000001
#define MPARAM_OUT              0x000000002
#define MPARAM_INTERFACE        0x000010000
#define MPARAM_POINTER          0x000020000
#define MPARAM_ULONG            0x000040000
#define MPARAM_BSTR             0x000080000
#define MPARAM_STRUCT           0x000100000
#define MPARAM_HBITMAP          0x000200000
#define MPARAM_TF_LBBALLOONINFO      0x000400000
#define MPARAM_HICON            0x000800000

#define MPARAM_IN_POINTER         (MPARAM_IN | MPARAM_POINTER)
#define MPARAM_IN_INTERFACE       (MPARAM_IN | MPARAM_INTERFACE)
#define MPARAM_IN_ULONG           (MPARAM_IN | MPARAM_ULONG)
#define MPARAM_IN_STRUCT          (MPARAM_IN | MPARAM_STRUCT)
#define MPARAM_IN_HBITMAP         (MPARAM_IN | MPARAM_HBITMAP)
#define MPARAM_IN_HICON           (MPARAM_IN | MPARAM_HICON)

#define MPARAM_OUT_POINTER        (MPARAM_OUT | MPARAM_POINTER)
#define MPARAM_OUT_INTERFACE      (MPARAM_OUT | MPARAM_INTERFACE)
#define MPARAM_OUT_BSTR           (MPARAM_OUT | MPARAM_BSTR)
#define MPARAM_OUT_HBITMAP        (MPARAM_OUT | MPARAM_HBITMAP)
#define MPARAM_OUT_TF_LBBALLOONINFO    (MPARAM_OUT | MPARAM_TF_LBBALLOONINFO)
#define MPARAM_OUT_HICON          (MPARAM_OUT | MPARAM_HICON)

#define MPARAM_IN_OUT_INTERFACE   (MPARAM_IN | MPARAM_OUT | MPARAM_INTERFACE)

typedef struct tag_MARSHALPARAM 
{
    ULONG     cbBufSize;
    DWORD     dwFlags;
    // DWORD     buf[1];
} MARSHALPARAM;

typedef struct tag_MARSHALMSG
{
    ULONG        cbSize;
    ULONG        cbBufSize;
    IID          iid;
    ULONG        ulMethodId;
    ULONG        ulParamNum;
    union {
        HRESULT      hrRet;
        ULONG        ulRet;
    };
    DWORD        dwSrcThreadId;
    DWORD        dwSrcProcessId;
    ULONG        ulStubId;
    DWORD        dwStubTime;
    HRESULT      hrMarshalOutParam;
    ULONG        ulParamOffset[1];
} MARSHALMSG;

__inline MARSHALPARAM *GetMarshalParam(MARSHALMSG *pMsg, ULONG ulParam)
{
    return (MARSHALPARAM *)(((BYTE *)pMsg) + pMsg->ulParamOffset[ulParam]);
}


//////////////////////////////////////////////////////////////////////////////
//
// ParamExtractor
//
//////////////////////////////////////////////////////////////////////////////


__inline void *ParamToBufferPointer(MARSHALPARAM *pParam)
{
    return (void *)((BYTE *)pParam + sizeof(MARSHALPARAM));
}

__inline void *ParamToBufferPointer(MARSHALMSG *pMsg, ULONG ulParam)
{
    MARSHALPARAM *pParam = GetMarshalParam(pMsg, ulParam);
    return (void *)((BYTE *)pParam + sizeof(MARSHALPARAM));
}

__inline void *ParamToPointer(MARSHALPARAM *pParam)
{
    return *(void **)((BYTE *)pParam + sizeof(MARSHALPARAM));
}

__inline void *ParamToPointer(MARSHALMSG *pMsg , ULONG ulParam)
{
    MARSHALPARAM *pParam = GetMarshalParam(pMsg, ulParam);
    return *(void **)((BYTE *)pParam + sizeof(MARSHALPARAM));
}

__inline ULONG ParamToULONG(MARSHALMSG *pMsg , ULONG ulParam)
{
    MARSHALPARAM *pParam = GetMarshalParam(pMsg, ulParam);
    return *(ULONG *)((BYTE *)pParam + sizeof(MARSHALPARAM));
}

HBITMAP ParamToHBITMAP(MARSHALMSG *pMsg , ULONG ulParam);

//////////////////////////////////////////////////////////////////////////////
//
// CModalLoop
//
//////////////////////////////////////////////////////////////////////////////

class CModalLoop : public CSysThreadRef
{
public:
    CModalLoop(SYSTHREAD *psfn);
    ~CModalLoop();

    HRESULT BlockFn(CCicEvent *pevent, DWORD dwWaitingThreadId, DWORD &dwWaitFlags);

private:
    void WaitHandleWndMessages(DWORD dwQueueFlags);
    BOOL WaitRemoveMessage(UINT uMsgFirst, UINT uMsgLast, DWORD dwFlags);
    BOOL MyPeekMessage(MSG *pMsg, HWND hwnd, UINT min, UINT max, WORD wFlag);

    ULONG _wQuitCode;
    BOOL _fQuitReceived;
};

//////////////////////////////////////////////////////////////////////////////
//
// CThreadMarshalWnd
//
//////////////////////////////////////////////////////////////////////////////

class CThreadMarshalWnd
{
public:
    CThreadMarshalWnd();
    ~CThreadMarshalWnd();

    BOOL Init(DWORD dwThreadId);
    BOOL PostMarshalThreadMessage(UINT uMsg, WPARAM wParam, LPARAM lParam);

    static BOOL DestroyAll();
    static BOOL DestroyThreadMarshalWnd(DWORD dwThread);
    static HWND GetThreadMarshalWnd(DWORD dwThread);
    static void ClearMarshalWndProc(DWORD dwProcessId);

    BOOL IsWindow()
    {
        return ::IsWindow(_hwnd);
    }

    BOOL IsThreadWindow();

    void SetMarshalWindow(HWND hwndMarshal)
    {
        _hwnd = hwndMarshal;
    }

private:
    static BOOL EnumThreadWndProc(HWND hwnd, LPARAM lParam);

    DWORD _dwThreadId;
    HWND  _hwnd;
};

void RegisterMarshalWndClass();
HWND EnsureMarshalWnd();

//////////////////////////////////////////////////////////////////////////////
//
// CProxy
//
//////////////////////////////////////////////////////////////////////////////
#define CPROXY_PARAM_START()      CPROXY_PARAM param[] = {

#define CPROXY_PARAM_ULONG_IN(ul)                                             \
              {MPARAM_IN_ULONG, NULL, ul, NULL, sizeof(ULONG), 1},

#define CPROXY_PARAM_WCHAR_IN(pch, cch)                                       \
              {MPARAM_IN_POINTER, (void *)(pch), 0, NULL, cch * sizeof(WCHAR), 1},

#define CPROXY_PARAM_POINTER_IN(p)                                            \
              {MPARAM_IN_POINTER, (void *)(p), 0, NULL, sizeof(*p), 1},

#define CPROXY_PARAM_POINTER_ARRAY_IN(p, nCnt)                                \
              {MPARAM_IN_POINTER, (void *)(p), 0, NULL, sizeof(*p), nCnt},

#define CPROXY_PARAM_INTERFACE_IN(p, iid)                                     \
              {MPARAM_IN_INTERFACE, p, 0, &iid, sizeof(void *), 1},

#define CPROXY_PARAM_INTERFACE_ARRAY_IN(p, iid, nCnt)                         \
              {MPARAM_IN_INTERFACE, p, 0, &iid, sizeof(void *), nCnt},

#define CPROXY_PARAM_POINTER_OUT(p)                                           \
              {MPARAM_OUT_POINTER, p, 0, NULL, sizeof(*p), 1},

#define CPROXY_PARAM_POINTER_ARRAY_OUT(p, nCnt)                               \
              {MPARAM_OUT_POINTER, p, 0, NULL, sizeof(*p), nCnt},

#define CPROXY_PARAM_INTERFACE_OUT(p, iid)                                    \
              {MPARAM_OUT_INTERFACE, p, 0, &iid, sizeof(void *), 1},

#define CPROXY_PARAM_INTERFACE_ARRAY_OUT(p, iid, nCnt)                        \
              {MPARAM_OUT_INTERFACE, p, 0, &iid, sizeof(void *), nCnt},

#define CPROXY_PARAM_INTERFACE_IN_OUT(p, iid)                                 \
              {MPARAM_IN_OUT_INTERFACE, p, 0, &iid, sizeof(void *), 1},

#define CPROXY_PARAM_INTERFACE_ARRAY_IN_OUT(p, iid, nCnt)                     \
              {MPARAM_IN_OUT_INTERFACE, p, 0, &iid, sizeof(void *), nCnt},

#define CPROXY_PARAM_BSTR_OUT(p)                                              \
              {MPARAM_OUT_BSTR, p, 0, NULL, 0, 1},

#define CPROXY_PARAM_HBITMAP_OUT(p)                                           \
              {MPARAM_OUT_HBITMAP, p, 0, NULL, 0, 1},

#define CPROXY_PARAM_HICON_OUT(p)                                             \
              {MPARAM_OUT_HICON, p, 0, NULL, 0, 1},

#define CPROXY_PARAM_HBITMAP_IN(hbmp)                                         \
              {MPARAM_IN_HBITMAP, &hbmp, 0, NULL, 0, 1},

#define CPROXY_PARAM_HICON_IN(hicon)                                          \
              {MPARAM_IN_HICON, &hicon, 0, NULL, 0, 1},

#define CPROXY_PARAM_TF_LBBALLOONINFO_OUT(p)                                   \
              {MPARAM_OUT_TF_LBBALLOONINFO, (void *)p, 0, NULL, sizeof(*p), 1},

#define CPROXY_PARAM_STRUCT_IN(s)                                             \
              {MPARAM_IN_STRUCT, &s, 0, NULL, sizeof(s), 1},

#define CPROXY_PARAM_CALL(uMethodId)                                          \
              };                                                              \
              return proxy_Param(uMethodId, ARRAYSIZE(param), param);

#define CPROXY_PARAM_CALL_NOPARAM(x) return proxy_Param(x, 0, NULL);

typedef struct {
   DWORD        dwFlags;
   void         *pv;
   ULONG        ul;
   const IID    *piid;
   ULONG        cbUnitSize;
   ULONG        ulCount;          // if this is array, the number of unit.

   ULONG        GetBufSize() {return cbUnitSize * ulCount;}
} CPROXY_PARAM;
 

class CProxy : public CSysThreadRef
{
public:
    CProxy(SYSTHREAD *psfn);
    virtual ~CProxy();

    ULONG InternalAddRef();
    ULONG InternalRelease();
    void Init(REFIID riid, 
              ULONG ulProxyId, 
              ULONG ulIdStubId, 
              DWORD dwStubTime, 
              DWORD dwStubThreadId, 
              DWORD dwCurThreadId, 
              DWORD dwCurProcessId);

    //
    // IRpcChannelBuffer
    //
    HRESULT SendReceive( MARSHALMSG *pMsg , ULONG ulBlockId);
    ULONG GetStubId() {return _ulStubId;}
    DWORD GetStubThreadId() {return _dwStubThreadId;}


protected:
    HRESULT proxy_Param(ULONG ulMethodId, ULONG ulParamNum, CPROXY_PARAM *pProsyParam);


protected:
    IID   _iid;                 // interface id for this proxy.
    ULONG _cRef;

private:
    CThreadMarshalWnd _tmw;
    ULONG _ulProxyId;           // unique proxy id in src thread.
    ULONG _ulStubId;            // unique stub id in stub thread.
    DWORD _dwStubTime;          // stub created time stamp.
    DWORD _dwStubThreadId;      // stub thread id.
    DWORD _dwSrcThreadId;       // src thread id.
    DWORD _dwSrcProcessId;      // src process id.

#ifdef DEBUG
    BOOL _fInLoop;
#endif
};

//////////////////////////////////////////////////////////////////////////////
//
// CMarshalInterfaceFileMapping
//
//////////////////////////////////////////////////////////////////////////////

class CMarshalInterfaceFileMapping : public CCicFileMapping
{
public:
   CMarshalInterfaceFileMapping(DWORD dwThreadId, ULONG ulStubId, ULONG ulStubTime) : CCicFileMapping()
   {
       if (SetName2(szFileMap, ARRAYSIZE(szFileMap), SZMARSHALINTERFACEFILEMAP, dwThreadId, ulStubId, ulStubTime))
           _pszFile = szFileMap;
   }
 
private:
    char szFileMap[MAX_PATH];
};

//////////////////////////////////////////////////////////////////////////////
//
// CStub
//
//////////////////////////////////////////////////////////////////////////////

#define CSTUB_PARAM_START()      CPROXY_PARAM param[] = {

#define CSTUB_PARAM_ULONG_IN(ul)                                             \
              {MPARAM_IN_ULONG, NULL, ul, NULL, 0 /*sizeof(ULONG)*/, 1},

#define CSTUB_PARAM_POINTER_IN(p)                                            \
              {MPARAM_IN_POINTER, (void *)(p), 0, NULL, 0 /*sizeof(*p)*/, 1},

#define CSTUB_PARAM_POINTER_ARRAY_IN(p, nCnt)                                \
              {MPARAM_IN_POINTER, (void *)(p), 0, NULL, 0 /*sizeof(*p)*/, nCnt},

#define CSTUB_PARAM_INTERFACE_IN(p, iid)                                     \
              {MPARAM_IN_INTERFACE, p, 0, &iid, 0 /*sizeof(void *)*/, 1},

#define CSTUB_PARAM_INTERFACE_ARRAY_IN(p, iid, cnt)                          \
              {MPARAM_IN_INTERFACE, p, 0, &iid, 0 /*sizeof(void *)*/, cnt},

#define CSTUB_PARAM_POINTER_OUT(p)                                           \
              {MPARAM_OUT_POINTER, p, 0, NULL, sizeof(*p), 1},

#define CSTUB_PARAM_POINTER_ARRAY_OUT(p, nCnt)                               \
              {MPARAM_OUT_POINTER, p, 0, NULL, sizeof(*p), nCnt},

#define CSTUB_PARAM_INTERFACE_OUT(p, iid)                                    \
              {MPARAM_OUT_INTERFACE, p, 0, &iid, sizeof(void *), 1},

#define CSTUB_PARAM_INTERFACE_ARRAY_OUT(p, iid, cnt)                         \
              {MPARAM_OUT_INTERFACE, p, 0, &iid, sizeof(void *), cnt},

#define CSTUB_PARAM_BSTR_OUT(p)                                              \
              {MPARAM_OUT_BSTR, p, 0, NULL, 0, 1},

#define CSTUB_PARAM_HBITMAP_OUT(p)                                           \
              {MPARAM_OUT_HBITMAP, p, 0, NULL, 0, 1},

#define CSTUB_PARAM_HICON_OUT(p)                                             \
              {MPARAM_OUT_HICON, p, 0, NULL, 0, 1},

#define CSTUB_PARAM_TF_LBBALLOONINFO_OUT(p)                                   \
              {MPARAM_OUT_TF_LBBALLOONINFO, (void *)p, 0, NULL, sizeof(*p), 1},

#define CSTUB_PARAM_HBITMAP_IN(hbmp)                                         \
              {MPARAM_IN_HBITMAP, &hbmp, 0, NULL, 0, 1},

#define CSTUB_PARAM_HICON_IN(hicon)                                         \
              {MPARAM_IN_HICON, &hicon, 0, NULL, 0, 1},


#define CSTUB_PARAM_END()                                                    \
              };

#define CSTUB_PARAM_INTERFACE_OUT_RELEASE(p)                                 \
              if (p) ((IUnknown *)p)->Release();

#define CSTUB_PARAM_INTERFACE_ARRAY_OUT_RELEASE(p, ulCnt)                    \
              for (ULONG __ul = 0; __ul < ulCnt; __ul++)                     \
                   if (p[__ul]) ((IUnknown *)p[__ul])->Release();


#define CSTUB_PARAM_CALL(pMsg, hrRet, psb)                                 \
              stub_OutParam(_this, pMsg, pMsg->ulMethodId, ARRAYSIZE(param), param, psb); \
              pMsg->hrRet = hrRet;

#define CSTUB_PARAM_RETURN()                                                  \
              return S_OK;

#define CSTUB_NOT_IMPL()                                                      \
              Assert(0);                                                      \
              return S_OK;
class CStub
{
public:
    CStub();
    virtual ~CStub();
    ULONG _AddRef();
    ULONG _Release();
    ULONG GetStubId() {return _ulStubId;}
    virtual HRESULT Invoke(MARSHALMSG *pMsg, CSharedBlock *psb) = 0;

    void ClearFileMap()
    {
        if (_pfm)
        {
            _pfm->Close();
            delete _pfm;
            _pfm = NULL;
        }
    }

    static HRESULT stub_OutParam(CStub *_this, 
                                 MARSHALMSG *pMsg, 
                                 ULONG ulMethodId, 
                                 ULONG ulParamNum, 
                                 CPROXY_PARAM *pProxyParam, 
                                 CSharedBlock *psb);

    CMarshalInterfaceFileMapping *_pfm;

    IID      _iid;             // interface id for this stub.
    IUnknown *_punk;           // actual object.
    ULONG    _ulStubId;        // unique stubid of this thread.
    DWORD    _dwStubTime;      // stub created time stamp.
    DWORD    _dwStubThreadId;  // stub thread id.
    DWORD    _dwStubProcessId; // stub process id.
    DWORD    _dwSrcThreadId;   // src thread id.

    BOOL     _fNoRemoveInDtor; // this stub has been removed from list.
                               // so don't try at dtor.
    ULONG    _cRef;
};

#endif // MARSHAL_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\ctf\uim\lqueue.cpp ===
//
// lqueue.cpp
//
// Lock queue code.
//

#include "private.h"
#include "ic.h"
#include "tim.h"
#include "dim.h"

//+---------------------------------------------------------------------------
//
// _EditSessionQiCallback
//
//----------------------------------------------------------------------------

HRESULT CAsyncQueueItem::_EditSessionQiCallback(CInputContext *pic, struct _TS_QUEUE_ITEM *pItem, QiCallbackCode qiCode)
{
    switch (qiCode)
    {
        case QI_ADDREF:
            pItem->state.aqe.paqi->_AddRef();
            break;

        case QI_DISPATCH:
            return pItem->state.aqe.paqi->DoDispatch(pic);

        case QI_FREE:
            pItem->state.aqe.paqi->_Release();
            break;
    }
    return S_OK;
}

//+---------------------------------------------------------------------------
//
// _CheckReadOnly
//
//----------------------------------------------------------------------------

void CAsyncQueueItem::_CheckReadOnly(CInputContext *pic)
{
    TS_STATUS dcs;
    if (SUCCEEDED(pic->GetStatus(&dcs)))
    {
        if (dcs.dwDynamicFlags & TF_SD_READONLY)
            _item.dwFlags &= ~TF_ES_WRITE;
    }
}

//+---------------------------------------------------------------------------
//
// _QueueItem
//
//----------------------------------------------------------------------------

HRESULT CInputContext::_QueueItem(TS_QUEUE_ITEM *pItem, BOOL fForceAsync, HRESULT *phrSession)
{
    TS_QUEUE_ITEM *pQueueItem;
    int iItem;
    HRESULT hr;
    HRESULT hrRet;
    BOOL fSync;
    BOOL fNeedWriteLock;
    BOOL fSyncLockFailed = FALSE;

    if (pItem->dwFlags & TF_ES_WRITE)
    {
        // write access implies property write access
        pItem->dwFlags |= TF_ES_PROPERTY_WRITE;
    }

    fSync = (pItem->dwFlags & TF_ES_SYNC);

    Assert(!(fSync && fForceAsync)); // doesn't make sense
    
    fNeedWriteLock = _fLockHeld ? (pItem->dwFlags & TF_ES_WRITE) && !(_dwlt & TF_ES_WRITE) : FALSE;

    if (fForceAsync)
        goto QueueItem;

    if (!fSync &&
        _rgLockQueue.Count() > 0)
    {
        // there's already something in the queue
        // so we can't handle an async request until later
        fForceAsync = TRUE;
        goto QueueItem;
    }

    if (_fLockHeld)
    {
        if (fSync)
        {
            // sync
            // we can't handle a sync write req while holding a read lock
            *phrSession = fNeedWriteLock ? TF_E_SYNCHRONOUS : _DispatchQueueItem(pItem);
        }
        else
        {
            // async
            if (fNeedWriteLock)
            {
                // we need a write lock we don't currently hold
                fForceAsync = TRUE;
                goto QueueItem;
            }

            *phrSession = _DispatchQueueItem(pItem);
        }

        return S_OK;
    }

QueueItem:
    if ((pQueueItem = _rgLockQueue.Append(1)) == NULL)
    {
        *phrSession = E_FAIL;
        return E_OUTOFMEMORY;
    }

    *pQueueItem = *pItem;
    _AddRefQueueItem(pQueueItem);

    hrRet = S_OK;
    *phrSession = TF_S_ASYNC;

    if (!fForceAsync)
    {
        Assert(!_fLockHeld);

        _fLockHeld = TRUE;
        _dwlt = pItem->dwFlags;

        hrRet = SafeRequestLock(_ptsi, pItem->dwFlags & ~TF_ES_PROPERTY_WRITE, phrSession);

        _fLockHeld = FALSE;

        // possibly this was a synch request, but the app couldn't grant it
        // now we need to make sure the queue item is cleared
        if ((iItem = _rgLockQueue.Count() - 1) >= 0)
        {
            TS_QUEUE_ITEM *pItemTemp;
            pItemTemp = _rgLockQueue.GetPtr(iItem);
            if (pItemTemp->dwFlags & TF_ES_SYNC)
            {
                Assert(*phrSession == TS_E_SYNCHRONOUS); // only reason why item is still in queue should be app lock rejection

                _ReleaseQueueItem(pItemTemp);
                _rgLockQueue.Remove(iItem, 1);

                fSyncLockFailed = TRUE;
            }
        }

        if (_ptsi == NULL)
        {
            // someone popped this ic during the RequestLock above
            goto Exit;
        }
    }

    // make sure synchronous edit session gets cleared off the queue no matter what after the lock request!
    _Dbg_AssertNoSyncQueueItems();

    // this shouldn't go reentrant, but just to be safe do it last
    if (_fLockHeld)
    {
        if (fForceAsync && fNeedWriteLock)
        {
            SafeRequestLock(_ptsi, TS_LF_READWRITE, &hr); // Issue: try to recover if app goes reentrant?
            Assert(hr == TS_S_ASYNC); // app should have granted this async
        }
    }
    else if (!fSyncLockFailed)
    {
        // we don't hold a lock currently
        if (fForceAsync || (fSync && _rgLockQueue.Count() > 0))
        {
            // ask for another lock later, if there are pending async items in the queue
            _PostponeLockRequest(pItem->dwFlags);
        }
    }

Exit:
    return hrRet;
}

//+---------------------------------------------------------------------------
//
// _EmptyLockQueue
//
//----------------------------------------------------------------------------

HRESULT CInputContext::_EmptyLockQueue(DWORD dwLockFlags, BOOL fAppChangesSent)
{
    TS_QUEUE_ITEM *pItem;
    TS_QUEUE_ITEM item;
    int iItem;
    HRESULT hr;

    Assert(_fLockHeld); // what are we doing emptying the queue without a lock?!

    if ((iItem = _rgLockQueue.Count() - 1) < 0)
        return S_OK;

    //
    // special case: there may be a single synchronous es at the end of the queue
    //

    pItem = _rgLockQueue.GetPtr(iItem);

    if (pItem->dwFlags & TF_ES_SYNC)
    {
        item = *pItem;
        _rgLockQueue.Remove(iItem, 1);

        if (fAppChangesSent)
        {
            Assert(0); // this is suspicious...the app should not let this happen.
                       // What's happened: the app had some pending changes, but hadn't responed to
                       // our lock requests yet.  Then some TIP asked for a sync lock, which we just got.
                       // Normally, it is unlikely that an app would still have pending changes by the time
                       // a tip fires off -- the app should clear any pending changes before starting a
                       // transaction like a key event or reconversion.  However, another possibility is
                       // that a rogue TIP is using the sync flag for a private event, which is discouraged
                       // because it could fail here.
            // in any case, we won't continue until the app changes have been dealt with...must back out with an error.
            return E_UNEXPECTED;
        }

        if ((item.dwFlags & TF_ES_WRITE) && !(dwLockFlags & TF_ES_WRITE))
        {
            Assert(0); // app granted wrong access?
            return E_UNEXPECTED;
        }
        Assert(!(item.dwFlags & TF_ES_WRITE) || (item.dwFlags & TF_ES_PROPERTY_WRITE)); // write implies property write

        hr = _DispatchQueueItem(&item);
        _ReleaseQueueItem(&item);

        return hr;
    }

    //
    // handle any asynch requests
    //

    while (_rgLockQueue.Count() > 0)
    {
        pItem = _rgLockQueue.GetPtr(0);

        Assert(!(pItem->dwFlags & TF_ES_SYNC)); // should never see synch item here!

        // make sure the lock we've been given is good enough for the queued es
        if ((pItem->dwFlags & TF_ES_WRITE) && !(dwLockFlags & TF_ES_WRITE))
        {
            // ask for an upgrade anyways, to try to recover
            SafeRequestLock(_ptsi, TS_LF_READWRITE, &hr); // Issue: try to recover if app goes reentrant?
            Assert(hr == TS_S_ASYNC); // app should have granted this async
            break;
        }

        item = *pItem;
        _rgLockQueue.Remove(0, 1);
        _DispatchQueueItem(&item);
        _ReleaseQueueItem(&item);
    }

    return S_OK;
}

//+---------------------------------------------------------------------------
//
// _AbortQueueItems
//
//----------------------------------------------------------------------------

void CInputContext::_AbortQueueItems()
{
    TS_QUEUE_ITEM *pItem;
    int i;

    for (i=0; i<_rgLockQueue.Count(); i++)
    {
        pItem = _rgLockQueue.GetPtr(i);

        Assert(!(pItem->dwFlags & TF_ES_SYNC)); // should never see synch item here!

        _ReleaseQueueItem(pItem);
    }

    _rgLockQueue.Clear();

    if (_dwPendingLockRequest)
    {
        SYSTHREAD *psfn = GetSYSTHREAD();

        if (psfn)
            psfn->_dwLockRequestICRef--;

        _dwPendingLockRequest = 0;
    }
}

//+---------------------------------------------------------------------------
//
// _PostponeLockRequest
//
//----------------------------------------------------------------------------

void CInputContext::_PostponeLockRequest(DWORD dwFlags)
{
    dwFlags &= TF_ES_READWRITE;

    Assert(dwFlags != 0);

    // we don't need to upgrade the req because we can do that inside the
    // lock grant more efficiently
    if (_dwPendingLockRequest == 0)
    {
        SYSTHREAD *psfn = GetSYSTHREAD();

        if (!psfn)
            return;
   
        if (!_nLockReqPostDisableRef && !psfn->_fLockRequestPosted)
        {
            if (!PostThreadMessage(GetCurrentThreadId(), g_msgPrivate, TFPRIV_LOCKREQ, 0))
            {
                return;
            }

            psfn->_fLockRequestPosted = TRUE;
        }

        psfn->_dwLockRequestICRef++;
    }

    _dwPendingLockRequest |= dwFlags;
}


//+---------------------------------------------------------------------------
//
// _PostponeLockRequestCallback
//
//----------------------------------------------------------------------------

/* static */
void CInputContext::_PostponeLockRequestCallback(SYSTHREAD *psfn, CInputContext *pic)
{
    CThreadInputMgr *tim;
    CDocumentInputManager *dim;
    int iDim;
    int iContext;
    DWORD dwFlags;
    HRESULT hr;

    Assert(psfn);


    if (!psfn->_dwLockRequestICRef)
        return;

    // need to verify pic is still valid
    tim = CThreadInputMgr::_GetThisFromSYSTHREAD(psfn);
    if (!tim)
        return;

    for (iDim = 0; iDim < tim->_rgdim.Count(); iDim++)
    {
        dim = tim->_rgdim.Get(iDim);

        for (iContext = 0; iContext <= dim->_GetCurrentStack(); iContext++)
        {
            CInputContext *picCur = dim->_GetIC(iContext);
            if (!pic || (picCur == pic))
            {
                // we found this ic, it's valid
                dwFlags = picCur->_dwPendingLockRequest;
                if (dwFlags)
                {
                    picCur->_dwPendingLockRequest = 0;

                    Assert(psfn->_dwLockRequestICRef > 0);
                    psfn->_dwLockRequestICRef--;

                    SafeRequestLock(picCur->_ptsi, dwFlags, &hr);
                }

                if (pic)
                    return;
            }
        }
    }
}

//+---------------------------------------------------------------------------
//
// EnableLockRequestPosting
//
//----------------------------------------------------------------------------

HRESULT CInputContext::EnableLockRequestPosting(BOOL fEnable)
{
    if (!fEnable)
    {
       _nLockReqPostDisableRef++;
    }
    else
    {
       if (_nLockReqPostDisableRef > 0)
           _nLockReqPostDisableRef--;
    }
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\ctf\uim\memcache.h ===
//
// memcache.h
//

#ifndef MEMCACHE_H
#define MEMCACHE_H

#include "mem.h"
#include "globals.h"

extern LONG g_lMemCacheMutex;

typedef struct _MEMCACHE
{
    ULONG uMaxPtrs;
    ULONG iNextFree;
    void *rgPtrs[1]; // 1 or more...
} MEMCACHE;

MEMCACHE *MemCache_New(ULONG uMaxPtrs);

void MemCache_Delete(MEMCACHE *pMemCache);

//+---------------------------------------------------------------------------
//
// MemCache_Add
//
//----------------------------------------------------------------------------

inline BOOL MemCache_Add(MEMCACHE *pMemCache, void *pv)
{
    BOOL fRet = FALSE;

    if (InterlockedIncrement(&g_lMemCacheMutex) != 0)
        goto Exit;

    if (pMemCache->iNextFree >= pMemCache->uMaxPtrs)
        goto Exit; // cache is full!

    pMemCache->rgPtrs[pMemCache->iNextFree++] = pv;

    fRet = TRUE;

Exit:
    InterlockedDecrement(&g_lMemCacheMutex);
    return fRet;
}

//+---------------------------------------------------------------------------
//
// MemCache_Remove
//
//----------------------------------------------------------------------------

inline void *MemCache_Remove(MEMCACHE *pMemCache)
{
    void *pv = NULL;

    if (InterlockedIncrement(&g_lMemCacheMutex) != 0)
        goto Exit;

    if (pMemCache->iNextFree == 0)
        goto Exit;

    pv = pMemCache->rgPtrs[--pMemCache->iNextFree];

Exit:
    InterlockedDecrement(&g_lMemCacheMutex);
    return pv;
}

//+---------------------------------------------------------------------------
//
// MemCache_NewOp
//
//----------------------------------------------------------------------------

#ifdef DEBUG
inline void *MemCache_NewOp(MEMCACHE *pMemCache, size_t nSize, const TCHAR *pszFile, int iLine)
#else
inline void *MemCache_NewOp(MEMCACHE *pMemCache, size_t nSize)
#endif
{
    void *pv = NULL;

    if (pMemCache != NULL)
    {
        if (pv = MemCache_Remove(pMemCache))
        {   // Issue: update debug mem track info
            memset(pv, 0, nSize);
        }
    }

    if (pv == NULL)
    {
#ifdef DEBUG
        pv = Dbg_MemAllocClear(nSize, pszFile, iLine);
#else
        pv = cicMemAllocClear(nSize);
#endif
    }

    return pv;
}

//+---------------------------------------------------------------------------
//
// MemCache_DeleteOp
//
//----------------------------------------------------------------------------

inline void MemCache_DeleteOp(MEMCACHE *pMemCache, void *pv)
{
    if (pMemCache == NULL ||
        !MemCache_Add(pMemCache, pv))
    {
        cicMemFree(pv);
    }
}

#ifdef DEBUG
#define DECLARE_CACHED_NEW                                                              \
    void *operator new(size_t nSize, const TCHAR *pszFile, int iLine) { return MemCache_NewOp(_s_pMemCache, nSize, pszFile, iLine); }  \
    void operator delete(void *pv) { MemCache_DeleteOp(_s_pMemCache, pv); }             \
    static _MEMCACHE *_s_pMemCache;

#else // !DEBUG
#define DECLARE_CACHED_NEW                                                              \
    void *operator new(size_t nSize) { return MemCache_NewOp(_s_pMemCache, nSize); }    \
    void operator delete(void *pv) { MemCache_DeleteOp(_s_pMemCache, pv); }             \
    static _MEMCACHE *_s_pMemCache;
#endif

#define DECLARE_CACHED_NEW_STATIC(the_class)   \
    MEMCACHE *the_class::_s_pMemCache = NULL;

#endif // MEMCACHE_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\ctf\uim\memcache.cpp ===
//
// memcache.cpp
//

#include "private.h"
#include "memcache.h"

LONG g_lMemCacheMutex = -1;

//+---------------------------------------------------------------------------
//
// MemCache_New
//
//----------------------------------------------------------------------------

MEMCACHE *MemCache_New(ULONG uMaxPtrs)
{
    MEMCACHE *pmc;
    ULONG uSize;

    Assert(uMaxPtrs > 0);

    uSize = sizeof(MEMCACHE) + uMaxPtrs*sizeof(void *) - sizeof(void *);

    if ((pmc = (MEMCACHE *)cicMemAlloc(uSize)) == NULL)
        return NULL;

    pmc->uMaxPtrs = uMaxPtrs;
    pmc->iNextFree = 0;

    return pmc;
}

//+---------------------------------------------------------------------------
//
// MemCache_Delete
//
//----------------------------------------------------------------------------

void MemCache_Delete(MEMCACHE *pMemCache)
{ 
    while (pMemCache->iNextFree > 0)
    {
        cicMemFree(pMemCache->rgPtrs[--pMemCache->iNextFree]);
    }
    cicMemFree(pMemCache);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\ctf\uim\marshal.cpp ===
//
// marshal.cpp
//
#include "private.h"
#include "globals.h"
#include "marshal.h"
#include "thdutil.h"
#include "cicmutex.h"
#include "helpers.h"
#include "mstub.h"
#include "mproxy.h"
#include "ithdmshl.h"
#include "transmit.h"
#include "smblock.h"
#include "utb.h"
#include "nuimgr.h"
#include "timlist.h"

#define WIN9X_SRCTHREADID 0x0001

inline HRESULT MAKE_WIN32( HRESULT status )
{
    return MAKE_HRESULT( SEVERITY_ERROR, FACILITY_WIN32, status );
}

#ifdef DEBUG
ULONG g_ulMarshalTimeOut = DEFAULTMARSHALTIMEOUT;
#endif


//////////////////////////////////////////////////////////////////////////////
//
// CSendReceiveEvent
//
//////////////////////////////////////////////////////////////////////////////

class CSendReceiveEvent : public CCicEvent
{
public:
   CSendReceiveEvent(DWORD dwThreadId, ULONG ulBlockId) : CCicEvent()
   {
       if (SetName2(sz, ARRAYSIZE(sz), SZRPCSENDRECEIVEEVENT, dwThreadId, ulBlockId))
           _psz = sz;
   }
 
private:
    char sz[MAX_PATH];
};

//////////////////////////////////////////////////////////////////////////////
//
// CSendReceiveConnectionEvent
//
//////////////////////////////////////////////////////////////////////////////

class CSendReceiveConnectionEvent : public CCicEvent
{
public:
   CSendReceiveConnectionEvent(DWORD dwThreadId, ULONG ulBlockId) : CCicEvent()
   {
       if (SetName2(sz, ARRAYSIZE(sz), SZRPCSENDRECEIVECONNECTIONEVENT, dwThreadId, ulBlockId))
           _psz = sz;
   }
 
private:
    char sz[MAX_PATH];
};

//////////////////////////////////////////////////////////////////////////////
//
// CCheckThreadInputIdle
//
//////////////////////////////////////////////////////////////////////////////

#define SZCHECKTHREADINPUTIDLE     __TEXT("MSCTF.CheckThreadInptIdle.Event.")

class CCheckThreadInputIdle : public CCicEvent
{
public:
   CCheckThreadInputIdle(DWORD dwThreadId, DWORD dw) : CCicEvent()
   {
       if (SetName2(sz, ARRAYSIZE(sz), SZCHECKTHREADINPUTIDLE, dwThreadId, dw))
           _psz = sz;
   }

private:
    char sz[MAX_PATH];
};



//--------------------------------------------------------------------------
//
//  GetOleMainThreadWindow
//
//--------------------------------------------------------------------------

BOOL IsOleMainThreadWindow(HWND hwnd)
{
    char szClassName[32];

    if (!GetClassName(hwnd, szClassName, ARRAYSIZE(szClassName)))
       return FALSE;

    if (!lstrcmp(szClassName, TEXT("OleMainThreadWndClass")))
       return TRUE;

    return FALSE;
}

HWND FindOleMainThredWindow(DWORD dwThreadId)
{
    HWND hwnd = FindWindowEx(IsOnNT5() ? HWND_MESSAGE : NULL, 
                             NULL, 
                             TEXT("OleMainThreadWndClass"), NULL);

    while (hwnd)
    {
        if (dwThreadId == GetWindowThreadProcessId(hwnd, NULL))
        {
            if (IsOleMainThreadWindow(hwnd))
                return hwnd;
        }

        hwnd = GetWindow(hwnd, GW_HWNDNEXT);
    }

    return NULL;
}
  

HWND GetOleMainThreadWindow(SYSTHREAD *psfn)
{
    HWND hwndOle = NULL;

    if (psfn->hwndOleMainThread)
    {
        if (IsWindow(psfn->hwndOleMainThread) && 
            IsOleMainThreadWindow(psfn->hwndOleMainThread))
            return psfn->hwndOleMainThread;

        psfn->hwndOleMainThread = NULL;
    }


    hwndOle = FindOleMainThredWindow(GetCurrentThreadId());
    psfn->hwndOleMainThread = hwndOle;

    return hwndOle;
}

//--------------------------------------------------------------------------
//
//  FindStub
//
//--------------------------------------------------------------------------

int FindStub(CPtrArray<CStub> *prgStub, ULONG ulStubId)
{
    int nMin = 0;
    int nMax = prgStub->Count();
    int nMid = -1;

    while (nMin < nMax)
    {
         ULONG ulMidStubId;
         nMid = (nMin + nMax) / 2;
     
         ulMidStubId = prgStub->Get(nMid)->_ulStubId;

         if (ulMidStubId > ulStubId)
            nMax = nMid;
         else if (ulMidStubId < ulStubId)
            nMin = nMid + 1;
         else
            return nMid;
    }

    return -1;
}

//--------------------------------------------------------------------------
//
//  FindStubId
//
//--------------------------------------------------------------------------

BOOL FindStubId(SYSTHREAD *psfn, ULONG *pulStubId, ULONG *pulInsert)
{
    Assert(psfn->prgStub);
    int i;
    int nCnt = psfn->prgStub->Count();
    BOOL fFound;

    if (nCnt >= 0x7fffffff)
    {
        Assert(0);
        return FALSE;
    }
    
    *pulStubId = 0;
    *pulInsert = 0;

    if (!nCnt)
        return TRUE;

    //
    // max is 0x7ffffffff....
    //
    *pulStubId = 0x7fffffff;
    fFound = FALSE;

    for (i = nCnt - 1; i >= 0; i--)
    {
        CStub *pStub = psfn->prgStub->Get(i);
        if (*pulStubId > pStub->_ulStubId)
        {
            i++;
            *pulStubId = pStub->_ulStubId + 1;
            fFound = TRUE;
            break;
        }
        *pulStubId = pStub->_ulStubId - 1;
    }
 
    //
    // we should be able to find any number in 32bit value.
    //
    Assert(fFound); 
    Assert(*pulStubId <= 0x7fffffff); 

#ifdef DEBUG
    Assert(FindStub(psfn->prgStub, *pulStubId) == -1);
#endif
    *pulInsert = i;
    return fFound;
}

#ifdef DEBUG
void dbg_CheckStubIds(SYSTHREAD *psfn)
{
    Assert(psfn->prgStub);

    int i;
    int nCnt = psfn->prgStub->Count();

    CStub *pStubPrev = psfn->prgStub->Get(0);
    for (i = 1; i < nCnt; i++)
    {
        CStub *pStub = psfn->prgStub->Get(i);
        Assert(pStubPrev->_ulStubId < pStub->_ulStubId);
        pStubPrev = pStub;
    }
}
#else
#define dbg_CheckStubIds(psfn)
#endif


//--------------------------------------------------------------------------
//
//  CicCoMarshalInterface
//
//--------------------------------------------------------------------------

HRESULT CicCoMarshalInterface(REFIID riid, IUnknown *punk, ULONG *pulStubId, DWORD *pdwStubTime, DWORD dwSrcThreadId)
{
    HRESULT hr = E_OUTOFMEMORY;
    SYSTHREAD *psfn = GetSYSTHREAD();
    CStub *pStub = NULL;
    DWORD dwThreadId = GetCurrentThreadId();
    MARSHALINTERFACE *pmi = NULL;
    ULONG ulStubId;
    ULONG ulInsert;
    DWORD dwStubTime;
    
    if (!psfn)
        return E_FAIL;

    if (!psfn->prgStub)
    {
        psfn->prgStub = new CPtrArray<CStub>;
        if (!psfn->prgStub)
        {
            goto Exit;
        }
    }

    if (!FindStubId(psfn, &ulStubId, &ulInsert))
    {
        Assert(0);
        hr = E_FAIL;
        goto Exit;
    }

    dwStubTime = GetTickCount();
    pStub = StubCreator(riid, punk, ulStubId, dwStubTime, psfn->dwThreadId, psfn->dwProcessId, dwSrcThreadId);
    if (!pStub)
    {
        Assert(0);
        goto Exit;
    }

    if (!psfn->prgStub->Insert(ulInsert, 1))
    {
        goto Exit;
    }

    psfn->prgStub->Set(ulInsert, pStub);
    dbg_CheckStubIds(psfn);

    pStub->_pfm = new CMarshalInterfaceFileMapping(dwThreadId, ulStubId, dwStubTime);

    if (pStub->_pfm == NULL)
    {
        goto Exit;
    }

    pmi = (MARSHALINTERFACE *)pStub->_pfm->Create(NULL, sizeof(MARSHALINTERFACE), NULL);
    if (!pmi)
    {
        goto Exit;
    }

    pmi->iid = riid;
    pmi->dwStubTime = dwStubTime;

    *pulStubId = ulStubId;
    *pdwStubTime = dwStubTime;

    hr = S_OK;

Exit:
    if (hr != S_OK && pStub != NULL)
    {
        // pStub dtor will remove stub from psfn->prgStub
        pStub->_Release();
    }

    return hr;
}


//--------------------------------------------------------------------------
//
//  CicCoUnmarshalInterface
//
//--------------------------------------------------------------------------

HRESULT CicCoUnmarshalInterface(REFIID riid, DWORD dwStubThreadId, ULONG ulStubId, DWORD dwStubTime, void **ppv)
{
    HRESULT hr = E_FAIL;
    SYSTHREAD *psfn = GetSYSTHREAD();
    IUnknown *punkProxy = NULL;
    MARSHALINTERFACE *pmi;
    CMarshalInterfaceFileMapping fm(dwStubThreadId, ulStubId, dwStubTime);

    *ppv = NULL;

    if (!psfn)
    {
        hr = E_OUTOFMEMORY;
        goto Exit;
    }

    pmi = (MARSHALINTERFACE *)fm.Open();
    if (!pmi)
    {
        // Assert(0);
        hr = MAKE_WIN32(RPC_S_SERVER_UNAVAILABLE);
        goto Exit;
    }

    if (!IsEqualIID(pmi->iid, riid))
    {
        // Assert(0);
        hr = E_FAIL;
        goto Exit;
    }

    punkProxy = ProxyCreator(psfn,
                             pmi->iid, 
                             ulStubId, 
                             dwStubTime, 
                             dwStubThreadId, 
                             psfn->dwThreadId, 
                             psfn->dwProcessId);

    if (!punkProxy)
    {
        Assert(0);
        hr = E_OUTOFMEMORY;
        goto Exit;
    }

    *ppv = punkProxy;
    hr = S_OK;
Exit:
    fm.Close();
    return hr;
}

//--------------------------------------------------------------------------
//
//  HandleSendReceive
//
//--------------------------------------------------------------------------

void HandleSendReceiveMsg(DWORD dwSrcThreadId, ULONG ulBlockId)
{
    MARSHALMSG *pMsg = NULL;
    SYSTHREAD *psfn = GetSYSTHREAD();
    int nTarget;
    CStub *pStub = NULL;
    HRESULT hr;
    CSharedBlock *psb;

    if (!psfn)
    {
        Assert(0);
        return;
    }

    Assert(IsOnNT() || (dwSrcThreadId == WIN9X_SRCTHREADID));

    CSendReceiveEvent event(dwSrcThreadId, ulBlockId);
    CSendReceiveConnectionEvent eventc(dwSrcThreadId, ulBlockId);

    if (eventc.Open())
        eventc.Set();

    if (psfn->pti && (psfn->dwThreadId == psfn->pti->dwThreadId))
        psfn->pti->ulInMarshal++;
    else
        Assert(0);


    psb = EnsureSharedBlockForThread(psfn, dwSrcThreadId);
    if (!psb)
    {
        TraceMsg(TF_EVENT, "HandleSendReceive no Shared Block Ptr");
        goto Exit;
    }

    pMsg = (MARSHALMSG *)psb->GetPtrFromBlockId(ulBlockId);
    if (!pMsg)
    {
        TraceMsg(TF_EVENT, "HandleSendReceive no Msg Ptr");
        goto Exit;
    }

    if (!psfn->prgStub)
    {
        TraceMsg(TF_EVENT, "HandleSendReceive no more sink");
        goto Exit;
    }

    nTarget = FindStub(psfn->prgStub, pMsg->ulStubId);
    if (nTarget == -1)
    {
        TraceMsg(TF_EVENT, "HandleSendReceive no Stub");
        goto Exit;
    }

    pStub = psfn->prgStub->Get(nTarget);
    if (!pStub)
    {
        TraceMsg(TF_EVENT, "HandleSendReceive no Stub Ptr");
        goto Exit;
    }

    if (pStub->_dwStubTime != pMsg->dwStubTime)
    {
        TraceMsg(TF_EVENT, "HandleSendReceive old proxy was used");
        goto Exit;
    }

    Assert(IsEqualIID(pStub->_iid, pMsg->iid));

#ifdef DEBUG
    TCHAR _szModule[MAX_PATH];
    ::GetModuleFileName(NULL, _szModule, sizeof(_szModule)/sizeof(TCHAR));
    TraceMsg(TF_EVENT, "%s HandleSendReceive Invoke", _szModule);
#endif

    //
    // we check the file map handle to marshal this interface itself.
    //
    pStub->ClearFileMap();

    _try 
    {
        hr = pStub->Invoke(pMsg, psb);
    }
    _except(1)
    {
#ifdef DEBUG
        TraceMsg(TF_EVENT, "%s HandleSendReceive Except", _szModule);
#endif
        Assert(0);
        goto Exit;
    }

    if (FAILED(hr))
    {
#ifdef DEBUG
        TraceMsg(TF_EVENT, "%s HandleSendReceive Error", _szModule);
#endif
        Assert(0);
        goto Exit;
    }

#ifdef DEBUG
    TraceMsg(TF_EVENT, "%s HandleSendReceive OK", _szModule);
#endif
 
#if 0
    if (IsOnNT5())
    {
        // 
        // for Office10 beta.
        // 
        // we want to allow SetForegroundWindow always when marshalling
        // call happens. Thus we may have non-necessary calls here. 
        // Needs to find a good place to call this.
        //
        ALLOWSETFOREGROUNDWINDOW fnAllowSetForeground;
        fnAllowSetForeground = EnsureAllowSetForeground();
        if (fnAllowSetForeground)
            fnAllowSetForeground(pMsg->dwSrcProcessId);
    }
#endif

Exit:
    if (psfn->pti && (psfn->dwThreadId == psfn->pti->dwThreadId))
        psfn->pti->ulInMarshal--;
    else
        Assert(0);

    if (event.Open())
        event.Set();

}

//////////////////////////////////////////////////////////////////////////////
//
// CModalLoop
//
//////////////////////////////////////////////////////////////////////////////

//--------------------------------------------------------------------------
//
//  ctor
//
//--------------------------------------------------------------------------

CModalLoop::CModalLoop(SYSTHREAD *psfn) : CSysThreadRef(psfn)
{
    _wQuitCode =  0;
    _fQuitReceived = FALSE;
}

//--------------------------------------------------------------------------
//
//  dtor
//
//--------------------------------------------------------------------------

CModalLoop::~CModalLoop()
{
    if (_fQuitReceived)
        PostQuitMessage(_wQuitCode);
}

//--------------------------------------------------------------------------
//
//  WaitHandleWndMessage
//
//--------------------------------------------------------------------------

#define WRM_MARSHALWND         0x0001
#define WRM_DISPATCH           0x0002
#define WRM_OLEWINDOW          0x0004
#define WRM_MARSHALWNDDISPATCH (WRM_DISPATCH | WRM_MARSHALWND)

void CModalLoop::WaitHandleWndMessages(DWORD dwQueueFlags)
{

    // Try to clear the queue as best we can of any messages that
    // might be holding off some other modal loop from executing.
    // So we eat all mouse and key events.
    if (dwQueueFlags & QS_KEY)
    {
        WaitRemoveMessage(WM_KEYFIRST, WM_KEYLAST, 0);
    }

    // Clear mouse releated messages if there are any
    if (dwQueueFlags & QS_MOUSE)
    {
        WaitRemoveMessage(WM_MOUSEMOVE, WM_MOUSEMOVE, 0);
        WaitRemoveMessage(WM_NCMOUSEFIRST, WM_NCMOUSELAST, 0);
        WaitRemoveMessage(WM_QUEUESYNC, WM_QUEUESYNC, 0);
    }

    if (dwQueueFlags & QS_POSTMESSAGE)
    {
        WaitRemoveMessage(WM_DDE_FIRST, WM_DDE_LAST, WRM_DISPATCH);
        WaitRemoveMessage(g_msgThreadMarshal, 
                          g_msgThreadMarshal, 
                          WRM_MARSHALWNDDISPATCH);
        WaitRemoveMessage(g_msgCheckThreadInputIdel,
                          g_msgCheckThreadInputIdel,
                          WRM_MARSHALWNDDISPATCH);
#ifdef POINTER_MARSHAL
        WaitRemoveMessage(g_msgPointerMarshal, 
                          g_msgPointerMarshal, 
                          WRM_MARSHALWNDDISPATCH);
#endif
#ifdef DEBUG
        TCHAR _szModule[MAX_PATH];
        ::GetModuleFileName(NULL, _szModule, sizeof(_szModule)/sizeof(TCHAR));
        TraceMsg(TF_EVENT, "%s CModalLoop::WaitHandleWndMessage:: MSUIM.Msg.RpcSendReceive", _szModule);
#endif
        WaitRemoveMessage(g_msgRpcSendReceive, 
                          g_msgRpcSendReceive, 
                          WRM_MARSHALWNDDISPATCH);
        // WaitRemoveMessage(g_msgPrivate, g_msgPrivate, WRM_DISPATCH);
        WaitRemoveMessage(g_msgPrivate, g_msgPrivate, 0);
        if (!_psfn->fInmsgSetFocus)
            WaitRemoveMessage(g_msgSetFocus, g_msgSetFocus, 0);
        if (!_psfn->fInmsgThreadItemChange)
            WaitRemoveMessage(g_msgThreadItemChange, g_msgThreadItemChange, 0);
        if (!_psfn->fInmsgThreadTerminate)
            WaitRemoveMessage(g_msgThreadTerminate, g_msgThreadTerminate, 0);
        WaitRemoveMessage(g_msgLBarModal, g_msgLBarModal, 0);

        WaitRemoveMessage(WM_USER, (UINT)(-1), WRM_OLEWINDOW | WRM_DISPATCH);
    }

    // Get rid of paint message if we can as well -- this makes
    // the screen look so much better.
    if (dwQueueFlags & QS_PAINT)
    {
        WaitRemoveMessage(WM_PAINT, WM_PAINT, WRM_DISPATCH);
    }

}


//--------------------------------------------------------------------------
//
//  MyPeekMessage
//
//--------------------------------------------------------------------------

BOOL CModalLoop::MyPeekMessage(MSG *pMsg, HWND hwnd, UINT min, UINT max, WORD wFlag)
{
    BOOL fRet = PeekMessage(pMsg, hwnd, min, max, wFlag);

    while (fRet)
    {
        if (pMsg->message != WM_QUIT)
        {
            break;
        }

        _wQuitCode = (ULONG)(pMsg->wParam);
        _fQuitReceived = TRUE;

        if (!(wFlag & PM_REMOVE)) 
        {
            // quit message is still on queue so pull it off
            PeekMessage(pMsg, hwnd, WM_QUIT, WM_QUIT, PM_REMOVE | PM_NOYIELD);
        }

        // peek again to see if there is another message
        fRet = PeekMessage(pMsg, hwnd, min, max, wFlag);
    }

    return fRet;
}

//--------------------------------------------------------------------------
//
//  WaitRemoveMessage
//
//--------------------------------------------------------------------------

BOOL CModalLoop::WaitRemoveMessage(UINT uMsgFirst, UINT uMsgLast, DWORD dwFlags)
{
    MSG msg;
    HWND hwnd = NULL;
    BOOL fRet = FALSE;

    if (dwFlags & WRM_MARSHALWND)
    {
        hwnd = _psfn->hwndMarshal;
    }
    if (dwFlags & WRM_OLEWINDOW)
    {
        hwnd = GetOleMainThreadWindow(_psfn);
        if (!hwnd)
            return FALSE;
    }

    while (MyPeekMessage(&msg, hwnd, uMsgFirst, uMsgLast,
                       PM_REMOVE  | PM_NOYIELD))
    {
        if (dwFlags & WRM_DISPATCH)
            DispatchMessage(&msg);

        fRet = TRUE;
    }
    return fRet;
}

//--------------------------------------------------------------------------
//
//  BlockFn
//
//--------------------------------------------------------------------------

HRESULT CModalLoop::BlockFn(CCicEvent *pevent, DWORD dwWaitingThreadId, DWORD &dwWaitFlags)
{
    DWORD dwReason;
    HRESULT hr = S_FALSE;

    //
    // if the event is already set, we don't need to wait.
    //
    dwReason = pevent->EventCheck();
    if (dwReason == WAIT_OBJECT_0)
        return S_OK;

    if (dwReason == WAIT_TIMEOUT)
    {
        //
        // we just check the our target send marshaling message to
        // our thread. If so, just handle it.
        //
        DWORD dwStatus = GetQueueStatus(QS_POSTMESSAGE);
        WORD wNew = (WORD)dwStatus | HIWORD(dwStatus);

        if (wNew & QS_POSTMESSAGE)
        {
            //
            // handle ThreadMarshaling.
            //
            if (WaitRemoveMessage(g_msgThreadMarshal, 
                                  g_msgThreadMarshal, 
                                  WRM_MARSHALWNDDISPATCH))
                return S_FALSE;

            //
            // handle another rpc cal.
            //
#ifdef DEBUG
            TCHAR _szModule[MAX_PATH];
            ::GetModuleFileName(NULL, _szModule, sizeof(_szModule)/sizeof(TCHAR));
            TraceMsg(TF_EVENT, "%s CModalLoop::BlockFn:: MSUIM.Msg.RpcSendReceive", _szModule);
#endif
            if (WaitRemoveMessage(g_msgRpcSendReceive, 
                                  g_msgRpcSendReceive, 
                                  WRM_MARSHALWNDDISPATCH))
                return S_FALSE;

        }

        dwReason = pevent->MsgWait(500, dwWaitFlags);
    }

    if (dwReason == WAIT_OBJECT_0)
    {
        return S_OK;
    }
    else if (dwReason == WAIT_OBJECT_0 + 1)
    {
        //
        // now we handle only new messages.
        //
        DWORD dwStatus = GetQueueStatus(dwWaitFlags);
        WORD wNew = (WORD)dwStatus | HIWORD(dwStatus);

        WaitHandleWndMessages((DWORD)wNew);

        //
        // need to review this later.
        // we want to check the thread was terminated or not.
        //
        goto CheckThread;
    }
    else 
    {
        //
        // Cic#4516
        // 
        //  The target thread seems to be busy. Check the current queue to 
        //  see if we have a message sent. The target thread may be in
        //  SendMessage() and waiting for the reply of this thread.
        // 
        //
        DWORD dwStatus = GetQueueStatus(QS_SENDMESSAGE);
        WORD wNew = HIWORD(dwStatus);
        if (wNew & QS_SENDMESSAGE)
        {
            MSG msg;
            //
            // Maybe PeekMessage is better than ReplyMessage(). 
            //
            PeekMessage(&msg, NULL, 0, 0, 
                        ((IsOnNT5() || IsOn98()) ? PM_QS_SENDMESSAGE : 0) | PM_NOREMOVE);
        }

CheckThread:
        if (!g_timlist.IsThreadId(dwWaitingThreadId))
        {
            TraceMsg(TF_EVENT, "CProxy::SendReceive No Thread");
            hr = MAKE_WIN32(RPC_S_SERVER_UNAVAILABLE);
            goto Exit;
        }
    }
Exit:
    return hr;
}


//+---------------------------------------------------------------------------
//
// FreeStubs
//
//+---------------------------------------------------------------------------

void FreeMarshaledStubs(SYSTHREAD *psfn)
{
    if (psfn->prgStub)
    {
        int nCnt = psfn->prgStub->Count();
        int i = 0;

        for (i = 0; i < nCnt; i++)
        {
            CStub *pStub = psfn->prgStub->Get(i);
            pStub->_fNoRemoveInDtor = TRUE;
            delete pStub;
        }
         
        psfn->prgStub->Clear();
        delete psfn->prgStub;
        psfn->prgStub = NULL;
    }
}

//+---------------------------------------------------------------------------
//
// FreeStubsForThread
//
//+---------------------------------------------------------------------------

void FreeMarshaledStubsForThread(SYSTHREAD *psfn, DWORD dwThread)
{
    if (psfn->prgStub)
    {
        int nCnt = psfn->prgStub->Count();
        int i = 0;

        for (i = nCnt; i > 0; i--)
        {
            CStub *pStub = psfn->prgStub->Get(i - 1);

            if (!pStub)
                continue;

            if (pStub->_dwSrcThreadId == dwThread)
                delete pStub;
        }
         
    }
}



//--------------------------------------------------------------------------
//
//  StubCleanUp
//
//--------------------------------------------------------------------------

void StubCleanUp(DWORD dwStubTime, ULONG ulStubId)
{
    SYSTHREAD *psfn = GetSYSTHREAD();
    CStub *pStub;
    int nRemove;

    if (psfn == NULL)
        return;

    // Assert(psfn->prgStub);
    if (!psfn->prgStub)
        return;

    dbg_CheckStubIds(psfn);

    nRemove = FindStub(psfn->prgStub, ulStubId);
    if (nRemove == -1)
        return;

    pStub = psfn->prgStub->Get(nRemove);

    //
    // check stub created time.
    //
    // Requested Stub ID seems to be destroyed long time ago and
    // newer stub is using same ID.
    //
    if (pStub->_dwStubTime != dwStubTime)
        return;
    
    psfn->prgStub->Remove(nRemove, 1);
    delete pStub;
}

//+---------------------------------------------------------------------------
//
// CicMarshalWndProc
//
//+---------------------------------------------------------------------------

LRESULT CALLBACK CicMarshalWndProc(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    SYSTHREAD *psfn;

    if (uMsg == WM_DESTROY)
    {
        g_timlist.SetMarshalWnd(GetCurrentThreadId(), NULL);
        if (psfn = GetSYSTHREAD())
        {
            Assert(!psfn->hwndMarshal || (psfn->hwndMarshal == hWnd));
            psfn->hwndMarshal = NULL;

            //
            // #507248
            //
            // need to reset the dirty flag.
            //
            if (psfn->plbim)
                psfn->plbim->ResetDirtyUpdate();
        }
    }
    else if ((uMsg == WM_CLOSE) || (uMsg == WM_QUERYENDSESSION))
    {
        if (psfn = GetSYSTHREAD())
        {
            Assert(!psfn->hwndMarshal || (psfn->hwndMarshal == hWnd));
            DestroyWindow(hWnd);
            psfn->hwndMarshal = NULL;
        }
    }
    else if (uMsg == g_msgNuiMgrDirtyUpdate)
    {
        goto CallOnUpdateHandler;
    }
    else if (uMsg == WM_TIMER)
    {
        if (wParam == MARSHALWND_TIMER_UPDATEKANACAPS)
        {
            KillTimer(hWnd, MARSHALWND_TIMER_UPDATEKANACAPS);

            if (psfn = GetSYSTHREAD())
            {
                KanaCapsUpdate(psfn);
            }
        }
        else if (wParam == MARSHALWND_TIMER_NUIMGRDIRTYUPDATE)
        {
            KillTimer(hWnd, MARSHALWND_TIMER_NUIMGRDIRTYUPDATE);

CallOnUpdateHandler:
            if (IsCTFMONBusy() || IsInPopupMenuMode())
            {
TryOnUpdatehandlerAgain:
                SetTimer(hWnd, MARSHALWND_TIMER_NUIMGRDIRTYUPDATE, 100, NULL);
            }
            else 
            {
                if (psfn = GetSYSTHREAD())
                {
                    if (psfn->plbim)
                    {
                        if (psfn->plbim->IsInOnUpdateHandler())
                            goto TryOnUpdatehandlerAgain;

                        psfn->plbim->OnUpdateHandler();
                    }
                }
            }
        }
        else if (wParam == MARSHALWND_TIMER_WAITFORINPUTIDLEFORSETFOCUS)
        {
             KillTimer(hWnd, MARSHALWND_TIMER_WAITFORINPUTIDLEFORSETFOCUS);
             PostThreadMessage(GetCurrentThreadId(), g_msgSetFocus, 0, 0);
        }
    }
    else if (uMsg == g_msgRpcSendReceive)
    {
        HandleSendReceiveMsg((ULONG)wParam, (ULONG)lParam);
    }
#ifdef POINTER_MARSHAL
    else if (uMsg == g_msgPointerMarshal)
    {
        switch (LOWORD(wParam))
        {
            case MP_MARSHALINTERFACE:
                PointerMarshalInterfaceHandler(lParam);
                break;

            case MP_UNMARSHALINTERFACEERROR:
                PointerUnMarshalInterfaceErrorHandler(lParam);
                break;
        }
    }
#endif
    else if (uMsg == g_msgThreadMarshal)
    {
        switch (LOWORD(wParam))
        {
            case MP_MARSHALINTERFACE:
                ThreadMarshalInterfaceHandler((int)lParam);
                break;

            case MP_UNMARSHALINTERFACEERROR:
                ThreadUnMarshalInterfaceErrorHandler((int)lParam);
                break;
        }
    }
    else if (uMsg == g_msgStubCleanUp)
    {
        StubCleanUp((DWORD)wParam, (ULONG)lParam);
    }
    else if (uMsg == g_msgCheckThreadInputIdel)
    {
        DWORD dwThreadId = GetCurrentThreadId();
        CCheckThreadInputIdle event(dwThreadId, (DWORD)lParam);

        if (event.Open())
            event.Set();
    }

    return DefWindowProc(hWnd, uMsg, wParam, lParam);
}


ATOM g_atomMarshalClass = 0;

//+---------------------------------------------------------------------------
//
// EnsureMarshalWnd
//
//+---------------------------------------------------------------------------

HWND EnsureMarshalWnd()
{
    SYSTHREAD *psfn;

    if ((psfn = GetSYSTHREAD()) == NULL)
        return NULL;

    if (!EnsureTIMList(psfn))
        return NULL;
    
    if (IsWindow(psfn->hwndMarshal))
    {
        if (psfn->hwndMarshal != g_timlist.GetMarshalWnd(psfn->dwThreadId))
        {
             g_timlist.SetMarshalWnd(psfn->dwThreadId, psfn->hwndMarshal);
        }
        return psfn->hwndMarshal;
    }

    //
    // we can not support marshaling after process detach.
    //
    if (g_fDllProcessDetached)
        return NULL;

    //
    // Win98 has a bug in FindWindow() with HWND_MESSAGE, so we need to have
    // unique windiw text for each thread.
    //
    char sz[MAX_PATH];
    if (!SetName(sz, ARRAYSIZE(sz), c_szCicMarshalWnd, GetCurrentThreadId()))
        return NULL;

    //
    // We want to hide this window from EnumWindow() API.
    // So we use HWND_MESSAGE for Win98 and NT5.
    //
    // For Beta.
    //
    // Under NT4, we destroy every time the popup window is destroyed in
    // WndProcHook. However we should
    //

    psfn->hwndMarshal = CreateWindowEx(0, 
                                       c_szCicMarshalClass, 
                                       sz,
                                       WS_DISABLED | WS_POPUP, 
                                       0,
                                       0, 
                                       0, 
                                       0, 
                                       IsOn98orNT5() ? HWND_MESSAGE : NULL, 
                                       0,
                                       g_hInst, 
                                       0);

    g_timlist.SetMarshalWnd(psfn->dwThreadId, psfn->hwndMarshal);

    Assert(psfn->hwndMarshal);

    return psfn->hwndMarshal;
}

//+---------------------------------------------------------------------------
//
// RegisterMarshalWndClass
//
//+---------------------------------------------------------------------------


void RegisterMarshalWndClass()
{
    WNDCLASSEX wndclass;

    memset(&wndclass, 0, sizeof(wndclass));
    wndclass.cbSize        = sizeof(wndclass);
    wndclass.style         = CS_HREDRAW | CS_VREDRAW ;
    wndclass.hInstance     = g_hInst;
    wndclass.hCursor       = LoadCursor(NULL, IDC_ARROW);
    wndclass.lpfnWndProc   = CicMarshalWndProc;
    wndclass.lpszClassName = c_szCicMarshalClass;
    g_atomMarshalClass = RegisterClassEx(&wndclass);
}

//////////////////////////////////////////////////////////////////////////////
//
// CThreadMarshalWnd
//
//////////////////////////////////////////////////////////////////////////////

//--------------------------------------------------------------------------
//
//  ctor
//
//--------------------------------------------------------------------------

CThreadMarshalWnd::CThreadMarshalWnd()
{
    _dwThreadId = 0;
    _hwnd = 0;
}

//--------------------------------------------------------------------------
//
//  dtor
//
//--------------------------------------------------------------------------

CThreadMarshalWnd::~CThreadMarshalWnd()
{
}

//--------------------------------------------------------------------------
//
//  Init
//
//--------------------------------------------------------------------------

BOOL CThreadMarshalWnd::Init(DWORD dwThreadId)
{
    HWND hwndTemp = NULL;

    _dwThreadId = dwThreadId;

    //
    // clear _hwnd out first.
    //
    _hwnd = NULL;

    if (hwndTemp = GetThreadMarshalWnd(dwThreadId))
    {
        if (GetWindowThreadProcessId(hwndTemp, NULL) == dwThreadId)
        {
            _hwnd = hwndTemp;
        }
    }

    return _hwnd ? TRUE : FALSE;
}

//+---------------------------------------------------------------------------
//
// PostMarshalThreadMessage
//
//+---------------------------------------------------------------------------

BOOL CThreadMarshalWnd::PostMarshalThreadMessage(UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    Assert(g_atomMarshalClass);
    if (!_hwnd || !IsWindow())
    {
        //
        // Was the window destroyed? 
        //
        TraceMsg(TF_GENERAL, "CThreadmarshalWnd::PostMarshalThreadMessage  marshal window could not be found");
        return FALSE;
    }

#ifdef DEBUG
    TCHAR _szModule[MAX_PATH];
    ::GetModuleFileName(NULL, _szModule, sizeof(_szModule)/sizeof(TCHAR));
    TraceMsg(TF_EVENT, "%s CThreadMarshalWnd::PostMarshalThreadMessage hWnd - %x uMsg - %x wParam - %x lParam - %x", _szModule, _hwnd, uMsg, wParam, lParam);
#endif

    return PostMessage(_hwnd, uMsg, wParam, lParam);
}

//--------------------------------------------------------------------------
//
//  DestroyAll
//
//--------------------------------------------------------------------------

BOOL CThreadMarshalWnd::DestroyAll()
{
    ULONG ulNum;
    SYSTHREAD *psfn = GetSYSTHREAD();
    if (!psfn)
        return FALSE;

    EnsureTIMList(psfn);

    ulNum = g_timlist.GetNum();

    if (ulNum)
    {
        DWORD *pdw = new DWORD[ulNum + 1];
        if (pdw)
        {
            if (g_timlist.GetList(pdw, ulNum+1, &ulNum, 0, 0, FALSE))
            {
                ULONG ul;
                for (ul = 0; ul < ulNum; ul++)
                {
                    if (pdw[ul])
                        DestroyThreadMarshalWnd(pdw[ul]);
                }
            }
            delete [] pdw;
        }
    }

    return TRUE;
}

//+---------------------------------------------------------------------------
//
// DestroyThreadMarshalWnd
//
//+---------------------------------------------------------------------------

BOOL CThreadMarshalWnd::DestroyThreadMarshalWnd(DWORD dwThread)
{
    HWND hwndTemp;

    if (hwndTemp = GetThreadMarshalWnd(dwThread))
    {
        //
        // #425375.
        //
        // SendMessageTimeout() makes shut-down slower.
        // instead, we use SendNotifyMessage() and this is safer since
        // the queue of the thread does not miss WM_CLOSE message for the
        // window.
        //
        SendNotifyMessage(hwndTemp, WM_CLOSE, 0, 0);

    }
    return TRUE;
}

//+---------------------------------------------------------------------------
//
// ClearMarshalWndProc
//
//+---------------------------------------------------------------------------

void CThreadMarshalWnd::ClearMarshalWndProc(DWORD dwProcessId)
{
    ULONG ulNum;

    if (!g_timlist.IsInitialized())
        return;

    ulNum = g_timlist.GetNum();

    //
    // MSCTF.DLL will be unloaded so we may need to make all existing marshal 
    // windows in the current process a ghost. We wanted to destroy them
    // but we missed a chance to destroy them.
    //
    // It may be ok to call DestroyWindow() in process detach since
    // it is known window. But making them a ghost seems to be safer.
    //
    if (ulNum)
    {
        DWORD *pdw = new DWORD[ulNum + 1];
        if (pdw)
        {
            if (g_timlist.GetListInProcess(pdw, &ulNum, dwProcessId))
            {
                ULONG ul;
                for (ul = 0; ul < ulNum; ul++)
                {
                    if (pdw[ul])
                    {
                        HWND hwnd = GetThreadMarshalWnd(pdw[ul]);
                        if (hwnd)
                        {
                            SetWindowLongPtr(hwnd, 
                                             GWLP_WNDPROC,
                                             (LONG_PTR)DefWindowProc);
                        }
                    }
                }
            }
            delete [] pdw;
        }
    }
}

//+---------------------------------------------------------------------------
//
// GetThreadMarshalWnd
//
//+---------------------------------------------------------------------------

HWND CThreadMarshalWnd::GetThreadMarshalWnd(DWORD dwThread)
{
    HWND hwnd = g_timlist.GetMarshalWnd(dwThread);

    if (::IsWindow(hwnd))
    {
         if (dwThread == GetWindowThreadProcessId(hwnd, NULL))
         {
              ATOM atomClass = (ATOM)GetClassLongPtr(hwnd, GCW_ATOM);
              if (g_atomMarshalClass == atomClass)
                  return hwnd;
         }
         g_timlist.SetMarshalWnd(dwThread, NULL);
    }
    return NULL;
}

//+---------------------------------------------------------------------------
//
// EnumThreadWndProc
//
//+---------------------------------------------------------------------------

BOOL CThreadMarshalWnd::EnumThreadWndProc(HWND hwnd, LPARAM lParam)
{
    *(BOOL *)lParam = TRUE;
    return FALSE;
}

//+---------------------------------------------------------------------------
//
// IsThreadWindow
//
//+---------------------------------------------------------------------------

BOOL CThreadMarshalWnd::IsThreadWindow()
{
    BOOL fFound = FALSE;

    EnumThreadWindows(_dwThreadId,
                      EnumThreadWndProc,
                      (LPARAM)&fFound);

    return fFound;
}

//////////////////////////////////////////////////////////////////////////////
//
// CProxy
//
//////////////////////////////////////////////////////////////////////////////

//--------------------------------------------------------------------------
//
//  ctor
//
//--------------------------------------------------------------------------

CProxy::CProxy(SYSTHREAD *psfn) : CSysThreadRef(psfn)
{
    _ulProxyId = 0;
    _ulStubId = (ULONG)(-1);
    _dwStubThreadId = 0;
    _dwSrcThreadId = 0;
    _dwSrcProcessId = 0;
    _cRef = 1;
#ifdef DEBUG
    _fInLoop = FALSE;
#endif
}

//--------------------------------------------------------------------------
//
//  dtor
//
//--------------------------------------------------------------------------

CProxy::~CProxy()
{
#ifdef DEBUG
    Assert(!_fInLoop);
#endif
    if (g_timlist.IsThreadId(_dwStubThreadId))
        _tmw.PostMarshalThreadMessage(g_msgStubCleanUp, _dwStubTime, _ulStubId);
}

ULONG CProxy::InternalAddRef()
{
    _cRef++;
    return _cRef;
}

ULONG CProxy::InternalRelease()
{
    _cRef--;
    if (!_cRef)
    {
        delete this;
        return 0;
    }
    return _cRef;
}


//--------------------------------------------------------------------------
//
//  Init
//
//--------------------------------------------------------------------------

void CProxy::Init(REFIID riid, ULONG ulProxyId, ULONG ulStubId, DWORD dwStubTime, DWORD dwStubThreadId, DWORD dwCurThreadId, DWORD dwCurProcessId)
{
    _iid = riid;
    _ulProxyId = ulProxyId;
    _ulStubId = ulStubId;
    _dwStubTime = dwStubTime;
    _dwStubThreadId = dwStubThreadId;
    _dwSrcThreadId = dwCurThreadId;
    _dwSrcProcessId = dwCurProcessId;
    _tmw.Init(_dwStubThreadId);
}


//--------------------------------------------------------------------------
//
//  SendReceive
//
//--------------------------------------------------------------------------

HRESULT CProxy::SendReceive(MARSHALMSG *pMsg, ULONG ulBlockId)
{
    HRESULT hr = E_FAIL;
    CCicTimer timer(MARSHALTIMEOUT, FALSE);
    DWORD dwWaitFlags;
    DWORD dwThreadId = _dwStubThreadId;
    CModalLoop modalloop(_psfn);
    DWORD dwSrcThreadId;
    TL_THREADINFO *pti;
    DWORD dwPrevWaitingThread;

#ifdef DEBUG
    TCHAR _szModule[MAX_PATH];
    ::GetModuleFileName(NULL, _szModule, sizeof(_szModule)/sizeof(TCHAR));
    TraceMsg(TF_EVENT, "%s CProxy::SendReceive Start _ThreadId - %x _uStubId - %x, msg size - %x", _szModule, _dwStubThreadId, _ulStubId, pMsg->cbSize);
#endif

    pti = g_timlist.IsThreadId(_dwStubThreadId);
    if (!pti)
    {
        TraceMsg(TF_EVENT, "CProxy::SendReceive Invalid ThreadId %x", _dwStubThreadId);
        return E_FAIL;
    }

    Assert(pti->dwThreadId ==  _dwStubThreadId);
    if (pti->dwFlags & TLF_INSFW)
    {
        TraceMsg(TF_EVENT, "CProxy::SendReceive  Thread is in SetForegroundWindow %08x", _dwStubThreadId);
        return E_FAIL;
    }


    //
    // for Win9x, we can identify the event and shared block by ulBlockId.
    //
    if (IsOnNT())
        dwSrcThreadId = pMsg->dwSrcThreadId;
    else
        dwSrcThreadId = WIN9X_SRCTHREADID;


    //
    // Event for marshaling
    //
    CSendReceiveEvent event(dwSrcThreadId, ulBlockId);
    if (!event.Create(NULL))
        return E_FAIL;

    CSendReceiveConnectionEvent eventc(dwSrcThreadId, ulBlockId);
    BOOL fSendReceiveConnection = FALSE;

    if (!eventc.Create(NULL))
        return E_FAIL;


    // Win98 QS_EVENT hack.
    // Win98's Event QueueItem could cause inter thread sendmessage
    // We want to clean up Event QueueItem before Marshaling happens.
    //
    // because CTFMON.EXE may call AttatchThreadInput() and this event
    // could be handled in CTFMON's thread and this make the event queue item 
    // to do inter thread SendMessage.
    //
    if (!IsOnNT())
    {
        MSG msg;
        PeekMessage(&msg, NULL, 0, 0, PM_NOREMOVE | PM_NOYIELD);
    }

    //
    // save previous waiting thread.
    //
    if (_psfn->pti)
    {
        dwPrevWaitingThread = _psfn->pti->dwMarshalWaitingThread;
        _psfn->pti->dwMarshalWaitingThread = _dwStubThreadId;
    }

    //
    // update marshal window handle from PTI.
    // the window handle in _tmw may be destroyed on NT4.
    //
    _tmw.SetMarshalWindow(pti->hwndMarshal);

    if (!_tmw.PostMarshalThreadMessage(g_msgRpcSendReceive,
                                       dwSrcThreadId,
                                       ulBlockId))
    {
         TraceMsg(TF_EVENT, "CProxy::SendReceive PostThreadMessage failed");
         goto Exit;
    }

#ifdef DEBUG
    _fInLoop = TRUE;
#endif
    timer.Start();
    dwWaitFlags = QS_DEFAULTWAITFLAG;
    while (!timer.IsTimerAtZero())
    {
        if (!fSendReceiveConnection &&
             timer.IsTimerPass(DEFAULTMARSHALCONNECTIONTIMEOUT))
        { 
            DWORD dwReason = eventc.EventCheck();
            if (dwReason != WAIT_OBJECT_0)
            {
                hr = E_FAIL;
                break;
            }
            fSendReceiveConnection = TRUE;
        }

        hr = modalloop.BlockFn(&event, dwThreadId, dwWaitFlags);
       
        if (hr == S_OK)
            goto EventOK;

        if (FAILED(hr))
            break;

        if (!_tmw.IsWindow())
        {
            hr = E_FAIL;
            break;
        }

        if (!_tmw.IsThreadWindow())
        {
            CThreadMarshalWnd::DestroyThreadMarshalWnd(_dwStubThreadId);
            hr = E_FAIL;
            break;
        }

    }

#ifdef DEBUG
    TraceMsg(TF_EVENT, "%s CProxy::SendReceive Time Out", _szModule);
#endif
    goto Exit;

EventOK:
#ifdef DEBUG
    TraceMsg(TF_EVENT, "%s CProxy::SendReceive OK", _szModule);
#endif
    hr = S_OK;

Exit:
#ifdef DEBUG
    _fInLoop = FALSE;
#endif

    //
    // restore previous waiting thread.
    //
    if (_psfn->pti)
        _psfn->pti->dwMarshalWaitingThread = dwPrevWaitingThread;

    return hr;
}


//--------------------------------------------------------------------------
//
//  proxy_Param
//
//--------------------------------------------------------------------------

HRESULT CProxy::proxy_Param(ULONG ulMethodId, ULONG ulParamNum, CPROXY_PARAM *pProxyParam)
{
    HRESULT hr = E_FAIL;
    ULONG i;
    MARSHALMSG *pMsgMap = NULL;
    ULONG cbBufSize;
    CMarshalParamCreator cparam;
    ULONG ulBlockId;
    HRESULT hrMarshalOutParam = S_OK;
    ULONG cbPadMemSize = 0;

    CSharedHeap *psheap = EnsureSharedHeap(_psfn);
    if (!psheap)
        return hr;

    InternalAddRef();

TryAgain:
    cbBufSize = sizeof(MARSHALMSG) + ulParamNum * sizeof(MARSHALPARAM);
    LENGTH_ALIGN(cbBufSize, CIC_ALIGNMENT);
    cbBufSize += cbPadMemSize;
    LENGTH_ALIGN(cbBufSize, CIC_ALIGNMENT);

    for (i = 0; i < ulParamNum; i++)
    {
        ULONG cbUnitSize = sizeof(ULONG_PTR);
        LENGTH_ALIGN(cbUnitSize, CIC_ALIGNMENT);

        if (pProxyParam[i].dwFlags & MPARAM_INTERFACE)
           cbUnitSize +=  sizeof(MARSHALINTERFACEPARAM);
        else if (pProxyParam[i].dwFlags & MPARAM_HICON)
        {
           if (!(pProxyParam[i].dwFlags & MPARAM_IN))
           {
               cbUnitSize +=  0x2000;
           }
           else
           {
               Assert(pProxyParam[i].ulCount == 1);
               HICON *picon = (HICON *)pProxyParam[i].pv;
               cbUnitSize += Cic_HICON_UserSize(picon);
           }
        }
        else if (pProxyParam[i].dwFlags & MPARAM_HBITMAP)
        {
           if (!(pProxyParam[i].dwFlags & MPARAM_IN))
           {
               cbUnitSize +=  0x1000;
           }
           else
           {
               Assert(pProxyParam[i].ulCount == 1);
               HBITMAP *pbmp = (HBITMAP *)pProxyParam[i].pv;
               cbUnitSize += Cic_HBITMAP_UserSize(pbmp);
           }
        }
        else if (pProxyParam[i].dwFlags & MPARAM_BSTR)
           cbUnitSize +=  0x1000;
        // else if (pProxyParam[i].dwFlags & MPARAM_POINTER)
        //    cbUnitSize +=  0x1000;
        else if (pProxyParam[i].dwFlags & MPARAM_TF_LBBALLOONINFO)
           cbUnitSize +=  0x1000;
        else
           cbUnitSize += pProxyParam[i].cbUnitSize;

        LENGTH_ALIGN(cbUnitSize, CIC_ALIGNMENT);
        cbBufSize += (cbUnitSize * pProxyParam[i].ulCount);
        LENGTH_ALIGN(cbBufSize, CIC_ALIGNMENT);
    }

    if (!psheap->GetBlock()->GetMutex()->Enter())
    {
        hr = E_FAIL;
        goto Exit;
    }

    pMsgMap = (MARSHALMSG *)psheap->Alloc(cbBufSize);

    if (!pMsgMap)
    {
        hr = E_OUTOFMEMORY;
        goto FinishParamCreation;
    }

    ulBlockId = psheap->GetBlockId(pMsgMap);

    cparam.Set(pMsgMap, cbBufSize);
    cparam.Init(_dwSrcThreadId, 
                _dwSrcProcessId, 
                _iid, 
                ulMethodId, 
                ulParamNum, 
                _ulStubId,
                _dwStubTime);

    hr = S_OK;

    for (i = 0; i < ulParamNum; i++)
    {
        if (!(pProxyParam[i].dwFlags & MPARAM_IN))
        {
            hr = cparam.Add(pProxyParam[i].GetBufSize(),
                            pProxyParam[i].dwFlags,
                            NULL);
            if (FAILED(hr))
                goto FinishParamCreation;

            continue;
        }

        if (pProxyParam[i].dwFlags & MPARAM_INTERFACE)
        {
            if (pProxyParam[i].ulCount == 1)
            {
                MARSHALINTERFACEPARAM miparam;
                if ((IUnknown **)pProxyParam[i].pv &&
                    (*(IUnknown **)pProxyParam[i].pv))
                {
                    CicCoMarshalInterface(*pProxyParam[i].piid, 
                                      *(IUnknown **)pProxyParam[i].pv,
                                      &miparam.ulStubId,
                                      &miparam.dwStubTime,
                                      _dwStubThreadId);
                    miparam.fNULLPointer = FALSE;
                    miparam.fNULLStack = FALSE;
                }
                else
                {
                    miparam.ulStubId = 0;
                    miparam.fNULLPointer = TRUE;
                    if (!(IUnknown **)pProxyParam[i].pv)
                        miparam.fNULLStack = TRUE;
                    else
                        miparam.fNULLStack = FALSE;
                }
                hr = cparam.Add(sizeof(miparam),
                                pProxyParam[i].dwFlags,
                                &miparam);
            }
            else
            {
                MARSHALINTERFACEPARAM *pmiparam;
                pmiparam = new MARSHALINTERFACEPARAM[pProxyParam[i].ulCount];
                if (pmiparam)
                {
                    ULONG ul;
                    for (ul = 0; ul < pProxyParam[i].ulCount; ul++)
                    {
                        IUnknown **ppunk =  (IUnknown **)pProxyParam[i].pv;
                        if (ppunk && ppunk[ul])
                        {
                            CicCoMarshalInterface(*pProxyParam[i].piid, 
                                                  ppunk[ul],
                                                  &pmiparam[ul].ulStubId,
                                                  &pmiparam[ul].dwStubTime,
                                                  _dwStubThreadId);
                            pmiparam[ul].fNULLPointer = FALSE;
                            pmiparam[ul].fNULLStack = FALSE;
                        }
                        else
                        {
                            pmiparam[ul].ulStubId = 0;
                            pmiparam[ul].fNULLPointer = TRUE;
                            if (!ppunk)
                                pmiparam[ul].fNULLStack = TRUE;
                            else
                                pmiparam[ul].fNULLStack = FALSE;
                        }
                    }

                    hr = cparam.Add(sizeof(*pmiparam) * pProxyParam[i].ulCount,
                                    pProxyParam[i].dwFlags,
                                   pmiparam);
                    delete [] pmiparam;
                }
            }
        }
        else if (pProxyParam[i].dwFlags & MPARAM_POINTER)
        {
            hr = cparam.Add(pProxyParam[i].GetBufSize(),
                            pProxyParam[i].dwFlags,
                            pProxyParam[i].pv);
        }
        else if (pProxyParam[i].dwFlags & MPARAM_ULONG)
        {
            Assert(pProxyParam[i].ulCount == 1);
            hr = cparam.Add(pProxyParam[i].cbUnitSize,
                            pProxyParam[i].dwFlags,
                            &pProxyParam[i].ul);
        }
        else if (pProxyParam[i].dwFlags & MPARAM_BSTR)
        {
            Assert(pProxyParam[i].ulCount == 1);
            hr = cparam.Add(pProxyParam[i].cbUnitSize,
                            pProxyParam[i].dwFlags,
                            pProxyParam[i].pv);
        }
        else if (pProxyParam[i].dwFlags & MPARAM_STRUCT)
        {
            hr = cparam.Add(pProxyParam[i].GetBufSize(),
                            pProxyParam[i].dwFlags,
                            pProxyParam[i].pv);
        }
        else if (pProxyParam[i].dwFlags & MPARAM_HICON)
        {
            Assert(pProxyParam[i].ulCount == 1);
            HICON *picon = (HICON *)pProxyParam[i].pv;
            ULONG cbSize = Cic_HICON_UserSize(picon);
            BYTE *pBufOrg = NULL;
            BYTE *pBuf = NULL;
            BYTE *pBufEnd = NULL;

            if (cbSize)
            {
                pBufOrg = (BYTE *)cicMemAlloc(cbSize + CIC_ALIGNMENT + 1);
                pBuf = pBufOrg;
                POINTER_ALIGN( pBuf, CIC_ALIGNMENT);
                pBufEnd = pBuf + cbSize;
            }

            if (pBuf && Cic_HICON_UserMarshal(pBuf, pBufEnd, picon))
            {
                hr = cparam.Add(cbSize,
                                pProxyParam[i].dwFlags,
                                pBuf);
                Cic_HICON_UserFree(picon);
            }
            else
            {
                hr = cparam.Add(0,
                                pProxyParam[i].dwFlags,
                                NULL);
            }

            if (pBufOrg)
                cicMemFree(pBufOrg);
        }
        else if (pProxyParam[i].dwFlags & MPARAM_HBITMAP)
        {
            Assert(pProxyParam[i].ulCount == 1);
            HBITMAP *pbmp = (HBITMAP *)pProxyParam[i].pv;
            ULONG cbSize = Cic_HBITMAP_UserSize(pbmp);
            BYTE *pBufOrg = NULL;
            BYTE *pBuf = NULL;
            BYTE *pBufEnd = NULL;

            if (cbSize)
            {
                pBufOrg = (BYTE *)cicMemAlloc(cbSize + CIC_ALIGNMENT + 1);
                pBuf = pBufOrg;
                POINTER_ALIGN( pBuf, CIC_ALIGNMENT);
                pBufEnd = pBuf + cbSize;
            }

            if (pBuf && Cic_HBITMAP_UserMarshal(pBuf, pBufEnd, pbmp))
            {
                hr = cparam.Add(cbSize,
                                pProxyParam[i].dwFlags,
                                pBuf);
                Cic_HBITMAP_UserFree(pbmp);
            }
            else
            {
                hr = cparam.Add(0,
                                pProxyParam[i].dwFlags,
                                NULL);
            }
            if (pBufOrg)
                cicMemFree(pBufOrg);
        }
        else if (pProxyParam[i].dwFlags & MPARAM_TF_LBBALLOONINFO)
        {
            Assert(pProxyParam[i].ulCount == 1);
            TF_LBBALLOONINFO *pInfo = (TF_LBBALLOONINFO *)pProxyParam[i].pv;
            BYTE *pBufOrg = NULL;
            BYTE *pBuf = NULL;
            ULONG cbSize = Cic_TF_LBBALLOONINFO_UserSize(pInfo);

            if (cbSize)
            {
                pBufOrg = (BYTE *)cicMemAlloc(cbSize + CIC_ALIGNMENT + 1);
                pBuf = pBufOrg;
                POINTER_ALIGN( pBuf, CIC_ALIGNMENT);
            }

            if (pBuf && Cic_TF_LBBALLOONINFO_UserMarshal(pBuf, pInfo))
            {
                hr = cparam.Add(cbSize,
                                pProxyParam[i].dwFlags,
                                pBuf);
                Cic_TF_LBBALLOONINFO_UserFree(pInfo);
            }
            else
            {
                hr = cparam.Add(0,
                                pProxyParam[i].dwFlags,
                                NULL);
            }
            if (pBufOrg)
                cicMemFree(pBufOrg);
            
        }
        else 
        {
            Assert(0);
            hr = E_FAIL;
        }

        if (FAILED(hr))
        {
            Assert(0);
            goto FinishParamCreation;
        }
    }

FinishParamCreation:

    psheap->GetBlock()->GetMutex()->Leave();

    if (FAILED(hr))
    {
        Assert(0);
        goto Exit;
    }

    hr = cparam.SendReceive(this, ulBlockId);
    if (FAILED(hr))
        goto Exit;

    hrMarshalOutParam = pMsgMap->hrMarshalOutParam;
    if (hrMarshalOutParam != S_OK)
    {
        hr = E_FAIL;
        goto Exit;
    }

    if (!psheap->GetBlock()->GetMutex()->Enter())
    {
        hr = E_FAIL;
        goto Exit;
    }

    for (i = 0; i < ulParamNum; i++)
    {
        MARSHALPARAM *pParam;

        if (!(pProxyParam[i].dwFlags & MPARAM_OUT))
            continue;

        if (!pProxyParam[i].pv)
            continue;

        pParam = cparam.GetMarshalParam(i);
        hr = S_OK;

        if (pProxyParam[i].dwFlags & MPARAM_POINTER)
        {
             if (pParam->cbBufSize)
             {
                 memcpy(pProxyParam[i].pv, 
                        ParamToBufferPointer(pParam), 
                        pProxyParam[i].GetBufSize());
             }
             else
             {
                 memset(pProxyParam[i].pv, 0, pProxyParam[i].GetBufSize());
             }
        }
        else if (pProxyParam[i].dwFlags & MPARAM_INTERFACE)
        {
             MARSHALMSG *pMsg = cparam.Get();
             MARSHALINTERFACEPARAM *pmiparam = (MARSHALINTERFACEPARAM *)ParamToBufferPointer(pParam);
             ULONG ul;
             IUnknown **ppunk = (IUnknown **)pProxyParam[i].pv;
             if (ppunk)
             {
                 for (ul = 0; ul < pProxyParam[i].ulCount; ul++)
                 {
                     if (pmiparam->fNULLPointer)
                     {
                         *ppunk = NULL;

                     }
                     else
                     {
                         hr = CicCoUnmarshalInterface(*pProxyParam[i].piid,
                                                      pMsg->dwSrcThreadId, 
                                                      pmiparam->ulStubId,
                                                      pmiparam->dwStubTime,
                                                      (void **)ppunk);
                     }
                     ppunk++;
                     pmiparam++;
                 }
             }
        }
        else if (pProxyParam[i].dwFlags & MPARAM_BSTR)
        {
             Assert(pProxyParam[i].ulCount == 1);
             if (pParam->cbBufSize)
             {
                 void *pv = ParamToBufferPointer(pParam);
                 if ((*(BSTR *)pProxyParam[i].pv = SysAllocString((BSTR)pv)) == NULL)
                 {
                     hr = E_OUTOFMEMORY;
                 }
             }
             else
             {
                 *(BSTR *)pProxyParam[i].pv = NULL;
             }
        }
        else if (pProxyParam[i].dwFlags & MPARAM_STRUCT)
        {
             if (pParam->cbBufSize)
             {
                 memcpy(pProxyParam[i].pv, 
                        ParamToBufferPointer(pParam), 
                        pProxyParam[i].GetBufSize());
             }
             else
             {
                 memset(pProxyParam[i].pv, 0, pProxyParam[i].GetBufSize());
             }
        }
        else if (pProxyParam[i].dwFlags & MPARAM_HICON)
        {
             Assert(pProxyParam[i].ulCount == 1);
             HICON hicon = NULL;
             if (pParam->cbBufSize)
             {
                  BYTE *pBuf = (BYTE *)ParamToBufferPointer(pParam);
                  Cic_HICON_UserUnmarshal(pBuf, &hicon);
             }
             *(HICON *)pProxyParam[i].pv = hicon;
        }
        else if (pProxyParam[i].dwFlags & MPARAM_HBITMAP)
        {
             Assert(pProxyParam[i].ulCount == 1);
             HBITMAP hbmp = NULL;
             if (pParam->cbBufSize)
             {
                  BYTE *pBuf = (BYTE *)ParamToBufferPointer(pParam);
                  Cic_HBITMAP_UserUnmarshal(pBuf, &hbmp);
             }
             *(HBITMAP *)pProxyParam[i].pv = hbmp;
        }
        else if (pProxyParam[i].dwFlags & MPARAM_TF_LBBALLOONINFO)
        {
             Assert(pProxyParam[i].ulCount == 1);
             if (pParam->cbBufSize)
             {
                  BYTE *pBuf = (BYTE *)ParamToBufferPointer(pParam);
                  hr = Cic_TF_LBBALLOONINFO_UserUnmarshal(pBuf, (TF_LBBALLOONINFO *)pProxyParam[i].pv);
             }
        }
        else
        {
             Assert(0);
             hr = E_FAIL;
        }

        if (FAILED(hr))
             break;
    }

    if (SUCCEEDED(hr))
        hr = cparam.GetHresult();

    psheap->GetBlock()->GetMutex()->Leave();

Exit:
    if (pMsgMap)
        psheap->Free(pMsgMap);

    if ((cbPadMemSize == 0) && (hrMarshalOutParam == E_OUTOFMEMORY))
    {
        cbPadMemSize = cbBufSize * 2;
        cparam.Clear();
        goto TryAgain;
    }

    InternalRelease();
    return hr;
}


//////////////////////////////////////////////////////////////////////////////
//
// CStub
//
//////////////////////////////////////////////////////////////////////////////

//--------------------------------------------------------------------------
//
//  ctor
//
//--------------------------------------------------------------------------

CStub::CStub()
{
    _pfm = NULL;
    _fNoRemoveInDtor = FALSE;
    _cRef = 1;
}

//--------------------------------------------------------------------------
//
//  dtor
//
//--------------------------------------------------------------------------

CStub::~CStub()  
{
    //
    // #489905
    //
    // we can not call sink anymore after DLL_PROCESS_DETACH.
    //
    if (!DllShutdownInProgress())
    {
        if (_punk && !IsBadReadPtr(_punk, 1))
        {
            _try {
                _punk->Release();
                _punk = NULL;
            }     
            _except(1) 
            {
                //
                // Tips may not do DllAddRef() for LangBarItems so 
                // _punk could be bad pointer. We need to have a 
                // way to clean up CStub.
                //
                ; // TraceMsg(TF_GENERAL, "CStub punk is gone.");
            }
        }
    }

    ClearFileMap();

    if (_fNoRemoveInDtor)
    {
        //
        // we're in FreeMarshaledStubs() so we don't have to
        // remove itself. GetSYSTEMTHREAD() may not work when it is called
        // in UninitProcess().
        //
        return;
    }

    SYSTHREAD *psfn = GetSYSTHREAD();
    Assert(psfn != NULL && psfn->prgStub != NULL);
    if (psfn == NULL || psfn->prgStub == NULL)
        return;

    dbg_CheckStubIds(psfn);

    int i;
    int nCnt = psfn->prgStub->Count();
    for (i = 0; i < nCnt; i++)
    {
        if (this == psfn->prgStub->Get(i))
        {
            psfn->prgStub->Remove(i, 1);
            break;
        }
    }
}

//--------------------------------------------------------------------------
//
//  _AddRef
//
//--------------------------------------------------------------------------

ULONG CStub::_AddRef()
{
    _cRef++;
    return _cRef;
}


//--------------------------------------------------------------------------
//
//  _Release
//
//--------------------------------------------------------------------------

ULONG CStub::_Release()
{
    _cRef--;
    if (!_cRef)
    {
        delete this;
        return 0;
    }
    return _cRef;
}

//--------------------------------------------------------------------------
//
//  stub_OutParam
//
//--------------------------------------------------------------------------

HRESULT CStub::stub_OutParam(CStub *_this, MARSHALMSG *pMsg, ULONG ulMethodId, ULONG ulParamNum, CPROXY_PARAM *pProxyParam, CSharedBlock *psb)
{
    ULONG i;
    HRESULT hr = E_FAIL;

    CMarshalParamCreator cparam;

    if (!psb->GetMutex()->Enter())
    {
        Assert(0);
        return E_FAIL;
    }

    if (!CSharedHeap::IsValidBlock(psb, pMsg))
    {
        Assert(0);
        goto Exit;
    }

    if (!IsEqualIID(pMsg->iid, _this->_iid))
    {
        Assert(0);
        goto Exit;
    }

    if (pMsg->ulMethodId != ulMethodId)
    {
        Assert(0);
        goto Exit;
    }

    if (pMsg->ulParamNum != ulParamNum)
    {
        Assert(0);
        goto Exit;
    }

    if (pMsg->ulStubId != _this->_ulStubId)
    {
        Assert(0);
        goto Exit;
    }

    if (pMsg->dwStubTime != _this->_dwStubTime)
    {
        Assert(0);
        goto Exit;
    }
        
    hr = S_OK;

    cparam.Set(pMsg, pMsg->cbBufSize);
    cparam.Init(_this->_dwStubThreadId, 
                _this->_dwStubProcessId, 
                _this->_iid, 
                ulMethodId, 
                ulParamNum, 
                _this->_ulStubId,
                _this->_dwStubTime);

    for (i = 0; i < ulParamNum; i++)
    {
        if (!(pProxyParam[i].dwFlags & MPARAM_OUT))
        {
            cparam.Add(0, pProxyParam[i].dwFlags, NULL);
            continue;
        }

        if (!pProxyParam[i].pv && !(pProxyParam[i].dwFlags & MPARAM_INTERFACE))
        {
            cparam.Add(0, pProxyParam[i].dwFlags, NULL);
            continue;
        }

        if (pProxyParam[i].dwFlags & MPARAM_INTERFACE)
        {
#if 0
            MARSHALINTERFACEPARAM miparam;

            if (pProxyParam[i].pv)
            {
                CicCoMarshalInterface(*pProxyParam[i].piid, 
                                  *(IUnknown **)pProxyParam[i].pv,
                                  &miparam.ulStubId,
                                  &miparam.dwStubTime,
                                  _this->_dwSrcThreadId);
                miparam.fNULLPointer = FALSE;
            }
            else
            {
                miparam.ulStubId = 0;
                miparam.fNULLPointer = TRUE;
            }
            hr = cparam.Add(sizeof(miparam),
                       pProxyParam[i].dwFlags,
                       &miparam);

#else
            if (pProxyParam[i].ulCount == 1)
            {
                MARSHALINTERFACEPARAM miparam;
                if ((IUnknown **)pProxyParam[i].pv &&
                    (*(IUnknown **)pProxyParam[i].pv))
                {
                    CicCoMarshalInterface(*pProxyParam[i].piid, 
                                      *(IUnknown **)pProxyParam[i].pv,
                                      &miparam.ulStubId,
                                      &miparam.dwStubTime,
                                      _this->_dwSrcThreadId);
                    miparam.fNULLPointer = FALSE;
                    miparam.fNULLStack = FALSE;
                }
                else
                {
                    miparam.ulStubId = 0;
                    miparam.fNULLPointer = TRUE;
                    if (!(IUnknown **)pProxyParam[i].pv)
                        miparam.fNULLStack = TRUE;
                    else
                        miparam.fNULLStack = FALSE;
                }
                hr = cparam.Add(sizeof(miparam),
                           pProxyParam[i].dwFlags,
                           &miparam);
            }
            else
            {
                MARSHALINTERFACEPARAM *pmiparam;
                pmiparam = new MARSHALINTERFACEPARAM[pProxyParam[i].ulCount];
                if (pmiparam)
                {
                    ULONG ul;
                    for (ul = 0; ul < pProxyParam[i].ulCount; ul++)
                    {
                        IUnknown **ppunk =  (IUnknown **)pProxyParam[i].pv;
                        if (ppunk && ppunk[ul])
                        {
                            CicCoMarshalInterface(*pProxyParam[i].piid, 
                                                  ppunk[ul],
                                                  &pmiparam[ul].ulStubId,
                                                  &pmiparam[ul].dwStubTime,
                                                  _this->_dwSrcThreadId);
                            pmiparam[ul].fNULLPointer = FALSE;
                            pmiparam[ul].fNULLStack = FALSE;
                        }
                        else
                        {
                            pmiparam[ul].ulStubId = 0;
                            pmiparam[ul].fNULLPointer = TRUE;
                            if (!ppunk)
                                pmiparam[ul].fNULLStack = TRUE;
                            else
                                pmiparam[ul].fNULLStack = FALSE;
                        }
                    }

                    hr = cparam.Add(sizeof(*pmiparam) * pProxyParam[i].ulCount,
                               pProxyParam[i].dwFlags,
                               pmiparam);
                    delete [] pmiparam;
                }
            }
#endif
        }
        else if (pProxyParam[i].dwFlags & MPARAM_POINTER)
        {
            hr = cparam.Add(pProxyParam[i].GetBufSize(),
                       pProxyParam[i].dwFlags,
                       pProxyParam[i].pv);
        }
        else if (pProxyParam[i].dwFlags & MPARAM_ULONG)
        {
            Assert(pProxyParam[i].ulCount == 1);
            hr = cparam.Add(pProxyParam[i].cbUnitSize,
                       pProxyParam[i].dwFlags,
                       &pProxyParam[i].ul);
        }
        else if (pProxyParam[i].dwFlags & MPARAM_BSTR)
        {
            Assert(pProxyParam[i].ulCount == 1);
            if (pProxyParam[i].pv)
            {
                hr = cparam.Add(SysStringByteLen((BSTR)pProxyParam[i].pv) + 2, 
                           pProxyParam[i].dwFlags,
                           pProxyParam[i].pv);
                SysFreeString((BSTR)pProxyParam[i].pv);
            }
            else
            {
                hr = cparam.Add(0,
                           pProxyParam[i].dwFlags,
                           NULL);
            }
            
        }
        else if (pProxyParam[i].dwFlags & MPARAM_HICON)
        {
            Assert(pProxyParam[i].ulCount == 1);
            HICON *picon = (HICON *)pProxyParam[i].pv;
            ULONG cbSize = Cic_HICON_UserSize(picon);
            BYTE *pBuf = NULL;
            BYTE *pBufOrg = NULL;
            BYTE *pBufEnd = NULL;

            if (cbSize)
            {
                pBufOrg = (BYTE *)cicMemAlloc(cbSize + CIC_ALIGNMENT + 1);
                pBuf = pBufOrg;
                POINTER_ALIGN( pBuf, CIC_ALIGNMENT);
                pBufEnd = pBuf + cbSize;
            }

            if (pBuf && Cic_HICON_UserMarshal(pBuf, pBufEnd, picon))
            {
                hr = cparam.Add(cbSize,
                           pProxyParam[i].dwFlags,
                           pBuf);
                Cic_HICON_UserFree(picon);
            }
            else
            {
                hr = cparam.Add(0,
                           pProxyParam[i].dwFlags,
                           NULL);
            }
            if (pBufOrg)
                cicMemFree(pBufOrg);
        }
        else if (pProxyParam[i].dwFlags & MPARAM_HBITMAP)
        {
            Assert(pProxyParam[i].ulCount == 1);
            HBITMAP *pbmp = (HBITMAP *)pProxyParam[i].pv;
            ULONG cbSize = Cic_HBITMAP_UserSize(pbmp);
            BYTE *pBuf = NULL;
            BYTE *pBufOrg = NULL;
            BYTE *pBufEnd = NULL;

            if (cbSize)
            {
                pBufOrg = (BYTE *)cicMemAlloc(cbSize + CIC_ALIGNMENT + 1);
                pBuf = pBufOrg;
                POINTER_ALIGN( pBuf, CIC_ALIGNMENT);
                pBufEnd = pBuf + cbSize;
            }

            if (pBuf && Cic_HBITMAP_UserMarshal(pBuf, pBufEnd, pbmp))
            {
                hr = cparam.Add(cbSize,
                           pProxyParam[i].dwFlags,
                           pBuf);
                Cic_HBITMAP_UserFree(pbmp);
            }
            else
            {
                hr = cparam.Add(0,
                           pProxyParam[i].dwFlags,
                           NULL);
            }
            if (pBufOrg)
                cicMemFree(pBufOrg);
        }
        else if (pProxyParam[i].dwFlags & MPARAM_TF_LBBALLOONINFO)
        {
            Assert(pProxyParam[i].ulCount == 1);
            TF_LBBALLOONINFO *pInfo = (TF_LBBALLOONINFO *)pProxyParam[i].pv;
            ULONG cbSize = Cic_TF_LBBALLOONINFO_UserSize(pInfo);
            BYTE *pBuf = NULL;
            BYTE *pBufOrg = NULL;

            if (cbSize)
            {
                pBufOrg = (BYTE *)cicMemAlloc(cbSize + CIC_ALIGNMENT + 1);
                pBuf = pBufOrg;
                POINTER_ALIGN( pBuf, CIC_ALIGNMENT);
            }

            if (pBuf && Cic_TF_LBBALLOONINFO_UserMarshal(pBuf, pInfo))
            {
                hr = cparam.Add(cbSize,
                           pProxyParam[i].dwFlags,
                           pBuf);
                Cic_TF_LBBALLOONINFO_UserFree(pInfo);
            }
            else
            {
                hr = cparam.Add(0,
                           pProxyParam[i].dwFlags,
                           NULL);
            }
            if (pBufOrg)
                cicMemFree(pBufOrg);
        }
        else 
            Assert(0);

 
        if (hr != S_OK)
        {
            break;
        }
    }
    
Exit:
    pMsg->hrMarshalOutParam = hr;

    psb->GetMutex()->Leave();

    return hr;
}

//////////////////////////////////////////////////////////////////////////////
//
// TF_CCheckThreadInputIdle
//
//////////////////////////////////////////////////////////////////////////////

extern "C" DWORD WINAPI TF_CheckThreadInputIdle(DWORD dwThreadId, DWORD dwTimeOut)
{
    if (dwThreadId == GetCurrentThreadId())
        return 0;

    HWND hwndTemp = CThreadMarshalWnd::GetThreadMarshalWnd(dwThreadId);
    if (!hwndTemp)
    {
        return WAIT_FAILED;
    }


    DWORD dwTime = GetTickCount();
    CCheckThreadInputIdle event(dwThreadId, dwTime);
    if (!event.Create(NULL))
    {
        Assert(0);
        return WAIT_FAILED;
    }

    PostMessage(hwndTemp, g_msgCheckThreadInputIdel, 0, (LPARAM)dwTime);
    
    DWORD dwReason = event.EventCheck();
    if (dwReason == WAIT_OBJECT_0)
        return 0;

    if (event.Wait(dwTimeOut))
        return 0;

    return WAIT_TIMEOUT;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\ctf\uim\lbaddin.cpp ===
//
// lbaddin.cpp
//

#include "private.h"
#include "globals.h"
#include "ctflbui.h"
#include "regsvr.h"
#include "cregkey.h"
#include "tim.h"
#include "lbaddin.h"

const TCHAR c_szLangBarAddInKey[] =  TEXT("SOFTWARE\\Microsoft\\CTF\\LangBarAddIn\\");
const TCHAR c_szGuid[] =       TEXT("GUID");
const WCHAR c_wszFilePath[] =   L"FilePath";

typedef HRESULT (STDAPICALLTYPE* LPFNCTFGETLANGBARADDIN)(ITfLangBarAddIn **ppAddIn);


extern CPtrArray<SYSTHREAD> *g_rgSysThread;
    

//////////////////////////////////////////////////////////////////////////////
//
// LangBar AddIn service
//
//////////////////////////////////////////////////////////////////////////////

//+---------------------------------------------------------------------------
//
// TF_RegisterLangBarAddIn
//
//+---------------------------------------------------------------------------

HRESULT TF_RegisterLangBarAddIn(REFGUID rguidUISrv, const WCHAR *pwszFile, DWORD dwFlags)
{
    BOOL fLocalMachine = dwFlags & TF_RLBAI_LOCALMACHINE;

    if (IsEqualGUID(GUID_NULL, rguidUISrv))
        return E_INVALIDARG;

    if (!pwszFile)
        return E_INVALIDARG;

    CMyRegKey key;
    TCHAR szKey[256];

    StringCopyArray(szKey, c_szLangBarAddInKey);
    CLSIDToStringA(rguidUISrv, szKey + lstrlen(szKey));

    if (key.Create(fLocalMachine ? HKEY_LOCAL_MACHINE : HKEY_CURRENT_USER, szKey) != S_OK)
        return E_FAIL;

    if (key.SetValueW(pwszFile, c_wszFilePath) != S_OK)
        return E_FAIL;

    if (key.SetValue((dwFlags & TF_RLBAI_ENABLE) ? 1 : 0, c_szEnable) != S_OK)
        return E_FAIL;

    return S_OK;
}

//+---------------------------------------------------------------------------
//
// TF_UnregisterLangBarAddIn
//
//+---------------------------------------------------------------------------

HRESULT TF_UnregisterLangBarAddIn(REFGUID rguidUISrv, DWORD dwFlags)
{
    CMyRegKey key;
    TCHAR szKey[256];
    TCHAR szSubKey[256];
    BOOL fLocalMachine = dwFlags & TF_RLBAI_LOCALMACHINE;

    if (IsEqualGUID(GUID_NULL, rguidUISrv))
        return E_INVALIDARG;

    StringCopyArray(szKey, c_szLangBarAddInKey);

    if (key.Open(fLocalMachine ? HKEY_LOCAL_MACHINE : HKEY_CURRENT_USER, szKey, KEY_ALL_ACCESS) != S_OK)
        return E_FAIL;

    CLSIDToStringA(rguidUISrv, szSubKey);

    key.RecurseDeleteKey(szSubKey);

    return S_OK;
}

//+---------------------------------------------------------------------------
//
// TF_ClearLangBarAddIns
//
//+---------------------------------------------------------------------------

HRESULT TF_ClearLangBarAddIns(REFCLSID rclsid)
{
    int i;
    CicEnterCriticalSection(g_csInDllMain);

    if (g_rgSysThread)
    {
        int nCnt = g_rgSysThread->Count();
        for (i = 0; i < nCnt; i++)
        {
            SYSTHREAD *psfn = g_rgSysThread->Get(i);

            if (psfn)
            {
                ClearLangBarAddIns(psfn, rclsid);
            }
        }
    }

    CicLeaveCriticalSection(g_csInDllMain);
    return S_OK;
}

BOOL ClearLangBarAddIns(SYSTHREAD *psfn, REFCLSID rclsid)
{
    int i;
    int nCnt;

    if (!psfn->prgLBAddIn)
        return TRUE;

    nCnt = psfn->prgLBAddIn->Count();

    for (i = nCnt - 1; i >= 0; i--)
    {
        LANGBARADDIN *pAddIn = psfn->prgLBAddIn->Get(i);

        if (pAddIn)
        {
            if (pAddIn->_plbai)
            {
                if (IsEqualGUID(rclsid, CLSID_NULL) || 
                    IsEqualGUID(rclsid, pAddIn->_clsid))
                {
                    _try {
                        if (pAddIn->_fStarted)
                            pAddIn->_plbai->OnTerminate();

                        pAddIn->_plbai->Release();
                    }
                    _except(1) {
                        Assert(0);
                    }
                }
            }

            delete pAddIn;
        }

        psfn->prgLBAddIn->Remove(i, 1);
    }

    if (!psfn->prgLBAddIn->Count())
        UninitLangBarAddIns(psfn);

    return TRUE;
}

//+---------------------------------------------------------------------------
//
// InitLangBarAddInArray
//
//+---------------------------------------------------------------------------

void InitLangBarAddInArray()
{
    CMyRegKey key;
    DWORD dwIndex;
    char szKey[MAX_PATH];
    SYSTHREAD *psfn = GetSYSTHREAD();
    BOOL fLocalMachine = FALSE;

    if (!psfn)
        return;

    if (key.Open(HKEY_CURRENT_USER, c_szLangBarAddInKey, KEY_READ) != S_OK)
    {
        //
        // if there is no addin current user, try local machine.
        //
        goto StartInLocalmachine;
    }

TryAgainInLocalMachine:

    dwIndex = 0;
    while (key.EnumKey(dwIndex, szKey, ARRAYSIZE(szKey)) == S_OK)
    {
        CMyRegKey subkey;
        GUID guid;
        WCHAR wszFilePath[MAX_PATH];
        LANGBARADDIN **ppAddIn;

        if (subkey.Open(key, szKey, KEY_READ) != S_OK)
            goto Next;

        if (subkey.QueryValueCchW(wszFilePath, c_wszFilePath, ARRAYSIZE(wszFilePath)) != S_OK)
            goto Next;

        StringAToCLSID(szKey, &guid);

        if (psfn->prgLBAddIn)
        {
            int i;
            int nCnt = psfn->prgLBAddIn->Count();
            for (i = 0; i < nCnt; i++)
            {
                LANGBARADDIN *pAddIn = psfn->prgLBAddIn->Get(i);
                if (pAddIn && IsEqualGUID(pAddIn->_guid, guid))
                    goto Next;
            }
        }
        else
        {
            psfn->prgLBAddIn = new CPtrArray<LANGBARADDIN>;
            if (!psfn->prgLBAddIn)
            {
                return;
            }
        }

        //
        // if there is no reg entry for Enable, the default is enabled.
        //
        DWORD dwRet;
        BOOL fEnabled = FALSE;
        if (subkey.QueryValue(dwRet, c_szEnable) == S_OK)
        {
            if (dwRet)
                fEnabled = TRUE;
        }

        ppAddIn = psfn->prgLBAddIn->Append(1);
        if (!ppAddIn)
            goto Next;

        *ppAddIn = new LANGBARADDIN;
        if (!*ppAddIn)
            goto Next;

        (*ppAddIn)->_guid = guid;
        (*ppAddIn)->_fEnabled = fEnabled ? TRUE : FALSE;
        StringCopyArrayW((*ppAddIn)->_wszFilePath, wszFilePath);
      
Next:
        dwIndex++;
    }

    key.Close();

    if (!fLocalMachine)
    {
StartInLocalmachine:
        fLocalMachine = TRUE;
        if (key.Open(HKEY_LOCAL_MACHINE, c_szLangBarAddInKey, KEY_READ) == S_OK)
        {
            //
            // it is time to try local machine.
            //
            goto TryAgainInLocalMachine;
        }
    }

    return;
}

//+---------------------------------------------------------------------------
//
// LoadLangBarAddIns
//
//+---------------------------------------------------------------------------

BOOL LoadLangBarAddIns(SYSTHREAD *psfn)
{
    int i;
    int nCnt;

    if (psfn->fLBAddInLoaded)
        return TRUE;

    psfn->fLBAddInLoaded = TRUE;

    if (!psfn->prgLBAddIn)
    {
        InitLangBarAddInArray();
        if (!psfn->prgLBAddIn)
            return FALSE;
    }

    if (!psfn->prgLBAddIn)
        return TRUE;

    nCnt = psfn->prgLBAddIn->Count();

    for (i = 0; i < nCnt; i++)
    {
        LANGBARADDIN *pAddIn = psfn->prgLBAddIn->Get(i);
        LPFNCTFGETLANGBARADDIN pfn;
        ITfLangBarAddIn *plbai;

        if (!pAddIn)
            continue;

        if (pAddIn->_plbai)
            continue;

        if (!pAddIn->_fEnabled)
            continue;

        if (!pAddIn->_hInst)
        {
            if (IsOnNT())
                pAddIn->_hInst = LoadLibraryW(pAddIn->_wszFilePath);
            else
                pAddIn->_hInst = LoadLibrary(WtoA(pAddIn->_wszFilePath));
        }

        pfn = (LPFNCTFGETLANGBARADDIN)GetProcAddress(pAddIn->_hInst,
                                                     TEXT("CTFGetLangBarAddIn"));

        if (!pfn)
            continue;

   
        if (FAILED(pfn(&plbai)))
            continue;

        pAddIn->_plbai = plbai;

    }

    return psfn->prgLBAddIn->Count() ? TRUE : FALSE;
}

//+---------------------------------------------------------------------------
//
// UpdateLangBarAddIns
//
//+---------------------------------------------------------------------------

void UpdateLangBarAddIns()
{
    int i;
    int nCnt;
    DWORD dwFlags = 0;
    SYSTHREAD *psfn = GetSYSTHREAD();

    if (!psfn)
        return;

    if (!LoadLangBarAddIns(psfn))
        return;

    if (!psfn->prgLBAddIn)
        return;

    if (psfn->ptim && psfn->ptim->_GetFocusDocInputMgr()) 
        dwFlags = 1;

    nCnt = psfn->prgLBAddIn->Count();

    for (i = 0; i < nCnt; i++)
    {
        LANGBARADDIN *pAddIn = psfn->prgLBAddIn->Get(i);

        if (!pAddIn)
            continue;

        if (!pAddIn->_plbai)
            continue;

        if (!pAddIn->_fEnabled)
            continue;

        if (!pAddIn->_fStarted)
        {
           pAddIn->_fStarted = TRUE;
           HRESULT hr = E_FAIL;

           _try {
               hr = pAddIn->_plbai->OnStart(&pAddIn->_clsid);
           }
           _except(1) {
               Assert(0);
           }

           if (FAILED(hr))
           {
               pAddIn->_plbai->Release();
               pAddIn->_plbai = NULL;
               continue;
           }
        }

        _try {
            pAddIn->_plbai->OnUpdate(dwFlags);
        }
        _except(1) {
            Assert(0);
        }
    }
}

//+---------------------------------------------------------------------------
//
// TerminateLangBarAddIns
//
//+---------------------------------------------------------------------------

void UninitLangBarAddIns(SYSTHREAD *psfn)
{
    if (psfn->prgLBAddIn)
    {
        // Assert(!psfn->prgLBAddIn->Count());
        delete psfn->prgLBAddIn;
        psfn->prgLBAddIn = NULL;
    }

    psfn->fLBAddInLoaded = FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\ctf\uim\msgpump.cpp ===
//
// msgpump.cpp
//

#include "private.h"
#include "tim.h"

//+---------------------------------------------------------------------------
//
// PeekMessageA
//
//----------------------------------------------------------------------------

STDAPI CThreadInputMgr::PeekMessageA(LPMSG pMsg, HWND hwnd, UINT wMsgFilterMin,
                                     UINT wMsgFilterMax, UINT wRemoveMsg, BOOL *pfResult)
{
    if (pfResult == NULL)
        return E_INVALIDARG;

    Assert(_cAppWantsKeystrokesRef >= 0); // ref count is never negative!
    _cAppWantsKeystrokesRef++;

    *pfResult = ::PeekMessageA(pMsg, hwnd, wMsgFilterMin, wMsgFilterMax, wRemoveMsg);

    _cAppWantsKeystrokesRef--;

    return S_OK;
}

//+---------------------------------------------------------------------------
//
// GetMessageA
//
//----------------------------------------------------------------------------

STDAPI CThreadInputMgr::GetMessageA(LPMSG pMsg, HWND hwnd, UINT wMsgFilterMin,
                                    UINT wMsgFilterMax, BOOL *pfResult)
{
    if (pfResult == NULL)
        return E_INVALIDARG;

    Assert(_cAppWantsKeystrokesRef >= 0); // ref count is never negative!
    _cAppWantsKeystrokesRef++;

    Perf_StartStroke(PERF_STROKE_GETMSG);

    *pfResult = ::GetMessageA(pMsg, hwnd, wMsgFilterMin, wMsgFilterMax);

    Perf_EndStroke(PERF_STROKE_GETMSG);

    _cAppWantsKeystrokesRef--;

    return S_OK;
}

//+---------------------------------------------------------------------------
//
// PeekMessageW
//
//----------------------------------------------------------------------------

STDAPI CThreadInputMgr::PeekMessageW(LPMSG pMsg, HWND hwnd, UINT wMsgFilterMin,
                                     UINT wMsgFilterMax, UINT wRemoveMsg, BOOL *pfResult)
{
    if (pfResult == NULL)
        return E_INVALIDARG;

    Assert(_cAppWantsKeystrokesRef >= 0); // ref count is never negative!
    _cAppWantsKeystrokesRef++;

    *pfResult = ::PeekMessageW(pMsg, hwnd, wMsgFilterMin, wMsgFilterMax, wRemoveMsg);

    _cAppWantsKeystrokesRef--;

    return S_OK;
}

//+---------------------------------------------------------------------------
//
// GetMessageW
//
//----------------------------------------------------------------------------

STDAPI CThreadInputMgr::GetMessageW(LPMSG pMsg, HWND hwnd, UINT wMsgFilterMin,
                                    UINT wMsgFilterMax, BOOL *pfResult)
{
    if (pfResult == NULL)
        return E_INVALIDARG;

    Assert(_cAppWantsKeystrokesRef >= 0); // ref count is never negative!
    _cAppWantsKeystrokesRef++;

    Perf_StartStroke(PERF_STROKE_GETMSG);

    *pfResult = ::GetMessageW(pMsg, hwnd, wMsgFilterMin, wMsgFilterMax);

    Perf_EndStroke(PERF_STROKE_GETMSG);

    _cAppWantsKeystrokesRef--;

    return S_OK;
}

//+---------------------------------------------------------------------------
//
// EnableSystemKeystrokeFeed
//
//----------------------------------------------------------------------------

STDAPI CThreadInputMgr::EnableSystemKeystrokeFeed()
{
    if (_cDisableSystemKeystrokeFeedRef <= 0)
    {
        Assert(0); // bogus ref count!
        return E_UNEXPECTED;
    }

    _cDisableSystemKeystrokeFeedRef--;

    return S_OK;
}

//+---------------------------------------------------------------------------
//
// DisableSystemKeystrokeFeed
//
//----------------------------------------------------------------------------

STDAPI CThreadInputMgr::DisableSystemKeystrokeFeed()
{
    _cDisableSystemKeystrokeFeedRef++;
    return S_OK;
}

//+---------------------------------------------------------------------------
//
// IsKeystrokeFeedEnabled
//
// nb: this method is on a private interface used by the aimm layer.
//----------------------------------------------------------------------------

STDAPI CThreadInputMgr::IsKeystrokeFeedEnabled(BOOL *pfEnabled)
{
    Assert(pfEnabled != NULL);

    *pfEnabled = _IsKeystrokeFeedEnabled();

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\ctf\uim\mproxy.h ===
//
// mproxy.h
//

#ifndef MPROXY_H
#define MPROXY_H

#include "private.h"
#include "marshal.h"
#include "mstub.h"
#include "ptrary.h"
#include "strary.h"
#include "transmit.h"

IUnknown *ProxyCreator(SYSTHREAD *psfn, REFIID riid, ULONG ulStubId, DWORD dwStubTime, DWORD dwThreadId, DWORD dwCurThreadId, DWORD dwCurProcessId);

typedef struct tag_MARSHALINTERFACEPARAM 
{
    ULONG  ulStubId;
    ULONG  dwStubTime;
    BOOL   fNULLPointer;
    BOOL   fNULLStack;
} MARSHALINTERFACEPARAM;

#define MSGMAPSIZE  0x100

//////////////////////////////////////////////////////////////////////////////
//
// CMarshalParamCreator
//
//////////////////////////////////////////////////////////////////////////////

class CMarshalParamCreator
{
public:
    CMarshalParamCreator()
    {
        _ulCur = 0;
        _ulParamNum = 0;
        _pMsg = NULL;
        _fMsgCreated = FALSE;
    }

    ~CMarshalParamCreator()
    {
        if (_fMsgCreated)
            cicMemFree(_pMsg);
    }

    void Clear()
    {
        if (_fMsgCreated)
            cicMemFree(_pMsg);

        _ulCur = 0;
        _ulParamNum = 0;
        _pMsg = NULL;
        _fMsgCreated = FALSE;
    }

    BOOL Set(MARSHALMSG *pMsg, ULONG cbSize)
    {
        _pMsg = pMsg;
        _pMsg->cbBufSize = cbSize;
        return TRUE;
    }

    BOOL Init(DWORD dwSrcThreadId, DWORD dwSrcProcessId, REFIID riid, ULONG ulMethodId, ULONG ulParamNum, ULONG ulStubId, DWORD dwStubTime, BOOL fUseulRet = FALSE)
    {
        _ulParamNum = ulParamNum;
        ULONG cbSize = sizeof(MARSHALMSG) + ulParamNum * sizeof(MARSHALPARAM *);

        if (!_pMsg)
        {
            _pMsg = (MARSHALMSG *)cicMemAllocClear(MSGMAPSIZE);
            if (!_pMsg)
                return FALSE;

            _fMsgCreated = TRUE;
            _pMsg->cbBufSize = MSGMAPSIZE;
        }

        LENGTH_ALIGN(cbSize, CIC_ALIGNMENT);
        _pMsg->cbSize = cbSize;
        _pMsg->iid = riid;
        _pMsg->ulMethodId = ulMethodId;
        _pMsg->ulParamNum = 0;
        _pMsg->dwSrcThreadId = dwSrcThreadId;
        _pMsg->dwSrcProcessId = dwSrcProcessId;
        _pMsg->ulStubId = ulStubId;
        _pMsg->dwStubTime = dwStubTime;
        if (!fUseulRet)
            _pMsg->hrRet = E_FAIL;
            
        return TRUE;
    }

    HRESULT Add(ULONG cbBufSize, DWORD dwFlags, const void *pv)
    {
        ULONG cbOrgBufSize = cbBufSize;
        LENGTH_ALIGN(cbBufSize, CIC_ALIGNMENT);
        ULONG cbMsgSize = _pMsg->cbSize + cbBufSize + sizeof(MARSHALPARAM);
        LENGTH_ALIGN(cbMsgSize, CIC_ALIGNMENT);
        MARSHALPARAM *pParam;

        if (_pMsg->cbBufSize < cbMsgSize)
        {
            Assert(0);
            return E_OUTOFMEMORY;
        }

        pParam  = (MARSHALPARAM *)((BYTE *)_pMsg + _pMsg->cbSize);
        _pMsg->ulParamOffset[_ulCur] = _pMsg->cbSize;
        pParam->cbBufSize = cbBufSize;
        pParam->dwFlags = dwFlags;

        if (cbBufSize)
        {
            if (pv)
            {
                BYTE *pb = (BYTE *)ParamToBufferPointer(pParam);
                memcpy(pb, pv, cbOrgBufSize);
                if (cbBufSize - cbOrgBufSize)
                    memset(pb + cbOrgBufSize, 0, cbBufSize - cbOrgBufSize);
            }
            else
            {
                memset(ParamToBufferPointer(pParam), 0, cbBufSize);
            }
        }

        _pMsg->cbSize = cbMsgSize;
        _pMsg->ulParamNum++;

        _ulCur++;
        return S_OK;
    }

    MARSHALMSG *Get() {return _pMsg;}
    HRESULT GetHresult() {return _pMsg->hrRet;}

    MARSHALPARAM *GetMarshalParam(ULONG ulParam)
    {
        return (MARSHALPARAM *)(((BYTE *)_pMsg) + _pMsg->ulParamOffset[ulParam]);
    }

    HRESULT _RealSendReceive(CProxy *pProxy, ULONG ulBlockId)
    {
        HRESULT hr = pProxy->SendReceive(_pMsg, ulBlockId);
        return hr;
    }

    HRESULT SendReceive(CProxy *pProxy, ULONG ulBlockId)
    {
        HRESULT hr = _RealSendReceive(pProxy, ulBlockId);
        if (FAILED(hr))
            return hr;
        return _pMsg->hrRet;
    }

#ifdef UNKNOWN_MARSHAL
    HRESULT SendReceiveULONG(CProxy *pProxy, ULONG ulBlockId)
    {
        HRESULT hr = _RealSendReceive(pProxy, ulBlockId);
        if (FAILED(hr))
            return hr;
        return S_OK;
    }
#endif


private:
    MARSHALMSG *_pMsg;
    ULONG _ulParamNum;
    ULONG _ulCur;
    BOOL  _fMsgCreated;
};

//////////////////////////////////////////////////////////////////////////////
//
// CProxyIUnknown
//
//////////////////////////////////////////////////////////////////////////////

class CProxyIUnknown : public IUnknown,
                       public CProxy
{
public:
    CProxyIUnknown(SYSTHREAD *psfn);

    virtual ~CProxyIUnknown()
    {
        Assert(!_cRef);
    }

    //
    // IUnknown methods
    //
    STDMETHODIMP QueryInterface(REFIID riid, void **ppvObj);
    STDMETHODIMP_(ULONG) AddRef(void);
    STDMETHODIMP_(ULONG) Release(void);

    HRESULT _QueryInterface(REFIID riid, void **ppvObj);

private:
    DBG_ID_DECLARE;
};

extern const IID IID_CPROXYPRIV;
inline CProxyIUnknown *GetCProxyIUnknown(IUnknown *punk)
{
    CProxyIUnknown *pv;

    punk->QueryInterface(IID_CPROXYPRIV, (void **)&pv);

    return pv;
}

#define CPROXYIUNKOWNIMPL()                                      \
    STDMETHODIMP QueryInterface(REFIID riid, void **ppvObj)      \
    {                                                            \
        return CProxyIUnknown::QueryInterface(riid, ppvObj);     \
    }                                                            \
    STDMETHODIMP_(ULONG) AddRef(void)                            \
    {                                                            \
        return CProxyIUnknown::AddRef();                         \
    }                                                            \
    STDMETHODIMP_(ULONG) Release(void)                           \
    {                                                            \
        return CProxyIUnknown::Release();                        \
    }

//////////////////////////////////////////////////////////////////////////////
//
// CProxyITfLangBarMgr
//
//////////////////////////////////////////////////////////////////////////////

class CProxyITfLangBarMgr : public CProxyIUnknown,
                            public ITfLangBarMgr
{
public:
    CProxyITfLangBarMgr(SYSTHREAD *psfn);
    CPROXYIUNKOWNIMPL()

    //
    // ITfLangBarMgr methods
    //
    STDMETHODIMP AdviseEventSink(ITfLangBarEventSink *pSink, 
                                 HWND hwnd, 
                                 DWORD dwFlags, 
                                 DWORD *pdwCookie);

    STDMETHODIMP UnadviseEventSink(DWORD dwCookie);

    STDMETHODIMP GetThreadMarshalInterface(DWORD dwThreadId, 
                                           DWORD dwType, 
                                           REFIID riid, 
                                           IUnknown **ppunk);

    STDMETHODIMP GetThreadLangBarItemMgr(DWORD dwThreadId, 
                                         ITfLangBarItemMgr **pplbi, 
                                         DWORD *pdwThreadId) ;

    STDMETHODIMP GetInputProcessorProfiles(DWORD dwThreadId, 
                                           ITfInputProcessorProfiles **ppaip, 
                                           DWORD *pdwThreadId) ;

    STDMETHODIMP RestoreLastFocus(DWORD *pdwThreadId, BOOL fPrev);

    STDMETHODIMP SetModalInput(ITfLangBarEventSink *pSink, 
                               DWORD dwThreadId,
                               DWORD dwFlags);

    STDMETHODIMP ShowFloating(DWORD dwFlags);

    STDMETHODIMP GetShowFloatingStatus(DWORD *pdwFlags);
    DBG_ID_DECLARE;
};

//////////////////////////////////////////////////////////////////////////////
//
// CProxyITfLangBarItemMgr
//
//////////////////////////////////////////////////////////////////////////////

class CProxyITfLangBarItemMgr : public ITfLangBarItemMgr,
                                public CProxyIUnknown
{
public:
    CProxyITfLangBarItemMgr(SYSTHREAD *psfn);
    CPROXYIUNKOWNIMPL()

    STDMETHODIMP EnumItems(IEnumTfLangBarItems **ppEnum);

    STDMETHODIMP GetItem(REFGUID rguid, 
                    ITfLangBarItem **ppItem);

    STDMETHODIMP AddItem(ITfLangBarItem *punk);

    STDMETHODIMP RemoveItem(ITfLangBarItem *punk);

    STDMETHODIMP AdviseItemSink(ITfLangBarItemSink *punk, 
                           DWORD *pdwCookie, 
                           REFGUID rguidItem);

    STDMETHODIMP UnadviseItemSink(DWORD dwCookie);

    STDMETHODIMP GetItemFloatingRect(DWORD dwThreadId, REFGUID rguid, RECT *prc);
    STDMETHODIMP GetItemsStatus(ULONG ulCount, const GUID *prgguid, DWORD *pdwStatus);

    STDMETHODIMP GetItemNum(ULONG *pulCount);

    STDMETHODIMP GetItems(ULONG ulCount,  ITfLangBarItem **ppItem,  TF_LANGBARITEMINFO *pInfo, DWORD *pdwStatus, ULONG *pcFetched);

    STDMETHODIMP AdviseItemsSink(ULONG ulCount, ITfLangBarItemSink **ppunk,  const GUID *pguidItem, DWORD *pdwCookie);

    STDMETHODIMP UnadviseItemsSink(ULONG ulCount, DWORD *pdwCookie);

    DBG_ID_DECLARE;
};

//////////////////////////////////////////////////////////////////////////////
//
// CProxyITfLangBarItemSink
//
//////////////////////////////////////////////////////////////////////////////

class CProxyITfLangBarItemSink : public ITfLangBarItemSink,
                                 public CProxyIUnknown
{
public:
    CProxyITfLangBarItemSink(SYSTHREAD *psfn);
    CPROXYIUNKOWNIMPL()
    STDMETHODIMP OnUpdate(DWORD dwFlags);
    DBG_ID_DECLARE;
};

//////////////////////////////////////////////////////////////////////////////
//
// CProxyIEnumEnumTfLangBarItems
//
//////////////////////////////////////////////////////////////////////////////

class CProxyIEnumTfLangBarItems : public IEnumTfLangBarItems,
                                  public CProxyIUnknown
{
public:
    CProxyIEnumTfLangBarItems(SYSTHREAD *psfn);
    CPROXYIUNKOWNIMPL()
    STDMETHODIMP Clone(IEnumTfLangBarItems **ppEnum);
    STDMETHODIMP Next(ULONG ulCount, 
                      ITfLangBarItem **ppItem, 
                      ULONG *pcFetched);
    STDMETHODIMP Reset();
    STDMETHODIMP Skip(ULONG ulCount);
    DBG_ID_DECLARE;
};

//////////////////////////////////////////////////////////////////////////////
//
// CProxyITfLangBarItem
//
//////////////////////////////////////////////////////////////////////////////

class CProxyITfLangBarItem : public ITfLangBarItem,
                             public CProxyIUnknown
{
public:
    CProxyITfLangBarItem(SYSTHREAD *psfn);
    CPROXYIUNKOWNIMPL()
    STDMETHODIMP GetInfo(TF_LANGBARITEMINFO *pInfo);
    STDMETHODIMP GetStatus(DWORD *pdwStatus);
    STDMETHODIMP Show(BOOL fShow);
    STDMETHODIMP GetTooltipString(BSTR *pbstrToolTip);
    DBG_ID_DECLARE;
};

#define CPROXYLANGBARITEMIMPL()                                              \
    STDMETHODIMP GetInfo(TF_LANGBARITEMINFO *pInfo)                          \
                 {return CProxyITfLangBarItem::GetInfo(pInfo);}              \
    STDMETHODIMP GetStatus(DWORD *pdwStatus)                                 \
                 {return CProxyITfLangBarItem::GetStatus(pdwStatus);}        \
    STDMETHODIMP Show(BOOL fShow)                                            \
                 {return CProxyITfLangBarItem::Show(fShow);}                 \
    STDMETHODIMP GetTooltipString(BSTR *pbstr)                               \
                 {return CProxyITfLangBarItem::GetTooltipString(pbstr);}

//////////////////////////////////////////////////////////////////////////////
//
// CProxyITfLangBarItemButton
//
//////////////////////////////////////////////////////////////////////////////

class CProxyITfLangBarItemButton : public ITfLangBarItemButton,
                                   public CProxyITfLangBarItem
{
public:
    CProxyITfLangBarItemButton(SYSTHREAD *psfn);
    CPROXYIUNKOWNIMPL()
    CPROXYLANGBARITEMIMPL() 
    STDMETHODIMP OnClick(TfLBIClick click, POINT pt, const RECT *prcArea);
    STDMETHODIMP InitMenu(ITfMenu *pMenu);
    STDMETHODIMP OnMenuSelect(UINT wID);
    STDMETHODIMP GetIcon(HICON *phIcon);
    STDMETHODIMP GetText(BSTR *pbstrText);
    DBG_ID_DECLARE;
};

//////////////////////////////////////////////////////////////////////////////
//
// CProxyITfLangBarItemBitmapButton
//
//////////////////////////////////////////////////////////////////////////////

class CProxyITfLangBarItemBitmapButton : public ITfLangBarItemBitmapButton,
                                         public CProxyITfLangBarItem
{
public:
    CProxyITfLangBarItemBitmapButton(SYSTHREAD *psfn);
    CPROXYIUNKOWNIMPL()
    CPROXYLANGBARITEMIMPL() 
    STDMETHODIMP OnClick(TfLBIClick click, POINT pt, const RECT *prcArea);
    STDMETHODIMP InitMenu(ITfMenu *pMenu);
    STDMETHODIMP OnMenuSelect(UINT wID);
    STDMETHODIMP GetPreferredSize(const SIZE *pszDefault,SIZE *psz);
    STDMETHODIMP DrawBitmap(LONG bmWidth, LONG bmHeight,  DWORD dwFlags, HBITMAP *phbmp, HBITMAP *phbmpMask);
    STDMETHODIMP GetText(BSTR *pbstrText);
    DBG_ID_DECLARE;
};

//////////////////////////////////////////////////////////////////////////////
//
// CProxyITfLangBarItemBitmap
//
//////////////////////////////////////////////////////////////////////////////

class CProxyITfLangBarItemBitmap : public ITfLangBarItemBitmap,
                                   public CProxyITfLangBarItem
{
public:
    CProxyITfLangBarItemBitmap(SYSTHREAD *psfn);
    CPROXYIUNKOWNIMPL()
    CPROXYLANGBARITEMIMPL() 
    STDMETHODIMP OnClick(TfLBIClick click, POINT pt, const RECT *prcArea);
    STDMETHODIMP GetPreferredSize(const SIZE *pszDefault,SIZE *psz);
    STDMETHODIMP DrawBitmap(LONG bmWidth, LONG bmHeight,  DWORD dwFlags, HBITMAP *phbmp, HBITMAP *phbmpMask);
    DBG_ID_DECLARE;
};

//////////////////////////////////////////////////////////////////////////////
//
// CProxyITfLangBarItemBalloon
//
//////////////////////////////////////////////////////////////////////////////

class CProxyITfLangBarItemBalloon : public ITfLangBarItemBalloon,
                                   public CProxyITfLangBarItem
{
public:
    CProxyITfLangBarItemBalloon(SYSTHREAD *psfn);
    CPROXYIUNKOWNIMPL()
    CPROXYLANGBARITEMIMPL() 
    STDMETHODIMP OnClick(TfLBIClick click, POINT pt, const RECT *prcArea);
    STDMETHODIMP GetPreferredSize(const SIZE *pszDefault,SIZE *psz);
    STDMETHODIMP GetBalloonInfo(TF_LBBALLOONINFO *pInfo);
    DBG_ID_DECLARE;
};

//////////////////////////////////////////////////////////////////////////////
//
// CProxyITfMenu
//
//////////////////////////////////////////////////////////////////////////////

class CProxyITfMenu : public ITfMenu,
                                 public CProxyIUnknown
{
public:
    CProxyITfMenu(SYSTHREAD *psfn);
    CPROXYIUNKOWNIMPL()
    STDMETHODIMP AddMenuItem(UINT uId,
                             DWORD dwFlags,
                             HBITMAP hbmp,
                             HBITMAP hbmpMask,
                             const WCHAR *pch,
                             ULONG cch,
                             ITfMenu **ppMenu);
    DBG_ID_DECLARE;
};

//////////////////////////////////////////////////////////////////////////////
//
// CProxyITfMenu
//
//////////////////////////////////////////////////////////////////////////////

class CProxyITfInputProcessorProfiles : public ITfInputProcessorProfiles,
                                        public CProxyIUnknown
{
public:
    CProxyITfInputProcessorProfiles(SYSTHREAD *psfn);
    CPROXYIUNKOWNIMPL()
    STDMETHODIMP Register(REFCLSID rclsid);

    STDMETHODIMP Unregister(REFCLSID rclsid);

    STDMETHODIMP AddLanguageProfile(REFCLSID rclsid,
                               LANGID langid,
                               REFGUID guidProfile,
                               const WCHAR *pchDesc,
                               ULONG cchDesc,
                               const WCHAR *pchIconFile,
                               ULONG cchFile,
                               ULONG uIconIndex);

    STDMETHODIMP RemoveLanguageProfile(REFCLSID rclsid,
                                  LANGID langid,
                                  REFGUID guidProfile);

    STDMETHODIMP EnumInputProcessorInfo(IEnumGUID **ppEnum);

    STDMETHODIMP GetDefaultLanguageProfile(LANGID langid,
                                      REFGUID catid,
                                      CLSID *pclsid,
                                      GUID *pguidProfile);

    STDMETHODIMP SetDefaultLanguageProfile(LANGID langid,
                                      REFCLSID rclsid,
                                      REFGUID guidProfiles);

    STDMETHODIMP ActivateLanguageProfile(REFCLSID rclsid, 
                                    LANGID langid, 
                                    REFGUID guidProfiles);

    STDMETHODIMP GetActiveLanguageProfile(REFCLSID rclsid, 
                                     LANGID *plangid, 
                                     GUID *pguidProfile);

    STDMETHODIMP GetLanguageProfileDescription(REFCLSID rclsid, 
                                          LANGID langid, 
                                          REFGUID guidProfile,
                                          BSTR *pbstrProfile);

    STDMETHODIMP GetCurrentLanguage(LANGID *plangid);

    STDMETHODIMP ChangeCurrentLanguage(LANGID langid);

    STDMETHODIMP GetLanguageList(LANGID **ppLangId,
                            ULONG *pulCount);

    STDMETHODIMP EnumLanguageProfiles(LANGID langid, 
                                 IEnumTfLanguageProfiles **ppEnum);

    STDMETHODIMP EnableLanguageProfile(REFCLSID rclsid,
                                       LANGID langid,
                                       REFGUID guidProfile,
                                       BOOL fEnable);

    STDMETHODIMP IsEnabledLanguageProfile(REFCLSID rclsid,
                                          LANGID langid,
                                          REFGUID guidProfile,
                                          BOOL *pfEnable);

    STDMETHODIMP EnableLanguageProfileByDefault(REFCLSID rclsid,
                                                LANGID langid,
                                                REFGUID guidProfile,
                                                BOOL fEnable);

    STDMETHODIMP SubstituteKeyboardLayout(REFCLSID rclsid,
                                          LANGID langid,
                                          REFGUID guidProfile,
                                          HKL hKL);

    DBG_ID_DECLARE;
};

#endif // MPROXY_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\ctf\uim\msaa.h ===
//
// msaa.h
//

#ifndef MSAA_H
#define MSAA_H

// when we ditch atl, this should be a static class!  we don't need to allocate any memory!
class CMSAAControl : public ITfMSAAControl,
                     public CComObjectRoot_CreateInstance<CMSAAControl>
{
public:
    CMSAAControl() {}

    BEGIN_COM_MAP_IMMX(CMSAAControl)
        COM_INTERFACE_ENTRY(ITfMSAAControl)
    END_COM_MAP_IMMX()

    // ITfMSAAControl
    STDMETHODIMP SystemEnableMSAA();
    STDMETHODIMP SystemDisableMSAA();
};

#endif // MSAA_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\ctf\uim\msaa.cpp ===
//
// msaa.cpp
//
// AA stuff.
//

#include "private.h"
#include "ic.h"
#include "tim.h"
#include "dim.h"
#include "msaa.h"
#include "tlapi.h"

extern "C" HRESULT WINAPI TF_PostAllThreadMsg(WPARAM wParam, DWORD dwFlags);

//+---------------------------------------------------------------------------
//
// SystemEnableMSAA
//
// Called by msaa to kick cicero msaa support on the desktop.
//----------------------------------------------------------------------------

STDAPI CMSAAControl::SystemEnableMSAA()
{
    if (InterlockedIncrement(&GetSharedMemory()->cMSAARef) == 0)
    {
        TF_PostAllThreadMsg(TFPRIV_ENABLE_MSAA, TLF_TIMACTIVE);
    }
    return S_OK;
}

//+---------------------------------------------------------------------------
//
// SystemDisableMSAA
//
// Called by msaa to halt cicero msaa support on the desktop.
//----------------------------------------------------------------------------

STDAPI CMSAAControl::SystemDisableMSAA()
{
    if (InterlockedDecrement(&GetSharedMemory()->cMSAARef) == -1)
    {
        TF_PostAllThreadMsg(TFPRIV_DISABLE_MSAA, TLF_TIMACTIVE);
    }
    return S_OK;
}

//+---------------------------------------------------------------------------
//
// _InitMSAAHook
//
//----------------------------------------------------------------------------

void CInputContext::_InitMSAAHook(IAccServerDocMgr *pAAAdaptor)
{
    IDocWrap *pAADocWrapper;

    if (_pMSAAState != NULL)
        return; // already inited

    Assert(_ptsi != NULL);

    // try to allocate some space for the state we'll need to save
    // since we rarely use msaa, it's stored separately from the ic
    if ((_pMSAAState = (MSAA_STATE *)cicMemAlloc(sizeof(MSAA_STATE))) == NULL)
        return;

    // back up the original ptsi
    _pMSAAState->ptsiOrg = _ptsi;
    _ptsi = NULL;

    if (CoCreateInstance(CLSID_DocWrap, NULL, CLSCTX_INPROC_SERVER,
        IID_IDocWrap, (void **)&pAADocWrapper) != S_OK)
    {
        goto ExitError;
    }

    if (pAADocWrapper->SetDoc(IID_ITextStoreAnchor, _pMSAAState->ptsiOrg) != S_OK)
        goto ExitError;

    if (pAADocWrapper->GetWrappedDoc(IID_ITextStoreAnchor, (IUnknown **)&_pMSAAState->pAADoc) != S_OK)
        goto ExitError;

    if (pAADocWrapper->GetWrappedDoc(IID_ITextStoreAnchor, (IUnknown **)&_ptsi) != S_OK)
        goto ExitError;

    if (pAAAdaptor->NewDocument(IID_ITextStoreAnchor, _pMSAAState->pAADoc) != S_OK)
        goto ExitError;

    pAADocWrapper->Release();
    return;

ExitError:
    pAADocWrapper->Release();
    _UninitMSAAHook(pAAAdaptor);
}

//+---------------------------------------------------------------------------
//
// _UninitMSAAHook
//
//----------------------------------------------------------------------------

void CInputContext::_UninitMSAAHook(IAccServerDocMgr *pAAAdaptor)
{
    if (_pMSAAState == NULL)
        return; // not inited

    pAAAdaptor->RevokeDocument(_pMSAAState->pAADoc);
    SafeRelease(_pMSAAState->pAADoc);
    SafeRelease(_ptsi);
    // restore orig unwrapped doc
    _ptsi = _pMSAAState->ptsiOrg;
    // free msaa struct
    cicMemFree(_pMSAAState);
    _pMSAAState = NULL;
}

//+---------------------------------------------------------------------------
//
// _InitMSAA
//
//----------------------------------------------------------------------------

void CThreadInputMgr::_InitMSAA()
{
    CDocumentInputManager *dim;
    CInputContext *pic;
    int iDim;
    int iContext;
    HRESULT hr;

    if (_pAAAdaptor != NULL)
        return; // already inited

    hr = CoCreateInstance(CLSID_AccServerDocMgr, NULL, CLSCTX_INPROC_SERVER,
                          IID_IAccServerDocMgr, (void **)&_pAAAdaptor);

    if (hr != S_OK || _pAAAdaptor == NULL)
    {
        _pAAAdaptor = NULL;
        return;
    }

    // now wrap all existing ic's
    for (iDim = 0; iDim < _rgdim.Count(); iDim++)
    {
        dim = _rgdim.Get(iDim);

        for (iContext = 0; iContext <= dim->_GetCurrentStack(); iContext++)
        {
            pic = dim->_GetIC(iContext);
            // we need to reset our sinks, so msaa can wrap them
            // first, disconnect the sink
            pic->_GetTSI()->UnadviseSink(SAFECAST(pic, ITextStoreAnchorSink *));

            // now announce the ic
            pic->_InitMSAAHook(_pAAAdaptor);

            // now reset the sink on the wrapped _ptsi
            pic->_GetTSI()->AdviseSink(IID_ITextStoreAnchorSink, SAFECAST(pic, ITextStoreAnchorSink *), TS_AS_ALL_SINKS);
        }
    }
}

//+---------------------------------------------------------------------------
//
// _UninitMSAA
//
//----------------------------------------------------------------------------

void CThreadInputMgr::_UninitMSAA()
{
    CDocumentInputManager *dim;
    CInputContext *pic;
    int iDim;
    int iContext;

    if (_pAAAdaptor == NULL)
        return; // already uninited

    // unwrap all existing ic's
    for (iDim = 0; iDim < _rgdim.Count(); iDim++)
    {
        dim = _rgdim.Get(iDim);

        for (iContext = 0; iContext <= dim->_GetCurrentStack(); iContext++)
        {
            pic = dim->_GetIC(iContext);
            // we need to reset our sinks
            // first, unadvise the wrapped sinks
            pic->_GetTSI()->UnadviseSink(SAFECAST(pic, ITextStoreAnchorSink *));

            // unwrap the ptsi
            pic->_UninitMSAAHook(_pAAAdaptor);

            // now reset the sink on the original _ptsi
            pic->_GetTSI()->AdviseSink(IID_ITextStoreAnchorSink, SAFECAST(pic, ITextStoreAnchorSink *), TS_AS_ALL_SINKS);
        }
    }

    _pAAAdaptor->Release();
    _pAAAdaptor = NULL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\ctf\uim\mstub.cpp ===
//
// mstub.cpp
//

#include "private.h"
#include "mstub.h"
#include "mproxy.h"
#include "ithdmshl.h"
#include "transmit.h"


//////////////////////////////////////////////////////////////////////////////
//
// StubCreator
//
//////////////////////////////////////////////////////////////////////////////

#define CREATENEWSTUB(interface_name)                                      \
    if (IsEqualIID(riid, IID_ ## interface_name ## ))                      \
    {                                                                      \
        CStub *pStub =  new CStub ## interface_name ## ;                   \
        if (!pStub)                                                        \
             return NULL;                                                  \
        pStub->_iid = riid;                                                \
        pStub->_ulStubId = ulStubId;                                       \
        pStub->_dwStubTime = dwStubTime;                                   \
        pStub->_dwStubThreadId = dwCurThreadId;                            \
        pStub->_dwStubProcessId = dwCurProcessId;                          \
        pStub->_dwSrcThreadId = dwSrcThreadId;                             \
        pStub->_punk = punk;                                               \
        pStub->_punk->AddRef();                                            \
        return pStub;                                                      \
    }                                                                      

CStub *StubCreator(REFIID riid, IUnknown *punk, ULONG ulStubId, DWORD dwStubTime, DWORD dwCurThreadId, DWORD dwCurProcessId, DWORD dwSrcThreadId)
{
    Assert(dwCurThreadId != dwSrcThreadId);

    CREATENEWSTUB(ITfLangBarMgr);
    CREATENEWSTUB(ITfLangBarItemMgr);
    CREATENEWSTUB(ITfLangBarItemSink);
    CREATENEWSTUB(IEnumTfLangBarItems);
    CREATENEWSTUB(ITfLangBarItem);
    CREATENEWSTUB(ITfLangBarItemButton);
    CREATENEWSTUB(ITfLangBarItemBitmapButton);
    CREATENEWSTUB(ITfLangBarItemBitmap);
    CREATENEWSTUB(ITfLangBarItemBalloon);
    CREATENEWSTUB(ITfMenu);
    CREATENEWSTUB(ITfInputProcessorProfiles);
    return NULL;
}


void StubPointerToParam(MARSHALPARAM *pParam, void *pv)
{
    Assert(pParam->dwFlags & MPARAM_OUT);
    Assert(pParam->cbBufSize >= sizeof(void *));
    void **ppv = (void **)ParamToBufferPointer(pParam);
    *ppv = pv;
}

void StubParamPointerToParam(MARSHALPARAM *pParam, void *pv)
{
    Assert(pParam->dwFlags & MPARAM_OUT);
    Assert(pParam->cbBufSize >= sizeof(void *));
    void *pBuf = ParamToBufferPointer(pParam);
    memcpy(pBuf, pv, pParam->cbBufSize);
}

void *ParamToMarshaledPointer(MARSHALMSG *pMsg, REFIID riid, ULONG ulParam, BOOL *pfNULLStack = NULL)
{
    MARSHALINTERFACEPARAM *pmiparam = (MARSHALINTERFACEPARAM *)ParamToBufferPointer(pMsg, ulParam);
    void *pv = NULL;

    Assert(pfNULLStack || !pmiparam->fNULLStack);
    if (pfNULLStack)
       *pfNULLStack = pmiparam->fNULLStack;

    if (pmiparam->fNULLPointer)
        return NULL;
   
    CicCoUnmarshalInterface(riid, pMsg->dwSrcThreadId, pmiparam->ulStubId, pmiparam->dwStubTime, &pv);
    return pv;
}

BOOL ParamToArrayMarshaledPointer(ULONG ulCount, void **ppv, MARSHALMSG *pMsg, REFIID riid, ULONG ulParam, BOOL *pfNULLStack = NULL)
{
    MARSHALINTERFACEPARAM *pmiparam = (MARSHALINTERFACEPARAM *)ParamToBufferPointer(pMsg, ulParam);

    Assert(pfNULLStack || !pmiparam->fNULLStack);
    if (pfNULLStack)
       *pfNULLStack = pmiparam->fNULLStack;

    if (pmiparam->fNULLPointer)
        return FALSE;
   
    ULONG ul;
    for (ul = 0; ul < ulCount; ul++)
    {
        CicCoUnmarshalInterface(riid, pMsg->dwSrcThreadId, pmiparam->ulStubId, pmiparam->dwStubTime, ppv);
        ppv++;
        pmiparam++;
    }
    return TRUE;
}

void ClearMarshaledPointer(IUnknown *punk)
{
    if (!punk)
        return;

    CProxyIUnknown *pProxy = GetCProxyIUnknown(punk);
    if (!pProxy)
        return;

    if (pProxy->InternalRelease())
        pProxy->InternalRelease();
    else
        Assert(0);
}

HBITMAP ParamToHBITMAP(MARSHALMSG *pMsg , ULONG ulParam)
{
    MARSHALPARAM *pParam = GetMarshalParam(pMsg, ulParam);
    HBITMAP hbmp = NULL;
    if (pParam->cbBufSize)
    {
        BYTE *pBuf = (BYTE *)ParamToBufferPointer(pParam);
        Cic_HBITMAP_UserUnmarshal(pBuf, &hbmp);
    }
    return hbmp;
}

#define PREPARE_PARAM_START()                             \
    if (!psb->GetMutex()->Enter())                        \
        return E_FAIL;                                    \
    _try                                                  \
    {

#define PREPARE_PARAM_END()                               \
    }                                                     \
    _except(1)                                            \
    {                                                     \
        Assert(0);                                        \
        psb->GetMutex()->Leave();                         \
        return E_FAIL;                                    \
    }                                                     \
    psb->GetMutex()->Leave();

//////////////////////////////////////////////////////////////////////////////
//
// CStubIUnknown
//
//////////////////////////////////////////////////////////////////////////////

MSTUBCALL CStubIUnknown::_StubTbl[] = 
{
    stub_QueryInterface,
    stub_AddRef,
    stub_Release
};

HRESULT CStubIUnknown::stub_QueryInterface(CStub *_this, MARSHALMSG *pMsg, CSharedBlock *psb)
{
    IID iid;
    void *pv;

    Assert(pMsg->ulParamNum == 2);

    PREPARE_PARAM_START()

    iid = *(IID *)ParamToBufferPointer(pMsg, 0);

    PREPARE_PARAM_END()

    HRESULT hrRet = _this->_punk->QueryInterface(iid, &pv);

    if (SUCCEEDED(hrRet))
    {
        _this->_AddRef();
    }
    else
    {
        pv = NULL;
    }

    CSTUB_PARAM_START()
    CSTUB_PARAM_POINTER_IN(&iid)
    CSTUB_PARAM_INTERFACE_OUT(&pv, iid)
    CSTUB_PARAM_END()
    CSTUB_PARAM_CALL(pMsg, hrRet, psb);
    CSTUB_PARAM_INTERFACE_OUT_RELEASE(pv)
    CSTUB_PARAM_RETURN()
}

HRESULT CStubIUnknown::stub_AddRef(CStub *_this, MARSHALMSG *pMsg, CSharedBlock *psb)
{
    Assert(pMsg->ulParamNum == 0);
    pMsg->ulRet = _this->_punk->AddRef();
    _this->_AddRef();
    return S_OK;
}

HRESULT CStubIUnknown::stub_Release(CStub *_this, MARSHALMSG *pMsg, CSharedBlock *psb)
{
    Assert(pMsg->ulParamNum == 0);
    pMsg->ulRet = _this->_punk->Release();

    if (!pMsg->ulRet)
        _this->_punk = NULL;
        
    _this->_Release();
    return S_OK;
}


//////////////////////////////////////////////////////////////////////////////
//
// CStubITfLangBarMgr
//
//////////////////////////////////////////////////////////////////////////////

MSTUBCALL CStubITfLangBarMgr::_StubTbl[] = 
{
    stub_QueryInterface,
    stub_AddRef,
    stub_Release,
    stub_AdviseEventSink,
    stub_UnadviseEventSink,
    stub_GetThreadMarshalInterface,
    stub_GetThreadLangBarItemMgr,
    stub_GetInputProcessorProfiles,
    stub_RestoreLastFocus,
    stub_SetModalInput,
    stub_ShowFloating,
    stub_GetShowFloatingStatus,
};

HRESULT CStubITfLangBarMgr::stub_AdviseEventSink(CStub *_this, MARSHALMSG *pMsg, CSharedBlock *psb)
{
    CSTUB_NOT_IMPL()
}
HRESULT CStubITfLangBarMgr::stub_UnadviseEventSink(CStub *_this, MARSHALMSG *pMsg, CSharedBlock *psb)
{
    CSTUB_NOT_IMPL()
}
HRESULT CStubITfLangBarMgr::stub_GetThreadMarshalInterface(CStub *_this, MARSHALMSG *pMsg, CSharedBlock *psb)
{
    CSTUB_NOT_IMPL()
}
HRESULT CStubITfLangBarMgr::stub_GetThreadLangBarItemMgr(CStub *_this, MARSHALMSG *pMsg, CSharedBlock *psb)
{
    CSTUB_NOT_IMPL()
}
HRESULT CStubITfLangBarMgr::stub_GetInputProcessorProfiles(CStub *_this, MARSHALMSG *pMsg, CSharedBlock *psb)
{
    CSTUB_NOT_IMPL()
}
HRESULT CStubITfLangBarMgr::stub_RestoreLastFocus(CStub *_this, MARSHALMSG *pMsg, CSharedBlock *psb)
{
    CSTUB_NOT_IMPL()
}
HRESULT CStubITfLangBarMgr::stub_SetModalInput(CStub *_this, MARSHALMSG *pMsg, CSharedBlock *psb)
{
    CSTUB_NOT_IMPL()
}
HRESULT CStubITfLangBarMgr::stub_ShowFloating(CStub *_this, MARSHALMSG *pMsg, CSharedBlock *psb)
{
    CSTUB_NOT_IMPL()
}
HRESULT CStubITfLangBarMgr::stub_GetShowFloatingStatus(CStub *_this, MARSHALMSG *pMsg, CSharedBlock *psb)
{
    CSTUB_NOT_IMPL()
}

//////////////////////////////////////////////////////////////////////////////
//
// CStubITfLangBarItemMgr
//
//////////////////////////////////////////////////////////////////////////////

MSTUBCALL CStubITfLangBarItemMgr::_StubTbl[] = 
{
    stub_QueryInterface,
    stub_AddRef,
    stub_Release,
    stub_EnumItems,
    stub_GetItem,
    stub_AddItem,
    stub_RemoveItem,
    stub_AdviseItemSink,
    stub_UnadviseItemSink,
    stub_GetItemFloatingRect,
    stub_GetItemsStatus,
    stub_GetItemNum,
    stub_GetItems,
    stub_AdviseItemsSink,
    stub_UnadviseItemsSink,
};

HRESULT CStubITfLangBarItemMgr::stub_EnumItems(CStub *_this, MARSHALMSG *pMsg, CSharedBlock *psb)
{
    HRESULT hrRet;
    void *pv = NULL;

    Assert(pMsg->ulParamNum == 1);
    hrRet = ((ITfLangBarItemMgr *)_this->_punk)->EnumItems((IEnumTfLangBarItems **)&pv);

    CSTUB_PARAM_START()
    CSTUB_PARAM_INTERFACE_OUT(&pv, IID_IEnumTfLangBarItems)
    CSTUB_PARAM_END()
    CSTUB_PARAM_CALL(pMsg, hrRet, psb);
    CSTUB_PARAM_INTERFACE_OUT_RELEASE(pv)
    CSTUB_PARAM_RETURN()
}

HRESULT CStubITfLangBarItemMgr::stub_GetItem(CStub *_this, MARSHALMSG *pMsg, CSharedBlock *psb)
{
    CSTUB_NOT_IMPL()
}

HRESULT CStubITfLangBarItemMgr::stub_AddItem(CStub *_this, MARSHALMSG *pMsg, CSharedBlock *psb)
{
    CSTUB_NOT_IMPL()
}

HRESULT CStubITfLangBarItemMgr::stub_RemoveItem(CStub *_this, MARSHALMSG *pMsg, CSharedBlock *psb)
{
    CSTUB_NOT_IMPL()
}

HRESULT CStubITfLangBarItemMgr::stub_AdviseItemSink(CStub *_this, MARSHALMSG *pMsg, CSharedBlock *psb)
{
    TraceMsg(TF_FUNC, "CStubITfLangbarItemMgr::AdviseItemSink");
    ITfLangBarItemSink *punk = NULL;
    DWORD dwCookie = 0;
    GUID guid = {0};

    PREPARE_PARAM_START()

    punk = (ITfLangBarItemSink *)ParamToMarshaledPointer(pMsg, IID_ITfLangBarItemSink, 0);
    guid = *(GUID *)ParamToBufferPointer(pMsg, 2);

    PREPARE_PARAM_END()

    HRESULT hrRet = ((ITfLangBarItemMgr *)_this->_punk)->AdviseItemSink(punk, &dwCookie, (REFGUID)guid);

    ClearMarshaledPointer(punk);
    CSTUB_PARAM_START()
    CSTUB_PARAM_INTERFACE_IN(NULL, IID_ITfLangBarItemSink)
    CSTUB_PARAM_POINTER_OUT(&dwCookie)
    CSTUB_PARAM_POINTER_IN(&guid)
    CSTUB_PARAM_END()
    CSTUB_PARAM_CALL(pMsg, hrRet, psb);
    CSTUB_PARAM_RETURN()
}

HRESULT CStubITfLangBarItemMgr::stub_UnadviseItemSink(CStub *_this, MARSHALMSG *pMsg, CSharedBlock *psb)
{
    DWORD dwCookie = 0;

    PREPARE_PARAM_START()

    dwCookie = (DWORD)ParamToULONG(pMsg, 0);

    PREPARE_PARAM_END()

    pMsg->hrRet = ((ITfLangBarItemMgr *)_this->_punk)->UnadviseItemSink(dwCookie);
    return S_OK;
}

HRESULT CStubITfLangBarItemMgr::stub_GetItemFloatingRect(CStub *_this, MARSHALMSG *pMsg, CSharedBlock *psb)
{
    DWORD dwThreadId = 0;
    GUID guid = {0};

    PREPARE_PARAM_START()

    dwThreadId = (DWORD)ParamToULONG(pMsg, 0);
    guid = *(GUID *)ParamToBufferPointer(pMsg, 1);

    PREPARE_PARAM_END()

    RECT rc;
    HRESULT hrRet = ((ITfLangBarItemMgr *)_this->_punk)->GetItemFloatingRect(dwThreadId, guid, &rc);
    CSTUB_PARAM_START()
    CSTUB_PARAM_ULONG_IN(dwThreadId)
    CSTUB_PARAM_POINTER_IN(&guid)
    CSTUB_PARAM_POINTER_OUT(&rc)
    CSTUB_PARAM_END()
    CSTUB_PARAM_CALL(pMsg, hrRet, psb)
    CSTUB_PARAM_RETURN()
    return S_OK;
}

HRESULT CStubITfLangBarItemMgr::stub_GetItemsStatus(CStub *_this, MARSHALMSG *pMsg, CSharedBlock *psb)
{
    ULONG ulCount = 0;
    GUID *pguid = NULL;

    PREPARE_PARAM_START()

    ulCount = (ULONG)ParamToULONG(pMsg, 0);
    pguid = new GUID[ulCount];

    if (pguid)
        memcpy(pguid, ParamToBufferPointer(pMsg, 1), sizeof(GUID) * ulCount);

    PREPARE_PARAM_END()

    if (!pguid)
        return E_OUTOFMEMORY;

    DWORD *pdwStatus;

    pdwStatus = new DWORD[ulCount];
    if (!pdwStatus)
    {
        delete pguid;
        return E_OUTOFMEMORY;
    }

    HRESULT hrRet = ((ITfLangBarItemMgr *)_this->_punk)->GetItemsStatus(ulCount, pguid, pdwStatus);

    CSTUB_PARAM_START()
    CSTUB_PARAM_ULONG_IN(ulCount)
    CSTUB_PARAM_POINTER_ARRAY_IN(pguid, ulCount)
    CSTUB_PARAM_POINTER_ARRAY_OUT(pdwStatus, ulCount)
    CSTUB_PARAM_END()
    CSTUB_PARAM_CALL(pMsg, hrRet, psb)
    delete pdwStatus;
    delete pguid;
    CSTUB_PARAM_RETURN()
    return S_OK;
}

HRESULT CStubITfLangBarItemMgr::stub_GetItemNum(CStub *_this, MARSHALMSG *pMsg, CSharedBlock *psb)
{
    HRESULT hrRet;
    DWORD dw;
    hrRet = ((ITfLangBarItemMgr *)_this->_punk)->GetItemNum(&dw);
    CSTUB_PARAM_START()
    CSTUB_PARAM_POINTER_OUT(&dw)
    CSTUB_PARAM_END()
    CSTUB_PARAM_CALL(pMsg, hrRet, psb)
    CSTUB_PARAM_RETURN()
}

HRESULT CStubITfLangBarItemMgr::stub_GetItems(CStub *_this, MARSHALMSG *pMsg, CSharedBlock *psb)
{
    ULONG ulCount;
    ULONG ulFetched;
    HRESULT hrRet;
    IUnknown **ppunk;
    TF_LANGBARITEMINFO *pInfo;
    DWORD *pdwStatus;

    PREPARE_PARAM_START()

    ulCount = ParamToULONG(pMsg, 0);

    PREPARE_PARAM_END()

    ppunk = new IUnknown*[ulCount];
    if (!ppunk)
         return E_OUTOFMEMORY;

    pInfo = new TF_LANGBARITEMINFO[ulCount];
    if (!pInfo)
    {
        delete ppunk;
        return E_OUTOFMEMORY;
    }

    pdwStatus = new DWORD[ulCount];
    if (!pdwStatus)
    {
        delete ppunk;
        delete pInfo;
        return E_OUTOFMEMORY;
    }

    hrRet = ((ITfLangBarItemMgr *)_this->_punk)->GetItems(ulCount, (ITfLangBarItem **)ppunk, pInfo, pdwStatus, &ulFetched);

    CSTUB_PARAM_START()
    CSTUB_PARAM_ULONG_IN(ulCount)
    CSTUB_PARAM_INTERFACE_ARRAY_OUT(ppunk, IID_ITfLangBarItem, ulCount)
    CSTUB_PARAM_POINTER_ARRAY_OUT(pInfo, ulCount)
    CSTUB_PARAM_POINTER_ARRAY_OUT(pdwStatus, ulCount)
    CSTUB_PARAM_POINTER_OUT(&ulFetched)
    CSTUB_PARAM_END()
    CSTUB_PARAM_CALL(pMsg, hrRet, psb);
    CSTUB_PARAM_INTERFACE_ARRAY_OUT_RELEASE(ppunk, ulFetched)

    delete ppunk;
    delete pInfo;
    delete pdwStatus;
    CSTUB_PARAM_RETURN()
}

HRESULT CStubITfLangBarItemMgr::stub_AdviseItemsSink(CStub *_this, MARSHALMSG *pMsg, CSharedBlock *psb)
{
    ULONG ulCount = 0;
    HRESULT hrRet;
    IUnknown **ppunk = NULL;
    DWORD *pdwCookie = NULL;
    GUID *pguid = NULL;

    PREPARE_PARAM_START()

    ulCount = ParamToULONG(pMsg, 0);


    ppunk = new IUnknown*[ulCount];

    if (ppunk)
        ParamToArrayMarshaledPointer(ulCount, (void **)ppunk, pMsg, IID_ITfLangBarItemSink, 1);

    pguid = new GUID[ulCount];
    if (pguid)
        memcpy(pguid, ParamToBufferPointer(pMsg, 2), sizeof(GUID) * ulCount);

    PREPARE_PARAM_END()

    if (!ppunk)
    {
        if (pguid)
            delete pguid;
        return E_OUTOFMEMORY;
    }

    if (!pguid)
    {
        delete ppunk;
        return E_OUTOFMEMORY;
    }

    pdwCookie = new DWORD[ulCount];
    if (!pdwCookie)
    {
        delete ppunk;
        delete pguid;
        return E_OUTOFMEMORY;
    }

    hrRet = ((ITfLangBarItemMgr *)_this->_punk)->AdviseItemsSink(ulCount, (ITfLangBarItemSink **)ppunk, pguid, pdwCookie);

    CSTUB_PARAM_START()
    CSTUB_PARAM_ULONG_IN(ulCount)
    CSTUB_PARAM_INTERFACE_ARRAY_IN(NULL, IID_ITfLangBarItemSink, ulCount)
    CSTUB_PARAM_POINTER_ARRAY_IN(pguid, ulCount)
    CSTUB_PARAM_POINTER_ARRAY_OUT(pdwCookie, ulCount)
    CSTUB_PARAM_END()
    CSTUB_PARAM_CALL(pMsg, hrRet, psb);

    CSTUB_PARAM_INTERFACE_ARRAY_OUT_RELEASE(ppunk, ulCount)

    delete ppunk;
    delete pdwCookie;
    delete pguid;
    CSTUB_PARAM_RETURN()
}

HRESULT CStubITfLangBarItemMgr::stub_UnadviseItemsSink(CStub *_this, MARSHALMSG *pMsg, CSharedBlock *psb)
{
    ULONG ulCount;
    HRESULT hrRet;
    DWORD *pdwCookie;

    PREPARE_PARAM_START()

    ulCount = ParamToULONG(pMsg, 0);

    pdwCookie = new DWORD[ulCount];
    if (pdwCookie)
        memcpy(pdwCookie,ParamToBufferPointer(pMsg, 1), sizeof(DWORD) * ulCount);

    PREPARE_PARAM_END()

    if (!pdwCookie)
        return E_OUTOFMEMORY;

    hrRet = ((ITfLangBarItemMgr *)_this->_punk)->UnadviseItemsSink(ulCount, pdwCookie);

    CSTUB_PARAM_START()
    CSTUB_PARAM_ULONG_IN(ulCount)
    CSTUB_PARAM_POINTER_ARRAY_IN(pdwCookie, ulCount)
    CSTUB_PARAM_END()
    CSTUB_PARAM_CALL(pMsg, hrRet, psb);

    delete pdwCookie;
    CSTUB_PARAM_RETURN()
}

//////////////////////////////////////////////////////////////////////////////
//
// CStubITfLangBarItemSink
//
//////////////////////////////////////////////////////////////////////////////

MSTUBCALL CStubITfLangBarItemSink::_StubTbl[] = 
{
    stub_QueryInterface,
    stub_AddRef,
    stub_Release,
    stub_OnUpdate,
};

HRESULT CStubITfLangBarItemSink::stub_OnUpdate(CStub *_this, MARSHALMSG *pMsg, CSharedBlock *psb)
{
    DWORD dw = 0;

    PREPARE_PARAM_START()

    dw = (DWORD)ParamToULONG(pMsg, 0);

    PREPARE_PARAM_END()

    pMsg->hrRet = ((ITfLangBarItemSink *)_this->_punk)->OnUpdate(dw);
    return S_OK;
}

//////////////////////////////////////////////////////////////////////////////
//
// CStubIEnumTfLangBarItems
//
//////////////////////////////////////////////////////////////////////////////

MSTUBCALL CStubIEnumTfLangBarItems::_StubTbl[] = 
{
    stub_QueryInterface,
    stub_AddRef,
    stub_Release,
    stub_Clone,
    stub_Next,
    stub_Reset,
    stub_Skip,
};

HRESULT CStubIEnumTfLangBarItems::stub_Clone(CStub *_this, MARSHALMSG *pMsg, CSharedBlock *psb)
{
    CSTUB_NOT_IMPL()
}

HRESULT CStubIEnumTfLangBarItems::stub_Next(CStub *_this, MARSHALMSG *pMsg, CSharedBlock *psb)
{
    ULONG ulCount;
    ULONG ulFetched;
    HRESULT hrRet;
    IUnknown **ppunk;

    PREPARE_PARAM_START()

    ulCount = ParamToULONG(pMsg, 0);

    PREPARE_PARAM_END()

    ppunk = new IUnknown*[ulCount];
    if (!ppunk)
         return E_OUTOFMEMORY;

    hrRet = ((IEnumTfLangBarItems *)_this->_punk)->Next(ulCount, (ITfLangBarItem **)ppunk, &ulFetched);

    CSTUB_PARAM_START()
    CSTUB_PARAM_ULONG_IN(ulCount)
    CSTUB_PARAM_INTERFACE_ARRAY_OUT(ppunk, IID_ITfLangBarItem, ulCount)
    CSTUB_PARAM_POINTER_OUT(&ulFetched)
    CSTUB_PARAM_END()
    CSTUB_PARAM_CALL(pMsg, hrRet, psb);
    CSTUB_PARAM_INTERFACE_ARRAY_OUT_RELEASE(ppunk, ulFetched)

    delete ppunk;
    CSTUB_PARAM_RETURN()
}

HRESULT CStubIEnumTfLangBarItems::stub_Reset(CStub *_this, MARSHALMSG *pMsg, CSharedBlock *psb)
{
    CSTUB_NOT_IMPL()
}

HRESULT CStubIEnumTfLangBarItems::stub_Skip(CStub *_this, MARSHALMSG *pMsg, CSharedBlock *psb)
{
    CSTUB_NOT_IMPL()
}

//////////////////////////////////////////////////////////////////////////////
//
// CStubITfLangBarItem
//
//////////////////////////////////////////////////////////////////////////////

MSTUBCALL CStubITfLangBarItem::_StubTbl[] = 
{
    stub_QueryInterface,
    stub_AddRef,
    stub_Release,
    stub_GetInfo,
    stub_GetStatus,
    stub_Show,
    stub_GetTooltipString
};

HRESULT CStubITfLangBarItem::stub_GetInfo(CStub *_this, MARSHALMSG *pMsg, CSharedBlock *psb)
{
    HRESULT hrRet;
    TF_LANGBARITEMINFO info;
    hrRet = ((ITfLangBarItem *)_this->_punk)->GetInfo(&info);
    CSTUB_PARAM_START()
    CSTUB_PARAM_POINTER_OUT(&info)
    CSTUB_PARAM_END()
    CSTUB_PARAM_CALL(pMsg, hrRet, psb)
    CSTUB_PARAM_RETURN()
}

HRESULT CStubITfLangBarItem::stub_GetStatus(CStub *_this, MARSHALMSG *pMsg, CSharedBlock *psb)
{
    HRESULT hrRet;
    DWORD dw;
    hrRet = ((ITfLangBarItem *)_this->_punk)->GetStatus(&dw);
    CSTUB_PARAM_START()
    CSTUB_PARAM_POINTER_OUT(&dw)
    CSTUB_PARAM_END()
    CSTUB_PARAM_CALL(pMsg, hrRet, psb)
    CSTUB_PARAM_RETURN()
}

HRESULT CStubITfLangBarItem::stub_Show(CStub *_this, MARSHALMSG *pMsg, CSharedBlock *psb)
{
    BOOL fShow = FALSE;

    PREPARE_PARAM_START()

    fShow = (BOOL)ParamToULONG(pMsg, 0);

    PREPARE_PARAM_END()

    pMsg->hrRet = ((ITfLangBarItem *)_this->_punk)->Show(fShow);
    return S_OK;
}

HRESULT CStubITfLangBarItem::stub_GetTooltipString(CStub *_this, MARSHALMSG *pMsg, CSharedBlock *psb)
{
    BSTR bstr = NULL;
    HRESULT hrRet = ((ITfLangBarItem *)_this->_punk)->GetTooltipString(&bstr);
    CSTUB_PARAM_START()
    CSTUB_PARAM_BSTR_OUT(bstr)
    CSTUB_PARAM_END()
    CSTUB_PARAM_CALL(pMsg, hrRet, psb)
    CSTUB_PARAM_RETURN()
}

//////////////////////////////////////////////////////////////////////////////
//
// CStubITfLangBarItemButton
//
//////////////////////////////////////////////////////////////////////////////

MSTUBCALL CStubITfLangBarItemButton::_StubTbl[] = 
{
    stub_QueryInterface,
    stub_AddRef,
    stub_Release,
    stub_GetInfo,
    stub_GetStatus,
    stub_Show,
    stub_GetTooltipString,
    stub_OnClick,
    stub_InitMenu,
    stub_OnMenuSelect,
    stub_GetIcon,
    stub_GetText,
};

HRESULT CStubITfLangBarItemButton::stub_OnClick(CStub *_this, MARSHALMSG *pMsg, CSharedBlock *psb)
{
    TfLBIClick click;
    POINT pt;
    RECT rc;

    PREPARE_PARAM_START()

    click = (TfLBIClick)ParamToULONG(pMsg, 0);
    pt = *(POINT *)ParamToBufferPointer(pMsg, 1);
    rc = *(RECT *)ParamToBufferPointer(pMsg, 2);

    PREPARE_PARAM_END()

    pMsg->hrRet = ((ITfLangBarItemButton *)_this->_punk)->OnClick(click, pt, &rc);
    return S_OK;
}

HRESULT CStubITfLangBarItemButton::stub_InitMenu(CStub *_this, MARSHALMSG *pMsg, CSharedBlock *psb)
{
    ITfMenu *punk = NULL;

    PREPARE_PARAM_START()

    punk = (ITfMenu *)ParamToMarshaledPointer(pMsg, IID_ITfMenu, 0);

    PREPARE_PARAM_END()

    pMsg->hrRet = ((ITfLangBarItemButton *)_this->_punk)->InitMenu(punk);

    CSTUB_PARAM_INTERFACE_OUT_RELEASE(punk)
    CSTUB_PARAM_RETURN()
}

HRESULT CStubITfLangBarItemButton::stub_OnMenuSelect(CStub *_this, MARSHALMSG *pMsg, CSharedBlock *psb)
{
    ULONG ulId;

    PREPARE_PARAM_START()

    ulId = (ULONG)ParamToULONG(pMsg, 0);

    PREPARE_PARAM_END()

    pMsg->hrRet = ((ITfLangBarItemButton *)_this->_punk)->OnMenuSelect(ulId);
    return S_OK;
}

HRESULT CStubITfLangBarItemButton::stub_GetIcon(CStub *_this, MARSHALMSG *pMsg, CSharedBlock *psb)
{
    HICON hIcon;
    HRESULT hrRet = ((ITfLangBarItemButton *)_this->_punk)->GetIcon(&hIcon);
    CSTUB_PARAM_START()
    CSTUB_PARAM_HICON_OUT(&hIcon)
    CSTUB_PARAM_END()
    CSTUB_PARAM_CALL(pMsg, hrRet, psb)
    CSTUB_PARAM_RETURN()
}

HRESULT CStubITfLangBarItemButton::stub_GetText(CStub *_this, MARSHALMSG *pMsg, CSharedBlock *psb)
{
    BSTR bstr = NULL;
    HRESULT hrRet = ((ITfLangBarItemButton *)_this->_punk)->GetText(&bstr);
    CSTUB_PARAM_START()
    CSTUB_PARAM_BSTR_OUT(bstr)
    CSTUB_PARAM_END()
    CSTUB_PARAM_CALL(pMsg, hrRet, psb)
    CSTUB_PARAM_RETURN()
}

//////////////////////////////////////////////////////////////////////////////
//
// CStubITfLangBarItemBitmapButton
//
//////////////////////////////////////////////////////////////////////////////

MSTUBCALL CStubITfLangBarItemBitmapButton::_StubTbl[] = 
{
    stub_QueryInterface,
    stub_AddRef,
    stub_Release,
    stub_GetInfo,
    stub_GetStatus,
    stub_Show,
    stub_GetTooltipString,
    stub_OnClick,
    stub_InitMenu,
    stub_OnMenuSelect,
    stub_GetPreferredSize,
    stub_DrawBitmap,
    stub_GetText,
};

HRESULT CStubITfLangBarItemBitmapButton::stub_OnClick(CStub *_this, MARSHALMSG *pMsg, CSharedBlock *psb)
{
    TfLBIClick click;
    POINT pt;
    RECT rc;

    PREPARE_PARAM_START()

    click = (TfLBIClick)ParamToULONG(pMsg, 0);
    pt = *(POINT *)ParamToBufferPointer(pMsg, 1);
    rc = *(RECT *)ParamToBufferPointer(pMsg, 2);

    PREPARE_PARAM_END()

    pMsg->hrRet = ((ITfLangBarItemBitmapButton *)_this->_punk)->OnClick(click, pt, &rc);
    return S_OK;
}

HRESULT CStubITfLangBarItemBitmapButton::stub_InitMenu(CStub *_this, MARSHALMSG *pMsg, CSharedBlock *psb)
{
    ITfMenu *punk;

    PREPARE_PARAM_START()

    punk = (ITfMenu *)ParamToMarshaledPointer(pMsg, IID_ITfMenu, 0);

    PREPARE_PARAM_END()

    pMsg->hrRet = ((ITfLangBarItemBitmapButton *)_this->_punk)->InitMenu(punk);

    CSTUB_PARAM_INTERFACE_OUT_RELEASE(punk)
    CSTUB_PARAM_RETURN()
}

HRESULT CStubITfLangBarItemBitmapButton::stub_OnMenuSelect(CStub *_this, MARSHALMSG *pMsg, CSharedBlock *psb)
{
    ULONG ulId;

    PREPARE_PARAM_START()

    ulId = (ULONG)ParamToULONG(pMsg, 0);

    PREPARE_PARAM_END()

    pMsg->hrRet = ((ITfLangBarItemBitmapButton *)_this->_punk)->OnMenuSelect(ulId);
    return S_OK;
}

HRESULT CStubITfLangBarItemBitmapButton::stub_GetPreferredSize(CStub *_this, MARSHALMSG *pMsg, CSharedBlock *psb)
{
    SIZE size;
    SIZE sizeOut;

    PREPARE_PARAM_START()

    size = *(SIZE *)ParamToBufferPointer(pMsg, 0);

    PREPARE_PARAM_END()

    HRESULT hrRet = ((ITfLangBarItemBitmapButton *)_this->_punk)->GetPreferredSize(&size, &sizeOut);
    CSTUB_PARAM_START()
    CSTUB_PARAM_POINTER_IN(&size)
    CSTUB_PARAM_POINTER_OUT(&sizeOut)
    CSTUB_PARAM_END()
    CSTUB_PARAM_CALL(pMsg, hrRet, psb)
    CSTUB_PARAM_RETURN()
}

HRESULT CStubITfLangBarItemBitmapButton::stub_DrawBitmap(CStub *_this, MARSHALMSG *pMsg, CSharedBlock *psb)
{
    ULONG bmWidth;
    ULONG bmHeight;
    DWORD dwFlags;

    PREPARE_PARAM_START()

    bmWidth = (ULONG)ParamToULONG(pMsg, 0);
    bmHeight = (ULONG)ParamToULONG(pMsg, 1);
    dwFlags = (DWORD)ParamToULONG(pMsg, 2);

    PREPARE_PARAM_END()

    HBITMAP hbmp;
    HBITMAP hbmpMask;
    HRESULT hrRet = ((ITfLangBarItemBitmapButton *)_this->_punk)->DrawBitmap(bmWidth, bmHeight, dwFlags, &hbmp, &hbmpMask);
    CSTUB_PARAM_START()
    CSTUB_PARAM_ULONG_IN(bmWidth)
    CSTUB_PARAM_ULONG_IN(bmHeight)
    CSTUB_PARAM_ULONG_IN(dwFlags)
    CSTUB_PARAM_HBITMAP_OUT(&hbmp)
    CSTUB_PARAM_HBITMAP_OUT(&hbmpMask)
    CSTUB_PARAM_END()
    CSTUB_PARAM_CALL(pMsg, hrRet, psb)
    CSTUB_PARAM_RETURN()
}

HRESULT CStubITfLangBarItemBitmapButton::stub_GetText(CStub *_this, MARSHALMSG *pMsg, CSharedBlock *psb)
{
    BSTR bstr = NULL;
    HRESULT hrRet = ((ITfLangBarItemBitmapButton *)_this->_punk)->GetText(&bstr);
    CSTUB_PARAM_START()
    CSTUB_PARAM_BSTR_OUT(bstr)
    CSTUB_PARAM_END()
    CSTUB_PARAM_CALL(pMsg, hrRet, psb)
    CSTUB_PARAM_RETURN()
}

//////////////////////////////////////////////////////////////////////////////
//
// CStubITfLangBarItemBitmap
//
//////////////////////////////////////////////////////////////////////////////

MSTUBCALL CStubITfLangBarItemBitmap::_StubTbl[] = 
{
    stub_QueryInterface,
    stub_AddRef,
    stub_Release,
    stub_GetInfo,
    stub_GetStatus,
    stub_Show,
    stub_GetTooltipString,
    stub_OnClick,
    stub_GetPreferredSize,
    stub_DrawBitmap,
};

HRESULT CStubITfLangBarItemBitmap::stub_OnClick(CStub *_this, MARSHALMSG *pMsg, CSharedBlock *psb)
{
    TfLBIClick click;
    POINT pt;
    RECT rc;

    PREPARE_PARAM_START()

    click = (TfLBIClick)ParamToULONG(pMsg, 0);
    pt = *(POINT *)ParamToBufferPointer(pMsg, 1);
    rc = *(RECT *)ParamToBufferPointer(pMsg, 2);

    PREPARE_PARAM_END()

    pMsg->hrRet = ((ITfLangBarItemBitmap *)_this->_punk)->OnClick(click, pt, &rc);
    return S_OK;
}

HRESULT CStubITfLangBarItemBitmap::stub_GetPreferredSize(CStub *_this, MARSHALMSG *pMsg, CSharedBlock *psb)
{
    SIZE size;
    SIZE sizeOut;

    PREPARE_PARAM_START()

    size = *(SIZE *)ParamToBufferPointer(pMsg, 0);

    PREPARE_PARAM_END()

    HRESULT hrRet = ((ITfLangBarItemBitmap *)_this->_punk)->GetPreferredSize(&size, &sizeOut);
    CSTUB_PARAM_START()
    CSTUB_PARAM_POINTER_IN(&size)
    CSTUB_PARAM_POINTER_OUT(&sizeOut)
    CSTUB_PARAM_END()
    CSTUB_PARAM_CALL(pMsg, hrRet, psb)
    CSTUB_PARAM_RETURN()
}

HRESULT CStubITfLangBarItemBitmap::stub_DrawBitmap(CStub *_this, MARSHALMSG *pMsg, CSharedBlock *psb)
{
    ULONG bmWidth;
    ULONG bmHeight;
    DWORD dwFlags;

    PREPARE_PARAM_START()

    bmWidth = (ULONG)ParamToULONG(pMsg, 0);
    bmHeight = (ULONG)ParamToULONG(pMsg, 1);
    dwFlags = (DWORD)ParamToULONG(pMsg, 2);

    PREPARE_PARAM_END()

    HBITMAP hbmp;
    HBITMAP hbmpMask;
    HRESULT hrRet = ((ITfLangBarItemBitmap *)_this->_punk)->DrawBitmap(bmWidth, bmHeight, dwFlags, &hbmp, &hbmpMask);
    CSTUB_PARAM_START()
    CSTUB_PARAM_ULONG_IN(bmWidth)
    CSTUB_PARAM_ULONG_IN(bmHeight)
    CSTUB_PARAM_ULONG_IN(dwFlags)
    CSTUB_PARAM_HBITMAP_OUT(&hbmp)
    CSTUB_PARAM_HBITMAP_OUT(&hbmpMask)
    CSTUB_PARAM_END()
    CSTUB_PARAM_CALL(pMsg, hrRet, psb)
    CSTUB_PARAM_RETURN()
}

//////////////////////////////////////////////////////////////////////////////
//
// CStubITfLangBarItemBalloon
//
//////////////////////////////////////////////////////////////////////////////

MSTUBCALL CStubITfLangBarItemBalloon::_StubTbl[] = 
{
    stub_QueryInterface,
    stub_AddRef,
    stub_Release,
    stub_GetInfo,
    stub_GetStatus,
    stub_Show,
    stub_GetTooltipString,
    stub_OnClick,
    stub_GetPreferredSize,
    stub_GetBalloonInfo,
};

HRESULT CStubITfLangBarItemBalloon::stub_OnClick(CStub *_this, MARSHALMSG *pMsg, CSharedBlock *psb)
{
    TfLBIClick click;
    POINT pt;
    RECT rc;

    PREPARE_PARAM_START()

    click = (TfLBIClick)ParamToULONG(pMsg, 0);
    pt = *(POINT *)ParamToBufferPointer(pMsg, 1);
    rc = *(RECT *)ParamToBufferPointer(pMsg, 2);

    PREPARE_PARAM_END()

    pMsg->hrRet = ((ITfLangBarItemBalloon *)_this->_punk)->OnClick(click, pt, &rc);
    return S_OK;
}

HRESULT CStubITfLangBarItemBalloon::stub_GetPreferredSize(CStub *_this, MARSHALMSG *pMsg, CSharedBlock *psb)
{
    SIZE size;
    SIZE sizeOut;

    PREPARE_PARAM_START()

    size = *(SIZE *)ParamToBufferPointer(pMsg, 0);

    PREPARE_PARAM_END()

    HRESULT hrRet = ((ITfLangBarItemBalloon *)_this->_punk)->GetPreferredSize(&size, &sizeOut);
    CSTUB_PARAM_START()
    CSTUB_PARAM_POINTER_IN(&size)
    CSTUB_PARAM_POINTER_OUT(&sizeOut)
    CSTUB_PARAM_END()
    CSTUB_PARAM_CALL(pMsg, hrRet, psb)
    CSTUB_PARAM_RETURN()
}

HRESULT CStubITfLangBarItemBalloon::stub_GetBalloonInfo(CStub *_this, MARSHALMSG *pMsg, CSharedBlock *psb)
{
    TF_LBBALLOONINFO info;
    HRESULT hrRet = ((ITfLangBarItemBalloon *)_this->_punk)->GetBalloonInfo(&info);
    CSTUB_PARAM_START()
    CSTUB_PARAM_TF_LBBALLOONINFO_OUT(&info)
    CSTUB_PARAM_END()
    CSTUB_PARAM_CALL(pMsg, hrRet, psb)
    CSTUB_PARAM_RETURN()
}

//////////////////////////////////////////////////////////////////////////////
//
// CStubITfMenu
//
//////////////////////////////////////////////////////////////////////////////

MSTUBCALL CStubITfMenu::_StubTbl[] = 
{
    stub_QueryInterface,
    stub_AddRef,
    stub_Release,
    stub_AddItemMenu,
};

HRESULT CStubITfMenu::stub_AddItemMenu(CStub *_this, MARSHALMSG *pMsg, CSharedBlock *psb)
{
    UINT uId = 0;
    DWORD dwFlags = 0;
    HBITMAP hbmp = NULL;
    HBITMAP hbmpMask = NULL;
    WCHAR *pchTemp = NULL;
    ULONG cch = 0;
    WCHAR *pch = NULL;
    BOOL fNULLStack;
    ITfMenu *pMenu = NULL;

    PREPARE_PARAM_START()

    uId = (ULONG)ParamToULONG(pMsg, 0);
    dwFlags = (ULONG)ParamToULONG(pMsg, 1);
    hbmp = ParamToHBITMAP(pMsg, 2);
    hbmpMask = ParamToHBITMAP(pMsg, 3);
    pchTemp = (WCHAR *)ParamToBufferPointer(pMsg, 4);
    cch = (ULONG)ParamToULONG(pMsg, 5);
    pch = new WCHAR[cch + 1];
    if (pch)
        wcsncpy(pch, pchTemp, cch);

    pMenu = (ITfMenu *)ParamToMarshaledPointer(pMsg, IID_ITfMenu, 6, &fNULLStack);

    PREPARE_PARAM_END()

    if (!pch)
        return E_OUTOFMEMORY;


    HRESULT hrRet = ((ITfMenu *)_this->_punk)->AddMenuItem(uId,
                                             dwFlags,
                                             hbmp,
                                             hbmpMask,
                                             pch,
                                             cch,
                                             !fNULLStack ? &pMenu : NULL);

    CSTUB_PARAM_START()
    CSTUB_PARAM_ULONG_IN(uId)
    CSTUB_PARAM_ULONG_IN(dwFlags)
    CSTUB_PARAM_HBITMAP_IN(hbmp)
    CSTUB_PARAM_HBITMAP_IN(hbmpMask)
    CSTUB_PARAM_POINTER_IN(pch)
    CSTUB_PARAM_ULONG_IN(cch)
    CSTUB_PARAM_INTERFACE_OUT(&pMenu, IID_ITfMenu)
    CSTUB_PARAM_END()
    CSTUB_PARAM_CALL(pMsg, hrRet, psb)
    CSTUB_PARAM_INTERFACE_OUT_RELEASE(pMenu)

    delete pch;

    CSTUB_PARAM_RETURN()
}

//////////////////////////////////////////////////////////////////////////////
//
// CStubITfInputProcessorProfiles
//
//////////////////////////////////////////////////////////////////////////////

MSTUBCALL CStubITfInputProcessorProfiles::_StubTbl[] = 
{
    stub_QueryInterface,
    stub_AddRef,
    stub_Release,
    stub_Register,
    stub_Unregister,
    stub_AddLanguageProfile,
    stub_RemoveLanguageProfile,
    stub_EnumInputProcessorInfo,
    stub_GetDefaultLanguageProfile,
    stub_SetDefaultLanguageProfile,
    stub_ActivateLanguageProfile,
    stub_GetActiveLanguageProfile,
    stub_GetCurrentLanguage,
    stub_ChangeCurrentLanguage,
    stub_GetLanguageList,
    stub_EnumLanguageProfiles,
    stub_EnableLanguageProfile,
    stub_IsEnabledLanguageProfile,
    stub_EnableLanguageProfileByDefault,
    stub_SubstituteKeyboardLayout,
};


HRESULT CStubITfInputProcessorProfiles::stub_Register(CStub *_this, MARSHALMSG *pMsg, CSharedBlock *psb)
{
    CSTUB_NOT_IMPL()
}

HRESULT CStubITfInputProcessorProfiles::stub_Unregister(CStub *_this, MARSHALMSG *pMsg, CSharedBlock *psb)
{
    CSTUB_NOT_IMPL()
}

HRESULT CStubITfInputProcessorProfiles::stub_AddLanguageProfile(CStub *_this, MARSHALMSG *pMsg, CSharedBlock *psb)
{
    CSTUB_NOT_IMPL()
}

HRESULT CStubITfInputProcessorProfiles::stub_RemoveLanguageProfile(CStub *_this, MARSHALMSG *pMsg, CSharedBlock *psb)
{
    CSTUB_NOT_IMPL()
}

HRESULT CStubITfInputProcessorProfiles::stub_EnumInputProcessorInfo(CStub *_this, MARSHALMSG *pMsg, CSharedBlock *psb)
{
    CSTUB_NOT_IMPL()
}

HRESULT CStubITfInputProcessorProfiles::stub_GetDefaultLanguageProfile(CStub *_this, MARSHALMSG *pMsg, CSharedBlock *psb)
{
    CSTUB_NOT_IMPL()
}

HRESULT CStubITfInputProcessorProfiles::stub_SetDefaultLanguageProfile(CStub *_this, MARSHALMSG *pMsg, CSharedBlock *psb)
{
    CSTUB_NOT_IMPL()
}

HRESULT CStubITfInputProcessorProfiles::stub_ActivateLanguageProfile(CStub *_this, MARSHALMSG *pMsg, CSharedBlock *psb)
{
    CSTUB_NOT_IMPL()
}

HRESULT CStubITfInputProcessorProfiles::stub_GetActiveLanguageProfile(CStub *_this, MARSHALMSG *pMsg, CSharedBlock *psb)
{
    CSTUB_NOT_IMPL()
}

HRESULT CStubITfInputProcessorProfiles::stub_GetLanguageProfileDescription(CStub *_this, MARSHALMSG *pMsg, CSharedBlock *psb)
{
    CSTUB_NOT_IMPL()
}

HRESULT CStubITfInputProcessorProfiles::stub_GetCurrentLanguage(CStub *_this, MARSHALMSG *pMsg, CSharedBlock *psb)
{
    LANGID langid;
    HRESULT hrRet = ((ITfInputProcessorProfiles *)_this->_punk)->GetCurrentLanguage(&langid);
    CSTUB_PARAM_START()
    CSTUB_PARAM_POINTER_OUT(&langid)
    CSTUB_PARAM_END()
    CSTUB_PARAM_CALL(pMsg, hrRet, psb)
    CSTUB_PARAM_RETURN()
}

HRESULT CStubITfInputProcessorProfiles::stub_ChangeCurrentLanguage(CStub *_this, MARSHALMSG *pMsg, CSharedBlock *psb)
{
    CSTUB_NOT_IMPL()
}

HRESULT CStubITfInputProcessorProfiles::stub_GetLanguageList(CStub *_this, MARSHALMSG *pMsg, CSharedBlock *psb)
{
    CSTUB_NOT_IMPL()
}

HRESULT CStubITfInputProcessorProfiles::stub_EnumLanguageProfiles(CStub *_this, MARSHALMSG *pMsg, CSharedBlock *psb)
{
    CSTUB_NOT_IMPL()
}

HRESULT CStubITfInputProcessorProfiles::stub_EnableLanguageProfile(CStub *_this, MARSHALMSG *pMsg, CSharedBlock *psb)
{
    CSTUB_NOT_IMPL()
}

HRESULT CStubITfInputProcessorProfiles::stub_IsEnabledLanguageProfile(CStub *_this, MARSHALMSG *pMsg, CSharedBlock *psb)
{
    CSTUB_NOT_IMPL()
}

HRESULT CStubITfInputProcessorProfiles::stub_EnableLanguageProfileByDefault(CStub *_this, MARSHALMSG *pMsg, CSharedBlock *psb)
{
    CSTUB_NOT_IMPL()
}

HRESULT CStubITfInputProcessorProfiles::stub_SubstituteKeyboardLayout(CStub *_this, MARSHALMSG *pMsg, CSharedBlock *psb)
{
    CSTUB_NOT_IMPL()
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\ctf\uim\normal.cpp ===
//
// normal.cpp
//

#include "private.h"
#include "normal.h"
#include "txtcache.h"

//+---------------------------------------------------------------------------
//
// GetTextComplete
//
// Wrapper for GetText that keeps asking until the input buffers are full.
//----------------------------------------------------------------------------

HRESULT GetTextComplete(ITextStoreACP *ptsi, LONG acpStart, LONG acpEnd,
                        WCHAR *pchPlain, ULONG cchPlainReq,
                        ULONG *pcchPlainOut, TS_RUNINFO *prgRunInfo, ULONG ulRunInfoReq, ULONG *pulRunInfoOut,
                        LONG *pacpNext)
{
    ULONG cchPlainOut;
    ULONG ulRunInfoOut;
    BOOL fNoMoreSpace;
    HRESULT hr;

    fNoMoreSpace = FALSE;

    *pcchPlainOut = 0;
    *pulRunInfoOut = 0;

    while (TRUE)
    {
        Perf_IncCounter(PERF_NORM_GETTEXTCOMPLETE);

        hr = CProcessTextCache::GetText(ptsi, acpStart, acpEnd, pchPlain, cchPlainReq, &cchPlainOut,
                                        prgRunInfo, ulRunInfoReq, &ulRunInfoOut, pacpNext);

        if (hr != S_OK)
            break;

        if (cchPlainOut == 0 && ulRunInfoOut == 0)
            break; // eod

        if (cchPlainReq > 0 && cchPlainOut > 0)
        {
            cchPlainReq -= cchPlainOut;
            *pcchPlainOut += cchPlainOut;

            if (cchPlainReq == 0)
            {
                fNoMoreSpace = TRUE;
            }
            else
            {
                pchPlain += cchPlainOut;
            }
        }
        if (ulRunInfoReq > 0)
        {
            Assert(ulRunInfoOut > 0 && prgRunInfo->uCount > 0); // app bug?

            if (ulRunInfoOut == 0)
                break; // woah, app bug, avoid infinite loop

            ulRunInfoReq -= ulRunInfoOut;
            *pulRunInfoOut += ulRunInfoOut;

            if (ulRunInfoReq == 0)
            {
                fNoMoreSpace = TRUE;
            }
            else
            {
                prgRunInfo += ulRunInfoOut;
            }
        }

        if (fNoMoreSpace)
            break; // buffers full

        if (*pacpNext == acpEnd)
            break; // got it all

        acpStart = *pacpNext;
        Assert(acpStart < acpEnd);
    }

    return hr;
}

//+---------------------------------------------------------------------------
//
// PlainTextOffset
//
// NB: current implementation always skips hidden text.
//----------------------------------------------------------------------------

HRESULT PlainTextOffset(ITextStoreACP *ptsi, LONG ichAppBase, LONG iAppOffset, LONG *piPlainOffset)
{
    BOOL fNeg;
    HRESULT hr;
    ULONG uRunInfoLen;
    ULONG cch;
    ULONG cchPlain;
    TS_RUNINFO *pri;
    TS_RUNINFO *priStop;
    TS_RUNINFO rgRunInfo[32];

    *piPlainOffset = 0;

    if (iAppOffset == 0)
        return S_OK;

    fNeg = FALSE;

    if (iAppOffset < 0)
    {
        fNeg = TRUE;
        ichAppBase += iAppOffset;
        iAppOffset = -iAppOffset;
    }

    cchPlain = 0;

    do
    {
        Perf_IncCounter(PERF_PTO_GETTEXT);

        hr = CProcessTextCache::GetText(ptsi, ichAppBase, ichAppBase + iAppOffset, NULL, 0, &cch,
                                        rgRunInfo, ARRAYSIZE(rgRunInfo), &uRunInfoLen, &ichAppBase);

        if (hr != S_OK)
            goto Exit;

        if (uRunInfoLen == 0 || rgRunInfo[0].uCount == 0)
        {
            Assert(0); // this should never happen, it means cicero is referencing a position past end-of-doc
            hr = E_UNEXPECTED;
            goto Exit;
        }

        cch = 0;
        pri = rgRunInfo;
        priStop = rgRunInfo + uRunInfoLen;

        while (pri < priStop)
        {
            if (pri->type == TS_RT_PLAIN)
            {
                cchPlain += pri->uCount;
            }
            iAppOffset -= pri->uCount;
            pri++;
        }

    } while (iAppOffset > 0);

    *piPlainOffset = fNeg ? -(LONG)cchPlain : cchPlain;

    hr = S_OK;

Exit:
    return hr;
}

//+---------------------------------------------------------------------------
//
// AppTextOffsetForward
//
// piAppOffset, on return, points just past the iPlainOffset plain char or eod.
// Use AppTextOffsetNorm for a normalized return value!
//
// Returns S_FALSE if clipped due to bod or eod.
//----------------------------------------------------------------------------

inline IsPlainRun(TS_RUNINFO *pri, BOOL fSkipHidden)
{
    return (pri->type == TS_RT_PLAIN ||
            (!fSkipHidden && pri->type == TS_RT_HIDDEN));
}

HRESULT AppTextOffsetForward(ITextStoreACP *ptsi, LONG ichAppBase, LONG iPlainOffset, LONG *piAppOffset, DWORD dwFlags)
{
    LONG acpStart;
    LONG acpEnd;
    HRESULT hr;
    ULONG uRunInfoLen;
    ULONG cch;
    ULONG cchRead;
    ULONG cchACP;
    TS_RUNINFO *pri;
    TS_RUNINFO *priStop;
    ULONG i;
    WCHAR *pch;
    TS_RUNINFO rgRunInfo[32];
    WCHAR ach[256];
    BOOL fIgnoreRegions = (dwFlags & ATO_IGNORE_REGIONS);
    BOOL fSkipHidden = (dwFlags & ATO_SKIP_HIDDEN);

    Perf_IncCounter(PERF_ATOF_COUNTER);

    Assert(iPlainOffset > 0);
    Assert(*piAppOffset == 0);

    cchACP = 0;
    // Issue: use TsSF_REGIONS
    cchRead = (ULONG)(fIgnoreRegions ? 0 : ARRAYSIZE(ach)); // we only need text if looking for regions

    do
    {        
        acpStart = ichAppBase;
        acpEnd = (ichAppBase + iPlainOffset) < 0 ? LONG_MAX : ichAppBase + iPlainOffset;
        Assert(acpEnd >= acpStart);

        Perf_IncCounter(PERF_ATOF_GETTEXT_COUNTER);

        hr = CProcessTextCache::GetText(ptsi, acpStart, acpEnd, ach, cchRead, &cch,
                                        rgRunInfo, ARRAYSIZE(rgRunInfo), &uRunInfoLen, &acpEnd);

        if (hr != S_OK)
        {
            Assert(0);
            goto Exit;
        }

        if (uRunInfoLen == 0) // hit eod?
        {
            hr = S_FALSE;
            break;
        }

        pri = rgRunInfo;
        priStop = rgRunInfo + uRunInfoLen;
        pch = &ach[0];

        while (pri != priStop)
        {
            Assert(pri->uCount > 0); // runs should always be at least one char long

            // scan for region boundary if necessary
            if (!fIgnoreRegions && pri->type != TS_RT_OPAQUE)
            {
                if (IsPlainRun(pri, fSkipHidden))
                {
                    // run is plain or hidden text (and we want to count hidden text)
                    for (i=0; i<pri->uCount; i++)
                    {
                        if (*pch == TS_CHAR_REGION)
                        {
                            // we hit a region boundary, pull out!
                            cchACP += i;
                            hr = S_FALSE; // for normalization
                            goto ExitOK;
                        }
                        pch++;
                    }
                }
                else
                {
                    // run is hidden text, which we want to skip over
                    pch += pri->uCount;
                }       
            }

            cchACP += pri->uCount;
            if (IsPlainRun(pri, fSkipHidden))
            {
                iPlainOffset -= pri->uCount;
            }
            ichAppBase += pri->uCount;
            pri++;
        }
    }
    while (iPlainOffset != 0);

ExitOK:
    *piAppOffset = cchACP;

Exit:
    return hr;
}

//+---------------------------------------------------------------------------
//
// AppTextOffsetBackward
//
// piAppOffset, on return, points just past the iPlainOffset plain char or eod.
// Use AppTextOffsetNorm for a normalized return value!
//
// Returns S_FALSE if clipped due to bod or eod.
//----------------------------------------------------------------------------

HRESULT AppTextOffsetBackward(ITextStoreACP *ptsi, LONG ichAppBase, LONG iPlainOffset, LONG *piAppOffset, DWORD dwFlags)
{
    LONG acpStart;
    LONG acpEnd;
    LONG acpEndOut;
    HRESULT hr;
    ULONG uRunInfoLen;
    ULONG cch;
    ULONG cchRead;
    ULONG cchACP;
    TS_RUNINFO *pri;
    TS_RUNINFO *priStop;
    ULONG i;
    TS_RUNINFO rgRunInfo[32];
    WCHAR *pch;
    WCHAR ach[256];
    BOOL fIgnoreRegions = (dwFlags & ATO_IGNORE_REGIONS);
    BOOL fSkipHidden = (dwFlags & ATO_SKIP_HIDDEN);

    Assert(iPlainOffset < 0);
    Assert(*piAppOffset == 0);

    cchACP = 0;
    // Issue: use TsSF_REGIONS
    cchRead = (ULONG)(fIgnoreRegions ? 0 : ARRAYSIZE(ach)); // we only need text if looking for regions

    do
    {
        Assert(iPlainOffset < 0); // if this is >= 0, we or the app messed up the formatting run count

        acpStart = ichAppBase + (fIgnoreRegions ? iPlainOffset : max(iPlainOffset, -(LONG)ARRAYSIZE(ach)));
        acpStart = max(acpStart, 0); // handle top-of-doc collisions
        acpEnd = ichAppBase;
        Assert(acpEnd >= acpStart);

        hr = GetTextComplete(ptsi, acpStart, acpEnd, ach, cchRead, &cch,
                             rgRunInfo, ARRAYSIZE(rgRunInfo), &uRunInfoLen, &acpEndOut);

        if (hr != S_OK)
        {
            Assert(0);
            goto Exit;
        }

        if (uRunInfoLen == 0) // hit eod?
        {
            hr = S_FALSE;
            break;
        }

        // it's possible the GetText above didn't return everything we asked for....
        // this happens when our format buffer isn't large enough
        if (acpEndOut != acpEnd)
        {
            // so let's be conservative and ask for something we know should succeed
            acpStart = ichAppBase - ARRAYSIZE(rgRunInfo);

            Assert(acpStart >= 0); // the prev GetText should have succeeded if there were fewer chars than we're asking for now....
            Assert(acpEnd - acpStart < -iPlainOffset); // again, we shouldn't get this far if we already asked for fewer chars
            Assert(ARRAYSIZE(rgRunInfo) < ARRAYSIZE(ach)); // want to ask for the max we can handle in the worst case
            Assert(acpEnd == ichAppBase);

            hr = GetTextComplete(ptsi, acpStart, acpEnd, ach, cchRead, &cch,
                                 rgRunInfo, ARRAYSIZE(rgRunInfo), &uRunInfoLen, &acpEndOut);

            if (hr != S_OK)
            {
                Assert(0);
                goto Exit;
            }

            if (uRunInfoLen == 0) // hit eod?
            {
                Assert(0); // this should never happen, because the original call for more chars returned non-zero!
                goto Exit;
            }

            Assert(acpEnd == acpEndOut);
        }

        pri = rgRunInfo + uRunInfoLen - 1;
        priStop = rgRunInfo - 1;
        pch = &ach[cch-1];

        while (pri != priStop)
        {
            Assert(pri->uCount > 0); // runs should always be at least one char long

            // scan for region boundary if necessary
            if (!fIgnoreRegions && pri->type != TS_RT_OPAQUE)
            {
                if (IsPlainRun(pri, fSkipHidden))
                {
                    // run is plain or hidden text (and we want to count hidden text)
                    for (i=0; i<pri->uCount; i++)
                    {
                        if (*pch == TS_CHAR_REGION)
                        {
                            // we hit a region boundary, pull out!
                            cchACP += i;
                            hr = S_FALSE; // for normalization
                            goto ExitOK;
                        }
                        pch--;
                    }
                }
                else
                {
                    // run is hidden text, which we want to skip over
                    pch -= pri->uCount;
                }       
            }

            cchACP += pri->uCount;
            if (IsPlainRun(pri, fSkipHidden))
            {
                iPlainOffset += (LONG)pri->uCount;
            }
            ichAppBase -= (LONG)pri->uCount;
            pri--;
        }

        // also check for top-of-doc
        if (ichAppBase == 0)
        {
            hr = S_FALSE;
            break;
        }

    } while (iPlainOffset != 0);

ExitOK:
    *piAppOffset = -(LONG)cchACP;

Exit:
    return hr;
}

#ifdef UNUSED
//+---------------------------------------------------------------------------
//
// AppTextOffsetNorm
//
// Returns a normalized acp offset that spans the specificed number of plain chars --
// so the return offset is just short of (lPlainOffset + 1), or at eod.  Returns
// S_FALSE if the initial call to AppTextOffset gets clipped because of eod.
//----------------------------------------------------------------------------

HRESULT AppTextOffsetNorm(ITextStoreACP *ptsi, LONG acpAppBase, LONG lPlainOffset, LONG *plAppOffset)
{
    HRESULT hr;

    Perf_IncCounter(PERF_ATON_COUNTER);

    // if caller wants a neg offset, return value is already
    // guarenteed normalized -- just before a plain text char.
    // Otherwise, ask for the offset of the next char, then
    // step back one char.
    if ((lPlainOffset < LONG_MAX) && (lPlainOffset >= 0))
    {
        lPlainOffset++;
    }

    hr = AppTextOffset(ptsi, acpAppBase, lPlainOffset, plAppOffset, FALSE);

    if (*plAppOffset > 0)
    {
        if ((lPlainOffset < LONG_MAX) && (hr == S_OK)) // could be S_FALSE if hit eod
        {
            // step back, and we're normalized
            (*plAppOffset)--;
        }
    }
    else if (*plAppOffset < 0)
    {
        // if we moved backwards there's only one case to
        // worry about: if we hit a region boundary.  Then
        // we need to normalize.
        if (hr == S_FALSE)
        {
            *plAppOffset = Normalize(ptsi, acpAppBase + *plAppOffset) - acpAppBase;
        }
    }

#ifndef PERF_DUMP
    Assert(*plAppOffset == Normalize(ptsi, acpAppBase + *plAppOffset) - acpAppBase);
#endif

    return hr;
}
#endif // UNUSED
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\ctf\uim\mstub.h ===
//
// mstub.h
//

#ifndef MSTUB_H
#define MSTUB_H

#include "private.h"
#include "marshal.h"
#include "ptrary.h"
#include "strary.h"
#include "cicmutex.h"
#include "smblock.h"

typedef HRESULT (*MSTUBCALL)(CStub *_this, MARSHALMSG *pMsg, CSharedBlock *psb);

CStub *StubCreator(REFIID riid, IUnknown *punk, ULONG ulStubId, DWORD dwStubTime, DWORD dwCurThreadId, DWORD dwCurProcessId, DWORD dwSrcThreadId);

#define STUBINVOKE_IMPL(interface_name)                                       \
    public:                                                                   \
        HRESULT Invoke(MARSHALMSG *pMsg, CSharedBlock *psb)                   \
        {                                                                     \
            TraceMsg(TF_FUNC,                                                 \
                     "Stub " #interface_name " ulMethodId - %x",              \
                     pMsg->ulMethodId);                                       \
            return _StubTbl[pMsg->ulMethodId](this, pMsg, psb);               \
        }                                                                     \
    private:                                                                  \
        static MSTUBCALL _StubTbl[]; 

#define STUBFUNC_DEF(method_name)                                             \
    static HRESULT stub_ ## method_name ## (CStub *_this, MARSHALMSG *pMsg, CSharedBlock *psb);

//////////////////////////////////////////////////////////////////////////////
//
// CStubIUnknown
//
//////////////////////////////////////////////////////////////////////////////

class CStubIUnknown : public CStub
{
    STUBINVOKE_IMPL(IUnknwon);
protected:
    STUBFUNC_DEF(QueryInterface)
    STUBFUNC_DEF(AddRef)
    STUBFUNC_DEF(Release)
};

//////////////////////////////////////////////////////////////////////////////
//
// CStubITfLangBarMgr
//
//////////////////////////////////////////////////////////////////////////////

class CStubITfLangBarMgr : public CStubIUnknown
{
    STUBINVOKE_IMPL(ITfLangBarMgr);
private:
    STUBFUNC_DEF(AdviseEventSink)
    STUBFUNC_DEF(UnadviseEventSink)
    STUBFUNC_DEF(GetThreadMarshalInterface)
    STUBFUNC_DEF(GetThreadLangBarItemMgr)
    STUBFUNC_DEF(GetInputProcessorProfiles)
    STUBFUNC_DEF(RestoreLastFocus)
    STUBFUNC_DEF(SetModalInput)
    STUBFUNC_DEF(ShowFloating)
    STUBFUNC_DEF(GetShowFloatingStatus)
};

//////////////////////////////////////////////////////////////////////////////
//
// CStubITfLangBarItemMgr
//
//////////////////////////////////////////////////////////////////////////////

class CStubITfLangBarItemMgr : public CStubIUnknown
{
    STUBINVOKE_IMPL(ITfLangBarItemMgr);
private:
    STUBFUNC_DEF(EnumItems)
    STUBFUNC_DEF(GetItem)
    STUBFUNC_DEF(AddItem)
    STUBFUNC_DEF(RemoveItem)
    STUBFUNC_DEF(AdviseItemSink)
    STUBFUNC_DEF(UnadviseItemSink)
    STUBFUNC_DEF(GetItemFloatingRect)
    STUBFUNC_DEF(GetItemsStatus)
    STUBFUNC_DEF(GetItemNum)
    STUBFUNC_DEF(GetItems)
    STUBFUNC_DEF(AdviseItemsSink)
    STUBFUNC_DEF(UnadviseItemsSink)

};

//////////////////////////////////////////////////////////////////////////////
//
// CStubITfLangBarItemSink
//
//////////////////////////////////////////////////////////////////////////////

class CStubITfLangBarItemSink : public CStubIUnknown
{
    STUBINVOKE_IMPL(ITfLangBarItemSink);

public:
    STUBFUNC_DEF(OnUpdate)
};

//////////////////////////////////////////////////////////////////////////////
//
// CStubIEnumTfLangBarItemMgr
//
//////////////////////////////////////////////////////////////////////////////

class CStubIEnumTfLangBarItems : public CStubIUnknown
{
    STUBINVOKE_IMPL(IEnumTfLangBarItems);

public:
    STUBFUNC_DEF(Clone)
    STUBFUNC_DEF(Next)
    STUBFUNC_DEF(Reset)
    STUBFUNC_DEF(Skip)
};

//////////////////////////////////////////////////////////////////////////////
//
// CStubITfLangBarItem
//
//////////////////////////////////////////////////////////////////////////////

class CStubITfLangBarItem : public CStubIUnknown
{
    STUBINVOKE_IMPL(ITfLangBarItem);

public:
    STUBFUNC_DEF(GetInfo)
    STUBFUNC_DEF(GetStatus)
    STUBFUNC_DEF(Show)
    STUBFUNC_DEF(GetTooltipString)
};

//////////////////////////////////////////////////////////////////////////////
//
// CStubITfLangBarItemButton
//
//////////////////////////////////////////////////////////////////////////////

class CStubITfLangBarItemButton : public CStubITfLangBarItem
{
    STUBINVOKE_IMPL(ITfLangBarItemButton);

public:
    STUBFUNC_DEF(OnClick)
    STUBFUNC_DEF(InitMenu)
    STUBFUNC_DEF(OnMenuSelect)
    STUBFUNC_DEF(GetIcon)
    STUBFUNC_DEF(GetText)
};

//////////////////////////////////////////////////////////////////////////////
//
// CStubITfLangBarItemBitmapButton
//
//////////////////////////////////////////////////////////////////////////////

class CStubITfLangBarItemBitmapButton : public CStubITfLangBarItem
{
    STUBINVOKE_IMPL(ITfLangBarItemBitmapButton);

public:
    STUBFUNC_DEF(OnClick)
    STUBFUNC_DEF(InitMenu)
    STUBFUNC_DEF(OnMenuSelect)
    STUBFUNC_DEF(GetPreferredSize)
    STUBFUNC_DEF(DrawBitmap)
    STUBFUNC_DEF(GetText)
};

//////////////////////////////////////////////////////////////////////////////
//
// CStubITfLangBarItemBitmap
//
//////////////////////////////////////////////////////////////////////////////

class CStubITfLangBarItemBitmap : public CStubITfLangBarItem
{
    STUBINVOKE_IMPL(ITfLangBarItemBitmap);

public:
    STUBFUNC_DEF(OnClick)
    STUBFUNC_DEF(GetPreferredSize)
    STUBFUNC_DEF(DrawBitmap)
};

//////////////////////////////////////////////////////////////////////////////
//
// CStubITfLangBarItemBalloon
//
//////////////////////////////////////////////////////////////////////////////

class CStubITfLangBarItemBalloon : public CStubITfLangBarItem
{
    STUBINVOKE_IMPL(ITfLangBarItemBalloon);

public:
    STUBFUNC_DEF(OnClick)
    STUBFUNC_DEF(GetPreferredSize)
    STUBFUNC_DEF(GetBalloonInfo)
};

//////////////////////////////////////////////////////////////////////////////
//
// CStubITfMenu
//
//////////////////////////////////////////////////////////////////////////////

class CStubITfMenu : public CStubITfLangBarItem
{
    STUBINVOKE_IMPL(ITfMenu);

public:
    STUBFUNC_DEF(AddItemMenu)
};

//////////////////////////////////////////////////////////////////////////////
//
// CStubITfMenu
//
//////////////////////////////////////////////////////////////////////////////

class CStubITfInputProcessorProfiles : public CStubIUnknown
{
    STUBINVOKE_IMPL(ITfInputProcessorProfiles);
public:
    STUBFUNC_DEF(Register)
    STUBFUNC_DEF(Unregister)
    STUBFUNC_DEF(AddLanguageProfile)
    STUBFUNC_DEF(RemoveLanguageProfile)
    STUBFUNC_DEF(EnumInputProcessorInfo)
    STUBFUNC_DEF(GetDefaultLanguageProfile)
    STUBFUNC_DEF(SetDefaultLanguageProfile)
    STUBFUNC_DEF(ActivateLanguageProfile)
    STUBFUNC_DEF(GetActiveLanguageProfile)
    STUBFUNC_DEF(GetLanguageProfileDescription)
    STUBFUNC_DEF(GetCurrentLanguage)
    STUBFUNC_DEF(ChangeCurrentLanguage)
    STUBFUNC_DEF(GetLanguageList)
    STUBFUNC_DEF(EnumLanguageProfiles)
    STUBFUNC_DEF(EnableLanguageProfile)
    STUBFUNC_DEF(IsEnabledLanguageProfile)
    STUBFUNC_DEF(EnableLanguageProfileByDefault)
    STUBFUNC_DEF(SubstituteKeyboardLayout)
};

#endif MSTUB_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\ctf\uim\mproxy.cpp ===
//
// mproxy.cpp
//

#include "private.h"
#include "mproxy.h"
#include "ithdmshl.h"

/* 344E266C-FB48-4E81-9FD9-0CC8070F984A */
const IID IID_CPROXYPRIV = { 
    0x344E266C,
    0xFB48,
    0x4E81,
    {0x9F, 0xD9, 0x0C, 0xC8, 0x07, 0x0F, 0x98, 0x4A}
 };

DBG_ID_INSTANCE(CProxyIUnknown);
DBG_ID_INSTANCE(CProxyITfLangBarMgr);
DBG_ID_INSTANCE(CProxyITfLangBarItemMgr);
DBG_ID_INSTANCE(CProxyITfLangBarItemSink);
DBG_ID_INSTANCE(CProxyIEnumTfLangBarItems);
DBG_ID_INSTANCE(CProxyITfLangBarItem);
DBG_ID_INSTANCE(CProxyITfLangBarItemButton);
DBG_ID_INSTANCE(CProxyITfLangBarItemBitmapButton);
DBG_ID_INSTANCE(CProxyITfLangBarItemBitmap);
DBG_ID_INSTANCE(CProxyITfLangBarItemBalloon);
DBG_ID_INSTANCE(CProxyITfMenu);
DBG_ID_INSTANCE(CProxyITfInputProcessorProfiles);

//////////////////////////////////////////////////////////////////////////////
//
// ProxyCreator
//
//////////////////////////////////////////////////////////////////////////////

#define CREATENEWPROXY(interface_name)                                    \
    if (IsEqualIID(riid, IID_ ## interface_name ## ))                      \
    {                                                                      \
        CProxy ## interface_name ##  *pProxy =  new CProxy ## interface_name ## (psfn);\
        if (!pProxy)                                                       \
             return NULL;                                                  \
        pProxy->Init(riid, 0, ulStubId, dwStubTime, dwThreadId, dwCurThreadId, dwCurProcessId);                       \
        return SAFECAST(pProxy, ## interface_name ## *);                     \
    }                                                                      

IUnknown *ProxyCreator(SYSTHREAD *psfn, REFIID riid, ULONG ulStubId, DWORD dwStubTime, DWORD dwThreadId, DWORD dwCurThreadId, DWORD dwCurProcessId)
{
    CREATENEWPROXY(IUnknown)
    CREATENEWPROXY(ITfLangBarMgr)
    CREATENEWPROXY(ITfLangBarItemMgr)
    CREATENEWPROXY(ITfLangBarItemSink)
    CREATENEWPROXY(IEnumTfLangBarItems)
    CREATENEWPROXY(ITfLangBarItem)
    CREATENEWPROXY(ITfLangBarItemButton)
    CREATENEWPROXY(ITfLangBarItemBitmapButton)
    CREATENEWPROXY(ITfLangBarItemBitmap)
    CREATENEWPROXY(ITfLangBarItemBalloon)
    CREATENEWPROXY(ITfMenu)
    CREATENEWPROXY(ITfInputProcessorProfiles);
    return NULL;
}


//////////////////////////////////////////////////////////////////////////////
//
// CProxyIUnknown
//
//////////////////////////////////////////////////////////////////////////////

CProxyIUnknown::CProxyIUnknown(SYSTHREAD *psfn) : CProxy(psfn)
{
    Dbg_MemSetThisNameID(TEXT("CProxyIUnknown"));
}

HRESULT CProxyIUnknown::QueryInterface(REFIID riid, void **ppvObj)
{
    TraceMsg(TF_FUNC, "CProxyIUnknown::QueryInterface");

    if (IsEqualIID(riid, IID_CPROXYPRIV))
    {
        *ppvObj = SAFECAST(this, CProxyIUnknown *);
        InternalAddRef();
        return S_OK;
    }

    HRESULT hr = _QueryInterface(riid, ppvObj);
    // if (SUCCEEDED(hr))
    //     InternalAddRef();

    return hr;
}

HRESULT CProxyIUnknown::_QueryInterface(REFIID riid, void **ppvObj)
{
    CPROXY_PARAM_START()
    CPROXY_PARAM_POINTER_IN(&riid)
    CPROXY_PARAM_INTERFACE_OUT(ppvObj, riid)
    CPROXY_PARAM_CALL(0)
}

STDAPI_(ULONG) CProxyIUnknown::AddRef()
{
#ifdef UNKNOWN_MARSHAL
    HRESULT hr;

    TraceMsg(TF_FUNC, "CProxyIUnknown::AddRef");

    CMarshalParamCreator cparam;
    cparam.Init(_iid, 1, 0);
    hr = cparam.SendReceiveULONG(this);
    if (FAILED(hr))
        return hr;
#endif

    return InternalAddRef();
}


STDAPI_(ULONG) CProxyIUnknown::Release()
{
#ifdef UNKNOWN_MARSHAL
    HRESULT hr;

    TraceMsg(TF_FUNC, "CProxyIUnknown::Release");

    CMarshalParamCreator cparam;
    cparam.Init(_iid, 2, 0);
    hr = cparam.SendReceiveULONG(this);
    if (FAILED(hr))
        return hr;
#endif

    return InternalRelease();
}

//////////////////////////////////////////////////////////////////////////////
//
// CProxyITfLangBarMgr
//
//////////////////////////////////////////////////////////////////////////////

CProxyITfLangBarMgr::CProxyITfLangBarMgr(SYSTHREAD *psfn) : CProxyIUnknown(psfn)
{
    Dbg_MemSetThisNameID(TEXT("CProxyITfLangBarMgr"));
}

STDAPI CProxyITfLangBarMgr::AdviseEventSink(ITfLangBarEventSink *pSink, 
                                 HWND hwnd, 
                                 DWORD dwFlags, 
                                 DWORD *pdwCookie)
{
    Assert(0);
    return E_NOTIMPL;
}

STDAPI CProxyITfLangBarMgr::UnadviseEventSink(DWORD dwCookie)
{
    Assert(0);
    return E_NOTIMPL;
}

STDAPI CProxyITfLangBarMgr::GetThreadMarshalInterface(DWORD dwThreadId, 
                                           DWORD dwType, 
                                           REFIID riid, 
                                           IUnknown **ppunk)
{
    Assert(0);
    return E_NOTIMPL;
}

STDAPI CProxyITfLangBarMgr::GetThreadLangBarItemMgr(DWORD dwThreadId, 
                                         ITfLangBarItemMgr **pplbi, 
                                         DWORD *pdwThreadId)
{
    Assert(0);
    return E_NOTIMPL;
}

STDAPI CProxyITfLangBarMgr::GetInputProcessorProfiles(DWORD dwThreadId, 
                                           ITfInputProcessorProfiles **ppaip, 
                                           DWORD *pdwThreadId)
{
    Assert(0);
    return E_NOTIMPL;
}

STDAPI CProxyITfLangBarMgr::RestoreLastFocus(DWORD *pdwThreadId, BOOL fPrev)
{
    Assert(0);
    return E_NOTIMPL;
}

STDAPI CProxyITfLangBarMgr::SetModalInput(ITfLangBarEventSink *pSink, 
                                          DWORD dwThreadId,
                                          DWORD dwFlags)
{
    Assert(0);
    return E_NOTIMPL;
}

STDAPI CProxyITfLangBarMgr::ShowFloating(DWORD dwFlags)
{
    Assert(0);
    return E_NOTIMPL;
}

STDAPI CProxyITfLangBarMgr::GetShowFloatingStatus(DWORD *pdwFlags)
{
    Assert(0);
    return E_NOTIMPL;
}

//////////////////////////////////////////////////////////////////////////////
//
// CProxyITfLangBarItemMgr
//
//////////////////////////////////////////////////////////////////////////////

CProxyITfLangBarItemMgr::CProxyITfLangBarItemMgr(SYSTHREAD *psfn) : CProxyIUnknown(psfn)
{
    Dbg_MemSetThisNameID(TEXT("CProxyITfLangBarItemMgr"));
}

STDMETHODIMP CProxyITfLangBarItemMgr::EnumItems(IEnumTfLangBarItems **ppEnum)
{
    TraceMsg(TF_FUNC, "CProxyITfLangbarItemMgr::EnumItems");
    CPROXY_PARAM_START()
    CPROXY_PARAM_INTERFACE_OUT(ppEnum, IID_IEnumTfLangBarItems)
    CPROXY_PARAM_CALL(3)
}

STDMETHODIMP CProxyITfLangBarItemMgr::GetItem(REFGUID rguid,  ITfLangBarItem **ppItem)
{
#if 1
    Assert(0);
    return E_NOTIMPL;
#else
    TraceMsg(TF_FUNC, "CProxyITfLangbarItemMgr::GetItem");
    CPROXY_PARAM_START()
    CPROXY_PARAM_POINTER_IN(&rguid)
    CPROXY_PARAM_INTERFACE_OUT(ppItem, IID_ITfLangBarItem)
    CPROXY_PARAM_CALL(4)
#endif
}

STDMETHODIMP CProxyITfLangBarItemMgr::AddItem(ITfLangBarItem *punk)
{
#if 1
    Assert(0);
    return E_NOTIMPL;
#else
    TraceMsg(TF_FUNC, "CProxyITfLangbarItemMgr::AddItem");
    CPROXY_PARAM_START()
    CPROXY_PARAM_INTERFACE_IN(&punk, IID_ITfLangBarItem)
    CPROXY_PARAM_CALL(5)
#endif
}

STDMETHODIMP CProxyITfLangBarItemMgr::RemoveItem(ITfLangBarItem *punk)
{
#if 1
    Assert(0);
    return E_NOTIMPL;
#else
    TraceMsg(TF_FUNC, "CProxyITfLangbarItemMgr::RemoveItem");
    CPROXY_PARAM_START()
    CPROXY_PARAM_INTERFACE_IN(&punk, IID_ITfLangBarItem)
    CPROXY_PARAM_CALL(6)
#endif
}

STDMETHODIMP CProxyITfLangBarItemMgr::AdviseItemSink(ITfLangBarItemSink *punk,  DWORD *pdwCookie,  REFGUID rguidItem)
{
    TraceMsg(TF_FUNC, "CProxyITfLangbarItemMgr::AdviseItemSink");
    CPROXY_PARAM_START()
    CPROXY_PARAM_INTERFACE_IN(&punk, IID_ITfLangBarItemSink)
    CPROXY_PARAM_POINTER_OUT(pdwCookie)
    CPROXY_PARAM_POINTER_IN(&rguidItem)
    CPROXY_PARAM_CALL(7)
}

STDMETHODIMP CProxyITfLangBarItemMgr::UnadviseItemSink(DWORD dwCookie)
{
    TraceMsg(TF_FUNC, "CProxyITfLangbarItemMgr::UnadviseItemSink");
    CPROXY_PARAM_START()
    CPROXY_PARAM_ULONG_IN(dwCookie)
    CPROXY_PARAM_CALL(8)
}

STDMETHODIMP CProxyITfLangBarItemMgr::GetItemFloatingRect(DWORD dwThreadId, REFGUID rguid, RECT *prc)
{
    TraceMsg(TF_FUNC, "CProxyITfLangbarItemMgr::GetItemFloatingRect");
    CPROXY_PARAM_START()
    CPROXY_PARAM_ULONG_IN(dwThreadId)
    CPROXY_PARAM_POINTER_IN(&rguid)
    CPROXY_PARAM_POINTER_OUT(prc)
    CPROXY_PARAM_CALL(9)
}

STDMETHODIMP CProxyITfLangBarItemMgr::GetItemsStatus(ULONG ulCount, const GUID *prgguid, DWORD *pdwStatus)
{
    TraceMsg(TF_FUNC, "CProxyITfLangbarItemMgr::GetItemsStatus");
    CPROXY_PARAM_START()
    CPROXY_PARAM_ULONG_IN(ulCount)
    CPROXY_PARAM_POINTER_ARRAY_IN(prgguid, ulCount)
    CPROXY_PARAM_POINTER_ARRAY_OUT(pdwStatus, ulCount)
    CPROXY_PARAM_CALL(10)
}

STDMETHODIMP CProxyITfLangBarItemMgr::GetItemNum(ULONG *pulCount)
{
    TraceMsg(TF_FUNC, "CProxyITfLangbarItemMgr::GetItemNum");
    CPROXY_PARAM_START()
    CPROXY_PARAM_POINTER_OUT(pulCount)
    CPROXY_PARAM_CALL(11)
}

STDMETHODIMP CProxyITfLangBarItemMgr::GetItems(ULONG ulCount,  ITfLangBarItem **ppItem,  TF_LANGBARITEMINFO *pInfo, DWORD *pdwStatus, ULONG *pcFetched)
{
    TraceMsg(TF_FUNC, "CProxyITfLangbarItemMgr::GetItems");
    CPROXY_PARAM_START()
    CPROXY_PARAM_ULONG_IN(ulCount)
    CPROXY_PARAM_INTERFACE_ARRAY_OUT(ppItem, IID_ITfLangBarItem, ulCount)
    CPROXY_PARAM_POINTER_ARRAY_OUT(pInfo, ulCount)
    CPROXY_PARAM_POINTER_ARRAY_OUT(pdwStatus, ulCount)
    CPROXY_PARAM_POINTER_OUT(pcFetched)
    CPROXY_PARAM_CALL(12)
}

STDMETHODIMP CProxyITfLangBarItemMgr::AdviseItemsSink(ULONG ulCount, ITfLangBarItemSink **ppunk,  const GUID *pguidItem, DWORD *pdwCookie)
{
    TraceMsg(TF_FUNC, "CProxyITfLangbarItemMgr::AdviseItemsSink");
    CPROXY_PARAM_START()
    CPROXY_PARAM_ULONG_IN(ulCount)
    CPROXY_PARAM_INTERFACE_ARRAY_IN(ppunk, IID_ITfLangBarItemSink, ulCount)
    CPROXY_PARAM_POINTER_ARRAY_IN(pguidItem, ulCount)
    CPROXY_PARAM_POINTER_ARRAY_OUT(pdwCookie, ulCount)
    CPROXY_PARAM_CALL(13)
}

STDMETHODIMP CProxyITfLangBarItemMgr::UnadviseItemsSink(ULONG ulCount, DWORD *pdwCookie)
{
    TraceMsg(TF_FUNC, "CProxyITfLangbarItemMgr::AdviseItemsSink");
    CPROXY_PARAM_START()
    CPROXY_PARAM_ULONG_IN(ulCount)
    CPROXY_PARAM_POINTER_ARRAY_IN(pdwCookie, ulCount)
    CPROXY_PARAM_CALL(14)
}


//////////////////////////////////////////////////////////////////////////////
//
// CProxyITfLangBarItemSink
//
//////////////////////////////////////////////////////////////////////////////

CProxyITfLangBarItemSink::CProxyITfLangBarItemSink(SYSTHREAD *psfn) : CProxyIUnknown(psfn)
{
    Dbg_MemSetThisNameID(TEXT("CProxyITfLangBarItemSink"));
}

HRESULT CProxyITfLangBarItemSink::OnUpdate(DWORD dwFlags)
{
    TraceMsg(TF_FUNC, "CProxyITfLangBarItemSink:OnUpdate");
    CPROXY_PARAM_START()
    CPROXY_PARAM_ULONG_IN(dwFlags)
    CPROXY_PARAM_CALL(3)
}

//////////////////////////////////////////////////////////////////////////////
//
// CProxyIEnumTfLangBarItems
//
//////////////////////////////////////////////////////////////////////////////

CProxyIEnumTfLangBarItems::CProxyIEnumTfLangBarItems(SYSTHREAD *psfn) : CProxyIUnknown(psfn)
{
    Dbg_MemSetThisNameID(TEXT("CProxyIEnumTfLangBarItems"));
}


HRESULT CProxyIEnumTfLangBarItems::Clone(IEnumTfLangBarItems **ppEnum)
{
    TraceMsg(TF_FUNC, "CProxyIEnumTfLangBarItems:Clone");
    CPROXY_PARAM_START()
    CPROXY_PARAM_INTERFACE_OUT(ppEnum, IID_IEnumTfLangBarItems)
    CPROXY_PARAM_CALL(3)
}

HRESULT CProxyIEnumTfLangBarItems::Next(ULONG ulCount, 
                                   ITfLangBarItem **ppItem, 
                                   ULONG *pcFetched)
{
    TraceMsg(TF_FUNC, "CProxyIEnumTfLangBarItems:Next");
    CPROXY_PARAM_START()
    CPROXY_PARAM_ULONG_IN(ulCount)
    CPROXY_PARAM_INTERFACE_ARRAY_OUT(ppItem, IID_ITfLangBarItem, ulCount)
    CPROXY_PARAM_POINTER_OUT(pcFetched)
    CPROXY_PARAM_CALL(4)
}

HRESULT CProxyIEnumTfLangBarItems::Reset()
{
    TraceMsg(TF_FUNC, "CProxyIEnumTfLangBarItems:Reset");
    CPROXY_PARAM_CALL_NOPARAM(5)
}

HRESULT CProxyIEnumTfLangBarItems::Skip(ULONG ulCount)
{
    TraceMsg(TF_FUNC, "CProxyIEnumTfLangBarItems:Skip");
    CPROXY_PARAM_START()
    CPROXY_PARAM_ULONG_IN(ulCount)
    CPROXY_PARAM_CALL(6)
}


//////////////////////////////////////////////////////////////////////////////
//
// CProxyITfLangBarItem
//
//////////////////////////////////////////////////////////////////////////////

CProxyITfLangBarItem::CProxyITfLangBarItem(SYSTHREAD *psfn) : CProxyIUnknown(psfn)
{
    Dbg_MemSetThisNameID(TEXT("CProxyITfLangBarItem"));
}

HRESULT CProxyITfLangBarItem::GetInfo(TF_LANGBARITEMINFO *pInfo)
{
    TraceMsg(TF_FUNC, "CProxyITfLangBarItem::GetInfo");
    CPROXY_PARAM_START()
    CPROXY_PARAM_POINTER_OUT(pInfo)
    CPROXY_PARAM_CALL(3)
}

HRESULT CProxyITfLangBarItem::GetStatus(DWORD *pdwStatus)
{
    TraceMsg(TF_FUNC, "CProxyITfLangBarItem::GetStatus");
    CPROXY_PARAM_START()
    CPROXY_PARAM_POINTER_OUT(pdwStatus)
    CPROXY_PARAM_CALL(4)
}

HRESULT CProxyITfLangBarItem::Show(BOOL fShow)
{
    TraceMsg(TF_FUNC, "CProxyITfLangBarItem::Show");
    CPROXY_PARAM_START()
    CPROXY_PARAM_ULONG_IN(fShow)
    CPROXY_PARAM_CALL(5)
}

HRESULT CProxyITfLangBarItem::GetTooltipString(BSTR *pbstrToolTip)
{
    TraceMsg(TF_FUNC, "CProxyITfLangBarItem::GetTooltipString");
    CPROXY_PARAM_START()
    CPROXY_PARAM_BSTR_OUT(pbstrToolTip)
    CPROXY_PARAM_CALL(6)
}

//////////////////////////////////////////////////////////////////////////////
//
// CProxyITfLangBarItemButton
//
//////////////////////////////////////////////////////////////////////////////

CProxyITfLangBarItemButton::CProxyITfLangBarItemButton(SYSTHREAD *psfn) : CProxyITfLangBarItem(psfn)
{
    Dbg_MemSetThisNameID(TEXT("CProxyITfLangBarItemButton"));
}

STDAPI CProxyITfLangBarItemButton::OnClick(TfLBIClick click, POINT pt, const RECT *prcArea)
{
    TraceMsg(TF_FUNC, "CProxyITfLangBarItemButton::OnClick");
    CPROXY_PARAM_START()
    CPROXY_PARAM_ULONG_IN(click)
    CPROXY_PARAM_STRUCT_IN(pt)
    CPROXY_PARAM_POINTER_IN(prcArea)
    CPROXY_PARAM_CALL(7)
}

STDAPI CProxyITfLangBarItemButton::InitMenu(ITfMenu *pMenu)
{
    CPROXY_PARAM_START()
    CPROXY_PARAM_INTERFACE_IN(&pMenu, IID_ITfMenu)
    CPROXY_PARAM_CALL(8)
}

STDAPI CProxyITfLangBarItemButton::OnMenuSelect(UINT wID)
{
    CPROXY_PARAM_START()
    CPROXY_PARAM_ULONG_IN(wID)
    CPROXY_PARAM_CALL(9)
}

STDAPI CProxyITfLangBarItemButton::GetIcon(HICON *phIcon)
{
    CPROXY_PARAM_START()
    CPROXY_PARAM_HICON_OUT(phIcon)
    CPROXY_PARAM_CALL(10)
}

STDAPI CProxyITfLangBarItemButton::GetText(BSTR *pbstrText)
{
    CPROXY_PARAM_START()
    CPROXY_PARAM_BSTR_OUT(pbstrText)
    CPROXY_PARAM_CALL(11)
}


//////////////////////////////////////////////////////////////////////////////
//
// CProxyITfLangBarItemBitmapButton
//
//////////////////////////////////////////////////////////////////////////////

CProxyITfLangBarItemBitmapButton::CProxyITfLangBarItemBitmapButton(SYSTHREAD *psfn) : CProxyITfLangBarItem(psfn)
{
    Dbg_MemSetThisNameID(TEXT("CProxyITfLangBarItemBitmapButton"));
}

STDAPI CProxyITfLangBarItemBitmapButton::OnClick(TfLBIClick click, POINT pt, const RECT *prcArea)
{
    TraceMsg(TF_FUNC, "CProxyITfLangBarItemBitmapButton::OnClick");
    CPROXY_PARAM_START()
    CPROXY_PARAM_ULONG_IN(click)
    CPROXY_PARAM_STRUCT_IN(pt)
    CPROXY_PARAM_POINTER_IN(prcArea)
    CPROXY_PARAM_CALL(7)
}

STDAPI CProxyITfLangBarItemBitmapButton::InitMenu(ITfMenu *pMenu)
{
    CPROXY_PARAM_START()
    CPROXY_PARAM_INTERFACE_IN(&pMenu, IID_ITfMenu)
    CPROXY_PARAM_CALL(8)
}

STDAPI CProxyITfLangBarItemBitmapButton::OnMenuSelect(UINT wID)
{
    CPROXY_PARAM_START()
    CPROXY_PARAM_ULONG_IN(wID)
    CPROXY_PARAM_CALL(9)
}

STDAPI CProxyITfLangBarItemBitmapButton::GetPreferredSize(const SIZE *pszDefault,SIZE *psz)
{
    CPROXY_PARAM_START()
    CPROXY_PARAM_POINTER_IN(pszDefault)
    CPROXY_PARAM_POINTER_OUT(psz)
    CPROXY_PARAM_CALL(10)
}

STDAPI CProxyITfLangBarItemBitmapButton::DrawBitmap(LONG bmWidth, LONG bmHeight,  DWORD dwFlags, HBITMAP *phbmp, HBITMAP *phbmpMask)
{
    CPROXY_PARAM_START()
    CPROXY_PARAM_ULONG_IN(bmWidth)
    CPROXY_PARAM_ULONG_IN(bmHeight)
    CPROXY_PARAM_ULONG_IN(dwFlags)
    CPROXY_PARAM_HBITMAP_OUT(phbmp)
    CPROXY_PARAM_HBITMAP_OUT(phbmpMask)
    CPROXY_PARAM_CALL(11)
}

STDAPI CProxyITfLangBarItemBitmapButton::GetText(BSTR *pbstrText)
{
    CPROXY_PARAM_START()
    CPROXY_PARAM_BSTR_OUT(pbstrText)
    CPROXY_PARAM_CALL(12)
}

//////////////////////////////////////////////////////////////////////////////
//
// CProxyITfLangBarItemBitmap
//
//////////////////////////////////////////////////////////////////////////////

CProxyITfLangBarItemBitmap::CProxyITfLangBarItemBitmap(SYSTHREAD *psfn) : CProxyITfLangBarItem(psfn)
{
    Dbg_MemSetThisNameID(TEXT("CProxyITfLangBarItemBitmap"));
}

STDAPI CProxyITfLangBarItemBitmap::OnClick(TfLBIClick click, POINT pt, const RECT *prcArea)
{
    TraceMsg(TF_FUNC, "CProxyITfLangBarItemBitmap::OnClick");
    CPROXY_PARAM_START()
    CPROXY_PARAM_ULONG_IN(click)
    CPROXY_PARAM_STRUCT_IN(pt)
    CPROXY_PARAM_POINTER_IN(prcArea)
    CPROXY_PARAM_CALL(7)
}

STDAPI CProxyITfLangBarItemBitmap::GetPreferredSize(const SIZE *pszDefault,SIZE *psz)
{
    CPROXY_PARAM_START()
    CPROXY_PARAM_POINTER_IN(pszDefault)
    CPROXY_PARAM_POINTER_OUT(psz)
    CPROXY_PARAM_CALL(8)
}

STDAPI CProxyITfLangBarItemBitmap::DrawBitmap(LONG bmWidth, LONG bmHeight,  DWORD dwFlags, HBITMAP *phbmp, HBITMAP *phbmpMask)
{
    CPROXY_PARAM_START()
    CPROXY_PARAM_ULONG_IN(bmWidth)
    CPROXY_PARAM_ULONG_IN(bmHeight)
    CPROXY_PARAM_ULONG_IN(dwFlags)
    CPROXY_PARAM_HBITMAP_OUT(phbmp)
    CPROXY_PARAM_HBITMAP_OUT(phbmpMask)
    CPROXY_PARAM_CALL(9)
}

//////////////////////////////////////////////////////////////////////////////
//
// CProxyITfLangBarItemBalloon
//
//////////////////////////////////////////////////////////////////////////////

CProxyITfLangBarItemBalloon::CProxyITfLangBarItemBalloon(SYSTHREAD *psfn) : CProxyITfLangBarItem(psfn)
{
    Dbg_MemSetThisNameID(TEXT("CProxyITfLangBarItemBalloon"));
}

STDAPI CProxyITfLangBarItemBalloon::OnClick(TfLBIClick click, POINT pt, const RECT *prcArea)
{
    TraceMsg(TF_FUNC, "CProxyITfLangBarItemBalloon::OnClick");
    CPROXY_PARAM_START()
    CPROXY_PARAM_ULONG_IN(click)
    CPROXY_PARAM_STRUCT_IN(pt)
    CPROXY_PARAM_POINTER_IN(prcArea)
    CPROXY_PARAM_CALL(7)
}

STDAPI CProxyITfLangBarItemBalloon::GetPreferredSize(const SIZE *pszDefault,SIZE *psz)
{
    CPROXY_PARAM_START()
    CPROXY_PARAM_POINTER_IN(pszDefault)
    CPROXY_PARAM_POINTER_OUT(psz)
    CPROXY_PARAM_CALL(8)
}

STDAPI CProxyITfLangBarItemBalloon::GetBalloonInfo(TF_LBBALLOONINFO *pInfo)
{
    CPROXY_PARAM_START()
    CPROXY_PARAM_TF_LBBALLOONINFO_OUT(pInfo)
    CPROXY_PARAM_CALL(9)
}

//////////////////////////////////////////////////////////////////////////////
//
// CProxyITfMenu
//
//////////////////////////////////////////////////////////////////////////////

CProxyITfMenu::CProxyITfMenu(SYSTHREAD *psfn) : CProxyIUnknown(psfn)
{
    Dbg_MemSetThisNameID(TEXT("CProxyITfMenu"));
}

STDAPI CProxyITfMenu::AddMenuItem(UINT uId,
                                             DWORD dwFlags,
                                             HBITMAP hbmp,
                                             HBITMAP hbmpMask,
                                             const WCHAR *pch,
                                             ULONG cch,
                                             ITfMenu **ppMenu)
{
    CPROXY_PARAM_START()
    CPROXY_PARAM_ULONG_IN(uId)
    CPROXY_PARAM_ULONG_IN(dwFlags)
    CPROXY_PARAM_HBITMAP_IN(hbmp)
    CPROXY_PARAM_HBITMAP_IN(hbmpMask)
    CPROXY_PARAM_WCHAR_IN(pch, cch)
    CPROXY_PARAM_ULONG_IN(cch)
    CPROXY_PARAM_INTERFACE_IN_OUT(ppMenu, IID_ITfMenu)
    CPROXY_PARAM_CALL(3)
}

//////////////////////////////////////////////////////////////////////////////
//
// CProxyITfMenu
//
//////////////////////////////////////////////////////////////////////////////

CProxyITfInputProcessorProfiles::CProxyITfInputProcessorProfiles(SYSTHREAD *psfn) : CProxyIUnknown(psfn)
{
    Dbg_MemSetThisNameID(TEXT("CProxyITfInputProcessorProfiles"));
}

STDAPI CProxyITfInputProcessorProfiles::Register(REFCLSID rclsid)
{
    // 3
    Assert(0);
    return E_NOTIMPL;
}

STDAPI CProxyITfInputProcessorProfiles::Unregister(REFCLSID rclsid)
{
    // 4
    Assert(0);
    return E_NOTIMPL;
}

STDAPI CProxyITfInputProcessorProfiles::AddLanguageProfile(REFCLSID rclsid,
                               LANGID langid,
                               REFGUID guidProfile,
                               const WCHAR *pchDesc,
                               ULONG cchDesc,
                               const WCHAR *pchIconFile,
                               ULONG cchFile,
                               ULONG uIconIndex)
{
    // 5
    Assert(0);
    return E_NOTIMPL;
}

STDAPI CProxyITfInputProcessorProfiles::RemoveLanguageProfile(REFCLSID rclsid,
                                  LANGID langid,
                                  REFGUID guidProfile)
{
    // 6
    Assert(0);
    return E_NOTIMPL;
}

STDAPI CProxyITfInputProcessorProfiles::EnumInputProcessorInfo(IEnumGUID **ppEnum)
{
    // 7
    Assert(0);
    return E_NOTIMPL;
}

STDAPI CProxyITfInputProcessorProfiles::GetDefaultLanguageProfile(LANGID langid,
                                      REFGUID catid,
                                      CLSID *pclsid,
                                      GUID *pguidProfile)
{
    // 9
    Assert(0);
    return E_NOTIMPL;
}

STDAPI CProxyITfInputProcessorProfiles::SetDefaultLanguageProfile(LANGID langid,
                                      REFCLSID rclsid,
                                      REFGUID guidProfiles)
{
    // 11
    Assert(0);
    return E_NOTIMPL;
}

STDAPI CProxyITfInputProcessorProfiles::ActivateLanguageProfile(REFCLSID rclsid, 
                                    LANGID langid, 
                                    REFGUID guidProfiles)
{
    // 12
    Assert(0);
    return E_NOTIMPL;
}

STDAPI CProxyITfInputProcessorProfiles::GetActiveLanguageProfile(REFCLSID rclsid, 
                                     LANGID *plangid, 
                                     GUID *pguidProfile)
{
    // 13
    Assert(0);
    return E_NOTIMPL;
}

HRESULT CProxyITfInputProcessorProfiles::GetLanguageProfileDescription(REFCLSID rclsid, 
                                          LANGID langid, 
                                          REFGUID guidProfile,
                                          BSTR *pbstrProfile)
{
    // 14
    Assert(0);
    return E_NOTIMPL;
}

STDAPI CProxyITfInputProcessorProfiles::GetCurrentLanguage(LANGID *plangid)
{
    // 15
    CPROXY_PARAM_START()
    CPROXY_PARAM_POINTER_OUT(plangid)
    CPROXY_PARAM_CALL(14)
}

STDAPI CProxyITfInputProcessorProfiles::ChangeCurrentLanguage(LANGID langid)
{
    // 16
    Assert(0);
    return E_NOTIMPL;
}

STDAPI CProxyITfInputProcessorProfiles::GetLanguageList(LANGID **ppLangId,
                            ULONG *pulCount)
{
    // 17
    Assert(0);
    return E_NOTIMPL;
}

STDAPI CProxyITfInputProcessorProfiles::EnumLanguageProfiles(LANGID langid, 
                                 IEnumTfLanguageProfiles **ppEnum)
{
    // 18
    Assert(0);
    return E_NOTIMPL;
}

STDAPI CProxyITfInputProcessorProfiles::EnableLanguageProfile(REFCLSID rclsid,
                                       LANGID langid,
                                       REFGUID guidProfile,
                                       BOOL fEnable)
{
    // 19
    Assert(0);
    return E_NOTIMPL;
}

STDAPI CProxyITfInputProcessorProfiles::IsEnabledLanguageProfile(REFCLSID rclsid,
                                          LANGID langid,
                                          REFGUID guidProfile,
                                          BOOL *pfEnable)
{
    // 20
    Assert(0);
    return E_NOTIMPL;
}

STDAPI CProxyITfInputProcessorProfiles::EnableLanguageProfileByDefault(REFCLSID rclsid,
                                                LANGID langid,
                                                REFGUID guidProfile,
                                                BOOL fEnable)
{
    // 21
    Assert(0);
    return E_NOTIMPL;
}

STDAPI CProxyITfInputProcessorProfiles::SubstituteKeyboardLayout(REFCLSID rclsid,
                                          LANGID langid,
                                          REFGUID guidProfile,
                                          HKL hKL)
{
    // 22
    Assert(0);
    return E_NOTIMPL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\ctf\uim\nuimgr.cpp ===
//
// nuimgr.cpp
//

#include "private.h"
#include "tim.h"
#include "nuimgr.h"
#include "nuictrl.h"
#include "marshal.h"
#include "timlist.h"
#include "lbaddin.h"
#include "hotkey.h"

DBG_ID_INSTANCE(CLBarItemSink);
DBG_ID_INSTANCE(CLBarItemSinkProxy);
DBG_ID_INSTANCE(CLangBarItemMgr);
DBG_ID_INSTANCE(CEnumLBItem);

//////////////////////////////////////////////////////////////////////////////
//
// marshalling misc func
//
//////////////////////////////////////////////////////////////////////////////

//+---------------------------------------------------------------------------
//
// FreeStubForThis
//
// this function clean up all marshaling stubs for the LangBarItem.
//
//+---------------------------------------------------------------------------

void FreeMarshaledStubOfItem(SYSTHREAD *psfn, REFGUID rguid)
{
    ITfLangBarItem *pItem;
    if (!psfn->prgStub)
        return;

    //
    // #489905
    //
    // we can not call sink anymore after DLL_PROCESS_DETACH.
    //
    if (DllShutdownInProgress())
        return;

    int nCnt = psfn->prgStub->Count();
    int i = 0;

    for (i = 0; i < nCnt; i++)
    {
TryThisIdAgain:
        CStub *pStub = psfn->prgStub->Get(i);
        HRESULT hr;
        TF_LANGBARITEMINFO info;


        //
        //  Win98-J and Satori cause exception at the sutdown of notepad.
        //  we need to make sure this exception handler is not hiding any
        //  potential problems.
        //
        _try {
            if (FAILED(pStub->_punk->QueryInterface(IID_ITfLangBarItem, (void **)&pItem)))
               continue;
        } 
        _except (1) {
            continue;
        }
       
        hr = pItem->GetInfo(&info);
        pItem->Release();

        if (SUCCEEDED(hr) && IsEqualGUID(info.guidItem, rguid))
        {
            pStub->_fNoRemoveInDtor = TRUE;
            psfn->prgStub->Remove(i, 1);
            delete pStub;
            nCnt--;
            if (i < nCnt)
               goto TryThisIdAgain;

            return;
        }
    }
}

//////////////////////////////////////////////////////////////////////////////
//
// CLangBarItemMgr
//
//////////////////////////////////////////////////////////////////////////////

//+---------------------------------------------------------------------------
//
// ctor
//
//----------------------------------------------------------------------------

CLangBarItemMgr::CLangBarItemMgr(SYSTHREAD *psfn) : CSysThreadRef(psfn)
{
    Dbg_MemSetThisNameID(TEXT("CLangBarItemMgr"));

    Assert(_GetThis() == NULL);
    _SetThis(this);

    _dwCurCookie = 0;
    _ulInAssemblyChange = 0;
    _fHandleOnUpdate = TRUE;

    EnsureMarshalWnd();
}

//+---------------------------------------------------------------------------
//
// dtor
//
//----------------------------------------------------------------------------

CLangBarItemMgr::~CLangBarItemMgr()
{
    g_timlist.ClearFlags(_psfn->dwThreadId, TLF_LBIMGR);
    _RemoveSystemItems(_psfn);
    CleanUp();
    _SetThis(NULL);
}

//+---------------------------------------------------------------------------
//
// IUnknown
//
//----------------------------------------------------------------------------

STDAPI CLangBarItemMgr::QueryInterface(REFIID riid, void **ppvObj)
{
    if (ppvObj == NULL)
        return E_INVALIDARG;

    *ppvObj = NULL;

    if (IsEqualIID(riid, IID_ITfLangBarItemMgr) ||
        IsEqualIID(riid, IID_IUnknown))
    {
        *ppvObj = SAFECAST(this, ITfLangBarItemMgr *);
    }

    if (*ppvObj)
    {
        AddRef();
        return S_OK;
    }

    return E_NOINTERFACE;
}

STDAPI_(ULONG) CLangBarItemMgr::AddRef()
{
    //
    // we don't have ref count.
    // Keep this class in psfn and delete at the end of thread.
    //
    return 2;
}

STDAPI_(ULONG) CLangBarItemMgr::Release()
{
    //
    // we don't have ref count.
    // Keep this class in psfn and delete at the end of thread.
    //
    return 1;
}

//+---------------------------------------------------------------------------
//
// _RemoveSystemItems
//
//----------------------------------------------------------------------------

void CLangBarItemMgr::_RemoveSystemItems(SYSTHREAD *psfn)
{
    int i;
    CLBarItemDeviceType *plbiDT;
    DWORD dwThreadId = GetCurrentThreadId();

    if (_plbiCtrl != NULL)
    {
        RemoveItem(*_plbiCtrl->GetGuidItem());

        if (_plbiCtrl->Release() > 0)
        {
            if (psfn && (psfn->dwThreadId == dwThreadId))
            {
                // Clean up a pointer that is marshalled to UTB.
                delete _plbiCtrl;
            }
        }

        _plbiCtrl = NULL;
    }

    if (_plbiReconv != NULL)
    {
        RemoveItem(*_plbiReconv->GetGuidItem());

        if (_plbiReconv->Release() > 0)
        {
            if (psfn && (psfn->dwThreadId == dwThreadId))
            {
                // Clean up a pointer that is marshalled to UTB.
                delete _plbiReconv;
            }
        }

        _plbiReconv = NULL;
    }

    if (_plbiWin32IME != NULL)
    {
        RemoveItem(*_plbiWin32IME->GetGuidItem());

        if (_plbiWin32IME->Release() > 0)
        {
            if (psfn && (psfn->dwThreadId == dwThreadId))
            {
                // Clean up a pointer that is marshalled to UTB.
                delete _plbiWin32IME;
            }
        }

        _plbiWin32IME = NULL;
    }

    if (_plbiHelp != NULL)
    {
        RemoveItem(*_plbiHelp->GetGuidItem());

        if (_plbiHelp->Release() > 0)
        {
            if (psfn && (psfn->dwThreadId == dwThreadId))
            {
                // Clean up a pointer that is marshalled to UTB.
                delete _plbiHelp;
            }
        }

        _plbiHelp = NULL;
    }

    for (i = 0; i < _rglbiDeviceType.Count(); i++)
    {
        plbiDT = _rglbiDeviceType.Get(i);
        if (plbiDT)
        {
            RemoveItem(*plbiDT->GetGuidItem());

            if (plbiDT->Release() > 0)
            {
                if (psfn && (psfn->dwThreadId == dwThreadId))
                {
                    // Clean up a pointer that is marshalled to UTB.
                    delete plbiDT;
                }
            }
        }
    }
    _rglbiDeviceType.Clear();
}

//+---------------------------------------------------------------------------
//
// CreateInstance
//
//----------------------------------------------------------------------------

/* static */
HRESULT CLangBarItemMgr::CreateInstance(IUnknown *pUnkOuter, REFIID riid, void **ppvObj)
{
    CLangBarItemMgr *plbim;
    HRESULT hr;

    if (ppvObj == NULL)
        return E_INVALIDARG;

    *ppvObj = NULL;

    if (pUnkOuter != NULL)
        return CLASS_E_NOAGGREGATION;

    if (plbim = _GetThis())
    {
        return plbim->QueryInterface(riid, ppvObj);
    }

    SYSTHREAD *psfn = GetSYSTHREAD();
    if (!psfn)
        return E_OUTOFMEMORY;

    if ((plbim = new CLangBarItemMgr(psfn)) == NULL)
        return E_OUTOFMEMORY;

    if (!plbim->_Init())
    {
        plbim->Release();
        return E_FAIL;
    }

    hr = plbim->QueryInterface(riid, ppvObj);

    plbim->Release();

#ifdef WINLOGON_LANGBAR
    ExecuteLoader();
#endif

    return hr;
}

//+---------------------------------------------------------------------------
//
// FindDeviceTypeItem
//
//----------------------------------------------------------------------------

CLBarItemDeviceType *CLangBarItemMgr::FindDeviceTypeItem(REFGUID guid)
{
    int i;
    CLBarItemDeviceType *plbiDT;
    for (i = 0; i < _rglbiDeviceType.Count(); i++)
    {
        plbiDT = _rglbiDeviceType.Get(i);
        if (plbiDT)
        {
            if (IsEqualGUID(*plbiDT->GetDeviceTypeGUID(), guid))
            {
                return plbiDT;
            }
        }
    }
    return NULL;
}

//+---------------------------------------------------------------------------
//
// _Init
//
//----------------------------------------------------------------------------

BOOL CLangBarItemMgr::_Init()
{
    CLBarItemDeviceType **pplbiDT;
    GUID guid;

    //
    // set TLF_LBIMGR flag for this thread of timlist.
    //
    if (EnsureTIMList(_psfn))
    {
        g_timlist.SetFlags(_psfn->dwThreadId, TLF_LBIMGR);

        InitLangChangeHotKey();
    }

    // init the system default ctls
    if (!_plbiCtrl && (_plbiCtrl = new CLBarItemCtrl(_psfn)) == NULL)
        return FALSE;

    AddItem(_plbiCtrl);

    // 
    // I want to hide a help button on Winlogon.
    // But IMJP8 causes av, if we don't have Help button...
    // 
    // if (!IsInWinLogOnDesktop())
    {
        if (!_plbiHelp && (_plbiHelp = new CLBarItemHelp(_psfn)) != NULL)
        {
            AddItem(_plbiHelp);
        }
    }

    if (CThreadInputMgr::_GetThis())
    {
        if (!_plbiReconv && (_plbiReconv = new CLBarItemReconv(_psfn)))
        {
            AddItem(_plbiReconv);
            _plbiReconv->ShowOrHide(FALSE);
        }

        IEnumGUID *pEnum;
        if (SUCCEEDED(CCategoryMgr::s_EnumItemsInCategory(
                                               GUID_TFCAT_CATEGORY_OF_TIP,
                                               &pEnum)))
        {
            while (pEnum->Next(1, &guid, NULL) == S_OK)
            {
                if (FindDeviceTypeItem(guid))
                    continue;

                pplbiDT = _rglbiDeviceType.Append(1);
    
                if (pplbiDT)
                {
                    *pplbiDT = new CLBarItemDeviceType(_psfn, guid);
                    if (*pplbiDT)
                    {
                        (*pplbiDT)->Init();
                        AddItem(*pplbiDT);
                    }
                    else
                    {
                        int nCnt = _rglbiDeviceType.Count();
                        if (nCnt)
                           _rglbiDeviceType.Remove(nCnt - 1, 1);
                    }
                }
                
            }
            pEnum->Release();
        }
    }
    else
    {
        if (!FindDeviceTypeItem(GUID_TFCAT_TIP_KEYBOARD))
        {
            pplbiDT = _rglbiDeviceType.Append(1);
            if (pplbiDT)
            {
                *pplbiDT = new CLBarItemDeviceType(_psfn, GUID_TFCAT_TIP_KEYBOARD);
                if (*pplbiDT)
                {
                    (*pplbiDT)->Init();
                    AddItem(*pplbiDT);
                }
                else
                {
                    int nCnt = _rglbiDeviceType.Count();
                    if (nCnt)
                       _rglbiDeviceType.Remove(nCnt - 1, 1);
                }
            }
        }
    }

    if (_plbiCtrl)
    {
        _plbiCtrl->_UpdateLangIcon(NULL, FALSE);
    }

    UpdateLangBarAddIns();

    MakeSetFocusNotify(g_msgThreadItemChange, 0, (LPARAM)GetCurrentThreadId());

    return TRUE;
}

//+---------------------------------------------------------------------------
//
// CleanUp
//
//----------------------------------------------------------------------------

void CLangBarItemMgr::CleanUp()
{

    // 
    //  we can not call COM in PROCESS_DETACH. we just make sure 
    //  if someone forget to call UnRegister.
    // 
#if 1
    // Assert(!_rglbiProxy.Count());
#else
    int i;
    int nCnt;

    nCnt = _rglbiProxy.Count();
    for (i = 0; i < nCnt; i++)
    {
         CLBarItemSinkProxy *pProxy = _rglbiProxy.Get(i);
         pProxy->Clear();
         pProxy->Release();
    }

#endif

    _rglbiProxy.Clear();

    int i;
    int nCnt = _rgSink.Count();
    for (i = 0; i < nCnt ; i++)
    {
        CLBarItemSink  *pSink = _rgSink.Get(i);
        Assert(pSink);

        TraceMsg(TF_GENERAL, "NuiMgr clean up ItemSink - 0x%x08", (UINT_PTR)pSink);

        //
        // Issue: This is a pointer that is marshalled from UTB.
        //         If this is called in DllMain(THREAD_DETACH).
        //         calling Release() cause dead lock....
        //
        pSink->_pItemSink->Release();
        pSink->_pItemSink = NULL;
        delete pSink;
    }
    _rgSink.Clear();
}

//+---------------------------------------------------------------------------
//
// AddItem
//
//----------------------------------------------------------------------------

STDAPI CLangBarItemMgr::AddItem(ITfLangBarItem *pItem)
{
    ITfSource *pSource = NULL;
    HRESULT hr = E_FAIL;
    CLBarItemSinkProxy *pProxy;
    TF_LANGBARITEMINFO info;

    if (pItem == NULL)
        return E_INVALIDARG;

    if (FAILED(pItem->QueryInterface(IID_ITfSource, (void **)&pSource)))
    {
        goto Exit;
    }

    if (SUCCEEDED(pItem->GetInfo(&info)))
    {
       int i;
       int nCnt = _rglbiProxy.Count();
       for (i = 0; i < nCnt; i++)
       {
            pProxy = _rglbiProxy.Get(i);
   
            if (IsEqualGUID(pProxy->_info.guidItem, info.guidItem))
            {
                hr = E_INVALIDARG;
                goto Exit;
            }
       }
    }
    else
    {
        goto Exit;
    }

    pProxy = new CLBarItemSinkProxy();
    if (!pProxy)
    {
        hr = E_OUTOFMEMORY;
        goto Exit;
    }

    if (!pProxy->Init(this, pItem, &info))
    {
        goto Exit;
    }

    if (FAILED(pSource->AdviseSink(IID_ITfLangBarItemSink, 
                                   pProxy, &pProxy->_dwCookie)))
    {
        pProxy->Clear();
        pProxy->Release();
    }
    else
    {
        int nCnt = _rglbiProxy.Count();
        if (!_rglbiProxy.Insert(nCnt, 1))
        {
            pSource->UnadviseSink(pProxy->_dwCookie);
            pProxy->Clear();
            pProxy->Release();

            hr = E_OUTOFMEMORY;
            goto Exit;
        }
        _rglbiProxy.Set(nCnt, pProxy);

        if (!_ulInAssemblyChange)
             MakeSetFocusNotify(g_msgThreadItemChange, 0, (LPARAM)GetCurrentThreadId());
        _fItemChanged = TRUE;

        hr = S_OK;
    }

Exit:
    SafeRelease(pSource);

    return hr;
}

//+---------------------------------------------------------------------------
//
// RemoveItem
//
//----------------------------------------------------------------------------

STDAPI CLangBarItemMgr::RemoveItem(ITfLangBarItem *pItem)
{
    TF_LANGBARITEMINFO info;

    if (!pItem)
        return E_INVALIDARG;

    if (FAILED(pItem->GetInfo(&info)))
        return E_FAIL;

    return RemoveItem(info.guidItem);
}

//+---------------------------------------------------------------------------
//
// RemoveItem
//
//----------------------------------------------------------------------------

HRESULT CLangBarItemMgr::RemoveItem(REFGUID rguid)
{
    int nCnt;
    int i;

    nCnt = _rglbiProxy.Count();
    for (i = 0; i < nCnt; i++)
    {
         CLBarItemSinkProxy *pProxy = _rglbiProxy.Get(i);

         if (IsEqualGUID(pProxy->_info.guidItem, rguid))
         {
             ITfSource *pSource;
             if (SUCCEEDED(pProxy->_plbi->QueryInterface(IID_ITfSource, 
                                                         (void **)&pSource)))
             {
                 pSource->UnadviseSink(pProxy->_dwCookie);
                 pSource->Release();
             }
             _rglbiProxy.Remove(i, 1);
             pProxy->Clear();
             pProxy->Release();

             if (!_ulInAssemblyChange)
             {
                 MakeSetFocusNotify(g_msgThreadItemChange, 0, (LPARAM)GetCurrentThreadId());
             }
             SYSTHREAD *psfn = FindSYSTHREAD();
             if (psfn && (psfn->dwThreadId == _psfn->dwThreadId))
                 FreeMarshaledStubOfItem(psfn, rguid);

             _fItemChanged = TRUE;
             break;
         }
    }

    return S_OK;
}

//+---------------------------------------------------------------------------
//
// RegisterItemSink
//
//----------------------------------------------------------------------------

STDAPI CLangBarItemMgr::AdviseItemSink(ITfLangBarItemSink *punk, DWORD *pdwCookie, REFGUID rguidItem)
{
    CLBarItemSinkProxy *pProxy;
    CLBarItemSink *pSink;
    int nCnt;
    HRESULT hr;

    if (pdwCookie == NULL)
        return E_POINTER;

    *pdwCookie = 0;

    if (punk == NULL)
        return E_POINTER;

    pProxy = GetItemSinkProxy(rguidItem);
    if (!pProxy)
        return E_INVALIDARG;

    pSink = new CLBarItemSink();
    if (!pSink)
    {
        hr = E_OUTOFMEMORY;
        goto Exit;
    }

    *pdwCookie = _GetCookie();
    if (!pSink->Init(punk, &pProxy->_info, *pdwCookie))
    {
        hr = E_FAIL;
        goto Exit;
    }

    nCnt = _rgSink.Count();
    if (!_rgSink.Insert(nCnt, 1))
    {
        hr = E_OUTOFMEMORY;
        goto Exit;
    }

    _rgSink.Set(nCnt, pSink);

    hr = S_OK;
Exit:
    return hr;
}

//+---------------------------------------------------------------------------
//
// UnregisterItemSink
//
//----------------------------------------------------------------------------

STDAPI CLangBarItemMgr::UnadviseItemSink(DWORD dwCookie)
{
    int i;
    int nCnt = _rgSink.Count();

    for (i = 0; i < nCnt ; i++)
    {
        CLBarItemSink  *pSink = _rgSink.Get(i);
        if (pSink->_dwCookie == dwCookie)
        {
#ifdef DEBUG
            pSink->_fUnadvised = TRUE;
#endif
            _rgSink.Remove(i, 1);


            delete pSink;
            break;
        }
    }
    return S_OK;
}

//+---------------------------------------------------------------------------
//
// GetItemFloatingRect
//
//----------------------------------------------------------------------------

STDAPI CLangBarItemMgr::GetItemFloatingRect(DWORD dwThreadId, REFGUID rguid, RECT *prc)
{
    if (!prc)
       return E_INVALIDARG;

    if (!dwThreadId)
       dwThreadId = GetCurrentThreadId();

    memset(prc, 0, sizeof(*prc));

    return ThreadGetItemFloatingRect(dwThreadId, rguid, prc);
}

//+---------------------------------------------------------------------------
//
// GetItemsStatus
//
//----------------------------------------------------------------------------

STDAPI CLangBarItemMgr::GetItemsStatus(ULONG ulCount, const GUID *prgguid, DWORD *pdwStatus)
{
    ULONG ul;

    for (ul = 0; ul < ulCount; ul++)
    {
        int i;
        BOOL fFound = FALSE;
        for (i = 0; i < _rglbiProxy.Count(); i++)
        {
            CLBarItemSinkProxy *pProxy = _rglbiProxy.Get(i);
            if (IsEqualGUID(pProxy->_info.guidItem, *prgguid))
            {
                if (FAILED(pProxy->_plbi->GetStatus(pdwStatus)))
                    return E_FAIL;

                pdwStatus++;
                prgguid++;
                fFound = TRUE;
                break;
            }
        }

        if (!fFound)
            return E_FAIL;
    }

    return S_OK;
}

//+---------------------------------------------------------------------------
//
// GetItemNum
//
//----------------------------------------------------------------------------

STDAPI CLangBarItemMgr::GetItemNum(ULONG *pulCount)
{
    if (!pulCount)
        return E_INVALIDARG;

    *pulCount = _rglbiProxy.Count();
    return S_OK;
}

//+---------------------------------------------------------------------------
//
// GetItems
//
//----------------------------------------------------------------------------

STDAPI CLangBarItemMgr::GetItems(ULONG ulCount,  ITfLangBarItem **ppItem,  TF_LANGBARITEMINFO *pInfo, DWORD *pdwStatus, ULONG *pcFetched)
{
    int i;
    ULONG ulFetched = 0;
    CThreadInputMgr *ptim = CThreadInputMgr::_GetThis();
    BOOL fHasFocusDIM;

    if (!ulCount)
        return S_FALSE;

    fHasFocusDIM = (ptim && ptim->_GetFocusDocInputMgr()) ? TRUE : FALSE;

    for (i = 0; i < _rglbiProxy.Count(); i++)
    {
        CLBarItemSinkProxy *pProxy = _rglbiProxy.Get(i);

        if (!fHasFocusDIM && pProxy->_fCicTip)
            continue;

        if (FAILED(pProxy->_plbi->GetInfo(pInfo)))
        return E_FAIL;
        pInfo++;

        if (FAILED(pProxy->_plbi->GetStatus(pdwStatus)))
            return E_FAIL;
        pdwStatus++;

        *ppItem = pProxy->_plbi;
        pProxy->_plbi->AddRef();
        ppItem++;

        ulFetched++;

        if (ulFetched >= ulCount)
            break;
    }

    if (pcFetched)
        *pcFetched = ulFetched;

    return (ulFetched == ulCount) ? S_OK : S_FALSE;
}

//+---------------------------------------------------------------------------
//
// AdviseItemsSink
//
//----------------------------------------------------------------------------

STDMETHODIMP CLangBarItemMgr::AdviseItemsSink(ULONG ulCount, ITfLangBarItemSink **ppunk,  const GUID *pguidItem, DWORD *pdwCookie)
{
    ULONG ul;
    for ( ul = 0; ul < ulCount; ul++)
    {
        if (FAILED(AdviseItemSink(ppunk[ul], &pdwCookie[ul], pguidItem[ul])))
            return E_FAIL;
    }

    return S_OK;
}

//+---------------------------------------------------------------------------
//
// UnadviseItemsSink
//
//----------------------------------------------------------------------------

STDMETHODIMP CLangBarItemMgr::UnadviseItemsSink(ULONG ulCount, DWORD *pdwCookie)
{
    ULONG ul;
    for ( ul = 0; ul < ulCount; ul++)
    {
        if (FAILED(UnadviseItemSink(pdwCookie[ul])))
            return E_FAIL;
    }
    return S_OK;
}

//+---------------------------------------------------------------------------
//
// EnumLBItem
//
//----------------------------------------------------------------------------

STDAPI CLangBarItemMgr::EnumItems(IEnumTfLangBarItems **ppEnum)
{
    CEnumLBItem *pEnum = new CEnumLBItem(_psfn);
    *ppEnum = pEnum;
    return S_OK;
}

//+---------------------------------------------------------------------------
//
// GetItem
//
//----------------------------------------------------------------------------

STDAPI CLangBarItemMgr::GetItem(REFGUID rguid, ITfLangBarItem **ppItem)
{
    if (!ppItem)
        return E_INVALIDARG;

    *ppItem = NULL;

    CLBarItemSinkProxy *pProxy = GetItemSinkProxy(rguid);
    if (pProxy)
    {
        *ppItem = pProxy->_plbi;
        (*ppItem)->AddRef();
    }

    return *ppItem ? S_OK : S_FALSE;
}

//+---------------------------------------------------------------------------
//
// _AddWin32IMECtrl
//
//----------------------------------------------------------------------------

void CLangBarItemMgr::_AddWin32IMECtrl(BOOL fNotify)
{
    if (_plbiWin32IME != NULL)
        return;

    if (_plbiWin32IME = new CLBarItemWin32IME)
    {
        AddItem(_plbiWin32IME);
        _plbiWin32IME->ShowInternal(TRUE, fNotify);
    }
}

//+---------------------------------------------------------------------------
//
// _RemoveWin32IMECtrl
//
//----------------------------------------------------------------------------

void CLangBarItemMgr::_RemoveWin32IMECtrl()
{
    if (_plbiWin32IME == NULL)
        return;

    RemoveItem(_plbiWin32IME);
}

//+---------------------------------------------------------------------------
//
// GetItemSinkProxy
//
//----------------------------------------------------------------------------

CLBarItemSinkProxy *CLangBarItemMgr::GetItemSinkProxy(REFGUID rguid)
{
    CLBarItemSinkProxy *pProxy = NULL;
    int nCnt = _rglbiProxy.Count();
    int i;

    for (i = 0; i < nCnt; i++)
    {
         CLBarItemSinkProxy *pProxyTemp = _rglbiProxy.Get(i);
         if (IsEqualGUID(pProxyTemp->_info.guidItem, rguid))
         {
             pProxy = pProxyTemp;
             break;
         }
    }

    return pProxy;
}

//+---------------------------------------------------------------------------
//
// UpdateIcon
//
//----------------------------------------------------------------------------

HRESULT CLangBarItemMgr::OnUpdate(ITfLangBarItem *plbi, DWORD dwFlags)
{
    int i;
    int nCnt;
    HRESULT hr;
    TF_LANGBARITEMINFO info;
    BOOL fFound;

    //
    // Toolbar will be being updated. So no need to handle OnUpdate.
    // Toolbar will ask icons, bitmaps no matter what.
    //
    if (!_fHandleOnUpdate)
         return S_OK;

    hr = plbi->GetInfo(&info);
    if (FAILED(hr))
         return hr;
    
    fFound = FALSE;
    nCnt = _rgSink.Count();
    for (i = 0; i < nCnt ; i++)
    {
        CLBarItemSink *pSink = _rgSink.Get(i);

#ifdef DEBUG
        Assert(!pSink->_fUnadvised);
#endif

        if (IsEqualGUID(pSink->_info.guidItem, info.guidItem))
        {
            pSink->_dwDirtyUpdateFlags |= dwFlags;
            fFound = TRUE;
        }
    }

    if (_fDirtyUpdateHandling)
    {
        //
        // #509783
        //
        // Some apps (Adobe PhotoShop) call PeekMessage() to eat the message
        // from queue but it does not call DispatchMessage() sometimes.
        // We need a way to restore _fDirtyUpdateHandling flag.
        //
        if (GetTickCount() - dwDirtyUpdateHandlingTime > 1000)
        {
            _fDirtyUpdateHandling = 0;
        }
    }

    if (fFound && !_fDirtyUpdateHandling)
    {
        HWND hwnd = EnsureMarshalWnd();
        if (hwnd)
        {
            PostMessage(hwnd, g_msgNuiMgrDirtyUpdate, 0, 0);
            _fDirtyUpdateHandling = TRUE;
            dwDirtyUpdateHandlingTime = GetTickCount();
         
            //
            // we need to check Kana-Caps status every time the langbar item
            // is updated.
            //
            SYSTHREAD *psfn = FindSYSTHREAD();
            if (psfn)
                StartKanaCapsUpdateTimer(psfn);
        }
    }

    return S_OK;
}

//+---------------------------------------------------------------------------
//
// OnUpdateHandler
//
//----------------------------------------------------------------------------

HRESULT CLangBarItemMgr::OnUpdateHandler()
{
    int i;
    int nCnt;

    _fDirtyUpdateHandling = FALSE;
    _fInOnUpdateHandler = TRUE;

    nCnt = _rgSink.Count();

    for (i = 0; i < nCnt ; i++)
    {
        CLBarItemSink *pSink = _rgSink.Get(i);

        DWORD dwFlags = pSink->_dwDirtyUpdateFlags;

        if (!dwFlags)
            continue;

        pSink->_dwDirtyUpdateFlags = 0;
        pSink->_pItemSink->OnUpdate(dwFlags);

        int nCntNew = _rgSink.Count();
        if (nCnt > nCntNew)
        {
            nCnt = nCntNew;
            i--;
        }
    }

    _fInOnUpdateHandler = FALSE;
    return S_OK;
}


//////////////////////////////////////////////////////////////////////////////
//
// CLBarItemSinkProxy
//
//////////////////////////////////////////////////////////////////////////////

BOOL CLBarItemSinkProxy::Init(CLangBarItemMgr *plbiMgr, ITfLangBarItem *plbi, TF_LANGBARITEMINFO *pinfo)
{ 

    _plbiMgr = plbiMgr; // don't AddRef, because this obj is contained in the mgr's life
                        // we'd create a circular ref if we did, and we don't need to

    _plbi = plbi;
    _plbi->AddRef();
    _fCicTip = FALSE;

    _info = *pinfo;

    CTip *ptip;
    TfGuidAtom guidatom;
    CThreadInputMgr *ptim = CThreadInputMgr::_GetThis();
    if (ptim && SUCCEEDED(MyRegisterGUID(_info.clsidService, &guidatom)))
    {
         _fCicTip = ptim->_GetCTipfromGUIDATOM(guidatom, &ptip);
    }

    return TRUE;
}

//////////////////////////////////////////////////////////////////////////////
//
// CEnumLBItem
//
//////////////////////////////////////////////////////////////////////////////

//+---------------------------------------------------------------------------
//
// ctor
//
//----------------------------------------------------------------------------

CEnumLBItem::CEnumLBItem(SYSTHREAD *psfn) : CSysThreadRef(psfn)
{
    Dbg_MemSetThisNameID(TEXT("CEnumLBItem"));

    CThreadInputMgr *ptim = CThreadInputMgr::_GetThisFromSYSTHREAD(_psfn);
    if (ptim)
        _fHasFocusDIM = ptim->_GetFocusDocInputMgr() ? TRUE : FALSE;

    _nCur = 0;
}

//+---------------------------------------------------------------------------
//
// dtor
//
//----------------------------------------------------------------------------

CEnumLBItem::~CEnumLBItem()
{
}

//+---------------------------------------------------------------------------
//
// Clone
//
//----------------------------------------------------------------------------

HRESULT CEnumLBItem::Clone(IEnumTfLangBarItems **ppEnum)
{
    return E_NOTIMPL;
}

//+---------------------------------------------------------------------------
//
// Next
//
//----------------------------------------------------------------------------

HRESULT CEnumLBItem::Next(ULONG ulCount, ITfLangBarItem **ppLBItem, ULONG *pcFetched)
{
    int nCnt;
    ULONG cFetched;

    CLangBarItemMgr *plbim = _psfn->plbim;
    if (!plbim)
        return E_FAIL;

    nCnt = plbim->_rglbiProxy.Count();
    cFetched = 0;

    if (!ppLBItem)
         return E_INVALIDARG;

    *ppLBItem = NULL;

    while (cFetched < ulCount)
    {
        *ppLBItem = NULL;

        CLBarItemSinkProxy *pProxy;
        if (nCnt <= _nCur)
            break;

        pProxy = plbim->_rglbiProxy.Get(_nCur);
        if (!pProxy)
            break;

        if (_fHasFocusDIM || !pProxy->_fCicTip)
        {
           *ppLBItem = pProxy->_plbi;
           (*ppLBItem)->AddRef();

           ppLBItem++;
           cFetched++;
        }
        _nCur++;
    }

    if (pcFetched)
        *pcFetched = cFetched;

    return (cFetched == ulCount) ? S_OK : S_FALSE;
}

//+---------------------------------------------------------------------------
//
// Reset
//
//----------------------------------------------------------------------------

HRESULT CEnumLBItem::Reset()
{
    _nCur = 0;
    return S_OK;
}

//+---------------------------------------------------------------------------
//
// Skip
//
//----------------------------------------------------------------------------

HRESULT CEnumLBItem::Skip(ULONG ulCount)
{
    int nCnt;
    CLangBarItemMgr *plbim = _psfn->plbim;
    if (!plbim)
        return E_FAIL;

    nCnt = plbim->_rglbiProxy.Count();


    while (ulCount)
    {
        if (nCnt <= _nCur)
            break;

        _nCur++;
        ulCount--;
    }

    return ulCount ? S_FALSE : S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\ctf\uim\nuictrl.cpp ===
//depot/Lab06_N/windows/AdvCore/ctf/uim/nuictrl.cpp#50 - edit change 9353 (text)
//
// nui.cpp
//

#include "private.h"
#include "globals.h"
#include "nuictrl.h"
#include "xstring.h"
#include "immxutil.h"
#include "tim.h"
#include "profiles.h"
#include "ctffunc.h"
#include "slbarid.h"
#include "cregkey.h"
#include "cmydc.h"
#include "nuihkl.h"
#include "cresstr.h"
#include "slbarid.h"
#include "iconlib.h"


DBG_ID_INSTANCE(CLBarItemCtrl);
DBG_ID_INSTANCE(CLBarItemHelp);

#define SHOW_BRANDINGICON 1

//---------------------------------------------------------------------------
//
// TF_RunInputCPL
//
//---------------------------------------------------------------------------

HRESULT WINAPI TF_RunInputCPL()
{
    CicSystemModulePath fullpath;
    TCHAR szRunInputCPLCmd[MAX_PATH * 2];
    UINT uLen = 0;
    HRESULT hr = E_FAIL;

    if (IsOnNT51())
        fullpath.Init(c_szRunInputCPLOnNT51);
    else if (IsOn98() || IsOn95())
        fullpath.Init(c_szRunInputCPLOnWin9x);
    else
        fullpath.Init(c_szRunInputCPL);

    if (!fullpath.GetLength())
        return hr;

    StringCchPrintf(szRunInputCPLCmd,
                    ARRAYSIZE(szRunInputCPLCmd),
                    c_szRunInputCPLCmdLine,
                    fullpath.GetPath());

    if (RunCPLSetting(szRunInputCPLCmd))
        hr = S_OK;

    return hr;
}


//////////////////////////////////////////////////////////////////////////////
//
// CLBarItemCtrl
//
//////////////////////////////////////////////////////////////////////////////

//+---------------------------------------------------------------------------
//
// ctor
//
//----------------------------------------------------------------------------

CLBarItemCtrl::CLBarItemCtrl(SYSTHREAD *psfn) : CSysThreadRef(psfn)
{
    Dbg_MemSetThisNameID(TEXT("CLBarItemCtrl"));

    InitNuiInfo(CLSID_SYSTEMLANGBARITEM,  
                GUID_LBI_CTRL, 
                TF_LBI_STYLE_BTN_MENU | 
                TF_LBI_STYLE_HIDDENSTATUSCONTROL | 
                TF_LBI_STYLE_SHOWNINTRAY, 
                0,
                CRStr(IDS_NUI_LANGUAGE_TEXT));

    SetToolTip(CRStr(IDS_NUI_LANGUAGE_TOOLTIP));
    _meEto = 0;
    _Init();
}

//+---------------------------------------------------------------------------
//
// dtor
//
//----------------------------------------------------------------------------

CLBarItemCtrl::~CLBarItemCtrl()
{
    HICON hIcon = GetIcon();
    SetIcon(NULL);
    if (hIcon)
        DestroyIcon(hIcon);
}

//----------------------------------------------------------------------------
//
// Init
//
//----------------------------------------------------------------------------

#define NLS_RESOURCE_LOCALE_KEY   TEXT("Control Panel\\desktop\\ResourceLocale")
void CLBarItemCtrl::_Init()
{
    if (GetSystemMetrics(SM_MIDEASTENABLED))
    {
        char sz[10];
        long cb = sizeof(sz);

        //
        // as we are releasing an enabled version, we need to check the
        // resource locale as well.
        //
        sz[0] = '\0';
        if( RegQueryValue( HKEY_CURRENT_USER, 
                           NLS_RESOURCE_LOCALE_KEY, sz, &cb) == ERROR_SUCCESS)
            if ((cb == 9) && 
                (sz[6] == '0') && 
                ((sz[7] == '1') || (sz[7] == 'd') || (sz[7] == 'D')))
                _meEto = ETO_RTLREADING;
    }

    TF_InitMlngInfo();

    _AsmListUpdated(FALSE);
}


//+---------------------------------------------------------------------------
//
// InitMenu
//
//----------------------------------------------------------------------------

STDAPI CLBarItemCtrl::InitMenu(ITfMenu *pMenu)
{
    CThreadInputMgr *ptim;
    CAssemblyList *pAsmList;
    int i;
    int nCnt;
    INT cxSmIcon;
    INT cySmIcon;
    LOGFONT lf;
    int nMenuFontHeight;

    cxSmIcon = cySmIcon = GetMenuIconHeight(&nMenuFontHeight);

    if( !SystemParametersInfo(SPI_GETICONTITLELOGFONT, sizeof(LOGFONT), &lf, 0))
        return E_FAIL;

    lf.lfHeight = nMenuFontHeight;
    lf.lfWidth  = 0;
    lf.lfWeight = FW_NORMAL;

    if ((pAsmList = EnsureAssemblyList(_psfn)) == NULL)
        return E_FAIL;

    nCnt = pAsmList->Count();
    Assert(nCnt > 0);

    ptim = CThreadInputMgr::_GetThisFromSYSTHREAD(_psfn);

    for (i = 0; i < nCnt; i++)
    {
        CAssembly *pAsm = pAsmList->GetAssembly(i);

        if (pAsm->IsEnabled(_psfn))
        {
            BOOL bChecked = (pAsm->GetLangId() == GetCurrentAssemblyLangId(_psfn));

            HICON hIcon = InatCreateIconBySize(pAsm->GetLangId(), cxSmIcon, cySmIcon, &lf);
            HBITMAP hbmp = NULL;
            HBITMAP hbmpMask = NULL;
            if (hIcon)
            {
                SIZE size = {cxSmIcon, cySmIcon};

                if (!GetIconBitmaps(hIcon, &hbmp, &hbmpMask, &size))
                    return E_FAIL;

                if (hIcon)
                    DestroyIcon(hIcon);
            }

            pMenu->AddMenuItem(IDM_ASM_MENU_START + i, 
                               bChecked ? TF_LBMENUF_CHECKED : 0,
                               hbmp,
                               hbmpMask,
                               pAsm->GetLangName(),
                               wcslen(pAsm->GetLangName()),
                               NULL);

        }

    }

    DWORD dwFlags;
    if (SUCCEEDED(CLangBarMgr::s_GetShowFloatingStatus(&dwFlags)))
    {
        if (dwFlags & (TF_SFT_MINIMIZED | TF_SFT_DESKBAND))
        {
            LangBarInsertSeparator(pMenu);
            LangBarInsertMenu(pMenu, IDM_SHOWLANGBAR, CRStr(IDS_SHOWLANGBAR));
#if 0
            if (dwFlags & TF_SFT_EXTRAICONSONMINIMIZED) 
                LangBarInsertMenu(pMenu, 
                                  IDM_NONOTIFICATIONICONS, 
                                  CRStr(IDS_NOTIFICATIONICONS),
                                  TRUE);
            else
                LangBarInsertMenu(pMenu, 
                                  IDM_NOTIFICATIONICONS, 
                                  CRStr(IDS_NOTIFICATIONICONS),
                                  FALSE);
            LangBarInsertMenu(pMenu, IDM_SHOWINPUTCPL, CRStr(IDS_SHOWINPUTCPL));
#endif
        }
    }


    return S_OK;
}

//+---------------------------------------------------------------------------
//
// OnMenuSelect
//
//----------------------------------------------------------------------------

STDAPI CLBarItemCtrl::OnMenuSelect(UINT uID)
{
    CAssemblyList *pAsmList = EnsureAssemblyList(_psfn);
    switch (uID)
    {
        case IDM_SHOWLANGBAR:
            CLangBarMgr::s_ShowFloating(TF_SFT_SHOWNORMAL);
            break;

        case IDM_NOTIFICATIONICONS:
            CLangBarMgr::s_ShowFloating(TF_SFT_EXTRAICONSONMINIMIZED);
            break;

        case IDM_NONOTIFICATIONICONS:
            CLangBarMgr::s_ShowFloating(TF_SFT_NOEXTRAICONSONMINIMIZED);
            break;

        case IDM_SHOWINPUTCPL:
            TF_RunInputCPL();
            break;

        default:
            if (uID >= IDM_ASM_MENU_START)
            {
                Assert((uID - IDM_ASM_MENU_START) < (UINT)pAsmList->Count());
                CAssembly *pAsm = pAsmList->GetAssembly(uID - IDM_ASM_MENU_START);
                if (pAsm && (pAsm->GetLangId() != GetCurrentAssemblyLangId(_psfn)))
                    ActivateAssembly(pAsm->GetLangId(), ACTASM_NONE);
            }
            break;
    }
    return S_OK;
}

//+---------------------------------------------------------------------------
//
// OnShellLanguage
//
//----------------------------------------------------------------------------

void CLBarItemCtrl::OnShellLanguage(HKL hKL)
{
    _UpdateLangIcon(hKL, FALSE);
}

//+---------------------------------------------------------------------------
//
// UpdateLangIcon
//
//----------------------------------------------------------------------------

void CLBarItemCtrl::_UpdateLangIcon(HKL hKL, BOOL fNotify)
{
    CLBarItemDeviceType *plbiDT = NULL;
    BOOL fIsPureIME;
    CThreadInputMgr *ptim;
    int nCnt;
    int i;

    if (!hKL)
        hKL = GetKeyboardLayout(NULL);

    _UpdateLangIconForCic(fNotify);

    ptim = CThreadInputMgr::_GetThisFromSYSTHREAD(_psfn);

    if (ptim && ptim->_GetFocusDocInputMgr()) 
    {
        CAssembly *pAsm = GetCurrentAssembly(_psfn);
        if (!pAsm)
            return;
        fIsPureIME = pAsm->IsFEIMEActive();
    }
    else
    {
        fIsPureIME = IsPureIMEHKL(hKL);
    }


    if (fIsPureIME)
    {
        if (_psfn->plbim != NULL)
        {
            _psfn->plbim->_AddWin32IMECtrl(fNotify);
        }
    }
    else
    {
        if (_psfn->plbim != NULL)
        {
            _psfn->plbim->_RemoveWin32IMECtrl();
        }
    }


#ifdef SHOW_BRANDINGICON
    if (_psfn->plbim && _psfn->plbim->_GetLBarItemDeviceTypeArray())
    {
        nCnt = _psfn->plbim->_GetLBarItemDeviceTypeArray()->Count();

        for (i = 0; i < nCnt; i++)
        {
            plbiDT = _psfn->plbim->_GetLBarItemDeviceTypeArray()->Get(i);
            if (!plbiDT)
                continue;

            if (plbiDT->IsKeyboardType())
            {
                plbiDT->SetBrandingIcon(hKL, fNotify);
                break;
            }
        }
    }
#endif SHOW_BRANDINGICON

    if (fNotify && _plbiSink)
        _plbiSink->OnUpdate(TF_LBI_ICON);
}

//+---------------------------------------------------------------------------
//
// AsmListUpdated
//
//----------------------------------------------------------------------------

void CLBarItemCtrl::_AsmListUpdated(BOOL fNotify)
{
    CAssemblyList *pAsmList;
    int i;
    int nCntShowInMenu = 0;
    int nCnt;

    if ((pAsmList = EnsureAssemblyList(_psfn)) == NULL)
        return;

    nCnt = pAsmList->Count();
    Assert(nCnt > 0);

    for (i = 0; i < nCnt; i++)
    {
        CAssembly *pAsm = pAsmList->GetAssembly(i);

        if (pAsm->IsEnabled(_psfn))
        {
            nCntShowInMenu++;
        }
    }

    ShowInternal((nCntShowInMenu > 1), fNotify);
}

//+---------------------------------------------------------------------------
//
// UpdateLangIconForCic
//
//----------------------------------------------------------------------------

void CLBarItemCtrl::_UpdateLangIconForCic(BOOL fNotify)
{
    HICON hIcon;
    LANGID langid = GetCurrentAssemblyLangId(_psfn);

    if (langid == _langidForIcon)
        return;

    _langidForIcon = langid;

    hIcon = GetIcon();
    SetIcon(NULL);

    if (hIcon)
        DestroyIcon(hIcon);

    hIcon = InatCreateIcon(_langidForIcon);
    SetIcon(hIcon);
    if (hIcon)
    {
        CAssembly *pAsm = GetCurrentAssembly(_psfn);
        if (pAsm != NULL)
        {
            SetToolTip(pAsm->GetLangName());
            SetText(pAsm->GetLangName());
        }
    }

    if (fNotify && _plbiSink)
        _plbiSink->OnUpdate(TF_LBI_ICON | TF_LBI_TEXT | TF_LBI_TOOLTIP);
}

//+---------------------------------------------------------------------------
//
// OnSysColorChanged
//
//----------------------------------------------------------------------------

void CLBarItemCtrl::OnSysColorChanged()
{
    HICON hIcon = GetIcon();
    SetIcon(NULL);
    if (hIcon)
        DestroyIcon(hIcon);

    hIcon = InatCreateIcon(_langidForIcon);
    SetIcon(hIcon);

#ifdef WHISTLER_LATER
    if (_plbiSink && GetFocus())
        _plbiSink->OnUpdate(TF_LBI_ICON);
#endif
}


//////////////////////////////////////////////////////////////////////////////
//
// CLBarItemHelp
//
//////////////////////////////////////////////////////////////////////////////

//+---------------------------------------------------------------------------
//
// ctor
//
//----------------------------------------------------------------------------

CLBarItemHelp::CLBarItemHelp(SYSTHREAD *psfn) :  CLBarItemSystemButtonBase(psfn)
{
    Dbg_MemSetThisNameID(TEXT("CLBarItemHelp"));

    InitNuiInfo(CLSID_SYSTEMLANGBARITEM2,  
                GUID_LBI_HELP, 
                TF_LBI_STYLE_BTN_MENU | 
                // TF_LBI_STYLE_HIDDENSTATUSCONTROL | 
                TF_LBI_STYLE_HIDEONNOOTHERITEMS, 
                HELPBTN_ORDER,
                CRStr(IDS_IMEHELP));

    SetToolTip(CRStr(IDS_NUI_HELP));

    if (!IsInteractiveUserLogon())
        SetStatusInternal(TF_LBI_STATUS_DISABLED);

}

//+---------------------------------------------------------------------------
//
// InitMenu
//
//----------------------------------------------------------------------------

STDAPI CLBarItemHelp::InitMenu(ITfMenu *pMenu)
{
    int nCnt = 0;
    CThreadInputMgr *ptim;

    UINT nTipCurMenuID = IDM_CUSTOM_MENU_START;

    ptim = _psfn->ptim;


    if (!_InsertCustomMenus(pMenu, &nTipCurMenuID))
        goto InsertSysHelpItem;

    //
    // Insert separator.
    //
    if (nTipCurMenuID > IDM_CUSTOM_MENU_START)
        LangBarInsertSeparator(pMenu);

    if (ptim && ptim->_GetFocusDocInputMgr())
    {
        int i = 0;
        BOOL fInsert = FALSE;
        nCnt = ptim->_GetTIPCount();
    
        for (i = 0; i < nCnt; i++)
        {
            const CTip *ptip = ptim->_GetCTip(i);
    
            ITfFnShowHelp *phelp;
    
            if (nCnt >= IDM_CUSTOM_MENU_START)
            {
                Assert(0);
                break;
            }
    
            if (!ptip->_pFuncProvider)
                continue;
    
            if (SUCCEEDED(ptip->_pFuncProvider->GetFunction(GUID_NULL, 
                                                            IID_ITfFnShowHelp, 
                                                            (IUnknown **)&phelp)))
            {
    
                BSTR bstr;
                if (SUCCEEDED(phelp->GetDisplayName(&bstr)))
                {
                    LangBarInsertMenu(pMenu, i, bstr, FALSE);
                    fInsert = TRUE;
                    SysFreeString(bstr);
                }
                phelp->Release();
            }
        }
    
        if (fInsert)
            LangBarInsertSeparator(pMenu);
    }

InsertSysHelpItem:
    LangBarInsertMenu(pMenu, nCnt, CRStr(IDS_LANGBARHELP), FALSE);

    return S_OK;
}

//+---------------------------------------------------------------------------
//
// OnMenuSelect
//
//----------------------------------------------------------------------------

STDAPI CLBarItemHelp::OnMenuSelect(UINT uID)
{
    HRESULT hr = E_FAIL;
    CThreadInputMgr *ptim = CThreadInputMgr::_GetThis();
    UINT ulCnt = 0;

    if (ptim)
        ulCnt = ptim->_GetTIPCount();

    if (uID >= IDM_CUSTOM_MENU_START)
    {
        int nMenuMapoCnt = _pMenuMap->Count();
        int i;
        for (i = 0; i < nMenuMapoCnt; i++)
        {
            TIPMENUITEMMAP *ptmm;
            ptmm = _pMenuMap->GetPtr(i);
            if (ptmm->nTmpID == (UINT)uID)
            {
                hr = ptmm->plbSink->OnMenuSelect(ptmm->nOrgID);
                break;
            }
        }
    }
    else if (uID > ulCnt)
    {
        hr = E_UNEXPECTED;
    }
    else if (uID == ulCnt)
    {
        //
        //  show Langbar help
        //
        InvokeCicHelp();
        hr = S_OK;
    }
    else
    {
        Assert(ptim);
        const CTip *ptip = ptim->_GetCTip(uID);

        if (ptip->_pFuncProvider)
        {
            ITfFnShowHelp *phelp;
            if (SUCCEEDED(ptip->_pFuncProvider->GetFunction(GUID_NULL, 
                                                            IID_ITfFnShowHelp, 
                                                            (IUnknown **)&phelp)))
            {
                hr = phelp->Show(GetActiveWindow());
                phelp->Release();
            }
        }
    }

    ClearMenuMap();
    return hr;
}

//+---------------------------------------------------------------------------
//
// InvokeCicHelp
//
//----------------------------------------------------------------------------

BOOL CLBarItemHelp::InvokeCicHelp()
{
    return FullPathExec(c_szHHEXE, c_szHHEXELANGBARCHM, SW_SHOWNORMAL, TRUE);
}

//+---------------------------------------------------------------------------
//
// GetIcon
//
//----------------------------------------------------------------------------

STDAPI CLBarItemHelp::GetIcon(HICON *phIcon)
{
    *phIcon = LoadSmIcon(g_hInst, MAKEINTRESOURCE(ID_ICON_HELP));
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\ctf\uim\nuihkl.cpp ===
//
// nui.cpp
//

#include "private.h"
#include "globals.h"
#include "nuihkl.h"
#include "xstring.h"
#include "tim.h"
#include "dim.h"
#include "immxutil.h"
#include "internat.h"
#include "ctffunc.h"
#include "imemenu.h"
#include "ic.h"
#include "imelist.h"
#include "computil.h"
#include "funcprv.h"
#include "nuictrl.h"
#include "profiles.h"
#include "lbmenu.h"
#include "slbarid.h"
#include "cresstr.h"
#include "fnrecon.h"

DBG_ID_INSTANCE(CLBarItemWin32IME);
DBG_ID_INSTANCE(CLBarItemReconv);
DBG_ID_INSTANCE(CLBarItemDeviceType);

extern "C" DWORD WINAPI TF_CheckThreadInputIdle(DWORD dwThreadId, DWORD dwTimeOut);

#define LBBASE_NUM_CONNECTIONPTS 1

//////////////////////////////////////////////////////////////////////////////
//
// utility functions
//
//////////////////////////////////////////////////////////////////////////////

#ifndef WM_IME_SYSTEM
#define WM_IME_SYSTEM 0x287
#endif

// wParam for WM_IME_SYSTEM
#define TFS_DESTROYWINDOW               0x0001
#define TFS_IME31COMPATIBLE             0x0002
#define TFS_SETOPENSTATUS               0x0003
#define TFS_SETACTIVECONTEXT            0x0004
#define TFS_CHANGE_SHOWSTAT             0x0005
#define TFS_WINDOWPOS                   0x0006
#define TFS_SENDIMEMSG                  0x0007
#define TFS_SENDIMEMSGEX                0x0008
#define TFS_SETCANDIDATEPOS             0x0009
#define TFS_SETCOMPOSITIONFONT          0x000A
#define TFS_SETCOMPOSITIONWINDOW        0x000B
#define TFS_CHECKENABLE                 0x000C
#define TFS_CONFIGUREIME                0x000D
#define TFS_CONTROLIMEMSG               0x000E
#define TFS_SETOPENCLOSE                0x000F
#define TFS_ISACTIVATED                 0x0010
#define TFS_UNLOADTHREADLAYOUT          0x0011
#define TFS_LCHGREQUEST                 0x0012
#define TFS_SETSOFTKBDONOFF             0x0013
#define TFS_GETCONVERSIONMODE           0x0014
#define TFS_IMEHELP                     0x0015          // ;Internal


//+---------------------------------------------------------------------------
//
// GetIMEShowStatus
//
//----------------------------------------------------------------------------

static char szInputMethod[]="control panel\\input method" ;
static TCHAR szInputMethodNT[] = TEXT("Control Panel\\Input Method");
static char szValueName[]="show status";
BOOL GetIMEShowStatus()
{
    char  szValueText[16];
    ULONG cb;
    HKEY  hkey;
    BOOL fReturn = IsOnNT() ? TRUE : FALSE;

    if(RegOpenKey(HKEY_CURRENT_USER, IsOnNT() ? szInputMethodNT : szInputMethod,&hkey) == ERROR_SUCCESS)
    {
        cb = sizeof(szValueText);

        if(RegQueryValueEx(hkey, szValueName, NULL, NULL, (BYTE *)szValueText, &cb) != ERROR_SUCCESS)
        {
             szValueText[0] = '\0';
        }
        RegCloseKey(hkey);
        if(lstrcmp(szValueText, IsOnNT() ? "0" : "1") == 0)
           fReturn = !fReturn;
    }

    return fReturn;
}

//+---------------------------------------------------------------------------
//
// SetIMEShowStatus
//
//----------------------------------------------------------------------------

BOOL SetIMEShowStatus(HWND hwnd, BOOL fShow)
{
    char  szValueText[16];
    ULONG cb;
    HKEY  hkey;

    szValueText[0] = fShow ? '1' : '0';
    szValueText[1] = 0;

    if(RegOpenKey(HKEY_CURRENT_USER,szInputMethod,&hkey)==ERROR_SUCCESS)
    {
        cb = lstrlen(szValueText)+1;
        if(RegSetValueEx(hkey, szValueName, 0L, REG_SZ, (BYTE *)szValueText, cb) == ERROR_SUCCESS)
        {
            if (IsOnNT())
            {
                hwnd = ImmGetDefaultIMEWnd(hwnd);
                if (IsWindow(hwnd))
                    goto SendShowMsg;
            }
            else
            {
SendShowMsg:
             SendMessage(hwnd, WM_IME_SYSTEM, TFS_CHANGE_SHOWSTAT, (LPARAM)(DWORD)fShow);
            }
        }
        RegCloseKey(hkey);
        return TRUE;
    }
    return FALSE;
}

//+---------------------------------------------------------------------------
//
// CallIMEHelp
//
//----------------------------------------------------------------------------

BOOL CallIMEHelp(HWND hwnd, BOOL fCallWinHelp)
{
    if(hwnd)
    {
        return (BOOL)SendMessage(hwnd, WM_IME_SYSTEM, TFS_IMEHELP, 
                           (LPARAM)fCallWinHelp);

    }
    return FALSE;
}


//+---------------------------------------------------------------------------
//
// CallConfigureIME
//
//----------------------------------------------------------------------------

void CallConfigureIME(HWND hwnd, HKL dwhkl)
{
    if (IsWindow(hwnd))
    {
        hwnd = ImmGetDefaultIMEWnd(hwnd);

        if(IsWindow(hwnd))
        {
            SendMessage(hwnd, WM_IME_SYSTEM, TFS_CONFIGUREIME, (LPARAM)dwhkl);
        }
    }
}

//---------------------------------------------------------------------------
//
// GetFontSig()
//
//---------------------------------------------------------------------------

BOOL GetFontSig(HWND hwnd, HKL hKL)
{
    LOCALESIGNATURE ls;
    BOOL bFontSig = 0;

    //
    // 4th param is TCHAR count but we call GetLocaleInfoA()
    //                                                   ~
    // so we pass "sizeof(LOCALESIGNATURE) / sizeof(char)".
    //
    if( GetLocaleInfoA( (DWORD)(LOWORD(hKL)), 
                        LOCALE_FONTSIGNATURE, 
                        (LPSTR)&ls, 
                        sizeof(LOCALESIGNATURE) / sizeof(char)))
    {
        CHARSETINFO cs;
        HDC hdc = GetDC(hwnd);
        TranslateCharsetInfo((LPDWORD)UIntToPtr(GetTextCharsetInfo(hdc,NULL,0)), 
                             &cs, TCI_SRCCHARSET);
        DWORD fsShell = cs.fs.fsCsb[0];
        ReleaseDC(hwnd, hdc);
        if (fsShell & ls.lsCsbSupported[0])
            bFontSig = 1;
    }
    return bFontSig;
}

//+---------------------------------------------------------------------------
//
// CanActivateKeyboardLayout
//
//----------------------------------------------------------------------------

BOOL CanActivateKeyboardLayout(HKL hkl)
{
    if (!IsIMEHKL(hkl))
        return TRUE;

    //
    // ActivateKeyboardLayout() does not call ImeSelct() if default ime window
    // is destroyed.
    //
    HWND hDefImeWnd = ImmGetDefaultIMEWnd(NULL);
    if (!hDefImeWnd)
        return FALSE;

    if (!IsWindow(hDefImeWnd))
        return FALSE;

    return TRUE;
}

//+---------------------------------------------------------------------------
//
// PostInputLangRequest
//
//----------------------------------------------------------------------------

void PostInputLangRequest(SYSTHREAD *psfn, HKL hkl, BOOL fUsePost)
{
    if (!psfn->hklBeingActivated)
    {
        if (hkl == GetKeyboardLayout(0))
            return;
    }
    else if (psfn->hklBeingActivated == hkl)
    {
        return;
    }

    psfn->hklBeingActivated = hkl;

    //
    // Issue:
    //
    // we want to call ActivateKeybaordLayout() at the beginning of Thread
    // start. But is it safe to call it? There is no window created so
    // PostMessage() can not be used.
    // 
    // We need to take care of rejecting WM_INPUTLANGAGEREQUEST.
    //
    if (!fUsePost)
    {
        //
        // make sure we already updated the current assmelby lang id.
        // If not, we will call ActivateAssembly() in ShellHook again
        // and may cause recursion call of ActivateAssembly().
        //
        Assert((LOWORD(hkl) == GetCurrentAssemblyLangId(psfn)));

        if (g_dwAppCompatibility & CIC_COMPAT_DELAYFIRSTACTIVATEKBDLAYOUT)
        {
            static s_fFirstPostInput = FALSE;
            if (!s_fFirstPostInput)
            {
                s_fFirstPostInput = TRUE;
                goto TryPostMessage;
            }
        }

        //
        // #613953
        //
        // ActivateKeyboardLayout() does SendMessage() to the focus window.
        // If the focus window is in another thread, we like to check 
        // the thread is not busy.
        //
        HWND hwndFocus = GetFocus();
        DWORD dwFocusThread = 0;

        if (hwndFocus)
             dwFocusThread = GetWindowThreadProcessId(hwndFocus, NULL);

        if (dwFocusThread && (dwFocusThread != GetCurrentThreadId()))
        {
            if (TF_CheckThreadInputIdle(dwFocusThread, 0x100))
            {
                Assert(0);
                goto TryPostMessage;
            }
        }

        if (CanActivateKeyboardLayout(hkl))
        {
            if (!ActivateKeyboardLayout(hkl, 0))
            {
                psfn->hklDelayActive = hkl;
            }
        }
        else
        {
            //
            // There is no workaround here. The keyboard layout will be
            // restored correctly when this thread gets a visible window back.
            //
            Assert(0);
        }
    }
    else
    {
TryPostMessage:
        HWND hwndForLang = GetFocus();

        if (hwndForLang != NULL)
        {
            BOOL bFontSig = GetFontSig(hwndForLang, hkl);
            PostMessage(hwndForLang, 
                        WM_INPUTLANGCHANGEREQUEST, 
                        (WPARAM)bFontSig, 
                        (LPARAM)hkl);
        }
        else
        {
            psfn->hklDelayActive = hkl;
        }
    }
}

//+---------------------------------------------------------------------------
//
// GetIconIndexFromhKL
//
//----------------------------------------------------------------------------

ULONG GetIconIndexFromhKL(HKL hKL)
{
    MLNGINFO   mlInfo;
    BOOL       bFound;
    int nCnt = TF_MlngInfoCount();
    int i;

    bFound = FALSE;
    for (i = 0; i < nCnt; i++)
    {
        if (!GetMlngInfo(i, &mlInfo))
           continue;

        if (mlInfo.hKL == hKL)
        {
            bFound = TRUE;
            break;
        }
    }

    if (!bFound)
    {
        if (!GetMlngInfo(0, &mlInfo))
            return -1;
    }

    return mlInfo.GetIconIndex();
}

//+---------------------------------------------------------------------------
//
// GetIconIndex
//
//----------------------------------------------------------------------------

ULONG GetIconIndex(LANGID langid, ASSEMBLYITEM *pItem)
{
   ULONG uIconIndex = -1;

   if ((pItem->uIconIndex != -1) || pItem->fInitIconIndex)
       return pItem->uIconIndex;

   if (!IsEqualGUID(pItem->clsid, GUID_NULL))
   {
       int cx, cy;
       ULONG uFileIconIndex;
       WCHAR szFileName[MAX_PATH];

       InatGetIconSize(&cx, &cy);

       //
       // Get Icon filename from registry.
       //
       // At first, we try the given langid's icon.
       // Then we try just primary language.
       // At last we try 0xffff complete neutral language.
       //
TryAgain:
       if (SUCCEEDED(GetProfileIconInfo(pItem->clsid,
                                        langid,
                                        pItem->guidProfile,
                                        szFileName, ARRAYSIZE(szFileName),
                                        &uFileIconIndex)))
       {
           HICON hIcon = GetIconFromFile(cx, cy, szFileName, uFileIconIndex);

           if (hIcon)
           {
               uIconIndex = InatAddIcon(hIcon);
               DestroyIcon(hIcon);
           }
       }
       else if (langid != 0xffff) 
       {
           if (langid & 0xfc00)
           {
              langid = PRIMARYLANGID(langid);
           }
           else
           {
              langid = 0xffff;
           }
           goto TryAgain;
       }

   }
   else
   {
       uIconIndex = GetIconIndexFromhKL(pItem->hkl);
   }

   pItem->fInitIconIndex = TRUE;
   pItem->uIconIndex = uIconIndex;
   return uIconIndex;
}

//+---------------------------------------------------------------------------
//
// FlushIconIndex
//
//----------------------------------------------------------------------------

void FlushIconIndex(SYSTHREAD *psfn)
{
    int i,j;
    CAssemblyList *pAsmList;
    int nAsmCnt;

    //
    // reset icon of Language Button
    //
    if (psfn->plbim && psfn->plbim->_GetLBarItemCtrl())
        psfn->plbim->_GetLBarItemCtrl()->OnSysColorChanged();

    //
    // clear icon list cache.
    //
    pAsmList = psfn->pAsmList;
    if (!pAsmList)
        return;

    nAsmCnt = pAsmList->Count();
    if (!nAsmCnt)
        return;

    for (i = 0; i < nAsmCnt; i++)
    {
        CAssembly *pAsm = pAsmList->GetAssembly(i);
        int nItemCnt = pAsm->Count();
        for (j = 0; j < nItemCnt; j++)
        {
            ASSEMBLYITEM *pItem;
            pItem= pAsm->GetItem(j);
            pItem->fInitIconIndex = FALSE;
            pItem->uIconIndex = (ULONG)(-1);
        }
    }

    //
    // check icon list
    // And clean up all icon list if there is the impage icon list.
    //
    if (InatGetImageCount())
    {
        ClearMlngIconIndex();
        InatRemoveAll();
    }
}


//////////////////////////////////////////////////////////////////////////////
//
// CLBarItemWin32IME
//
//////////////////////////////////////////////////////////////////////////////

//+---------------------------------------------------------------------------
//
// ctor
//
//----------------------------------------------------------------------------
static const TCHAR c_szNuiWin32IMEWndClass[] = "NuiWin32IMEDummyWndClass";

CLBarItemWin32IME::CLBarItemWin32IME()
{
    Dbg_MemSetThisNameID(TEXT("CLBarItemWin32IME"));

    InitNuiInfo(CLSID_SYSTEMLANGBARITEM_KEYBOARD,  
                GUID_LBI_WIN32IME, 
                TF_LBI_STYLE_BTN_BUTTON | 
                TF_LBI_STYLE_HIDDENSTATUSCONTROL |
                TF_LBI_STYLE_SHOWNINTRAY |
                TF_LBI_STYLE_SHOWNINTRAYONLY, 
                WIN32IME_ORDER,
                CRStr(IDS_NUI_IME_TEXT));

    WNDCLASSEX wc;

    memset(&wc, 0, sizeof(wc));
    wc.cbSize        = sizeof(wc);
    wc.style         = CS_HREDRAW | CS_VREDRAW ;
    wc.hInstance     = g_hInst;
    wc.lpfnWndProc   = _WndProc;
    wc.lpszClassName = c_szNuiWin32IMEWndClass;
    RegisterClassEx(&wc);

    UpdateIMEIcon();

    SetText(CRStr(IDS_NUI_IME_TEXT));
    SetToolTip(CRStr(IDS_NUI_IME_TOOLTIP));
}

//+---------------------------------------------------------------------------
//
// _WndProc
//
//----------------------------------------------------------------------------

LRESULT CALLBACK CLBarItemWin32IME::_WndProc(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    switch (uMsg)
    {
        case WM_CREATE:
            SetThis(hWnd, lParam);
            break;

        default:
            return DefWindowProc(hWnd, uMsg, wParam, lParam);
    }

    return 0;
}

//+---------------------------------------------------------------------------
//
// OnLButtonUp
//
//----------------------------------------------------------------------------

HRESULT CLBarItemWin32IME::OnLButtonUp(const POINT pt, const RECT *prcArea)
{
    HWND hWnd;
    hWnd = CreateMyWnd();
    ShowIMELeftMenu(hWnd, pt.x, pt.y);
    DestroyWindow(hWnd);
    return S_OK;
}

//+---------------------------------------------------------------------------
//
// OnRButtonUp
//
//----------------------------------------------------------------------------

HRESULT CLBarItemWin32IME::OnRButtonUp(const POINT pt, const RECT *prcArea)
{
    HWND hWnd;
    hWnd = CreateMyWnd();
    ShowIMERightMenu(hWnd, pt.x, pt.y);
    DestroyWindow(hWnd);
    return S_OK;
}

//+---------------------------------------------------------------------------
//
// ShowIMELeftMenu
//
//----------------------------------------------------------------------------

void CLBarItemWin32IME::ShowIMELeftMenu(HWND hWnd, LONG xPos, LONG yPos)
{
    HKL   hKL;
    HMENU hMenu;
    HIMC  hIMC;
    HWND  hFocusWnd;
    int cmd;
    int nIds;
    int nIdsSoftKbd;
    DWORD fdwConversion;
    DWORD fdwSentence;
    BOOL fShow;
    CWin32ImeMenu *pWin32Menu = NULL;

    hKL = GetKeyboardLayout(0);

    hMenu = CreatePopupMenu();
    if (!hMenu)
        return;

    hFocusWnd = GetFocus();
    hIMC = ImmGetContext(hFocusWnd);

    if (IsOn98orNT5())
    {
        if ((pWin32Menu = new CWin32ImeMenu) == NULL)
            goto Exit;

        pWin32Menu->GetIMEMenu(hFocusWnd, hIMC, FALSE);
        pWin32Menu->BuildIMEMenu(hMenu, FALSE);
    }
    else
    {
        nIds = 0;
        // If Korean TFE, don't show OPEN/CLOSE menu
        if (((DWORD)(UINT_PTR)hKL & 0xF000FFFF) != 0xE0000412)
        {
            BOOL bOpen = ImmGetOpenStatus(hIMC);
            nIds= (bOpen ? IDS_IMECLOSE : IDS_IMEOPEN);
    
            InsertMenu(hMenu, (UINT)-1, MF_BYPOSITION, 
                                        IDM_IME_OPENCLOSE, CRStr(nIds));
        }
    
        // open or close the soft keyboard
        nIdsSoftKbd = 0;
        if (ImmGetProperty(hKL, IGP_CONVERSION) & IME_CMODE_SOFTKBD)
        {
            ImmGetConversionStatus(hIMC, &fdwConversion, &fdwSentence);
    
            nIdsSoftKbd = ((fdwConversion & IME_CMODE_SOFTKBD)?
                                            IDS_SOFTKBDOFF:IDS_SOFTKBDON);
    
            InsertMenu(hMenu, (UINT)-1, MF_BYPOSITION,
                                        IDM_IME_SOFTKBDONOFF, (LPCSTR)CRStr(nIdsSoftKbd));
        }
    
        if (nIds || nIdsSoftKbd) 
        {
            InsertMenu(hMenu, (UINT)-1, MF_SEPARATOR, 0, 0);
        }
    
        InsertMenu(hMenu, (UINT)-1, MF_BYPOSITION,
                                    IDM_IME_SHOWSTATUS, (LPCSTR)CRStr(IDS_IMESHOWSTATUS));
    
    
        if((fShow = GetIMEShowStatus()) == TRUE)
            CheckMenuItem(hMenu, IDM_IME_SHOWSTATUS, MF_CHECKED);
    }

    cmd = TrackPopupMenuEx(hMenu,
            TPM_VERTICAL | TPM_BOTTOMALIGN | TPM_NONOTIFY | TPM_RETURNCMD,
                xPos, yPos, hWnd, NULL);

    switch (cmd)
    {
        case IDM_IME_OPENCLOSE:
            if (hIMC)
                ImmSetOpenStatus(hIMC, (nIds == IDS_IMEOPEN));
            break;
    
        case IDM_IME_SOFTKBDONOFF:
            ImmGetConversionStatus(hIMC, &fdwConversion, &fdwSentence);
            if (nIdsSoftKbd == IDS_SOFTKBDOFF)
                fdwConversion &= ~IME_CMODE_SOFTKBD;
            else
                fdwConversion |= IME_CMODE_SOFTKBD;
            ImmSetConversionStatus(hIMC, fdwConversion, fdwSentence);
            break;

        case IDM_IME_SHOWSTATUS:
             SetIMEShowStatus(GetFocus(), !fShow);
             break;
    
        default:
             if (IsOn98orNT5() && 
                 pWin32Menu && 
                 (cmd >= IDM_CUSTOM_MENU_START))
             {
                   UINT uID = pWin32Menu->GetIMEMenuItemID(cmd);
                   DWORD dwData = pWin32Menu->GetIMEMenuItemData(uID);
                   ImmNotifyIME(hIMC, NI_IMEMENUSELECTED, uID, dwData);
             }
             break;
    }

Exit:
    DestroyMenu(hMenu);

    ImmReleaseContext(hFocusWnd, hIMC);

    if (pWin32Menu)
        delete pWin32Menu;
}

//+---------------------------------------------------------------------------
//
// ShowIMERightMenu
//
//----------------------------------------------------------------------------

void CLBarItemWin32IME::ShowIMERightMenu(HWND hWnd, LONG xPos, LONG yPos)
{
    HMENU       hMenu;
    int         cmd;
    HKL         hKL;
    HIMC        hIMC;
    HWND        hFocusWnd;
    CWin32ImeMenu *pWin32Menu = NULL;

    hFocusWnd = GetFocus();

    if (!(hIMC = ImmGetContext(hFocusWnd)))
        return;

    hMenu = CreatePopupMenu();

    if (hMenu == 0)
        goto ExitNoMenu;

    if (IsOn98orNT5())
    {
        if ((pWin32Menu = new CWin32ImeMenu) == NULL)
            goto Exit;

        pWin32Menu->GetIMEMenu(hFocusWnd, hIMC, TRUE);
        pWin32Menu->BuildIMEMenu(hMenu, TRUE);
    }
    else
    {
        InsertMenu(hMenu, (UINT)-1, MF_STRING | MF_BYPOSITION,
                          IDM_RMENU_PROPERTIES, (LPCSTR)CRStr(IDS_CONFIGUREIME));
    }

    cmd = TrackPopupMenuEx(hMenu,
            TPM_VERTICAL | TPM_BOTTOMALIGN | TPM_RETURNCMD,
                xPos, yPos, hWnd, NULL);

    if (cmd && (cmd != -1))
    {
        switch (cmd)
        {
            case IDM_RMENU_PROPERTIES:
                hKL = GetKeyboardLayout(0);

                if ((HIWORD(hKL) & 0xF000) == 0xE000)
                    CallConfigureIME(hFocusWnd, hKL);

                break;

            case IDM_RMENU_IMEHELP:
                CallIMEHelp(hFocusWnd, TRUE);
                break;

            default:
                if (IsOn98orNT5() && 
                    pWin32Menu && 
                    (cmd >= IDM_CUSTOM_MENU_START))
                {
                      UINT uID = pWin32Menu->GetIMEMenuItemID(cmd);
                      DWORD dwData = pWin32Menu->GetIMEMenuItemData(uID);
                      ImmNotifyIME(hIMC, NI_IMEMENUSELECTED, uID, dwData);
                }
                break;
        }
    }

Exit:
    DestroyMenu(hMenu);
ExitNoMenu:
    ImmReleaseContext(hFocusWnd, hIMC);

    if (pWin32Menu)
        delete pWin32Menu;
}

//+---------------------------------------------------------------------------
//
// UpdateIMEIcon
//
//----------------------------------------------------------------------------

void CLBarItemWin32IME::UpdateIMEIcon()
{
    HWND hWnd;
    HIMC hIMC;
    DWORD fdwConversion;
    DWORD fdwSentence;
    BOOL bOpen;
    HKL hKL = GetKeyboardLayout(0);

    if (!IsPureIMEHKL(hKL))
    {
        _nIconId = 0;
        goto Exit;
    }

    hWnd = GetFocus();
    hIMC = ImmGetContext(hWnd);
    bOpen = ImmGetOpenStatus(hIMC);
    ImmGetConversionStatus(hIMC, &fdwConversion, &fdwSentence);

    if (((DWORD)(UINT_PTR)hKL & 0xF000FFFFL) == 0xE0000412L)
    {
        if (!hIMC)
            _nIconId = ID_ICON_IMEDISAB;
        else if (!bOpen)
            _nIconId = ID_ICON_IMEE_H;
        else
        {
            _nIconId = (fdwConversion & IME_CMODE_NATIVE) ? 
                                     ID_ICON_IMEH_H : ID_ICON_IMEE_H;
            if (fdwConversion & IME_CMODE_FULLSHAPE)
                _nIconId++;
        }
    }
    else
    {
        if (!hIMC)
            _nIconId = ID_ICON_IMEDISAB;
        else
            _nIconId = bOpen ? ID_ICON_IMEOPEN : ID_ICON_IMECLOSE;

    }

    ImmReleaseContext(hWnd, hIMC);

Exit:
    SetStatusInternal(_nIconId ? 0 : TF_LBI_STATUS_HIDDEN | TF_LBI_STATUS_DISABLED);
    if (_plbiSink)
        _plbiSink->OnUpdate(TF_LBI_ICON | TF_LBI_STATUS);

}

//+---------------------------------------------------------------------------
//
// GetIcon
//
//----------------------------------------------------------------------------

STDAPI CLBarItemWin32IME::GetIcon(HICON *phIcon)
{
    *phIcon = LoadSmIcon(g_hInst, MAKEINTRESOURCE(_nIconId));
    return S_OK;
}

//////////////////////////////////////////////////////////////////////////////
//
// CAsyncReconvQueueItem
//
//////////////////////////////////////////////////////////////////////////////

class CAsyncReconvQueueItem : public CAsyncQueueItem
{
public:
    CAsyncReconvQueueItem() {}
    HRESULT DoDispatch(CInputContext *pic);
};

HRESULT CAsyncReconvQueueItem::DoDispatch(CInputContext *pic)
{
    CThreadInputMgr *ptim;
    ITfRange *pRangeSel = NULL;
    ITfRange *pRangeReconv = NULL;
    ITfFunctionProvider *psysFuncPrv = NULL;
    ITfFnReconversion *psysReconv = NULL;
    HRESULT hr;
    GETSELECTIONQUEUEITEM qItemGS;
    BOOL fConvertable;
    CStructArray<GENERICSINK> *prgSinks;
    int i;

    if ((ptim = CThreadInputMgr::_GetThis()) == NULL)
        return E_FAIL;

    //
    // AIMM12 hack!
    //
    // If the target IC is aimm12, we mak a notifycation to AIMM
    //
    prgSinks = pic->_GetStartReconversionNotifySinks();

    for (i = 0; i < prgSinks->Count(); i++)
        ((ITfStartReconversionNotifySink *)prgSinks->GetPtr(i)->pSink)->StartReconversion();


    hr = S_OK;
    qItemGS.ppRange = &pRangeSel;

    if (pic->_DoPseudoSyncEditSession(TF_ES_READ, PSEUDO_ESCB_GETSELECTION, &qItemGS, &hr) != S_OK || hr != S_OK)
    {
        Assert(0);
        goto Exit;
    }

    psysFuncPrv = ptim->GetSystemFunctionProvider();
    if (!psysFuncPrv)
        goto Exit;

    if (FAILED(psysFuncPrv->GetFunction(GUID_NULL, IID_ITfFnReconversion, 
                                        (IUnknown **)&psysReconv)))
        goto Exit;

    if (psysReconv->QueryRange(pRangeSel, &pRangeReconv, &fConvertable) != S_OK)
        goto Exit;

    if (fConvertable)
        psysReconv->Reconvert(pRangeReconv);

    SafeRelease(pRangeReconv);

Exit:
    for (i = 0; i < prgSinks->Count(); i++)
        ((ITfStartReconversionNotifySink *)prgSinks->GetPtr(i)->pSink)->EndReconversion();

    SafeRelease(pRangeSel);
    SafeRelease(psysFuncPrv);
    SafeRelease(psysReconv);

    return S_OK;
}

//+---------------------------------------------------------------------------
//
// AsyncReconversion
//
//----------------------------------------------------------------------------

HRESULT AsyncReconversion()
{
    CThreadInputMgr *ptim;
    CDocumentInputManager *pdim;
    CInputContext *pic;
    CAsyncReconvQueueItem *paReconv;
    HRESULT hr = E_FAIL;
    TF_STATUS dcs;

    if ((ptim = CThreadInputMgr::_GetThis()) == NULL)
        goto Exit;

    if ((pdim = ptim->_GetFocusDocInputMgr()) == NULL)
        goto Exit;

    if (!(pic = pdim->_GetTopIC()))
        goto Exit;

    if (SUCCEEDED(pic->GetStatus(&dcs)))
    {
        //
        // Korean AIMM1.2 don't support the corrention button.
        //
        if ((dcs.dwStaticFlags & TF_SS_TRANSITORY) &&
            (PRIMARYLANGID(GetCurrentAssemblyLangId(GetSYSTHREAD()))) == LANG_KOREAN)
        {
            goto Exit;
        }
    }

    paReconv = new CAsyncReconvQueueItem();
    if (!paReconv)
        goto Exit;
    
    hr = S_OK;

    if ((pic->_QueueItem(paReconv->GetItem(), FALSE, &hr) != S_OK) || FAILED(hr))
    {
        Assert(0);
    }

    paReconv->_Release();
Exit:
    return hr;
}

//////////////////////////////////////////////////////////////////////////////
//
// CLBarItemReconv
//
//////////////////////////////////////////////////////////////////////////////

//+---------------------------------------------------------------------------
//
// ctor
//
//----------------------------------------------------------------------------

CLBarItemReconv::CLBarItemReconv(SYSTHREAD *psfn) : CSysThreadRef(psfn)
{
    Dbg_MemSetThisNameID(TEXT("CLBarItemReconv"));

    InitNuiInfo(CLSID_SYSTEMLANGBARITEM,  
                GUID_LBI_RECONV, 
                TF_LBI_STYLE_BTN_BUTTON | TF_LBI_STYLE_HIDDENBYDEFAULT,
                0,
                CRStr(IDS_NUI_CORRECTION_TEXT));

    SetText(CRStr(IDS_NUI_CORRECTION_TEXT));
    SetToolTip(CRStr(IDS_NUI_CORRECTION_TOOLTIP));

    _fAddedBefore = FALSE;
}

//+---------------------------------------------------------------------------
//
// GetIcon
//
//----------------------------------------------------------------------------

STDAPI CLBarItemReconv::GetIcon(HICON *phIcon)
{
    *phIcon = LoadSmIcon(g_hInst, MAKEINTRESOURCE(ID_ICON_RECONVERSION));
    return S_OK;
}

//+---------------------------------------------------------------------------
//
// LButtonUpHandler
//
//----------------------------------------------------------------------------

HRESULT CLBarItemReconv::OnLButtonUp(const POINT pt, const RECT *prcArea)
{
    return AsyncReconversion();
}

//+---------------------------------------------------------------------------
//
// ShowOrHide
//
//----------------------------------------------------------------------------

void CLBarItemReconv::ShowOrHide(BOOL fNotify)
{
    CThreadInputMgr *ptim = _psfn->ptim;
    CDocumentInputManager *pdim;
    CInputContext *pic;
    BOOL bShow = FALSE;
    DWORD dwOldStatus = _dwStatus;

    //
    // If the real IME is running, we don't show the correction button.
    //
    if (!IsPureIMEHKL(GetKeyboardLayout(0)))
    {
        //
        // If there is no focus dim, we don't show the correction button.
        //
        if (ptim && (pdim = ptim->_GetFocusDocInputMgr()))
        {
            pic = pdim->_GetIC(0);
            if (pic)
            {
                LANGID langid = GetCurrentAssemblyLangId(_psfn);
                TF_STATUS dcs;
                CAssemblyList *pAsmList;
                CAssembly *pAsm;
                BOOL fTransitory = FALSE;
                BOOL fIsTipActive = FALSE;

                if (pAsmList = EnsureAssemblyList(_psfn))
                {
                    if (pAsm = pAsmList->FindAssemblyByLangId(langid))
                    {
                        int i;
                        for (i = 0; i < pAsm->Count(); i++)
                        {
                            ASSEMBLYITEM *pItem = pAsm->GetItem(i);

                            if (!pItem)
                                continue;

                            if (!pItem->fEnabled)
                                continue;

                            if (!pItem->fActive)
                                continue;

                            if (!IsEqualGUID(pItem->clsid, GUID_NULL))
                            {
                                fIsTipActive = TRUE;
                                break;
                            }
                        }
                    }
                }

                //
                // if there is no Tip, we won't show correction button.
                //
                if (!fIsTipActive)
                    goto Exit;

                if (SUCCEEDED(pic->GetStatus(&dcs)))
                {
                    //
                    // Don't show the corrention button on AIMM1.2 non EA.
                    // And Korean AIMM1.2 also don't show the corrention button.
                    //
                    if (dcs.dwStaticFlags & TF_SS_TRANSITORY)
                        fTransitory = TRUE;
                }

                if (!fTransitory || (IsFELangId(langid) && langid != 0x0412))
                {
                    bShow = TRUE;
                    SetOrClearStatus(TF_LBI_STATUS_DISABLED, FALSE);
                }
            }
            else
            {
                //
                // if it is shown, we don't remove it. Just disable it.
                //
                if (!(_dwStatus & TF_LBI_STATUS_HIDDEN))
                {
                    bShow = TRUE;
                    SetOrClearStatus(TF_LBI_STATUS_DISABLED, TRUE);
                }
            }
        }
    }

Exit:

    if (bShow)
    {
        if (_fAddedBefore)
        {
            SetOrClearStatus(TF_LBI_STATUS_DISABLED, FALSE);
            if (fNotify && (dwOldStatus != _dwStatus) && _plbiSink)
                 _plbiSink->OnUpdate(TF_LBI_STATUS);
        }
        else
        {
            _psfn->plbim->AddItem(this);
            SetOrClearStatus(TF_LBI_STATUS_HIDDEN, FALSE);
            if (fNotify && (dwOldStatus != _dwStatus) && _plbiSink)
                 _plbiSink->OnUpdate(TF_LBI_STATUS);

            _fAddedBefore = TRUE;
        }
    }
    else
    {
        if (_fAddedBefore)
        {
            SetOrClearStatus(TF_LBI_STATUS_DISABLED, TRUE);
            if (fNotify && (dwOldStatus != _dwStatus) && _plbiSink)
                 _plbiSink->OnUpdate(TF_LBI_STATUS);
        }
        else
        {
            SetOrClearStatus(TF_LBI_STATUS_HIDDEN, TRUE);
            if (fNotify && (dwOldStatus != _dwStatus) && _plbiSink)
                 _plbiSink->OnUpdate(TF_LBI_STATUS);
            _psfn->plbim->RemoveItem(*this->GetGuidItem());
        }
    }
}

//////////////////////////////////////////////////////////////////////////////
//
// CLBarItemSystemButtonBase
//
//////////////////////////////////////////////////////////////////////////////

//+---------------------------------------------------------------------------
//
// IUnknown
//
//----------------------------------------------------------------------------

STDAPI CLBarItemSystemButtonBase::QueryInterface(REFIID riid, void **ppvObj)
{
    *ppvObj = NULL;

    if (IsEqualIID(riid, IID_IUnknown) ||
        IsEqualIID(riid, IID_ITfLangBarItem))
    {
        *ppvObj = SAFECAST(this, ITfLangBarItem *);
    }
    else if (IsEqualIID(riid, IID_ITfLangBarItemButton))
    {
        *ppvObj = SAFECAST(this, ITfLangBarItemButton *);
    }
    else if (IsEqualIID(riid, IID_ITfSource))
    {
        *ppvObj = SAFECAST(this, ITfSource *);
    }
    else if (IsEqualIID(riid, IID_ITfSystemLangBarItem))
    {
        *ppvObj = SAFECAST(this, ITfSystemLangBarItem *);
    }
    else if (IsEqualIID(riid, IID_ITfSystemDeviceTypeLangBarItem))
    {
        *ppvObj = SAFECAST(this, ITfSystemDeviceTypeLangBarItem *);
    }

    if (*ppvObj)
    {
        AddRef();
        return S_OK;
    }

    return E_NOINTERFACE;
}

STDAPI_(ULONG) CLBarItemSystemButtonBase::AddRef()
{
    return CLBarItemButtonBase::AddRef();
}

STDAPI_(ULONG) CLBarItemSystemButtonBase::Release()
{
    return CLBarItemButtonBase::Release();
}

//+---------------------------------------------------------------------------
//
// ctor
//
//----------------------------------------------------------------------------

CLBarItemSystemButtonBase::CLBarItemSystemButtonBase(SYSTHREAD *psfn) : CSysThreadRef(psfn)
{
    _dwIconMode = 0;
}

//----------------------------------------------------------------------------
//
// dtor
//
//----------------------------------------------------------------------------

CLBarItemSystemButtonBase::~CLBarItemSystemButtonBase()
{
    if (_pMenuMap)
        delete _pMenuMap;
}

//+---------------------------------------------------------------------------
//
// AdviseSink
//
//----------------------------------------------------------------------------

STDAPI CLBarItemSystemButtonBase::AdviseSink(REFIID riid, IUnknown *punk, DWORD *pdwCookie)
{
    HRESULT hr = CLBarItemButtonBase::AdviseSink(riid, punk, pdwCookie);

    if (hr == S_OK)
       return hr;

    const IID *rgiid = &IID_ITfSystemLangBarItemSink;
    hr = GenericAdviseSink(riid, punk, &rgiid, &_rgEventSinks, 1, pdwCookie);
    if (hr != S_OK)
        return hr;

    // adjust the cookie so we don't overlap with idle detector sinks
    *pdwCookie = GenericChainToCookie(*pdwCookie, LBBASE_NUM_CONNECTIONPTS);

    return hr;
}

//+---------------------------------------------------------------------------
//
// UnadviseSink
//
//----------------------------------------------------------------------------

STDAPI CLBarItemSystemButtonBase::UnadviseSink(DWORD dwCookie)
{
    HRESULT hr =  CLBarItemButtonBase::UnadviseSink(dwCookie);
    if (hr == S_OK)
       return hr;

    dwCookie = GenericUnchainToCookie(dwCookie, LBBASE_NUM_CONNECTIONPTS);
    return GenericUnadviseSink(&_rgEventSinks, 1, dwCookie);
}

//+---------------------------------------------------------------------------
//
// GetInfo
//
//----------------------------------------------------------------------------

STDAPI CLBarItemSystemButtonBase::GetInfo(TF_LANGBARITEMINFO *pInfo)
{
    return CLBarItemButtonBase::GetInfo(pInfo);
}

//+---------------------------------------------------------------------------
//
// Show
//
//----------------------------------------------------------------------------

STDAPI CLBarItemSystemButtonBase::Show(BOOL fShow)
{
    return CLBarItemButtonBase::Show(fShow);
}

//----------------------------------------------------------------------------
//
// SetIcon
//
//----------------------------------------------------------------------------

STDAPI CLBarItemSystemButtonBase::SetIcon(HICON hIcon)
{
    CLBarItemButtonBase::SetIcon(hIcon);
    return S_OK;
}

//----------------------------------------------------------------------------
//
// SetTooltipString
//
//----------------------------------------------------------------------------

STDAPI CLBarItemSystemButtonBase::SetTooltipString(WCHAR *pchToolTip, ULONG cch)
{
    SetToolTip(pchToolTip, cch);
    return S_OK;
}

//----------------------------------------------------------------------------
//
// SetIconMode()
//
//----------------------------------------------------------------------------

STDAPI CLBarItemSystemButtonBase::SetIconMode(DWORD dwFlags)
{
    _dwIconMode = dwFlags;

    if (_dwIconMode & TF_DTLBI_USEPROFILEICON)
        SetBrandingIcon(NULL, TRUE);
    else
        SetDefaultIcon(TRUE);


    return S_OK;
}
//----------------------------------------------------------------------------
//
// GetIconMode()
//
//----------------------------------------------------------------------------

STDAPI CLBarItemSystemButtonBase::GetIconMode(DWORD *pdwFlags)
{
    if (!pdwFlags)
        return E_INVALIDARG;

    *pdwFlags = _dwIconMode;

    return S_OK;
}

//+---------------------------------------------------------------------------
//
// _InsertCustomMenus
//
//----------------------------------------------------------------------------

BOOL CLBarItemSystemButtonBase::_InsertCustomMenus(ITfMenu *pMenu, UINT *pnTipCurMenuID)
{
    int nCntEventSink;
    int i;
    BOOL bRet = FALSE;

    //
    // Insert Custom item to menu
    //
    ClearMenuMap();

    nCntEventSink = _rgEventSinks.Count();
    for (i = 0; i < nCntEventSink; i++)
    {
         CCicLibMenu *pMenuTmp;
         GENERICSINK *pSink;
         ITfSystemLangBarItemSink *plbSink;

         if (i >= IDM_CUSTOM_MENU_START - IDM_ASM_MENU_START)
         {
             Assert(0);
             break;
         }
         
         if (!_pMenuMap)
             _pMenuMap = new CStructArray<TIPMENUITEMMAP>;

         if (!_pMenuMap)
         {
             Assert(0);
             goto Exit;
         }


         pMenuTmp = new CCicLibMenu;
         if (!pMenuTmp)
         {
             goto Exit;
         }

         pSink = _rgEventSinks.GetPtr(i);

         if (SUCCEEDED(pSink->pSink->QueryInterface(
                                      IID_ITfSystemLangBarItemSink,
                                      (void **)&plbSink)))
         {
             if (SUCCEEDED(plbSink->InitMenu(pMenuTmp)))
             {
                 if (*pnTipCurMenuID > IDM_CUSTOM_MENU_START)
                     LangBarInsertSeparator(pMenu);

                 *pnTipCurMenuID = _MergeMenu(pMenu, 
                                            pMenuTmp, 
                                            plbSink, 
                                            _pMenuMap, 
                                            *pnTipCurMenuID);
             }
             plbSink->Release();
         }
         else
         {
             Assert(0);
         }

         pMenuTmp->Release();
    }

    bRet = TRUE;
Exit:
    return bRet;
}

//+---------------------------------------------------------------------------
//
// _MergeMenu
//
//----------------------------------------------------------------------------
#define MIIM_ALL  ( MIIM_STATE | MIIM_ID | MIIM_SUBMENU | MIIM_CHECKMARKS | MIIM_STRING | MIIM_BITMAP | MIIM_FTYPE )

UINT CLBarItemSystemButtonBase::_MergeMenu(ITfMenu *pMenu, 
                                     CCicLibMenu *pMenuTip, 
                                     ITfSystemLangBarItemSink *plbSink, 
                                     CStructArray<TIPMENUITEMMAP> *pMenuMap, 
                                     UINT &nCurID)
{
    int i;
    int nMenuCnt = pMenuTip->GetItemCount();
    HRESULT hr;

    if (nMenuCnt <= 0)
        return nCurID;

    for (i = 0; i < nMenuCnt; i++)
    {
        CCicLibMenuItem *pItem = pMenuTip->GetItem(i);
        if (!pItem)
            continue;

        TIPMENUITEMMAP *ptmm;
        ptmm = pMenuMap->Append(1);
        if (!ptmm)
            continue;

        ptmm->plbSink = plbSink;
        ptmm->nOrgID = pItem->GetId();
        ptmm->nTmpID = nCurID++;

        hr = E_FAIL;

        if (pItem->GetSubMenu())
        {
            ITfMenu *pSubMenu = NULL;
            hr = pMenu->AddMenuItem((UINT)-1,
                                    pItem->GetFlags(),
                                    pItem->GetBitmap(),
                                    pItem->GetBitmapMask(),
                                    pItem->GetText(),
                                    wcslen(pItem->GetText()),
                                    &pSubMenu);

            if (SUCCEEDED(hr))
            {
                _MergeMenu(pSubMenu, 
                           pItem->GetSubMenu(), 
                           plbSink, 
                           pMenuMap, 
                           nCurID);

                pSubMenu->Release();
            }
        }
        else
        {
            hr = pMenu->AddMenuItem(ptmm->nTmpID,
                                    pItem->GetFlags(),
                                    pItem->GetBitmap(),
                                    pItem->GetBitmapMask(),
                                    pItem->GetText(),
                                    wcslen(pItem->GetText()),
                                    NULL);
        }

        if (SUCCEEDED(hr))
            pItem->ClearBitmaps();
    }

    return nCurID;
}

//////////////////////////////////////////////////////////////////////////////
//
// CLBarItemDeviceType
//
//////////////////////////////////////////////////////////////////////////////

//+---------------------------------------------------------------------------
//
// ctor
//
//----------------------------------------------------------------------------

CLBarItemDeviceType::CLBarItemDeviceType(SYSTHREAD *psfn, REFGUID rguid) : CLBarItemSystemButtonBase(psfn)
{
    Dbg_MemSetThisNameID(TEXT("CLBarItemDeviceType"));
    DWORD dwNuiStyle = TF_LBI_STYLE_BTN_MENU | 
                       TF_LBI_STYLE_HIDDENSTATUSCONTROL;



    _guid = rguid;
    _nType = -1;
    _fHideOrder = FALSE;

    if (IsEqualGUID(_guid, GUID_TFCAT_TIP_KEYBOARD))
    {
        _nType = ID_TYPE_KEYBOARD;
        dwNuiStyle |= TF_LBI_STYLE_SHOWNINTRAY;
        _dwIconMode = TF_DTLBI_USEPROFILEICON;
    }
    else if (IsEqualGUID(_guid, GUID_TFCAT_TIP_HANDWRITING))
    {
        _nType = ID_TYPE_HANDWRITING;
    }
    else if (IsEqualGUID(_guid, GUID_TFCAT_TIP_SPEECH))
    {
        _nType = ID_TYPE_SPEECH;
    }

    if (_nType != -1)
    {
        InitNuiInfo(CLSID_SYSTEMLANGBARITEM, 
                    rguid, 
                    dwNuiStyle, 
                    0,
                    CRStr(IDS_NUI_DEVICE_NAME_START + _nType));
    }
    else
    {
        BSTR bstr = NULL;
        MyGetGUIDDescription(rguid, &bstr);
        InitNuiInfo(CLSID_SYSTEMLANGBARITEM, 
                    rguid, 
                    dwNuiStyle, 
                    0,
                    bstr ? bstr : L"");
        if (bstr)
           SysFreeString(bstr);
    }

    _pif = NULL;

}

//----------------------------------------------------------------------------
//
// dtor
//
//----------------------------------------------------------------------------

CLBarItemDeviceType::~CLBarItemDeviceType()
{
    if (_pif)
       delete _pif;

    if (_pces)
    {
       _pces->_Unadvise();
       _pces->Release();
    }
}

//+---------------------------------------------------------------------------
//
// Init
//
//----------------------------------------------------------------------------

static const TCHAR c_szNuiDeviceTypeWndClass[] = "NuiDeviceTypeDummyWndClass";
void CLBarItemDeviceType::Init()
{

    if (_nType != -1)
    {
        SetText(CRStr(IDS_NUI_DEVICE_NAME_START + _nType));
        SetToolTip(CRStr(IDS_NUI_DEVICE_TIP_START + _nType));
    }
    else
    {
        SetText(_lbiInfo.szDescription);
        SetToolTip(_lbiInfo.szDescription);
    }


    ShowOrHide(FALSE);
}

//+---------------------------------------------------------------------------
//
// Uninit
//
//----------------------------------------------------------------------------

void CLBarItemDeviceType::Uninit()
{
    if (_pces)
    {
       _pces->_Unadvise();
       SafeReleaseClear(_pces);
    }
}

//+---------------------------------------------------------------------------
//
// InitTipArray
//
//----------------------------------------------------------------------------

void CLBarItemDeviceType::InitTipArray(BOOL fInitIconIndex)
{
    CAssembly *pAsm;
    int i;
    int nCnt;
    LANGID langid = 0;

    _rgGuidatomHkl.Clear();

    pAsm = GetCurrentAssembly();
    if (!pAsm)
        goto Exit;

    if (_psfn->plbim && _psfn->plbim->_GetLBarItemCtrl())
        langid = GetCurrentAssemblyLangId(_psfn);

    nCnt = pAsm->Count();

    if (_psfn->ptim && _psfn->ptim->_GetFocusDocInputMgr())
        pAsm->RebuildSubstitutedHKLList();
    else
        pAsm->ClearSubstitutedHKLList();

    for (i = 0; i < nCnt; i++)
    {
        ASSEMBLYITEM *pItem = pAsm->GetItem(i);

        if (!pItem->fEnabled)
            continue;

        if (IsEqualGUID(pItem->catid, _guid))
        {
            GUIDATOMHKL gahkl;
            BOOL fInsert = FALSE;

            if (!IsEqualGUID(pItem->clsid, GUID_NULL))
            {
                if (_psfn->ptim && _psfn->ptim->_GetFocusDocInputMgr())
                {
                    TfGuidAtom guidatom;
                    MyRegisterGUID(pItem->clsid, &guidatom);
                    gahkl.guidatom = guidatom;
                    gahkl.hkl = pItem->hkl;
                    gahkl.pItem = pItem;
                    fInsert = TRUE;
                }
            }
            else 
            {
                Assert(pItem->hkl);
                BOOL bSkip = FALSE;

                if (pAsm->IsSubstitutedHKL(pItem->hkl) ||
                    ((!_psfn->ptim || !_psfn->ptim->_GetFocusDocInputMgr()) &&
                      CAssemblyList::IsFEDummyKL(pItem->hkl)))
                {
                    bSkip = TRUE;
                }

                if (!bSkip) 
                {
                    gahkl.guidatom = TF_INVALID_GUIDATOM;
                    gahkl.hkl = pItem->hkl;
                    gahkl.pItem = pItem;
                    fInsert = TRUE;
                }
            }

            if (fInsert)
            {
                GUIDATOMHKL *pgahkl;
                int nCurId;
                int nMaxId = _rgGuidatomHkl.Count();

                for (nCurId = 0; nCurId < nMaxId; nCurId++)
                {
                    GUIDATOMHKL *pgahklCur;
                    int nCmp;
                    pgahklCur = _rgGuidatomHkl.GetPtr(nCurId);

                    if (!pgahklCur)
                        continue;

                    nCmp = CompareGUIDs(pgahklCur->pItem->clsid, 
                                        gahkl.pItem->clsid);
                    if (nCmp > 0)
                        break;

                    if (nCmp < 0)
                        continue;

                    if (CompareGUIDs(pgahklCur->pItem->guidProfile, 
                                     gahkl.pItem->guidProfile) > 0)
                        break;
                }

                if (_rgGuidatomHkl.Insert(nCurId, 1) &&
                    (pgahkl = _rgGuidatomHkl.GetPtr(nCurId)))
                {
                    gahkl.uIconIndex = fInitIconIndex ? GetIconIndex(langid, pItem) : (ULONG)-1;
                    *pgahkl = gahkl;
                }
            }
        }
    }

Exit:
    return;
}

//+---------------------------------------------------------------------------
//
// ShowOrHide
//
//----------------------------------------------------------------------------

void CLBarItemDeviceType::ShowOrHide(BOOL fNotify)
{
    BOOL bShow = TRUE;
    int nCnt;

    //
    // if _fHideOrder is TRUE, someone asked not to show this category icon.
    // we do nothing.
    //
    if (_fHideOrder)
    {
        Assert(_dwStatus & TF_LBI_STATUS_HIDDEN);
        return;
    }

    InitTipArray(FALSE);
    nCnt = _rgGuidatomHkl.Count();

    if (_nType != ID_TYPE_KEYBOARD)
    {
        CAssembly *pAsm = GetCurrentAssembly();

        if (pAsm && pAsm->IsFEIMEActive())
        {
            ShowInternal(FALSE, fNotify);
            return;
        }
    }

    if (!nCnt)
    {
        bShow = FALSE;
    }
    else if (nCnt == 1) 
    {
        if (_nType == ID_TYPE_KEYBOARD)
        {
            GUIDATOMHKL *pgahkl;
            pgahkl = _rgGuidatomHkl.GetPtr(0);
            bShow = pgahkl->guidatom ? TRUE : FALSE;
        }
        else
        {
            bShow = FALSE;
        }
    }

    ShowInternal(bShow, fNotify);
}

//+---------------------------------------------------------------------------
//
// Show
//
//----------------------------------------------------------------------------

STDAPI CLBarItemDeviceType::Show(BOOL fShow)
{
    _fHideOrder = fShow ? FALSE : TRUE;
    return CLBarItemSystemButtonBase::Show(fShow);
}

//+---------------------------------------------------------------------------
//
// InitMenu
//
//----------------------------------------------------------------------------

#if IDM_CUSTOM_MENU_START <= IDM_ASM_MENU_START
#erroe IDM_CUSTOM_MENU_START is smaller than IDM_ASM_MENU_START
#endif
#if IDM_ASM_MENU_START <= IDM_LANG_MENU_START
#erroe IDM_ASM_MENU_START is smaller than IDM_LANG_MENU_START
#endif

STDAPI CLBarItemDeviceType::InitMenu(ITfMenu *pMenu)
{
    CThreadInputMgr *ptim = NULL;
    CDocumentInputManager *pdim = NULL;
    CInputContext *pic;
    int nCntGuidatomHkl;
    int i;
    CLSID clsid;
    UINT nTipCurMenuID = IDM_CUSTOM_MENU_START;
    LANGID langid = 0;
    BOOL bMenuChecked = FALSE;
    GUIDATOMHKL *pgahkl;
    BOOL fTransitory = FALSE;

    ptim = _psfn->ptim;

    InitTipArray(TRUE);
    nCntGuidatomHkl = _rgGuidatomHkl.Count();
    if (!ptim)
        goto SetHKLMenu;

    if (!(pdim = ptim->_GetFocusDocInputMgr()))
        goto SetHKLMenu;

    pic = pdim->_GetTopIC();
    if (pic)
    {
        TF_STATUS dcs;
        if (SUCCEEDED(pic->GetStatus(&dcs)) &&
            (dcs.dwStaticFlags & TF_SS_TRANSITORY))
            fTransitory = TRUE;
    }


    if (!_InsertCustomMenus(pMenu, &nTipCurMenuID))
        goto Exit;

    //
    // Insert separator.
    //
    if (nCntGuidatomHkl && (nTipCurMenuID > IDM_CUSTOM_MENU_START))
        LangBarInsertSeparator(pMenu);

    if (_psfn->plbim && _psfn->plbim->_GetLBarItemCtrl())
        langid = GetCurrentAssemblyLangId(_psfn);

    //
    // Insert TIPs to menu
    //
    for (i = 0; i < nCntGuidatomHkl; i++)
    {
        BOOL bCheckThis;

        pgahkl = _rgGuidatomHkl.GetPtr(i);
        

        if (i >= IDM_CUSTOM_MENU_START - IDM_ASM_MENU_START)
        {
            Assert(0);
            break;
        }

        if (!pgahkl->guidatom)
            continue;

        MyGetGUID(pgahkl->guidatom, &clsid);
        if (!CAssemblyList::CheckLangSupport(clsid, langid))
            continue;

        bCheckThis = (pgahkl->pItem->fActive) ? TRUE : FALSE;

        if (fTransitory && pgahkl->pItem->fDisabledOnTransitory)
            LangBarInsertGrayedMenu(pMenu, 
                                    pgahkl->pItem->szProfile,
                                    TF_InatExtractIcon(pgahkl->uIconIndex));
        else
            LangBarInsertMenu(pMenu, 
                              IDM_ASM_MENU_START + i,
                              pgahkl->pItem->szProfile,
                              bCheckThis,
                              TF_InatExtractIcon(pgahkl->uIconIndex));

        if (bCheckThis)
        {
             bMenuChecked = TRUE;
        }
    }

SetHKLMenu:
    //
    // Insert HKLs to menu
    //
    for (i = 0; i < nCntGuidatomHkl; i++)
    {
        BOOL bCheckIt = FALSE;
        pgahkl = _rgGuidatomHkl.GetPtr(i);

        if (i >= IDM_CUSTOM_MENU_START - IDM_ASM_MENU_START)
        {
            Assert(0);
            break;
        }

        if (pgahkl->guidatom)
            continue;

        if (!bMenuChecked  && pgahkl->hkl == GetKeyboardLayout(0))
        {
            if (pdim)
                bCheckIt = (pgahkl->pItem->fActive) ? TRUE : FALSE;
            else
                bCheckIt = TRUE;
        }
        
        LangBarInsertMenu(pMenu, 
                          IDM_LANG_MENU_START + i,
                          pgahkl->pItem->szProfile,
                          bCheckIt,
                          IsPureIMEHKL(pgahkl->hkl) ? TF_InatExtractIcon(pgahkl->uIconIndex) : NULL);
        if (bCheckIt)
        {
            bMenuChecked = TRUE;
        }
    }


    //
    // If the lbiCtrl is hidden (there is only one language available) and
    // the floating toolbar is minimized, the keyboard langbar item
    // has a "Show Langbar" menu item.
    //
    if ((_nType == ID_TYPE_KEYBOARD) && _psfn->plbim)
    {
        CLBarItemCtrl *plbiCtrl = _psfn->plbim->_GetLBarItemCtrl();
        if (plbiCtrl)
        {
            DWORD dwFlags;
            DWORD dwStatus;
            dwStatus = plbiCtrl->GetStatusInternal();
            if ((dwStatus & TF_LBI_STATUS_HIDDEN) &&
                SUCCEEDED(CLangBarMgr::s_GetShowFloatingStatus(&dwFlags)) &&
                (dwFlags & (TF_SFT_MINIMIZED | TF_SFT_DESKBAND)))
            {
                LangBarInsertSeparator(pMenu);
                LangBarInsertMenu(pMenu, 
                                  IDM_SHOWLANGBAR, 
                                  CRStr(IDS_SHOWLANGBAR));
            }
        }
    }

Exit:
    return S_OK;
}


//+---------------------------------------------------------------------------
//
// OnMenuSelect
//
//----------------------------------------------------------------------------

STDAPI CLBarItemDeviceType::OnMenuSelect(UINT uID)
{
    CThreadInputMgr *ptim;
    int i;
    GUIDATOMHKL *pgahkl;

    ptim = _psfn->ptim;

    if (uID == IDM_SHOWLANGBAR)
    {
        CLangBarMgr::s_ShowFloating(TF_SFT_SHOWNORMAL);
    }
    else if (uID >= IDM_CUSTOM_MENU_START)
    {
        Assert(ptim);
        int nMenuMapoCnt = _pMenuMap->Count();
        for (i = 0; i < nMenuMapoCnt; i++)
        {
            TIPMENUITEMMAP *ptmm;
            ptmm = _pMenuMap->GetPtr(i);
            if (ptmm->nTmpID == (UINT)uID)
            {
                ptmm->plbSink->OnMenuSelect(ptmm->nOrgID);
                break;
            }
        }
    }
    else if (uID >= IDM_ASM_MENU_START)
    {
        Assert(ptim);
        pgahkl = _rgGuidatomHkl.GetPtr(uID - IDM_ASM_MENU_START);
        Assert(pgahkl);
        Assert(pgahkl->guidatom);

        ASSEMBLYITEM *pItem = pgahkl->pItem;

        if (!pgahkl->pItem->fActive)
        {
             LANGID langid = GetCurrentAssemblyLangId(_psfn);
             ActivateAssemblyItem(_psfn, 
                                  langid,
                                  pItem,  
                                  AAIF_CHANGEDEFAULT);

             CAssemblyList *pAsmList = EnsureAssemblyList(_psfn);
             if (pAsmList)
             {
                 CAssembly *pAsm = pAsmList->FindAssemblyByLangId(langid);
                 if (pAsm)
                 {
                     pAsmList->SetDefaultTIPInAssemblyInternal(pAsm, 
                                                               pItem,
                                                               TRUE);
                 }
             }
        }

// #ifdef HANDWRITINGAUTOSHOW
        if (_nType == ID_TYPE_HANDWRITING)
        {
            MySetCompartmentDWORD(g_gaSystem,
                                  ptim,
                                  GUID_COMPARTMENT_HANDWRITING_OPENCLOSE,
                                  TRUE);

        }
// #endif

    }
    else if (uID >= IDM_LANG_MENU_START)
    {
        pgahkl = _rgGuidatomHkl.GetPtr(uID - IDM_LANG_MENU_START);
        Assert(pgahkl);
        Assert(pgahkl->hkl);
        ActivateAssemblyItem(_psfn, 
                             GetCurrentAssemblyLangId(_psfn), 
                             pgahkl->pItem,
                             AAIF_CHANGEDEFAULT);
    }

    ClearMenuMap();
    return S_OK;
}
 

//----------------------------------------------------------------------------
//
// CompEventSinkCallback (static)
//
//----------------------------------------------------------------------------

HRESULT CLBarItemDeviceType::CompEventSinkCallback(void *pv, REFGUID rguid)
{
    CLBarItemDeviceType *_this = (CLBarItemDeviceType *)pv;

    if (IsEqualGUID(rguid, GUID_COMPARTMENT_SPEECH_OPENCLOSE))
    {
        _this->SetSpeechButtonState(_this->_psfn->ptim);
    }
    return S_FALSE;
}

//----------------------------------------------------------------------------
//
// SetSpeechButtonState
//
//----------------------------------------------------------------------------

HRESULT CLBarItemDeviceType::SetSpeechButtonState(CThreadInputMgr *ptim)
{
    DWORD dw = 0;
    MyGetCompartmentDWORD(ptim->GetGlobalComp(), GUID_COMPARTMENT_SPEECH_OPENCLOSE, &dw);

    SetOrClearStatus(TF_LBI_STATUS_BTN_TOGGLED, dw);
    if (_plbiSink)
        _plbiSink->OnUpdate(TF_LBI_STATUS);
    return S_OK;
}

//----------------------------------------------------------------------------
//
// SetIcon
//
//----------------------------------------------------------------------------

STDAPI CLBarItemDeviceType::SetIcon(HICON hIcon)
{
    CLBarItemButtonBase::SetIcon(hIcon);
    return S_OK;
}

//----------------------------------------------------------------------------
//
// GetIcon
//
//----------------------------------------------------------------------------

STDAPI CLBarItemDeviceType::GetIcon(HICON *phIcon)
{
    if (CLBarItemButtonBase::GetIcon())
    {
        return CLBarItemButtonBase::GetIcon(phIcon); 
    }

    HICON hIcon = NULL;

    if (_nType != -1)
    {
        hIcon = LoadSmIcon(g_hInst, MAKEINTRESOURCE(ID_ICON_DEVICE_START + _nType));
    }
    else
    {
       int cx, cy;
       InatGetIconSize(&cx, &cy);

       if (!_pif)
       {
           BSTR bstr;
           HRESULT hr;
           ICONFILE *pif;

           pif = new ICONFILE;
           if (!pif)
               goto Exit;

           if (FAILED(hr = MyGetGUIDValue(_guid, c_szIconIndexW, &bstr)))
           {
               delete pif;
               goto Exit;
           }

           pif->uIconIndex = WToNum(bstr);
           SysFreeString(bstr);

           if (FAILED(hr = MyGetGUIDValue(_guid, c_szIconFileW, &bstr)))
           {
               delete pif;
               goto Exit;
           }

           wcsncpy(pif->szFile, bstr, ARRAYSIZE(pif->szFile));

           SysFreeString(bstr);

           _pif = pif;
       }

       hIcon = GetIconFromFile(cx, cy, _pif->szFile, _pif->uIconIndex);
    }

Exit:
    *phIcon = hIcon;
    return S_OK;
}

//----------------------------------------------------------------------------
//
// SetTooltipString
//
//----------------------------------------------------------------------------

STDAPI CLBarItemDeviceType::SetTooltipString(WCHAR *pchToolTip, ULONG cch)
{
    if (!pchToolTip)
    {
        SetToolTip(CRStr(IDS_NUI_DEVICE_TIP_START + _nType));
    }
    else
        SetToolTip(pchToolTip, cch);

    return S_OK;
}

//+---------------------------------------------------------------------------
//
// UpdateLangIcon
//
//----------------------------------------------------------------------------

void CLBarItemDeviceType::SetBrandingIcon(HKL hKL, BOOL fNotify)
{
    CThreadInputMgr *ptim;
    HICON hIcon;
    ULONG uIconIndex = -1;
    ASSEMBLYITEM *pItem = NULL;
    CAssembly *pAsm;
    WCHAR szDesc[128];

    if (!hKL)
        hKL = GetKeyboardLayout(0);

    if (!(_dwIconMode & TF_DTLBI_USEPROFILEICON))
        return;

    ptim = CThreadInputMgr::_GetThisFromSYSTHREAD(_psfn);

    pAsm = GetCurrentAssembly(_psfn);
    if (!pAsm)
        return;

#ifdef USE_ASM_ISFEIMEACTIVE
    BOOL fIsPureIME = FALSE;

    if (_nType == ID_TYPE_KEYBOARD)
    {
        if (ptim && ptim->_GetFocusDocInputMgr()) 
        {
            fIsPureIME = pAsm->IsFEIMEActive();
        }
        else
        {
            fIsPureIME = IsPureIMEHKL(hKL);
        }
    }
#endif USE_ASM_ISFEIMEACTIVE

    hIcon = NULL;

    szDesc[0] = L'\0';

#ifdef USE_ASM_ISFEIMEACTIVE
    if (fIsPureIMEHKL)
#else
    if (IsPureIMEHKL(hKL))
#endif USE_ASM_ISFEIMEACTIVE
    {
        pItem = pAsm->FindKeyboardLayoutItem(hKL);

        uIconIndex = GetIconIndexFromhKL(hKL);
        if (uIconIndex != -1)
            hIcon = TF_InatExtractIcon(uIconIndex);
    }
    else if (ptim && ptim->_GetFocusDocInputMgr())
    {
        pItem = pAsm->FindActiveKeyboardItem();

        //
        // if it is Cicero item, we will show the branding Icon.
        //
        if (pItem && !IsEqualGUID(pItem->clsid, GUID_NULL))
        {
            uIconIndex = GetIconIndex(LOWORD(HandleToLong(hKL)), pItem);
            if (uIconIndex != -1)
                hIcon = TF_InatExtractIcon(uIconIndex);
        }
    }
    else
    {
        MLNGINFO mlInfo;
        if (GetMlngInfoByhKL(hKL, &mlInfo) != -1)
        { 
            wcsncpy(szDesc, mlInfo.GetDesc(), ARRAYSIZE(szDesc));
        }
    }


    HICON hIconOld = GetIcon();
    SetIcon(hIcon);
    if (hIconOld)
        DestroyIcon(hIconOld);

    if (pItem)
    {
        SetText(pItem->szProfile);
        SetToolTip(pItem->szProfile);
    }
    else if (szDesc[0])
    {
        SetText(szDesc);
        SetToolTip(szDesc);
    }
    else if (_nType != -1)
    {
        SetText(CRStr(IDS_NUI_DEVICE_NAME_START + _nType));
        SetToolTip(CRStr(IDS_NUI_DEVICE_TIP_START + _nType));
    }

    if (fNotify && _plbiSink)
        _plbiSink->OnUpdate(TF_LBI_ICON | TF_LBI_TEXT | TF_LBI_TOOLTIP);
}

//+---------------------------------------------------------------------------
//
// SetDefaultIcon
//
//----------------------------------------------------------------------------

void CLBarItemDeviceType::SetDefaultIcon(BOOL fNotify)
{
    HICON hIconOld = GetIcon();
    SetIcon(NULL);
    if (hIconOld)
        DestroyIcon(hIconOld);

    if (_nType != -1)
    {
        SetToolTip(CRStr(IDS_NUI_DEVICE_NAME_START + _nType));
        SetText(_szToolTip);
    }

    if (fNotify && _plbiSink)
        _plbiSink->OnUpdate(TF_LBI_ICON | TF_LBI_TEXT | TF_LBI_TOOLTIP);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\ctf\uim\nuihkl.h ===
//
// nuihkl.h
//

#ifndef NUIHKL_H
#define NUIHKL_H

#include "private.h"
#include "strary.h"
#include "commctrl.h"
#include "internat.h"
#include "nuibase.h"
#include "sink.h"
#include "assembly.h"
#include "lbmenu.h"
#include "systhrd.h"

ULONG GetIconIndexFromhKL(HKL hKL);
ULONG GetIconIndex(LANGID langid, ASSEMBLYITEM *pItem);
HRESULT AsyncReconversion();

extern const TCHAR c_szNuiWin32IMEWndClass[];
class CCompartmentEventSink;


typedef struct tag_TIPMENUITEMMAP {
    ITfSystemLangBarItemSink *plbSink;
    UINT nOrgID;
    UINT nTmpID;
} TIPMENUITEMMAP;

typedef struct tag_GUIDATOMHKL {
    TfGuidAtom guidatom;
    HKL        hkl;
    ULONG      uIconIndex;
    ASSEMBLYITEM *pItem;
} GUIDATOMHKL;

//////////////////////////////////////////////////////////////////////////////
//
// CLBarItemWin32IME
//
//////////////////////////////////////////////////////////////////////////////

class CLBarItemWin32IME : public CLBarItemButtonBase
{
public:
    CLBarItemWin32IME();
    ~CLBarItemWin32IME() {}

    STDMETHODIMP GetIcon(HICON *phIcon);

    HRESULT OnLButtonUp(const POINT pt, const RECT *prcArea);
    HRESULT OnRButtonUp(const POINT pt, const RECT *prcArea);

    void UpdateIMEIcon();

private:
    void ShowIMELeftMenu(HWND hWnd, LONG xPos, LONG yPos);
    void ShowIMERightMenu(HWND hWnd, LONG xPos, LONG yPos);

    static LRESULT CALLBACK _WndProc(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam);

    HWND CreateMyWnd()
    {
         return CreateWindow(c_szNuiWin32IMEWndClass,
                                     "",
                                     WS_POPUP | WS_DISABLED,
                                     0,0,0,0,
                                     NULL, 0, g_hInst, this);
    }

    static void SetThis(HWND hWnd, LPARAM lParam)
    {
        SetWindowLongPtr(hWnd, GWLP_USERDATA,
                      (LONG_PTR)((CREATESTRUCT *)lParam)->lpCreateParams);
    }

    static CLBarItemWin32IME *GetThis(HWND hWnd)
    {
        CLBarItemWin32IME *p = (CLBarItemWin32IME *)GetWindowLongPtr(hWnd, GWLP_USERDATA);
        Assert(p != NULL);
        return p;
    }

    int _nIconId;
    DBG_ID_DECLARE;
};

//////////////////////////////////////////////////////////////////////////////
//
// CLBarItemReconv
//
//////////////////////////////////////////////////////////////////////////////

class CLBarItemReconv : public CLBarItemButtonBase,
                        public CSysThreadRef
{
public:
    CLBarItemReconv(SYSTHREAD *psfn);

    STDMETHODIMP GetIcon(HICON *phIcon);
    void ShowOrHide(BOOL fNotify);

private:
    HRESULT OnLButtonUp(const POINT pt, const RECT *prcArea);

    BOOL _fAddedBefore;

    DBG_ID_DECLARE;
};

//////////////////////////////////////////////////////////////////////////////
//
// CLBarItemDeviceType
//
//////////////////////////////////////////////////////////////////////////////

class __declspec(novtable) CLBarItemSystemButtonBase : public CLBarItemButtonBase,
                                  public ITfSystemLangBarItem,
                                  public ITfSystemDeviceTypeLangBarItem,
                                  public CSysThreadRef
{
public:
    CLBarItemSystemButtonBase(SYSTHREAD *psfn);
    ~CLBarItemSystemButtonBase();

    //
    // IUnknown methods
    //
    STDMETHODIMP QueryInterface(REFIID riid, void **ppvObj);
    STDMETHODIMP_(ULONG) AddRef(void);
    STDMETHODIMP_(ULONG) Release(void);

    //
    // ITfSource
    //
    STDMETHODIMP AdviseSink(REFIID riid, IUnknown *punk, DWORD *pdwCookie);
    STDMETHODIMP UnadviseSink(DWORD dwCookie);

    //
    // ITfLangBarItem
    //
    STDMETHODIMP GetInfo(TF_LANGBARITEMINFO *pInfo);
    STDMETHODIMP Show(BOOL fShow);

    //
    // ITfSystemLangBarItem
    //
    STDMETHODIMP SetIcon(HICON hIcon);
    STDMETHODIMP SetTooltipString(WCHAR *pchToolTip, ULONG cch);

    //
    // ITfSystemDeviceTypeLangBarItem,
    //
    STDMETHODIMP SetIconMode(DWORD dwFlags);
    STDMETHODIMP GetIconMode(DWORD *pdwFlags);

protected:
    BOOL _InsertCustomMenus(ITfMenu *pMenu, UINT *pnTipCurMenuID);
    UINT _MergeMenu(ITfMenu *pMenu, CCicLibMenu *pMenuTip, ITfSystemLangBarItemSink *plbSink, CStructArray<TIPMENUITEMMAP> *pMenuMap, UINT &nCurID);

    CStructArray<TIPMENUITEMMAP> *_pMenuMap;
    void ClearMenuMap()
    {
        if (_pMenuMap)
            _pMenuMap->Clear();
    }

    virtual void SetBrandingIcon(HKL hKL, BOOL fNotify) {return;}
    virtual void SetDefaultIcon(BOOL fNotify) {return;}

    CStructArray<GENERICSINK> _rgEventSinks; // ITfSystemLangBarItemSink

    DWORD _dwIconMode;
};

//////////////////////////////////////////////////////////////////////////////
//
// CLBarItemDeviceType
//
//////////////////////////////////////////////////////////////////////////////

#define ID_TYPE_KEYBOARD    0
#define ID_TYPE_HANDWRITING 1
#define ID_TYPE_SPEECH      2

class CLBarItemDeviceType : public CLBarItemSystemButtonBase
{
public:
    CLBarItemDeviceType(SYSTHREAD *psfn, REFGUID rguid);
    ~CLBarItemDeviceType();

    //
    // IUnknown methods
    //
    // STDMETHODIMP QueryInterface(REFIID riid, void **ppvObj);
    // STDMETHODIMP_(ULONG) AddRef(void);
    // STDMETHODIMP_(ULONG) Release(void);

    //
    // ITfSource
    //
    // STDMETHODIMP AdviseSink(REFIID riid, IUnknown *punk, DWORD *pdwCookie);
    // STDMETHODIMP UnadviseSink(DWORD dwCookie);

    //
    // ITfLangBarItem
    //
    // STDMETHODIMP GetInfo(TF_LANGBARITEMINFO *pInfo);
    STDMETHODIMP Show(BOOL fShow);
    STDMETHODIMP GetIcon(HICON *phIcon);

    //
    // ITfSystemLangBarItem
    //
    STDMETHODIMP SetIcon(HICON hIcon);
    STDMETHODIMP SetTooltipString(WCHAR *pchToolTip, ULONG cch);

    void Init();
    void Uninit();
    void ShowOrHide(BOOL fNotify);
    void InitTipArray(BOOL fInitIconIndex);

    BOOL IsKeyboardType() {return (_nType == ID_TYPE_KEYBOARD) ? TRUE : FALSE;}

    HICON GetIcon()
    {
        return CLBarItemSystemButtonBase::GetIcon();
    }

    void SetBrandingIcon(HKL hKL, BOOL fNotify);
    void SetDefaultIcon(BOOL fNotify);

    GUID *GetDeviceTypeGUID() {return &_guid;}

private:
    BOOL _StringFromMenuId(int nMenuId, BSTR *pbstr);

    STDMETHODIMP InitMenu(ITfMenu *pMenu);
    STDMETHODIMP OnMenuSelect(UINT wID);

    GUID _guid;
    int _nType;

    CStructArray<GUIDATOMHKL> _rgGuidatomHkl;

    CCompartmentEventSink *_pces;

    static HRESULT CompEventSinkCallback(void *pv, REFGUID rguid);
    HRESULT SetSpeechButtonState(CThreadInputMgr *ptim);

    typedef struct tag_ICONFILE {
        int uIconIndex;
        WCHAR szFile[MAX_PATH];
    } ICONFILE;
    ICONFILE *_pif;

    //
    // When someone else calls Show(FALSE), we hide the button forcefully.
    // If this is TRUE, we never clear TF_LBI_STATUS_HIDDEN flag.
    //
    BOOL _fHideOrder;


    DBG_ID_DECLARE;
};

#endif // NUIHKL_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\ctf\uim\normal.h ===
//
// normal.h
//

#ifndef NORMAL_H
#define NORMAL_H

#include "globals.h"

HRESULT PlainTextOffset(ITextStoreACP *ptsi, LONG acpAppBase, LONG lAppOffset, LONG *plPlainOffset);
HRESULT AppTextOffsetForward(ITextStoreACP *ptsi, LONG acpAppBase, LONG lPlainOffset, LONG *plAppOffset, DWORD dwFlags);
HRESULT AppTextOffsetBackward(ITextStoreACP *ptsi, LONG acpAppBase, LONG lPlainOffset, LONG *plAppOffset, DWORD dwFlags);

#define ATO_IGNORE_REGIONS  1
#define ATO_SKIP_HIDDEN     2

inline HRESULT AppTextOffset(ITextStoreACP *ptsi, LONG acpAppBase, LONG lPlainOffset, LONG *plAppOffset, DWORD dwFlags)
{
    *plAppOffset = 0;

    if (lPlainOffset == 0)
        return S_OK;

    return (lPlainOffset >= 0) ? AppTextOffsetForward(ptsi, acpAppBase, lPlainOffset, plAppOffset, dwFlags) :
                                 AppTextOffsetBackward(ptsi, acpAppBase, lPlainOffset, plAppOffset, dwFlags);
}

#define NORM_SKIP_HIDDEN    ATO_SKIP_HIDDEN

inline int Normalize(ITextStoreACP *ptsi, LONG acp, DWORD dwFlags = 0)
{
    LONG iNextPlain;
    HRESULT hr;

    Perf_IncCounter(PERF_NORMALIZE_COUNTER);

    // if we hit eod, AppTextOffset will return S_FALSE
    // and iNextPlain will be the offset to eod
    if (FAILED(hr = AppTextOffset(ptsi, acp, 1, &iNextPlain, dwFlags)))
    {
        Assert(0);
        return acp;
    }

    if (hr == S_OK)
    {
        // need to back up behind the plain text char
        iNextPlain--;
    }

    return (acp + iNextPlain);
}

// Returns a normalized acp offset that spans the specificed number of plain chars --
// so the return offset is just short of (lPlainOffset + 1), or at eod.  Returns
// S_FALSE if the initial call to AppTextOffset gets clipped because of eod.
#ifdef UNUSED
HRESULT AppTextOffsetNorm(ITextStoreACP *ptsi, LONG acpAppBase, LONG lPlainOffset, LONG *plAppOffset);
#endif // UNUSED

#endif // NORMAL_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\ctf\uim\nuictrl.h ===
//
// nuihkl.h
//

#ifndef NUICTRLL_H
#define NUICTRLL_H

#include "private.h"
#include "strary.h"
#include "commctrl.h"
#include "internat.h"
#include "nuihkl.h"
#include "assembly.h"
#include "systhrd.h"

extern HRESULT WINAPI TF_RunInputCPL();

//////////////////////////////////////////////////////////////////////////////
//
// CLBarItemCtrl
//
//////////////////////////////////////////////////////////////////////////////

class CLBarItemCtrl : public CLBarItemButtonBase,
                      public CSysThreadRef
{
public:
    CLBarItemCtrl(SYSTHREAD *psfn);
    ~CLBarItemCtrl();

    STDMETHODIMP InitMenu(ITfMenu *pMenu);
    STDMETHODIMP OnMenuSelect(UINT wID);
    void OnShellLanguage(HKL hKL);

    void _UpdateLangIcon(HKL hKL, BOOL fNotify);
    void _UpdateLangIconForCic(BOOL fNotify);
    void _AsmListUpdated(BOOL fNotify);
    void OnSysColorChanged();

private:
    void _Init();

    void _ShowLanguageMenu(HWND hwnd, LONG xPos, LONG yPos, RECT *prcArea);
    BOOL _HandleLangMenuMeasure(HWND hwnd, LPMEASUREITEMSTRUCT lpmi);
    BOOL _HandleLangMenuDraw(HWND hwnd, LPDRAWITEMSTRUCT lpdi);
    void _ShowAssemblyMenu(HWND hwnd, const LONG xPos, const LONG yPos, const RECT *prcArea);

    int _meEto;
    LANGID _langidForIcon;
    DBG_ID_DECLARE;
};

//////////////////////////////////////////////////////////////////////////////
//
// CLBarItemHelp
//
//////////////////////////////////////////////////////////////////////////////

class CLBarItemHelp : public CLBarItemSystemButtonBase
{
public:
    CLBarItemHelp(SYSTHREAD *psfn);
    ~CLBarItemHelp() {}

    STDMETHODIMP GetIcon(HICON *phIcon);
    STDMETHODIMP InitMenu(ITfMenu *pMenu);
    STDMETHODIMP OnMenuSelect(UINT wID);

private:
    BOOL InvokeCicHelp();

    DBG_ID_DECLARE;
};

#endif // NUICTRLL_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\ctf\uim\nuimgr.h ===
//
// nuimgr.h
//

#ifndef NUIMGR_H
#define NUIMGR_H

#include "private.h"
#include "ptrary.h"
#include "helpers.h"
#include "systhrd.h"

class CThreadInputMgr;
class CLBarItemSinkProxy;
class CLangBarItemMgr;

//////////////////////////////////////////////////////////////////////////////
//
// CLBarItemSink
//
//////////////////////////////////////////////////////////////////////////////

class CLBarItemSink
{
public:
    CLBarItemSink()
    {
#ifdef DEBUG
        _fUnadvised = FALSE;
#endif
    }

    ~CLBarItemSink()
    {
        SafeRelease(_pItemSink);
    }

    BOOL Init(ITfLangBarItemSink *pItemSink, 
              TF_LANGBARITEMINFO *pinfo,
              DWORD dwCookie)
    {
        _pItemSink = pItemSink;
        _pItemSink->AddRef();
        _dwCookie = dwCookie;
        _info = *pinfo;
        return TRUE;
    }


    ITfLangBarItemSink *_pItemSink;
    TF_LANGBARITEMINFO _info;
    DWORD _dwCookie;

    DWORD _dwDirtyUpdateFlags;

#ifdef DEBUG
    BOOL _fUnadvised;
#endif

    DBG_ID_DECLARE;
};

//////////////////////////////////////////////////////////////////////////////
//
// CLangBarItemMgr
//
//////////////////////////////////////////////////////////////////////////////

class CLangBarItemMgr : public ITfLangBarItemMgr,
                        public CSysThreadRef
{
public:
    CLangBarItemMgr(SYSTHREAD *psfn);
    ~CLangBarItemMgr();

    // IUnknown methods
    STDMETHODIMP QueryInterface(REFIID riid, void **ppvObj);
    STDMETHODIMP_(ULONG) AddRef(void);
    STDMETHODIMP_(ULONG) Release(void);

    static HRESULT CreateInstance(IUnknown *pUnkOuter, REFIID riid, void **ppvObj);

    BOOL _Init();

    //
    // ITfLangBarItemMgr
    //
    STDMETHODIMP EnumItems(IEnumTfLangBarItems **ppEnum);
    STDMETHODIMP GetItem(REFGUID rguid, ITfLangBarItem **ppItem);
    STDMETHODIMP AddItem(ITfLangBarItem *punk);
    STDMETHODIMP RemoveItem(ITfLangBarItem *punk);
    STDMETHODIMP AdviseItemSink(ITfLangBarItemSink *punk, DWORD *pdwCookie, REFGUID rguidItem);
    STDMETHODIMP UnadviseItemSink(DWORD dwCookie);
    STDMETHODIMP GetItemFloatingRect(DWORD dwThreadId, REFGUID rguid, RECT *prc);
    STDMETHODIMP GetItemsStatus(ULONG ulCount, const GUID *prgguid, DWORD *pdwStatus);
    STDMETHODIMP GetItemNum(ULONG *pulCount);
    STDMETHODIMP GetItems(ULONG ulCount,  ITfLangBarItem **ppItem,  TF_LANGBARITEMINFO *pInfo, DWORD *pdwStatus, ULONG *pcFetched);
    STDMETHODIMP AdviseItemsSink(ULONG ulCount, ITfLangBarItemSink **ppunk,  const GUID *pguidItem, DWORD *pdwCookie);
    STDMETHODIMP UnadviseItemsSink(ULONG ulCount, DWORD *pdwCookie);

    HRESULT RemoveItem(REFGUID rguid);
    HRESULT OnUpdate(ITfLangBarItem *plbi, DWORD dwFlags);
    BOOL IsInOnUpdateHandler() {return _fInOnUpdateHandler ? TRUE : FALSE;}

    HRESULT OnUpdateHandler();

    CLBarItemDeviceType *FindDeviceTypeItem(REFGUID guid);
    void CleanUp();

    CPtrArray<CLBarItemSinkProxy> _rglbiProxy;

    static CLangBarItemMgr *_GetThis() 
    { 
        SYSTHREAD *psfn = GetSYSTHREAD();
        if (!psfn)
            return NULL;

        return psfn->plbim;
    }

    BOOL _SetThis(CLangBarItemMgr *_this)
    { 
        if (!_psfn)
            return FALSE;

        _psfn->plbim = _this;

        return TRUE;
    }

    void EnterAssemblyChange()
    {
        _ulInAssemblyChange++;
        _fItemChanged = FALSE;
    }

    BOOL LeaveAssemblyChange()
    {
        Assert(_ulInAssemblyChange);
        _ulInAssemblyChange--;

        return (_fItemChanged && (_ulInAssemblyChange == 0)) ? TRUE : FALSE;
    }

    BOOL InAssemblyChange()
    {
        return _ulInAssemblyChange ? TRUE : FALSE;
    }
   
    void SetItemChange()
    {
        _fItemChanged = TRUE;
    }

    void StopHandlingOnUpdate() {_fHandleOnUpdate = FALSE;}
    void StartHandlingOnUpdate() {_fHandleOnUpdate = TRUE;}
    
    CLBarItemCtrl *_GetLBarItemCtrl() { return _plbiCtrl; }
    CLBarItemReconv *_GetLBarItemReconv() { return _plbiReconv; }
    CLBarItemWin32IME *_GetLBarItemWin32IME() { return _plbiWin32IME; }
    //CLBarItemHelp *_GetLBarItemHelp() { return _plbiHelp; } // unused
    CPtrArray<CLBarItemDeviceType> *_GetLBarItemDeviceTypeArray() { return &_rglbiDeviceType; }

    void _AddWin32IMECtrl(BOOL fNotify);
    void _RemoveWin32IMECtrl();

    void _RemoveSystemItems(SYSTHREAD *psfn);

    void ResetDirtyUpdate()
    {
        _fDirtyUpdateHandling = FALSE;
    }

private:

    CLBarItemSinkProxy *GetItemSinkProxy(REFGUID rguid);
    DWORD _GetCookie() {_dwCurCookie++; return _dwCurCookie;} // Issue: need to prevent wrap-around
    DWORD _dwCurCookie;

    CPtrArray<CLBarItemSink> _rgSink;

    ULONG _ulInAssemblyChange;
    BOOL _fItemChanged : 1;
    BOOL _fHandleOnUpdate : 1;
    BOOL _fDirtyUpdateHandling : 1;
    BOOL _fInOnUpdateHandler  : 1;

    DWORD dwDirtyUpdateHandlingTime;

    // system ctls
    CLBarItemCtrl       *_plbiCtrl;
    CLBarItemReconv     *_plbiReconv;
    CLBarItemWin32IME   *_plbiWin32IME;
    CLBarItemHelp       *_plbiHelp;
    CPtrArray<CLBarItemDeviceType> _rglbiDeviceType;

    DBG_ID_DECLARE;
};

// wrapper for CoCreateInstance calls, unlike CLangBarItemMgr this
// class calls DllAddRef/Release
class CLangBarItemMgr_Ole : public ITfLangBarItemMgr,
                            public CComObjectRootImmx
{
public:
    BEGIN_COM_MAP_IMMX(CLangBarItemMgr_Ole)
        COM_INTERFACE_ENTRY(ITfLangBarItemMgr)
    END_COM_MAP_IMMX()

    CLangBarItemMgr_Ole()
    {
        _plbim = NULL;
    }

    ~CLangBarItemMgr_Ole()
    {
        SafeRelease(_plbim);
    }

    static HRESULT CreateInstance(IUnknown *pUnkOuter, REFIID riid, void **ppvObj)
    {
        CLangBarItemMgr_Ole *pLangBarItemMgr_Ole;
        HRESULT hr;

        if (ppvObj == NULL)
            return E_INVALIDARG;

        *ppvObj = NULL;

        if (pUnkOuter != NULL)
            return CLASS_E_NOAGGREGATION;

        pLangBarItemMgr_Ole = new CLangBarItemMgr_Ole;

        if (pLangBarItemMgr_Ole == NULL)
            return E_OUTOFMEMORY;

        hr = pLangBarItemMgr_Ole->QueryInterface(riid, ppvObj);

        pLangBarItemMgr_Ole->Release();

        if (hr == S_OK)
        {
            hr = CLangBarItemMgr::CreateInstance(pUnkOuter, IID_ITfLangBarItemMgr, (void **)&pLangBarItemMgr_Ole->_plbim);

            if (hr != S_OK) // only reason I can think of would be E_OUTOFMEMORY, but be careful
            {
                pLangBarItemMgr_Ole->Release();
                *ppvObj = NULL;
                hr = E_FAIL;
            }
        }

        return hr;
    }

    // ITfLangBarItemMgr
    STDMETHODIMP EnumItems(IEnumTfLangBarItems **ppEnum)
    {
        return _plbim->EnumItems(ppEnum);
    }
    STDMETHODIMP GetItem(REFGUID rguid, ITfLangBarItem **ppItem)
    {
        return _plbim->GetItem(rguid, ppItem);
    }
    STDMETHODIMP AddItem(ITfLangBarItem *punk)
    {
        return _plbim->AddItem(punk);
    }
    STDMETHODIMP RemoveItem(ITfLangBarItem *punk)
    {
        return _plbim->RemoveItem(punk);
    }
    STDMETHODIMP AdviseItemSink(ITfLangBarItemSink *punk, DWORD *pdwCookie, REFGUID rguidItem)
    {
        return _plbim->AdviseItemSink(punk, pdwCookie, rguidItem);
    }
    STDMETHODIMP UnadviseItemSink(DWORD dwCookie)
    {
        return _plbim->UnadviseItemSink(dwCookie);
    }
    STDMETHODIMP GetItemFloatingRect(DWORD dwThreadId, REFGUID rguid, RECT *prc)
    {
        return _plbim->GetItemFloatingRect(dwThreadId, rguid, prc);
    }
    STDMETHODIMP GetItemsStatus(ULONG ulCount, const GUID *prgguid, DWORD *pdwStatus)
    {
        return _plbim->GetItemsStatus(ulCount, prgguid, pdwStatus);
    }
    STDMETHODIMP GetItemNum(ULONG *pulCount)
    {
        return _plbim->GetItemNum(pulCount);
    }
    STDMETHODIMP GetItems(ULONG ulCount,  ITfLangBarItem **ppItem,  TF_LANGBARITEMINFO *pInfo, DWORD *pdwStatus, ULONG *pcFetched)
    {
        return _plbim->GetItems(ulCount,  ppItem,  pInfo, pdwStatus, pcFetched);
    }
    STDMETHODIMP AdviseItemsSink(ULONG ulCount, ITfLangBarItemSink **ppunk,  const GUID *pguidItem, DWORD *pdwCookie)
    {
        return _plbim->AdviseItemsSink(ulCount, ppunk,  pguidItem, pdwCookie);
    }
    STDMETHODIMP UnadviseItemsSink(ULONG ulCount, DWORD *pdwCookie)
    {
        return _plbim->UnadviseItemsSink(ulCount, pdwCookie);
    }

private:
    ITfLangBarItemMgr *_plbim;
};

//////////////////////////////////////////////////////////////////////////////
//
// CLBarItemSinkProxy
//
//////////////////////////////////////////////////////////////////////////////

class CLBarItemSinkProxy : public ITfLangBarItemSink,
                           public CComObjectRootImmx_NoDllAddRef
{
public:
    CLBarItemSinkProxy()
    {
    }

    ~CLBarItemSinkProxy()
    {
        Clear();
    }

    BOOL Init(CLangBarItemMgr *plbiMgr, ITfLangBarItem *plbi, TF_LANGBARITEMINFO *pinfo);

    void Clear()
    {
        _plbiMgr = NULL; // not AddRef'd
        SafeReleaseClear(_plbi);
    }

    BEGIN_COM_MAP_IMMX(CLBarItemSinkProxy)
        COM_INTERFACE_ENTRY(ITfLangBarItemSink)
    END_COM_MAP_IMMX()

    IMMX_OBJECT_IUNKNOWN_FOR_ATL()

    //
    // ITfLangBarItemSink
    //
    STDMETHODIMP OnUpdate(DWORD dwFlags) 
    {
        if (!_plbiMgr || !_plbi)
             return E_FAIL;

        return _plbiMgr->OnUpdate(_plbi, dwFlags);
    }


    CLangBarItemMgr *_plbiMgr;
    ITfLangBarItem *_plbi;
    DWORD _dwCookie;
    BOOL _fCicTip;
    TF_LANGBARITEMINFO _info;

    DBG_ID_DECLARE;
};

//////////////////////////////////////////////////////////////////////////////
//
// CEnumLBItem
//
//////////////////////////////////////////////////////////////////////////////

// Issue: this class should copy all data in ctor
// and derive from CEnumUnknown base
class CEnumLBItem : public IEnumTfLangBarItems,
                    public CSysThreadRef,
                    public CComObjectRootImmx
{
public:
    CEnumLBItem(SYSTHREAD *psfn);
    ~CEnumLBItem();

    BEGIN_COM_MAP_IMMX(CEnumLBItem)
        COM_INTERFACE_ENTRY(IEnumTfLangBarItems)
    END_COM_MAP_IMMX()

    IMMX_OBJECT_IUNKNOWN_FOR_ATL()

    //
    // IEnumTfLBItem
    //
    STDMETHODIMP Clone(IEnumTfLangBarItems **ppEnum);
    STDMETHODIMP Next(ULONG ulCount, ITfLangBarItem **ppNUI, ULONG *pcFetched);
    STDMETHODIMP Reset();
    STDMETHODIMP Skip(ULONG ulCount);

private:
    int _nCur;
    BOOL _fHasFocusDIM;
    DBG_ID_DECLARE;
};


#endif // NUIMGR_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\ctf\uim\perfct.cpp ===
//
// perfct.cpp
//

#include "private.h"
#include "perfct.h"

#ifdef DEBUG

extern DBG_MEMSTATS s_Dbg_MemStats;

DBG_MEM_COUNTER g_rgPerfObjCounters[] =
{
    { TEXT("CAnchorRef:          "), 0 },
    { TEXT("CRange:              "), 0 },
    { TEXT("CLoaderACP:          "), 0 },
    { TEXT("CACPWrap:            "), 0 },
    { TEXT("CAnchorList:         "), 0 },
    { TEXT("CAnchor:             "), 0 },
    { TEXT("CEnumAppPropRanges:  "), 0 },
    { TEXT("CAppProperty:        "), 0 },
    { TEXT("CEnumUberRanges:     "), 0 },
    { TEXT("CUberProperty:       "), 0 },
    { TEXT("CEnumProperties:     "), 0 },
    { TEXT("CProperty:           "), 0 },
    { TEXT("CCategoryMgr:        "), 0 },
    { TEXT("CEnumCategories:     "), 0 },
    { TEXT("CCompartmentMgr:     "), 0 },
    { TEXT("CEnumCompartment:    "), 0 },
    { TEXT("CCompartment:        "), 0 },
    { TEXT("CGlobalCompartment:  "), 0 },
    { TEXT("CCompartmentSub:     "), 0 },
    { TEXT("CEditRecord:         "), 0 },
    { TEXT("CEnumPropertyRanges: "), 0 },
    { TEXT("CInputContext:       "), 0 },
    { TEXT("CSpanSet:            "), 0 },
    { TEXT("PROPERTYLIST:        "), 0 },
    { TEXT("---------------------"), 0 },
    { TEXT("CACPWrap::GetText    "), 0 },
    { TEXT("CACPWrap:GetText:loop"), 0 },
    { TEXT("ShiftRegion:GetText  "), 0 },
    { TEXT("GetTextComp:GetText  "), 0 },
    { TEXT("PlainTextOff:GetText "), 0 },
    { TEXT("ATOF GetText calls:  "), 0 },
    { TEXT("ShiftCond:GetText    "), 0 },
    { TEXT("---------------------"), 0 },
    { TEXT("ATOF calls:          "), 0 },
    { TEXT("ATON calls:          "), 0 },
    { TEXT("Normalize calls:     "), 0 },
    { TEXT("ShiftRegion calls:   "), 0 },
    { TEXT("Renormalize calls:   "), 0 },
    { TEXT("---------------------"), 0 },
    { TEXT("CreateRangeACP       "), 0 },
    { TEXT("Lazy:Norm            "), 0 },
    { TEXT("---------------------"), 0 },
    { TEXT("ITfRange::ShiftStart "), 0 },
    { TEXT("ITfRange::ShiftEnd   "), 0 },
    { TEXT("ITfRange::GetText    "), 0 },
    { TEXT("ITfRange::SetText    "), 0 },
    { TEXT("CAnchorRef::Shift    "), 0 },
    { TEXT("key down events      "), 0 },
};

#endif // DEBUG

#ifdef PERF_DUMP

LARGE_INTEGER g_liPerfFreq = { 0 };

ULONG g_cStrokes = 0;

struct
{
    LARGE_INTEGER liStart[PERF_STROKE_ARRAYSIZE];
    LARGE_INTEGER liEnd[PERF_STROKE_ARRAYSIZE];
}
g_rgPerfStrokes[2048] = { 0 };

BOOL Perf_Init()
{
    QueryPerformanceFrequency(&g_liPerfFreq);
    return TRUE;
}

//+---------------------------------------------------------------------------
//
// Perf_GetTicks
//
//----------------------------------------------------------------------------

LARGE_INTEGER GetTicks()
{
    LARGE_INTEGER li;

    if (g_liPerfFreq.QuadPart != 0)
    {
        QueryPerformanceCounter(&li);
    }
    else
    {
        li.LowPart =  GetTickCount();
        li.HighPart = 0;
    }

    return li;
}

//+---------------------------------------------------------------------------
//
// Perf_GetTickDifference
//
//----------------------------------------------------------------------------

ULONG GetTickDifference(LARGE_INTEGER liStartTicks, LARGE_INTEGER liEndTicks)
{
    liEndTicks.QuadPart -= liStartTicks.QuadPart;

    if (g_liPerfFreq.QuadPart != 0)
    {
        liEndTicks.QuadPart /= (g_liPerfFreq.QuadPart / 1000);
    }

    return liEndTicks.LowPart;
}

//+---------------------------------------------------------------------------
//
// Perf_StartStroke
//
//----------------------------------------------------------------------------

void Perf_StartStroke(UINT iIndex)
{
    LARGE_INTEGER liPrevTotal;

    if (g_cStrokes < ARRAYSIZE(g_rgPerfStrokes))
    {
        liPrevTotal.QuadPart = g_rgPerfStrokes[g_cStrokes].liEnd[iIndex].QuadPart - g_rgPerfStrokes[g_cStrokes].liStart[iIndex].QuadPart;
        g_rgPerfStrokes[g_cStrokes].liStart[iIndex].QuadPart = GetTicks().QuadPart - liPrevTotal.QuadPart;
    }
}

//+---------------------------------------------------------------------------
//
// Perf_EndStroke
//
//----------------------------------------------------------------------------

void Perf_EndStroke(UINT iIndex)
{
    if (g_cStrokes < ARRAYSIZE(g_rgPerfStrokes))
    {
        g_rgPerfStrokes[g_cStrokes].liEnd[iIndex] = GetTicks();
    }

    if (iIndex == PERF_STROKE_DOWN)
    {
        g_cStrokes++;
    }
}

#include <stdio.h>

//+---------------------------------------------------------------------------
//
// Perf_DumpStats
//
//----------------------------------------------------------------------------

void Perf_DumpStats()
{
    //
    // add the application name to check the cicero's performance.
    //
    static const TCHAR *c_rgPerfProcesses[] =
    {
        TEXT("notepad.exe"),
    };

    FILE *file;
    TCHAR ach[MAX_PATH];
    DWORD cch;
    DWORD cchTest;
    LONG i;

    //
    // only dump perf info for certain processes
    //
    for (i=0; i<ARRAYSIZE(c_rgPerfProcesses); i++)
    {
        cchTest = lstrlen(c_rgPerfProcesses[i]);

        if ((cch = GetModuleFileName(0, ach, ARRAYSIZE(ach))) < cchTest)
            continue;

        if (lstrcmpi(ach+cch-cchTest, c_rgPerfProcesses[i]) != 0)
            continue;

        break;
    }
    if (i == ARRAYSIZE(c_rgPerfProcesses))
        return;

    file = fopen("c:\\perf.txt", "w");

    fprintf(file, "****************************************************************\n");
    fprintf(file, "Cicero Perf Counters (%s)\n", c_rgPerfProcesses[i]);
    fprintf(file, "****************************************************************\n");
    fprintf(file, "\n\n");

#ifdef DEBUG
    for (i=0; i<ARRAYSIZE(g_rgPerfObjCounters); i++)
    {
        fprintf(file, "%s %d\n", g_rgPerfObjCounters[i].pszDesc, g_rgPerfObjCounters[i].uCount);
    }

    fprintf(file, "\n\n");
    fprintf(file, "cicMemAlloc:      %d\n", s_Dbg_MemStats.uTotalMemAllocCalls);
    fprintf(file, "cicMemAllocClear: %d\n", s_Dbg_MemStats.uTotalMemAllocClearCalls);
    fprintf(file, "cicMemReAlloc:    %d\n", s_Dbg_MemStats.uTotalMemReAllocCalls);
#endif // DEBUG

    fprintf(file, "\n\n");
    for (i=0; i<(int)min(g_cStrokes, ARRAYSIZE(g_rgPerfStrokes)); i++)
    {
        ULONG ulElapsedDn = GetTickDifference(g_rgPerfStrokes[i].liStart[PERF_STROKE_DOWN], g_rgPerfStrokes[i].liEnd[PERF_STROKE_DOWN]);
        ULONG ulElapsedUp = GetTickDifference(g_rgPerfStrokes[i].liStart[PERF_STROKE_UP], g_rgPerfStrokes[i].liEnd[PERF_STROKE_UP]);
        ULONG ulElapsedTestDn = GetTickDifference(g_rgPerfStrokes[i].liStart[PERF_STROKE_TESTDOWN], g_rgPerfStrokes[i].liEnd[PERF_STROKE_TESTDOWN]);
        ULONG ulElapsedTestUp = GetTickDifference(g_rgPerfStrokes[i].liStart[PERF_STROKE_TESTUP], g_rgPerfStrokes[i].liEnd[PERF_STROKE_TESTUP]);
        ULONG ulElapsedGetMessage = GetTickDifference(g_rgPerfStrokes[i].liStart[PERF_STROKE_GETMSG], g_rgPerfStrokes[i].liEnd[PERF_STROKE_GETMSG]);

        ULONG ulPrev = (i == 0) ? 0 : GetTickDifference(g_rgPerfStrokes[i-1].liEnd[PERF_STROKE_DOWN], g_rgPerfStrokes[i].liEnd[PERF_STROKE_DOWN]);
        ULONG ulPercent = (i == 0) ? 0 : (ulElapsedDn+ulElapsedUp+ulElapsedTestUp+ulElapsedTestDn)*100/ulPrev;

        fprintf(file, "KeyDown %d: %d/%d/%d/%d (%d) (%d%% of %d)\n", i,
                ulElapsedDn, ulElapsedUp, ulElapsedTestDn, ulElapsedTestUp, ulElapsedGetMessage, ulPercent, ulPrev);
    }

    fclose(file);
}

#endif // PERF_DUMP
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\ctf\uim\prop.cpp ===
//
// prop.cpp
//

#include "private.h"
#include "prop.h"
#include "ic.h"

//////////////////////////////////////////////////////////////////////////////
//
// CEnumProperties
//
//////////////////////////////////////////////////////////////////////////////

DBG_ID_INSTANCE(CEnumProperties);

//+---------------------------------------------------------------------------
//
// _Init
//
//----------------------------------------------------------------------------

BOOL CEnumProperties::_Init(CInputContext *pic)
{
    ULONG i;
    CProperty *prop;
    
    // get a count of the number of properties
    for (i=0, prop = pic->_GetFirstProperty(); prop != NULL; prop = prop->_pNext)
    {
        i++;
    }

    // alloc an array
    _prgUnk = SUA_Alloc(i);

    if (_prgUnk == NULL)
        return FALSE;

    // copy the data
    for (i=0, prop = pic->_GetFirstProperty(); prop != NULL; prop = prop->_pNext)
    {
        _prgUnk->rgUnk[i] = prop;
        _prgUnk->rgUnk[i]->AddRef();
        i++;
    }

    _prgUnk->cRef = 1;
    _prgUnk->cUnk = i;

    _iCur = 0;

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\ctf\uim\perfct.h ===
//
// perfct.h
//
// Profiling counters.
//

#ifndef PERFCOUNT_H
#define PERFCOUNT_H

//#define PERF_DUMP

// offsets into s_rgPerfCounters
#define PERF_ANCHORREF_COUNTER      0
#define PERF_RANGE_COUNTER          1
#define PERF_LOADERACP_COUNTER      2
#define PERF_ACPWRAP_COUNTER        3
#define PERF_ANCHORLIST_COUNTER     4
#define PERF_ANCHOR_COUNTER         5
#define PERF_ENUMAPPPROP_COUNTER    6
#define PERF_APPPROP_COUNTER        7
#define PERF_ENUMUBERPROP_COUNTER   8
#define PERF_UBERPROP_COUNTER       9
#define PERF_ENUMPROP_COUNTER       10
#define PERF_PROP_COUNTER           11
#define PERF_CATMGR_COUNTER         12
#define PERF_ENUMCAT_COUNTER        13
#define PERF_COMPARTMGR_COUNTER     14
#define PERF_ENUMCOMPART_COUNTER    15
#define PERF_COMPART_COUNTER        16
#define PERF_GLOBCOMPART_COUNTER    17
#define PERF_COMPARTSUB_COUNTER     18
#define PERF_EDITREC_COUNTER        19
#define PERF_ENUMPROPRANGE_COUNTER  20
#define PERF_CONTEXT_COUNTER        21
#define PERF_SPANSET_COUNTER        22
#define PERF_PROPERTYLIST_COUNTER   23

#define PERF_BREAK0                 24

#define PERF_ACPWRAP_GETTEXT        25
#define PERF_ACPWRAP_GETTEXT_LOOP   26
#define PERF_ANCHOR_REGION_GETTEXT  27
#define PERF_NORM_GETTEXTCOMPLETE   28
#define PERF_PTO_GETTEXT            29
#define PERF_ATOF_GETTEXT_COUNTER   30
#define PERF_SHIFTCOND_GETTEXT      31

#define PERF_BREAK1                 32

#define PERF_ATOF_COUNTER           33
#define PERF_ATON_COUNTER           34
#define PERF_NORMALIZE_COUNTER      35
#define PERF_SHIFTREG_COUNTER       36
#define PERF_RENORMALIZE_COUNTER    37

#define PERF_BREAK2                 38

#define PERF_CREATERANGE_ACP        39
#define PERF_LAZY_NORM              40

#define PERF_BREAK3                 41

#define PERF_SHIFTSTART_COUNT       42
#define PERF_SHIFTEND_COUNT         43
#define PERF_RGETTEXT_COUNT         44
#define PERF_RSETTEXT_COUNT         45
#define PERF_ANCHOR_SHIFT           46
#define PERF_KEYDOWN_COUNT          47

#ifdef PERF_DUMP

BOOL Perf_Init();
void Perf_DumpStats();

#define PERF_STROKE_DOWN            0
#define PERF_STROKE_UP              1
#define PERF_STROKE_TESTDOWN        2
#define PERF_STROKE_TESTUP          3
#define PERF_STROKE_GETMSG          4
#define PERF_STROKE_ARRAYSIZE       5

void Perf_StartStroke(UINT iIndex);
void Perf_EndStroke(UINT iIndex);

#else 

#define Perf_Init()
#define Perf_DumpStats()
#define Perf_StartStroke(iIndex)
#define Perf_EndStroke(iIndex)

#endif // PERF_DUMP

#ifdef DEBUG

//
// debug
//

extern DBG_MEM_COUNTER g_rgPerfObjCounters[];

__inline void Perf_IncCounter(int iCounter) { g_rgPerfObjCounters[iCounter].uCount++; }

#else

//
// retail
//

#define Perf_IncCounter(iCounter)

#endif // DEBUG
#endif // PERFCOUNT_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\ctf\uim\private.h ===
//+---------------------------------------------------------------------------
//
//  File:       private.h
//
//  Contents:   Private header for immx project.
//
//----------------------------------------------------------------------------

#ifndef _PRIVATE_H_
#define _PRIVATE_H_

#define _OLEAUT32_

#define OEMRESOURCE

#undef WINVER 
#define WINVER 0x500

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <immp.h>
#include <ccstock.h>
#include <debug.h>
#include <ole2.h>
#include <olectl.h>
#include <limits.h>
#include <initguid.h>
#ifndef STRSAFE_NO_DEPRECATE
#define STRSAFE_NO_DEPRECATE
#endif
#include <strsafe.h> 
#include "msctf.h"
#include "msctfp.h"
#include "helpers.h"

#include "docwrap.h"
#include "msaadptr.h"
#include "cicmsaa.h"

#include "delay.h"

#ifdef __cplusplus
#include "combase.h"
#endif

#include "mem.h"  // put this last because it macros "new" in DEBUG
#include "dbgid.h"
#include "osver.h"

#include "chkobj.h"

#include "perfct.h"

#ifdef __cplusplus
#include "immxutil.h"
#include "template.h"
#endif

//
// Cic #4580: enable this to support SmartVoice 4.0
//
#define CHECKFEIMESELECTED 1

#define SCALE_ICON 1

#endif  // _PRIVATE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\ctf\uim\prop.h ===
//
// prop.h
//

#ifndef PROP_H
#define PROP_H

#include "sunka.h"

class CInputContext;
class CProperty;

class CEnumProperties : public IEnumTfProperties,
                        public CEnumUnknown,
                        public CComObjectRootImmx
{
public:
    CEnumProperties()
    { 
        Dbg_MemSetThisNameIDCounter(TEXT("CEnumProperties"), PERF_ENUMPROP_COUNTER);
    }

    BOOL _Init(CInputContext *pic);

    BEGIN_COM_MAP_IMMX(CEnumProperties)
        COM_INTERFACE_ENTRY(IEnumTfProperties)
    END_COM_MAP_IMMX()

    IMMX_OBJECT_IUNKNOWN_FOR_ATL()

    DECLARE_SUNKA_ENUM(IEnumTfProperties, CEnumProperties, ITfProperty)

private:
    DBG_ID_DECLARE;
};

#endif // PROP_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\ctf\uim\propstru.h ===
#ifndef PROPSTRU_H
#define PROPSTRU_H

//
// Magic values for PROPERTYSTREAMxxx structures.
//
#define MAGIC_PROPSTREAMHEADER  0xbeef0001
#define MAGIC_PROPSTREAMITEM    0xbeef0002
#define MAGIC_PROPSTREAMFOOTER  0xbeefffff

typedef struct tag_PROPERTYSTREAMHEADER
{
  DWORD _dwMagic;
  long _lTextCheckSum;
  GUID _guidProp;
  long _lPropSize;
} PROPERTYSTREAMHEADER;

typedef struct tag_PROPERTYSTREAMITEM
{
  DWORD _dwMagic;
  long _lBufSize;
} PROPERTYSTREAMITEM;

typedef struct tag_PROPERTYSTREAMITEM_CHAR
{
  long _lAnchor;
  long _lSize;
} PROPERTYSTREAMITEM_CHAR;

typedef struct tag_PROPERTYSTREAMITEM_RANGE
{
  long _lAnchor;
  long _lSize;
  CLSID _clsidIME;
} PROPERTYSTREAMITEM_RANGE;

typedef struct tag_PROPERTYSTREAMFOOTER
{
  DWORD _dwMagic;
} PROPERTYSTREAMFOOTER;


#endif //  PROPSTRU_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\ctf\uim\profiles.h ===
//
// profiles.h
//

#ifndef PROFILES_H
#define PROFILES_H

#include "private.h"
#include "strary.h"
#include "assembly.h"
#include "ic.h"

class CThreadInputMgr;

//
// profiles.cpp
//
void UpdateSystemLangBarItems(SYSTHREAD *psfn, HKL hkl, BOOL fNotify);

#define ACTASM_NONE              0
#define ACTASM_ONTIMACTIVE       1
#define ACTASM_ONSHELLLANGCHANGE 2
typedef WORD ACTASM;

BOOL ActivateAssembly(LANGID langid, ACTASM actasm);
BOOL SyncActivateAssembly(SYSTHREAD *psfn, LANGID langid, ACTASM actasm);
BOOL ActivateNextAssembly(BOOL bPrev);
BOOL ActivateNext(BOOL bPrev);
BOOL ActivateNextKeyTip(BOOL bPrev);
CAssembly *GetCurrentAssembly(SYSTHREAD *psfn = NULL);

#ifdef CHECKFEIMESELECTED
BOOL UnknownFEIMESelected(LANGID langid);
BOOL SyncUnknownFEIMESelected(SYSTHREAD *psfn, LANGID langid);
#endif CHECKFEIMESELECTED

#define AAIF_CHANGEDEFAULT              0x00000001
BOOL ActivateAssemblyItem(SYSTHREAD *psfn, LANGID langid, ASSEMBLYITEM *pItem, DWORD dwFlags);
BOOL SyncActivateAssemblyItem(SYSTHREAD *psfn, LANGID langid, ASSEMBLYITEM *pItem, DWORD dwFlags);

BOOL SetFocusDIMForAssembly(BOOL fSetFocus);
UINT GetKeyboardItemNum();

//////////////////////////////////////////////////////////////////////////////
//
// CEnumLanguageProfile
//
//////////////////////////////////////////////////////////////////////////////

class CEnumLanguageProfiles : public IEnumTfLanguageProfiles,
                        public CComObjectRootImmx
{
public:
    CEnumLanguageProfiles();
    ~CEnumLanguageProfiles();

    BEGIN_COM_MAP_IMMX(CEnumLanguageProfiles)
        COM_INTERFACE_ENTRY(IEnumTfLanguageProfiles)
    END_COM_MAP_IMMX()

    IMMX_OBJECT_IUNKNOWN_FOR_ATL()

    //
    // IEnumTfRangeDeltas
    //
    STDMETHODIMP Clone(IEnumTfLanguageProfiles **ppEnum);
    STDMETHODIMP Next(ULONG ulCount, TF_LANGUAGEPROFILE *rgLanguageProfiles, ULONG *pcFetched);
    STDMETHODIMP Reset();
    STDMETHODIMP Skip(ULONG ulCount);

    BOOL Init(LANGID langid);

private:
    LANGID _langid;
    int _iCur;

    CStructArray<TF_LANGUAGEPROFILE> _rgProfiles;

    DBG_ID_DECLARE;
};

#endif // PROFILES_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\ctf\uim\ptrack.cpp ===
//
// ptrack.cpp
//

#include "private.h"
#include "ic.h"
#include "saa.h"
#include "attr.h"
#include "immxutil.h"
#include "erfa.h"
#include "epval.h"
#include "range.h"

//+---------------------------------------------------------------------------
//
// CalcCicPropertyTrackerAnchors
//
//----------------------------------------------------------------------------

CSharedAnchorArray *CalcCicPropertyTrackerAnchors(CInputContext *pic, IAnchor *paStart, IAnchor *paEnd, ULONG cGUIDATOMs, const TfGuidAtom *prgGUIDATOMs)
{
    CProperty *pProperty;
    CSharedAnchorArray *prgAnchors;
    CSharedAnchorArray **prgAnchorArrays;
    ULONG i;
    LONG iStartEdge;
    LONG iEndEdge;
    LONG iSpan;
    PROPERTYLIST *pPropList;
    IAnchor **ppa;
    ULONG cArrays;
    BOOL fExactEndMatch;
    ULONG cMaxElems;

    if ((prgAnchorArrays = (CSharedAnchorArray **)cicMemAlloc(sizeof(CSharedAnchorArray *)*(cGUIDATOMs+1))) == NULL)
        return NULL;

    cArrays = 0;

    //
    // shove in the range start and end pts
    //
    if ((prgAnchors = new CSharedAnchorArray) == NULL)
        goto ErrorExit;

    if (!prgAnchors->Insert(0, 2))
        goto ErrorExit;

    if (paStart->Clone(prgAnchors->GetPtr(0)) != S_OK)
        goto ErrorExit;

    if (IsEqualAnchor(paStart, paEnd))
    {
        // empty range, we just want a single anchor at the range pos
        prgAnchors->SetCount(1);
        goto Exit;
    }

    if (paEnd->Clone(prgAnchors->GetPtr(1)) != S_OK)
        goto ErrorExit;

    prgAnchorArrays[0] = prgAnchors;

    //
    // assemble a list of all the points between start, end
    //
    cArrays = 1; // 1 for the start, end anchors array
    for (i=0; i<cGUIDATOMs; i++)
    {
        if ((pProperty = pic->_FindProperty(prgGUIDATOMs[i])) == NULL)
            continue; // no instances of this property

        // find the start, end points
        pProperty->Find(paStart, &iStartEdge, FALSE);
        fExactEndMatch = (pProperty->Find(paEnd, &iEndEdge, TRUE) != NULL);

        if (iEndEdge < iStartEdge)
            continue; // start, end are in the same property span, so value is constant over range

        // alloc memory for all the new anchors
        if ((prgAnchors = new CSharedAnchorArray) == NULL)
            goto ErrorExit;

        // alloc for max anchors
        cMaxElems = (iEndEdge - iStartEdge + 1)*2;

        if ((ppa = prgAnchors->Append(cMaxElems)) == NULL)
            goto ErrorExit;
        // prep for failure
        memset(ppa, 0, sizeof(IAnchor *)*cMaxElems);

        // add all the covered anchors for this prop to the list
        if (iStartEdge < 0)
        {
            iSpan = 0;
        }
        else
        {
            iSpan = iStartEdge;

            // if paStart is to the right of the span, skip it
            pPropList = pProperty->GetPropList(iStartEdge);
            if (CompareAnchors(paStart, pPropList->_paEnd) >= 0)
            {
                // we don't cover this span at all, or we just touch the right edge
                // so skip it
                iSpan++;
            }
        }

        while (iSpan <= iEndEdge)
        {
            // shove in this span's anchors
            pPropList = pProperty->GetPropList(iSpan);

            if (iSpan != iStartEdge)
            {
                // filter out dups
                // perf: we could elim the dup check for static compact props
                if (ppa == prgAnchors->GetPtr(0) || !IsEqualAnchor(*(ppa-1), pPropList->_paStart))
                {
                    if (pPropList->_paStart->Clone(ppa++) != S_OK)
                        goto ErrorExit;
                }
            }

            Assert(!IsEqualAnchor(pPropList->_paStart, pPropList->_paEnd)); // no zero-len properties!

            if (iSpan != iEndEdge ||
                (!fExactEndMatch && (iStartEdge < iEndEdge || CompareAnchors(paStart, pPropList->_paEnd) < 0)))
            {                
                if (pPropList->_paEnd->Clone(ppa++) != S_OK)
                    goto ErrorExit;
            }

            iSpan++;
        }
        // may also want the start anchor of the next span
        if (!fExactEndMatch &&
            pProperty->GetPropNum() > iEndEdge+1)
        {
            pPropList = pProperty->GetPropList(iEndEdge+1);

            if (CompareAnchors(paEnd, pPropList->_paStart) > 0) 
            {
                // start of this span may be same as end of prev for non-compact property, check for dup
                if (ppa == prgAnchors->GetPtr(0) || !IsEqualAnchor(*(ppa-1), pPropList->_paStart))
                {
                    // don't need a dup check w/ paEnd because we would have set fExactEndMatch in that case
                    if (pPropList->_paStart->Clone(ppa++) != S_OK)
                        goto ErrorExit;
                }
            }
        }

        // need to resize the array since we may have over-alloc'd
        Assert((int)cMaxElems >= ppa - prgAnchors->GetPtr(0));
        prgAnchors->SetCount((int)(ppa - prgAnchors->GetPtr(0)));
        prgAnchorArrays[cArrays++] = prgAnchors;
    }

    //
    // sort the list
    //
    if (cArrays > 1)
    {
        // mergesort will free all the arrays in prgAnchorArrays
        prgAnchors = CSharedAnchorArray::_MergeSort(prgAnchorArrays, cArrays);
    }
    else
    {
        Assert(prgAnchors == prgAnchorArrays[0]);
    }

    // shrink the array down to size, it won't be modified again
    if (prgAnchors)
        prgAnchors->CompactSize();

Exit:
    cicMemFree(prgAnchorArrays);
    return prgAnchors;

ErrorExit:
    for (i=0; i<cArrays; i++)
    {
        prgAnchorArrays[i]->_Release();
    }
    prgAnchors = NULL;
    goto Exit;
}

//+---------------------------------------------------------------------------
//
// FillCicValueArray
//
//----------------------------------------------------------------------------

void FillCicValueArray(CInputContext *pic, CRange *range, TF_PROPERTYVAL *rgPropVal, ULONG cGUIDATOMs, const TfGuidAtom *prgGUIDATOMs)
{
    ULONG i;
    CProperty *pProperty;

    for (i=0; i<cGUIDATOMs; i++)
    {
        Assert(rgPropVal[i].varValue.vt == VT_EMPTY);

        if (MyGetGUID(prgGUIDATOMs[i], &rgPropVal[i].guidId) != S_OK)
        {
            Assert(0); // this shouldn't happen, we registered the GUID when caller created the property
            rgPropVal[i].guidId = GUID_NULL;
            continue;
        }

        if ((pProperty = pic->_FindProperty(prgGUIDATOMs[i])) != NULL)
        {
            pProperty->_GetDataInternal(range->_GetStart(), range->_GetEnd(), &rgPropVal[i].varValue);
        }
    }
}

//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////
//
// CEnumUberRanges
//
//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////

class CEnumUberRanges : public CEnumRangesFromAnchorsBase
{
public:
    CEnumUberRanges()
    { 
        Dbg_MemSetThisNameIDCounter(TEXT("CEnumUberRanges"), PERF_ENUMUBERPROP_COUNTER);
    }
    BOOL _Init(CInputContext *pic, ITfRange *rangeSuper, ULONG cCicGUIDs, const TfGuidAtom *prgCicGUIDATOMs, ULONG cAppGUIDs, const GUID *prgAppGUIDs);

private:
    DBG_ID_DECLARE;
};

DBG_ID_INSTANCE(CEnumUberRanges);

//+---------------------------------------------------------------------------
//
// _Init
//
//----------------------------------------------------------------------------

BOOL CEnumUberRanges::_Init(CInputContext *pic, ITfRange *rangeSuper, ULONG cCicGUIDATOMs, const TfGuidAtom *prgCicGUIDATOMs, ULONG cAppGUIDs, const GUID *prgAppGUIDs)
{
    CRange *range;
    CSharedAnchorArray *prgSrcAnchorArrays[2];

    Assert(_iCur == 0);
    Assert(_pic == NULL);
    Assert(_prgAnchors == NULL);

    // find the app property transitions
    prgSrcAnchorArrays[0] = CalcAppPropertyTrackerAnchors(pic->_GetTSI(), rangeSuper, cAppGUIDs, prgAppGUIDs);

    if (prgSrcAnchorArrays[0] == NULL)
        return FALSE;

    // find the cicero property transitions
    if ((range = GetCRange_NA(rangeSuper)) == NULL)
        goto ErrorExit;

    prgSrcAnchorArrays[1] = CalcCicPropertyTrackerAnchors(pic, range->_GetStart(), range->_GetEnd(), cCicGUIDATOMs, prgCicGUIDATOMs);

    if (prgSrcAnchorArrays[1] == NULL)
        goto ErrorExit;

    // now combine the two lists
    _prgAnchors = CSharedAnchorArray::_MergeSort(prgSrcAnchorArrays, 2);

    if (_prgAnchors == NULL)
        return FALSE;

    _pic = pic;
    _pic->AddRef();

    return TRUE;

ErrorExit:
    prgSrcAnchorArrays[0]->_Release();
    return FALSE;
}

//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////
//
// CUberProperty
//
//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////

class CUberProperty : public ITfReadOnlyProperty, // perf: share base clas with CAppProperty
                      public CComObjectRootImmx
{
public:
    CUberProperty(CInputContext *pic);
    ~CUberProperty();

    BEGIN_COM_MAP_IMMX(CUberProperty)
        COM_INTERFACE_ENTRY(ITfReadOnlyProperty)
    END_COM_MAP_IMMX()

    IMMX_OBJECT_IUNKNOWN_FOR_ATL()

    BOOL _Init(ULONG cCicGUIDs, const GUID **prgCicGUIDs, ULONG cAppGUIDs, const GUID **prgAppGUIDs);

    // ITfReadOnlyProperty
    STDMETHODIMP GetType(GUID *pguid);
    STDMETHODIMP EnumRanges(TfEditCookie ec, IEnumTfRanges **ppEnum, ITfRange *pTargetRange);
    STDMETHODIMP GetValue(TfEditCookie ec, ITfRange *pRange, VARIANT *pvarValue);
    STDMETHODIMP GetContext(ITfContext **ppContext);

private:
    BOOL _IsValidEditCookie(TfEditCookie ec, DWORD dwFlags)
    {
        return _pic->_IsValidEditCookie(ec, dwFlags);
    }

    CInputContext *_pic;

    ULONG _cCicGUIDATOMs;
    TfGuidAtom *_prgCicGUIDATOMs;

    ULONG _cAppGUIDs;
    GUID *_prgAppGUIDs;

    DBG_ID_DECLARE;
};

DBG_ID_INSTANCE(CUberProperty);

//+---------------------------------------------------------------------------
//
// ctor
//
//----------------------------------------------------------------------------

CUberProperty::CUberProperty(CInputContext *pic)
{
    Dbg_MemSetThisNameIDCounter(TEXT("CUberProperty"), PERF_UBERPROP_COUNTER);

    _pic = pic;
    _pic->AddRef();
}

//+---------------------------------------------------------------------------
//
// dtor
//
//----------------------------------------------------------------------------

CUberProperty::~CUberProperty()
{
    _pic->Release();
    cicMemFree(_prgCicGUIDATOMs);
    cicMemFree(_prgAppGUIDs);
}

//+---------------------------------------------------------------------------
//
// _Init
//
//----------------------------------------------------------------------------

BOOL CUberProperty::_Init(ULONG cCicGUIDs, const GUID **prgCicGUIDs, ULONG cAppGUIDs, const GUID **prgAppGUIDs)
{
    ULONG i;

    if ((_prgCicGUIDATOMs = (TfGuidAtom *)cicMemAlloc(cCicGUIDs*sizeof(TfGuidAtom))) == NULL)
        return FALSE;

    for (i=0; i<cCicGUIDs; i++)
    {
        if (MyRegisterGUID(*prgCicGUIDs[i], &_prgCicGUIDATOMs[i]) != S_OK)
            goto ExitError;
    }

    if ((_prgAppGUIDs = (GUID *)cicMemAlloc(cAppGUIDs*sizeof(GUID))) == NULL)
        goto ExitError;

    _cCicGUIDATOMs = cCicGUIDs;

    _cAppGUIDs = cAppGUIDs;
    for (i=0; i<cAppGUIDs; i++)
    {
        _prgAppGUIDs[i] = *prgAppGUIDs[i];
    }

    return TRUE;

ExitError:
    cicMemFree(_prgCicGUIDATOMs);
    _prgCicGUIDATOMs = NULL; // no funny business in the dtor please
    return FALSE;
}

//+---------------------------------------------------------------------------
//
// EnumRanges
//
//----------------------------------------------------------------------------

STDAPI CUberProperty::EnumRanges(TfEditCookie ec, IEnumTfRanges **ppEnum, ITfRange *pTargetRange)
{
    CEnumUberRanges *pEnum;

    if (ppEnum == NULL)
        return E_INVALIDARG;

    *ppEnum = NULL;

    if (pTargetRange == NULL)
        return E_INVALIDARG;

    if (!VerifySameContext(_pic, pTargetRange))
        return E_INVALIDARG;
    
    if (!_IsValidEditCookie(ec, TF_ES_READ))
    {
        Assert(0);
        return TF_E_NOLOCK;
    }

    pEnum = new CEnumUberRanges;

    if (pEnum == NULL)
        return E_OUTOFMEMORY;

    if (!pEnum->_Init(_pic, pTargetRange, _cCicGUIDATOMs, _prgCicGUIDATOMs, _cAppGUIDs, _prgAppGUIDs))
    {
        pEnum->Release();
        return E_FAIL;
    }

    *ppEnum = pEnum;
    return S_OK;
}

//+---------------------------------------------------------------------------
//
// GetType
//
//----------------------------------------------------------------------------

STDAPI CUberProperty::GetType(GUID *pguid)
{
    if (pguid != NULL)
    {
        // tracker's don't support GetType
        *pguid = GUID_NULL;
    }

    return E_NOTIMPL; // by design
}

//+---------------------------------------------------------------------------
//
// GetValue
//
//----------------------------------------------------------------------------

STDAPI CUberProperty::GetValue(TfEditCookie ec, ITfRange *pRange, VARIANT *pvarValue)
{
    CEnumPropertyValue *pEnumVal;
    CRange *range;
    SHARED_TFPROPERTYVAL_ARRAY *pPropVal;
    HRESULT hr;

    if (pvarValue == NULL)
        return E_INVALIDARG;

    QuickVariantInit(pvarValue);

    if (pRange == NULL)
        return E_INVALIDARG;

    if ((range = GetCRange_NA(pRange)) == NULL)
        return E_INVALIDARG;

    if (!VerifySameContext(_pic, range))
        return E_INVALIDARG;

    if (!_IsValidEditCookie(ec, TF_ES_READ))
    {
        Assert(0);
        return TF_E_NOLOCK;
    }

    hr = E_FAIL;

    if ((pPropVal = SAA_New(_cCicGUIDATOMs + _cAppGUIDs)) == NULL)
        goto Exit;

    // get an array of app values
    if (FillAppValueArray(_pic->_GetTSI(), range, pPropVal->rgAttrVals, _cAppGUIDs, _prgAppGUIDs) != S_OK)
        goto Exit;

    // get an array of cic values
    FillCicValueArray(_pic, range, pPropVal->rgAttrVals + _cAppGUIDs, _cCicGUIDATOMs, _prgCicGUIDATOMs);

    // stick them in an enum
    if ((pEnumVal = new CEnumPropertyValue(pPropVal)) == NULL)
        goto Exit;

    pvarValue->vt = VT_UNKNOWN;
    pvarValue->punkVal = pEnumVal;

    hr = S_OK;

Exit:
    if (pPropVal != NULL)
    {
        SAA_Release(pPropVal);
    }
    return hr;
}

//+---------------------------------------------------------------------------
//
// GetContext
//
// perf: identical to CAppProperty::GetContext....move to base class?
//----------------------------------------------------------------------------

STDAPI CUberProperty::GetContext(ITfContext **ppContext)
{
    if (ppContext == NULL)
        return E_INVALIDARG;

    *ppContext = _pic;
    (*ppContext)->AddRef();

    return S_OK;
}

//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////
//
// CInputContext
//
//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////

//+---------------------------------------------------------------------------
//
// TrackProperties
//
//----------------------------------------------------------------------------

STDAPI CInputContext::TrackProperties(const GUID **pguidProp, ULONG cProp, const GUID **pguidAppProp, ULONG cAppProp, ITfReadOnlyProperty **ppPropX)
{
    CUberProperty *pup;

    if (ppPropX == NULL)
        return E_INVALIDARG;

    *ppPropX = NULL;

    if (pguidProp == NULL && cProp > 0)
        return E_INVALIDARG;

    if (pguidAppProp == NULL && cAppProp > 0)
        return E_INVALIDARG;

    if (!_IsConnected())
        return TF_E_DISCONNECTED;

    if ((pup = new CUberProperty(this)) == NULL)
        return E_OUTOFMEMORY;

    if (!pup->_Init(cProp, pguidProp, cAppProp, pguidAppProp))
    {
        pup->Release();
        return E_OUTOFMEMORY;
    }

    *ppPropX = pup;

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\ctf\uim\profiles.cpp ===
//
// profiles.cpp
//

#include "private.h"
#include "tim.h"
#include "ic.h"
#include "dim.h"
#include "assembly.h"
#include "nuictrl.h"
#include "nuihkl.h"
#include "imelist.h"
#include "xstring.h"
#include "profiles.h"
#include "lbaddin.h"

BOOL MyGetTIPCategory(REFCLSID clsid, GUID *pcatid);

DBG_ID_INSTANCE(CEnumLanguageProfiles);

typedef struct _PENDING_ASSEMBLY_ITEM
{
    LANGID langid;
    HKL hkl;
    CLSID clsid;
    GUID guidProfile;
    DWORD dwFlags;
} PENDING_ASSEMBLY_ITEM;


//////////////////////////////////////////////////////////////////////////////
//
// static functions
//
//////////////////////////////////////////////////////////////////////////////

//+---------------------------------------------------------------------------
//
// UpdateSystemLangBarItems()
//
//----------------------------------------------------------------------------

void UpdateSystemLangBarItems(SYSTHREAD *psfn, HKL hNewKL, BOOL fNotify)
{
    if (psfn->plbim == NULL)
        return;

    if (psfn->plbim->_GetLBarItemDeviceTypeArray())
    {
        int nCnt = psfn->plbim->_GetLBarItemDeviceTypeArray()->Count();
        int i;
        for (i = 0; i < nCnt; i++)
        {
            CLBarItemDeviceType *plbi = psfn->plbim->_GetLBarItemDeviceTypeArray()->Get(i);
            plbi->ShowOrHide(fNotify);
        }
    }

    if (psfn->plbim->_GetLBarItemCtrl())
        psfn->plbim->_GetLBarItemCtrl()->_UpdateLangIcon(hNewKL, fNotify);

    if (psfn->plbim->_GetLBarItemReconv())
        psfn->plbim->_GetLBarItemReconv()->ShowOrHide(fNotify);

    //
    // If this function is called, someone needs to make
    // notification later.
    //
    if (psfn->plbim->InAssemblyChange())
    {
        Assert(!fNotify);
        psfn->plbim->SetItemChange();
    }

    UpdateLangBarAddIns();
}

//+---------------------------------------------------------------------------
//
// ActivateAssemblyPostCleanupCallback
//
//----------------------------------------------------------------------------

void ActivateAssemblyPostCleanupCallback(BOOL fAbort, LONG_PTR lPrivate)
{
    SYSTHREAD *psfn;
    LANGID langid = HIWORD(lPrivate);
    ACTASM actasm = (ACTASM)LOWORD(lPrivate);

    if (fAbort)
        return; // nothing to cleanup...

    if (psfn = GetSYSTHREAD())
    {
        SyncActivateAssembly(psfn, langid, actasm);
    }
}

//+---------------------------------------------------------------------------
//
// DeactivateRemovedTipinAssembly
//
// Deactivate active TIPs that are not in the assembly list. This can happen
// someone remove the profile from the control panel during the tip is 
// running on some application.
//
//----------------------------------------------------------------------------

void DeactivateRemovedTipInAssembly(CThreadInputMgr *ptim, CAssembly *pAsm)
{
    int nAsmCnt = pAsm->Count();
    TfGuidAtom *patom;
    int i; 
    UINT j;

    if (!ptim)
        return;

    if (!nAsmCnt)
        return;

    patom = new TfGuidAtom[nAsmCnt];
    if (!patom)
        return;

    for (i = 0; i < nAsmCnt; i++)
    {
        ASSEMBLYITEM *pItem = pAsm->GetItem(i);
        patom[i] = TF_INVALID_GUIDATOM;
        if (pItem && pItem->fEnabled && !IsEqualGUID(pItem->clsid, GUID_NULL))
            MyRegisterGUID(pItem->clsid, &patom[i]);
    }
  
    for (j = 0; j < ptim->_GetTIPCount(); j++)
    {
        const CTip *ptip = ptim->_GetCTip(j);
        if (ptip && ptip->_fActivated)
        {
            BOOL fFound = FALSE;

            for (i = 0; i < nAsmCnt; i++)
            {
                if (ptip->_guidatom == patom[i])
                    fFound = TRUE;
            }

            if (!fFound)
            {
                CLSID clsid;
                if (SUCCEEDED(MyGetGUID(ptip->_guidatom, &clsid)))
                    ptim->ActivateInputProcessor(clsid, 
                                                 GUID_NULL,
                                                 NULL,
                                                 FALSE);
            }
        }
    }

    delete patom;
}

//+---------------------------------------------------------------------------
//
// GetAssemblyChangeHKL
//
//  ---------   !!!!!!! WARNING WARNING WARNING !!!!!!! ----------
//
//  GetAssemblyChangeHKL and SyncActivateAssembly must have exactly
//  same logic. Otherwise HKL will be corrupted.
//
//  ---------   !!!!!!! WARNING WARNING WARNING !!!!!!! ----------
//
//----------------------------------------------------------------------------

HKL GetAssemblyChangeHKL(SYSTHREAD *psfn, LANGID langid, BOOL fTimActivateLayout)
{
    CThreadInputMgr *ptim;
    BOOL fRet = FALSE;
    ULONG ul;
    ULONG ulCount = 0;
    int nAsmCnt;
    int i;
    BOOL fActivated = FALSE;
    BOOL fActiveNoCic = FALSE;
    BOOL fActivateFEIMEHKLOnCic = FALSE;
    BOOL fCiceroClient= FALSE;
    CAssembly *pAsm;
    CAssemblyList *pAsmList;
    HKL hNewKL = NULL;
    HKL hCurrKL = GetKeyboardLayout(0);

    pAsmList = EnsureAssemblyList(psfn);
    if (!pAsmList)
        return NULL;

    pAsm = pAsmList->FindAssemblyByLangId(langid);
    if (!pAsm)
        return NULL;

    nAsmCnt = pAsm->Count();
    ptim = CThreadInputMgr::_GetThisFromSYSTHREAD(psfn);

    //
    // Check if we're in Cicero aware focus.
    //
    if (ptim && ptim->_GetFocusDocInputMgr()) 
        fCiceroClient = TRUE;

    fActivateFEIMEHKLOnCic = pAsm->IsFEIMEActive();

TryAgain:
    for (i = 0; i < nAsmCnt; i++)
    {
        ASSEMBLYITEM *pItem = pAsm->GetItem(i);

        if (!pItem->fEnabled)
            continue;

        if (fActiveNoCic)
        {
           if (fCiceroClient)
           {
              if (!pItem->fActiveNoCic)
                 continue;
           }
           else
           { 
              if (fActivated)
                 break;
           }
        }
        else
        {
           if (!pItem->fActive)
              continue;
        }


        if (!IsEqualGUID(pItem->clsid, GUID_NULL))
        {
            BOOL fFound = FALSE;
            ul = 0;

            //
            // if fTimActivateLayout is true, we load TIPs.
            //
            if (!fCiceroClient && !fTimActivateLayout)
               continue;

            //
            // skip to activate cicero tip because we will activate
            // FEIMEHKL.
            //
            if (fActivateFEIMEHKLOnCic)
               continue;

            if (pItem->hkl)
            {
                HKL hKL = pItem->hkl;

                //
                // If hKL is different, post WM_INPUTLANGCHANGEREQUEST.
                //
                if (hKL != hCurrKL)
                    hNewKL = hKL;
            }

            fActivated = TRUE;
        }
        else if (pItem->hkl)
        {
            HKL hKL = pItem->hkl;

            //
            // skip substituted hKL on Cicero aware control.
            //
            if (fCiceroClient && pAsm->GetSubstituteItem(hKL))
                continue;

            //
            // If hKL is different, post WM_INPUTLANGCHANGEREQUEST.
            //
            if (hKL != hCurrKL)
                hNewKL = hKL;

            fActivated = TRUE;
        }
    }

    if (!fActivated && !fActiveNoCic)
    {
        fActiveNoCic = TRUE;
        goto TryAgain;
    }
 
    return hNewKL;
}

//+---------------------------------------------------------------------------
//
// ActivateAssembly
//
//----------------------------------------------------------------------------

BOOL ActivateAssembly(LANGID langid, ACTASM actasm)
{
    CThreadInputMgr *ptim;
    SYSTHREAD *psfn;
    LONG_PTR lParam;
    CLEANUPCONTEXT cc;
    BOOL bRet = FALSE;
    BOOL fTimActivateLayout = (actasm == ACTASM_ONTIMACTIVE) ? TRUE : FALSE;
    BOOL fOnShellLangChange = (actasm == ACTASM_ONSHELLLANGCHANGE) ? TRUE : FALSE;

    psfn = GetSYSTHREAD();
    if (!psfn)
        return FALSE;

    if (psfn->fInActivateAssembly)
        return FALSE;

    psfn->fInActivateAssembly = TRUE;

    ptim = CThreadInputMgr::_GetThisFromSYSTHREAD(psfn);

    //
    // if the client is no Cicero aware, we just post 
    // WM_INPUTLANGCHANGEREQUEST.
    //
    if (!ptim || (!fTimActivateLayout && !ptim->_GetFocusDocInputMgr()))
    {
        //
        // If we don't requires any hKL change to activate this new
        // assembly, we can call SyncActivateAssembly now.
        // Otherwise we need to wait until WM_INPUTLANGUAGECHANGEREQUEST
        // is processed.
        //
        HKL hKL = GetAssemblyChangeHKL(psfn, langid, fTimActivateLayout);
        if (fOnShellLangChange || !hKL || (hKL == GetKeyboardLayout(0)))
            SyncActivateAssembly(psfn, langid, actasm);
        else
            PostInputLangRequest(psfn, hKL, TRUE);

        goto Exit;
    }

    lParam = ((DWORD)langid << 16);
    lParam |= actasm;

    cc.fSync = fTimActivateLayout;
    cc.pCatId = NULL;
    cc.langid = langid;
    cc.pfnPostCleanup = ActivateAssemblyPostCleanupCallback;
    cc.lPrivate = lParam;

    ptim->_CleanupContexts(&cc);

    bRet = TRUE;
Exit:
    psfn->fInActivateAssembly = FALSE;
    return bRet;
}

//+---------------------------------------------------------------------------
//
// SyncActivateAssembly
//
//  ---------   !!!!!!! WARNING WARNING WARNING !!!!!!! ----------
//
//  GetAssemblyChangeHKL and SyncActivateAssembly must have exactly
//  same logic. Otherwise HKL will be corrupted.
//
//  ---------   !!!!!!! WARNING WARNING WARNING !!!!!!! ----------
//
//----------------------------------------------------------------------------

BOOL SyncActivateAssembly(SYSTHREAD *psfn, LANGID langid, ACTASM actasm)
{
    CThreadInputMgr *ptim;
    BOOL fRet = FALSE;
    ULONG ul;
    ULONG ulCount = 0;
    int nAsmCnt;
    int i;
    BOOL fActivated = FALSE;
    BOOL fActiveNoCic = FALSE;
    BOOL fIconUpdated = FALSE;
    BOOL fActivateFEIMEHKLOnCic = FALSE;
    BOOL fCallLeaveAssembly = FALSE;
    BOOL fCiceroClient= FALSE;
    CAssembly *pAsm;
    CAssemblyList *pAsmList;
    HKL hNewKL = NULL;
    BOOL fTimActivateLayout = (actasm == ACTASM_ONTIMACTIVE) ? TRUE : FALSE;
    BOOL fOnShellLangChange = (actasm == ACTASM_ONSHELLLANGCHANGE) ? TRUE : FALSE;

    pAsmList = EnsureAssemblyList(psfn);
    if (!pAsmList)
        return FALSE;

    pAsm = pAsmList->FindAssemblyByLangId(langid);
    if (!pAsm)
        return FALSE;

#ifdef CHECKFEIMESELECTED
    pAsm->_fUnknownFEIMESelected = FALSE;
#endif CHECKFEIMESELECTED

    if (psfn->pipp)
    {
        if (!psfn->pipp->_OnLanguageChange(FALSE, pAsm->GetLangId()))
            return TRUE;
    }

    //
    // Enter assembly change notification section.
    // We delay the notificaiton untill LeaveAssemblyChange() is called.
    //
    if (psfn->plbim)
    {
        fCallLeaveAssembly = TRUE;
        psfn->plbim->EnterAssemblyChange();
    }

    nAsmCnt = pAsm->Count();
    ptim = CThreadInputMgr::_GetThisFromSYSTHREAD(psfn);

    //
    // Check if we're in Cicero aware focus.
    //
    if (ptim && ptim->_GetFocusDocInputMgr()) 
        fCiceroClient = TRUE;

    for (i = 0; i < nAsmCnt; i++)
    {
        ASSEMBLYITEM *pItem = pAsm->GetItem(i);
        pItem->fSkipToActivate = FALSE;
        pItem->fSkipToNotify = FALSE;
    }

    if (ptim)
    {
        CAssembly *pAsmCur;
        pAsmCur = GetCurrentAssembly(psfn);
        if (pAsmCur)
        {
            int nAsmCurCnt = pAsmCur->Count();
    
            DeactivateRemovedTipInAssembly(ptim, pAsmCur);
    
            //
            // check if we will activate FEIMEHKL. If so, we will disable 
            // all Cicero tip.
            //
            fActivateFEIMEHKLOnCic = pAsm->IsFEIMEActive();
    
            for (int j = 0; j < nAsmCurCnt; j++)
            {
                ASSEMBLYITEM *pItemCur = pAsmCur->GetItem(j);
    
                if (!pItemCur->fEnabled)
                    continue;
    
                BOOL fSkipToActivate = FALSE;
                BOOL fSkipToNotify = FALSE;
    
                if (ptim->_IsActiveInputProcessor(pItemCur->clsid) != S_OK)
                    continue;
    
                for (i = 0; i < nAsmCnt; i++)
                {
                    ASSEMBLYITEM *pItem = pAsm->GetItem(i);
    
                    if (!pItem->fEnabled)
                        continue;
    
                    if (pItem->fActive && 
                        !fActivateFEIMEHKLOnCic &&
                        IsEqualCLSID(pItem->clsid, pItemCur->clsid))
                    {
                        if (IsEqualCLSID(pItem->guidProfile, pItemCur->guidProfile))
                        {
                            pItem->fSkipToNotify = TRUE;
                            fSkipToNotify = TRUE;
                        }
                        pItem->fSkipToActivate = TRUE;
                        fSkipToActivate = TRUE;
                        break;
                    }
                }
       
                if (!fSkipToNotify)
                {
                    if (fSkipToActivate)
                        ptim->NotifyActivateInputProcessor(pItemCur->clsid, pItemCur->guidProfile, FALSE);
                    else
                        ptim->ActivateInputProcessor(pItemCur->clsid, pItemCur->guidProfile, pItemCur->hklSubstitute, FALSE);
                }
            }
        }
        else
        {
            //
            // if the current assembly is gone, we deactivate all tips.
            //
            for (ul = 0; ul < ptim->_GetTIPCount(); ul++)
            {
                const CTip *ptip = ptim->_GetCTip(ul);
                if (ptip->_fActivated)
                {
                    CLSID clsid;
                    if (SUCCEEDED(MyGetGUID(ptip->_guidatom, &clsid)))
                       ptim->ActivateInputProcessor(clsid, GUID_NULL, NULL, FALSE);
                }
            }
        }
    }

    SetCurrentAssemblyLangId(psfn, pAsm->GetLangId());

TryAgain:
    for (i = 0; i < nAsmCnt; i++)
    {
        ASSEMBLYITEM *pItem = pAsm->GetItem(i);

        if (!pItem)
        {
            Assert(0);
            continue;
        }

        if (!pItem->fEnabled)
            continue;

        if (fActiveNoCic)
        {
           if (fCiceroClient)
           {
              if (!pItem->fActiveNoCic)
                 continue;
           }
           else
           { 
              if (fActivated)
                 break;
           }
        }
        else
        {
           if (!pItem->fActive)
              continue;
        }


        if (!IsEqualGUID(pItem->clsid, GUID_NULL))
        {
            BOOL fFound = FALSE;
            ul = 0;

            //
            // if fTimActivateLayout is true, we load TIPs.
            //
            if (!fCiceroClient && !fTimActivateLayout)
               continue;

            //
            // skip to activate cicero tip because we will activate
            // FEIMEHKL.
            //
            if (fActivateFEIMEHKLOnCic)
               continue;

            if (pItem->hkl)
            {
                HKL hKL = pItem->hkl;
                HKL hCurrKL = GetKeyboardLayout(0);

                //
                // If hKL is different, post WM_INPUTLANGCHANGEREQUEST.
                //
                if (hKL != hCurrKL)
                {
                    //
                    // If we're not on Cicero aware focus,
                    // we won't set AssemblyLangId here 
                    // but we post WM_INPUTLANGCHANGEREQUEST.
                    //
                    if (!fOnShellLangChange)
                        PostInputLangRequest(psfn, hKL, 
                                             !fTimActivateLayout && !fCiceroClient);
                    hNewKL = hKL;
                }
            }

            //
            // check if this TIP is already activated.
            //
            if (pItem->fSkipToActivate)
            {
                if (!pItem->fSkipToNotify)
                    ptim->NotifyActivateInputProcessor(pItem->clsid, pItem->guidProfile, TRUE);
                pItem->fSkipToActivate = FALSE;
                pItem->fSkipToNotify = FALSE;
            }
            else
                ptim->ActivateInputProcessor(pItem->clsid, pItem->guidProfile, pItem->hklSubstitute, TRUE);

            fActivated = TRUE;
        }
        else if (pItem->hkl)
        {
            HKL hKL = pItem->hkl;
            HKL hCurrKL = GetKeyboardLayout(0);

            //
            // skip substituted hKL on Cicero aware control.
            //
            if (fCiceroClient && pAsm->GetSubstituteItem(hKL))
                continue;

            //
            // If hKL is different, post WM_INPUTLANGCHANGEREQUEST.
            //
            if (hKL != hCurrKL)
            {
                //
                // If we're not on Cicero aware focus,
                // we won't set AssemblyLangId here 
                // but we post WM_INPUTLANGCHANGEREQUEST.
                //
                if (!fOnShellLangChange)
                    PostInputLangRequest(psfn, hKL,
                                         !fTimActivateLayout && !fCiceroClient);
                hNewKL = hKL;
                MakeSetFocusNotify(g_msgThreadItemChange, 0, (LPARAM)GetCurrentThreadId());
            }

            //
            // Notify to profile.
            //
            if (ptim)
            {
                 ptim->NotifyActivateInputProcessor(pItem->clsid, 
                                                        pItem->guidProfile, 
                                                        TRUE);
            }

            // 
            // Now we activated this pItem.
            // 
            fActivated = TRUE;
        }

    }

    if (!fActivated && !fActiveNoCic)
    {
        fActiveNoCic = TRUE;
        goto TryAgain;
    }
 
    UpdateSystemLangBarItems(psfn, hNewKL, FALSE);


    fRet = TRUE;

    if (psfn->pipp)
    {
        psfn->pipp->_OnLanguageChange(TRUE, 0);
    }

    if (fCallLeaveAssembly && (psfn->plbim->LeaveAssemblyChange()))
        MakeSetFocusNotify(g_msgThreadItemChange, 0, (LPARAM)GetCurrentThreadId());

    return fRet;
}

//+---------------------------------------------------------------------------
//
// ActivateNextAssembly
//
//----------------------------------------------------------------------------

BOOL ActivateNextAssembly(BOOL bPrev)
{
    SYSTHREAD *psfn;
    CAssemblyList *pAsmList;
    CAssembly *pAsmNext = NULL;
    BOOL bRet = FALSE;
    LANGID langidCur;

    if ((psfn = GetSYSTHREAD()) == NULL)
        return FALSE;

    if ((pAsmList = EnsureAssemblyList(psfn)) == NULL)
        return FALSE;

    int i;
    int nCnt = pAsmList->Count();
    Assert(nCnt > 0);

    langidCur = GetCurrentAssemblyLangId(psfn);

    for (i = 0; i < nCnt; i++)
    {
        CAssembly *pAsm = pAsmList->GetAssembly(i);
        if (pAsm->GetLangId() == langidCur)
        {
            int nNext;
            int nCur = i;

CheckNext:
            if (bPrev)
            {
                nNext = i - 1;
                if (nNext < 0)
                   nNext = nCnt - 1;
            }
            else
            {
                nNext = i + 1;
                if (nNext >= nCnt)
                   nNext = 0;
            }

            pAsmNext = pAsmList->GetAssembly(nNext);
            if (!pAsmNext->IsEnabled(psfn))
            {
                i = nNext;

                if (i == nCur)
                {
                    //
                    // we cound not find Asm.
                    // we don't have to change the assembly.
                    //
                    pAsmNext = NULL;
                    break;
                }

                goto CheckNext;
            }
            break;
        }
    }

    if (pAsmNext && pAsmNext->GetLangId() != langidCur)
    {
        bRet = ActivateAssembly(pAsmNext->GetLangId(), ACTASM_NONE);
    }

    return bRet;
}

//+---------------------------------------------------------------------------
//
// ActivateNextKeyTip
//
//----------------------------------------------------------------------------

BOOL ActivateNextKeyTip(BOOL bPrev)
{
    SYSTHREAD *psfn;
    CThreadInputMgr *ptim;
    CAssembly *pAsm;
    ASSEMBLYITEM *pItemFirst = NULL;
    ASSEMBLYITEM *pItemCur = NULL;
    ASSEMBLYITEM *pItemNext = NULL;
    BOOL bCatchNext = FALSE;
    int i;
    BOOL fTransitory = FALSE;
    BOOL fCiceroClient = FALSE;

    if ((psfn = GetSYSTHREAD()) == NULL)
        return FALSE;

    if ((pAsm = GetCurrentAssembly(psfn)) == NULL)
        return FALSE;

    ptim = CThreadInputMgr::_GetThisFromSYSTHREAD(psfn);

    if (ptim && ptim->_GetFocusDocInputMgr())
    {
        pAsm->RebuildSubstitutedHKLList();
        CInputContext *pic = ptim->_GetFocusDocInputMgr()->_GetTopIC();
        if (pic)
        {
            TF_STATUS dcs;
            if (SUCCEEDED(pic->GetStatus(&dcs)) &&
                (dcs.dwStaticFlags & TF_SS_TRANSITORY))
                fTransitory = TRUE;
        }
        fCiceroClient = TRUE;
    }
    else
        pAsm->ClearSubstitutedHKLList();

    HKL hkl = GetKeyboardLayout(0);
    int nCnt = pAsm->Count();

    for (i = 0; i < nCnt; i++)
    {
        ASSEMBLYITEM *pItemTemp;

        if (!bPrev)
            pItemTemp = pAsm->GetItem(i);
        else
            pItemTemp = pAsm->GetItem(nCnt - i - 1);

        if (!pItemTemp->fEnabled)
            continue;

        if (pItemTemp->fDisabledOnTransitory && fTransitory)
            continue;

        if (IsEqualGUID(pItemTemp->catid, GUID_TFCAT_TIP_KEYBOARD))
        {
            if (!fCiceroClient)
            {
                if (!IsEqualGUID(pItemTemp->clsid, GUID_NULL))
                    continue;
            }
            else
            {
                if (IsEqualGUID(pItemTemp->clsid, GUID_NULL))
                {
                    if (pAsm->IsSubstitutedHKL(pItemTemp->hkl))
                        continue;
                }
            }

            if (!pItemFirst)
                pItemFirst = pItemTemp;

            if (bCatchNext)
            {
                pItemNext = pItemTemp;
                break;
            }

            if (pItemTemp->fActive ||
               ((!fCiceroClient || IsPureIMEHKL(hkl)) && (hkl == pItemTemp->hkl)))
            {
                pItemCur = pItemTemp;
                bCatchNext = TRUE;
            }
        }
    }

    if (!pItemNext)
    {
        pItemNext = pItemFirst;
    }

    if (pItemNext)
    {
        ActivateAssemblyItem(psfn, pAsm->GetLangId(), pItemNext, AAIF_CHANGEDEFAULT);
    }

    return TRUE;
}

//+---------------------------------------------------------------------------
//
// GetCurrentAssembly
//
//+---------------------------------------------------------------------------

CAssembly *GetCurrentAssembly(SYSTHREAD *psfn)
{
    LANGID langid = 0;

    if (!psfn)
    {
        if ((psfn = GetSYSTHREAD()) == NULL)
            return NULL;
    }

    CAssemblyList *pAsmList = EnsureAssemblyList(psfn);

    if (!pAsmList)
        return NULL;

    if (psfn->plbim && psfn->plbim->_GetLBarItemCtrl())
        langid = GetCurrentAssemblyLangId(psfn);

    return pAsmList->FindAssemblyByLangId(langid);
}


//+---------------------------------------------------------------------------
//
// ActivateAssemblyItemPostCleanupCallback
//
//----------------------------------------------------------------------------

void ActivateAssemblyItemPostCleanupCallback(BOOL fAbort, LONG_PTR lPrivate)
{
    PENDING_ASSEMBLY_ITEM *pas = (PENDING_ASSEMBLY_ITEM *)lPrivate;
    SYSTHREAD *psfn;
    CAssemblyList *pAsmList;
    CAssembly *pAsm;
    ASSEMBLYITEM *pItem;
    int i;

    if (fAbort) // just a cleanup?
        goto Exit;

    if ((psfn = GetSYSTHREAD()) == NULL)
        goto Exit;

    if ((pAsmList = EnsureAssemblyList(psfn)) == NULL)
    {
        Assert(0);
        goto Exit;
    }

    if ((pAsm = pAsmList->FindAssemblyByLangId(pas->langid)) == NULL)
    {
        Assert(0);
        goto Exit;
    }

    //
    // we need to make sure the pItem is valid.
    //
    for (i = 0; i < pAsm->Count(); i++)
    {
        pItem = pAsm->GetItem(i);

        if (pItem->IsEqual(pas->hkl, pas->clsid, pas->guidProfile))
        {
            SyncActivateAssemblyItem(psfn, pas->langid, pItem, pas->dwFlags);
            break;
        }
    }
    Assert(i < pAsm->Count()); // should have found the item we were looking for...

Exit:
    cicMemFree(pas);
}

//+---------------------------------------------------------------------------
//
// ActivateAssemblyItem
//
//----------------------------------------------------------------------------

BOOL ActivateAssemblyItem(SYSTHREAD *psfn, LANGID langid, ASSEMBLYITEM *pItem, DWORD dwFlags)
{
    CThreadInputMgr *ptim;
    PENDING_ASSEMBLY_ITEM *pas;
    CLEANUPCONTEXT cc;

    ptim = CThreadInputMgr::_GetThisFromSYSTHREAD(psfn);

    if (ptim == NULL)
    {
        return SyncActivateAssemblyItem(psfn, langid, pItem, dwFlags);
    }

    if ((pas = (PENDING_ASSEMBLY_ITEM *)cicMemAlloc(sizeof(PENDING_ASSEMBLY_ITEM))) == NULL)
        return FALSE;

    pas->langid = langid;
    pas->hkl = pItem->hkl;
    pas->clsid = pItem->clsid;
    pas->guidProfile = pItem->guidProfile;
    pas->dwFlags = dwFlags;

    cc.fSync = FALSE;
    cc.pCatId = &pItem->catid;
    cc.langid = langid;
    cc.pfnPostCleanup = ActivateAssemblyItemPostCleanupCallback;
    cc.lPrivate = (LONG_PTR)pas;

    ptim->_CleanupContexts(&cc);

    return TRUE;
}

//+---------------------------------------------------------------------------
//
// SyncActivateAssemblyItem
//
//----------------------------------------------------------------------------

BOOL SyncActivateAssemblyItem(SYSTHREAD *psfn, LANGID langid, ASSEMBLYITEM *pItem, DWORD dwFlags)
{
    int i;
    int nCnt;
    BOOL fActivateFEIMEHKL = FALSE;
    BOOL fPrevActivateFEIMEHKL = FALSE;
    BOOL fCallLeaveAssembly = FALSE;
    BOOL fSkipActivate = FALSE;
    BOOL fSkipNotify = FALSE;
    BOOL fCiceroClient = FALSE;
    CThreadInputMgr *ptim;
    CAssembly *pAsm;
    CAssemblyList *pAsmList;
    HKL hNewKL = NULL;

    pAsmList = EnsureAssemblyList(psfn);
    if (!pAsmList)
        return FALSE;

    pAsm = pAsmList->FindAssemblyByLangId(langid);
    if (!pAsm)
        return FALSE;

    ptim = psfn->ptim;

    //
    // Check if we're in Cicero aware focus.
    //
    if (ptim && ptim->_GetFocusDocInputMgr()) 
        fCiceroClient = TRUE;

    if (IsEqualGUID(pItem->clsid, GUID_NULL))
    {
        if (IsPureIMEHKL(pItem->hkl))
        {
            fActivateFEIMEHKL = TRUE;
        }
    }
    else if (!fCiceroClient)
    {
        //
        // we should not activate TIPs in the focus is already changed to
        // non cicero aware DIM.
        //
        return TRUE;
    }

    if (psfn->plbim)
    {
        fCallLeaveAssembly = TRUE;
        psfn->plbim->EnterAssemblyChange();
    }

#ifdef CHECKFEIMESELECTED
    if (pAsm->_fUnknownFEIMESelected)
    {
        pAsm->_fUnknownFEIMESelected = FALSE;
        fPrevActivateFEIMEHKL = TRUE;
    }
#endif CHECKFEIMESELECTED

    //
    // deactivate all tip in the same category or diactivate all tips
    // when FE-IME is activated.
    //
    nCnt = pAsm->Count();
    for (i = 0; i < nCnt; i++)
    {
        ASSEMBLYITEM *pItemTemp = pAsm->GetItem(i);

        if (!pItemTemp->fActive)
            continue;

        if (IsEqualGUID(pItem->catid, pItemTemp->catid))
        {
            if (!IsEqualGUID(pItemTemp->clsid, GUID_NULL))
            {
                if (ptim)
                {
                    if (IsEqualGUID(pItemTemp->clsid, pItem->clsid))
                    {
                        if (IsEqualGUID(pItemTemp->guidProfile, pItem->guidProfile))
                            fSkipNotify = TRUE;

                        if (!fSkipNotify)
                            ptim->NotifyActivateInputProcessor(pItemTemp->clsid, pItemTemp->guidProfile, FALSE);
                        fSkipActivate = TRUE;
                    }
                    else
                        ptim->ActivateInputProcessor(pItemTemp->clsid, pItemTemp->guidProfile, pItemTemp->hklSubstitute, FALSE);
                }
            }
            else
            {
                if (IsPureIMEHKL(pItemTemp->hkl))
                    fPrevActivateFEIMEHKL = TRUE;

                if (ptim)
                    ptim->NotifyActivateInputProcessor(pItemTemp->clsid, 
                                                       pItemTemp->guidProfile, 
                                                       FALSE);
            }

            pItemTemp->fActive = FALSE;
        }
        else if (fActivateFEIMEHKL)
        { 
            //
            // FEIMEHKL will be activated so deactivate all tips.
            //
            if (ptim)
            {
                if (!IsEqualGUID(pItemTemp->clsid, GUID_NULL))
                    ptim->ActivateInputProcessor(pItemTemp->clsid, 
                                                 pItemTemp->guidProfile, 
                                                 pItemTemp->hklSubstitute, 
                                                 FALSE);
                else
                    ptim->NotifyActivateInputProcessor(pItemTemp->clsid, 
                                                       pItemTemp->guidProfile, 
                                                       FALSE);
            }
        }
    }

    pItem->fActive = TRUE;

    if (pItem->hkl && (pItem->hkl != GetKeyboardLayout(0)))
    {
        //
        // If we're not on Cicero aware focus,
        // we won't set AssemblyLangId here 
        // but we post WM_INPUTLANGCHANGEREQUEST.
        //
        PostInputLangRequest(psfn, pItem->hkl, !fCiceroClient);
        hNewKL = pItem->hkl;
    }

    //
    // Update assembly reg before making notify.
    //
    pAsmList->SetDefaultTIPInAssemblyInternal(pAsm, pItem, dwFlags & AAIF_CHANGEDEFAULT);

    if (!fActivateFEIMEHKL)
    {
        if (ptim)
        {
            if (!fSkipNotify)
            {
                if (fSkipActivate || IsEqualGUID(pItem->clsid, GUID_NULL))
                    ptim->NotifyActivateInputProcessor(pItem->clsid, pItem->guidProfile, TRUE);
                else
                    ptim->ActivateInputProcessor(pItem->clsid, pItem->guidProfile, pItem->hklSubstitute, TRUE);
            }
        }

        //
        // if the previous activated item was FEIMEHKL,
        // restore all tips in the other categories.
        //
        if (fPrevActivateFEIMEHKL)
        {
            nCnt = pAsm->Count();
            for (i = 0; i < nCnt; i++)
            {
                ASSEMBLYITEM *pItemTemp = pAsm->GetItem(i);

                if (!pItemTemp->fEnabled)
                    continue;

                if (!pItemTemp->fActive)
                    continue;

                if (ptim && !IsEqualGUID(pItem->catid, pItemTemp->catid))
                {
                    ptim->ActivateInputProcessor(pItemTemp->clsid, pItemTemp->guidProfile, pItemTemp->hklSubstitute, TRUE);
                }
            }
        }
    }
    else
    {
        if (ptim)
            ptim->NotifyActivateInputProcessor(pItem->clsid, 
                                               pItem->guidProfile, 
                                               TRUE);
    }

    UpdateSystemLangBarItems(psfn, hNewKL, FALSE);

    if (fCallLeaveAssembly && (psfn->plbim->LeaveAssemblyChange()))
        MakeSetFocusNotify(g_msgThreadItemChange, 0, (LPARAM)GetCurrentThreadId());

    return TRUE;
}

//+---------------------------------------------------------------------------
//
//  SetFocusDIMForAssembly
//
//----------------------------------------------------------------------------

BOOL SetFocusDIMForAssembly(BOOL fSetFocus)
{
    SYSTHREAD *psfn = GetSYSTHREAD();
    CThreadInputMgr *ptim;
    CAssembly *pAsm;
    int nCnt;
    int i;
    HKL hNewKL = NULL;
    BOOL fCallLeaveAssembly = FALSE;

    if (!psfn)
    {
        Assert(0);
        return FALSE;
    }

    ptim = CThreadInputMgr::_GetThisFromSYSTHREAD(psfn);
    if (!ptim)
    {
        Assert(0);
        return FALSE;
    }

    pAsm = GetCurrentAssembly(psfn);
    if (!pAsm)
    {
        Assert(0);
        return FALSE;
    }

    if (fSetFocus)
    {
        //
        // If the substitute hKL is activated now, we move to Cicero mode
        // completely.
        //
        HKL hKL = GetKeyboardLayout(0);

        ActivateAssembly(LOWORD(hKL), ACTASM_NONE);

        //
        // make sure the substituing item will be activated.
        // we need to use hKL that was before calling ActivateAssembly().
        //
        ASSEMBLYITEM *pItem = pAsm->GetSubstituteItem(hKL);
        if (pItem)
        {
            if (!ActivateAssemblyItem(psfn, pAsm->GetLangId(), pItem, 0))
                return FALSE;

            ptim->NotifyActivateInputProcessor(pItem->clsid, 
                                               pItem->guidProfile, 
                                               TRUE);
        }
    }
    else
    {
        if (pAsm->IsEnabled(psfn))
        {
            //
            // if the crruent active TIP has a substitute hKL, we activate it.
            //
            nCnt = pAsm->Count();
            for (i = 0; i < nCnt; i++)
            {
                ASSEMBLYITEM *pItemTemp = pAsm->GetItem(i);

                Assert(!pItemTemp->hkl || (LOWORD((HKL)pItemTemp->hkl) == pAsm->GetLangId()));

                if (!pItemTemp->fEnabled)
                    continue;
    
                if (!pItemTemp->fActive)
                    continue;
    
                if (IsEqualGUID(pItemTemp->catid, GUID_TFCAT_TIP_KEYBOARD))
                {
                    //
                    // we activate the substitute hkl.
                    //
                    if (pItemTemp->hklSubstitute)
                    {
                        PostInputLangRequest(psfn, pItemTemp->hklSubstitute, FALSE);
                        ptim->NotifyActivateInputProcessor(GUID_NULL,
                                                           GUID_NULL,
                                                           TRUE);
                        hNewKL = pItemTemp->hklSubstitute;
                    }

                    break;
                }
            }
        }
        else
        {
#if 0
            //
            // If the current language does not have an Item can run
            // under non-Cicero control, we need to swtich the languiage to
            // system default input locale.
            //

            CAssembly *pAsmTemp;
            CAssemblyList *pAsmList;

            pAsmList = EnsureAssemblyList(psfn);
            pAsmTemp = pAsmList->GetDefaultAssembly();
            if (pAsmTemp)
                ActivateAssembly(pAsmTemp->GetLangId(), ACTASM_NONE);
#endif
        }
    }

    //
    // Enter assembly change notification section.
    // We delay the notificaiton untill LeaveAssemblyChange() is called.
    //
    if (psfn->plbim)
    {
        fCallLeaveAssembly = TRUE;
        psfn->plbim->EnterAssemblyChange();
    }

    UpdateSystemLangBarItems(psfn, hNewKL, FALSE);

    if (psfn->plbim && psfn->plbim->_GetLBarItemCtrl())
        psfn->plbim->_GetLBarItemCtrl()->_AsmListUpdated(FALSE);

    if (fCallLeaveAssembly && (psfn->plbim->LeaveAssemblyChange()))
        MakeSetFocusNotify(g_msgThreadItemChange, 0, (LPARAM)GetCurrentThreadId());

    return TRUE;
}

//+---------------------------------------------------------------------------
//
// GetKeyboardItemNum
//
//----------------------------------------------------------------------------

UINT GetKeyboardItemNum()
{
    SYSTHREAD *psfn;
    CThreadInputMgr *ptim;
    CAssembly *pAsm;
    int i;

    psfn = GetSYSTHREAD();

    if (psfn == NULL)
        return 0;

    pAsm = GetCurrentAssembly(psfn);

    if (!pAsm)
        return 0;

    ptim = CThreadInputMgr::_GetThisFromSYSTHREAD(psfn);

    if (ptim && ptim->_GetFocusDocInputMgr())
        pAsm->RebuildSubstitutedHKLList();
    else
        pAsm->ClearSubstitutedHKLList();

    int nCnt = 0;

    for (i = 0; i < pAsm->Count(); i++)
    {
        ASSEMBLYITEM *pItemTemp;

        pItemTemp = pAsm->GetItem(i);

        if (!pItemTemp->fEnabled)
            continue;

        if (IsEqualGUID(pItemTemp->catid, GUID_TFCAT_TIP_KEYBOARD))
        {
            if (!ptim || !ptim->_GetFocusDocInputMgr())
            {
                if (!IsEqualGUID(pItemTemp->clsid, GUID_NULL))
                    continue;
            }
             
            if (IsEqualGUID(pItemTemp->clsid, GUID_NULL))
            {
                if (pAsm->IsSubstitutedHKL(pItemTemp->hkl))
                    continue;
            }
            nCnt++;
        }
    }

    return nCnt;
}

#ifdef CHECKFEIMESELECTED
//+---------------------------------------------------------------------------
//
// UnknownFEIMESelectedPostCleanupCallback
//
//----------------------------------------------------------------------------

void UnknownFEIMESelectedPostCleanupCallback(BOOL fAbort, LONG_PTR lPrivate)
{
    SYSTHREAD *psfn;
    LANGID langid = (LANGID)lPrivate;

    if (fAbort)
        return; // nothing to cleanup...

    if (psfn = GetSYSTHREAD())
    {
        SyncUnknownFEIMESelected(psfn, langid);
    }
}


//+---------------------------------------------------------------------------
//
// UnknownFEIMESelected
//
//----------------------------------------------------------------------------

BOOL UnknownFEIMESelected(LANGID langid)
{
    CThreadInputMgr *ptim;
    SYSTHREAD *psfn;
    CLEANUPCONTEXT cc;

    psfn = GetSYSTHREAD();
    if (!psfn)
        return FALSE;

    ptim = CThreadInputMgr::_GetThisFromSYSTHREAD(psfn);

    if (ptim == NULL)
        return TRUE;

    cc.fSync = FALSE;
    cc.pCatId = NULL;
    cc.langid = langid;
    cc.pfnPostCleanup = UnknownFEIMESelectedPostCleanupCallback;
    cc.lPrivate = langid;

    ptim->_CleanupContexts(&cc);

    return TRUE;
}

//+---------------------------------------------------------------------------
//
// SyncUnknownFEIMESelected
//
//----------------------------------------------------------------------------

BOOL SyncUnknownFEIMESelected(SYSTHREAD *psfn, LANGID langid)
{
    int i;
    int nCnt;
    // BOOL fActivateFEIMEHKL = FALSE;
    // BOOL fPrevActivateFEIMEHKL = FALSE;
    BOOL fCallLeaveAssembly = FALSE;
    // BOOL fSkipActivate = FALSE;
    // BOOL fSkipNotify = FALSE;
    // BOOL fCiceroClient = FALSE;
    CThreadInputMgr *ptim;
    CAssembly *pAsm;
    CAssemblyList *pAsmList;

    pAsmList = EnsureAssemblyList(psfn);
    if (!pAsmList)
        return FALSE;

    pAsm = pAsmList->FindAssemblyByLangId(langid);
    if (!pAsm)
        return FALSE;

    ptim = psfn->ptim;

    if (psfn->plbim)
    {
        fCallLeaveAssembly = TRUE;
        psfn->plbim->EnterAssemblyChange();
    }

    pAsm->_fUnknownFEIMESelected = TRUE;
    //
    // deactivate all tip in the same category or diactivate all tips
    // when FE-IME is activated.
    //
    nCnt = pAsm->Count();
    for (i = 0; i < nCnt; i++)
    {
        ASSEMBLYITEM *pItemTemp = pAsm->GetItem(i);

        if (!pItemTemp->fActive)
            continue;

        //
        // FEIMEHKL will be activated so deactivate all tips.
        //
        if (ptim && !IsEqualGUID(pItemTemp->clsid, GUID_NULL))
            ptim->ActivateInputProcessor(pItemTemp->clsid, 
                                         pItemTemp->guidProfile, 
                                         pItemTemp->hklSubstitute, 
                                         FALSE);

        if (IsEqualGUID(pItemTemp->catid, GUID_TFCAT_TIP_KEYBOARD))
            pItemTemp->fActive = FALSE;
    }

    UpdateSystemLangBarItems(psfn, NULL, FALSE);

    if (psfn->plbim && psfn->plbim->_GetLBarItemCtrl())
        psfn->plbim->_GetLBarItemCtrl()->_AsmListUpdated(FALSE);

    if (fCallLeaveAssembly && (psfn->plbim->LeaveAssemblyChange()))
        MakeSetFocusNotify(g_msgThreadItemChange, 0, (LPARAM)GetCurrentThreadId());

    return TRUE;
}
#endif CHECKFEIMESELECTED


//////////////////////////////////////////////////////////////////////////////
//
// CEnumLanguageProfiles
//
//////////////////////////////////////////////////////////////////////////////

//+---------------------------------------------------------------------------
//
// ctor
//
//----------------------------------------------------------------------------

CEnumLanguageProfiles::CEnumLanguageProfiles()
{
    _langid = 0;
    _iCur = 0;
}

//+---------------------------------------------------------------------------
//
// dtor
//
//----------------------------------------------------------------------------

CEnumLanguageProfiles::~CEnumLanguageProfiles()
{
}

//+---------------------------------------------------------------------------
//
// Init
//
// !!!WARNING WARNING WARNING!!!
//
// LanguageProfile enumrator is not focus DIM sensitive. Some caller
// want to know which TIP will be activated if the focus is moved to
// Cicero aware (or AIMM12). 
// Don't check the current focus or patch fActive flag.
//
//----------------------------------------------------------------------------

BOOL CEnumLanguageProfiles::Init(LANGID langid)
{
    CAssemblyList *pAsmList;
    int nCntAsm;
    int i;
    SYSTHREAD *psfn = GetSYSTHREAD();

    if (psfn == NULL)
        return FALSE;

    pAsmList = EnsureAssemblyList(psfn);

    if (pAsmList == NULL)
        return FALSE;

    nCntAsm = pAsmList->Count();
    if (!nCntAsm)
        return FALSE;

    for (i = 0;i < nCntAsm; i++)
    {
        CAssembly *pAsm = pAsmList->GetAssembly(i);
        if (!pAsm)
            continue;

        if (!langid || langid == pAsm->GetLangId())
        {
            int j;
            int nCntList = pAsm->Count();
            BOOL fActivateFEIMEHKLOnCic = pAsm->IsFEIMEActive();

            for (j = 0; j < nCntList; j++)
            {
                ASSEMBLYITEM *pItem;
                TF_LANGUAGEPROFILE *pprofile;
                pItem = pAsm->GetItem(j);

                if (!pItem)
                    continue;

                if (IsEqualCLSID(pItem->clsid, GUID_NULL))
                    continue;

                pprofile = _rgProfiles.Append(1);
                if (!pprofile)
                    continue;

                pprofile->clsid = pItem->clsid;
                pprofile->langid = pAsm->GetLangId();
                pprofile->guidProfile = pItem->guidProfile;
                pprofile->catid = pItem->catid;

                if (fActivateFEIMEHKLOnCic)
                    pprofile->fActive = FALSE;
                else
                {
                    //
                    // we need to return TRUE even if the current focus is 
                    // not Cicero aware as above comments.
                    //
                    pprofile->fActive = pItem->fActive;
                }
            }
        }
    }
 
    _langid = langid;
 
    return _rgProfiles.Count() ? TRUE : FALSE;
}

//+---------------------------------------------------------------------------
//
// Clone
//
//----------------------------------------------------------------------------

STDAPI CEnumLanguageProfiles::Clone(IEnumTfLanguageProfiles **ppEnum)
{
    CEnumLanguageProfiles *pEnum = NULL;

    if (!ppEnum)
        return E_INVALIDARG;

    *ppEnum = NULL;

    pEnum = new CEnumLanguageProfiles();
    if (!pEnum)
        return E_OUTOFMEMORY;

    if (!pEnum->Init(_langid))
    {
        pEnum->Release();
        return E_FAIL;
    }

    *ppEnum = pEnum;
    return  S_OK;
}

//+---------------------------------------------------------------------------
//
// Next
//
//----------------------------------------------------------------------------

STDAPI CEnumLanguageProfiles::Next(ULONG ulCount, TF_LANGUAGEPROFILE *rgLanguageProfiles, ULONG *pcFetched)
{
    ULONG cFetched;

    if (pcFetched == NULL)
    {
        pcFetched = &cFetched;
    }
    *pcFetched = 0;

    while (_iCur < _rgProfiles.Count() && *pcFetched < ulCount)
    {
        TF_LANGUAGEPROFILE *pprofile;
        pprofile = _rgProfiles.GetPtr(_iCur);
        *rgLanguageProfiles = *pprofile;
        rgLanguageProfiles++;
        *pcFetched = *pcFetched + 1;
        _iCur++;
    }

    return *pcFetched == ulCount ? S_OK : S_FALSE;
}

//+---------------------------------------------------------------------------
//
// Reset
//
//----------------------------------------------------------------------------

STDAPI CEnumLanguageProfiles::Reset()
{
    _iCur = 0;
    return S_OK;
}

//+---------------------------------------------------------------------------
//
// Skip
//
//----------------------------------------------------------------------------

STDAPI CEnumLanguageProfiles::Skip(ULONG ulCount)
{
    _iCur += ulCount;
    
    return (_iCur > _rgProfiles.Count()) ? S_FALSE : S_OK;
}

//////////////////////////////////////////////////////////////////////////////
//
// CInputProcessorProfiles
//
//////////////////////////////////////////////////////////////////////////////

//+---------------------------------------------------------------------------
//
// GetLanguageList
//
// This function is not TIM sensitive.
//
//----------------------------------------------------------------------------

STDAPI CInputProcessorProfiles::GetLanguageList(LANGID **ppLangId, ULONG *pulCount)
{
    CAssemblyList *pAsmList;
    int i;
    SYSTHREAD *psfn = GetSYSTHREAD();
    
    if (pulCount != NULL)
    {
        *pulCount = 0;
    }
    if (ppLangId != NULL)
    {
        *ppLangId = NULL;
    }

    if (!pulCount)
        return E_INVALIDARG;
    if (!ppLangId)
        return E_INVALIDARG;

    if (psfn == NULL)
        return E_FAIL;

    pAsmList = EnsureAssemblyList(psfn);
    if (!pAsmList)
        return E_FAIL;

    if (!pAsmList->Count())
        return S_OK;

    *ppLangId = (LANGID *)CoTaskMemAlloc(sizeof(LANGID) * pAsmList->Count());
    if (!*ppLangId)
    {
        *pulCount = 0;
        return E_OUTOFMEMORY;
    }

    for (i = 0;i < pAsmList->Count(); i++)
    {
        CAssembly *pAsm = pAsmList->GetAssembly(i);

        //
        // At least one keyboard Item must be enabled to be in the list.
        //
        if (pAsm->IsEnabledKeyboardItem(psfn))
        {
            (*ppLangId)[*pulCount] = pAsm->GetLangId();
            (*pulCount)++;
        }
    }

    return S_OK;
}

//+---------------------------------------------------------------------------
//
// EnumLanguageProfiles
//
//----------------------------------------------------------------------------

STDAPI CInputProcessorProfiles::EnumLanguageProfiles(LANGID langid, IEnumTfLanguageProfiles **ppEnum)
{
    CEnumLanguageProfiles *pEnum;

    if (!ppEnum)
        return E_INVALIDARG;

    *ppEnum = NULL;

    pEnum = new CEnumLanguageProfiles();
    if (!pEnum)
        return E_OUTOFMEMORY;

    if (!pEnum->Init(langid))
    {
        pEnum->Release();
        return E_FAIL;
    }

    *ppEnum = pEnum;
    return  S_OK;
}

//+---------------------------------------------------------------------------
//
// ActivateLanguageProfile
//
//----------------------------------------------------------------------------

STDAPI CInputProcessorProfiles::ActivateLanguageProfile(REFCLSID rclsid, LANGID langid, REFGUID guidProfile)
{
    CThreadInputMgr *ptim;
    CAssemblyList *pAsmList;
    CAssembly *pAsm;
    SYSTHREAD *psfn;
    BOOL fFound = FALSE;
    BOOL fNoCategory = FALSE;
    GUID catid;
    BOOL fSkipActivate = FALSE;

    if (!langid)
        return E_INVALIDARG;

    psfn = GetSYSTHREAD();
    if (!psfn)
        return E_FAIL;

    if (!(ptim = psfn->ptim))
        return E_UNEXPECTED;

    if (langid != GetCurrentAssemblyLangId(psfn))
        return E_INVALIDARG;

    pAsmList = EnsureAssemblyList(psfn);
    if (!pAsmList)
        return E_OUTOFMEMORY;

    pAsm = pAsmList->FindAssemblyByLangId(langid);
    if (!pAsm)
        return E_FAIL;

    fNoCategory = MyGetTIPCategory(rclsid, &catid) ? FALSE : TRUE;

    int nCntList = pAsm->Count();
    int i;
    ASSEMBLYITEM *pItemActivate = NULL;
    for (i = 0; i < nCntList; i++)
    {
        ASSEMBLYITEM *pItem;
        pItem = pAsm->GetItem(i);

        if (!pItem->fEnabled)
            continue;

        if (fNoCategory || IsEqualGUID(catid, pItem->catid))
        {
            if (IsEqualGUID(pItem->guidProfile, guidProfile) &&
                IsEqualGUID(rclsid, pItem->clsid))
            {
               if (pItem->fActive)
               {
                   fSkipActivate = TRUE;
               }
               pItemActivate = pItem;
               break;
            }
        }
    }

    //
    // we could not find the given profile in the assembly.
    //
    if (!pItemActivate)
        return E_INVALIDARG;

    if (fSkipActivate)
    {
        //
        // the clsid is now activated. We skip to call activate 
        // but make a notification.
        //
        ptim->NotifyActivateInputProcessor(pItemActivate->clsid, pItemActivate->guidProfile, FALSE);

        for (i = 0; i < nCntList; i++)
        {
            ASSEMBLYITEM *pItem;
            pItem = pAsm->GetItem(i);

            if (!pItem->fEnabled)
                continue;

            if (!pItem->fActive)
                continue;

            if (!fNoCategory && !IsEqualGUID(catid, pItem->catid))
                continue;

            if (IsEqualGUID(rclsid, pItem->clsid))
            {
                pItem->fActive = FALSE;
            }
        }

        pAsmList->SetDefaultTIPInAssemblyInternal(pAsm, pItemActivate, TRUE);
        pItemActivate->fActive = TRUE;
        ptim->NotifyActivateInputProcessor(pItemActivate->clsid, pItemActivate->guidProfile, TRUE);

        UpdateSystemLangBarItems(psfn, NULL, FALSE);

        MakeSetFocusNotify(g_msgThreadItemChange, 0, (LPARAM)GetCurrentThreadId());
    }
    else if (!pItemActivate->fActive)
    {
        if (!IsEqualGUID(pItemActivate->clsid, GUID_NULL) &&
            !ptim->_GetFocusDocInputMgr())
        {
            //
            // We don't want to support this. It is better to return ERROR.
            // However TIP and Apps may want to call this method
            // on Non-Cicero aware control such as DialogBox.
            //
            pAsmList->SetDefaultTIPInAssemblyInternal(pAsm, pItemActivate, TRUE);
            ActivateAssemblyItem(psfn, pAsm->GetLangId(), pItemActivate, AAIF_CHANGEDEFAULT);
            if (IsEqualGUID(pItemActivate->catid, GUID_TFCAT_TIP_KEYBOARD))
            {
                pItemActivate->fActive = TRUE;
                SetFocusDIMForAssembly(FALSE);
            }
        }
        else
        {
            ActivateAssemblyItem(psfn, pAsm->GetLangId(), pItemActivate, AAIF_CHANGEDEFAULT);
        }
    }

    return S_OK;
}

//+---------------------------------------------------------------------------
//
// GetActiveLanguageProfile
//
// WARNING!!!
//
// Which GetActiveLanguageProfile() or GetDefaultLanguageProfile() should
// we use?
//
// This function is FocusDIM sensetive. So we can call any function
// to check TIM or FocusDIM.
//
// If you don't want to care about TIM and FocusDIM, try 
// GetDefaultLanguageProfile.
//
// if clsid is TIP's category ID, this returns the activated profiles in the
// category. 
//
//----------------------------------------------------------------------------

STDAPI CInputProcessorProfiles::GetActiveLanguageProfile(REFCLSID clsid, LANGID *plangid, GUID *pguid)
{
    CThreadInputMgr *ptim;
    CAssemblyList *pAsmList;
    CAssembly *pAsm;
    SYSTHREAD *psfn;
    LANGID langid;
    BOOL fFound = FALSE;

    if (!plangid)
        return E_INVALIDARG;

    if (!pguid)
        return E_INVALIDARG;

    *plangid = 0;
    *pguid = GUID_NULL;

    psfn = GetSYSTHREAD();
    if (!psfn)
        return E_FAIL;

    ptim = CThreadInputMgr::_GetThisFromSYSTHREAD(psfn);
    if (!ptim || !ptim->_GetFocusDocInputMgr()) 
    {
        //
        // Special Service!
        //
        // GetActiveLanguageProfile(GUID_TFCAT_TIP_KEYBOARD) works
        // without TIM, it can returns, the current keyboard layout.
        //
        if (IsEqualGUID(clsid, GUID_TFCAT_TIP_KEYBOARD))
        {
            HKL hkl;

            if (psfn->hklBeingActivated)
                hkl = psfn->hklBeingActivated;
            else
                hkl = GetKeyboardLayout(0);

            *plangid = LOWORD((DWORD)(UINT_PTR)hkl);
            *((DWORD *)pguid) =  (DWORD)(UINT_PTR)hkl;
            return S_OK;
        }

        return E_UNEXPECTED;
    }

    langid = GetCurrentAssemblyLangId(psfn);

    pAsmList = EnsureAssemblyList(psfn);
    if (!pAsmList)
        return E_OUTOFMEMORY;

    pAsm = pAsmList->FindAssemblyByLangId(langid);
    if (!pAsm)
        return E_FAIL;

    int nCntList = pAsm->Count();
    int i;
    for (i = 0; i < nCntList; i++)
    {
        ASSEMBLYITEM *pItem;
        pItem = pAsm->GetItem(i);

        if (!pItem->fEnabled)
            continue;

        if (pItem->fActive)
        {
            if (IsEqualGUID(clsid, pItem->catid) ||
                IsEqualGUID(clsid, pItem->clsid))
            {
                fFound = TRUE;
                *plangid = langid;
                if (!IsEqualCLSID(pItem->clsid, CLSID_NULL))
                    *pguid = pItem->guidProfile;
                else
                    *((DWORD *)pguid) =  (DWORD)(UINT_PTR)(HKL)(pItem->hkl);
            }
        }
    }

    return fFound ? S_OK : S_FALSE;
}


//+---------------------------------------------------------------------------
//
// GetCurrentLanguage
//
//----------------------------------------------------------------------------

STDAPI CInputProcessorProfiles::GetCurrentLanguage(LANGID *plangid)
{
    if (!plangid)
        return E_INVALIDARG;

    *plangid = GetCurrentAssemblyLangId(NULL);
    return S_OK;
}

//+---------------------------------------------------------------------------
//
// ChangeCurrentLanguage
//
//----------------------------------------------------------------------------

STDAPI CInputProcessorProfiles::ChangeCurrentLanguage(LANGID langid)
{
    CAssemblyList *pAsmList;
    CAssembly *pAsm;
    SYSTHREAD *psfn;

    if (CThreadInputMgr::_GetThis() == NULL)
        return E_UNEXPECTED;

    psfn = GetSYSTHREAD();
    if (!psfn)
        return E_FAIL;

    if (langid == GetCurrentAssemblyLangId(psfn))
        return S_OK;

    pAsmList = EnsureAssemblyList(psfn);
    if (!pAsmList)
        return E_OUTOFMEMORY;

    pAsm = pAsmList->FindAssemblyByLangId(langid);
    if (!pAsm)
        return E_INVALIDARG;

    return ActivateAssembly(pAsm->GetLangId(), ACTASM_NONE) ? S_OK : E_FAIL;
}


//+---------------------------------------------------------------------------
//
// AdviseSink
//
//----------------------------------------------------------------------------

STDAPI CInputProcessorProfiles::AdviseSink(REFIID riid, IUnknown *punk, DWORD *pdwCookie)
{
    const IID *rgiid = &IID_ITfLanguageProfileNotifySink;

    return GenericAdviseSink(riid, punk, &rgiid, &_rgNotifySinks, 1, pdwCookie);
}

//+---------------------------------------------------------------------------
//
// UnadviseSink
//
//----------------------------------------------------------------------------

STDAPI CInputProcessorProfiles::UnadviseSink(DWORD dwCookie)
{
    return GenericUnadviseSink(&_rgNotifySinks, 1, dwCookie);
}

//+---------------------------------------------------------------------------
//
// _OnLanguageChange
//
//----------------------------------------------------------------------------

BOOL CInputProcessorProfiles::_OnLanguageChange(BOOL fChanged, LANGID langid)
{
    int i;

    for (i = 0; i < _rgNotifySinks.Count(); i++)
    {
        HRESULT hr;

        if (!fChanged)
        {
            BOOL fAccept;
            hr = ((ITfLanguageProfileNotifySink *)_rgNotifySinks.GetPtr(i)->pSink)->OnLanguageChange(langid, &fAccept);
            if (SUCCEEDED(hr) && !fAccept)
                return FALSE;
        }
        else
        {
            ((ITfLanguageProfileNotifySink *)_rgNotifySinks.GetPtr(i)->pSink)->OnLanguageChanged();
        }
    }

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\ctf\uim\rangebk.h ===
//
// perange.h
//

#ifndef PERANGE_H
#define PERANGE_H

#include "private.h"
#include "ptrary.h"

class CInputContext;
class CRange;
class CRangeBackup;
class CProperty;

typedef struct tag_PERSISTPROPERTYRANGE
{
  ULONG achStart;
  ULONG achEnd;
  ITfPropertyStore *_pPropStore;
} PERSISTPROPERTYRANGE;

class CRangeBackupProperty
{
public:
    CRangeBackupProperty(CRangeBackup *ppr, CProperty *pProp);
    ~CRangeBackupProperty();

    BOOL Init(TfEditCookie ec);
    BOOL Restore(TfEditCookie ec);

private:
    BOOL _StoreOneRange(TfEditCookie ec, CRange *pCRange);
    int _GetOffset(TfEditCookie ec, IAnchor *pa);
    CRangeBackup *_ppr;
    CProperty *_pProp;

    CStructArray<PERSISTPROPERTYRANGE> _rgPropRanges;
};

class CRangeBackup : public ITfRangeBackup,
                     public CComObjectRootImmx
{
public:
    CRangeBackup(CInputContext *pic);
    ~CRangeBackup();

    BEGIN_COM_MAP_IMMX(CRangeBackup)
        COM_INTERFACE_ENTRY(ITfRangeBackup)
    END_COM_MAP_IMMX()

    IMMX_OBJECT_IUNKNOWN_FOR_ATL()

    STDMETHODIMP Restore(TfEditCookie ec, ITfRange *pRange);

    void Clear();

    HRESULT Init(TfEditCookie ec, CRange *pRange);

private:
    friend CRangeBackupProperty;

    CPtrArray<CRangeBackupProperty> _rgProp;

    // temp text buffer.
    WCHAR *_psz;
    ULONG _cch;

    CInputContext *_pic;
    CRange *_pRange; // perf: we don't need this really

    DBG_ID_DECLARE;
};

#endif // PERANGE_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\ctf\uim\resource.h ===
//+---------------------------------------------------------------------------
//
//  File:       resource.h
//
//----------------------------------------------------------------------------

#ifndef RESOURCE_H
#define RESOURCE_H

#define DEVICE_TYPE_KBD  0
#define DEVICE_TYPE_PEN  1
#define DEVICE_TYPE_MIC  2
#define DEVICE_TYPE_NUM  3

//---------------------------------------------------------------------------
//  Strings
//---------------------------------------------------------------------------
#define IDS_UNKNOWN                 200
#define IDS_IMECLOSE                201
#define IDS_IMEOPEN                 202
#define IDS_SOFTKBDOFF              203
#define IDS_SOFTKBDON               204
#define IDS_IMESHOWSTATUS           205
#define IDS_CONFIGUREIME            206
#define IDS_IMEHELP                 207

#define IDS_NUI_DEVICE_NAME_START   208
#define IDS_NUI_DEVICE_NAME_KBD     208
#define IDS_NUI_DEVICE_NAME_PEN     209
#define IDS_NUI_DEVICE_NAME_MIC     210
#define IDS_NUI_DEVICE_TIP_START    211
#define IDS_NUI_DEVICE_TIP_KBD      211
#define IDS_NUI_DEVICE_TIP_PEN      212
#define IDS_NUI_DEVICE_TIP_MIC      213

#define IDS_NUI_CORRECTION_TOOLTIP  220
#define IDS_NUI_CORRECTION_TEXT     221
#define IDS_NUI_IME_TEXT            222
#define IDS_NUI_IME_TOOLTIP         223
#define IDS_NUI_LANGUAGE_TEXT       224
#define IDS_NUI_LANGUAGE_TOOLTIP    225
#define IDS_NUI_HELP                226

#define IDS_LANGBARHELP             228
#define IDS_SHOWLANGBAR             229
#define IDS_NOTIFICATIONICONS       230
#define IDS_SHOWINPUTCPL            231

#define IDS_CPL_WIN_KBDCPLNAME      240
#define IDS_CPL_WIN9X_KBDCPLTITLE   241
#define IDS_CPL_WINNT_INTLCPLNAME   242
#define IDS_CPL_WINNT_KBDCPLTITLE   243
#define IDS_CPL_INPUT_DISABLED      244
#define IDS_CPL_INPUT_GROUPBOX      245
#define IDS_CPL_INPUT_CHAANGE_BTN   246

#define IDS_PROP_ATTRIBUTE          250

#define IDS_TFCAT_TIP_KEYBOARD      251
#define IDS_TFCAT_TIP_SPEECH        252
#define IDS_TFCAT_TIP_HANDWRITING   253
#define IDS_TFCAT_TIP_REFERENCE     254
#define IDS_TFCAT_TIP_PROOFING      255
#define IDS_TFCAT_TIP_SMARTTAG      256
//---------------------------------------------------------------------------
// Icon
//---------------------------------------------------------------------------
#define ID_ICON_RECONVERSION        300

#define ID_ICON_IMEOPEN             350
#define ID_ICON_IMECLOSE            351
#define ID_ICON_IMEDISAB            352
#define ID_ICON_IMEE_H              353
#define ID_ICON_IMEE_F              354
#define ID_ICON_IMEH_H              355
#define ID_ICON_IMEH_F              356

#define ID_ICON_DEVICE_START        357
#define ID_ICON_DEVICE_KBD          357
#define ID_ICON_DEVICE_PEN          358
#define ID_ICON_DEVICE_MIC          359

#define ID_ICON_TEXT_SERVICE        360

#define ID_ICON_HELP                400

//---------------------------------------------------------------------------
//  Menu
//---------------------------------------------------------------------------

#define IDM_IME_OPENCLOSE           5000
#define IDM_IME_SOFTKBDONOFF        5001
#define IDM_IME_SHOWSTATUS          5002
#define IDM_RMENU_WHATSTHIS         5003
#define IDM_RMENU_HELPFINDER        5004
#define IDM_RMENU_PROPERTIES        5005
#define IDM_RMENU_IMEHELP           5006
#define IDM_SHOWLANGBAR             5007
#define IDM_NOTIFICATIONICONS       5008
#define IDM_NONOTIFICATIONICONS     5009
#define IDM_SHOWINPUTCPL            5010


#define IDM_LANG_MENU_START         6000
#define IDM_ASM_MENU_START          6500
#define IDM_CUSTOM_MENU_START       7000


#endif // RESOURCE_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\ctf\uim\rmcoll.cpp ===
//
// rmcoll.cpp
//
// Render markup/collections.
//

#include "private.h"
#include "dam.h"
#include "saa.h"
#include "strary.h"
#include "ic.h"
#include "attr.h"
#include "range.h"
#include "immxutil.h"
#include "rprop.h"

//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////
//
// CRenderMarkupCollection
//
//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////

//+---------------------------------------------------------------------------
//
// ctor
//
//----------------------------------------------------------------------------

CRenderMarkupCollection::CRenderMarkupCollection()
{
    // always add GUID_PROP_ATTRIBUTE at index 0

    if (!_rgGUIDAtom.Append(1))
        return;
    if (!_rgOther.Append(1))
    {
        _rgGUIDAtom.Clear();
        return;
    }

    MyRegisterGUID(GUID_PROP_ATTRIBUTE, _rgGUIDAtom.GetPtr(0));
    _rgOther.GetPtr(0)->uPriority = TF_DA_PRIORITY_HIGHEST;
    _rgOther.GetPtr(0)->gaTip = g_gaSystem;
}

//+---------------------------------------------------------------------------
//
// _Advise
//
//----------------------------------------------------------------------------

void CRenderMarkupCollection::_Advise(ITfTextInputProcessor *tip, TfGuidAtom gaTip)
{
    ITfDisplayAttributeCollectionProvider *pProvider;
    ULONG uCount;
    TF_DA_PROPERTY rgProperty[8];
    int i;
    int iOldCount;
    int iOld;
    int iNew;

    if (tip->QueryInterface(IID_ITfDisplayAttributeCollectionProvider, (void **)&pProvider) != S_OK)
        return;

    if (pProvider->GetCollection(ARRAYSIZE(rgProperty), rgProperty, &uCount) != S_OK || uCount == 0)
        goto Exit;

    iOldCount = _rgGUIDAtom.Count();
    Assert(iOldCount == _rgOther.Count());

    if (!_rgGUIDAtom.Append(uCount))
        goto Exit;
    if (!_rgOther.Append(uCount))
    {
        _rgGUIDAtom.Remove(iOldCount, uCount);
        goto Exit;
    }

    // merge the new guids with the old
    // nb: we assume rgProperty is sorted
    iNew = uCount-1;
    iOld = iOldCount-1;

    for (i=iNew + iOld + 1; i>=0; i--)
    {
        // nb: we put new GUIDs with same priority as existing GUIDs lower in the list
        // this makes sure that GUID_PROP_ATTRIBUTE is always at index 0, and keeps
        // existing rendering consistent (no change on screen of existing markup)
        if (iNew >= 0 &&
            rgProperty[iNew].uPriority >= _rgOther.GetPtr(iOld)->uPriority)
        {
            MyRegisterGUID(rgProperty[iNew].guidProperty, _rgGUIDAtom.GetPtr(i));
            _rgOther.GetPtr(i)->uPriority = rgProperty[iNew].uPriority;
            _rgOther.GetPtr(i)->gaTip = gaTip;
            iNew--;
        }
        else
        {
            *_rgGUIDAtom.GetPtr(i) = *_rgGUIDAtom.GetPtr(iOld);
            *_rgOther.GetPtr(i) = *_rgOther.GetPtr(iOld);
            iOld--;
        }
    }

Exit:
    pProvider->Release();
}

//+---------------------------------------------------------------------------
//
// _Unadvise
//
//----------------------------------------------------------------------------

void CRenderMarkupCollection::_Unadvise(TfGuidAtom gaTip)
{
    int iOldCount;
    int iNewCount;
    int i;
    int iDst;
    iOldCount = _rgGUIDAtom.Count();
    iNewCount = 0;

    iDst = -1;

    for (i=0; i<iOldCount; i++)
    {
        if (_rgOther.GetPtr(i)->gaTip == gaTip)
        {
            if (iDst == -1)
            {
                iDst = i;
            }
        }
        else if (iDst != -1)
        {
            *_rgGUIDAtom.GetPtr(iDst) = *_rgGUIDAtom.GetPtr(i);
            *_rgOther.GetPtr(iDst) = *_rgOther.GetPtr(i);
            iDst++;
            iNewCount++;
        }
    }

    if (iDst != -1)
    {
        _rgGUIDAtom.Remove(iDst, iOldCount - iDst);
        _rgOther.Remove(iDst, iOldCount - iDst);
    }
    Assert(_rgGUIDAtom.Count() == _rgOther.Count());
}

//+---------------------------------------------------------------------------
//
// _IsInCollection
//
//----------------------------------------------------------------------------

BOOL CRenderMarkupCollection::_IsInCollection(REFGUID rguidProperty)
{
    TfGuidAtom tfGuidAtom;
    int i;

    if (_rgGUIDAtom.Count() == 0)
        return FALSE;

    MyRegisterGUID(rguidProperty, &tfGuidAtom);

    for (i=0; i<_rgGUIDAtom.Count(); i++)
    {
        if (*_rgGUIDAtom.GetPtr(i) == tfGuidAtom)
            return TRUE;
    }

    return FALSE;
}

//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////
//
// CEnumRenderingMarkup
//
//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////

class CEnumRenderingMarkup : public IEnumTfRenderingMarkup,
                             public CComObjectRootImmx
{
public:
    CEnumRenderingMarkup()
    {
        Dbg_MemSetThisNameIDCounter(TEXT("CEnumRenderingMarkup"), PERF_UBERPROP_COUNTER);
    }
    ~CEnumRenderingMarkup();

    BEGIN_COM_MAP_IMMX(CEnumRenderingMarkup)
        COM_INTERFACE_ENTRY(IEnumTfRenderingMarkup)
    END_COM_MAP_IMMX()

    IMMX_OBJECT_IUNKNOWN_FOR_ATL()

    BOOL _Init(DWORD dwFlags, CRange *pRangeCover, CInputContext *pContext);

    // IEnumTfRenderingMarkup
    STDMETHODIMP Clone(IEnumTfRenderingMarkup **ppClone);
    STDMETHODIMP Next(ULONG ulCount, TF_RENDERINGMARKUP *rgMarkup, ULONG *pcFetched);
    STDMETHODIMP Reset();
    STDMETHODIMP Skip(ULONG ulCount);

private:
    int _iCur;
    CSharedAnchorArray *_prgAnchors;
    CSharedStructArray<TF_DISPLAYATTRIBUTE> *_prgValues;
    CInputContext *_pContext;

    DBG_ID_DECLARE;
};

DBG_ID_INSTANCE(CEnumRenderingMarkup);

//+---------------------------------------------------------------------------
//
// dtor
//
//----------------------------------------------------------------------------

CEnumRenderingMarkup::~CEnumRenderingMarkup()
{
    if (_prgAnchors != NULL)
    {
        _prgAnchors->_Release();
    }
    if (_prgValues != NULL)
    {
        _prgValues->_Release();
    }
    _pContext->Release();
}

//+---------------------------------------------------------------------------
//
// LookupProperty
//
//----------------------------------------------------------------------------

BOOL LookupProperty(CInputContext *pContext, ITfDisplayAttributeMgr *pDisplayAttrMgr,
                   TfGuidAtom tfGuidAtom, IAnchor *paStart, IAnchor *paEnd, TF_DISPLAYATTRIBUTE *ptfAttrInfoNext)
{
    CProperty *pProperty;
    ITfDisplayAttributeInfo *pDisplayAttrInfo;
    VARIANT varValue;
    GUID guidValue;
    BOOL fRet;

    // get the property matching the GUID
    if ((pProperty = pContext->_FindProperty(tfGuidAtom)) == NULL)
        return FALSE;

    // get the GUID value of the property
    if (pProperty->_GetDataInternal(paStart, paEnd, &varValue) != S_OK) // perf: don't really need paEnd
        return FALSE;

    Assert(varValue.vt == VT_I4); // should be a GUIDATOM

    if (MyGetGUID(varValue.lVal, &guidValue) != S_OK)
        return FALSE;

    // translate the GUID to a display attribute
    if (pDisplayAttrMgr->GetDisplayAttributeInfo(guidValue, &pDisplayAttrInfo, NULL) != S_OK)
        return FALSE;

    fRet = (pDisplayAttrInfo->GetAttributeInfo(ptfAttrInfoNext) == S_OK);

    pDisplayAttrInfo->Release();
    return fRet;
}


//+---------------------------------------------------------------------------
//
// _Init
//
//----------------------------------------------------------------------------

BOOL CEnumRenderingMarkup::_Init(DWORD dwFlags, CRange *pRangeCover, CInputContext *pContext)
{
    CDisplayAttributeMgr *pDisplayAttrMgr;
    CRenderMarkupCollection *pMarkupCollection;
    int i;
    int j;
    TF_DISPLAYATTRIBUTE *ptfAttrInfo;
    TF_DISPLAYATTRIBUTE tfAttrInfoNext;
    BOOL fNeedLine;
    BOOL fNeedText;
    BOOL fRet;
    ULONG uCount;
    const TfGuidAtom *pAtoms;

    Assert(_iCur == 0);
    Assert(_pContext == NULL);
    Assert(_prgAnchors == NULL);
    Assert(_prgValues == NULL);

    pDisplayAttrMgr = CDisplayAttributeMgr::_GetThis();
    if (pDisplayAttrMgr == NULL)
    {
        Assert(0); // ITfThreadMgr::Activate should ensure the singleton is initialized in tls
        return FALSE;
    }

    fRet = FALSE;

    pMarkupCollection = pDisplayAttrMgr->_GetMarkupCollection();

    // find the cicero property transitions
    if (dwFlags & TF_GRM_INCLUDE_PROPERTY)
    {
        uCount = pMarkupCollection->_Count();
        pAtoms = pMarkupCollection->_GetAtoms();
    }
    else
    {
        // skip GUID_PROP_ATTRIBUTE at index 0
        Assert(pMarkupCollection->_Count() >= 1);
        uCount = pMarkupCollection->_Count() - 1;
        pAtoms = pMarkupCollection->_GetAtoms() + 1;
    }
    _prgAnchors = CalcCicPropertyTrackerAnchors(pContext, pRangeCover->_GetStart(), pRangeCover->_GetEnd(),
                                                pMarkupCollection->_Count(), pMarkupCollection->_GetAtoms());

    if (_prgAnchors == NULL)
        goto Exit;

    Assert(_prgAnchors->Count() > 0); // we should get at least the pRangeCover start anchor

    if ((_prgValues = new CSharedStructArray<TF_DISPLAYATTRIBUTE>) == NULL)
        goto Exit;

    if (_prgAnchors->Count() > 1) // Append(0) will return NULL if the array is empty
    {                             // which is fine, but we don't want to return failure in that case (empty range => empty enum)
        if (!_prgValues->Append(_prgAnchors->Count()-1))
            goto Exit;
    }

    // now calculate the TF_DISPLAYATTRIBUTE for each span
    for (i=0; i<_prgAnchors->Count()-1; i++)
    {
        ptfAttrInfo = _prgValues->GetPtr(i);

        memset(ptfAttrInfo, 0, sizeof(*ptfAttrInfo));
        ptfAttrInfo->bAttr = TF_ATTR_OTHER;

        fNeedLine = TRUE;
        fNeedText = TRUE;

        // examine property values over the single span
        // index 0 is always GUID_PROP_ATTRIBUTE, only include it if the TF_GRM_INCLUDE_PROPERTY is set
        j = (dwFlags & TF_GRM_INCLUDE_PROPERTY) ? 0 : 1;
        for (; j<pMarkupCollection->_Count(); j++)
        {
            // get the property matching the GUID
            if (!LookupProperty(pContext, pDisplayAttrMgr, pMarkupCollection->_GetAtom(j), _prgAnchors->Get(i), _prgAnchors->Get(i+1), &tfAttrInfoNext))
                continue;

            // we got one
            if (fNeedText &&
                (tfAttrInfoNext.crText.type != TF_CT_NONE || tfAttrInfoNext.crBk.type != TF_CT_NONE))
            {
                ptfAttrInfo->crText = tfAttrInfoNext.crText;
                ptfAttrInfo->crBk = tfAttrInfoNext.crBk;
                fNeedText = FALSE;
            }
            if (fNeedLine &&
                tfAttrInfoNext.lsStyle != TF_LS_NONE)
            {
                ptfAttrInfo->lsStyle = tfAttrInfoNext.lsStyle;
                ptfAttrInfo->crLine = tfAttrInfoNext.crLine;
                ptfAttrInfo->fBoldLine = tfAttrInfoNext.fBoldLine;
                fNeedLine = FALSE;
            }

            // we can stop looking at this span if everything lower in the z-order is blocked
            if (j == 0 && (!fNeedText || !fNeedLine))
                break; // GUID_PROP_ATTRIBUTE is never masked with anything else
            if (!fNeedText && !fNeedLine)
                break; // couldn't mask in any more attributes
        }
    }

    _pContext = pContext;
    _pContext->AddRef();

    fRet = TRUE;

Exit:
    return fRet;
}

//+---------------------------------------------------------------------------
//
// Clone
//
//----------------------------------------------------------------------------

STDAPI CEnumRenderingMarkup::Clone(IEnumTfRenderingMarkup **ppEnum)
{
    CEnumRenderingMarkup *pClone;

    if (ppEnum == NULL)
        return E_INVALIDARG;

    *ppEnum = NULL;

    if ((pClone = new CEnumRenderingMarkup) == NULL)
        return E_OUTOFMEMORY;

    pClone->_iCur = _iCur;

    pClone->_prgAnchors = _prgAnchors;
    pClone->_prgAnchors->_AddRef();

    pClone->_prgValues = _prgValues ;
    pClone->_prgValues->_AddRef();

    pClone->_pContext = _pContext;
    pClone->_pContext->AddRef();

    *ppEnum = pClone;

    return S_OK;
}

//+---------------------------------------------------------------------------
//
// Next
//
//----------------------------------------------------------------------------

STDAPI CEnumRenderingMarkup::Next(ULONG ulCount, TF_RENDERINGMARKUP *rgMarkup, ULONG *pcFetched)
{
    ULONG cFetched;
    CRange *range;
    IAnchor *paPrev;
    IAnchor *pa;
    int iCurOld;

    if (pcFetched == NULL)
    {
        pcFetched = &cFetched;
    }
    *pcFetched = 0;
    iCurOld = _iCur;

    if (ulCount > 0 && rgMarkup == NULL)
        return E_INVALIDARG;

    // we should always have at least one anchor (one anchor => empty range for enum, nothing to enum)
    Assert(_prgAnchors->Count() >= 1);

    paPrev = _prgAnchors->Get(_iCur);

    while (_iCur < _prgAnchors->Count()-1 && *pcFetched < ulCount)
    {
        pa = _prgAnchors->Get(_iCur+1);

        if ((range = new CRange) == NULL)
            break;
        if (!range->_InitWithDefaultGravity(_pContext, COPY_ANCHORS, paPrev, pa))
        {
            range->Release();
            break;
        }

        // we should never be returning empty ranges, since currently this base
        // class is only used for property enums and property spans are never
        // empty.
        // Similarly, paPrev should always precede pa.
        Assert(CompareAnchors(paPrev, pa) < 0);

        rgMarkup->pRange = (ITfRangeAnchor *)range;
        rgMarkup->tfDisplayAttr = *_prgValues->GetPtr(_iCur);
        rgMarkup++;

        *pcFetched = *pcFetched + 1;
        _iCur++;
        paPrev = pa;
    }

    return *pcFetched == ulCount ? S_OK : S_FALSE;
}

//+---------------------------------------------------------------------------
//
// Reset
//
//----------------------------------------------------------------------------

STDAPI CEnumRenderingMarkup::Reset()
{
    _iCur = 0;
    return S_OK;
}

//+---------------------------------------------------------------------------
//
// Skip
//
//----------------------------------------------------------------------------

STDAPI CEnumRenderingMarkup::Skip(ULONG ulCount)
{
    _iCur += ulCount;
    
    return (_iCur > _prgValues->Count()) ? S_FALSE : S_OK;
}

//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////
//
// CDisplayAttributeMgr
//
//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////

//+---------------------------------------------------------------------------
//
// EnumCollections
//
//----------------------------------------------------------------------------

STDAPI CDisplayAttributeMgr::EnumCollections(IEnumTfCollection **ppEnum)
{
    return E_NOTIMPL;
}

//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////
//
// CInputContext
//
//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////

//+---------------------------------------------------------------------------
//
// GetRenderingMarkup
//
//----------------------------------------------------------------------------

STDAPI CInputContext::GetRenderingMarkup(TfEditCookie ec, DWORD dwFlags,
                                         ITfRange *pRangeCover,
                                         IEnumTfRenderingMarkup **ppEnum)
{
    CEnumRenderingMarkup *pEnum;
    CRange *range;

    if (ppEnum == NULL)
        return E_INVALIDARG;

    *ppEnum = NULL;

    if (!_IsValidEditCookie(ec, TF_ES_READ))
        return TF_E_NOLOCK;

    if (dwFlags & ~TF_GRM_INCLUDE_PROPERTY)
        return E_INVALIDARG;

    if (pRangeCover == NULL)
        return E_INVALIDARG;

    if ((range = GetCRange_NA(pRangeCover)) == NULL)
        return E_INVALIDARG;

    if (!_IsConnected())
        return TF_E_DISCONNECTED;

    if ((pEnum = new CEnumRenderingMarkup) == NULL)
        return E_OUTOFMEMORY;

    if (!pEnum->_Init(dwFlags, range, this))
    {
        pEnum->Release();
        return E_FAIL;
    }

    *ppEnum = pEnum;

    return S_OK;
}

//+---------------------------------------------------------------------------
//
// FindNextRenderingMarkup
//
//----------------------------------------------------------------------------

STDAPI CInputContext::FindNextRenderingMarkup(TfEditCookie ec, DWORD dwFlags,
                                              ITfRange *pRangeQuery,
                                              TfAnchor tfAnchorQuery,
                                              ITfRange **ppRangeFound,
                                              TF_RENDERINGMARKUP *ptfRenderingMarkup)
{
    return E_NOTIMPL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\ctf\uim\range.cpp ===
//
// range.cpp
//

#include "private.h"
#include "range.h"
#include "ic.h"
#include "immxutil.h"
#include "rprop.h"
#include "tim.h"
#include "anchoref.h"
#include "compose.h"

/* b68832f0-34b9-11d3-a745-0050040ab407 */
const IID IID_PRIV_CRANGE = { 0xb68832f0,0x34b9, 0x11d3, {0xa7, 0x45, 0x00, 0x50, 0x04, 0x0a, 0xb4, 0x07} };

DBG_ID_INSTANCE(CRange);

MEMCACHE *CRange::_s_pMemCache = NULL;

//+---------------------------------------------------------------------------
//
// _InitClass
//
//----------------------------------------------------------------------------

/* static */
void CRange::_InitClass()
{
    _s_pMemCache = MemCache_New(32);
}

//+---------------------------------------------------------------------------
//
// _UninitClass
//
//----------------------------------------------------------------------------

/* static */
void CRange::_UninitClass()
{
    if (_s_pMemCache == NULL)
        return;

    MemCache_Delete(_s_pMemCache);
    _s_pMemCache = NULL;
}

//+---------------------------------------------------------------------------
//
// _Init
//
// NB: If fSetDefaultGravity == TRUE, make certain paStart <= paEnd, or you
// will break something!
//----------------------------------------------------------------------------

BOOL CRange::_Init(CInputContext *pic, AnchorOwnership ao, IAnchor *paStart, IAnchor *paEnd, RInit rinit)
{
    TsGravity gStart;
    TsGravity gEnd;

    // can't check the anchors because we may be cloned from a range with crossed anchors
    // can't do anything about crossed anchors until we know we have a doc lock
    //Assert(CompareAnchors(paStart, paEnd) <= 0);

    Assert(_paStart == NULL);
    Assert(_paEnd == NULL);
    Assert(_fDirty == FALSE);
    Assert(_nextOnChangeRangeInIcsub == NULL);

    if (ao == OWN_ANCHORS)
    {
        _paStart = paStart;
        _paEnd = paEnd;
    }
    else
    {
        Assert(ao == COPY_ANCHORS);
        if (paStart->Clone(&_paStart) != S_OK || _paStart == NULL)
            goto ErrorExit;
        if (paEnd->Clone(&_paEnd) != S_OK || _paEnd == NULL)
            goto ErrorExit;
    }

    _pic = pic;

    switch (rinit)
    {
        case RINIT_DEF_GRAVITY:
            Assert(CompareAnchors(paStart, paEnd) <= 0); // Issue: this is only a safe assert for acp implementations

            if (_SetGravity(TF_GRAVITY_BACKWARD, TF_GRAVITY_FORWARD, FALSE) != S_OK)
                goto ErrorExit;
            break;

        case RINIT_GRAVITY:
            if (_paStart->GetGravity(&gStart) != S_OK)
                goto ErrorExit;
            if (_paEnd->GetGravity(&gEnd) != S_OK)
                goto ErrorExit;

            _InitLastLockReleaseId(gStart, gEnd);
            break;

        default:
            // caller must init _dwLastLockReleaseID!
            break;
    }

    _pic->AddRef();

    return TRUE;

ErrorExit:
    Assert(0);
    if (ao == COPY_ANCHORS)
    {
        SafeReleaseClear(_paStart);
        SafeReleaseClear(_paEnd);
    }
    return FALSE;
}

//+---------------------------------------------------------------------------
//
// dtor
//
//----------------------------------------------------------------------------

CRange::~CRange()
{
    _paStart->Release();
    _paEnd->Release();

    _pic->Release();

    Assert(_prgChangeSinks == NULL || _prgChangeSinks->Count() == 0); // all ITfRangeChangeSink's should have been unadvised
    delete _prgChangeSinks;
}

//+---------------------------------------------------------------------------
//
// IUnknown
//
//----------------------------------------------------------------------------

STDAPI CRange::QueryInterface(REFIID riid, void **ppvObj)
{
    CAnchorRef *par;

    if (&riid == &IID_PRIV_CRANGE ||
        IsEqualIID(riid, IID_PRIV_CRANGE))
    {
        *ppvObj = SAFECAST(this, CRange *);
        return S_OK; // No AddRef for IID_PRIV_CRANGE!  this is a private IID....
    }

    *ppvObj = NULL;

    if (IsEqualIID(riid, IID_ITfRange) ||
        IsEqualIID(riid, IID_IUnknown))
    {
        *ppvObj = SAFECAST(this, ITfRangeAnchor *);
    }
    else if (IsEqualIID(riid, IID_ITfRangeACP))
    {
        if ((par = GetCAnchorRef_NA(_paStart)) != NULL) // just a test to see if we're wrapping
        {
            *ppvObj = SAFECAST(this, ITfRangeACP *);
        }
    }
    else if (IsEqualIID(riid, IID_ITfRangeAnchor))
    {
        if ((par = GetCAnchorRef_NA(_paStart)) == NULL) // just a test to see if we're wrapping
        {
            *ppvObj = SAFECAST(this, ITfRangeAnchor *);
        }
    }
    else if (IsEqualIID(riid, IID_ITfSource))
    {
        *ppvObj = SAFECAST(this, ITfSource *);
    }

    if (*ppvObj)
    {
        AddRef();
        return S_OK;
    }

    return E_NOINTERFACE;
}

STDAPI_(ULONG) CRange::AddRef()
{
    return ++_cRef;
}

STDAPI_(ULONG) CRange::Release()
{
    long cr;

    cr = --_cRef;
    Assert(cr >= 0);

    if (cr == 0)
    {
        delete this;
    }

    return cr;
}

//+---------------------------------------------------------------------------
//
// _IsValidEditCookie
//
//----------------------------------------------------------------------------

BOOL CRange::_IsValidEditCookie(TfEditCookie ec, DWORD dwFlags)
{
    // any time someone is about to access the doc, we also need
    // to verify the last app edit didn't cross this range's anchors
    _QuickCheckCrossedAnchors();

    return _pic->_IsValidEditCookie(ec, dwFlags);
}

//+---------------------------------------------------------------------------
//
// _CheckCrossedAnchors
//
//----------------------------------------------------------------------------

void CRange::_CheckCrossedAnchors()
{
    DWORD dw;

    Assert(_dwLastLockReleaseID != IGNORE_LAST_LOCKRELEASED); // use _QuickCheckCrossedAnchors first!

#ifdef DEBUG
    // we shold only make is this far if this range has TF_GRAVITY_FORWARD,
    // TF_GRAVITY_BACKWARD otherwise we should never be able to get crossed
    // anchors.
    TsGravity gStart;
    TsGravity gEnd;

    _paStart->GetGravity(&gStart);
    _paEnd->GetGravity(&gEnd);

    Assert(gStart == TS_GR_FORWARD && gEnd == TS_GR_BACKWARD);
#endif // DEBUG

    dw = _pic->_GetLastLockReleaseID();
    Assert(dw != IGNORE_LAST_LOCKRELEASED);

    if (_dwLastLockReleaseID == dw)
        return;

    _dwLastLockReleaseID = dw;

    if (CompareAnchors(_paStart, _paEnd) > 0)
    {
        // for crossed anchors, we always move the start anchor to the end pos -- ie, don't move
        _paStart->ShiftTo(_paEnd);
    }
}


//+---------------------------------------------------------------------------
//
// GetText
//
//----------------------------------------------------------------------------

STDAPI CRange::GetText(TfEditCookie ec, DWORD dwFlags, WCHAR *pch, ULONG cchMax, ULONG *pcch)
{
    HRESULT hr;
    BOOL fMove;

    Perf_IncCounter(PERF_RGETTEXT_COUNT);

    if (pcch == NULL)
        return E_INVALIDARG;

    *pcch = 0;

    if (dwFlags & ~(TF_TF_MOVESTART | TF_TF_IGNOREEND))
        return E_INVALIDARG;

    if (!_IsValidEditCookie(ec, TF_ES_READ))
    {
        Assert(0);
        return TF_E_NOLOCK;
    }

    fMove = (dwFlags & TF_TF_MOVESTART);

    hr = _pic->_ptsi->GetText(0, _paStart, (dwFlags & TF_TF_IGNOREEND) ? NULL : _paEnd, pch, cchMax, pcch, fMove);

    if (hr != S_OK)
    {
        hr = E_FAIL;
    }

    // don't let the start advance past the end
    if (fMove && CompareAnchors(_paStart, _paEnd) > 0)
    {
        _paEnd->ShiftTo(_paStart);
    }

    return hr;
}

//+---------------------------------------------------------------------------
//
// SetText
//
//----------------------------------------------------------------------------

STDAPI CRange::SetText(TfEditCookie ec, DWORD dwFlags, const WCHAR *pchText, LONG cch)
{
    CComposition *pComposition;
    HRESULT hr;
    BOOL fNewComposition;

    Perf_IncCounter(PERF_RSETTEXT_COUNT);

    if (pchText == NULL && cch != 0)
        return E_INVALIDARG;

    if ((dwFlags & ~TF_ST_CORRECTION) != 0)
        return E_INVALIDARG;

    if (!_IsValidEditCookie(ec, TF_ES_READWRITE))
    {
        Assert(0);
        return TF_E_NOLOCK;
    }

    hr = _PreEditCompositionCheck(ec, &pComposition, &fNewComposition);

    if (hr != S_OK)
        return hr;

    if (cch < 0)
    {
        cch = wcslen(pchText);
    }

#ifdef DEBUG
    for (LONG i=0; i<cch; i++)
    {        
        Assert(pchText[i] != TF_CHAR_EMBEDDED); // illegal to insert TF_CHAR_EMBEDDED!
        Assert(pchText[i] != TS_CHAR_REGION); // illegal to insert TS_CHAR_REGION!
    }
#endif

    //
    // set the text
    //

    hr = _pic->_ptsi->SetText(dwFlags, _paStart, _paEnd, pchText ? pchText : L"", cch);

    if (hr == S_OK)
    {
        _pic->_DoPostTextEditNotifications(pComposition, ec, dwFlags, cch, NULL, NULL, this);
    }

    // terminate the default composition, if there is one
    if (fNewComposition)
    {
        Assert(pComposition != NULL);
        pComposition->EndComposition(ec);
        pComposition->Release(); // don't need Release if !fNewComposition
    }

    return hr;
}

//+---------------------------------------------------------------------------
//
// GetEmbedded
//
//----------------------------------------------------------------------------

STDAPI CRange::GetEmbedded(TfEditCookie ec, REFGUID rguidService, REFIID riid, IUnknown **ppunk)
{
    if (ppunk == NULL)
        return E_INVALIDARG;

    *ppunk = NULL;

    if (!_IsValidEditCookie(ec, TF_ES_READ))
    {
        Assert(0);
        return TF_E_NOLOCK;
    }

    return _pic->_ptsi->GetEmbedded(0, _paStart, rguidService, riid, ppunk);
}

//+---------------------------------------------------------------------------
//
// Clone
//
//----------------------------------------------------------------------------

STDAPI CRange::InsertEmbedded(TfEditCookie ec, DWORD dwFlags, IDataObject *pDataObject)
{
    CComposition *pComposition;
    BOOL fNewComposition;
    HRESULT hr;

    if ((dwFlags & ~TF_IE_CORRECTION) != 0)
        return E_INVALIDARG;

    if (pDataObject == NULL)
        return E_INVALIDARG;

    if (!_IsValidEditCookie(ec, TF_ES_READWRITE))
    {
        Assert(0);
        return TF_E_NOLOCK;
    }

    hr = _PreEditCompositionCheck(ec, &pComposition, &fNewComposition);

    if (hr != S_OK)
        return hr;

    hr = _pic->_ptsi->InsertEmbedded(dwFlags, _paStart, _paEnd, pDataObject);

    if (hr == S_OK)
    {
        _pic->_DoPostTextEditNotifications(pComposition, ec, dwFlags, 1, NULL, NULL, this);
    }

    // terminate the default composition, if there is one
    if (fNewComposition)
    {
        Assert(pComposition != NULL);
        pComposition->EndComposition(ec);
        pComposition->Release(); // don't need Release if !fNewComposition
    }

    return hr;
}

//+---------------------------------------------------------------------------
//
// GetFormattedText
//
//----------------------------------------------------------------------------

STDAPI CRange::GetFormattedText(TfEditCookie ec, IDataObject **ppDataObject)
{
    if (ppDataObject == NULL)
        return E_INVALIDARG;

    *ppDataObject = NULL;

    if (!_IsValidEditCookie(ec, TF_ES_READ))
    {
        Assert(0);
        return TF_E_NOLOCK;
    }

    return _pic->_ptsi->GetFormattedText(_paStart, _paEnd, ppDataObject);
}

//+---------------------------------------------------------------------------
//
// Clone
//
//----------------------------------------------------------------------------

STDAPI CRange::Clone(ITfRange **ppClone)
{
    if (ppClone == NULL)
        return E_INVALIDARG;

    return (*ppClone = (ITfRangeAnchor *)_Clone()) ? S_OK : E_OUTOFMEMORY;
}

//+---------------------------------------------------------------------------
//
// GetContext
//
//----------------------------------------------------------------------------

STDAPI CRange::GetContext(ITfContext **ppContext)
{
    if (ppContext == NULL)
        return E_INVALIDARG;

    *ppContext = _pic;
    if (*ppContext)
    {
       (*ppContext)->AddRef();
       return S_OK;
    }

    return E_FAIL;
}

//+---------------------------------------------------------------------------
//
// ShiftStart
//
//----------------------------------------------------------------------------

STDAPI CRange::ShiftStart(TfEditCookie ec, LONG cchReq, LONG *pcch, const TF_HALTCOND *pHalt)
{
    CRange *pRangeP;
    IAnchor *paLimit;
    IAnchor *paShift;
    HRESULT hr;

    Perf_IncCounter(PERF_SHIFTSTART_COUNT);

    if (pcch == NULL)
        return E_INVALIDARG;

    *pcch = 0;

    if (pHalt != NULL && (pHalt->dwFlags & ~TF_HF_OBJECT))
        return E_INVALIDARG;

    if (!_IsValidEditCookie(ec, TF_ES_READ))
    {
        Assert(0);
        return TF_E_NOLOCK;
    }

    paLimit = NULL;

    if (pHalt != NULL && pHalt->pHaltRange != NULL)
    {
        if ((pRangeP = GetCRange_NA(pHalt->pHaltRange)) == NULL)
            return E_FAIL;

        paLimit = (pHalt->aHaltPos == TF_ANCHOR_START) ? pRangeP->_GetStart() : pRangeP->_GetEnd();
    }

    if (pHalt == NULL || pHalt->dwFlags == 0)
    {
        // caller doesn't care about special chars, so we can do it the easy way
        hr = _paStart->Shift(0, cchReq, pcch, paLimit);
    }
    else
    {
        // caller wants us to halt for special chars, need to read text
        if (_paStart->Clone(&paShift) != S_OK)
            return E_FAIL;

        hr = _ShiftConditional(paShift, paLimit, cchReq, pcch, pHalt);

        if (hr == S_OK)
        {
            hr = _paStart->ShiftTo(paShift);
        }
        paShift->Release();
    }

    if (hr != S_OK)
        return E_FAIL;

    // don't let the start advance past the end
    if (cchReq > 0 && CompareAnchors(_paStart, _paEnd) > 0)
    {
        _paEnd->ShiftTo(_paStart);
    }

    return S_OK;
}

//+---------------------------------------------------------------------------
//
// ShiftEnd
//
//----------------------------------------------------------------------------

STDAPI CRange::ShiftEnd(TfEditCookie ec, LONG cchReq, LONG *pcch, const TF_HALTCOND *pHalt)
{
    CRange *pRangeP;
    IAnchor *paLimit;
    IAnchor *paShift;
    HRESULT hr;

    Perf_IncCounter(PERF_SHIFTEND_COUNT);

    if (pcch == NULL)
        return E_INVALIDARG;

    *pcch = 0;

    if (pHalt != NULL && (pHalt->dwFlags & ~TF_HF_OBJECT))
        return E_INVALIDARG;

    if (!_IsValidEditCookie(ec, TF_ES_READ))
    {
        Assert(0);
        return TF_E_NOLOCK;
    }

    paLimit = NULL;

    if (pHalt != NULL && pHalt->pHaltRange != NULL)
    {
        if ((pRangeP = GetCRange_NA(pHalt->pHaltRange)) == NULL)
            return E_FAIL;

        paLimit = (pHalt->aHaltPos == TF_ANCHOR_START) ? pRangeP->_GetStart() : pRangeP->_GetEnd();
    }

    if (pHalt == NULL || pHalt->dwFlags == 0)
    {
        // caller doesn't care about special chars, so we can do it the easy way
        hr = _paEnd->Shift(0, cchReq, pcch, paLimit);
    }
    else
    {
        // caller wants us to halt for special chars, need to read text
        if (_paEnd->Clone(&paShift) != S_OK)
            return E_FAIL;

        hr = _ShiftConditional(paShift, paLimit, cchReq, pcch, pHalt);

        if (hr == S_OK)
        {
            hr = _paEnd->ShiftTo(paShift);
        }
        paShift->Release();
    }

    if (hr != S_OK)
        return E_FAIL;

    // don't let the start advance past the end
    if (cchReq < 0 && CompareAnchors(_paStart, _paEnd) > 0)
    {
        _paStart->ShiftTo(_paEnd);
    }

    return S_OK;
}

//+---------------------------------------------------------------------------
//
// _ShiftConditional
//
//----------------------------------------------------------------------------

HRESULT CRange::_ShiftConditional(IAnchor *paStart, IAnchor *paLimit, LONG cchReq, LONG *pcch, const TF_HALTCOND *pHalt)
{
    HRESULT hr;
    ITextStoreAnchor *ptsi;
    LONG cchRead;
    LONG cch;
    LONG i;
    LONG iStop;
    LONG delta;
    BOOL fHaltObj;
    WCHAR ach[64];

    Assert(*pcch == 0);
    Assert(pHalt && pHalt->dwFlags);

    hr = S_OK;
    ptsi = _pic->_ptsi;
    fHaltObj = pHalt->dwFlags & TF_HF_OBJECT;
    delta = (cchReq > 0) ? +1 : -1;

    while (cchReq != 0)
    {
        if (cchReq > 0)
        {
            cch = (LONG)min(cchReq, ARRAYSIZE(ach));
        }
        else
        {
            // going backwards is tricky!
            cch = max(cchReq, -(LONG)ARRAYSIZE(ach));
            hr = paStart->Shift(0, cch, &cchRead, paLimit);

            if (hr != S_OK)
                break;

            if (cchRead == 0)
                break; // at top of doc or hit paLimit

            cch = -cchRead; // must read text forward
        }

        Perf_IncCounter(PERF_SHIFTCOND_GETTEXT);

        hr = ptsi->GetText(0, paStart, paLimit, ach, cch, (ULONG *)&cchRead, (cchReq > 0));

        if (hr != S_OK)
            break;

        if (cchRead == 0)
            break; // end of doc

        if (fHaltObj)
        {
            // scan for special chars
            if (cchReq > 0)
            {
                // scan left-to-right
                i = 0;
                iStop = cchRead;
            }
            else
            {
                // scan right-to-left
                i = cchRead - 1;
                iStop = -1;
            }

            for (; i != iStop; i += delta)
            {
                if (ach[i] == TS_CHAR_EMBEDDED)
                {
                    if (cchReq > 0)
                    {
                        hr = paStart->Shift(0, i - cchRead, &cch, NULL);
                        cchReq = cchRead = i;
                    }
                    else
                    {
                        hr = paStart->Shift(0, i + 1, &cch, NULL);
                        cchRead -= i + 1;
                        cchReq = -cchRead;
                    }
                    goto ExitLoop;
                }
            }
        }

ExitLoop:
        if (cchReq < 0)
        {
            cchRead = -cchRead;
        }
        cchReq -= cchRead;
        *pcch += cchRead;
    }

    if (hr != S_OK)
    {
        *pcch = 0;
    }

    return hr;
}

//+---------------------------------------------------------------------------
//
// ShiftStartToRange
//
//----------------------------------------------------------------------------

STDAPI CRange::ShiftStartToRange(TfEditCookie ec, ITfRange *pRange, TfAnchor aPos)
{
    CRange *pRangeP;
    HRESULT hr;

    if (pRange == NULL)
        return E_INVALIDARG;

    if (!_IsValidEditCookie(ec, TF_ES_READ))
    {
        Assert(0);
        return TF_E_NOLOCK;
    }

    if ((pRangeP = GetCRange_NA(pRange)) == NULL)
        return E_INVALIDARG;

    if (!VerifySameContext(this, pRangeP))
        return E_INVALIDARG;

    pRangeP->_QuickCheckCrossedAnchors();

    hr = _paStart->ShiftTo((aPos == TF_ANCHOR_START) ? pRangeP->_GetStart() : pRangeP->_GetEnd());

    // don't let the start advance past the end
    if (CompareAnchors(_paStart, _paEnd) > 0)
    {
        _paEnd->ShiftTo(_paStart);
    }

    return hr;
}

//+---------------------------------------------------------------------------
//
// ShiftEndToRange
//
//----------------------------------------------------------------------------

STDAPI CRange::ShiftEndToRange(TfEditCookie ec, ITfRange *pRange, TfAnchor aPos)
{
    CRange *pRangeP;
    HRESULT hr;

    if (pRange == NULL)
        return E_INVALIDARG;

    if (!_IsValidEditCookie(ec, TF_ES_READ))
    {
        Assert(0);
        return TF_E_NOLOCK;
    }

    if ((pRangeP = GetCRange_NA(pRange)) == NULL)
        return E_FAIL;

    if (!VerifySameContext(this, pRangeP))
        return E_INVALIDARG;

    pRangeP->_QuickCheckCrossedAnchors();

    hr = _paEnd->ShiftTo((aPos == TF_ANCHOR_START) ? pRangeP->_GetStart() : pRangeP->_GetEnd());

    // don't let the end advance past the start
    if (CompareAnchors(_paStart, _paEnd) > 0)
    {
        _paStart->ShiftTo(_paEnd);
    }

    return hr;
}

//+---------------------------------------------------------------------------
//
// ShiftStartRegion
//
//----------------------------------------------------------------------------

STDAPI CRange::ShiftStartRegion(TfEditCookie ec, TfShiftDir dir, BOOL *pfNoRegion)
{
    HRESULT hr;

    if (pfNoRegion == NULL)
        return E_INVALIDARG;

    *pfNoRegion = TRUE;

    if (!_IsValidEditCookie(ec, TF_ES_READ))
    {
        Assert(0);
        return TF_E_NOLOCK;
    }

    hr = _paStart->ShiftRegion(0, (TsShiftDir)dir, pfNoRegion);

    if (hr == S_OK && dir == TF_SD_FORWARD && !*pfNoRegion)
    {
        // don't let the start advance past the end
        if (CompareAnchors(_paStart, _paEnd) > 0)
        {
            _paEnd->ShiftTo(_paStart);
        }
    }
    else if (hr == E_NOTIMPL)
    {
        // app doesn't support regions, so we can still succeed
        // it's just that there's no region to shift over
        *pfNoRegion = TRUE; // be paranoid, the app could be wacky
        hr = S_OK;
    }

    return hr;
}

//+---------------------------------------------------------------------------
//
// ShiftEndRegion
//
//----------------------------------------------------------------------------

STDAPI CRange::ShiftEndRegion(TfEditCookie ec, TfShiftDir dir, BOOL *pfNoRegion)
{
    HRESULT hr;

    if (pfNoRegion == NULL)
        return E_INVALIDARG;

    *pfNoRegion = TRUE;

    if (!_IsValidEditCookie(ec, TF_ES_READ))
    {
        Assert(0);
        return TF_E_NOLOCK;
    }

    hr = _paEnd->ShiftRegion(0, (TsShiftDir)dir, pfNoRegion);

    if (hr == S_OK && dir == TF_SD_BACKWARD && !*pfNoRegion)
    {
        // don't let the end advance past the start
        if (CompareAnchors(_paStart, _paEnd) > 0)
        {
            _paStart->ShiftTo(_paEnd);
        }
    }
    else if (hr == E_NOTIMPL)
    {
        // app doesn't support regions, so we can still succeed
        // it's just that there's no region to shift over
        *pfNoRegion = TRUE; // be paranoid, the app could be wacky
        hr = S_OK;
    }

    return hr;
}

//+---------------------------------------------------------------------------
//
// _SnapToRegion
//
//----------------------------------------------------------------------------

#if 0

HRESULT CRange::_SnapToRegion(DWORD dwFlags)
{
    ITfRange *range;
    TF_HALTCOND hc;
    LONG cch;
    HRESULT hr;

    if (Clone(&range) != S_OK)
        return E_OUTOFMEMORY;

    hc.pHaltRange = (ITfRangeAnchor *)this;
    hc.dwFlags = 0;

    if (dwFlags & TF_GS_SNAPREGION_START)
    {
        if ((hr = range->Collapse(BACKDOOR_EDIT_COOKIE, TF_ANCHOR_START)) != S_OK)
            goto Exit;

        hc.aHaltPos = TF_ANCHOR_END;

        do
        {
            if ((hr = range->ShiftEnd(BACKDOOR_EDIT_COOKIE, LONG_MAX, &cch, &hc)) != S_OK)
                goto Exit;
        }
        while (cch >= LONG_MAX); // just in case this is a _really_ huge doc

        hr = ShiftEndToRange(BACKDOOR_EDIT_COOKIE, range, TF_ANCHOR_END);
    }
    else
    {
        Assert(dwFlags & TF_GS_SNAPREGION_END);

        if ((hr = range->Collapse(BACKDOOR_EDIT_COOKIE, TF_ANCHOR_END)) != S_OK)
            goto Exit;

        hc.aHaltPos = TF_ANCHOR_START;

        do
        {
            if ((hr = range->ShiftStart(BACKDOOR_EDIT_COOKIE, LONG_MIN, &cch, &hc)) != S_OK)
                goto Exit;
        }
        while (cch <= LONG_MIN); // just in case this is a _really_ huge doc

        hr = ShiftStartToRange(BACKDOOR_EDIT_COOKIE, range, TF_ANCHOR_START);
    }

Exit:
    if (hr != S_OK)
    {
        hr = E_FAIL;
    }

    range->Release();

    return hr;
}

#endif // 0

//+---------------------------------------------------------------------------
//
// IsEmpty
//
//----------------------------------------------------------------------------

STDAPI CRange::IsEmpty(TfEditCookie ec, BOOL *pfEmpty)
{
    return IsEqualStart(ec, (ITfRangeAnchor *)this, TF_ANCHOR_END, pfEmpty);
}

//+---------------------------------------------------------------------------
//
// Collapse
//
//----------------------------------------------------------------------------

STDAPI CRange::Collapse(TfEditCookie ec, TfAnchor aPos)
{
    if (!_IsValidEditCookie(ec, TF_ES_READ))
    {
        Assert(0);
        return TF_E_NOLOCK;
    }

    return (aPos == TF_ANCHOR_START) ? _paEnd->ShiftTo(_paStart) : _paStart->ShiftTo(_paEnd);
}

//+---------------------------------------------------------------------------
//
// IsEqualStart
//
//----------------------------------------------------------------------------

STDAPI CRange::IsEqualStart(TfEditCookie ec, ITfRange *pWith, TfAnchor aPos, BOOL *pfEqual)
{
    return _IsEqualX(ec, TF_ANCHOR_START, pWith, aPos, pfEqual);
}

//+---------------------------------------------------------------------------
//
// IsEqualEnd
//
//----------------------------------------------------------------------------

STDAPI CRange::IsEqualEnd(TfEditCookie ec, ITfRange *pWith, TfAnchor aPos, BOOL *pfEqual)
{
    return _IsEqualX(ec, TF_ANCHOR_END, pWith, aPos, pfEqual);
}

//+---------------------------------------------------------------------------
//
// _IsEqualX
//
//----------------------------------------------------------------------------

HRESULT CRange::_IsEqualX(TfEditCookie ec, TfAnchor aPosThisRange, ITfRange *pWith, TfAnchor aPos, BOOL *pfEqual)
{
    LONG lComp;
    HRESULT hr;

    if (pfEqual == NULL)
        return E_INVALIDARG;

    *pfEqual = FALSE;

    // perf: we could check TS_SS_NOHIDDENTEXT for better perf
    hr = _CompareX(ec, aPosThisRange, pWith, aPos, &lComp);

    if (hr != S_OK)
        return hr;

    *pfEqual = (lComp == 0);
    return S_OK;
}

//+---------------------------------------------------------------------------
//
// CompareStart
//
//----------------------------------------------------------------------------

STDAPI CRange::CompareStart(TfEditCookie ec, ITfRange *pWith, TfAnchor aPos, LONG *plResult)
{
    return _CompareX(ec, TF_ANCHOR_START, pWith, aPos, plResult);
}

//+---------------------------------------------------------------------------
//
// CompareEnd
//
//----------------------------------------------------------------------------

STDAPI CRange::CompareEnd(TfEditCookie ec, ITfRange *pWith, TfAnchor aPos, LONG *plResult)
{
    return _CompareX(ec, TF_ANCHOR_END, pWith, aPos, plResult);
}

//+---------------------------------------------------------------------------
//
// _CompareX
//
//----------------------------------------------------------------------------

HRESULT CRange::_CompareX(TfEditCookie ec, TfAnchor aPosThisRange, ITfRange *pWith, TfAnchor aPos, LONG *plResult)
{
    CRange *pRangeP;
    IAnchor *paThis;
    IAnchor *paWith;
    IAnchor *paTest;
    LONG lComp;
    LONG cch;
    BOOL fEqual;
    HRESULT hr;

    if (plResult == NULL)
        return E_INVALIDARG;

    *plResult = 0;

    if (!_IsValidEditCookie(ec, TF_ES_READ))
    {
        Assert(0);
        return TF_E_NOLOCK;
    }

    if (pWith == NULL)
        return E_INVALIDARG;

    if ((pRangeP = GetCRange_NA(pWith)) == NULL)
        return E_INVALIDARG;

    if (!VerifySameContext(this, pRangeP))
        return E_INVALIDARG;

    pRangeP->_QuickCheckCrossedAnchors();

    paWith = (aPos == TF_ANCHOR_START) ? pRangeP->_GetStart() : pRangeP->_GetEnd();
    paThis = (aPosThisRange == TF_ANCHOR_START) ? _paStart : _paEnd;

    if (paThis->Compare(paWith, &lComp) != S_OK)
        return E_FAIL;

    if (lComp == 0) // exact match
    {
        Assert(*plResult == 0);
        return S_OK;
    }

    // we need to account for hidden text, so we actually have to do a shift
    // perf: we could check TS_SS_NOHIDDENTEXT for better perf

    if (paThis->Shift(TS_SHIFT_COUNT_ONLY, (lComp < 0) ? 1 : -1, &cch, paWith) != S_OK)
        return E_FAIL;

    if (cch == 0)
    {
        // nothing but hidden text between the two anchors?
        // one special case: we might have hit a region boundary
        if (paThis->Clone(&paTest) != S_OK || paTest == NULL)
            return E_FAIL;

        hr = E_FAIL;

        // if we're not at paWith after the shift, we must have hit a region
        if (paTest->Shift(0, (lComp < 0) ? 1 : -1, &cch, paWith) != S_OK)
            goto ReleaseTest;

        Assert(cch == 0);

        if (paTest->IsEqual(paWith, &fEqual) != S_OK)
            goto ReleaseTest;

        hr = S_OK;

ReleaseTest:
        paTest->Release();

        if (hr != S_OK)
            return E_FAIL;

        if (fEqual)
        {
            Assert(*plResult == 0);
            return S_OK;
        }
    }

    *plResult = lComp;
    return S_OK;
}

//+---------------------------------------------------------------------------
//
// GetGravity
//
//----------------------------------------------------------------------------

STDAPI CRange::AdjustForInsert(TfEditCookie ec, ULONG cchInsert, BOOL *pfInsertOk)
{
    TfGravity gStart;
    TfGravity gEnd;
    IAnchor *paStartResult;
    IAnchor *paEndResult;
    HRESULT hr;

    if (pfInsertOk == NULL)
        return E_INVALIDARG;

    *pfInsertOk = FALSE;

    if (!_IsValidEditCookie(ec, TF_ES_READ))
    {
        Assert(0);
        return TF_E_NOLOCK;
    }

    hr = _pic->_ptsi->QueryInsert(_paStart, _paEnd, cchInsert, &paStartResult, &paEndResult);

    if (hr == E_NOTIMPL)
    {
        // ok, just allow the request
        goto Exit;
    }
    else if (hr != S_OK)
    {
        Assert(*pfInsertOk == FALSE);
        return E_FAIL;
    }
    else if (paStartResult == NULL || paEndResult == NULL)
    {
        Assert(paEndResult == NULL);
        // NULL out params means no insert possible
        Assert(*pfInsertOk == FALSE);
        return S_OK;
    }

    // all set, just swap anchors and make sure gravity doesn't change
    GetGravity(&gStart, &gEnd);

    _paStart->Release();
    _paEnd->Release();
    _paStart = paStartResult;
    _paEnd = paEndResult;

    _SetGravity(gStart, gEnd, TRUE);

Exit:
    *pfInsertOk = TRUE;
    return S_OK;
}

//+---------------------------------------------------------------------------
//
// GetGravity
//
//----------------------------------------------------------------------------

STDAPI CRange::GetGravity(TfGravity *pgStart, TfGravity *pgEnd)
{
    TsGravity gStart;
    TsGravity gEnd;

    if (pgStart == NULL || pgEnd == NULL)
        return E_INVALIDARG;

    _paStart->GetGravity(&gStart);
    _paEnd->GetGravity(&gEnd);
    
    *pgStart = (gStart == TS_GR_BACKWARD) ? TF_GRAVITY_BACKWARD : TF_GRAVITY_FORWARD;
    *pgEnd = (gEnd == TS_GR_BACKWARD) ? TF_GRAVITY_BACKWARD : TF_GRAVITY_FORWARD;

    return S_OK;
}

//+---------------------------------------------------------------------------
//
// SetGravity
//
//----------------------------------------------------------------------------

STDAPI CRange::SetGravity(TfEditCookie ec, TfGravity gStart, TfGravity gEnd)
{
    if (!_IsValidEditCookie(ec, TF_ES_READ))
    {
        Assert(0);
        return TF_E_NOLOCK;
    }

    return _SetGravity(gStart, gEnd, TRUE);
}

//+---------------------------------------------------------------------------
//
// _SetGravity
//
//----------------------------------------------------------------------------

HRESULT CRange::_SetGravity(TfGravity gStart, TfGravity gEnd, BOOL fCheckCrossedAnchors)
{
    if (fCheckCrossedAnchors)
    {
        // make sure we're not crossed in case we're switching away from inward gravity
        _QuickCheckCrossedAnchors();
    }

    if (_paStart->SetGravity((TsGravity)gStart) != S_OK)
        return E_FAIL;
    if (_paEnd->SetGravity((TsGravity)gEnd) != S_OK)
        return E_FAIL;

    _InitLastLockReleaseId((TsGravity)gStart, (TsGravity)gEnd);

    return S_OK;
}

//+---------------------------------------------------------------------------
//
// AdviseSink
//
//----------------------------------------------------------------------------

STDAPI CRange::AdviseSink(REFIID riid, IUnknown *punk, DWORD *pdwCookie)
{
    const IID *rgiid = &IID_ITfRangeChangeSink;
    HRESULT hr;

    if (_prgChangeSinks == NULL)
    {
        // we delay allocate our sink container
        if ((_prgChangeSinks = new CStructArray<GENERICSINK>) == NULL)
            return E_OUTOFMEMORY;
    }

    hr = GenericAdviseSink(riid, punk, &rgiid, _prgChangeSinks, 1, pdwCookie);

    if (hr == S_OK && _prgChangeSinks->Count() == 1)
    {
        // add this range to the list of ranges with sinks in the icsub
        _nextOnChangeRangeInIcsub = _pic->_pOnChangeRanges;
        _pic->_pOnChangeRanges = this;

        // start tracking anchor collapses
        //_paStart->TrackCollapse(TRUE);
        //_paEnd->TrackCollapse(TRUE);
    }

    return hr;
}

//+---------------------------------------------------------------------------
//
// UnadviseSink
//
//----------------------------------------------------------------------------

STDAPI CRange::UnadviseSink(DWORD dwCookie)
{
    CRange *pRange;
    CRange **ppRange;
    HRESULT hr;

    if (_prgChangeSinks == NULL)
        return CONNECT_E_NOCONNECTION;

    hr = GenericUnadviseSink(_prgChangeSinks, 1, dwCookie);

    if (hr == S_OK && _prgChangeSinks->Count() == 0)
    {
        // remove this range from the list of ranges in its icsub
        ppRange = &_pic->_pOnChangeRanges;
        while (pRange = *ppRange)
        {
            if (pRange == this)
            {
                *ppRange = pRange->_nextOnChangeRangeInIcsub;
                break;
            }
            ppRange = &pRange->_nextOnChangeRangeInIcsub;
        }

        // stop tracking anchor collapses
        //_paStart->TrackCollapse(FALSE);
        //_paEnd->TrackCollapse(FALSE);
    }

    return hr;
}

//+---------------------------------------------------------------------------
//
// GetExtent
//
//----------------------------------------------------------------------------

STDAPI CRange::GetExtent(LONG *pacpAnchor, LONG *pcch)
{
    CAnchorRef *par;
    HRESULT hr = E_FAIL;

    if (pacpAnchor == NULL || pcch == NULL)
        return E_INVALIDARG;

    *pacpAnchor = 0;
    *pcch = 0;

    // make the validation call anyways because we do other stuff in there
    _IsValidEditCookie(BACKDOOR_EDIT_COOKIE, TF_ES_READ);

    if ((par = GetCAnchorRef_NA(_paStart)) != NULL)
    {
        // we have a wrapped ACP impl, this is easy

        *pacpAnchor = par->_GetACP();

        if ((par = GetCAnchorRef_NA(_paEnd)) == NULL)
            goto ErrorExit;

        *pcch = par->_GetACP() - *pacpAnchor;

        hr = S_OK;
    }
    else
    {
        Assert(0); // who's doing this?
        // we fail if someone tries to do GetExtentACP on a
        // non-acp text store.  Users of this method should
        // be aware of whether or not they are using an acp
        // store.
    }

    return hr;

ErrorExit:
    *pacpAnchor = 0;
    *pcch = 0;
    return E_FAIL;
}

//+---------------------------------------------------------------------------
//
// GetExtent
//
//----------------------------------------------------------------------------

STDAPI CRange::GetExtent(IAnchor **ppaStart, IAnchor **ppaEnd)
{
    if (ppaStart == NULL || ppaEnd == NULL)
        return E_INVALIDARG;

    *ppaStart = NULL;
    *ppaEnd = NULL;

    // make the validation call anyways because we do other stuff in there
    _IsValidEditCookie(BACKDOOR_EDIT_COOKIE, TF_ES_READ);

    if (_paStart->Clone(ppaStart) != S_OK)
        return E_FAIL;

    if (_paEnd->Clone(ppaEnd) != S_OK)
    {
        SafeReleaseClear(*ppaStart);
        return E_FAIL;
    }

    return S_OK;
}

//+---------------------------------------------------------------------------
//
// SetExtent
//
//----------------------------------------------------------------------------

STDAPI CRange::SetExtent(LONG acpAnchor, LONG cch)
{
    CAnchorRef *par;
    IAnchor *paStart;
    IAnchor *paEnd;

    // make the validation call anyways because we do other stuff in there
    _IsValidEditCookie(BACKDOOR_EDIT_COOKIE, TF_ES_READ);

    if (acpAnchor < 0 || cch < 0)
        return E_INVALIDARG;

    paStart = paEnd = NULL;

    if ((par = GetCAnchorRef_NA(_paStart)) != NULL)
    {
        // we have a wrapped ACP impl, this is easy

        // need to work with Clones to handle failure gracefully
        if (FAILED(_paStart->Clone(&paStart)))
            goto ErrorExit;

        if ((par = GetCAnchorRef_NA(paStart)) == NULL)
            goto ErrorExit;

        if (!par->_SetACP(acpAnchor))
            goto ErrorExit;

        if (FAILED(_paEnd->Clone(&paEnd)))
            goto ErrorExit;

        if ((par = GetCAnchorRef_NA(paEnd)) == NULL)
            goto ErrorExit;

        if (!par->_SetACP(acpAnchor + cch))
            goto ErrorExit;
    }
    else
    {
        Assert(0); // who's doing this?
        // we fail if someone tries to do SetExtentACP on a
        // non-acp text store.  Users of this method should
        // be aware of whether or not they are using an acp
        // store.
        goto ErrorExit;
    }

    SafeRelease(_paStart);
    SafeRelease(_paEnd);
    _paStart = paStart;
    _paEnd = paEnd;

    return S_OK;

ErrorExit:
    SafeRelease(paStart);
    SafeRelease(paEnd);
    return E_FAIL;
}

//+---------------------------------------------------------------------------
//
// SetExtent
//
//----------------------------------------------------------------------------

STDAPI CRange::SetExtent(IAnchor *paStart, IAnchor *paEnd)
{
    IAnchor *paStartClone;
    IAnchor *paEndClone;

    // make the validation call anyways because we do other stuff in there
    _IsValidEditCookie(BACKDOOR_EDIT_COOKIE, TF_ES_READ);

    if (paStart == NULL || paEnd == NULL)
        return E_INVALIDARG;

    if (CompareAnchors(paStart, paEnd) > 0)
        return E_INVALIDARG;
        
    if (paStart->Clone(&paStartClone) != S_OK)
        return E_FAIL;

    if (paEnd->Clone(&paEndClone) != S_OK)
    {
        paStartClone->Release();
        return E_FAIL;
    }

    SafeRelease(_paStart);
    SafeRelease(_paEnd);

    _paStart = paStartClone;   
    _paEnd = paEndClone;

    return S_OK;
}

//+---------------------------------------------------------------------------
//
// _PreEditCompositionCheck
//
//----------------------------------------------------------------------------

HRESULT CRange::_PreEditCompositionCheck(TfEditCookie ec, CComposition **ppComposition, BOOL *pfNewComposition)
{
    IRC irc;

    // any active compositions?
    *pfNewComposition = FALSE;
    irc = CComposition::_IsRangeCovered(_pic, _pic->_GetClientInEditSession(ec), _paStart, _paEnd, ppComposition);

    if (irc == IRC_COVERED)
    {
        // this range is within an owned composition
        Assert(*ppComposition != NULL);
        return S_OK;
    }
    else if (irc == IRC_OUTSIDE)
    {
        // the caller owns compositions, but this range isn't wholly within them
        return TF_E_RANGE_NOT_COVERED;
    }
    else
    {
        Assert(irc == IRC_NO_OWNEDCOMPOSITIONS);
    }

    // not covered, need to create a default composition
    if (_pic->_StartComposition(ec, _paStart, _paEnd, NULL, ppComposition) != S_OK)
        return E_FAIL;

    if (*ppComposition != NULL)
    {
        *pfNewComposition = TRUE;
        return S_OK;
    }

    return TF_E_COMPOSITION_REJECTED;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\ctf\uim\rngsink.cpp ===
//
// readrng.cpp
//

#include "private.h"
#include "globals.h"
#include "rngsink.h"
#include "immxutil.h"
#include "catmgr.h"
#include "rprop.h"
#include "proputil.h"

/* f66ee5c0-fe8c-11d2-8ded-00105a2799b5 */
static const IID IID_CGeneralPropStore = { 
    0xf66ee5c0,
    0xfe8c,
    0x11d2,
    {0x8d, 0xed, 0x00, 0x10, 0x5a, 0x27, 0x99, 0xb5}
  };

DBG_ID_INSTANCE(CGeneralPropStore);
DBG_ID_INSTANCE(CStaticPropStore);

//////////////////////////////////////////////////////////////////////////////
//
// CGeneralPropStore
//
//////////////////////////////////////////////////////////////////////////////

//+---------------------------------------------------------------------------
//
// _Init
//
//----------------------------------------------------------------------------

BOOL CGeneralPropStore::_Init(TfGuidAtom guidatom, const VARIANT *pvarValue, DWORD dwPropFlags)
{
    _guidatom = guidatom;

    _dwPropFlags  = dwPropFlags;

    return (VariantToTfProp(&_prop, 
                    pvarValue, 
                    ADDREF, 
                    (dwPropFlags & PROPF_VTI4TOGUIDATOM))
            == S_OK);
}

BOOL CGeneralPropStore::_Init(TfGuidAtom guidatom, TFPROPERTY *ptfp, DWORD dwPropFlags)
{
    _guidatom = guidatom;
    _dwPropFlags  = dwPropFlags;

    _prop = *ptfp;

    switch (_prop.type)
    {
        case TF_PT_UNKNOWN:
            _prop.punk->AddRef();
            break;

        case TF_PT_BSTR:
            if ((_prop.bstr = SysAllocString(ptfp->bstr)) == NULL)
                return FALSE;
            break;

        case TF_PT_PROXY:
            if ((_prop.blob = PROXY_BLOB::Clone(ptfp->blob)) == NULL)
                return FALSE;
            break;
    }

    return TRUE;
}

BOOL CGeneralPropStore::_Init(TfGuidAtom guidatom, int iDataSize, TfPropertyType proptype, IStream *pStream, DWORD dwPropFlags)
{
    GUID guid;
    TfGuidAtom gaTmp;
    BOOL fRet;

    _guidatom = guidatom;
    _dwPropFlags  = dwPropFlags;
    _prop.type = proptype;

    fRet = FALSE; // failure

    switch (proptype)
    {
        case TF_PT_DWORD:
            if (iDataSize != sizeof(DWORD))
                break;

            fRet = SUCCEEDED(pStream->Read((void *)&_prop.dw, iDataSize, NULL));
            break;

        case TF_PT_GUID:
            if (iDataSize != sizeof(GUID))
                break;

            if (FAILED(pStream->Read((void *)&guid, iDataSize, NULL)))
                break;

            CCategoryMgr::s_RegisterGUID(guid, &gaTmp);
            _prop.guidatom = gaTmp;

            fRet = TRUE;
            break;

        case TF_PT_BSTR:
            _prop.bstr = SysAllocStringLen(NULL, iDataSize / sizeof(WCHAR));

            if (_prop.bstr == NULL)
                break;

            if (FAILED(pStream->Read((void *)_prop.bstr, iDataSize, NULL)))
            {
                SysFreeString(_prop.bstr);
                _prop.bstr = NULL;
                break;
            }

            fRet = TRUE;
            break;

        case TF_PT_PROXY:
            // just copy the bytes blindly, we won't do anything with them
            if ((_prop.blob = PROXY_BLOB::Alloc(iDataSize)) == NULL)
                break;

            if (FAILED(pStream->Read(_prop.blob->rgBytes, iDataSize, NULL)))
            {
                cicMemFree(_prop.blob);
                _prop.blob = NULL;
            }

            _prop.blob->cb = iDataSize;

            fRet = TRUE;
            break;

        case TF_PT_NONE:
            Assert(0);
            break;
    }

    return fRet;
}

//+---------------------------------------------------------------------------
//
// dtor
//
//----------------------------------------------------------------------------

CGeneralPropStore::~CGeneralPropStore()
{
    switch (_prop.type)
    {
        case TF_PT_UNKNOWN:
            SafeRelease(_prop.punk);
            break;

        case TF_PT_BSTR:
            SysFreeString(_prop.bstr);
            break;

        case TF_PT_PROXY:
            PROXY_BLOB::Free(_prop.blob);
            break;
    }
}

//+---------------------------------------------------------------------------
//
// GetType
//
//----------------------------------------------------------------------------

STDAPI CGeneralPropStore::GetType(GUID *pguid)
{
    return MyGetGUID(_guidatom, pguid);
}

//+---------------------------------------------------------------------------
//
// GetDataType
//
//----------------------------------------------------------------------------

STDAPI CGeneralPropStore::GetDataType(DWORD *pdwReserved)
{
    if (pdwReserved == NULL)
        return E_INVALIDARG;

    *pdwReserved = _prop.type;
    return S_OK;
}

//+---------------------------------------------------------------------------
//
// GetData
//
//----------------------------------------------------------------------------

STDAPI CGeneralPropStore::GetData(VARIANT *pvarValue)
{
    if (pvarValue == NULL)
        return E_INVALIDARG;

    return TfPropToVariant(pvarValue, &_prop, ADDREF);
}

//+---------------------------------------------------------------------------
//
// OnTextUpdated
//
//----------------------------------------------------------------------------

STDAPI CGeneralPropStore::OnTextUpdated(DWORD dwFlags, ITfRange *pRange, BOOL *pfAccept)
{
    // This PropStore does not support TextUpdate.
    // leave the ink alone if it's a correction
    if (_dwPropFlags & PROPF_ACCEPTCORRECTION)
        *pfAccept = (dwFlags & TF_TU_CORRECTION);
    else
        *pfAccept = FALSE;
    return S_OK;
}

//+---------------------------------------------------------------------------
//
// Shrink
//
//----------------------------------------------------------------------------

STDAPI CGeneralPropStore::Shrink(ITfRange *pRange, BOOL *pfFree)
{
    // This PropStore does not support Shrink.
    *pfFree = TRUE;
    return S_OK;
}

//+---------------------------------------------------------------------------
//
// Divide
//
//----------------------------------------------------------------------------

STDAPI CGeneralPropStore::Divide(ITfRange *pRangeThis, ITfRange *pRangeNew, ITfPropertyStore **ppPropStore)
{
    //
    // This PropStore does not support Divide.
    //
    *ppPropStore = NULL;
    return S_OK;
}

//+---------------------------------------------------------------------------
//
// Clone
//
//----------------------------------------------------------------------------

STDAPI CGeneralPropStore::Clone(ITfPropertyStore **ppPropStore)
{
    CGeneralPropStore *pStore;

    if (ppPropStore == NULL)
        return E_INVALIDARG;

    *ppPropStore = NULL;

    //
    // we can't clone a Unknown prop.
    //
    if (_prop.type == TF_PT_UNKNOWN)
        return E_FAIL;

    if ((pStore = new CGeneralPropStore) == NULL)
        return E_OUTOFMEMORY;

    if (!pStore->_Init(_guidatom, &_prop, _dwPropFlags))
        return E_FAIL;

    *ppPropStore = pStore;
    return S_OK;
}

//+---------------------------------------------------------------------------
//
// GetpropertyRangeCreator
//
//----------------------------------------------------------------------------

STDAPI CGeneralPropStore::GetPropertyRangeCreator(CLSID *pclsid)
{
    memset(pclsid, 0, sizeof(*pclsid));
    return TF_S_GENERALPROPSTORE;
}

//+---------------------------------------------------------------------------
//
// Serialize
//
//----------------------------------------------------------------------------

STDAPI CGeneralPropStore::Serialize(IStream *pStream, ULONG *pcb)
{
    GUID guid;
    ULONG ulSize;
    HRESULT hr = E_FAIL;

    if (!pcb)
        return E_INVALIDARG;
    *pcb = 0;

    if (!pStream)
        return E_INVALIDARG;

    switch (_prop.type)
    {
        case TF_PT_DWORD:
            if (SUCCEEDED(hr = pStream->Write(&_prop.dw, sizeof(DWORD), NULL)))
                *pcb = sizeof(DWORD);
            break;

        case TF_PT_GUID:
            if (SUCCEEDED(MyGetGUID(_prop.guidatom, &guid)) &&
                SUCCEEDED(hr = pStream->Write(&guid, sizeof(GUID), NULL)))
            {
                *pcb = sizeof(GUID);
            }
            break;

        case TF_PT_BSTR:
            ulSize = SysStringLen(_prop.bstr) * sizeof(WCHAR);

            if (SUCCEEDED(pStream->Write(_prop.bstr, ulSize, NULL)))
            {
                *pcb =  ulSize;
            }
            hr = *pcb ? S_OK : S_FALSE;
            break;

        case TF_PT_PROXY:
            if (SUCCEEDED(pStream->Write(_prop.blob->rgBytes, _prop.blob->cb, pcb)))
            {
                hr = (*pcb == _prop.blob->cb) ? S_OK : E_FAIL;
            }
            break;

        case TF_PT_UNKNOWN:
            hr = S_FALSE;
            break;
    }

    return hr;
}

//////////////////////////////////////////////////////////////////////////////
//
// CPropStoreProxy
//
// CPropStore is for keeping the persistent data when the owner TFE
// is not available.
//
// GetPropertyRangeCreator() returns the real owner TFE of this data.
// So next time the application may be able to find the real owner if it is
// available.
//
//////////////////////////////////////////////////////////////////////////////

//+---------------------------------------------------------------------------
//
// _Init
//
//----------------------------------------------------------------------------

BOOL CPropStoreProxy::_Init(const CLSID *pclsidTIP, TfGuidAtom guidatom, int iDataSize, IStream *pStream, DWORD dwPropFlags)
{
    if (!CGeneralPropStore::_Init(guidatom, iDataSize, TF_PT_PROXY,  pStream, dwPropFlags))
        return FALSE;

    _clsidTIP = *pclsidTIP;

    return TRUE;
}

BOOL CPropStoreProxy::_Init(const CLSID *pclsidTIP, TfGuidAtom guidatom, TFPROPERTY *ptfp, DWORD dwPropFlags)
{
    if (!CGeneralPropStore::_Init(guidatom, ptfp, dwPropFlags))
        return FALSE;

    _clsidTIP = *pclsidTIP;

    return TRUE;
}

//+---------------------------------------------------------------------------
//
// GetpropertyRangeCreator
//
//----------------------------------------------------------------------------

STDAPI CPropStoreProxy::GetPropertyRangeCreator(CLSID *pclsid)
{
    *pclsid = _clsidTIP;
    return TF_S_PROPSTOREPROXY;
}

//+---------------------------------------------------------------------------
//
// Clone
//
//----------------------------------------------------------------------------

STDAPI CPropStoreProxy::Clone(ITfPropertyStore **ppPropStore)
{
    CPropStoreProxy *pStore;

    if (ppPropStore == NULL)
        return E_INVALIDARG;

    *ppPropStore = NULL;

    //
    // we can't clone a Unknown prop.
    //
    if (_prop.type == TF_PT_UNKNOWN)
        return E_FAIL;

    if ((pStore = new CPropStoreProxy) == NULL)
        return E_OUTOFMEMORY;

    if (!pStore->_Init(&_clsidTIP, _guidatom, &_prop, _dwPropFlags))
        return E_FAIL;

    *ppPropStore = pStore;
    return S_OK;
}

//////////////////////////////////////////////////////////////////////////////
//
// CStaticPropStore
//
// CStaticPropStore works like character property. We keep same raw data 
// even if the range is devided or changed.
//
// So the range data should not contain the information that is associated
// with cch.
//
//////////////////////////////////////////////////////////////////////////////

//+---------------------------------------------------------------------------
//
// Shrink
//
//----------------------------------------------------------------------------

STDAPI CStaticPropStore::Shrink(ITfRange *pRange, BOOL *pfFree)
{
    // we don't change any raw data.
    *pfFree = FALSE;
    return S_OK;
}

//+---------------------------------------------------------------------------
//
// Divide
//
//----------------------------------------------------------------------------

STDAPI CStaticPropStore::Divide(ITfRange *pRangeThis, ITfRange *pRangeNew, ITfPropertyStore **ppPropStore)
{
    CStaticPropStore *pss;

    *ppPropStore = NULL;

    if ((pss = new CStaticPropStore) == NULL)
        return E_OUTOFMEMORY;

    if (!pss->_Init(_guidatom, &_prop, _dwPropFlags))
        return E_FAIL;

    *ppPropStore = pss;
    return S_OK;
}

//+---------------------------------------------------------------------------
//
// Clone
//
//----------------------------------------------------------------------------

STDAPI CStaticPropStore::Clone(ITfPropertyStore **ppPropStore)
{
    CStaticPropStore *pStore;

    if (ppPropStore == NULL)
        return E_INVALIDARG;

    *ppPropStore = NULL;

    //
    // we can't clone a Unknown prop.
    //
    if (_prop.type == TF_PT_UNKNOWN)
        return E_FAIL;

    if ((pStore = new CStaticPropStore) == NULL)
        return E_OUTOFMEMORY;

    if (!pStore->_Init(_guidatom, &_prop, _dwPropFlags))
        return E_FAIL;

    *ppPropStore = pStore;
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\ctf\uim\range.h ===
//
// range.h
//

#ifndef RANGE_H
#define RANGE_H

#include "private.h"
#include "anchor.h"
#include "sink.h"
#include "ic.h"

#define IGNORE_LAST_LOCKRELEASED    0xffffffff

class CInputContext;
class CEnumOwnedRanges;

extern const IID IID_PRIV_CRANGE;

inline TfGravity DCGToIMG(TsGravity dcg) { return dcg == TS_GR_FORWARD ? TF_GRAVITY_FORWARD : TF_GRAVITY_BACKWARD; }

typedef enum { RINIT_DEF_GRAVITY, RINIT_GRAVITY, RINIT_NO_GRAVITY } RInit;

class CRange : public ITfRangeACP,
               public ITfRangeAnchor,
               public ITfSource
{
public:
// work around for new #define in mem.h
#undef new
    DECLARE_CACHED_NEW;
// retore mem.h trick
#ifdef DEBUG
#define new new(TEXT(__FILE__), __LINE__)
#endif // DEBUG

    CRange()
    {
        Dbg_MemSetThisNameIDCounter(TEXT("CRange"), PERF_RANGE_COUNTER);
        _cRef = 1;
    }
    ~CRange();

    // NB: caller must be certain that paStart <= paEnd before calling _InitWithDefaultGravity!
    BOOL _InitWithDefaultGravity(CInputContext *pic, AnchorOwnership ao, IAnchor *paStart, IAnchor *paEnd)
    {
        return _Init(pic, ao, paStart, paEnd, RINIT_DEF_GRAVITY);
    }
    BOOL _InitWithAnchorGravity(CInputContext *pic, AnchorOwnership ao, IAnchor *paStart, IAnchor *paEnd)
    {
        return _Init(pic, ao, paStart, paEnd, RINIT_GRAVITY);
    }

    static void _InitClass();
    static void _UninitClass();

    //
    // IUnknown methods
    //
    STDMETHODIMP QueryInterface(REFIID riid, void **ppvObj);
    STDMETHODIMP_(ULONG) AddRef(void);
    STDMETHODIMP_(ULONG) Release(void);

    // ITfRange
    STDMETHODIMP GetText(TfEditCookie ec, DWORD dwFlags, WCHAR *pchText, ULONG cchMax, ULONG *pcch);
    STDMETHODIMP SetText(TfEditCookie ec, DWORD dwFlags, const WCHAR *pchText, LONG cch);
    STDMETHODIMP GetFormattedText(TfEditCookie ec, IDataObject **ppDataObject);
    STDMETHODIMP GetEmbedded(TfEditCookie ec, REFGUID rguidService, REFIID riid, IUnknown **ppunk);
    STDMETHODIMP InsertEmbedded(TfEditCookie ec, DWORD dwFlags, IDataObject *pDataObject);
    STDMETHODIMP ShiftStart(TfEditCookie ec, LONG cchReq, LONG *pcch, const TF_HALTCOND *pHalt);
    STDMETHODIMP ShiftEnd(TfEditCookie ec, LONG cchReq, LONG *pcch, const TF_HALTCOND *pHalt);
    STDMETHODIMP ShiftStartToRange(TfEditCookie ec, ITfRange *pRange, TfAnchor aPos);
    STDMETHODIMP ShiftEndToRange(TfEditCookie ec, ITfRange *pRange, TfAnchor aPos);
    STDMETHODIMP ShiftStartRegion(TfEditCookie ec, TfShiftDir dir, BOOL *pfNoRegion);
    STDMETHODIMP ShiftEndRegion(TfEditCookie ec, TfShiftDir dir, BOOL *pfNoRegion);
    STDMETHODIMP IsEmpty(TfEditCookie ec, BOOL *pfEmpty);
    STDMETHODIMP Collapse(TfEditCookie ec, TfAnchor aPos);
    STDMETHODIMP IsEqualStart(TfEditCookie ec, ITfRange *pWith, TfAnchor aPos, BOOL *pfEqual);
    STDMETHODIMP IsEqualEnd(TfEditCookie ec, ITfRange *pWith, TfAnchor aPos, BOOL *pfEqual);
    STDMETHODIMP CompareStart(TfEditCookie ec, ITfRange *pWith, TfAnchor aPos, LONG *plResult);
    STDMETHODIMP CompareEnd(TfEditCookie ec, ITfRange *pWith, TfAnchor aPos, LONG *plResult);
    STDMETHODIMP AdjustForInsert(TfEditCookie ec, ULONG cchInsert, BOOL *pfInsertOk);
    STDMETHODIMP GetGravity(TfGravity *pgStart, TfGravity *pgEnd);
    STDMETHODIMP SetGravity(TfEditCookie ec, TfGravity gStart, TfGravity gEnd);
    STDMETHODIMP Clone(ITfRange **ppClone);
    STDMETHODIMP GetContext(ITfContext **ppContext);

    // ITfRangeACP
    STDMETHODIMP GetExtent(LONG *pacpAnchor, LONG *pcch);
    STDMETHODIMP SetExtent(LONG acpAnchor, LONG cch);

    // ITfRangeAnchor
    STDMETHODIMP GetExtent(IAnchor **ppaStart, IAnchor **ppaEnd);
    STDMETHODIMP SetExtent(IAnchor *paStart, IAnchor *paEnd);

    // ITfSource
    STDMETHODIMP AdviseSink(REFIID riid, IUnknown *punk, DWORD *pdwCookie);
    STDMETHODIMP UnadviseSink(DWORD dwCookie);

    CRange *_Clone()
    { 
        CRange *rangeClone;

        if ((rangeClone = new CRange) == NULL)
            return NULL;

        if (!rangeClone->_Init(_pic, COPY_ANCHORS, _paStart, _paEnd, RINIT_NO_GRAVITY))
        {
            rangeClone->Release();
            return NULL;
        }

        rangeClone->_dwLastLockReleaseID = _dwLastLockReleaseID;

        return rangeClone;
    }

    CRange *_GetNextOnChangeRangeInIcsub() { return _nextOnChangeRangeInIcsub; }

    IAnchor *_GetStart() { return _paStart; }
    IAnchor *_GetEnd() { return _paEnd; }

    CInputContext *_GetContext() { return _pic; }

    CStructArray<GENERICSINK> *_GetChangeSinks() { return _prgChangeSinks; }

    void _QuickCheckCrossedAnchors()
    {
        if (_dwLastLockReleaseID != IGNORE_LAST_LOCKRELEASED)
        {
            _CheckCrossedAnchors();
        }
    }

#if 0
    HRESULT _SnapToRegion(DWORD dwFlags);
#endif

    BOOL _IsDirty() { return _fDirty; }
    void _SetDirty() { _fDirty = TRUE; }
    void _ClearDirty() { _fDirty = FALSE; }

private:
    BOOL _Init(CInputContext *pic, AnchorOwnership ao, IAnchor *paStart, IAnchor *paEnd, RInit rinit);

    HRESULT _SetGravity(TfGravity gStart, TfGravity gEnd, BOOL fCheckCrossedAnchors);

    void _CheckCrossedAnchors();

    HRESULT _PreEditCompositionCheck(TfEditCookie ec, CComposition **ppComposition, BOOL *pfNewComposition);

    HRESULT _ShiftConditional(IAnchor *paStart, IAnchor *paLimit, LONG cchReq, LONG *pcch, const TF_HALTCOND *pHalt);

    HRESULT _IsEqualX(TfEditCookie ec, TfAnchor aPosThisRange, ITfRange *pWith, TfAnchor aPos, BOOL *pfEqual);
    HRESULT _CompareX(TfEditCookie ec, TfAnchor aPosThisRange, ITfRange *pWith, TfAnchor aPos, LONG *plResult);

    BOOL _IsValidEditCookie(TfEditCookie ec, DWORD dwFlags);

    void _InitLastLockReleaseId(TsGravity gStart, TsGravity gEnd)
    {
        if (gStart == TF_GRAVITY_FORWARD && gEnd == TF_GRAVITY_BACKWARD)
        {
            // this range has the potential for crossed anchors, need to monitor
            // since the range may have just been cloned from a crossed range, need to
            // init _dwLastLockReleaseID with something that will guarantee a check
            _dwLastLockReleaseID = _pic->_GetLastLockReleaseID() - 1;
        }
        else
        {
            // don't bother checking for crossed anchors, since it can't happen
            _dwLastLockReleaseID = IGNORE_LAST_LOCKRELEASED;
        }
    }

    CStructArray<GENERICSINK> *_prgChangeSinks; // ITfRangeChangeSink sinks

    IAnchor *_paStart;
    IAnchor *_paEnd;

    CInputContext *_pic;
    CRange *_nextOnChangeRangeInIcsub; // perf: could use an array in the pic to save space

    DWORD _dwLastLockReleaseID;

    BOOL _fDirty : 1;

    long _cRef;

    DBG_ID_DECLARE;
};


// this call doesn't AddRef the object!
inline CRange *GetCRange_NA(IUnknown *range)
{
    CRange *prange;

    range->QueryInterface(IID_PRIV_CRANGE, (void **)&prange);

    return prange;
}

// returns TRUE if range is in the same context
inline BOOL VerifySameContext(CRange *pRange1, CRange *pRange2)
{
    Assert((pRange1->_GetContext() == pRange2->_GetContext()));
    return (pRange1->_GetContext() == pRange2->_GetContext());
}
// returns TRUE if range is in the same context
inline BOOL VerifySameContext(CInputContext *pContext, CRange *pRange)
{
    Assert((pRange->_GetContext() == pContext));
    return (pRange->_GetContext() == pContext);
}
// returns TRUE if range is in the same context
inline BOOL VerifySameContext(CInputContext *pContext, ITfRange *pTargetRange)
{
    CRange *pRange = GetCRange_NA(pTargetRange);

    Assert((pRange != NULL) && (pRange->_GetContext() == pContext));
    return (pRange != NULL) && (pRange->_GetContext() == pContext);
}


#endif // RANGE_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\ctf\uim\rangebk.cpp ===
//
// perange.cpp
//

#include "private.h"
#include "helpers.h"
#include "ic.h"
#include "range.h"
#include "rangebk.h"
#include "rprop.h"
#include "immxutil.h"

//////////////////////////////////////////////////////////////////////////////
//
// CRangeBackup
//
//////////////////////////////////////////////////////////////////////////////

//+---------------------------------------------------------------------------
//
// ctor
//
//----------------------------------------------------------------------------

CRangeBackupProperty::CRangeBackupProperty(CRangeBackup *ppr, CProperty *pProp)
{
    _ppr = ppr;
    _pProp = pProp;
}

//+---------------------------------------------------------------------------
//
// dtor
//
//----------------------------------------------------------------------------

CRangeBackupProperty::~CRangeBackupProperty()
{
    int i;
    int nCnt = _rgPropRanges.Count();

    for (i = 0; i < nCnt; i++)
    {
        PERSISTPROPERTYRANGE *pPropRange;
        pPropRange = _rgPropRanges.GetPtr(i);

        Assert(pPropRange);
        Assert(pPropRange->_pPropStore);

        pPropRange->_pPropStore->Release();
        pPropRange->_pPropStore = NULL;
    }
    
}

//+---------------------------------------------------------------------------
//
// Init
//
//----------------------------------------------------------------------------

BOOL CRangeBackupProperty::Init(TfEditCookie ec)
{
    IEnumTfRanges *pEnum;
    ITfRange *pRange;
    HRESULT hr;

    hr = _pProp->EnumRanges(ec, &pEnum, (ITfRangeAnchor *)_ppr->_pRange);
    if (FAILED(hr) || !pEnum)
        return FALSE;

    while (pEnum->Next(1, &pRange, NULL) == S_OK)
    {
        CRange *pCRange;
        pCRange = GetCRange_NA(pRange);
        if (pCRange)
        {
            _StoreOneRange(ec, pCRange);
        }
        pRange->Release();
    }

    pEnum->Release();
    
    return TRUE;
}

//+---------------------------------------------------------------------------
//
// StoreOneRange
//
//----------------------------------------------------------------------------

BOOL CRangeBackupProperty::_StoreOneRange(TfEditCookie ec, CRange *pCRange)
{
    PROPERTYLIST *pPropList;
    ULONG achStart = 0;
    ULONG achEnd = 0;

    if (CompareAnchors(pCRange->_GetStart(), _ppr->_pRange->_GetStart()) < 0)
    {
        if (CompareAnchors(pCRange->_GetEnd(), _ppr->_pRange->_GetEnd()) > 0)
        {
           pPropList = _pProp->_FindPropListAndDivide(_ppr->_pRange->_GetStart(), _ppr->_pRange->_GetEnd());

           achStart = _GetOffset(ec, _ppr->_pRange->_GetStart());
           achEnd = _GetOffset(ec, _ppr->_pRange->_GetEnd());
        }
        else
        {
           pPropList = _pProp->_FindPropListAndDivide(_ppr->_pRange->_GetStart(), pCRange->_GetEnd());
           achStart = _GetOffset(ec, _ppr->_pRange->_GetStart());
           achEnd = _GetOffset(ec, pCRange->_GetEnd());
        }
    }
    else if (CompareAnchors(pCRange->_GetEnd(), _ppr->_pRange->_GetEnd()) > 0)
    {
        pPropList = _pProp->_FindPropListAndDivide(pCRange->_GetStart(), _ppr->_pRange->_GetEnd());
        achStart = _GetOffset(ec, pCRange->_GetStart());
        achEnd = _GetOffset(ec, _ppr->_pRange->_GetEnd());
    }
    else
    {
        pPropList = _pProp->_FindPropListAndDivide(pCRange->_GetStart(), pCRange->_GetEnd());
        achStart = _GetOffset(ec, pCRange->_GetStart());
        achEnd = _GetOffset(ec, pCRange->_GetEnd());
    }

    if (pPropList)
    {
        if (!pPropList->_pPropStore)
            _pProp->LoadData(pPropList);

        if (pPropList->_pPropStore)
        {
             HRESULT hr;
             PERSISTPROPERTYRANGE *pPropRange;
             ITfPropertyStore *pPropStore = NULL;
             int nCnt;
             
             hr = pPropList->_pPropStore->Clone(&pPropStore);
             if (FAILED(hr) || !pPropStore)
                 return FALSE;

             nCnt = _rgPropRanges.Count();

             if (!_rgPropRanges.Insert(nCnt, 1))
             { 
                 pPropStore->Release();
                 return FALSE;
             }

             pPropRange = _rgPropRanges.GetPtr(nCnt);
             pPropRange->achStart = achStart;
             pPropRange->achEnd = achEnd;
             pPropRange->_pPropStore = pPropStore;
        }
    }
    return TRUE;
}

//+---------------------------------------------------------------------------
//
// _GetOffset
//
//----------------------------------------------------------------------------

int CRangeBackupProperty::_GetOffset(TfEditCookie ec, IAnchor *pa)
{
    CRange *pCRange;
    CRange *pCRangeTmp = NULL;
    ULONG cch = 0;
    HRESULT hr;
    BOOL fEmpty;

    pCRange = new CRange;
    if (!pCRange)
        goto Exit;

    if (!pCRange->_InitWithDefaultGravity(_ppr->_pic, COPY_ANCHORS, pa, pa))
        goto Exit;

    pCRangeTmp = _ppr->_pRange->_Clone();
    if (!pCRangeTmp)
        goto Exit;

    hr = pCRangeTmp->ShiftEndToRange(ec, (ITfRangeAnchor *)pCRange, TF_ANCHOR_START);
    if (FAILED(hr))
        goto Exit;

    
    fEmpty = FALSE;
    while ((pCRangeTmp->IsEmpty(ec, &fEmpty) == S_OK) && !fEmpty)
    {
        WCHAR sz[256];
        ULONG cchTmp;

        pCRangeTmp->GetText(ec, TF_TF_MOVESTART, sz, ARRAYSIZE(sz), &cchTmp);
        cch += cchTmp;
    }

Exit:
    SafeRelease(pCRangeTmp);
    SafeRelease(pCRange);

    return cch;
}

//+---------------------------------------------------------------------------
//
// Restore
//
//----------------------------------------------------------------------------

BOOL CRangeBackupProperty::Restore(TfEditCookie ec)
{
    int i;
    HRESULT hr;
    int nCnt;
    CRange *pCRange;

    nCnt = _rgPropRanges.Count();
    if (!nCnt)
        return FALSE;

    pCRange = _ppr->_pRange->_Clone();
    if (!pCRange)
        return FALSE;

    for (i = 0; i < nCnt; i++)
    {
        PERSISTPROPERTYRANGE *pPropRange;
        LONG cchStart, cchEnd;
        pPropRange = _rgPropRanges.GetPtr(i);

        Assert(pPropRange);
        Assert(pPropRange->_pPropStore);

        hr = pCRange->ShiftStartToRange(ec, (ITfRangeAnchor *)_ppr->_pRange,
                                        TF_ANCHOR_START);
        if (FAILED(hr))
            goto Next;

        hr = pCRange->Collapse(ec, TF_ANCHOR_START);
        if (FAILED(hr))
            goto Next;

        // shift End first.
        hr = pCRange->ShiftEnd(ec, pPropRange->achEnd, &cchEnd, NULL);
        if (FAILED(hr))
            goto Next;

        hr = pCRange->ShiftStart(ec, pPropRange->achStart, &cchStart, NULL);
        if (FAILED(hr))
            goto Next;

        _pProp->_SetStoreInternal(ec, pCRange, pPropRange->_pPropStore, TRUE);
Next:
        pPropRange->_pPropStore->Release();
        pPropRange->_pPropStore = NULL;
    }

    pCRange->Release();
    _rgPropRanges.Clear();

    return TRUE;
}

//////////////////////////////////////////////////////////////////////////////
//
// CRangeBackup
//
//////////////////////////////////////////////////////////////////////////////

//+---------------------------------------------------------------------------
//
// ctor
//
//----------------------------------------------------------------------------

CRangeBackup::CRangeBackup(CInputContext *pic)
{
    _pic = pic;
    Assert(!_pRange);
}

//+---------------------------------------------------------------------------
//
// dtor
//
//----------------------------------------------------------------------------

CRangeBackup::~CRangeBackup()
{
    Clear();
}

//+---------------------------------------------------------------------------
//
// Clear
//
//----------------------------------------------------------------------------

void CRangeBackup::Clear()
{
    _pic = NULL;
    SafeReleaseClear(_pRange);

    delete _psz;
    _psz = NULL;

    int nCnt = _rgProp.Count();
    for (int i = 0; i < nCnt; i++)
    {
        CRangeBackupProperty *pprp = _rgProp.Get(i);
        delete pprp;
    }
    _rgProp.Clear();
}


//+---------------------------------------------------------------------------
//
// Init
//
//----------------------------------------------------------------------------

HRESULT CRangeBackup::Init(TfEditCookie ec, CRange *pRange)
{
    ITfRange *pRangeTmp = NULL;
    ULONG cch, cchCur;
    BOOL fEmpty;
    CProperty *pProp;
    HRESULT hr;
    WCHAR *pszTmp;

    Assert(!_pRange);
    Assert(!_psz);

    _pRange = pRange->_Clone();

    hr = _pRange->Clone(&pRangeTmp);
    if (FAILED(hr) || !pRangeTmp)
        return E_FAIL;

    hr = E_FAIL;

    //
    // Save text.
    //
    fEmpty = FALSE;
    cchCur = 0;
    cch = 31;
    while ((pRangeTmp->IsEmpty(ec, &fEmpty) == S_OK) && !fEmpty)
    {
        if (!_psz)
        {
            Assert(cchCur == 0);
            _psz = (WCHAR *)cicMemAlloc((cch + 1) * sizeof(WCHAR));
        }
        else
        {
            Assert(cchCur);
            pszTmp = (WCHAR *)cicMemReAlloc(_psz, (cchCur + cch + 1) * sizeof(WCHAR));
            if (pszTmp != NULL)
            {
                _psz = pszTmp;
            }
            else
            {
                cicMemFree(_psz);
                _psz = NULL;
            }
        }

        if (_psz == NULL)
            goto Exit;

        pRangeTmp->GetText(ec, TF_TF_MOVESTART, _psz + cchCur, cch, &cch);

        cchCur += cch;
        cch *= 2;
    }

    if (!cchCur)
    {
        hr = S_FALSE;
        _cch = 0;
    
        if (_psz)
        {
            cicMemFree(_psz);
            _psz = NULL;
        }

        goto Exit;
    }

    _cch = cchCur;
    _psz[_cch] = L'\0';

    //
    // Save property.
    //
    pProp = _pic->_pPropList;
    while (pProp)
    {
        CRangeBackupProperty *pPropRange;
        int nCnt = _rgProp.Count();

        pPropRange = new CRangeBackupProperty(this, pProp);
        if (!pPropRange)
        {
            hr = E_OUTOFMEMORY;
            goto Exit;
        }

        if (!pPropRange->Init(ec))
        {
            delete pPropRange;
            goto Next;
        }

        if (!_rgProp.Insert(nCnt, 1))
        {
            hr = E_OUTOFMEMORY;
            delete pPropRange;
            goto Next;
        }

        _rgProp.Set(nCnt, pPropRange);

Next:
        pProp = pProp->_pNext;
    }

    hr = S_OK;
Exit:
    SafeRelease(pRangeTmp);

    return hr;
}

//+---------------------------------------------------------------------------
//
// Restore
//
//----------------------------------------------------------------------------

STDAPI CRangeBackup::Restore(TfEditCookie ec, ITfRange *pRange)
{
    HRESULT hr = E_FAIL;
    int i;
    int nCnt;
    CRange *range;

    if (!_pic->_IsValidEditCookie(ec, TF_ES_READWRITE))
    {
        Assert(0);
        return TF_E_NOLOCK;
    }
   
    if (pRange)
    {
        SafeReleaseClear(_pRange);
        range = GetCRange_NA(pRange);
        if (range == NULL)
            return E_INVALIDARG;

        if (!VerifySameContext(_pic, range))
            return E_INVALIDARG;

        range->_QuickCheckCrossedAnchors();

        _pRange = range->_Clone();      
    }

    Assert(_pRange);
    Assert(_psz || !_cch);

    if (!_pic)
        return S_OK;

    Assert(_pRange);

    _pRange->SetText(ec, 0, _psz, _cch);

    nCnt = _rgProp.Count();
    for (i = 0; i < nCnt; i++)
    {
        CRangeBackupProperty *pPropRange = _rgProp.Get(i);

        Assert(pPropRange);
        pPropRange->Restore(ec);
        delete pPropRange;
    }
    _rgProp.Clear();

    hr = S_OK;
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\ctf\uim\rngsink.h ===
//
// rngsink.h
//

#ifndef RNGSINK_H
#define RNGSINK_H

#include "tfprop.h"

#define BUF_SIZE 16

#define TF_PT_PROXY ((TfPropertyType)-1)  // private property type used for CPropStoreProxy data

extern const IID IID_CGeneralPropStore;

class CGeneralPropStore : public ITfPropertyStore,
                          public CComObjectRootImmx
{
public:
    CGeneralPropStore()
    {
        Dbg_MemSetThisNameID(TEXT("CGeneralPropStore"));
    }
    ~CGeneralPropStore();

    BOOL _Init(TfGuidAtom guidatom, const VARIANT *pvarValue, DWORD dwPropFlags);
    BOOL _Init(TfGuidAtom guidatom, int iDataSize, TfPropertyType type, IStream *pStream, DWORD dwPropFlags);

    BEGIN_COM_MAP_IMMX(CGeneralPropStore)
        COM_INTERFACE_ENTRY_IID(IID_CGeneralPropStore, CGeneralPropStore)
        COM_INTERFACE_ENTRY(ITfPropertyStore)
    END_COM_MAP_IMMX()

    IMMX_OBJECT_IUNKNOWN_FOR_ATL()

    //
    // ITfPropertyStore
    //
    STDMETHODIMP GetType(GUID *pguid);
    STDMETHODIMP GetDataType(DWORD *pdwReserved);
    STDMETHODIMP GetData(VARIANT *pvarValue);
    STDMETHODIMP OnTextUpdated(DWORD dwFlags, ITfRange *pRange, BOOL *pfAccept);
    STDMETHODIMP Shrink(ITfRange *pRange, BOOL *pfFree);
    STDMETHODIMP Divide(ITfRange *pRangeThis, ITfRange *pRangeNew, ITfPropertyStore **ppPropStore);
    STDMETHODIMP Clone(ITfPropertyStore **ppPropStore);
    STDMETHODIMP GetPropertyRangeCreator(CLSID *pclsid);
    STDMETHODIMP Serialize(IStream *pStream, ULONG *pcb);

protected:
    BOOL _Init(TfGuidAtom guidatom, TFPROPERTY *ptfp, DWORD dwPropFlags);

    TFPROPERTY _prop;
    DWORD _dwPropFlags;
    TfGuidAtom _guidatom;

    DBG_ID_DECLARE;
};

class CPropStoreProxy : public CGeneralPropStore
{
public:
    CPropStoreProxy()
    {
        Dbg_MemSetThisNameID(TEXT("CPropStoreProxy"));
    }

    BOOL _Init(const CLSID *pclsidTIP, TfGuidAtom guidatom, int iDataSize, IStream *pStream, DWORD dwPropFlags);

    //
    // ITfPropertyStore
    //
    STDMETHODIMP GetPropertyRangeCreator(CLSID *pclsid);
    STDMETHODIMP Clone(ITfPropertyStore **ppPropStore);

private:
    BOOL _Init(const CLSID *pclsidTIP, TfGuidAtom guidatom, TFPROPERTY *ptfp, DWORD dwPropFlags);

    CLSID _clsidTIP;
};

class CStaticPropStore : public CGeneralPropStore
{
public:
    CStaticPropStore()
    {
        Dbg_MemSetThisNameID(TEXT("CStaticPropStore"));
    }

    //
    // ITfPropertyStore
    //
    STDMETHODIMP Shrink(ITfRange *pRange, BOOL *pfFree);
    STDMETHODIMP Divide(ITfRange *pRangeThis, ITfRange *pRangeNew, ITfPropertyStore **ppPropStore);
    STDMETHODIMP Clone(ITfPropertyStore **ppPropStore);

private:
    DBG_ID_DECLARE;
};

#endif // RNGSINK_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\ctf\uim\saa.cpp ===
//
// saa.cpp
//
// CSharedAnchorArray
//

#include "private.h"
#include "saa.h"
#include "immxutil.h"

//+---------------------------------------------------------------------------
//
// _MergeSort
//
// NB: rgArrays is freed before the method exits.
//     Caller must release the out array.
//
// perf: some possible optimizations:
//       quick check if the arrays don't overlap
//       find some way to anticipate dups
//----------------------------------------------------------------------------

/* static */
CSharedAnchorArray *CSharedAnchorArray::_MergeSort(CSharedAnchorArray **rgArrays, ULONG cArrays)
{
    LONG l;
    IAnchor *pa;
    IAnchor **ppaDst;
    IAnchor **ppa1;
    IAnchor **ppaEnd1;
    IAnchor **ppa2;
    IAnchor **ppaEnd2;
    CSharedAnchorArray *prgAnchors1 = NULL;
    CSharedAnchorArray *prgAnchors2 = NULL;
    CSharedAnchorArray *prgAnchors = NULL;
    BOOL fRet = FALSE;
    
    // recursion
    if (cArrays > 2)
    {
        if (cArrays == 3)
        {
            // avoid unnecessary mem alloc here
            prgAnchors1 = rgArrays[0];
        }
        else
        {
            prgAnchors1 =  _MergeSort(rgArrays, cArrays / 2);
        }
        prgAnchors2 = _MergeSort(rgArrays + cArrays / 2, cArrays - cArrays / 2);
    }
    else
    {
        Assert(cArrays == 2);
        prgAnchors1 = rgArrays[0];
        prgAnchors2 = rgArrays[1];
    }

    // check for out-of-mem after the recursion, so we at least free the entire source array
    if (prgAnchors1 == NULL || prgAnchors2 == NULL)
        goto Exit;

    // allocate some memory
    // perf: we could do something complicated and do everything in place
    if ((prgAnchors = new CSharedAnchorArray) == NULL)
        goto Exit;

    if (prgAnchors1->Count() + prgAnchors2->Count() == 0)
    {
        Assert(!prgAnchors->Count());
        fRet = TRUE;
        goto Exit;
    }

    if (!prgAnchors->Append(prgAnchors1->Count() + prgAnchors2->Count()))
        goto Exit;

    // the actual combination
    ppaDst = prgAnchors->GetPtr(0);
    ppa1 = prgAnchors1->GetPtr(0);
    ppa2 = prgAnchors2->GetPtr(0);
    ppaEnd1 = prgAnchors1->GetPtr(prgAnchors1->Count());
    ppaEnd2 = prgAnchors2->GetPtr(prgAnchors2->Count());

    // do a one pass merge sort -- both prgAnchors1 and prgAnchors2 are sorted already
    while (ppa1 < ppaEnd1 ||
           ppa2 < ppaEnd2)
    {
        if (ppa1 < ppaEnd1)
        {
            if (ppa2 < ppaEnd2)
            {
                l = CompareAnchors(*ppa1, *ppa2);
                if (l < 0)
                {
                    pa = *ppa1++;
                }
                else if (l > 0)
                {
                    pa = *ppa2++;
                }
                else // equal
                {
                    pa = *ppa1++;
                    (*ppa2++)->Release();
                }
            }
            else
            {
                pa = *ppa1++;
            }
        }
        else // ppa2 < ppaEnd2
        {
            pa = *ppa2++;
        }

        *ppaDst++ = pa;
    }

    // taking ownership, so no AddRef
    // clear the elems counts so we don't Release in the destructors
    prgAnchors1->SetCount(0);
    prgAnchors2->SetCount(0);
    // we might have removed dups, so calc a new size
    prgAnchors->SetCount((int)(ppaDst - prgAnchors->GetPtr(0)));

    fRet = TRUE;

Exit:
    if (prgAnchors1 != NULL)
    {
        prgAnchors1->_Release();
    }
    if (prgAnchors2 != NULL)
    {
        prgAnchors2->_Release();
    }
    if (!fRet)
    {
        if (prgAnchors != NULL)
        {
            prgAnchors->_Release();
        }
        prgAnchors = NULL;
    }

    return prgAnchors;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\ctf\uim\saa.h ===
//
// saa.h
//
// CSharedAnchorArray
//

#ifndef SAA_H
#define SAA_H

#include "ptrary.h"

//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////
//
// CSharedAnchorArray
//
//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////

class CSharedAnchorArray : public CPtrArray<IAnchor>
{
public:
    CSharedAnchorArray() : CPtrArray<IAnchor>() { _cRef = 1; };

    void _AddRef()
    { 
        _cRef++;
    }

    void _Release()
    {   
        int i;

        Assert(_cRef > 0);

        if (--_cRef == 0)
        {
            for (i=0; i<Count(); i++)
            {
                SafeRelease(Get(i));
            }
            delete this;
        }
    }

    static CSharedAnchorArray *_MergeSort(CSharedAnchorArray **rgArrays, ULONG cArrays);

private:
    ULONG _cRef;
};

#endif // SAA_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\ctf\uim\rprop.h ===
//
// rprop.h
//

#ifndef RPROP_H
#define RPROP_H

#include "private.h"
#include "strary.h"
#include "spans.h"
#include "tfprop.h"
#include "ptrary.h"

// for dwPropFlags of CProperty and CGeneralPropStore
#define PROPF_ACCEPTCORRECTION   0x00000001
#define PROPF_VTI4TOGUIDATOM     0x00000002
#define PROPF_MARKUP_COLLECTION  0x00000004 // property is member of a display attr markup collection

class CRange;
class CEnumProperties;

class CPropertyLoad
{
public:
    CPropertyLoad() {}

    ~CPropertyLoad()
    {
        SafeRelease(_pLoader);
        SafeRelease(_hdr.paStart);
        SafeRelease(_hdr.paEnd);
    }

    BOOL _Init(const TF_PERSISTENT_PROPERTY_HEADER_ANCHOR *phdr, ITfPersistentPropertyLoaderAnchor *pLoader)
    {
        _hdr = *phdr;

        _hdr.paStart = NULL;
        _hdr.paEnd = NULL;
        Assert(_pLoader == NULL);

        if (phdr->paStart->Clone(&_hdr.paStart) != S_OK)
        {
            _hdr.paStart = NULL;
            return FALSE;
        }
        if (phdr->paEnd->Clone(&_hdr.paEnd) != S_OK)
        {
            _hdr.paEnd = NULL;
            return FALSE;
        }

        _pLoader = pLoader;
        _pLoader->AddRef();

        return TRUE;
    }

    TF_PERSISTENT_PROPERTY_HEADER_ANCHOR _hdr;
    ITfPersistentPropertyLoaderAnchor *_pLoader;
};

typedef struct tag_PROPERTYLIST
{
  IAnchor *_paStart;
  IAnchor *_paEnd;
  ITfPropertyStore *_pPropStore;
  CPropertyLoad *_pPropLoad;
} PROPERTYLIST;

const DWORD PROPA_NONE          =  0;
const DWORD PROPA_TEXTOWNER     =  1;
const DWORD PROPA_FOCUSRANGE    =  2;
const DWORD PROPA_READONLY      =  4;
const DWORD PROPA_WONT_SERIALZE =  8;

// 
// Property Styles
//
typedef enum { 
    TFPROPSTYLE_NULL = 0x0, 
    TFPROPSTYLE_STATIC = 0x1, 
    TFPROPSTYLE_STATICCOMPACT = 0x2, 
    TFPROPSTYLE_CUSTOM = 0x3,
    TFPROPSTYLE_CUSTOM_COMPACT = 0x4
} TFPROPERTYSTYLE;

class CInputContext;
class CPropertySub;

// nb: if anything else derived from ITfProperty ever supports
// Unserialize, we'll need to have a shared abstract base class
// to that privately exposed the Unserialize method (or something
// equivalent...)
extern const IID IID_PRIV_CPROPERTY;

class CProperty : public ITfProperty2,
                  public CComObjectRootImmx
{
public:
    CProperty(CInputContext *pic, REFGUID guidProp, TFPROPERTYSTYLE propStyle, DWORD  dwAuthority, DWORD dwPropFlags);
    ~CProperty();

    BEGIN_COM_MAP_IMMX(CProperty)
        COM_INTERFACE_ENTRY_IID(IID_PRIV_CPROPERTY, CProperty)
        COM_INTERFACE_ENTRY(ITfReadOnlyProperty)
        COM_INTERFACE_ENTRY(ITfProperty)
        COM_INTERFACE_ENTRY(ITfProperty2)
    END_COM_MAP_IMMX()

    IMMX_OBJECT_IUNKNOWN_FOR_ATL()

    // ITfProperty2
    STDMETHODIMP EnumRanges(TfEditCookie ec, IEnumTfRanges **ppv, ITfRange *pTargetRange);
    STDMETHODIMP FindRange(TfEditCookie ec, ITfRange *pRange, ITfRange **ppv, TfAnchor aPos);
    STDMETHODIMP GetValue(TfEditCookie ec, ITfRange *pRange, VARIANT *pvarValue);
    STDMETHODIMP SetValueStore(TfEditCookie ec, ITfRange *pRange, ITfPropertyStore *pPropStore);
    STDMETHODIMP SetValue(TfEditCookie ec, ITfRange *pRange, const VARIANT *pvarValue);
    STDMETHODIMP Clear(TfEditCookie ec, ITfRange *pRange);
    STDMETHODIMP GetContext(ITfContext **ppContext);
    STDMETHODIMP FindNextValue(TfEditCookie ec, ITfRange *pRangeQuery, TfAnchor tfAnchorQuery, DWORD dwFlags, BOOL *pfContained, ITfRange **ppRangeNextValue);

    //
    // ITfPropertyCommon
    //
    STDMETHODIMP GetType(GUID *pType);
    STDMETHODIMP GetStyle(TFPROPERTYSTYLE *propStyle);

    // ITfSource
    STDMETHODIMP AdviseSink(REFIID refiid, IUnknown *punk, DWORD *pdwCookie);
    STDMETHODIMP UnadviseSink(DWORD dwCookie);

    HRESULT ForceLoad();
    void Clear(IAnchor *paStart, IAnchor *paEnd, DWORD dwFlags, BOOL fTextUpdate);

    HRESULT SetLoader(IAnchor *paStart, IAnchor *paEnd, CPropertyLoad *pPropLoad);

    TFPROPERTYSTYLE GetPropStyle() {return _propStyle;}

    BOOL Defrag(IAnchor *paStart, IAnchor *paEnd);

    TfGuidAtom GetPropGuidAtom() {return _guidatom;}

    CProperty *_pNext;
    CInputContext *_pic;
    TFPROPERTYSTYLE _propStyle;

    int GetPropNum() 
    {
        return _rgProp.Count();
    }
    PROPERTYLIST * GetFirstPropList() 
    {
        if (_rgProp.Count())
            return _rgProp.Get(0);
        return NULL;
    }
    PROPERTYLIST * GetLastPropList() 
    {
        int nCnt;
        if (nCnt = _rgProp.Count())
            return _rgProp.Get(nCnt - 1);
        return NULL;
    }
    PROPERTYLIST *QuickGetPropList(int iIndex)
    {
        return _rgProp.Get(iIndex);
    }
    PROPERTYLIST * GetPropList(int nCnt) 
    {
        if (nCnt < 0)
            return NULL;
        return _rgProp.Get(nCnt);
    }

    PROPERTYLIST *SafeGetPropList(int nCur)
    {
        int nCnt = _rgProp.Count();

        if (nCur >= nCnt)
        {
            return NULL;
        }
        else if (nCur > 0)
        {
            return _rgProp.Get(nCur);
        }
        else
        {
            return _rgProp.Get(0);
        }
    }

    // return the property list, or NULL if the data cannot be loaded
    PROPERTYLIST *QuickGetAndLoadPropList(int iIndex)
    {
        PROPERTYLIST *pPropList = _rgProp.Get(iIndex);
        
        if (pPropList->_pPropStore != NULL)
            return pPropList;

        LoadData(pPropList);

        return (pPropList->_pPropStore != NULL) ? pPropList : NULL;
    }

    PROPERTYLIST *Find(IAnchor *pa, LONG *piOut, BOOL fEnd)
    {
        return _FindComplex(pa, piOut, fEnd, FALSE /* fTextUpdate */);
    }
    PROPERTYLIST *FindPropertyListByPos(IAnchor *paPos, BOOL fEnd);
    HRESULT LoadData(PROPERTYLIST *pPropList);

    DWORD GetValidation() {return _dwAuthority;}

    HRESULT _SetDataInternal(TfEditCookie ec, IAnchor *paStart, IAnchor *paEnd, const VARIANT *pvarValue);
    HRESULT _ClearInternal(TfEditCookie ec, IAnchor *paStart, IAnchor *paEnd);

    HRESULT _Serialize(CRange *pRange, TF_PERSISTENT_PROPERTY_HEADER_ANCHOR *pHdr, IStream *pStream);
    HRESULT _Unserialize(const TF_PERSISTENT_PROPERTY_HEADER_ANCHOR *pHdr, IStream *pStream, ITfPersistentPropertyLoaderAnchor *pLoader);

    HRESULT _InternalFindRange(CRange *pRange, CRange **ppv, TfAnchor aPos, BOOL fEnd);

    PROPERTYLIST *_FindPropList(IAnchor *paStart, IAnchor *paEnd);
    PROPERTYLIST *_FindPropListAndDivide(IAnchor *paStart, IAnchor *paEnd);
    HRESULT _SetStoreInternal(TfEditCookie ec, CRange *pRange, ITfPropertyStore *pPropStore, BOOL fInternal);

    CSpanSet *_GetSpanSet() { return _pss; }
    void _ClearSpanSet() { _pss = NULL; }
    void _ResetSpanSet() { _pss->Reset(); }

    HRESULT _GetDataInternal(IAnchor *paStart, IAnchor *paEnd, VARIANT *pvarValue);

#ifdef DEBUG
    void _Dbg_AssertNoChangeHistory();
    GUID _dbg_guid;
#else
    void _Dbg_AssertNoChangeHistory() {}
#endif // DEBUG

private:

    PROPERTYLIST *_FindComplex(IAnchor *pa, LONG *piOut, BOOL fEnd, BOOL fTextUpdate);
    PROPERTYLIST *_FindUpdateTouchup(IAnchor *pa, int *piMid, BOOL fEnd);

    void _ClearOneSpan(IAnchor *paStart, IAnchor *paEnd, int iIndex, BOOL fStartMatchesSpanEnd, BOOL fEndMatchesSpanStart, DWORD dwFlags, BOOL fTextUpdate);
    BOOL _OnTextUpdate(DWORD dwFlags, PROPERTYLIST *pPropertyList, IAnchor *paStart, IAnchor *paEnd);
    void _MovePropertySpans(int iDst, int iSrc, int iCount);
    BOOL _ClearFirstLastSpan(BOOL fFirst, BOOL fMatchesSpanEdge,
                             IAnchor *paStart, IAnchor *paEnd, PROPERTYLIST *pPropertyList,
                             DWORD dwFlags, BOOL fTextUpdate, BOOL *pfSkipNextOnTextUpdate);

    void _ClearChangeHistory(PROPERTYLIST *prop, DWORD *pdwStartHistory, DWORD *pdwEndHistory);

    HRESULT Set(IAnchor *paStart, IAnchor *paEnd, ITfPropertyStore *pPropStore);

    CSpanSet *_CreateSpanSet()
    {
        if (_pss == NULL)
        {
            _pss = new CSpanSet;
        }
        return _pss;
    }

    BOOL _IsValidEditCookie(TfEditCookie ec, DWORD dwFlags);

    PROPERTYLIST *_CreateNewProp(IAnchor *paStart, IAnchor *paEnd, ITfPropertyStore *pPropStore, CPropertyLoad *pPropLoad);
    void _FreePropertyList(PROPERTYLIST *pProp);
    HRESULT _SetNewExtent(PROPERTYLIST *pProp, IAnchor *paStart, IAnchor *paEnd, BOOL fNew);
    HRESULT _Divide(PROPERTYLIST *pProp, IAnchor *paBreakPtStart, IAnchor *paBreakPtEnd, ITfPropertyStore **ppStore);
    void _RemoveProp(LONG iIndex, PROPERTYLIST *pProp);
    BOOL _InsertPropList(IAnchor *paStart, IAnchor *paEnd, ITfPropertyStore *pPropStore, CPropertyLoad *pPropLoad);
    BOOL _AddIntoProp(int nCur, IAnchor *paStart, IAnchor *paEnd, ITfPropertyStore *pPropStore);
    void _DefragAfterThis(int nCur);

    HRESULT _SetPropertyLoaderInternal(TfEditCookie ec, CRange *pRange, CPropertyLoad *pPropLoad);

    HRESULT _GetPropStoreFromStream(const TF_PERSISTENT_PROPERTY_HEADER_ANCHOR *pHdr, IStream *pStream, CRange *pRange, ITfPropertyStore **ppStore);

    HRESULT _CheckValidation(TfEditCookie ec, CRange *pRange);

    HRESULT _CheckOwner(TfClientId tid, IAnchor *paStart, IAnchor *paEnd);

    TfGuidAtom _guidatom;

    CPtrArray<PROPERTYLIST> _rgProp;

    //
    // if we use CSpanSet to record the deltas.
    //
    void PropertyUpdated(IAnchor *paStart, IAnchor *paEnd);
    CSpanSet *_pss;

    DWORD _dwCookie;
    DWORD _dwAuthority;
    DWORD _dwPropFlags;

#ifdef DEBUG
    void _Dbg_AssertProp();
#else
    void _Dbg_AssertProp() {}
#endif
    DBG_ID_DECLARE;
};


inline CProperty *GetCProperty(IUnknown *pProp)
{
    CProperty *pPropP;

    pProp->QueryInterface(IID_PRIV_CPROPERTY, (void **)&pPropP);

    return pPropP;
}

#endif // RPROP_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\ctf\uim\smblock.h ===
//
// smblock.h
//

#ifndef SMBLOCK_H
#define SMBLOCK_H

#include "private.h"
#include "cicmutex.h"

#define SZSHAREDFILEMAP    __TEXT("SFM.")
#define SZSHAREDMUTEX      __TEXT("MUTEX.")

class CSharedHeap9x;

//////////////////////////////////////////////////////////////////////////////
//
// instead of wsprintf
//
//////////////////////////////////////////////////////////////////////////////

#define ONEDWORDCCHFORSETNAME 9

__inline BOOL SetName(TCHAR *pszDst, UINT cchDst, const TCHAR *pszSrc, DWORD dw)
{
    TCHAR *psz;
    StringCchCopy(pszDst, cchDst, pszSrc);
    psz = pszDst + lstrlen(pszDst);

    if (cchDst < (UINT)(psz - pszDst)/sizeof(TCHAR) + ONEDWORDCCHFORSETNAME)
    {
        Assert(0);
        return FALSE;
    }

    while (dw)
    {
        *psz = 'A' + ((char)dw & 0x0F);
        dw >>= 4;
        psz++;
    }

    *psz = '\0';
    return TRUE;
}

__inline BOOL SetName2(TCHAR *pszDst, UINT cchDst, const TCHAR *pszSrc, DWORD dw, DWORD dw2, DWORD dw3 = 0)
{
    TCHAR *psz;
    StringCchCopy(pszDst, cchDst, pszSrc);
    psz = pszDst + lstrlen(pszDst);

    if (cchDst < (UINT)(psz - pszDst)/sizeof(TCHAR) + 
                 ONEDWORDCCHFORSETNAME * 2 + 
                 (dw3 ? ONEDWORDCCHFORSETNAME : 0))
    {
        Assert(0);
        return FALSE;
    }
    
    while (dw)
    {
        *psz = 'A' + ((char)dw & 0x0F);
        dw >>= 4;
        psz++;
    }

    *psz = '.';
    psz++;

    while (dw2)
    {
        *psz = 'A' + ((char)dw2 & 0x0F);
        dw2 >>= 4;
        psz++;
    }

    if (dw3)
    {
        *psz = '.';
        psz++;

        while (dw3)
        {
            *psz = 'A' + ((char)dw3 & 0x0F);
            dw3 >>= 4;
            psz++;
        }
    }

    *psz = '\0';
    return TRUE;
}


//////////////////////////////////////////////////////////////////////////////
//
// func
//
//////////////////////////////////////////////////////////////////////////////

CSharedHeap *EnsureSharedHeap(SYSTHREAD *psfn);
void DestroySharedHeap(SYSTHREAD *psfn);
CSharedBlock *EnsureSharedBlockForThread(SYSTHREAD *psfn, DWORD dwThreadId);
void DestroySharedBlocks(SYSTHREAD *psfn);

//////////////////////////////////////////////////////////////////////////////
//
// CSharedBlock
//
//////////////////////////////////////////////////////////////////////////////

class CSharedBlock
{
public:
    CSharedBlock(const char *pszPrefix, DWORD dwThread) 
    {
        _pszPrefix = pszPrefix; 
        _dwThread = dwThread; 
    }

    virtual ~CSharedBlock() 
    {
        _mutex.Uninit();
    }

    virtual HRESULT Init(SECURITY_DESCRIPTOR *pSecDes,
                         ULONG ulSize,
                         ULONG ulCommitSize,
                         void *pvBase,
                         BOOL fCreate,
                         BOOL *pfAlreadyExists = NULL) = 0;
    virtual HRESULT Commit(ULONG ulNewSize) = 0;
    virtual HRESULT Reset() = 0;

    void *GetBase() {return _pvBase;}
    virtual void *GetPtr(ULONG ulOffset)  = 0;
    virtual void *GetPtrFromBlockId(ULONG ulBlockId)  = 0;
    virtual BOOL IsValidPtr(void *pv) = 0;

    ULONG GetOffset(void *pv)
    {
        return (ULONG)((BYTE *)pv - (BYTE *)_pvBase);
    }

    ULONG GetCommitSize()
    {
        return _ulCommitSize;
    }

    ULONG GetInitCommitSize()
    {
        return _ulInitCommitSize;
    }
    DWORD GetThreadId()
    {
        return _dwThread;
    }

    CCicMutex *GetMutex()
    {
        return &_mutex;
    }

protected:
    void *_pvBase;
    ULONG _ulCommitSize;
    ULONG _ulInitCommitSize;
    CCicMutex _mutex;
    DWORD _dwThread;
    const char *_pszPrefix;
};


//////////////////////////////////////////////////////////////////////////////
//
// CSharedBlockNT
//
//////////////////////////////////////////////////////////////////////////////

class CSharedBlockNT : public CSharedBlock
{
public:
    CSharedBlockNT(const char *pszPrefix, DWORD dwThread, BOOL fUseUniqueName);
    ~CSharedBlockNT();

    HRESULT Init(SECURITY_DESCRIPTOR *pSecDes,
                 ULONG ulSize,
                 ULONG ulCommitSize,
                 void *pvBase,
                 BOOL fCreate,
                 BOOL *pfAlreadyExists);

    HRESULT Commit(ULONG ulNewSize);
    HRESULT Reset();

    void *GetPtrFromBlockId(ULONG ulBlockId);

    void *GetPtr(ULONG ulOffset) 
    {
        return (void *)(((BYTE *)_pvBase) + ulOffset);
    }
  
    BOOL IsValidPtr(void *pv)
    {
        if (pv < _pvBase)
            return FALSE;

        if (pv > (BYTE *)_pvBase + _ulCommitSize)
            return FALSE;

        return TRUE;
    }


private:
    HANDLE _hfm;
    BOOL _fUseUniqueName;
};


//////////////////////////////////////////////////////////////////////////////
//
// CSharedBlock9x
//
//////////////////////////////////////////////////////////////////////////////

#ifndef _WIN64
class CSharedBlock9x : public CSharedBlock
{
public:
    CSharedBlock9x(const char *pszPrefix, DWORD dwThread);
    ~CSharedBlock9x();

    HRESULT Init(SECURITY_DESCRIPTOR *pSecDes,
                 ULONG ulSize,
                 ULONG ulCommitSize,
                 void *pvBase,
                 BOOL fCreate,
                 BOOL *pfAlreadyExists);

    HRESULT Commit(ULONG ulNewSize);
    HRESULT Reset();

    void *GetPtrFromBlockId(ULONG ulOffset) 
    {
        Assert(ulOffset >= 0x80000000);
        return (void *)ulOffset;
    }

    void *GetPtr(ULONG ulOffset) 
    {
        return (void *)(((BYTE *)_pvBase) + ulOffset);
    }

private:
friend CSharedHeap9x;
    BOOL IsValidPtr(void *pv)
    {
         if (!_hsheap || !pv)
             return FALSE;
         // return HeapValid(_hsheap, 0, pv);
         return TRUE;
    }
    HANDLE _hsheap;
};
#endif // !_WIN64

//////////////////////////////////////////////////////////////////////////////
//
// CShraedHeap
//
//////////////////////////////////////////////////////////////////////////////

#define BLK_FREE   0x01

class CSharedHeap 
{
public:
    CSharedHeap(DWORD dwThread);
    ~CSharedHeap();


    HRESULT Init(SECURITY_DESCRIPTOR *pSecDes,
                 ULONG ulSize,
                 ULONG ulCommitSize);

    void *Alloc(ULONG ulSize);
#ifdef LATER
    void *Realloc(void *pv, ULONG ulSize);
#endif
    BOOL Free(void *pv);

    ULONG GetBlockId(void *pv)
    {
#ifndef _WIN64
        if (!IsOnNT())
            return (ULONG)pv;
#endif
        return _psb->GetOffset(pv);
    }

    CSharedBlock *GetBlock()
    {
        return _psb;
    }

    static BOOL IsValidBlock(CSharedBlock *psb, void *pv);

    typedef struct tag_HEAPHDR {
        ULONG ulList;
        ULONG ulSize;
    } HEAPHDR;

private:
    void InitHeap(ULONG ulInitSize);

    typedef struct tag_BLOCKHDR {
        ULONG ulPrev;
        ULONG ulNext;
        ULONG ulSize;
        ULONG ulFlags;
        ULONG u[4];

        ULONG GetSize() 
        {
            return ulSize;
        }

        void SetSize(ULONG ulNewSize) 
        {
            Assert(!(ulNewSize & 0x001f));
            ulSize = ulNewSize;
        }

        void SetFree(BOOL fFree)
        {
            if (fFree)
                ulFlags |= BLK_FREE;
            else
                ulFlags &= ~BLK_FREE;
        }

        BOOL IsFree()
        {
            return (ulFlags & BLK_FREE) ? TRUE : FALSE;
        }

        void *GetPtr()
        {
            BYTE *pb = (BYTE *)this;
            return pb + sizeof(tag_BLOCKHDR);
        }

    } BLOCKHDR;

    void MergeFreeBlock(BLOCKHDR *pbhdr);

#ifdef DEBUG
    void _dbg_HeapCheck();
#else
    void _dbg_HeapCheck() {};
#endif

    CSharedBlock *_psb;
    DWORD _dwThread;
};

#endif // SMBLOCK_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\ctf\uim\server.cpp ===
//+---------------------------------------------------------------------------
//
//  File:       server.cpp
//
//  Contents:   COM server functionality.
//
//----------------------------------------------------------------------------

#include "private.h"
#include "cresstr.h"
#include "tim.h"
#include "imelist.h"
#include "utb.h"
#include "dam.h"
#include "catmgr.h"
#include "nuimgr.h"
#include "profiles.h"
#include "msaa.h"

//
//  DWORD value for TIP Categories.
//  This will be an sort order of UI.
//
#define ORDER_TFCAT_TIP_KEYBOARD      10
#define ORDER_TFCAT_TIP_SPEECH        11
#define ORDER_TFCAT_TIP_HANDWRITING   12
#define ORDER_TFCAT_TIP_REFERENCE     13
#define ORDER_TFCAT_TIP_PROOFING      14
#define ORDER_TFCAT_TIP_SMARTTAG      15

BEGIN_COCLASSFACTORY_TABLE
    DECLARE_COCLASSFACTORY_ENTRY(CLSID_TF_ThreadMgr, CThreadInputMgr, TEXT("TF_ThreadMgr"))
    DECLARE_COCLASSFACTORY_ENTRY(CLSID_TF_InputProcessorProfiles, CInputProcessorProfiles, TEXT("TF_InputProcessorProfiles"))
    DECLARE_COCLASSFACTORY_ENTRY(CLSID_TF_LangBarMgr, CLangBarMgr, TEXT("TF_LangBarMgr"))
    DECLARE_COCLASSFACTORY_ENTRY(CLSID_TF_DisplayAttributeMgr, CDisplayAttributeMgr, TEXT("TF_DisplayAttributeMgr"))
    DECLARE_COCLASSFACTORY_ENTRY(CLSID_TF_CategoryMgr, CCategoryMgr, TEXT("TF_CategoryMgr"))
    DECLARE_COCLASSFACTORY_ENTRY(CLSID_TF_LangBarItemMgr, CLangBarItemMgr_Ole, TEXT("TF_LangBarItemMgr"))
    DECLARE_COCLASSFACTORY_ENTRY(CLSID_TF_MSAAControl, CMSAAControl, TEXT("TF_MSAAControl"))
END_COCLASSFACTORY_TABLE

//+---------------------------------------------------------------------------
//
//  DllGetClassObject
//
//----------------------------------------------------------------------------

STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, void **ppvObj)
{
    return COMBase_DllGetClassObject(rclsid, riid, ppvObj);
}

//+---------------------------------------------------------------------------
//
//  DllCanUnloadNow
//
//----------------------------------------------------------------------------

STDAPI DllCanUnloadNow(void)
{
    return COMBase_DllCanUnloadNow();
}

//+---------------------------------------------------------------------------
//
//  DllRegisterServer
//
//----------------------------------------------------------------------------

STDAPI DllRegisterServer(void)
{
    HRESULT hr = COMBase_DllRegisterServer();

    if (hr == S_OK)
    {
        MyRegisterCategory(GUID_TFCAT_DISPLAYATTRIBUTEPROPERTY, GUID_PROP_ATTRIBUTE);
        MyRegisterGUIDDescription(GUID_PROP_ATTRIBUTE, CRStr(IDS_PROP_ATTRIBUTE));

        MyRegisterCategory(GUID_TFCAT_CATEGORY_OF_TIP, GUID_TFCAT_TIP_KEYBOARD);
        MyRegisterCategory(GUID_TFCAT_CATEGORY_OF_TIP, GUID_TFCAT_TIP_SPEECH);
        MyRegisterCategory(GUID_TFCAT_CATEGORY_OF_TIP, GUID_TFCAT_TIP_HANDWRITING);
        MyRegisterCategory(GUID_TFCAT_CATEGORY_OF_TIP, GUID_TFCAT_TIP_REFERENCE);
        MyRegisterCategory(GUID_TFCAT_CATEGORY_OF_TIP, GUID_TFCAT_TIP_PROOFING);
        MyRegisterCategory(GUID_TFCAT_CATEGORY_OF_TIP, GUID_TFCAT_TIP_SMARTTAG);
        MyRegisterGUIDDescription(GUID_TFCAT_TIP_KEYBOARD, CRStr(IDS_TFCAT_TIP_KEYBOARD));
        MyRegisterGUIDDescription(GUID_TFCAT_TIP_SPEECH, CRStr(IDS_TFCAT_TIP_SPEECH));
        MyRegisterGUIDDescription(GUID_TFCAT_TIP_HANDWRITING, CRStr(IDS_TFCAT_TIP_HANDWRITING));
        MyRegisterGUIDDescription(GUID_TFCAT_TIP_REFERENCE, CRStr(IDS_TFCAT_TIP_REFERENCE));
        MyRegisterGUIDDescription(GUID_TFCAT_TIP_PROOFING, CRStr(IDS_TFCAT_TIP_PROOFING));
        MyRegisterGUIDDescription(GUID_TFCAT_TIP_SMARTTAG, CRStr(IDS_TFCAT_TIP_SMARTTAG));
        MyRegisterGUIDDWORD(GUID_TFCAT_TIP_KEYBOARD, ORDER_TFCAT_TIP_KEYBOARD);
        MyRegisterGUIDDWORD(GUID_TFCAT_TIP_SPEECH, ORDER_TFCAT_TIP_SPEECH);
        MyRegisterGUIDDWORD(GUID_TFCAT_TIP_HANDWRITING, ORDER_TFCAT_TIP_HANDWRITING);
        MyRegisterGUIDDWORD(GUID_TFCAT_TIP_REFERENCE, ORDER_TFCAT_TIP_REFERENCE);
        MyRegisterGUIDDWORD(GUID_TFCAT_TIP_PROOFING, ORDER_TFCAT_TIP_PROOFING);
        MyRegisterGUIDDWORD(GUID_TFCAT_TIP_SMARTTAG, ORDER_TFCAT_TIP_SMARTTAG);
    }

    return hr;
}

//+---------------------------------------------------------------------------
//
//  DllUnregisterServer
//
//----------------------------------------------------------------------------

STDAPI DllUnregisterServer(void)
{
    HRESULT hr = COMBase_DllUnregisterServer();

    if (hr == S_OK)
    {
        MyUnregisterCategory(GUID_TFCAT_DISPLAYATTRIBUTEPROPERTY, GUID_PROP_ATTRIBUTE);
        MyUnregisterCategory(GUID_TFCAT_CATEGORY_OF_TIP, GUID_TFCAT_TIP_KEYBOARD);
        MyUnregisterCategory(GUID_TFCAT_CATEGORY_OF_TIP, GUID_TFCAT_TIP_SPEECH);
        MyUnregisterCategory(GUID_TFCAT_CATEGORY_OF_TIP, GUID_TFCAT_TIP_HANDWRITING);
        MyUnregisterCategory(GUID_TFCAT_CATEGORY_OF_TIP, GUID_TFCAT_TIP_REFERENCE);
        MyUnregisterCategory(GUID_TFCAT_CATEGORY_OF_TIP, GUID_TFCAT_TIP_PROOFING);
        MyUnregisterCategory(GUID_TFCAT_CATEGORY_OF_TIP, GUID_TFCAT_TIP_SMARTTAG);

        MyUnregisterGUIDDescription(GUID_TFCAT_TIP_KEYBOARD);
        MyUnregisterGUIDDescription(GUID_TFCAT_TIP_SPEECH);
        MyUnregisterGUIDDescription(GUID_TFCAT_TIP_HANDWRITING);
        MyUnregisterGUIDDescription(GUID_TFCAT_TIP_REFERENCE);
        MyUnregisterGUIDDescription(GUID_TFCAT_TIP_PROOFING);
        MyUnregisterGUIDDescription(GUID_TFCAT_TIP_SMARTTAG);
        MyUnregisterGUIDDWORD(GUID_TFCAT_TIP_KEYBOARD);
        MyUnregisterGUIDDWORD(GUID_TFCAT_TIP_SPEECH);
        MyUnregisterGUIDDWORD(GUID_TFCAT_TIP_HANDWRITING);
        MyUnregisterGUIDDWORD(GUID_TFCAT_TIP_REFERENCE);
        MyUnregisterGUIDDWORD(GUID_TFCAT_TIP_PROOFING);
        MyUnregisterGUIDDWORD(GUID_TFCAT_TIP_SMARTTAG);
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\ctf\uim\smblock.cpp ===
//
// smblock.cpp
//

#include "private.h"
#include "globals.h"
#include "marshal.h"
#include "smblock.h"
#include "osver.h"

#define MAXHEAPSIZE      0x00080000
#define INITIALHEAPSIZE  0x00002000
#define RESETHEAPSIZE    0x00008000

const char c_szShared[] = "MSCTF.Shared.";

//////////////////////////////////////////////////////////////////////////////
//
// func
//
//////////////////////////////////////////////////////////////////////////////

//--------------------------------------------------------------------------
//
//  EnsureSharedHeap
//
//--------------------------------------------------------------------------

CSharedHeap *EnsureSharedHeap(SYSTHREAD *psfn)
{
    Assert(psfn);

    if (psfn->psheap)
        return psfn->psheap;

    DWORD dwThread = GetCurrentThreadId();

    psfn->psheap = new CSharedHeap(dwThread);
    if (!psfn->psheap)
        return NULL;

    if (FAILED(psfn->psheap->Init(NULL, INITIALHEAPSIZE, MAXHEAPSIZE)))
    {
        delete psfn->psheap;
        psfn->psheap = NULL;
    }

    return psfn->psheap;
}

//--------------------------------------------------------------------------
//
//  DestroySharedHeap
//
//--------------------------------------------------------------------------

void DestroySharedHeap(SYSTHREAD *psfn)
{
    Assert(psfn);

    if (!psfn->psheap)
        return;

    delete psfn->psheap;
    psfn->psheap = NULL;
}

//--------------------------------------------------------------------------
//
//  EnsureSharedBlockForThread
//
//--------------------------------------------------------------------------

#define MAX_THREAD_NUM 15

CSharedBlock *EnsureSharedBlockForThread(SYSTHREAD *psfn, DWORD dwThreadId)
{
    int nCnt;
    int i;
    CSharedBlock *psb = NULL;
    Assert(psfn);

    if (!psfn->prgThreadMem)
        psfn->prgThreadMem = new CPtrArray<CSharedBlock>;

    if (!psfn->prgThreadMem)
        return NULL;


    nCnt = psfn->prgThreadMem->Count();
    for (i = 0; i < nCnt; i++)
    {
        psb = psfn->prgThreadMem->Get(i);
        if (psb->GetThreadId() == dwThreadId)
        {
            //
            // this thread mem was found in the 2nd half of this list.
            // we don't have to reorder this entry.
            //
            if (nCnt < (MAX_THREAD_NUM) / 2 || (i >= (nCnt / 2)))
                goto Exit;

            //
            // reorder this entry.
            //
            psfn->prgThreadMem->Remove(i,1);
            goto SetPSB;
        }
    }

#ifndef _WIN64
    if (!IsOnNT())
        psb = new CSharedBlock9x(c_szShared, dwThreadId);
    else
#endif
        psb = new CSharedBlockNT(c_szShared, dwThreadId, FALSE);

    if (!psb)
        return NULL;

    if (FAILED(psb->Init(NULL, 0, 0, NULL, FALSE)))
    {
        delete psb;
        return NULL;
    }

SetPSB:
    if (psfn->prgThreadMem->Count() >= MAX_THREAD_NUM)
    {
        //
        // delete the oldest thread mem entry.
        //
        CSharedBlock *psbTemp = psfn->prgThreadMem->Get(0);
        psfn->prgThreadMem->Remove(0, 1);
        delete psbTemp;
    }

    CSharedBlock **ppsb = psfn->prgThreadMem->Append(1);
    if (!ppsb)
    {
        delete psb;
        return NULL;
        
    }

    *ppsb = psb;
Exit:
    return psb;
}

//--------------------------------------------------------------------------
//
//  DestroySharedBlocks
//
//--------------------------------------------------------------------------

void DestroySharedBlocks(SYSTHREAD *psfn)
{
    int nCnt;
    int i;
    CSharedBlock *psb = NULL;
    Assert(psfn);

    if (!psfn->prgThreadMem)
        return;

    nCnt = psfn->prgThreadMem->Count();
    for (i = 0; i < nCnt; i++)
    {
        psb = psfn->prgThreadMem->Get(i);
        delete psb;
    }

    delete psfn->prgThreadMem;
    psfn->prgThreadMem = NULL;
    return;
}


//////////////////////////////////////////////////////////////////////////////
//
// CSharedBlockNT
//
//////////////////////////////////////////////////////////////////////////////

//--------------------------------------------------------------------------
//
//  ctor
//
//--------------------------------------------------------------------------

CSharedBlockNT::CSharedBlockNT(const char *pszPrefix, DWORD dwThread, BOOL fUseUniqueName) : CSharedBlock(pszPrefix, dwThread)
{
    _fUseUniqueName = fUseUniqueName;
}

//--------------------------------------------------------------------------
//
//  dtor
//
//--------------------------------------------------------------------------

CSharedBlockNT::~CSharedBlockNT()
{
    if (_pvBase)
        UnmapViewOfFile(_pvBase);

    if (_hfm)
        CloseHandle(_hfm);

    TraceMsg(TF_GENERAL, "CSharedBlock dtor");
    TraceMsg(TF_GENERAL, "    _dwThread           0x%08x", _dwThread);
    TraceMsg(TF_GENERAL, "    _ulInitCommitSize   0x%08x", _ulInitCommitSize);
    TraceMsg(TF_GENERAL, "    _ulCommitSize       0x%08x", _ulCommitSize);
}

//--------------------------------------------------------------------------
//
//  Init
//
//--------------------------------------------------------------------------

HRESULT CSharedBlockNT::Init(SECURITY_DESCRIPTOR *pSecDes,
                           ULONG ulSize,
                           ULONG ulCommitSize,
                           void *pvBase,
                           BOOL fCreate,
                           BOOL *pfAlreadyExists)
{
    char szName[MAX_PATH];
    char szObjName[MAX_PATH];
    StringCopyArray(szName, _pszPrefix);
    int nLen = lstrlen(szName);

    if (!SetName(&szName[nLen], ARRAYSIZE(szName) - nLen, SZSHAREDMUTEX, _dwThread))
        return E_FAIL;

    if (_fUseUniqueName)
    {
        GetDesktopUniqueNameArray(szName, szObjName);
    }
    else
        StringCchCopy(szObjName, ARRAYSIZE(szObjName), szName);

    if (!_mutex.Init(NULL, szObjName))
        return E_FAIL;

    if (!SetName(&szName[nLen], ARRAYSIZE(szName) - nLen, SZSHAREDFILEMAP, _dwThread))
        return E_FAIL;

    if (_fUseUniqueName)
    {
        GetDesktopUniqueNameArray(szName, szObjName);
    }
    else
        StringCchCopy(szObjName, ARRAYSIZE(szObjName), szName);

    if (fCreate)
    {
        _hfm = CreateFileMapping(INVALID_HANDLE_VALUE, 
                                 NULL, 
                                 PAGE_READWRITE | SEC_RESERVE,
                                 0, 
                                 ulSize, 
                                 szObjName);

        if (pfAlreadyExists != NULL)
        {
            *pfAlreadyExists = (GetLastError() == ERROR_ALREADY_EXISTS);
        }

    }
    else
    {
        _hfm = OpenFileMapping(FILE_MAP_ALL_ACCESS, FALSE, szObjName);

        if (pfAlreadyExists != NULL)
        {
            *pfAlreadyExists = _hfm ? TRUE : FALSE;
        }
    }

    if (_hfm == NULL)
    {
        TraceMsg(TF_GENERAL, "CSharedBlock Init: Open/CreateFileMapping failed");
        Assert(!fCreate);

        return E_OUTOFMEMORY;
    }

    _pvBase = (void *)MapViewOfFile(_hfm, 
                                    FILE_MAP_WRITE, 
                                    0, 
                                    0, 
                                    0);

    if (!_pvBase)
    {
        TraceMsg(TF_GENERAL, "CSharedBlock Init: MapVieOfFile failed");
        return E_OUTOFMEMORY;
    }


    if (fCreate)
    {
        void *pvResult;
        pvResult = VirtualAlloc(_pvBase, 
                                ulCommitSize, 
                                MEM_COMMIT, 
                                PAGE_READWRITE);

        if (!pvResult)
        {
            TraceMsg(TF_GENERAL, "CSharedBlock Init: VirtualAlloc failed");
            CloseHandle(_hfm);
            _hfm = NULL;
            return E_OUTOFMEMORY;
        }
    }

    _ulCommitSize = ulCommitSize;
    _ulInitCommitSize = ulCommitSize;

    return S_OK;
}


//--------------------------------------------------------------------------
//
//  GetPtrFromBlockId
//
//--------------------------------------------------------------------------

void *CSharedBlockNT::GetPtrFromBlockId(ULONG ulBlockId) 
{
    if (((CSharedHeap::HEAPHDR *)_pvBase)->ulSize <= ulBlockId)
    {
        Assert(0);
        return NULL;
    }

    return GetPtr(ulBlockId);
}

//--------------------------------------------------------------------------
//
//  Commit
//
//--------------------------------------------------------------------------

HRESULT CSharedBlockNT::Commit(ULONG ulNewSize)
{
    void *pv;


    Assert(ulNewSize >= _ulCommitSize);
    if (ulNewSize == _ulCommitSize)   
        return S_OK;

    pv = VirtualAlloc(_pvBase, ulNewSize, MEM_COMMIT, PAGE_READWRITE);

    if (!pv)
    {
        TraceMsg(TF_GENERAL, "CSharedBlock Commit: VirtualAlloc failed");
        return E_OUTOFMEMORY;
    }

    _ulCommitSize = ulNewSize;
    return S_OK;
}

//--------------------------------------------------------------------------
//
//  Reset
//
//--------------------------------------------------------------------------

HRESULT CSharedBlockNT::Reset()
{
    void *pv;

    Assert(_ulCommitSize >= _ulInitCommitSize);
    if (_ulCommitSize == _ulInitCommitSize)   
        return S_FALSE;

    VirtualFree(_pvBase, _ulCommitSize, MEM_DECOMMIT);

    pv = VirtualAlloc(_pvBase, _ulInitCommitSize, MEM_COMMIT, PAGE_READWRITE);

    if (!pv)
    {
        TraceMsg(TF_GENERAL, "CSharedBlock Reset: VirtualAlloc failed");
        return E_OUTOFMEMORY;
    }

    TraceMsg(TF_GENERAL, "CSharedBlock Reset");
    TraceMsg(TF_GENERAL, "    Old _ulCommitSize  0x%08x", _ulCommitSize);
    TraceMsg(TF_GENERAL, "    New _ulCommitSize  0x%08x", _ulInitCommitSize);

    _ulCommitSize = _ulInitCommitSize;
    return S_OK;
}


//////////////////////////////////////////////////////////////////////////////
//
// CSharedBlock9x
//
//////////////////////////////////////////////////////////////////////////////
#ifndef _WIN64

//--------------------------------------------------------------------------
//
//  ctor
//
//--------------------------------------------------------------------------

CSharedBlock9x::CSharedBlock9x(const char *pszPrefix, DWORD dwThread) : CSharedBlock(pszPrefix, dwThread)
{
    _hsheap = NULL;
}

//--------------------------------------------------------------------------
//
//  dtor
//
//--------------------------------------------------------------------------

CSharedBlock9x::~CSharedBlock9x()
{
    if (_pvBase)
        HeapFree(_hsheap, 0, _pvBase);

    if (_hsheap)
        HeapDestroy(_hsheap);

    TraceMsg(TF_GENERAL, "CSharedBlock 9x dtor");
    TraceMsg(TF_GENERAL, "    _dwThread           0x%08x", _dwThread);
    TraceMsg(TF_GENERAL, "    _ulInitCommitSize   0x%08x", _ulInitCommitSize);
    TraceMsg(TF_GENERAL, "    _ulCommitSize       0x%08x", _ulCommitSize);
}

//--------------------------------------------------------------------------
//
//  Init
//
//--------------------------------------------------------------------------

HRESULT CSharedBlock9x::Init(SECURITY_DESCRIPTOR *pSecDes,
                             ULONG ulSize,
                             ULONG ulCommitSize,
                             void *pvBase,
                             BOOL fCreate,
                             BOOL *pfAlreadyExists)
{
    char szName[MAX_PATH];
    StringCopyArray(szName, _pszPrefix);
    UINT uLen = lstrlen(szName);

    if (!SetName(&szName[uLen], ARRAYSIZE(szName) - uLen, SZSHAREDMUTEX, _dwThread))
        return E_FAIL;

    if (!_mutex.Init(NULL, szName))
        return E_FAIL;

    if (fCreate)
    {
        _hsheap = HeapCreate(0x04000000, ulCommitSize + 0x100, 0);

        if ( _hsheap == NULL )
            return E_FAIL;

        _pvBase = HeapAlloc(_hsheap, 0, ulCommitSize);

        if (pfAlreadyExists != NULL)
        {
            *pfAlreadyExists = TRUE;
        }
    }
    else
    {
        _hsheap = NULL;
        _pvBase = NULL;

        if (pfAlreadyExists != NULL)
        {
            *pfAlreadyExists = FALSE;
        }
    }

    _ulCommitSize = ulCommitSize;
    _ulInitCommitSize = ulCommitSize;
    return S_OK;
}


//--------------------------------------------------------------------------
//
//  Commit
//
//--------------------------------------------------------------------------

HRESULT CSharedBlock9x::Commit(ULONG ulNewSize)
{
    void *pvNew;
    pvNew = HeapReAlloc(_hsheap, 0, _pvBase, ulNewSize);

    if (!pvNew)
    {
        HeapFree(_hsheap, 0, _pvBase);
        _pvBase = NULL;
        return E_OUTOFMEMORY;
    }

    TraceMsg(TF_GENERAL, "Commit  0x%08x", ulNewSize);
    _pvBase = pvNew;
    _ulCommitSize = ulNewSize;
    return S_OK;
}

//--------------------------------------------------------------------------
//
//  Reset
//
//--------------------------------------------------------------------------

HRESULT CSharedBlock9x::Reset()
{
    Assert(_ulCommitSize >= _ulInitCommitSize);
    if (_ulCommitSize == _ulInitCommitSize)   
        return S_FALSE;

    HeapFree(_hsheap, 0, _pvBase);
    _pvBase = HeapAlloc(_hsheap, 0, _ulInitCommitSize);
    if (!_pvBase)
        return E_OUTOFMEMORY;

    _ulCommitSize = _ulInitCommitSize;

    return S_OK;
}
#endif // !_WIN64


//////////////////////////////////////////////////////////////////////////////
//
// CSharedHeap
//
//////////////////////////////////////////////////////////////////////////////

//--------------------------------------------------------------------------
//
//  ctor
//
//--------------------------------------------------------------------------

CSharedHeap::CSharedHeap(DWORD dwThread)
{
    _dwThread = dwThread;
    _psb = NULL;
}

//--------------------------------------------------------------------------
//
//  dtor
//
//--------------------------------------------------------------------------

CSharedHeap::~CSharedHeap()
{
#ifdef DEBUG
    if (_psb->GetBase())
    {
        HEAPHDR *phhdr = (HEAPHDR *)_psb->GetPtr(0);
        BLOCKHDR *pbhdr = (BLOCKHDR *)_psb->GetPtr(phhdr->ulList);
        Assert(pbhdr->IsFree());
        Assert(pbhdr->ulNext == (-1));
    }
#endif

    if (_psb)
        delete _psb;
}

//--------------------------------------------------------------------------
//
//  Init
//
//--------------------------------------------------------------------------

HRESULT CSharedHeap::Init(SECURITY_DESCRIPTOR *pSecDes,
                          ULONG ulInitSize,
                          ULONG ulMaxSize)
{
    HRESULT hr;

#ifndef _WIN64
    if (!IsOnNT())
        _psb = new CSharedBlock9x(c_szShared, _dwThread);
    else
#endif
        _psb = new CSharedBlockNT(c_szShared, _dwThread, FALSE);

    if (!_psb)
        return E_OUTOFMEMORY;

    hr = _psb->Init(pSecDes, ulMaxSize, ulInitSize, NULL, TRUE);
    if (FAILED(hr))
        return E_FAIL;

    InitHeap(ulInitSize);
    return S_OK;
}

//--------------------------------------------------------------------------
//
//  InitHeap
//
//--------------------------------------------------------------------------

void CSharedHeap::InitHeap(ULONG ulInitSize)
{
    BYTE *pb;
    HEAPHDR *phhdr;
    BLOCKHDR *pbhdr;

    //
    // init heap header.
    //
    pb = (BYTE *)_psb->GetPtr(0);
    phhdr = (HEAPHDR *)pb;
    phhdr->ulList = _psb->GetOffset(pb + sizeof(HEAPHDR));
    phhdr->ulSize = ulInitSize;

    //
    // init first block
    //
    pb = (BYTE *)_psb->GetPtr(phhdr->ulList);
    pbhdr = (BLOCKHDR *)pb;
    pbhdr->ulPrev = 0;
    pbhdr->ulNext = -1;
    pbhdr->SetFree(TRUE);
    pbhdr->SetSize(ulInitSize - _psb->GetOffset(pb + sizeof(BLOCKHDR)) & ~0x1f);

    _dbg_HeapCheck();
}

//--------------------------------------------------------------------------
//
//  Alloc
//
//--------------------------------------------------------------------------

void *CSharedHeap::Alloc(ULONG ulSize)
{
    BYTE *pb;
    HEAPHDR *phhdr;
    BLOCKHDR *pbhdr = NULL;
    ULONG ulCur;
    BOOL fFound = FALSE;
    BOOL fHeapIncreased = FALSE;
    void *pvRet = NULL;
    
    if (!GetBlock()->GetMutex()->Enter())
        return NULL;

    _dbg_HeapCheck();

    ulSize += 0x0000001F;
    ulSize &= (ULONG)(-0x20);

    pb = (BYTE *)_psb->GetPtr(0);
    phhdr = (HEAPHDR *)pb;

TryAgain:
    ulCur = phhdr->ulList;

    while (ulCur != -1)
    {
        pbhdr = (BLOCKHDR *)_psb->GetPtr(ulCur);
        if (pbhdr->IsFree() && (pbhdr->GetSize() >= ulSize))
        {
            fFound = TRUE;
            break;
        }
        ulCur = pbhdr->ulNext;
    }

    if (!fFound)
    {
        if (!pbhdr)
        {
            pvRet = NULL;
            goto Exit;
        }

        Assert(pbhdr->ulNext == (-1));

        if (fHeapIncreased)
        {
            pvRet = NULL;
            goto Exit;
        }

        if (FAILED(_psb->Commit(_psb->GetCommitSize() + ulSize)))
        {
            pvRet = NULL;
            goto Exit;
        }

        phhdr->ulSize += ulSize;
        pbhdr->SetSize(pbhdr->GetSize() + ulSize);
        fHeapIncreased = TRUE;
        goto TryAgain;
    }

    Assert(pbhdr->GetSize() >= ulSize);
    if (pbhdr->GetSize() < (ulSize + 32 + sizeof(BLOCKHDR)))
    {
        pbhdr->SetFree(FALSE);
    }
    else
    {
        pbhdr->SetFree(FALSE);
        pbhdr->SetSize(ulSize);
    
        BLOCKHDR *pbhdrNext = (BLOCKHDR *)((BYTE *)pbhdr->GetPtr() + ulSize);
        pbhdrNext->ulNext = pbhdr->ulNext;
        pbhdrNext->ulPrev = _psb->GetOffset(pbhdr);
        pbhdr->ulNext = _psb->GetOffset(pbhdrNext);
        ULONG ulNewSize;
        if (pbhdrNext->ulNext != (-1))
             ulNewSize = pbhdrNext->ulNext - pbhdr->ulNext - sizeof(BLOCKHDR);
        else
             ulNewSize = (_psb->GetCommitSize() - 
                          _psb->GetOffset((BYTE*)pbhdrNext + sizeof(BLOCKHDR))) & ~0x1f;

        pbhdrNext->SetSize(ulNewSize);
        pbhdrNext->SetFree(TRUE);
        BLOCKHDR *pbhdrNextNext = (BLOCKHDR *)((BYTE *)pbhdrNext->GetPtr() + ulNewSize);
        pbhdrNextNext->ulPrev = _psb->GetOffset(pbhdrNext);

    }

    _dbg_HeapCheck();

    pvRet = pbhdr->GetPtr();
Exit:
    GetBlock()->GetMutex()->Leave();
    return pvRet;
}

//--------------------------------------------------------------------------
//
//  Realloc
//
//--------------------------------------------------------------------------

#ifdef LATER
void *CSharedHeap::Realloc(void *pv, ULONG ulSize)
{
    if (!_psb->IsValidPtr(pv))
    {
        Assert(0);
        return NULL;
    }

    if (!GetBlock()->GetMutex()->Enter())
        return NULL;

    void *pvRet = NULL;

    BLOCKHDR *pbhdr = (BLOCKHDR *)((BYTE *)pv - sizeof(BLOCKHDR));
    if (pbhdr->GetSize() >= ulSize)
    {
        pvRet = pv;
        goto Exit;
    }

    //
    // perf: This should be smart!!
    //
    pvRet = Alloc(ulSize);
    if (pvRet)
    {
        memcpy(pvRet, pv, pbhdr->GetSize());
    }
    Free(pv);

Exit:
    GetBlock()->GetMutex()->Leave();
    return pvRet;
}
#endif


//--------------------------------------------------------------------------
//
//  Free
//
//--------------------------------------------------------------------------

BOOL CSharedHeap::Free(void *pv)
{
    if (!_psb->IsValidPtr(pv))
    {
        Assert(0);
        return FALSE;
    }

    if (!GetBlock()->GetMutex()->Enter())
        return FALSE;

    BOOL bRet = FALSE;
    _dbg_HeapCheck();

    HEAPHDR *phhdr;
    BLOCKHDR *pbhdr = (BLOCKHDR *)((BYTE *)pv - sizeof(BLOCKHDR));

    //
    // do nothing for free block.
    //
    if (pbhdr->IsFree())
    {
        Assert(0);
        goto Exit;
    }

    pbhdr->SetFree(TRUE);
    MergeFreeBlock(pbhdr);

    if (pbhdr->ulPrev)
    {
        BLOCKHDR *pbhdrPrev = (BLOCKHDR *)_psb->GetPtr(pbhdr->ulPrev);
        if (pbhdrPrev->IsFree())
            MergeFreeBlock(pbhdrPrev);
    }

    //
    // if we don't have any mem block, it is time to recommit the block.
    //
    phhdr = (HEAPHDR *)_psb->GetPtr(0);
    pbhdr = (BLOCKHDR *)_psb->GetPtr(phhdr->ulList);
    if (pbhdr->ulNext == (-1))
    {
        if (_psb->GetCommitSize() > RESETHEAPSIZE)
        {
            HRESULT hr = _psb->Reset();
            if (FAILED(hr))
            {
                Assert(0);
                goto Exit;
            }

            if (hr == S_OK)
                InitHeap(_psb->GetInitCommitSize());
        }
    }

    bRet = TRUE;
Exit:
    _dbg_HeapCheck();

    GetBlock()->GetMutex()->Leave();
    return bRet;
}

//--------------------------------------------------------------------------
//
//  MergeFreeBlock
//
//--------------------------------------------------------------------------

void CSharedHeap::MergeFreeBlock(BLOCKHDR *pbhdr)
{
    BLOCKHDR *pbhdrNext = (BLOCKHDR *)_psb->GetPtr(pbhdr->ulNext);
    BLOCKHDR *pbhdrNewNext = NULL;


    if (pbhdrNext->IsFree())
    {
        ULONG ulNewSize;
        pbhdr->ulNext = pbhdrNext->ulNext;

        if (pbhdr->ulNext != (-1))
        {
            pbhdrNewNext = (BLOCKHDR *)_psb->GetPtr(pbhdr->ulNext);
            // ulNewSize = pbhdrNewNext->ulNext - pbhdr->ulNext - sizeof(BLOCKHDR);
            ulNewSize = ((DWORD)(DWORD_PTR)((BYTE *)pbhdrNewNext - (BYTE *)pbhdr) - sizeof(BLOCKHDR));
            pbhdrNewNext->ulPrev = _psb->GetOffset(pbhdr);
        }
        else
        {
            ulNewSize = (_psb->GetCommitSize() - 
                          _psb->GetOffset((BYTE*)pbhdrNext + sizeof(BLOCKHDR))) & ~0x1f;
        }

        pbhdr->SetSize(ulNewSize);
    }

}

//--------------------------------------------------------------------------
//
//  IsValidBlock
//
//--------------------------------------------------------------------------

BOOL CSharedHeap::IsValidBlock(CSharedBlock *psb, void *pv)
{
    BOOL fFound = FALSE;

    //
    // On Win9x, we use system shared heap _psb does not have a pointer..
    // How can we valid the block??
    //
    if (!IsOnNT())
        return TRUE;

    _try 
    {
        BLOCKHDR *pbhdr = (BLOCKHDR *)((BYTE *)pv - sizeof(BLOCKHDR));
        BYTE *pb;
        HEAPHDR *phhdr;
        ULONG ulCur;
    
        pb = (BYTE *)psb->GetPtr(0);
        phhdr = (HEAPHDR *)pb;
        ulCur = phhdr->ulList;
    
        while (ulCur != -1)
        {
            BLOCKHDR *pbhdrTmp = (BLOCKHDR *)psb->GetPtr(ulCur);
    
            if (pbhdrTmp == pbhdr)
            {
                fFound = TRUE;
                break;
            }
            ulCur = pbhdrTmp->ulNext;
        }
    }
    _except(1)
    {
        Assert(0);
    }

    return fFound;

}


//--------------------------------------------------------------------------
//
//  _dbg_HeapCheck()
//
//--------------------------------------------------------------------------

#ifdef DEBUG
void CSharedHeap::_dbg_HeapCheck()
{
    HEAPHDR *phhdr = (HEAPHDR *)_psb->GetPtr(0);
    BLOCKHDR *pbhdr = NULL;
    BLOCKHDR *pbhdrPrev = NULL;
    ULONG ulCur = phhdr->ulList;

    while (ulCur != -1)
    {
        Assert(!(ulCur & CIC_ALIGNMENT));

        pbhdr = (BLOCKHDR *)_psb->GetPtr(ulCur);

        if (pbhdrPrev)
        {
            Assert(_psb->GetOffset(pbhdrPrev) == pbhdr->ulPrev);
            Assert(_psb->GetPtr(pbhdrPrev->ulNext) == pbhdr);
            Assert(pbhdrPrev->ulSize == 
                   ((BYTE *)pbhdr - (BYTE *)pbhdrPrev - sizeof(BLOCKHDR)));

            Assert(!pbhdrPrev->IsFree() || !pbhdr->IsFree());
        }
        else
        {
            Assert(!pbhdr->ulPrev);
        }

        pbhdrPrev = pbhdr;
        ulCur = pbhdr->ulNext;
    }

}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\ctf\uim\rprop.cpp ===
//
// rprop.cpp
//

#include "private.h"
#include "rprop.h"
#include "rngsink.h"
#include "immxutil.h"
#include "varutil.h"
#include "ic.h"
#include "tim.h"
#include "enumprop.h"
#include "tfprop.h"
#include "range.h"
#include "anchoref.h"

/* ccaefd20-38a6-11d3-a745-0050040ab407 */
const IID IID_PRIV_CPROPERTY = { 0xccaefd20, 0x38a6, 0x11d3, {0xa7, 0x45, 0x00, 0x50, 0x04, 0x0a, 0xb4, 0x07} };
    

//
// By using this fake CLSID, the StaticProperty pretends 
// to be an TFE for persistent data.
//
/* b6a4bc60-0749-11d3-8def-00105a2799b5 */
static const CLSID CLSID_IME_StaticProperty = { 
    0xb6a4bc60,
    0x0749,
    0x11d3,
    {0x8d, 0xef, 0x00, 0x10, 0x5a, 0x27, 0x99, 0xb5}
  };


DBG_ID_INSTANCE(CProperty);

inline void CheckCrossedAnchors(PROPERTYLIST *pProp)
{
    if (CompareAnchors(pProp->_paStart, pProp->_paEnd) > 0)
    {
        // for crossed anchors, we always move the start anchor to the end pos -- ie, don't move
        pProp->_paStart->ShiftTo(pProp->_paEnd);
    }
}

//+---------------------------------------------------------------------------
//
// IsEqualPropertyValue
//
//----------------------------------------------------------------------------

BOOL IsEqualPropertyValue(ITfPropertyStore *pStore1, ITfPropertyStore *pStore2)
{
    BOOL fEqual;
    VARIANT varValue1;
    VARIANT varValue2;

    if (pStore1->GetData(&varValue1) != S_OK)
        return FALSE;

    if (pStore2->GetData(&varValue2) != S_OK)
    {
        VariantClear(&varValue1);
        return FALSE;
    }

    if (varValue1.vt != varValue2.vt)
    {
        Assert(0); // shouldn't happen for property of same type
        VariantClear(&varValue1);
        VariantClear(&varValue2);
        return FALSE;
    }

    switch (varValue1.vt)
    {
        case VT_I4:
            fEqual = varValue1.lVal == varValue2.lVal;
            break;

        case VT_UNKNOWN:
            fEqual = IdentityCompare(varValue1.punkVal, varValue2.punkVal);
            varValue1.punkVal->Release();
            varValue2.punkVal->Release();
            break;

        case VT_BSTR:
            fEqual = (wcscmp(varValue1.bstrVal, varValue2.bstrVal) == 0);
            SysFreeString(varValue1.bstrVal);
            SysFreeString(varValue2.bstrVal);
            break;

        case VT_EMPTY:
            fEqual = TRUE;
            break;

        default:
            Assert(0); // invalid type
            fEqual = FALSE;
            VariantClear(&varValue1);
            VariantClear(&varValue2);
            break;
    }

    return fEqual;
}


//////////////////////////////////////////////////////////////////////////////
//
// CProperty
//
//////////////////////////////////////////////////////////////////////////////


//+---------------------------------------------------------------------------
//
// ctor
//
//----------------------------------------------------------------------------

CProperty::CProperty(CInputContext *pic, REFGUID guidProp, TFPROPERTYSTYLE propStyle, DWORD dwAuthority, DWORD dwPropFlags)
{
    Dbg_MemSetThisNameIDCounter(TEXT("CProperty"), PERF_PROP_COUNTER);

    _dwAuthority = dwAuthority;
    _propStyle = propStyle;
    _pic = pic; // don't need to AddRef because we are contained in the ic
                // CPropertySub, otoh, must AddRef the owner ic
    MyRegisterGUID(guidProp, &_guidatom);

    _dwPropFlags = dwPropFlags;
    _dwCookie = 0;

    Assert(_pss == NULL);

#ifdef DEBUG
    _dbg_guid = guidProp;
#endif // DEBUG
}

//+---------------------------------------------------------------------------
//
// dtor
//
//----------------------------------------------------------------------------

CProperty::~CProperty()
{
    int nCnt = GetPropNum();
    int i;

    for (i = 0; i < nCnt; i++)
    {
        PROPERTYLIST *pProp = GetPropList(i);
        Assert(pProp);
        _FreePropertyList(pProp);
    }

    _rgProp.Clear();

    if (_pss != NULL)
    {
        delete _pss;
    }

    Assert(!GetPropNum());
}

//+---------------------------------------------------------------------------
//
// _FreePropertyList
//
//----------------------------------------------------------------------------

void CProperty::_FreePropertyList(PROPERTYLIST *pProp)
{
    SafeRelease(pProp->_pPropStore);

    if (pProp->_pPropLoad)
    {
        delete pProp->_pPropLoad;
    }

    SafeRelease(pProp->_paStart);
    SafeRelease(pProp->_paEnd);

    cicMemFree(pProp);
}

//+---------------------------------------------------------------------------
//
// GetType
//
//----------------------------------------------------------------------------

HRESULT CProperty::GetType(GUID *pguid)
{
    return MyGetGUID(_guidatom, pguid);
}


//+---------------------------------------------------------------------------
//
// _FindComplex
//
// If piOut != NULL then it is set to the index where ich was found, or the
// index of the next lower ich if ich isn't in the array.
// If there is no element in the array with a lower ich, returns offset -1.
//
// If fTextUpdate == TRUE, the expectation is that this method is being called
// from _PropertyTextUpdate and we have to worry about empty or crossed spans.
//----------------------------------------------------------------------------

PROPERTYLIST *CProperty::_FindComplex(IAnchor *pa, LONG *piOut, BOOL fEnd, BOOL fTextUpdate)
{
    PROPERTYLIST *pProp;
    PROPERTYLIST *pPropMatch;
    int iMin;
    int iMax;
    int iMid;
    LONG l;

    pPropMatch = NULL;
    iMid = -1;
    iMin = 0;
    iMax = _rgProp.Count();

    while (iMin < iMax)
    {
        iMid = (iMin + iMax) / 2;
        pProp = _rgProp.Get(iMid);
        Assert(pProp != NULL);

        if (fTextUpdate)
        {
            // after an edit, the anchors may be crossed
            CheckCrossedAnchors(pProp);
        }

        l = CompareAnchors(pa, fEnd ? pProp->_paEnd : pProp->_paStart);

        if (l < 0)
        {
            iMax = iMid;
        }
        else if (l > 0)
        {
            iMin = iMid + 1;
        }
        else // pa == paPropStart
        {
            pPropMatch = pProp;
            break;
        }
    }

    if (fTextUpdate &&
        pPropMatch != NULL &&
        iMid != -1)
    {
        // we have to account for empty spans during a textupdate
        pPropMatch = _FindUpdateTouchup(pa, &iMid, fEnd);
    }

    if (piOut != NULL)
    {
        if (pPropMatch == NULL && iMid >= 0)
        {
            PROPERTYLIST *pPropTmp = _rgProp.Get(iMid);
            // couldn't find a match, return the next lowest ich
            // this assert won't work because the previous property list might have crossed anchors (which is ok)
            //Assert(iMid == 0 || CompareAnchors(fEnd ? GetPropList(iMid - 1)->_paEnd : GetPropList(iMid - 1)->_paStart, pa) < 0);
            if (CompareAnchors(fEnd ? pProp->_paEnd : pPropTmp->_paStart, pa) > 0)
            {
                iMid--;
            }
        }
        *piOut = iMid;
    }

    return pPropMatch;
}

//+---------------------------------------------------------------------------
//
// _FindUpdateTouchup
//
//----------------------------------------------------------------------------

PROPERTYLIST *CProperty::_FindUpdateTouchup(IAnchor *pa, int *piMid, BOOL fEnd)
{
    PROPERTYLIST *pPropertyList;
    int iTmp;

    // we may have empty spans after a text update, because of a text delete.
    // in this case, return the last empty span.
    // We'll do a O(n) scan instead of anything tricky, because in this case
    // we'll soon touch every empty span again just so we can delete it.

    // if we testing vs. the span end, we want the first empty span, otherwise we want the last one
    for (iTmp = fEnd ? *piMid-1 : *piMid+1; iTmp >= 0 && iTmp < _rgProp.Count(); iTmp += fEnd ? -1 : +1)
    {
        pPropertyList = _rgProp.Get(iTmp);

        if (CompareAnchors(pPropertyList->_paStart, pPropertyList->_paEnd) < 0) // use Compare instead of IsEqual to handle crossed anchors
            break;

        *piMid = iTmp;
    }

    // was the next/prev span truncated? we want it if it matches the original search criteria
    if (fEnd)
    {
        if (iTmp >= 0 && IsEqualAnchor(pa, pPropertyList->_paEnd))
        {
            *piMid = iTmp;
        }
    }
    else
    {
        if (iTmp < _rgProp.Count() && IsEqualAnchor(pa, pPropertyList->_paStart))
        {
            *piMid = iTmp;
        }
    }

    return _rgProp.Get(*piMid);
}

//+---------------------------------------------------------------------------
//
// Set
//
//----------------------------------------------------------------------------

HRESULT CProperty::Set(IAnchor *paStart, IAnchor *paEnd, ITfPropertyStore *pPropStore)
{
    BOOL bRet;

    Assert(pPropStore != NULL);

    bRet = _InsertPropList(paStart, paEnd, pPropStore, NULL);

    if (bRet)
        PropertyUpdated(paStart, paEnd);

    _Dbg_AssertProp();

    return bRet ? S_OK : E_FAIL;
}

//+---------------------------------------------------------------------------
//
// SetLoader
//
//----------------------------------------------------------------------------

HRESULT CProperty::SetLoader(IAnchor *paStart, IAnchor *paEnd, CPropertyLoad *pPropLoad)
{
    BOOL bRet;
    bRet = _InsertPropList(paStart, paEnd, NULL, pPropLoad);

    if (bRet)
        PropertyUpdated(paStart, paEnd);

    return bRet ? S_OK : E_FAIL;
}

//+---------------------------------------------------------------------------
//
// ForceLoad
//
//----------------------------------------------------------------------------

HRESULT CProperty::ForceLoad()
{
    int nCnt = GetPropNum();
    int i;

    for (i = 0; i < nCnt; i++)
    {
        PROPERTYLIST *pProp = GetPropList(i);
        if (!pProp->_pPropStore)
        {
            HRESULT hr;
            if (FAILED(hr = LoadData(pProp)))
                return hr;
        }
    }

    return S_OK;
}

//+---------------------------------------------------------------------------
//
// Clear
//
// Removes property spans from paStart to paEnd.
//----------------------------------------------------------------------------

void CProperty::Clear(IAnchor *paStart, IAnchor *paEnd, DWORD dwFlags, BOOL fTextUpdate)
{
    PROPERTYLIST *pPropertyList;
    LONG iEnd;
    LONG iStart;
    LONG iRunSrc;
    LONG iRunDst;
    LONG iBogus;
    LONG lResult;
    BOOL fStartMatchesSpanEnd;
    BOOL fEndMatchesSpanStart;
    BOOL fSkipNextOnTextUpdate;

    if (_rgProp.Count() == 0)
        return; // no props

    fEndMatchesSpanStart = (_FindComplex(paEnd, &iEnd, FALSE /* fFindEndEdge */, fTextUpdate) != NULL);

    if (iEnd < 0)
        return; // no props covered -- delta preceeds all spans

    fStartMatchesSpanEnd = (_FindComplex(paStart, &iStart, TRUE /* fFindEndEdge */, fTextUpdate) != NULL);

    if (!fStartMatchesSpanEnd)
    {
        // we can skip this span, it's end edge is to the left of paStart
        iStart++;
    }

    if (iEnd < iStart)
        return; // no props covered -- delta is between two spans

    //
    // first span is special, since it may be partially covered
    //

    // just one span?
    if (iStart == iEnd)
    {
        _ClearOneSpan(paStart, paEnd, iStart, fStartMatchesSpanEnd, fEndMatchesSpanStart, dwFlags, fTextUpdate);
        return;
    }

    // first span may be truncated
    pPropertyList = _rgProp.Get(iStart);

    if (!_ClearFirstLastSpan(TRUE /* fFirst */, fStartMatchesSpanEnd, paStart, paEnd, pPropertyList, dwFlags, fTextUpdate, &fSkipNextOnTextUpdate))
    {
        // we're not going clear the first span, so skip past it
        iStart++;
    }

    //
    // handle all the totally covered spans
    //

    iBogus = iStart-1; // a sentinel
    iRunSrc = iBogus;
    iRunDst = iBogus;

    if (!fTextUpdate)
    {
        // we don't need a loop for non-text updates
        // everything will be deleted, and we don't have
        // to worry about crossed anchors or change histories
        // we just need to some extra checking on the last span
        if (iStart < iEnd)
        {
            iRunDst = iStart;
        }
        iStart = iEnd;
    }

    for (; iStart <= iEnd; iStart++)
    {
        pPropertyList = _rgProp.Get(iStart);

        if (iStart == iEnd)
        {
            // last span is special, since it may be partially covered
            if (_ClearFirstLastSpan(FALSE /* fFirst */, fEndMatchesSpanStart, paStart, paEnd,
                                    pPropertyList, dwFlags, fTextUpdate, &fSkipNextOnTextUpdate))
            {
                goto ClearSpan;
            }
            else
            {
                goto SaveSpan;
            }
        }

        // make sure we handle any crossed anchors
        lResult = CompareAnchors(pPropertyList->_paStart, pPropertyList->_paEnd);

        if (lResult >= 0)
        {
            if (lResult > 0)
            {
                // for crossed anchors, we always move the start anchor to the end pos -- ie, don't move
                pPropertyList->_paStart->ShiftTo(pPropertyList->_paEnd);
            }
            // don't do OnTextUpdated for empty spans!
            fSkipNextOnTextUpdate = TRUE;
        }

        // give the property owner a chance to ignore text updates
        if (fSkipNextOnTextUpdate ||
            !_OnTextUpdate(dwFlags, pPropertyList, paStart, paEnd))
        {
ClearSpan:
            // this span is going to die
            fSkipNextOnTextUpdate = FALSE;

            if (iRunDst == iBogus)
            {
                iRunDst = iStart;
            }
            else if (iRunSrc > iRunDst)
            {
                // time to move this run
                _MovePropertySpans(iRunDst, iRunSrc, iStart - iRunSrc);
                // and update the pointers
                iRunDst += iStart - iRunSrc;
                iRunSrc = iBogus;
            }
        }
        else
        {
            // make sure we clear the history for this span
            pPropertyList->_paStart->ClearChangeHistory();
            pPropertyList->_paEnd->ClearChangeHistory();
SaveSpan:
            // this span will live
            if (iRunSrc == iBogus && iRunDst != iBogus)
            {
                iRunSrc = iStart;
            }
        }
    }

    // handle the final run
    if (iRunDst > iBogus)
    {
        // if iRunSrc == iBogus, then we want to delete every span we saw
        if (iRunSrc == iBogus)
        {
            _MovePropertySpans(iRunDst, iStart, _rgProp.Count()-iStart);
        }
        else
        {
            _MovePropertySpans(iRunDst, iRunSrc, _rgProp.Count()-iRunSrc);
        }
    }

    _Dbg_AssertProp();
}

//+---------------------------------------------------------------------------
//
// _ClearOneSpan
//
// Handle a clear that intersects just one span.
//----------------------------------------------------------------------------

void CProperty::_ClearOneSpan(IAnchor *paStart, IAnchor *paEnd, int iIndex,
                              BOOL fStartMatchesSpanEnd, BOOL fEndMatchesSpanStart, DWORD dwFlags, BOOL fTextUpdate)
{
    PROPERTYLIST *pPropertyList;
    ITfPropertyStore *pPropertyStore;
    IAnchor *paTmp;
    LONG lResult;
    DWORD dwStartHistory;
    DWORD dwEndHistory;
    LONG lStartDeltaToStartSpan;
    LONG lEndDeltaToEndSpan;
    HRESULT hr;

    pPropertyList = _rgProp.Get(iIndex);
    lResult = 0;

    // empty or crossed span?
    if (fTextUpdate)
    {
        if ((lResult = CompareAnchors(pPropertyList->_paStart, pPropertyList->_paEnd)) >= 0)
            goto ClearSpan; // we shouldn't call OnTextUpdated for empty/crossed spans
    }
    else
    {
        // we should never see an empty span outside a text update
        Assert(!IsEqualAnchor(pPropertyList->_paStart, pPropertyList->_paEnd));
    }

    if (fTextUpdate)
    {
        // make sure we clear the history for this span in case it isn't cleared
        _ClearChangeHistory(pPropertyList, &dwStartHistory, &dwEndHistory);
    }

    // handle edge case first, if the clear range just touches an edge of the property span
    if (fStartMatchesSpanEnd || fEndMatchesSpanStart)
    {
        // if this is not a text update, then the ranges don't intersect
        if (!fTextUpdate)
            return;

        // some of the text at either end of the span might have been deleted
        if (fStartMatchesSpanEnd)
        {
            if (!(dwEndHistory & TS_CH_PRECEDING_DEL))
                return;

            if (_OnTextUpdate(dwFlags, pPropertyList, paStart, paEnd))
                return;

            goto ShrinkLeft; // we can avoid the CompareAnchors calls below
        }
        else
        {
            Assert(fEndMatchesSpanStart);

            if (!(dwStartHistory & TS_CH_FOLLOWING_DEL))
                return;

            if (_OnTextUpdate(dwFlags, pPropertyList, paStart, paEnd))
                return;

            goto ShrinkRight; // we can avoid the CompareAnchors calls below
        }
    }

    if (fTextUpdate &&
        _OnTextUpdate(dwFlags, pPropertyList, paStart, paEnd))
    {
        // property owner is ok with the clear
        return;
    }

    lStartDeltaToStartSpan = CompareAnchors(paStart, pPropertyList->_paStart);
    lEndDeltaToEndSpan = CompareAnchors(paEnd, pPropertyList->_paEnd);

    if (lStartDeltaToStartSpan > 0)
    {
        if (lEndDeltaToEndSpan < 0)
        {
            //
            // divide, we're clearing in the middle of the span
            //
            if (pPropertyList->_paEnd->Clone(&paTmp) != S_OK)
                goto ClearSpan; // give up

            hr = _Divide(pPropertyList, paStart, paEnd, &pPropertyStore);

            if (hr == S_OK)
            {
                _CreateNewProp(paEnd, paTmp, pPropertyStore, NULL);
                pPropertyStore->Release();

                PropertyUpdated(paStart, paEnd);
            }

            paTmp->Release();

            if (hr != S_OK)
                goto ClearSpan;
        }
        else
        {
            //
            // shrink to the left, we're clearing the right edge of this span
            //
ShrinkLeft:
            if (pPropertyList->_paEnd->Clone(&paTmp) != S_OK)
                goto ClearSpan;

            hr = _SetNewExtent(pPropertyList, pPropertyList->_paStart, paStart, FALSE);

            PropertyUpdated(paStart, paTmp);

            paTmp->Release();

            if (hr != S_OK)
                goto ClearSpan;
        }
    }
    else if (lEndDeltaToEndSpan < 0)
    {
        //
        // shrink to the right, we're clearing the left edge of this span
        //
ShrinkRight:
        if (pPropertyList->_paStart->Clone(&paTmp) != S_OK)
            goto ClearSpan;

        hr = _SetNewExtent(pPropertyList, paEnd, pPropertyList->_paEnd, FALSE);

        PropertyUpdated(paTmp, paEnd);

        paTmp->Release();

        if (hr != S_OK)
            goto ClearSpan;
    }
    else
    {
        // we're wiping the whole span
ClearSpan:
        if (lResult <= 0)
        {
            PropertyUpdated(pPropertyList->_paStart, pPropertyList->_paEnd);
        }
        else
        {
            // we found a crossed span above, report as if empty
            PropertyUpdated(pPropertyList->_paEnd, pPropertyList->_paEnd);
        }
        _FreePropertyList(pPropertyList);
        _rgProp.Remove(iIndex, 1);
    }
}

//+---------------------------------------------------------------------------
//
// _OnTextUpdate
//
// Make a ITfPropertyStore::OnTextUpdate callback.
// Returns FALSE if the property should be freed.
//----------------------------------------------------------------------------

BOOL CProperty::_OnTextUpdate(DWORD dwFlags, PROPERTYLIST *pPropertyList, IAnchor *paStart, IAnchor *paEnd)
{
    CRange *pRange;
    BOOL fRet;
    BOOL fAccept;

    if (pPropertyList->_pPropStore == NULL)
    {
        // need to load data to make a change notification
        if (LoadData(pPropertyList) != S_OK)
            return FALSE;
        Assert(pPropertyList->_pPropStore != NULL);
    }

    // perf: can we cache the range for the notification?
    if ((pRange = new CRange) == NULL)
        return FALSE; // out of memory, give up

    fRet = FALSE;

    if (!pRange->_InitWithDefaultGravity(_pic, COPY_ANCHORS, paStart, paEnd))
        goto Exit;

    if (pPropertyList->_pPropStore->OnTextUpdated(dwFlags, (ITfRangeAnchor *)pRange, &fAccept) != S_OK)
        goto Exit;
    
    fRet = fAccept;

Exit:
    pRange->Release();
    return fRet;
}

//+---------------------------------------------------------------------------
//
// _MovePropertySpans
//
// Shift PROPERTYLISTs from iSrc to iDst, and shrink the array if we move
// anything that touches the very end.
//----------------------------------------------------------------------------

void CProperty::_MovePropertySpans(int iDst, int iSrc, int iCount)
{
    PROPERTYLIST *pPropertyList;
    PROPERTYLIST **pSrc;
    PROPERTYLIST **pDst;
    LONG i;
    LONG iHalt;
    int cb;
    BOOL fLastRun;

    Assert(iCount >= 0);
    Assert(iDst < iSrc);
    Assert(iDst >= 0);
    Assert(iSrc + iCount <= _rgProp.Count());

    fLastRun = (iSrc + iCount == _rgProp.Count());

    if (!fLastRun)
    {
        // free all the spans that are going to be clobbered
        iHalt = min(iSrc, iDst + iCount);
    }
    else
    {
        // on the last call, cleanup everything that never got clobbered
        iHalt = iSrc;
    }

    for (i=iDst; i<iHalt; i++)
    {
        pPropertyList = _rgProp.Get(i);

        if (pPropertyList == NULL)
            continue; // already freed this guy

        if (CompareAnchors(pPropertyList->_paStart, pPropertyList->_paEnd) <= 0)
        {
            PropertyUpdated(pPropertyList->_paStart, pPropertyList->_paEnd);
        }
        else
        {
            // crossed anchors
            PropertyUpdated(pPropertyList->_paEnd, pPropertyList->_paEnd);
        }
        *_rgProp.GetPtr(i) = NULL; // NULL before the callbacks in _FreePropertyList
        _FreePropertyList(pPropertyList);
    }

    // shift the moving spans down

    pSrc = _rgProp.GetPtr(iSrc);
    pDst = _rgProp.GetPtr(iDst);

    memmove(pDst, pSrc, iCount*sizeof(PROPERTYLIST *));

    // this method is called from Clear as we shift through an array of spans
    // to remove.  On the last call only, we want to re-size the array.

    if (fLastRun)
    {
        // free any unused memory at the end of the array
        _rgProp.Remove(iDst + iCount, _rgProp.Count() - (iDst + iCount));
    }
    else
    {
        // mark vacated spans so we don't try to free them a second time
        // nb: we don't do this on the last call, which can be a big win since
        // in the case of delete there is only one single call
        pDst = _rgProp.GetPtr(max(iSrc, iDst + iCount));
        cb = sizeof(PROPERTYLIST *)*(iSrc+iCount - max(iSrc, iDst + iCount));
        memset(pDst, 0, cb);
    }
}

//+---------------------------------------------------------------------------
//
// _ClearFirstLastSpan
//
// Returns TRUE if the span should be cleared.
//----------------------------------------------------------------------------

BOOL CProperty::_ClearFirstLastSpan(BOOL fFirst, BOOL fMatchesSpanEdge,
                                    IAnchor *paStart, IAnchor *paEnd, PROPERTYLIST *pPropertyList,
                                    DWORD dwFlags, BOOL fTextUpdate, BOOL *pfSkipNextOnTextUpdate)
{
    DWORD dwStartHistory;
    DWORD dwEndHistory;
    BOOL fCovered;
    LONG lResult;

    *pfSkipNextOnTextUpdate = FALSE;

    if (fTextUpdate)
    {
        lResult = CompareAnchors(pPropertyList->_paStart, pPropertyList->_paEnd);

        if (lResult == 0)
        {
            // empty span, nix it
            goto Exit;
        }

        // make sure we clear the history for this span in case it isn't cleared
        _ClearChangeHistory(pPropertyList, &dwStartHistory, &dwEndHistory);
        // make sure we handle any crossed anchors
        if (lResult > 0)
        {
            // for crossed anchors, we always move the start anchor to the end pos -- ie, don't move
            pPropertyList->_paStart->ShiftTo(pPropertyList->_paEnd);
        }
    }

    // completely covered?
    if (fFirst)
    {
        fCovered = (CompareAnchors(pPropertyList->_paStart, paStart) >= 0);
    }
    else
    {
        fCovered = (CompareAnchors(pPropertyList->_paEnd, paEnd) <= 0);
    }

    if (fCovered)
    {
        // this span is covered, so we're going to clear it unless it's a text update
        // and the store is cool with it
        if (!fTextUpdate)
            return TRUE;

        if (_OnTextUpdate(dwFlags, pPropertyList, paStart, paEnd))
            return FALSE;

        goto Exit; // return TRUE, and make sure we don't call OnTextUpdate again
    }

    // start of span matches end of clear range? (or vice-versa)
    if (fMatchesSpanEdge)
    {
        // if no text was deleted, then there really is no overlap
        if (!fTextUpdate)
            return FALSE;

        // otherwise, we may have just deleted text at the edge of the property span
        if (fFirst)
        {
            if (!(dwEndHistory & TS_CH_PRECEDING_DEL))
                return FALSE;
        }
        else
        {
            if (!(dwStartHistory & TS_CH_FOLLOWING_DEL))
                return FALSE;
        }
    }

    // if we made it here we're going to clear some of the property span

    if (fTextUpdate)
    {
        if (_OnTextUpdate(dwFlags, pPropertyList, paStart, paEnd))
        {
            // property owner is ok with the text edit
            return FALSE;
        }
    }

    if (fFirst)
    {
        if (_SetNewExtent(pPropertyList, pPropertyList->_paStart, paStart, FALSE) == S_OK)
            return FALSE;
    }
    else
    {
        if (_SetNewExtent(pPropertyList, paEnd, pPropertyList->_paEnd, FALSE) == S_OK)
            return FALSE;
    }

Exit:
    // property owner is not ok with the shink, kill this span
    *pfSkipNextOnTextUpdate = TRUE;

    return TRUE;
}

//+---------------------------------------------------------------------------
//
// CreateNewProp
//
//----------------------------------------------------------------------------

PROPERTYLIST *CProperty::_CreateNewProp(IAnchor *paStart, IAnchor *paEnd, ITfPropertyStore *pPropStore, CPropertyLoad *pPropLoad)
{
    PROPERTYLIST *pProp;
    LONG iProp;

    Assert(!IsEqualAnchor(paStart, paEnd));

    if (Find(paStart, &iProp, FALSE))
    {
        Assert(0);
    }
    iProp++;

    pProp = (PROPERTYLIST *)cicMemAllocClear(sizeof(PROPERTYLIST));

    if (pProp == NULL)
        return NULL;

    Dbg_MemSetNameIDCounter(pProp, TEXT("PROPERTYLIST"), (DWORD)-1, PERF_PROPERTYLIST_COUNTER);

    if (!_rgProp.Insert(iProp, 1))
    {
        cicMemFree(pProp);
        return NULL;
    }

    _rgProp.Set(iProp, pProp);

    pProp->_pPropStore = pPropStore;
    pProp->_pPropLoad = pPropLoad;

    if (pPropStore)
        pPropStore->AddRef();

    Assert(pProp->_paStart == NULL);
    Assert(pProp->_paEnd == NULL);
    Assert(pProp->_pPropStore || pProp->_pPropLoad);

    _SetNewExtent(pProp, paStart, paEnd, TRUE);

    pProp->_paStart->SetGravity(TS_GR_FORWARD);
    pProp->_paEnd->SetGravity(TS_GR_BACKWARD); // End must be LEFT, too. Because we don't want to stratch this property.

    if (GetPropStyle() == TFPROPSTYLE_STATICCOMPACT ||
        GetPropStyle() == TFPROPSTYLE_CUSTOM_COMPACT)
    {
        _DefragAfterThis(iProp);
    }

    return pProp;
}

//+---------------------------------------------------------------------------
//
// _SetNewExtent
//
// return S_FALSE, if tip wants to free the property.
//
//----------------------------------------------------------------------------

HRESULT CProperty::_SetNewExtent(PROPERTYLIST *pProp, IAnchor *paStart, IAnchor *paEnd, BOOL fNew)
{
    HRESULT hr;
    BOOL fFree;
    CRange *pRange = NULL;

    Assert(!IsEqualAnchor(paStart, paEnd));

    ShiftToOrClone(&pProp->_paStart, paStart);
    ShiftToOrClone(&pProp->_paEnd, paEnd);

    // we don't load actual data or send a resize event for new data
    if (fNew)
        return S_OK;

    Assert(pProp);

    if (!pProp->_pPropStore)
    {
        //
        // need to load data to make a change notification.
        //
        // perf:   we may skip and delete Loader if this property is not
        //         custom property.
        //
        if (FAILED(LoadData(pProp)))
            return E_FAIL;
    }

    hr = E_FAIL;

    if ((pRange = new CRange) != NULL)
    {
        if (pRange->_InitWithDefaultGravity(_pic, COPY_ANCHORS, pProp->_paStart, pProp->_paEnd))
        {
            hr = pProp->_pPropStore->Shrink((ITfRangeAnchor *)pRange, &fFree);

            if (hr != S_OK || fFree)
            {
                SafeReleaseClear(pProp->_pPropStore); // caller will free this property when it see S_FALSE return
                hr = S_FALSE;
            }
        }
        pRange->Release();
    }

    return hr;
}

//+---------------------------------------------------------------------------
//
// _Divide
//
// return S_FALSE, if tip wants to free the property.
//
//----------------------------------------------------------------------------

HRESULT CProperty::_Divide(PROPERTYLIST *pProp, IAnchor *paBreakPtStart, IAnchor *paBreakPtEnd, ITfPropertyStore **ppStore)
{
    HRESULT hr = E_FAIL;
    CRange *pRangeThis = NULL;
    CRange *pRangeNew = NULL;

    Assert(CompareAnchors(pProp->_paStart, paBreakPtStart) <= 0);
    Assert(CompareAnchors(paBreakPtStart, paBreakPtEnd) <= 0);
    Assert(CompareAnchors(paBreakPtEnd, pProp->_paEnd) <= 0);

    if ((pRangeThis = new CRange) == NULL)
        goto Exit;
    if (!pRangeThis->_InitWithDefaultGravity(_pic, COPY_ANCHORS, pProp->_paStart, paBreakPtStart))
        goto Exit;
    if ((pRangeNew = new CRange) == NULL)
        goto Exit;
    if (!pRangeNew->_InitWithDefaultGravity(_pic, COPY_ANCHORS, paBreakPtEnd, pProp->_paEnd))
        goto Exit;

    if (!pProp->_pPropStore)
    {
        //
        // we need to load data to make a change notification.
        //
        // perf: we may skip and delete Loader if this property is not
        //       custom property.
        //
        if (FAILED(LoadData(pProp)))
            goto Exit;
    }

    hr = pProp->_pPropStore->Divide((ITfRangeAnchor *)pRangeThis, (ITfRangeAnchor *)pRangeNew, ppStore);

    if ((hr == S_OK) && *ppStore)
    {
        ShiftToOrClone(&pProp->_paEnd, paBreakPtStart);
    }
    else
    {
        *ppStore = NULL;
        hr = S_FALSE;
    }

Exit:
    SafeRelease(pRangeThis);
    SafeRelease(pRangeNew);

    return hr;
}

//+---------------------------------------------------------------------------
//
// DestroyProp
//
//----------------------------------------------------------------------------

void CProperty::_RemoveProp(LONG iIndex, PROPERTYLIST *pProp)
{
#ifdef DEBUG
    LONG iProp;

    Assert(Find(pProp->_paStart, &iProp, FALSE) == pProp);
    Assert(iProp == iIndex);
#endif // DEBUG

    _rgProp.Remove(iIndex, 1);
    _FreePropertyList(pProp);
}

//+---------------------------------------------------------------------------
//
// _InsertPropList
//
//----------------------------------------------------------------------------

BOOL CProperty::_InsertPropList(IAnchor *paStart, IAnchor *paEnd, ITfPropertyStore *pPropStore, CPropertyLoad *pPropLoad)
{
    PROPERTYLIST *pProp;
    IAnchor *paTmpEnd = NULL;
    LONG nCnt = GetPropNum();
    LONG nCur;

    Assert(!IsEqualAnchor(paStart, paEnd));

    if (!nCnt)
    {
        //
        // we create the first PropList.
        //
        _CreateNewProp(paStart, paEnd, pPropStore, pPropLoad);
        goto End;
    }
    
    nCur = 0;
    Find(paStart, &nCur, FALSE);
    if (nCur <= 0)
        nCur = 0;

    pProp = QuickGetPropList(nCur);

    while (nCur < nCnt)
    {
        Assert(pProp);
        SafeReleaseClear(paTmpEnd);
        pProp->_paEnd->Clone(&paTmpEnd);

        if (CompareAnchors(paStart, paTmpEnd) >= 0)
            goto Next;

        if (CompareAnchors(paEnd, pProp->_paStart) <= 0)
        {
            //
            // we insert new PropList just before pProp.
            //
            if (!_AddIntoProp(nCur - 1, paStart, paEnd, pPropStore))
                _CreateNewProp(paStart, paEnd, pPropStore, pPropLoad);
            goto End;
        }


        if (CompareAnchors(paStart, pProp->_paStart) > 0)
        {
            //
            // Now need to split pProp to insert new Prop.
            //
            Assert(pProp->_pPropStore);

            if (CompareAnchors(paTmpEnd, paEnd) > 0)
            {
                ITfPropertyStore *pNewPropStore = NULL;

                if (S_OK != _Divide(pProp, paStart, paEnd, &pNewPropStore))
                {
                    _RemoveProp(nCur, pProp);
                    nCnt--;
                    goto DoAgain;
                }
                else if (pNewPropStore)
                {
                    _CreateNewProp(paEnd, paTmpEnd, pNewPropStore, pPropLoad);
                    pNewPropStore->Release();
                    pProp = GetPropList(nCur);
                    nCnt++;
                }
            }
            else
            {
                if (S_OK != _SetNewExtent(pProp, pProp->_paStart, paStart, FALSE))
                {
                    _RemoveProp(nCur, pProp);
                    nCnt--;
                    goto DoAgain;
                }
            }

            //
            // next time, new Prop will be inserted.
            //
            goto Next;
        }

        Assert(CompareAnchors(paStart, pProp->_paStart) <= 0);

        if (CompareAnchors(pProp->_paStart, paEnd) < 0)
        {
            if (CompareAnchors(paTmpEnd, paEnd) <= 0)
            {
                //
                // pProp is completely overlapped by new Prop.
                // so we delete this pProp.
                //
                _RemoveProp(nCur, pProp);
                nCnt--;
            }
            else
            {
                //
                // A part of pProp is overlapped by new Prop.
                //
                if (S_OK != _SetNewExtent(pProp, paEnd, paTmpEnd, FALSE))
                {
                    _RemoveProp(nCur, pProp);
                    nCnt--;
                }
            }

            goto DoAgain;
        }

        Assert(0);
Next:
        nCur++;
DoAgain:
        pProp = SafeGetPropList(nCur);
    }

    if (!_AddIntoProp(nCur - 1, paStart, paEnd, pPropStore))
        _CreateNewProp(paStart, paEnd, pPropStore, pPropLoad);

End:
    _Dbg_AssertProp();
    SafeRelease(paTmpEnd);
    return TRUE;
}

//+---------------------------------------------------------------------------
//
// Defrag
//
// paStart, paEnd == NULL will defrag everything.
//----------------------------------------------------------------------------

BOOL CProperty::Defrag(IAnchor *paStart, IAnchor *paEnd)
{
    PROPERTYLIST *pProp;
    LONG nCnt = GetPropNum();
    LONG nCur;
    BOOL fSamePropIndex;
    BOOL fDone = FALSE;

    if (GetPropStyle() != TFPROPSTYLE_STATICCOMPACT &&
        GetPropStyle() != TFPROPSTYLE_CUSTOM_COMPACT)
    {
        return fDone;
    }

    if (!nCnt)
        return fDone;
   
    pProp = GetFirstPropList();
    nCur = 0;
    if (paStart != NULL)
    {
        if (Find(paStart, &nCur, FALSE))
            nCur--;
        if (nCur <= 0)
            nCur = 0;
    }

    pProp = GetPropList(nCur);

    while (nCur < nCnt - 1) // Issue: shouldn't this terminate at paEnd?
    {
        PROPERTYLIST *pPropNext = GetPropList(nCur + 1);

        if (paEnd != NULL && CompareAnchors(pProp->_paStart, paEnd) > 0)
            break;

        fSamePropIndex = FALSE;

        if (CompareAnchors(pProp->_paEnd, pPropNext->_paStart) == 0)
        {
            if (!pProp->_pPropStore)
            {
                if (FAILED(LoadData(pProp)))
                    return FALSE;
            }
            if (!pPropNext->_pPropStore)
            {
                if (FAILED(LoadData(pPropNext)))
                    return FALSE;
            }

            // compare the value of each property instance

            if (IsEqualPropertyValue(pProp->_pPropStore, pPropNext->_pPropStore))
            {
                //
                // pPropNext is next to pProp and has same data.
                // So we merge them.
                // We should never fail this.
                //
                _SetNewExtent(pProp, pProp->_paStart, pPropNext->_paEnd, FALSE);
                Assert(pProp->_pPropStore);
                _RemoveProp(nCur+1, pPropNext);
                nCnt = GetPropNum();
                pProp = GetPropList(nCur);

                fDone = TRUE;

                //
                // Do same pProp again because _pNext was changed.
                //
                fSamePropIndex = TRUE;
            }
        }
        if (!fSamePropIndex)
        {
            nCur++;
        }
        pProp = GetPropList(nCur);
    }

    _Dbg_AssertProp();
    return fDone;
}

//+---------------------------------------------------------------------------
//
// _AddIntoProp
//
//----------------------------------------------------------------------------

BOOL CProperty::_AddIntoProp(int nCur, IAnchor *paStart, IAnchor *paEnd, ITfPropertyStore *pPropStore)
{
    PROPERTYLIST *pProp;
    BOOL bRet = FALSE;

    Assert(!IsEqualAnchor(paStart, paEnd));

    if (GetPropStyle() != TFPROPSTYLE_STATICCOMPACT &&
        GetPropStyle() != TFPROPSTYLE_CUSTOM_COMPACT)
    {
        return FALSE;
    }

    if (!pPropStore)
        return FALSE;

    if (nCur < 0)
        return FALSE;

    if (!(pProp = GetPropList(nCur)))
        return FALSE;

    if (CompareAnchors(pProp->_paStart, paStart) <= 0 && // Issue: why do we need 2 compares? isn't CompareAnchors(pProp->_paEnd, paStart) >= 0 enough?
        CompareAnchors(pProp->_paEnd, paStart) >= 0)
    {
        if (CompareAnchors(paEnd, pProp->_paEnd) > 0)
        {
            if (!pProp->_pPropStore)
            {
                if (FAILED(LoadData(pProp)))
                    return FALSE;
            }

            if (IsEqualPropertyValue(pProp->_pPropStore, pPropStore))
            {
                HRESULT hr;
                hr = _SetNewExtent(pProp, pProp->_paStart, paEnd, FALSE);

                //
                // Our static property store should never fail.
                //
                Assert(hr == S_OK);
                Assert(pProp->_pPropStore);
                bRet = TRUE;
            }
        }
    }

    if (bRet)
       _DefragAfterThis(nCur);

    _Dbg_AssertProp();
    return bRet;
}

//+---------------------------------------------------------------------------
//
// DefragThis
//
//----------------------------------------------------------------------------

void CProperty::_DefragAfterThis(int nCur)
{

    nCur++;
    while (1)
    {
        IAnchor *paTmpStart = NULL;
        IAnchor *paTmpEnd = NULL;
        PROPERTYLIST *pProp;
        int nCnt = GetPropNum();
        BOOL bRet;

        if (nCur >= nCnt)
            goto Exit;

        if (!(pProp = GetPropList(nCur)))
            goto Exit;

        pProp->_paStart->Clone(&paTmpStart);
        pProp->_paEnd->Clone(&paTmpEnd);

        bRet = Defrag(paTmpStart, paTmpEnd);

        SafeRelease(paTmpStart);
        SafeRelease(paTmpEnd);

        if (!bRet)
            goto Exit;
    }
Exit:
    return;
}

//+---------------------------------------------------------------------------
//
// FindPropertyListByPos
//
//----------------------------------------------------------------------------

PROPERTYLIST *CProperty::FindPropertyListByPos(IAnchor *paPos, BOOL fEnd)
{
    PROPERTYLIST *pPropList = NULL;
    BOOL fFound = FALSE;
    LONG nCnt;

    Find(paPos, &nCnt, fEnd);
    if (nCnt >= 0)
        pPropList = GetPropList(nCnt);
 
    if (pPropList)
    {
        if (!fEnd)
        {
            if (CompareAnchors(pPropList->_paStart, paPos) <= 0 &&
                CompareAnchors(paPos, pPropList->_paEnd) < 0)
            {
                fFound = TRUE;
            }
        }
        else
        {
            if (CompareAnchors(pPropList->_paStart, paPos) < 0 &&
                CompareAnchors(paPos, pPropList->_paEnd) <= 0)
            {
                fFound = TRUE;
            }
        }
    }

    return fFound ? pPropList : NULL;
}

//+---------------------------------------------------------------------------
//
// LoadData
//
//----------------------------------------------------------------------------

HRESULT CProperty::LoadData(PROPERTYLIST *pPropList)
{
    HRESULT hr = E_FAIL;
    ITfPropertyStore *pStore;
    TF_PERSISTENT_PROPERTY_HEADER_ANCHOR *ph;
    IStream *pStream = NULL;
    CRange *pRange = NULL;
    
    Assert(!pPropList->_pPropStore);
    Assert(pPropList->_pPropLoad);

    //
    // Update ichAnchor and cch of TF_PERSISTENT_PROPERTY_HEADER_ACP.
    // As text may be updated, the original value is
    // obsolete.
    //
    ph = &pPropList->_pPropLoad->_hdr;

    ShiftToOrClone(&ph->paStart, pPropList->_paStart);
    ShiftToOrClone(&ph->paEnd, pPropList->_paEnd);

    if (FAILED(pPropList->_pPropLoad->_pLoader->LoadProperty(ph, &pStream)))
        goto Exit;

    if ((pRange = new CRange) == NULL)
    {
        hr = E_OUTOFMEMORY;
        goto Exit;
    }
    if (!pRange->_InitWithDefaultGravity(_pic, COPY_ANCHORS, ph->paStart, ph->paEnd))
    {
        hr = E_FAIL;
        goto Exit;
    }

    if (FAILED(_GetPropStoreFromStream(ph, pStream, pRange, &pStore)))
        goto Exit;

    pPropList->_pPropStore = pStore;
    delete pPropList->_pPropLoad;
    pPropList->_pPropLoad = NULL;

    hr = S_OK;

Exit:
    SafeRelease(pStream);
    SafeRelease(pRange);
    return hr;
}

//+---------------------------------------------------------------------------
//
// _Dbg_AssertProp
//
//----------------------------------------------------------------------------

#ifdef DEBUG
void CProperty::_Dbg_AssertProp()
{
    LONG nCnt = GetPropNum();
    LONG n;
    IAnchor *paEndLast = NULL;

    for (n = 0; n < nCnt; n++)
    {
        PROPERTYLIST *pProp = GetPropList(n);

        Assert(paEndLast == NULL || CompareAnchors(paEndLast, pProp->_paStart) <= 0);
        Assert(CompareAnchors(pProp->_paStart, pProp->_paEnd) < 0);
        Assert(pProp->_pPropStore || pProp->_pPropLoad);

        paEndLast = pProp->_paEnd;
    }

}
#endif

//+---------------------------------------------------------------------------
//
// PropertyUpdated
//
//----------------------------------------------------------------------------

void CProperty::PropertyUpdated(IAnchor *paStart, IAnchor *paEnd)
{
    CSpanSet *pss;
    CProperty *pDisplayAttrProperty;

    if (pss = _CreateSpanSet()) 
    {
        pss->Add(0, paStart, paEnd, COPY_ANCHORS);
    }

    if (_dwPropFlags & PROPF_MARKUP_COLLECTION)
    {
        // we also need to update the display attribute property
        if (_pic->_GetProperty(GUID_PROP_ATTRIBUTE, &pDisplayAttrProperty) == S_OK)
        {
            Assert(!(pDisplayAttrProperty->_dwPropFlags & PROPF_MARKUP_COLLECTION)); // don't allow infinite recursion!
            pDisplayAttrProperty->PropertyUpdated(paStart, paEnd);
            pDisplayAttrProperty->Release();
        }
    }
}

//+---------------------------------------------------------------------------
//
// GetPropStoreFromStream
//
//----------------------------------------------------------------------------

HRESULT CProperty::_GetPropStoreFromStream(const TF_PERSISTENT_PROPERTY_HEADER_ANCHOR *pHdr, IStream *pStream, CRange *pRange, ITfPropertyStore **ppStore)
{
    ITfTextInputProcessor *pIME = NULL;
    CTip                  *ptip = NULL;

    ITfCreatePropertyStore *pCreateStore = NULL;
    ITfPropertyStore *pPropStore = NULL;
    CRange *pRangeTmp = NULL;
    GUID guidProp;
    CThreadInputMgr *ptim = CThreadInputMgr::_GetThis();
    HRESULT hr = E_FAIL;
    LARGE_INTEGER li;
    TfGuidAtom guidatom;

    Assert(!IsEqualAnchor(pHdr->paStart, pHdr->paEnd));

    GetCurrentPos(pStream, &li);

    if (!ptim)
        goto Exit;

    if (FAILED(GetType(&guidProp)))
        goto Exit;

    if (!IsEqualGUID(guidProp, pHdr->guidType))
        goto Exit;

    //
    // Try QI.
    //
    if (FAILED(MyRegisterGUID(pHdr->clsidTIP, &guidatom)))
        goto Exit;

    if (ptim->_GetCTipfromGUIDATOM(guidatom, &ptip))
        pIME = ptip->_pTip;

    if (pIME && ptip->_fActivated) 
    {
        if (FAILED(hr = pIME->QueryInterface(IID_ITfCreatePropertyStore,
                                             (void **)&pCreateStore)))
            goto Exit;

        if ((pRangeTmp = new CRange) == NULL)
        {
            hr = E_OUTOFMEMORY;
            goto Exit;
        }
        if (!pRangeTmp->_InitWithDefaultGravity(_pic, COPY_ANCHORS, pHdr->paStart, pHdr->paEnd))
        {
            hr = E_FAIL;
            goto Exit;
        }
        
        if (FAILED(hr = pCreateStore->CreatePropertyStore(guidProp,
                                                          (ITfRangeAnchor *)pRangeTmp,
                                                          pHdr->cb,
                                                          pStream,
                                                          &pPropStore)))
            goto Exit;
    }
    else
    {
        if (IsEqualCLSID(pHdr->clsidTIP, CLSID_IME_StaticProperty))
        {
            //
            // Unserialize Static properties.
            //
            CGeneralPropStore *pStore;

            // GUID_PROP_READING is TFPROPSTYLE_CUSTOM ==> uses a general prop store
            if (_propStyle == TFPROPSTYLE_CUSTOM)
            {
                // general prop stores are thrown away if their text is edited
                pStore =  new CGeneralPropStore;
            }
            else
            {
                // static prop stores are per char, and simply clone themselves in response to any edit
                pStore =  new CStaticPropStore;
            }
    
            if (!pStore)
                goto Exit;

            if (!pStore->_Init(GetPropGuidAtom(),
                              pHdr->cb,
                              (TfPropertyType)pHdr->dwPrivate,
                              pStream,
                              _dwPropFlags))
            {
                goto Exit;
            }

            pPropStore = pStore;
            hr = S_OK;
        }
        else
        {
            //
            // There is no TFE installed in this system. So we use 
            // PropStoreProxy to hold the data.
            // Temporarily we use ITfIME_APP. But original TFE that owns this
            // data is kept in CPropStoreProxy.
            //
            CPropStoreProxy *pStoreProxy = new CPropStoreProxy;
    
            if (!pStoreProxy)
                goto Exit;

            if (!pStoreProxy->_Init(&pHdr->clsidTIP,
                                    GetPropGuidAtom(),
                                    pHdr->cb,
                                    pStream,
                                    _dwPropFlags))
            {
                goto Exit;
            }

            pPropStore = pStoreProxy;
            hr = S_OK;
        }
    }


Exit:

    // make sure the stream seek ptr is in a consistent state -- don't count
    // on any tip to do it right!
    if (SUCCEEDED(hr))
    {
        li.QuadPart += pHdr->cb;
    }
    pStream->Seek(li, STREAM_SEEK_SET, NULL);

    *ppStore = pPropStore;
    SafeRelease(pRangeTmp);
    SafeRelease(pCreateStore);

    return hr;
}

//+---------------------------------------------------------------------------
//
// GetContext
//
//----------------------------------------------------------------------------

STDAPI CProperty::GetContext(ITfContext **ppContext)
{
    if (ppContext == NULL)
        return E_INVALIDARG;

    *ppContext = _pic;
    if (*ppContext)
    {
       (*ppContext)->AddRef();
       return S_OK;
    }

    return E_FAIL;
}


//+---------------------------------------------------------------------------
//
// Clear
//
//----------------------------------------------------------------------------

STDAPI CProperty::Clear(TfEditCookie ec, ITfRange *pRange)
{
    CRange *pCRange = NULL;
    IAnchor *paStart = NULL;
    IAnchor *paEnd = NULL;
    HRESULT hr;

    if (!_IsValidEditCookie(ec, TF_ES_READ_PROPERTY_WRITE))
    {
        Assert(0);
        return TF_E_NOLOCK;
    }

    paStart = NULL;
    paEnd = NULL;

    if (pRange != NULL)
    {
        pCRange = GetCRange_NA(pRange);
        if (!pCRange)
             return E_INVALIDARG;

        if (!VerifySameContext(_pic, pCRange))
            return E_INVALIDARG;

        pCRange->_QuickCheckCrossedAnchors();

        paStart = pCRange->_GetStart();
        paEnd = pCRange->_GetEnd();
    }

    if ((hr = _CheckValidation(ec, pCRange)) != S_OK)
        return hr;

    return _ClearInternal(ec, paStart, paEnd);
}

//+---------------------------------------------------------------------------
//
// _CheckValidation
//
//----------------------------------------------------------------------------

HRESULT CProperty::_CheckValidation(TfEditCookie ec, CRange *range)
{
    CProperty *prop;
    BOOL fExactEndMatch;
    LONG iStartEdge;
    LONG iEndEdge;
    LONG iSpan;
    PROPERTYLIST *pPropList;
    TfClientId tid;
    IAnchor *paStart;

    //
    // There is no validation. Return TRUE;
    //
    if (_dwAuthority == PROPA_NONE)
        return S_OK;

    if (_dwAuthority & PROPA_READONLY)
        return TF_E_READONLY;

    tid = _pic->_GetClientInEditSession(ec);

    if (range == NULL)
        return (tid == _pic->_GetTIPOwner()) ? S_OK : TF_E_NOTOWNEDRANGE;

    if (!(_dwAuthority & PROPA_FOCUSRANGE))
    {
        Assert(_dwAuthority & PROPA_TEXTOWNER);
        return _CheckOwner(tid, range->_GetStart(), range->_GetEnd());
    }

    //
    // If the validation is PROPA_FOCUSTEXTOWNER, we check the focus range
    // first. If the range is not focus range, we allow tip to
    // update the property.
    //
    if ((prop = _pic->_FindProperty(GUID_PROP_COMPOSING)) == NULL)
        return S_OK; // no focus spans, so must be valid

    // for each focus span covered by the range, we need to make sure
    // this tip is the owner
    prop->Find(range->_GetStart(), &iStartEdge, FALSE);
    fExactEndMatch = (prop->Find(range->_GetEnd(), &iEndEdge, TRUE) != NULL);

    for (iSpan = max(iStartEdge, 0); iSpan <= iEndEdge; iSpan++)
    {
        pPropList = prop->GetPropList(iSpan);

        if (iSpan == iStartEdge)
        {
            // this span may not be covered, need to check
            // only relivent case: are we entirely to the right of the span?
            if (CompareAnchors(range->_GetStart(), pPropList->_paEnd) >= 0)
                continue;

            paStart = range->_GetStart();
        }
        else
        {
            paStart = pPropList->_paStart;
        }

        if (_CheckOwner(tid, paStart, pPropList->_paEnd) == TF_E_NOTOWNEDRANGE)
            return TF_E_NOTOWNEDRANGE;
    }
    // might also need to check the next span, since we rounded down
    if (!fExactEndMatch && prop->GetPropNum() > iEndEdge+1)
    {
        pPropList = prop->GetPropList(iEndEdge+1);

        IAnchor *paMaxStart;

        if (CompareAnchors(range->_GetStart(), pPropList->_paStart) >= 0)
            paMaxStart = range->_GetStart();
        else
            paMaxStart = pPropList->_paStart;

        if (CompareAnchors(range->_GetEnd(), pPropList->_paStart) > 0)
        {
            return _CheckOwner(tid, paMaxStart, range->_GetEnd());
        }
    }

    return S_OK;
}

//+---------------------------------------------------------------------------
//
// _CheckOwner
//
//----------------------------------------------------------------------------

HRESULT CProperty::_CheckOwner(TfClientId tid, IAnchor *paStart, IAnchor *paEnd)
{
    CProperty *prop;
    BOOL fExactEndMatch;
    LONG iStartEdge;
    LONG iEndEdge;
    LONG iSpan;
    PROPERTYLIST *pPropList;
    VARIANT var;

    if ((prop = _pic->GetTextOwnerProperty()) == NULL)
        return S_OK; // no owned spans, so must be valid

    // for each owner span covered by the range, we need to make sure
    // this tip is the owner
    prop->Find(paStart, &iStartEdge, FALSE);
    fExactEndMatch = (prop->Find(paEnd, &iEndEdge, TRUE) != NULL);

    for (iSpan = max(iStartEdge, 0); iSpan <= iEndEdge; iSpan++)
    {
        pPropList = prop->QuickGetAndLoadPropList(iSpan);

        if (pPropList == NULL)
        {
            // this probably means we couldn't unserialize the data
            // just skip it
            continue;
        }

        if (iSpan == iStartEdge)
        {
            // this span may not be covered, need to check
            // only relivent case: are we entirely to the right of the span?
            if (CompareAnchors(paStart, pPropList->_paEnd) >= 0)
                continue;
        }

        if (pPropList->_pPropStore->GetData(&var) == S_OK)
        {
            Assert(var.vt == VT_I4); // this is the text owner property!
            if ((TfClientId)var.lVal != tid)
            {
                return TF_E_NOTOWNEDRANGE;
            }
        }
    }
    // might also need to check the next span, since we rounded down
    if (!fExactEndMatch && prop->GetPropNum() > iEndEdge+1)
    {
        pPropList = prop->QuickGetAndLoadPropList(iEndEdge+1);

        if (pPropList == NULL)
        {
            // this probably means we couldn't unserialize the data
            goto Exit;
        }

        if (CompareAnchors(paEnd, pPropList->_paStart) > 0)
        {
            if (pPropList->_pPropStore->GetData(&var) == S_OK)
            {
                Assert(var.vt == VT_I4); // this is the text owner property!
                if ((TfClientId)var.lVal != tid)
                {
                    return TF_E_NOTOWNEDRANGE;
                }
            }
        }
    }

Exit:
    return S_OK;
}

//+---------------------------------------------------------------------------
//
// CheckTextOwner
//
//----------------------------------------------------------------------------

BOOL CProperty::_IsValidEditCookie(TfEditCookie ec, DWORD dwFlags)
{ 
    return _pic->_IsValidEditCookie(ec, dwFlags);
}

//+---------------------------------------------------------------------------
//
// SetValue
//
//----------------------------------------------------------------------------

STDAPI CProperty::SetValue(TfEditCookie ec, ITfRange *pRange, const VARIANT *pvarValue)
{
    CRange *pCRange;
    HRESULT hr;

    if (pRange == NULL)
        return E_INVALIDARG;

    if (pvarValue == NULL)
        return E_INVALIDARG;

    if (!IsValidCiceroVarType(pvarValue->vt))
        return E_INVALIDARG;

    if (!_IsValidEditCookie(ec, TF_ES_READ_PROPERTY_WRITE))
    {
        Assert(0);
        return TF_E_NOLOCK;
    }

    pCRange = GetCRange_NA(pRange);
    if (!pCRange)
         return E_INVALIDARG;

    if (!VerifySameContext(_pic, pCRange))
        return E_INVALIDARG;

    pCRange->_QuickCheckCrossedAnchors();

    if ((hr = _CheckValidation(ec, pCRange)) != S_OK)
        return hr;

    if (IsEqualAnchor(pCRange->_GetStart(), pCRange->_GetEnd()))
        return E_INVALIDARG;

    return _SetDataInternal(ec, pCRange->_GetStart(), pCRange->_GetEnd(), pvarValue);
}

//+---------------------------------------------------------------------------
//
// GetValue
//
//----------------------------------------------------------------------------

STDAPI CProperty::GetValue(TfEditCookie ec, ITfRange *pRange, VARIANT *pvarValue)
{
    CRange *pCRange;

    if (pvarValue == NULL)
        return E_INVALIDARG;

    QuickVariantInit(pvarValue);

    if (pRange == NULL)
        return E_INVALIDARG;

    if ((pCRange = GetCRange_NA(pRange)) == NULL)
         return E_INVALIDARG;

    if (!VerifySameContext(_pic, pCRange))
        return E_INVALIDARG;

    if (!_IsValidEditCookie(ec, TF_ES_READ))
    {
        Assert(0);
        return TF_E_NOLOCK;
    }

    pCRange->_QuickCheckCrossedAnchors();

    return _GetDataInternal(pCRange->_GetStart(), pCRange->_GetEnd(), pvarValue);
}

//+---------------------------------------------------------------------------
//
// SetValueStore
//
//----------------------------------------------------------------------------

STDAPI CProperty::SetValueStore(TfEditCookie ec, ITfRange *pRange, ITfPropertyStore *pPropStore)
{
    CRange *pCRange;

    if (pRange == NULL || pPropStore == NULL)
        return E_INVALIDARG;

    if (!_IsValidEditCookie(ec, TF_ES_READ_PROPERTY_WRITE))
    {
        Assert(0);
        return TF_E_NOLOCK;
    }

    pCRange = GetCRange_NA(pRange);
    if (!pCRange)
         return E_INVALIDARG;

    if (!VerifySameContext(_pic, pCRange))
        return E_INVALIDARG;

    pCRange->_QuickCheckCrossedAnchors();

    return _SetStoreInternal(ec, pCRange, pPropStore, FALSE);
}

//+---------------------------------------------------------------------------
//
// FindRange
//
//----------------------------------------------------------------------------

STDAPI CProperty::FindRange(TfEditCookie ec, ITfRange *pRange, ITfRange **ppv, TfAnchor aPos)
{
    CRange *pCRange;
    CRange *range;
    HRESULT hr;

    if (!ppv)
        return E_INVALIDARG;

    *ppv = NULL;

    if (pRange == NULL)
        return E_INVALIDARG;

    if ((range = GetCRange_NA(pRange)) == NULL)
        return E_INVALIDARG;

    if (!VerifySameContext(_pic, range))
        return E_INVALIDARG;

    if (!_IsValidEditCookie(ec, TF_ES_READ))
    {
        Assert(0);
        return TF_E_NOLOCK;
    }

    range->_QuickCheckCrossedAnchors();

    if (SUCCEEDED(hr = _InternalFindRange(range, &pCRange, aPos, FALSE)))
    {
        *ppv = (ITfRangeAnchor *)pCRange;
    }
    return hr;
}

//+---------------------------------------------------------------------------
//
// FindRange
//
//----------------------------------------------------------------------------

HRESULT CProperty::_InternalFindRange(CRange *pRange, CRange **ppv, TfAnchor aPos, BOOL fEnd)
{
    PROPERTYLIST *pPropList;
    CRange *pCRange;

    //
    // Issue: need to defrag for STATICCOMPACT property.
    //
    if (pRange)
    {
        pPropList = FindPropertyListByPos((aPos == TF_ANCHOR_START) ? pRange->_GetStart() : pRange->_GetEnd(), fEnd);
    }
    else
    {
        // if pRange is NULL, we returns the first or last property.

        if (aPos == TF_ANCHOR_START)
            pPropList = GetFirstPropList();
        else
            pPropList = GetLastPropList();
    }

    *ppv = NULL;

    if (!pPropList)
        return S_FALSE;

    if ((pCRange = new CRange) == NULL)
        return E_OUTOFMEMORY;

    if (!pCRange->_InitWithDefaultGravity(_pic, COPY_ANCHORS, pPropList->_paStart, pPropList->_paEnd))
    {
        pCRange->Release();
        return E_FAIL;
    }

    *ppv = pCRange;
    return S_OK;
}

//+---------------------------------------------------------------------------
//
// EnumRanges
//
//----------------------------------------------------------------------------

STDAPI CProperty::EnumRanges(TfEditCookie ec, IEnumTfRanges **ppv, ITfRange *pTargetRange)
{
    CRange *range;
    CEnumPropertyRanges *pEnum;

    if (ppv == NULL)
        return E_INVALIDARG;

    *ppv = NULL;

    if (!_IsValidEditCookie(ec, TF_ES_READ))
    {
        Assert(0);
        return TF_E_NOLOCK;
    }

    range = NULL;

    if (pTargetRange != NULL)
    {
        if ((range = GetCRange_NA(pTargetRange)) == NULL)
            return E_INVALIDARG;

        if (!VerifySameContext(_pic, range))
            return E_INVALIDARG;

        range->_QuickCheckCrossedAnchors();
    }

    if ((pEnum = new CEnumPropertyRanges) == NULL)
        return E_OUTOFMEMORY;

    if (!pEnum->_Init(_pic, range ? range->_GetStart() : NULL, range ? range->_GetEnd() : NULL, this))
    {
        pEnum->Release();
        return E_FAIL;
    }

    *ppv = pEnum;
    return S_OK;
}

//+---------------------------------------------------------------------------
//
// _Serialize
//
//----------------------------------------------------------------------------

HRESULT CProperty::_Serialize(CRange *pRange, TF_PERSISTENT_PROPERTY_HEADER_ANCHOR *pHdr, IStream *pStream)
{
    HRESULT hr = E_FAIL;
    CLSID clsidTIP;
    LARGE_INTEGER li;
    GUID guidProp;
    PROPERTYLIST *pPropList;

    memset(pHdr, 0, sizeof(*pHdr));

    if (_dwAuthority & PROPA_WONT_SERIALZE)
        return S_FALSE;

    // nb: this call ignores any property spans following the leftmost span covered by pRange
    // callers are expected to call for each span (which is goofy, but that's the way it is)
    pPropList = _FindPropListAndDivide(pRange->_GetStart(), pRange->_GetEnd());

    if (pPropList == NULL)
    {
        //
        // There is no actual property data.
        //
        hr = S_FALSE;
        goto Exit;
    }

    //
    // perf: we have to tell the application that the data is not 
    //       unserialized yet. maybe we don't have to load it.
    //
    if (!pPropList->_pPropStore)
    {
        if (FAILED(THR(LoadData(pPropList))))
            return E_FAIL;
    }

    Assert(pPropList->_pPropStore);

    if (FAILED(GetType(&guidProp)))
        goto Exit;

    //
    // If the request range does not match the PROPERTYLIST,
    // we can not serialize STATIC and CUSTOM correctly.
    //
    // STATICCOMPACT property does not care about boundary, so
    // let it serialize.
    //
    if (CompareAnchors(pRange->_GetStart(), pPropList->_paStart) != 0 ||
        CompareAnchors(pRange->_GetEnd(), pPropList->_paEnd) != 0)
    {
        if (_propStyle != TFPROPSTYLE_STATICCOMPACT &&
            _propStyle != TFPROPSTYLE_CUSTOM_COMPACT)
        {
            hr = S_FALSE;
            goto Exit;
        }

        pRange->_GetStart()->Clone(&pHdr->paStart);
        pRange->_GetEnd()->Clone(&pHdr->paEnd);
    }
    else
    {
        pPropList->_paStart->Clone(&pHdr->paStart);
        pPropList->_paEnd->Clone(&pHdr->paEnd);
    }

    hr = pPropList->_pPropStore->GetPropertyRangeCreator(&clsidTIP);

    if (FAILED(hr))
    {
        hr = E_FAIL;
        goto Exit;
    }

    if (hr == S_OK)
    {
        if (IsEqualGUID(clsidTIP, GUID_NULL)) // NULL owner means "I don't want to be serialized"
        {
            hr = S_FALSE;
            goto Exit;
        }

        //
        // Check if clsid has ITfCreatePropertyStore interface.
        //
        CThreadInputMgr *ptim = CThreadInputMgr::_GetThis();
        ITfTextInputProcessor *pIME;
        ITfCreatePropertyStore *pCreateStore;
        TfGuidAtom guidatom;

        hr = E_FAIL;

        if (FAILED(MyRegisterGUID(clsidTIP, &guidatom)))
            goto Exit;

        if (!ptim->_GetITfIMEfromGUIDATOM(guidatom, &pIME))
            goto Exit;

        if (FAILED(pIME->QueryInterface(IID_ITfCreatePropertyStore,
                                        (void **)&pCreateStore)))
        {
            hr = S_FALSE;
            goto Exit;
        }

        BOOL fSerializable = FALSE;

        Assert(pRange != NULL);

        if (FAILED(pCreateStore->IsStoreSerializable(guidProp,
                                                 (ITfRangeAnchor *)pRange, 
                                                 pPropList->_pPropStore, 
                                                 &fSerializable)))
        {
             fSerializable = FALSE;
        }

        pCreateStore->Release();

        if (!fSerializable)
        {
            hr = S_FALSE;
            goto Exit;
        }

        pHdr->clsidTIP = clsidTIP;
    }
    else if (hr == TF_S_PROPSTOREPROXY)
    {
        //
        // the data is held by our PropertyStoreProxy.
        // we don't have to check this.
        //
        pHdr->clsidTIP = clsidTIP;
    }
    else if (hr == TF_S_GENERALPROPSTORE)
    {
        //
        // the data is held by our GeneralPropertyStore.
        // we don't have to check this.
        //
        pHdr->clsidTIP = CLSID_IME_StaticProperty;
    }
    else 
    {
        Assert(0);
        hr = E_FAIL;
        goto Exit;
    }

    pHdr->guidType = guidProp;

    if (FAILED(hr = THR(pPropList->_pPropStore->GetDataType(&pHdr->dwPrivate))))
    {
        goto Exit;
    }

    GetCurrentPos(pStream, &li);

    hr = THR(pPropList->_pPropStore->Serialize(pStream, &pHdr->cb));

    // make sure the stream seek ptr is in a consistent state -- don't count
    // on any tip to do it right!
    if (hr == S_OK)
    {
        li.QuadPart += pHdr->cb;
    }
    pStream->Seek(li, STREAM_SEEK_SET, NULL);

Exit:
    if (hr != S_OK)
    {
        SafeRelease(pHdr->paStart);
        SafeRelease(pHdr->paEnd);
        memset(pHdr, 0, sizeof(*pHdr));
    }

    _Dbg_AssertProp();

    return hr;
}

//+---------------------------------------------------------------------------
//
// Unserialize
//
//----------------------------------------------------------------------------

HRESULT CProperty::_Unserialize(const TF_PERSISTENT_PROPERTY_HEADER_ANCHOR *pHdr, IStream *pStream, ITfPersistentPropertyLoaderAnchor *pLoader)
{
    HRESULT hr = E_FAIL;
    CRange *pRange;

    if (pStream)
    {
        if (pRange = new CRange)
        {
            if (pRange->_InitWithDefaultGravity(_pic, COPY_ANCHORS, pHdr->paStart, pHdr->paEnd))
            {
                ITfPropertyStore *pPropStore;
                if (SUCCEEDED(hr = _GetPropStoreFromStream(pHdr, pStream, pRange, &pPropStore)))
                {
                    hr = _SetStoreInternal(BACKDOOR_EDIT_COOKIE, pRange, pPropStore, TRUE);
                    pPropStore->Release();
                }
            }
            pRange->Release();
        }
    }
    else if (pLoader)
    {
        if (pRange = new CRange)
        {
            if (pRange->_InitWithDefaultGravity(_pic, COPY_ANCHORS, pHdr->paStart, pHdr->paEnd))
            {
                CPropertyLoad *pPropLoad = new CPropertyLoad;

                if (pPropLoad != NULL)
                {
                    hr = E_FAIL;
                    if (pPropLoad->_Init(pHdr, pLoader))
                    {
                        hr = _SetPropertyLoaderInternal(BACKDOOR_EDIT_COOKIE, pRange, pPropLoad);
                    }

                    if (FAILED(hr))
                    {
                        delete pPropLoad;
                    }
                }
            }
            pRange->Release();
        }
    }

    _Dbg_AssertProp();

    return hr;
}
//+---------------------------------------------------------------------------
//
// _ClearChangeHistory
//
//----------------------------------------------------------------------------

void CProperty::_ClearChangeHistory(PROPERTYLIST *prop, DWORD *pdwStartHistory, DWORD *pdwEndHistory)
{
    if (prop->_paStart->GetChangeHistory(pdwStartHistory) != S_OK)
    {
        *pdwStartHistory = 0;
    }
    if (prop->_paEnd->GetChangeHistory(pdwEndHistory) != S_OK)
    {
        *pdwEndHistory = 0;
    }

    // need to clear the history so we don't deal with the after-effects
    // of a SetText more than once
    if (*pdwStartHistory != 0)
    {
        prop->_paStart->ClearChangeHistory();
    }
    if (*pdwEndHistory != 0)
    {
        prop->_paEnd->ClearChangeHistory();
    }
}

//+---------------------------------------------------------------------------
//
// _ClearChangeHistory
//
//----------------------------------------------------------------------------

#ifdef DEBUG
void CProperty::_Dbg_AssertNoChangeHistory()
{
    int i;
    PROPERTYLIST *prop;
    DWORD dwHistory;

    // all the history bits should have been cleared immediately following the text change notification
    for (i=0; i<_rgProp.Count(); i++)
    {
        prop = _rgProp.Get(i);

        prop->_paStart->GetChangeHistory(&dwHistory);
        Assert(dwHistory == 0);
        prop->_paEnd->GetChangeHistory(&dwHistory);
        Assert(dwHistory == 0);
    }
}
#endif // DEBUG

//+---------------------------------------------------------------------------
//
// FindNextValue
//
//----------------------------------------------------------------------------

STDAPI CProperty::FindNextValue(TfEditCookie ec, ITfRange *pRangeQueryIn, TfAnchor tfAnchorQuery,
                                DWORD dwFlags, BOOL *pfContained, ITfRange **ppRangeNextValue)
{
    CRange *pRangeQuery;
    CRange *pRangeNextValue;
    IAnchor *paQuery;
    PROPERTYLIST *pPropertyList;
    LONG iIndex;
    BOOL fSearchForward;
    BOOL fContained;
    BOOL fExactMatch;

    if (pfContained != NULL)
    {
        *pfContained = FALSE;
    }
    if (ppRangeNextValue != NULL)
    {
        *ppRangeNextValue = NULL;
    }
    if (pfContained == NULL || ppRangeNextValue == NULL)
         return E_INVALIDARG;

    if (pRangeQueryIn == NULL)
         return E_INVALIDARG;

    if (dwFlags & ~(TF_FNV_BACKWARD | TF_FNV_NO_CONTAINED))
         return E_INVALIDARG;

    if (!_IsValidEditCookie(ec, TF_ES_READ))
        return TF_E_NOLOCK;

    if ((pRangeQuery = GetCRange_NA(pRangeQueryIn)) == NULL)
         return E_INVALIDARG;

    if (!VerifySameContext(_pic, pRangeQuery))
        return E_INVALIDARG;

    fSearchForward = !(dwFlags & TF_FNV_BACKWARD);

    pRangeQuery->_QuickCheckCrossedAnchors();

    paQuery = (tfAnchorQuery == TF_ANCHOR_START) ? pRangeQuery->_GetStart() : pRangeQuery->_GetEnd();

    fExactMatch = (Find(paQuery, &iIndex, fSearchForward) != NULL);

    if (fSearchForward)
    {
        if (++iIndex >= _rgProp.Count())
            return S_OK; // no next value
    }
    else
    {
        if (fExactMatch)
        {
            --iIndex;
        }
        if (iIndex < 0)
            return S_OK; // no prev value
    }

    pPropertyList = _rgProp.Get(iIndex);
    Assert(pPropertyList != NULL);

    fContained = (CompareAnchors(pPropertyList->_paStart, paQuery) <= 0) &&
                 (CompareAnchors(pPropertyList->_paEnd, paQuery) >= 0);

    if (fContained && (dwFlags & TF_FNV_NO_CONTAINED))
    {
        // caller wants to skip any contained value span
        if (fSearchForward)
        {
            if (++iIndex >= _rgProp.Count())
                return S_OK; // no next value
        }
        else
        {
            if (--iIndex == -1)
                return S_OK; // no prev value
        }

        pPropertyList = _rgProp.Get(iIndex);
        Assert(pPropertyList != NULL);

        fContained = FALSE;
    }

    if ((pRangeNextValue = new CRange) == NULL)
        return E_OUTOFMEMORY;

    if (!pRangeNextValue->_InitWithDefaultGravity(_pic, COPY_ANCHORS, pPropertyList->_paStart, pPropertyList->_paEnd))
    {
        pRangeNextValue->Release();
        return E_FAIL;
    }

    *pfContained = fContained;
    *ppRangeNextValue = (ITfRangeAnchor *)pRangeNextValue;

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\ctf\uim\rprange.cpp ===
//
// rprange.cpp
//

#include "private.h"
#include "ic.h"
#include "rprop.h"
#include "range.h"
#include "tim.h"
#include "rngsink.h"
#include "immxutil.h"

//+---------------------------------------------------------------------------
//
// GetData
//
//----------------------------------------------------------------------------

HRESULT CProperty::_GetDataInternal(IAnchor *paStart, IAnchor *paEnd, VARIANT *pvarValue)
{
    HRESULT hr;
    PROPERTYLIST *pPropList;

    if (pvarValue == NULL)
        return E_INVALIDARG;

    QuickVariantInit(pvarValue);

    pPropList = _FindPropList(paStart, paEnd);

    if (pPropList)
    {
        if (!pPropList->_pPropStore)
        {
            if (FAILED(hr = LoadData(pPropList)))
                goto Exit;
        }

        hr = pPropList->_pPropStore->GetData(pvarValue);
    }
    else
    {
        // property has no value over the range
        hr = S_FALSE;
    }

Exit:
    return hr;
}

//+---------------------------------------------------------------------------
//
// _SetStoreInternal
//
//----------------------------------------------------------------------------

HRESULT CProperty::_SetStoreInternal(TfEditCookie ec, CRange *pRange, ITfPropertyStore *pPropStore, BOOL fInternal)
{
    GUID guidStore;

    if (pPropStore == NULL)
        return E_INVALIDARG;

    if (!fInternal)
    {
        //
        // Make sure this property is not using System's StaticPropStore.
        //
        if (GetPropStyle() != TFPROPSTYLE_CUSTOM && GetPropStyle() != TFPROPSTYLE_CUSTOM_COMPACT)
            return E_FAIL;
    }

    if (IsEqualAnchor(pRange->_GetStart(), pRange->_GetEnd()))
        return E_INVALIDARG;

    //
    // Check type of PropertyStore.
    //
    if (FAILED(pPropStore->GetType(&guidStore)))
        return E_FAIL;

    if (!MyIsEqualTfGuidAtom(GetPropGuidAtom(), guidStore))
        return E_FAIL;

    return Set(pRange->_GetStart(), pRange->_GetEnd(), pPropStore);
}


//+---------------------------------------------------------------------------
//
// _SetDataInternal
//
//----------------------------------------------------------------------------

HRESULT CProperty::_SetDataInternal(TfEditCookie ec, IAnchor *paStart, IAnchor *paEnd, const VARIANT *pvarValue)
{
    CGeneralPropStore *store;
    HRESULT hr;

    Assert(!IsEqualAnchor(paStart, paEnd)); // caller should have checked

    switch (GetPropStyle())
    {
        case TFPROPSTYLE_STATIC:
        case TFPROPSTYLE_STATICCOMPACT:
            if ((store = new CStaticPropStore) == NULL)
                return E_OUTOFMEMORY;

            break;

        case TFPROPSTYLE_CUSTOM:
        case TFPROPSTYLE_CUSTOM_COMPACT:
            //
            // This property is not using System's StaticPropStore.
            // so we use a default range property sink.
            //
            if ((store = new CGeneralPropStore) == NULL)
                return E_OUTOFMEMORY;

            break;

        default:
            Assert(0); // bogus style!
            return E_UNEXPECTED;
    }

    if (!store->_Init(GetPropGuidAtom(), pvarValue, _dwPropFlags))
    {
        store->Release();
        return E_FAIL;
    }

    hr = Set(paStart, paEnd, store);
    store->Release();

    return hr;
}


//+---------------------------------------------------------------------------
//
// ClearInternal
//
//----------------------------------------------------------------------------

HRESULT CProperty::_ClearInternal(TfEditCookie ec, IAnchor *paStart, IAnchor *paEnd)
{
    PROPERTYLIST *pPropertyList;
    LONG nCur;

    if (paStart != NULL)
    {
        Assert(paEnd != NULL);

        if (IsEqualAnchor(paStart, paEnd))
            return S_OK;

        Clear(paStart, paEnd, 0, FALSE);

        Find(paStart, &nCur, FALSE);
        if (nCur >= 0)
            _DefragAfterThis(nCur);
    }
    else
    {
        // Clear(NULL, NULL) means wipe all instances
        for (nCur=0; nCur<_rgProp.Count(); nCur++)
        {
            pPropertyList = _rgProp.Get(nCur);

            if (CompareAnchors(pPropertyList->_paStart, pPropertyList->_paEnd) <= 0)
            {
                PropertyUpdated(pPropertyList->_paStart, pPropertyList->_paEnd);
            }
            else
            {
                // crossed anchors
                PropertyUpdated(pPropertyList->_paEnd, pPropertyList->_paEnd);
            }
            _FreePropertyList(pPropertyList);
        }
        _rgProp.Clear();
    }

    return S_OK;
}

//+---------------------------------------------------------------------------
//
// _FindPropList
//
//----------------------------------------------------------------------------

PROPERTYLIST *CProperty::_FindPropList(IAnchor *paStart, IAnchor *paEnd)
{
    PROPERTYLIST *pPropList;
    LONG nCur;

    if (CompareAnchors(paStart, paEnd) == 0)
        return NULL;

    //
    // The range does not have to be exactly matched.
    // we can return pPropList covers the given range.
    //

    Find(paStart, &nCur, FALSE);
    if (nCur < 0)
        return NULL;

    pPropList = SafeGetPropList(nCur);
    if (!pPropList)
    {
        Assert(0);
        return NULL;
    }

    Assert(CompareAnchors(paStart, pPropList->_paStart) >= 0);
    if (CompareAnchors(paEnd, pPropList->_paEnd) <= 0)
        return pPropList;

    return NULL;
}

//+---------------------------------------------------------------------------
//
// _FindPropListAndDivide
//
//----------------------------------------------------------------------------

PROPERTYLIST *CProperty::_FindPropListAndDivide(IAnchor *paStart, IAnchor *paEnd)
{
    PROPERTYLIST *pPropList = NULL;
    LONG nCur;
    ITfPropertyStore *pNewPropStore;
    IAnchor *paTmp = NULL;
    BOOL fExactMatch;
    HRESULT hr;

    if (CompareAnchors(paStart, paEnd) == 0)
        return NULL;

    fExactMatch = (Find(paStart, &nCur, FALSE) != NULL);
    if (nCur < 0)
        goto Exit;

    pPropList = SafeGetPropList(nCur);
    if (!pPropList)
    {
        Assert(0);
        goto Exit;
    }

    if (_propStyle == TFPROPSTYLE_STATICCOMPACT ||
        _propStyle == TFPROPSTYLE_CUSTOM_COMPACT)
    {
        Assert(CompareAnchors(paStart, pPropList->_paStart) >= 0);
        if (CompareAnchors(paEnd, pPropList->_paEnd) <= 0)
            return pPropList;

        pPropList = NULL;
        goto Exit;
    }

    if (!fExactMatch)
    {
        if (CompareAnchors(paStart, pPropList->_paEnd) >= 0)
        {
            // query span begins at or after pPropList end-of-span
        
            // is there a following property?
            if ((pPropList = SafeGetPropList(nCur+1)) == NULL)
                goto Exit;
        
            // there is, does the query span cover it?
            if (CompareAnchors(paEnd, pPropList->_paStart) <= 0)
            {
                pPropList = NULL;
                goto Exit; // nope
            }

            // okay, our left edge will be the start of the following property
        }
        else
        {
            Assert(CompareAnchors(paStart, pPropList->_paStart) > 0);

            pNewPropStore = NULL;
            hr = pPropList->_paEnd->Clone(&paTmp);
            if (FAILED(hr) || !paTmp)
            {
                pPropList = NULL;
                goto Exit;
            }

            hr = _Divide(pPropList, paStart, paStart, &pNewPropStore);
            if ((hr == S_OK) && pNewPropStore)
            {
                _CreateNewProp(paStart, 
                               paTmp, 
                               pNewPropStore, 
                               NULL);

                pNewPropStore->Release();
            }
            else
            {
                pPropList = NULL;
                goto Exit;
            }

            pPropList = Find(paStart, NULL, FALSE);
            if (!pPropList)
            {
                Assert(0);
                goto Exit;
            }
        }
    }
    Assert(CompareAnchors(paStart, pPropList->_paStart) == 0);

    SafeReleaseClear(paTmp);

    if (CompareAnchors(paEnd, pPropList->_paEnd) < 0)
    {
        pNewPropStore = NULL;
        hr = pPropList->_paEnd->Clone(&paTmp);
        if (FAILED(hr) || !paTmp)
        {
            pPropList = NULL;
            goto Exit;
        }

        hr = _Divide(pPropList, paEnd, paEnd, &pNewPropStore);
        if ((hr == S_OK) && pNewPropStore)
        {
            _CreateNewProp(paEnd, 
                           paTmp, 
                           pNewPropStore, 
                           NULL);

            pNewPropStore->Release();
        }
        else
        {
            pPropList = NULL;
            goto Exit;
        }

        pPropList = Find(paStart, NULL, FALSE);
        if (!pPropList)
        {
            Assert(0);
            goto Exit;
        }
    }

    Assert(CompareAnchors(paStart, pPropList->_paStart) == 0);
    Assert(CompareAnchors(paEnd, pPropList->_paEnd) == 0);

Exit:
    SafeRelease(paTmp);
    return pPropList;
}

//+---------------------------------------------------------------------------
//
// SetPropertyLoader
//
//----------------------------------------------------------------------------

HRESULT CProperty::_SetPropertyLoaderInternal(TfEditCookie ec, CRange *pRange, CPropertyLoad *pPropLoad)
{
    if (IsEqualAnchor(pRange->_GetStart(), pRange->_GetEnd()))
        return S_OK;

    return SetLoader(pRange->_GetStart(), pRange->_GetEnd(), pPropLoad);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\ctf\uim\systhrd.h ===
//
// systhrd.h
//

#ifndef SYSTHRD_H
#define SYSTHRD_H

#include "globals.h"

class CSysThreadRef
{
public:
    CSysThreadRef(SYSTHREAD *psfn)
    {
        Assert(psfn);
        _psfn = psfn;
    }


protected:
    SYSTHREAD *_psfn;
};

#endif // SYSTHRD_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\ctf\uim\sunka.h ===
//
// sunka.h
//
// CSharedUnknownArray/CEnumUnknown
//

#ifndef SUNKA_H
#define SUNKA_H

// I would love to make this a class,
// but I can't get the compiler to accept a run-time template arg
typedef struct _SHARED_UNKNOWN_ARRAY
{
    ULONG cRef;
    ULONG cUnk;
    IUnknown *rgUnk[1]; // one or more...
} SHARED_UNKNOWN_ARRAY;

inline void SUA_AddRef(SHARED_UNKNOWN_ARRAY *pua)
{
    pua->cRef++;
}

void SUA_Release(SHARED_UNKNOWN_ARRAY *pua);

SHARED_UNKNOWN_ARRAY *SUA_Init(ULONG cUnk, IUnknown **prgUnk);

inline SHARED_UNKNOWN_ARRAY *SUA_Alloc(ULONG cUnk)
{
    return (SHARED_UNKNOWN_ARRAY *)cicMemAlloc(sizeof(SHARED_UNKNOWN_ARRAY)+sizeof(IUnknown)*cUnk-sizeof(IUnknown));
}

inline BOOL SUA_ReAlloc(SHARED_UNKNOWN_ARRAY **ppua, ULONG cUnk)
{
    SHARED_UNKNOWN_ARRAY *pua;

    pua = (SHARED_UNKNOWN_ARRAY *)cicMemReAlloc(*ppua, sizeof(SHARED_UNKNOWN_ARRAY)+sizeof(IUnknown)*cUnk-sizeof(IUnknown));
    
    if (pua != NULL)
    {
        *ppua = pua;
        return TRUE;
    }

    return FALSE;
}

class __declspec(novtable) CEnumUnknown
{
public:
    CEnumUnknown() {}
    virtual ~CEnumUnknown();

    // derived class supplies an _Init() method here
    // It must initialize:
    //      _iCur
    //      _prgUnk
    //
    // the default dtor will clean these guys up.

    void Clone(CEnumUnknown *pClone);
    HRESULT Next(ULONG ulCount, IUnknown **ppUnk, ULONG *pcFetched);
    HRESULT Reset();
    HRESULT Skip(ULONG ulCount);

protected:
    SHARED_UNKNOWN_ARRAY *_prgUnk;
    int _iCur;
};

#define DECLARE_SUNKA_ENUM(sunka_enum_iface, sunka_enumerator_class, sunka_enumed_iface)    \
    STDMETHODIMP Clone(sunka_enum_iface **ppEnum)                                           \
    {                                                                                       \
        sunka_enumerator_class *pClone;                                                     \
                                                                                            \
        if (ppEnum == NULL)                                                                 \
            return E_INVALIDARG;                                                            \
                                                                                            \
        *ppEnum = NULL;                                                                     \
                                                                                            \
        if ((pClone = new sunka_enumerator_class) == NULL)                                  \
            return E_OUTOFMEMORY;                                                           \
                                                                                            \
        CEnumUnknown::Clone(pClone);                                                        \
                                                                                            \
        *ppEnum = pClone;                                                                   \
        return S_OK;                                                                        \
    }                                                                                       \
    STDMETHODIMP Next(ULONG ulCount, sunka_enumed_iface **ppClass, ULONG *pcFetched)        \
    {                                                                                       \
        return CEnumUnknown::Next(ulCount, (IUnknown **)ppClass, pcFetched);                \
    }                                                                                       \
    STDMETHODIMP Reset()                                                                    \
    {                                                                                       \
        return CEnumUnknown::Reset();                                                       \
    }                                                                                       \
    STDMETHODIMP Skip(ULONG ulCount)                                                        \
    {                                                                                       \
        return CEnumUnknown::Skip(ulCount);                                                 \
    }

#endif // SUNKA_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\ctf\uim\spans.h ===
//
// spans.h
//
// CSpanSet
//

#ifndef SPANS_H
#define SPANS_H

#include "private.h"
#include "strary.h"
#include "globals.h"

typedef struct
{
    IAnchor *paStart;
    IAnchor *paEnd;
    DWORD dwFlags;
} SPAN;

class CSpanSet
{
public:
    CSpanSet()
    { 
        Dbg_MemSetThisNameIDCounter(TEXT("CSpanSet"), PERF_SPANSET_COUNTER);
    }
    virtual ~CSpanSet() 
    { 
        Clear();
    }

    void Add(DWORD dwFlags, IAnchor *paStart, IAnchor *paEnd, AnchorOwnership ao);    
    int GetCount() { return _rgSpans.Count(); }
    SPAN *GetSpans() { return _rgSpans.GetPtr(0); }
    void Clear()
    {
        _AnchorsAway();
        _rgSpans.Clear();
    }
    void Reset()
    {
        _AnchorsAway();
        _rgSpans.Reset(4);
    }

    BOOL Normalize(ITextStoreAnchor *ptsi);

protected:

    SPAN *_Find(IAnchor *pa, int *piOut);

    BOOL _AllSpansCovered()
    {
        BOOL fRet = (_rgSpans.Count() == 1 &&
                     _rgSpans.GetPtr(0)->paStart == NULL);

        // paStart == NULL implies paEnd == NULL
        Assert(!fRet || _rgSpans.GetPtr(0)->paEnd == NULL);

        return fRet;
    }

    SPAN *_InsertNewSpan(int iIndex);

    CStructArray<SPAN> _rgSpans;

private:
    void _AnchorsAway();

    DBG_ID_DECLARE;
};


#endif // SPANS_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\ctf\uim\sunka.cpp ===
//
// sunka.cpp
//
// CEnumUnknown
//

#include "private.h"
#include "sunka.h"


//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////
//
// SHARED_UNKNOWN_ARRAY
//
//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////

//+---------------------------------------------------------------------------
//
// SUA_Init
//
//----------------------------------------------------------------------------

SHARED_UNKNOWN_ARRAY *SUA_Init(ULONG cUnk, IUnknown **prgUnk)
{
    SHARED_UNKNOWN_ARRAY *pua;

    pua = (SHARED_UNKNOWN_ARRAY *)cicMemAlloc(sizeof(SHARED_UNKNOWN_ARRAY)+sizeof(IUnknown)*cUnk-sizeof(IUnknown));

    if (pua == NULL)
        return NULL;

    pua->cRef = 1;
    pua->cUnk = cUnk;

    while (cUnk-- > 0)
    {
        pua->rgUnk[cUnk] = prgUnk[cUnk];
        pua->rgUnk[cUnk]->AddRef();
    }

    return pua;
}

//+---------------------------------------------------------------------------
//
// SUA_Release
//
//----------------------------------------------------------------------------

void SUA_Release(SHARED_UNKNOWN_ARRAY *pua)
{
    ULONG i;

    Assert(pua->cRef > 0);
    if (--pua->cRef == 0)
    {
        for (i=0; i<pua->cUnk; i++)
        {
            SafeRelease(pua->rgUnk[i]);
        }
        cicMemFree(pua);
    }
}

//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////
//
// CEnumUnknown
//
//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////


//+---------------------------------------------------------------------------
//
// dtor
//
//----------------------------------------------------------------------------

CEnumUnknown::~CEnumUnknown()
{
    if (_prgUnk != NULL)
    {
        SUA_Release(_prgUnk);
    }
}

//+---------------------------------------------------------------------------
//
// Clone
//
//----------------------------------------------------------------------------

void CEnumUnknown::Clone(CEnumUnknown *pClone)
{
    pClone->_iCur = _iCur;
    pClone->_prgUnk = _prgUnk;
    SUA_AddRef(pClone->_prgUnk);
}

//+---------------------------------------------------------------------------
//
// Next
//
//----------------------------------------------------------------------------

HRESULT CEnumUnknown::Next(ULONG ulCount, IUnknown **ppUnk, ULONG *pcFetched)
{
    ULONG cFetched;

    if (ulCount > 0 && ppUnk == NULL)
        return E_INVALIDARG;

    if (pcFetched == NULL)
    {
        pcFetched = &cFetched;
    }

    *pcFetched = 0;

    while ((ULONG)_iCur < _prgUnk->cUnk && *pcFetched < ulCount)
    {
        *ppUnk = _prgUnk->rgUnk[_iCur];
        (*ppUnk)->AddRef();

        ppUnk++;
        *pcFetched = *pcFetched + 1;
        _iCur++;
    }

    return *pcFetched == ulCount ? S_OK : S_FALSE;
}

//+---------------------------------------------------------------------------
//
// Reset
//
//----------------------------------------------------------------------------

HRESULT CEnumUnknown::Reset()
{
    _iCur = 0;
    return S_OK;
}

//+---------------------------------------------------------------------------
//
// Skip
//
//----------------------------------------------------------------------------

HRESULT CEnumUnknown::Skip(ULONG ulCount)
{
    _iCur += ulCount;

    if ((ULONG)_iCur >= _prgUnk->cUnk)
    {
        _iCur = _prgUnk->cUnk; // prevent overflow for repeated calls
        return S_FALSE;
    }
    
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\ctf\uim\tfprop.h ===
//
// tfprop.h
//

#ifndef TFPROP_H
#define TFPROP_H

#include "mem.h"

typedef struct _PROXY_BLOB
{
    ULONG cb;
    BYTE rgBytes[1]; // 0 or more...

    static struct _PROXY_BLOB *Alloc(ULONG cb)
    {
        return (struct _PROXY_BLOB *)cicMemAlloc(sizeof(ULONG)+cb);
    }

    static struct _PROXY_BLOB *Clone(struct _PROXY_BLOB *blobOrg)
    {
        struct _PROXY_BLOB *blobNew;

        if ((blobNew = Alloc(blobOrg->cb)) == NULL)
            return FALSE;

        blobNew->cb = blobOrg->cb;
        memcpy(blobNew->rgBytes, blobOrg->rgBytes, blobOrg->cb);

        return blobNew;
    }

    static void Free(struct _PROXY_BLOB *blob)
    {
        cicMemFree(blob);
    }

} PROXY_BLOB;

typedef enum
{
    TF_PT_NONE               = 0,
    TF_PT_UNKNOWN            = 1,
    TF_PT_DWORD              = 2,
    TF_PT_GUID               = 3,
    TF_PT_BSTR               = 4
} TfPropertyType;

typedef struct tagTFPROPERTY
{
    TfPropertyType type;
    union
    {
        IUnknown *           punk;
        DWORD                dw;
        TfGuidAtom           guidatom;
        BSTR                 bstr;
        PROXY_BLOB *         blob;
    };
} TFPROPERTY;

inline BOOL IsValidCiceroVarType(VARTYPE vt)
{
    return (vt == VT_I4 || vt == VT_UNKNOWN || vt == VT_EMPTY || vt == VT_BSTR);
}

typedef enum { ADDREF, NO_ADDREF } AddRefCmd;

inline HRESULT VariantToTfProp(TFPROPERTY *ptfp, const VARIANT *pvar, AddRefCmd arc, BOOL fVTI4ToGuidAtom)
{
    HRESULT hr = S_OK;

    switch (pvar->vt)
    {
        case VT_I4:
            if (fVTI4ToGuidAtom)
                ptfp->type = TF_PT_GUID;
            else
                ptfp->type = TF_PT_DWORD;
            ptfp->dw = pvar->lVal;
            break;

        case VT_UNKNOWN:
            ptfp->type = TF_PT_UNKNOWN;
            ptfp->punk = pvar->punkVal;
            if (arc == ADDREF)
            {
                if (ptfp->punk)
                    ptfp->punk->AddRef();
            }
            break;

        case VT_BSTR:
            ptfp->type = TF_PT_BSTR;
            ptfp->bstr = SysAllocString(pvar->bstrVal);
            if (ptfp->bstr == NULL)
            {
                hr = E_OUTOFMEMORY;
            }
            break;

        default:
            Assert(pvar->vt == VT_EMPTY); // only valid value left
            ptfp->type = TF_PT_NONE;
            ptfp->dw = 0;
            break;
    }

    return hr;
}

inline HRESULT TfPropToVariant(VARIANT *pvar, TFPROPERTY *ptfp, AddRefCmd arc)
{
    HRESULT hr = S_OK;

    QuickVariantInit(pvar);

    switch (ptfp->type)
    {
        case TF_PT_DWORD:
        case TF_PT_GUID:
            pvar->vt = VT_I4;
            pvar->lVal = ptfp->dw;
            break;

        case TF_PT_UNKNOWN:
            pvar->vt = VT_UNKNOWN;
            pvar->punkVal = ptfp->punk;
            if (arc == ADDREF)
            {
                if (pvar->punkVal)
                    pvar->punkVal->AddRef();
            }
            break;

        case TF_PT_BSTR:
            pvar->vt = VT_BSTR;
            if (arc == ADDREF)
            {
                pvar->bstrVal = SysAllocString(ptfp->bstr);
                if (pvar->bstrVal == NULL)
                {
                    hr = E_OUTOFMEMORY;
                }
            }
            else
                pvar->bstrVal = ptfp->bstr;
            break;

        default:
            Assert(ptfp->type == TF_PT_NONE);
            pvar->lVal = 0;
            break;
    }

    return hr;
}

inline VARTYPE TfPropTypeToVarType(TfPropertyType tftype)
{
    switch (tftype)
    {
        case TF_PT_DWORD:
        case TF_PT_GUID:
            return VT_I4;

        case TF_PT_UNKNOWN:
            return VT_UNKNOWN;

        case TF_PT_BSTR:
            return VT_BSTR;

        default:
            Assert(tftype == TF_PT_NONE);
            return VT_EMPTY;
    }
}

#endif // TFPROP_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\ctf\uim\tim.cpp ===
//
// tim.cpp
//

#include "private.h"
#include "lmcons.h" // for UNLEN
#include "tim.h"
#include "dim.h"
#include "range.h"
#include "imelist.h"
#include "nuimgr.h"
#include "assembly.h"
#include "acp2anch.h"
#include "sink.h"
#include "ic.h"
#include "funcprv.h"
#include "enumfnpr.h"
#include "enumdim.h"
#include "profiles.h"
#include "marshal.h"
#include "timlist.h"
#include "nuihkl.h"
#include "immxutil.h"
#include "dam.h"
#include "hotkey.h"
#include "sddl.h"

extern void UninitBackgroundThread(); // bthread.cpp
extern "C" HRESULT WINAPI TF_GetGlobalCompartment(ITfCompartmentMgr **ppCompMgr);

const IID *CThreadInputMgr::_c_rgConnectionIIDs[TIM_NUM_CONNECTIONPTS] =
{
    &IID_ITfDisplayAttributeNotifySink,
    &IID_ITfActiveLanguageProfileNotifySink,
    &IID_ITfThreadFocusSink,
    &IID_ITfPreservedKeyNotifySink,
    &IID_ITfThreadMgrEventSink,
    &IID_ITfKeyTraceEventSink,
};

BOOL OnForegroundChanged(HWND hwndFocus);

DBG_ID_INSTANCE(CEnumDocumentInputMgrs);

#ifndef _WIN64
static const TCHAR c_szCicLoadMutex[] = TEXT("CtfmonInstMutex");
#else
static const TCHAR c_szCicLoadMutex[] = TEXT("CtfmonInstMutex.IA64");
#endif

static BOOL s_fOnlyTranslationRunning = FALSE;

TCHAR g_szUserUnique[MAX_PATH];

//+---------------------------------------------------------------------------
//
// InitUniqueString
//
//----------------------------------------------------------------------------

char *GetUserSIDString()
{
    HANDLE hToken = NULL;
    char *pszStringSid = NULL;

    OpenProcessToken(GetCurrentProcess(), TOKEN_QUERY, &hToken);

    if (hToken)
    {
        DWORD dwReturnLength = 0;
        void  *pvUserBuffer = NULL;

        GetTokenInformation(hToken, TokenUser, NULL, 0, &dwReturnLength);

        pvUserBuffer = cicMemAllocClear(dwReturnLength);
        if (pvUserBuffer &&
            GetTokenInformation(hToken, 
                                 TokenUser, 
                                 pvUserBuffer, 
                                 dwReturnLength, 
                                 &dwReturnLength))
        {
            if (!ConvertSidToStringSid(((TOKEN_USER*)(pvUserBuffer))->User.Sid,
                                       &pszStringSid))
            {
                if (pszStringSid)
                    LocalFree(pszStringSid);

                pszStringSid = NULL;
            }
                               
        }

        if (pvUserBuffer)
        {
            cicMemFree(pvUserBuffer);
        }

        CloseHandle(hToken);
    }

    return pszStringSid;
}

//+---------------------------------------------------------------------------
//
// InitUniqueString
//
//----------------------------------------------------------------------------

BOOL InitUniqueString()
{
    TCHAR ach[MAX_PATH];
    DWORD dwLength;
    HDESK hdesk;

    g_szUserUnique[0] = TEXT('\0');

    hdesk = GetThreadDesktop(GetCurrentThreadId());

    if (hdesk && 
        GetUserObjectInformation(hdesk, UOI_NAME, ach, sizeof(ach) /* byte count */, &dwLength))
    {
        StringCchCat(g_szUserUnique, ARRAYSIZE(g_szUserUnique), ach);
    }

    DWORD dwLen = ARRAYSIZE(ach);
    char *pStringSid = GetUserSIDString();
    if (pStringSid)
    {
        StringCchCat(g_szUserUnique, ARRAYSIZE(g_szUserUnique), pStringSid);
        LocalFree(pStringSid);
    }
    else
    {
        return FALSE;
    }

    return TRUE;
}

//+---------------------------------------------------------------------------
//
// GetDesktopUniqueName
//
//----------------------------------------------------------------------------

void GetDesktopUniqueName(const TCHAR *pszPrefix, TCHAR *pch, ULONG cchPch)
{
    StringCchCopy(pch, cchPch, pszPrefix);
    StringCchCat(pch, cchPch, g_szUserUnique);
}

//+---------------------------------------------------------------------------
//
// TF_IsCtfmonRunning
//
//----------------------------------------------------------------------------

extern "C" BOOL WINAPI TF_IsCtfmonRunning()
{
    TCHAR ach[MAX_PATH];
    HANDLE hInstanceMutex;

    //
    // get mutex name.
    //
    GetDesktopUniqueName(c_szCicLoadMutex, ach, ARRAYSIZE(ach));


    hInstanceMutex = OpenMutex(MUTEX_ALL_ACCESS, FALSE, ach);

    if (hInstanceMutex != NULL)
    {
        // ctfmon.exe is already running, don't do any more work
        CloseHandle(hInstanceMutex);
        return TRUE;
    }
    return FALSE;
}

//+---------------------------------------------------------------------------
//
// ExecuteLoader
//
//----------------------------------------------------------------------------

const char c_szCtfmonExe[] = "ctfmon.exe";
const char c_szCtfmonExeN[] = "ctfmon.exe -n";

void ExecuteLoader(void)
{
    if (TF_IsCtfmonRunning())
        return;

    FullPathExec(c_szCtfmonExe,
                 s_fOnlyTranslationRunning ? c_szCtfmonExeN : c_szCtfmonExe,
                 SW_SHOWMINNOACTIVE,
                 FALSE);
}

//+---------------------------------------------------------------------------
//
// TF_CreateCicLoadMutex
//
//----------------------------------------------------------------------------

extern "C" HANDLE WINAPI TF_CreateCicLoadMutex(BOOL *pfWinLogon)
{
    *pfWinLogon = FALSE;

    if (IsOnNT())
    {
        //
        // This checking is for logged on user or not. So we can blcok running
        // ctfmon.exe process from non-authorized user.
        //
        if (!IsInteractiveUserLogon())
        {
            g_SharedMemory.Close();
#ifdef WINLOGON_LANGBAR
            g_SharedMemory.Start();
#else
            return NULL;
#endif WINLOGON_LANGBAR
        }
    }

    HANDLE hmutex;
    TCHAR ach[MAX_PATH];

    //
    // get mutex name after calling SetThreadDesktop.
    //
    GetDesktopUniqueName(c_szCicLoadMutex, ach, ARRAYSIZE(ach));

#ifdef __DEBUG
    {
        char szBuf[MAX_PATH];
        wsprintf(szBuf, "TF_CreateCicLoadMutex in %s\r\n", ach);
        OutputDebugString(szBuf);
    }
#endif

    hmutex =  CreateMutex(NULL, FALSE, ach);

    if (GetLastError() == ERROR_ALREADY_EXISTS)
    {
        //
        // another cicload process is already running        
        //
        CloseHandle(hmutex);
        hmutex = NULL;
    }

    return hmutex;
}

DBG_ID_INSTANCE(CThreadInputMgr);

//+---------------------------------------------------------------------------
//
// ctor
//
//----------------------------------------------------------------------------

CThreadInputMgr::CThreadInputMgr()
                :CCompartmentMgr(g_gaApp, COMPTYPE_TIM)
{
    Dbg_MemSetThisNameID(TEXT("CThreadInputMgr"));

    Assert(_GetThis() == NULL);
    _SetThis(this); // save a pointer to this in TLS

    _fAddedProcessAtom = FALSE;
    _SetProcessAtom();

    Assert(_fActiveView == FALSE);
    Assert(_pSysHookSink == NULL);
    Assert(_fFirstSetFocusAfterActivated == FALSE);
}

//+---------------------------------------------------------------------------
//
// dtor
//
//----------------------------------------------------------------------------

CThreadInputMgr::~CThreadInputMgr()
{
    ATOM atom;

    Assert(_tidForeground == TF_INVALID_GUIDATOM);
    Assert(_tidPrevForeground == TF_INVALID_GUIDATOM);

    Assert(_rgTip.Count() == 0);

    Assert(_pPendingCleanupContext == NULL);
    Assert(_pSysHookSink == NULL);

    SafeReleaseClear(_pSysFuncPrv);
    SafeReleaseClear(_pAppFuncProvider);

    // remove ref to this in TLS
    _SetThis(NULL);

    // Release the per-process atom
    if (_fAddedProcessAtom &&
        (atom = FindAtom(TF_PROCESS_ATOM)))
    {
        DeleteAtom(atom);
    }
}

//+---------------------------------------------------------------------------
//
// CreateInstance
//
//----------------------------------------------------------------------------

/* static */
BOOL CThreadInputMgr::VerifyCreateInstance(IUnknown *pUnkOuter, REFIID riid, void **ppvObj)
{
    // Look up disabling Text Services status from the registry.
    // If it is disabled, return fail not to support Text Services.
    if (IsDisabledTextServices())
        return FALSE;

    if (NoTipsInstalled(&s_fOnlyTranslationRunning))
        return FALSE;

    //
    // Check up the interactive user logon
    //
    if (!IsInteractiveUserLogon())
        return FALSE;

    //
    // #609356
    //
    // we don't want to start Cicero on SMSCliToknAcct& account.
    //
    char szUserName[UNLEN + 1];
    DWORD dwUserNameLen = UNLEN;
    if (GetUserName(szUserName, &dwUserNameLen) && dwUserNameLen)
    {
        if (!lstrcmp(szUserName, "SMSCliToknAcct&"))
        {
            return FALSE;
        }
    }

    return TRUE;
}

//+---------------------------------------------------------------------------
//
// SetProcessAtom
//
//----------------------------------------------------------------------------

void CThreadInputMgr::_SetProcessAtom()
{
    if (_fAddedProcessAtom)
        return;

    // AddRef the per-process atom
    if (FindAtom(TF_ENABLE_PROCESS_ATOM))
    {
        AddAtom(TF_PROCESS_ATOM);
        _fAddedProcessAtom = TRUE;
    }
}

//+---------------------------------------------------------------------------
//
// _StaticInit_OnActivate
//
// Init all our process global members. Called from Activate.
//
//----------------------------------------------------------------------------

void CThreadInputMgr::_StaticInit_OnActivate()
{

    CicEnterCriticalSection(g_cs);

    // register two special guid atoms
    MyRegisterGUID(GUID_APPLICATION, &g_gaApp);
    MyRegisterGUID(GUID_SYSTEM, &g_gaSystem);

    CicLeaveCriticalSection(g_cs);
}

//+---------------------------------------------------------------------------
//
// Activate
//
//----------------------------------------------------------------------------

STDAPI CThreadInputMgr::Activate(TfClientId *ptid)
{
    return ActivateEx(ptid, 0);
}

//+---------------------------------------------------------------------------
//
// ActivateEx
//
//----------------------------------------------------------------------------

STDAPI CThreadInputMgr::ActivateEx(TfClientId *ptid, DWORD dwFlags)
{
    CDisplayAttributeMgr *pDisplayAttrMgr;
    CAssemblyList *pAsmList = NULL;
    SYSTHREAD *psfn = GetSYSTHREAD();

    if (ptid == NULL)
        return E_INVALIDARG;

    *ptid = TF_INVALID_GUIDATOM;

    if (_fInDeactivate)
    {
        Assert(0); // woah, we're inside Deactivate higher up the stack...
        return E_UNEXPECTED;
    }
    _fInActivate = TRUE;

    //
    // Windows #476099
    //
    // Under CUAS, TIM could be created before Word set TF_ENABLE_PROCESS_ATIM,
    // so we need to check the atom whenever Activate() is called.
    //
    _SetProcessAtom();

    if (_iActivateRefCount++ > 0)
        goto Exit;

    Assert(_iActivateRefCount == 1);

    ExecuteLoader();

    CtfImmSetCiceroStartInThread(TRUE);

    if (EnsureTIMList(psfn))
        g_timlist.SetFlags(psfn->dwThreadId, TLF_TIMACTIVE | TLF_GCOMPACTIVE);

    // g_gcomplist.Init();

    _StaticInit_OnActivate();

    // dink with active accessibility
    if (GetSharedMemory()->cMSAARef >= 0) // don't worry about mutex since this is just for perf
    {
        _InitMSAA();
    }

    // make sure lbaritems are updated
    TF_CreateLangBarItemMgr(&_plbim);

    //
    // we call _Init here to make sure Reconversion and DeviceType items
    // are added. LangBarItemMgr could be created before TIM is created.
    // Then the LangBarItemMgr does not have Reconversion or DeviceTye items.
    //
    if (psfn && psfn->plbim)
        psfn->plbim->_Init();

    if (psfn)
    {
        //
        // perf: need to find a way to delay allocation.
        //
        pAsmList = EnsureAssemblyList(psfn);
    }

    //
    // warm up the tips
    //
    
    if (!pAsmList || !pAsmList->Count())
        goto Exit;
    
    // keep a ref on the display attr mgr while tips are activated
    Assert(_fReleaseDisplayAttrMgr == FALSE);
    if (CDisplayAttributeMgr::CreateInstance(NULL, IID_CDisplayAttributeMgr, (void **)&pDisplayAttrMgr) == S_OK)
    {
        _fReleaseDisplayAttrMgr = TRUE;
    }

    if (!(dwFlags & TF_TMAE_NOACTIVATETIP))
    {
        //
        // get first (default) assembly.
        //
        CAssembly *pAsm;
        pAsm = pAsmList->FindAssemblyByLangId(GetCurrentAssemblyLangId(psfn));
        if (pAsm)
            ActivateAssembly(pAsm->GetLangId(), ACTASM_ONTIMACTIVE);
    }

    if (GetSharedMemory()->dwFocusThread == GetCurrentThreadId())
    {
        _OnThreadFocus(TRUE);
    }

    InitDefaultHotkeys();
    _fFirstSetFocusAfterActivated = TRUE;
    
Exit:
    _fInActivate = FALSE;

    *ptid = g_gaApp;
    return S_OK;
}

//+---------------------------------------------------------------------------
//
// Deactivate
//
//----------------------------------------------------------------------------

STDAPI CThreadInputMgr::Deactivate()
{
    SYSTHREAD *psfn;
    int i;
    int nCnt;
    HRESULT hr;
    CLEANUPCONTEXT cc;

    if (_fInActivate)
    {
        Assert(0); // woah, we're inside Activate higher up the stack...
        return E_UNEXPECTED;
    }
    _fInDeactivate = TRUE;

    hr = S_OK;

    _iActivateRefCount--;

    if (_iActivateRefCount > 0)
        goto Exit;

    if (_iActivateRefCount < 0)
    {
        Assert(0); // someone is under-refing us
        _iActivateRefCount = 0;
        hr = E_UNEXPECTED;
        goto Exit;
    }

    CtfImmSetCiceroStartInThread(FALSE);

    UninitDefaultHotkeys();

    psfn = GetSYSTHREAD();

    _SetFocus(NULL, TRUE);

    if (_fActiveUI)
    {
        _OnThreadFocus(FALSE);
    }
    _tidPrevForeground = TF_INVALID_GUIDATOM;

    _iActivateRefCount = 0; // must do this after calling _OnThreadFocus(FALSE) or the call will be ignored

    //
    // #489905
    //
    // we can not call sink anymore after DLL_PROCESS_DETACH.
    //
    if (DllShutdownInProgress())
        goto Exit;

    // cleanup all the ics
    cc.fSync = TRUE;
    cc.pCatId = NULL;
    cc.langid = MAKELANGID(LANG_NEUTRAL, SUBLANG_NEUTRAL);
    cc.pfnPostCleanup = NULL;
    cc.lPrivate = 0;

    _CleanupContexts(&cc);


    // deactivate everyone
    for (i=0; i<_rgTip.Count(); i++)
    {
        CTip *ptip = _rgTip.Get(i);

        if (ptip->_pTip != NULL)
        {
            _DeactivateTip(ptip);
        }
    }
    // wipe out the array after calling everyone
    for (i=0; i<_rgTip.Count(); i++)
    {
        CTip *ptip = _rgTip.Get(i);

        ptip->CleanUp();
        delete ptip;
    }
    _rgTip.Clear();

    if (_pAAAdaptor != NULL)
    {
        _UninitMSAA();
    }

    if (psfn != NULL &&
        psfn->plbim &&
        psfn->plbim->_GetLBarItemDeviceTypeArray() &&
        (nCnt = psfn->plbim->_GetLBarItemDeviceTypeArray()->Count()))
    {
        for (i = 0; i < nCnt; i++)
        {
            CLBarItemDeviceType *plbiDT;
            plbiDT = psfn->plbim->_GetLBarItemDeviceTypeArray()->Get(i);
            if (plbiDT)
                plbiDT->Uninit();
        }
    }

    // g_gcomplist.Uninit();
    g_timlist.ClearFlags(GetCurrentThreadId(), TLF_TIMACTIVE);

    if (_fReleaseDisplayAttrMgr && psfn->pdam != NULL)
    {
        psfn->pdam->Release();
    }
    _fReleaseDisplayAttrMgr = FALSE;

    Perf_DumpStats();

Exit:
    _fInDeactivate = FALSE;
    return hr;
}

//+---------------------------------------------------------------------------
//
// _GetActiveInputProcessors
//
//----------------------------------------------------------------------------

HRESULT CThreadInputMgr::_GetActiveInputProcessors(ULONG ulCount, CLSID *pclsid, ULONG *pulCount)
{
    ULONG i;
    ULONG ulCopy;
    ULONG ulCnt;
    HRESULT hr;

    if (!pulCount)
        return E_INVALIDARG;

    ulCnt = _rgTip.Count();
    if (!pclsid)
    {
        ulCopy = 0;
        for (i = 0; i < ulCnt; i++)
        {
            CTip *ptip = _rgTip.Get(i);
            if (ptip->_fActivated)
                 ulCopy++;
        }
        *pulCount = ulCopy;
        return S_OK;
    }

    ulCopy = min((int)ulCount, _rgTip.Count());
    *pulCount = ulCopy;

    hr = S_OK;

    for (i = 0; i < ulCnt; i++)
    {
        CTip *ptip = _rgTip.Get(i);

        if (ulCopy && ptip->_fActivated)
        {
            if (FAILED(hr = MyGetGUID(ptip->_guidatom, pclsid)))
                 break;

            pclsid++;
            ulCopy--;
        }
    }
   

    return hr;
}


//+---------------------------------------------------------------------------
//
// IsActivateInputProcessor
//
//----------------------------------------------------------------------------

HRESULT CThreadInputMgr::_IsActiveInputProcessor(REFCLSID clsid)
{
    TfGuidAtom guidatom;

    if (FAILED(MyRegisterGUID(clsid, &guidatom)))
        return E_FAIL;

    return _IsActiveInputProcessorByATOM(guidatom);
}

HRESULT CThreadInputMgr::_IsActiveInputProcessorByATOM(TfGuidAtom guidatom)
{
    ULONG i;
    ULONG ulCnt;
    HRESULT hr = E_FAIL;

    ulCnt = _rgTip.Count();
    for (i = 0; i < ulCnt; i++)
    {
        CTip *ptip = _rgTip.Get(i);

        if (ptip->_guidatom == guidatom)
        {
            hr = ptip->_fActivated ? S_OK : S_FALSE;
            break;
        }
    }

    return hr;
}


//+---------------------------------------------------------------------------
//
// ActivateInputProcessor
//
//----------------------------------------------------------------------------

HRESULT CThreadInputMgr::ActivateInputProcessor(REFCLSID clsid, REFGUID guidProfile, HKL hklSubstitute, BOOL fActivate)
{
    CTip *ptip;
    HRESULT hr = E_FAIL;

    if (fActivate)
    {
        if (_ActivateTip(clsid, hklSubstitute, &ptip) == S_OK)
        { 
            hr = S_OK;
        }
    }
    else
    {
        TfGuidAtom guidatom;

        if (FAILED(MyRegisterGUID(clsid, &guidatom)))
            return E_FAIL;

        if (_GetCTipfromGUIDATOM(guidatom, &ptip))
        {
            hr = _DeactivateTip(ptip);
        }
    }

    if (hr == S_OK)
    {
        NotifyActivateInputProcessor(clsid, guidProfile, fActivate);
    }

    return S_OK;
}

//+---------------------------------------------------------------------------
//
// NotifyActivateInputProcessor
//
//----------------------------------------------------------------------------

HRESULT CThreadInputMgr::NotifyActivateInputProcessor(REFCLSID clsid, REFGUID guidProfile, BOOL fActivate)
{
    if (DllShutdownInProgress())
        return S_OK;

    CStructArray<GENERICSINK> *rgActiveTIPNotifySinks;
    int i;

    // Notify this to ITfActiveLanguageProfileNotifySink
    rgActiveTIPNotifySinks = _GetActiveTIPNotifySinks();

    for (i=0; i<rgActiveTIPNotifySinks->Count(); i++)
    {
        ((ITfActiveLanguageProfileNotifySink *)rgActiveTIPNotifySinks->GetPtr(i)->pSink)->OnActivated(clsid, guidProfile, fActivate);
    }
    return S_OK;
}

//+---------------------------------------------------------------------------
//
// _GetSubstituteIMEModule
//
// Win98's imm.dll load and free IME module whenever hKL is changed. But 
// Cicero changes hKL frequently even during IME is showing it's on 
// dialog boxies.
// It is bad to free IME module then. So we keep IME's module ref count 
// in CTip.
//
//----------------------------------------------------------------------------

void CThreadInputMgr::_GetSubstituteIMEModule(CTip *ptip, HKL hklSubstitute)
{
    char szIMEFile[MAX_PATH];

    //
    // In NT, system keep the module of IME. So we don't have to cache it.
    //
    if (IsOnNT())
        return;

    if (!IsIMEHKL(hklSubstitute))
        return;

    if (ptip->_hInstSubstituteHKL)
        return;

    if (ImmGetIMEFileNameA(hklSubstitute, szIMEFile, ARRAYSIZE(szIMEFile)))
    {
        ptip->_hInstSubstituteHKL = LoadSystemLibrary(szIMEFile);
    }
}

//+---------------------------------------------------------------------------
//
// ActivateTip
//
//----------------------------------------------------------------------------

HRESULT CThreadInputMgr::_ActivateTip(REFCLSID clsid, HKL hklSubstitute, CTip **pptip)
{
    ITfTextInputProcessor *pitip;
    CTip *ptip = NULL;
    HRESULT hr = E_FAIL;
    TfGuidAtom guidatom;
    int i;
    int nCnt;
    BOOL fCoInitCountCkipMode;

    if (FAILED(MyRegisterGUID(clsid, &guidatom)))
        return E_FAIL;

    nCnt = _rgTip.Count();

    for (i = 0; i < nCnt; i++)
    {
        ptip = _rgTip.Get(i);

        if (ptip->_guidatom == guidatom)
        {
            Assert(ptip->_pTip);
            if (!ptip->_fActivated)
            {
                ptip->_fActivated = TRUE;

                fCoInitCountCkipMode = CtfImmEnterCoInitCountSkipMode();
                ptip->_pTip->Activate(this, guidatom);
                if (fCoInitCountCkipMode)
                    CtfImmLeaveCoInitCountSkipMode();

                hr = S_OK;
                goto Exit;
            }
            hr = S_FALSE;
            goto Exit;
        }
    }

    if (SUCCEEDED(CoCreateInstance(clsid,
                                   NULL, 
                                   CLSCTX_INPROC_SERVER, 
                                   IID_ITfTextInputProcessor, 
                                   (void**)&pitip)))
    {
        CTip **pptipBuf;
        if ((ptip = new CTip) == NULL)
        {
            pitip->Release();
            goto Exit;
        }

        pptipBuf = _rgTip.Append(1);
        if (!pptipBuf)
        {
            delete ptip;
            pitip->Release();
            goto Exit;
        }

        *pptipBuf = ptip;

        ptip->_pTip = pitip;

        ptip->_guidatom = guidatom;
        ptip->_fActivated = TRUE;

        //
        // add refcound of IME file module of klSubstitute.
        //
        _GetSubstituteIMEModule(ptip, hklSubstitute);

        // and activate its ui
        fCoInitCountCkipMode = CtfImmEnterCoInitCountSkipMode();
        ptip->_pTip->Activate(this, guidatom);
        if (fCoInitCountCkipMode)
            CtfImmLeaveCoInitCountSkipMode();

        hr = S_OK;
    }

Exit:
    //
    // Stress 613240
    //
    //   clsid {f25e9f57-2fc8-4eb3-a41a-cce5f08541e6} Tablet PC handwriting 
    //   TIP somehow has this problem. During tip->Activate(), tim seems to
    //   be deactivated. So now _rgTip is empty.
    //
    if (!_rgTip.Count())
    {
        ptip = NULL;
        hr = E_FAIL;
    }

    if (pptip)
        *pptip = ptip;
 
    if (hr == S_OK)
    {
        // hook up any display attribute collections for this tip
        CDisplayAttributeMgr::_AdviseMarkupCollection(ptip->_pTip, guidatom);
    }

    return hr;
}


//+---------------------------------------------------------------------------
//
// DeactivateTip
//
//----------------------------------------------------------------------------

HRESULT CThreadInputMgr::_DeactivateTip(CTip *ptip)
{
    HRESULT hr = S_FALSE;

    //
    // #622929
    //
    // Hack for UninitThread on shutting down.
    //
    SYSTHREAD *psfn = FindSYSTHREAD();
    if (psfn && psfn->fUninitThreadOnShuttingDown)
    {
        Assert(0);
        return S_OK;
    }

    Assert(ptip->_pTip);
    if (ptip->_fActivated)
    {
        BOOL fCoInitCountCkipMode;

        if (ptip->_guidatom == _tidForeground)
        {
            _SetForeground(TF_INVALID_GUIDATOM);
        }

        if (ptip->_guidatom == _tidPrevForeground)
        {
            _tidPrevForeground = TF_INVALID_GUIDATOM;
        }

        ptip->_fActivated = FALSE;

        if (psfn)
            psfn->fDeactivatingTIP = TRUE;

        fCoInitCountCkipMode = CtfImmEnterCoInitCountSkipMode();
        ptip->_pTip->Deactivate();
        if (fCoInitCountCkipMode)
            CtfImmLeaveCoInitCountSkipMode();

        if (psfn)
            psfn->fDeactivatingTIP = FALSE;

        hr = S_OK;

        // unhook any display attribute collections for this tip
        CDisplayAttributeMgr::_UnadviseMarkupCollection(ptip->_guidatom);
    }
    return hr;
}

//----------------------------------------------------------------------------
//
// _OnThreadFocus
//
//----------------------------------------------------------------------------

HRESULT CThreadInputMgr::_OnThreadFocus(BOOL fActivate)
{
    int i;
    ITfThreadFocusSink *pUIFocusSink;

    if (_iActivateRefCount == 0)
        return S_OK; // thread has not been Activate'd

    if (_fActiveUI == fActivate)
        return S_OK; // already in a matching state

    _fActiveUI = fActivate;

    if (!fActivate)
    {
        if (_tidForeground != TF_INVALID_GUIDATOM)
        {
            _tidPrevForeground = _tidForeground;
            _tidForeground = TF_INVALID_GUIDATOM;
        }
    }
    else
    {
        if (_tidPrevForeground != TF_INVALID_GUIDATOM)
        {
            _tidForeground = _tidPrevForeground;
            _tidPrevForeground = TF_INVALID_GUIDATOM;
        }
    }

    for (i=0; i<_GetUIFocusSinks()->Count(); i++)
    {
        pUIFocusSink = (ITfThreadFocusSink *)_GetUIFocusSinks()->GetPtr(i)->pSink;
        _try {
            if (fActivate)
            {
                pUIFocusSink->OnSetThreadFocus();
            }
            else
            {
                pUIFocusSink->OnKillThreadFocus();
            }
        }
        _except(1) {
            Assert(0);
        }
    }

    return S_OK;
}

//+---------------------------------------------------------------------------
//
// CreateDocumentMgr
//
//----------------------------------------------------------------------------

STDAPI CThreadInputMgr::CreateDocumentMgr(ITfDocumentMgr **ppdim)
{
    CDocumentInputManager *dim;
    CDocumentInputManager **ppSlot;

    if (ppdim == NULL)
        return E_INVALIDARG;

    *ppdim = NULL;

    dim = new CDocumentInputManager;
    if (dim == NULL)
        return E_OUTOFMEMORY;
   
    ppSlot = _rgdim.Append(1);

    if (ppSlot == NULL)
    {
        dim->Release();
        return E_OUTOFMEMORY;
    }

    *ppSlot = dim;
    *ppdim = dim;

    return S_OK;
}

//+---------------------------------------------------------------------------
//
// _CheckNewActiveView
//
// Returns TRUE if the old and new value don't match, and there is both an old and new value.
//         FALSE otherwise.
//----------------------------------------------------------------------------

BOOL CThreadInputMgr::_CheckNewActiveView(CDocumentInputManager *pdim)
{
    CInputContext *pic;
    TsViewCookie vcActiveViewOld;
    BOOL fActiveViewOld;

    fActiveViewOld = _fActiveView;
    _fActiveView = FALSE;

    if (pdim == NULL)
        return FALSE;

    vcActiveViewOld = _vcActiveView;

    if (pic = pdim->_GetTopIC())
    {
        if (pic->_GetTSI()->GetActiveView(&_vcActiveView) != S_OK)
        {
            Assert(0); // how did GetActiveView fail?
            return FALSE;
        }
    }
    else
    {
        //
        // empty dim so set null active view.
        //
        _vcActiveView = TS_VCOOKIE_NUL;
    }

    _fActiveView = TRUE;

    return (fActiveViewOld && _vcActiveView != vcActiveViewOld);
}

//+---------------------------------------------------------------------------
//
// _SetFocus
//
//----------------------------------------------------------------------------

HRESULT CThreadInputMgr::_SetFocus(CDocumentInputManager *pdim, BOOL fInternal)
{
    int iStack;
    BOOL fDoLayoutNotify;
    BOOL fNewActiveView;
    BOOL fDIMFocusChanged;
    CDocumentInputManager *pPrevFocusDIM;
    SYSTHREAD *psfn = GetSYSTHREAD();
    BOOL fFirstSetFocusAfterActivated;
    BOOL fShutdownInProgress = DllShutdownInProgress();

    fNewActiveView = _CheckNewActiveView(pdim);
    fDoLayoutNotify = FALSE;

    fFirstSetFocusAfterActivated = _fFirstSetFocusAfterActivated;
    _fFirstSetFocusAfterActivated = FALSE;

    _fInternalFocusedDim = fInternal;

    //
    // stop pending focus change.
    //

    if (psfn != NULL )
        psfn->hwndBeingFocused = NULL;

    if (pdim == _pFocusDocInputMgr)
    {
        if (pdim == NULL)
        {
            //
            // we were ready to be acitvated Cicero. But the first setfocus
            // was not Cicero enabled after Activate call....
            //
            // if we or msctfime are in thread detach, we don't
            // have to set assembly back.
            //
            if (psfn && 
                fFirstSetFocusAfterActivated && 
                !psfn->fCUASDllDetachInOtherOrMe)
                SetFocusDIMForAssembly(FALSE);

            return S_OK; // nothing happened (no view change)
        }

        // did the default view change?
        if (!fNewActiveView)
            return S_OK; // nothing happened (no view change)

        fDoLayoutNotify = TRUE;
    }

    pPrevFocusDIM = _pFocusDocInputMgr;;
    _pFocusDocInputMgr = NULL;

    if (pdim != NULL)
    {
#ifdef DEBUG
    {
        BOOL fFound = FALSE;
        int i = 0;
        int nCnt = _rgdim.Count();
        CDocumentInputManager **ppdim = _rgdim.GetPtr(0);
        while (i < nCnt)
        {
            if (*ppdim == pdim)
            {
                fFound = TRUE;
            }
            i++;
            ppdim++;
        }
        if (!fFound)
        {
                Assert(0);
        }
    }
#endif
        _pFocusDocInputMgr = pdim;
        _pFocusDocInputMgr->AddRef();
    }

    if ((!pPrevFocusDIM && _pFocusDocInputMgr) ||
        (pPrevFocusDIM && !_pFocusDocInputMgr))
    {
        fDIMFocusChanged = TRUE;

        //
        // we will call SetFocusDIMForAssembly() and it will makes 
        // ThreadItmChange. So we don't need to handle OnUpdate call.
        //
        if (psfn && psfn->plbim)
            psfn->plbim->StopHandlingOnUpdate();
    }
    else
    {
        fDIMFocusChanged = FALSE;
    }

    //
    // we skip notification in Shutdown
    //
    if (!fShutdownInProgress)
    {
        _MSAA_OnSetFocus(pdim);
        _NotifyCallbacks(TIM_SETFOCUS, pdim, pPrevFocusDIM);
    }

    SafeReleaseClear(pPrevFocusDIM);

    //
    // we skip notification in Shutdown
    //
    if (fShutdownInProgress)
        goto Exit;

    if (fDoLayoutNotify)
    {
        // kick a layout chg notification for the benefit
        // of tips just tracking the active view
        iStack = _pFocusDocInputMgr->_GetCurrentStack();
        if (iStack >= 0)
        {
            _pFocusDocInputMgr->_GetIC(iStack)->OnLayoutChange(TS_LC_CHANGE, _vcActiveView);
        }

    }

    if (fDIMFocusChanged)
    {
        //
        // if we or msctfime are in thread detach, we don't
        // have to set assembly back.
        //
        if (psfn && !psfn->fCUASDllDetachInOtherOrMe)
            SetFocusDIMForAssembly(_pFocusDocInputMgr ? TRUE : FALSE);
    }
    else
    {
        if (psfn && psfn->plbim && psfn->plbim->_GetLBarItemReconv())
            psfn->plbim->_GetLBarItemReconv()->ShowOrHide(TRUE);
    }

    //
    // we now start handling ITfLangBarMge::OnUpdate()
    //
    if (psfn && psfn->plbim)
        psfn->plbim->StartHandlingOnUpdate();

Exit:
    return S_OK;
}

//+---------------------------------------------------------------------------
//
// _GetAssoc
//
//----------------------------------------------------------------------------

CDocumentInputManager *CThreadInputMgr::_GetAssoc(HWND hWnd)
{
    CDocumentInputManager *dim;

    dim = _dimwndMap._Find(hWnd);

    return dim;
}

//+---------------------------------------------------------------------------
//
// _GetAssoced
//
//----------------------------------------------------------------------------

HWND CThreadInputMgr::_GetAssoced(CDocumentInputManager *pdim)
{
    HWND hwnd = NULL;

    if (!pdim)
        return NULL;

    if (_dimwndMap._FindKey(pdim, &hwnd))
        return hwnd;

    return NULL;
}

//+---------------------------------------------------------------------------
//
// _GetGUIDATOMfromITfIME
//
//----------------------------------------------------------------------------

BOOL CThreadInputMgr::_GetGUIDATOMfromITfIME(ITfTextInputProcessor *pTip, TfGuidAtom *pguidatom)
{
    int i;
    int nCnt = _rgTip.Count();

    for (i = 0; i < nCnt; i++)
    {
        CTip *ptip = _rgTip.Get(i);
        if (ptip->_pTip == pTip)
        {
            *pguidatom = ptip->_guidatom;
            return TRUE;
        }
    }

    return FALSE;
}

//+---------------------------------------------------------------------------
//
// _GetITfIMEfromCLSID
//
//----------------------------------------------------------------------------

BOOL CThreadInputMgr::_GetITfIMEfromGUIDATOM(TfGuidAtom guidatom, ITfTextInputProcessor **ppTip)
{
    int i;
    int nCnt = _rgTip.Count();

    for (i = 0; i < nCnt; i++)
    {
        CTip *ptip = _rgTip.Get(i);
        if (ptip->_guidatom == guidatom)
        {
            *ppTip = ptip->_pTip;
            return TRUE;
        }
    }

    return FALSE;
}

//+---------------------------------------------------------------------------
//
// _GetCTipfromCLSID
//
//----------------------------------------------------------------------------

BOOL CThreadInputMgr::_GetCTipfromGUIDATOM(TfGuidAtom guidatom, CTip **pptip)
{
    int i;
    int nCnt = _rgTip.Count();

    for (i = 0; i < nCnt; i++)
    {
        CTip *ptip = _rgTip.Get(i);
        if (ptip->_guidatom == guidatom)
        {
            *pptip = ptip;
            return TRUE;
        }
    }

    return FALSE;
}

//+---------------------------------------------------------------------------
//
// _NotifyCallbacks
//
//----------------------------------------------------------------------------

void CThreadInputMgr::_NotifyCallbacks(TimNotify notify, CDocumentInputManager *dim, void *pv)
{
    int i;

    //
    // #489905
    //
    // we can not call sink anymore after DLL_PROCESS_DETACH.
    //
    if (DllShutdownInProgress())
        return;

    CStructArray<GENERICSINK> *_rgSink = _GetThreadMgrEventSink();

    i = 0;
    while(i < _rgSink->Count())
    {
        int nCnt = _rgSink->Count();
        ITfThreadMgrEventSink *pSink = (ITfThreadMgrEventSink *)_rgSink->GetPtr(i)->pSink;

        switch (notify)
        {
            case TIM_INITDIM:
                pSink->OnInitDocumentMgr(dim);
                break;

            case TIM_UNINITDIM:
                pSink->OnUninitDocumentMgr(dim);
                break;

            case TIM_SETFOCUS:
                pSink->OnSetFocus(dim, (ITfDocumentMgr *)pv);
                break;

            case TIM_INITIC:
                pSink->OnPushContext((ITfContext *)pv);
                break;

            case TIM_UNINITIC:
                pSink->OnPopContext((ITfContext *)pv);
                break;
        }

        if (i >= _rgSink->Count())
            break;

        if (nCnt == _rgSink->Count())
            i++;
    }
}

//+---------------------------------------------------------------------------
//
// UpdateDispAttr
//
//----------------------------------------------------------------------------

void CThreadInputMgr::UpdateDispAttr()
{
    CStructArray<GENERICSINK> *rgDispAttrNotifySinks;
    int i;

    rgDispAttrNotifySinks = _GetDispAttrNotifySinks();

    for (i=0; i<rgDispAttrNotifySinks->Count(); i++)
    {
        ((ITfDisplayAttributeNotifySink *)rgDispAttrNotifySinks->GetPtr(i)->pSink)->OnUpdateInfo();
    }
}

//+---------------------------------------------------------------------------
//
// InitSystemFunctionProvider
//
//----------------------------------------------------------------------------

void CThreadInputMgr::InitSystemFunctionProvider()
{
    if (_pSysFuncPrv)
        return;
    //
    // register system function provider.
    //
    _pSysFuncPrv = new CFunctionProvider();
}

//+---------------------------------------------------------------------------
//
// InitSystemFunctionProvider
//
//----------------------------------------------------------------------------

CFunctionProvider *CThreadInputMgr::GetSystemFunctionProvider() 
{
    InitSystemFunctionProvider();
    if (_pSysFuncPrv)
        _pSysFuncPrv->AddRef();

    return _pSysFuncPrv;
}

//+---------------------------------------------------------------------------
//
// GetFunctionProvider
//
//----------------------------------------------------------------------------

STDAPI CThreadInputMgr::GetFunctionProvider(REFCLSID clsidTIP, ITfFunctionProvider **ppv)
{
    TfGuidAtom guidatom;
    HRESULT hr = TF_E_NOPROVIDER;
    CTip *ctip;

    if (ppv == NULL)
        return E_INVALIDARG;

    *ppv = NULL;

    // 
    // create system function provider, if it is not create yet.
    // 
    if (IsEqualGUID(clsidTIP, GUID_SYSTEM_FUNCTIONPROVIDER))
    {
        *ppv = GetSystemFunctionProvider();
        hr = (*ppv) ? S_OK : E_FAIL;
        goto Exit;
    }
    else if (IsEqualGUID(clsidTIP, GUID_APP_FUNCTIONPROVIDER))
    {
        if (_pAppFuncProvider == NULL)
            goto Exit;

        *ppv = _pAppFuncProvider;
    }
    else
    {
        if (FAILED(MyRegisterGUID(clsidTIP, &guidatom)))
            goto Exit;
        if (!_GetCTipfromGUIDATOM(guidatom, &ctip))
            goto Exit;

        if (ctip->_pFuncProvider == NULL)
            goto Exit;

        *ppv = ctip->_pFuncProvider;
    }

    (*ppv)->AddRef();
    hr = S_OK;

Exit:
    return hr;
}

//+---------------------------------------------------------------------------
//
// EnumFunctionProviders
//
//----------------------------------------------------------------------------

STDAPI CThreadInputMgr::EnumFunctionProviders(IEnumTfFunctionProviders **ppEnum)
{
    CEnumFunctionProviders *pEnum;

    if (!ppEnum)
        return E_INVALIDARG;

    *ppEnum = NULL;
    // 
    // create system function provider, if it is not create yet.
    // 
    InitSystemFunctionProvider();

    pEnum = new CEnumFunctionProviders();
    if (!pEnum)
        return E_OUTOFMEMORY;

    if (!pEnum->_Init(this))
    {
        pEnum->Release();
        return E_FAIL;
    }
    *ppEnum = pEnum;

    return S_OK;
}

//+---------------------------------------------------------------------------
//
// AdviseSink
//
//----------------------------------------------------------------------------

STDAPI CThreadInputMgr::AdviseSink(REFIID refiid, IUnknown *punk, DWORD *pdwCookie)
{
    return GenericAdviseSink(refiid, punk, _c_rgConnectionIIDs, _rgSinks, TIM_NUM_CONNECTIONPTS, pdwCookie);
}

//+---------------------------------------------------------------------------
//
// UnadviseSink
//
//----------------------------------------------------------------------------

STDAPI CThreadInputMgr::UnadviseSink(DWORD dwCookie)
{
    return GenericUnadviseSink(_rgSinks, TIM_NUM_CONNECTIONPTS, dwCookie);
}

//+---------------------------------------------------------------------------
//
// AdviseSingleSink
//
//----------------------------------------------------------------------------

STDAPI CThreadInputMgr::AdviseSingleSink(TfClientId tid, REFIID riid, IUnknown *punk)
{
    CTip *ctip;

    if (punk == NULL)
        return E_INVALIDARG;

    if (tid == g_gaApp)
    {
        if (IsEqualIID(riid, IID_ITfFunctionProvider))
        {
            if (_pAppFuncProvider)
                return CONNECT_E_ADVISELIMIT;

            if (punk->QueryInterface(IID_ITfFunctionProvider, (void **)&_pAppFuncProvider) != S_OK)
                return E_NOINTERFACE;
    
            return S_OK;
        }
    }

    if (!_GetCTipfromGUIDATOM(tid, &ctip))
        return E_INVALIDARG;

    if (IsEqualIID(riid, IID_ITfFunctionProvider))
    {
        if (ctip->_pFuncProvider != NULL)
             return CONNECT_E_ADVISELIMIT;

        if (punk->QueryInterface(IID_ITfFunctionProvider, (void **)&ctip->_pFuncProvider) != S_OK)
            return E_NOINTERFACE;

        return S_OK;
    }
    else if (IsEqualIID(riid, IID_ITfCleanupContextDurationSink))
    {
        if (ctip->_pCleanupDurationSink != NULL)
             return CONNECT_E_ADVISELIMIT;

        if (punk->QueryInterface(IID_ITfCleanupContextDurationSink, (void **)&ctip->_pCleanupDurationSink) != S_OK)
            return E_NOINTERFACE;

        return S_OK;        
    }

    return CONNECT_E_CANNOTCONNECT;
}

//+---------------------------------------------------------------------------
//
// UnadviseSingleSink
//
//----------------------------------------------------------------------------

STDAPI CThreadInputMgr::UnadviseSingleSink(TfClientId tid, REFIID riid)
{
    CTip *ctip;

    if (tid == g_gaApp)
    {
        if (IsEqualIID(riid, IID_ITfFunctionProvider))
        {
            if (_pAppFuncProvider == NULL)
                 return CONNECT_E_NOCONNECTION;

            SafeReleaseClear(_pAppFuncProvider);

            return S_OK;
        }
    }

    if (!_GetCTipfromGUIDATOM(tid, &ctip))
        return E_INVALIDARG;

    if (IsEqualIID(riid, IID_ITfFunctionProvider))
    {
        if (ctip->_pFuncProvider == NULL)
             return CONNECT_E_NOCONNECTION;

        SafeReleaseClear(ctip->_pFuncProvider);

        return S_OK;
    }
    else if (IsEqualIID(riid, IID_ITfCleanupContextDurationSink))
    {
        if (ctip->_pCleanupDurationSink == NULL)
             return CONNECT_E_NOCONNECTION;

        SafeReleaseClear(ctip->_pCleanupDurationSink);

        return S_OK;
    }

    return CONNECT_E_NOCONNECTION;
}

//+---------------------------------------------------------------------------
//
// EnumItems
//
//----------------------------------------------------------------------------

STDAPI CThreadInputMgr::EnumItems(IEnumTfLangBarItems **ppEnum)
{
    if (ppEnum == NULL)
        return E_INVALIDARG;

    *ppEnum = NULL;

    if (_plbim == NULL)
        return E_FAIL;

    return _plbim->EnumItems(ppEnum);
}

//+---------------------------------------------------------------------------
//
// GetItem
//
//----------------------------------------------------------------------------

STDAPI CThreadInputMgr::GetItem(REFGUID rguid, ITfLangBarItem **ppItem)
{
    if (ppItem == NULL)
        return E_INVALIDARG;

    *ppItem = NULL;

    if (_plbim == NULL)
        return E_FAIL;

    return _plbim->GetItem(rguid, ppItem);
}

//+---------------------------------------------------------------------------
//
// AddItem
//
//----------------------------------------------------------------------------

STDAPI CThreadInputMgr::AddItem(ITfLangBarItem *punk)
{
    if (_plbim == NULL)
        return E_FAIL;

    return _plbim->AddItem(punk);
}

//+---------------------------------------------------------------------------
//
// RemoveItem
//
//----------------------------------------------------------------------------

STDAPI CThreadInputMgr::RemoveItem(ITfLangBarItem *punk)
{
    if (_plbim == NULL)
        return E_FAIL;

    return _plbim->RemoveItem(punk);
}

//+---------------------------------------------------------------------------
//
// AdviseItemSink
//
//----------------------------------------------------------------------------

STDAPI CThreadInputMgr::AdviseItemSink(ITfLangBarItemSink *punk, DWORD *pdwCookie, REFGUID rguid)
{
    if (pdwCookie == NULL)
        return E_INVALIDARG;

    *pdwCookie = 0;

    if (_plbim == NULL)
        return E_FAIL;

    return _plbim->AdviseItemSink(punk, pdwCookie, rguid);
}

//+---------------------------------------------------------------------------
//
// UnadviseItemSink
//
//----------------------------------------------------------------------------

STDAPI CThreadInputMgr::UnadviseItemSink(DWORD dwCookie)
{
    if (_plbim == NULL)
        return E_FAIL;

    return _plbim->UnadviseItemSink(dwCookie);
}

//+---------------------------------------------------------------------------
//
// GetItemFloatingRect
//
//----------------------------------------------------------------------------

STDAPI CThreadInputMgr::GetItemFloatingRect(DWORD dwThreadId, REFGUID rguid, RECT *prc)
{
    if (prc == NULL)
        return E_INVALIDARG;

    memset(prc, 0, sizeof(*prc));

    if (_plbim == NULL)
        return E_FAIL;

    return _plbim->GetItemFloatingRect(dwThreadId, rguid, prc);
}

//+---------------------------------------------------------------------------
//
// GetItemsStatus
//
//----------------------------------------------------------------------------

STDAPI CThreadInputMgr::GetItemsStatus(ULONG ulCount, const GUID *prgguid, DWORD *pdwStatus)
{
    if (_plbim == NULL)
        return E_FAIL;

    return _plbim->GetItemsStatus(ulCount, prgguid, pdwStatus);
}

//+---------------------------------------------------------------------------
//
// GetItemNum
//
//----------------------------------------------------------------------------

STDAPI CThreadInputMgr::GetItemNum(ULONG *pulCount)
{
    if (pulCount == NULL)
        return E_INVALIDARG;

    *pulCount = 0;

    if (_plbim == NULL)
        return E_FAIL;

    return _plbim->GetItemNum(pulCount);
}

//+---------------------------------------------------------------------------
//
// GetItems
//
//----------------------------------------------------------------------------

STDAPI CThreadInputMgr::GetItems(ULONG ulCount,  ITfLangBarItem **ppItem,  TF_LANGBARITEMINFO *pInfo, DWORD *pdwStatus, ULONG *pcFetched)
{
    if (_plbim == NULL)
        return E_FAIL;

    return _plbim->GetItems(ulCount, ppItem,  pInfo, pdwStatus, pcFetched);
}

//+---------------------------------------------------------------------------
//
// AdviseItemsSink
//
//----------------------------------------------------------------------------

STDMETHODIMP CThreadInputMgr::AdviseItemsSink(ULONG ulCount, ITfLangBarItemSink **ppunk,  const GUID *pguidItem, DWORD *pdwCookie)
{
    if (_plbim == NULL)
        return E_FAIL;

    return _plbim->AdviseItemsSink(ulCount, ppunk, pguidItem, pdwCookie);
}

//+---------------------------------------------------------------------------
//
// UnadviseItemsSink
//
//----------------------------------------------------------------------------

STDMETHODIMP CThreadInputMgr::UnadviseItemsSink(ULONG ulCount, DWORD *pdwCookie)
{
    if (_plbim == NULL)
        return E_FAIL;

    return _plbim->UnadviseItemsSink(ulCount, pdwCookie);
}

//+---------------------------------------------------------------------------
//
// EnumDocumentInputMgrs
//
//----------------------------------------------------------------------------

STDAPI CThreadInputMgr::EnumDocumentMgrs(IEnumTfDocumentMgrs **ppEnum)
{
    CEnumDocumentInputMgrs *pEnum;

    if (!ppEnum)
        return E_INVALIDARG;

    if ((pEnum = new CEnumDocumentInputMgrs()) == NULL)
        return E_OUTOFMEMORY;

    if (!pEnum->_Init(this))
    {
        pEnum->Release();
        return E_FAIL;
    }

    *ppEnum = pEnum;

    return S_OK;
}

//+---------------------------------------------------------------------------
//
// GetFocus
//
//----------------------------------------------------------------------------

STDAPI CThreadInputMgr::GetFocus(ITfDocumentMgr **ppdimFocus)
{
    if (ppdimFocus == NULL)
        return E_INVALIDARG;

    *ppdimFocus = _pFocusDocInputMgr;

    if (*ppdimFocus)
    {
        (*ppdimFocus)->AddRef();
        return S_OK;
    }

    return S_FALSE;
}

//+---------------------------------------------------------------------------
//
// SetFocus
//
//----------------------------------------------------------------------------

STDAPI CThreadInputMgr::SetFocus(ITfDocumentMgr *pdimFocus)
{
    CDocumentInputManager *dim = NULL;
    HRESULT hr;
               
    if (pdimFocus && (dim = GetCDocumentInputMgr(pdimFocus)) == NULL)
        return E_INVALIDARG;

    // pdimFocus may be NULL, which means clear the focus
    // (_tim->_SetFocus will check for this)
    hr = _SetFocus(dim, FALSE);

    SafeRelease(dim);

    //
    // #602692
    //
    // The richedit calls SetFocus(dim) when it gets WM_SETFOCUS.
    // But user32!SetFocus() of this WM_SETFOCUS could be made by 
    // AcitivateWindow() of another user32!SetFocus() call.
    // If this happens, CBTHook() has been called and we won't get
    // another notification when pq->hwndFocus is changed.
    // 
    // So we can not call OnForegroundChanges() right now and need to wait
    // until pq->hwndFocus() set. So we can trust user32!GetFocus().
    //
    PostThreadMessage(GetCurrentThreadId(), 
        g_msgPrivate, 
        TFPRIV_ONSETWINDOWFOCUS,  
        (LPARAM)-2);

    return hr;
}

//+---------------------------------------------------------------------------
//
// AssociateFocus
//
//----------------------------------------------------------------------------

STDAPI CThreadInputMgr::AssociateFocus(HWND hwnd, ITfDocumentMgr *pdimNew, ITfDocumentMgr **ppdimPrev)
{
    CDocumentInputManager *dim;
    CDocumentInputManager *dimNew;
    SYSTHREAD *psfn;

    if (ppdimPrev == NULL)
        return E_INVALIDARG;

    *ppdimPrev = NULL;

    if (!IsWindow(hwnd))
        return E_INVALIDARG;

    if (pdimNew == NULL)
    {
        dimNew = NULL;
    }
    else if ((dimNew = GetCDocumentInputMgr(pdimNew)) == NULL)
        return E_INVALIDARG;

    // get the old association and remove it from our list
    dim = _GetAssoc(hwnd);

    if (dim != NULL)
    {
        _dimwndMap._Remove(hwnd);
    }

    *ppdimPrev = dim;
    if (*ppdimPrev)
       (*ppdimPrev)->AddRef();

    // setup the new assoc
    // nb: we don't AddRef the dim, since we assume caller will clear before releasing it
    if (dimNew != NULL)
    {
        _dimwndMap._Set(hwnd, dimNew);
    }

    //
    // if some window is being focused, we will have another _SetFocus().
    // Then we don't have to call _SetFocus() now.
    //
    psfn = GetSYSTHREAD();
    if (psfn && !psfn->hwndBeingFocused && (hwnd == ::GetFocus()))
        _SetFocus(dimNew, TRUE);

    SafeRelease(dimNew);

    return S_OK;
}

//+---------------------------------------------------------------------------
//
// IsThreadFocus
//
//----------------------------------------------------------------------------

STDAPI CThreadInputMgr::IsThreadFocus(BOOL *pfUIFocus)
{
    if (pfUIFocus == NULL)
        return E_INVALIDARG;

    *pfUIFocus = _fActiveUI;

    return S_OK;
}

//+---------------------------------------------------------------------------
//
// GetAssociated
//
//----------------------------------------------------------------------------

STDAPI CThreadInputMgr::GetAssociated(HWND hWnd, ITfDocumentMgr **ppdim)
{
    //
    // we may need to have a more complex logic here.
    // Some application does not call AssociateFocus and it may
    // handle the dim focus by it self. The we need to walk all TSI and 
    // find the window is associated to an IC.
    //
    *ppdim = _GetAssoc(hWnd);
    if (*ppdim)
        (*ppdim)->AddRef();
    return S_OK;
}

//+---------------------------------------------------------------------------
//
// SetSysHookSink
//
//----------------------------------------------------------------------------

STDAPI CThreadInputMgr::SetSysHookSink(ITfSysHookSink *pSink)
{    
    // nb: this is a private, internal interface method
    // so we break COM rules and DON'T AddRef pSink (to avoid a circular ref)
    // we'll get a call later with pSink == NULL to clear it out
    // the pointer is contained in the life of the aimm layer tip,
    // which is responsible for NULLing it out before unloading
    _pSysHookSink = pSink;

    return S_OK;
}

//+---------------------------------------------------------------------------
//
// RequestPostponedLock
//
//----------------------------------------------------------------------------

STDAPI CThreadInputMgr::RequestPostponedLock(ITfContext *pic)
{    
    HRESULT hr = E_FAIL;
    CInputContext *pcic = GetCInputContext(pic);
    if (!pcic)
        goto Exit;

    if (pcic->_fLockHeld)
        pcic->_EmptyLockQueue(pcic->_dwlt, FALSE);
    else
    {
        SYSTHREAD *psfn;
        if (psfn = GetSYSTHREAD())
        {
            CInputContext::_PostponeLockRequestCallback(psfn, pcic);
        }
    }
    hr = S_OK;

Exit:
    SafeRelease(pcic);
    return hr;
}

//+---------------------------------------------------------------------------
//
// GetGlobalCompartment
//
//----------------------------------------------------------------------------

STDAPI CThreadInputMgr::GetGlobalCompartment(ITfCompartmentMgr **ppCompMgr)
{
    return TF_GetGlobalCompartment(ppCompMgr);
}

//+---------------------------------------------------------------------------
//
// GetClientId
//
//----------------------------------------------------------------------------

STDAPI CThreadInputMgr::GetClientId(REFCLSID rclsid, TfClientId *ptid)
{
    TfGuidAtom guidatom;
    if (!ptid)
        return E_INVALIDARG;

    *ptid = TF_INVALID_GUIDATOM;

    if (FAILED(MyRegisterGUID(rclsid, &guidatom)))
        return E_FAIL;

    *ptid = guidatom;
    return S_OK;
}

//+---------------------------------------------------------------------------
//
// CallImm32Hotkeyhandler
//
//----------------------------------------------------------------------------

STDAPI CThreadInputMgr::CallImm32HotkeyHanlder(WPARAM wParam, LPARAM lParam, BOOL *pbHandled)
{
    if (!pbHandled)
        return E_INVALIDARG;

    *pbHandled = CheckImm32HotKey(wParam, lParam);

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\ctf\uim\spans.cpp ===
//
// spans.cpp
//
// CSpanSet
//

#include "private.h"
#include "spans.h"
#include "immxutil.h"

DBG_ID_INSTANCE(CSpanSet);

//+---------------------------------------------------------------------------
//
// _InsertNewSpan
//
//----------------------------------------------------------------------------

SPAN *CSpanSet::_InsertNewSpan(int iIndex)
{
    if (!_rgSpans.Insert(iIndex, 1))
        return NULL;

    return _rgSpans.GetPtr(iIndex);
}

//+---------------------------------------------------------------------------
//
// Add
//
//----------------------------------------------------------------------------

void CSpanSet::Add(DWORD dwFlags, IAnchor *paStart, IAnchor *paEnd, AnchorOwnership ao)
{
    int iStart;
    int iEnd;
    SPAN *psStart;
    SPAN *psEnd;
    IAnchor *paLowerBound;
    IAnchor *paUpperBound;
    IAnchor *paClone;
    BOOL fReleaseStart;
    BOOL fReleaseEnd;

    fReleaseStart = fReleaseEnd = (ao == OWN_ANCHORS);

    if (_AllSpansCovered())
    {
        // if we already cover the entire doc, nothing to do
        goto ExitRelease;
    }

    if (paStart == NULL)
    {        
        Assert(paEnd == NULL);

        // NULL, NULL means "the whole doc"
        // so this new span automatically eats all pre-existing ones

        dwFlags = 0; // don't accept corrections for the entire doc
        iStart = 0;
        iEnd = _rgSpans.Count();

        if (iEnd == 0)
        {
            if ((psStart = _InsertNewSpan(0)) == NULL)
                return; // out-of-memory!

            memset(psStart, 0, sizeof(*psStart));
        }
        else
        {
            // need to free the anchors in the first span
            psStart = _rgSpans.GetPtr(0);
            SafeReleaseClear(psStart->paStart);
            SafeReleaseClear(psStart->paEnd);
            psStart->dwFlags = 0;
        }

        goto Exit;
    }

    Assert(CompareAnchors(paStart, paEnd) <= 0);

    psStart = _Find(paStart, &iStart);
    psEnd = _Find(paEnd, &iEnd);

    if (iStart == iEnd)
    {
        if (psStart == NULL)
        {
            // this span doesn't overlap with anything else
            iStart++;

            if ((psStart = _InsertNewSpan(iStart)) == NULL)
                goto ExitRelease; // out-of-memory!

            if (ao == OWN_ANCHORS)
            {
                psStart->paStart = paStart;
                fReleaseStart = FALSE;
                psStart->paEnd = paEnd;
                fReleaseEnd = FALSE;
            }
            else
            {
                if (paStart->Clone(&psStart->paStart) != S_OK)
                {
                    _rgSpans.Remove(iStart, 1);
                    goto ExitRelease;
                }
                if (paEnd->Clone(&psStart->paEnd) != S_OK)
                {
                    psStart->paStart->Release();
                    _rgSpans.Remove(iStart, 1);
                    goto ExitRelease;
                }
            }
            psStart->dwFlags = dwFlags;
        }
        else if (psEnd != NULL)
        {
            Assert(psStart == psEnd);
            // the new span is a subset of an existing span
            psStart->dwFlags &= dwFlags;
        }
        else
        {
            // this spans overlaps with an existing one, but extends further to the right
            // just swap out the end anchor, since we know (iStart == iEnd) that we only
            // cover just this one span
            if (ao == OWN_ANCHORS)
            {
                psStart->paEnd->Release();
                psStart->paEnd = paEnd;
                fReleaseEnd = FALSE;
            }
            else
            {
                if (paEnd->Clone(&paClone) != S_OK || paClone == NULL)
                    goto ExitRelease;
                psStart->paEnd->Release();
                psStart->paEnd = paClone;
            }
        }

        goto ExitRelease;
    }    

    // delete all but one of the covered spans
    if (psStart == NULL)
    {
        iStart++;
        psStart = _rgSpans.GetPtr(iStart);
        Assert(psStart != NULL);

        if (ao == OWN_ANCHORS)
        {
            paLowerBound = paStart;
            fReleaseStart = FALSE;
        }
        else
        {
            if (FAILED(paStart->Clone(&paLowerBound)))
                goto ExitRelease;
        }
    }
    else
    {
        paLowerBound = psStart->paStart;
        paLowerBound->AddRef();
    }
    if (psEnd == NULL)
    {
        if (ao == OWN_ANCHORS)
        {
            paUpperBound = paEnd;
            fReleaseEnd = FALSE;
        }
        else
        {
            if (FAILED(paEnd->Clone(&paUpperBound)))
                goto ExitRelease;
        }
    }
    else
    {
        paUpperBound = psEnd->paEnd;
        paUpperBound->AddRef();
    }

    // psStart grows to cover the entire span
    psStart->paStart->Release();
    psStart->paEnd->Release();
    psStart->paStart = paLowerBound;
    psStart->paEnd = paUpperBound;

Exit:
    // then delete the covered spans
    for (int i=iStart + 1; i <= iEnd; i++)
    {
        SPAN *ps = _rgSpans.GetPtr(i);
        dwFlags &= ps->dwFlags;
        ps->paStart->Release();
        ps->paEnd->Release();
    }

    psStart->dwFlags &= dwFlags; // only set correction bit if all spans were corrections

    //Remove all spans we just cleared out
    if (iEnd - iStart > 0)
    {
        _rgSpans.Remove(iStart+1, iEnd - iStart);
    }

ExitRelease:
    if (fReleaseStart)
    {
        SafeRelease(paStart);
    }
    if (fReleaseEnd)
    {
        SafeRelease(paEnd);
    }
}

//+---------------------------------------------------------------------------
//
// _Find
//
//----------------------------------------------------------------------------

SPAN *CSpanSet::_Find(IAnchor *pa, int *piOut)
{
    SPAN *ps;
    SPAN *psMatch;
    int iMin;
    int iMax;
    int iMid;

    psMatch = NULL;
    iMid = -1;
    iMin = 0;
    iMax = _rgSpans.Count();

    while (iMin < iMax)
    {
        iMid = (iMin + iMax) / 2;
        ps = _rgSpans.GetPtr(iMid);
        Assert(ps != NULL);

        if (CompareAnchors(pa, ps->paStart) < 0)
        {
            iMax = iMid;
        }
        else if (CompareAnchors(pa, ps->paEnd) > 0)
        {
            iMin = iMid + 1;
        }
        else // anchor is in the span
        {
            psMatch = ps;
            break;
        }
    }

    if (piOut != NULL)
    {
        if (psMatch == NULL && iMid >= 0)
        {
            // couldn't find a match, return the next lowest span
            Assert(iMid == 0 || CompareAnchors(_rgSpans.GetPtr(iMid-1)->paEnd, pa) < 0);
            if (CompareAnchors(_rgSpans.GetPtr(iMid)->paStart, pa) > 0)
            {
                iMid--;
            }
        }
        *piOut = iMid;
    }

    return psMatch;
}

//+---------------------------------------------------------------------------
//
// AnchorsAway
//
// Note we don't zero-out the IAnchors pointers!  Be careful.
//----------------------------------------------------------------------------

void CSpanSet::_AnchorsAway()
{ 
    SPAN *span;
    int i;

    for (i=0; i<_rgSpans.Count(); i++)
    {
        span = _rgSpans.GetPtr(i);
        SafeRelease(span->paStart);
        SafeRelease(span->paEnd);
    }
}

//+---------------------------------------------------------------------------
//
// Normalize
//
// Replaces (NULL, NULL) spans with actual anchor values for start, end of doc
//----------------------------------------------------------------------------

BOOL CSpanSet::Normalize(ITextStoreAnchor *ptsi)
{
    SPAN *span;

    if (!_AllSpansCovered())
        return TRUE;

    // if we get here, we have a single span with NULL/NULL anchors
    span = _rgSpans.GetPtr(0);

    if (ptsi->GetStart(&span->paStart) != S_OK || span->paStart == NULL)
        return FALSE;

    // Issue: need a GetEnd wrapper that handle unimplemented case! DON'T USE GetEnd!
    if (ptsi->GetEnd(&span->paEnd) != S_OK || span->paEnd == NULL)
    {
        SafeReleaseClear(span->paStart);
        return FALSE;
    }

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\ctf\uim\tim.h ===
//
// tim.h
//
// CThreadInputMgr
//


#ifndef TIM_H
#define TIM_H

#include "private.h"
#include "globals.h"
#include "ptrmap.h"
#include "ptrary.h"
#include "nuimgr.h"
#include "utb.h"
#include "compart.h"
#include "msctfp.h"
#include "dim.h"
#include "ic.h"

extern void ExecuteLoader(void);

#define TIM_NUM_CONNECTIONPTS    6
// these are indices into _rgSinks, must match _c_rgConnectionIIDs
#define TIM_SINK_ITfDisplayAttributeNotifySink       0
#define TIM_SINK_ITfActiveLanguageProfileNotifySink  1
#define TIM_SINK_ITfUIFocusSink                      2
#define TIM_SINK_ITfPreservedKeyNotifySink           3
#define TIM_SINK_ITfThreadMgrEventSink               4
#define TIM_SINK_ITfKeyTraceEventSink                5

//
// for _AsyncKeyHandler()
//
#define TIM_AKH_SYNC             0x0001
#define TIM_AKH_TESTONLY         0x0002
#define TIM_AKH_SIMULATEKEYMSGS  0x0004

class CHotKey;

// callback for CThreadMgr::_CleanupContexts
typedef void (*POSTCLEANUPCALLBACK)(BOOL fAbort, LONG_PTR lPrivate);

//////////////////////////////////////////////////////////////////////////////
//
// CTip
//
//////////////////////////////////////////////////////////////////////////////

class CTip 
{
public:
    CTip() {};
    ~CTip() 
    {
        Assert(!_rgHotKey.Count());
    };

    void CleanUp()
    {
        Assert(!_pKeyEventSink);
        Assert(!_pFuncProvider);

        if (_hInstSubstituteHKL)
        {
            FreeLibrary(_hInstSubstituteHKL);
            _hInstSubstituteHKL = NULL;
        }

        SafeReleaseClear(_pKeyEventSink);
        SafeReleaseClear(_pFuncProvider);
        SafeReleaseClear(_pTip);
    }

    ITfTextInputProcessor *_pTip;
    TfGuidAtom _guidatom;
    ITfKeyEventSink *_pKeyEventSink;
    ITfFunctionProvider *_pFuncProvider;
    ITfCleanupContextDurationSink *_pCleanupDurationSink;

    BOOL _fForegroundKeyEventSink : 1;
    BOOL _fActivated : 1;
    BOOL _fNeedCleanupCall : 1;

    CPtrArray<CHotKey> _rgHotKey;

    HMODULE _hInstSubstituteHKL;
};

typedef struct _CLEANUPCONTEXT
{
    BOOL fSync;
    const GUID *pCatId;
    LANGID langid;
    POSTCLEANUPCALLBACK pfnPostCleanup;
    LONG_PTR lPrivate;
} CLEANUPCONTEXT;

typedef enum { TIM_INITDIM, TIM_UNINITDIM, TIM_SETFOCUS, TIM_INITIC, TIM_UNINITIC } TimNotify;
typedef enum { TSH_SYSHOTKEY, TSH_NONSYSHOTKEY, TSH_DONTCARE} TimSysHotkey;
typedef enum { KS_DOWN, KS_DOWN_TEST, KS_UP, KS_UP_TEST } KSEnum;

class CDocumentInputManager;
class CInputContext;
class CTIPRegister;
class CACPWrap;
class CFunctionProvider;

//////////////////////////////////////////////////////////////////////////////
//
// CThreadInputMgr
//
//////////////////////////////////////////////////////////////////////////////

class CThreadInputMgr : public ITfThreadMgr_P,
                        public ITfKeystrokeMgr_P,
                        public ITfLangBarItemMgr,
                        public ITfSource,
                        public ITfSourceSingle,
                        public ITfMessagePump,
                        public ITfConfigureSystemKeystrokeFeed,
                        public ITfClientId,
                        public CCompartmentMgr,
                        public CComObjectRoot_CreateSingletonInstance_Verify<CThreadInputMgr>
{
public:
    CThreadInputMgr();
    ~CThreadInputMgr();

    BEGIN_COM_MAP_IMMX(CThreadInputMgr)
        COM_INTERFACE_ENTRY(ITfThreadMgr)
        COM_INTERFACE_ENTRY(ITfThreadMgr_P_old)
        COM_INTERFACE_ENTRY(ITfThreadMgr_P)
        COM_INTERFACE_ENTRY(ITfSource)
        COM_INTERFACE_ENTRY(ITfSourceSingle)
        COM_INTERFACE_ENTRY(ITfCompartmentMgr)
        COM_INTERFACE_ENTRY(ITfKeystrokeMgr)
        COM_INTERFACE_ENTRY(ITfKeystrokeMgr_P)
        COM_INTERFACE_ENTRY(ITfLangBarItemMgr)
        COM_INTERFACE_ENTRY(ITfMessagePump)
        COM_INTERFACE_ENTRY(ITfConfigureSystemKeystrokeFeed)
        COM_INTERFACE_ENTRY(ITfClientId)
    END_COM_MAP_IMMX()

    static BOOL VerifyCreateInstance(IUnknown *pUnkOuter, REFIID riid, void **ppvObj);
    static void PostCreateInstance(REFIID riid, void *pvObj) {}

    // ITfThreadMgr
    STDMETHODIMP Activate(TfClientId *ptid);
    STDMETHODIMP Deactivate();
    STDMETHODIMP CreateDocumentMgr(ITfDocumentMgr **ppdim);
    STDMETHODIMP EnumDocumentMgrs(IEnumTfDocumentMgrs **ppEnum);
    STDMETHODIMP GetFocus(ITfDocumentMgr **ppdimFocus);
    STDMETHODIMP SetFocus(ITfDocumentMgr *pdimFocus);
    STDMETHODIMP AssociateFocus(HWND hwnd, ITfDocumentMgr *pdimNew, ITfDocumentMgr **ppdimPrev);
    STDMETHODIMP IsThreadFocus(BOOL *pfUIFocus);
    STDMETHODIMP GetFunctionProvider(REFGUID guidPrvdr, ITfFunctionProvider **ppv);
    STDMETHODIMP EnumFunctionProviders(IEnumTfFunctionProviders **ppEnum);

    // ITfSource
    STDMETHODIMP AdviseSink(REFIID refiid, IUnknown *punk, DWORD *pdwCookie);
    STDMETHODIMP UnadviseSink(DWORD dwCookie);
    // ITfSourceSingle
    STDMETHODIMP AdviseSingleSink(TfClientId tid, REFIID riid, IUnknown *punk);
    STDMETHODIMP UnadviseSingleSink(TfClientId tid, REFIID riid);

    STDMETHODIMP GetGlobalCompartment(ITfCompartmentMgr **pCompMgr);

    // ITfThreadMgr_P
    STDMETHODIMP GetAssociated(HWND hWnd, ITfDocumentMgr **ppdim);
    STDMETHODIMP SetSysHookSink(ITfSysHookSink *pSink);
    STDMETHODIMP RequestPostponedLock(ITfContext *pic);
    STDMETHODIMP IsKeystrokeFeedEnabled(BOOL *pfEnabled);
    STDMETHODIMP CallImm32HotkeyHanlder(WPARAM wParam, LPARAM lParam, BOOL *pbHandled);
    STDMETHODIMP ActivateEx(TfClientId *ptid, DWORD dwFlags);

    //
    // ITfKeystrokeManager
    //
    STDMETHODIMP GetForeground(CLSID *pclsid);
    STDMETHODIMP AdviseKeyEventSink(TfClientId tid, ITfKeyEventSink *pSink, BOOL fForeground);
    STDMETHODIMP UnadviseKeyEventSink(TfClientId tid);
    STDMETHODIMP TestKeyDown(WPARAM wParam, LPARAM lParam, BOOL *pfEaten);
    STDMETHODIMP TestKeyUp(WPARAM wParam, LPARAM lParam, BOOL *pfEaten);
    STDMETHODIMP KeyDown(WPARAM wParam, LPARAM lParam, BOOL *pfEaten);
    STDMETHODIMP KeyUp(WPARAM wParam, LPARAM lParam, BOOL *pfEaten);
    STDMETHODIMP GetPreservedKey(ITfContext *pic, const TF_PRESERVEDKEY *pprekey, GUID *pguid);
    STDMETHODIMP IsPreservedKey(REFGUID rguid, const TF_PRESERVEDKEY *pprekey, BOOL *pfRegistered);
    STDMETHODIMP PreserveKey(TfClientId tid, REFGUID rguid, const TF_PRESERVEDKEY *prekey, const WCHAR *pchDesc, ULONG cchDesc);
    STDMETHODIMP UnpreserveKey(REFGUID rguid, const TF_PRESERVEDKEY *pprekey);
    STDMETHODIMP SetPreservedKeyDescription(REFGUID rguid, const WCHAR *pchDesc, ULONG cchDesc);
    STDMETHODIMP GetPreservedKeyDescription(REFGUID rguid, BSTR *pbstrDesc);
    STDMETHODIMP SimulatePreservedKey(ITfContext *pic, REFGUID rguid, BOOL *pfEaten);
    STDMETHODIMP KeyDownUpEx(WPARAM wParam, LPARAM lParam, DWORD dwFlags, BOOL *pfEaten);

    //
    // ITfKeystrokeManager_P
    //
    STDMETHODIMP PreserveKeyEx(TfClientId tid, REFGUID rguid, const TF_PRESERVEDKEY *prekey, const WCHAR *pchDesc, ULONG cchDesc, DWORD dwFlags);

    // ITfConfigureSystemKeystrokeFeed
    STDMETHODIMP DisableSystemKeystrokeFeed();
    STDMETHODIMP EnableSystemKeystrokeFeed();

    //
    // ITfLangBarItemMgr
    //
    STDMETHODIMP EnumItems(IEnumTfLangBarItems **ppEnum);
    STDMETHODIMP GetItem(REFGUID rguid, ITfLangBarItem **ppItem);
    STDMETHODIMP AddItem(ITfLangBarItem *punk);
    STDMETHODIMP RemoveItem(ITfLangBarItem *punk);
    STDMETHODIMP AdviseItemSink(ITfLangBarItemSink *punk, DWORD *pdwCookie, REFGUID rguid);
    STDMETHODIMP UnadviseItemSink(DWORD dwCookie);
    STDMETHODIMP GetItemFloatingRect(DWORD dwThreadId, REFGUID rguid, RECT *prc);
    STDMETHODIMP GetItemsStatus(ULONG ulCount, const GUID *prgguid, DWORD *pdwStatus);
    STDMETHODIMP GetItemNum(ULONG *pulCount);

    STDMETHODIMP GetItems(ULONG ulCount,  ITfLangBarItem **ppItem,  TF_LANGBARITEMINFO *pInfo, DWORD *pdwStatus, ULONG *pcFetched);
    STDMETHODIMP AdviseItemsSink(ULONG ulCount, ITfLangBarItemSink **ppunk,  const GUID *pguidItem, DWORD *pdwCookie);
    STDMETHODIMP UnadviseItemsSink(ULONG ulCount, DWORD *pdwCookie);

    //
    // ITfMessagePump
    //
    STDMETHODIMP PeekMessageA(LPMSG pMsg, HWND hwnd, UINT wMsgFilterMin, UINT wMsgFilterMax, UINT wRemoveMsg, BOOL *pfResult);
    STDMETHODIMP GetMessageA(LPMSG pMsg, HWND hwnd, UINT wMsgFilterMin, UINT wMsgFilterMax, BOOL *pfResult);
    STDMETHODIMP PeekMessageW(LPMSG pMsg, HWND hwnd, UINT wMsgFilterMin, UINT wMsgFilterMax, UINT wRemoveMsg, BOOL *pfResult);
    STDMETHODIMP GetMessageW(LPMSG pMsg, HWND hwnd, UINT wMsgFilterMin, UINT wMsgFilterMax, BOOL *pfResult);

    //
    // ITfClientId
    //
    STDMETHODIMP GetClientId(REFCLSID rclsid, TfClientId *ptid);

    HRESULT ActivateInputProcessor(REFCLSID clsid, REFGUID guidProfile, HKL hklSubstitute, BOOL fActivate);
    HRESULT NotifyActivateInputProcessor(REFCLSID clsid, REFGUID guidProfile, BOOL fActivate);

    HRESULT _SetForeground(TfClientId tid);
    BOOL _ProcessHotKey(WPARAM wParam, LPARAM lParam, TimSysHotkey tsh, BOOL fTest, BOOL fSync);
    BOOL _SyncProcessHotKey(WPARAM wParam, LPARAM lParam, TimSysHotkey tsh, BOOL fTest);

    // use this to grab the single CThreadInputMgr for the calling thread
    static CThreadInputMgr *_GetThis() 
    { 
        SYSTHREAD *psfn = GetSYSTHREAD();
        if (!psfn)
            return NULL;
        return psfn->ptim;
    }

    static CThreadInputMgr *_GetThisFromSYSTHREAD(SYSTHREAD *psfn) 
    { 
        Assert(psfn);
        return psfn->ptim;
    }

    ITfTextInputProcessor *_tidToTIP(TfClientId tid)
    {
        ITfTextInputProcessor *tip;

        _GetITfIMEfromGUIDATOM(tid, &tip);

        return tip;
    }

    TfClientId _TIPToTid(ITfTextInputProcessor *tip)
    {
        TfClientId tid;

        _GetGUIDATOMfromITfIME(tip, &tid);

        return tid;
    }

    void _SetProcessAtom();

    HRESULT _OnThreadFocus(BOOL fActivate);
    void _GetSubstituteIMEModule(CTip *ptip, HKL hklSubstitute);
    HRESULT _ActivateTip(REFCLSID clsid, HKL hklSubstitute, CTip **pptip);
    HRESULT _DeactivateTip(CTip *ptip);

    HRESULT _SetFocus(CDocumentInputManager *pdim, BOOL fInternal);

    CDocumentInputManager *_GetAssoc(HWND hWnd);
    HWND _GetAssoced(CDocumentInputManager *pdim);
    BOOL _GetGUIDATOMfromITfIME(ITfTextInputProcessor *pIME, TfGuidAtom *pguidatom);
    BOOL _GetITfIMEfromGUIDATOM(TfGuidAtom guidatom, ITfTextInputProcessor **ppIME);
    BOOL _GetCTipfromGUIDATOM(TfGuidAtom guidatom, CTip **pptip);

    UINT _GetTIPCount() { return _rgTip.Count(); }
    const CTip *_GetCTip(UINT i) { return _rgTip.Get(i); }

    CDocumentInputManager *_GetFocusDocInputMgr() { return _pFocusDocInputMgr; }
    BOOL _IsInternalFocusedDim() { return _fInternalFocusedDim; }
    BOOL _IsNoFirstSetFocusAfterActivated() {return _fFirstSetFocusAfterActivated;}

    void _NotifyCallbacks(TimNotify notify, CDocumentInputManager *dim, void *pv);


    void UpdateDispAttr();

    CPtrArray<CDocumentInputManager> _rgdim;

    void InitSystemFunctionProvider();
    CFunctionProvider *GetSystemFunctionProvider();

    CStructArray<GENERICSINK> *_GetThreadMgrEventSink() { return &_rgSinks[TIM_SINK_ITfThreadMgrEventSink]; }
    CStructArray<GENERICSINK> *_GetActiveTIPNotifySinks() { return &_rgSinks[TIM_SINK_ITfActiveLanguageProfileNotifySink]; }
    CStructArray<GENERICSINK> *_GetDispAttrNotifySinks() { return &_rgSinks[TIM_SINK_ITfDisplayAttributeNotifySink]; }
    CStructArray<GENERICSINK> *_GetUIFocusSinks() { return &_rgSinks[TIM_SINK_ITfUIFocusSink]; }
    CStructArray<GENERICSINK> *_GetPreservedKeyNotifySinks() { return &_rgSinks[TIM_SINK_ITfPreservedKeyNotifySink]; }
    CStructArray<GENERICSINK> *_GetKeyTraceEventSinks() { return &_rgSinks[TIM_SINK_ITfKeyTraceEventSink]; }

    HRESULT _GetActiveInputProcessors(ULONG ulCount, CLSID *pclsid, ULONG *pulCount);
    HRESULT _IsActiveInputProcessor(REFCLSID clsid);
    HRESULT _IsActiveInputProcessorByATOM(TfGuidAtom guidatom);

    BOOL _AppWantsKeystrokes()
    { 
        Assert(_cAppWantsKeystrokesRef >= 0);
        return _cAppWantsKeystrokesRef > 0;
    }
    BOOL _IsKeystrokeFeedEnabled()
    {
        Assert(_cDisableSystemKeystrokeFeedRef >= 0);
        return (_cDisableSystemKeystrokeFeedRef == 0);
    }

    BOOL _AsyncKeyHandler(WPARAM wParam, LPARAM lParam, DWORD dwFlags, BOOL *pfEaten);

    BOOL _IsMSAAEnabled() { return _pAAAdaptor != NULL; }
    IAccServerDocMgr *_GetAAAdaptor() { return _pAAAdaptor; }
    CPtrMap<HWND, CDocumentInputManager> *GetDimWndMap() {return &_dimwndMap;}

    
    CGlobalCompartmentMgr *GetGlobalComp(void)
    {
        SYSTHREAD *psfn = GetSYSTHREAD();
        return psfn->_pGlobalCompMgr;
    }

    void _CleanupContexts(CLEANUPCONTEXT *pcc);
    void _HandlePendingCleanupContext();
    void _NotifyKeyTraceEventSink(WPARAM wParam, LPARAM lParam);

    ITfSysHookSink *GetSysHookSink() {return _pSysHookSink;}
    TfClientId GetForegroundKeyboardTip() {return _tidForeground;}

    HRESULT _KeyStroke(KSEnum ksenum, WPARAM wParam, LPARAM lParam, BOOL *pfEaten, BOOL fSync, DWORD dwFlags);

    void _SendEndCleanupNotifications();

    BOOL _IsValidTfClientId(TfClientId tid)
    {
        CTip *ctip;
        return (tid == g_gaApp) || (tid == g_gaSystem) || _GetCTipfromGUIDATOM(tid, &ctip);
    }

    void _InitMSAA();
    void _UninitMSAA();

    void ClearLangBarItemMgr()
    {
        _plbim = NULL;
    }

private:

    void _CleanupContextsWorker(CLEANUPCONTEXT *pcc);
    
    void _CalcAndSendBeginCleanupNotifications(CLEANUPCONTEXT *pcc);
    
    BOOL _CheckNewActiveView(CDocumentInputManager *pdim);

    HRESULT _CallKeyEventSink(TfClientId tid, CInputContext *pic, KSEnum ksenum, WPARAM wParam, LPARAM lParam, BOOL *pfEaten);
    HRESULT _CallKeyEventSinkNotForeground(TfClientId tid, CInputContext *pic, KSEnum ksenum, WPARAM wParam, LPARAM lParam, BOOL *pfEaten);
    HRESULT _CallSimulatePreservedKey(CHotKey *pHotKey, CInputContext *pic, REFGUID rguid, BOOL *pfEaten);
    BOOL _FindHotKeyByTID(TfClientId tid, WPARAM wParam, LPARAM lParam, CHotKey **ppHotKey, TimSysHotkey tsh, UINT uModSrc);
    BOOL _FindHotKeyAndIC(WPARAM wParam, LPARAM lParam, CHotKey **ppHotKey, CInputContext **ppic, TimSysHotkey tsh, UINT uModSrc);
    BOOL _FindHotKeyInIC(WPARAM wParam, LPARAM lParam, CHotKey **ppHotKey, CInputContext *pic, TimSysHotkey tsh, UINT uModSrc);
    BOOL _GetFirstPreservedKey(REFGUID rguid, CHotKey **ppHotKey);
    BOOL _CheckPreservedKey(KSEnum ksenum, WPARAM wParam, LPARAM lParam, BOOL fSync);
    HRESULT _OnPreservedKeyUpdate(CHotKey *pHotKey);
    BOOL _IsThisHotKey(TfClientId tid, const TF_PRESERVEDKEY *pprekey);
    HRESULT InternalPreserveKey(CTip *ctip, REFGUID rguid, const TF_PRESERVEDKEY *pprekey, const WCHAR *pchDesc, ULONG cchDesc, DWORD dwFlags, CHotKey **ppHotKey);
    HRESULT InitDefaultHotkeys();
    HRESULT UninitDefaultHotkeys();

    BOOL _IsMsctfimeDim(ITfDocumentMgr *pdim);

    static BOOL _SetThis(CThreadInputMgr *_this)
    { 
        SYSTHREAD *psfn = GetSYSTHREAD();
        if (!psfn)
            return FALSE;

        psfn->ptim = _this;
        return TRUE;
    }

    static void _StaticInit_OnActivate();

    CStructArray<DWORD> _rgCookie;
    CPtrArray<CHotKey> *_rgHotKey[256];

    CFunctionProvider *_pSysFuncPrv;
    ITfFunctionProvider *_pAppFuncProvider;


    TfClientId _tidForeground;
    TfClientId _tidPrevForeground;


    static const IID *_c_rgConnectionIIDs[TIM_NUM_CONNECTIONPTS];
    CStructArray<GENERICSINK> _rgSinks[TIM_NUM_CONNECTIONPTS];

    CPtrMap<HWND, CDocumentInputManager> _dimwndMap;
    CPtrArray<CTip> _rgTip;
    CDocumentInputManager *_pFocusDocInputMgr;
    int _iActivateRefCount;
    TsViewCookie _vcActiveView; // only valid if _fActiveView == TRUE
    BOOL _fInternalFocusedDim : 1;
    BOOL _fActiveView : 1;

    // aa stuff
    //
    void _MSAA_OnSetFocus(CDocumentInputManager *dim)
    {
        CInputContext *pic;

        if (_pAAAdaptor == NULL)
            return; // no msaa hookup

        pic = (dim == NULL) ? NULL : dim->_GetTopIC();

        _pAAAdaptor->OnDocumentFocus((pic == NULL) ? NULL : pic->_GetAATSI());
    }

    IAccServerDocMgr *_pAAAdaptor;    // the AA adaptor
    //
    // end aa stuff

    ITfLangBarItemMgr *_plbim;


    BOOL _fActiveUI : 1;
    int _cAppWantsKeystrokesRef;
    int _cDisableSystemKeystrokeFeedRef;

    BOOL _fInActivate : 1;
    BOOL _fInDeactivate : 1;
    BOOL _fFirstSetFocusAfterActivated : 1;

    CLEANUPCONTEXT *_pPendingCleanupContext;
    BOOL _fPendingCleanupContext : 1;

    BOOL _fAddedProcessAtom : 1;

    BOOL _fReleaseDisplayAttrMgr : 1;

    ITfSysHookSink *_pSysHookSink;

    DBG_ID_DECLARE;
};


#endif // TIM_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\ctf\uim\timlist.h ===
//
// timlist.h
//

#ifndef TIMLIST_H
#define TIMLIST_H

#include "smblock.h"
#include "tlapi.h"

#define INITIAL_TIMLIST_SIZE 0x10000


TL_THREADINFO *EnsureTIMList(SYSTHREAD *psfn);
BOOL CicIs16bitTask(DWORD dwProcessId, DWORD dwThreadId);
void PostTimListMessage(DWORD dwMaskFlags, DWORD dwExcludeFlags, UINT uMsg, WPARAM wParam, LPARAM lParam);
DWORD TLFlagFromTFPriv(WPARAM wParam);

typedef enum {
      TI_THREADID  = 0,
      TI_PROCESSID = 1,
      TI_FLAGS     = 2,
} TIEnum;

class CTimList
{
public:
    void CleanUp()
    {
        if (_psb)
            delete _psb;

        _psb = NULL;
    }

    BOOL Enter()
    {
        if (!_psb || !_psb->GetBase())
            return FALSE;
        
        if (ISINDLLMAIN())
            return TRUE;

        if (!_psb->GetMutex() || !_psb->GetMutex()->Enter())
            return FALSE;

        return TRUE;
    }

    void Leave()
    {
        if (ISINDLLMAIN())
            return;

        _psb->GetMutex()->Leave();
    }

    BOOL Init(BOOL fCreate);
    BOOL Uninit();

    BOOL EnsureCurrentThread();
    TL_THREADINFO *AddCurrentThread(DWORD dwFlags, SYSTHREAD *psfn);
    TL_THREADINFO *AddThreadProcess(DWORD dwThreadId, DWORD dwProcessId, HWND hwndMarshal, DWORD dwFlags);
    BOOL RemoveThread(DWORD dwThreadId);
    BOOL RemoveProcess(DWORD dwProcessId);
    ULONG GetNum();
    BOOL GetList(DWORD *pdwOut, ULONG ulMax, DWORD *pdwNum, DWORD dwMaskFlags, DWORD dwExcludeFlags, BOOL fUpdateExcludeFlags);
    BOOL GetListInProcess(DWORD *pdwOut, DWORD *pdwNum, DWORD dwProcessId);
    DWORD GetProcessId(DWORD dwThreadId);
    DWORD GetFlags(DWORD dwThreadId);
    TL_THREADINFO *IsThreadId(DWORD dwThreadId);
    BOOL SetFlags(DWORD dwThreadId, DWORD dwFlags);
    BOOL ClearFlags(DWORD dwThreadId, DWORD dwFlags);
    BOOL SetMarshalWnd(DWORD dwThreadId, HWND hwndMarshal);
    HWND GetMarshalWnd(DWORD dwThreadId);
    BOOL SetConsoleHKL(DWORD dwThreadId, HKL hkl);
    HKL  GetConsoleHKL(DWORD dwThreadId);

    typedef struct tag_TIMLIST {
        ULONG ulNum;
        TL_THREADINFO rgThread[1];
    } TIMLIST;

    BOOL IsInitialized()
    {
       return (_lInit >= 0) ? TRUE : FALSE;
    }

    BOOL GetThreadFlags(DWORD dwThreadId, DWORD *pdwFlags, DWORD *pdwProcessId, DWORD *pdwTickTime);

private:
    TL_THREADINFO *Find(DWORD dwThreadId);
    DWORD GetDWORD(DWORD dwThreadId, TIEnum tie);
    BOOL SetClearFlags(DWORD dwThreadId, DWORD dwFlags, BOOL fClear);

    static CSharedBlock *_psb;
    static ULONG _ulCommitSize;
    static LONG _lInit;

#ifdef DEBUG
    void dbg_Check(TIMLIST *ptl);
#else
    void dbg_Check(TIMLIST *ptl) {}
#endif
};


#endif // TIMLIST_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\ctf\uim\transmit.cpp ===
#include "private.h"
#include "globals.h"
#include "osver.h"
#include "transmit.h"
#include "cmydc.h"


#define MAXFILEMAPSIZE  0x1000


#define DATA_MARKER     0x0001
#define HANDLE_MARKER   0x0002
#define IS_DATA_MARKER( x) (x == DATA_MARKER)
#define IS_HANDLE_MARKER( x) (x == HANDLE_MARKER)

#define GDI_DATA_PASSING() (IsOnNT())
#define POINTER_CAST(x) *(x **)&

#define ICON_DATA_PASSING() (IsOnNT())


//+---------------------------------------------------------------------------
//
// GetIconBitmaps
//
//----------------------------------------------------------------------------

BOOL Cic_GetIconBitmaps(HICON hIcon, HBITMAP *phbmp, HBITMAP *phbmpMask, SIZE *psize)
{
    CBitmapDC hdcSrc(TRUE);
    CBitmapDC hdcMask(TRUE);
    SIZE size;

    size = *psize;

    hdcSrc.SetDIB(size.cx, size.cy);
    hdcMask.SetBitmap(size.cx, size.cy, 1, 1);
    RECT rc = {0, 0, size.cx, size.cy};
    FillRect(hdcSrc, &rc, (HBRUSH)GetStockObject(BLACK_BRUSH));
    DrawIconEx(hdcSrc, 0, 0, hIcon, size.cx, size.cy, 0, NULL, DI_NORMAL);
    DrawIconEx(hdcMask, 0, 0, hIcon, size.cx, size.cy, 0, NULL, DI_MASK);
    *phbmp = hdcSrc.GetBitmapAndKeep();
    *phbmpMask = hdcMask.GetBitmapAndKeep();
    return TRUE;
}

//+---------------------------------------------------------------------------
//
// CreateDIB
//
//----------------------------------------------------------------------------

HBITMAP CreateDIB(int cx, int cy, int nWidthByte, BYTE *pMyBits, ULONG_PTR nBitsSize)
{
    CBitmapDC hdc(TRUE);

    HBITMAP hBmp;
    BITMAPINFO bi = {0};
    bi.bmiHeader.biSize = sizeof(bi.bmiHeader);
    bi.bmiHeader.biWidth = cx;
    bi.bmiHeader.biHeight = cy;
    bi.bmiHeader.biPlanes = 1;
    bi.bmiHeader.biBitCount = 32;
    bi.bmiHeader.biCompression = BI_RGB;

    BYTE *pDibBits;
    hBmp = CreateDIBSection(hdc, &bi, DIB_RGB_COLORS, (void**)&pDibBits, NULL, 0);

    if (hBmp)
    {
        int y;
        for (y = 0; y < cy; y++)
        {
            int nyDibBites = (cy - y - 1) * nWidthByte;
            int nyMyBites = y * nWidthByte;
            memcpy(&pDibBits[nyDibBites], &pMyBits[nyMyBites], nWidthByte);
        }
    }

    return hBmp;
}

//+---------------------------------------------------------------------------
//
// MARSHAL_HDR
//
//----------------------------------------------------------------------------

template<class TYPE>
struct MARSHAL_HDR
{
    DWORD                   dwDataType;
    CAlignWinHandle<TYPE>   h;
};

// #########################################################################
//
//  HBITMAP
//  See transmit.h for explanation of gdi data/handle passing.
//
// #########################################################################

struct BITMAP_WOW64
{
    // Identical BITMAP structure.

    LONG    bmType;
    LONG    bmWidth;
    LONG    bmHeight;
    LONG    bmWidthBytes;
    WORD    bmPlanes;
    WORD    bmBitsPixel;
    CAlignPointer<LPVOID>  bmBits;

    void operator = (BITMAP& a)
    {
        bmType = a.bmType;
        bmWidth = a.bmWidth;
        bmHeight = a.bmHeight;
        bmWidthBytes = a.bmWidthBytes;
        bmPlanes     = a.bmPlanes;
        bmBitsPixel  = a.bmBitsPixel;
        bmBits       = a.bmBits;
    }

    void operator = (int a)
    {
        memset(this, a, sizeof(BITMAP_WOW64));
    }
};

struct MARSHAL_HBITMAP
{
    MARSHAL_HDR<HBITMAP>    hdr;
    MARSHAL_HDR<HBITMAP>    hdr_2;

    struct
    {
        DWORD               dwCount;
        BITMAP_WOW64        bm;
    } bitmap_1;

    struct
    {
        DWORD               dwCount;
        BITMAP_WOW64        bm;
    } bitmap_2;

    BYTE                    bits[1];
};

//+-------------------------------------------------------------------------
//
// UserSize
//
//--------------------------------------------------------------------------

ULONG Cic_HBITMAP_UserSize (HBITMAP *pHBitmap, HBITMAP *pHBitmap_2) 
{
    ULONG Offset = 0;

    if ( !pHBitmap )
        return 0;

    BITMAP      bm, bm_2;
    HBITMAP     hBitmap, hBitmap_2;

    hBitmap   = *pHBitmap;
    hBitmap_2 = pHBitmap_2 ? *pHBitmap_2 : NULL;

    memset(&bm, 0, sizeof(BITMAP));
    memset(&bm_2, 0, sizeof(BITMAP));

    //
    // The encapsulated union.
    // Discriminant and then handle or pointer from the union arm.
    // Union discriminant is 4 bytes + handle is represented by a long.
    //

    if ( GDI_DATA_PASSING() )
    {
        Offset += sizeof(struct MARSHAL_HBITMAP);

        if (hBitmap)
        {
            // Get information about the bitmap
            if (!GetObject(hBitmap, sizeof(BITMAP), &bm))
                return 0;

            Offset += (bm.bmPlanes * bm.bmHeight * bm.bmWidthBytes);
        }

        if (hBitmap_2)
        {
            // Get information about the bitmap
            if (!GetObject(hBitmap_2, sizeof(BITMAP), &bm_2))
                return 0;

            Offset += (bm_2.bmPlanes * bm_2.bmHeight * bm_2.bmWidthBytes);
        }

        Offset = Align( Offset );

    }
    else
    {
        if (pHBitmap)
            Offset += Align( sizeof(struct MARSHAL_HDR<HBITMAP>) );

        if (pHBitmap_2)
            Offset += Align( sizeof(struct MARSHAL_HDR<HBITMAP>) );
    }

    return( Offset ) ;
}

//+-------------------------------------------------------------------------
//
//  HBITMAP_UserMarshall
//
//--------------------------------------------------------------------------

BYTE *Cic_HBITMAP_UserMarshal(BYTE *pBuffer, BYTE *pBufferEnd, HBITMAP *pHBitmap, HBITMAP *pHBitmap_2)
{
    if ( !pHBitmap )
        return pBuffer;

    // Discriminant of the encapsulated union and union arm.
    struct MARSHAL_HBITMAP* pdata = (struct MARSHAL_HBITMAP*) pBuffer;

    if ( GDI_DATA_PASSING() )
    {
        if (!pHBitmap)
        {
            pdata->hdr.dwDataType = 0;
            pdata->hdr.h          = NULL;
        }
        else
        {
            pdata->hdr.dwDataType = DATA_MARKER;
            pdata->hdr.h          = *pHBitmap;
        }

        if (!pHBitmap_2)
        {
            pdata->hdr_2.dwDataType = 0;
            pdata->hdr_2.h          = NULL;
        }
        else
        {
            pdata->hdr_2.dwDataType = DATA_MARKER;
            pdata->hdr_2.h          = *pHBitmap_2;
        }

        //
        // Get information about the bitmap
        //

        BITMAP bm, bm_2;
        HBITMAP hBitmap   = *pHBitmap;
        HBITMAP hBitmap_2 = pHBitmap_2 ? *pHBitmap_2 : NULL;

        //
        // Bitmap object 1
        //
        if (!hBitmap)
        {
            pdata->bitmap_1.bm = 0;
            pdata->bitmap_1.dwCount = 0;
        }
        else
        {
            if (!GetObject(hBitmap, sizeof(BITMAP), &bm))
                return pBuffer + Align( sizeof(struct MARSHAL_HDR<HBITMAP>) );

            pdata->bitmap_1.dwCount = bm.bmPlanes * bm.bmHeight * bm.bmWidthBytes;

            //
            // Get the bm structure fields.
            //
            pdata->bitmap_1.bm = bm;
        }


        //
        // Bitmap object 2
        //

        if (!hBitmap_2)
        {
            pdata->bitmap_2.bm = 0;
            pdata->bitmap_2.dwCount = 0;
        }
        else
        {
            if (!GetObject(hBitmap_2, sizeof(BITMAP), &bm_2))
                return pBuffer + Align( sizeof(struct MARSHAL_HDR<HBITMAP>) );

            pdata->bitmap_2.dwCount = bm_2.bmPlanes * bm_2.bmHeight * bm_2.bmWidthBytes;

            pdata->bitmap_2.bm     = bm_2;
        }

        //
        // Get the raw bits.
        //

        if (hBitmap)
        {
     
            BYTE *pbTemp = pdata->bits;
            if (pbTemp + pdata->bitmap_1.dwCount > pBufferEnd)
            {
                Assert(0);
                pdata->bitmap_1.bm      = 0;
                pdata->bitmap_1.dwCount = 0;
            }
            else
            {
                GetBitmapBits( hBitmap, 
                               pdata->bitmap_1.dwCount, 
                               pdata->bits );

            }
        }

        if (hBitmap_2)
        {
            BYTE *pbTemp = &pdata->bits[pdata->bitmap_1.dwCount];
            if (pbTemp + pdata->bitmap_2.dwCount > pBufferEnd)
            {
                Assert(0);
                pdata->bitmap_2.bm      = 0;
                pdata->bitmap_2.dwCount = 0;
            }
            else
            {
                GetBitmapBits( hBitmap_2, 
                               pdata->bitmap_2.dwCount, 
                               &pdata->bits[pdata->bitmap_1.dwCount]);
            }
        }

        pBuffer += Align( sizeof(struct MARSHAL_HBITMAP) + pdata->bitmap_1.dwCount + pdata->bitmap_2.dwCount);

    }
    else
    {
        // Sending a handle.

        pdata->hdr.dwDataType = 0;
        pdata->hdr.h          = NULL;
        pdata->hdr_2.dwDataType = 0;
        pdata->hdr_2.h          = NULL;

        if (pHBitmap)
        {
            pdata->hdr.dwDataType = HANDLE_MARKER;
            pdata->hdr.h          = *pHBitmap;

            pBuffer += Align( sizeof(struct MARSHAL_HDR<HBITMAP>) );
        }

        if (pHBitmap_2)
        {
            pdata->hdr_2.dwDataType = HANDLE_MARKER;
            pdata->hdr_2.h          = *pHBitmap_2;

            pBuffer += Align( sizeof(struct MARSHAL_HDR<HBITMAP>) );
        }

    }

    return( pBuffer );
}

//+-------------------------------------------------------------------------
//
//  HBITMAP_UserUnmarshallWorker
//
//--------------------------------------------------------------------------

BYTE *Cic_HBITMAP_UserUnmarshal(BYTE *pBuffer, HBITMAP *pHBitmap, HBITMAP *pHBitmap_2)
{
    HBITMAP         hBitmap, hBitmap_2;

    // Get Discriminant and handle.  Caller checked for EOB.
    struct MARSHAL_HBITMAP* pdata = (struct MARSHAL_HBITMAP*) pBuffer;

    DWORD UnionDisc = pdata->hdr.dwDataType;
    hBitmap   = pdata->hdr.h;

    if (!hBitmap)
    {
        if (!pHBitmap_2)
        {
            *pHBitmap = NULL;
            return pBuffer;
        }

        UnionDisc = pdata->hdr_2.dwDataType;
    }

    hBitmap_2 = pdata->hdr_2.h ? (HBITMAP)pdata->hdr_2.h : NULL;

    if ( IS_DATA_MARKER( UnionDisc) )
    {
        ULONG_PTR dwCount = 0;
        ULONG_PTR dwCount_2 = 0;

        if ( hBitmap )
        {
            dwCount = pdata->bitmap_1.dwCount;
            
            // verify dwCount matches the bitmap.
            if ( dwCount != (DWORD) pdata->bitmap_1.bm.bmPlanes * 
                                    pdata->bitmap_1.bm.bmHeight * 
                                    pdata->bitmap_1.bm.bmWidthBytes )
            {
                Assert(0);
                return NULL;
            }


            // Create a bitmap based on the BITMAP structure and the raw bits in
            // the transmission buffer

            if (pdata->bitmap_1.bm.bmBitsPixel == 0x20)
                hBitmap = CreateDIB( pdata->bitmap_1.bm.bmWidth,
                                     pdata->bitmap_1.bm.bmHeight,
                                     pdata->bitmap_1.bm.bmWidthBytes,
                                     pdata->bits, dwCount);
            else
                hBitmap = CreateBitmap( pdata->bitmap_1.bm.bmWidth,
                                        pdata->bitmap_1.bm.bmHeight,
                                        pdata->bitmap_1.bm.bmPlanes,
                                        pdata->bitmap_1.bm.bmBitsPixel,
                                        pdata->bits);
        }

        if (hBitmap_2)
        {
            dwCount_2 = pdata->bitmap_2.dwCount;

            // verify dwCount_2 matches the bitmap.
            if ( dwCount_2 != (DWORD) pdata->bitmap_2.bm.bmPlanes * 
                                      pdata->bitmap_2.bm.bmHeight * 
                                      pdata->bitmap_2.bm.bmWidthBytes )
            {
                Assert(0);
                return NULL;
            }

            // Create a bitmap based on the BITMAP structure and the raw bits in
            // the transmission buffer

            if (pdata->bitmap_2.bm.bmBitsPixel == 0x20)
                hBitmap_2 = CreateDIB( pdata->bitmap_2.bm.bmWidth,
                                       pdata->bitmap_2.bm.bmHeight,
                                       pdata->bitmap_2.bm.bmWidthBytes,
                                       &pdata->bits[dwCount], dwCount_2);
            else
                hBitmap_2 = CreateBitmap( pdata->bitmap_2.bm.bmWidth,
                                          pdata->bitmap_2.bm.bmHeight,
                                          pdata->bitmap_2.bm.bmPlanes,
                                          pdata->bitmap_2.bm.bmBitsPixel,
                                          &pdata->bits[dwCount]);
        }


        pBuffer += Align( sizeof(struct MARSHAL_HBITMAP) + dwCount + dwCount_2 );
    }
    else if ( !IS_HANDLE_MARKER( UnionDisc ) )
    {
        Assert(0);
    }

    // A new bitmap handle is ready, destroy the old one, if needed.

    if ( *pHBitmap )
        DeleteObject( *pHBitmap );

    *pHBitmap = hBitmap;

    if ( pHBitmap_2 )
    {
        if ( *pHBitmap_2 )
            DeleteObject( *pHBitmap_2 );

        *pHBitmap_2 = hBitmap_2;
    }


    return( pBuffer );
}

//+-------------------------------------------------------------------------
//
//  HBITMAP_UserFree
//
//--------------------------------------------------------------------------

void Cic_HBITMAP_UserFree(HBITMAP *pHBitmap, HBITMAP *pHBitmap_2)
{
    if( pHBitmap  &&  *pHBitmap )
    {
        if ( GDI_DATA_PASSING() )
        {
            DeleteObject( *pHBitmap );
        }
    }

    if( pHBitmap_2  &&  *pHBitmap_2 )
    {
        if ( GDI_DATA_PASSING() )
        {
            DeleteObject( *pHBitmap_2 );
        }
    }
}

//////////////////////////////////////////////////////////////////////////////
//
// TF_LBBALLOON
//
//////////////////////////////////////////////////////////////////////////////

//+-------------------------------------------------------------------------
//
// UserSize
//
//--------------------------------------------------------------------------

ULONG Cic_TF_LBBALLOONINFO_UserSize(TF_LBBALLOONINFO *pInfo)
{
    ULONG ulRet;

    ulRet = sizeof(TF_LBBALLOONINFO);
    LENGTH_ALIGN(ulRet, CIC_ALIGNMENT);

    if (pInfo->bstrText)
        ulRet += (SysStringByteLen(pInfo->bstrText) + 2);
    else
        ulRet += 2;

    LENGTH_ALIGN(ulRet, CIC_ALIGNMENT);
    return ulRet;
}

//+-------------------------------------------------------------------------
//
// UserMarshal
//
//--------------------------------------------------------------------------

BYTE *Cic_TF_LBBALLOONINFO_UserMarshal(BYTE *pBuf, TF_LBBALLOONINFO *pInfo)
{
    if (!pInfo)
        return pBuf;

    memcpy(pBuf, pInfo, sizeof(TF_LBBALLOONINFO));
    pBuf += sizeof(TF_LBBALLOONINFO);
    POINTER_ALIGN( pBuf, CIC_ALIGNMENT);
    if (pInfo->bstrText)
        wcscpy((WCHAR *)pBuf, pInfo->bstrText);


    pBuf += ((pInfo->bstrText ? wcslen(pInfo->bstrText) : 0) + 2);
    POINTER_ALIGN( pBuf, CIC_ALIGNMENT);
    return pBuf;
}

//+-------------------------------------------------------------------------
//
// UserUnMarshal
//
//--------------------------------------------------------------------------

HRESULT Cic_TF_LBBALLOONINFO_UserUnmarshal(BYTE *pBuf, TF_LBBALLOONINFO  *pInfo)
{
    HRESULT hr;;

    if (!pInfo)
        return S_OK;

    hr = S_OK;

    memcpy(pInfo, pBuf, sizeof(TF_LBBALLOONINFO));
   
    if (pInfo->bstrText)
    {
        BYTE *pTmp = pBuf + sizeof(TF_LBBALLOONINFO);
        POINTER_ALIGN( pTmp, CIC_ALIGNMENT);
        pInfo->bstrText =  SysAllocString((WCHAR *)pTmp);
        hr = (pInfo->bstrText != NULL) ? S_OK : E_OUTOFMEMORY;
    }

    return hr;
}

//+-------------------------------------------------------------------------
//
// UserFree
//
//--------------------------------------------------------------------------

void Cic_TF_LBBALLOONINFO_UserFree(TF_LBBALLOONINFO *pInfo)
{
    if (pInfo->bstrText)
    {
       SysFreeString(pInfo->bstrText);
       pInfo->bstrText = NULL;
    }
}

// #########################################################################
//
//  HICON
//  See transmit.h for explanation of gdi data/handle passing.
//
// #########################################################################

struct ICONINFO_WOW64
{
    // Identical ICONINFO structure.

    BOOL    fIcon;
    DWORD   xHotspot;
    DWORD   yHotspot;
    CAlignWinHandle<HBITMAP>  hbmMask;
    CAlignWinHandle<HBITMAP>  hbmColor;

    void operator = (ICONINFO& a)
    {
        fIcon    = a.fIcon;
        xHotspot = a.xHotspot;
        yHotspot = a.yHotspot;
        hbmMask  = a.hbmMask;
        hbmColor = a.hbmColor;
    }

};

struct MARSHAL_HICON
{
    MARSHAL_HDR<HICON>      hdr;

    ICONINFO_WOW64          ic;

    MARSHAL_HBITMAP         bm;
};

//+-------------------------------------------------------------------------
//
// UserSize
//
//--------------------------------------------------------------------------

ULONG Cic_HICON_UserSize (HICON *pHIcon) 
{
    ULONG Offset = 0;

    if ( !pHIcon )
        return 0;

    HICON     hIcon = *pHIcon;

    //
    // The encapsulated union.
    // Discriminant and then handle or pointer from the union arm.
    // Union discriminant is 4 bytes + handle is represented by a long.
    //
    if ( ! *pHIcon )
        return Align( sizeof(struct MARSHAL_HDR<HICON>) );

    if ( ICON_DATA_PASSING() )
    {
        ICONINFO IconInfo;
        ULONG ulBmpUserSize = 0;
        if (!GetIconInfo(hIcon, &IconInfo))
            return 0;

        Offset += Align( sizeof(struct MARSHAL_HICON) );

        //
        // On NT4, CreateBitmap() can not create different device type
        // bitmap. We convert the dc bitmap by calling DrawIconEx().
        //
        // We may want to use DIB section to marshal but marshaling and 
        // unmarshaling happens in same device so it does not have to
        // convert bitmaps to DIB.
        //
        if (!IsOnNT5())
        {
            HBITMAP hbmp = NULL;
            HBITMAP hbmpMask = NULL;
            SIZE    size;
            BITMAP  bmp;

            if (!GetObject( IconInfo.hbmColor, sizeof(bmp), &bmp ))
            {
                Offset = 0;
                goto DeleteAndExit;
            }

            size.cx = bmp.bmWidth;
            size.cy = bmp.bmHeight;
            Cic_GetIconBitmaps(*pHIcon, &hbmp, &hbmpMask, &size);

            ulBmpUserSize = Cic_HBITMAP_UserSize(&hbmp, &hbmpMask);
            if (!ulBmpUserSize)
            {
                Offset = 0;
                goto DeleteAndExit;
            }

            Offset += ulBmpUserSize;
            Offset = Align( Offset );

DeleteAndExit:
            if (hbmp)
                DeleteObject(hbmp);
            if (hbmpMask)
                DeleteObject(hbmpMask);
        }
        else
        {
            ulBmpUserSize = Cic_HBITMAP_UserSize(&IconInfo.hbmColor, &IconInfo.hbmMask);
            if (!ulBmpUserSize)
            {
                Offset = 0;
                goto Exit;
            }

            Offset += ulBmpUserSize;
            Offset = Align( Offset );

        }
Exit:
        if (IconInfo.hbmColor)
            DeleteObject(IconInfo.hbmColor);
        if (IconInfo.hbmMask)
            DeleteObject(IconInfo.hbmMask);
    }
    else
    {
        Offset += Align( sizeof(struct MARSHAL_HDR<HICON>) );
    }

    return( Offset ) ;
}

//+-------------------------------------------------------------------------
//
//  HICON_UserMarshall
//
//--------------------------------------------------------------------------

BYTE *Cic_HICON_UserMarshal(BYTE *pBuffer, BYTE *pBufferEnd, HICON *pHIcon)
{
    if ( !pHIcon )
        return pBuffer;

    // Discriminant of the encapsulated union and union arm.
    struct MARSHAL_HICON* pdata = (struct MARSHAL_HICON*) pBuffer;

    if ( ICON_DATA_PASSING() )
    {
        pdata->hdr.dwDataType = DATA_MARKER;
        pdata->hdr.h          = *pHIcon;

        if ( ! *pHIcon )
            return pBuffer + Align( sizeof(struct MARSHAL_HDR<HICON>) );

        //
        // Get information about the bitmap
        //
        ICONINFO IconInfo;

        if (!GetIconInfo(*pHIcon, &IconInfo))
            memset(&IconInfo, 0, sizeof(IconInfo));

        //
        // Get the ic structure fields.
        //
        pdata->ic    = IconInfo;

        //
        // On NT4, CreateBitmap() can not create different device type
        // bitmap. We convert the dc bitmap by calling DrawIconEx().
        //
        // We may want to use DIB section to marshal but marshaling and 
        // unmarshaling happens in same device so it does not have to
        // convert bitmaps to DIB.
        //
        if (!IsOnNT5())
        {
            HBITMAP hbmp = NULL;
            HBITMAP hbmpMask = NULL;
            SIZE    size;
            BITMAP  bmp;
            GetObject( IconInfo.hbmColor, sizeof(bmp), &bmp );
            size.cx = bmp.bmWidth;
            size.cy = bmp.bmHeight;
            Cic_GetIconBitmaps(*pHIcon, &hbmp, &hbmpMask, &size);

            pBuffer = Cic_HBITMAP_UserMarshal((BYTE*) &pdata->bm, pBufferEnd, &hbmp, &hbmpMask);

            if (hbmp)
                DeleteObject(hbmp);
            if (hbmpMask)
                DeleteObject(hbmpMask);
        }
        else
        {
            pBuffer = Cic_HBITMAP_UserMarshal((BYTE*) &pdata->bm, pBufferEnd, &IconInfo.hbmColor, &IconInfo.hbmMask);
        }
        if (IconInfo.hbmColor)
            DeleteObject(IconInfo.hbmColor);
        if (IconInfo.hbmColor)
            DeleteObject(IconInfo.hbmMask);
    }
    else
    {
        //
        // we need to make sure this pointer of the Icon is
        // not a resource.
        //
        HICON hIcon = CopyIcon(*pHIcon);
        if (hIcon)
            DestroyIcon(*pHIcon);
        else
            hIcon = *pHIcon;
     
        // Sending a handle.

        pdata->hdr.dwDataType = HANDLE_MARKER;
        pdata->hdr.h          = hIcon;

        pBuffer += Align( sizeof(struct MARSHAL_HDR<HICON>) );

    }

    return( pBuffer );
}

//+-------------------------------------------------------------------------
//
//  HICON_UserUnmarshallWorker
//
//--------------------------------------------------------------------------

BYTE *Cic_HICON_UserUnmarshal(BYTE *pBuffer, HICON  *pHIcon)
{
    HICON hIcon = NULL;

    // Get Discriminant and handle.  Caller checked for EOB.
    struct MARSHAL_HICON* pdata = (struct MARSHAL_HICON*) pBuffer;

    DWORD UnionDisc = pdata->hdr.dwDataType;
    hIcon           = pdata->hdr.h;

    if ( IS_DATA_MARKER( UnionDisc) )
    {
        if ( hIcon )
        {
            ICONINFO IconInfo;
            IconInfo.fIcon    = pdata->ic.fIcon;
            IconInfo.xHotspot = pdata->ic.xHotspot;
            IconInfo.yHotspot = pdata->ic.yHotspot;
            IconInfo.hbmMask  = pdata->ic.hbmMask;
            IconInfo.hbmColor = pdata->ic.hbmColor;

            //
            // We just get the bitmap handle from marshaling buffer.
            // And the marshaling buffer does not have a valid bitmap handle.
            //
            IconInfo.hbmColor = NULL;
            IconInfo.hbmMask = NULL;

            pBuffer = Cic_HBITMAP_UserUnmarshal((BYTE*) &pdata->bm, &IconInfo.hbmColor, &IconInfo.hbmMask);
            if (pBuffer)
            {
                hIcon = CreateIconIndirect(&IconInfo);
            }

            if (IconInfo.hbmColor)
                DeleteObject(IconInfo.hbmColor);
            if (IconInfo.hbmMask)
                DeleteObject(IconInfo.hbmMask);
        }
    }
    else if ( !IS_HANDLE_MARKER( UnionDisc ) )
    {
        Assert(0);
    }

    // A new bitmap handle is ready, destroy the old one, if needed.

    if ( *pHIcon )
        DestroyIcon( *pHIcon );

    *pHIcon = hIcon;

    return( pBuffer );
}

//+-------------------------------------------------------------------------
//
//  HICON_UserFree
//
//--------------------------------------------------------------------------

void Cic_HICON_UserFree(HICON *pHIcon)
{
    if( pHIcon  &&  *pHIcon )
    {
        if ( ICON_DATA_PASSING() )
        {
            DestroyIcon( *pHIcon );
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\ctf\uim\timlist.cpp ===
//
// timlist.cpp
//

#include "private.h"
#include "globals.h"
#include "timlist.h"
#include "thdutil.h"

CTimList g_timlist;

CSharedBlock *CTimList::_psb = NULL;
ULONG CTimList::_ulCommitSize = INITIAL_TIMLIST_SIZE;
LONG CTimList::_lInit = -1;

//////////////////////////////////////////////////////////////////////////////
//
// func
//
//////////////////////////////////////////////////////////////////////////////

//--------------------------------------------------------------------------
//
//  TF_GetThreadFlags
//
//--------------------------------------------------------------------------

BOOL TF_GetThreadFlags(DWORD dwThreadId, DWORD *pdwFlags, DWORD *pdwProcessId, DWORD *pdwTickTime)
{
    return g_timlist.GetThreadFlags(dwThreadId, pdwFlags, pdwProcessId, pdwTickTime);
}

//--------------------------------------------------------------------------
//
//  TF_IsInMarshaling
//
//--------------------------------------------------------------------------

BOOL TF_IsInMarshaling(DWORD dwThreadId)
{
    TL_THREADINFO *pti;
    pti = g_timlist.IsThreadId(dwThreadId);
    if (!pti)
        return FALSE;

    return pti->ulInMarshal ? TRUE : FALSE;
}

//--------------------------------------------------------------------------
//
//  EnsureTIMList
//
//--------------------------------------------------------------------------

TL_THREADINFO *EnsureTIMList(SYSTHREAD *psfn)
{
    TL_THREADINFO *pti = NULL;

    Assert(psfn);

    if (!g_timlist.IsInitialized())
    {
        if (!g_timlist.Init(FALSE))
            return NULL;

        //
        // we should not see the timlist entry of this thread. This thread
        // is starting now.
        // the thread with same ID was terminated incorrectly so there was no
        // chance to clean timlist up.
        //

        Assert(psfn->dwProcessId == GetCurrentProcessId());
        g_timlist.RemoveProcess(psfn->dwProcessId);
    }

    Assert(psfn->dwThreadId == GetCurrentThreadId());
    pti = g_timlist.IsThreadId(psfn->dwThreadId);

    //
    // check if pti is invalid.
    //
    if (pti && (pti->dwProcessId != psfn->dwProcessId))
    {
         Assert(pti->dwThreadId == psfn->dwThreadId);

         memset(pti, 0, sizeof(TL_THREADINFO));
         pti = NULL;
    }

    if (!pti)
    {
        DWORD dwFlags = 0;

        if (psfn && psfn->plbim)
            dwFlags |= TLF_LBIMGR;

        if (CicTestAppCompat(CIC_COMPAT_NOWAITFORINPUTIDLEONWIN9X))
            dwFlags |= TLF_NOWAITFORINPUTIDLEONWIN9X;

        if (g_fCTFMONProcess)
            dwFlags |= TLF_CTFMONPROCESS;

        pti = g_timlist.AddCurrentThread(dwFlags, psfn);
    }

    if (psfn->pti != pti)
        psfn->pti = pti;

    return pti;
}

//--------------------------------------------------------------------------
//
//  CicIs16bitTask
//
//--------------------------------------------------------------------------

BOOL CicIs16bitTask(DWORD dwProcessId, DWORD dwThreadId)
{
    DWORD dwFlags = g_timlist.GetFlags(dwThreadId);

    if (dwFlags & TLF_16BITTASKCHECKED)
        goto Exit;

    dwFlags = TLF_16BITTASKCHECKED;
    if (Is16bitThread(dwProcessId, dwThreadId))
    {
        dwFlags |= TLF_16BITTASK;
    }
    g_timlist.SetFlags(dwThreadId, dwFlags);

Exit:
    return (dwFlags & TLF_16BITTASK) ? TRUE : FALSE;
}

//--------------------------------------------------------------------------
//
//  PostTimListMessage
//
//--------------------------------------------------------------------------

void PostTimListMessage(DWORD dwMaskFlags, DWORD dwExcludeFlags, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    //
    // call PostThreadMessage() to other threads.
    //
    ULONG ulNum = g_timlist.GetNum();
    if (ulNum)
    {
         DWORD *pdw = new DWORD[ulNum + 1];
         if (pdw)
         {
             if (g_timlist.GetList(pdw, ulNum+1, &ulNum, dwMaskFlags, dwExcludeFlags, TRUE))
             {
                 DWORD dwCurThreadId = GetCurrentThreadId();
                 ULONG ul;
                 for (ul = 0; ul < ulNum; ul++)
                 {
                     if (pdw[ul] && (dwCurThreadId != pdw[ul]))
                     {
                         PostThreadMessage(pdw[ul], uMsg, wParam, lParam);
                     }
                 }
             }
             delete pdw;
         }
    }
}


//--------------------------------------------------------------------------
//
//  TLFlagFromTFPriv
//
//--------------------------------------------------------------------------

DWORD TLFlagFromTFPriv(WPARAM wParam)
{
    if (wParam == TFPRIV_UPDATE_REG_IMX)
        return TLF_TFPRIV_UPDATE_REG_IMX_IN_QUEUE;

    if (wParam == TFPRIV_SYSCOLORCHANGED)
        return TLF_TFPRIV_SYSCOLORCHANGED_IN_QUEUE;

    if (wParam == TFPRIV_UPDATE_REG_KBDTOGGLE)
        return TLF_TFPRIV_UPDATE_REG_KBDTOGGLE_IN_QUEUE;

    return 0;
}


//////////////////////////////////////////////////////////////////////////////
//
// CTimList
//
//////////////////////////////////////////////////////////////////////////////

//--------------------------------------------------------------------------
//
//  Init
//
//--------------------------------------------------------------------------

extern char g_szTimListCache[];
BOOL CTimList::Init(BOOL fCreate)
{
    BOOL bRet = FALSE;
    // TIMLIST *ptl;

    if (InterlockedIncrement(&_lInit))
        return TRUE;

    if (!_psb)
        _psb = new CSharedBlockNT(g_szTimListCache, 0, TRUE);

    if (!_psb)
    {
        Assert(0);
        return FALSE;
    }

    HRESULT hr = _psb->Init(NULL, 0x40000, _ulCommitSize, NULL, fCreate);
    if (FAILED(hr))
    {
        //
        // maybe ctfmon.exe does not start yet.
        //
        TraceMsg(TF_GENERAL, "Init: failed");
        goto Exit;
    }

    //
    // ulNum is initialized by VirtualAlloc().
    //
    // ptl = (TIMLIST *)_psb->GetBase();
    //
    // ptl->ulNum = 0;
    //

    bRet = TRUE;

Exit:

    if (!bRet)
        InterlockedDecrement(&_lInit);
    return bRet;
}

//--------------------------------------------------------------------------
//
//  UnInit
//
//--------------------------------------------------------------------------

BOOL CTimList::Uninit()
{
    if (InterlockedDecrement(&_lInit) >= 0)
        return TRUE;

    CleanUp();
    return TRUE;
}


//--------------------------------------------------------------------------
//
//  AddCurrentThread
//
//--------------------------------------------------------------------------

TL_THREADINFO *CTimList::AddCurrentThread(DWORD dwFlags, SYSTHREAD *psfn)
{
    return AddThreadProcess(GetCurrentThreadId(), 
                            GetCurrentProcessId(), 
                            psfn ? psfn->hwndMarshal : NULL,
                            dwFlags);
}

//--------------------------------------------------------------------------
//
//  AddThreadProcess
//
//--------------------------------------------------------------------------

TL_THREADINFO *CTimList::AddThreadProcess(DWORD dwThreadId, DWORD dwProcessId, HWND hwndMarshal,  DWORD dwFlags)
{
    TL_THREADINFO *pti = NULL;
    BOOL bFound = FALSE;
    ULONG ul;

    if (!Enter())
        return pti;

    _try 
    {
        TIMLIST *ptl = (TIMLIST *)_psb->GetBase();
        if (!ptl)
            goto Exit;

        //
        // check if there is a thread info in the list.
        //
        for (ul = 0; ul < ptl->ulNum; ul++)
        {
            if (!ptl->rgThread[ul].dwThreadId || 
                (ptl->rgThread[ul].dwThreadId == dwThreadId))
            {
                pti = &ptl->rgThread[ul];
                goto InitPTI;
            }
        }


        if (_ulCommitSize <  sizeof(TIMLIST) + (ptl->ulNum * sizeof(TL_THREADINFO)))
        {
            _ulCommitSize = sizeof(TIMLIST) + (ptl->ulNum * sizeof(TL_THREADINFO));
            _ulCommitSize += INITIAL_TIMLIST_SIZE;
            if (FAILED(_psb->Commit(_ulCommitSize)))
            {
                Assert(0);
                goto Exit;
            }
        }

        pti = &ptl->rgThread[ptl->ulNum];
        ptl->ulNum++;

InitPTI:
        memset(pti, 0, sizeof(TL_THREADINFO));
        pti->dwThreadId = dwThreadId;
        pti->dwProcessId = dwProcessId;
        pti->dwFlags = dwFlags;
        pti->hwndMarshal = hwndMarshal;

        pti->dwTickTime = GetTickCount();

    }
    _except(1)
    {
        Assert(0);
    }

Exit:
    Leave();
    return pti;
}

//--------------------------------------------------------------------------
//
//  RemoveThread
//
//--------------------------------------------------------------------------

BOOL CTimList::RemoveThread(DWORD dwThreadId)
{
    ULONG ul;
    ULONG ulMax;
    BOOL bRet = FALSE;

    if (!_psb)
        return bRet;
        
    TIMLIST *ptl = (TIMLIST *)_psb->GetBase();
    if (!ptl)
        goto Exit;

    ulMax = ptl->ulNum;
    for (ul = 0; ul < ulMax; ul++)
    {
        if (ptl->rgThread[ul].dwThreadId == dwThreadId)
        {
            memset(&ptl->rgThread[ul], 0, sizeof(TL_THREADINFO));
            break;
        }
    }

    bRet = TRUE;
Exit:
    return bRet;
}

//--------------------------------------------------------------------------
//
//  RemoveProcess
//
//--------------------------------------------------------------------------

BOOL CTimList::RemoveProcess(DWORD dwProcessId)
{
    ULONG ul;
    ULONG ulMax;
    BOOL bRet = FALSE;

    if (!_psb)
        return bRet;

    if (!Enter())
        return bRet;

    _try 
    {
        TIMLIST *ptl = (TIMLIST *)_psb->GetBase();
        if (ptl)
        {
            ulMax = ptl->ulNum;
            for (ul = 0; ul < ulMax; ul++)
            {
                if (ptl->rgThread[ul].dwProcessId == dwProcessId)
                    memset(&ptl->rgThread[ul], 0, sizeof(TL_THREADINFO));
            }
            bRet = TRUE;
        }
    }
    _except(1)
    {
        Assert(0);
    }

    Leave();
    return bRet;
}

//--------------------------------------------------------------------------
//
//  GetNum
//
//--------------------------------------------------------------------------

ULONG CTimList::GetNum()
{
    ULONG ulRet = 0;

    if (!Enter())
        return ulRet;

    _try 
    {
        TIMLIST *ptl = (TIMLIST *)_psb->GetBase();
        if (!ptl)
            goto Exit;

        ulRet = ptl->ulNum;

    }
    _except(1)
    {
        Assert(0);
    }

Exit:
    Leave();
    return ulRet;
}


//--------------------------------------------------------------------------
//
//  GetList
//
//--------------------------------------------------------------------------

BOOL CTimList::GetList(DWORD *pdwOut, ULONG ulMax, DWORD *pdwNum, DWORD dwMaskFlags, DWORD dwExcludeFlags, BOOL fUpdateExcludeFlags)
{
    if (!Enter())
        return FALSE;

    ULONG ul;
    ULONG ulCur = 0;
    BOOL bRet = FALSE;
    DWORD dwTmpFlags = 0;

    _try 
    {
        TIMLIST *ptl = (TIMLIST *)_psb->GetBase();
        if (!ptl)
            goto Exit;

        for (ul = 0; ul < ptl->ulNum; ul++)
        {
            if (ul >= ulMax)
                break; // no space in caller's buffer

            if (!ptl->rgThread[ul].dwThreadId)
               continue;

            if (ptl->rgThread[ul].dwFlags & dwExcludeFlags)
               continue;

            dwTmpFlags = ptl->rgThread[ul].dwFlags;

            if (fUpdateExcludeFlags)
               dwTmpFlags |= dwExcludeFlags;

            if (!dwMaskFlags || (dwTmpFlags & dwMaskFlags))
            {
                if (pdwOut)
                {
                    pdwOut[ulCur] = ptl->rgThread[ul].dwThreadId;

                    if (fUpdateExcludeFlags)
                       ptl->rgThread[ul].dwFlags |= dwExcludeFlags;
                }
                ulCur++;

            }
        }

Exit:
        if (pdwNum)
            *pdwNum = ulCur;

        bRet = TRUE;
    }
    _except(1)
    {
        Assert(0);
    }

    Leave();
    return bRet;
}

//--------------------------------------------------------------------------
//
//  GetListInProcess
//
//--------------------------------------------------------------------------

BOOL CTimList::GetListInProcess(DWORD *pdwOut, DWORD *pdwNum, DWORD dwProcessId)
{
    if (!Enter())
        return FALSE;

    ULONG ul;
    ULONG ulCur = 0;
    BOOL bRet = FALSE;

    _try 
    {
        TIMLIST *ptl = (TIMLIST *)_psb->GetBase();
        if (!ptl)
            goto Exit;

        for (ul = 0; ul < ptl->ulNum; ul++)
        {
            if (!ptl->rgThread[ul].dwThreadId)
               continue;

            if (!dwProcessId || (ptl->rgThread[ul].dwProcessId == dwProcessId))
            {
                if (pdwOut)
                    pdwOut[ulCur] = ptl->rgThread[ul].dwThreadId;
                ulCur++;
            }
        }

Exit:
        if (pdwNum)
            *pdwNum = ulCur;

        bRet = TRUE;
    }
    _except(1)
    {
        Assert(0);
    }

    Leave();
    return bRet;
}

//--------------------------------------------------------------------------
//
//  GetFlags
//
//--------------------------------------------------------------------------

DWORD CTimList::GetFlags(DWORD dwThreadId)
{
    return GetDWORD(dwThreadId, TI_FLAGS);
}

//--------------------------------------------------------------------------
//
//  GetProcessId
//
//--------------------------------------------------------------------------

DWORD CTimList::GetProcessId(DWORD dwThreadId)
{
    return GetDWORD(dwThreadId, TI_PROCESSID);
}

//--------------------------------------------------------------------------
//
//  GetThreadId
//
//--------------------------------------------------------------------------

TL_THREADINFO *CTimList::IsThreadId(DWORD dwThreadId)
{
    TL_THREADINFO *pti = NULL;

    if (!Enter())
        return NULL;

    _try 
    {
        TIMLIST *ptl = (TIMLIST *)_psb->GetBase();
        if (!ptl)
            goto Exit;

        pti = Find(dwThreadId);
    }
    _except(1)
    {
        Assert(0);
    }

Exit:
    Leave();
    return pti;
}

//--------------------------------------------------------------------------
//
//  GetDWORD
//
//--------------------------------------------------------------------------

DWORD CTimList::GetDWORD(DWORD dwThreadId, TIEnum tie)
{
    DWORD dwRet = 0;
    TIMLIST *ptl;
    TL_THREADINFO *pti;

    if (!Enter())
        return 0;

    _try 
    {
        ptl = (TIMLIST *)_psb->GetBase();
        if (!ptl)
            goto Exit;

        pti = Find(dwThreadId);
        if (pti)
        {
            switch (tie)
            {
                case TI_THREADID: 
                    dwRet = pti->dwThreadId;
                    break;

                case TI_PROCESSID: 
                    dwRet = pti->dwProcessId;
                    break;

                case TI_FLAGS: 
                    dwRet = pti->dwFlags;
                    break;
            }
        }
    }
    _except(1)
    {
        Assert(0);
    }
Exit:
    Leave();
    return dwRet;
}

//--------------------------------------------------------------------------
//
//  SetFlags
//
//--------------------------------------------------------------------------

BOOL CTimList::SetFlags(DWORD dwThreadId, DWORD dwFlags)
{
    return SetClearFlags(dwThreadId, dwFlags, FALSE);
}

//--------------------------------------------------------------------------
//
//  ClearFlags
//
//--------------------------------------------------------------------------

BOOL CTimList::ClearFlags(DWORD dwThreadId, DWORD dwFlags)
{
    return SetClearFlags(dwThreadId, dwFlags, TRUE);
}

//--------------------------------------------------------------------------
//
//  SetClearFlags
//
//--------------------------------------------------------------------------

BOOL CTimList::SetClearFlags(DWORD dwThreadId, DWORD dwFlags, BOOL fClear)
{
    BOOL bRet = FALSE;
    TL_THREADINFO *pti;

    if (!Enter())
        return bRet;

    _try
    {
        TIMLIST *ptl = (TIMLIST *)_psb->GetBase();
        if (!ptl)
            goto Exit;

        pti = Find(dwThreadId);
        if (pti)
        {
            if (fClear)
                pti->dwFlags &= ~dwFlags;
            else
                pti->dwFlags |= dwFlags;

            bRet = TRUE;
        }
    }
    _except(1)
    {
        Assert(0);
    }

Exit:
    Leave();

    return bRet;
}

//--------------------------------------------------------------------------
//
//  GetDWORD
//
//--------------------------------------------------------------------------

TL_THREADINFO *CTimList::Find(DWORD dwThreadId)
{
    ULONG ul;
    DWORD dwRet = 0;

    Assert(_psb);

    TIMLIST *ptl = (TIMLIST *)_psb->GetBase();
    if (!ptl)
        goto Exit;

    for (ul = 0; ul < ptl->ulNum; ul++)
    {
        if (ptl->rgThread[ul].dwThreadId == dwThreadId)
        {
            return &ptl->rgThread[ul];
        }
    }

Exit:
    return NULL;
}

//--------------------------------------------------------------------------
//
//  GetDWORD
//
//--------------------------------------------------------------------------

BOOL CTimList::GetThreadFlags(DWORD dwThreadId, DWORD *pdwFlags, DWORD *pdwProcessId, DWORD *pdwTickTime)
{
    BOOL bRet = FALSE;
    TIMLIST *ptl;
    TL_THREADINFO *pti;

    if (pdwFlags)
        *pdwFlags = 0;

    if (pdwProcessId)
        *pdwProcessId = 0;

    if (!Enter())
        return FALSE;

    _try
    {
        ptl = (TIMLIST *)_psb->GetBase();
        if (!ptl)
            goto Exit;

        pti = Find(dwThreadId);
        if (pti)
        {
            if (pdwProcessId)
                *pdwProcessId = pti->dwProcessId;

            if (pdwFlags)
                *pdwFlags = pti->dwFlags;

            if (pdwTickTime)
                *pdwTickTime = pti->dwTickTime;

            bRet = TRUE;
        }
    }
    _except(1)
    {
        Assert(0);
    }
Exit:
    Leave();
    return bRet;
}

//--------------------------------------------------------------------------
//
//  SetMarshalWnd
//
//--------------------------------------------------------------------------

BOOL CTimList::SetMarshalWnd(DWORD dwThreadId, HWND hwndMarshal)
{
    BOOL bRet = FALSE;
    TL_THREADINFO *pti;

    if (!IsInitialized())
        return bRet;

    if (!Enter())
        return bRet;

    _try
    {
        TIMLIST *ptl = (TIMLIST *)_psb->GetBase();
        if (!ptl)
            goto Exit;

        pti = Find(dwThreadId);
        if (pti)
        {
            pti->hwndMarshal = hwndMarshal;
            bRet = TRUE;
        }
    }
    _except(1)
    {
        Assert(0);
    }
Exit:
    Leave();
    return bRet;
}

//--------------------------------------------------------------------------
//
//  GetMarshalWnd
//
//--------------------------------------------------------------------------

HWND CTimList::GetMarshalWnd(DWORD dwThreadId)
{
    HWND hwndRet = NULL;
    TL_THREADINFO *pti;

    if (!IsInitialized())
        return NULL;

    if (!Enter())
        return NULL;

    _try
    {
        TIMLIST *ptl = (TIMLIST *)_psb->GetBase();
        if (!ptl)
            goto Exit;

        pti = Find(dwThreadId);
        if (pti)
            hwndRet = pti->hwndMarshal;

    }
    _except(1)
    {
        Assert(0);
    }
Exit:
    Leave();
    return hwndRet;
}

//--------------------------------------------------------------------------
//
//  SetConsoleHKL
//
//--------------------------------------------------------------------------

BOOL CTimList::SetConsoleHKL(DWORD dwThreadId, HKL hkl)
{
    BOOL bRet = FALSE;
    TL_THREADINFO *pti;

    if (!IsInitialized())
        return bRet;

    if (!Enter())
        return bRet;

    _try
    {
        TIMLIST *ptl = (TIMLIST *)_psb->GetBase();
        if (!ptl)
            goto Exit;

        pti = Find(dwThreadId);
        if (pti)
        {
            pti->hklConsole = hkl;
            bRet = TRUE;
        }
    }
    _except(1)
    {
        Assert(0);
    }
Exit:
    Leave();
    return bRet;
}

//--------------------------------------------------------------------------
//
//  GetConsoleHKL
//
//--------------------------------------------------------------------------

HKL CTimList::GetConsoleHKL(DWORD dwThreadId)
{
    HKL hklRet = NULL;
    TL_THREADINFO *pti;

    if (!IsInitialized())
        return NULL;

    if (!Enter())
        return NULL;

    _try
    {
        TIMLIST *ptl = (TIMLIST *)_psb->GetBase();
        if (!ptl)
            goto Exit;

        pti = Find(dwThreadId);
        if (pti)
            hklRet = pti->hklConsole;

    }
    _except(1)
    {
        Assert(0);
    }
Exit:
    Leave();
    return hklRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\ctf\uim\tom.cpp ===
//
// tom.cpp
//

#include "private.h"
#include "range.h"
#include "tim.h"
#include "ic.h"
#include "immxutil.h"
#include "dim.h"
#include "view.h"
#include "tsi.h"
#include "compose.h"
#include "profiles.h"
#include "fnrecon.h"
#include "acp2anch.h"

//+---------------------------------------------------------------------------
//
// GetSelection
//
//----------------------------------------------------------------------------

STDAPI CInputContext::GetSelection(TfEditCookie ec, ULONG ulIndex, ULONG ulCount, TF_SELECTION *pSelection, ULONG *pcFetched)
{
    HRESULT hr;
    TS_SELECTION_ANCHOR sel;
    TS_SELECTION_ANCHOR *pSelAnchor;
    ULONG i;
    ULONG j;
    CRange *range;

    if (pcFetched == NULL)
        return E_INVALIDARG;

    *pcFetched = 0;

    if (pSelection == NULL && ulCount > 0)
        return E_INVALIDARG;

    if (!_IsConnected())
        return TF_E_DISCONNECTED;

    if (!_IsValidEditCookie(ec, TF_ES_READ))
    {
        Assert(0);
        return TF_E_NOLOCK;
    }

    if (ulCount == 1)
    {
        pSelAnchor = &sel;
    }
    else if ((pSelAnchor = (TS_SELECTION_ANCHOR *)cicMemAlloc(ulCount*sizeof(TS_SELECTION_ANCHOR))) == NULL)
        return E_OUTOFMEMORY;

    if ((hr = _ptsi->GetSelection(ulIndex, ulCount, pSelAnchor, pcFetched)) != S_OK)
        goto Exit;

    // verify the anchors
    for (i=0; i<*pcFetched; i++)
    {
        if (pSelAnchor[i].paStart == NULL ||
            pSelAnchor[i].paEnd == NULL ||
            CompareAnchors(pSelAnchor[i].paStart, pSelAnchor[i].paEnd) > 0)
        {
            // free up all the anchors
            for (j=0; j<*pcFetched; j++)
            {
                SafeRelease(pSelAnchor[i].paStart);
                SafeRelease(pSelAnchor[i].paEnd);
            }
            hr = E_FAIL;
            goto Exit;
        }
    }

    // anchors -> ranges
    for (i=0; i<*pcFetched; i++)
    {
        range = new CRange;
        pSelection[i].range = (ITfRangeAnchor *)range;

        if (range == NULL ||
            !range->_InitWithDefaultGravity(this, OWN_ANCHORS, pSelAnchor[i].paStart, pSelAnchor[i].paEnd))
        {
            SafeRelease(range);
            SafeRelease(pSelAnchor[i].paStart);
            SafeRelease(pSelAnchor[i].paEnd);
            while (i>0) // need to free up all the ranges already allocated
            {
                pSelection[--i].range->Release();
            }
            hr = E_OUTOFMEMORY;
            goto Exit;
        }
        pSelection[i].style.ase = (TfActiveSelEnd)pSelAnchor[i].style.ase;
        pSelection[i].style.fInterimChar = pSelAnchor[i].style.fInterimChar;
    }

Exit:
    if (hr != S_OK)
    {
        *pcFetched = 0;
    }
    if (pSelAnchor != &sel)
    {
        cicMemFree(pSelAnchor);
    }

    return hr;
}

//+---------------------------------------------------------------------------
//
// SetSelection
//
//----------------------------------------------------------------------------

STDAPI CInputContext::SetSelection(TfEditCookie ec, ULONG ulCount, const TF_SELECTION *pSelection)
{
    CRange *pRangeP;
    HRESULT hr;
    TS_SELECTION_ANCHOR sel;
    TS_SELECTION_ANCHOR *pSelAnchor;
    ULONG i;
    BOOL fPrevInterimChar;
    BOOL fEqual;
    IAnchor *paTest;
    LONG cchShift;

    if (ulCount == 0)
        return E_INVALIDARG;
    if (pSelection == NULL)
        return E_INVALIDARG;

    if (!_IsConnected())
        return TF_E_DISCONNECTED;

    if (!_IsValidEditCookie(ec, TF_ES_READWRITE))
    {
        Assert(0);
        return TF_E_NOLOCK;
    }

    if (ulCount == 1)
    {
        pSelAnchor = &sel;
    }
    else if ((pSelAnchor = (TS_SELECTION_ANCHOR *)cicMemAlloc(ulCount*sizeof(TS_SELECTION_ANCHOR))) == NULL)
        return E_OUTOFMEMORY;

    // convert to TS_SELECTION_ANCHOR
    fPrevInterimChar = FALSE;

    for (i=0; i<ulCount; i++)
    {
        hr = E_INVALIDARG;

        if (pSelection[i].range == NULL)
            goto Exit;

        if ((pRangeP = GetCRange_NA(pSelection[i].range)) == NULL)
            goto Exit;

        pSelAnchor[i].paStart = pRangeP->_GetStart(); // no AddRef here
        pSelAnchor[i].paEnd = pRangeP->_GetEnd();

        if (pSelection[i].style.fInterimChar)
        {
            // verify this really has length 1, and there's only one in the array
            if (fPrevInterimChar)
                goto Exit;

            if (pSelection[i].style.ase != TS_AE_NONE)
                goto Exit;

            if (pSelAnchor[i].paStart->Clone(&paTest) == S_OK)
            {
                if (paTest->Shift(0, 1, &cchShift, NULL) != S_OK)
                    goto EndTest;

                if (cchShift != 1)
                    goto EndTest;

                if (paTest->IsEqual(pSelAnchor[i].paEnd, &fEqual) != S_OK || !fEqual)
                    goto EndTest;

                hr = S_OK;
EndTest:
                paTest->Release();
                if (hr != S_OK)
                    goto Exit;
            }

            fPrevInterimChar = TRUE;
        }

        pSelAnchor[i].style.ase = (TsActiveSelEnd)pSelection[i].style.ase;
        pSelAnchor[i].style.fInterimChar = pSelection[i].style.fInterimChar;
    }

    hr = _ptsi->SetSelection(ulCount, pSelAnchor);

    if (hr != S_OK)
        goto Exit;

    // app won't notify us about sel changes we cause, so do that manually
    _OnSelectionChangeInternal(FALSE);

Exit:
    if (pSelAnchor != &sel)
    {
        cicMemFree(pSelAnchor);
    }

    return hr;
}

//+---------------------------------------------------------------------------
//
// RequestEditSession
//
//----------------------------------------------------------------------------

STDAPI CInputContext::RequestEditSession(TfClientId tid, ITfEditSession *pes, DWORD dwFlags, HRESULT *phrSession)
{
    BOOL fForceAsync;
    TS_QUEUE_ITEM item;
    DWORD dwEditSessionFlagsOrg;

    if (phrSession == NULL)
        return E_INVALIDARG;

    *phrSession = E_FAIL;

    if (!_IsConnected())
        return TF_E_DISCONNECTED;

    if (pes == NULL ||
        (dwFlags & TF_ES_READ) == 0 ||
        (dwFlags & ~(TF_ES_SYNC | TF_ES_ASYNC | TF_ES_ALL_ACCESS_BITS)) != 0 ||
        ((dwFlags & TF_ES_SYNC) && (dwFlags & TF_ES_ASYNC)))
    {
        Assert(0);
        return E_INVALIDARG;
    }

    if (dwFlags & TF_ES_WRITE)
    {
        // TS_ES_WRITE implies TF_ES_PROPERTY_WRITE, so set it here to make life easier
        // for binary compat with cicero 1.0, we couldn't redefine TF_ES_READWRITE to include the third bit
        dwFlags |= TF_ES_PROPERTY_WRITE;
    }

    fForceAsync = (dwFlags & TF_ES_ASYNC);

    if ((dwFlags & (TF_ES_WRITE | TF_ES_PROPERTY_WRITE)) && (_dwEditSessionFlags & TF_ES_INNOTIFY))
    {
        // we're in _NotifyEndEdit or OnLayoutChange -- we only allow read locks here
        if (!(dwFlags & TF_ES_SYNC))
        {
            fForceAsync = TRUE;
        }
        else
        {
            Assert(0); // we can't do a synchronous write during a notification callback
            *phrSession = TF_E_SYNCHRONOUS;
            return S_OK;
        }
    }
    else if (!fForceAsync && (_dwEditSessionFlags & TF_ES_INEDITSESSION))
    {
        *phrSession = TF_E_LOCKED; // edit sessions are generally not re-entrant

        // no reentrancy if caller wants a write lock but current lock is read-only
        // nb: this explicitly disallows call stacks like: write-read-write, the
        // inner write would confuse the preceding reader, who doesn't expect changes
        if ((dwFlags & TF_ES_WRITE) && !(_dwEditSessionFlags & TF_ES_WRITE) ||
            (dwFlags & TF_ES_PROPERTY_WRITE) && !(_dwEditSessionFlags & TF_ES_PROPERTY_WRITE))
        {
            if (!(dwFlags & TF_ES_SYNC))
            {
                // request is TS_ES_ASYNCDONTCARE, so we'll make it async to recover
                fForceAsync = TRUE;
                goto QueueItem;
            }

            Assert(0);
            return TF_E_LOCKED;
        }

        // only allow reentrant write locks for the same tip
        if ((dwFlags & (TF_ES_WRITE | TF_ES_PROPERTY_WRITE)) && _tidInEditSession != tid)
        {
            Assert(0);
            return TF_E_LOCKED;
        }

        dwEditSessionFlagsOrg = _dwEditSessionFlags;
        // adjust read/write access for inner es
        _dwEditSessionFlags = (_dwEditSessionFlags & ~TF_ES_ALL_ACCESS_BITS) | (dwFlags & TF_ES_ALL_ACCESS_BITS);

        // ok, do it
        *phrSession = pes->DoEditSession(_ec);

        _dwEditSessionFlags = dwEditSessionFlagsOrg;

        return S_OK;
    }

QueueItem:
    //
    // Don't queue the write lock item when the doc is read only.
    //
    if (dwFlags & TF_ES_WRITE) 
    {
        TS_STATUS dcs;
        if (SUCCEEDED(GetStatus(&dcs)))
        {
            if (dcs.dwDynamicFlags & TF_SD_READONLY)
            {
                *phrSession = TS_E_READONLY;
                return S_OK;
            }
        }
    }

    item.pfnCallback = _EditSessionQiCallback;
    item.dwFlags = dwFlags;
    item.state.es.tid = tid;
    item.state.es.pes = pes;

    return _QueueItem(&item, fForceAsync, phrSession);
}

//+---------------------------------------------------------------------------
//
// _EditSessionQiCallback
//
//----------------------------------------------------------------------------

/* static */
HRESULT CInputContext::_EditSessionQiCallback(CInputContext *pic, TS_QUEUE_ITEM *pItem, QiCallbackCode qiCode)
{
    HRESULT hr = S_OK;

    //
    // #489905
    //
    // we can not call sink anymore after DLL_PROCESS_DETACH.
    //
    if (DllShutdownInProgress())
        return hr;

    //
    // #507366
    //
    // Random AV happens with SPTIP's edit session.
    // #507366 might be fixed by #371798 (sptip). However it is nice to
    // have a pointer checking and protect the call by an exception handler.
    //
    if (!pItem->state.es.pes)
        return E_FAIL;

    switch (qiCode)
    {
        case QI_ADDREF:
            //
            // #507366
            //
            // Random AV happens with SPTIP's edit session.
            // #507366 might be fixed by #371798 (sptip). However it is nice to
            // have a pointer checking and protect the call by an exception 
            // handler.
            //
            _try {
                pItem->state.es.pes->AddRef();
            }
            _except(1) {
                Assert(0);
            }
            break;

        case QI_DISPATCH:
            hr = pic->_DoEditSession(pItem->state.es.tid, pItem->state.es.pes, pItem->dwFlags);
            break;

        case QI_FREE:
            //
            // #507366
            //
            // Random AV happens with SPTIP's edit session.
            // #507366 might be fixed by #371798 (sptip). However it is nice to
            // have a pointer checking and protect the call by an exception 
            // handler.
            //
            _try {
                pItem->state.es.pes->Release();
            }
            _except(1) {
                Assert(0);
            }
            break;

        default:
            Assert(0);
    }

    return hr;
}

//+---------------------------------------------------------------------------
//
// _PseudoSyncEditSessionQiCallback
//
//----------------------------------------------------------------------------

/* static */
HRESULT CInputContext::_PseudoSyncEditSessionQiCallback(CInputContext *_this, TS_QUEUE_ITEM *pItem, QiCallbackCode qiCode)
{
    HRESULT hr;
    DWORD      dwEditSessionFlags;
    TfClientId tidInEditSession;

    if (qiCode != QI_DISPATCH)
        return S_OK; // we can skip QI_ADDREF, QI_FREE since everything is synchronous/on the stack

    hr = S_OK;

    //
    // hook up fake ec here!
    //
    // NB: this code is very similar to _DoEditSession
    // make sure the logic stays consistent

    if (_this->_dwEditSessionFlags & TF_ES_INEDITSESSION)
    {
        Assert((TF_ES_WRITE & _this->_dwEditSessionFlags) ||
                !(TF_ES_WRITE & pItem->dwFlags));

        dwEditSessionFlags = _this->_dwEditSessionFlags;
        tidInEditSession = _this->_tidInEditSession;
    }
    else
    {
        dwEditSessionFlags = _this->_dwEditSessionFlags & ~TF_ES_ALL_ACCESS_BITS;
        tidInEditSession = TF_CLIENTID_NULL;
    }

    _this->_dwEditSessionFlags |= (TF_ES_INEDITSESSION | (pItem->dwFlags & TF_ES_ALL_ACCESS_BITS));
    _this->_tidInEditSession = g_gaSystem;

    //
    // dispatch
    //
    switch (pItem->state.pes.uCode)
    {
        case PSEUDO_ESCB_TERMCOMPOSITION:
            _this->_TerminateCompositionWithLock((ITfCompositionView *)pItem->state.pes.pvState, _this->_ec);
            break;

        case PSEUDO_ESCB_UPDATEKEYEVENTFILTER:
            _this->_UpdateKeyEventFilterCallback(_this->_ec);
            break;

        case PSEUDO_ESCB_GROWRANGE:
            GrowEmptyRangeByOneCallback(_this->_ec, (ITfRange *)pItem->state.pes.pvState);
            break;

        case PSEUDO_ESCB_BUILDOWNERRANGELIST:
            {
            BUILDOWNERRANGELISTQUEUEINFO *pbirl;
            pbirl = (BUILDOWNERRANGELISTQUEUEINFO *)(pItem->state.pes.pvState);
            pbirl->pFunc->BuildOwnerRangeListCallback(_this->_ec, _this, pbirl->pRange);
            }
            break;

        case PSEUDO_ESCB_SHIFTENDTORANGE:
            {
            SHIFTENDTORANGEQUEUEITEM *pqItemSER;
            pqItemSER = (SHIFTENDTORANGEQUEUEITEM*)(pItem->state.pes.pvState);
            pqItemSER->pRange->ShiftEndToRange(_this->_ec, pqItemSER->pRangeTo, pqItemSER->aPos);
            }
            break;

        case PSEUDO_ESCB_GETSELECTION:
            {
            GETSELECTIONQUEUEITEM *pqItemGS;
            pqItemGS = (GETSELECTIONQUEUEITEM *)(pItem->state.pes.pvState);
            GetSelectionSimple(_this->_ec, _this, pqItemGS->ppRange);
            break;
            }
            break;

        case PSEUDO_ESCB_SERIALIZE_ACP:
        {
            SERIALIZE_ACP_PARAMS *pParams = (SERIALIZE_ACP_PARAMS *)(pItem->state.pes.pvState);

            hr = pParams->pWrap->_Serialize(pParams->pProp, pParams->pRange, pParams->pHdr, pParams->pStream);

            break;
        }

        case PSEUDO_ESCB_SERIALIZE_ANCHOR:
        {
            SERIALIZE_ANCHOR_PARAMS *pParams = (SERIALIZE_ANCHOR_PARAMS *)(pItem->state.pes.pvState);

            hr = pParams->pProp->_Serialize(pParams->pRange, pParams->pHdr, pParams->pStream);

            break;
        }

        case PSEUDO_ESCB_UNSERIALIZE_ACP:
        {
            UNSERIALIZE_ACP_PARAMS *pParams = (UNSERIALIZE_ACP_PARAMS *)(pItem->state.pes.pvState);

            hr = pParams->pWrap->_Unserialize(pParams->pProp, pParams->pHdr, pParams->pStream, pParams->pLoaderACP);

            break;
        }

        case PSEUDO_ESCB_UNSERIALIZE_ANCHOR:
        {
            UNSERIALIZE_ANCHOR_PARAMS *pParams = (UNSERIALIZE_ANCHOR_PARAMS *)(pItem->state.pes.pvState);

            hr = pParams->pProp->_Unserialize(pParams->pHdr, pParams->pStream, pParams->pLoader);

            break;
        }

        case PSEUDO_ESCB_GETWHOLEDOCRANGE:
            {
            GETWHOLEDOCRANGE *pqItemGWDR;
            pqItemGWDR = (GETWHOLEDOCRANGE *)(pItem->state.pes.pvState);
            GetRangeForWholeDoc(_this->_ec, _this, pqItemGWDR->ppRange);
            }
            break;
    }

    //
    // notify/cleanup
    //
    if (pItem->dwFlags & (TF_ES_WRITE | TF_ES_PROPERTY_WRITE)) // don't bother if it was read-only
    {
        _this->_NotifyEndEdit();
    }

    if (tidInEditSession == TF_CLIENTID_NULL)
        _this->_IncEditCookie(); // next edit cookie value

    _this->_dwEditSessionFlags = dwEditSessionFlags;
    _this->_tidInEditSession = tidInEditSession;

    return hr;
}

//+---------------------------------------------------------------------------
//
// InWriteSession
//
//----------------------------------------------------------------------------

STDAPI CInputContext::InWriteSession(TfClientId tid, BOOL *pfWriteSession)
{
    if (pfWriteSession == NULL)
        return E_INVALIDARG;

    *pfWriteSession = (_dwEditSessionFlags & TF_ES_INEDITSESSION) &&
                      (_tidInEditSession == tid) &&
                      (_dwEditSessionFlags & (TF_ES_WRITE | TF_ES_PROPERTY_WRITE));

    Assert(!*pfWriteSession || tid != TF_CLIENTID_NULL); // should never return TRUE for TFCLIENTID_NULL
                                                         // _tidInEditSession shouldn't be NULL if _dwEditSessionFlags & TF_ES_INEDITSESSION

    return S_OK;
}

//+---------------------------------------------------------------------------
//
// _DoEditSession
//
//----------------------------------------------------------------------------

HRESULT CInputContext::_DoEditSession(TfClientId tid, ITfEditSession *pes, DWORD dwFlags)
{
    HRESULT hr;

    // NB: this code is very similar to _PseudoSyncEditSessionQiCallback
    // make sure the logic stays consistent

    Assert(!(_dwEditSessionFlags & TF_ES_INEDITSESSION)); // shouldn't get this far
    Assert(_tidInEditSession == TF_CLIENTID_NULL || _tidInEditSession == g_gaApp); // there should never be another session in progress -- this is not a reentrant func

    _dwEditSessionFlags |= (TF_ES_INEDITSESSION | (dwFlags & TF_ES_ALL_ACCESS_BITS));

    _tidInEditSession = tid;

    //
    // #507366
    //
    // Random AV happens with SPTIP's edit session.
    // #507366 might be fixed by #371798 (sptip). However it is nice to
    // have a pointer checking and protect the call by an exception 
    // handler.
    //
    _try {
        hr = pes->DoEditSession(_ec);
    }
    _except(1) {
        hr = E_FAIL;
    }

    // app won't notify us about our own lock release, so do it manually
    if (dwFlags & (TF_ES_WRITE | TF_ES_PROPERTY_WRITE)) // don't bother if it was read-only
    {
        _NotifyEndEdit();
    }

    _IncEditCookie(); // next edit cookie value
    _dwEditSessionFlags &= ~(TF_ES_INEDITSESSION | TF_ES_ALL_ACCESS_BITS);
    _tidInEditSession = TF_CLIENTID_NULL;

    return hr;
}

//+---------------------------------------------------------------------------
//
// _NotifyEndEdit
//
// Returns TRUE iff there were changes.
//----------------------------------------------------------------------------

BOOL CInputContext::_NotifyEndEdit(void)
{
    CRange *pRange;
    CProperty *prop;
    int i;
    int cTextSpans;
    SPAN *pSpan;
    CSpanSet *pssText;
    CSpanSet *pssProperty;
    DWORD dwOld;
    CStructArray<GENERICSINK> *prgSinks;
    BOOL fChanges = FALSE;

    if (!_IsConnected())
        return FALSE; // we've been disconnected, nothing to notify

    if (!EnsureEditRecord())
        return FALSE; // low mem.

    if (_pEditRecord->_GetSelectionStatus())
    {
        // we let keystroke manager to update _gaKeyEventFilterTIP
        // since selection was changed.
        _fInvalidKeyEventFilterTIP = TRUE;
    }

    // only allow read locks during the notification
    // if we're in an edit session, keep using the same lock
    _dwEditSessionFlags |= TF_ES_INNOTIFY;

    pssText = _pEditRecord->_GetTextSpanSet();
    cTextSpans = pssText->GetCount();

    // if we are not in the edit session, we need to make
    // _PropertyTextUpdate.  The app has clobbered some text.
    if (!(_dwEditSessionFlags & TF_ES_INEDITSESSION))
    {
        pSpan = pssText->GetSpans();

        for (i = 0; i < cTextSpans; i++)
        {
            _PropertyTextUpdate(pSpan->dwFlags, pSpan->paStart, pSpan->paEnd);
            pSpan++;
        }
    }

    // do the ITfRangeChangeSink::OnChange notifications
    if (cTextSpans > 0)
    {
        fChanges = TRUE;

        for (pRange = _pOnChangeRanges; pRange != NULL; pRange = pRange->_GetNextOnChangeRangeInIcsub())
        {
            if (!pRange->_IsDirty())
                continue;

            pRange->_ClearDirty();

            prgSinks = pRange->_GetChangeSinks();
            Assert(prgSinks); // shouldn't be on the list if this is NULL
            Assert(prgSinks->Count() > 0); // shouldn't be on the list if this is 0

            for (i=0; i<prgSinks->Count(); i++)
            {
                ((ITfRangeChangeSink *)prgSinks->GetPtr(i)->pSink)->OnChange((ITfRangeAnchor *)pRange);
            }
        }
    }

    // accumulate the property span sets into _pEditRecord
    for (prop = _pPropList; prop != NULL; prop = prop->_pNext)
    {
        if ((pssProperty = prop->_GetSpanSet()) == NULL ||
            pssProperty->GetCount() == 0)
        {
            continue; // no delta
        }

        fChanges = TRUE;
  
        _pEditRecord->_AddProperty(prop->GetPropGuidAtom(), pssProperty);
    }

    if (!_pEditRecord->_IsEmpty()) // just a perf thing
    {
        // do the OnEndEdit notifications
        prgSinks = _GetTextEditSinks();
        dwOld = _dwEditSessionFlags;
        _dwEditSessionFlags = (TF_ES_READWRITE | TF_ES_PROPERTY_WRITE | TF_ES_INNOTIFY | TF_ES_INEDITSESSION);

        for (i=0; i<prgSinks->Count(); i++)
        {
            ((ITfTextEditSink *)prgSinks->GetPtr(i)->pSink)->OnEndEdit(this, _ec, _pEditRecord);
        }

        _dwEditSessionFlags = dwOld;

        // properties need to either stop referencing their span sets, or reset them
        for (prop = _pPropList; prop != NULL; prop = prop->_pNext)
        {
            prop->_Dbg_AssertNoChangeHistory();

            if ((pssProperty = prop->_GetSpanSet()) == NULL ||
                pssProperty->GetCount() == 0)
            {
                continue; // no delta
            }

            if (_pEditRecord->_SecondRef())
            {
                prop->_ClearSpanSet();
            }
            else
            {
                prop->_ResetSpanSet();
            }
        }

        if (!_pEditRecord->_SecondRef())
        {
            _pEditRecord->_Reset();
        }
        else
        {
            // someone still holds a ref, so need a new edit record
            _pEditRecord->Release();
            _pEditRecord = new CEditRecord(this); // Issue: delay load! Issue: handle out of mem
        }
    }

    // status change sinks
    if (_fStatusChanged)
    {
        _fStatusChanged = FALSE;
        _OnStatusChangeInternal();
    }

    // layout change sinks
    if (_fLayoutChanged)
    {
        _fLayoutChanged = FALSE;

        // for cicero 1, we only support one view
        // eventually we'll need a list of all affected views...not just the default view..and also create/destroy
        TsViewCookie vcActiveView;

        if (_ptsi->GetActiveView(&vcActiveView) == S_OK)
        {
            _OnLayoutChangeInternal(TS_LC_CHANGE, vcActiveView);
        }
        else
        {
            Assert(0); // how did GetActiveView fail?
        }
    }

    // clear the read-only block
    _dwEditSessionFlags &= ~TF_ES_INNOTIFY;

    return fChanges;
}

//+---------------------------------------------------------------------------
//
// OnTextChange
//
// We only get here from ITextStoreAnchorSink.  We don't have a lock!
//----------------------------------------------------------------------------

STDAPI CInputContext::OnTextChange(DWORD dwFlags, IAnchor *paStart, IAnchor *paEnd)
{
    HRESULT hr;
    SPAN *span;

    Assert((dwFlags & ~TS_TC_CORRECTION) == 0);

    if (_IsInEditSession())
    {
        Assert(0); // someone other than cicero is editing the doc while cicero holds a lock
        return TS_E_NOLOCK;
    }

    // record this change
    if ((span = _rgAppTextChanges.Append(1)) == NULL)
        return E_OUTOFMEMORY;

    if (paStart->Clone(&span->paStart) != S_OK || span->paStart == NULL)
        goto ExitError;
    if (paEnd->Clone(&span->paEnd) != S_OK || span->paEnd == NULL)
        goto ExitError;

    span->dwFlags = dwFlags;

    // get a lock eventually so we can deal with the changes
    SafeRequestLock(_ptsi, TS_LF_READ, &hr);

    return S_OK;

ExitError:
    SafeRelease(span->paStart);
    SafeRelease(span->paEnd);
    Assert(_rgAppTextChanges.Count() > 0);
    _rgAppTextChanges.Remove(_rgAppTextChanges.Count()-1, 1);

    return E_FAIL;
}

//+---------------------------------------------------------------------------
//
// _OnTextChangeInternal
//
// Unlike OnTextChange, here we know it's safe to call IAnchor::Compare.
// We either got here from an ITfRange method, or from a wrapped ITextStoreACP.
//----------------------------------------------------------------------------

HRESULT CInputContext::_OnTextChangeInternal(DWORD dwFlags, IAnchor *paStart, IAnchor *paEnd, AnchorOwnership ao)
{
    Assert((dwFlags & ~TS_TC_CORRECTION) == 0);

    if (!EnsureEditRecord())
        return E_OUTOFMEMORY;

    // track the delta
    _pEditRecord->_GetTextSpanSet()->Add(dwFlags, paStart, paEnd, ao);

    // mark any appropriate ranges dirty
    // perf: do this after the edit session ends!  fewer calls that way...
    _MarkDirtyRanges(paStart, paEnd);

    return S_OK;
}

//+---------------------------------------------------------------------------
//
// OnSelectionChange
//
//----------------------------------------------------------------------------

STDAPI CInputContext::OnSelectionChange()
{
    if (_IsInEditSession())
    {
        Assert(0); // someone other than cicero is editing the doc while cicero holds a lock
        return TS_E_NOLOCK;
    }

    return _OnSelectionChangeInternal(TRUE);
}

//+---------------------------------------------------------------------------
//
// _OnSelectionChangeInternal
//
//----------------------------------------------------------------------------

HRESULT CInputContext::_OnSelectionChangeInternal(BOOL fAppChange)
{
    HRESULT hr;

    if (!EnsureEditRecord())
        return E_OUTOFMEMORY;

    _pEditRecord->_SetSelectionStatus();

    if (fAppChange) // perf: could we use _fLockHeld and do away with the fAppChange param?
    {
        // get a lock eventually so we can deal with the changes
        SafeRequestLock(_ptsi, TS_LF_READ, &hr);
    }

    return S_OK;
}

//+---------------------------------------------------------------------------
//
// OnLockGranted
//
//----------------------------------------------------------------------------

STDAPI CInputContext::OnLockGranted(DWORD dwLockFlags)
{
    BOOL fAppChangesSent;
    BOOL fAppCall;
    HRESULT hr;

    if ((dwLockFlags & ~(TS_LF_SYNC | TS_LF_READWRITE)) != 0)
    {
        Assert(0); // bogus dwLockFlags param
        return E_INVALIDARG;
    }
    if ((dwLockFlags & TS_LF_READWRITE) == 0)
    {
        Assert(0); // bogus dwLockFlags param
        return E_INVALIDARG;
    }

#ifdef DEBUG
    // we don't really need to check for reentrancy since
    // the app is not supposed to call back into us, but
    // why not be paranoid?
    // Issue: for robustness, do something in retail
    Assert(!_dbg_fInOnLockGranted) // no reentrancy
    _dbg_fInOnLockGranted = TRUE;
#endif // DEBUG

    fAppChangesSent = FALSE;
    fAppCall = FALSE;

    if (_fLockHeld == FALSE)
    {
        fAppCall = TRUE;
        _fLockHeld = TRUE;
        _dwlt = dwLockFlags;

        fAppChangesSent = _SynchAppChanges(dwLockFlags);
    }

    // hr will hold result of any synch queue item, need to return this!
    hr = _EmptyLockQueue(dwLockFlags, fAppChangesSent);

    if (fAppCall)
    {
        _fLockHeld = FALSE;
    }

#ifdef DEBUG
    _dbg_fInOnLockGranted = FALSE;
#endif // DEBUG

    return hr;
}

//+---------------------------------------------------------------------------
//
// _SynchAppChanges
//
//----------------------------------------------------------------------------

BOOL CInputContext::_SynchAppChanges(DWORD dwLockFlags)
{
    TfClientId tidInEditSessionOrg;
    int i;
    SPAN *span;
    BOOL fAppChangesSent;

    if (!EnsureEditRecord())
        return FALSE;

    // check for cached app text changes
    for (i=0; i<_rgAppTextChanges.Count(); i++)
    {
        span = _rgAppTextChanges.GetPtr(i);

        // track the delta
        // NB: Add takes ownership of anchors here!  So we don't release them...
        _pEditRecord->_GetTextSpanSet()->Add(span->dwFlags, span->paStart, span->paEnd, OWN_ANCHORS);

        // mark any appropriate ranges dirty
        _MarkDirtyRanges(span->paStart, span->paEnd);
    }
    // all done with the app changes!
    _rgAppTextChanges.Clear();

    // at this point ranges with TF_GRAVITY_FORWARD, TF_GRAVITY_BACKWARD could
    // have crossed anchors (this can only happen in response to app changes,
    // so we check here instead of in _NotifyEndEdit, which can be called after
    // a SetText, etc.).  We track this with a lazy test in the range obj
    // based on an id.
    if (++_dwLastLockReleaseID == 0xffffffff)
    {
        Assert(0); // Issue: need code here to handle wrap-around, prob. need to notify all range objects
    }

    // deal with any app changes, need to send notifications
    // theoretically, we only need to make this call when _tidInEditSession == TF_CLIENTID_NULL
    // (not inside _DoEditSession, a call from the app) but we'll make it anyways to deal with app bugs
    // App bug: if the app has pending changes but grants a synchronous lock, we'll announce the changes
    // here even though we're in an edit session, then return error below...
    tidInEditSessionOrg = _tidInEditSession;
    _tidInEditSession = g_gaApp;

    fAppChangesSent = _NotifyEndEdit();

    _tidInEditSession = tidInEditSessionOrg;

    return fAppChangesSent;
}

//+---------------------------------------------------------------------------
//
// ITfContextOwnerServices::OnLayoutChange
//
//----------------------------------------------------------------------------

STDAPI CInputContext::OnLayoutChange()
{
    // the default impl always has just one view,
    // so specify it directly
    return OnLayoutChange(TS_LC_CHANGE, TSI_ACTIVE_VIEW_COOKIE);
}

//+---------------------------------------------------------------------------
//
// IDocCommonSinkAnchor::OnLayoutChange
//
//----------------------------------------------------------------------------

STDAPI CInputContext::OnLayoutChange(TsLayoutCode lcode, TsViewCookie vcView)
{
    HRESULT hr;

    _fLayoutChanged = TRUE;

    // for now (cicero 1), ignoring views other than the default!
    // todo: need to keep a list of all affected views

    if (!_fLockHeld) // might hold lock if ic owner is making modifications
    {
        // get a lock eventually so we can deal with the changes
        SafeRequestLock(_ptsi, TS_LF_READ, &hr);
    }

    return S_OK;
}

//+---------------------------------------------------------------------------
//
// OnStatusChange
//
//----------------------------------------------------------------------------

STDAPI CInputContext::OnStatusChange(DWORD dwFlags)
{
    HRESULT hr;

    _fStatusChanged = TRUE;
    _dwStatusChangedFlags |= dwFlags;

    if (!_fLockHeld) // might hold lock if ic owner is making modifications
    {
        // get a lock eventually so we can deal with the changes
        SafeRequestLock(_ptsi, TS_LF_READ, &hr);
    }

    return S_OK;
}

//+---------------------------------------------------------------------------
//
// OnAttrsChange
//
//----------------------------------------------------------------------------

STDAPI CInputContext::OnAttrsChange(IAnchor *paStart, IAnchor *paEnd, ULONG cAttrs, const TS_ATTRID *paAttrs)
{
    CSpanSet *pss;
    ULONG i;
    TfGuidAtom gaType;
    HRESULT hr;

    //
    // Issue: need to delay any work until we have a lock!, just like text deltas
    //

    // paStart, paEnd can be NULL if both are NULL -> whole doc
    if ((paStart == NULL && paEnd != NULL) ||
        (paStart != NULL && paEnd == NULL))
    {
        return E_INVALIDARG;
    }

    if (cAttrs == 0)
        return S_OK;

    if (paAttrs == NULL)
        return E_INVALIDARG;

    if (!EnsureEditRecord())
        return E_OUTOFMEMORY;

    // record the change
    for (i=0; i<cAttrs; i++)
    {
        if (MyRegisterGUID(paAttrs[i], &gaType) != S_OK)
            continue;

        if (pss = _pEditRecord->_FindCreateAppAttr(gaType))
        {
            pss->Add(0, paStart, paEnd, COPY_ANCHORS);
        }
    }

    if (!_fLockHeld) // might hold lock if ic owner is making modifications
    {
        // get a lock eventually so we can deal with the changes
        SafeRequestLock(_ptsi, TS_LF_READ, &hr);
    }

    return S_OK;
}

//+---------------------------------------------------------------------------
//
// OnAttributeChange
//
// Called when sys attr changes for cicero default tsi.
//----------------------------------------------------------------------------

HRESULT CInputContext::OnAttributeChange(REFGUID rguidAttr)
{
    return OnAttrsChange(NULL, NULL, 1, &rguidAttr);
}

//+---------------------------------------------------------------------------
//
// OnStartEditTransaction
//
//----------------------------------------------------------------------------

STDAPI CInputContext::OnStartEditTransaction()
{
    int i;
    CStructArray<GENERICSINK> *prgSinks;

    if (_cRefEditTransaction++ > 0)
        return S_OK;

    prgSinks = _GetEditTransactionSink();

    for (i=0; i<prgSinks->Count(); i++)
    {
        ((ITfEditTransactionSink *)prgSinks->GetPtr(i)->pSink)->OnStartEditTransaction(this);
    }

    return S_OK;
}

//+---------------------------------------------------------------------------
//
// OnEndEditTransaction
//
//----------------------------------------------------------------------------

STDAPI CInputContext::OnEndEditTransaction()
{
    int i;
    CStructArray<GENERICSINK> *prgSinks;

    if (_cRefEditTransaction <= 0)
    {
        Assert(0); // bogus ref count
        return E_UNEXPECTED;
    }

    if (_cRefEditTransaction > 1)
        goto Exit;

    prgSinks = _GetEditTransactionSink();

    for (i=0; i<prgSinks->Count(); i++)
    {
        ((ITfEditTransactionSink *)prgSinks->GetPtr(i)->pSink)->OnEndEditTransaction(this);
    }

Exit:
    // dec the ref to 0 last, to prevent reentrancy
    _cRefEditTransaction--;

    return S_OK;
}

//+---------------------------------------------------------------------------
//
// _OnLayoutChangeInternal
//
//----------------------------------------------------------------------------

HRESULT CInputContext::_OnLayoutChangeInternal(TsLayoutCode lcode, TsViewCookie vcView)
{
    DWORD dwOld;
    CStructArray<GENERICSINK> *prgSinks;
    int i;
    ITfContextView *pView = NULL; // compiler "uninitialized var" warning

    // xlate the view
    GetActiveView(&pView); // when we support multiple views, need to actually use vcView
    if (pView == NULL)
        return E_OUTOFMEMORY;

    // only allow read locks during the notification
    // we might have the read-only bit set already, so save the
    // old value
    dwOld = _dwEditSessionFlags;
    _dwEditSessionFlags |= TF_ES_INNOTIFY;

    prgSinks = _GetTextLayoutSinks();

    for (i=0; i<prgSinks->Count(); i++)
    {
        ((ITfTextLayoutSink *)prgSinks->GetPtr(i)->pSink)->OnLayoutChange(this, (TfLayoutCode)lcode, pView);
    }

    pView->Release();

    // clear the read-only block
    _dwEditSessionFlags = dwOld;

    return S_OK;
}

//+---------------------------------------------------------------------------
//
// _OnStatusChangeInternal
//
//----------------------------------------------------------------------------

HRESULT CInputContext::_OnStatusChangeInternal()
{
    DWORD dwOld;
    CStructArray<GENERICSINK> *prgSinks;
    int i;

    Assert((_dwEditSessionFlags & TF_ES_INEDITSESSION) == 0); // we must never hold a lock when we do the callbacks

    // only allow read locks during the notification
    // we might have the read-only bit set already, so save the
    // old value
    dwOld = _dwEditSessionFlags;
    _dwEditSessionFlags |= TF_ES_INNOTIFY;

    prgSinks = _GetStatusSinks();

    for (i=0; i<prgSinks->Count(); i++)
    {
        ((ITfStatusSink *)prgSinks->GetPtr(i)->pSink)->OnStatusChange(this, _dwStatusChangedFlags);
    }

    _dwStatusChangedFlags = 0;

    // clear the read-only block
    _dwEditSessionFlags = dwOld;

    return S_OK;
}

//+---------------------------------------------------------------------------
//
// Serialize
//
//----------------------------------------------------------------------------

STDAPI CInputContext::Serialize(ITfProperty *pProp, ITfRange *pRange, TF_PERSISTENT_PROPERTY_HEADER_ANCHOR *pHdr, IStream *pStream)
{
    SERIALIZE_ANCHOR_PARAMS params;
    HRESULT hr;
    CProperty *pPropP;
    CRange *pCRange;

    if ((pCRange = GetCRange_NA(pRange)) == NULL)
        return E_INVALIDARG;

    if (!VerifySameContext(this, pCRange))
        return E_INVALIDARG;

    if ((pPropP = GetCProperty(pProp)) == NULL)
        return E_INVALIDARG;

    params.pProp = pPropP;
    params.pRange = pCRange;
    params.pHdr = pHdr;
    params.pStream = pStream;

    hr = S_OK;

    // need a sync read lock to do our work
    if (_DoPseudoSyncEditSession(TF_ES_READ, PSEUDO_ESCB_SERIALIZE_ANCHOR, &params, &hr) != S_OK)
    {
        Assert(0); // app won't give us a sync read lock
        hr = E_FAIL;
    }

    SafeRelease(pPropP);
    return hr;
}

//+---------------------------------------------------------------------------
//
// Unserialize
//
//----------------------------------------------------------------------------

STDAPI CInputContext::Unserialize(ITfProperty *pProp, const TF_PERSISTENT_PROPERTY_HEADER_ANCHOR *pHdr, IStream *pStream, ITfPersistentPropertyLoaderAnchor *pLoader)
{
    CProperty *pPropP;
    UNSERIALIZE_ANCHOR_PARAMS params;
    HRESULT hr;

    if ((pPropP = GetCProperty(pProp)) == NULL)
        return E_INVALIDARG;

    params.pProp = pPropP;
    params.pHdr = pHdr;
    params.pStream = pStream;
    params.pLoader = pLoader;

    // need a sync read lock to do our work
    if (_DoPseudoSyncEditSession(TF_ES_READ, PSEUDO_ESCB_UNSERIALIZE_ANCHOR, &params, &hr) != S_OK)
    {
        Assert(0); // app won't give us a sync read lock
        return E_FAIL;
    }

    return hr;
}

//+---------------------------------------------------------------------------
//
// ForceLoadProperty
//
//----------------------------------------------------------------------------

STDAPI CInputContext::ForceLoadProperty(ITfProperty *pProp)
{
    CProperty *pPropP;
    HRESULT hr;

    if ((pPropP = GetCProperty(pProp)) == NULL)
        return E_INVALIDARG;

    hr = pPropP->ForceLoad();

    pPropP->Release();

    return hr;
}

//+---------------------------------------------------------------------------
//
// _MarkDirtyRanges
//
//----------------------------------------------------------------------------

void CInputContext::_MarkDirtyRanges(IAnchor *paStart, IAnchor *paEnd)
{
    CRange *range;
    IAnchor *paRangeStart;
    IAnchor *paRangeEnd;
    DWORD dwHistory;
    BOOL fDirty;

    // we're only interested in ranges that have notification sinks
    // perf: it would be cool avoid checking ranges based on some ordering scheme....
    for (range = _pOnChangeRanges; range != NULL; range = range->_GetNextOnChangeRangeInIcsub())
    {
        if (range->_IsDirty())
            continue;

        fDirty = FALSE;
        paRangeStart = range->_GetStart();
        paRangeEnd = range->_GetEnd();

        // check BOTH anchors for deletions -- need to clear both
        // no matter what
        if (paRangeStart->GetChangeHistory(&dwHistory) == S_OK &&
            (dwHistory & TS_CH_FOLLOWING_DEL))
        {
            paRangeStart->ClearChangeHistory();
            fDirty = TRUE;
        }
        if (paRangeEnd->GetChangeHistory(&dwHistory) == S_OK &&
            (dwHistory & TS_CH_PRECEDING_DEL))
        {
            paRangeEnd->ClearChangeHistory();
            fDirty = TRUE;
        }

        // even if no anchors collapsed, the range may overlap a delta
        if (!fDirty)
        {
            if (CompareAnchors(paRangeEnd, paStart) > 0 &&
                CompareAnchors(paRangeStart, paEnd) < 0)
            {
                fDirty = TRUE;
            }
        }

        if (fDirty)
        {
            range->_SetDirty();
        }
    }
}

//+---------------------------------------------------------------------------
//
// UpdateKeyEventFilter
//
//----------------------------------------------------------------------------

void CInputContext::_UpdateKeyEventFilter()
{
    HRESULT hr;

    // Our cache _gaKeyEventFilterTTIP is valid so just return TRUE.
    if (!_fInvalidKeyEventFilterTIP)
        return;

    _gaKeyEventFilterTIP[0] = TF_INVALID_GUIDATOM;
    _gaKeyEventFilterTIP[1] = TF_INVALID_GUIDATOM;

    if (_DoPseudoSyncEditSession(TF_ES_READ, 
                                 PSEUDO_ESCB_UPDATEKEYEVENTFILTER, 
                                 NULL, 
                                 &hr) != S_OK || hr != S_OK)
    {
        //
        // Isn't application ready to give lock?
        //
        Assert(0);
    }
}


//+---------------------------------------------------------------------------
//
// _UpdateKeyEventFilterCallback
//
//----------------------------------------------------------------------------

HRESULT CInputContext::_UpdateKeyEventFilterCallback(TfEditCookie ec)
{
    TF_SELECTION sel;
    ULONG cFetched;
    BOOL fEmpty;

    // perf: we don't really need to create a range here, we just want the anchors
    if (GetSelection(ec, TF_DEFAULT_SELECTION, 1, &sel, &cFetched) == S_OK && cFetched == 1)
    {
        HRESULT hr;
        BOOL bRightSide= TRUE;
        BOOL bLeftSide= TRUE;

        //
        // If the current selection is not empty, we just interested in
        // the caret position.
        //
        hr = sel.range->IsEmpty(ec, &fEmpty);
        if ((hr == S_OK) && !fEmpty)
        {
            if (sel.style.ase == TF_AE_START)
            {
                hr = sel.range->ShiftEndToRange(ec,
                                                sel.range, 
                                                TF_ANCHOR_START);
                bRightSide = FALSE;
            }
            else if (sel.style.ase == TF_AE_END)
            {
                hr = sel.range->ShiftStartToRange(ec,
                                                  sel.range, 
                                                  TF_ANCHOR_END);
                bLeftSide = FALSE;
            }
        }

        if (SUCCEEDED(hr))
        {
            if (_pPropTextOwner)
            {
                CRange *pPropRange;
                CRange *pSelRange = GetCRange_NA(sel.range);
                Assert(pSelRange != NULL); // we just created this guy

                if (bRightSide)
                {
                    //
                    // Find the right side owner of sel.
                    // try the start edge of the property so fEnd is FALSE.
                    //
                    if (_pPropTextOwner->_InternalFindRange(pSelRange, 
                                                                   &pPropRange, 
                                                                   TF_ANCHOR_END, 
                                                                   FALSE) == S_OK)
                    {
                        VARIANT var;

                        if (_pPropTextOwner->GetValue(ec, (ITfRangeAnchor *)pPropRange, &var) == S_OK)
                        {
                            IAnchor *paEnd;
                            CRange *pCRangeSel;

                            Assert(var.vt == VT_I4);

                            _gaKeyEventFilterTIP[LEFT_FILTERTIP] = (TfGuidAtom)var.lVal;
                            // don't need to VariantClear because it's VT_I4

                            //
                            // If the end of this proprange is left side of
                            // the caret, the left side owner will be same.
                            // so we don't have to find left proprange then.
                            //
                            paEnd = pPropRange->_GetEnd();
                            if (paEnd && (pCRangeSel = GetCRange_NA(sel.range)))
                            {
                                if (CompareAnchors(paEnd, pCRangeSel->_GetStart()) > 0)
                                    bLeftSide = FALSE;
                            }
                        }
                        pPropRange->Release();
                    }
                }

                if (bLeftSide)
                {
                    //
                    // Find the left side owner of sel.
                    // try the end edge of the property so fEnd is TRUE.
                    //
                    if (_pPropTextOwner->_InternalFindRange(pSelRange, 
                                                                   &pPropRange, 
                                                                   TF_ANCHOR_START, 
                                                                   TRUE) == S_OK)
                    {
                        VARIANT var;

                        if (_pPropTextOwner->GetValue(ec, (ITfRangeAnchor *)pPropRange, &var) == S_OK)
                        {
                            Assert(var.vt == VT_I4);

                            if (_gaKeyEventFilterTIP[LEFT_FILTERTIP] != (TfGuidAtom)var.lVal)
                            {
                                _gaKeyEventFilterTIP[RIGHT_FILTERTIP] = (TfGuidAtom)var.lVal;
                            }
                            // don't need to VariantClear because it's VT_I4
                        }
                        pPropRange->Release();
                    }
                }
            }
        }
        sel.range->Release();
    }

    _fInvalidKeyEventFilterTIP = FALSE;

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\ctf\uim\transmit.h ===
//
// transmit.h
//

#ifndef TRANSMIT_H
#define TRANSMIT_H


#define POINTER_ALIGN( pStuff, cAlign ) \
      pStuff = (unsigned char *)((ULONG_PTR)((pStuff) + (cAlign)) & ~ (cAlign))

#define LENGTH_ALIGN( Length, cAlign ) \
            Length = (((Length) + (cAlign)) & ~ (cAlign))


ULONG Cic_HBITMAP_UserSize (HBITMAP * pHBitmap, HBITMAP * pHBitmap_2 = NULL);
BYTE *Cic_HBITMAP_UserMarshal(BYTE *pBuffer, BYTE *pBufferEnd, HBITMAP *pHBitmap, HBITMAP *pHBitmap_2 = NULL);
BYTE *Cic_HBITMAP_UserUnmarshal(BYTE *pBuffer, HBITMAP *pHBitmap, HBITMAP *pHBitmap_2 = NULL);
void Cic_HBITMAP_UserFree(HBITMAP *pHBitmap, HBITMAP *pHBitmap_2 = NULL);

ULONG Cic_TF_LBBALLOONINFO_UserSize (TF_LBBALLOONINFO *pInfo);
BYTE *Cic_TF_LBBALLOONINFO_UserMarshal(BYTE *pBuffer, TF_LBBALLOONINFO *pInfo);
HRESULT Cic_TF_LBBALLOONINFO_UserUnmarshal(BYTE *pBuffer, TF_LBBALLOONINFO  *pInfo);
void Cic_TF_LBBALLOONINFO_UserFree(TF_LBBALLOONINFO *pInfo);

ULONG Cic_HICON_UserSize (HICON * pHBitmap);
BYTE *Cic_HICON_UserMarshal(BYTE *pBuffer, BYTE *pBufferEnd, HICON *pHBitmap);
BYTE *Cic_HICON_UserUnmarshal(BYTE *pBuffer, HICON  *pHBitmap);
void Cic_HICON_UserFree(HICON *pHBitmap);

#endif // TRANSMIT_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\ctf\uim\tsdo.cpp ===
//
// sdo.cpp
//

#include "private.h"
#include "tsdo.h"
#include "helpers.h"

//////////////////////////////////////////////////////////////////////////////
//
// CTFDataObject
//
//////////////////////////////////////////////////////////////////////////////

//+---------------------------------------------------------------------------
//
// IUnknown
//
//----------------------------------------------------------------------------

STDAPI CTFDataObject::QueryInterface(REFIID riid, void **ppvObj)
{
    *ppvObj = NULL;

    if (IsEqualIID(riid, IID_IUnknown) ||
        IsEqualIID(riid, IID_IDataObject))
    {
        *ppvObj = SAFECAST(this, IDataObject *);
    }

    if (*ppvObj)
    {
        AddRef();
        return S_OK;
    }

    return E_NOINTERFACE;
}

STDAPI_(ULONG) CTFDataObject::AddRef()
{
    return ++_cRef;
}

STDAPI_(ULONG) CTFDataObject::Release()
{
    long cr;

    cr = --_cRef;
    Assert(cr >= 0);

    if (cr == 0)
    {
        delete this;
    }

    return cr;
}

//+---------------------------------------------------------------------------
//
// ctor
//
//----------------------------------------------------------------------------

CTFDataObject::CTFDataObject()
{
    Dbg_MemSetThisName(TEXT("CTFDataObject"));

    memset(&_fe, 0, sizeof(_fe));
    memset(&_sm, 0, sizeof(_sm));
    _cRef = 1;
}

//+---------------------------------------------------------------------------
//
// dtor
//
//----------------------------------------------------------------------------

CTFDataObject::~CTFDataObject()
{
    ReleaseStgMedium(&_sm);
}

//+---------------------------------------------------------------------------
//
// GetData
//
//----------------------------------------------------------------------------

STDAPI CTFDataObject::GetData(FORMATETC *pfe, STGMEDIUM *psm)
{
    WCHAR *pch;
    ULONG cch;

    if (pfe == NULL || psm == NULL)
        return E_INVALIDARG;

    // verify the formatetc -- Issue: use QueryGetData
    if (pfe->cfFormat != _fe.cfFormat)
        return DV_E_FORMATETC;
    // Issue: ignoring ptd
    if (pfe->dwAspect != _fe.dwAspect)
        return DV_E_DVASPECT;
    if (pfe->lindex != _fe.lindex)
        return DV_E_LINDEX;
    if (!(pfe->tymed & _fe.lindex))
        return DV_E_TYMED;

    Assert(_fe.tymed == _sm.tymed);

    // allocate the medium
    if ((pfe->tymed & _fe.lindex) == TYMED_HGLOBAL)
    {
        switch (pfe->cfFormat)
        {
            case CF_UNICODETEXT:
                pch = (WCHAR *)GlobalLock(_sm.hGlobal);
                if (pch)
                {
                    cch = wcslen(pch) + 1; // include the '\0'

                    if ((psm->hGlobal = GlobalAlloc(GMEM_FIXED, cch*sizeof(WCHAR))) == NULL)
                    {
                        GlobalUnlock(_sm.hGlobal);
                        return STG_E_MEDIUMFULL;
                    }

                    memcpy(psm->hGlobal, pch, cch*sizeof(WCHAR));
                    GlobalUnlock(_sm.hGlobal);
                }

                psm->tymed = TYMED_HGLOBAL;

                psm->pUnkForRelease = NULL; // caller must GlobalFree
                break;

            default:
                Assert(0); // shouldn't have let anyone SetData with something we can't handle
                break;
        }
    }
    else
    {
        Assert(0); // shouldn't have let anyone SetData with something we can't handle
    }

    return S_OK;
}

//+---------------------------------------------------------------------------
//
// GetDataHere
//
//----------------------------------------------------------------------------

STDAPI CTFDataObject::GetDataHere(FORMATETC *pfe, STGMEDIUM *psm)
{
    return E_NOTIMPL;
}

//+---------------------------------------------------------------------------
//
// QueryGetData
//
//----------------------------------------------------------------------------

STDAPI CTFDataObject::QueryGetData(FORMATETC *pfe)
{
    if (pfe == NULL)
        return E_INVALIDARG;

    // verify the formatetc
    if (pfe->cfFormat != _fe.cfFormat)
        return DV_E_FORMATETC;
    // Issue: ignoring ptd
    if (pfe->dwAspect != _fe.dwAspect)
        return DV_E_DVASPECT;
    if (pfe->lindex != _fe.lindex)
        return DV_E_LINDEX;
    if (!(pfe->tymed & _fe.lindex))
        return DV_E_TYMED;

    return S_OK;
}

//+---------------------------------------------------------------------------
//
// GetCanonicalFormatEtc
//
//----------------------------------------------------------------------------

STDAPI CTFDataObject::GetCanonicalFormatEtc(FORMATETC *pfeIn, FORMATETC *pfeOut)
{
    return E_NOTIMPL;
}

//+---------------------------------------------------------------------------
//
// SetData
//
//----------------------------------------------------------------------------

STDAPI CTFDataObject::SetData(FORMATETC *pfe, STGMEDIUM *psm, BOOL fRelease)
{
    Assert(fRelease == TRUE); // bogus, but for now we don't support copying

    if (pfe == NULL || psm == NULL)
        return E_INVALIDARG;

    if (pfe->tymed != psm->tymed)
        return E_INVALIDARG;

    // free up any storage
    ReleaseStgMedium(&_sm);

    // copy the new stuff
    _fe = *pfe;
    _sm = *psm;

    return S_OK;
}

//+---------------------------------------------------------------------------
//
// EnumFormatEtc
//
//----------------------------------------------------------------------------

STDAPI CTFDataObject::EnumFormatEtc(DWORD dwDir, IEnumFORMATETC **ppefe)
{
    return E_NOTIMPL;
}

//+---------------------------------------------------------------------------
//
// DAdvise
//
//----------------------------------------------------------------------------

STDAPI CTFDataObject::DAdvise(FORMATETC *pfe, DWORD advf, IAdviseSink *pas, DWORD *pdwCookie)
{
    return E_NOTIMPL;
}

//+---------------------------------------------------------------------------
//
// DUnadvise
//
//----------------------------------------------------------------------------

STDAPI CTFDataObject::DUnadvise(DWORD dwCookie)
{
    return E_NOTIMPL;
}

//+---------------------------------------------------------------------------
//
// EnumDAdvise
//
//----------------------------------------------------------------------------

STDAPI CTFDataObject::EnumDAdvise(IEnumSTATDATA **ppesd)
{
    return E_NOTIMPL;
}

//+---------------------------------------------------------------------------
//
// _SetData
//
//----------------------------------------------------------------------------

HRESULT CTFDataObject::_SetData(const WCHAR *pch, ULONG cch)
{
    FORMATETC fe;
    STGMEDIUM sm;

    fe.cfFormat = CF_UNICODETEXT;
    fe.ptd = NULL;
    fe.dwAspect = DVASPECT_CONTENT;
    fe.lindex = -1;
    fe.tymed = TYMED_HGLOBAL;

    sm.tymed = TYMED_HGLOBAL;
    sm.hGlobal = NULL;
    sm.pUnkForRelease = NULL;
    sm.hGlobal = GlobalAlloc(GMEM_FIXED, (cch+1)*sizeof(WCHAR));

    if (sm.hGlobal == NULL)
        return E_OUTOFMEMORY;

    memcpy(sm.hGlobal, pch, cch*sizeof(WCHAR));
    ((WCHAR *)sm.hGlobal)[cch] = '\0';

    return SetData(&fe, &sm, TRUE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\ctf\uim\tsdo.h ===
//
// tsdo.h
//
// Generic simple IDataObject object
//

#ifndef SDO_H
#define SDO_H

#include "private.h"

class CTFDataObject : public IDataObject
{
public:
    CTFDataObject();
    ~CTFDataObject();

    //
    // IUnknown methods
    //
    STDMETHODIMP QueryInterface(REFIID riid, void **ppvObj);
    STDMETHODIMP_(ULONG) AddRef(void);
    STDMETHODIMP_(ULONG) Release(void);

    //
    // IDataObject
    //
    STDMETHODIMP GetData(FORMATETC *pfe, STGMEDIUM *psm);
    STDMETHODIMP GetDataHere(FORMATETC *pfe, STGMEDIUM *psm);
    STDMETHODIMP QueryGetData(FORMATETC *pfe);
    STDMETHODIMP GetCanonicalFormatEtc(FORMATETC *pfeIn, FORMATETC *pfeOut);
    STDMETHODIMP SetData(FORMATETC *pfe, STGMEDIUM *psm, BOOL fRelease);
    STDMETHODIMP EnumFormatEtc(DWORD dwDir, IEnumFORMATETC **ppefe);
    STDMETHODIMP DAdvise(FORMATETC *pfe, DWORD advf, IAdviseSink *pas, DWORD *pdwCookie);
    STDMETHODIMP DUnadvise(DWORD dwCookie);
    STDMETHODIMP EnumDAdvise(IEnumSTATDATA **ppesd);

    HRESULT _SetData(const WCHAR *pch, ULONG cch);

private:
    FORMATETC _fe;
    STGMEDIUM _sm;
    BOOL _fReleaseSM;
    long _cRef;
};

#endif // SDO_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\ctf\uim\tsi.cpp ===
//
// tsi.cpp
//
// CTextStoreImpl
//

#include "private.h"
#include "tsi.h"
#include "immxutil.h"
#include "tsdo.h"
#include "tsattrs.h"
#include "ic.h"
#include "rprop.h"

#define TSI_TOKEN   0x01010101

DBG_ID_INSTANCE(CTextStoreImpl);

/* 012313d4-b1e7-476a-bf88-173a316572fb */
extern const IID IID_PRIV_CTSI = { 0x012313d4, 0xb1e7, 0x476a, {0xbf, 0x88, 0x17, 0x3a, 0x31, 0x65, 0x72, 0xfb} };

//+---------------------------------------------------------------------------
//
// ctor
//
//----------------------------------------------------------------------------

CTextStoreImpl::CTextStoreImpl(CInputContext *pic)
{
    Dbg_MemSetThisNameID(TEXT("CTextStoreImpl"));

	Assert(_fPendingWriteReq == FALSE);
	Assert(_dwlt == 0);

    _pic = pic;
}

//+---------------------------------------------------------------------------
//
// dtor
//
//----------------------------------------------------------------------------

CTextStoreImpl::~CTextStoreImpl()
{
    cicMemFree(_pch);
}

//+---------------------------------------------------------------------------
//
// AdviseSink
//
//----------------------------------------------------------------------------

STDAPI CTextStoreImpl::AdviseSink(REFIID riid, IUnknown *punk, DWORD dwMask)
{
    if (_ptss != NULL)
    {
        Assert(0); // cicero shouldn't do this
        return CONNECT_E_ADVISELIMIT;
    }

    if (FAILED(punk->QueryInterface(IID_ITextStoreACPSink, (void **)&_ptss)))
        return E_UNEXPECTED;

    return S_OK;
}

//+---------------------------------------------------------------------------
//
// UnadviseSink
//
//----------------------------------------------------------------------------

STDAPI CTextStoreImpl::UnadviseSink(IUnknown *punk)
{
    Assert(_ptss == punk); // we're dealing with cicero, this should always hold
    SafeReleaseClear(_ptss);
    return S_OK;
}

//+---------------------------------------------------------------------------
//
// GetSelection
//
//----------------------------------------------------------------------------

STDAPI CTextStoreImpl::GetSelection(ULONG ulIndex, ULONG ulCount, TS_SELECTION_ACP *pSelection, ULONG *pcFetched)
{
    if (pcFetched == NULL)
        return E_INVALIDARG;

    *pcFetched = 0;

    if (ulIndex > 1 && ulIndex != TS_DEFAULT_SELECTION)
        return E_INVALIDARG; // index too high

    if (ulCount == 0 || ulIndex == 1)
        return S_OK;

    if (pSelection == NULL)
        return E_INVALIDARG;

    pSelection[0] = _Sel;
    *pcFetched = 1;

    return S_OK;
}

//+---------------------------------------------------------------------------
//
// SetSelection
//
//----------------------------------------------------------------------------

STDAPI CTextStoreImpl::SetSelection(ULONG ulCount, const TS_SELECTION_ACP *pSelection)
{
    Assert(ulCount > 0); // should have been caught by caller
    Assert(pSelection != NULL); // should have been caught by caller

    Assert(pSelection[0].acpStart >= 0);
    Assert(pSelection[0].acpEnd >= pSelection[0].acpStart);

    if (ulCount > 1)
        return E_FAIL; // don't support disjoint sel

    if (pSelection[0].acpEnd > _cch)
        return TS_E_INVALIDPOS;

    _Sel = pSelection[0];

    return S_OK;
}

//+---------------------------------------------------------------------------
//
// GetText
//
//----------------------------------------------------------------------------

STDAPI CTextStoreImpl::GetText(LONG acpStart, LONG acpEnd,
                               WCHAR *pchPlain, ULONG cchPlainReq, ULONG *pcchPlainOut,
                               TS_RUNINFO *prgRunInfo, ULONG ulRunInfoReq, ULONG *pulRunInfoOut,
                               LONG *pacpNext)
{
    ULONG cch;

    *pcchPlainOut = 0;
    *pulRunInfoOut = 0;
    *pacpNext = acpStart;

    if (acpStart < 0 || acpStart > _cch)
        return TS_E_INVALIDPOS;    

    // get a count of acp chars requested
    cch = (acpEnd >= acpStart) ? acpEnd - acpStart : _cch - acpStart;
    // since we're plain text, we can also simply clip by the plaintext buffer len
    if (cchPlainReq > 0) // if they don't want plain text we won't clip!
    {
        cch = min(cch, cchPlainReq);
    }

    // check for eod
    if (acpStart + cch > (ULONG)_cch)
    {
        cch = _cch - acpStart;
    }

    if (ulRunInfoReq > 0 && cch > 0)
    {
        *pulRunInfoOut = 1;
        prgRunInfo[0].uCount = cch;
        prgRunInfo[0].type = TS_RT_PLAIN;
    }

    if (cchPlainReq > 0)
    {
        // we're a plain text buffer, so we always copy all the requested chars
        *pcchPlainOut = cch;
        memcpy(pchPlain, _pch + acpStart, cch*sizeof(WCHAR));
    }

    *pacpNext = acpStart + cch;

    return S_OK;
}

//+---------------------------------------------------------------------------
//
// SetText
//
//----------------------------------------------------------------------------

STDAPI CTextStoreImpl::SetText(DWORD dwFlags, LONG acpStart, LONG acpEnd, const WCHAR *pchText, ULONG cch, TS_TEXTCHANGE *pChange)
{
    int iSizeRange;
    int cchAdjust;
    TS_STATUS tss;
    WCHAR *pch = NULL;

    // Since we know our only caller will be cicero, we can assert rather than
    // returning failure codes.
    Assert(acpStart >= 0);
    Assert(acpStart <= acpEnd);

    if (acpEnd > _cch)
        return TS_E_INVALIDPOS;

    if (_owner != NULL &&
        _owner->GetStatus(&tss) == S_OK &&
        (tss.dwDynamicFlags & TS_SD_READONLY))
    {
        return TS_E_READONLY;
    }

    //
    // Check mapped app property for TSATTRID_Text_ReadOnly.
    //
    CProperty *pProp;
    BOOL fReadOnly = FALSE;
    if (SUCCEEDED(_pic->GetMappedAppProperty(TSATTRID_Text_ReadOnly, &pProp)))
    {
        ITfRangeACP *range;
        if (SUCCEEDED(_pic->CreateRange(acpStart, acpEnd, &range)))
        {
            IEnumTfRanges *pEnumRanges;

            if (SUCCEEDED(pProp->EnumRanges(BACKDOOR_EDIT_COOKIE,
                                            &pEnumRanges,
                                            range)))
            {
                ITfRange *rangeTmp;
                while (pEnumRanges->Next(1, &rangeTmp, NULL) == S_OK)
                {
                    VARIANT var;
                    if (pProp->GetValue(BACKDOOR_EDIT_COOKIE, rangeTmp, &var) == S_OK)
                    {
                        if (var.lVal != 0)
                        {
                            fReadOnly = TRUE;
                            break;
                        }
                    }
                    rangeTmp->Release();
                }

                pEnumRanges->Release();
            }

            range->Release();
        }
        pProp->Release();
    }

    if (fReadOnly)
    {
        return TS_E_READONLY;
    }


    // this will all be rewritten for the gap buffer, so keep it simple for now.
    // delete the ranage, then insert the new text.

    iSizeRange = acpEnd - acpStart;
    cchAdjust = (LONG)cch - iSizeRange;

    if (cchAdjust > 0)
    {
        // if we need to alloc more memory, try now, to handle failure gracefully
        if ((pch = (_pch == NULL) ? (WCHAR *)cicMemAlloc((_cch + cchAdjust)*sizeof(WCHAR)) :
                                    (WCHAR *)cicMemReAlloc(_pch, (_cch + cchAdjust)*sizeof(WCHAR))) == NULL)
        {
            return E_OUTOFMEMORY;
        }

        // we're all set
        _pch = pch;
    }

    //
    // shift existing text to the right of the range
    //
    memmove(_pch + acpStart + cch, _pch + acpStart + iSizeRange, (_cch - iSizeRange - acpStart)*sizeof(WCHAR));

    //
    // now fill in the gap
    //
    if (pchText != NULL)
    {
        memcpy(_pch + acpStart, pchText, cch*sizeof(WCHAR));
    }

    //
    // update our buffer size
    //
    _cch += cchAdjust;
    Assert(_cch >= 0);

    // if we shrank, try to realloc a smaller buffer (otherwise we alloc'd above)
    if (cchAdjust < 0)
    {
        if (_cch == 0)
        {
            cicMemFree(_pch);
            _pch = NULL;
        }
        else if (pch = (WCHAR *)cicMemReAlloc(_pch, _cch*sizeof(WCHAR)))
        {
            _pch = pch;
        }
    }

    // handle the out params
    pChange->acpStart = acpStart;
    pChange->acpOldEnd = acpEnd;
    pChange->acpNewEnd = acpEnd + cchAdjust;

    //
    // update the selection
    //
    _Sel.acpStart = AdjustAnchor(acpStart, acpEnd, cch, _Sel.acpStart, FALSE);
    _Sel.acpEnd = AdjustAnchor(acpStart, acpEnd, cch, _Sel.acpEnd, TRUE);
    Assert(_Sel.acpStart >= 0);
    Assert(_Sel.acpStart <= _Sel.acpEnd);
    Assert(_Sel.acpEnd <= _cch);

    // never need to call OnTextChange because we have only one adaptor
    // and this class never calls SetText internally
    // do the OnDelta
    //_ptss->OnTextChange(acpStart, acpEnd, acpStart + cch);

    return S_OK;
}

//+---------------------------------------------------------------------------
//
// GetFormattedText
//
//----------------------------------------------------------------------------

STDAPI CTextStoreImpl::GetFormattedText(LONG acpStart, LONG acpEnd, IDataObject **ppDataObject)
{
    CTFDataObject *pcdo;

    Assert(acpStart >= 0 && acpEnd <= _cch);
    Assert(acpStart <= acpEnd);
    Assert(ppDataObject != NULL);

    *ppDataObject = NULL;

    pcdo = new CTFDataObject;

    if (pcdo == NULL)
        return E_OUTOFMEMORY;

    if (FAILED(pcdo->_SetData(&_pch[acpStart], acpEnd - acpStart)))
    {
        Assert(0);
        pcdo->Release();
        return E_FAIL;
    }

    return S_OK;
}

//+---------------------------------------------------------------------------
//
// GetEmbedded
//
//----------------------------------------------------------------------------

STDAPI CTextStoreImpl::GetEmbedded(LONG acpPos, REFGUID rguidService, REFIID riid, IUnknown **ppunk)
{
    return E_NOTIMPL;
}

//+---------------------------------------------------------------------------
//
// InsertEmbedded
//
//----------------------------------------------------------------------------

STDAPI CTextStoreImpl::InsertEmbedded(DWORD dwFlags, LONG acpStart, LONG acpEnd, IDataObject *pDataObject, TS_TEXTCHANGE *pChange)
{
    ULONG cch;
    FORMATETC fe;
    STGMEDIUM sm;
    WCHAR *pch;
    HRESULT hr;

    Assert(acpStart <= acpEnd);
    Assert((dwFlags & ~TS_IE_CORRECTION) == 0);
    Assert(pDataObject != NULL);
    Assert(pChange != NULL);

    memset(pChange, 0, sizeof(*pChange));

    fe.cfFormat = CF_UNICODETEXT;
    fe.ptd = NULL;
    fe.dwAspect = DVASPECT_CONTENT;
    fe.lindex = -1;
    fe.tymed = TYMED_HGLOBAL;

    if (FAILED(pDataObject->GetData(&fe, &sm)))
        return TS_E_FORMAT;

    if (sm.hGlobal == NULL)
        return E_FAIL;

    pch = (WCHAR *)GlobalLock(sm.hGlobal);
    cch = wcslen(pch);

    hr = SetText(dwFlags, acpStart, acpEnd, pch, cch, pChange);

    GlobalUnlock(sm.hGlobal);
    ReleaseStgMedium(&sm);

    return hr;
}

//+---------------------------------------------------------------------------
//
// RequestLock
//
//----------------------------------------------------------------------------

#define TS_LF_WRITE (TS_LF_READWRITE & ~TS_LF_READ)

STDAPI CTextStoreImpl::RequestLock(DWORD dwLockFlags, HRESULT *phrSession)
{
    Assert(phrSession != NULL); // caller should have caught this

    if (_dwlt != 0)
    {
        *phrSession = E_UNEXPECTED;

        // this is a reentrant call
        // only one case is legal
        if ((_dwlt & TS_LF_WRITE) ||
            !(dwLockFlags & TS_LF_WRITE) ||
            (dwLockFlags & TS_LF_SYNC))
        {
            Assert(0); // bogus reentrant lock req!
            return E_UNEXPECTED;
        }

        _fPendingWriteReq = TRUE;
        *phrSession = TS_S_ASYNC;
        return S_OK;
    }

    _dwlt = dwLockFlags;

    *phrSession = _ptss->OnLockGranted(dwLockFlags);

    if (_fPendingWriteReq)
    {
        _dwlt = TS_LF_READWRITE;
        _fPendingWriteReq = FALSE;
        if (_ptss != NULL) // might be NULL if we're disconnected during the OnLockGranted above
        {
            _ptss->OnLockGranted(TS_LF_READWRITE);
        }
    }

    _dwlt = 0;

    return S_OK;
}

//+---------------------------------------------------------------------------
//
// GetStatus
//
//----------------------------------------------------------------------------

STDAPI CTextStoreImpl::GetStatus(TS_STATUS *pdcs)
{
    HRESULT hr;

    if (_owner != NULL)
    {
        hr = _owner->GetStatus(pdcs);

        // only let the owner ctl certain bits
        if (hr == S_OK)
        {
            pdcs->dwDynamicFlags &= (TF_SD_READONLY | TF_SD_LOADING);
            pdcs->dwStaticFlags &= (TF_SS_TRANSITORY);
        }
        else
        {
            memset(pdcs, 0, sizeof(*pdcs));
        }
    }
    else
    {
        hr = S_OK;
        memset(pdcs, 0, sizeof(*pdcs));
    }

    return hr;
}

//+---------------------------------------------------------------------------
//
// QueryInsert
//
//----------------------------------------------------------------------------

STDAPI CTextStoreImpl::QueryInsert(LONG acpTestStart, LONG acpTestEnd, ULONG cch, LONG *pacpResultStart, LONG *pacpResultEnd)
{
    Assert(acpTestStart >= 0);
    Assert(acpTestStart <= acpTestEnd);
    Assert(acpTestEnd <= _cch);

    // default text store does not support overtype, and the selection is always replaced
    *pacpResultStart = acpTestStart;
    *pacpResultEnd = acpTestEnd;

    return S_OK;   
}

//+---------------------------------------------------------------------------
//
// Unlock
//
//----------------------------------------------------------------------------

STDAPI CTextStoreImpl::GetEndACP(LONG *pacp)
{
    *pacp = _cch;
    return S_OK;
}

//+---------------------------------------------------------------------------
//
// GetACPFromPoint
//
//----------------------------------------------------------------------------

STDAPI CTextStoreImpl::GetACPFromPoint(TsViewCookie vcView, const POINT *pt, DWORD dwFlags, LONG *pacp)
{
    Assert(vcView == TSI_ACTIVE_VIEW_COOKIE); // default tsi only has a single view

    if (_owner == NULL)
        return E_FAIL; // who ever owns the ic hasn't bothered to give us a callback....

    return _owner->GetACPFromPoint(pt, dwFlags, pacp);    
}

//+---------------------------------------------------------------------------
//
// GetScreenExt
//
//----------------------------------------------------------------------------

STDAPI CTextStoreImpl::GetScreenExt(TsViewCookie vcView, RECT *prc)
{
    Assert(vcView == TSI_ACTIVE_VIEW_COOKIE); // default tsi only has a single view

    if (_owner == NULL)
        return E_FAIL; // who ever owns the ic hasn't bothered to give us a callback....

    return _owner->GetScreenExt(prc);
}

//+---------------------------------------------------------------------------
//
// GetTextExt
//
//----------------------------------------------------------------------------

STDAPI CTextStoreImpl::GetTextExt(TsViewCookie vcView, LONG acpStart, LONG acpEnd, RECT *prc, BOOL *pfClipped)
{
    Assert(vcView == TSI_ACTIVE_VIEW_COOKIE); // default tsi only has a single view

    if (_owner == NULL)
        return E_FAIL; // who ever owns the ic hasn't bothered to give us a callback....

    return _owner->GetTextExt(acpStart, acpEnd, prc, pfClipped);
}

//+---------------------------------------------------------------------------
//
// GetWnd
//
//----------------------------------------------------------------------------

STDAPI CTextStoreImpl::GetWnd(TsViewCookie vcView, HWND *phwnd)
{
    Assert(vcView == TSI_ACTIVE_VIEW_COOKIE); // default tsi only has a single view
    Assert(phwnd != NULL); // should have caught this in the ic

    *phwnd = NULL;

    if (_owner == NULL)
        return E_FAIL; // who ever owns the ic hasn't bothered to give us a callback....

    return _owner->GetWnd(phwnd);
}

//+---------------------------------------------------------------------------
//
// _LoadAttr
//
//----------------------------------------------------------------------------

HRESULT CTextStoreImpl::_LoadAttr(DWORD dwFlags, ULONG cFilterAttrs, const TS_ATTRID *paFilterAttrs)
{
    ULONG i;
    HRESULT hr;

    ClearAttrStore();

    if (dwFlags & TS_ATTR_FIND_WANT_VALUE)
    {
        if (_owner == NULL)
            return E_FAIL;
    }

    for (i=0; i<cFilterAttrs; i++)
    {
        VARIANT var;
        QuickVariantInit(&var);

        if (dwFlags & TS_ATTR_FIND_WANT_VALUE)
        {
            if (_owner->GetAttribute(paFilterAttrs[i], &var) != S_OK)
            {
                ClearAttrStore();
                return E_FAIL;
            }
        }
        else
        {
            // Issue: benwest: I think these should be init'd to VT_EMPTY if caller doesn't specify TS_ATTR_FIND_WANT_VALUE
            if (IsEqualGUID(paFilterAttrs[i], GUID_PROP_MODEBIAS))
            {
                 var.vt   = VT_I4;
                 var.lVal = TF_INVALID_GUIDATOM;
            }
            else if (IsEqualGUID(paFilterAttrs[i], TSATTRID_Text_Orientation))
            {
                 var.vt   = VT_I4;
                 var.lVal = 0;
            }
            else if (IsEqualGUID(paFilterAttrs[i], TSATTRID_Text_VerticalWriting))
            {
                 var.vt   = VT_BOOL;
                 var.lVal = 0;
            }
        }

        if (var.vt != VT_EMPTY)
        {
            TSI_ATTRSTORE *pas = _rgAttrStore.Append(1);
            if (!pas)
            {
                hr = E_OUTOFMEMORY;
                goto Exit;
            }
            pas->attrid = paFilterAttrs[i];
            pas->var    = var;
        }
    }

    hr = S_OK;

Exit:
    return hr;
}

//+---------------------------------------------------------------------------
//
// RequestSupportedAttrs
//
//----------------------------------------------------------------------------

STDAPI CTextStoreImpl::RequestSupportedAttrs(DWORD dwFlags, ULONG cFilterAttrs, const TS_ATTRID *paFilterAttrs)
{
    // note the return value is technically a default value, but since we have a value for every location
    // this will never need to be used
    return _LoadAttr(dwFlags, cFilterAttrs, paFilterAttrs);
}

//+---------------------------------------------------------------------------
//
// RequestAttrsAtPosition
//
//----------------------------------------------------------------------------

STDAPI CTextStoreImpl::RequestAttrsAtPosition(LONG acpPos, ULONG cFilterAttrs, const TS_ATTRID *paFilterAttrs, DWORD dwFlags)
{
    return _LoadAttr(TS_ATTR_FIND_WANT_VALUE, cFilterAttrs, paFilterAttrs);
}

//+---------------------------------------------------------------------------
//
// RequestAttrsTransitioningAtPosition
//
//----------------------------------------------------------------------------

STDAPI CTextStoreImpl::RequestAttrsTransitioningAtPosition(LONG acpPos, ULONG cFilterAttrs, const TS_ATTRID *paFilterAttrs, DWORD dwFlags)
{
    ClearAttrStore();
    return S_OK;
}

//+---------------------------------------------------------------------------
//
// FindNextAttrTransition
//
//----------------------------------------------------------------------------

STDAPI CTextStoreImpl::FindNextAttrTransition(LONG acpStart, LONG acpHaltPos, ULONG cFilterAttrs, const TS_ATTRID *paFilterAttrs, DWORD dwFlags, LONG *pacpNext, BOOL *pfFound, LONG *plFoundOffset)
{
    // our attrs never transition

    *pacpNext = acpStart;
    *pfFound = FALSE;
    plFoundOffset = 0;

    return S_OK;
}

//+---------------------------------------------------------------------------
//
// RetrieveRequestedAttrs
//
//----------------------------------------------------------------------------

STDAPI CTextStoreImpl::RetrieveRequestedAttrs(ULONG ulCount, TS_ATTRVAL *paAttrVals, ULONG *pcFetched)
{
    ULONG i = 0;

    while((i < ulCount) && ((int)i < _rgAttrStore.Count()))
    {
        TSI_ATTRSTORE *pas = _rgAttrStore.GetPtr(i);
        paAttrVals->idAttr = pas->attrid;
        paAttrVals->dwOverlapId = 0;
        QuickVariantInit(&paAttrVals->varValue);
        paAttrVals->varValue = pas->var;
        paAttrVals++;
        i++;
    }

    *pcFetched = i;
    ClearAttrStore();
    return S_OK;
}

//+---------------------------------------------------------------------------
//
// QueryService
//
//----------------------------------------------------------------------------

STDAPI CTextStoreImpl::QueryService(REFGUID guidService, REFIID riid, void **ppv)
{
    if (ppv == NULL)
        return E_INVALIDARG;

    *ppv = NULL;

    if (!IsEqualGUID(guidService, GUID_SERVICE_TF) ||
        !IsEqualIID(riid, IID_PRIV_CTSI))
    {
        // SVC_E_NOSERVICE is proper return code for wrong service....
        // but it's not defined anywhere.  So use E_NOINTERFACE for both
        // cases as trident is rumored to do
        return E_NOINTERFACE;
    }

    *ppv = this;
    AddRef();

    return S_OK;
}

//+---------------------------------------------------------------------------
//
// GetActiveView
//
//----------------------------------------------------------------------------

STDAPI CTextStoreImpl::GetActiveView(TsViewCookie *pvcView)
{
    // each CEditWnd has only a single view, so this can be constant.
    *pvcView = TSI_ACTIVE_VIEW_COOKIE;
    return S_OK;
}

//+---------------------------------------------------------------------------
//
// AdviseMouseSink
//
//----------------------------------------------------------------------------

STDAPI CTextStoreImpl::AdviseMouseSink(ITfRangeACP *range, ITfMouseSink *pSink, DWORD *pdwCookie)
{
    ITfMouseTrackerACP *pTracker;
    HRESULT hr;

    Assert(range != NULL);
    Assert(pSink != NULL);
    Assert(pdwCookie != NULL);

    *pdwCookie = 0;

    if (_owner == NULL)
        return E_FAIL;

    if (_owner->QueryInterface(IID_ITfMouseTrackerACP, (void **)&pTracker) != S_OK)
        return E_NOTIMPL;

    hr = pTracker->AdviseMouseSink(range, pSink, pdwCookie);

    pTracker->Release();
    return hr;
}

//+---------------------------------------------------------------------------
//
// UnadviseMouseSink
//
//----------------------------------------------------------------------------

STDAPI CTextStoreImpl::UnadviseMouseSink(DWORD dwCookie)
{
    ITfMouseTrackerACP *pTracker;
    HRESULT hr;

    if (_owner == NULL)
        return E_FAIL;

    if (_owner->QueryInterface(IID_ITfMouseTrackerACP, (void **)&pTracker) != S_OK)
        return E_NOTIMPL;

    hr = pTracker->UnadviseMouseSink(dwCookie);

    pTracker->Release();
    return hr;
}

//+---------------------------------------------------------------------------
//
// QueryInsertEmbedded
//
//----------------------------------------------------------------------------

STDAPI CTextStoreImpl::QueryInsertEmbedded(const GUID *pguidService, const FORMATETC *pFormatEtc, BOOL *pfInsertable)
{
    Assert(pfInsertable != NULL); // cicero should have caught this

    *pfInsertable = FALSE;

    // only accept unicode text
    if (pguidService == NULL &&
        pFormatEtc != NULL &&
        pFormatEtc->cfFormat == CF_UNICODETEXT &&
        pFormatEtc->dwAspect == DVASPECT_CONTENT &&
        pFormatEtc->lindex == -1 &&
        pFormatEtc->tymed == TYMED_HGLOBAL)
    {
        *pfInsertable = TRUE;
    }

    return S_OK;
}

//+---------------------------------------------------------------------------
//
// InsertTextAtSelection
//
//----------------------------------------------------------------------------

STDAPI CTextStoreImpl::InsertTextAtSelection(DWORD dwFlags, const WCHAR *pchText,
                                             ULONG cch, LONG *pacpStart, LONG *pacpEnd, TS_TEXTCHANGE *pChange)
{
    HRESULT hr;

    Assert((dwFlags & TS_IAS_QUERYONLY) || pchText != NULL); // caller should have already caught this
    Assert((dwFlags & TS_IAS_QUERYONLY) || cch > 0); // caller should have already caught this
    Assert(pacpStart != NULL && pacpEnd != NULL); // caller should have already caught this
    Assert((dwFlags & (TS_IAS_NOQUERY | TS_IAS_QUERYONLY)) != (TS_IAS_NOQUERY | TS_IAS_QUERYONLY));  // caller should have already caught this

    if (dwFlags & TS_IAS_QUERYONLY)
        goto Exit;

    *pacpStart = -1;
    *pacpEnd = -1;

    hr = SetText(0, _Sel.acpStart, _Sel.acpEnd, pchText, cch, pChange);

    if (hr != S_OK)
        return hr;

Exit:
    // since this is cheap, always set the insert span even if caller sets TS_IAS_NOQUERY
    *pacpStart = _Sel.acpStart;
    *pacpEnd = _Sel.acpEnd;

    return S_OK;
}

//+---------------------------------------------------------------------------
//
// InsertEmbeddedAtSelection
//
//----------------------------------------------------------------------------

STDAPI CTextStoreImpl::InsertEmbeddedAtSelection(DWORD dwFlags, IDataObject *pDataObject,
                                                 LONG *pacpStart, LONG *pacpEnd, TS_TEXTCHANGE *pChange)
{
    HRESULT hr;

    Assert((dwFlags & TS_IAS_QUERYONLY) || pDataObject != NULL); // caller should have already caught this
    Assert(pacpStart != NULL && pacpEnd != NULL); // caller should have already caught this
    Assert((dwFlags & (TS_IAS_NOQUERY | TS_IAS_QUERYONLY)) != (TS_IAS_NOQUERY | TS_IAS_QUERYONLY));  // caller should have already caught this

    if (dwFlags & TS_IAS_QUERYONLY)
        goto Exit;

    *pacpStart = -1;
    *pacpEnd = -1;

    hr = InsertEmbedded(0, _Sel.acpStart, _Sel.acpEnd, pDataObject, pChange);

    if (hr != S_OK)
        return hr;

Exit:
    // since this is cheap, always set the insert span even if caller sets TS_IAS_QUERYONLY
    *pacpStart = _Sel.acpStart;
    *pacpEnd = _Sel.acpEnd;

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\ctf\uim\tsi.h ===
//
// tsi.h
//
// CTextStoreImpl
//

#ifndef TSI_H
#define TSI_H

#include "private.h"
#include "strary.h"

extern const IID IID_PRIV_CTSI;

// the cookie for each CTextStoreImpl's single view
#define TSI_ACTIVE_VIEW_COOKIE 0

class CInputContext;

class CTextStoreImpl : public ITextStoreACP,
                       public ITfMouseTrackerACP,
                       public IServiceProvider,
                       public CComObjectRootImmx
{
public:
    CTextStoreImpl(CInputContext *pic);
    ~CTextStoreImpl();

    BEGIN_COM_MAP_IMMX(CTextStoreImpl)
        COM_INTERFACE_ENTRY(ITextStoreACP)
        COM_INTERFACE_ENTRY(ITfMouseTrackerACP)
        COM_INTERFACE_ENTRY(IServiceProvider)
    END_COM_MAP_IMMX()

    IMMX_OBJECT_IUNKNOWN_FOR_ATL()

    //
    // ITextStoreACP
    //
    STDMETHODIMP AdviseSink(REFIID riid, IUnknown *punk, DWORD dwMask);
    STDMETHODIMP UnadviseSink(IUnknown *punk);
    STDMETHODIMP RequestLock(DWORD dwLockFlags, HRESULT *phrSession);
    STDMETHODIMP GetStatus(TS_STATUS *pdcs);
    STDMETHODIMP QueryInsert(LONG acpTestStart, LONG acpTestEnd, ULONG cch, LONG *pacpResultStart, LONG *pacpResultEnd);
    STDMETHODIMP GetSelection(ULONG ulIndex, ULONG ulCount, TS_SELECTION_ACP *pSelection, ULONG *pcFetched);
    STDMETHODIMP SetSelection(ULONG ulCount, const TS_SELECTION_ACP *pSelection);
    STDMETHODIMP GetText(LONG acpStart, LONG acpEnd, WCHAR *pchPlain, ULONG cchPlainReq, ULONG *pcchPlainOut, TS_RUNINFO *prgRunInfo, ULONG ulRunInfoReq, ULONG *pulRunInfoOut, LONG *pacpNext);
    STDMETHODIMP SetText(DWORD dwFlags, LONG acpStart, LONG acpEnd, const WCHAR *pchText, ULONG cch, TS_TEXTCHANGE *pChange);
    STDMETHODIMP GetFormattedText(LONG acpStart, LONG acpEnd, IDataObject **ppDataObject);
    STDMETHODIMP GetEmbedded(LONG acpPos, REFGUID rguidService, REFIID riid, IUnknown **ppunk);
    STDMETHODIMP QueryInsertEmbedded(const GUID *pguidService, const FORMATETC *pFormatEtc, BOOL *pfInsertable);
    STDMETHODIMP InsertEmbedded(DWORD dwFlags, LONG acpStart, LONG acpEnd, IDataObject *pDataObject, TS_TEXTCHANGE *pChange);
    STDMETHODIMP RequestSupportedAttrs(DWORD dwFlags, ULONG cFilterAttrs, const TS_ATTRID *paFilterAttrs);
    STDMETHODIMP RequestAttrsAtPosition(LONG acpPos, ULONG cFilterAttrs, const TS_ATTRID *paFilterAttrs, DWORD dwFlags);
    STDMETHODIMP RequestAttrsTransitioningAtPosition(LONG acpPos, ULONG cFilterAttrs, const TS_ATTRID *paFilterAttrs, DWORD dwFlags);
    STDMETHODIMP FindNextAttrTransition(LONG acpStart, LONG acpHalt, ULONG cFilterAttrs, const TS_ATTRID *paFilterAttrs, DWORD dwFlags, LONG *pacpNext, BOOL *pfFound, LONG *plFoundOffset);
    STDMETHODIMP RetrieveRequestedAttrs(ULONG ulCount, TS_ATTRVAL *paAttrVals, ULONG *pcFetched);
    STDMETHODIMP GetEndACP(LONG *pacp);
    STDMETHODIMP GetActiveView(TsViewCookie *pvcView);
    STDMETHODIMP GetACPFromPoint(TsViewCookie vcView, const POINT *pt, DWORD dwFlags, LONG *pacp);
    STDMETHODIMP GetTextExt(TsViewCookie vcView, LONG acpStart, LONG acpEnd, RECT *prc, BOOL *pfClipped);
    STDMETHODIMP GetScreenExt(TsViewCookie vcView, RECT *prc);
    STDMETHODIMP GetWnd(TsViewCookie vcView, HWND *phwnd);
    STDMETHODIMP InsertTextAtSelection(DWORD dwFlags, const WCHAR *pchText, ULONG cch, LONG *pacpStart, LONG *pacpEnd, TS_TEXTCHANGE *pChange);
    STDMETHODIMP InsertEmbeddedAtSelection(DWORD dwFlags, IDataObject *pDataObject, LONG *pacpStart, LONG *pacpEnd, TS_TEXTCHANGE *pChange);

    // ITfMouseTrackerACP
    STDMETHODIMP AdviseMouseSink(ITfRangeACP *range, ITfMouseSink *pSink, DWORD *pdwCookie);
    STDMETHODIMP UnadviseMouseSink(DWORD dwCookie);

    // IServiceProvider
    STDMETHODIMP QueryService(REFGUID guidService, REFIID riid, void **ppv);

    void _AdviseOwner(ITfContextOwner *owner) { Assert(_owner == NULL); _owner = owner; _owner->AddRef(); }
    void _UnadviseOwner() { SafeReleaseClear(_owner); }
    BOOL _HasOwner() { return (_owner != NULL); }

private:

    HRESULT _LoadAttr(DWORD dwFlags, ULONG cFilterAttrs, const TS_ATTRID *paFilterAttrs);

    WCHAR *_pch;    // text buffer
    int _cch;       // size of buffer

    TS_SELECTION_ACP _Sel;

    ITextStoreACPSink *_ptss;

    ITfContextOwner *_owner; // this can be NULL...be careful

    BOOL _fAttrToReturn : 1;
    TfGuidAtom _gaModeBias;

    typedef struct {
         TS_ATTRID    attrid;
         VARIANT      var;
    } TSI_ATTRSTORE;

    CStructArray<TSI_ATTRSTORE> _rgAttrStore;
    void ClearAttrStore()
    {
        int i;
        for (i = 0; i < _rgAttrStore.Count(); i++)
        {
             TSI_ATTRSTORE *pas = _rgAttrStore.GetPtr(i);
             VariantClear(&pas->var);
        }
        _rgAttrStore.Clear();
    }

    BOOL _fPendingWriteReq : 1;
    DWORD _dwlt;

    CInputContext *_pic;

    DBG_ID_DECLARE;
};

#endif // TSI_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\ctf\uim\txtcache.cpp ===
//
// txtcache.cpp
//

#include "private.h"
#include "txtcache.h"

long CProcessTextCache::_lCacheMutex = -1;
ITextStoreACP *CProcessTextCache::_ptsi = NULL;
LONG CProcessTextCache::_acpStart;
LONG CProcessTextCache::_acpEnd;
WCHAR CProcessTextCache::_achPlain[CACHE_SIZE_TEXT];
TS_RUNINFO CProcessTextCache::_rgRunInfo[CACHE_SIZE_RUNINFO];
ULONG CProcessTextCache::_ulRunInfoLen;

//+---------------------------------------------------------------------------
//
// GetText
//
// Wrapper for GetText that uses a cache.
//----------------------------------------------------------------------------

HRESULT CProcessTextCache::GetText(ITextStoreACP *ptsi, LONG acpStart, LONG acpEnd,
                                   WCHAR *pchPlain, ULONG cchPlainReq, ULONG *pcchPlainOut,
                                   TS_RUNINFO *prgRunInfo, ULONG ulRunInfoReq, ULONG *pulRunInfoOut,
                                   LONG *pacpNext)
{
#ifdef DEBUG
    // use these guys to verify the cache in debug
    WCHAR *dbg_pchPlain;
    LONG dbg_acpStart = acpStart;
    LONG dbg_acpEnd = acpEnd;
    ULONG dbg_cchPlainReq = cchPlainReq;
    ULONG dbg_cchPlainOut;
    TS_RUNINFO *dbg_prgRunInfo;
    ULONG dbg_ulRunInfoReq = ulRunInfoReq;
    ULONG dbg_ulRunInfoOut;
    LONG dbg_acpNext;
#endif
    ULONG cch;
    ULONG cchBase;
    LONG acpBase;
    ULONG i;
    ULONG iDst;
    ULONG iOffset;
    int dStartEnd;
    HRESULT hr;

    // don't block if the mutex is held, just call the real GetText
    if (InterlockedIncrement(&_lCacheMutex) != 0)
        goto RealGetText;

    // if its a really big request, don't try to use the cache
    // the way we set things up, once we decide to use the cache we only ask
    // for CACHE_SIZE_TEXT chunks of text at a time, no matter what
    // the code would still be correct without this test, but probably slower
    if (acpEnd < 0 && cchPlainReq > CACHE_SIZE_TEXT)
        goto RealGetText;

    // need to reset the cache?
    if (_ptsi != ptsi ||                              // no cache       
        _acpStart > acpStart || _acpEnd <= acpStart) // is any of the text in the cache?
    {
        _ptsi = NULL; // invalidate the cache in case the GetText fails
        _acpStart = max(0, acpStart - CACHE_PRELOAD_COUNT);

        hr = ptsi->GetText(_acpStart, -1, _achPlain, ARRAYSIZE(_achPlain), &cch,
                           _rgRunInfo, ARRAYSIZE(_rgRunInfo), &_ulRunInfoLen, &_acpEnd);

        if (hr != S_OK)
            goto RealGetText;

        // we have a good cache
        _ptsi = ptsi;
    }

    // return something from the cache

    if (pcchPlainOut != NULL)
    {
        *pcchPlainOut = 0;
    }
    if (pulRunInfoOut != NULL)
    {
        *pulRunInfoOut = 0;
    }

    // find a start point
    // in the first run?
    acpBase = _acpStart;
    cchBase = 0;
    iDst = 0;

    for (i=0; i<_ulRunInfoLen; i++)
    {
        if (acpStart == acpEnd)
            break;
        dStartEnd = acpEnd - acpStart;

        iOffset = acpStart - acpBase;
        acpBase += _rgRunInfo[i].uCount;
        cch = 0;

        if (iOffset >= _rgRunInfo[i].uCount)
        {
            if (_rgRunInfo[i].type != TS_RT_OPAQUE)
            {
                cchBase += _rgRunInfo[i].uCount;
            }
            continue;
        }

        if (ulRunInfoReq > 0)
        {
            cch = _rgRunInfo[i].uCount - iOffset;
            if (dStartEnd > 0 &&
                iOffset + dStartEnd < _rgRunInfo[i].uCount)
            {
                cch = dStartEnd;
            }
            prgRunInfo[iDst].uCount = cch;
            prgRunInfo[iDst].type = _rgRunInfo[i].type;
            (*pulRunInfoOut)++;
        }

        if (cchPlainReq > 0 &&
            _rgRunInfo[i].type != TS_RT_OPAQUE)
        {
            cch = min(cchPlainReq, _rgRunInfo[i].uCount - iOffset);
            if (dStartEnd > 0 &&
                iOffset + dStartEnd < _rgRunInfo[i].uCount)
            {
                cch = min(cchPlainReq, (ULONG)dStartEnd);
            }
            memcpy(pchPlain+*pcchPlainOut, _achPlain+cchBase+iOffset, sizeof(WCHAR)*cch);
            *pcchPlainOut += cch;
            if (ulRunInfoReq > 0)
            {
                // might have truncated the run based on pchPlain buffer size, so fix it
                prgRunInfo[iDst].uCount = cch;
            }
            cchPlainReq -= cch;
            cchBase += cch + iOffset;

            if (cchPlainReq == 0)
            {
                ulRunInfoReq = 1; // force a break below
            }
        }

        if (cch == 0)
            break;

        acpStart += cch;
        iDst++;

        if (ulRunInfoReq > 0)
        {
            if (--ulRunInfoReq == 0)
                break;
        }
    }

    *pacpNext = acpStart;

    InterlockedDecrement(&_lCacheMutex);

#ifdef DEBUG
    // verify the cache worked
    if (dbg_acpEnd <= _acpEnd) // this simple check won't work if the GetText was truncated
    {
        dbg_pchPlain = (WCHAR *)cicMemAlloc(sizeof(WCHAR)*dbg_cchPlainReq);

        if (dbg_pchPlain)
        {
            // there's a bug in word where it will write to dbg_ulRunInfoReq even when dbg_ulRunInfoReq is zero,
            // if it is non-NULL
            dbg_prgRunInfo = dbg_ulRunInfoReq ? (TS_RUNINFO *)cicMemAlloc(sizeof(TS_RUNINFO)*dbg_ulRunInfoReq) : NULL;

            if (dbg_prgRunInfo || !dbg_ulRunInfoReq)
            {
                hr = ptsi->GetText(dbg_acpStart, dbg_acpEnd, dbg_pchPlain, dbg_cchPlainReq, &dbg_cchPlainOut,
                                     dbg_prgRunInfo, dbg_ulRunInfoReq, &dbg_ulRunInfoOut, &dbg_acpNext);

                Assert(hr == S_OK);
                if (dbg_cchPlainReq > 0)
                {
                    Assert(dbg_cchPlainOut == *pcchPlainOut);
                    Assert(memcmp(dbg_pchPlain, pchPlain, dbg_cchPlainOut*sizeof(WCHAR)) == 0);
                }
                if (dbg_ulRunInfoReq > 0)
                {
                    Assert(dbg_ulRunInfoOut == *pulRunInfoOut);
                    Assert(memcmp(dbg_prgRunInfo, prgRunInfo, sizeof(TS_RUNINFO)*dbg_ulRunInfoOut) == 0);
                }
                Assert(dbg_acpNext == *pacpNext);

                cicMemFree(dbg_prgRunInfo);
            }
            else
            {
                // could not allocate mem.
                Assert(0);
            }

            cicMemFree(dbg_pchPlain);
        }
        else
        {
            // could not allocate mem.
            Assert(0);
        }
    }
#endif

    return S_OK;

RealGetText:
    InterlockedDecrement(&_lCacheMutex);
    return ptsi->GetText(acpStart, acpEnd, pchPlain, cchPlainReq, pcchPlainOut,
                         prgRunInfo, ulRunInfoReq, pulRunInfoOut, pacpNext);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\ctf\uim\txtcache.h ===
//
// txtcache.h
//

#ifndef TXTCACHE_H
#define TXTCACHE_H

#define CACHE_SIZE_TEXT     128
#define CACHE_PRELOAD_COUNT (CACHE_SIZE_TEXT/4) // number of chars we ask for ahead of the GetText acpStart to init the cache
#define CACHE_SIZE_RUNINFO  (CACHE_PRELOAD_COUNT+1) // this number should be very small for speed, but must be > CACHE_PRELOAD_COUNT
                                                    // the danger is that we could run out of space before hitting the caller's acpStart

class CProcessTextCache
{
public:

    static HRESULT GetText(ITextStoreACP *ptsi, LONG acpStart, LONG acpEnd,
                           WCHAR *pchPlain, ULONG cchPlainReq, ULONG *pcchPlainOut,
                           TS_RUNINFO *prgRunInfo, ULONG ulRunInfoReq, ULONG *pulRunInfoOut,
                           LONG *pacpNext);

    static void Invalidate(ITextStoreACP *ptsi)
    {
        // not strictly thread safe
        // BUT, since we're appartment threaded, we shouldn't ever invalidate the
        // same ptsi that someone is trying to use simultaneously
        if (_ptsi == ptsi)
        {
            _ptsi = NULL;
        }
    }

private:

    static long _lCacheMutex;
    static ITextStoreACP *_ptsi;
    static LONG _acpStart;
    static LONG _acpEnd;
    static WCHAR _achPlain[CACHE_SIZE_TEXT];
    static TS_RUNINFO _rgRunInfo[CACHE_SIZE_RUNINFO];
    static ULONG _ulRunInfoLen;
};

#endif // TXTCACHE_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\ctf\uim\view.cpp ===
//
// view.cpp
//

#include "private.h"
#include "view.h"
#include "ic.h"
#include "range.h"

DBG_ID_INSTANCE(CContextView);

//+---------------------------------------------------------------------------
//
// ctor
//
//----------------------------------------------------------------------------

CContextView::CContextView(CInputContext *pic, TsViewCookie vcView)
{
    Dbg_MemSetThisNameID(TEXT("CContextView"));

    _pic = pic;
    _pic->AddRef();

    _vcView = vcView;
}

//+---------------------------------------------------------------------------
//
// dtor
//
//----------------------------------------------------------------------------

CContextView::~CContextView()
{
    _pic->Release();
}

//+---------------------------------------------------------------------------
//
// GetRangeFromPoint
//
//----------------------------------------------------------------------------

STDAPI CContextView::GetRangeFromPoint(TfEditCookie ec, const POINT *ppt, DWORD dwFlags, ITfRange **ppRange)
{
    CRange *range;
    IAnchor *pa;
    HRESULT hr;

    if (ppRange == NULL)
        return E_INVALIDARG;

    *ppRange = NULL;

    if (ppt == NULL)
        return E_INVALIDARG;

    if (dwFlags & ~(GXFPF_ROUND_NEAREST | GXFPF_NEAREST))
        return E_INVALIDARG;

    if (!_pic->_IsValidEditCookie(ec, TF_ES_READ))
    {
        Assert(0);
        return TF_E_NOLOCK;
    }

    hr = _pic->_GetTSI()->GetAnchorFromPoint(_vcView, ppt, dwFlags, &pa);

    if (hr != S_OK)
    {
        // the only potentially bogus arg is the view, which could have gone away
        return (hr == E_INVALIDARG) ? TF_E_INVALIDVIEW : E_FAIL;
    }

    hr = E_FAIL;

    range = new CRange;

    if (range == NULL)
        goto Exit;

    if (!range->_InitWithDefaultGravity(_pic, COPY_ANCHORS, pa, pa))
    {
        range->Release();
        goto Exit;
    }

    *ppRange = (ITfRangeAnchor *)range;
    hr = S_OK;

Exit:
    pa->Release();
    return hr;
}

//+---------------------------------------------------------------------------
//
// GetScreenExt
//
//----------------------------------------------------------------------------

STDAPI CContextView::GetScreenExt(RECT *prc)
{
    HRESULT hr;

    if (prc == NULL)
        return E_INVALIDARG;

    hr = _pic->_GetTSI()->GetScreenExt(_vcView, prc);

    if (hr != S_OK)
    {
        hr = (hr == E_INVALIDARG) ? TF_E_INVALIDVIEW : E_FAIL;
    }

    return hr;
}

//+---------------------------------------------------------------------------
//
// GetScreenExtent
//
//----------------------------------------------------------------------------

STDAPI CContextView::GetTextExt(TfEditCookie ec, ITfRange *pRange, RECT *prc, BOOL *pfClipped)
{
    CRange *range;
    HRESULT hr;

    if (prc != NULL)
    {
        memset(prc, 0, sizeof(*prc));
    }
    if (pfClipped != NULL)
    {
        *pfClipped = FALSE;
    }
    if (pRange == NULL || prc == NULL || pfClipped == NULL)
        return E_INVALIDARG;

    if ((range = GetCRange_NA(pRange)) == NULL)
        return E_INVALIDARG;

    if (!VerifySameContext(_pic, range))
        return E_INVALIDARG;

    if (!_pic->_IsValidEditCookie(ec, TF_ES_READ))
    {
        Assert(0);
        return TF_E_NOLOCK;
    }

    range->_QuickCheckCrossedAnchors();

    hr = _pic->_GetTSI()->GetTextExt(_vcView, range->_GetStart(), range->_GetEnd(), prc, pfClipped);

    if (hr != S_OK)
    {
        // the only potentially bogus arg is the view, which could have gone away
        hr = (hr == E_INVALIDARG) ? TF_E_INVALIDVIEW : E_FAIL;
    }

    return hr;
}

//+---------------------------------------------------------------------------
//
// GetWnd
//
//----------------------------------------------------------------------------

STDAPI CContextView::GetWnd(HWND *phwnd)
{
    HRESULT hr;

    if (phwnd == NULL)
        return E_INVALIDARG;

    hr = _pic->_GetTSI()->GetWnd(_vcView, phwnd);

    if (hr != S_OK)
    {
        // the only potentially bogus arg is the view, which could have gone away
        hr = (hr == E_INVALIDARG) ? TF_E_INVALIDVIEW : E_FAIL;
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\ctf\uim\view.h ===
//
// view.h
//

#ifndef VIEW_H
#define VIEW_H

class CInputContext;

class CContextView : public ITfContextView,
                     public CComObjectRootImmx
{
public:
    CContextView(CInputContext *pic, TsViewCookie vcView);
    ~CContextView();

    BEGIN_COM_MAP_IMMX(CContextView)
        COM_INTERFACE_ENTRY(ITfContextView)
    END_COM_MAP_IMMX()

    IMMX_OBJECT_IUNKNOWN_FOR_ATL()

    // ITfContextView
    STDMETHODIMP GetRangeFromPoint(TfEditCookie ec, const POINT *ppt, DWORD dwFlags, ITfRange **ppRange);
    STDMETHODIMP GetTextExt(TfEditCookie ec, ITfRange *pRange, RECT *prc, BOOL *pfClipped);
    STDMETHODIMP GetScreenExt(RECT *prc);
    STDMETHODIMP GetWnd(HWND *phwnd);

private:
    CInputContext *_pic;
    TsViewCookie _vcView;
    DBG_ID_DECLARE;
};

#endif // VIEW_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\ctf\uim\utb.h ===
//
// utb.h
//

#ifndef UTB_H
#define UTB_H

#include "private.h"

#ifndef ASFW_ANY
#define ASFW_ANY    ((DWORD)-1)
#endif

typedef void (*REGISTERSYSTEMTHREAD)(DWORD dw, DWORD reserve);
typedef BOOL (*ALLOWSETFOREGROUNDWINDOW)(DWORD dw);
ALLOWSETFOREGROUNDWINDOW EnsureAllowSetForeground();
REGISTERSYSTEMTHREAD EnsureRegSys();

HRESULT RegisterLangBarNotifySink(ITfLangBarEventSink *pSink, HWND hwnd, DWORD dwFlags, DWORD *pdwCookie);
HRESULT UnregisterLangBarNotifySink(DWORD dwCookie);

BOOL CALLBACK EnumChildWndProc(HWND hwnd, LPARAM lParam);
BOOL FindTrayEtc();
BOOL IsNotifyTrayWnd(HWND hWnd);

void LangBarClosed();

//////////////////////////////////////////////////////////////////////////////
//
// CLangBarMgr
//
//////////////////////////////////////////////////////////////////////////////

// If we ever go crazy for perf, this class could be a single static instance,
// since it has no state.  We need to get rid of the ATL CComCoClass and
// CComObjectRoot to do this.
class CLangBarMgr : 
      public ITfLangBarMgr_P,
      public CComObjectRoot_CreateInstance<CLangBarMgr>
{
public:
    CLangBarMgr();
    ~CLangBarMgr();

    BEGIN_COM_MAP_IMMX(CLangBarMgr)
        COM_INTERFACE_ENTRY(ITfLangBarMgr)
        COM_INTERFACE_ENTRY(ITfLangBarMgr_P)
    END_COM_MAP_IMMX()

    //
    // ITfLangBarManager
    //
    STDMETHODIMP AdviseEventSink(ITfLangBarEventSink *pSink, HWND hwnd, DWORD dwFlags, DWORD *pdwCookie);
    STDMETHODIMP UnadviseEventSink(DWORD dwCookie);
    STDMETHODIMP GetThreadMarshalInterface(DWORD dwThreadId, DWORD dwType, REFIID riid, IUnknown **ppunk);
    STDMETHODIMP GetThreadLangBarItemMgr(DWORD dwThreadId, ITfLangBarItemMgr **pplbi, DWORD *pdwThreadId) ;
    STDMETHODIMP GetInputProcessorProfiles(DWORD dwThreadId, ITfInputProcessorProfiles **ppaip, DWORD *pdwThreadId) ;
    STDMETHODIMP RestoreLastFocus(DWORD *pdwThreadId, BOOL fPrev);
    STDMETHODIMP SetModalInput(ITfLangBarEventSink *pSink, DWORD dwThreadId, DWORD dwFlags);
    STDMETHODIMP ShowFloating(DWORD dwFlags);
    STDMETHODIMP GetShowFloatingStatus(DWORD *pdwFlags);

    //
    // ITfLangBarManager_P
    //
    STDMETHODIMP GetPrevShowFloatingStatus(DWORD *pdwFlags);

    static HRESULT s_ShowFloating(DWORD dwFlags);
    static HRESULT s_GetShowFloatingStatus(DWORD *pdwFlags);

private:
    static BOOL CheckFloatingBits(DWORD dwBits);

    DBG_ID_DECLARE;
};


#endif //UTB_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\ctf\uim\utb.cpp ===
//
// utb.cpp
//

#include "private.h"
#include "tim.h"
#include "utb.h"
#include "ithdmshl.h"
#include "shlapip.h"
#include "cregkey.h"
#include "assembly.h"
#include "mui.h"
#include "timlist.h"
#include "compart.h"
#include "tlapi.h"


HWND g_hwndTray = NULL;
HWND g_hwndNotify = NULL;
HWND g_hwndSysTabControlInTray = NULL;
DWORD g_dwThreadIdTray = NULL;

DBG_ID_INSTANCE(CLangBarMgr);

//////////////////////////////////////////////////////////////////////////////
//
// misc func
//
//////////////////////////////////////////////////////////////////////////////

ALLOWSETFOREGROUNDWINDOW EnsureAllowSetForeground()
{
    static ALLOWSETFOREGROUNDWINDOW g_fnAllowSetForeground = NULL;

    if (!g_fnAllowSetForeground)
    {
        HINSTANCE hUser32 = GetSystemModuleHandle("USER32");
        if (hUser32)
            g_fnAllowSetForeground = (ALLOWSETFOREGROUNDWINDOW)GetProcAddress(hUser32, "AllowSetForegroundWindow");
    }

    return g_fnAllowSetForeground;
}

REGISTERSYSTEMTHREAD EnsureRegSys()
{
    static REGISTERSYSTEMTHREAD g_fnRegSys = NULL;

    if (!g_fnRegSys)
    {
        HINSTANCE hUser32 = GetSystemModuleHandle("USER32");
        if (hUser32)
            g_fnRegSys = (REGISTERSYSTEMTHREAD)GetProcAddress(hUser32, "RegisterSystemThread");
    }

    return g_fnRegSys;
}

//---------------------------------------------------------------------------
//
//  BOOL CALLBACK EnumChildProc(HWND hwnd, LPARAM lParam)
//
//  Look at the class names using GetClassName to see if you can find the
//  Tray notification Window.
//
//---------------------------------------------------------------------------

static const TCHAR c_szNotifyWindow[] = TEXT("TrayNotifyWnd");
static const TCHAR c_szSysTabControl32[] = TEXT("SysTabControl32");
BOOL CALLBACK EnumChildWndProc(HWND hwnd, LPARAM lParam)
{
    char    szString[50];

    if (!GetClassName(hwnd, (LPSTR) szString, sizeof(szString)))
        return FALSE;

    if (!lstrcmp(szString, c_szNotifyWindow))
    {
        g_hwndNotify = hwnd;
    }
    else if (!lstrcmp(szString, c_szSysTabControl32))
    {
        g_hwndSysTabControlInTray = hwnd;
        return FALSE;
    }

    return TRUE;
}

BOOL FindTrayEtc()
{
    if (g_hwndTray)
        return TRUE;

    g_hwndTray = FindWindow(TEXT(WNDCLASS_TRAYNOTIFY), NULL);

    if (!g_hwndTray)
    {
        return FALSE;
    }

    EnumChildWindows(g_hwndTray, (WNDENUMPROC)EnumChildWndProc, (LPARAM)0);

    if (!g_hwndNotify)
    {
        return FALSE;
    }

    g_dwThreadIdTray = GetWindowThreadProcessId(g_hwndTray, NULL);

    return TRUE;
}

BOOL IsNotifyTrayWnd(HWND hWnd)
{
    FindTrayEtc();
    HWND hwndParent = hWnd;
    while (hwndParent)
    {
        if (hwndParent == g_hwndNotify)
            return TRUE;

        if (hwndParent == g_hwndSysTabControlInTray)
            return TRUE;

        hwndParent = GetParent(hwndParent);
    }

    return FALSE;
}

//+---------------------------------------------------------------------------
//
// LangbarClosed
//
//----------------------------------------------------------------------------

void LangBarClosed()
{
    SYSTHREAD *psfn;
    CThreadInputMgr *ptim;

    if (!(psfn = GetSYSTHREAD()))
        return;

    ptim = CThreadInputMgr::_GetThisFromSYSTHREAD(psfn);
    if (!ptim)
        return;

    MySetCompartmentDWORD(g_gaSystem, 
                          ptim, 
                          GUID_COMPARTMENT_HANDWRITING_OPENCLOSE, 
                          0);

    MySetCompartmentDWORD(g_gaSystem, 
                          ptim, 
                          GUID_COMPARTMENT_KEYBOARD_OPENCLOSE, 
                          0);

    MySetCompartmentDWORD(g_gaSystem, 
                          ptim->GetGlobalComp(), 
                          GUID_COMPARTMENT_SPEECH_OPENCLOSE, 
                          0);

}

//////////////////////////////////////////////////////////////////////////////
//
// CLangBarMgr
//
//////////////////////////////////////////////////////////////////////////////

//+---------------------------------------------------------------------------
//
// ctor
//
//----------------------------------------------------------------------------

CLangBarMgr::CLangBarMgr()
{
    Dbg_MemSetThisNameID(TEXT("CLangBarMgr"));
}

//+---------------------------------------------------------------------------
//
// dtor
//
//----------------------------------------------------------------------------

CLangBarMgr::~CLangBarMgr()
{
}

//+---------------------------------------------------------------------------
//
// GetThreadMarshallInterface
//
//----------------------------------------------------------------------------

STDAPI CLangBarMgr::GetThreadMarshalInterface(DWORD dwThreadId, DWORD dwType, REFIID riid, IUnknown **ppunk)
{
    return ::GetThreadMarshalInterface(dwThreadId, dwType, riid, ppunk);
}

//+---------------------------------------------------------------------------
//
// GetThreadLangBarItemMgr
//
//----------------------------------------------------------------------------

STDAPI CLangBarMgr::GetThreadLangBarItemMgr(DWORD dwThreadId, ITfLangBarItemMgr **pplbi, DWORD *pdwThreadId)
{
    return ::GetThreadUIManager(dwThreadId, pplbi, pdwThreadId);
}

//+---------------------------------------------------------------------------
//
// GetInputProcessotProdiles
//
//----------------------------------------------------------------------------

STDAPI CLangBarMgr::GetInputProcessorProfiles(DWORD dwThreadId, ITfInputProcessorProfiles **ppaip, DWORD *pdwThreadId)
{
    return ::GetInputProcessorProfiles(dwThreadId, ppaip, pdwThreadId);
}

//+---------------------------------------------------------------------------
//
// AadviseEventSink
//
//----------------------------------------------------------------------------

STDAPI CLangBarMgr::AdviseEventSink(ITfLangBarEventSink *pSink, HWND hwnd, DWORD dwFlags, DWORD *pdwCookie)
{
    HRESULT hr;

    if (!pSink)
        return E_INVALIDARG;

    hr = RegisterLangBarNotifySink(pSink, hwnd, dwFlags, pdwCookie);

    if (SUCCEEDED(hr))
    {
        OnForegroundChanged(NULL);
        DWORD dwActiveThreadId = GetSharedMemory()->dwFocusThread;
        if (dwActiveThreadId)
        {
            PostThreadMessage(dwActiveThreadId,
                              g_msgPrivate,
                              TFPRIV_REGISTEREDNEWLANGBAR,
                              0);
        }
    }

    return hr;
}

//+---------------------------------------------------------------------------
//
// UnadviseEventSink
//
//----------------------------------------------------------------------------

STDAPI CLangBarMgr::UnadviseEventSink(DWORD dwCookie)
{
    return UnregisterLangBarNotifySink(dwCookie);
}

//+---------------------------------------------------------------------------
//
// RestoreLastFocus
//
//----------------------------------------------------------------------------

STDAPI CLangBarMgr::RestoreLastFocus(DWORD *pdwThreadId, BOOL fPrev)
{
    DWORD dwThreadTarget;
    HWND hwndTarget;
    BOOL bRet = FALSE;
    SYSTHREAD *psfn;
    TL_THREADINFO *ptiTarget = NULL;

    FindTrayEtc();

    if (pdwThreadId)
        *pdwThreadId = 0;

    if ((fPrev && GetSharedMemory()->hwndForegroundPrev && (g_dwThreadIdTray == GetSharedMemory()->dwFocusThread)) || !GetSharedMemory()->hwndForeground)
    {
        dwThreadTarget = GetSharedMemory()->dwFocusThreadPrev;
        hwndTarget = GetSharedMemory()->hwndForegroundPrev;
    }
    else
    {
        dwThreadTarget = GetSharedMemory()->dwFocusThread;
        hwndTarget = GetSharedMemory()->hwndForeground;
    }

    //
    // call RegisterSystemThread() is one bad way to allow SetForeground()
    // under Win98.
    //
    if (IsOn98())
    {
        REGISTERSYSTEMTHREAD fnRegSys = EnsureRegSys();
        if (fnRegSys)
            fnRegSys(0, 0);
    }
#if 0
    else if (IsOnNT5())
    {
        ALLOWSETFOREGROUNDWINDOW fnAllowSetForeground = EnsureAllowSetForeground();
        if (fnAllowSetForeground)
            bRet = fnAllowSetForeground(ASFW_ANY);

#ifdef DEBUG
        if (!bRet)
        {
            TraceMsg(TF_GENERAL, "AllowForegroundWindow failed thread - %x hwnd - %x", dwThreadTarget, hwndTarget);
        }
#endif
    }
#endif

    //
    // RestoreLastFocus() is called in the notify message of TrayIcon.
    // sending message to tray icon area thread causes dead lock on Win9x.
    //
    ptiTarget = g_timlist.IsThreadId(dwThreadTarget);
    psfn = GetSYSTHREAD();

    if (ptiTarget && 
        psfn &&
        (ptiTarget->dwMarshalWaitingThread != psfn->dwThreadId))
    {
        TL_THREADINFO *ptiCur = NULL;
        if (psfn->pti && (psfn->pti->dwThreadId == psfn->dwThreadId))
            ptiCur = psfn->pti;

        if (ptiCur)
            ptiCur->dwFlags |= TLF_INSFW;

        bRet = SetForegroundWindow(hwndTarget);

        if (ptiCur)
            ptiCur->dwFlags &= ~TLF_INSFW;

    }

#ifdef DEBUG
    if (!bRet)
    {
        TraceMsg(TF_GENERAL, "SetForegroundWindow failed thread - %x hwnd - %x", dwThreadTarget, hwndTarget);
    }
#endif

    if (bRet && pdwThreadId)
        *pdwThreadId = dwThreadTarget;

    // Issue:
    // we want to restore the focus, too. But we need to go to the target
    // thread to call SetFocus()....
    // SetFocus(g_hwndFocus);

    return bRet ? S_OK : S_FALSE;
}

//+---------------------------------------------------------------------------
//
// SetModalInput
//
//----------------------------------------------------------------------------

STDAPI CLangBarMgr::SetModalInput(ITfLangBarEventSink *pSink, DWORD dwThreadId, DWORD dwFlags)
{
    SetModalLBarSink(dwThreadId, pSink ? TRUE : NULL, dwFlags);
    return S_OK;
}

//+---------------------------------------------------------------------------
//
// ShowFloating
//
//----------------------------------------------------------------------------
#define REG_TF_SFT_SHOWNORMAL    (DWORD)0
#define REG_TF_SFT_DOCK          (DWORD)1
#define REG_TF_SFT_MINIMIZED     (DWORD)2
#define REG_TF_SFT_HIDDEN        (DWORD)3
#define REG_TF_SFT_DESKBAND      (DWORD)4

#define TF_SFT_BITS_SHOWSTATUS    (TF_SFT_SHOWNORMAL | TF_SFT_DOCK | TF_SFT_MINIMIZED | TF_SFT_HIDDEN | TF_SFT_DESKBAND)
#define TF_SFT_BITS_TRANSPARENCY  (TF_SFT_NOTRANSPARENCY | TF_SFT_LOWTRANSPARENCY | TF_SFT_HIGHTRANSPARENCY)
#define TF_SFT_BITS_LABELS        (TF_SFT_LABELS | TF_SFT_NOLABELS)
#define TF_SFT_BITS_EXTRAICONSONMINIMIZED    (TF_SFT_EXTRAICONSONMINIMIZED | TF_SFT_NOEXTRAICONSONMINIMIZED)

STDAPI CLangBarMgr::ShowFloating(DWORD dwFlags)
{
    // 
    //  check params
    // 
    if (!CheckFloatingBits(dwFlags))
        return E_INVALIDARG;

    return s_ShowFloating(dwFlags);
}

__inline BOOL IsNotPowerOf2(DWORD dw)
{
    return (dw & (dw - 1));
}

BOOL CLangBarMgr::CheckFloatingBits(DWORD dwBits)
{
    //
    // we allow only one bit in each group.
    // if there are two or more bits are set there, return FALSE.
    //

    if (IsNotPowerOf2(dwBits & TF_SFT_BITS_SHOWSTATUS))
        return FALSE;

    if (IsNotPowerOf2(dwBits & TF_SFT_BITS_TRANSPARENCY))
        return FALSE;

    if (IsNotPowerOf2(dwBits & TF_SFT_BITS_LABELS))
        return FALSE;

    if (IsNotPowerOf2(dwBits &  TF_SFT_BITS_EXTRAICONSONMINIMIZED))
        return FALSE;

    return TRUE;
}

HRESULT CLangBarMgr::s_ShowFloating(DWORD dwFlags)
{
    DWORD dwStatus;
    CMyRegKey key;

    //
    // keep tracking the prev show floating sttaus.
    //
    if (SUCCEEDED(s_GetShowFloatingStatus(&dwStatus)))
        GetSharedMemory()->dwPrevShowFloatingStatus = dwStatus;
    
    if (key.Create(HKEY_CURRENT_USER, c_szLangBarKey) != S_OK)
        return E_FAIL;

    if (dwFlags & TF_SFT_SHOWNORMAL)
    {
        key.SetValue(REG_TF_SFT_SHOWNORMAL, c_szShowStatus);
    }
    else if (dwFlags & TF_SFT_DOCK)
    {
        key.SetValue(REG_TF_SFT_DOCK, c_szShowStatus);
    }
    else if (dwFlags & TF_SFT_MINIMIZED)
    {
        key.SetValue(REG_TF_SFT_MINIMIZED, c_szShowStatus);
    }
    else if (dwFlags & TF_SFT_HIDDEN)
    {
        key.SetValue(REG_TF_SFT_HIDDEN, c_szShowStatus);
    }
    else if (dwFlags & TF_SFT_DESKBAND)
    {
        key.SetValue(REG_TF_SFT_DESKBAND, c_szShowStatus);
    }

    if (dwFlags & TF_SFT_NOTRANSPARENCY)
    {
        key.SetValue((DWORD)255, c_szTransparency);
    }
    else if (dwFlags & TF_SFT_LOWTRANSPARENCY)
    {
        key.SetValue((DWORD)128, c_szTransparency);
    }
    else if (dwFlags & TF_SFT_HIGHTRANSPARENCY)
    {
        key.SetValue((DWORD)64, c_szTransparency);
    }

    if (dwFlags & TF_SFT_LABELS)
    {
        key.SetValue((DWORD)1, c_szLabel);
    }
    else if (dwFlags & TF_SFT_NOLABELS)
    {
        key.SetValue((DWORD)0, c_szLabel);
    }

    if (dwFlags & TF_SFT_EXTRAICONSONMINIMIZED)
    {
        key.SetValue((DWORD)1, c_szExtraIconsOnMinimized);
    }
    else if (dwFlags & TF_SFT_NOEXTRAICONSONMINIMIZED)
    {
        key.SetValue((DWORD)0, c_szExtraIconsOnMinimized);
    }

    if (SUCCEEDED(s_GetShowFloatingStatus(&dwStatus)))
        MakeSetFocusNotify(g_msgShowFloating, 0, (LPARAM)dwStatus);

    if (dwStatus & TF_SFT_HIDDEN)
        PostTimListMessage(TLF_TIMACTIVE, 0, g_msgPrivate, TFPRIV_LANGBARCLOSED, 0);

    return S_OK;
}

//+---------------------------------------------------------------------------
//
// GetShowFloatingStatus
//
//----------------------------------------------------------------------------

STDAPI CLangBarMgr::GetShowFloatingStatus(DWORD *pdwFlags)
{
    if (!pdwFlags)
        return E_INVALIDARG;

    return s_GetShowFloatingStatus(pdwFlags);
}

//+---------------------------------------------------------------------------
//
// GetPrevShowFloatingStatus
//
//----------------------------------------------------------------------------

STDAPI CLangBarMgr::GetPrevShowFloatingStatus(DWORD *pdwFlags)
{
    if (!pdwFlags)
        return E_INVALIDARG;

    DWORD dwFlags;
    if (!GetSharedMemory()->dwPrevShowFloatingStatus)
    {
        s_GetShowFloatingStatus(&dwFlags);
        GetSharedMemory()->dwPrevShowFloatingStatus = dwFlags;
    }

    *pdwFlags = GetSharedMemory()->dwPrevShowFloatingStatus;
    return S_OK;
}

HRESULT CLangBarMgr::s_GetShowFloatingStatus(DWORD *pdwFlags)
{
    CMyRegKey key;
    DWORD dwFlags = 0;

    if (!pdwFlags)
        return E_INVALIDARG;

    if (key.Open(HKEY_CURRENT_USER, c_szLangBarKey, KEY_READ) != S_OK)
    {
        // return default.
        if (IsFELangId(GetPlatformResourceLangID()))
            *pdwFlags = (TF_SFT_SHOWNORMAL | 
                         TF_SFT_NOTRANSPARENCY | 
                         TF_SFT_NOLABELS | 
                         TF_SFT_EXTRAICONSONMINIMIZED);
        else
        {
            if (IsOnNT51())
            {
                *pdwFlags = (TF_SFT_DESKBAND |
                             TF_SFT_NOTRANSPARENCY |
                             TF_SFT_LABELS |
                             TF_SFT_NOEXTRAICONSONMINIMIZED);
            }
            else
            {
                *pdwFlags = (TF_SFT_SHOWNORMAL |
                             TF_SFT_NOTRANSPARENCY |
                             TF_SFT_LABELS |
                             TF_SFT_NOEXTRAICONSONMINIMIZED);
            }
        }
        return S_OK;
    }

    DWORD dw;
    dw = 0;
    if (key.QueryValue(dw, c_szShowStatus) == S_OK)
    {
        switch (dw)
        {
            case REG_TF_SFT_SHOWNORMAL: dwFlags |= TF_SFT_SHOWNORMAL;  break;
            case REG_TF_SFT_DOCK:       dwFlags |= TF_SFT_DOCK;        break;
            case REG_TF_SFT_MINIMIZED:
                //
                // BugBug#452872 - Only take care of GetShowFloating case,
                // since SetShowFloating require the regression testing.
                // This is simple fix to support the upgrade Window XP from the
                // minimized language UI status platform.
                //
                dwFlags |= IsOnNT51() ? TF_SFT_DESKBAND : TF_SFT_MINIMIZED;
                break;
            case REG_TF_SFT_HIDDEN:     dwFlags |= TF_SFT_HIDDEN;      break;
            case REG_TF_SFT_DESKBAND:   dwFlags |= TF_SFT_DESKBAND;    break;
            default:                    dwFlags |= TF_SFT_SHOWNORMAL;  break;
        }
    }
    else
    {
        if (IsOnNT51() && !IsFELangId(GetPlatformResourceLangID()))
        {
            dwFlags |= TF_SFT_DESKBAND;
        }
        else
        {
            dwFlags |= TF_SFT_SHOWNORMAL;
        }
    }

    dw = 0;
    if (key.QueryValue(dw, c_szTransparency) == S_OK)
    {
        switch (dw)
        {
            case 255: dwFlags |= TF_SFT_NOTRANSPARENCY;    break;
            case 128: dwFlags |= TF_SFT_LOWTRANSPARENCY;   break;
            case 64:  dwFlags |= TF_SFT_HIGHTRANSPARENCY;  break;
            default:  dwFlags |= TF_SFT_NOTRANSPARENCY;    break;
        }
    }
    else
    {
        dwFlags |= TF_SFT_NOTRANSPARENCY;
    }

    dw = 0;
    if (key.QueryValue(dw, c_szLabel) == S_OK)
    {
        switch (dw)
        {
            case 1:   dwFlags |= TF_SFT_LABELS;      break;
            default:  dwFlags |= TF_SFT_NOLABELS;    break;
        }
    }
    else
    {
        if (IsFELangId(GetPlatformResourceLangID()))
            dwFlags |= TF_SFT_NOLABELS;
        else
            dwFlags |= TF_SFT_LABELS;
    }

    dw = 0;
    if (key.QueryValue(dw, c_szExtraIconsOnMinimized) == S_OK)
    {
        switch (dw)
        {
            case 1:   dwFlags |= TF_SFT_EXTRAICONSONMINIMIZED;      break;
            default:  dwFlags |= TF_SFT_NOEXTRAICONSONMINIMIZED;    break;
        }
    }
    else
    {
        if (IsFELangId(GetPlatformResourceLangID()))
            dwFlags |= TF_SFT_EXTRAICONSONMINIMIZED;
        else
            dwFlags |= TF_SFT_NOEXTRAICONSONMINIMIZED;
    }

    *pdwFlags = dwFlags;
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\ctf\uuid\ctfspui_g.c ===
#ifdef __cplusplus
extern "C"{
#endif 

#ifndef __IID_DEFINED__
#define __IID_DEFINED__

typedef struct _IID
{
    unsigned long x;
    unsigned short s1;
    unsigned short s2;
    unsigned char  c[8];
} IID;

#endif // __IID_DEFINED__

#define GUID IID

#ifndef CLSID_DEFINED
#define CLSID_DEFINED
typedef IID CLSID;
#endif // CLSID_DEFINED

/* 1443904b-34e4-40f6-b30f-6beb81267b80 */
const CLSID CLSID_SpeechUIServer = { 
    0x1443904b,
    0x34e4,
    0x40f6,
    {0xb3, 0x0f, 0x6b, 0xeb, 0x81, 0x26, 0x7b, 0x80}
  };

#ifdef __cplusplus
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\ctf\uuid\ctffunc_g.c ===
#ifdef __cplusplus
extern "C"{
#endif 


#ifndef __IID_DEFINED__
#define __IID_DEFINED__

typedef struct _IID
{
    unsigned long x;
    unsigned short s1;
    unsigned short s2;
    unsigned char  c[8];
} IID;

#endif // __IID_DEFINED__

#define GUID IID

#ifndef CLSID_DEFINED
#define CLSID_DEFINED
typedef IID CLSID;
#endif // CLSID_DEFINED

/* dcbd6fa8-032f-11d3-b5b1-00c04fc324a1 */
const CLSID CLSID_SapiLayr  = {
    0xdcbd6fa8,
    0x032f,
    0x11d3,
    {0xb5, 0xb1, 0x00, 0xc0, 0x4f, 0xc3, 0x24, 0xa1}
};

// FE7C68F6-DED1-4787-9AB5-AF15E8B91A0F
const GUID GUID_TFCAT_TIP_MASTERLM =
{0xFE7C68F6, 0xDED1, 0x4787, {0x9A, 0xB5, 0xAF, 0x15, 0xE8, 0xB9, 0x1A, 0x0F} };

// FF341C48-DB92-46E5-8830-18B8015BAF49
const GUID GUID_MASTERLM_FUNCTIONPROVIDER =
{0xFF341C48, 0xDB92, 0x46E5, {0x88, 0x30, 0x18, 0xB8, 0x01, 0x5B, 0xAF, 0x49} };

// 23B2BE84-9EBE-4820-B29F-70FCA97E7D57 
const GUID GUID_LMLATTICE_VER1_0 = 
{0x23B2BE84, 0x9EBE, 0x4820, {0xB2, 0x9F, 0x70, 0xFC, 0xA9, 0x7E, 0x7D, 0x57} };

// 8189B801-D62F-400A-8C12-E29340967BA8 
const GUID GUID_PROP_LMLATTICE = 
{0x8189B801, 0xD62F, 0x400A, {0x8C, 0x12, 0xE2, 0x93, 0x40, 0x96, 0x7B, 0xA8} };
#ifdef __cplusplus
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\directui\new\dll\directui.cpp ===
#include "stdafx.h"

//////////////////////////////////////////////////////////////////////////////
HRESULT DuiProcessAttach()
{
    return S_OK;
}

//////////////////////////////////////////////////////////////////////////////
HRESULT DuiProcessDetach()
{
    return S_OK;
}


//////////////////////////////////////////////////////////////////////////////
extern "C" BOOL WINAPI DllMain(HINSTANCE hModule, DWORD dwReason, LPVOID lpReserved)
{
    BOOL fRet = TRUE;

    UNREFERENCED_PARAMETER(hModule);
    UNREFERENCED_PARAMETER(lpReserved);
    

    switch (dwReason)
    {
    case DLL_PROCESS_ATTACH:
        if (FAILED(DuiProcessAttach())) {
            fRet = FALSE;
        }
        break;
        
    case DLL_PROCESS_DETACH:
        if (FAILED(DuiProcessDetach())) {
            fRet = FALSE;
        }
        break;

    case DLL_THREAD_ATTACH:
        break;

    case DLL_THREAD_DETACH:
        break;
    }

    return fRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\directui\new\dll\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
//

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NO_MFC                     1
#define _APS_NEXT_RESOURCE_VALUE        100
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1000
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\ctf\uuid\msctf_g.c ===
#ifdef __cplusplus
extern "C"{
#endif 


#ifndef __IID_DEFINED__
#define __IID_DEFINED__

typedef struct _IID
{
    unsigned long x;
    unsigned short s1;
    unsigned short s2;
    unsigned char  c[8];
} IID;

#endif // __IID_DEFINED__

#define GUID IID

#ifndef CLSID_DEFINED
#define CLSID_DEFINED
typedef IID CLSID;
#endif // CLSID_DEFINED

#include "cicclsid.c"

/* f1e2d520-0969-11d3-8df0-00105a2799b5 */
const GUID GUID_PROP_TEXTOWNER = { 
    0xf1e2d520,
    0x0969,
    0x11d3,
    {0x8d, 0xf0, 0x00, 0x10, 0x5a, 0x27, 0x99, 0xb5}
  };

/* 34b45670-7526-11d2-a147-00105a2799b5 */
const GUID GUID_PROP_ATTRIBUTE = { 
    0x34b45670,
    0x7526,
    0x11d2,
    {0xa1, 0x47, 0x00, 0x10, 0x5a, 0x27, 0x99, 0xb5}
  };


/* 3280ce20-8032-11d2-b603-00105a2799b5 */
const GUID GUID_PROP_LANGID = { 
    0x3280ce20,
    0x8032,
    0x11d2,
    {0xb6, 0x03, 0x00, 0x10, 0x5a, 0x27, 0x99, 0xb5}
  };

/* 5463f7c0-8e31-11d2-bf46-00105a2799b5 */
const GUID GUID_PROP_READING = { 
    0x5463f7c0,
    0x8e31,
    0x11d2,
    {0xbf, 0x46, 0x00, 0x10, 0x5a, 0x27, 0x99, 0xb5}
  };

/* e12ac060-af15-11d2-afc5-00105a2799b5 */
const GUID GUID_PROP_COMPOSING = {
    0xe12ac060,
    0xaf15,
    0x11d2,
    {0xaf, 0xc5, 0x00, 0x10, 0x5a, 0x27, 0x99, 0xb5}
  };

/* 9a698bb0-0f21-11d3-8df1-00105a2799b5 */
const GUID GUID_SYSTEM_FUNCTIONPROVIDER = { 
    0x9a698bb0,
    0x0f21,
    0x11d3,
    {0x8d, 0xf1, 0x00, 0x10, 0x5a, 0x27, 0x99, 0xb5}
  };

/* 4caef01e-12af-4b0e-9db1-a6ec5b881208 */
const GUID GUID_APP_FUNCTIONPROVIDER = { 
    0x4caef01e,
    0x12af,
    0x4b0e,
    {0x9d, 0xb1, 0xa6, 0xec, 0x5b, 0x88, 0x12, 0x08}
  };


/* 534c48c1-0607-4098-a521-4fc899c73e90 */
const GUID GUID_TFCAT_CATEGORY_OF_TIP = { 
    0x534c48c1,
    0x0607,
    0x4098,
    {0xa5, 0x21, 0x4f, 0xc8, 0x99, 0xc7, 0x3e, 0x90}
  };

/* 34745c63-b2f0-4784-8b67-5e12c8701a31 */
const GUID GUID_TFCAT_TIP_KEYBOARD = { 
    0x34745c63,
    0xb2f0,
    0x4784,
    {0x8b, 0x67, 0x5e, 0x12, 0xc8, 0x70, 0x1a, 0x31}
  };

/* b5a73cd1-8355-426b-a161-259808f26b14 */
const GUID GUID_TFCAT_TIP_SPEECH = { 
    0xb5a73cd1,
    0x8355,
    0x426b,
    {0xa1, 0x61, 0x25, 0x98, 0x08, 0xf2, 0x6b, 0x14}
  };

/* 246ecb87-c2f2-4abe-905b-c8b38add2c43 */
const GUID GUID_TFCAT_TIP_HANDWRITING = { 
    0x246ecb87,
    0xc2f2,
    0x4abe,
    {0x90, 0x5b, 0xc8, 0xb3, 0x8a, 0xdd, 0x2c, 0x43}
  };

/* 9b7be3a9-e8ab-4d47-a8fe-254fa423436d */
const GUID GUID_TFCAT_PROP_AUDIODATA = { 
    0x9b7be3a9,
    0xe8ab,
    0x4d47,
    {0xa8, 0xfe, 0x25, 0x4f, 0xa4, 0x23, 0x43, 0x6d}
  };

/* 7c6a82ae-b0d7-4f14-a745-14f28b009d61 */
const GUID GUID_TFCAT_PROP_INKDATA = { 
    0x7c6a82ae,
    0xb0d7,
    0x4f14,
    {0xa7, 0x45, 0x14, 0xf2, 0x8b, 0x00, 0x9d, 0x61}
  };

/* 51af2086-cc6b-457d-b5aa-8b19dc290ab4 */
const GUID GUID_COMPARTMENT_SAPI_AUDIO= {
    0x51af2086,
    0xcc6b,
    0x457d,
    {0xb5, 0xaa, 0x8b, 0x19, 0xdc, 0x29, 0x0a, 0xb4}
};

/* 71a5b253-1951-466b-9fbc-9c8808fa84f2 */
const GUID GUID_COMPARTMENT_KEYBOARD_DISABLED = { 
    0x71a5b253,
    0x1951,
    0x466b,
    {0x9f, 0xbc, 0x9c, 0x88, 0x08, 0xfa, 0x84, 0xf2}
  };

/* 58273aad-01bb-4164-95c6-755ba0b5162d */
const GUID GUID_COMPARTMENT_KEYBOARD_OPENCLOSE = { 
    0x58273aad,
    0x01bb,
    0x4164,
    {0x95, 0xc6, 0x75, 0x5b, 0xa0, 0xb5, 0x16, 0x2d}
  };

/* f9ae2c6b-1866-4361-af72-7aa30948890e */
const GUID GUID_COMPARTMENT_HANDWRITING_OPENCLOSE = { 
    0xf9ae2c6b,
    0x1866,
    0x4361,
    {0xaf, 0x72, 0x7a, 0xa3, 0x09, 0x48, 0x89, 0x0e}
  };

/* 56c5c607-0703-4e59-8e52-cbc84e8bbe35 */
const GUID GUID_COMPARTMENT_SPEECH_DISABLED = { 
    0x56c5c607,
    0x0703,
    0x4e59,
    {0x8e, 0x52, 0xcb, 0xc8, 0x4e, 0x8b, 0xbe, 0x35}
  };

/* 544d6a63-e2e8-4752-bbd1-000960bca083 */
const GUID GUID_COMPARTMENT_SPEECH_OPENCLOSE = { 
    0x544d6a63,
    0xe2e8,
    0x4752,
    {0xbb, 0xd1, 0x00, 0x09, 0x60, 0xbc, 0xa0, 0x83}
  };

/* 2a54fe8e-0d08-460c-a75d-87035ff436c5 */
const GUID GUID_COMPARTMENT_SPEECH_GLOBALSTATE = { 
    0x2a54fe8e, 
    0x0d08, 
    0x460c, 
    {0xa7, 0x5d, 0x87, 0x03, 0x5f, 0xf4, 0x36, 0xc5}
  };

/* 5497f516-ee91-436e-b946-aa2c05f1ac5b */
const GUID GUID_COMPARTMENT_CONVERSIONMODEBIAS = {
    0x5497f516,
    0xee91,
    0x436e,
    {0xb9, 0x46, 0xaa, 0x2c, 0x05, 0xf1, 0xac, 0x5b}
  };

/* 372E0716-974F-40AC-A088-08CDC92EBFBC */
const GUID GUID_PROP_MODEBIAS = {
    0x372E0716,
    0x974F,
    0x40AC,
    {0xA0, 0x88, 0x08, 0xCD, 0xC9, 0x2E, 0xBF, 0xBC}
  };

/* b6592511-bcee-4122-a7c4-09f4b3fa4396 */
const GUID GUID_COMPARTMENT_KEYBOARD_INPUTMODE = {
    0xb6592511,
    0xbcee,
    0x4122,
    {0xa7, 0xc4, 0x09, 0xf4, 0xb3, 0xfa, 0x43, 0x96}
  };


/* GUID_NULL */
const GUID GUID_MODEBIAS_NONE = {
    0x00000000,
    0x0000,
    0x0000,
    {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}
  };

/* 8b0e54d9-63f2-4c68-84d4-79aee7a59f09 */
const GUID GUID_MODEBIAS_URLHISTORY = {
    0x8b0e54d9,
    0x63f2,
    0x4c68,
    {0x84, 0xd4, 0x79, 0xae, 0xe7, 0xa5, 0x9f, 0x09}
  };

/* d7f707fe-44c6-4fca-8e76-86ab50c7931b */
const GUID GUID_MODEBIAS_FILENAME = {
    0xd7f707fe,
    0x44c6,
    0x4fca,
    {0x8e, 0x76, 0x86, 0xab, 0x50, 0xc7, 0x93, 0x1b}
  };


/* e31643a3-6466-4cbf-8d8b-0bd4d8545461 */
const GUID GUID_MODEBIAS_READING = {
    0xe31643a3,
    0x6466,
    0x4cbf,
    {0x8d, 0x8b, 0x0b, 0xd4, 0xd8, 0x54, 0x54, 0x61}
  };


/* f2bdb372-7f61-4039-92ef-1c35599f0222 */
const GUID GUID_MODEBIAS_DATETIME = {
    0xf2bdb372,
    0x7f61,
    0x4039,
    {0x92, 0xef, 0x1c, 0x35, 0x59, 0x9f, 0x02, 0x22}
  };

/* fddc10f0-d239-49bf-b8fc-5410caaa427e */
const GUID GUID_MODEBIAS_NAME = {
    0xfddc10f0,
    0xd239,
    0x49bf,
    {0xb8, 0xfc, 0x54, 0x10, 0xca, 0xaa, 0x42, 0x7e}
  };

/* 0f4ec104-1790-443b-95f1-e10f939d6546 */
const GUID GUID_MODEBIAS_CONVERSATION = {
    0x0f4ec104,
    0x1790,
    0x443b,
    {0x95, 0xf1, 0xe1, 0x0f, 0x93, 0x9d, 0x65, 0x46}
  };

/* 4021766c-e872-48fd-9cee-4ec5c75e16c3 */
const GUID GUID_MODEBIAS_NUMERIC = {
    0x4021766c,
    0xe872,
    0x48fd,
    {0x9c, 0xee, 0x4e, 0xc5, 0xc7, 0x5e, 0x16, 0xc3}
  };

/* d73d316e-9b91-46f1-a280-31597f52c694 */
const GUID GUID_MODEBIAS_HIRAGANA = {
    0xd73d316e,
    0x9b91,
    0x46f1,
    {0xa2, 0x80, 0x31, 0x59, 0x7f, 0x52, 0xc6, 0x94}
  };

/* 2e0eeddd-3a1a-499e-8543-3c7ee7949811 */
const GUID GUID_MODEBIAS_KATAKANA = {
    0x2e0eeddd,
    0x3a1a,
    0x499e,
    {0x85, 0x43, 0x3c, 0x7e, 0xe7, 0x94, 0x98, 0x11}
  };


/* 76ef0541-23b3-4d77-a074-691801ccea17 */
const GUID GUID_MODEBIAS_HANGUL = {
    0x76ef0541,
    0x23b3,
    0x4d77,
    {0xa0, 0x74, 0x69, 0x18, 0x01, 0xcc, 0xea, 0x17}
  };

/* 7add26de-4328-489b-83ae-6493750cad5c */
const GUID GUID_MODEBIAS_CHINESE = { 
    0x7add26de,
    0x4328,
    0x489b,
    {0x83, 0xae, 0x64, 0x93, 0x75, 0x0c, 0xad, 0x5c}
  };

/* 005f6b63-78d4-41cc-8859-485ca821a795 */
const GUID GUID_MODEBIAS_HALFWIDTHKATAKANA = {
    0x005f6b63,
    0x78d4,
    0x41cc,
    {0x88, 0x59, 0x48, 0x5c, 0xa8, 0x21, 0xa7, 0x95}
  };

/* 81489fb8-b36a-473d-8146-e4a2258b24ae */
const GUID GUID_MODEBIAS_FULLWIDTHALPHANUMERIC = {
    0x81489fb8,
    0xb36a,
    0x473d,
    {0x81, 0x46, 0xe4, 0xa2, 0x25, 0x8b, 0x24, 0xae}
  };

/* c6f24fc0-4479-46ed-938a-6052b1653d3b */
const GUID GUID_MODEBIAS_HALFWIDTHALPHANUMERIC = {
    0xc6f24fc0,
    0x4479,
    0x46ed,
    {0x93, 0x8a, 0x60, 0x52, 0xb1, 0x65, 0x3d, 0x3b}
  };

/* c01ae6c9-45b5-4fd0-9cb1-9f4cebc39fea */
const GUID GUID_MODEBIAS_FULLWIDTHHANGUL = { 
    0xc01ae6c9,
    0x45b5,
    0x4fd0,
    {0x9c, 0xb1, 0x9f, 0x4c, 0xeb, 0xc3, 0x9f, 0xea}
  };


/* 24af3031-852d-40a2-bc09-8992898ce722 */
const GUID GUID_TFCAT_PROPSTYLE_CUSTOM = { 
    0x24af3031,
    0x852d,
    0x40a2,
    {0xbc, 0x09, 0x89, 0x92, 0x89, 0x8c, 0xe7, 0x22}
  };

/* 565fb8d8-6bd4-4ca1-b223-0f2ccb8f4f96 */
const GUID GUID_TFCAT_PROPSTYLE_STATIC = { 
    0x565fb8d8,
    0x6bd4,
    0x4ca1,
    {0xb2, 0x23, 0x0f, 0x2c, 0xcb, 0x8f, 0x4f, 0x96}
  };

/* 85f9794b-4d19-40d8-8864-4e747371a66d */
const GUID GUID_TFCAT_PROPSTYLE_STATICCOMPACT = { 
    0x85f9794b,
    0x4d19,
    0x40d8,
    {0x88, 0x64, 0x4e, 0x74, 0x73, 0x71, 0xa6, 0x6d}
  };

/* 046b8c80-1647-40f7-9b21-b93b81aabc1b */
const GUID GUID_TFCAT_DISPLAYATTRIBUTEPROVIDER = { 
    0x046b8c80,
    0x1647,
    0x40f7,
    {0x9b, 0x21, 0xb9, 0x3b, 0x81, 0xaa, 0xbc, 0x1b}
  };

/* b95f181b-ea4c-4af1-8056-7c321abbb091 */
const GUID GUID_TFCAT_DISPLAYATTRIBUTEPROPERTY = { 
    0xb95f181b,
    0xea4c,
    0x4af1,
    {0x80, 0x56, 0x7c, 0x32, 0x1a, 0xbb, 0xb0, 0x91}
  };

/* 1edb55cc-58f0-4592-aae1-fe51f43b95c5 */
const GUID GUID_COMPARTMENT_SPEECH_DICTATIONSTAT = {
    0x1edb55cc,
    0x58f0,
    0x4592,
    {0xaa, 0xe1, 0xfe, 0x51, 0xf4, 0x3b, 0x95, 0xc5 }
  };
/* 575F3783-70C8-47C8-AE5D-91A01A1F7592 */
const GUID GUID_COMPARTMENT_PERSISTMENUENABLED = {
    0x575F3783,
    0x70C8,
    0x47C8,
    {0xAE, 0x5D, 0x91, 0xA0, 0x1A, 0x1F, 0x75, 0x92 }
  };

/* D92016F0-9367-4FE7-9ABF-BC59DACBE0E3 */
const GUID GUID_COMPARTMENT_SPEECH_UI_STATUS = {
    0xD92016F0,
    0x9367,
    0x4FE7,
    {0x9A, 0xBF, 0xBC, 0x59, 0xDA, 0xCB, 0xE0, 0xE3 }
  };

/* d7487dbf-804e-41c5-894d-ad96fd4eea13 */
const GUID GUID_COMPARTMENT_EMPTYCONTEXT = { 
    0xd7487dbf,
    0x804e,
    0x41c5,
    {0x89, 0x4d, 0xad, 0x96, 0xfd, 0x4e, 0xea, 0x13}
  };

/* 148ca3ec-0366-401c-8d75-ed978d85fbc9 */
const GUID GUID_COMPARTMENT_TIPUISTATUS = {
    0x148ca3ec,
    0x0366,
    0x401c,
    {0x8d, 0x75, 0xed, 0x97, 0x8d, 0x85, 0xfb, 0xc9}
  };

/* fb6c5c2d-4e83-4bb6-91a2-e019bff6762d */
const GUID GUID_COMPARTMENT_SPEECH_CFGMENU = { 
    0xfb6c5c2d,
    0x4e83,
    0x4bb6,
    {0x91, 0xa2, 0xe0, 0x19, 0xbf, 0xf6, 0x76, 0x2d}
  };

/* D02F24A1-942D-422E-8D99-B4F2ADDEE999 */
const GUID GUID_LBI_SAPILAYR_CFGMENUBUTTON = {
    0xD02F24A1,
    0x942D,
    0x422E,
    {0x8D, 0x99, 0xB4, 0xF2, 0xAD, 0xDE, 0xE9, 0x99}
  };

#ifdef __cplusplus
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\directui\new\dll\stdafx.h ===
#pragma once
#include <windows.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\ctf\uuid\cicclsid.c ===
//
//  !! WARNING WARNING WARNING !!
// 
//  THIS FILE WAS GENERATED BY CICCLSID.BAT.
//  THESE CLSIDS MUST BE SAME WITH *.RGS FILES UNDER UIM.
//


/* 529A9E6B-6587-4F23-AB9E-9C7D683E3C50 */
const CLSID CLSID_TF_ThreadMgr = { 
    0x529A9E6B,
    0x6587,
    0x4F23,
    {0xAB, 0x9E, 0x9C, 0x7D, 0x68, 0x3E, 0x3C, 0x50}
  };
/* EBB08C45-6C4A-4FDC-AE53-4EB8C4C7DB8E */
const CLSID CLSID_TF_LangBarMgr = { 
    0xEBB08C45,
    0x6C4A,
    0x4FDC,
    {0xAE, 0x53, 0x4E, 0xB8, 0xC4, 0xC7, 0xDB, 0x8E}
  };
/* 3CE74DE4-53D3-4D74-8B83-431B3828BA53 */
const CLSID CLSID_TF_DisplayAttributeMgr = { 
    0x3CE74DE4,
    0x53D3,
    0x4D74,
    {0x8B, 0x83, 0x43, 0x1B, 0x38, 0x28, 0xBA, 0x53}
  };
/* A4B544A1-438D-4B41-9325-869523E2D6C7 */
const CLSID CLSID_TF_CategoryMgr = { 
    0xA4B544A1,
    0x438D,
    0x4B41,
    {0x93, 0x25, 0x86, 0x95, 0x23, 0xE2, 0xD6, 0xC7}
  };
/* 33C53A50-F456-4884-B049-85FD643ECFED */
const CLSID CLSID_TF_InputProcessorProfiles = { 
    0x33C53A50,
    0xF456,
    0x4884,
    {0xB0, 0x49, 0x85, 0xFD, 0x64, 0x3E, 0xCF, 0xED}
  };
/* B9931692-A2B3-4FAB-BF33-9EC6F9FB96AC */
const CLSID CLSID_TF_LangBarItemMgr = { 
    0xB9931692,
    0xA2B3,
    0x4FAB,
    {0xBF, 0x33, 0x9E, 0xC6, 0xF9, 0xFB, 0x96, 0xAC}
  };

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\directui\new\properties\value.cpp ===
#include "stdafx.h"
#include "value.h"

/////////////////////////////////////////////////////////////////////////////
class CEmptyValue : IValue
{
public:
    static HRESULT Create(OUT IValue ** ppValue)
    {
        if (ppValue == NULL) {
            return E_POINTER;
        } else {
            *ppValue = NULL;
        }

        CEmptyValue * pEmptyValue  = new CEmptyValue();
        if (pEmptyValue == NULL) {
            return E_OUTOFMEMORY;
        }

        pEmptyValue->m_cRefs = 1;
        *ppValue = static_cast<IValue *>(pEmptyValue);
        return S_OK;
    }

    STDMETHOD_(ULONG, AddRef)(void)
    {
        return InterlockedIncrement(&m_cRefs);
    }

    STDMETHOD_(ULONG, Release)(void)
    {
        LONG cRefs = InterlockedDecrement(&m_cRefs);
        if (cRefs == 0) {
            delete this;
        }
        return cRefs;
    }

    STDMETHOD(QueryInterface)(IN REFIID riid, OUT void **ppvObject)
    {
        HRESULT hr = S_OK;

        if (ppvObject == NULL) {
            return E_POINTER;
        } else {
            *ppvObject = NULL;
        }

        if (riid == __uuidof(IUnknown)) {
            *ppvObject = reinterpret_cast<void *>(static_cast<IUnknown *>(this));
        } else if (riid == __uuidof(IValue)) {
            *ppvObject = reinterpret_cast<void *>(static_cast<IValue *>(this));
        } else {
            hr = E_NOINTERFACE;
        }

        if (SUCCEEDED(hr)) {
            AddRef();
        }

        return hr;
    }

    STDMETHOD(GetValue)(IN TYPEID idType, OUT void * pValue)
    {
        UNREFERENCED_PARAMETER(idType);
        UNREFERENCED_PARAMETER(pValue);
        return E_NOTIMPL;
    }

    STDMETHOD(GetNativeType)(OUT TYPEID * pidType)
    {
        if (pidType == NULL) {
            return E_POINTER;
        }

        *pidType = TYPEID_EMPTY;
        return S_OK;
    }

private:
    ~CEmptyValue() { }

    LONG m_cRefs;
};

/////////////////////////////////////////////////////////////////////////////
template<class T, VALUEID const * __valueid, TYPEID const * __typeid>
class TStandardValue : IValue
{
public:
    static HRESULT Create(IN TYPEID idInitType, IN void *pInitValue, OUT IValue ** ppValue)
    {
        if (ppValue != NULL) {
            *ppValue = NULL;
        }
        if (idInitType != (*__typeid) || pInitValue == NULL) {
            return E_INVALIDARG;
        }
        if (ppValue == NULL) {
            return E_POINTER;
        }

        TStandardValue<T, __valueid, __typeid> * pStandardValue  = new TStandardValue();
        if (pStandardValue == NULL) {
            return E_OUTOFMEMORY;
        }

        pStandardValue->m_value = *(reinterpret_cast<T*>(pInitValue));
        pStandardValue->m_cRefs = 1;
        *ppValue = static_cast<IValue *>(pStandardValue);
        return S_OK;
    }

    STDMETHOD_(ULONG, AddRef)(void)
    {
        return InterlockedIncrement(&m_cRefs);
    }

    STDMETHOD_(ULONG, Release)(void)
    {
        LONG cRefs = InterlockedDecrement(&m_cRefs);
        if (cRefs == 0) {
            delete this;
        }
        return cRefs;
    }

    STDMETHOD(QueryInterface)(IN REFIID riid, OUT void **ppvObject)
    {
        HRESULT hr = S_OK;

        if (ppvObject == NULL) {
            return E_POINTER;
        } else {
            *ppvObject = NULL;
        }

        if (riid == __uuidof(IUnknown)) {
            *ppvObject = reinterpret_cast<void *>(static_cast<IUnknown *>(this));
        } else if (riid == __uuidof(IValue)) {
            *ppvObject = reinterpret_cast<void *>(static_cast<IValue *>(this));
        } else {
            hr = E_NOINTERFACE;
        }

        if (SUCCEEDED(hr)) {
            AddRef();
        }

        return hr;
    }

    STDMETHOD(GetValue)(IN TYPEID idType, OUT void * pValue)
    {
        if (pValue == NULL) {
            return E_INVALIDARG;
        }
        if (idType != (*__typeid)) {
            return E_NOTIMPL;
        }

        *(reinterpret_cast<T*>(pValue)) = m_value;
        return S_OK;
    }

    STDMETHOD(GetNativeType)(OUT TYPEID * pidType)
    {
        if (pidType == NULL) {
            return E_POINTER;
        }

        *pidType = (*__typeid);
        return S_OK;
    }

private:
    ~TStandardValue() { }

    LONG m_cRefs;
    T m_value;
};

/////////////////////////////////////////////////////////////////////////////
class CStandardValueFactory : IValueFactory
{
public:
    STDMETHOD_(ULONG, AddRef)(void)
    {
        return 0;
    }
    
    STDMETHOD_(ULONG, Release)(void)
    {
        return 0;
    }
    
    STDMETHOD(QueryInterface)(IN REFIID riid, OUT void **ppvObject)
    {
        UNREFERENCED_PARAMETER(riid);
        UNREFERENCED_PARAMETER(ppvObject);
        return E_NOTIMPL;
    }

    STDMETHOD(CreateValue)(IN VALUEID idValue, IN TYPEID idInitType, IN void *pInitValue, OUT IValue ** ppValue)
    {
        HRESULT hr = S_OK;

        if (idValue == VALUEID_EMPTY) {
            hr = CEmptyValue::Create(ppValue);
        } else if(idValue == VALUEID_LUINT8) {
            hr = TStandardValue<unsigned char, &VALUEID_LUINT8, &TYPEID_LUINT8>::Create(idInitType, pInitValue, ppValue);
        } else if(idValue == VALUEID_LSINT8) {
            hr = TStandardValue<signed char, &VALUEID_LSINT8, &TYPEID_LSINT8>::Create(idInitType, pInitValue, ppValue);
        } else if(idValue == VALUEID_LUINT16) {
            hr = TStandardValue<unsigned short, &VALUEID_LUINT16, &TYPEID_LUINT16>::Create(idInitType, pInitValue, ppValue);
        } else if(idValue == VALUEID_LSINT16) {
            hr = TStandardValue<signed short, &VALUEID_LSINT16, &TYPEID_LSINT16>::Create(idInitType, pInitValue, ppValue);
        } else if(idValue == VALUEID_LUINT32) {
            hr = TStandardValue<unsigned long, &VALUEID_LUINT32, &TYPEID_LUINT32>::Create(idInitType, pInitValue, ppValue);
        } else if(idValue == VALUEID_LSINT32) {
            hr = TStandardValue<signed long, &VALUEID_LSINT32, &TYPEID_LSINT32>::Create(idInitType, pInitValue, ppValue);
        }

        return hr;
    }
};

/////////////////////////////////////////////////////////////////////////////
CStandardValueFactory g_StandardValueFactory;

/////////////////////////////////////////////////////////////////////////////
// Extend as reasonable in the future.  Actual value factories that implement
// IValueFactory...
HRESULT CoCreateValue(IN VALUEID idValue, IN TYPEID idInitType, IN void * pInitValue, OUT IValue ** ppValue)
{
    return g_StandardValueFactory.CreateValue(idValue, idInitType, pInitValue, ppValue);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\directui\new\properties\value.h ===
//---------------------------------------------------------------------------
// Value Types
//
// This is a partial list.  Value types can be gernerated at will by simply
// assigning a new GUID.  But these types are the ones that DirectUI uses
// internally.
//---------------------------------------------------------------------------

typedef GUID TYPEID;
#define DECLARE_TYPEID(type,l1,s1,s2,c1,c2,c3,c4,c5,c6,c7,c8)  \
EXTERN_C const TYPEID __declspec(selectany) TYPEID_##type = {l1,s1,s2,{c1,c2,c3,c4,c5,c6,c7,c8}}

typedef GUID VALUEID;
#define DECLARE_VALUEID(type,l1,s1,s2,c1,c2,c3,c4,c5,c6,c7,c8)  \
EXTERN_C const VALUEID __declspec(selectany) VALUEID_##type = {l1,s1,s2,{c1,c2,c3,c4,c5,c6,c7,c8}}

// Empty (no value)
// TYPEID_EMPTY = {E6FF6701-AA03-40d7-BEFE-F3AEC586D6CE}
// VALUEID_EMPTY = {EFAE2E37-A227-452e-A2ED-22BAE7B3BD03}
DECLARE_TYPEID(EMPTY, 0xe6ff6701, 0xaa03, 0x40d7, 0xbe, 0xfe, 0xf3, 0xae, 0xc5, 0x86, 0xd6, 0xce);
DECLARE_VALUEID(EMPTY, 0xefae2e37, 0xa227, 0x452e, 0xa2, 0xed, 0x22, 0xba, 0xe7, 0xb3, 0xbd, 0x03);

// Little-Endian, unsigned, 8-bit integer
// TYPEID_LUINT8 = {F1651FA7-7039-41e2-BDC6-59C2A1AD24B1}
// VALUEID_LUINT8 = {426A341C-C8E1-44ac-9D7C-FD956ABED7C0}
DECLARE_TYPEID(LUINT8, 0xf1651fa7, 0x7039, 0x41e2, 0xbd, 0xc6, 0x59, 0xc2, 0xa1, 0xad, 0x24, 0xb1);
DECLARE_VALUEID(LUINT8, 0x426a341c, 0xc8e1, 0x44ac, 0x9d, 0x7c, 0xfd, 0x95, 0x6a, 0xbe, 0xd7, 0xc0);

// Little-Endian, signed, 8-bit integer
// TYPEID_LSINT8 = {21BA2A5C-65AF-4149-9D02-E8EAB68C43B9}
// VALUEID_LSINT8 = {C46BD029-7D96-4e4d-8D8F-3D1344554DE6}
DECLARE_TYPEID(LSINT8, 0x21ba2a5c, 0x65af, 0x4149, 0x9d, 0x02, 0xe8, 0xea, 0xb6, 0x8c, 0x43, 0xb9);
DECLARE_VALUEID(LSINT8, 0xc46bd029, 0x7d96, 0x4e4d, 0x8d, 0x8f, 0x3d, 0x13, 0x44, 0x55, 0x4d, 0xe6);

// Little-Endian, unsigned, 16-bit integer
// TYPEID_LUINT16 = {87A448BC-9273-4ee8-9577-17963E7A4925}
// VALUEID_LUINT16 = {885208E4-890F-407a-804C-5AA7C1A1C2DE}
DECLARE_TYPEID(LUINT16, 0x87a448bc, 0x9273, 0x4ee8, 0x95, 0x77, 0x17, 0x96, 0x3e, 0x7a, 0x49, 0x25);
DECLARE_VALUEID(LUINT16, 0x885208e4, 0x890f, 0x407a, 0x80, 0x4c, 0x5a, 0xa7, 0xc1, 0xa1, 0xc2, 0xde);

// Little-Endian, signed, 16-bit integer
// TYPEID_LSINT16 = {1F6E04E3-35BB-450b-831D-9D15C1ACA96C}
// VALUEID_LSINT16 = {3B363CF4-DD46-4f0b-A6B3-A192B5E59813}
DECLARE_TYPEID(LSINT16, 0x1f6e04e3, 0x35bb, 0x450b, 0x83, 0x1d, 0x9d, 0x15, 0xc1, 0xac, 0xa9, 0x6c);
DECLARE_VALUEID(LSINT16, 0x3b363cf4, 0xdd46, 0x4f0b, 0xa6, 0xb3, 0xa1, 0x92, 0xb5, 0xe5, 0x98, 0x13);

// Little-Endian, unsigned, 32-bit integer
// TYPEID_LUINT32 = {EDC6F5AD-4750-45ed-8176-A3DFC389E76B}
// VALUEID_LUINT32 = {803BFDEB-BA57-44e9-BC5D-3A744A3B5C2C}
DECLARE_TYPEID(LUINT32, 0xedc6f5ad, 0x4750, 0x45ed, 0x81, 0x76, 0xa3, 0xdf, 0xc3, 0x89, 0xe7, 0x6b);
DECLARE_VALUEID(LUINT32, 0x803bfdeb, 0xba57, 0x44e9, 0xbc, 0x5d, 0x3a, 0x74, 0x4a, 0x3b, 0x5c, 0x2c);

// Little-Endian, signed, 32-bit integer
// TYPEID_LSINT32 = {475CE331-34A9-403b-8745-FA9A4D201F26}
// VALUEID_LSINT32 = {5D641CDA-64D3-4408-A57E-5E18B3D929DE}
DECLARE_TYPEID(LSINT32, 0x475ce331, 0x34a9, 0x403b, 0x87, 0x45, 0xfa, 0x9a, 0x4d, 0x20, 0x1f, 0x26);
DECLARE_VALUEID(LSINT32, 0x5d641cda, 0x64d3, 0x4408, 0xa5, 0x7e, 0x5e, 0x18, 0xb3, 0xd9, 0x29, 0xde);

//---------------------------------------------------------------------------
// Interface IValue
//---------------------------------------------------------------------------
interface __declspec(uuid("4d4005e7-f9fb-4137-b07c-d06717010f73")) IValue : public IUnknown
{
    STDMETHOD(GetValue)(IN TYPEID idType, OUT void * pValue) = 0;
    STDMETHOD(GetNativeType)(TYPEID * pidType) = 0;
    
    // Future...
    // STDMETHOD(QueryType)(TYPEID idType, BOOL * pfSupported) = 0;
    // STDMETHOD(EnumSupportedTypes)(IEnumTYPEID ** ppEnumTYPEID) = 0;
};

//---------------------------------------------------------------------------
// Interface IValueFactory
//---------------------------------------------------------------------------
interface __declspec(uuid("cc914031-74e5-4aeb-9610-1128e2c5250a")) IValueFactory : public IUnknown
{
    STDMETHOD(CreateValue)(IN VALUEID idValue, IN TYPEID idInitType, IN void * pInitValue, OUT IValue ** ppValue) = 0;
};

//---------------------------------------------------------------------------
// Global function to create values.  Similar to CoCreateInstance.
//---------------------------------------------------------------------------
HRESULT CoCreateValue(IN VALUEID idValue, IN TYPEID idInitType, IN void * pInitValue, OUT IValue ** ppValue);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\directui\new\test\testvalues\stdafx.h ===
#include <windows.h>
#include <objbase.h>
#include <Value.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\directui\new\properties\stdafx.h ===
#pragma once
#include <windows.h>
#include <objbase.h>

#define UNREFERENCED_PARAMETER(P)          (P)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\directui\new\test\testvalues\testvalues.cpp ===
#include "stdafx.h"
#include <stdio.h>

void __cdecl main()
{
    DWORD dw = 2;
    IValue * pValue = NULL;
    HRESULT hr = S_OK;

    hr = CoCreateValue(VALUEID_LUINT32, TYPEID_LUINT32, &dw, &pValue);
    if(SUCCEEDED(hr)) {
        printf("CoCreateValue succeeded.\n");
        pValue->Release();
    } else {
        printf("CoCreateValue failed.  hr=%X\n", hr);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\directui\old\engine\sources.inc ===
!IF 0

    Shared sources.inc file for Engine projects.

!ENDIF

# Do not use NTBUILD's Warning.h pragmas, will treat all warnings as errors and use highest level (W4)
COMPILER_WARNINGS=

MSC_STDCALL=1
MSC_WARNING_LEVEL=/W4

USE_CRTDLL=1

INCLUDES=\
        ..\inc;\
        ..\..\inc;\
        ..\ObjectAPI\$(O);\
        $(WINDOWS_INC_PATH)\DUser;\
        $(BASEDIR)\windows\advcore\duser\inc\Public;\
        $(SDK_INC_PATH)\gdiplus

C_DEFINES=$(C_DEFINES) -DDIRECTUI_EXPORTS
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\directui\old\engine\base\alloc.cpp ===
/***************************************************************************\
*
* File: Alloc.cpp
*
* Description:
* Alloc wraps heap allocation functions so that they may be changed
* without having to update any other file (abstraction)
*
* History:
*  9/12/2000: MarkFi:       Created
*
* Copyright (C) 1999-2001 by Microsoft Corporation.  All rights reserved.
*
\***************************************************************************/


#include "stdafx.h"
#include "Base.h"
#include "Alloc.h"

#include "Debug.h"


/***************************************************************************\
*****************************************************************************
*
* class DuiHeap
*
* Heap management methods (static)
*
*****************************************************************************
\***************************************************************************/


//------------------------------------------------------------------------------
void *
DuiHeap::Alloc(
    IN  SIZE_T s)
{
    return HeapAlloc(GetProcessHeap(), 0, s);
}


//------------------------------------------------------------------------------
void *
DuiHeap::AllocAndZero(
    IN  SIZE_T s)
{ 
    return HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, s);
}


//------------------------------------------------------------------------------
void * 
DuiHeap::ReAlloc(
    IN  void * p, 
    IN  SIZE_T s)
{ 
    return HeapReAlloc(GetProcessHeap(), 0, p, s);
}


//------------------------------------------------------------------------------
void * 
DuiHeap::ReAllocAndZero(
    IN  void * p,
    IN  SIZE_T s)
{ 
    return HeapReAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, p, s);
}


//------------------------------------------------------------------------------
void
DuiHeap::Free(
    IN  void * p)
{
    HeapFree(GetProcessHeap(), 0, p);
}


/***************************************************************************\
*****************************************************************************
*
* class DuiStack
*
* Stack management methods (static)
*
*****************************************************************************
\***************************************************************************/


//------------------------------------------------------------------------------
void *
DuiStack::Alloc(
    IN  SIZE_T s)
{
    return alloca(s);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\directui\old\engine\base\alloc.h ===
/***************************************************************************\
*
* File: Alloc.h
*
* Description:
* Alloc wraps heap allocation functions so that they may be changed
* without having to update any other file (abstraction)
*
* History:
*  9/12/2000: MarkFi:       Created
*
* Copyright (C) 1999-2001 by Microsoft Corporation.  All rights reserved.
*
\***************************************************************************/


#if !defined(DUIBASE__Alloc_h__INCLUDED)
#define DUIBASE__Alloc_h__INCLUDED
#pragma once


#define ARRAYSIZE(a)    (sizeof(a) / sizeof(a[0]))


/***************************************************************************\
*
* class DuiHeap
*
* Heap management methods (static)
*
\***************************************************************************/

class DuiHeap
{
// Operations
public:
    static  void *      Alloc(SIZE_T s);
    static  void *      AllocAndZero(SIZE_T s);
    static  void *      ReAlloc(void * p, SIZE_T s);
    static  void *      ReAllocAndZero(void * p, SIZE_T s);
    static  void        Free(void * p);
};


/***************************************************************************\
*
* class DuiStack
*
* Stack management methods (static)
*
\***************************************************************************/

class DuiStack
{
// Operations
public:
    static  void *      Alloc(SIZE_T s);
};


#endif // DUIBASE__Alloc_h__INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\directui\old\engine\base\base.h ===
/***************************************************************************\
*
* File: Base.h
*
* Description:
* Internal project dependencies
*
* This file provides a project-wide header that is included in all source
* files specific to this project.  It is similar to a precompiled header,
* but is designed for more rapidly changing headers.
*
* The primary purpose of this file is to determine which DirectUI
* projects this project has direct access to instead of going through public
* API's.  It is VERY IMPORTANT that this is as minimal as possible since
* adding a new project unnecessarily reduces the benefit of project
* partitioning.
*
* History:
*  9/12/2000: MarkFi:       Created
*
* Copyright (C) 1999-2001 by Microsoft Corporation.  All rights reserved.
*
\***************************************************************************/


#if !defined(DUIBASE__Base_h__INCLUDED)
#define DUIBASE__Base_h__INCLUDED
#pragma once


//
// Public flat APIs and defines
//

#include <DirectUI.h>


//
// Inter-project includes
//


#endif // DUIBASE__Base_h__INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\directui\old\engine\base\btreelookup.h ===
/***************************************************************************\
*
* File: Btreelookup.h
*
* Description:
* Stores data and associated key and uses a binary search for quick lookup
* Used if gets are much more frequent than gets
*
* Keys are compared as pointers. If fKeyIsWStr is true, Keys are dereferenced
* as WCHAR* and compared
*
* History:
*  9/18/2000: MarkFi:       Created
*
* Copyright (C) 1999-2001 by Microsoft Corporation.  All rights reserved.
*
\***************************************************************************/


#if !defined(DUIBASE__DuiBTreeLookup_h__INCLUDED)
#define DUIBASE__DuiBTreeLookup_h__INCLUDED
#pragma once


// REFORMAT


template <typename D> class DuiBTreeLookup
{
    typedef struct
    {
        void* pKey;
        D tData;
    } ENTRY, *PENTRY;

    typedef void (*PBTENUMCALLBACK)(void* pKey, D tData);

public:
    static HRESULT Create(BOOL fKeyIsWStr, OUT DuiBTreeLookup<D>** ppBTree);
    virtual ~DuiBTreeLookup();

    D* GetItem(void* pKey);                  // Pointer to Value (NULL if doesn't exist, internal copy returned)
    HRESULT SetItem(void* pKey, D* ptData);  // Setup Key/Value map, creates new is doesn't exist (via indirection)
    HRESULT SetItem(void* pKey, D tData);    // Setup Key/Value map, creates new is doesn't exist
    void Remove(void* pKey);                 // Removes Key/Value map, ok if Key doesn't exist
    void Enum(PBTENUMCALLBACK pfnCallback);  // Callback with every item in map

    static int __cdecl ENTRYCompare(const void* pA, const void* pB);
    static int __cdecl WStrENTRYCompare(const void* pA, const void* pB);

protected:
    DuiBTreeLookup() { }
    void Initialize(BOOL fKeyIsWStr);

private:
    UINT _uListSize;
    PENTRY _pList;
    BOOL _fKeyIsWStr;
};

template <typename D> HRESULT DuiBTreeLookup<D>::Create(BOOL fKeyIsWStr, OUT DuiBTreeLookup<D>** ppBTree)
{
    *ppBTree = NULL;

    // Instantiate
    DuiBTreeLookup<D>* pbt = new DuiBTreeLookup<D>;
    if (!pbt)
        return E_OUTOFMEMORY;

    pbt->Initialize(fKeyIsWStr);

    *ppBTree = pbt;

    return S_OK;
}

template <typename D> void DuiBTreeLookup<D>::Initialize(BOOL fKeyIsWStr)
{
    _uListSize = 0;
    _pList = NULL;
    _fKeyIsWStr = fKeyIsWStr;
}

template <typename D> DuiBTreeLookup<D>::~DuiBTreeLookup()
{
    if (_pList)
        DuiHeap::Free(_pList);
}

template <typename D> D* DuiBTreeLookup<D>::GetItem(void* pKey)
{
    ASSERT_(_fKeyIsWStr ? pKey != NULL : true, "pKey may not be NULL");

    //PENTRY pEntry = NULL;

    if (_pList)
    {
        //ENTRY eKey = { pKey }; // Create ENTRY key, populate key field
        //pEntry = (PENTRY)bsearch(&eKey, _pList, _uListSize, sizeof(ENTRY), ENTRYCompare);

        PENTRY pEntry;
        int uPv;
        int uLo = 0;
        int uHi = _uListSize - 1;
        while (uLo <= uHi)
        {
            uPv = (uHi + uLo) / 2;

            pEntry = _pList + uPv;

            // Locate
            if (!_fKeyIsWStr)
            {
                // Key is numeric
                if ((UINT_PTR)pKey == (UINT_PTR)pEntry->pKey)
                    return &(pEntry->tData);

                if ((UINT_PTR)pKey < (UINT_PTR)pEntry->pKey)
                    uHi = uPv - 1;
                else
                    uLo = uPv + 1;
            }
            else
            {
                // Key is pointer to a wide string
                int cmp = _wcsicmp((LPCWSTR)pKey, (LPCWSTR)pEntry->pKey);

                if (!cmp)
                    return &(pEntry->tData);

                if (cmp < 0)
                    uHi = uPv - 1;
                else
                    uLo = uPv + 1;
            }
        }
    }

    //return pEntry ? &(pEntry->tData) : NULL;
    return NULL;
}

template <typename D> HRESULT DuiBTreeLookup<D>::SetItem(void* pKey, D tData)
{
    D* pData = GetItem(pKey);  // Find current entry (if exits)

    if (pData)
    {
        // Entry found and have pointer to data of entry
        *pData = tData;
    }
    else
    {
        // Entry not found, allocate room for new entry, store, and sort

        // New size
        UINT uNewSize = _uListSize + 1;

        if (_pList)
        {
            ASSERT_(uNewSize > 1, "Tracked list size and actual size differ");

            PENTRY pNewList = (PENTRY)DuiHeap::ReAlloc(_pList, sizeof(ENTRY) * uNewSize);
            if (!pNewList)
                return E_OUTOFMEMORY;

            _pList = pNewList;
        }
        else
        {
            ASSERT_(uNewSize == 1, "Tracked list size and actual list size differ");

            _pList = (PENTRY)DuiHeap::Alloc(sizeof(ENTRY));
            if (!_pList)
                return E_OUTOFMEMORY;
        }

        // Update size
        _uListSize = uNewSize;

        // Store
        _pList[_uListSize - 1].pKey = pKey;
        _pList[_uListSize - 1].tData = tData;

        // Sort
        qsort(_pList, _uListSize, sizeof(ENTRY), !_fKeyIsWStr ? ENTRYCompare : WStrENTRYCompare);
    }

    return S_OK;
}

template <typename D> HRESULT DuiBTreeLookup<D>::SetItem(void* pKey, D* ptData)
{
    D* pData = GetItem(pKey);  // Find current entry (if exits)

    if (pData)
    {
        // Entry found and have pointer to data of entry
        *pData = *ptData;
    }
    else
    {
        // Entry not found, allocate room for new entry, store, and sort

        // New size
        UINT uNewSize = _uListSize + 1;

        if (_pList)
        {
            ASSERT_(uNewSize > 1, "Tracked list size and actual list size differ");

            PENTRY pNewList = (PENTRY)DuiHeap::ReAlloc(_pList, sizeof(ENTRY) * uNewSize);
            if (!pNewList)
                return E_OUTOFMEMORY;

            _pList = pNewList;
        }
        else
        {
            ASSERT_(uNewSize == 1, "Tracked list size and actual list size differ");

            _pList = (PENTRY)DuiHeap::Alloc(sizeof(ENTRY));
            if (!_pList)
                return E_OUTOFMEMORY;
        }

        // Update size
        _uListSize = uNewSize;

        // Store
        _pList[_uListSize - 1].pKey = pKey;
        _pList[_uListSize - 1].tData = *ptData;

        // Sort
        qsort(_pList, _uListSize, sizeof(ENTRY), !_fKeyIsWStr ? ENTRYCompare : WStrENTRYCompare);
    }

    return S_OK;
}

// Returns success even if key isn't found
template <typename D> void DuiBTreeLookup<D>::Remove(void* pKey)
{
    // Validate parameters
    ASSERT_(_fKeyIsWStr ? pKey != NULL : true, "Invalid parameter: pKey == NULL");

    if (_pList)
    {
        // Search for ENTRY with key
        //ENTRY eKey = { pKey };
        //PENTRY pEntry = (PENTRY)bsearch(&eKey, _pList, _uListSize, sizeof(ENTRY), ENTRYCompare);

        PENTRY pEntry = NULL;
        int uPv;
        int uLo = 0;
        int uHi = _uListSize - 1;
        while (uLo <= uHi)
        {
            uPv = (uHi + uLo) / 2;

            pEntry = _pList + uPv;

            // Locate
            if (!_fKeyIsWStr)
            {
                // Key is numeric
                if ((UINT_PTR)pKey == (UINT_PTR)pEntry->pKey)
                    break;

                if ((UINT_PTR)pKey < (UINT_PTR)pEntry->pKey)
                    uHi = uPv - 1;
                else
                    uLo = uPv + 1;
            }
            else
            {
                // Key is pointer to a wide string
                int cmp = _wcsicmp((LPCWSTR)pKey, (LPCWSTR)pEntry->pKey);

                if (!cmp)
                    break;

                if (cmp < 0)
                    uHi = uPv - 1;
                else
                    uLo = uPv + 1;
            }

            pEntry = NULL;
        }

        if (pEntry)
        {
            UINT uIndex = (UINT)(((UINT_PTR)pEntry - (UINT_PTR)_pList) / sizeof(ENTRY));

            ASSERT_(uIndex < _uListSize, "Index out of bounds");

            // ENTRY found, move all entries after this entry down
            MoveMemory(pEntry, pEntry + 1, (_uListSize - uIndex - 1) * sizeof(ENTRY));

            // One less entry
            UINT uNewSize = _uListSize - 1;

            // Trim allocation
            if (uNewSize == 0)
            {
                DuiHeap::Free(_pList);
                _pList = NULL;
            }
            else
            {
                PENTRY pNewList = (PENTRY)DuiHeap::ReAlloc(_pList, uNewSize * sizeof(ENTRY));

                // List is becoming smaller, if re-allocation failed, keep previous and continue
                if (pNewList)
                    _pList = pNewList;
            }

            // Update size
            _uListSize = uNewSize;
        }
    }
}

template <typename D> void DuiBTreeLookup<D>::Enum(PBTENUMCALLBACK pfnCallback)
{
    if (_pList)
    {
        for (UINT i = 0; i < _uListSize; i++)
            pfnCallback(_pList[i].pKey, _pList[i].tData);
    }
}

template <typename D> int __cdecl DuiBTreeLookup<D>::ENTRYCompare(const void* pA, const void* pB)
{
    PENTRY pEA = (PENTRY)pA;
    PENTRY pEB = (PENTRY)pB;

    if ((UINT_PTR)pEA->pKey == (UINT_PTR)pEB->pKey)
        return 0;
    else if ((UINT_PTR)pEA->pKey < (UINT_PTR)pEB->pKey)
        return -1;
    else
        return 1;
}

template <typename D> int __cdecl DuiBTreeLookup<D>::WStrENTRYCompare(const void* pA, const void* pB)
{
    PENTRY pEA = (PENTRY)pA;
    PENTRY pEB = (PENTRY)pB;

    // Ignore case
    return _wcsicmp((LPCWSTR)pEA->pKey, (LPCWSTR)pEB->pKey);
}


#endif // DUIBASE__DuiBTreeLookup_h__INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\directui\old\engine\base\pub