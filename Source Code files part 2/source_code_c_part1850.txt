
    NewShenDiaoXiaLv.cpp

 Abstract:

    On NT, when there is no CD in the CDROM, and the app sends a MCI_OPEN 
    command to the CDAUDIO device, the app has fully exclusive control of the 
    CDROM. When later on user inserts CD, the app will not receive 
    WM_DEVICECHANGE message. And this app relies on the message to know if 
    there is a new CD inserted. 
    
    The fix is check whether the CD is there when we do MCI_OPEN command, if 
    there is not CD, we will close the device.

 Notes: 
  
    This is an app specific shim.

 History:

    05/28/2001 xiaoz    Created

--*/

#include "precomp.h"

IMPLEMENT_SHIM_BEGIN(NewShenDiaoXiaLv)
#include "ShimHookMacro.h"

APIHOOK_ENUM_BEGIN
    APIHOOK_ENUM_ENTRY(mciSendCommandA) 
APIHOOK_ENUM_END

/*++

 Close the device if we get hardware error(CD is not there).

--*/

MCIERROR 
APIHOOK(mciSendCommandA)(
    MCIDEVICEID IDDevice,  
    UINT uMsg,             
    DWORD fdwCommand,      
    DWORD dwParam          
    )
{
    MCIERROR mciErr, mciError;
    MCI_STATUS_PARMS mciStatus;
    LPMCI_OPEN_PARMSA lpmciOpenParam;
    CString cstrDeviveType;
    
    mciErr = ORIGINAL_API(mciSendCommandA)(IDDevice, uMsg, fdwCommand, dwParam);
    
    // We are only interested in a successful MCI_OPEN Message  
    if (mciErr || (uMsg != MCI_OPEN) || IsBadReadPtr((CONST VOID*)(ULONG_PTR)dwParam, 1))
    {
        goto End;
    }  

    // We are only interested in MCI message sent to CDAUDIO
    lpmciOpenParam = (LPMCI_OPEN_PARMSA) dwParam;
    if ((ULONG_PTR) lpmciOpenParam->lpstrDeviceType <= 0xffff)
    {
        if ((ULONG_PTR)lpmciOpenParam->lpstrDeviceType != MCI_DEVTYPE_CD_AUDIO)
        {
            goto End;
        }
    }
    else
    {
        CString cstrDeviveType(lpmciOpenParam->lpstrDeviceType);
        if (cstrDeviveType.CompareNoCase(L"cdaudio"))
        {
            goto End;
        }
    }
    
    // Send an MCI_STATUS 
    mciStatus.dwItem = MCI_STATUS_LENGTH ;
    mciError = mciSendCommandA(lpmciOpenParam->wDeviceID, MCI_STATUS, 
        MCI_STATUS_ITEM | MCI_TRACK | MCI_WAIT, (DWORD_PTR) &mciStatus);

    if (MCIERR_HARDWARE == mciError)
    {        
        //
        // If we get hardware error, it means CD is not there, close the device
        // and return error
        //
        mciSendCommandA(lpmciOpenParam->wDeviceID, MCI_CLOSE, 0, 0);
        mciErr = MCIERR_DEVICE_NOT_READY;
    }

End:
    return mciErr;
}

/*++

 Register hooked functions

--*/

HOOK_BEGIN
    APIHOOK_ENTRY(WINMM.DLL, mciSendCommandA)        
HOOK_END

IMPLEMENT_SHIM_END
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\appcompat\shims\specific\nflblitz.cpp ===
/*++

 Copyright (c) 2000 Microsoft Corporation

 Module Name:
    
    NFLBlitz.cpp

 Abstract:

    NFL Blitz has 2 problems:
    
      1. It keeps linked lists on it's stack and somehow the stack pointer 
         is changed to allow altered FindFirstFile to corrupt it. We don't hit 
         this on win9x because FindFirstFile doesn't use any app stack space.

      2. Autorun and the main executable are synchronized using a mutex that is 
         freed only on process termination. The sequence of events is:

            a. Autorun creates a mutex
            b. Autorun creates a new process
            c. Autorun terminates thus freeing the mutex in (a).
            d. New process checks if it's already running by examining the 
               mutex created in (a).

         This fails when (c) and (d) are exchanged which happens all the time 
         on NT, but apparently very seldom on win9x.
    
 Notes:

    This is an app specific shim.

 History:

    02/10/2000 linstev  Created

--*/

#include "precomp.h"

IMPLEMENT_SHIM_BEGIN(NFLBlitz)
#include "ShimHookMacro.h"

APIHOOK_ENUM_BEGIN
    APIHOOK_ENUM_ENTRY(CreateMutexA) 
    APIHOOK_ENUM_ENTRY(CreateProcessA) 
APIHOOK_ENUM_END

HANDLE g_hMutex = NULL;

/*++

 Store the handle to the mutex we're interested in.

--*/

HANDLE 
APIHOOK(CreateMutexA)(
    LPSECURITY_ATTRIBUTES lpMutexAttributes,
    BOOL bInitialOwner,  
    LPCSTR lpName       
    )
{
    HANDLE hRet = ORIGINAL_API(CreateMutexA)(
        lpMutexAttributes, 
        bInitialOwner, 
        lpName);

    DWORD dwErrCode = GetLastError();

    if (lpName && _tcsicmp(lpName, "NFL BLITZ") == 0)
    {
        g_hMutex = hRet;
    }

    SetLastError(dwErrCode);

    return hRet;
}

/*++

 Close the mutex.

--*/

BOOL 
APIHOOK(CreateProcessA)(
    LPCSTR lpApplicationName,
    LPSTR lpCommandLine,  
    LPSECURITY_ATTRIBUTES lpProcessAttributes,  
    LPSECURITY_ATTRIBUTES lpThreadAttributes,   
    BOOL bInheritHandles,  
    DWORD dwCreationFlags, 
    LPVOID lpEnvironment,  
    LPCSTR lpCurrentDirectory,
    LPSTARTUPINFOA lpStartupInfo,  
    LPPROCESS_INFORMATION lpProcessInformation  
    )
{
    if (g_hMutex)
    {
        ReleaseMutex(g_hMutex);
        CloseHandle(g_hMutex);
        g_hMutex = NULL;
    }

    return ORIGINAL_API(CreateProcessA)(
        lpApplicationName,
        lpCommandLine,  
        lpProcessAttributes,  
        lpThreadAttributes,   
        bInheritHandles,  
        dwCreationFlags, 
        lpEnvironment,  
        lpCurrentDirectory,
        lpStartupInfo,  
        lpProcessInformation);
}
  
/*++

 Register hooked functions

--*/

HOOK_BEGIN

    APIHOOK_ENTRY(KERNEL32.DLL, CreateMutexA)
    APIHOOK_ENTRY(KERNEL32.DLL, CreateProcessA)

HOOK_END

IMPLEMENT_SHIM_END
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\appcompat\shims\specific\nflfever2000.cpp ===
/*++

 Copyright (c) 2000 Microsoft Corporation

 Module Name:

    NFLFever2000.cpp

 Abstract:
     
    The app reads past the end of files that it's copied into memory. 
    The shim allocates additional memory for it

    Note we included an in-memory patch for Win2k. On Whistler it's not
    required, the rest of the shim does the work.
     
 Notes:

    This is an app specific shim.

 History:
           
    01/11/2000 linstev  Created
    10/03/2000 maonis   Modified (the acm stuff is now in a general purpose shim)
   
--*/

#include "precomp.h"

IMPLEMENT_SHIM_BEGIN(NFLFever2000)
#include "ShimHookMacro.h"

APIHOOK_ENUM_BEGIN
    APIHOOK_ENUM_ENTRY(GetFileSize) 
    APIHOOK_ENUM_ENTRY(RtlAllocateHeap) 
    APIHOOK_ENUM_ENTRY(mmioSetInfo) 
APIHOOK_ENUM_END

DWORD g_dwFileSize = -1;
BOOL g_bPatched = FALSE;

/*++

 Hook GetFileSize to make sure we get the correct heap allocations.

--*/

DWORD 
APIHOOK(GetFileSize)(
    HANDLE hFile,
    LPDWORD lpFileSizeHigh 
    )
{
    DWORD dwRet = ORIGINAL_API(GetFileSize)(hFile, lpFileSizeHigh);

    g_dwFileSize = dwRet;

    PBYTE p;
    ULONG oldProtect;

    if (!g_bPatched)  {
        p = (PBYTE)0x10995d0;
        if (!IsBadReadPtr(p, 1) && (*p == 0x8b)) {
            VirtualProtect(p, 3, PAGE_READWRITE, &oldProtect);
            *p = 0xc2;
            *(p + 1) = 0x8;
            *(p + 2) = 0x0;
            VirtualProtect(p, 3, oldProtect, &oldProtect);
            g_bPatched = TRUE;
        }
    }

    return dwRet;
}

/*++

 Increase the heap allocation size.

--*/

PVOID 
APIHOOK(RtlAllocateHeap) (
    PVOID HeapHandle,
    ULONG Flags,
    SIZE_T Size
    )
{
    if (Size == g_dwFileSize)  {
        DPFN( eDbgLevelError, "Adjusted heap allocation from %d to %d\n", Size, Size+0x1000);
        Size += 0x1000;
    }

    return ORIGINAL_API(RtlAllocateHeap)(HeapHandle, Flags, Size);
}

/*++

 Make the buffer read/write.

--*/

MMRESULT 
APIHOOK(mmioSetInfo)(
    HMMIO hmmio,            
    LPMMIOINFO lpmmioinfo,  
    UINT wFlags             
    )
{
    //
    // BUGBUG: Not needed on XP, but still required on Win2k
    // This fix causes sound to skip, see #304678. 
    //
    // Win2k used to check if the buffer could be written to, instead of just 
    // read. We fixed this on XP. However, it's not enough to just copy the 
    // buffer, because it's used later.
    // Not clear what the actual fix is though.
    // 
    
    /*
    HPSTR p = NULL;

    if (lpmmioinfo && lpmmioinfo->pchBuffer &&
       (IsBadWritePtr(lpmmioinfo->pchBuffer, lpmmioinfo->cchBuffer) && 
        !IsBadReadPtr(lpmmioinfo->pchBuffer, lpmmioinfo->cchBuffer)))    {
            p = (HPSTR) malloc(lpmmioinfo->cchBuffer);
            if (p)  {
                DPFN( eDbgLevelError, "Fixing mmioSetInfo buffer");
                MoveMemory(p, lpmmioinfo->pchBuffer, lpmmioinfo->cchBuffer);
                lpmmioinfo->pchBuffer = p;
            } 
    }

    MMRESULT mRet = ORIGINAL_API(mmioSetInfo)(hmmio, lpmmioinfo, wFlags);

    if (p)  {
        free(p);
    }

    return mRet;
    */

    return ORIGINAL_API(mmioSetInfo)(hmmio, lpmmioinfo, wFlags);
}
 
/*++

 Register hooked functions

--*/

HOOK_BEGIN

    APIHOOK_ENTRY(KERNEL32.DLL, GetFileSize)
    APIHOOK_ENTRY(NTDLL.DLL, RtlAllocateHeap)
    APIHOOK_ENTRY(WINMM.DLL, mmioSetInfo)

HOOK_END

IMPLEMENT_SHIM_END
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\appcompat\shims\specific\nhl2001.cpp ===
/*

 Copyright (c) 2001 Microsoft Corporation

 Module Name:

   NHL2001.cpp

 Abstract:

    EA Sports' NHL 2001 has a bug where if the platform returned by
    GetVersionExA is not windows, they don't call the GetDiskFreeSpace and
    then report no free space to create a tournament season or playoff.
    Unfortunately, a generic version lie does not work because the game is
    safedisk protected, so we both apps to have the same GetVesionExA.

 History:

    06/04/2001  pierreys    Created
*/

#include "precomp.h"
#include <stdio.h>

IMPLEMENT_SHIM_BEGIN(NHL2001)

#include "ShimHookMacro.h"

APIHOOK_ENUM_BEGIN
    APIHOOK_ENUM_ENTRY(GetVersionExA)
    APIHOOK_ENUM_ENTRY(GetDiskFreeSpaceA)
APIHOOK_ENUM_END

BOOL    fGetDiskFreeSpaceCalled = FALSE;

BOOL 
APIHOOK(GetDiskFreeSpaceA)(
    LPCSTR  lpRootPathName,
    LPDWORD lpSectorsPerCluster,
    LPDWORD lpBytesPerSector,
    LPDWORD lpNumberOfFreeClusters,
    LPDWORD lpTotalNumberOfClusters
    )
{
    //
    // Take notice of the call
    //
    fGetDiskFreeSpaceCalled = TRUE;

    //
    // Call the original API
    //
    return ORIGINAL_API(GetDiskFreeSpaceA)(
                    lpRootPathName, 
                    lpSectorsPerCluster, 
                    lpBytesPerSector, 
                    lpNumberOfFreeClusters, 
                    lpTotalNumberOfClusters);
}

BOOL
APIHOOK(GetVersionExA)(LPOSVERSIONINFOA lpVersionInformation)
{
    if (fGetDiskFreeSpaceCalled)
    {
        LOGN(
        eDbgLevelInfo,
        "[GetVersionExA] called after GetDiskFreeSpace. return Win98.");

        // Fixup the structure with the Win98 data
        lpVersionInformation->dwMajorVersion = 4;
        lpVersionInformation->dwMinorVersion = 10;
        lpVersionInformation->dwBuildNumber = 0x040A08AE;
        lpVersionInformation->dwPlatformId = 1;
        *lpVersionInformation->szCSDVersion = '\0';

        return TRUE;
    }
    else
    {
        return ORIGINAL_API(GetVersionExA)(lpVersionInformation);
    }
}


HOOK_BEGIN

    APIHOOK_ENTRY(KERNEL32.DLL, GetVersionExA)
    APIHOOK_ENTRY(KERNEL32.DLL, GetDiskFreeSpaceA)

HOOK_END


IMPLEMENT_SHIM_END
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\appcompat\shims\specific\netzip.cpp ===
/*++

 Copyright (c) 2000 Microsoft Corporation

 Module Name:

    NetZip.cpp

 Abstract:

    This App. stops when it is searching for installed browsers. I found that 
    the App. tries enumerating all processes running using the API call 
    EnumProcesses(). This is OK and the App. gets the list of PID's. Now, the 
    App wants to go through each individual Process's modules using 
    EnumProcessModules. Before that it gets the handle to each process calling 
    OpenProcess() on each. On the 'System Idle Process', which has a PID of '0', 
    the call to OpenProcess() returns failure and that is handled. The App then 
    goes to the next process, which is the 'System' process. The PID is '8'. 
    The App successfully gets the process handle by a call to OpenProcess() but 
    when the App. calls EnumProcessModules(), this call returns failure and the 
    GetLastError( ) returns ERROR_PARTIAL_COPY(0x12b). The App. does not know 
    how to handle this and it fails.

    When I traced into this API, it calls ReadProcessMemory(), which in turn 
    calls NtReadVirtualMemory(). This is a Kernel call and it returns 8000000d 
    on Windows 2000. GetLastError() for this translates to 
    ERROR_PARTIAL_COPY(0x12b). On Windows NT 4.0, the EnumProcessModules() API 
    calls ReadProcessMemory(), which inturn calls NtReadVirtualMemory() which 
    returns 0xC0000005. GetLastError() for this translates to 
    ERROR_NOACCESS(0x3e6) - (Invalid access to a memory location). The App. is 
    able to handle this. So, the APP should handle both ERROR_NOACCESS and 
    ERROR_PARTIAL_COPY.
   
 Notes:

    This is an app specific shim.

 History:

    04/21/2000 prashkud Created

--*/

#include "precomp.h"

IMPLEMENT_SHIM_BEGIN(NetZip)
#include "ShimHookMacro.h"

APIHOOK_ENUM_BEGIN
    APIHOOK_ENUM_ENTRY(EnumProcessModules) 
APIHOOK_ENUM_END

/*++

  This function intercepts EnumProcessModules( ) and and handles the return of 
  ERROR_PARTIAL_COPY.

--*/

BOOL
APIHOOK(EnumProcessModules)(
    HANDLE hProcess,         // Handle to process
    HMODULE *lphModule,      // Array of Handle modules
    DWORD   cb,              // size of array
    LPDWORD lpcbNeeded       // Number od bytes returned.
    )      
{
    BOOL fRet = FALSE;

    fRet = ORIGINAL_API(EnumProcessModules)( 
        hProcess,
        lphModule,
        cb,
        lpcbNeeded);

    if (GetLastError( ) == ERROR_PARTIAL_COPY)
    {
        SetLastError(ERROR_NOACCESS);
    }
    
    return fRet;
}

/*++

 Register hooked functions

--*/


HOOK_BEGIN

    APIHOOK_ENTRY(PSAPI.DLL, EnumProcessModules )

HOOK_END


IMPLEMENT_SHIM_END
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\appcompat\shims\specific\omikron.cpp ===
/*++

 Copyright (c) 2000 Microsoft Corporation

 Module Name:

    Omikron.cpp

 Abstract:

    Shims RegQueryValueExA so that when the app asks for the shell command
    for opening an rtffile, it gets what it expected to see under Win95: 
    "C:\WINDOWS\WORDPAD.EXE %1" This is, of course, wrong, but we then apply 
    CorrectFilePaths, so when it actually goes out to launch wordpad, it has 
    the right path.

    This is necessary because it can't have a path name with spaces in it

 Notes:

    This is specific to Omikron.

 History:

    3/27/2000 dmunsil  Created


--*/
#include "precomp.h"

IMPLEMENT_SHIM_BEGIN(Omikron)
#include "ShimHookMacro.h"

APIHOOK_ENUM_BEGIN
    APIHOOK_ENUM_ENTRY(RegQueryValueExA) 
APIHOOK_ENUM_END

LONG
APIHOOK(RegQueryValueExA)(
    HKEY    hKey,
    LPSTR   lpValueName,
    LPDWORD lpReserved,
    LPDWORD lpType,
    LPBYTE  lpData,
    LPDWORD lpcbData
    )
{
    LONG lReturn;

    lReturn = ORIGINAL_API(RegQueryValueExA)(hKey, lpValueName, lpReserved, lpType, lpData, lpcbData);

    if (lReturn != ERROR_SUCCESS)
    {
        return lReturn;
    }

    if (lpType && lpcbData && lpData && (*lpType == REG_SZ || *lpType == REG_EXPAND_SZ))
    {
        CSTRING_TRY
        {
            LPSTR lpszData = (LPSTR)lpData;
            
            CString csData(lpszData);
            if (csData.Find(L"wordpad.exe \"%1\"") >= 0)
            {
                lstrcpyA(lpszData, "c:\\windows\\wordpad.exe \"%1\"");
            }
        }
        CSTRING_CATCH
        {
            // Do nothing
        }
    }

    return lReturn;
}


HOOK_BEGIN

    APIHOOK_ENTRY(ADVAPI32.DLL, RegQueryValueExA )

HOOK_END

IMPLEMENT_SHIM_END
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\appcompat\shims\specific\nikonview.cpp ===
/*++

 Copyright (c) 2002 Microsoft Corporation

 Module Name:

    NikonView.cpp

 Abstract:

    App crashes on exit trying to dereference a NULL. This memory is never 
    initialized, so it's not clear how this ever worked.

    Fixed by recognizing the exit sequence and killing the process before it 
    AVs.

 Notes:
 
    This is an app specific shim.

 History:

    06/25/2002 linstev  Created

--*/

#include "precomp.h"

IMPLEMENT_SHIM_BEGIN(NikonView)
#include "ShimHookMacro.h"

APIHOOK_ENUM_BEGIN
    APIHOOK_ENUM_ENTRY(UnregisterClassA) 
APIHOOK_ENUM_END

DWORD g_dwCount = 0;

/*++

 Kill the app on failed UnregisterClass

--*/

BOOL 
APIHOOK(UnregisterClassA)(
    LPCSTR lpClassName,  
    HINSTANCE hInstance   
    )
{
    BOOL bRet = ORIGINAL_API(UnregisterClassA)(lpClassName, hInstance);

    // Recognize termination sequence
    if (!bRet && lpClassName && (!IsBadReadPtr(lpClassName, 1)) && (*lpClassName == '\0')) {
        g_dwCount++;
        if (g_dwCount == 3) {
            ExitProcess(0); 
        }
    }

    return bRet;
}

/*++

 Register hooked functions

--*/

HOOK_BEGIN
    APIHOOK_ENTRY(USER32.DLL, UnregisterClassA)
HOOK_END


IMPLEMENT_SHIM_END
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\appcompat\shims\specific\omnipagepro11uninstall.cpp ===
/*++

 Copyright (c) 2002 Microsoft Corporation

 Module Name:

    OmniPagePro11Uninstall.cpp

 Abstract:
 
    An OmniPagePro custom action returns an invalid error code.
    We cannot shim it directly, but we can shim the custom action,
    and then trap all calls to GetProcAddress() from MSIExec    

 Notes:

    This is specific to OmniPage Pro 11 Uninstaller

 History:

    5/14/2002 mikrause  Created

--*/

#include "precomp.h"
#include <stdio.h>

IMPLEMENT_SHIM_BEGIN(OmniPagePro11Uninstall)
#include "ShimHookMacro.h"

APIHOOK_ENUM_BEGIN
    APIHOOK_ENUM_ENTRY(GetProcAddress)
APIHOOK_ENUM_END

typedef UINT (WINAPI *_pfn_MsiCustomAction)(MSIHANDLE msiHandle);

_pfn_MsiCustomAction g_pfnOriginalULinkToPagis = NULL;

UINT CALLBACK
ULinkToPagisHook(
   MSIHANDLE msiHandle
   )
{
    UINT uiRet = g_pfnOriginalULinkToPagis(msiHandle);
    if (uiRet == (UINT)-1) {
        uiRet = 0;
    }

   return uiRet;
}

FARPROC
APIHOOK(GetProcAddress)(
    HMODULE hModule,    // handle to DLL module
    LPCSTR lpProcName   // function name
    )
{
    if ((HIWORD(lpProcName) != 0) && (lstrcmpA(lpProcName, "ULinkToPagis") == 0)) {
        g_pfnOriginalULinkToPagis = (_pfn_MsiCustomAction) GetProcAddress(hModule, lpProcName);
        if (g_pfnOriginalULinkToPagis) {
            return (FARPROC)ULinkToPagisHook;
        }
    }

    return ORIGINAL_API(GetProcAddress)(hModule, lpProcName);
}

HOOK_BEGIN
    APIHOOK_ENTRY(KERNEL32.DLL, GetProcAddress )
HOOK_END

IMPLEMENT_SHIM_END
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\appcompat\shims\specific\outlook97.cpp ===
/*++

 Copyright (c) 2001 Microsoft Corporation

 Module Name:

    Outlook97.cpp

 Abstract:

    Investigation by zekel.

    Outlook 97 has an untested code-path:

        where iIndex == -173 and hInstDll == hinstShell32
        ...
            else if (iIndex < 0)
            {
                pThis->m_nEnumWant = 0;
                pThis->EnumIconFunc(hInstDll, MAKEINTRESOURCE(-iIndex), &iepStuff);
            }

    which will always fault, i.e. since iIndex used to be positive, this always 
    worked. 

 Notes:

    This is an app specific shim.

 History:

    06/15/2001 linstev   Created

--*/

#include "precomp.h"
#include "LegalStr.h"

IMPLEMENT_SHIM_BEGIN(Outlook97)
#include "ShimHookMacro.h"

APIHOOK_ENUM_BEGIN
    APIHOOK_ENUM_ENTRY(SHGetFileInfoA) 
APIHOOK_ENUM_END

/*++

 Fix faulting case.

--*/

DWORD_PTR 
APIHOOK(SHGetFileInfoA)(
    LPCSTR pszPath, 
    DWORD dwFileAttributes, 
    SHFILEINFOA *psfi, 
    UINT cbFileInfo, 
    UINT uFlags
    )
{
    DWORD_PTR dwRet = ORIGINAL_API(SHGetFileInfoA)(pszPath, dwFileAttributes, 
        psfi, cbFileInfo, uFlags);

    if (dwRet && ((uFlags & (SHGFI_ICONLOCATION | SHGFI_PIDL)) == (SHGFI_ICONLOCATION | SHGFI_PIDL))) {
        //        
        //  Check to see if this is shell32, IDI_FAVORITES
        //  Outlook faults if we return a negative index here
        //
        if (psfi->iIcon == -173 && stristr(psfi->szDisplayName, "shell32")) {
            LOGN(eDbgLevelError, "Negative icon id detected - fixing");
            psfi->iIcon = 0;
            psfi->szDisplayName[0] = 0;
        }
    }

    return dwRet;
}
 
/*++

 Register hooked functions

--*/

HOOK_BEGIN
    APIHOOK_ENTRY(SHELL32.DLL, SHGetFileInfoA)
HOOK_END

IMPLEMENT_SHIM_END
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\appcompat\shims\specific\operationsmanager.cpp ===
/*++

 Copyright (c) 2002 Microsoft Corporation

 Module Name:

    OperationsManager.cpp

 Abstract:

    The setup for OperationsManager needs to have LoadLibraryCWD applied.
    However, the setups name is random, so we need to DeRandomizeExeName.
    But, DeRandomizeExe name calls MoveFileEx to set the file to be deleted
    upon reboot.  The setup program detects that there are pending file
    deletions, interprets them as an aborted install, and recommends that
    the user stop installation.

    This shim will shim RegQueryValueExA, watch for the 
    "PendingFileRenameOperations" key, and remove any of our de-randomized exes 
    from the return string.

 Notes:

    This is an app-specific shim.

 History:

    05/07/2002 astritz  Created

--*/

#include "precomp.h"
#include "StrSafe.h"

IMPLEMENT_SHIM_BEGIN(OperationsManager)
#include "ShimHookMacro.h"

APIHOOK_ENUM_BEGIN
    APIHOOK_ENUM_ENTRY(RegQueryValueExA)
APIHOOK_ENUM_END

/*++

 Remove any of our de-randomized exe names from the PendingFileRenameOperations key.

--*/

LONG
APIHOOK(RegQueryValueExA)(
    HKEY hKey,            // handle to key
    LPCSTR lpValueName,   // value name
    LPDWORD lpReserved,   // reserved
    LPDWORD lpType,       // type buffer
    LPBYTE lpData,        // data buffer
    LPDWORD lpcbData      // size of data buffer
    )
{
    CHAR *pchBuff = NULL;

    LONG lRet = ORIGINAL_API(RegQueryValueExA)(hKey, lpValueName, lpReserved, 
        lpType, lpData, lpcbData);

    if (ERROR_SUCCESS == lRet) {
        if (CompareStringA(MAKELCID(MAKELANGID(LANG_ENGLISH, SUBLANG_NEUTRAL), 
            SORT_DEFAULT), NORM_IGNORECASE, lpValueName, -1, 
            "PendingFileRenameOperations", -1) == CSTR_EQUAL) {
            //
            // Since we're only removing strings from the original data, a buffer
            // of the original's size will suffice, and we won't overflow it.
            //

            CHAR *pchSrc = (CHAR *) lpData;
    
            pchBuff = new CHAR [*lpcbData];
            if (NULL != pchBuff) {
                CHAR *pchDest = pchBuff;

                //
                // We want to loop through ALL the data in case there is more than
                // one instance of our de-randomized name in the data.
                //
                while (pchSrc <= (CHAR *)lpData + *lpcbData) {
                    if (*pchSrc == NULL) {
                        break;
                    }

                    CString csSrc(pchSrc);
                    CString csFile;

                    csSrc.GetLastPathComponent(csFile);

                    if (csFile.CompareNoCase(L"MOM_SETUP_DERANDOMIZED.EXE") == 0) {
                        // Skip this Src File.
                        pchSrc += strlen(pchSrc) + 1;
                        if (pchSrc > (CHAR *)lpData + *lpcbData) {
                            goto Exit;
                        }

                        // Skip the Dest file as well (probably an empty string)
                        pchSrc += strlen(pchSrc) + 1;

                    } else {
                        
                        // Copy the src file.
                        if (FAILED(StringCchCopyExA(pchDest, 
                            *lpcbData - (pchDest - pchBuff), pchSrc, 
                            &pchDest, NULL, 0))) {
                            goto Exit;
                        }
                        pchSrc += strlen(pchSrc) + 1;
                        if (pchSrc > (CHAR *)lpData + *lpcbData) {
                            goto Exit;
                        }

                        // Copy the dest file.
                        if (FAILED(StringCchCopyExA(pchDest, 
                            *lpcbData - (pchDest - pchBuff), pchSrc, &pchDest, 
                            NULL, 0))) {
                            goto Exit;
                        }

                        pchSrc += strlen(pchSrc) + 1;
                    }
                }

                // Add the extra NULL to terminate the list of strings.
                *pchDest++ = NULL;

                // Copy our buffer to the returned buffer.
                memcpy(lpData, pchBuff, pchDest - pchBuff);
                *lpcbData = pchDest - pchBuff;
            }
        }
    }

Exit:
    if (NULL != pchBuff) {
        delete [] pchBuff;
    }

    return lRet;
}

/*++

 Register hooked functions

--*/

HOOK_BEGIN
    APIHOOK_ENTRY(ADVAPI32.DLL, RegQueryValueExA)
HOOK_END

IMPLEMENT_SHIM_END
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\appcompat\shims\specific\outlook2000.cpp ===
/*++

 Copyright (c) 2001 Microsoft Corporation

 Module Name:

    Outlook2000.cpp

 Abstract:

    If Outlook2000 is calling to set the system date to Hebrew, while the 
    associated UserLocale is passed in the call as Arabic, the shim will 
    replace the UserLocale with DefaultUserLocale and let the call proceed;  
    this way Outlook2000 will be able to restore the date to Hebrew 
    (which was prevented by the passing of an Arabic UserLocale).

 Notes:

    This is an app specific shim.

 History:
 
    06/12/2001 geoffguo  Created

--*/

#include "precomp.h"

IMPLEMENT_SHIM_BEGIN(Outlook2000)
#include "ShimHookMacro.h"

APIHOOK_ENUM_BEGIN
    APIHOOK_ENUM_ENTRY(SetLocaleInfoA)
APIHOOK_ENUM_END

/*++

 This hooks SetLocaleInfo.

--*/

BOOL
APIHOOK(SetLocaleInfoA)(
    LCID    Locale,
    LCTYPE  LCType,
    LPCSTR  lpLCData
    )
{
    LCID    lcid = Locale;
    LPCSTR  szCAL_HEBREW = "8";

    if (Locale == MAKELCID (LANG_ARABIC, SORT_DEFAULT) && lpLCData != NULL
        && lstrcmpA (lpLCData, szCAL_HEBREW) == 0) {
        lcid = LOCALE_USER_DEFAULT;
    }

    return SetLocaleInfoA(lcid, LCType, lpLCData);
}

/*++

 Register hooked functions

--*/

HOOK_BEGIN
    APIHOOK_ENTRY(KERNEL32.DLL, SetLocaleInfoA)    
HOOK_END

IMPLEMENT_SHIM_END
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\appcompat\shims\specific\omnipagepro.cpp ===
/*++

 Copyright (c) 2000 Microsoft Corporation

 Module Name:

    OmniPagePro.cpp

 Abstract:

    Shims ShellExecuteExA.  If the user double clicks on an image in the right 
    pane, the app will read the progID key in the registry for .BMP files 
    (HKCR, Paint.Picture\shell\open\command, "(Default)"). Previously, that 
    data had: "C:\winnt\system32\mspaint.exe" "%1". In Whistler, that changed 
    to: rundll32.exe C:\WINNT\System32\shimgvw.dll,ImageView_Fullscreen %1.
    
    The problem with Carea OmniPage Pro v10 is that on the double click, they 
    will read the regkey, remove the %1, pass the rest of the string to 
    ShellExecuteExA() lpFile.  They will put the filename into lpParameters.  
    The problem is that with the new path, "rundll32.exe" needs to be in lpFile 
    and "C:\WINNT\System32\shimgvw.dll,ImageView_Fullscreen <FileToOpen>" needs 
    to be in lpParameters.

 Notes:

    This is specific to OmniPage Pro.

 History:

    2/12/2000 bryanst  Created

--*/

#include "precomp.h"
#include <stdio.h>

IMPLEMENT_SHIM_BEGIN(OmniPage)
#include "ShimHookMacro.h"

APIHOOK_ENUM_BEGIN
    APIHOOK_ENUM_ENTRY(ShellExecuteExA) 
APIHOOK_ENUM_END

BOOL
APIHOOK(ShellExecuteExA)(
    LPSHELLEXECUTEINFOA lpExecInfo
    )
{
    CSTRING_TRY
    {
        CString csFile(lpExecInfo->lpFile);
        int nIndexGVW       = csFile.Find(L"shimgvw.dll,");
        int nIndexRundll    = csFile.Find(L"rundll32.exe");
        int nIndexSpace     = csFile.Find(L" ");

        if (nIndexGVW    != -1 &&
            nIndexRundll != -1 &&
            nIndexSpace  >=  1)
        {
            CString csParam;
            csFile.Mid(nIndexSpace + 1, csParam);   // everything after the space
            csFile.Delete(nIndexSpace, csFile.GetLength() - nIndexSpace); // Delete the space and everything after

            csParam += " ";
            csParam += lpExecInfo->lpParameters;

            lpExecInfo->lpFile       = csFile.GetAnsi();
            lpExecInfo->lpParameters = csParam.GetAnsi();
        }
    }
    CSTRING_CATCH
    {
        // Do nothing
    }

    return ORIGINAL_API(ShellExecuteExA)(lpExecInfo);
}


HOOK_BEGIN
    APIHOOK_ENTRY(SHELL32.DLL, ShellExecuteExA )
HOOK_END

IMPLEMENT_SHIM_END
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\appcompat\shims\specific\outlook98wizard.cpp ===
/*++

 Copyright (c) 2002 Microsoft Corporation

 Module Name:

    Outlook98Wizard.cpp

 Abstract:

    This DLL hooks VerQueryValue, and will return English Language information
    for Japanese outlook 98 setup file.

 Notes:

    This is an app specific shim.

 History:

    01/21/2002 v-rbabu  Created

--*/

#include "precomp.h"
#include "string.h"

IMPLEMENT_SHIM_BEGIN(Outlook98Wizard)
#include "ShimHookMacro.h"

APIHOOK_ENUM_BEGIN
    APIHOOK_ENUM_ENTRY(VerQueryValueA)
APIHOOK_ENUM_END

/*++

 The actual problem is, the outlook 98 setup is comparing the language 
 informations of the Shell32.dll and the setup file (outlwzd.exe). But 
 according to the bug scenario, the system is having English OS and Japanese 
 Locale. So, Shell32.dll have English language as its language. So, this 
 differs with the Language informaiton of Japanese Outlook setuip file.

 So, setup thorows an error that the Language of the outlook 98 going to be 
 installed differs with the system language.

 This stub function lie about the language information of the outlook setup 
 file. Though the setup file is Japanese as language informaiton, this shim 
 returns as if it is English.

--*/

BOOL
APIHOOK(VerQueryValueA)(
    const LPVOID pBlock,
    LPSTR lpSubBlock,
    LPVOID *lplpBuffer,
    PUINT puLen
    )
{
    BOOL bRet = ORIGINAL_API(VerQueryValueA)(pBlock, lpSubBlock, lplpBuffer, puLen);
    
    if (bRet) {
        CSTRING_TRY
        {
            //
            // If trying to get the \VarFileInfo\Translation, then assign English
            // Language information to the output buffer.
            //
            CString csSubBlockString(lpSubBlock);

            if (lplpBuffer && (csSubBlockString.Find(L"\\VarFileInfo\\Translation") != -1)) {
                // Adjust the version info
                LOGN(eDbgLevelInfo, "[VerQueryValueA] Return modified version info");
                *lplpBuffer = L"03a40409";  
            }
        }
        CSTRING_CATCH
        {
            // Do nothing
        }
    }

    return bRet;
}

/*++

 Register hooked functions

--*/

HOOK_BEGIN
    APIHOOK_ENTRY(VERSION.DLL, VerQueryValueA)
HOOK_END

IMPLEMENT_SHIM_END
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\appcompat\shims\specific\panzercommander.cpp ===
/*++

 Copyright (c) 2000 Microsoft Corporation

 Module Name:

    PanzerCommander.cpp

 Abstract:

    Panzer Commander launches its readme.txt file with Notepad.exe. 
    Unfortunately, on the readme file is > 64K so Win9x Notepad will open the 
    file with write.exe.  On Win2000, notepad will open the file just fine, 
    however the problem is that readme.txt should actually be readme.doc.

    We change %windir%\notepad.exe with %windir%\write.exe

 Notes:

    This is an app specific shim.

 History:

    12/12/2000  robkenny    Created
    03/13/2001  robkenny    Converted to CString

--*/

#include "precomp.h"

IMPLEMENT_SHIM_BEGIN(PanzerCommander)
#include "ShimHookMacro.h"

APIHOOK_ENUM_BEGIN
    APIHOOK_ENUM_ENTRY(CreateProcessA) 
APIHOOK_ENUM_END

/*++

 They use notepad to open a text file that is really a DOC file. Convert 
 notepad.exe to write.exe

--*/

BOOL 
APIHOOK(CreateProcessA)(
    LPCSTR lpApplicationName,                 
    LPSTR lpCommandLine,                      
    LPSECURITY_ATTRIBUTES lpProcessAttributes,
    LPSECURITY_ATTRIBUTES lpThreadAttributes, 
    BOOL bInheritHandles,                     
    DWORD dwCreationFlags,                    
    LPVOID lpEnvironment,                     
    LPCSTR lpCurrentDirectory,                
    LPSTARTUPINFOA lpStartupInfo,             
    LPPROCESS_INFORMATION lpProcessInformation
    )
{
    CSTRING_TRY
    {
        AppAndCommandLine acl(lpApplicationName, lpCommandLine);

        CString csAppName(acl.GetApplicationName());
        CString csCL(acl.GetCommandlineNoAppName());

        BOOL bChangedApp = FALSE;

        // If the application is notepad, change it to write
        if (!csAppName.CompareNoCase(L"notepad.exe") == 0)
        {
            csAppName = L"%windir%\\system32\\write.exe";
            csAppName.ExpandEnvironmentStringsW();

            bChangedApp = TRUE;
        }

        char * lpcl = csCL.GetAnsi();
        
        UINT uiReturn = ORIGINAL_API(CreateProcessA)(
            csAppName.GetAnsiNIE(),                 
            lpcl,
            lpProcessAttributes,
            lpThreadAttributes, 
            bInheritHandles,                     
            dwCreationFlags,                    
            lpEnvironment,                     
            lpCurrentDirectory,                
            lpStartupInfo,             
            lpProcessInformation);
        
        if (bChangedApp)
        {
            DPFN(
                eDbgLevelInfo,
                "PanzerCommander, corrected command line:\n(%s)\n(%s)\n",
                lpCommandLine, lpcl);
        }

        return uiReturn;
    }
    CSTRING_CATCH
    {
        // Do nothing
    }

    UINT uiReturn = ORIGINAL_API(CreateProcessA)(
        lpApplicationName,                 
        lpCommandLine,                      
        lpProcessAttributes,
        lpThreadAttributes, 
        bInheritHandles,                     
        dwCreationFlags,                    
        lpEnvironment,                     
        lpCurrentDirectory,                
        lpStartupInfo,             
        lpProcessInformation);

    return uiReturn;
}

/*++

 Register hooked functions

--*/

HOOK_BEGIN

    APIHOOK_ENTRY(KERNEL32.DLL, CreateProcessA)

HOOK_END

IMPLEMENT_SHIM_END
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\appcompat\shims\specific\pickyeater.cpp ===
/*++

 Copyright (c) 2000 Microsoft Corporation

 Module Name:

    PickyEater.cpp

 Abstract:

    The application AVs during startup.
    
    When the app receives a WM_PALETTECHANGED message,
    it should compare the wParam and the hWnd. If they
    match, it should not handle the message. If they don't,
    it should.

 Notes:

    This is an app specific shim.

 History:

    01/04/2001  rparsons    Created

--*/

#include "precomp.h"

IMPLEMENT_SHIM_BEGIN(PickyEater)
#include "ShimHookMacro.h"

APIHOOK_ENUM_BEGIN
    APIHOOK_ENUM_ENTRY(SendMessageA) 
APIHOOK_ENUM_END

/*++

  Eat the WM_PALETTECHANGED if the hWnd is NULL

--*/

BOOL
APIHOOK(SendMessageA)(
        HWND hWnd,
        UINT uMsg,
        WPARAM wParam,
        LPARAM lParam
        )
{
    if ((hWnd == NULL) && (uMsg == WM_PALETTECHANGED))
    {
        return TRUE;
    }

    return FALSE;
}

/*++

 Register hooked functions

--*/

HOOK_BEGIN

    APIHOOK_ENTRY(USER32.DLL, SendMessageA)

HOOK_END

IMPLEMENT_SHIM_END
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\appcompat\shims\specific\pirch98.cpp ===
/*++

 Copyright (c) 2001 Microsoft Corporation

 Module Name:

    Pirch98.cpp

 Abstract:

   Remove the HWND_TOPMOST property on all their windows

 Notes:

    This is an app specific shim.

 History:

    04/23/2001  robkenny    Created

--*/

#include "precomp.h"

IMPLEMENT_SHIM_BEGIN(Pirch98)
#include "ShimHookMacro.h"

APIHOOK_ENUM_BEGIN
    APIHOOK_ENUM_ENTRY(SetWindowPos) 
APIHOOK_ENUM_END


/*++

   Remove the HWND_TOPMOST property on all their windows

--*/

BOOL
APIHOOK(SetWindowPos)(
  HWND hWnd,             // handle to window
  HWND hWndInsertAfter,  // placement-order handle
  int X,                 // horizontal position
  int Y,                 // vertical position
  int cx,                // width
  int cy,                // height
  UINT uFlags            // window-positioning options
)
{
    if (hWndInsertAfter == HWND_TOPMOST)
    {
        hWndInsertAfter = HWND_TOP;
        LOGN(eDbgLevelError, "[SetWindowPos] Replacing HWND_TOPMOST with HWND_TOP\n");
    }

    return ORIGINAL_API(SetWindowPos)(hWnd, hWndInsertAfter, X, Y, cx, cy, uFlags);
}

/*++

 Register hooked functions

--*/

HOOK_BEGIN
    APIHOOK_ENTRY(USER32.DLL, SetWindowPos)
HOOK_END

IMPLEMENT_SHIM_END
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\appcompat\shims\specific\overlaypro.cpp ===
/*++

 Copyright (c) 2000 Microsoft Corporation

 Module Name:

    OverlayPro.cpp

 Abstract:

    This shim changes the return value of RegOpenKeyA from ERROR_SUCCESS
    to ERROR_FILE_NOT_FOUND if the key is "System\CurrentControlSet\Control\Print\Printers"
    
    No idea why this is needed but it seems to make the app work. Probably
    something else is the cause the app behaves differently but no one investigated
    more into the app's code to figure it out.

 Notes:

    This is an app specific shim.

 History:

    02/16/2000 clupu Created

--*/

#include "precomp.h"

IMPLEMENT_SHIM_BEGIN(OverlayPro)
#include "ShimHookMacro.h"

APIHOOK_ENUM_BEGIN
    APIHOOK_ENUM_ENTRY(RegOpenKeyA) 
APIHOOK_ENUM_END


/*++

 Change the return value of RegOpenKeyA from 0 to 2 if the key is 
 "System\CurrentControlSet\Control\Print\Printers"

--*/

LONG
APIHOOK(RegOpenKeyA)(
    HKEY   hKey,
    LPSTR  lpSubKey,
    PHKEY  phkResult
    )

{
    LONG lRet;

    //
    // Call the original API
    //
    lRet = ORIGINAL_API(RegOpenKeyA)(hKey, lpSubKey, phkResult);
    
    if (lRet == 0) {
        
        if (lstrcmpiA(lpSubKey, "System\\CurrentControlSet\\Control\\Print\\Printers") == 0) {
            DPFN(
                eDbgLevelInfo,
                "OverlayPro.dll, Changing RegOpenKeyA's "
                "return from ERROR_SUCCESS to ERROR_FILE_NOT_FOUND.\n");
            lRet = 2;
        }
    }
    
    return lRet;
}

/*++

 Register hooked functions

--*/

HOOK_BEGIN

    APIHOOK_ENTRY(ADVAPI32.DLL, RegOpenKeyA)

HOOK_END


IMPLEMENT_SHIM_END
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\appcompat\shims\specific\petz.cpp ===
/*++

 Copyright (c) 2000 Microsoft Corporation

 Module Name:

   PetzForceCritSecRelease.cpp

 Abstract:

   This DLL takes care of a Thread that is exiting without performing a
   LeaveCriticalSection on a critical section it owns. 

 Notes:

   This is a application specific shim.

 History:

   04/00/2000 a-chcoff  Created

--*/

#include "precomp.h"

IMPLEMENT_SHIM_BEGIN(Petz)
#include "ShimHookMacro.h"

APIHOOK_ENUM_BEGIN
    APIHOOK_ENUM_ENTRY(_endthread) 
    APIHOOK_ENUM_ENTRY(ShellExecuteA) 
APIHOOK_ENUM_END

LPCRITICAL_SECTION g_pCritSectToRelease;

HINSTANCE 
APIHOOK(ShellExecuteA)(                  
    HWND hwnd,              
    LPCSTR lpVerb,          
    LPCSTR lpFile, 
    LPCSTR lpParameters, 
    LPCSTR lpDirectory,
    INT nShowCmd)
{
    CSTRING_TRY
    {
        CString csFile(lpFile);
        csFile.Replace(L"SYSTEM\\PETZ", L"SYSTEM32\\PETZ");

        return ORIGINAL_API(ShellExecuteA)(
                hwnd,
                lpVerb,      
                csFile.GetAnsi(),      
                lpParameters,
                lpDirectory, 
                nShowCmd);         
    }
    CSTRING_CATCH
    {
        // Do nothing
    }

    return ORIGINAL_API(ShellExecuteA)(
            hwnd,
            lpVerb,      
            lpFile,      
            lpParameters,
            lpDirectory, 
            nShowCmd);         
}
                                    
VOID
APIHOOK(_endthread)(void) 
{
    //Don't let the thread orphan a critical section.
    LeaveCriticalSection(g_pCritSectToRelease);
    ORIGINAL_API(_endthread)();
}

/*++

 Register hooked functions

--*/

BOOL
NOTIFY_FUNCTION(
    DWORD fdwReason)
{
    if (fdwReason == DLL_PROCESS_ATTACH)
    {
        CSTRING_TRY
        {
            CString csCl(COMMAND_LINE);

            WCHAR *unused;
            g_pCritSectToRelease = (LPCRITICAL_SECTION) wcstol(csCl, &unused, 10);
        }
        CSTRING_CATCH
        {
            return FALSE;
        }
    }

    return TRUE;
}

HOOK_BEGIN

    CALL_NOTIFY_FUNCTION

    APIHOOK_ENTRY(MSVCRT.DLL, _endthread)
    APIHOOK_ENTRY(SHELL32.DLL, ShellExecuteA)

HOOK_END

IMPLEMENT_SHIM_END
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\appcompat\shims\specific\planecrazy.cpp ===
/*++

 Copyright (c) 2000 Microsoft Corporation

 Module Name:

    PlaneCrazy.cpp

 Abstract:

    Hooks all application-defined window procedures and adds a WM_PAINT 
    message upon receipt of a WM_SETFOCUS. For some reason the one that normally
    came through on win9x gets lost.

 Notes:

    This shim can be reused for other shims that require WindowProc hooking.
    Copy all APIHook_* functions and simply replace the code in PlaneCrazy_WindowProcHook
    and PlaneCrazy_DialogProcHook.

 History:

    11/01/1999 markder  Created
    02/15/1999 markder  Reworked WndProc hooking mechanism so that it generically
                        hooks all WndProcs for the process.
    02/15/1999 a-chcoff copied to here and created this shim with code base.

--*/

#include "precomp.h"

IMPLEMENT_SHIM_BEGIN(PlaneCrazy)
#include "ShimHookMacro.h"


APIHOOK_ENUM_BEGIN
    APIHOOK_ENUM_ENTRY(RegisterClassA)
    APIHOOK_ENUM_ENTRY(RegisterClassW)
    APIHOOK_ENUM_ENTRY(RegisterClassExA)
    APIHOOK_ENUM_ENTRY(RegisterClassExW)
    APIHOOK_ENUM_ENTRY(CreateDialogParamA)
    APIHOOK_ENUM_ENTRY(CreateDialogParamW)
    APIHOOK_ENUM_ENTRY(CreateDialogIndirectParamA)
    APIHOOK_ENUM_ENTRY(CreateDialogIndirectParamW)    
    APIHOOK_ENUM_ENTRY(CreateDialogIndirectParamAorW)
    APIHOOK_ENUM_ENTRY(SetWindowLongA)
    APIHOOK_ENUM_ENTRY(SetWindowLongW)
APIHOOK_ENUM_END

/*++

 Change WM_DRAWITEM behaviour

--*/

LRESULT CALLBACK 
PlaneCrazy_WindowProcHook(
    WNDPROC pfnOld, // address of old WindowProc
    HWND hwnd,      // handle to window
    UINT uMsg,      // message identifier
    WPARAM wParam,  // first message parameter
    LPARAM lParam   // second message parameter
    )
{
    // Check for message we're interested in
    if (uMsg == WM_SETFOCUS)
    {
        SendMessage(hwnd,WM_PAINT,NULL,NULL);
           
    }

    return (*pfnOld)(hwnd, uMsg, wParam, lParam);    
}

INT_PTR CALLBACK 
PlaneCrazy_DialogProcHook(
  DLGPROC   pfnOld,   // address of old DialogProc
  HWND      hwndDlg,  // handle to dialog box
  UINT      uMsg,     // message
  WPARAM    wParam,   // first message parameter
  LPARAM    lParam    // second message parameter
)
{
    // Check for message we're interested in
    if (uMsg == WM_SETFOCUS)
    {
        SendMessage(hwndDlg,WM_PAINT,NULL,NULL);

    }

    return (*pfnOld)(hwndDlg, uMsg, wParam, lParam);    
}





/*++

 Hook all possible calls that can initialize or change a window's
 WindowProc (or DialogProc)

--*/

ATOM
APIHOOK(RegisterClassA)(
    CONST WNDCLASSA *lpWndClass  // class data
)
{
    WNDCLASSA   wcNewWndClass   = *lpWndClass;

    wcNewWndClass.lpfnWndProc = (WNDPROC) HookCallback(lpWndClass->lpfnWndProc, PlaneCrazy_WindowProcHook);

    return ORIGINAL_API(RegisterClassA)(&wcNewWndClass);
}

ATOM
APIHOOK(RegisterClassW)(
    CONST WNDCLASSW *lpWndClass  // class data
)
{
    WNDCLASSW   wcNewWndClass   = *lpWndClass;

    wcNewWndClass.lpfnWndProc = (WNDPROC) HookCallback(lpWndClass->lpfnWndProc, PlaneCrazy_WindowProcHook);

    return ORIGINAL_API(RegisterClassW)(&wcNewWndClass);
}

ATOM
APIHOOK(RegisterClassExA)(
    CONST WNDCLASSEXA *lpwcx  // class data
)
{
    WNDCLASSEXA   wcNewWndClass   = *lpwcx;

    wcNewWndClass.lpfnWndProc = (WNDPROC) HookCallback(lpwcx->lpfnWndProc, PlaneCrazy_WindowProcHook);

    return ORIGINAL_API(RegisterClassExA)(&wcNewWndClass);
}

ATOM
APIHOOK(RegisterClassExW)(
    CONST WNDCLASSEXW *lpwcx  // class data
)
{
    WNDCLASSEXW   wcNewWndClass   = *lpwcx;

    wcNewWndClass.lpfnWndProc = (WNDPROC) HookCallback(lpwcx->lpfnWndProc, PlaneCrazy_WindowProcHook);

    return ORIGINAL_API(RegisterClassExW)(&wcNewWndClass);
}

HWND
APIHOOK(CreateDialogParamA)(
    HINSTANCE hInstance,     // handle to module
    LPCSTR lpTemplateName,   // dialog box template
    HWND hWndParent,         // handle to owner window
    DLGPROC lpDialogFunc,    // dialog box procedure
    LPARAM dwInitParam       // initialization value
)
{
    lpDialogFunc = (DLGPROC) HookCallback(lpDialogFunc, PlaneCrazy_DialogProcHook);

    return ORIGINAL_API(CreateDialogParamA)(  hInstance,
                                                lpTemplateName,
                                                hWndParent,
                                                lpDialogFunc,
                                                dwInitParam     );
}

HWND
APIHOOK(CreateDialogParamW)(
    HINSTANCE hInstance,     // handle to module
    LPCWSTR lpTemplateName,  // dialog box template
    HWND hWndParent,         // handle to owner window
    DLGPROC lpDialogFunc,    // dialog box procedure
    LPARAM dwInitParam       // initialization value
)
{
    lpDialogFunc = (DLGPROC) HookCallback(lpDialogFunc, PlaneCrazy_DialogProcHook);

    return ORIGINAL_API(CreateDialogParamW)(  hInstance,
                                                lpTemplateName,
                                                hWndParent,
                                                lpDialogFunc,
                                                dwInitParam     );
}

HWND
APIHOOK(CreateDialogIndirectParamA)(
  HINSTANCE hInstance,        // handle to module
  LPCDLGTEMPLATE lpTemplate,  // dialog box template
  HWND hWndParent,            // handle to owner window
  DLGPROC lpDialogFunc,       // dialog box procedure
  LPARAM lParamInit           // initialization value
)
{
    lpDialogFunc = (DLGPROC) HookCallback(lpDialogFunc, PlaneCrazy_DialogProcHook);

    return ORIGINAL_API(CreateDialogIndirectParamA)(  hInstance,
                                                        lpTemplate,
                                                        hWndParent,
                                                        lpDialogFunc,
                                                        lParamInit     );
}

HWND
APIHOOK(CreateDialogIndirectParamW)(
  HINSTANCE hInstance,        // handle to module
  LPCDLGTEMPLATE lpTemplate,  // dialog box template
  HWND hWndParent,            // handle to owner window
  DLGPROC lpDialogFunc,       // dialog box procedure
  LPARAM lParamInit           // initialization value
)
{
    lpDialogFunc = (DLGPROC) HookCallback(lpDialogFunc, PlaneCrazy_DialogProcHook);

    return ORIGINAL_API(CreateDialogIndirectParamW)(  hInstance,
                                                        lpTemplate,
                                                        hWndParent,
                                                        lpDialogFunc,
                                                        lParamInit     );
}

HWND
APIHOOK(CreateDialogIndirectParamAorW)(
  HINSTANCE hInstance,        // handle to module
  LPCDLGTEMPLATE lpTemplate,  // dialog box template
  HWND hWndParent,            // handle to owner window
  DLGPROC lpDialogFunc,       // dialog box procedure
  LPARAM lParamInit           // initialization value
)
{
    lpDialogFunc = (DLGPROC) HookCallback(lpDialogFunc, PlaneCrazy_DialogProcHook);

    return ORIGINAL_API(CreateDialogIndirectParamAorW)(  hInstance,
                                                           lpTemplate,
                                                           hWndParent,
                                                           lpDialogFunc,
                                                           lParamInit     );
}

LONG 
APIHOOK(SetWindowLongA)(
    HWND hWnd,
    int nIndex,           
    LONG dwNewLong    
    )
{
    if( nIndex == GWL_WNDPROC )
        dwNewLong = (LONG) HookCallback((PVOID)dwNewLong, PlaneCrazy_WindowProcHook);
    else if( nIndex == DWL_DLGPROC )
        dwNewLong = (LONG) HookCallback((PVOID)dwNewLong, PlaneCrazy_DialogProcHook);

    return ORIGINAL_API(SetWindowLongA)(  hWnd,
                                            nIndex,
                                            dwNewLong );
}

LONG 
APIHOOK(SetWindowLongW)(
    HWND hWnd,
    int nIndex,           
    LONG dwNewLong    
    )
{
    if( nIndex == GWL_WNDPROC )
        dwNewLong = (LONG) HookCallback((PVOID)dwNewLong, PlaneCrazy_WindowProcHook);
    else if( nIndex == DWL_DLGPROC )
        dwNewLong = (LONG) HookCallback((PVOID)dwNewLong, PlaneCrazy_DialogProcHook);

    return ORIGINAL_API(SetWindowLongA)(  hWnd,
                                            nIndex,
                                            dwNewLong );
}

/*++

 Register hooked functions

--*/

HOOK_BEGIN
    APIHOOK_ENTRY(USER32.DLL, RegisterClassA)
    APIHOOK_ENTRY(USER32.DLL, RegisterClassW)
    APIHOOK_ENTRY(USER32.DLL, RegisterClassExA)
    APIHOOK_ENTRY(USER32.DLL, RegisterClassExW)
    APIHOOK_ENTRY(USER32.DLL, CreateDialogParamA)
    APIHOOK_ENTRY(USER32.DLL, CreateDialogParamW)
    APIHOOK_ENTRY(USER32.DLL, CreateDialogIndirectParamA)
    APIHOOK_ENTRY(USER32.DLL, CreateDialogIndirectParamW)
    APIHOOK_ENTRY(USER32.DLL, CreateDialogIndirectParamAorW)
    APIHOOK_ENTRY(USER32.DLL, SetWindowLongA)
    APIHOOK_ENTRY(USER32.DLL, SetWindowLongW)
HOOK_END

IMPLEMENT_SHIM_END
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\appcompat\shims\specific\postit2.cpp ===
/*++

 Copyright (c) 2001 Microsoft Corporation

 Module Name:

    PostIt2.cpp

 Abstract:

    This shim eliminates an infinite loop in 3M's Post-It Notes application
    by preventing the WM_TIMECHANGE message from reaching the Post-It
    Notes windows when the application triggers a time change using
    SetTimeZoneInformation().
 
 Notes:

    This is an application specific shim.

 History:

    06/04/2001  tonyschr    Created

--*/

#include "precomp.h"

IMPLEMENT_SHIM_BEGIN(PostIt2)
#include "ShimHookMacro.h"

APIHOOK_ENUM_BEGIN
    APIHOOK_ENUM_ENTRY(SetTimeZoneInformation)
    APIHOOK_ENUM_ENTRY(CallWindowProcA)
APIHOOK_ENUM_END


static SYSTEMTIME g_localtime = { 0 };


BOOL
APIHOOK(SetTimeZoneInformation)(
          CONST TIME_ZONE_INFORMATION *lpTimeZoneInformation
)
{
    BOOL fReturn = ORIGINAL_API(SetTimeZoneInformation)(lpTimeZoneInformation);

    // Store off local time after this application requests timezone change.
    GetLocalTime(&g_localtime);

    return fReturn;
}


LRESULT
APIHOOK(CallWindowProcA)(
          WNDPROC pfn,
          HWND    hwnd,
          UINT    message,
          WPARAM  wParam,
          LPARAM  lParam)
{
    // Detect whether the WM_TIMECHANGE message was triggered by the app calling
    // SetTimeZoneInformation() or an external timechange by comparing the local
    // time.
    if (message == WM_TIMECHANGE)
    {
        SYSTEMTIME newtime;
        GetLocalTime(&newtime);
        
        if (newtime.wYear         == g_localtime.wYear      &&
            newtime.wMonth        == g_localtime.wMonth     &&
            newtime.wDayOfWeek    == g_localtime.wDayOfWeek &&
            newtime.wDay          == g_localtime.wDay       &&
            newtime.wHour         == g_localtime.wHour      &&
            newtime.wMinute       == g_localtime.wMinute    &&
            newtime.wSecond       == g_localtime.wSecond    &&
            newtime.wMilliseconds == g_localtime.wMilliseconds)
        {
            // Looks like this WM_TIMECHANGE was sent in response to the app
            // calling SetTimeZoneInformation(), so block it.
            // Note: Because of the asynchronous nature of window messages this
            // might let an occasional WM_TIMECHANGE slip through, but it should
            // always terminiate the infinite loop.
            return 0;
        }
    }
    
    return ORIGINAL_API(CallWindowProcA)(pfn, hwnd, message, wParam, lParam);
}


/*++

 Register hooked functions

--*/

HOOK_BEGIN
    APIHOOK_ENTRY(KERNEL32.DLL, SetTimeZoneInformation)
    APIHOOK_ENTRY(USER32.DLL, CallWindowProcA)
HOOK_END

IMPLEMENT_SHIM_END
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\appcompat\shims\specific\powerbuilder.cpp ===
/*

 Copyright (c) 2000 Microsoft Corporation

 Module Name:

   PowerBuilder.cpp

 Abstract:

    This fixes a profiles bug in PowerBuilder where it adds reg keys to HKCU
    which point to various paths in the install location, essentially by adding
    User ODBC datasources, which should've been System ODBC datasources, hence
    installed under HKLM. 
    This shim recreates the registry values expected in HKCU for other users:

    HKCU\Software\ODBC\ODBC.INI\ODBC Data Sources\Powersoft Demo DB V6 =
        "Sybase SQL Anywhere 5.0"
    HKCU\Software\ODBC\ODBC.INI\Powersoft Demo DB V6\DataBaseFile =
        "<install1>\demodb\psDemoDB.db"
    HKCU\Software\ODBC\ODBC.INI\Powersoft Demo DB V6\DataBaseName = "psDemoDB"
    HKCU\Software\ODBC\ODBC.INI\Powersoft Demo DB V6\Driver =
        "<install2>\WOD50T.DLL"
    HKCU\Software\ODBC\ODBC.INI\Powersoft Demo DB V6\PWD = "sql"
    HKCU\Software\ODBC\ODBC.INI\Powersoft Demo DB V6\Start =
        "<install2>\dbeng50.exe -d -c512"
    HKCU\Software\ODBC\ODBC.INI\Powersoft Demo DB V6\UID = "dba"

    where <install1> is location of PowerBuilder Install:
    The value of <install1> and <install2> can be found in
    HKLM\Software\Microsoft\Windows\CurrentVersion\App Paths\PB60.EXE\Path =
        "<install1>;...;...;<install2>;"

 History:

    03/29/2001  bklamik    Created
*/

#include "precomp.h"
#include <stdio.h>

IMPLEMENT_SHIM_BEGIN(PowerBuilder)
#include "ShimHookMacro.h"

APIHOOK_ENUM_BEGIN
    APIHOOK_ENUM_ENTRY(RegQueryValueExA)
    APIHOOK_ENUM_ENTRY(RegQueryValueExW)
APIHOOK_ENUM_END

void FixupPowerBuilder()
{
    DWORD dwPresent = REG_OPENED_EXISTING_KEY;
    HKEY hODBC;
    if( ERROR_SUCCESS == RegCreateKeyExW( HKEY_CURRENT_USER,
        L"SOFTWARE\\ODBC\\ODBC.INI\\ODBC Data Sources",
        0, NULL, 0, KEY_ALL_ACCESS, NULL, &hODBC, &dwPresent ) )
    {
        WCHAR c;
        DWORD dwLen = 0;
        DWORD dwType;

        if( REG_CREATED_NEW_KEY == dwPresent ||
            ERROR_MORE_DATA != RegQueryValueExW( hODBC,
                L"Powersoft Demo DB V6", 0, &dwType, 
                (BYTE*)&c, &dwLen ) )
        {
            const WCHAR szVal9[] = L"Sybase SQL Anywhere 5.0";

            RegSetValueExW( hODBC, L"Powersoft Demo DB V6",
                0, REG_SZ, (const BYTE*)szVal9, sizeof(szVal9) );

            // Find <install1> and <install2>
            HKEY hAppPath;
            if( ERROR_SUCCESS == RegOpenKeyExW( HKEY_LOCAL_MACHINE,
                L"SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\App Paths\\PB60.EXE",
                0, KEY_READ, &hAppPath ) )
            {
                WCHAR szValue[ 4 * (MAX_PATH + 1) ] = L"";
                DWORD dwSize = sizeof( szValue );
                DWORD dwType;

                if( ERROR_SUCCESS == RegQueryValueExW( hAppPath, L"path", NULL,
                    &dwType, (LPBYTE)szValue, &dwSize ) )
                {
                    const WCHAR* szInstall1 = szValue;
                    const WCHAR* szInstall2;

                    WCHAR* pFindSemi = szValue;

                    INT iSemis( 4 );
                    do
                    {
                        while( *pFindSemi != ';' && *pFindSemi != 0 )
                        {
                            ++pFindSemi;
                        }
                        *pFindSemi = 0;
                        ++pFindSemi;

                        if( 2 == iSemis )
                        {
                            szInstall2 = pFindSemi;
                        }
                    } while( --iSemis != 0 );

                    HKEY hDemoDB;
                    dwPresent = REG_OPENED_EXISTING_KEY;
                    if( ERROR_SUCCESS == RegCreateKeyExW( HKEY_CURRENT_USER,
                        L"SOFTWARE\\ODBC\\ODBC.INI\\Powersoft Demo DB V6",
                        0, NULL, 0, KEY_WRITE, NULL, &hDemoDB, &dwPresent ) )
                    {
                        if( REG_CREATED_NEW_KEY == dwPresent )
                        {

                            const WCHAR szVal0[] = L"psDemoDB";
                            const WCHAR szVal1[] = L"sql";
                            const WCHAR szVal2[] = L"dba";

                            RegSetValueExW( hDemoDB, L"DataBaseName",
                                0, REG_SZ, (const BYTE*)szVal0, sizeof(szVal0) );
                            RegSetValueExW( hDemoDB, L"PWD",
                                0, REG_SZ, (const BYTE*)szVal1, sizeof(szVal1) );
                            RegSetValueExW( hDemoDB, L"UID",
                                0, REG_SZ, (const BYTE*)szVal2, sizeof(szVal2) );

                            WCHAR szTemp[ MAX_PATH + 1 ];
                            lstrcpyW( szTemp, szInstall1 );
                            lstrcatW( szTemp, L"\\demodb\\psDemoDB.db" );
                            RegSetValueExW( hDemoDB, L"DataBaseFile",
                                0, REG_SZ, (const BYTE*)szTemp,
                                (lstrlen( szTemp ) + 1) * sizeof(WCHAR) );

                            lstrcpyW( szTemp, szInstall2 );
                            lstrcatW( szTemp, L"\\WOD50T.DLL" );
                            RegSetValueExW( hDemoDB, L"Driver",
                                0, REG_SZ, (const BYTE*)szTemp,
                                (lstrlen( szTemp ) + 1) * sizeof(WCHAR) );

                            lstrcpyW( szTemp, szInstall2 );
                            lstrcatW( szTemp, L"\\dbeng50.exe -d -c512" );
                            RegSetValueExW( hDemoDB, L"Start",
                                0, REG_SZ, (const BYTE*)szTemp,
                                (lstrlen( szTemp ) + 1) * sizeof(WCHAR) );
                        }

                        RegCloseKey( hDemoDB );
                    }
                }

                RegCloseKey( hAppPath );
            }

        }

        RegCloseKey( hODBC );
    }
}

LONG
APIHOOK(RegQueryValueExA)(HKEY hKey, LPCSTR lpValueName, 
                          LPDWORD lpReserved, LPDWORD lpType, LPBYTE lpData, 
                          LPDWORD lpcbData )
{
    FixupPowerBuilder();
    return ORIGINAL_API(RegQueryValueExA)(hKey, lpValueName,
                                            lpReserved, lpType, lpData, lpcbData);
}


LONG
APIHOOK(RegQueryValueExW)(HKEY hKey, LPCWSTR lpValueName, 
                          LPDWORD lpReserved, LPDWORD lpType, LPBYTE lpData, 
                          LPDWORD lpcbData )
{
    FixupPowerBuilder();
    return ORIGINAL_API(RegQueryValueExW)(hKey, lpValueName,
                                            lpReserved, lpType, lpData, lpcbData);
}



BOOL
NOTIFY_FUNCTION(
    DWORD fdwReason
    )
{
    if (fdwReason == DLL_PROCESS_ATTACH) {
        OSVERSIONINFOEX osvi = {0};
        
        osvi.dwOSVersionInfoSize = sizeof(OSVERSIONINFOEX);
        
        if (GetVersionEx((OSVERSIONINFO*)&osvi)) {
            
            if (!((VER_SUITE_TERMINAL & osvi.wSuiteMask) &&
                !(VER_SUITE_SINGLEUSERTS & osvi.wSuiteMask))) {
                //
                // Only install hooks if we are not on a "Terminal Server"
                // (aka "Application Server") machine.
                //
                APIHOOK_ENTRY(ADVAPI32.DLL, RegQueryValueExA)
                APIHOOK_ENTRY(ADVAPI32.DLL, RegQueryValueExW)
            }
        }
    }

    return TRUE;
}


HOOK_BEGIN

    CALL_NOTIFY_FUNCTION

HOOK_END


IMPLEMENT_SHIM_END
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\appcompat\shims\specific\printmaster4.cpp ===
/*++

 Copyright (c) 2002 Microsoft Corporation

 Module Name:

    PrintMaster4.cpp

 Abstract:

    Force mfcans32.dll to not have the read-only bit. Many HP systems shipped 
    with this turned on as a kind of lightweight SFP. However, the unpleasant 
    consequence is that PrintMaster doesn't install.

 Notes:

    This is an app specific shim.

 History:

    02/20/2002 linstev   Created

--*/

#include "precomp.h"

IMPLEMENT_SHIM_BEGIN(PrintMaster4)
#include "ShimHookMacro.h"

APIHOOK_ENUM_BEGIN
APIHOOK_ENUM_END

/*++

 Run Notify function only 

--*/

BOOL
NOTIFY_FUNCTION(
    DWORD fdwReason)
{
    if (fdwReason == DLL_PROCESS_ATTACH) {
        CSTRING_TRY
        {
            CString csFileName;
            csFileName.GetSystemDirectory();
            csFileName += L"\\mfcans32.dll";

            DWORD dwAttr = GetFileAttributesW(csFileName);

            // Remove the read-only 
            if (dwAttr != 0xffffffff) {
                SetFileAttributesW(csFileName, dwAttr & ~FILE_ATTRIBUTE_READONLY);
            }
        }
        CSTRING_CATCH 
        {
            // Don't care about exception
        }
    }
    return TRUE;
}

HOOK_BEGIN
    CALL_NOTIFY_FUNCTION
HOOK_END

IMPLEMENT_SHIM_END
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\appcompat\shims\specific\precomp.h ===
#ifndef _APPSPECIFIC_PRECOMP_H_
#define _APPSPECIFIC_PRECOMP_H_

#include "ShimHook.h"
#include "IllegalStr.h" // make strXXX routines illegal
#include "tcs.h"


using namespace ShimLib;

#endif // _APPSPECIFIC_PRECOMP_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\appcompat\shims\specific\proatlas2000.cpp ===
/*++

 Copyright (c) 2001 Microsoft Corporation

 Module Name:

   ProAtlas2000.cpp

 Abstract:

   This application has an uninstallation program, PAtls2kUninst.exe. The uninstallation
   program will generate a temp file DEL??.TMP in %temp% dircetory. It will call
   CreateProcessA to start the DEL??.TMP. The DEL??.TMP will wait for the end of
   PAtls2kUninst.exe. Due to the quick return of CreateProcessA call, the
   PAtls2kUninst.exe ends before DEL??.TMP starts to wait. The DEL??.TMP quits because
   it cannot find PAtls2kUninst.exe. The uninstallation cannot be completed. This fix is to
   hook CreateProcessA to delay the return of the function for 3 seconds.
   
 History:

    04/09/2001  zhongyl     Created

--*/

#include "precomp.h"

IMPLEMENT_SHIM_BEGIN(ProAtlas2000)
#include "ShimHookMacro.h"

//
// Add APIs that you wish to hook to this macro construction.
//
APIHOOK_ENUM_BEGIN
    APIHOOK_ENUM_ENTRY(CreateProcessA) 
APIHOOK_ENUM_END


BOOL
APIHOOK(CreateProcessA)(
    LPSTR lpszImageName, 
    LPSTR lpszCmdLine, 
    LPSECURITY_ATTRIBUTES lpsaProcess, 
    LPSECURITY_ATTRIBUTES lpsaThread, 
    BOOL fInheritHandles, 
    DWORD fdwCreate, 
    LPVOID lpvEnvironment, 
    LPSTR lpszCurDir, 
    LPSTARTUPINFOA lpsiStartInfo, 
    LPPROCESS_INFORMATION lppiProcInfo
    )
{
        BOOL bReturn=TRUE;
        bReturn = ORIGINAL_API(CreateProcessA)(lpszImageName, lpszCmdLine, lpsaProcess, lpsaThread, fInheritHandles, fdwCreate, lpvEnvironment, lpszCurDir, lpsiStartInfo, lppiProcInfo);
        Sleep(5000);
        return bReturn;
}


/*++

 Register hooked functions

--*/

HOOK_BEGIN

    //
    // Add APIs that you wish to hook here. All API prototypes
    // must be declared in Hooks\inc\ShimProto.h. Compiler errors
    // will result if you forget to add them.
    //
    APIHOOK_ENTRY(KERNEL32.DLL, CreateProcessA)

HOOK_END

IMPLEMENT_SHIM_END
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\appcompat\shims\specific\ppo3svrscr.cpp ===
/*++

 Copyright (c) 2000-2001 Microsoft Corporation

 Module Name:

   Ppo3svrScr.cpp

 Abstract:

   Power Plus screensaver bundled with Lotus Super Office 2000 Japanese could not launch
   Configure dialog on Whistler. But it works on Win 2000.
   The desk.cpl behavior of launching screensaver is changed a bit on Whistler.
   This screensaver's ScreenSaverConfigureDialog ID is not DLG_SCRNSAVECONFIGURE (2003=MSDN must) and unusual.
   Assuming unusual screensaver.
   This shim is applied to screensaver and hacks GetCommandLineW/A return text to change from
      "D:\WINDOWS\System32\ppo3svr.scr /c:1769646"
   to
      "D:\WINDOWS\System32\ppo3svr.scr"
   so that configure dialog appears.

   More Info:

      From desk.cpl (rundll32.exe), Screen Saver operation and CreateProcessW lpCommandLine argument:
      (1) Initial selection of screensaver
         "D:\WINDOWS\System32\ppo3svr.scr /p 721330" -> preview only
      (2) Preview button
         1st call "D:\WINDOWS\System32\ppo3svr.scr /s" -> screen saver
         2nd call "D:\WINDOWS\System32\ppo3svr.scr /p 721330" -> return to preview
      (3) Settings button
         1st call "D:\WINDOWS\System32\ppo3svr.scr /c:1769646" -> configure dialog (not working)
         2nd call "D:\WINDOWS\System32\ppo3svr.scr /p 721330" ->  return to preview

 History:

    06/11/2001  hioh        Created

--*/

#include "precomp.h"
// Using only strstr to find lower ascii text for GetCommandLineW/A. Operation is same between W & A.
#include "LegalStr.h"

IMPLEMENT_SHIM_BEGIN(Ppo3svrScr)
#include "ShimHookMacro.h"

//
// Add APIs that you wish to hook to this macro construction.
//
APIHOOK_ENUM_BEGIN
    APIHOOK_ENUM_ENTRY(GetCommandLineW) 
    APIHOOK_ENUM_ENTRY(GetCommandLineA) 
APIHOOK_ENUM_END

/*++

 Cut the /c:... string in CommandLine for ppo3svr.scr.
 
--*/

LPWSTR APIHOOK(GetCommandLineW)()
{
    WCHAR   szScreenSaverConfigure[] = L"ppo3svr.scr /c:";
    WCHAR   szConfigure[] = L" /c:";
    LPWSTR  lpCommandLine = ORIGINAL_API(GetCommandLineW)();
    LPWSTR  pw = wcsstr(lpCommandLine, szScreenSaverConfigure);

    if (pw != NULL)
    {
        if (pw = wcsstr(pw, szConfigure))
        {
            *pw = 0;    // cut from " /c:"
        }
    }

    return (lpCommandLine);
}

LPSTR APIHOOK(GetCommandLineA)()
{
    CHAR   szScreenSaverConfigure[] = "ppo3svr.scr /c:";
    CHAR   szConfigure[] = " /c:";
    LPSTR  lpCommandLine = ORIGINAL_API(GetCommandLineA)();
    LPSTR  pc = strstr(lpCommandLine, szScreenSaverConfigure);

    if (pc != NULL)
    {
        if (pc = strstr(pc, szConfigure))
        {
            *pc = 0;    // cut from " /c:"
        }
    }

    return (lpCommandLine);
}

/*++

 Register hooked functions

--*/

HOOK_BEGIN

    APIHOOK_ENTRY(KERNEL32.DLL, GetCommandLineW)
    APIHOOK_ENTRY(KERNEL32.DLL, GetCommandLineA)

HOOK_END

IMPLEMENT_SHIM_END
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\appcompat\shims\specific\quicken2001.cpp ===
/*++

 Copyright (c) 2000 Microsoft Corporation

 Module Name:

    Quicken2001.cpp

 Abstract:
    The app was passing bad string pointers to the
    lstrcmpiA() function which was causing it to crash
    during the app update.

 Notes:

    This is an app specific shim.

 History:

    05/09/2001 prashkud Created

--*/

#include "precomp.h"

IMPLEMENT_SHIM_BEGIN(Quicken2001)
#include "ShimHookMacro.h"

APIHOOK_ENUM_BEGIN
    APIHOOK_ENUM_ENTRY(lstrcmpiA) 
APIHOOK_ENUM_END

/*++

    Checks the parameters for invalid string pointers.

--*/

LONG
APIHOOK(lstrcmpiA)(
    LPCSTR lpString1,
    LPCSTR lpString2
    )
{

    if (IsBadStringPtrA(lpString1, MAX_PATH))
    {
        lpString1 = 0;
    }

    if (IsBadStringPtrA(lpString2, MAX_PATH))
    {
        lpString2 = 0;
    }

    /*
     * Call the original API
     */   
    return ORIGINAL_API(lstrcmpiA)(lpString1, lpString2);
}


/*++

 Register hooked functions

--*/

HOOK_BEGIN

    APIHOOK_ENTRY(KERNEL32.DLL, lstrcmpiA)

HOOK_END

IMPLEMENT_SHIM_END
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\appcompat\shims\specific\quicken2000.cpp ===
/*++

 Copyright (c) 2000 Microsoft Corporation

 Module Name:

    Quicken2000.cpp

 Abstract:

    Change the value of a registry key for Quicken 2000 setup.
    This is needed to disable a kernel mode driver that
    blue-screens in Win2k.

 Notes:

    This is an app specific shim.

 History:

    02/16/2000 clupu Created

--*/

#include "precomp.h"

IMPLEMENT_SHIM_BEGIN(Quicken2000)
#include "ShimHookMacro.h"

APIHOOK_ENUM_BEGIN
    APIHOOK_ENUM_ENTRY(RegSetValueExA) 
APIHOOK_ENUM_END

/*++

 Change the value passed for "Start" from 0 to 4 to prevent a kernel mode 
 driver from blue-screening Win2k.

--*/

LONG
APIHOOK(RegSetValueExA)(
    HKEY   hKey,
    LPCSTR lpValueName,
    DWORD  Reserved,
    DWORD  dwType,
    CONST BYTE * lpData,
    DWORD  cbData
    )
{
    if (lstrcmpA(lpValueName, "Start") == 0 &&
        dwType == REG_DWORD &&
        cbData == 4) {

        DPFN( eDbgLevelInfo, "[Quicken2000] RegSetValueExA changed to 4");
        
        *(DWORD*)lpData = 4;
    }

    /*
     * Call the original API
     */
    
    return ORIGINAL_API(RegSetValueExA)(
        hKey,
        lpValueName,
        Reserved,
        dwType,
        lpData,
        cbData);
}


/*++

 Register hooked functions

--*/

HOOK_BEGIN

    APIHOOK_ENTRY(ADVAPI32.DLL, RegSetValueExA)

HOOK_END

IMPLEMENT_SHIM_END
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\appcompat\shims\specific\rcenter.cpp ===
/*++

 Copyright (c) 2001 Microsoft Corporation

 Module Name:

    RCenter.cpp

 Abstract:

    RCenter attempts to compare file extensions from a CD's root against known media
	types.  When they get the file's extension, they get ".txt" and then add one to the
	pointer to leave "txt".  

	The trouble is that if a file has no extension they end up with a null pointer for
	the extension string, add one to it, and then pass it into lstrcmpiA.  lstrcmpiA
	can handle null pointers, but not "1" pointers.

	This shim treats bad pointers as the shortest possible string:
		lstrcmpi(BAD_PTR, "Hello World") == LESS_THAN
		lstrcmpi("Hello World", BAD_PTR) == GREATER_THAN
		lstrcmpi(BAD_PTR, BAD_PTR) == EQUAL
    
 Notes:

    This is an app specific shim.

 History:

    11/13/2001  astritz     Created

--*/
 
#include "precomp.h"

IMPLEMENT_SHIM_BEGIN(RCenter)
#include "ShimHookMacro.h"

APIHOOK_ENUM_BEGIN
    APIHOOK_ENUM_ENTRY(lstrcmpiA)
APIHOOK_ENUM_END

/*++

 Hook lstrcmpiA to handle NULL pointers as above.

--*/

BOOL 
APIHOOK(lstrcmpiA)(
	LPCSTR lpString1,
	LPCSTR lpString2
	)
{
	if (IsBadReadPtr(lpString1, 1)) {
		if (IsBadReadPtr(lpString2, 1)) {
			return 0;
        } else {
		    return -1;
        }
	} else if (IsBadReadPtr(lpString2, 1)) {
		return 1;
	}

	return ORIGINAL_API(lstrcmpiA)(lpString1, lpString2);
}

/*++

 Register hooked functions

--*/

HOOK_BEGIN
    APIHOOK_ENTRY(KERNEL32.DLL, lstrcmpiA)
HOOK_END

IMPLEMENT_SHIM_END
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\appcompat\shims\specific\quicktime5.cpp ===
/*++

 Copyright (c) 2001 Microsoft Corporation

 Module Name:

    QuickTime5.cpp

 Abstract:

    QuickTime 5 is calling Get/SetWindowLong(GWL_WNDPROC/DWL_DLGPROC) on hwnds outside its process
    and it is passing hardcoded strings within its address space (these calls will always fail on
    win9x). On 32-bit platforms this is pretty much benign, but on ia64 the call to SetWindowLong(hwnd, DWL_DLGPROC, crap)
    succeeds in trashing private window bits in explorer windows (since the window is not a dialog hwnd).

 Notes:

    This is an app specific shim.

 History:

    7/31/2001   reinerf     Created

--*/

#include "precomp.h"

IMPLEMENT_SHIM_BEGIN(QuickTime5)
#include "ShimHookMacro.h"

APIHOOK_ENUM_BEGIN
    APIHOOK_ENUM_ENTRY(GetWindowLongA) 
    APIHOOK_ENUM_ENTRY(SetWindowLongA) 
APIHOOK_ENUM_END


LONG
APIHOOK(GetWindowLongA)(HWND hwnd, int iIndex)
{
    if (hwnd)
    {
        if ((iIndex == GWL_WNDPROC) ||
            (iIndex == DWL_DLGPROC))
        {
            DWORD dwPID = 0;

            GetWindowThreadProcessId(hwnd, &dwPID);

            if (GetCurrentProcessId() != dwPID)
            {
                // we are querying an hwnd that is not in our 
                // process-- just fail the call
                return 0;
            }
        }
    }
    
    return ORIGINAL_API(GetWindowLongA)(hwnd, iIndex);
}


LONG
APIHOOK(SetWindowLongA)(HWND hwnd, int iIndex, LONG lNew)
{
    if (hwnd)
    {
        if ((iIndex == GWL_WNDPROC) ||
            (iIndex == DWL_DLGPROC))
        {

            DWORD dwPID = 0;

            GetWindowThreadProcessId(hwnd, &dwPID);

            if (GetCurrentProcessId() != dwPID)
            {
                // we are trying modify an hwnd that is not in our 
                // process-- just fail the call
                return 0;
            }
        }
    }
    
    return ORIGINAL_API(SetWindowLongA)(hwnd, iIndex, lNew);
}


/*++

 Register hooked functions

--*/

HOOK_BEGIN
    APIHOOK_ENTRY(USER32.DLL, GetWindowLongA)
    APIHOOK_ENTRY(USER32.DLL, SetWindowLongA)
HOOK_END

IMPLEMENT_SHIM_END
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\appcompat\shims\specific\returntokrondor.cpp ===
/*++

 Copyright (c) 2000 Microsoft Corporation

 Module Name:

   ReturnToKrondor.cpp

 Abstract:

   This APIHooks GetDIBits to hack around a performance problem with the 
   DIB_PAL_COLORS usage.

 Notes:

   This APIHook emulates Windows 9x.

 History:

   09/07/2000 robkenny  Created

--*/


#include "precomp.h"

IMPLEMENT_SHIM_BEGIN(ReturnToKrondor)
#include "ShimHookMacro.h"

APIHOOK_ENUM_BEGIN
    APIHOOK_ENUM_ENTRY(GetDIBits) 
APIHOOK_ENUM_END

int
APIHOOK(GetDIBits)(
    HDC hdc,           // handle to DC
    HBITMAP hbmp,      // handle to bitmap
    UINT uStartScan,   // first scan line to set
    UINT cScanLines,   // number of scan lines to copy
    LPVOID lpvBits,    // array for bitmap bits
    LPBITMAPINFO lpbi, // bitmap data buffer
    UINT uUsage        // RGB or palette index
    )
{
    return ORIGINAL_API(GetDIBits)(
                hdc,
                hbmp,
                uStartScan,
                cScanLines,
                lpvBits,
                lpbi,
                DIB_RGB_COLORS      // Force RGB_COLORS
                );
}

HOOK_BEGIN

    APIHOOK_ENTRY(GDI32.DLL, GetDIBits)

HOOK_END

IMPLEMENT_SHIM_END
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\appcompat\shims\specific\riskii.cpp ===
/*++

 Copyright (c) 2000 Microsoft Corporation

 Module Name:

    RiskII.cpp

 Abstract:

    This shim hooks LoadImageA to intercept the loading of two
    cursors and returns copies of the system cursors instead of
    the ones RiskII was trying to get.  RiskII's cursors were
    being rendered by software and it caused them to flicker since
    RiskII locks the primary surface.  The system cursors are 
    hardware cursors and don't flicker.

 History:

 08/03/2000 t-adams    Created

--*/

#include "precomp.h"
#include <mmsystem.h>

IMPLEMENT_SHIM_BEGIN(RiskII)
#include "ShimHookMacro.h"

APIHOOK_ENUM_BEGIN
    APIHOOK_ENUM_ENTRY(LoadImageA) 
APIHOOK_ENUM_END

/*++

  Abstract:

    Intercept the load of two cursors, and replace with the appropriate
    similar-looking system cursors.

  History:

    08/03/2000    t-adams     Created

--*/

HANDLE 
APIHOOK(LoadImageA)(
    HINSTANCE hinst,
    LPCSTR lpszName,
    UINT uType,
    int cxDesired,
    int cyDesired,
    UINT fuLoad) 
{

    HANDLE hRet = INVALID_HANDLE_VALUE;
                                
    CSTRING_TRY
    {
        CString csName(lpszName);

        if (csName.CompareNoCase(L"Gfx\\Arrow_m.cur") == 0 )
        {
            HCURSOR hCur = LoadCursor(NULL, IDC_ARROW);
            if (hCur)
            {
                hRet = CopyCursor(hCur);
            }
        }
        else if (csName.CompareNoCase(L"Gfx\\Busy_m.cur") == 0 )
        {
            HCURSOR hCur = LoadCursor(NULL, IDC_WAIT);
            if (hCur)
            {
                hRet = CopyCursor(hCur);
            }
        }
    }
    CSTRING_CATCH
    {
        // Do Nothing
    }

    if (hRet == INVALID_HANDLE_VALUE)
    {
        hRet = ORIGINAL_API(LoadImageA)(hinst, lpszName, uType, cxDesired, cyDesired, fuLoad);
    }
    return hRet;        
}

/*++

 Register hooked functions

--*/

HOOK_BEGIN

    APIHOOK_ENTRY(USER32.DLL, LoadImageA)

HOOK_END

IMPLEMENT_SHIM_END
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\appcompat\shims\specific\riven.cpp ===
/*++

 Copyright (c) 1999 Microsoft Corporation

 Module Name:

   Riven.cpp

 Abstract:

   A hack for Riven. The game gets confused about what windows version it's
   running under and tries to handle it's own messages. A simple ver lie 
   fixes this issue, but causes the game to use a win9x only method to 
   eject the CD.

 Fix:
   
   We can get ddraw to correctly handle alt+tabbing by turning off the 
   DDSCL_NOWINDOWCHANGES flag on IDirectDraw->SetCooperativeLevel

 Notes:

   This is an app specific hack, but could fix other similar issues.

 Created:

   11/23/1999 linstev

--*/

#include "precomp.h"

IMPLEMENT_SHIM_BEGIN(Riven)
#include "ShimHookMacro.h"

APIHOOK_ENUM_BEGIN
    APIHOOK_ENUM_ENTRY_DIRECTX_COMSERVER()
APIHOOK_ENUM_END

IMPLEMENT_DIRECTX_COMSERVER_HOOKS()

/*++

 IDirectDraw::SetCooperativeLevel hook

--*/

HRESULT
COMHOOK(IDirectDraw, SetCooperativeLevel)( 
    PVOID pThis, 
    HWND hWnd, 
    DWORD dwFlags
    )
{
    if (dwFlags & DDSCL_NOWINDOWCHANGES) 
    {
        dwFlags &= ~DDSCL_NOWINDOWCHANGES;
        LOGN(eDbgLevelError, "Removed NOWINDOWCHANGES flag");
    }

    return ORIGINAL_COM(IDirectDraw, SetCooperativeLevel, pThis)(
                pThis,
                hWnd,
                dwFlags);
}

HRESULT
COMHOOK(IDirectDraw2, SetCooperativeLevel)( 
    PVOID pThis, 
    HWND hWnd, 
    DWORD dwFlags
    )
{
    if (dwFlags & DDSCL_NOWINDOWCHANGES) 
    {
        dwFlags &= ~DDSCL_NOWINDOWCHANGES;
        LOGN(eDbgLevelError, "Removed NOWINDOWCHANGES flag");
    }

    return ORIGINAL_COM(IDirectDraw2, SetCooperativeLevel, pThis)(
                pThis,
                hWnd,
                dwFlags);
}

HRESULT
COMHOOK(IDirectDraw4, SetCooperativeLevel)( 
    PVOID pThis, 
    HWND hWnd, 
    DWORD dwFlags
    )
{
    if (dwFlags & DDSCL_NOWINDOWCHANGES) 
    {
        dwFlags &= ~DDSCL_NOWINDOWCHANGES;
        LOGN(eDbgLevelError, "Removed NOWINDOWCHANGES flag");
    }

    return ORIGINAL_COM(IDirectDraw4, SetCooperativeLevel, pThis)(
                pThis,
                hWnd,
                dwFlags);
}
HRESULT
COMHOOK(IDirectDraw7, SetCooperativeLevel)( 
    PVOID pThis, 
    HWND hWnd, 
    DWORD dwFlags
    )
{
    if (dwFlags & DDSCL_NOWINDOWCHANGES) 
    {
        dwFlags &= ~DDSCL_NOWINDOWCHANGES;
        LOGN(eDbgLevelError, "Removed NOWINDOWCHANGES flag");
    }

    return ORIGINAL_COM(IDirectDraw7, SetCooperativeLevel, pThis)(
                pThis,
                hWnd,
                dwFlags);
}

/*++

 Register hooked functions

--*/

HOOK_BEGIN

    APIHOOK_ENTRY_DIRECTX_COMSERVER()

    COMHOOK_ENTRY(DirectDraw, IDirectDraw, SetCooperativeLevel, 20)
    COMHOOK_ENTRY(DirectDraw, IDirectDraw2, SetCooperativeLevel, 20)
    COMHOOK_ENTRY(DirectDraw, IDirectDraw4, SetCooperativeLevel, 20)
    COMHOOK_ENTRY(DirectDraw, IDirectDraw7, SetCooperativeLevel, 20)

HOOK_END

IMPLEMENT_SHIM_END
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\appcompat\shims\specific\resumewriter3.cpp ===
/*++

 Copyright (c) 2001 Microsoft Corporation

 Module Name:

    ResumeWriter3.cpp

 Abstract:

    The setup of this app fails to register the OCX'es as it 
    tries loading the DLL's with a hardcoded 'system' path.
    Corrected the path to the 'system32' path.
   
 Notes:

    This is specific to this app.

 History:

    05/22/2001 prashkud Created

--*/

#include "precomp.h"

IMPLEMENT_SHIM_BEGIN(ResumeWriter3)
#include "ShimHookMacro.h"

APIHOOK_ENUM_BEGIN
    APIHOOK_ENUM_ENTRY(LoadLibraryA) 
APIHOOK_ENUM_END


WCHAR g_wszSystemDir[MAX_PATH];

/*++

    Hooks LoadLibraryA and changes the path that contains 'system' in it
    to the  'system32.

--*/

HMODULE
APIHOOK(LoadLibraryA)(
    LPCSTR lpFileName
    )
{
    CSTRING_TRY
    {
        // Bad string pointers can cause failures in CString.
        if (!IsBadStringPtrA(lpFileName, MAX_PATH))
        {
            CString csFileName(lpFileName);
            if (csFileName.Find(L"system") != -1)
            {
                // We have found 'system' in the path
                // Replace it with 'system32'.
                CString csName;
                csFileName.GetLastPathComponent(csName);              
                CString csNewFileName(g_wszSystemDir);
                csNewFileName.AppendPath(csName);

                DPFN(eDbgLevelInfo, "[ResumeWriter3] changed %s to (%s)\n", lpFileName, csNewFileName.GetAnsi());
                return ORIGINAL_API(LoadLibraryA)(csNewFileName.GetAnsi());                
            }
        }
    }
    CSTRING_CATCH
    {
    }

    return ORIGINAL_API(LoadLibraryA)(lpFileName);
}

/*++

    Cache the system directory when we get called in 
    the beginning.

--*/

BOOL
NOTIFY_FUNCTION(
    DWORD fdwReason
    )
{
    if (fdwReason == DLL_PROCESS_ATTACH)
    {
        GetSystemDirectory(g_wszSystemDir, MAX_PATH);
    }
    return TRUE;
}

/*++

 Register hooked functions

--*/

HOOK_BEGIN

    CALL_NOTIFY_FUNCTION
    APIHOOK_ENTRY(KERNEL32.DLL, LoadLibraryA)

HOOK_END

IMPLEMENT_SHIM_END
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\appcompat\shims\specific\rumbaoffice.cpp ===
/*++

 Copyright (c) 2000 Microsoft Corporation

 Module Name:

    RumbaOffice.cpp

 Abstract:

    Ingnore the first call to NdrProxySendReceive if the ProcNum is 0x8013. 
    This prevents the RPC call from raising an exception because it's being 
    called from an ASYNC callback. The error it would normally return would be 
    RPC_E_CANTCALLOUT_INASYNCCALL. If it raises an exception, the app dies.
        
    No idea why this works on 9X.

 Notes:

    This is an app specific shim.

 History:

    01/08/2001 linstev Created

--*/

#include "precomp.h"

IMPLEMENT_SHIM_BEGIN(RumbaOffice)
#include "ShimHookMacro.h"

APIHOOK_ENUM_BEGIN
    APIHOOK_ENUM_ENTRY(NdrProxySendReceive)
APIHOOK_ENUM_END

BOOL g_bFirst = TRUE;

typedef HRESULT (WINAPI *_pfn_NdrProxySendReceive)(void *pThis, MIDL_STUB_MESSAGE * pStubMsg);

/*++

 Ignore the first call to NdrProxySendReceive.

--*/

HRESULT
APIHOOK(NdrProxySendReceive)(
    void *pThis, 
    MIDL_STUB_MESSAGE * pStubMsg
    )
{
    HRESULT hr;

    if (g_bFirst && (pStubMsg->RpcMsg->ProcNum == 0x8013))
    {
        g_bFirst = FALSE;

        DPFN( eDbgLevelError, "Ignoring call to NdrProxySendReceive");

        hr = 0;
    }
    else
    {
        hr = ORIGINAL_API(NdrProxySendReceive)(pThis, pStubMsg);
    }

    return hr;
}

/*++

 Register hooked functions

--*/

HOOK_BEGIN
    APIHOOK_ENTRY(RPCRT4.DLL, NdrProxySendReceive)
HOOK_END


IMPLEMENT_SHIM_END
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\appcompat\shims\specific\safedisc.cpp ===
/*++

 Copyright (c) 2001 Microsoft Corporation

 Module Name:

    SafeDisc.cpp

 Abstract:

    Some versions of SafeDisc try to validate kernel32 by checking if certain 
    APIs fall within a particular area in the PE image. Our BBT process moves
    everything around and therefore breaks their checks.

    This shim can be used to fix this problems by effectively moving the entry 
    point of the APIs they test to a jump table located in a 'valid' location.

    The valid location itself is an API that isn't used, but does happen to lie
    before the export directory.

 Notes:

    This is an app specific shim.

 History:

    06/15/2001 linstev   Created

--*/

#include "precomp.h"

IMPLEMENT_SHIM_BEGIN(SafeDisc)

#include "ShimHookMacro.h"

APIHOOK_ENUM_BEGIN
APIHOOK_ENUM_END

#pragma pack(1)

//
// Random API used as a placeholder for a jump table. It's offset must be less 
// than the export directory. Also, since it's overwritten with a jump table, 
// it should not be an API that is used.
//
CHAR *g_szRandomAPI = "CreateMailslotA";

struct HOOK {
    CHAR *szName;
    FARPROC lpAddress;
};
HOOK g_aHooks[] = {
    { "ReadProcessMemory"       , 0 },
    { "WriteProcessMemory"      , 0 },
    { "VirtualProtect"          , 0 },
    { "CreateProcessA"          , 0 },
    { "CreateProcessW"          , 0 },
    { "GetStartupInfoA"         , 0 },
    { "GetStartupInfoW"         , 0 },
    { "GetSystemTime"           , 0 },
    { "GetSystemTimeAsFileTime" , 0 },
    { "TerminateProcess"        , 0 },
    { "Sleep"                   , 0 }
};
DWORD g_dwHookCount = sizeof(g_aHooks) / sizeof(HOOK);

BOOL Patch()
{
    //
    // Get the kernel32 image base 
    //
    HMODULE hKernel = GetModuleHandleW(L"kernel32");
    if (!hKernel) {
        goto Fail;
    }

    //
    // Get the address of the semi-random API where we'll put our jump table
    //
    FARPROC lpRandomAPI = GetProcAddress(hKernel, g_szRandomAPI);

    //
    // Get the export directory
    //
    PIMAGE_DOS_HEADER pIDH = (PIMAGE_DOS_HEADER) hKernel;
    PIMAGE_NT_HEADERS pINTH = (PIMAGE_NT_HEADERS)((LPBYTE) hKernel + pIDH->e_lfanew);
    DWORD dwExportOffset = pINTH->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT].VirtualAddress;
    PIMAGE_EXPORT_DIRECTORY lpExportDirectory = (PIMAGE_EXPORT_DIRECTORY)((DWORD_PTR)hKernel + dwExportOffset);

    //
    // Write out the jump table 
    //
    LPBYTE lpCurrAPI = (LPBYTE) lpRandomAPI;
    for (UINT i=0; i<g_dwHookCount; i++) {
        //
        // Loop through each API and create a jump table entry for it 
        //
        DWORD dwAPIOffset;

        g_aHooks[i].lpAddress = GetProcAddress(hKernel, g_aHooks[i].szName);
        dwAPIOffset = (DWORD)((DWORD_PTR) g_aHooks[i].lpAddress - (DWORD_PTR) hKernel);

        //
        // This API will cause problems for SafeDisc if it's after the export directory
        //
        if (dwAPIOffset > dwExportOffset) {
            //
            // Each jump table entry has the form: jmp dword ptr [address]
            //
            struct PATCH {
                WORD  wJump;
                DWORD dwAddress;
            };
            PATCH patch = { 0x25FF, (DWORD_PTR)&g_aHooks[i].lpAddress };
            DWORD dwOldProtect;

            DPF("SafeDisc", eDbgLevelWarning, "API %s is being redirected", g_aHooks[i].szName);
            
            //
            // Write the jump table entry
            //
            if (!VirtualProtect(lpCurrAPI, sizeof(PATCH), PAGE_READWRITE, &dwOldProtect)) {
                goto Fail;
            }

            MoveMemory(lpCurrAPI, &patch, sizeof(PATCH));

            if (!VirtualProtect(lpCurrAPI, sizeof(PATCH), dwOldProtect, &dwOldProtect)) { 
                goto Fail;
            }

            //
            // Now patch the export directory
            //
            LPDWORD lpExportList = (LPDWORD)((DWORD_PTR) hKernel + lpExportDirectory->AddressOfFunctions);
            for (UINT j=0; j<lpExportDirectory->NumberOfFunctions; j++) {
                if (*lpExportList == dwAPIOffset) {
                    //
                    // We've found the offset in the export directory, so patch it with the 
                    // new address
                    //
                    DWORD dwNewAPIOffset = (DWORD)((DWORD_PTR) lpCurrAPI - (DWORD_PTR) hKernel);

                    if (!VirtualProtect(lpExportList, sizeof(DWORD), PAGE_READWRITE, &dwOldProtect)) {
                        goto Fail;
                    }

                    MoveMemory(lpExportList, &dwNewAPIOffset, sizeof(DWORD));

                    if (!VirtualProtect(lpExportList, sizeof(DWORD), dwOldProtect, &dwOldProtect)) { 
                        goto Fail;
                    }
                    break;
                }
                lpExportList++;
            }

            lpCurrAPI += sizeof(PATCH);
        }
    }

    
    return TRUE;

Fail:

    return FALSE;
}

/*++

 Register hooked functions

--*/

BOOL
NOTIFY_FUNCTION(
    DWORD fdwReason)
{
    if (fdwReason == DLL_PROCESS_ATTACH) {
        CHAR *lpCommandLine = COMMAND_LINE;

        if (lpCommandLine && (*lpCommandLine != '\0')) {
            g_szRandomAPI = lpCommandLine;
        }

        Patch();
    }

    return TRUE;
}

HOOK_BEGIN
    CALL_NOTIFY_FUNCTION
HOOK_END

IMPLEMENT_SHIM_END
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\appcompat\shims\specific\schoolhouserockmath.cpp ===
/*++

 Copyright (c) 2000 Microsoft Corporation

 Module Name:

    SchoolHouseRockMath.cpp

 Abstract:

    This shim directs the install to look in the _InstallTo16 and 
    _InstallFrom16 sections of setup.inf instead of _InstallFrom32 and 
    _InstallTo32. This is needed because the application tries to use a 16-bit 
    DLL during gameplay which is allowed in Win9x but produces errors under 
    Whistler.

 History:

    10/18/2000 jdoherty  Created

--*/

#include "precomp.h"

// This module has been given an official blessing to use the str routines.
#include "LegalStr.h"

IMPLEMENT_SHIM_BEGIN(SchoolHouseRockMath)
#include "ShimHookMacro.h"

APIHOOK_ENUM_BEGIN
    APIHOOK_ENUM_ENTRY(GetPrivateProfileStringA) 
    APIHOOK_ENUM_ENTRY(GetPrivateProfileStringW) 
    APIHOOK_ENUM_ENTRY(GetProfileStringA) 
    APIHOOK_ENUM_ENTRY(GetProfileStringW) 
APIHOOK_ENUM_END

/*++

 This stub function breaks into GetPrivateProfileString and checks to see the section lpAppName
 being referred to is one of the sections in question.

--*/

DWORD 
APIHOOK(GetPrivateProfileStringA)(
    LPCSTR lpAppName,
    LPCSTR lpKeyName,
    LPCSTR lpDefault,
    LPSTR lpReturnedString,
    DWORD nSize,
    LPCSTR lpFileName
    )
{
    DWORD dRet;
    int iArraySize = 2;
    // The following array specifies what sections to look for and what to 
    // replace them with when calling GetPrivateProfileString
    CHAR *szAppNames[] = {"_INSTALLTO32", "_INSTALLFROM32"};
    CHAR *szNewAppNames[] = {"_INSTALLTO16", "_INSTALLFROM16"};
     
    for (int i = 0; i < iArraySize; i++)
    {
        // Find out if one of the known section names is lpAppName
        // if so change lpAppName parameter to new parameter and call API
        if ((stristr (szAppNames[i], lpAppName) !=NULL ))
        {
            return ORIGINAL_API(GetPrivateProfileStringA)(
                        szNewAppNames[i],
                        lpKeyName,
                        lpDefault,
                        lpReturnedString,
                        nSize,
                        lpFileName
                        );
        }
    }
    
    return ORIGINAL_API(GetPrivateProfileStringA)(
                lpAppName,
                lpKeyName,
                lpDefault,
                lpReturnedString,
                nSize,
                lpFileName
                );
}

/*++

 This stub function breaks into GetPrivateProfileString and checks to see the section lpAppName
 being referred to is one of the sections in question.

--*/

DWORD
WINAPI
APIHOOK(GetPrivateProfileStringW)(
    LPCWSTR lpAppName,
    LPCWSTR lpKeyName,
    LPCWSTR lpDefault,
    LPWSTR lpReturnedString,
    DWORD nSize,
    LPCWSTR lpFileName
    )
{
    DWORD dRet;
    int iArraySize = 2;
    // The following array specifies what sections to look for and what to 
    // replace them with when calling GetPrivateProfileString
    WCHAR *wszAppNames[] = {L"_INSTALLTO32", L"_INSTALLFROM32"};
    WCHAR *wszNewAppNames[] = {L"_INSTALLTO16", L"_INSTALLFROM16"};
            
    for (int i = 0; i < iArraySize; i++)
    {
        // Find out if one of the known section names is lpAppName
        // if so change lpAppName parameter to new parameter and call API
        if (wcsistr (lpAppName, wszAppNames[i]) != NULL)
        {
            return ORIGINAL_API(GetPrivateProfileStringW)(
                    wszNewAppNames[i],
                    lpKeyName,
                    lpDefault,
                    lpReturnedString,
                    nSize,
                    lpFileName
                    );
        }
    }
    
    return ORIGINAL_API(GetPrivateProfileStringW)(
            lpAppName,
            lpKeyName,
            lpDefault,
            lpReturnedString,
            nSize,
            lpFileName
            );
}

/*++

 This stub function breaks into GetProfileString and checks to see the section 
 lpAppName being referred to is one of the sections in question.

--*/

DWORD
APIHOOK(GetProfileStringA)(
    LPCSTR lpAppName,
    LPCSTR lpKeyName,
    LPCSTR lpDefault,
    LPSTR lpReturnedString,
    DWORD nSize
    )
{
    DWORD dRet;
    int iArraySize = 2;
    // The following array specifies what sections to look for and what to 
    // replace them with when calling GetPrivateProfileString
    CHAR *szAppNames[] = {"_INSTALLTO32", "_INSTALLFROM32"};
    CHAR *szNewAppNames[] = {"_INSTALLTO16", "_INSTALLFROM16"};
           
    for (int i = 0; i < iArraySize; i++)
    {
        // Find out if one of the known section names is lpAppName
        // if so change lpAppName parameter to new parameter and call API
        if (stristr (szAppNames[i], lpAppName) !=NULL )
        {
            return ORIGINAL_API(GetProfileStringA)(
                        szNewAppNames[i],
                        lpKeyName,
                        lpDefault,
                        lpReturnedString,
                        nSize
                        );
        }
    }
    
    return ORIGINAL_API(GetProfileStringA)(
                lpAppName,
                lpKeyName,
                lpDefault,
                lpReturnedString,
                nSize
                );
}

/*++

 This stub function breaks into GetProfileString and checks to see the section 
 lpAppName being referred to is one of the sections in question.

--*/

DWORD
APIHOOK(GetProfileStringW)(
    LPCWSTR lpAppName,
    LPCWSTR lpKeyName,
    LPCWSTR lpDefault,
    LPWSTR lpReturnedString,
    DWORD nSize
    )
{
    DWORD dRet;
    int iArraySize = 2;
    // The following array specifies what sections to look for and what to 
    // replace them with when calling GetPrivateProfileString
    WCHAR *wszAppNames[] = {L"_INSTALLTO32", L"_INSTALLFROM32"};
    WCHAR *wszNewAppNames[] = {L"_INSTALLTO16", L"_INSTALLFROM16"};
    
    for (int i = 0; i < iArraySize; i++)
    {
        // Find out if one of the known section names is lpAppName
        // if so change lpAppName parameter to new parameter and call API
        if (wcsistr (lpAppName, wszAppNames[i]) != NULL)
        {
            return ORIGINAL_API(GetProfileStringW)(
                        wszNewAppNames[i],
                        lpKeyName,
                        lpDefault,
                        lpReturnedString,
                        nSize
                        );
        }
    }
    
    return ORIGINAL_API(GetProfileStringW)(
                lpAppName,
                lpKeyName,
                lpDefault,
                lpReturnedString,
                nSize
                );
}


/*++

 Register hooked functions

--*/

HOOK_BEGIN

    APIHOOK_ENTRY(KERNEL32.DLL, GetPrivateProfileStringA)
    APIHOOK_ENTRY(KERNEL32.DLL, GetPrivateProfileStringW)
    APIHOOK_ENTRY(KERNEL32.DLL, GetProfileStringA)
    APIHOOK_ENTRY(KERNEL32.DLL, GetProfileStringW)

HOOK_END


IMPLEMENT_SHIM_END
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\appcompat\shims\specific\sierracartracing.cpp ===
/*++

 Copyright (c) 2000 Microsoft Corporation

 Module Name:

   SierraCartRacing.cpp

 Abstract:

    A hack for Cart Racing (Sierra). They call InitializeSecurityDescriptor 
    which trashes an old stack pointer which is later needed. They call 
    CreateSemaphore with an invalid security descriptor: 

        lpSemaphoreAttributes->lpSecurityDescriptor == 1

    This looks like a semaphore they use to prevent getting executed twice,
    Note, although it doesn't matter if the Semaphore doesn't get created,
    I thought it better if this worked.

    Fix:
   
    CreateSemaphore: set the security attributes to NULL (default)
    InitializeSecurityDescriptor: do nothing, since it's not needed anymore

 Notes:

    This is an app specific shim.

 History:

    11/03/1999 linstev  Created

--*/

#include "precomp.h"

IMPLEMENT_SHIM_BEGIN(SierraCartRacing)
#include "ShimHookMacro.h"

APIHOOK_ENUM_BEGIN
    APIHOOK_ENUM_ENTRY(CreateSemaphoreA) 
    APIHOOK_ENUM_ENTRY(InitializeSecurityDescriptor) 
APIHOOK_ENUM_END

/*++

 Use the default security descriptor.

--*/

HANDLE 
APIHOOK(CreateSemaphoreA)(
    LPSECURITY_ATTRIBUTES lpSemaphoreAttributes,
    LONG lInitialCount,  
    LONG lMaximumCount,  
    LPCSTR lpName
    )
{
    // Use default security descriptor

    return ORIGINAL_API(CreateSemaphoreA)(
        NULL, 
        lInitialCount, 
        lMaximumCount, 
        lpName);
}

/*++

 Returns false for InitializeSecurityDescriptor. i.e. do nothing so we don't 
 touch the stack.

--*/

BOOL 
APIHOOK(InitializeSecurityDescriptor)(
    PSECURITY_DESCRIPTOR pSecurityDescriptor,
    DWORD dwRevision
    )
{
    return FALSE;
}

/*++

 Register hooked functions

--*/

HOOK_BEGIN

    APIHOOK_ENTRY(KERNEL32.DLL, CreateSemaphoreA)
    APIHOOK_ENTRY(ADVAPI32.DLL, InitializeSecurityDescriptor)

HOOK_END

IMPLEMENT_SHIM_END
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\appcompat\shims\specific\simply3d.cpp ===
/*++

 Copyright (c) 2000 Microsoft Corporation

 Module Name:

    Simply3D.cpp

 Abstract:

    From Tomislav Markoc:

        MSPaint calls OleGetClipboard to get IDataObject interface and then 
        calls IDataObject::GetData. This call gets marshaled to Simply 3D 
        GetData.

        FORMATETC looks like:
            cfFormat=8(CF_DIB) or 2(CF_BITMAP)
            ptd=0
            dwAspect=1
            lindex= -1
            tymed=1(TYMED_HGLOBAL) or 16(TYMED_GDI)

        Simply 3D returns STGMEDIUM:
            tymed=0 //WRONG
            hBitmap=hGlobal=some handle !=0
            pUnkForRelease=0

        STGMEDIUM::tymed should be changed with something like this:

        if (STGMEDIUM::tymed==0 && STGMEDIUM::hBitmap && 
           (FORMATETC::tymed==TYMED_HGLOBAL || FORMATETC::tymed==TYMED_GDI))
            STGMEDIUM::tymed=FORMATETC::tymed;


 Notes:

    This is an app specific shim.

 History:

    02/22/2000 linstev Created

--*/

#include "precomp.h"

IMPLEMENT_SHIM_BEGIN(Simply3D)
#include "ShimHookMacro.h"

APIHOOK_ENUM_BEGIN
    APIHOOK_ENUM_ENTRY(OleSetClipboard) 
    APIHOOK_ENUM_ENTRY_COMSERVER(OLE32)
APIHOOK_ENUM_END

IMPLEMENT_COMSERVER_HOOK(OLE32)

#define CLSID_DataObject IID_IDataObject

typedef HRESULT   (*_pfn_IDataObject_GetData)(PVOID pThis, FORMATETC *pFormatetc, STGMEDIUM *pmedium);
typedef HRESULT   (*_pfn_OleSetClipboard)(IDataObject * pDataObj);

/*++

 Hook OleSetClipboard to hook the object.

--*/

HRESULT
APIHOOK(OleSetClipboard)(
    IDataObject *pDataObj
    )
{
    HRESULT hReturn = ORIGINAL_API(OleSetClipboard)(pDataObj);

    if (hReturn == NOERROR) {
        HookObject(
            NULL, 
            IID_IDataObject, 
            (PVOID *) &pDataObj, 
            NULL, 
            FALSE);
    }

    return hReturn;
}

/*++

 Hook GetData and correct the return values as 

--*/

HRESULT
COMHOOK(IDataObject, GetData)(
    PVOID pThis,
    FORMATETC *pFormatetc,  
    STGMEDIUM *pmedium
    )
{
    HRESULT hrReturn = E_FAIL;

    _pfn_IDataObject_GetData pfnOld = 
                ORIGINAL_COM(IDataObject, GetData, pThis);

    if (pfnOld) { 
        hrReturn = (*pfnOld)(pThis, pFormatetc, pmedium);

        if (!pmedium->tymed && pmedium->hBitmap && 
            ((pFormatetc->tymed == TYMED_HGLOBAL) || 
             (pFormatetc->tymed == TYMED_GDI))) {

            LOGN( eDbgLevelError, "[IDataObject_GetData] fixing tymed parameter");
            
            pmedium->tymed = pFormatetc->tymed;
        }
    }

    return hrReturn;
}

/*++

 Register hooked functions

--*/

HOOK_BEGIN
    APIHOOK_ENTRY_COMSERVER(OLE32)
    APIHOOK_ENTRY(OLE32.DLL, OleSetClipboard)
    COMHOOK_ENTRY(DataObject, IDataObject, GetData, 3)
HOOK_END

IMPLEMENT_SHIM_END
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\appcompat\shims\specific\sevenkingdoms.cpp ===
/*++

 Copyright (c) 2000 Microsoft Corporation

 Module Name:

    SevenKingdoms.cpp

 Abstract:
    
    The problem is in the installer that ships with some versions: specifically 
    the double pack: i.e. Seven Kingdoms and another. This installer reads 
    win.ini and parses it for localization settings.

 Notes:

    This is an app specific shim.

 History:

    07/24/2000 linstev  Created

--*/

#include "precomp.h"
#include <stdio.h>

// This module has been given an official blessing to use the str routines.
#include "LegalStr.h"

IMPLEMENT_SHIM_BEGIN(SevenKingdoms)
#include "ShimHookMacro.h"

APIHOOK_ENUM_BEGIN
    APIHOOK_ENUM_ENTRY(CreateFileA) 
    APIHOOK_ENUM_ENTRY(ReadFile) 
    APIHOOK_ENUM_ENTRY(CloseHandle) 
APIHOOK_ENUM_END

CHAR *g_pszINI; 
DWORD g_dwINIPos = 0;
DWORD g_dwINISize = 0;

/*++

 Spoof the international settings in win.ini.

--*/

HANDLE 
APIHOOK(CreateFileA)(
    LPSTR lpFileName,
    DWORD dwDesiredAccess,
    DWORD dwShareMode,
    LPSECURITY_ATTRIBUTES lpSecurityAttributes,
    DWORD dwCreationDisposition,
    DWORD dwFlagsAndAttributes,
    HANDLE hTemplateFile
    )
{
    HANDLE hRet;
    
    if (lpFileName && (stristr(lpFileName, "win.ini")))
    {
        g_dwINIPos = 0;
        hRet = (HANDLE)0xBAADF00D;
    }
    else
    {
        hRet = ORIGINAL_API(CreateFileA)(
            lpFileName, 
            dwDesiredAccess, 
            dwShareMode, 
            lpSecurityAttributes, 
            dwCreationDisposition, 
            dwFlagsAndAttributes, 
            hTemplateFile
            );
    }

    return hRet;
}

/*++

 Spoof the international settings in win.ini.

--*/

BOOL 
APIHOOK(ReadFile)(
    HANDLE hFile,
    LPVOID lpBuffer,
    DWORD nNumberOfBytesToRead,
    LPDWORD lpNumberOfBytesRead,
    LPOVERLAPPED lpOverlapped
    )
{
    BOOL bRet;

    if (hFile == (HANDLE)0xBAADF00D)
    {
        //
        // We've detected the bogus file, so pretend we are reading it
        //

        if (g_dwINIPos + nNumberOfBytesToRead >= g_dwINISize)
        {
            // At the end of the buffer, so return the number of bytes until the end
            nNumberOfBytesToRead = g_dwINISize - g_dwINIPos;
        }
        
        MoveMemory(lpBuffer, g_pszINI + g_dwINIPos, nNumberOfBytesToRead);

        // Move the initial position - like a file pointer
        g_dwINIPos += nNumberOfBytesToRead;

        if (lpNumberOfBytesRead)
        {
            // Store the number of bytes read
            *lpNumberOfBytesRead = nNumberOfBytesToRead;
        }

        bRet = nNumberOfBytesToRead > 0;
    }
    else
    {
        bRet = ORIGINAL_API(ReadFile)( 
            hFile,
            lpBuffer,
            nNumberOfBytesToRead,
            lpNumberOfBytesRead,
            lpOverlapped);
    }

    return bRet;
}

/*++

 Handle the close of the dummy win.ini file

--*/

BOOL 
APIHOOK(CloseHandle)(HANDLE hObject)
{
    BOOL bRet;

    if (hObject == (HANDLE)0xBAADF00D)
    {
        // Pretend we closed a real file handle
        g_dwINIPos = 0;
        bRet = TRUE;
    }
    else
    {
        bRet = ORIGINAL_API(CloseHandle)(hObject);
    }
    
    return bRet;
}

/*++

 Register hooked functions

--*/

BOOL
NOTIFY_FUNCTION(
    DWORD fdwReason
    )
{
    if (fdwReason == DLL_PROCESS_ATTACH)
    {
        CHAR szLocale[MAX_PATH];

        g_pszINI = (CHAR *) malloc(1024);

        if (g_pszINI)
        {
            // 
            // Add all the locale settings to a buffer which looks like the [intl]
            //  group in win.ini on Win9x
            //
        
            int j = sprintf(g_pszINI, "[intl]\r\n");

            if (GetLocaleInfoA(LOCALE_USER_DEFAULT, LOCALE_ICOUNTRY, szLocale, MAX_PATH))
                j += sprintf(g_pszINI + j, "iCountry=%s\r\n", szLocale);
    
            if (GetLocaleInfoA(LOCALE_USER_DEFAULT, LOCALE_ICURRDIGITS, szLocale, MAX_PATH))
                j += sprintf(g_pszINI + j, "ICurrDigits=%s\r\n", szLocale);

            if (GetLocaleInfoA(LOCALE_USER_DEFAULT, LOCALE_ICURRENCY, szLocale, MAX_PATH))
                j += sprintf(g_pszINI + j, "iCurrency=%s\r\n", szLocale);

            if (GetLocaleInfoA(LOCALE_USER_DEFAULT, LOCALE_IDATE, szLocale, MAX_PATH))
                j += sprintf(g_pszINI + j, "iDate=%s\r\n", szLocale);

            if (GetLocaleInfoA(LOCALE_USER_DEFAULT, LOCALE_IDIGITS, szLocale, MAX_PATH))
                j += sprintf(g_pszINI + j, "iDigits=%s\r\n", szLocale);

            if (GetLocaleInfoA(LOCALE_USER_DEFAULT, LOCALE_ILZERO, szLocale, MAX_PATH))
                j += sprintf(g_pszINI + j, "iLZero=%s\r\n", szLocale);

            if (GetLocaleInfoA(LOCALE_USER_DEFAULT, LOCALE_IMEASURE, szLocale, MAX_PATH))
                j += sprintf(g_pszINI + j, "iMeasure=%s\r\n", szLocale);

            if (GetLocaleInfoA(LOCALE_USER_DEFAULT, LOCALE_INEGCURR, szLocale, MAX_PATH))
                j += sprintf(g_pszINI + j, "iNegCurr=%s\r\n", szLocale);

            if (GetLocaleInfoA(LOCALE_USER_DEFAULT, LOCALE_ITIME, szLocale, MAX_PATH))
                j += sprintf(g_pszINI + j, "iTime=%s\r\n", szLocale);

            if (GetLocaleInfoA(LOCALE_USER_DEFAULT, LOCALE_ITLZERO, szLocale, MAX_PATH))
                j += sprintf(g_pszINI + j, "iTLZero=%s\r\n", szLocale);

            if (GetLocaleInfoA(LOCALE_USER_DEFAULT, LOCALE_S1159, szLocale, MAX_PATH))
                j += sprintf(g_pszINI + j, "s1159=%s\r\n", szLocale);

            if (GetLocaleInfoA(LOCALE_USER_DEFAULT, LOCALE_S2359, szLocale, MAX_PATH))
                j += sprintf(g_pszINI + j, "s2359=%s\r\n", szLocale);

            if (GetLocaleInfoA(LOCALE_USER_DEFAULT, LOCALE_SCOUNTRY, szLocale, MAX_PATH))
                j += sprintf(g_pszINI + j, "sCountry=%s\r\n", szLocale);

            if (GetLocaleInfoA(LOCALE_USER_DEFAULT, LOCALE_SCURRENCY, szLocale, MAX_PATH))
                j += sprintf(g_pszINI + j, "sCurrency=%s\r\n", szLocale);

            if (GetLocaleInfoA(LOCALE_USER_DEFAULT, LOCALE_SDATE, szLocale, MAX_PATH))
                j += sprintf(g_pszINI + j, "sDate=%s\r\n", szLocale);

            if (GetLocaleInfoA(LOCALE_USER_DEFAULT, LOCALE_SDECIMAL, szLocale, MAX_PATH))
                j += sprintf(g_pszINI + j, "sDecimal=%s\r\n", szLocale);

            if (GetLocaleInfoA(LOCALE_USER_DEFAULT, LOCALE_SLANGUAGE, szLocale, MAX_PATH))
                j += sprintf(g_pszINI + j, "sLanguage=%s\r\n", szLocale);

            if (GetLocaleInfoA(LOCALE_USER_DEFAULT, LOCALE_SLIST, szLocale, MAX_PATH))
                j += sprintf(g_pszINI + j, "sList=%s\r\n", szLocale);

            if (GetLocaleInfoA(LOCALE_USER_DEFAULT, LOCALE_SLONGDATE, szLocale, MAX_PATH))
                j += sprintf(g_pszINI + j, "sLongDate=%s\r\n", szLocale);
    
            if (GetLocaleInfoA(LOCALE_USER_DEFAULT, LOCALE_SSHORTDATE, szLocale, MAX_PATH))
                j += sprintf(g_pszINI + j, "sShortDate=%s\r\n", szLocale);

            if (GetLocaleInfoA(LOCALE_USER_DEFAULT, LOCALE_STHOUSAND, szLocale, MAX_PATH))
                j += sprintf(g_pszINI + j, "sThousand=%s\r\n", szLocale);

            if (GetLocaleInfoA(LOCALE_USER_DEFAULT, LOCALE_STIME, szLocale, MAX_PATH))
                j += sprintf(g_pszINI + j, "sTime=%s\r\n", szLocale);

            g_dwINISize = j;
        }
    }

    return TRUE;
}

HOOK_BEGIN

    CALL_NOTIFY_FUNCTION
    APIHOOK_ENTRY(KERNEL32.DLL, CreateFileA)
    APIHOOK_ENTRY(KERNEL32.DLL, ReadFile)
    APIHOOK_ENTRY(KERNEL32.DLL, CloseHandle)

HOOK_END

IMPLEMENT_SHIM_END
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\appcompat\shims\specific\shockwavelocation.cpp ===
/*++

 Copyright (c) 2000-2001 Microsoft Corporation

 Module Name:

   ShockwaveLocation.cpp

 Abstract:

   In Encarta Encyclopedia 2000 J DVD, Shockwave is accessible only by installed user's HKCU.
   \WINDOWS\System32\Macromed\Director\SwDir.dll is looking for Shockwave location in HKCU.
   For other users, this shim will create Shockwave location registry in HKCU if Shockwave folder exist
   and not exist in registry.

   Example:
   HKCU\Software\Macromedia\Shockwave\location\coreplayer
   (Default) REG_SZ "C:\WINDOWS\System32\Macromed\Shockwave\"
   HKCU\Software\Macromedia\Shockwave\location\coreplayerxtras
   (Default) REG_SZ "C:\WINDOWS\System32\Macromed\Shockwave\Xtras\"

 Notes:

   PopulateDefaultHKCUSettings shim does not work for this case 'cause the location include
   WINDOWS directry as REG_SZ and cannot be a static data.
   VirtualRegistry shim Redirector also not work 'cause sw70inst.exe does not use Reg API
   and use SWDIR.INF to install in HKCU.

 History:

    04/27/2001  hioh        Created

--*/

#include "precomp.h"


IMPLEMENT_SHIM_BEGIN(ShockwaveLocation)
#include "ShimHookMacro.h"

APIHOOK_ENUM_BEGIN
APIHOOK_ENUM_END

/*++

 Add coreplayer & coreplayerxtras location in registry

--*/

BOOL
NOTIFY_FUNCTION(
    DWORD fdwReason)
{
    if (fdwReason == SHIM_STATIC_DLLS_INITIALIZED)
    {
        HKEY    hKey;
        WCHAR   szRegCP[] = L"Software\\Macromedia\\Shockwave\\location\\coreplayer";
        WCHAR   szRegCPX[] = L"Software\\Macromedia\\Shockwave\\location\\coreplayerxtras";
        WCHAR   szLocCP[MAX_PATH];
        WCHAR   szLocCPX[MAX_PATH];

        // coreplayer
        if (ERROR_SUCCESS == RegOpenKeyExW(HKEY_CURRENT_USER, szRegCP, 0, KEY_QUERY_VALUE, &hKey))
        {   // key exist, do nothing
            RegCloseKey(hKey);
        }
        else
        {   // key not exist, set key
            GetSystemDirectoryW(szLocCP, sizeof(szLocCP)/sizeof(WCHAR));
            lstrcatW(szLocCP, L"\\Macromed\\Shockwave\\");
            if (GetFileAttributesW(szLocCP) != 0xffffffff)
            {   // folder exist, create key
                if (ERROR_SUCCESS == RegCreateKeyExW(HKEY_CURRENT_USER, szRegCP, 0, 0, REG_OPTION_NON_VOLATILE, KEY_WRITE, NULL, &hKey, NULL))
                {   // set location
                    RegSetValueExW(hKey, NULL, 0, REG_SZ, (BYTE*)szLocCP, (DWORD)((lstrlenW(szLocCP)+1)*sizeof(WCHAR)));
                    RegCloseKey(hKey);
                }
            }
        }

        // coreplayerxtras
        if (ERROR_SUCCESS == RegOpenKeyExW(HKEY_CURRENT_USER, szRegCPX, 0, KEY_QUERY_VALUE, &hKey))
        {   // key exist, do nothing
            RegCloseKey(hKey);
        }
        else
        {   // key not exist, set key
            GetSystemDirectoryW(szLocCPX, sizeof(szLocCPX)/sizeof(WCHAR));
            lstrcatW(szLocCPX, L"\\Macromed\\Shockwave\\Xtras\\");
            if (GetFileAttributesW(szLocCPX) != 0xffffffff)
            {   // folder exist, create key
                if (ERROR_SUCCESS == RegCreateKeyExW(HKEY_CURRENT_USER, szRegCPX, 0, 0, REG_OPTION_NON_VOLATILE, KEY_WRITE, NULL, &hKey, NULL))
                {   // set location
                    RegSetValueExW(hKey, NULL, 0, REG_SZ, (BYTE*)szLocCPX, (DWORD)((lstrlenW(szLocCPX)+1)*sizeof(WCHAR)));
                    RegCloseKey(hKey);
                }
            }
        }
    }
    return TRUE;
}

/*++

 Register hooked functions

--*/

HOOK_BEGIN

    CALL_NOTIFY_FUNCTION

HOOK_END

IMPLEMENT_SHIM_END
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\appcompat\shims\specific\settlers3.cpp ===
/*++

 Copyright (c) 2000 Microsoft Corporation

 Module Name:

    Settlers3.cpp

 Abstract:

    The app has a protection system that sets the CPU direction flag and 
    expects it to be maintained through calls to WaitForSingleObject, SetEvent
    and ResetEvent.

    We have to patch the import tables manually and pretend to be kernel32 so
    the protection system doesn't fail elsewhere.

 Notes:

    This is an app specific shim.

 History:

    07/05/2001 linstev   Created

--*/

#include "precomp.h"
#include "LegalStr.h"

IMPLEMENT_SHIM_BEGIN(Settlers3)
#include "ShimHookMacro.h"

APIHOOK_ENUM_BEGIN
APIHOOK_ENUM_END

//
// The real kernel32 handle
//

HINSTANCE g_hinstKernel;

// Functions to hook imports

BOOL HookImports(HMODULE hModule);

//
// List of hooks we'll be patching
//

FARPROC _GetProcAddress(HMODULE hModule, LPCSTR lpProcName);
HINSTANCE _LoadLibraryA(LPCSTR lpLibFileName);
HMODULE _GetModuleHandleA(LPCSTR lpModuleName);
BOOL _ResetEvent(HANDLE hEvent);
BOOL _SetEvent(HANDLE hEvent);
DWORD _WaitForSingleObject(HANDLE hHandle, DWORD dwMilliseconds);

struct AHOOK {
    LPSTR szName;
    PVOID pfnOld;
    PVOID pfnNew;
};

AHOOK g_HookArray[] = {
    { "LoadLibraryA"        , 0, _LoadLibraryA        },
    { "GetProcAddress"      , 0, _GetProcAddress      }, 
    { "GetModuleHandleA"    , 0, _GetModuleHandleA    },
    { "ResetEvent"          , 0, _ResetEvent          }, 
    { "SetEvent"            , 0, _SetEvent            },
    { "WaitForSingleObject" , 0, _WaitForSingleObject }
};
DWORD g_dwHookCount = sizeof(g_HookArray) / sizeof(AHOOK);

/*++

 Hooks section: each designed to spoof the app into thinking this shim is 
 kernel32.dll.

--*/

HINSTANCE 
_LoadLibraryA(
    LPCSTR lpLibFileName   
    )
{
    if (lpLibFileName && stristr(lpLibFileName, "kernel32")) {
        return g_hinstDll;
    } else {
        HINSTANCE hRet = LoadLibraryA(lpLibFileName);
        HookImports(GetModuleHandleW(0));
        return hRet;
    }
}

FARPROC 
_GetProcAddress(
    HMODULE hModule,    
    LPCSTR lpProcName   
    )
{
    if (hModule == g_hinstDll) {
        hModule = g_hinstKernel;
    }
    
    FARPROC lpRet = GetProcAddress(hModule, lpProcName);

    //
    // Run the list of our hooks to see if we need to spoof them
    //
    if (lpRet) {
        for (UINT i=0; i<g_dwHookCount; i++) {
            if (lpRet == g_HookArray[i].pfnOld) {
                lpRet = (FARPROC) g_HookArray[i].pfnNew;
                break;
            }
        }
    }
                
    return lpRet;
}

HMODULE 
_GetModuleHandleA(
    LPCSTR lpModuleName   
    )
{
    if (lpModuleName && stristr(lpModuleName, "kernel32")) {
        return g_hinstDll;
    } else {
        return GetModuleHandleA(lpModuleName);
    }
}

/*++

 These save and restore the state of the direction flag (actually all flags),
 before and after each call.

--*/

BOOL 
_ResetEvent(
    HANDLE hEvent   
    )
{
    DWORD dwFlags;

    __asm {
        pushfd
        pop  dwFlags
    }

    BOOL bRet = ResetEvent(hEvent);

    __asm {
        push dwFlags
        popfd 
    }

    return bRet;
}

BOOL 
_SetEvent(
    HANDLE hEvent   
    )
{
    DWORD dwFlags;

    __asm {
        pushfd
        pop  dwFlags
    }

    BOOL bRet = SetEvent(hEvent);

    __asm {
        push dwFlags
        popfd 
    }

    return bRet;
}

DWORD
_WaitForSingleObject(
    HANDLE hHandle,        
    DWORD dwMilliseconds   
    )
{
    DWORD dwFlags;

    __asm {
        pushfd
        pop  dwFlags
    }

    DWORD dwRet = WaitForSingleObject(hHandle, dwMilliseconds);
    
    __asm {
        push dwFlags
        popfd 
    }

    return dwRet;
}

/*++

 Patch everyone to point to this dll
  
--*/

BOOL
HookImports(HMODULE hModule)
{
    NTSTATUS                    status;
    BOOL                        bAnyHooked = FALSE;
    PIMAGE_DOS_HEADER           pIDH       = (PIMAGE_DOS_HEADER) hModule;
    PIMAGE_NT_HEADERS           pINTH;
    PIMAGE_IMPORT_DESCRIPTOR    pIID;
    DWORD                       dwImportTableOffset;
    DWORD                       dwOldProtect, dwOldProtect2;
    SIZE_T                      dwProtectSize;
    DWORD                       i, j;
    PVOID                       pfnOld;
    LPBYTE                      pDllBase = (LPBYTE) pIDH;

    if (!hModule || (hModule == g_hinstDll) || (hModule == g_hinstKernel)) {
        return FALSE;
    }

    //
    // Get the import table.
    //
    pINTH = (PIMAGE_NT_HEADERS)(pDllBase + pIDH->e_lfanew);

    dwImportTableOffset = pINTH->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_IMPORT].VirtualAddress;

    if (dwImportTableOffset == 0) {
        //
        // No import table found. This is probably ntdll.dll
        //
        return TRUE;
    }

    pIID = (PIMAGE_IMPORT_DESCRIPTOR)(pDllBase + dwImportTableOffset);

    //
    // Loop through the import table and search for the APIs that we want to patch
    //
    while (TRUE) {

        LPSTR             pszImportEntryModule;
        PIMAGE_THUNK_DATA pITDA;

        //
        // Return if no first thunk (terminating condition).
        //
        if (pIID->FirstThunk == 0) {
            break;
        }

        pszImportEntryModule = (LPSTR)(pDllBase + pIID->Name);

        //
        // We have APIs to hook for this module!
        //
        pITDA = (PIMAGE_THUNK_DATA)(pDllBase + (DWORD)pIID->FirstThunk);

        while (TRUE) {

            SIZE_T dwFuncAddr;
            AHOOK *pHook = NULL;

            pfnOld = (PVOID)pITDA->u1.Function;

            //
            // Done with all the imports from this module? (terminating condition)
            //
            if (pITDA->u1.Ordinal == 0) {
                break;
            }

            for (i=0; i<g_dwHookCount; i++) {
                if (pfnOld == g_HookArray[i].pfnOld) {
                    pHook = &g_HookArray[i];
                    break;
                }
            }

            // 
            // Check if we've found a hook
            //
            if (!pHook) {
                pITDA++;
                continue;
            }

            //
            // Make the code page writable and overwrite new function pointer
            // in the import table.
            //
            dwProtectSize = sizeof(DWORD);

            dwFuncAddr = (SIZE_T)&pITDA->u1.Function;

            status = VirtualProtect((PVOID)dwFuncAddr,                                            
                                    dwProtectSize,
                                    PAGE_READWRITE,
                                    &dwOldProtect);

            if (NT_SUCCESS(status)) {
                pITDA->u1.Function = (SIZE_T)pHook->pfnNew;

                dwProtectSize = sizeof(DWORD);

                status = VirtualProtect((PVOID)dwFuncAddr,
                                        dwProtectSize,
                                        dwOldProtect,
                                        &dwOldProtect2);

                if (!NT_SUCCESS(status)) {
                    DPFN(eDbgLevelError, "[HookImports] Failed to change back the protection");
                }
            } else {
                DPFN(eDbgLevelError,
                    "[HookImports] Failed 0x%X to change protection to PAGE_READWRITE."
                    " Addr 0x%p\n",
                    status,
                    &pITDA->u1.Function);

            }
            pITDA++;

        }
        pIID++;
    }

    return TRUE;
}

/*++

 Register hooked functions

--*/

BOOL
NOTIFY_FUNCTION(
    DWORD fdwReason
    )
{
    if (fdwReason == DLL_PROCESS_ATTACH) {
        //
        // Patch all the import tables of everyone with this module
        //
        g_hinstKernel = GetModuleHandleW(L"kernel32");
        for (UINT i=0; i<g_dwHookCount; i++) {
            g_HookArray[i].pfnOld = GetProcAddress(g_hinstKernel, g_HookArray[i].szName);
        }

        HookImports(GetModuleHandleW(0));
    }

    return TRUE;
}


HOOK_BEGIN

    CALL_NOTIFY_FUNCTION

HOOK_END

IMPLEMENT_SHIM_END
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\appcompat\shims\specific\speechviewer3.cpp ===
/*++

 Copyright (c) 2001 Microsoft Corporation

 Module Name:

    SpeechViewer3.cpp

 Abstract:

    The app requires ChangeDisplaySettings to cause a permanent mode change.

 Notes:

    This is an app specific shim.

 History:

    05/23/2001 linstev  Created

--*/

#include "precomp.h"

IMPLEMENT_SHIM_BEGIN(SpeechViewer3)
#include "ShimHookMacro.h"

APIHOOK_ENUM_BEGIN
    APIHOOK_ENUM_ENTRY(ChangeDisplaySettingsA) 
APIHOOK_ENUM_END

/*++

 Make the mode change permanent.

--*/

LONG 
APIHOOK(ChangeDisplaySettingsA)(
    LPDEVMODEA lpDevMode,  
    DWORD dwFlags         
    )
{
    if (dwFlags & CDS_FULLSCREEN) {
        dwFlags = 0;
    }
    return ORIGINAL_API(ChangeDisplaySettingsA)(lpDevMode, dwFlags);
}

/*++

 Register hooked functions

--*/

HOOK_BEGIN
    APIHOOK_ENTRY(USER32.DLL, ChangeDisplaySettingsA)
HOOK_END

IMPLEMENT_SHIM_END
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\appcompat\shims\specific\solidworks99plus.cpp ===
/*++

 Copyright (c) 2000 Microsoft Corporation

 Module Name:

    SolidWorks99Plus.cpp

 Abstract:

    This patches winhlp32.exe for calls to FTSRCH!OpenIndex only if they come from
    ROBOEX32.DLL. This needs to be written in the shim database otherwise the
    shim will be applied to all the apps using winhlp32.exe (which is bad!).
    
    Win2k's winhlp32.exe will only work with index files located in %windir%\Help
    so we need to redirect the location that the app points to.

 Notes:

    This is an app specific shim.

 History:

    02/16/2000 clupu    Created
    08/05/2001 linstev  Added module checking

--*/

#include "precomp.h"
#include "LegalStr.h"

IMPLEMENT_SHIM_BEGIN(SolidWorks99Plus)
#include "ShimHookMacro.h"

APIHOOK_ENUM_BEGIN
    APIHOOK_ENUM_ENTRY(OpenIndex)
APIHOOK_ENUM_END

/*++

 Read the index file from %windir%\Help

--*/

int
APIHOOK(OpenIndex)(
    HANDLE    hsrch,
    char*     pszIndexFile,
    PBYTE     pbSourceName,
    PUINT     pcbSourceNameLimit,
    PUINT     pTime1,
    PUINT     pTime2
    )
{
    if (GetModuleHandleW(L"ROBOEX32.DLL")) {
        //
        // This is SolidWorks
        //
        char szBuff[MAX_PATH];
        char* pszWalk;
        char* pszWalk2;

        DPF("SolidWorks99Plus",
           eDbgLevelInfo,
           "SolidWorks99Plus.dll, Changing OpenIndex file\n\tfrom: \"%s\".\n",
           pszIndexFile);

        GetSystemWindowsDirectoryA(szBuff, MAX_PATH);
        pszWalk = szBuff;

        pszWalk2 = pszIndexFile + lstrlenA(pszIndexFile) - 1;

        while (pszWalk2 > pszIndexFile && *pszWalk2 != '/' && *pszWalk2 != '\\') {
            pszWalk2--;
        }

        if (*pszWalk2 == '/') {

            while (*pszWalk != 0) {
                if (*pszWalk == '\\') {
                    *pszWalk = '/';
                }
                pszWalk++;
            }

            lstrcpyA(pszWalk, "/Help");
            lstrcatA(pszWalk, pszWalk2);

        } else if (*pszWalk2 == '\\') {
            lstrcatA(pszWalk, "\\Help");
            lstrcatA(pszWalk, pszWalk2);
        } else {
            lstrcpyA(pszWalk, pszWalk2);
        }

        DPF("SolidWorks99Plus",
            eDbgLevelInfo,
            "SolidWorks99Plus.dll, \tto:   \"%s\".\n",
            szBuff);

        return ORIGINAL_API(OpenIndex)(hsrch, szBuff, pbSourceName,
            pcbSourceNameLimit, pTime1, pTime2);
    } else {
        //
        // Not SolidWorks
        //
        return ORIGINAL_API(OpenIndex)(hsrch, pszIndexFile, pbSourceName,
            pcbSourceNameLimit, pTime1, pTime2);
    }
}

/*++

 Register hooked functions

--*/

HOOK_BEGIN

    APIHOOK_ENTRY(FTSRCH.DLL, OpenIndex)

HOOK_END


IMPLEMENT_SHIM_END
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\appcompat\shims\specific\sources.inc ===
!IF 0

Copyright (c) 1990  Microsoft Corporation

Module Name:

    sources.

!ENDIF

TARGETNAME=AcSpecfc

TARGETTYPE=DYNLINK

INCLUDES = $(INCLUDES);..;$(SHELL_INC_PATH)

SOURCES=..\ver.rc                          \
        ..\Main.cpp                        \
        ..\3DFrogFrenzy.cpp                \
        ..\Acrobat5.cpp                    \
        ..\AdobeLiveMotion.cpp             \
        ..\AfterDark.cpp                   \
        ..\AliensVsPredator.cpp            \
        ..\AOLFindBundledInstaller_Shim.cpp                \
        ..\AOLFindBundledInstaller_AOLCode.cpp             \
        ..\AOLSystemInfo.cpp               \
        ..\AOLRasSetEntryProperties.cpp    \
        ..\Attune.cpp                      \
        ..\AutoCad.cpp                     \
        ..\AutoDeskWorld2.cpp              \
        ..\BaanERP5.cpp                    \
        ..\BaanERP5c.cpp                   \
        ..\BaanIV.cpp                      \
        ..\BackOffice45Suite.cpp           \
        ..\Battleship.cpp                  \
        ..\BaseBall2000.cpp                \
        ..\BattleZone.cpp                  \
        ..\BeyondAtlantis.cpp              \
        ..\BigActionConstruction.cpp       \
        ..\BigGameHunter3.cpp              \
        ..\BizPlanBuilder.cpp              \
        ..\BoeingFix.cpp                   \
        ..\Britannica2001.cpp              \
        ..\Canvas6.cpp                     \
        ..\CanvasCheckedButtons.cpp        \
        ..\Casper.cpp                      \
        ..\ChemOffice.cpp                  \
        ..\Chollian2000.cpp                \
        ..\Chollian2000Plus.cpp            \
        ..\ClueFinders3rdGrade.cpp         \
        ..\CoffeeCupHTMLEditor.cpp         \
        ..\Commandos.cpp                   \
        ..\Cossacks.cpp                    \
        ..\ComptonsBible.cpp               \
        ..\CorelAppsRegistration.cpp       \
        ..\CorelDraw9JPN.cpp               \
        ..\CorelSiteBuilder.cpp            \
        ..\CreateResumesQuickandEasy.cpp   \
        ..\CreativeOnScreenDisplay.cpp     \
        ..\CrystalWebPageServer.cpp        \
        ..\CUSeeMe4.cpp                    \
        ..\Descent2.cpp                    \
        ..\DinosaurActivityCenter.cpp      \
        ..\DirtTrackRacing.cpp             \
        ..\DominantSpecies.cpp             \
        ..\DongFangKuaiChe3000Setup.cpp    \
        ..\DongFangYingDu.cpp              \
        ..\DrEye.cpp                       \
        ..\EA3dSetup.cpp                   \
        ..\EasyCDCreator4.cpp              \
        ..\EasyCDCreator5.cpp              \
        ..\EncartaEncyclopediaDeluxe2K.cpp \
        ..\EncompassMonitor.cpp            \
        ..\EuropeanAirWar.cpp              \
        ..\ExchangeServerSetup.cpp         \
        ..\F18Carrier.cpp                  \
        ..\FireFighters.cpp                \
        ..\Force21.cpp                     \
        ..\Gangsters.cpp                   \
        ..\Gizmos.cpp                      \
        ..\HeroSDVD.cpp                    \
        ..\HotFaxMessageCenter4.cpp        \
        ..\HoyleGames.cpp                  \
        ..\HPTourguide.cpp                 \
        ..\HTMLEditor8587.cpp              \
        ..\IConfig.cpp                     \
        ..\IE5DOMSetup.cpp                 \
        ..\ISA.cpp                         \
        ..\ISpeed.cpp                      \
        ..\InstallShield6.cpp              \
        ..\IntelVideoPhone.cpp             \
        ..\JavaVM.cpp                      \
        ..\JavaVM2.cpp                     \
        ..\JetFighter4.cpp                 \
        ..\Keisoku7.Cpp                    \
        ..\Khunmin2Album.cpp               \
        ..\KingsQuestMask.cpp              \
        ..\KOEISecurityCheck.cpp           \
        ..\LHVoiceXPressPlus.cpp           \
        ..\LinksExtreme.cpp                \
        ..\LotusOrganizer5.cpp             \
        ..\MahjonggMadness.cpp             \
        ..\MastersOfOrion2.cpp             \
        ..\MathBlaster9_12.cpp             \
        ..\MaxPayne.cpp                    \
        ..\MECCommander.cpp                \
        ..\MechWarrior2.cpp                \
        ..\MidTownMadness2.cpp             \
        ..\Millionaire.cpp                 \
        ..\MindSpring4.cpp                 \
        ..\ModemWizard.cpp                 \
        ..\Money2001.cpp                   \
        ..\Money2002.cpp                   \
        ..\MSAccess2000IME.cpp             \
        ..\MSDevDisabledButtons.cpp        \
        ..\MSWorks6.cpp                    \
        ..\MyPhotoCenter2.cpp              \
        ..\NBALive.cpp                     \
        ..\NetZip.cpp                      \
        ..\NetObjectsFusion5.cpp           \
        ..\NetManageViewNow.cpp            \
        ..\NewShenDiaoXiaLv.cpp            \
        ..\NFLBlitz.cpp                    \
        ..\NFLFever2000.cpp                \
        ..\NHL2001.cpp                     \
        ..\NikonView.cpp                   \
        ..\Omikron.cpp                     \
        ..\OmniPagePro.cpp                 \
        ..\OmniPagePro11Uninstall.cpp      \
        ..\OperationsManager.cpp           \
        ..\Outlook2000.cpp                 \
        ..\Outlook97.cpp                   \
        ..\Outlook98Wizard.cpp             \
        ..\OverlayPro.cpp                  \
        ..\PanzerCommander.cpp             \
        ..\PickyEater.cpp                  \
        ..\Pirch98.cpp                     \
        ..\Petz.cpp                        \
        ..\PlaneCrazy.cpp                  \
        ..\PostIt2.cpp                     \
        ..\PowerBuilder.cpp                \
        ..\Ppo3svrScr.cpp                  \
        ..\PrintMaster4.cpp                \
        ..\ProAtlas2000.cpp                \
        ..\Quicken2000.cpp                 \
        ..\Quicken2001.cpp                 \
        ..\QuickTime5.cpp                  \
        ..\RCenter.cpp                     \
        ..\ResumeWriter3.cpp               \
        ..\ReturnToKrondor.cpp             \
        ..\RiskII.cpp                      \
        ..\Riven.cpp                       \
        ..\RumbaOffice.cpp                 \
        ..\SafeDisc.cpp                    \
        ..\SchoolHouseRockMath.cpp         \
        ..\Settlers3.cpp                   \
        ..\SevenKingdoms.cpp               \
        ..\ShockwaveLocation.cpp           \
        ..\SierraCartRacing.cpp            \
        ..\Simply3D.cpp                    \
        ..\SirenJukebox2.cpp               \
        ..\SolidWorks99Plus.cpp            \
        ..\SpecOps2.cpp                    \
        ..\SpeechViewer3.cpp               \
        ..\StoneAge.Cpp                    \
	..\Suda2000.cpp                    \
        ..\Summoner.cpp                    \
        ..\SuperBike.cpp                   \
        ..\SuperChix76.cpp                 \
        ..\SysAdmiral.cpp                  \
        ..\TaskbarAndStartMenuProperty.cpp \
        ..\ThreedJungleTrain.cpp           \
        ..\TimeSlips.cpp                   \
        ..\TonkaConstruction.cpp           \
        ..\TreasureCove.cpp                \
        ..\TurkeyHunter.cpp                \
        ..\TwinssensOdyssey.cpp            \
        ..\Ultima9.cpp                     \
        ..\UltimateSoccerManager.cpp       \
        ..\UltraWinCleaner2002.cpp         \
        ..\UnInstallShield.cpp             \
        ..\UrbanChaos.cpp                  \
        ..\USNF97.cpp                      \
        ..\ViaVoice8J.cpp                  \
        ..\ViperRacing.cpp                 \
        ..\VJEDelta.cpp                    \
        ..\VJEDeltaSetup.cpp               \
        ..\VSAnalyzerServerSetup.cpp       \
        ..\WebPage6.cpp                    \
        ..\WinFaxPro9.cpp                  \
        ..\WinStone99.cpp                  \
        ..\WordPerfect8.cpp                \
        ..\WordPerfect9_1.cpp              \
        ..\Wordperfect9_2.cpp              \
        ..\Wordperfect9_3.cpp              \
        ..\WorksSuite2001.cpp              \
        ..\Works99.cpp                     \
        ..\Worms2.cpp                      \
        ..\Wps2000.cpp                     \
        ..\ZenWorks.cpp


C_DEFINES=$(C_DEFINES) -DSHIM_HOOKDLL_VERSION2

TARGETLIBS=$(TARGETLIBS) \
           $(SDK_LIB_PATH)\user32.lib \
           $(SDK_LIB_PATH)\gdi32.lib \
           $(SDK_LIB_PATH)\advapi32.lib \
           $(SDK_LIB_PATH)\ole32.lib \
           $(SDK_LIB_PATH)\shell32.lib \
           $(SDK_LIB_PATH)\winmm.lib \
           $(SDK_LIB_PATH)\ddraw.lib \
           $(SDK_LIB_PATH)\userenv.lib \
           $(SDK_LIB_PATH)\Mpr.lib \
           $(SDK_LIB_PATH)\psapi.lib \
           $(SDK_LIB_PATH)\comdlg32.lib \
           $(SDK_LIB_PATH)\imm32.lib

TARGETPATH=$(_OBJ_DIR)

DLLBASE=0x21000000

PRECOMPILED_CXX=1
PRECOMPILED_INCLUDE=..\precomp.h
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\appcompat\shims\specific\specops2.cpp ===
/*++

 Copyright (c) 2000 Microsoft Corporation

 Module Name:

    SpecOps2.cpp

 Abstract:

    App does too much within a DLLMain and hangs because dinput is waiting on 
    a thread it just created.

    The fix is to prevent the DllMain from running during the loader lock. The 
    only way to do this seems to be to hook an API that's called really early 
    during the DllMain and jump back to the loader. 

    The catch is that we still need to call the DllMain after the LoadLibrary 
    has completed.

 Notes:

    This is an app specific shim.

 History:

    05/01/2001 linstev   Created

--*/

#include "precomp.h"
#include "LegalStr.h"

IMPLEMENT_SHIM_BEGIN(SpecOps2)
#include "ShimHookMacro.h"

APIHOOK_ENUM_BEGIN
    APIHOOK_ENUM_ENTRY(GetVersion)
    APIHOOK_ENUM_ENTRY(LoadLibraryA) 
APIHOOK_ENUM_END

// Global state used to determine what to do for a particular call
BOOL g_bState = FALSE;

// The thread handle for matching synchronization logic
HANDLE g_hThread = NULL;

/*++

 This is the first API that the DllMain calls, so we're going to back out 
 jump straight out of it, back into loader code as if it completed normally.

--*/

__declspec(naked)
DWORD
APIHOOK(GetVersion)(
    void
    )
{
    __asm {
        // 
        // Make sure we're on the right thread so we don't have to synchronize
        //
        call dword ptr [GetCurrentThread]
        cmp  eax, g_hThread
        jne  Exit                       

        // test for the right dll
        cmp  g_bState, 1
        jne  Exit                
        
        // we're done
        mov  g_bState, 0                

        // leave the stack and registers as they were before
        add  esp, 20
        pop  edi
        pop  esi
        pop  ebx
        pop  ebp
        ret  12                         

    Exit:

        // original api
        call dword ptr [GetVersion]     
        ret
    }
}

/*++

 When "SO Menu.dll" is loaded, we start the sequence which prevents the DllMain 
 from crashing, but it means we have to run the entry point after the load.

--*/

HINSTANCE
APIHOOK(LoadLibraryA)(
    LPCSTR lpLibFileName
    )
{
    BOOL bCheck = FALSE;
    if (_stricmp(lpLibFileName, "menu\\SO Menu.dll") == 0) {
        //
        // We assume *only* the main thread tries to load this library, so
        // we don't synchronize multiple threads trying to load this same dll
        //
        g_hThread = GetCurrentThread();
        bCheck = TRUE;
        g_bState = TRUE;
    }
        
    //
    // Load the library, if it's "SO Menu", we'll catch the GetVersion called 
    // by its DllMain
    //

    HMODULE hMod = ORIGINAL_API(LoadLibraryA)(lpLibFileName);

    if (hMod && bCheck) {
        //
        // Run the DllMain
        //
        typedef BOOL (WINAPI *_pfn_DllMain)(HINSTANCE hinstDLL, DWORD fdwReason, LPVOID lpvReserved);

        PIMAGE_DOS_HEADER pIDH = (PIMAGE_DOS_HEADER) hMod;
        PIMAGE_NT_HEADERS pINTH = (PIMAGE_NT_HEADERS)((LPBYTE)hMod + pIDH->e_lfanew);
        _pfn_DllMain pfnMain = (_pfn_DllMain)((LPBYTE)hMod + pINTH->OptionalHeader.AddressOfEntryPoint);
        
        // Call the startup routine
        (*pfnMain)(hMod, DLL_PROCESS_ATTACH, NULL);
    }

    return hMod;
}

/*++

 Register hooked functions

--*/

HOOK_BEGIN

    APIHOOK_ENTRY(KERNEL32.DLL, GetVersion)
    APIHOOK_ENTRY(KERNEL32.DLL, LoadLibraryA)

HOOK_END

IMPLEMENT_SHIM_END
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\appcompat\shims\specific\sirenjukebox2.cpp ===
/*++

 Copyright (c) 2000 Microsoft Corporation

 Module Name:

    SirenJukebox2.cpp

 Abstract:

    This app has a problem with DirectDraw 7.0 and hence we fail the call to 
    GetProcAddress when it asks for DirectDrawCreateEx.

 Notes:

    This is an app specific shim.

 History:
 
    03/13/2001 prashkud  Created
    05/04/2001 prashkud  Modified to fix a bug if ordinals are passed
                         instead of string addresses. We now imitate 
                         the behaviour of the actual GetProcAddress().

--*/

#include "precomp.h"

IMPLEMENT_SHIM_BEGIN(SirenJukebox2)
#include "ShimHookMacro.h"

APIHOOK_ENUM_BEGIN
    APIHOOK_ENUM_ENTRY(GetProcAddress)    
APIHOOK_ENUM_END

const WCHAR  wszDirectDrawCreateEx[] = L"DirectDrawCreateEx";

/*++

 If the app is asking for the Proc adress for DirectDrawCreateEx, then return 
 NULL.
    
--*/

FARPROC
APIHOOK(GetProcAddress)(
    HMODULE hMod,
    LPCSTR lpProcName
    )
{
    CSTRING_TRY
    {
        //
        // Check to see if lpProcName contains an ordinal value.
        // Only the low word can contain the ordinal and the 
        // upper word has to be 0's.
        //

        if ((ULONG_PTR) lpProcName > 0xffff)
        {
            CString csProcName(lpProcName);

            if (csProcName.CompareNoCase(wszDirectDrawCreateEx) == 0)
            {
                return NULL;
            }
        }
    }
    CSTRING_CATCH
    {
        // Do Nothing
    }

    return ORIGINAL_API(GetProcAddress)(hMod, lpProcName);
}

/*++

 Register hooked functions

--*/

HOOK_BEGIN
    APIHOOK_ENTRY(KERNEL32.DLL, GetProcAddress)    
HOOK_END

IMPLEMENT_SHIM_END
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\appcompat\shims\specific\stoneage.cpp ===
/*++

 Copyright (c) 2001 Microsoft Corporation

 Module Name:

    StoneAge.cpp

 Abstract:

    The app is trying to create a window with NULL WndProc, and later it seems does
    not really use it , and just launch the installshield setup program and exit.
    Fix this by providing a dummy WndProc. 

    BUGBUG: Need to add to EmulateUSER when possible.

 Notes: 
  
    This is an app specific shim.

 History:

    06/09/2001 xiaoz    Created

--*/

#include "precomp.h"

IMPLEMENT_SHIM_BEGIN(StoneAge)
#include "ShimHookMacro.h"

APIHOOK_ENUM_BEGIN
    APIHOOK_ENUM_ENTRY(RegisterClassExA) 
APIHOOK_ENUM_END

/*++

 Set the WndProc to DefWndProc if it's NULL.

--*/

ATOM 
APIHOOK(RegisterClassExA)(
    CONST WNDCLASSEXA *lpwcx  // class data
    )
{
    if (!(lpwcx->lpfnWndProc)) {
        WNDCLASSEXA wcNewWndClassEx = *lpwcx;
        
        LOGN(eDbgLevelError, "[RegisterClassExA] Null WndProc specified - correcting.");

        wcNewWndClassEx.lpfnWndProc = DefWindowProcA;

        return ORIGINAL_API(RegisterClassExA)(&wcNewWndClassEx);
    }
    else
    {
        return ORIGINAL_API(RegisterClassExA)(lpwcx);
    }
}

/*++

 Register hooked functions

--*/

HOOK_BEGIN
    APIHOOK_ENTRY(USER32.DLL, RegisterClassExA)        
HOOK_END

IMPLEMENT_SHIM_END
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\appcompat\shims\specific\suda2000.cpp ===
/*++

 Copyright (c) 2001 Microsoft Corporation

 Module Name:

    Suda2000.cpp

 Abstract:

    Call to GetTempPathA is not getting enough buffer and it is returning some 
    garbage value, so GetTempFileNameA fails. This hooked API, GetTempPathA 
    returns a constant string "%temp%". GetTempFileNameA expands the environment 
    variable ("%temp%") and returns a valid path name.

 History:

    06/15/2001  mamathas   Created
 
--*/

#include "precomp.h"

IMPLEMENT_SHIM_BEGIN(Suda2000)
#include "ShimHookMacro.h"

APIHOOK_ENUM_BEGIN
    APIHOOK_ENUM_ENTRY(GetTempPathA) 
	APIHOOK_ENUM_ENTRY(GetTempFileNameA) 
APIHOOK_ENUM_END

/*++

 This stub function intercepts all calls to GetTempPathA and sets lpBuffer[out] 
 with a constant string "%temp%" and returns the length.
 
--*/

DWORD
APIHOOK(GetTempPathA)(
    DWORD nBufferLength,
    LPSTR lpBuffer
    )
{
	LOGN(eDbgLevelError,
        "GetTempPathA: Returns invalid Temp Path (%S)\n Changed to %tmp%", lpBuffer);

    _tcscpy(lpBuffer, "%temp%");
    
    return 6; // returns the length of "%temp%"
}

/*++

 This stub function intercepts all calls to GetTempFileNameA and sets lpPathName 
 with valid path and then calls the original API.
  
--*/

UINT
APIHOOK(GetTempFileNameA)(
    LPCTSTR lpPathName,      // directory name
    LPCTSTR lpPrefixString,  // file name prefix
    UINT uUnique,            // integer for use in creating the temporary file name
    LPTSTR lpTempFileName    // file name buffer
    )
{
    CHAR szDestinationString[MAX_PATH];
    ZeroMemory(szDestinationString, MAX_PATH);

    ExpandEnvironmentStringsA((LPCSTR)lpPathName, (LPSTR)szDestinationString,  MAX_PATH);

    LOGN(eDbgLevelInfo,
         "ExpandEnvironmentStringsA: Returned the value of environment variable, \"%temp%\" =  (%S) ", szDestinationString);
  	
    return ORIGINAL_API(GetTempFileNameA)((LPCSTR)szDestinationString, (LPCSTR)lpPrefixString,uUnique,(LPSTR)lpTempFileName);
}

/*++

 Register hooked functions

--*/

HOOK_BEGIN
    APIHOOK_ENTRY(KERNEL32.DLL, GetTempPathA)
	APIHOOK_ENTRY(KERNEL32.DLL, GetTempFileNameA)
HOOK_END

IMPLEMENT_SHIM_END
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\appcompat\shims\specific\summoner.cpp ===
/*++

 Copyright (c) 2001 Microsoft Corporation

 Module Name:

	Summoner.cpp

 Abstract:

    They don't correctly detect 3DFX Voodoo cards. This fix changes the driver 
	name from 3dfx to something else.

 Notes:

    This is an app specific shim.

 History:

    05/22/2001 linstev  Created

--*/

#include "precomp.h"

IMPLEMENT_SHIM_BEGIN(Summoner)
#include "ShimHookMacro.h"
#include "LegalStr.h"

APIHOOK_ENUM_BEGIN
    APIHOOK_ENUM_ENTRY_DIRECTX_COMSERVER()
APIHOOK_ENUM_END

IMPLEMENT_DIRECTX_COMSERVER_HOOKS()

/*++

 Change the driver name for GetDeviceIdentifier

--*/

HRESULT 
COMHOOK(IDirectDraw7, GetDeviceIdentifier)(
    PVOID pThis, 
    LPDDDEVICEIDENTIFIER2 lpDeviceIdentifier,
	UINT dwFlags
	)
{
    HRESULT hReturn;
    
    _pfn_IDirectDraw7_GetDeviceIdentifier pfnOld = 
        ORIGINAL_COM(IDirectDraw7, GetDeviceIdentifier, pThis);

    if (SUCCEEDED(hReturn = (*pfnOld)(pThis, lpDeviceIdentifier, dwFlags))) {
		//
		// Check the driver name
		//
		if (_stricmp(lpDeviceIdentifier->szDriver, "3dfxvs.dll") == 0) {
			//
			// This app doesn't like 3dfx for some reason
			//
			strcpy(lpDeviceIdentifier->szDriver, "temp.dll");
		}
    }

    return hReturn;
}
   
/*++

 Register hooked functions

--*/

HOOK_BEGIN
    APIHOOK_ENTRY_DIRECTX_COMSERVER()
    COMHOOK_ENTRY(DirectDraw, IDirectDraw7, GetDeviceIdentifier, 27)
HOOK_END

IMPLEMENT_SHIM_END
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\appcompat\shims\specific\superbike.cpp ===
/*++

 Copyright (c) 2000 Microsoft Corporation

 Module Name:

    SuperBike.cpp

 Abstract:

    The application attempts to convert the path to the executable into the directory
    containing the executable by replacing the last \ in the path with NULL.
    Unfortunately, they start not at the end of the string, but at the max length
    of the string.  On Win9x the extra memory doesn't (coincidentally) have a \,
    so the proper string is passed as the CWD to CreateProcessA.  On Whistler,
    the extra memory contains a \ so they end up changing nothing.


 History:

    10/26/2000  robkenny    Created
    03/13/2001  robkenny    Converted to CString

--*/

#include "precomp.h"

IMPLEMENT_SHIM_BEGIN(SuperBike)
#include "ShimHookMacro.h"

APIHOOK_ENUM_BEGIN
    APIHOOK_ENUM_ENTRY(CreateProcessA) 
APIHOOK_ENUM_END

/*++

 Make sure lpCurrentDirectory points to a directory, not an executable

--*/

BOOL
APIHOOK(CreateProcessA)(
    LPCSTR lpApplicationName,
    LPSTR lpCommandLine,
    LPSECURITY_ATTRIBUTES lpProcessAttributes,
    LPSECURITY_ATTRIBUTES lpThreadAttributes,
    BOOL bInheritHandles,
    DWORD dwCreationFlags,
    LPVOID lpEnvironment,
    LPCSTR lpCurrentDirectory,
    LPSTARTUPINFOA lpStartupInfo,
    LPPROCESS_INFORMATION lpProcessInformation
    )
{
    CSTRING_TRY
    {
        CString csDir(lpCurrentDirectory);
        char * duplicate = NULL;

        if (!csDir.IsEmpty())
        {
            DWORD dwFileAttr = GetFileAttributesW(csDir);
            if (dwFileAttr != -1 &&                             // Doesn't exist
                ( ! (FILE_ATTRIBUTE_DIRECTORY & dwFileAttr)))   // Is not a directory
            {
                csDir.StripPath();
            }
            BOOL bStat = ORIGINAL_API(CreateProcessA)(
                        lpApplicationName,
                        lpCommandLine,
                        lpProcessAttributes,
                        lpThreadAttributes,
                        bInheritHandles,
                        dwCreationFlags,
                        lpEnvironment,
                        csDir.GetAnsiNIE(), // our corrected value
                        lpStartupInfo,
                        lpProcessInformation);

            return bStat;
            
        }
    }
    CSTRING_CATCH
    {
        // Do nothing
    }

    BOOL bStat = ORIGINAL_API(CreateProcessA)(
        lpApplicationName,
        lpCommandLine,
        lpProcessAttributes,
        lpThreadAttributes,
        bInheritHandles,
        dwCreationFlags,
        lpEnvironment,
        lpCurrentDirectory,
        lpStartupInfo,
        lpProcessInformation);
    
    return bStat;
}


/*++

 Register hooked functions

--*/

HOOK_BEGIN

    APIHOOK_ENTRY(KERNEL32.DLL, CreateProcessA)

HOOK_END

IMPLEMENT_SHIM_END
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\appcompat\shims\specific\superchix76.cpp ===
/*++

 Copyright (c) 1999 Microsoft Corporation

 Module Name:

    SuperChix76.cpp

 Abstract:

    Hook LoadLibrary and calls GetDeviceIdentifier which initializes wintrust. 
    
    This fixes the problem whereby the app will hang if they call 
    GetDeviceIdentifier from within a DllMain - which is an app bug.

 Notes:

    This is an app specific shim.

 History:

    10/22/2000 linstev  Created

--*/

#include "precomp.h"

// This module has been given an official blessing to use the str routines.
#include "LegalStr.h"

IMPLEMENT_SHIM_BEGIN(SuperChix76)
#include "ShimHookMacro.h"

APIHOOK_ENUM_BEGIN
    APIHOOK_ENUM_ENTRY(LoadLibraryA) 
APIHOOK_ENUM_END

/*++

 Hook LoadLibrary and detect their dll.

--*/

HINSTANCE 
APIHOOK(LoadLibraryA)(
    LPCSTR lpLibFileName   
    )
{
    if (stristr(lpLibFileName, "did3d"))
    {
        LPDIRECTDRAW g_pDD;
        LPDIRECTDRAW7 g_pDD7;
    
        if (0 == DirectDrawCreate(NULL, &g_pDD, NULL))
        {
            if (0 == g_pDD->QueryInterface(IID_IDirectDraw7, (void **)&g_pDD7))
            {
                DDDEVICEIDENTIFIER2 devid;
                DWORD dwBlank[16];  // GetDeviceIdentifier writes passed it's allocation
                g_pDD7->GetDeviceIdentifier(&devid, 0);
                g_pDD7->Release();
            }
            g_pDD->Release();
        }
       
    }

    return ORIGINAL_API(LoadLibraryA)(lpLibFileName);
}
 
/*++

 Register hooked functions

--*/

HOOK_BEGIN

    APIHOOK_ENTRY(KERNEL32.DLL, LoadLibraryA)

HOOK_END

IMPLEMENT_SHIM_END
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\appcompat\shims\specific\timeslips.cpp ===
/*++

 Copyright (c) 2000 Microsoft Corporation

 Module Name:

    TimeSlip.cpp

 Abstract:

    Convert the command line to use short path names for both the app and the first (and only) argument.
    
    Example:
    C:\program files\accessories\wordpad.exe c:\program files\some app\some data.txt
    C:\Progra~1\access~1\wordpad.exe C:\Progra~1\someap~1\someda~1.txt

 Created:

    01/23/2001  robkenny    Created
    03/13/2001  robkenny    Converted to CString


--*/

#include "precomp.h"

IMPLEMENT_SHIM_BEGIN(TimeSlips)
#include "ShimHookMacro.h"

APIHOOK_ENUM_BEGIN
    APIHOOK_ENUM_ENTRY(GetCommandLineA)
APIHOOK_ENUM_END

char * g_lpCommandLine = NULL;

/*++

 Convert the application name to the short path to remove any spaces.

--*/

LPSTR 
APIHOOK(GetCommandLineA)(
    void
    )
{
    if (g_lpCommandLine == NULL)
    {
        LPSTR lpszOldCmdLine = ORIGINAL_API(GetCommandLineA)();
        AppAndCommandLine  appCmdLine(NULL, lpszOldCmdLine);

        CString csArg1 = appCmdLine.GetCommandlineNoAppName();
        csArg1.GetShortPathNameW();

        CString csCL = appCmdLine.GetApplicationName();
        csCL.GetShortPathNameW();
        csCL += L" ";
        csCL += csArg1;

        if (csCL.IsEmpty())
        {
            // We didn't change the CL, use the system value.
            g_lpCommandLine = lpszOldCmdLine;
        }
        else
        {
            g_lpCommandLine = csCL.ReleaseAnsi();

            LOGN(
                eDbgLevelError,
                "[GetCommandLineA] Changed \"%s\" to \"%s\".",
                lpszOldCmdLine, g_lpCommandLine);
        }
    }

    return g_lpCommandLine;
}


/*++

 Register hooked functions

--*/

HOOK_BEGIN

    APIHOOK_ENTRY(KERNEL32.DLL, GetCommandLineA)

HOOK_END


IMPLEMENT_SHIM_END
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\appcompat\shims\specific\threedjungletrain.cpp ===
/*++

 Copyright (c) 2000 Microsoft Corporation

 Module Name:
    
    ThreeDJungleTrain.cpp

 Abstract:

    ThreedJungleTrain created a new DirectSound object every time
    it entered the "3D Train Ride" part of the game, and destroyed
    the object every time it went to a "2D interior" part.  It was
    keeping and using an old pointer to the first DirectSound object
    it ever created even after it was destroyed.  It was only luck that
    Win9x would continue to allocate new objects in the same place that
    allowed the game to work.  This shim never allows the release of
    that first object and then continues to hand back pointers to the
    first object when new objects are requested so that the old pointer
    the app uses always points to a (the) valid DirectSound object.

 History:

    08/09/2000 t-adams Created

--*/

#include "precomp.h"

IMPLEMENT_SHIM_BEGIN(ThreeDJungleTrain)
#include "ShimHookMacro.h"

APIHOOK_ENUM_BEGIN
APIHOOK_ENUM_ENTRY(DirectSoundCreate) 
APIHOOK_ENUM_END


// Pointer to the first DirectSound object created.
LPDIRECTSOUND g_pDS = NULL;

/*++

Hook DirectSoundCreate to remeber the first DS object created and afterwards
return a pointer to that object when new DS objects are requested.

--*/
HRESULT
APIHOOK(DirectSoundCreate)(
    LPCGUID lpcGuid, 
    LPDIRECTSOUND *ppDS, 
    LPUNKNOWN pUnkOuter)
{
    HRESULT hRet = DS_OK;

    // Check to see if we have an old DS yet.
    if( NULL == g_pDS ) {
        // If not, then get a new DS 
        hRet = ORIGINAL_API(DirectSoundCreate)(lpcGuid, ppDS, pUnkOuter);

        if ( DS_OK == hRet )
        {
            HookObject(
                NULL, 
                IID_IDirectSound, 
                (PVOID*)ppDS, 
                NULL, 
                FALSE);
            g_pDS = *ppDS;
        }

        goto exit;
    
    } else {
        // If so, then give back the old DS
        *ppDS = g_pDS;
        goto exit;
    }
    
exit:        
    return hRet;
}

/*++

Hook IDirectSound_Release so DirectSound object isn't released.

--*/
HRESULT 
COMHOOK(IDirectSound, Release)(
    PVOID pThis)
{
    // Don't release.
    return 0;
}

/*++

 Release global DirectSound object.

--*/
BOOL
NOTIFY_FUNCTION(
    DWORD fdwReason)
{
    if (fdwReason == DLL_PROCESS_DETACH) {
        if (NULL != g_pDS) {
            ORIGINAL_COM(IDirectSound, Release, g_pDS)(g_pDS);
        }
    }

    return TRUE;
}

/*++

 Register hooked functions

--*/

HOOK_BEGIN

    APIHOOK_ENTRY(DSOUND.DLL, DirectSoundCreate)

    COMHOOK_ENTRY(DirectSound, IDirectSound, Release, 2)

    CALL_NOTIFY_FUNCTION

HOOK_END

IMPLEMENT_SHIM_END
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\appcompat\shims\specific\taskbarandstartmenuproperty.cpp ===
/*++

 Copyright (c) 2000-2001 Microsoft Corporation

 Module Name:

   TaskbarAndStartMenuProperty.cpp

 Abstract:

   Show Taskbar and Start Menu Properties dialog.

   This is originally for Hebrew App "Itzrubal Pro" that uses full screen and hide taskbar.
   The App launch always causes Taskbar and Start Menu Properties dialog pop up.
   When the dialog pop up on top of App during app loading, the App causes hung up.
   If the dialog exist prior to App launch, the dialog lose focus and App loaded successfully.

 History:

    07/13/2001  hioh     Created

--*/

#include "precomp.h"

IMPLEMENT_SHIM_BEGIN(TaskbarAndStartMenuProperty)
#include "ShimHookMacro.h"

//
// No APIs
//
APIHOOK_ENUM_BEGIN
APIHOOK_ENUM_END

/*++

 Run Taskbar and Start Menu
 
--*/

BOOL
NOTIFY_FUNCTION(
    DWORD fdwReason)
{
    if (fdwReason == SHIM_STATIC_DLLS_INITIALIZED)
    {
        WCHAR               szCommandLine[] = L"rundll32.exe shell32.dll,Options_RunDLL 1";
        WCHAR               szCurrentDirectry[MAX_PATH];
        STARTUPINFO         StartupInfo;
        PROCESS_INFORMATION ProcessInformation;

        GetCurrentDirectory(sizeof(szCurrentDirectry), szCurrentDirectry);

        StartupInfo.cb = sizeof(STARTUPINFO);
        StartupInfo.lpReserved = NULL;
        StartupInfo.lpDesktop = NULL;
        StartupInfo.lpTitle = NULL;
        StartupInfo.dwFlags = 0;
        StartupInfo.cbReserved2 = 0;
        StartupInfo.lpReserved2 = NULL;

        CreateProcess(
            NULL,                   // name of executable module
            szCommandLine,          // command line string
            NULL,                   // SD
            NULL,                   // SD
            FALSE,                  // handle inheritance option
            CREATE_NEW_CONSOLE | CREATE_UNICODE_ENVIRONMENT | CREATE_DEFAULT_ERROR_MODE,
                                    // creation flags
            NULL,                   // new environment block
            szCurrentDirectry,      // current directory name
            &StartupInfo,           // startup information
            &ProcessInformation     // process information
            );
    }
    return TRUE;
}

/*++

 Register hooked functions

--*/

HOOK_BEGIN

    CALL_NOTIFY_FUNCTION

HOOK_END

IMPLEMENT_SHIM_END
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\appcompat\shims\specific\tonkaconstruction.cpp ===
/*++

 Copyright (c) 1999 Microsoft Corporation

 Module Name:

    TonkaConstruction.cpp

 Abstract:

    Workaround for GDI behavior difference when bltting palettized bitmaps. On 
    Win9x GDI first looked at the current index for a color match when building 
    a lookup table, but on NT, it simply searches from the beginning. This 
    breaks palette animation. The fix is to make sure that the entries that are 
    animated are different from all the others.
    
 Notes:

    This is an app specific shim.

 History:

    12/02/2001 linstev  Created

--*/

#include "precomp.h"

IMPLEMENT_SHIM_BEGIN(TonkaConstruction)
#include "ShimHookMacro.h"

APIHOOK_ENUM_BEGIN
    APIHOOK_ENUM_ENTRY(CreatePalette) 
APIHOOK_ENUM_END

/*++

 Make sure index 10->15 are different from all other entries.

--*/

HPALETTE
APIHOOK(CreatePalette)(
    CONST LOGPALETTE *lplgpl    
    )
{
Restart:
    for (int i=10; i<=15; i++) {
        LPDWORD p1 = (DWORD *)&lplgpl->palPalEntry[i];
        for (int j=16; j<=255; j++) {
            LPDWORD p2 = (DWORD *)&lplgpl->palPalEntry[j]; 

            if (*p1 == *p2) {
                //
                // Entry is the same, so make it different
                //
                *p1 = *p1-1;
                goto Restart;
            }
        }
    }
    
    return ORIGINAL_API(CreatePalette)(lplgpl);
}
   
/*++

 Register hooked functions

--*/

HOOK_BEGIN
    APIHOOK_ENTRY(GDI32.DLL, CreatePalette)
HOOK_END

IMPLEMENT_SHIM_END
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\appcompat\shims\specific\sysadmiral.cpp ===
/*++

 Copyright (c) 2000 Microsoft Corporation

 Module Name:

    SysAdmiral.cpp

 Abstract:

    Application's service control routine does not properly restore the stack 
    when returning.

 History:

    10/22/2001  robkenny    Created

--*/

#include "precomp.h"

IMPLEMENT_SHIM_BEGIN(SysAdmiral)
#include "ShimHookMacro.h"

APIHOOK_ENUM_BEGIN
    APIHOOK_ENUM_ENTRY(StartServiceCtrlDispatcherA)
APIHOOK_ENUM_END

typedef BOOL (* _pfn_StartServiceCtrlDispatcherA)(CONST LPSERVICE_TABLE_ENTRYA lpServiceTable);

/*++

 0x12345678 is replaced with the original service control routine's address

--*/

__declspec(naked)
void 
Stub()
{
    __asm
    {
        // save the current stack pointer in ESI
        push    esi
        mov     esi, esp

        mov     eax, 0x12345678

        // push the arguments to the routine
        push    [esi+0xc]
        push    [esi+0x8]

        // call the routine
        call    eax

        // Restore the stack to its value before the routine.
        mov     esp, esi
        pop     esi

        ret     0x8
    }
}

#define Stub_OrigApi_Offset     0x4
#define STUB_SIZE               0x20

/*++

 Create an in-memory routine to save and restore the stack.

 This is used rather than a subroutine because we cannot pass any parameters 
 to the routine and it needs to know the address of the original service 
 routine.  A subroutine would have to use a global pointer to the service 
 routine, limiting this shim to handling only a *single* service routine.  

--*/

LPSERVICE_MAIN_FUNCTIONA
BuildStackSaver(LPSERVICE_MAIN_FUNCTIONA lpServiceProc)
{
    // Create the stub
    LPBYTE pStub = (LPBYTE) VirtualAlloc(
        0, 
        STUB_SIZE,
        MEM_COMMIT, 
        PAGE_EXECUTE_READWRITE);

    if (!pStub)
    {
        DPFN( eDbgLevelError, "Could not allocate memory for stub");
        return NULL;
    }         

    // Copy the template code into the memory.
    MoveMemory(pStub, Stub, STUB_SIZE);

    // Replace the place holding function pointer
    DWORD_PTR * origApi = (DWORD_PTR *)(pStub + Stub_OrigApi_Offset);
    *origApi = (DWORD_PTR)lpServiceProc;

    return (LPSERVICE_MAIN_FUNCTIONA)pStub;
}

/*++

 Application's service routine does not properly restore the stack when returning.

--*/

BOOL
APIHOOK(StartServiceCtrlDispatcherA)(
    CONST LPSERVICE_TABLE_ENTRYA lpServiceTable   // service table
    )
{
    SERVICE_TABLE_ENTRYA myServiceTable = *lpServiceTable;

    //
    // Create our in-memory stack restoring functiono
    //

    myServiceTable.lpServiceProc = BuildStackSaver(lpServiceTable->lpServiceProc);
    if (myServiceTable.lpServiceProc)
    {
        return ORIGINAL_API(StartServiceCtrlDispatcherA)(&myServiceTable);
    }
    else
    {
        return FALSE;
    }
}

/*++

 Register hooked functions

--*/

HOOK_BEGIN
    APIHOOK_ENTRY(ADVAPI32.DLL, StartServiceCtrlDispatcherA)
HOOK_END

IMPLEMENT_SHIM_END
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\appcompat\shims\specific\twinssensodyssey.cpp ===
/*++

 Copyright (c) 2000 Microsoft Corporation

 Module Name:

    TwinssensOdyssey.cpp

 Abstract:

    Return 0x347 when GetProcessorSpeed is called.

 Notes:

    This is an app specific shim.

 History:

    12/30/1999 a-vales  Created

--*/

#include "precomp.h"

IMPLEMENT_SHIM_BEGIN(TwinssensOdyssey)
#include "ShimHookMacro.h"

APIHOOK_ENUM_BEGIN
    APIHOOK_ENUM_ENTRY(GetProcessorSpeed) 
APIHOOK_ENUM_END

/*++

 Return 0x347 when GetProcessorSpeed is called.

--*/

int 
APIHOOK(GetProcessorSpeed)()
{
    return 0x347;
}

/*++

 Register hooked functions

--*/


HOOK_BEGIN

    APIHOOK_ENTRY(GETINFO.DLL, GetProcessorSpeed)

HOOK_END

IMPLEMENT_SHIM_END
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\appcompat\shims\specific\treasurecove.cpp ===
/*++

 Copyright (c) 2000 Microsoft Corporation

 Module Name:

    TreasureCove.cpp

 Abstract:

    This SHIM hooks _lopen and fakes the opening of the file when the file is 
    "midimap.cfg".

 Notes:

    This is an app specific shim.

 History:

    12/14/00 prashkud  Created

--*/

#include "precomp.h"

// This module has been given an official blessing to use the str routines.
#include "LegalStr.h"

IMPLEMENT_SHIM_BEGIN(TreasureCove)
#include "ShimHookMacro.h"

APIHOOK_ENUM_BEGIN
    APIHOOK_ENUM_ENTRY(_lopen)
APIHOOK_ENUM_END

/*++

 App requires this file to exist.

--*/

HFILE
APIHOOK(_lopen)(
    LPCSTR lpPathName,
    int iReadWrite
    )
{
    if (stristr(lpPathName, "midimap.cfg"))
    {
        return (HFILE)1;
    }
    else
    {
        return ORIGINAL_API(_lopen)(lpPathName, iReadWrite);
    }
}

/*++

 Register hooked functions

--*/

HOOK_BEGIN
    APIHOOK_ENTRY(KERNEL32.DLL,_lopen)
HOOK_END

IMPLEMENT_SHIM_END
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\appcompat\shims\specific\turkeyhunter.cpp ===
/*++

 Copyright (c) 1999 Microsoft Corporation

 Module Name:

    TurkeyHunter.cpp

 Abstract:

    In Win9x, IDirectDraw::GetDC simply locks the surface and creates a DC 
    around it via internal GDI calls. On NT, GDI supports DCs obtained from 
    DirectDraw surfaces. 

    Some games, like Turkey Hunter, use Surface::Unlock to get usage of the 
    surface back, instead of Surface::ReleaseDC. Ordinarily we could simply 
    make the unlock call the DirectDraw ReleaseDC, except that they continue 
    using the DC after they've unlocked the surface.

 Notes:

    This is a general purpose hack.

 History:

    01/20/2000 linstev  Created

--*/

#include "precomp.h"

IMPLEMENT_SHIM_BEGIN(TurkeyHunter)
#include "ShimHookMacro.h"

APIHOOK_ENUM_BEGIN
    APIHOOK_ENUM_ENTRY_DIRECTX_COMSERVER()
APIHOOK_ENUM_END

IMPLEMENT_DIRECTX_COMSERVER_HOOKS()

// Link list of open DCs
struct DC
{
    DC *next;
    HDC hdc;
    HBITMAP hbmp;
    DWORD dwWidth, dwHeight;
    LPDIRECTDRAWSURFACE lpDDSurface;
    BOOL bBad;
};
DC *g_DCList = NULL;

HRESULT 
COMHOOK(IDirectDrawSurface, ReleaseDC)(
    LPDIRECTDRAWSURFACE lpDDSurface, 
    HDC hDC);

/*++

 Hook create surface so we can be sure we're being called.

--*/

HRESULT 
COMHOOK(IDirectDraw, CreateSurface)(
    PVOID pThis, 
    LPDDSURFACEDESC lpDDSurfaceDesc, 
    LPDIRECTDRAWSURFACE* lplpDDSurface, 
    IUnknown* pUnkOuter 
    )
{
    HRESULT hReturn;
    
    _pfn_IDirectDraw_CreateSurface pfnOld = 
        ORIGINAL_COM(IDirectDraw, CreateSurface, pThis);

    if (SUCCEEDED(hReturn = (*pfnOld)(
            pThis, 
            lpDDSurfaceDesc, 
            lplpDDSurface, 
            pUnkOuter)))
    {
        HookObject(
            NULL, 
            IID_IDirectDrawSurface, 
            (PVOID*)lplpDDSurface, 
            NULL, 
            FALSE);
    }

    return hReturn;
}

/*++

 Hook create surface so we can be sure we're being called.

--*/

HRESULT 
COMHOOK(IDirectDraw2, CreateSurface)(
    PVOID pThis, 
    LPDDSURFACEDESC lpDDSurfaceDesc, 
    LPDIRECTDRAWSURFACE* lplpDDSurface, 
    IUnknown* pUnkOuter 
    )
{
    HRESULT hReturn;
    
    _pfn_IDirectDraw2_CreateSurface pfnOld = 
        ORIGINAL_COM(IDirectDraw2, CreateSurface, pThis);

    if (SUCCEEDED(hReturn = (*pfnOld)(
            pThis, 
            lpDDSurfaceDesc, 
            lplpDDSurface, 
            pUnkOuter)))
    {
        HookObject(
            NULL, 
            IID_IDirectDrawSurface, 
            (PVOID*)lplpDDSurface, 
            NULL, 
            FALSE);
    }

    return hReturn;
}

/*++

 Fake a DC - or rather produce a normal GDI DC that doesn't have the surface
 memory backing it.
 
--*/

HRESULT
COMHOOK(IDirectDrawSurface, GetDC)(
    LPDIRECTDRAWSURFACE lpDDSurface,
    HDC FAR *lphDC
    )
{
    HRESULT hReturn = DDERR_GENERIC;
    _pfn_IDirectDrawSurface_ReleaseDC pfnOldReleaseDC = NULL;
    _pfn_IDirectDrawSurface_GetDC pfnOld = NULL;
    DDSURFACEDESC ddsd = {sizeof(DDSURFACEDESC)};
    HDC hdc = 0;
    HBITMAP hbmp = 0;
    HGDIOBJ hOld = 0;
    DC *pdc = NULL;

    if (!lphDC || !lpDDSurface)
    {
        DPFN( eDbgLevelError, "Invalid parameters");
        goto Exit;
    }

    // Original GetDC
    pfnOld = ORIGINAL_COM(IDirectDrawSurface, GetDC, (LPVOID) lpDDSurface);

    if (!pfnOld)
    {
        DPFN( eDbgLevelError, "Old GetDC not found");
        goto Exit;
    }
    
    if (FAILED(hReturn = (*pfnOld)(
            lpDDSurface, 
            lphDC)))
    {
        DPFN( eDbgLevelError, "IDirectDraw::GetDC Failed");
        goto Exit;
    }

    // We need the surface desc for the surface width and height
    lpDDSurface->GetSurfaceDesc(&ddsd);
    
    // Create a DC to be used by the app
    hdc = CreateCompatibleDC(0);
    if (!hdc)
    {
        DPFN( eDbgLevelError, "CreateDC failed");
        goto Exit;
    }

    // Create the DIB Section
    BITMAPINFO bmi;
    ZeroMemory(&bmi, sizeof(bmi));
    bmi.bmiHeader.biSize     = sizeof(BITMAPINFOHEADER);
    bmi.bmiHeader.biPlanes   = 1;
    bmi.bmiHeader.biBitCount = 24;
    bmi.bmiHeader.biCompression = BI_RGB;
    bmi.bmiHeader.biWidth    = ddsd.dwWidth;
    bmi.bmiHeader.biHeight   = ddsd.dwHeight;
    hbmp = CreateDIBSection(hdc, &bmi, DIB_RGB_COLORS, NULL, NULL, 0);

    if (!hbmp)
    {
        DPFN( eDbgLevelError, "CreateDIBSection failed");
        goto Exit;
    }

    // Select the DIB Section into the DC
    hOld = SelectObject(hdc, hbmp);
    BitBlt(hdc, 0, 0, ddsd.dwWidth, ddsd.dwHeight, *lphDC, 0, 0, SRCCOPY);
    
    // Original ReleaseDC
    pfnOldReleaseDC = 
        ORIGINAL_COM(IDirectDrawSurface, ReleaseDC, (LPVOID) lpDDSurface);

    if (!pfnOldReleaseDC)
    {
        DPFN( eDbgLevelError, "Old ReleaseDC not found");
        goto Exit;
    }
    // Release the DirectDraw DC
    (*pfnOldReleaseDC)(lpDDSurface, *lphDC);
    
    // Return the DC we just created
    *lphDC = hdc;

    // Add this to our DC list
    pdc = (DC *) malloc(sizeof DC);
    if (pdc)
    {
        pdc->next = g_DCList;
        g_DCList = pdc;
        pdc->hdc = hdc;
        pdc->lpDDSurface = lpDDSurface;
        pdc->hbmp = hbmp;
        pdc->dwHeight = ddsd.dwHeight;
        pdc->dwWidth = ddsd.dwWidth;
        pdc->bBad = FALSE;
    }
    else
    {
        DPFN( eDbgLevelError, "Out of memory");
        goto Exit;
    }

    hReturn = DD_OK;

Exit:
    if (hReturn != DD_OK)
    {
        if (hOld && hdc)
        {
            SelectObject(hdc, hOld);
        }

        if (hbmp)
        {
            DeleteObject(hbmp);
        }

        if (hdc)
        {
            DeleteDC(hdc);
        }
    }
    
    return DD_OK;
}

/*++

 ReleaseDC has to copy the data back into the surface.

--*/

HRESULT
COMHOOK(IDirectDrawSurface, ReleaseDC)(
    LPDIRECTDRAWSURFACE lpDDSurface,
    HDC hDC
    )
{
    HRESULT hReturn = DDERR_GENERIC;
    
    // Original ReleaseDC
    _pfn_IDirectDrawSurface_ReleaseDC pfnOld = 
            ORIGINAL_COM(IDirectDrawSurface, ReleaseDC, (LPVOID) lpDDSurface);


    // Run the list to see if we need to do anything
    DC *pdc = g_DCList, *last = NULL;
    while (pdc)
    {
        if ((pdc->lpDDSurface == lpDDSurface) && 
            (pdc->hdc == hDC))
        {
            // Remove it from the list
            if (last)
            {
                last->next = pdc->next;
            }
            else
            {
                g_DCList = pdc->next;
            }
            break;
        }
        last = pdc;
        pdc = pdc->next;
    }

    // We were in the list and someone used Unlock.
    if (pdc && (pdc->bBad))
    {
        // Original GetDC
        _pfn_IDirectDrawSurface_GetDC pfnOldGetDC = 
            ORIGINAL_COM(IDirectDrawSurface, GetDC, (LPVOID)pdc->lpDDSurface);

        // Original ReleaseDC
        _pfn_IDirectDrawSurface_ReleaseDC pfnOldReleaseDC = 
                ORIGINAL_COM(IDirectDrawSurface, ReleaseDC, (LPVOID)pdc->lpDDSurface);

        if (pfnOldGetDC && pfnOldReleaseDC)
        {
            // Copy everything back onto the surface
            HDC hTempDC;
            HGDIOBJ hOld = SelectObject(hDC, pdc->hbmp);
            if (SUCCEEDED((*pfnOldGetDC)(pdc->lpDDSurface, &hTempDC)))
            {
                BitBlt(hTempDC, 0, 0, pdc->dwWidth, pdc->dwHeight, hDC, 0, 0, SRCCOPY);
                (*pfnOldReleaseDC)(pdc->lpDDSurface, hTempDC);
            }
            SelectObject(hDC, hOld);
        
            // Delete the DIB Section
            DeleteObject(pdc->hbmp);

            // Delete the DC
            DeleteDC(hDC);

            hReturn = DD_OK;
        }
    }
    else
    {
        if (pfnOld)
        {
            // Didn't need to fake 
            hReturn = (*pfnOld)(lpDDSurface, hDC);
        }
    }
    
    // Free the list item
    if (pdc) 
    {
        free(pdc);
    }

    return hReturn;
}

/*++
 
 This is where we detect if Surface::Unlock was called after a Surface::GetDC.

--*/

HRESULT 
COMHOOK(IDirectDrawSurface, Unlock)(
    LPDIRECTDRAWSURFACE lpDDSurface,
    LPVOID lpSurfaceData
    )
{
    HRESULT hRet = DDERR_GENERIC;

    // Walk the list to see if we're in it.
    DC *pdc = g_DCList;
    while (pdc)
    {
        if (pdc->lpDDSurface == lpDDSurface)
        {
            pdc->bBad = TRUE;
            break;    
        }
        pdc = pdc->next;
    }

    if (!pdc)
    {
        // Original Unlock
        _pfn_IDirectDrawSurface_Unlock pfnOld = 
                ORIGINAL_COM(IDirectDrawSurface, Unlock, (LPVOID)lpDDSurface);

        if (pfnOld)
        {
            // This is just a normal unlock
            hRet = (*pfnOld)(lpDDSurface, lpSurfaceData);
        }
    }
    else
    {
        // We never really locked in the first place, so no harm done.
        hRet = DD_OK;
    }

    return hRet;
}

/*++

 This is a problem case where they Blt after the Surface::Unlock, but before
 the Surface::ReleaseDC.

--*/

HRESULT 
COMHOOK(IDirectDrawSurface, Blt)(
    LPDIRECTDRAWSURFACE lpDDDestSurface,
    LPRECT lpDestRect,
    LPDIRECTDRAWSURFACE lpDDSrcSurface,
    LPRECT lpSrcRect,
    DWORD dwFlags,
    LPDDBLTFX lpDDBltFX 
    )
{
    HRESULT hRet = DDERR_GENERIC;

    // Original Blt
    _pfn_IDirectDrawSurface_Blt pfnOld = 
        ORIGINAL_COM(IDirectDrawSurface, Blt, (LPVOID) lpDDDestSurface);

    if (!pfnOld)
    {
        return hRet;
    }

    // Are we in the bad state
    DC *pdc = g_DCList;
    while (pdc)
    {
        if (pdc->lpDDSurface == lpDDDestSurface)
        {
            break;    
        }
        pdc = pdc->next;
    }

    if (!pdc)
    {
        return (*pfnOld)(
            lpDDDestSurface,
            lpDestRect,
            lpDDSrcSurface,
            lpSrcRect,
            dwFlags,
            lpDDBltFX);
    }

    // To get here, there must be an outstanding DC on this surface
    
    // Original GetDC 
    _pfn_IDirectDrawSurface_GetDC pfnOldGetDC = 
            ORIGINAL_COM(IDirectDrawSurface, GetDC, (LPVOID) lpDDDestSurface);


    // Original ReleaseDC 
    _pfn_IDirectDrawSurface_ReleaseDC pfnOldReleaseDC = 
            ORIGINAL_COM(IDirectDrawSurface, ReleaseDC, (LPVOID) lpDDDestSurface);

    if (!pfnOldGetDC || !pfnOldReleaseDC)
    {
        return hRet;
    }

    // Copy the DC contents to the surface

    HDC hTempDC;
    HGDIOBJ hOld = SelectObject(pdc->hdc, pdc->hbmp);
    if (SUCCEEDED((*pfnOldGetDC)(lpDDDestSurface, &hTempDC)))
    {
        BitBlt(hTempDC, 0, 0, pdc->dwWidth, pdc->dwHeight, pdc->hdc, 0, 0, SRCCOPY);
        (*pfnOldReleaseDC)(lpDDDestSurface, hTempDC);
    }

    // Do the ddraw Blt
    hRet = (*pfnOld)(
        lpDDDestSurface,
        lpDestRect,
        lpDDSrcSurface,
        lpSrcRect,
        dwFlags,
        lpDDBltFX);

    // Copy stuff back to the DC
    if (SUCCEEDED((*pfnOldGetDC)(lpDDDestSurface, &hTempDC)))
    {
        BitBlt(pdc->hdc, 0, 0, pdc->dwWidth, pdc->dwHeight, hTempDC, 0, 0, SRCCOPY);
        (*pfnOldReleaseDC)(lpDDDestSurface, hTempDC);
    }

    SelectObject(pdc->hdc, hOld);

    return hRet;
}

/*++

 Register hooked functions

--*/

HOOK_BEGIN
    APIHOOK_ENTRY_DIRECTX_COMSERVER()
    COMHOOK_ENTRY(DirectDraw, IDirectDraw, CreateSurface, 6)
    COMHOOK_ENTRY(DirectDraw, IDirectDraw2, CreateSurface, 6)
    COMHOOK_ENTRY(DirectDraw, IDirectDrawSurface, GetDC, 17)
    COMHOOK_ENTRY(DirectDraw, IDirectDrawSurface, ReleaseDC, 26)
    COMHOOK_ENTRY(DirectDraw, IDirectDrawSurface, Unlock, 32)
    COMHOOK_ENTRY(DirectDraw, IDirectDrawSurface, Blt, 5)
HOOK_END

IMPLEMENT_SHIM_END
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\appcompat\shims\specific\ultima9.cpp ===
/*++

 Copyright (c) 2000 Microsoft Corporation

 Module Name:
    
    Ultima9.cpp

 Abstract:

    Clean up bad ddraw CreateSurface caps.

 Notes:

    This is an app specific shim.

 History:

    03/04/2000 linstev  Created

--*/

#include "precomp.h"

IMPLEMENT_SHIM_BEGIN(Ultima9)
#include "ShimHookMacro.h"

APIHOOK_ENUM_BEGIN
    APIHOOK_ENUM_ENTRY_DIRECTX_COMSERVER()
APIHOOK_ENUM_END

IMPLEMENT_DIRECTX_COMSERVER_HOOKS()

VOID FixCaps(LPDDSURFACEDESC lpDDSurfaceDesc)
{
   if (lpDDSurfaceDesc->dwFlags & DDSD_CAPS)
   {
       if ((lpDDSurfaceDesc->ddsCaps.dwCaps & DDSCAPS_COMPLEX) && 
           (lpDDSurfaceDesc->ddsCaps.dwCaps & DDSCAPS_MIPMAP))
       {
            lpDDSurfaceDesc->ddsCaps.dwCaps |= DDSCAPS_TEXTURE;        
       }
   }
}

VOID FixCaps2(LPDDSURFACEDESC2 lpDDSurfaceDesc)
{
   if (lpDDSurfaceDesc->dwFlags & DDSD_CAPS)
   {
       if ((lpDDSurfaceDesc->ddsCaps.dwCaps & DDSCAPS_COMPLEX) && 
           (lpDDSurfaceDesc->ddsCaps.dwCaps & DDSCAPS_MIPMAP))
       {
            lpDDSurfaceDesc->ddsCaps.dwCaps |= DDSCAPS_TEXTURE;        
       }
   }
}

/*++

 Hook create surface and fix parameters

--*/

HRESULT 
COMHOOK(IDirectDraw, CreateSurface)(
    PVOID pThis, 
    LPDDSURFACEDESC lpDDSurfaceDesc, 
    LPDIRECTDRAWSURFACE* lplpDDSurface, 
    IUnknown* pUnkOuter 
    )
{
    FixCaps(lpDDSurfaceDesc);

    _pfn_IDirectDraw_CreateSurface pfnOld = 
        ORIGINAL_COM(IDirectDraw, CreateSurface, pThis);

    HRESULT hRet = (*pfnOld)(
        pThis, 
        lpDDSurfaceDesc, 
        lplpDDSurface, 
        pUnkOuter);

    return hRet;
}

/*++

 Hook create surface and fix parameters

--*/

HRESULT 
COMHOOK(IDirectDraw2, CreateSurface)(
    PVOID pThis, 
    LPDDSURFACEDESC lpDDSurfaceDesc, 
    LPDIRECTDRAWSURFACE* lplpDDSurface, 
    IUnknown* pUnkOuter 
    )
{
    FixCaps(lpDDSurfaceDesc);

    _pfn_IDirectDraw2_CreateSurface pfnOld = 
        ORIGINAL_COM(IDirectDraw2, CreateSurface, pThis);

    HRESULT hRet = (*pfnOld)(
        pThis, 
        lpDDSurfaceDesc, 
        lplpDDSurface, 
        pUnkOuter);

    return hRet;
}

/*++

 Hook create surface and fix parameters

--*/

HRESULT 
COMHOOK(IDirectDraw4, CreateSurface)(
    PVOID pThis, 
    LPDDSURFACEDESC2 lpDDSurfaceDesc, 
    LPDIRECTDRAWSURFACE* lplpDDSurface, 
    IUnknown* pUnkOuter 
    )
{
    FixCaps2(lpDDSurfaceDesc);

    _pfn_IDirectDraw4_CreateSurface pfnOld = 
        ORIGINAL_COM(IDirectDraw4, CreateSurface, pThis);

Retry:
    HRESULT hRet = (*pfnOld)(
        pThis, 
        lpDDSurfaceDesc, 
        lplpDDSurface, 
        pUnkOuter);

    if ((hRet == DDERR_INVALIDCAPS) && (lpDDSurfaceDesc->ddsCaps.dwCaps2))
    {
       lpDDSurfaceDesc->ddsCaps.dwCaps2 = 0;
       lpDDSurfaceDesc->ddsCaps.dwCaps3 = 0;
       lpDDSurfaceDesc->ddsCaps.dwCaps4 = 0;
       goto Retry;
    }

    return hRet;
}

/*++

 Hook create surface and fix parameters

--*/

HRESULT 
COMHOOK(IDirectDraw7, CreateSurface)(
    PVOID pThis, 
    LPDDSURFACEDESC2 lpDDSurfaceDesc, 
    LPDIRECTDRAWSURFACE* lplpDDSurface, 
    IUnknown* pUnkOuter 
    )
{
    FixCaps2(lpDDSurfaceDesc);

    _pfn_IDirectDraw7_CreateSurface pfnOld = 
        ORIGINAL_COM(IDirectDraw7, CreateSurface, pThis);

Retry:
    HRESULT hRet = (*pfnOld)(
        pThis, 
        lpDDSurfaceDesc, 
        lplpDDSurface, 
        pUnkOuter);

    if ((hRet == DDERR_INVALIDCAPS) && (lpDDSurfaceDesc->ddsCaps.dwCaps2))
    {
       lpDDSurfaceDesc->ddsCaps.dwCaps2 = 0;
       lpDDSurfaceDesc->ddsCaps.dwCaps3 = 0;
       lpDDSurfaceDesc->ddsCaps.dwCaps4 = 0;
       goto Retry;
    }

    return hRet;
}

/*++

 Register hooked functions

--*/

HOOK_BEGIN

    APIHOOK_ENTRY_DIRECTX_COMSERVER()
    COMHOOK_ENTRY(DirectDraw, IDirectDraw, CreateSurface, 6)
    COMHOOK_ENTRY(DirectDraw, IDirectDraw2, CreateSurface, 6)
    COMHOOK_ENTRY(DirectDraw, IDirectDraw4, CreateSurface, 6)
    COMHOOK_ENTRY(DirectDraw, IDirectDraw7, CreateSurface, 6)

HOOK_END


IMPLEMENT_SHIM_END
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\appcompat\shims\specific\ultimatesoccermanager.cpp ===
/*++

 Copyright (c) 1999 Microsoft Corporation

 Module Name:

    UltimateSoccerManager.cpp

 Abstract:

    A hack for Ultimate Soccer Manager (Sierra Sports). The game caches a 
    pointer to a ddraw system memory surface. It later uses that pointer even 
    after the surface has been freed.

    This worked on Win9x by blind luck: when they re-create a new surface, it 
    happened to end up in the same system memory as before.

 Notes:

    This is an app specific shim.

 History:

    01/07/2000 linstev  Created

--*/

#include "precomp.h"

IMPLEMENT_SHIM_BEGIN(UltimateSoccerManager)
#include "ShimHookMacro.h"

APIHOOK_ENUM_BEGIN
    APIHOOK_ENUM_ENTRY_DIRECTX_COMSERVER()
APIHOOK_ENUM_END

IMPLEMENT_DIRECTX_COMSERVER_HOOKS()

// Keep a list of cached surfaces
struct SLIST 
{
    struct SLIST *next;
    DDSURFACEDESC ddsd;
    LPDIRECTDRAWSURFACE lpDDSurface;
};
SLIST *g_SList = NULL;

/*++

 Hook create surface so we can return the cached surface if possible.

--*/

HRESULT 
COMHOOK(IDirectDraw, CreateSurface)(
    PVOID pThis, 
    LPDDSURFACEDESC lpDDSurfaceDesc, 
    LPDIRECTDRAWSURFACE* lplpDDSurface, 
    IUnknown* pUnkOuter 
    )
{
    HRESULT hReturn;
    
    // Retrieve the old function
    _pfn_IDirectDraw_CreateSurface pfnOld = 
        ORIGINAL_COM(IDirectDraw, CreateSurface, pThis);

    SLIST *surf = g_SList, *last = NULL;
    while (surf)
    {
        // Check for the same kind of surface. 
        if ((lpDDSurfaceDesc->ddsCaps.dwCaps == surf->ddsd.ddsCaps.dwCaps) &&
            (lpDDSurfaceDesc->dwWidth == surf->ddsd.dwWidth) &&
            (lpDDSurfaceDesc->dwHeight == surf->ddsd.dwHeight))
        {
            *lplpDDSurface = surf->lpDDSurface;

            if (last)
            {
                last->next = surf->next;
            }
            else
            {
                g_SList = surf->next;
            }
            free(surf);

            DPFN( eDbgLevelInfo, "Returning cached surface %08lx\n", *lplpDDSurface);

            return DD_OK;
        }
        surf = surf->next;
    }

    if (SUCCEEDED(hReturn = (*pfnOld)(
        pThis, 
        lpDDSurfaceDesc, 
        lplpDDSurface, 
        pUnkOuter)))
    {
        HookObject(
            NULL, 
            IID_IDirectDrawSurface, 
            (PVOID*)lplpDDSurface, 
            NULL, 
            FALSE);
    }

    return hReturn;
}

/*++

 If it's a system memory surface, go ahead and cache it if we're about to 
 release it anyway.

--*/

ULONG 
COMHOOK(IDirectDrawSurface, Release)(
    LPDIRECTDRAWSURFACE lpDDSurface
    )
{
    lpDDSurface->AddRef();

    // Retrieve the old function
    _pfn_IDirectDrawSurface_Release pfnOld = ORIGINAL_COM(IDirectDrawSurface, Release, (LPVOID) lpDDSurface);

    ULONG uRet = (*pfnOld)(lpDDSurface);

    if (uRet == 1)
    {
        DDSURFACEDESC ddsd = {sizeof(ddsd)};
      
        if (SUCCEEDED(lpDDSurface->GetSurfaceDesc(&ddsd)) &&
            (ddsd.ddsCaps.dwCaps ==
                (DDSCAPS_OFFSCREENPLAIN | DDSCAPS_SYSTEMMEMORY)))
        {
            SLIST *surf = (SLIST *) malloc(sizeof(SLIST));
            surf->next = g_SList;
            MoveMemory(&surf->ddsd, &ddsd, sizeof(ddsd));
            surf->lpDDSurface = lpDDSurface;
            g_SList = surf;

            DPFN( eDbgLevelInfo, "Surface %08lx is being cached\n", lpDDSurface);

            return 0;
        }
    }

    return (*pfnOld)(lpDDSurface);
}

/*++

 Register hooked functions

--*/


HOOK_BEGIN

    APIHOOK_ENTRY_DIRECTX_COMSERVER()
    COMHOOK_ENTRY(DirectDraw, IDirectDraw, CreateSurface, 6)
    COMHOOK_ENTRY(DirectDraw, IDirectDrawSurface, Release, 2)

HOOK_END

IMPLEMENT_SHIM_END
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\appcompat\shims\specific\ultrawincleaner2002.cpp ===
/*++

 Copyright (c) 2002 Microsoft Corporation

 Module Name:

    UltraWinCleaner2002.cpp

 Abstract:

    Ultra WinCleaner 2002 - WinJunk Cleaner removes files under 
    %WINDIR%\Resource\Themes.  This causes themes to fail to load.  Fixed by 
    hiding everything under %WINDIR%\Resource from FindFirstFileA.

 Notes:

    This is a application specific shim.

 History:

    5/13/2002 mikrause  Created

--*/

#include "precomp.h"
#include "StrSafe.h"
#include <nt.h>

IMPLEMENT_SHIM_BEGIN(UltraWinCleaner2002)
#include "ShimHookMacro.h"

APIHOOK_ENUM_BEGIN
    APIHOOK_ENUM_ENTRY(NtQueryDirectoryFile)
APIHOOK_ENUM_END

UNICODE_STRING g_strWinResourceDir;

typedef NTSTATUS (WINAPI *_pfn_NtQueryDirectoryFile)(HANDLE, HANDLE, 
    PIO_APC_ROUTINE, PVOID, PIO_STATUS_BLOCK, PVOID, ULONG, 
    FILE_INFORMATION_CLASS, BOOLEAN, PUNICODE_STRING, BOOLEAN);

NTSTATUS
APIHOOK(NtQueryDirectoryFile)(
    IN HANDLE FileHandle,
    IN HANDLE Event OPTIONAL,
    IN PIO_APC_ROUTINE ApcRoutine OPTIONAL,
    IN PVOID ApcContext OPTIONAL,
    OUT PIO_STATUS_BLOCK IoStatusBlock,
    OUT PVOID FileInformation,
    IN ULONG FileInformationLength,
    IN FILE_INFORMATION_CLASS FileInformationClass,
    IN BOOLEAN ReturnSingleEntry,
    IN PUNICODE_STRING FileName OPTIONAL,
    IN BOOLEAN RestartScan
    )
{
    //
    // If caller wants any async behavior, skip.
    // FileName must be valid.
    //
    if (Event == NULL && ApcRoutine == NULL && ApcContext == NULL && FileName != NULL) {
        // Only trap complete wildcard searches.
        if (lstrcmpW(FileName->Buffer, L"*.*") == 0 || 
            lstrcmpW(FileName->Buffer, L"*") == 0) {

            DWORD dwSize = MAX_PATH * sizeof(WCHAR) + sizeof(OBJECT_NAME_INFORMATION);
            PBYTE pbBuffer = new BYTE[dwSize]; 
            if (pbBuffer) {
                ULONG RetLen;
                ZeroMemory(pbBuffer, dwSize);
                POBJECT_NAME_INFORMATION poni = (POBJECT_NAME_INFORMATION)pbBuffer;           
                // Get the name of the directory
                NTSTATUS status = NtQueryObject(FileHandle, ObjectNameInformation, 
                poni, dwSize, &RetLen);

                // Retry if not enough buffer
                if (status == STATUS_BUFFER_TOO_SMALL) {
                    delete [] pbBuffer;
                    pbBuffer = new BYTE[RetLen];
                    if (pbBuffer) {
                        poni = (POBJECT_NAME_INFORMATION)pbBuffer;
                        status = NtQueryObject(FileHandle, ObjectNameInformation,
                        poni, RetLen, &RetLen);
                    }
                }

                // Check if it is the Windows Resource directory.
                if (NT_SUCCESS(status)) {               
                    if (CompareString(LOCALE_INVARIANT, NORM_IGNORECASE, 
                        poni->Name.Buffer, poni->Name.Length / sizeof(WCHAR), 
                        g_strWinResourceDir.Buffer, g_strWinResourceDir.Length / sizeof(WCHAR)) == CSTR_EQUAL) {

                        // Pretend this directory doesn't exist.
                        DPFN(eDbgLevelInfo, "[NtQueryDirectoryFile] Ignoring all file searches in %S",
                            poni->Name.Buffer);
                        delete [] pbBuffer;
                        return STATUS_NO_SUCH_FILE;
                    }
                }
                if (pbBuffer) {
                    delete [] pbBuffer;
                }
            }
        }      
    }

    return ORIGINAL_API(NtQueryDirectoryFile)(FileHandle, Event, ApcRoutine,
        ApcContext, IoStatusBlock, FileInformation, FileInformationLength,
        FileInformationClass, ReturnSingleEntry, FileName, RestartScan);
}

BOOL
NOTIFY_FUNCTION(
    DWORD fdwReason
    )
{
    if (fdwReason == DLL_PROCESS_ATTACH)
    {
        CSTRING_TRY
        {
            // Get the Windows Resource directory (which holds themes)
            CString csWinResourceDir;
            csWinResourceDir.GetWindowsDirectoryW();
            csWinResourceDir.AppendPath(L"Resources");

            //
            // Convert the DOS name like C:\Windows\Resources to
            // \Device\HarddiskVolume0\Windows\Resources which NT likes.
            //        
            CString csWinDrive;
            csWinResourceDir.GetDrivePortion(csWinDrive);
            WCHAR wszBuffer[1024];
            if (QueryDosDeviceW(csWinDrive, wszBuffer, 1024)) {
                csWinResourceDir.Replace(csWinDrive, wszBuffer);
                ZeroMemory(&g_strWinResourceDir, sizeof(g_strWinResourceDir));

                PWSTR wsz = new WCHAR[csWinResourceDir.GetLength()+1];
                if (wsz) {
                    StringCchCopyW(wsz, csWinResourceDir.GetLength() + 1, csWinResourceDir);
                    DPFN(eDbgLevelInfo, "Ignoring all file searches in %S", wsz);
                    RtlInitUnicodeString(&g_strWinResourceDir, wsz);
                } else {
                    return FALSE;
                }
            } else {
                return FALSE;
            }         
        }
        CSTRING_CATCH
        {
            DPFN(eDbgLevelError, "CString exception in NotifyFunc!\n");
            return FALSE;
        }
    }

    return TRUE;
}

HOOK_BEGIN
    CALL_NOTIFY_FUNCTION
    APIHOOK_ENTRY(NTDLL.DLL, NtQueryDirectoryFile)
HOOK_END

IMPLEMENT_SHIM_END
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\appcompat\shims\specific\urbanchaos.cpp ===
/*++

 Copyright (c) 2000 Microsoft Corporation

 Module Name:

    UrbanChaos.cpp

 Abstract:

    The sound system (Miles) uses a very high-resolution timer: 32ms. The app
    has badly designed message loop code. Instead of running everything off the
    loop, they have their movie playing code interspersed with a call to 
    empty the queue. Unfortunately for them, the queue on NT is almost always 
    filled with these timer messages, so their code to keep track of how far
    along their movie is gets starved.

    To fix this we reduce the timer resolution.

 Notes:

    This is an app specific shim.


 History:
        
    10/31/2000 linstev  Created

--*/

#include "precomp.h"

IMPLEMENT_SHIM_BEGIN(UrbanChaos)
#include "ShimHookMacro.h"

APIHOOK_ENUM_BEGIN
    APIHOOK_ENUM_ENTRY(SetTimer) 
APIHOOK_ENUM_END

/*++

 Reduce the timer resolution to a managable level.

--*/

UINT_PTR
APIHOOK(SetTimer)(
    HWND hWnd,              
    UINT nIDEvent,          
    UINT uElapse,           
    TIMERPROC lpTimerFunc   
    )
{
    // Reduce timer resolution
    if (uElapse < 100)
    {
        uElapse = 500;
    }

    return ORIGINAL_API(SetTimer)(hWnd, nIDEvent, uElapse, lpTimerFunc);
}

/*++

 Register hooked functions

--*/

HOOK_BEGIN

    APIHOOK_ENTRY(USER32.DLL, SetTimer)

HOOK_END

IMPLEMENT_SHIM_END
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\appcompat\shims\specific\viperracing.cpp ===
/*++

 Copyright (c) 2000 Microsoft Corporation

 Module Name:

    CheckTAPIVersionParameters.cpp

 Abstract:

    Hooks the call to lineNegotiateAPIVersion so that device 0 doesn't fail 
    causing the application to stop querying devices.

 Notes:
    
    This is an app specific shim. Could potentially be general, but requires
    research.

 History:

    07/17/2000 a-brienw Created

--*/

#include "precomp.h"

IMPLEMENT_SHIM_BEGIN(ViperRacing)
#include "ShimHookMacro.h"

APIHOOK_ENUM_BEGIN
    APIHOOK_ENUM_ENTRY(lineNegotiateAPIVersion)
APIHOOK_ENUM_END

/*++

 Hook lineNegotiateAPIVersion to reverse the order of the devices.

--*/

LONG
APIHOOK(lineNegotiateAPIVersion)(
    HLINEAPP hLineApp,
    DWORD dwDeviceID,
    DWORD dwAPILowVersion,
    DWORD dwAPIHighVersion,
    LPDWORD lpdwAPIVersion,
    LPLINEEXTENSIONID lpExtensionID
    )
{
    if (dwDeviceID == 0) dwDeviceID = 1;
    
    return ORIGINAL_API(lineNegotiateAPIVersion)(
        hLineApp,
        dwDeviceID,
        dwAPILowVersion,
        dwAPIHighVersion,
        lpdwAPIVersion,
        lpExtensionID);
}

/*++

 Register hooked functions

--*/

HOOK_BEGIN
    APIHOOK_ENTRY(TAPI32.DLL, lineNegotiateAPIVersion)
HOOK_END

IMPLEMENT_SHIM_END
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\appcompat\shims\specific\usnf97.cpp ===
/*++

 Copyright (c) 2000 Microsoft Corporation

 Module Name:
    
    USNF97.cpp

 Abstract:

    USNF '97 synchronizes it's video playback with cli/sti combinations. This 
    fails on NT, so we have to make sure they aren't bltting during the 
    refresh. Note that each time a cli/sti is hit, it makes only 1 blt 
    synchronize with the refresh. After the intro has played, cli/sti is no 
    longer used and so the blts don't incur extra overhead.

 Notes:

    This is an app specific shim.

 History:

    02/10/2000 linstev  Created

--*/

#include "precomp.h"

IMPLEMENT_SHIM_BEGIN(USNF97)
#include "ShimHookMacro.h"

APIHOOK_ENUM_BEGIN
    APIHOOK_ENUM_ENTRY_DIRECTX_COMSERVER()
    APIHOOK_ENUM_ENTRY(GetStartupInfoA) 
APIHOOK_ENUM_END

IMPLEMENT_DIRECTX_COMSERVER_HOOKS()

LPDIRECTDRAW g_lpDirectDraw = NULL;
BOOL bFixBlt = FALSE;

/*++

 Hook create surface so we can be sure we're being called.

--*/

HRESULT 
COMHOOK(IDirectDraw, CreateSurface)(
    PVOID pThis, 
    LPDDSURFACEDESC lpDDSurfaceDesc, 
    LPDIRECTDRAWSURFACE* lplpDDSurface, 
    IUnknown* pUnkOuter 
    )
{
    HRESULT hReturn;
    
    _pfn_IDirectDraw_CreateSurface pfnOld = 
        ORIGINAL_COM(IDirectDraw, CreateSurface, pThis);

    if (SUCCEEDED(hReturn = (*pfnOld)(
            pThis, 
            lpDDSurfaceDesc, 
            lplpDDSurface, 
            pUnkOuter)))
    {
        HookObject(
            NULL, 
            IID_IDirectDrawSurface, 
            (PVOID*)lplpDDSurface, 
            NULL, 
            FALSE);
    }

    g_lpDirectDraw = (LPDIRECTDRAW)pThis;

    return hReturn;
}

/*++

 Synchronize the blt with the refresh if a cli/sti has just been called.

--*/

HRESULT 
COMHOOK(IDirectDrawSurface, Blt)(
    LPDIRECTDRAWSURFACE lpDDDestSurface,
    LPRECT lpDestRect,
    LPDIRECTDRAWSURFACE lpDDSrcSurface,
    LPRECT lpSrcRect,
    DWORD dwFlags,
    LPDDBLTFX lpDDBltFX 
    )
{
    // Original Blt
    _pfn_IDirectDrawSurface_Blt pfnOld = ORIGINAL_COM(IDirectDrawSurface, Blt, (LPVOID) lpDDDestSurface);

    if (bFixBlt)
    {
        // Make sure we're in the blank.
        DWORD dwScanLine = 0;
        while (dwScanLine<480)
        {
            g_lpDirectDraw->GetScanLine(&dwScanLine);
        }
        bFixBlt = FALSE;
    }
   
    return (*pfnOld)(
            lpDDDestSurface,
            lpDestRect,
            lpDDSrcSurface,
            lpSrcRect,
            dwFlags,
            lpDDBltFX);
}

/*++

 Custom exception handler to filter the cli/sti instructions.
 Handle out of range idivs.

--*/

LONG 
USNF97_ExceptionFilter(
    struct _EXCEPTION_POINTERS *ExceptionInfo
    )
{
    CONTEXT *lpContext = ExceptionInfo->ContextRecord;
    LONG lRet = EXCEPTION_CONTINUE_SEARCH;

    if ((*((LPBYTE)lpContext->Eip) == 0xFA) ||
        (*((LPBYTE)lpContext->Eip) == 0xFB))
    {
        bFixBlt = TRUE;
        lpContext->Eip++;
        lRet = EXCEPTION_CONTINUE_EXECUTION;
    }
    else if ((*((LPBYTE)lpContext->Eip) == 0xF7) ||     // Handle idiv
             (*((LPBYTE)lpContext->Eip+1) == 0xF7))     // Handle 16 bit idiv
    {
        DPFN( eDbgLevelWarning, "Detected 'idiv' overflow: validating edx:eax");
        lpContext->Edx=0;
        if ((LONG)lpContext->Eax < 0)
        {
            lpContext->Eax = (DWORD)(-(LONG)lpContext->Eax);
        }
        lRet = EXCEPTION_CONTINUE_EXECUTION;
    }

    return lRet;
}

/*++

 Hook the exception handler.

--*/

VOID 
APIHOOK(GetStartupInfoA)( 
    LPSTARTUPINFOA lpStartupInfo   
    )
{
    SetUnhandledExceptionFilter(USNF97_ExceptionFilter);
    ORIGINAL_API(GetStartupInfoA)(lpStartupInfo);
}

/*++

 Register hooked functions

--*/

HOOK_BEGIN

    APIHOOK_ENTRY(KERNEL32.DLL, GetStartupInfoA)

    APIHOOK_ENTRY_DIRECTX_COMSERVER()
    COMHOOK_ENTRY(DirectDraw, IDirectDraw, CreateSurface, 6)
    COMHOOK_ENTRY(DirectDraw, IDirectDrawSurface, Blt, 5)

HOOK_END

IMPLEMENT_SHIM_END
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\appcompat\shims\specific\uninstallshield.cpp ===
/*++
eDbgLevelError
 Copyright (c) 2000 Microsoft Corporation

 Module Name:

    UnInstallShield.cpp

 Abstract:
    
    UnInstallShield has an insidious bug where it calls WaitForSingleObject
    on the HINSTANCE returned by ShellExecute. Since an HINSTANCE is not
    an actual HANDLE, the WaitForSingleObject behaviour was completely random
    and in some cases caused UnInstallShield to hang. The fix is to change
    the HINSTANCE returned from ShellExecute to 0x0BADF00D and then look for
    it being passed in to WaitForSingleObject. If found, WAIT_OBJECT_0 is
    returned immediately to prevent deadlock.
    
 Notes:

    This is an app specific shim.

 History:

    12/04/2000 jdoherty  Created

--*/

#include "precomp.h"

IMPLEMENT_SHIM_BEGIN(UnInstallShield)
#include "ShimHookMacro.h"

APIHOOK_ENUM_BEGIN
    APIHOOK_ENUM_ENTRY(ShellExecuteA)
    APIHOOK_ENUM_ENTRY(ShellExecuteW)
    APIHOOK_ENUM_ENTRY(WaitForSingleObject)
APIHOOK_ENUM_END

/*++

 Hook ShellExecuteA so we can check the return value.

--*/

HINSTANCE
APIHOOK(ShellExecuteA)(
    HWND hwnd, 
    LPSTR lpVerb,
    LPSTR lpFile, 
    LPSTR lpParameters, 
    LPSTR lpDirectory,
    INT nShowCmd
    )
{
    HINSTANCE hRet = ORIGINAL_API(ShellExecuteA)(
                        hwnd,
                        lpVerb,
                        lpFile,
                        lpParameters,
                        lpDirectory,
                        nShowCmd
                        );

    DPFN( eDbgLevelInfo, "[ShellExecuteA] Checking return value for 0x0000002a");
    if (hRet == (HINSTANCE)0x0000002a)
    {
        DPFN( eDbgLevelInfo, "[ShellExecuteA] 0x0000002a found to be return value.  Return 0x0BADF00D");
        //
        //  if the HINSTANCE returned is 0x0000002a then return BAADF00D
        //
        hRet = (HINSTANCE)0x0BADF00D;
    }

    return hRet;
}

/*++

 Hook ShellExecuteW so we can check the return value.

--*/

HINSTANCE
APIHOOK(ShellExecuteW)(
    HWND hwnd, 
    LPWSTR lpVerb,
    LPWSTR lpFile, 
    LPWSTR lpParameters, 
    LPWSTR lpDirectory,
    INT nShowCmd
    )
{
    HINSTANCE hRet = ORIGINAL_API(ShellExecuteW)(
                        hwnd,
                        lpVerb,
                        lpFile,
                        lpParameters,
                        lpDirectory,
                        nShowCmd
                        );
    DPFN( eDbgLevelInfo, "[ShellExecuteW] Checking return value for 0x0000002a");
    if (hRet == (HINSTANCE)0x0000002a)
    {
        DPFN( eDbgLevelInfo, "[ShellExecuteW] 0x0000002a found to be return value.  Return 0x0BADF00D");
        //
        //  if the HINSTANCE returned is 0x0000002a then return BAADF00D
        //
        hRet = (HINSTANCE)0x0BADF00D;
    }

    return hRet;
}

/*++

 Hook WaitForSingleObject to see if we are waiting for the known HINSTANCE.

--*/

DWORD
APIHOOK(WaitForSingleObject)(
  HANDLE hHandle,          
  DWORD dwMilliseconds   
  )
{
    DWORD dRet;
    
    DPFN( eDbgLevelInfo, "[WaitForSingleObject] Checking to see if hHandle waiting on is 0x0000002A");

    if (hHandle == (HANDLE)0x0BADF00D)
    {
        DPFN( eDbgLevelInfo, "[WaitForSingleObject] hHandle waiting on is 0x0000002A, returning WAIT_OBJECT_0");
        //
        //  if the hHandle is 0x0BADF00D then return WAIT_OBJECT_0
        //
        dRet = WAIT_OBJECT_0;
    }
    else
    {
        dRet = ORIGINAL_API(WaitForSingleObject)(
                        hHandle,
                        dwMilliseconds
                        );
    }

    return dRet;
}

/*++

 Register hooked functions

--*/

HOOK_BEGIN
    APIHOOK_ENTRY(SHELL32.DLL, ShellExecuteA)
    APIHOOK_ENTRY(SHELL32.DLL, ShellExecuteW)
    APIHOOK_ENTRY(KERNEL32.DLL, WaitForSingleObject)
HOOK_END

IMPLEMENT_SHIM_END
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\appcompat\shims\specific\viavoice8j.cpp ===
/*++

 Copyright (c) 2002 Microsoft Corporation

 Module Name:

    ViaVoice8J.cpp

 Abstract:

    ViaVoice8J mutes Master and Wave volume on Win XP. Disable mute. ViaVoice8J 
    installs riched20.dll and riched32.dll. These old dll prevent enroll wizard 
    richedit working properly on Win XP. Remove those.

 Notes:

    This is an app specific shim.

 History:

    06/03/2002 hioh     Created

--*/

#include "precomp.h"

IMPLEMENT_SHIM_BEGIN(ViaVoice8J)
#include "ShimHookMacro.h"

typedef MMRESULT (WINAPI *_pfn_mixerSetControlDetails)(HMIXEROBJ hmxobj, LPMIXERCONTROLDETAILS pmxcd, DWORD fdwDetails);

APIHOOK_ENUM_BEGIN
    APIHOOK_ENUM_ENTRY(mixerSetControlDetails) 
APIHOOK_ENUM_END

/*++

 Disregard mute when fdwDetails is 0. 

--*/

MMRESULT
APIHOOK(mixerSetControlDetails)(
    HMIXEROBJ               hmxobj,
    LPMIXERCONTROLDETAILS   pmxcd,
    DWORD                   fdwDetails)
{
    if (fdwDetails == 0) {
        return (0);
    }

    return ORIGINAL_API(mixerSetControlDetails)(hmxobj, pmxcd, fdwDetails);
}

/*++

 Remove installed \bin\riched20.dll & \bin\riched32.dll

--*/

BOOL
NOTIFY_FUNCTION(
    DWORD fdwReason)
{
    if (fdwReason == DLL_PROCESS_DETACH) {

        CSTRING_TRY 
        {
            HKEY hKey;
            WCHAR szRegDir[] = L"SOFTWARE\\IBM\\ViaVoice Runtimes\\RTConfig";

            // Get ViaVoice Registry
            if (ERROR_SUCCESS == RegOpenKeyExW(HKEY_LOCAL_MACHINE, szRegDir, 0, 
                KEY_QUERY_VALUE, &hKey)) {

                WCHAR szRegBin[] = L"bin";
                DWORD dwType;
                WCHAR szDir[MAX_PATH];
                DWORD cbData = sizeof(szDir) * sizeof(WCHAR);

                // Get installed directory
                if (ERROR_SUCCESS == RegQueryValueExW(hKey, szRegBin, NULL, &dwType, 
                    (LPBYTE) szDir, &cbData)) {

                    RegCloseKey(hKey);

                    // Delete problem richedit files
                    CString csDel;
                    csDel = szDir;
                    csDel += L"\\riched20.dll";
                    if (INVALID_FILE_ATTRIBUTES != GetFileAttributesW(csDel)) {
                        // Delete riched20.dll
                        DeleteFileW(csDel);
                    }
                    csDel = szDir;
                    csDel += L"\\riched32.dll";
                    if (INVALID_FILE_ATTRIBUTES != GetFileAttributesW(csDel)) {
                        // Delete riched32.dll
                        DeleteFileW(csDel);
                    }
                }
            }
        }
        CSTRING_CATCH 
        {
            // Do nothing
        }
    }   

    return TRUE;
}

/*++

 Register hooked functions

--*/

HOOK_BEGIN
    CALL_NOTIFY_FUNCTION
    APIHOOK_ENTRY(WINMM.DLL, mixerSetControlDetails)
HOOK_END

IMPLEMENT_SHIM_END
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\appcompat\shims\specific\vjedelta.cpp ===
/*++

 Copyright (c) 2001 Microsoft Corporation

 Module Name:

    VJEDelta.cpp

 Abstract:

    Broken by ACL changes to directories off the root.

 Notes:

    This is an app specific shim.

 History:

    05/31/2001 linstev   Created

--*/

#include "precomp.h"

IMPLEMENT_SHIM_BEGIN(VJEDelta)
#include "ShimHookMacro.h"

APIHOOK_ENUM_BEGIN
    APIHOOK_ENUM_ENTRY(OpenFile) 
APIHOOK_ENUM_END

/*++

 Remove write attributes on OpenFile in the case of failure.

--*/

HFILE
APIHOOK(OpenFile)(
    LPCSTR lpFileName,        
    LPOFSTRUCT lpReOpenBuff,  
    UINT uStyle               
    )
{
    HFILE hRet = ORIGINAL_API(OpenFile)(lpFileName, lpReOpenBuff, uStyle);

    if ((hRet == HFILE_ERROR) && (GetLastError() == ERROR_ACCESS_DENIED)) {
        //
        // Remove write attributes
        // 

        WCHAR *lpName = ToUnicode(lpFileName);

        if (lpName) {
            if (wcsistr(lpName, L"VJED95") && wcsistr(lpName, L".DIC")) {
                //
                // This is a file we care about
                //
                uStyle &= ~(OF_WRITE | OF_READWRITE);
                LOGN(eDbgLevelError, "Removed write attributes from %S", lpName);
                hRet = ORIGINAL_API(OpenFile)(lpFileName, lpReOpenBuff, uStyle);
            }
            free(lpName);
        }
    }

    return hRet;
}

/*++

 Register hooked functions

--*/

HOOK_BEGIN
    APIHOOK_ENTRY(KERNEL32.DLL, OpenFile)
HOOK_END

IMPLEMENT_SHIM_END
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\appcompat\shims\specific\vjedeltasetup.cpp ===
/*++

 Copyright (c) 2001 Microsoft Corporation

 Module Name:

    VJEDeltaSetup.cpp

 Abstract:

    This app' setup program has a MYDLL.DLL, it has memory corruption in it's 
    IsAdmin(). Fixing this by provide a new procedure IsAdmin().
    (Copy/Paste from PSDK)

 History:

    06/12/2001 xiaoz   create

--*/

#include "precomp.h"

//
// app's private Prototype 
//
typedef BOOL (WINAPI *_pfn_IsAdmin)(void);

IMPLEMENT_SHIM_BEGIN(VJEDeltaSetup)
#include "ShimHookMacro.h"

APIHOOK_ENUM_BEGIN
    APIHOOK_ENUM_ENTRY(IsAdmin)
APIHOOK_ENUM_END

/*++

 New function to check whethe currently login as Admin, Copy/Paste from PSDK

--*/

BOOL 
APIHOOK(IsAdmin)(
    void
    )
{
    PSID pSID = NULL;
    SID_IDENTIFIER_AUTHORITY SIDAuth = SECURITY_NT_AUTHORITY;
    BOOL IsMember;
    HANDLE hToken;
    TOKEN_OWNER SIDforOwner;
    BOOL bRet = FALSE;

    //
    // Open a handle to the access token for the calling process.
    //
    if (!OpenProcessToken(GetCurrentProcess(), TOKEN_QUERY | TOKEN_ADJUST_DEFAULT, 
                          &hToken ))
    {
        goto Cleanup;
    }
    //
    // Create a SID for the BUILTIN\Administrators group.
    //
    if (!AllocateAndInitializeSid(&SIDAuth, 2, SECURITY_BUILTIN_DOMAIN_RID, 
                                  DOMAIN_ALIAS_RID_ADMINS, 0, 0, 0, 0, 0, 0, &pSID))
    {
        pSID = NULL;
        goto Cleanup;
    }
    //
    // Check if the administrator group SID is enabled in current process token
    //
    if (!CheckTokenMembership(NULL, pSID, &IsMember))
    {
        goto Cleanup;
    }    
    if (IsMember)
    {
        bRet = TRUE;
    }

Cleanup:
    if (pSID)
    {
        FreeSid(pSID);
    }

    return bRet;

}

/*++

 Register hooked functions

--*/

HOOK_BEGIN
    APIHOOK_ENTRY(MYDLL.DLL, IsAdmin)
HOOK_END

IMPLEMENT_SHIM_END
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\appcompat\shims\specific\webpage6.cpp ===
/*++

 Copyright (c) 2000 Microsoft Corporation

 Module Name:

    WebPage6.cpp

 Abstract:
    
    The app passes in an uninitialized POINT structure in a call to ScreenToClient API.
    The API call fails, however the apps goes on to use the POINT structure
    resulting in an AV. This shim zeroes in the POINT structure passed to the API 
    if the API call fails.
    
 History:

    02/02/2001 a-leelat    Created

--*/

#include "precomp.h"

IMPLEMENT_SHIM_BEGIN(WebPage6)
#include "ShimHookMacro.h"

APIHOOK_ENUM_BEGIN
    APIHOOK_ENUM_ENTRY(ScreenToClient)
APIHOOK_ENUM_END


BOOL APIHOOK(ScreenToClient)(
  HWND hWnd,        // handle to window
  LPPOINT lpPoint   // screen coordinates
)
{

    BOOL bRet;   
 
    //Call the actual API
    bRet = ORIGINAL_API(ScreenToClient)(hWnd,lpPoint);


    //Zero fill the POINT structure
    if ( (bRet == 0) && lpPoint )
    {
        ZeroMemory(lpPoint,sizeof(POINT));
    }

    return bRet;
          
}


/*++

 Register hooked functions

--*/

HOOK_BEGIN

    APIHOOK_ENTRY( USER32.DLL, ScreenToClient)
 
HOOK_END

IMPLEMENT_SHIM_END
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\appcompat\shims\specific\winfaxpro9.cpp ===
/*++

 Copyright (c) 2000 Microsoft Corporation

 Module Name:

    WinFaxPro9.cpp

 Abstract:

    Use QueryServiceStatus instead of ControlService if ControlService is
    called for SERVICE_CONTROL_INTERROGATE.
    
    No idea why this works on NT4.

 Notes:

    This is an app specific shim.

 History:

    02/16/2000 clupu Created

--*/

#include "precomp.h"

IMPLEMENT_SHIM_BEGIN(WinFaxPro9)
#include "ShimHookMacro.h"

APIHOOK_ENUM_BEGIN
    APIHOOK_ENUM_ENTRY(ControlService)
APIHOOK_ENUM_END


/*++

    Use QueryServiceStatus instead of ControlService if ControlService is
    called for SERVICE_CONTROL_INTERROGATE.

--*/

BOOL
APIHOOK(ControlService)(
    SC_HANDLE         hService,
    DWORD             dwControl,
    LPSERVICE_STATUS  lpServiceStatus
    )
{
    if (dwControl == SERVICE_CONTROL_INTERROGATE) {

        DPFN(
            eDbgLevelWarning,
            "[ControlService] calling QueryServiceStatus instead of ControlService.\n");
        
        return QueryServiceStatus(hService, lpServiceStatus);
        
    } else {
        return ORIGINAL_API(ControlService)(
                                hService,
                                dwControl,
                                lpServiceStatus);
    }
}


/*++

 Register hooked functions

--*/

HOOK_BEGIN
    APIHOOK_ENTRY(ADVAPI32.DLL, ControlService)
HOOK_END


IMPLEMENT_SHIM_END
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\appcompat\shims\specific\vsanalyzerserversetup.cpp ===
/*++

 Copyright (c) 2000 Microsoft Corporation

 Module Name:

    VSAnalyzerServerSetup.cpp

 Abstract:

    This fix is for hardening the passwords for
    Visual C++ Analyzer Server Setup.

 Notes:

    This is an app specific shim.

 History:

    02/17/2000 clupu Created

--*/

#include "precomp.h"

IMPLEMENT_SHIM_BEGIN(VSAnalyzerServerSetup)
#include "ShimHookMacro.h"

APIHOOK_ENUM_BEGIN
    APIHOOK_ENUM_ENTRY(NetUserAdd)
    APIHOOK_ENUM_ENTRY(LsaStorePrivateData)
APIHOOK_ENUM_END

#include <lmcons.h>
#include <lmaccess.h>
#include <ntsecapi.h>

static WCHAR gwszPW[LM20_PWLEN] = L"Aa+0";

/*++

    Harden the password requirements

--*/

DWORD
APIHOOK(NetUserAdd)(
    LPCWSTR servername,
    DWORD   level,
    LPBYTE  buf,
    LPDWORD parm_err
    )
{
    NET_API_STATUS Status;
    USER_INFO_2*   puiNew;
    LPWSTR         pwszPSWRD;
    int            nBytes;

    if (level == 2) {

        //
        // Grab the pointer to the buffer as a pointer to USER_INFO_2
        //
        puiNew = (USER_INFO_2*)buf;

        //
        // Get the current password.
        //
        pwszPSWRD = puiNew->usri2_password;

        DPFN(
            eDbgLevelInfo,
            "VSAnalyzerServerSetup.dll, NetUserAdd PW:     \"%ws\".\n",
            pwszPSWRD);

        //
        // Copy the current password to the temp buffer.
        //
        lstrcpyW(gwszPW + 4, pwszPSWRD + 4);

        //
        // Stick in the new password.
        //
        puiNew->usri2_password = gwszPW;

        DPFN(
            eDbgLevelInfo,
            "VSAnalyzerServerSetup.dll, NetUserAdd new PW: \"%ws\".\n",
            gwszPW);
    }

    //
    // Call the original API.
    //
    Status = ORIGINAL_API(NetUserAdd)(
                                servername,
                                level,
                                buf,
                                parm_err);

    if (level == 2) {

        //
        // Restore the password.
        //
        puiNew->usri2_password = pwszPSWRD;
    }

    return Status;
}

/*++

    Harden the password requirements

--*/

NTSTATUS
APIHOOK(LsaStorePrivateData)(
    LSA_HANDLE          PolicyHandle,
    PLSA_UNICODE_STRING KeyName,
    PLSA_UNICODE_STRING PrivateData
    )
{
    NTSTATUS Status;
    LPWSTR   pwszPSWRD;

    //
    // Save the originals.
    //
    pwszPSWRD = PrivateData->Buffer;

    DPFN(
        eDbgLevelInfo,
        "VSAnalyzerServerSetup.dll, LsaStorePrivateData PW:     \"%ws\".\n",
        pwszPSWRD);

    //
    // Copy the current password to the temp buffer.
    //
    lstrcpyW(gwszPW + 4, pwszPSWRD + 4);

    //
    // Stick in the new settings.
    //
    PrivateData->Buffer = gwszPW;

    DPFN(
        eDbgLevelInfo,
        "VSAnalyzerServerSetup.dll, LsaStorePrivateData new PW: \"%ws\".\n",
        gwszPW);

    //
    // Call the original LsaStorePrivateData.
    //
    Status = ORIGINAL_API(LsaStorePrivateData)(
                                PolicyHandle,
                                KeyName,
                                PrivateData);
    //
    // Restore the originals.
    //
    PrivateData->Buffer = pwszPSWRD;

    return Status;
}

/*++

 Register hooked functions

--*/

HOOK_BEGIN

    APIHOOK_ENTRY(NETAPI32.DLL, NetUserAdd)
    APIHOOK_ENTRY(ADVAPI32.DLL, LsaStorePrivateData)

HOOK_END

IMPLEMENT_SHIM_END
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\appcompat\shims\specific\wordperfect9_1.cpp ===
/*++

 Copyright (c) 2000 Microsoft Corporation

 Module Name:

    WordPerfect9_1.cpp

 Abstract:

    Dispatch WM_USER messages (an OLE message in this case) automatically
    so the app doesn't hang. This is needed because of changes in OLE's behavior
    from Win9x to NT.

 Notes:

    This is an app specific shim.

 History:

    02/16/2000 clupu Created

--*/

#include "precomp.h"

IMPLEMENT_SHIM_BEGIN(WordPerfect9_1)
#include "ShimHookMacro.h"

APIHOOK_ENUM_BEGIN
    APIHOOK_ENUM_ENTRY(PeekMessageA)
APIHOOK_ENUM_END

/*++

 Dispatch WM_USER (an OLE message in this case) messages automatically.

--*/

BOOL
APIHOOK(PeekMessageA)(
    LPMSG lpMsg,
    HWND  hWnd,
    UINT  wMsgFilterMin,
    UINT  wMsgFilterMax,
    UINT  wRemoveMsg)
{
    BOOL bRet;

    bRet = ORIGINAL_API(PeekMessageA)(
        lpMsg,
        hWnd,
        wMsgFilterMin,
        wMsgFilterMax,
        wRemoveMsg);

    if (bRet && lpMsg->message == WM_USER && lpMsg->hwnd != NULL) {

        DispatchMessageA(lpMsg);

        if (wRemoveMsg == PM_REMOVE) {
            return APIHOOK(PeekMessageA)(
                lpMsg,
                hWnd,
                wMsgFilterMin,
                wMsgFilterMax,
                wRemoveMsg);
        }
    }

    return bRet;
}

/*++

 Register hooked functions

--*/

HOOK_BEGIN
    APIHOOK_ENTRY(USER32.DLL, PeekMessageA)
HOOK_END

IMPLEMENT_SHIM_END
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\appcompat\shims\specific\wordperfect8.cpp ===
/*++

 Copyright (c) 2000 Microsoft Corporation

 Module Name:

    WordPerfect8.cpp
 Abstract:
    If the SafeArray* to the SafeArrayAccessData is an invalid one
    this function returns a NULL pointer for the data. Corel WordPerfect8
    was AV'ing because of this.

         This is an app specific shim.

 History:
 
    02/07/2001 prashkud  Created

--*/

#include "precomp.h"

IMPLEMENT_SHIM_BEGIN(WordPerfect8)
#include "ShimHookMacro.h"

APIHOOK_ENUM_BEGIN
    APIHOOK_ENUM_ENTRY(SafeArrayAccessData)
APIHOOK_ENUM_END



/*++

    This hooks SafeArrayAccessData and returns
    an error code if *ppvData is NULL.
--*/

HRESULT
APIHOOK(SafeArrayAccessData)(
    SAFEARRAY *psa,
    void HUGEP **ppvData
    )
{
    HRESULT hRes = S_OK;


    hRes = ORIGINAL_API(SafeArrayAccessData)(
            psa,
            ppvData
            );

    if (*ppvData == NULL)
    {
        DPFN( eDbgLevelError, "Getting a NULL pointer for the\
             SafeArray Data - ppvData = %lx & *ppvData =%lx",ppvData,*ppvData);
        DPFN( eDbgLevelError, "SAFEARRAY is psa = %lx,\
             psa.cbElements= %l",psa,psa->cbElements);
        hRes = E_UNEXPECTED;
    }
    return hRes;
}

/*++

 Register hooked functions

--*/

HOOK_BEGIN
    APIHOOK_ENTRY(OLEAUT32.DLL, SafeArrayAccessData)    
HOOK_END

IMPLEMENT_SHIM_END
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\appcompat\shims\specific\worms2.cpp ===
/*++

 Copyright (c) 2000 Microsoft Corporation

 Module Name:

    Worms2.cpp

 Abstract:

    Extremely lame hack because we don't properly support full-screen MCI 
    playback on NT.

 Notes:

    This is an app specific shim.

 History:

    12/04/2000 linstev  Created

--*/

#include "precomp.h"
#include <mmsystem.h>
#include <digitalv.h>
#include <mciavi.h>

IMPLEMENT_SHIM_BEGIN(Worms2)
#include "ShimHookMacro.h"

APIHOOK_ENUM_BEGIN
    APIHOOK_ENUM_ENTRY(mciSendCommandA) 
APIHOOK_ENUM_END

/*++

 Do lots of lame stuff.

--*/

MCIERROR 
APIHOOK(mciSendCommandA)(
    MCIDEVICEID IDDevice,  
    UINT uMsg,             
    DWORD fdwCommand,      
    DWORD dwParam          
    )
{
    if ((uMsg == MCI_PLAY) &&
        (fdwCommand == (MCI_NOTIFY | MCI_WAIT | MCI_MCIAVI_PLAY_FULLSCREEN)))
    {
        DEVMODEA dm;
        dm.dmSize = sizeof(dm);
        dm.dmPelsWidth = 320;
        dm.dmPelsHeight = 200;
        dm.dmFields = DM_PELSWIDTH | DM_PELSHEIGHT;
        ChangeDisplaySettingsA(&dm, CDS_FULLSCREEN);

        #define szWndClass "WORMS2_HACK_WINDOW"
        WNDCLASSA cls;
        HMODULE hModule = GetModuleHandle(0);
        if (!GetClassInfoA(hModule, szWndClass, &cls))
        {
            cls.lpszClassName = szWndClass;
            cls.hbrBackground = (HBRUSH)GetStockObject(BLACK_BRUSH);
            cls.hInstance     = hModule;
            cls.hIcon         = NULL;
            cls.hCursor       = NULL;
            cls.lpszMenuName  = NULL;
            cls.style         = CS_DBLCLKS;
            cls.lpfnWndProc   = (WNDPROC)DefWindowProc;
            cls.cbWndExtra    = sizeof(INT_PTR);
            cls.cbClsExtra    = 0;
            if (RegisterClassA(&cls) == 0)
            {
                goto Fail;
            }
        }

        HWND hWnd = CreateWindowA(
            szWndClass,
            szWndClass,
            WS_OVERLAPPED|WS_POPUP|WS_VISIBLE,
            0,
            0,
            GetSystemMetrics(SM_CXSCREEN), 
            GetSystemMetrics(SM_CYSCREEN),
            (HWND)NULL, 
            NULL,
            hModule,
            (LPVOID)NULL);

        if (!hWnd)
        {
            goto Fail;
        }

        MCIERROR merr;
        MCI_DGV_WINDOW_PARMSA mciwnd;
        mciwnd.dwCallback = (DWORD) (WNDPROC) DefWindowProcA;
        mciwnd.hWnd = hWnd;
        mciwnd.lpstrText = 0;
        mciwnd.nCmdShow = 0;
        merr = mciSendCommandA(IDDevice, MCI_WINDOW, MCI_DGV_WINDOW_HWND, (DWORD)&mciwnd);
        if (merr != MMSYSERR_NOERROR)
        {
            DestroyWindow(hWnd);
            goto Fail;
        }

        ShowCursor(FALSE);
        MCI_PLAY_PARMS mciply;
        mciply.dwCallback = (DWORD)hWnd;
        mciply.dwFrom = 0x40000000;
        mciply.dwTo = 0;
        merr = mciSendCommandA(IDDevice, MCI_PLAY, MCI_NOTIFY | MCI_WAIT, (DWORD)&mciply);
        DestroyWindow(hWnd);
        ShowCursor(TRUE);

        if (merr != MMSYSERR_NOERROR)
        {
            goto Fail;
        }
        return 0;
    }
    
Fail:
    return ORIGINAL_API(mciSendCommandA)(
        IDDevice,
        uMsg,
        fdwCommand,
        dwParam);
}

/*++

 Register hooked functions

--*/

HOOK_BEGIN

    APIHOOK_ENTRY(WINMM.DLL, mciSendCommandA)

HOOK_END

IMPLEMENT_SHIM_END
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\appcompat\shims\specific\works99.cpp ===
/*++

 Copyright (c) 2001 Microsoft Corporation

 Module Name:
    
    Works99.cpp

 Abstract:

    This shim is to add in the missing/corrupted registry values
    for Works Suite 99 / Works Deluxe 99

 Notes:

    This is a app specific shim.

 History:

    03/12/2001 rankala  Created
    03/12/2001 a-leelat Modified for shim.

--*/


#include "precomp.h"

IMPLEMENT_SHIM_BEGIN(Works99)
#include "ShimHookMacro.h"

APIHOOK_ENUM_BEGIN
APIHOOK_ENUM_END


static LONG SetThreadingModel2Both(IN WCHAR *szKeyPath);
static LONG AddCAGKey(void);



VOID Works99()
{
    WCHAR   szPath[MAX_PATH];

    // Fix broken ThreadingModel value for several CLSID
    wcscpy(szPath, L"CLSID\\{29D44CA0-DD3A-11d0-95DF-00C04FD57E8C}\\InProcServer32");
    SetThreadingModel2Both(szPath);

    wcscpy(szPath, L"CLSID\\{4BA2C080-68BB-11d0-95BD-00C04FD57E8C}\\InProcServer32");
    SetThreadingModel2Both(szPath);

    wcscpy(szPath, L"CLSID\\{4BA2C081-68BB-11d0-95BD-00C04FD57E8C}\\InProcServer32");
    SetThreadingModel2Both(szPath);

    wcscpy(szPath, L"CLSID\\{56EE2738-BDF7-11d1-8C28-00C04FB995C9}\\InProcServer32");
    SetThreadingModel2Both(szPath);

    wcscpy(szPath, L"CLSID\\{6CFFE322-6E97-11d1-8C1C-00C04FB995C9}\\InProcServer32");
    SetThreadingModel2Both(szPath);

    wcscpy(szPath, L"CLSID\\{711D9B80-02F2-11d1-B244-00AA00A74BFF}\\InProcServer32");
    SetThreadingModel2Both(szPath);

    wcscpy(szPath, L"CLSID\\{8EE20D86-6DEC-11d1-8C1C-00C04FB995C9}\\InProcServer32");
    SetThreadingModel2Both(szPath);

    wcscpy(szPath, L"CLSID\\{92AABF20-39C8-11d1-95F6-00C04FD57E8C}\\InProcServer32");
    SetThreadingModel2Both(szPath);

    wcscpy(szPath, L"CLSID\\{9B3B23C0-E236-11d0-A5C9-0080C7195D7E}\\InProcServer32");
    SetThreadingModel2Both(szPath);

    wcscpy(szPath, L"CLSID\\{9B3B23C1-E236-11d0-A5C9-0080C7195D7E}\\InProcServer32");
    SetThreadingModel2Both(szPath);

    wcscpy(szPath, L"CLSID\\{9B3B23C2-E236-11d0-A5C9-0080C7195D7E}\\LocalServer32");
    SetThreadingModel2Both(szPath);

    wcscpy(szPath, L"CLSID\\{9B3B23C3-E236-11d0-A5C9-0080C7195D7E}\\InProcServer32");
    SetThreadingModel2Both(szPath);

    wcscpy(szPath, L"CLSID\\{CB40F470-02F1-11D1-B244-00AA00A74BFF}\\InProcServer32");
    SetThreadingModel2Both(szPath);

    wcscpy(szPath, L"CLSID\\{EAF6F280-DD53-11d0-95DF-00C04FD57E8C}\\InProcServer32");
    SetThreadingModel2Both(szPath);

    // Add CAG key and all of its values if missing
    AddCAGKey();

    
}

/*

 Function Description:

    Set ThreadingModel Registry REG_SZ value to "Both" for a given key

*/

static 
LONG SetThreadingModel2Both(
    IN WCHAR *szKeyPath
    )
{

    HKEY    hKey;
    WCHAR   szValue[32];
    WCHAR   szData[32];
    LONG    lStatus;        

    // Fix broken ThreadingModel value for several CLSID
    wcscpy(szValue, L"ThreadingModel");
    wcscpy(szData, L"Both");

    lStatus = RegOpenKeyExW (HKEY_CLASSES_ROOT, 
                             szKeyPath, 
                             0, 
                             KEY_ALL_ACCESS, 
                             &hKey);

    if ( lStatus == ERROR_SUCCESS ) {
        
        // Set it always since this is a one-time operation and 
        //it must have "Both", no matter what is the current data
        lStatus = RegSetValueExW(hKey, 
                                 szValue, 
                                 0, 
                                 REG_SZ, 
                                 (BYTE*)szData, 
                                 (wcslen(szData) + 1) * sizeof(WCHAR));

        RegCloseKey(hKey);
    }

    return lStatus;
}

/*

 Function Description:

    Check existance of CAG key, add key + all values if it doesn't exist

*/
static 
LONG AddCAGKey(
    void
    )
{
    HKEY    hKey, hKey1, hKey2;
    WCHAR   szKeyPath[MAX_PATH];
    WCHAR   szSubKeyPath[32];
    WCHAR   szValue[32];
    WCHAR   szData[MAX_PATH];
    DWORD   dwData;
    LONG    lStatus;        
    DWORD   dwCreated;

    // If this key doesn't exist, assume that something 
    // is completely wrong and don't try to complete the Registry
    wcscpy(szKeyPath, L"SOFTWARE\\Microsoft\\ClipArt Gallery\\5.0\\ConcurrentDatabases");

    lStatus = RegOpenKeyExW (HKEY_LOCAL_MACHINE, 
                             szKeyPath, 
                             0, 
                             KEY_ALL_ACCESS, 
                             &hKey);

    if (ERROR_SUCCESS != lStatus) {
        return lStatus;
    }

    // Check for next sub key, create if missing
    wcscpy(szSubKeyPath, L"Core");

    lStatus = RegCreateKeyExW (hKey, 
                               szSubKeyPath, 
                               0, 
                               NULL, 
                               REG_OPTION_NON_VOLATILE, 
                               KEY_ALL_ACCESS, 
                               NULL, 
                               &hKey1, 
                               NULL);
    RegCloseKey(hKey);

    if (ERROR_SUCCESS != lStatus) {
        return lStatus;
    }

    // Check for next sub key, create if missing, 
    // if so, we need create a set of values as well
    wcscpy(szSubKeyPath, L"CAG");

    lStatus = RegCreateKeyExW (hKey1, 
                               szSubKeyPath, 
                               0, 
                               NULL, 
                               REG_OPTION_NON_VOLATILE, 
                               KEY_ALL_ACCESS, 
                               NULL, 
                               &hKey2, 
                               &dwCreated);
    RegCloseKey(hKey1);

    if (ERROR_SUCCESS != lStatus) {
        return lStatus;
    }

    if (REG_CREATED_NEW_KEY == dwCreated) {

        // Create the appropriate set of values
        wcscpy(szValue, L"Section1Path1");

        if (! SHGetSpecialFolderPathW(NULL, szData, CSIDL_PROGRAM_FILES, FALSE)) {
            RegCloseKey(hKey2);
            return ERROR_FILE_NOT_FOUND;
        }

        wcscat(szData, L"\\Common Files\\Microsoft Shared\\Clipart\\cagcat50");

        lStatus = RegSetValueExW(hKey2, 
                                 szValue, 
                                 0, 
                                 REG_SZ, 
                                 (BYTE*)szData, 
                                 (wcslen(szData) + 1) * sizeof(WCHAR));

        if (ERROR_SUCCESS != lStatus) {
            RegCloseKey(hKey2);
            return lStatus;
        }

        wcscpy(szValue, L"CatalogPath0");
        wcscat(szData, L"\\CagCat50.MMC");
        lStatus = RegSetValueExW(hKey2, 
                                 szValue, 
                                 0, 
                                 REG_SZ, 
                                 (BYTE*)szData, 
                                 (wcslen(szData) + 1) * sizeof(WCHAR));

        if (ERROR_SUCCESS != lStatus) {
            RegCloseKey(hKey2);
            return lStatus;
        }

        wcscpy(szValue, L"CatalogDriveType0");
        dwData = 3;
        lStatus = RegSetValueExW(hKey2, 
                                 szValue, 
                                 0, 
                                 REG_DWORD, 
                                 (BYTE*)&dwData, 
                                 sizeof(DWORD));

        if (ERROR_SUCCESS != lStatus) {
            RegCloseKey(hKey2);
            return lStatus;
        }

        wcscpy(szValue, L"CatalogSections");
        dwData = 1;
        lStatus = RegSetValueExW(hKey2, 
                                 szValue, 
                                 0, 
                                 REG_DWORD, 
                                 (BYTE*)&dwData, 
                                 sizeof(DWORD));

        if (ERROR_SUCCESS != lStatus) {
            RegCloseKey(hKey2);
            return lStatus;
        }

        wcscpy(szValue, L"Section1Name");
        wcscpy(szData, L"MAIN");
        lStatus = RegSetValueExW(hKey2, 
                                 szValue, 
                                 0, 
                                 REG_SZ, 
                                 (BYTE*)szData, 
                                 (wcslen(szData) + 1) * sizeof(WCHAR));

        if (ERROR_SUCCESS != lStatus) {
            RegCloseKey(hKey2);
            return lStatus;
        }

        wcscpy(szValue, L"Section1DriveType1");
        dwData = 3;
        lStatus = RegSetValueExW(hKey2, 
                                 szValue, 
                                 0, 
                                 REG_DWORD, 
                                 (BYTE*)&dwData, 
                                 sizeof(DWORD));

        if (ERROR_SUCCESS != lStatus) {
            RegCloseKey(hKey2);
            return lStatus;
        }

        wcscpy(szValue, L"Section1Paths");
        dwData = 1;
        lStatus = RegSetValueExW(hKey2, 
                                 szValue, 
                                 0, 
                                 REG_DWORD, 
                                 (BYTE*)&dwData, 
                                 sizeof(DWORD));

        if (ERROR_SUCCESS != lStatus) {
            RegCloseKey(hKey2);
            return lStatus;
        }

        wcscpy(szValue, L"CatalogLCID");
        dwData = 1033;
        lStatus = RegSetValueExW(hKey2, 
                                 szValue, 
                                 0, 
                                 REG_DWORD, 
                                 (BYTE*)&dwData, 
                                 sizeof(DWORD));

        if (ERROR_SUCCESS != lStatus) {
            RegCloseKey(hKey2);
            return lStatus;
        }

        wcscpy(szValue, L"CatalogVersionID");
        dwData = 1;
        lStatus = RegSetValueExW(hKey2, 
                                 szValue, 
                                 0, 
                                 REG_DWORD, 
                                 (BYTE*)&dwData, sizeof(DWORD));

        if (ERROR_SUCCESS != lStatus) {
            RegCloseKey(hKey2);
            return lStatus;
        }

    }
    
    RegCloseKey(hKey2);

    return lStatus;
}



/*++

 Register hooked functions

--*/

BOOL
NOTIFY_FUNCTION(
    DWORD fdwReason)
{
    
    if (fdwReason == SHIM_STATIC_DLLS_INITIALIZED) {

        Works99();
    }

    return TRUE;
}

HOOK_BEGIN

    CALL_NOTIFY_FUNCTION

HOOK_END

IMPLEMENT_SHIM_END
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\appcompat\shims\specific\winstone99.cpp ===
/*
 Copyright (c) 2000 Microsoft Corporation

 Module Name:

    WinStone99.cpp

    Bug: Whistler #185797
    
 Problem:

    Only for Winstone '99. Winstone uses scripts that hide the taskbar, and print stuff. 
    PrintUI displays a balloon tip informing the user that the printing job is done (this is a 
    new addition to Whistler).

    The balloon tip utilizes user tracking code, and is hence left stationary on the machine, 
    till the user clicks on it, or there is 10 seconds of user activity on the machine. 
    Winstone runs these automated tests, hence there is no user activity on the machine, when 
    the balloon is up, so it stays up forever.

    Later, when Winstone tries to enumerate the application windows, the presence of the 
    balloon tip throws it off track. Hence this apphack that disables the display of these 
    balloons when Winstone is running.

    Winstone is a collection of Visual Test scripts, and zdbui32.exe is the only exe that runs 
    throughout when Winstone is running. So disable user tracking when Winstone is running.

 Solution:

    Disable display of balloon tips when Winstone is running and enable it when Winstone is
    finished

 Details:

    Winstone sends a message to the tray that disables the balloon tip when it is running, and
    re-sends the message to the tray when it is done, so that the tray can enable the balloon 
    tip

 History:

    09/20/2000  ramkumar Created
*/

#include "precomp.h"
#include <shlapip.h>

IMPLEMENT_SHIM_BEGIN(WinStone99)
#include "ShimHookMacro.h"

APIHOOK_ENUM_BEGIN
    APIHOOK_ENUM_ENTRY(GetCommandLineA) 
    APIHOOK_ENUM_ENTRY(GetCommandLineW) 
APIHOOK_ENUM_END

BOOL g_bInit = FALSE;
HWND g_hwndTray;
UINT g_uEnableBalloonMessage;

/*++

 Initialize

--*/

VOID
WinStone99_Initialize()
{
    if (!g_bInit)
    {
        g_bInit = TRUE;

        g_uEnableBalloonMessage = RegisterWindowMessage(ENABLE_BALLOONTIP_MESSAGE);
        if (!g_uEnableBalloonMessage)
        {
            return;
        }

        g_hwndTray = FindWindowA(WNDCLASS_TRAYNOTIFY, NULL);
        if (g_hwndTray)
        {
            SendMessage(g_hwndTray, g_uEnableBalloonMessage, FALSE, 0);
        }
    }
}

/*++

 Initialize.

--*/

LPSTR 
APIHOOK(GetCommandLineA)()
{
    WinStone99_Initialize();
    return ORIGINAL_API(GetCommandLineA)();
}

/*++

 Initialize.

--*/

LPWSTR 
APIHOOK(GetCommandLineW)()
{
    WinStone99_Initialize();
    return ORIGINAL_API(GetCommandLineW)();
}

/*++
 
 Register hooked functions

--*/

BOOL
NOTIFY_FUNCTION(
    DWORD fdwReason
    )
{
    if (fdwReason == DLL_PROCESS_DETACH)
    {
        if (g_bInit)
        {
            if (g_hwndTray)
            {
                SendMessage(g_hwndTray, g_uEnableBalloonMessage, TRUE, 0);
            }
        }
    }

    return TRUE;
}

HOOK_BEGIN

    CALL_NOTIFY_FUNCTION
    APIHOOK_ENTRY(KERNEL32.DLL, GetCommandLineA)
    APIHOOK_ENTRY(KERNEL32.DLL, GetCommandLineW)

HOOK_END


IMPLEMENT_SHIM_END
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\appcompat\shims\specific\workssuite2001.cpp ===
/*++

 Copyright (c) 2001 Microsoft Corporation

 Module Name:

    WorksSuite2001.cpp

 Abstract:

    Added the hook for CreateProcess to prevent IE5Setup.exe from starting
    up if the system has a higher version of IE.

 Notes:

    This is an app specific.

 History:

    03/28/2001	a-larrsh    Created
    07/13/2001	prashkud    Added hook for CreateProcess
    01/11/2001  robkenny    Removed code that was deleting Shockwave files whenever this shim loaded.

--*/

#include "precomp.h"

IMPLEMENT_SHIM_BEGIN(WorksSuite2001)
#include "ShimHookMacro.h"

#include "userenv.h"

APIHOOK_ENUM_BEGIN
    APIHOOK_ENUM_ENTRY(CreateProcessA) 
APIHOOK_ENUM_END


/*++

    Hooks CreateProcessA and if the process being invoked is "ie5setup.exe",
    determines the IE version on the system and if it is higher than IE 5.5,
    launches an harmless .exe like "rundll32.exe" instead.

--*/

BOOL
APIHOOK(CreateProcessA)(
    LPCSTR                  lpApplicationName,                 
    LPSTR                   lpCommandLine,                      
    LPSECURITY_ATTRIBUTES   lpProcessAttributes,
    LPSECURITY_ATTRIBUTES   lpThreadAttributes, 
    BOOL                    bInheritHandles,                     
    DWORD                   dwCreationFlags,                    
    LPVOID                  lpEnvironment,                     
    LPCSTR                  lpCurrentDirectory,                
    LPSTARTUPINFOA          lpStartupInfo,             
    LPPROCESS_INFORMATION   lpProcessInformation
    )
{
    DPFN( eDbgLevelSpew, "[CreateProcessA] appname:(%s)\ncommandline:(%s)",
          lpApplicationName, lpCommandLine );

    CSTRING_TRY
    {
        CString csAppName(lpApplicationName);
        CString csCmdLine(lpCommandLine);
        
        if ((csAppName.Find(L"ie5setup.exe") != -1) ||
            (csCmdLine.Find(L"ie5setup.exe") != -1))
        {
            //
            // App has called CreateProcess on ie5setup.exe.
            // Check the version of IE that we have on the machine.
            //

            HKEY hKey = NULL;            
            if ((RegOpenKeyExW(HKEY_LOCAL_MACHINE, 
                               L"Software\\Microsoft\\Internet Explorer",
                               0,
                               KEY_QUERY_VALUE,
                               &hKey) == ERROR_SUCCESS))
            {
                WCHAR wszBuf[MAX_PATH];
                DWORD dwSize = MAX_PATH;

                if (RegQueryValueExW(hKey, L"Version", NULL, NULL,
                    (LPBYTE)wszBuf, &dwSize) == ERROR_SUCCESS)
                {
                    WCHAR *StopString = NULL;
                    CStringParser csParser(wszBuf, L".");
                    
                    // We need at least the major and minor version numbers from the version string
                    if (csParser.GetCount() >= 2)
                    {
                        long lVal = wcstol(csParser[0].Get(), &StopString, 10);

                        if (lVal > 5)
                        {
                            //
                            // Call rundll32.exe, which is harmless
                            //
                            csAppName = "";
                            csCmdLine = "rundll32.exe";
                        }           
                        else
                        {
                            // check the 2nd value
                            StopString = NULL;
                            lVal = 0;
                            lVal = wcstol(csParser[1].Get(), &StopString, 10);
                            if (lVal > 5)
                            {
                                csAppName = "";
                                csCmdLine = "rundll32.exe";
                            }
                        }
                    }
                }
                RegCloseKey(hKey);
            }
        }

        return ORIGINAL_API(CreateProcessA)(
            csAppName.GetAnsiNIE(),csCmdLine.GetAnsiNIE(),
            lpProcessAttributes,lpThreadAttributes, bInheritHandles,
            dwCreationFlags, lpEnvironment,lpCurrentDirectory,
            lpStartupInfo,lpProcessInformation);
    }
    CSTRING_CATCH
    {
        // Do nothing
    }

    return ORIGINAL_API(CreateProcessA)(lpApplicationName,
            lpCommandLine, lpProcessAttributes,
            lpThreadAttributes, bInheritHandles,
            dwCreationFlags, lpEnvironment,
            lpCurrentDirectory, lpStartupInfo,lpProcessInformation);

}

/*++

 Register hooked functions

--*/

HOOK_BEGIN

    APIHOOK_ENTRY(KERNEL32.DLL, CreateProcessA)

HOOK_END


IMPLEMENT_SHIM_END
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\appcompat\shims\specific\wordperfect9_3.cpp ===
/*++

 Copyright (c) 2000 Microsoft Corporation

 Module Name:

   WordPerfect9_3.cpp

 Abstract:  

   WORDPERFECT 9 - Mapping Network Drives from Open / Save / Save As Dialogs:

 Notes:

   This is an application specific shim.

 History:

   02/21/2001 a-larrsh Created
--*/

#include "precomp.h"

IMPLEMENT_SHIM_BEGIN(WordPerfect9_3)
#include "ShimHookMacro.h"

APIHOOK_ENUM_BEGIN
    APIHOOK_ENUM_ENTRY(SHGetSpecialFolderLocation) 
APIHOOK_ENUM_END

// typedef HRESULT   (WINAPI *_pfn_SHGetSpecialFolderLocation)(HWND hwndOwner, int nFolder, LPITEMIDLIST *ppidl);


/*++

 Hook SHGetDesktopFolder to get the IShellFolder Interface Pointer.

--*/

HRESULT
APIHOOK(SHGetSpecialFolderLocation)(
    HWND hwndOwner,
    int nFolder,
    LPITEMIDLIST *ppidl
)
{
   if (hwndOwner == NULL && nFolder == 0x11 && (*ppidl) == NULL)
   {
      DWORD dwReturn = WNetConnectionDialog(hwndOwner, RESOURCETYPE_DISK);

      switch(dwReturn)
      {
      case NO_ERROR:
         DPFN( eDbgLevelInfo, "Creating NETWORK CONNECTIONS dialog Successful");
         break;

      case ERROR_INVALID_PASSWORD:
      case ERROR_NO_NETWORK:
      case ERROR_EXTENDED_ERROR:
         DPFN( eDbgLevelWarning, "Creating NETWORK CONNECTIONS dialog Successful");
         break;

      case ERROR_NOT_ENOUGH_MEMORY:
      default:
         DPFN( eDbgLevelError, "Creating NETWORK CONNECTIONS dialog Failed");
         break;      
      }

      return NOERROR;
   }
   else
   {
      return ORIGINAL_API(SHGetSpecialFolderLocation)(hwndOwner, nFolder, ppidl);              
   }
}

/*++

 Register hooked functions

--*/

HOOK_BEGIN
    APIHOOK_ENTRY(SHELL32.DLL, SHGetSpecialFolderLocation)
HOOK_END

IMPLEMENT_SHIM_END
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\appcompat\shims\specific\wordperfect9_2.cpp ===
/*++

 Copyright (c) 2000 Microsoft Corporation

 Module Name:

   WordPerfect9_2.cpp

 Abstract:  

   WORDPERFECT 9 - GRAMMAR CHECK BUG:

   Shim prevents an internal reference count used by the Grammar Checker 
   from becoming negative by not allowing Add/Release to be called more than
   once for the life of the interface.

   This COM Interface allocates some internal memory in DllGetClassObject()
   and frees the memory in the Release().  
   
   Under WIN98 and NT4 this works because DllGetClassObject() is called at
   the beginning of Grammar Checking and Release() is called after completion.

   In Whistler OLE makes two pairs of extra calls (AddRef => Release & 
   QueryInterface => Release) causing Release() to free the internal 
   memory before the object is truly deleted.  The code also set the internal
   reference count to -2.  On the next initiation of the grammar checker the 
   internal REF count NZ (-2) and DllGetClassObject() does not allocate the 
   needed memory and then access violates.

 Notes:

   This is an application specific shim.

 History:

   12/01/2000 a-larrsh Created
--*/

#include "precomp.h"
#include <initguid.h>

IMPLEMENT_SHIM_BEGIN(WordPerfect9_2)
#include "ShimHookMacro.h"

APIHOOK_ENUM_BEGIN
   APIHOOK_ENUM_ENTRY(DllGetClassObject) 
   APIHOOK_ENUM_ENTRY_COMSERVER(wt9li)
APIHOOK_ENUM_END

IMPLEMENT_COMSERVER_HOOK(wt9li)

/* ++

   COM definitions for object we are hooking

--*/

class  __declspec(uuid("C0E10005-0500-0900-C0E1-C0E1C0E1C0E1")) WP9;
struct __declspec(uuid("C0E10005-0100-0900-C0E1-C0E1C0E1C0E1")) IWP9;

DEFINE_GUID(CLSID_WP9, 0xC0E10005, 0x0500, 0x0900,  0xC0, 0xE1, 0xC0, 0xE1, 0xC0, 0xE1, 0xC0, 0xE1);
DEFINE_GUID(IID_IWP9,  0xC0E10005, 0x0100, 0x0900,  0xC0, 0xE1, 0xC0, 0xE1, 0xC0, 0xE1, 0xC0, 0xE1);

typedef HRESULT   (*_pfn_IWP9_QueryInterface)( PVOID pThis, REFIID iid, PVOID* ppvObject );
typedef ULONG     (*_pfn_IWP9_AddRef)( PVOID pThis );
typedef ULONG     (*_pfn_IWP9_Release)( PVOID pThis );


/*++

    Manage OLE Object Ref count for QueryInterface, AddRef and Release

--*/

static int g_nInternalRefCount = 0;

HRESULT 
APIHOOK(DllGetClassObject)(REFCLSID rclsid, REFIID riid, LPVOID * ppv)
{
    HRESULT hrResult;
   
   hrResult = ORIGINAL_API(DllGetClassObject)(rclsid, riid, ppv);            

   if (  IsEqualGUID(rclsid, CLSID_WP9) &&
         IsEqualGUID(riid,    IID_IWP9) &&
         hrResult == S_OK)
   {
      if (g_nInternalRefCount == 0)
      {
         g_nInternalRefCount++;
      }

      DPFN( eDbgLevelInfo, "DllGetClassObject");
   }

    return hrResult;
}

ULONG
COMHOOK(IWP9, AddRef)(PVOID pThis)
{       
   if (g_nInternalRefCount == 0)
   {
      _pfn_IWP9_AddRef pfnAddRef = (_pfn_IWP9_AddRef) ORIGINAL_COM(IWP9, AddRef, pThis);
      (*pfnAddRef)(pThis);
   }

   g_nInternalRefCount++;
   
   DPFN( eDbgLevelInfo, "AddRef");

   return g_nInternalRefCount;
}


ULONG
COMHOOK(IWP9, Release)(PVOID pThis)
{
   g_nInternalRefCount--;

   if (g_nInternalRefCount == 0)
   {
      _pfn_IWP9_Release pfnRelease = (_pfn_IWP9_Release) ORIGINAL_COM(IWP9, Release, pThis);   
      (*pfnRelease)(pThis);
   }
   
   DPFN( eDbgLevelInfo, "Release");

   return g_nInternalRefCount;
}

HRESULT
COMHOOK(IWP9, QueryInterface)( PVOID pThis, REFIID iid, PVOID* ppvObject )
{
   HRESULT hrResult;
   
   _pfn_IWP9_QueryInterface pfnQueryInterface = (_pfn_IWP9_QueryInterface) ORIGINAL_COM(IWP9, QueryInterface, pThis);

   hrResult = (*pfnQueryInterface)(pThis, iid, ppvObject);
   
   DPFN( eDbgLevelInfo, "QueryInterface");
   return hrResult;
}


/*++

 Register hooked functions

--*/

HOOK_BEGIN
    APIHOOK_ENTRY_COMSERVER(wt9li)
    APIHOOK_ENTRY(wt9li.dll, DllGetClassObject)

    COMHOOK_ENTRY(WP9, IWP9, QueryInterface,  0)
    COMHOOK_ENTRY(WP9, IWP9, AddRef,  1)
    COMHOOK_ENTRY(WP9, IWP9, Release, 2)
HOOK_END

IMPLEMENT_SHIM_END
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\appcompat\shims\specific\zenworks.cpp ===
/*++

 Copyright (c) 2001 Microsoft Corporation

 Module Name:

    ZenWorks.cpp

 Abstract:

    ZenWorks console plugins setup program changes the
    HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\Session Manager\Environment\Path
    registry key from REG_EXPAND_SZ to REG_SZ.

 Notes:

    This is an app specific shim.

 History:

    06/06/2001  robkenny    Created

--*/

#include "precomp.h"

IMPLEMENT_SHIM_BEGIN(ZenWorks)
#include "ShimHookMacro.h"

APIHOOK_ENUM_BEGIN
    APIHOOK_ENUM_ENTRY(RegSetValueExA) 
APIHOOK_ENUM_END

/*++

 Prevent HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\Session Manager\Environment\Path
 from being changed from a REG_EXPAND_SZ to REG_SZ

--*/

LONG
APIHOOK(RegSetValueExA)(
    HKEY   hKey,
    LPCSTR lpValueName,
    DWORD  Reserved,
    DWORD  dwType,
    CONST BYTE * lpData,
    DWORD  cbData
    )
{
    CSTRING_TRY
    {
        CString csValueName(lpValueName);

        DPFN( eDbgLevelSpew, "RegSetValueExA lpValueName(%S)", csValueName.Get());

        if (dwType == REG_SZ &&
            csValueName.CompareNoCase(L"Path") == 0)
        {
            dwType = REG_EXPAND_SZ;
            DPFN( eDbgLevelError, "RegSetValueExA lpValueName(%S) forced to REG_EXPAND_SZ type.",
                  csValueName.Get());
        }
    }
    CSTRING_CATCH
    {
        // fall through
    }

    /*
     * Call the original API
     */
    
    return ORIGINAL_API(RegSetValueExA)(
        hKey,
        lpValueName,
        Reserved,
        dwType,
        lpData,
        cbData);
}


/*++

 Register hooked functions

--*/

HOOK_BEGIN

    APIHOOK_ENTRY(ADVAPI32.DLL, RegSetValueExA)

HOOK_END

IMPLEMENT_SHIM_END
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\appcompat\shims\specific\wps2000.cpp ===
/*++

 Copyright (c) 2001 Microsoft Corporation

 Module Name:

    WPS2000.cpp

 Abstract:

    This in in fact NT user bug, see whistler bug 359407's attached mail for 
    detail. The problem is NT user's MSGFILTER hook is not dbcs-enabled, the dbcs 
    char code sent to ANSI edit control actually got reverted, 2nd byte first 
    followed by first byte. The code path seems only hit when edit control is 
    ANSI window and used in OLE server.

 Notes: 
  
    This is an app specific shim.

 History:

    06/02/2001 xiaoz    Created

--*/

#include "precomp.h"

IMPLEMENT_SHIM_BEGIN(WPS2000)
#include "ShimHookMacro.h"

APIHOOK_ENUM_BEGIN
    APIHOOK_ENUM_ENTRY(CreateDialogIndirectParamA) 
APIHOOK_ENUM_END

//
// Global windowproc for subclassed Edit Control
//

WNDPROC g_lpWndProc = NULL;

//
// CONSTANT for how we were being launched
//
#define EMBEDDIND_STATUS_UNKOWN 0  // We have not checked whether how we were launched 
#define EMBEDDIND_STATUS_YES    1  // We were launched as an OLE object
#define EMBEDDIND_STATUS_NO     2  // We were launched as stand-alone exe file

//
// Global variable to keep our status
//
UINT g_nEmbeddingObject =EMBEDDIND_STATUS_UNKOWN;

/*++

 The subclassed edit windowproc that we use to exchange the 1st byte and 2nd byte 
 of a DBCS char

--*/

LRESULT
CALLBACK
WindowProcA(
    HWND hWnd, 
    UINT uMsg, 
    WPARAM wParam, 
    LPARAM lParam
    )
{
    BYTE bHi,bLo;

    //
    // If it' not a WM_IME_CHAR message, ignore it
    //
    if (uMsg == WM_IME_CHAR)
    { 
        //
        // Exchange the 1st byte with 2nd byte
        //
        bHi = HIBYTE(wParam);
        bLo = LOBYTE(wParam);
        wParam = bLo*256 + bHi;
    }

    return CallWindowProcA(g_lpWndProc, hWnd, uMsg, wParam, lParam);
}


/*++

 Enumerate the control on the dlg and if is editbox, subclass it.

--*/

BOOL 
CALLBACK 
EnumChildProc(
    HWND hwnd,
    LPARAM lParam 
    )
{
    CString cstrEdit(L"Edit");
    WCHAR szClassName[MAX_PATH];
    WNDPROC lpWndProc;

    GetClassName(hwnd, szClassName, MAX_PATH);

    //
    // Only care Edit Control
    //
    if (!cstrEdit.CompareNoCase(szClassName))
    {
        //
        // There are 3 Edit Control on thsi speficic dlg,all standard one
        // having same WinProc Address
        //
        lpWndProc = (WNDPROC) GetWindowLongPtrA(hwnd, GWLP_WNDPROC);
        if (lpWndProc)
        {
           g_lpWndProc = lpWndProc;
           SetWindowLongPtrA(hwnd, GWLP_WNDPROC, (LONG_PTR)WindowProcA);
           LOGN(eDbgLevelWarning, "Edit Control Sub-Classed");
        }
    }
    return TRUE;
}

/*++

 Check commandline for a sub-string "-Embedding".

--*/
UINT GetAppLaunchMethod()
{
    WCHAR *pwstrCmdLine;
 
    //
    // If we have not check this, then do it 
    //
    if (g_nEmbeddingObject == EMBEDDIND_STATUS_UNKOWN)
    {
        CString cStrCmdLineRightPart;
        CString cStrCmdLine = GetCommandLine();
        CString cstrEmbeded(L"-Embedding");

        cStrCmdLineRightPart = cStrCmdLine.Right(cstrEmbeded.GetLength());
        if (cStrCmdLineRightPart.CompareNoCase(cstrEmbeded))
        {
            g_nEmbeddingObject = EMBEDDIND_STATUS_NO;
        }
        else
        {
            g_nEmbeddingObject = EMBEDDIND_STATUS_YES;
        }
    }

    return (g_nEmbeddingObject);
}

/*++

 Hook CreateDialogIndirectParamA to find this specific dlg and subclass
 edit control on it 

--*/

HWND 
APIHOOK(CreateDialogIndirectParamA)( 
    HINSTANCE hInstance, 
    LPCDLGTEMPLATE lpTemplate, 
    HWND hWndParent, 
    DLGPROC lpDialogFunc, 
    LPARAM lParamInit
    )
{
    HWND hDlg;
    WCHAR wszCaption[MAX_PATH];
    WCHAR wszTitle[] = { (WCHAR)0x6587, (WCHAR)0x672c, (WCHAR)0x8f93, (WCHAR)0x5165, (WCHAR)0x0000 };
    CString cstrCaption;
    
    hDlg = ORIGINAL_API(CreateDialogIndirectParamA)(hInstance, lpTemplate,
        hWndParent, lpDialogFunc, lParamInit);

    //
    // If dlg can not be created or not launched as OLE server, ignore it
    //
    if (!hDlg ||  (EMBEDDIND_STATUS_YES != GetAppLaunchMethod()))
    {
        goto End;
    }

    //
    // Try to get caption and see if that's the dlg we are interested 
    //
    if (!GetWindowText(hDlg, wszCaption, MAX_PATH))
    {
        goto End;
    }

    cstrCaption = wszCaption;
    if (!cstrCaption.CompareNoCase(wszTitle))
    {
        EnumChildWindows(hDlg, EnumChildProc, NULL);
    }

End:
    return hDlg;
}

/*++

 Register hooked functions

--*/

HOOK_BEGIN
    APIHOOK_ENTRY(USER32.DLL, CreateDialogIndirectParamA)        
HOOK_END

IMPLEMENT_SHIM_END
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\appcompat\shims\verifier\ids.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by verifier.rc
//
// Scheme for resource includes:
//  
// - Dialog box definition and controls should start at 0
//   and should end at 49.
//
// - VLOG entries and other AVS defines should start at 50
//   and should end at 99.
//
// - Each shim should be placed into it's own section
//   to keep defines separated for all shims.
//

/*****************************************************
// RegistryChecks Begin
//***************************************************/
#define AVS_HKCU_AppEvents_READ                     10
#define AVS_HKCU_AppEvents_READ_R                   11
#define AVS_HKCU_AppEvents_READ_URL                 12
#define AVS_HKCU_Console_READ                       13
#define AVS_HKCU_Console_READ_R                     14
#define AVS_HKCU_Console_READ_URL                   15
#define AVS_HKCU_ControlPanel_READ                  16
#define AVS_HKCU_ControlPanel_READ_R                17
#define AVS_HKCU_ControlPanel_READ_URL              18
#define AVS_HKCU_Environment_READ                   19
#define AVS_HKCU_Environment_READ_R                 20
#define AVS_HKCU_Environment_READ_URL               21
#define AVS_HKCU_Identities_READ                    22
#define AVS_HKCU_Identities_READ_R                  23
#define AVS_HKCU_Identities_READ_URL                24
#define AVS_HKCU_KeyboardLayout_READ                25
#define AVS_HKCU_KeyboardLayout_READ_R              26
#define AVS_HKCU_KeyboardLayout_READ_URL            27
#define AVS_HKCU_Printers_READ                      28
#define AVS_HKCU_Printers_READ_R                    29
#define AVS_HKCU_Printers_READ_URL                  30
#define AVS_HKCU_RemoteAccess_READ                  31
#define AVS_HKCU_RemoteAccess_READ_R                32
#define AVS_HKCU_RemoteAccess_READ_URL              33
#define AVS_HKCU_SessionInformation_READ            34
#define AVS_HKCU_SessionInformation_READ_R          35
#define AVS_HKCU_SessionInformation_READ_URL        36
#define AVS_HKCU_UNICODEProgramGroups_READ          37
#define AVS_HKCU_UNICODEProgramGroups_READ_R        38
#define AVS_HKCU_UNICODEProgramGroups_READ_URL      39
#define AVS_HKCU_VolatileEnvironment_READ           40
#define AVS_HKCU_VolatileEnvironment_READ_R         41
#define AVS_HKCU_VolatileEnvironment_READ_URL       42
#define AVS_HKCU_Windows31MigrationStatus_READ      43
#define AVS_HKCU_Windows31MigrationStatus_READ_R    44
#define AVS_HKCU_Windows31MigrationStatus_READ_URL  45
#define AVS_HKLM_HARDWARE_READ                      46
#define AVS_HKLM_HARDWARE_READ_R                    47
#define AVS_HKLM_HARDWARE_READ_URL                  48
#define AVS_HKLM_SAM_READ                           49
#define AVS_HKLM_SAM_READ_R                         50
#define AVS_HKLM_SAM_READ_URL                       51
#define AVS_HKLM_SECURITY_READ                      52
#define AVS_HKLM_SECURITY_READ_R                    53
#define AVS_HKLM_SECURITY_READ_URL                  54
#define AVS_HKLM_SYSTEM_READ                        55
#define AVS_HKLM_SYSTEM_READ_R                      56
#define AVS_HKLM_SYSTEM_READ_URL                    57
#define AVS_HKCC_READ                               58
#define AVS_HKCC_READ_R                             59
#define AVS_HKCC_READ_URL                           60
#define AVS_HKUS_READ                               61
#define AVS_HKUS_READ_R                             62
#define AVS_HKUS_READ_URL                           63
#define AVS_NON_HKCU_WRITE                          64
#define AVS_NON_HKCU_WRITE_R                        65
#define AVS_NON_HKCU_WRITE_URL                      66
#define AVS_REGISTRYCHECKS_DESC                     67
#define AVS_REGISTRYCHECKS_FRIENDLY                 68
/*****************************************************
// RegistryChecks End
//***************************************************/

/*****************************************************
// FilePaths Begin
//***************************************************/
#define AVS_HARDCODED_WINDOWSPATH                   150
#define AVS_HARDCODED_WINDOWSPATH_R                 151
#define AVS_HARDCODED_WINDOWSPATH_URL               152
#define AVS_HARDCODED_SYSWINDOWSPATH                153
#define AVS_HARDCODED_SYSWINDOWSPATH_R              154
#define AVS_HARDCODED_SYSWINDOWSPATH_URL            155
#define AVS_HARDCODED_SYSTEMPATH                    156
#define AVS_HARDCODED_SYSTEMPATH_R                  157
#define AVS_HARDCODED_SYSTEMPATH_URL                158
#define AVS_HARDCODED_PERSONALPATH                  159
#define AVS_HARDCODED_PERSONALPATH_R                160
#define AVS_HARDCODED_PERSONALPATH_URL              161
#define AVS_HARDCODED_COMMONPROGRAMS                162
#define AVS_HARDCODED_COMMONPROGRAMS_R              163
#define AVS_HARDCODED_COMMONPROGRAMS_URL            164
#define AVS_HARDCODED_COMMONSTARTMENU               165
#define AVS_HARDCODED_COMMONSTARTMENU_R             166
#define AVS_HARDCODED_COMMONSTARTMENU_URL           167
#define AVS_HARDCODED_PROGRAMS                      168
#define AVS_HARDCODED_PROGRAMS_R                    169
#define AVS_HARDCODED_PROGRAMS_URL                  170
#define AVS_HARDCODED_STARTMENU                     171
#define AVS_HARDCODED_STARTMENU_R                   172
#define AVS_HARDCODED_STARTMENU_URL                 173
#define AVS_HARDCODED_GETTEMPPATH                   174
#define AVS_HARDCODED_GETTEMPPATH_R                 175
#define AVS_HARDCODED_GETTEMPPATH_URL               176
#define AVS_FILEPATHS_DESC                          177
#define AVS_FILEPATHS_FRIENDLY                      178
/*****************************************************
// FilePaths End
//***************************************************/

/*****************************************************
// LogStartAndStop Begin
//***************************************************/
#define AVS_APP_STOPPED                             250
#define AVS_APP_STOPPED_R                           251
#define AVS_APP_STOPPED_URL                         252
#define AVS_APP_STARTED                             253
#define AVS_APP_STARTED_R                           254
#define AVS_APP_STARTED_URL                         255
#define AVS_LOGSTARTANDSTOP_DESC                    256
#define AVS_LOGSTARTANDSTOP_FRIENDLY                257
/*****************************************************
// LogStartAndStop End
//***************************************************/

/*****************************************************
// HighVersionLie Begin
//***************************************************/
#define IDD_HIGHVERSION_OPTIONS                     300
#define IDC_HVL_EDIT_MAJOR_VERSION                  301
#define IDC_HVL_EDIT_MINOR_VERSION                  302
#define IDC_HVL_EDIT_BUILD_NUMBER                   303
#define IDC_HVL_BTN_DEFAULT                         304
#define AVS_HIGHVERSION_GETVERSIONEX                350
#define AVS_HIGHVERSION_GETVERSIONEX_R              351
#define AVS_HIGHVERSION_GETVERSIONEX_URL            352
#define AVS_HIGHVERSION_GETVERSION                  353
#define AVS_HIGHVERSION_GETVERSION_R                354
#define AVS_HIGHVERSION_GETVERSION_URL              355
#define AVS_HIGHVERSIONLIE_DESC                     356
#define AVS_HIGHVERSIONLIE_FRIENDLY                 357
/*****************************************************
// HighVersionLie End
//***************************************************/

/*****************************************************
// LogFileChanges Begin
//***************************************************/
#define IDD_LOGFILECHANGES_OPTIONS                  400
#define IDC_LFC_LOG_ATTRIBUTES                      401
#define IDC_LFC_UFW_PROGFILES                       402
#define IDC_LFC_UFW_WINDOWS                         403
#define IDC_LFC_BTN_DEFAULT                         404
#define AVS_LOGFILECHANGES_LOGLOC                   450
#define AVS_LOGFILECHANGES_LOGLOC_R                 451
#define AVS_LOGFILECHANGES_LOGLOC_URL               452
#define AVS_LOGFILECHANGES_UFW                      453
#define AVS_LOGFILECHANGES_UFW_R                    454
#define AVS_LOGFILECHANGES_UFW_URL                  455
#define AVS_LOGFILECHANGES_DESC                     456
#define AVS_LOGFILECHANGES_FRIENDLY                 457
/*****************************************************
// LogFileChanges End
//***************************************************/

/*****************************************************
// WindowsFileProtection Begin
//***************************************************/
#define AVS_WFP_COPYFILE                            550
#define AVS_WFP_MOVEFILE                            551
#define AVS_WFP_DELETEFILE                          552
#define AVS_WFP_REPLACEFILE                         553
#define AVS_WFP_WRITEFILE                           554
#define AVS_WFP_OPENFILE                            555
#define AVS_WFP_SHFILEOP                            556
#define AVS_WFP_GENERAL_R                           557
#define AVS_WFP_GENERAL_URL                         558
#define AVS_WINFILEPROTECT_DESC                     559
#define AVS_WINFILEPROTECT_FRIENDLY                 560
/*****************************************************
// WindowsFileProtection End
//***************************************************/

/*****************************************************
// DirectXFileVersionInfo Begin
//***************************************************/
#define AVS_DXFILEVERINFO_DXFILE                    650
#define AVS_DXFILEVERINFO_DXFILE_R                  651
#define AVS_DXFILEVERINFO_DXFILE_URL                652
#define AVS_DXFILEVERINFO_DESC                      653
#define AVS_DXFILEVERINFO_FRIENDLY                  654
/*****************************************************
// DirectXFileVersionInfo End
//***************************************************/

/*****************************************************
// LogRegistryChanges Begin
//***************************************************/
#define AVS_LOGREGCHANGES_LOGLOC                    750
#define AVS_LOGREGCHANGES_LOGLOC_R                  751
#define AVS_LOGREGCHANGES_LOGLOC_URL                752
#define AVS_LOGREGCHANGES_DESC                      753
#define AVS_LOGREGCHANGES_FRIENDLY                  754
/*****************************************************
// LogRegistryChanges End
//***************************************************/

/*****************************************************
// ObsoleteAPICalls Begin
//***************************************************/
#define AVS_OBSOLETECALLS_API                       850
#define AVS_OBSOLETECALLS_API_R                     851
#define AVS_OBSOLETECALLS_API_URL                   852
#define AVS_OBSOLETECALLS_DESC                      853
#define AVS_OBSOLETECALLS_FRIENDLY                  854
/*****************************************************
// ObsoleteAPICalls End
//***************************************************/

/*****************************************************
// KernelModeDriverInstall Begin
//***************************************************/
#define AVS_KMODEDRIVER_INST                        950
#define AVS_KMODEDRIVER_INST_R                      951
#define AVS_KMODEDRIVER_INST_URL                    952
#define AVS_KMODEDRIVER_DESC                        953
#define AVS_KMODEDRIVER_FRIENDLY                    954
/*****************************************************
// KernelModeDriverInstall End
//***************************************************/

/*****************************************************
// SecurityChecks Begin
//***************************************************/
#define AVS_SECURITYCHECKS_DESC                     1050
#define AVS_SECURITYCHECKS_FRIENDLY                 1051
#define AVS_SECURITYCHECKS_BADARGUMENTS             1052
#define AVS_SECURITYCHECKS_BADARGUMENTS_R           1053
#define AVS_SECURITYCHECKS_BADARGUMENTS_URL         1054
#define AVS_SECURITYCHECKS_WINEXEC                  1055
#define AVS_SECURITYCHECKS_WINEXEC_R                1056
#define AVS_SECURITYCHECKS_WINEXEC_URL              1057
#define AVS_SECURITYCHECKS_NULL_DACL                1058
#define AVS_SECURITYCHECKS_NULL_DACL_R              1059
#define AVS_SECURITYCHECKS_NULL_DACL_URL            1060
#define AVS_SECURITYCHECKS_WORLDWRITE_DACL          1061
#define AVS_SECURITYCHECKS_WORLDWRITE_DACL_R        1062
#define AVS_SECURITYCHECKS_WORLDWRITE_DACL_URL      1063
/*****************************************************
// KernelModeDriverInstall End
//***************************************************/

#define IDC_STATIC                      -1

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NO_MFC                     1
#define _APS_NEXT_RESOURCE_VALUE        104
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1010
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\appcompat\shims\verifier\highversionlie.cpp ===
/*++

 Copyright (c) 2000 Microsoft Corporation

 Module Name:

   HighVersionLie.cpp

 Abstract:

   This DLL hooks GetVersion and GetVersionEx so that they return a future OS
   version credentials.

 Notes:

   This is a general purpose shim.

 History:

   02/08/2001   clupu       Created
   09/21/2001   rparsons    Added VLOG on hooks per billshih.
   10/17/2001   rparsons    Fixed bugs in GetVersionExW and GetVersion.
   11/27/2001   rparsons    Modified the VLOGs so they display what we
                            used for the API call.

--*/

#include "precomp.h"

IMPLEMENT_SHIM_BEGIN(HighVersionLie)
#include "ShimHookMacro.h"

BEGIN_DEFINE_VERIFIER_LOG(HighVersionLie)
    VERIFIER_LOG_ENTRY(VLOG_HIGHVERSION_GETVERSION)    
    VERIFIER_LOG_ENTRY(VLOG_HIGHVERSION_GETVERSIONEX)
END_DEFINE_VERIFIER_LOG(HighVersionLie)

INIT_VERIFIER_LOG(HighVersionLie);

APIHOOK_ENUM_BEGIN
    APIHOOK_ENUM_ENTRY(GetVersionExA)
    APIHOOK_ENUM_ENTRY(GetVersionExW)
    APIHOOK_ENUM_ENTRY(GetVersion)
APIHOOK_ENUM_END

DWORD g_dwMajorVersion;
DWORD g_dwMinorVersion;
DWORD g_dwBuildNumber;

BOOL
APIHOOK(GetVersionExA)(
    OUT LPOSVERSIONINFOA lpVersionInformation
    )
{
    BOOL bReturn = FALSE;

    if (ORIGINAL_API(GetVersionExA)(lpVersionInformation)) {
        LOGN(eDbgLevelInfo,
             "[GetVersionExA] called. Returning %lu.%lu build %lu",
             g_dwMajorVersion,
             g_dwMinorVersion,
             g_dwBuildNumber);

        VLOG(VLOG_LEVEL_INFO,
             VLOG_HIGHVERSION_GETVERSIONEX,
             "Returned %lu.%lu build number %lu.",
             g_dwMajorVersion,
             g_dwMinorVersion,
             g_dwBuildNumber);
        
        lpVersionInformation->dwMajorVersion = g_dwMajorVersion;
        lpVersionInformation->dwMinorVersion = g_dwMinorVersion;
        lpVersionInformation->dwBuildNumber  = g_dwBuildNumber;
        lpVersionInformation->dwPlatformId   = VER_PLATFORM_WIN32_NT;
        *lpVersionInformation->szCSDVersion  = '\0';

        bReturn = TRUE;
    }
    return bReturn;
}

BOOL
APIHOOK(GetVersionExW)(
    OUT LPOSVERSIONINFOW lpVersionInformation
    )
{
    BOOL bReturn = FALSE;

    if (ORIGINAL_API(GetVersionExW)(lpVersionInformation)) {
        LOGN(eDbgLevelInfo,
             "[GetVersionExW] called. Returning %lu.%lu build %lu",
             g_dwMajorVersion,
             g_dwMinorVersion,
             g_dwBuildNumber);

        VLOG(VLOG_LEVEL_INFO,
             VLOG_HIGHVERSION_GETVERSIONEX,
             "Returned %lu.%lu build number %lu.",
             g_dwMajorVersion,
             g_dwMinorVersion,
             g_dwBuildNumber);

        lpVersionInformation->dwMajorVersion = g_dwMajorVersion;
        lpVersionInformation->dwMinorVersion = g_dwMinorVersion;
        lpVersionInformation->dwBuildNumber  = g_dwBuildNumber;
        lpVersionInformation->dwPlatformId   = VER_PLATFORM_WIN32_NT;
        *lpVersionInformation->szCSDVersion  = L'\0';

        bReturn = TRUE;
    }
    return bReturn;
}

DWORD
APIHOOK(GetVersion)(
    void
    )
{
    LOGN(eDbgLevelInfo,
         "[GetVersion] called. Returning %lu.%lu build %lu",
         g_dwMajorVersion,
         g_dwMinorVersion,
         g_dwBuildNumber);

    VLOG(VLOG_LEVEL_INFO,
         VLOG_HIGHVERSION_GETVERSION,
         "Returned %lu.%lu build number %lu.",
         g_dwMajorVersion,
         g_dwMinorVersion,
         g_dwBuildNumber);
    
    return (((VER_PLATFORM_WIN32_NT ^ 0x2) << 30) |
            (g_dwBuildNumber << 16) |
            (g_dwMinorVersion << 8) |
             g_dwMajorVersion);
}

LRESULT CALLBACK
DlgOptions(
    HWND   hDlg,
    UINT   message,
    WPARAM wParam,
    LPARAM lParam
    )
{
    static LPCWSTR szExeName;

    switch (message) {
    case WM_INITDIALOG:
        {
            WCHAR szTemp[20];

            //
            // Limit the number of characters for each edit control.
            //
            SendDlgItemMessage(hDlg, IDC_HVL_EDIT_MAJOR_VERSION, EM_LIMITTEXT, (WPARAM)5, 0);
            SendDlgItemMessage(hDlg, IDC_HVL_EDIT_MINOR_VERSION, EM_LIMITTEXT, (WPARAM)5, 0);
            SendDlgItemMessage(hDlg, IDC_HVL_EDIT_BUILD_NUMBER, EM_LIMITTEXT, (WPARAM)5, 0);

            //
            // find out what exe we're handling settings for
            //
            szExeName = ExeNameFromLParam(lParam);

            g_dwMajorVersion = GetShimSettingDWORD(L"HighVersionLie", szExeName, L"MajorVersion", 7);
            g_dwMinorVersion = GetShimSettingDWORD(L"HighVersionLie", szExeName, L"MinorVersion", 2);
            g_dwBuildNumber  = GetShimSettingDWORD(L"HighVersionLie", szExeName, L"BuildNumber", 3595);

            swprintf(szTemp, L"%d", g_dwMajorVersion);
            SetDlgItemText(hDlg, IDC_HVL_EDIT_MAJOR_VERSION, szTemp);
            
            swprintf(szTemp, L"%d", g_dwMinorVersion);
            SetDlgItemText(hDlg, IDC_HVL_EDIT_MINOR_VERSION, szTemp);
            
            swprintf(szTemp, L"%d", g_dwBuildNumber);
            SetDlgItemText(hDlg, IDC_HVL_EDIT_BUILD_NUMBER, szTemp);

            return TRUE;
        }
        break;

    case WM_COMMAND:
        switch (LOWORD(wParam)) {
        case IDC_HVL_BTN_DEFAULT:
            {
                WCHAR szTemp[20];

                g_dwMajorVersion = 7;
                g_dwMinorVersion = 2;
                g_dwBuildNumber = 3595;

                //
                // Limit the number of characters for each edit control.
                //
                SendDlgItemMessage(hDlg, IDC_HVL_EDIT_MAJOR_VERSION, EM_LIMITTEXT, (WPARAM)5, 0);
                SendDlgItemMessage(hDlg, IDC_HVL_EDIT_MINOR_VERSION, EM_LIMITTEXT, (WPARAM)5, 0);
                SendDlgItemMessage(hDlg, IDC_HVL_EDIT_BUILD_NUMBER, EM_LIMITTEXT, (WPARAM)5, 0);

                swprintf(szTemp, L"%d", g_dwMajorVersion);
                SetDlgItemText(hDlg, IDC_HVL_EDIT_MAJOR_VERSION, szTemp);

                swprintf(szTemp, L"%d", g_dwMinorVersion);
                SetDlgItemText(hDlg, IDC_HVL_EDIT_MINOR_VERSION, szTemp);

                swprintf(szTemp, L"%d", g_dwBuildNumber);
                SetDlgItemText(hDlg, IDC_HVL_EDIT_BUILD_NUMBER, szTemp);

                break;
            }
        }
        break;


    case WM_NOTIFY:
        switch (((NMHDR FAR *) lParam)->code) {
    
        case PSN_APPLY:

            g_dwMajorVersion = GetDlgItemInt(hDlg, IDC_HVL_EDIT_MAJOR_VERSION, NULL, FALSE);
            g_dwMinorVersion = GetDlgItemInt(hDlg, IDC_HVL_EDIT_MINOR_VERSION, NULL, FALSE);
            g_dwBuildNumber  = GetDlgItemInt(hDlg, IDC_HVL_EDIT_BUILD_NUMBER, NULL, FALSE);

            SaveShimSettingDWORD(L"HighVersionLie", szExeName, L"MajorVersion", g_dwMajorVersion);
            SaveShimSettingDWORD(L"HighVersionLie", szExeName, L"MinorVersion", g_dwMinorVersion);
            SaveShimSettingDWORD(L"HighVersionLie", szExeName, L"BuildNumber", g_dwBuildNumber);

            break;
        }
        break;
    }

    return FALSE;
}

SHIM_INFO_BEGIN()

    SHIM_INFO_DESCRIPTION(AVS_HIGHVERSIONLIE_DESC)
    SHIM_INFO_FRIENDLY_NAME(AVS_HIGHVERSIONLIE_FRIENDLY)
    SHIM_INFO_VERSION(1, 2)
    SHIM_INFO_INCLUDE_EXCLUDE("E:msvcrt.dll msvcirt.dll oleaut32.dll")
    SHIM_INFO_OPTIONS_PAGE(IDD_HIGHVERSION_OPTIONS, DlgOptions)

SHIM_INFO_END()

/*++

 Register hooked functions

--*/

HOOK_BEGIN

    if (fdwReason == DLL_PROCESS_ATTACH) {
        //
        // get the settings
        //
        WCHAR szExe[100];

        GetCurrentExeName(szExe, 100);

        g_dwMajorVersion = GetShimSettingDWORD(L"HighVersionLie", szExe, L"MajorVersion", 7);
        g_dwMinorVersion = GetShimSettingDWORD(L"HighVersionLie", szExe, L"MinorVersion", 2);
        g_dwBuildNumber = GetShimSettingDWORD(L"HighVersionLie", szExe, L"BuildNumber", 3595);

        DUMP_VERIFIER_LOG_ENTRY(VLOG_HIGHVERSION_GETVERSION, 
                                AVS_HIGHVERSION_GETVERSION,
                                AVS_HIGHVERSION_GETVERSION_R,
                                AVS_HIGHVERSION_GETVERSION_URL)

        DUMP_VERIFIER_LOG_ENTRY(VLOG_HIGHVERSION_GETVERSIONEX, 
                                AVS_HIGHVERSION_GETVERSIONEX,
                                AVS_HIGHVERSION_GETVERSIONEX_R,
                                AVS_HIGHVERSION_GETVERSIONEX_URL)
    }

    APIHOOK_ENTRY(KERNEL32.DLL, GetVersionExA)
    APIHOOK_ENTRY(KERNEL32.DLL, GetVersionExW)
    APIHOOK_ENTRY(KERNEL32.DLL, GetVersion)

HOOK_END



IMPLEMENT_SHIM_END
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\appcompat\shims\verifier\logfilechanges.cpp ===
/*++

 Copyright (c) 2001 Microsoft Corporation

 Module Name:

   LogFileChanges.cpp

 Abstract:
 
   This AppVerifier shim hooks all the native file I/O APIs
   that change the state of the system and logs their
   associated data to a text file.

 Notes:

   This is a general purpose shim.

 History:

   08/17/2001   rparsons    Created
   09/20/2001   rparsons    Output attributes in XML
                            VLOG with log file location

--*/
#include "precomp.h"
#include "rtlutils.h"

IMPLEMENT_SHIM_BEGIN(LogFileChanges)
#include "ShimHookMacro.h"
#include "LogFileChanges.h"

BEGIN_DEFINE_VERIFIER_LOG(LogFileChanges)
    VERIFIER_LOG_ENTRY(VLOG_LOGFILECHANGES_LOGLOC)
    VERIFIER_LOG_ENTRY(VLOG_LOGFILECHANGES_UFW)
END_DEFINE_VERIFIER_LOG(LogFileChanges)

INIT_VERIFIER_LOG(LogFileChanges);

//
// Stores the NT path to the file system log file for the current session.
//
UNICODE_STRING g_strLogFilePath;

//
// Stores the DOS path to the file system log file for the current session.
// This doesn't get freed.
//
LPWSTR g_pwszLogFilePath;

//
// Head of our doubly linked list.
//
LIST_ENTRY g_OpenHandleListHead;

//
// Stores the settings for our shim.
//
DWORD g_dwSettings;

//
// Global buffer for putting text into the XML.
//
WCHAR g_wszXMLBuffer[MAX_ELEMENT_SIZE];

/*++

 Writes an entry to the log file.
 
--*/
void
WriteEntryToLog(
    IN LPCWSTR pwszEntry
    )
{
    int                 nLen = 0;
    HANDLE              hFile;
    OBJECT_ATTRIBUTES   ObjectAttributes;
    IO_STATUS_BLOCK     IoStatusBlock;
    LARGE_INTEGER       liOffset;
    NTSTATUS            status;

    //
    // Note that we have to use native APIs throughout this function
    // to avoid a problem with circular hooking. That is, if we simply
    // call WriteFile, which is exported from kernel32, it will call NtWriteFile,
    // which is a call that we hook, in turn leaving us in and endless loop.
    //
    
    //
    // Attempt to get a handle to our log file.
    //
    InitializeObjectAttributes(&ObjectAttributes,
                               &g_strLogFilePath,
                               OBJ_CASE_INSENSITIVE,
                               NULL,
                               NULL);

    status = NtCreateFile(&hFile,
                          FILE_APPEND_DATA | SYNCHRONIZE,
                          &ObjectAttributes,
                          &IoStatusBlock,
                          0,
                          FILE_ATTRIBUTE_NORMAL,
                          0,
                          FILE_OPEN,
                          FILE_NON_DIRECTORY_FILE | FILE_SYNCHRONOUS_IO_NONALERT,
                          NULL,
                          0);

    if (!NT_SUCCESS(status)) {
        DPFN(eDbgLevelError, "[WriteEntryToLog] Failed to open log");
        return;
    }
    
    //
    // Write the data out to the file.
    //
    nLen = wcslen(pwszEntry);

    IoStatusBlock.Status = 0;
    IoStatusBlock.Information = 0;

    liOffset.LowPart  = 0;
    liOffset.HighPart = 0;

    status = NtWriteFile(hFile,
                         NULL,
                         NULL,
                         NULL,
                         &IoStatusBlock,
                         (PVOID)pwszEntry,
                         (ULONG)(nLen) * sizeof(WCHAR),
                         &liOffset,
                         NULL);
    
    if (!NT_SUCCESS(status)) {
        DPFN(eDbgLevelError, "[WriteEntryToLog] 0x%X Failed to make entry", status);
        goto exit;
    }

exit:

    NtClose(hFile);

}

/*++

 Creates our log files using the local time.
 It goes into %windir%\AppPatch\VLog.
 
--*/
BOOL
InitializeLogFile(
    void
    )
{
    BOOL                fReturn = FALSE;
    HANDLE              hFile;
    SYSTEMTIME          st;
    UINT                nLen = 0;
    WCHAR               wszFileLog[64];
    WCHAR*              pwszLogFile = NULL;
    WCHAR*              pSlash = NULL;
    WCHAR*              pDot = NULL;
    WCHAR               wszModPathName[MAX_PATH];
    WCHAR               wszShortName[MAX_PATH];
    WCHAR               wszLogHdr[512];
    const WCHAR         wszLogDir[] = L"\\AppPatch\\VLog";
    WCHAR               wszUnicodeHdr = 0xFEFF;
    UNICODE_STRING      strLogFile;
    NTSTATUS            status;
    OBJECT_ATTRIBUTES   ObjectAttributes;
    IO_STATUS_BLOCK     IoStatusBlock;
    
    //
    // Format the log header.
    //
    if (!GetModuleFileName(NULL, wszModPathName, ARRAYSIZE(wszModPathName))) {
        wcscpy(wszModPathName, L"unknown");
    }

    if (_snwprintf(wszLogHdr,
                   ARRAYSIZE(wszLogHdr) - 1,
                   L"%lc<?xml version=\"1.0\" encoding=\"UTF-16\"?>\r\n<APPLICATION NAME=\"%ls\">\r\n",
                   wszUnicodeHdr,
                   wszModPathName) < 0) {
        DPFN(eDbgLevelError, "[InitializeLogFile] Buffer too small (1)");
        return FALSE;
    }
    
    //
    // Get the current time and set up the log file name.
    // The format of the log file name is this:
    // 'processname_filesys_yyyymmdd_hhmmss.xml'
    //
    GetLocalTime(&st);

    //
    // Extract the name of this module without the path and extension.
    // Basically we trim off the extension first (if there is one.)
    // Next we find out where the directory path ends, then grab
    // the file portion and save it away.
    //
    wszShortName[0] = 0;
    pDot = wcsrchr(wszModPathName, '.');

    if (pDot) {
        *pDot = '\0';
    }

    pSlash = wcsrchr(wszModPathName, '\\');

    if (pSlash) {
        wcsncpy(wszShortName, ++pSlash, (wcslen(pSlash) + 1));
    }

    if (_snwprintf(wszFileLog,
                   ARRAYSIZE(wszFileLog) - 1,
                   L"%ls_filesys_%02hu%02hu%02hu_%02hu%02hu%02hu.xml",
                   wszShortName,
                   st.wYear,
                   st.wMonth,
                   st.wDay,
                   st.wHour,
                   st.wMinute,
                   st.wSecond) < 0) {
        DPFN(eDbgLevelError, "[InitializeLogFile] Buffer too small (2)");
        return FALSE;
    }
        
    //
    // Set up the path our log file.
    //
    nLen = GetSystemWindowsDirectory(NULL, 0);

    if (0 == nLen) {
        DPFN(eDbgLevelError,
             "[InitializeLogFile] %lu Failed to get size for Windows directory path",
             GetLastError());
        return FALSE;
    }

    nLen += wcslen(wszFileLog);
    nLen += wcslen(wszLogDir);

    pwszLogFile = (LPWSTR)MemAlloc((nLen + 2) * sizeof(WCHAR));

    if (!pwszLogFile) {
        DPFN(eDbgLevelError, "[InitializeLogFile] No memory for log file");
        return FALSE;
    }

    nLen = GetSystemWindowsDirectory(pwszLogFile, (nLen + 2) * sizeof(WCHAR));

    if (0 == nLen) {
        DPFN(eDbgLevelError,
             "[InitializeLogFile] %lu Failed to get Windows directory path",
             GetLastError());
        return FALSE;
    }

    wcscat(pwszLogFile, wszLogDir);
    
    //
    // Ensure that the %windir%\AppPatch\VLog directory exists.
    // If it doesn't, attempt to create it.
    //
    if (-1 == GetFileAttributes(pwszLogFile)) {
        if (!CreateDirectory(pwszLogFile, NULL)) {
            DPFN(eDbgLevelError,
                 "[InitializeLogFile] %lu Failed to create VLog directory",
                 GetLastError());
            return FALSE;
        }
    }

    wcscat(pwszLogFile, L"\\");
    wcscat(pwszLogFile, wszFileLog);

    //
    // Save the pointer as we'll need it later.
    //
    g_pwszLogFilePath = pwszLogFile;

    //
    // Attempt to create the new log file.
    //
    RtlInitUnicodeString(&strLogFile, pwszLogFile);

    status = RtlDosPathNameToNtPathName_U(strLogFile.Buffer,
                                          &strLogFile,
                                          NULL,
                                          NULL);

    if (!NT_SUCCESS(status)) {
        DPFN(eDbgLevelError, "[InitializeLogFile] DOS -> NT failed");
        return FALSE;
    }

    InitializeObjectAttributes(&ObjectAttributes,
                               &strLogFile,
                               OBJ_CASE_INSENSITIVE,
                               NULL,
                               NULL);

    status = NtCreateFile(&hFile,
                          GENERIC_WRITE | SYNCHRONIZE,
                          &ObjectAttributes,
                          &IoStatusBlock,
                          NULL,
                          FILE_ATTRIBUTE_NORMAL,
                          0,
                          FILE_CREATE,
                          FILE_NON_DIRECTORY_FILE | FILE_SYNCHRONOUS_IO_NONALERT,
                          NULL,
                          0);

    if (!NT_SUCCESS(status)) {
        DPFN(eDbgLevelError,
             "[InitializeLogFile] 0x%X Failed to create log",
             status);
        goto cleanup;
    }

    NtClose(hFile);

    //
    // Save away the NT path to the file.
    //
    status = ShimDuplicateUnicodeString(RTL_DUPLICATE_UNICODE_STRING_NULL_TERMINATE | 
                                        RTL_DUPLICATE_UNICODE_STRING_ALLOCATE_NULL_STRING,
                                        &strLogFile,
                                        &g_strLogFilePath);

    if (!NT_SUCCESS(status)) {
        DPFN(eDbgLevelError,
             "[InitializeLogFile] Failed to save log file path");
        goto cleanup;
    }

    //
    // Write the header to the log.
    //                             
    WriteEntryToLog(wszLogHdr);

    fReturn = TRUE;

cleanup:

    RtlFreeUnicodeString(&strLogFile);

    return fReturn;
}

/*++

 Displays the name associated with this object.
 
--*/
void
PrintNameFromHandle(
    IN HANDLE hObject
    )
{
    NTSTATUS                status;
    WCHAR                   wszBuffer[MAX_PATH];
    OBJECT_NAME_INFORMATION *poni = NULL;

    wszBuffer[0] = 0;
    
    poni = (OBJECT_NAME_INFORMATION*)wszBuffer;

    status = NtQueryObject(hObject, ObjectNameInformation, poni, MAX_PATH, NULL);

    if (NT_SUCCESS(status)) {
        DPFN(eDbgLevelInfo, "Handle 0x%08x has name: %ls", hObject, poni->Name.Buffer); 
    }
}

/*++

 Formats the data to form an XML element.
 
--*/
void
FormatDataIntoElement(
    IN OperationType eType,
    IN LPCWSTR       pwszFilePath
    )
{
    int         nChars = 0;
    DWORD       dwCount;
    DWORD       dwAttrCount = 0;
    WCHAR       wszItem[MAX_PATH];
    WCHAR       wszOperation[MAX_OPERATION_LENGTH];
    PATTRINFO   pAttrInfo = NULL;

    CString csFilePart(L"");
    CString csPathPart(L"");
    CString csString(pwszFilePath);

    g_wszXMLBuffer[0] = 0;

    //
    // Replace any & or ' in the file path.
    // We have to do this since we're saving to XML.
    // Note that the file system doesn't allow < > or "
    //
    csString.Replace(L"&", L"amp;");
    csString.Replace(L"'", L"&apos;");

    //
    // Put the path into a CString, then break it into pieces
    // so we can use it in our element.
    //
    csString.GetNotLastPathComponent(csPathPart);
    csString.GetLastPathComponent(csFilePart);

    switch (eType) {
    case eCreatedFile:
        wcscpy(wszOperation, L"Created File");
        break;
    case eModifiedFile:
        wcscpy(wszOperation, L"Modified File");
        break;
    case eDeletedFile:
        wcscpy(wszOperation, L"Deleted File");
        break;
    default:
        wcscpy(wszOperation, L"Unknown");
        break;
    }

    //
    // If we're logging attributes and this is not file deletion, press on.
    //
    if ((g_dwSettings & LFC_OPTION_ATTRIBUTES) && (eType != eDeletedFile)) {
        
        nChars = wsprintf(g_wszXMLBuffer,
                          L"    <FILE OPERATION=\"%ls\" NAME=\"%ls\" PATH=\"%ls\"",
                          wszOperation,
                          csFilePart.Get(),
                          csPathPart.Get());
        //
        // Call the attribute manager to get the attributes for this file.
        // Loop through all the attributes and add the ones that are available.
        //
        if (SdbGetFileAttributes(pwszFilePath, &pAttrInfo, &dwAttrCount)) {
            
            for (dwCount = 0; dwCount < dwAttrCount; dwCount++) {

                if (pAttrInfo[dwCount].dwFlags & ATTRIBUTE_AVAILABLE) {
                    if (!SdbFormatAttribute(&pAttrInfo[dwCount], wszItem, MAX_PATH)) {
                        continue;
                    }
    
                    nChars += wsprintf(g_wszXMLBuffer + nChars, L" %ls", wszItem);
                }
            }
        
            if (pAttrInfo) {
                SdbFreeFileAttributes(pAttrInfo);
            }
        }

        //
        // Append the '/>\r\n' to the file element.
        //
        wsprintf(g_wszXMLBuffer + nChars, L"/>\r\n");
    } else {
        //
        // Format the element without attributes.
        //
        wsprintf(g_wszXMLBuffer,
                 L"    <FILE OPERATION=\"%ls\" NAME=\"%ls\" PATH=\"%ls\"/>\r\n",
                 wszOperation,
                 csFilePart.Get(),
                 csPathPart.Get());
    }

    WriteEntryToLog(g_wszXMLBuffer);
}

/*++

 Format file system data passed in and write it to the log.
 
--*/
void
FormatFileDataLogEntry(
    IN PLOG_HANDLE pHandle
    )
{
    //
    // Ensure that our parameters are valid before going any further.
    //
    if (!pHandle || !pHandle->pwszFilePath) {
        DPFN(eDbgLevelError, "[FormatFileDataLogEntry] Invalid parameter(s)");
        return;
    }

    //
    // Save ourselves a lot of work by logging only what needs to be logged.
    //
    if ((pHandle->dwFlags & LFC_EXISTING) &&
        (!(pHandle->dwFlags & LFC_DELETED)) &&
        (!(pHandle->dwFlags & LFC_MODIFIED))) {
        return;
    }

    //
    // Check for an unapproved file write, and keep moving afterward.
    //
    if (pHandle->dwFlags & LFC_UNAPPRVFW) {
        VLOG(VLOG_LEVEL_ERROR,
             VLOG_LOGFILECHANGES_UFW,
             "Path and Filename: %ls",
             pHandle->pwszFilePath);
    }

    //
    // Move through the different operations.
    //
    // 1. Check for a deletion of an existing file.
    //    
    if ((pHandle->dwFlags & LFC_DELETED) &&
        (pHandle->dwFlags & LFC_EXISTING)) {
        FormatDataIntoElement(eDeletedFile, pHandle->pwszFilePath);
        return;
    }

    //
    // 2. Check for modification of an existing file.
    //
    if ((pHandle->dwFlags & LFC_MODIFIED) &&
        (pHandle->dwFlags & LFC_EXISTING)) {
        FormatDataIntoElement(eModifiedFile, pHandle->pwszFilePath);
        return;
    }

    //
    // 3. Check for creation of a new file.
    //
    if (!(pHandle->dwFlags & LFC_EXISTING) &&
        (!(pHandle->dwFlags & LFC_DELETED))) {
        FormatDataIntoElement(eCreatedFile, pHandle->pwszFilePath);
        return;
    }
    
}

/*++

 Writes the closing element to the file and outputs the log file location.
 
--*/
void
CloseLogFile(
    void
    )
{
    WCHAR   wszBuffer[] = L"</APPLICATION>";

    WriteEntryToLog(wszBuffer);

    VLOG(VLOG_LEVEL_INFO, VLOG_LOGFILECHANGES_LOGLOC, "%ls", g_pwszLogFilePath);
}

/*++

 Write the entire linked list out to the log file.
 
--*/
BOOL
WriteListToLogFile(
    void
    )
{
    PLIST_ENTRY pCurrent = NULL;
    PLOG_HANDLE pHandle = NULL;
    
    //
    // Walk the list and write each node to the log file.
    //
    pCurrent = g_OpenHandleListHead.Blink;

    while (pCurrent != &g_OpenHandleListHead) {
        pHandle = CONTAINING_RECORD(pCurrent, LOG_HANDLE, Entry);

        FormatFileDataLogEntry(pHandle);
            
        pCurrent = pCurrent->Blink;
    }

    CloseLogFile();

    return TRUE;
}

/*++

 Given a file path, attempt to locate it in the list.
 This function may not always return a pointer.
 
--*/
PLOG_HANDLE 
FindPathInList(
    IN LPCWSTR pwszFilePath
    )
{
    BOOL        fFound = FALSE;
    PLIST_ENTRY pCurrent = NULL;
    PLOG_HANDLE pHandle = NULL;
    
    //
    // Attempt to locate the entry in the list.
    //
    pCurrent = g_OpenHandleListHead.Flink;

    while (pCurrent != &g_OpenHandleListHead) {

        pHandle = CONTAINING_RECORD(pCurrent, LOG_HANDLE, Entry);

        if (!_wcsicmp(pwszFilePath, pHandle->pwszFilePath)) {
            fFound = TRUE;
            break;
        }
        
        pCurrent = pCurrent->Flink;
    }

    return (fFound ? pHandle : NULL);
}

/*++

 Given a file handle and a file path, add an entry to the list.
 
--*/
PLOG_HANDLE
AddFileToList(
    IN HANDLE  hFile,
    IN LPCWSTR pwszPath,
    IN BOOL    fExisting,
    IN ULONG   ulCreateOptions
    )
{
    PLOG_HANDLE pHandle = NULL;

    if (!pwszPath) {
        DPFN(eDbgLevelError, "[AddFileToList] Invalid parameter");
        return NULL;
    }

    pHandle = (PLOG_HANDLE)MemAlloc(sizeof(LOG_HANDLE));

    if (!pHandle) {
        DPFN(eDbgLevelError, "[AddFileToList] Failed to allocate mem for struct");
        return NULL;
    }

    pHandle->pwszFilePath = (LPWSTR)MemAlloc((wcslen(pwszPath) + 1) * sizeof(WCHAR));

    if (!pHandle->pwszFilePath) {
        DPFN(eDbgLevelError, "[AddFileToList] Failed to allocate mem for path");
        MemFree(pHandle);
        return NULL;
    }

    if ((ulCreateOptions == FILE_OVERWRITE_IF) && fExisting) {
        pHandle->dwFlags |= LFC_MODIFIED;
    }

    if (ulCreateOptions & FILE_DELETE_ON_CLOSE) {
        pHandle->dwFlags |= LFC_DELETED;
    }

    pHandle->cHandles   = 1;
    pHandle->hFile[0]   = hFile ? hFile : INVALID_HANDLE_VALUE;

    if (fExisting) {
        pHandle->dwFlags |= LFC_EXISTING;
    }

    wcscpy(pHandle->pwszFilePath, pwszPath);

    DPFN(eDbgLevelInfo, "[AddFileToList] Adding entry: %p", pHandle);

    InsertHeadList(&g_OpenHandleListHead, &pHandle->Entry);

    return pHandle;
}

/*++

 Given a file handle, return a pointer to an entry in the list.
 This function should always return a pointer. If not, fire a breakpoint.
 
--*/
PLOG_HANDLE
FindHandleInArray(
    IN HANDLE hFile
    )
{
    UINT        uCount;
    BOOL        fFound = FALSE;
    PLIST_ENTRY pCurrent = NULL;
    PLOG_HANDLE pFindHandle = NULL;

    //
    // An invalid handle value is useless.
    //
    if (INVALID_HANDLE_VALUE == hFile) {
        DPFN(eDbgLevelError, "[FindHandleInArray] Invalid handle passed!");
        return FALSE;
    }

    pCurrent = g_OpenHandleListHead.Flink;

    while (pCurrent != &g_OpenHandleListHead) {
        pFindHandle = CONTAINING_RECORD(pCurrent, LOG_HANDLE, Entry);

        //
        // Step through this guy's array looking for the handle.
        //
        for (uCount = 0; uCount < pFindHandle->cHandles; uCount++) {
            if (pFindHandle->hFile[uCount] == hFile) {
                fFound = TRUE;
                break;
            }
        }

        if (fFound) {
            break;
        }

        pCurrent = pCurrent->Flink;
    }

    //
    // If the handle was not found, send output to the debugger.
    //
    if (!fFound) {
        DPFN(eDbgLevelError,
             "[FindHandleInArray] Handle 0x%08x not found!",
             hFile);
        PrintNameFromHandle(hFile);
    }

    return (pFindHandle ? pFindHandle : NULL);
}

/*++

 Given a file handle, remove it from the array in the list.
 
--*/
BOOL
RemoveHandleFromArray(
    IN HANDLE hFile
    )
{
    UINT        uCount;
    PLIST_ENTRY pCurrent = NULL;
    PLOG_HANDLE pFindHandle = NULL;

    //
    // An invalid handle value is useless.
    //
    if (INVALID_HANDLE_VALUE == hFile) {
        DPFN(eDbgLevelError, "[RemoveHandleFromArray] Invalid handle passed!");
        return FALSE;
    }

    pCurrent = g_OpenHandleListHead.Flink;

    while (pCurrent != &g_OpenHandleListHead) {

        pFindHandle = CONTAINING_RECORD(pCurrent, LOG_HANDLE, Entry);

        //
        // Step through this guy's array looking for the handle.
        //
        for (uCount = 0; uCount < pFindHandle->cHandles; uCount++) {
            //
            // If we find the handle, set the array element to -1 and
            // decrement the count of handles for this entry.
            //
            if (pFindHandle->hFile[uCount] == hFile) {
                DPFN(eDbgLevelInfo,
                     "[RemoveHandleFromArray] Removing handle 0x%08x",
                     hFile);
                pFindHandle->hFile[uCount] = INVALID_HANDLE_VALUE;
                pFindHandle->cHandles--;
                return TRUE;
            }
        }

        pCurrent = pCurrent->Flink;
    }

    return TRUE;
}

/*++

 Determine if the application is performing an operation in Windows or Program Files.
 
--*/
void
CheckForUnapprovedFileWrite(
    IN PLOG_HANDLE pHandle
    )
{
    int nPosition;

    //
    // Check our flags and search for the directories accordingly.
    // If we find a match, we're done.
    //
    CString csPath(pHandle->pwszFilePath);
    csPath.MakeLower();

    if (g_dwSettings & LFC_OPTION_UFW_WINDOWS) {
        nPosition = 0;
        nPosition = csPath.Find(L":\\windows");

        if (nPosition != -1) {
            pHandle->dwFlags |= LFC_UNAPPRVFW;
            return;
        }
    }

    if (g_dwSettings & LFC_OPTION_UFW_PROGFILES) {
        nPosition = 0;
        nPosition = csPath.Find(L":\\program files");

        if (nPosition != -1) {
            pHandle->dwFlags |= LFC_UNAPPRVFW;
            return;
        }
    }
}

/*++

 Inserts a handle into an existing list entry.
 
--*/
void
InsertHandleIntoList(
    IN HANDLE      hFile,
    IN PLOG_HANDLE pHandle
    )
{
    UINT    uCount = 0;

    //
    // Insert the handle into an empty spot and
    // update the number of handles we're storing.
    // Make sure we don't overstep the array bounds.
    //
    for (uCount = 0; uCount < pHandle->cHandles; uCount++) {
        if (INVALID_HANDLE_VALUE == pHandle->hFile[uCount]) {
            break;
        }
    }

    if (uCount >= MAX_NUM_HANDLES) {
        DPFN(eDbgLevelError, "[InsertHandleIntoList] Handle count reached");
        return;
    }

    pHandle->hFile[uCount] = hFile;
    pHandle->cHandles++;

    //
    // It's not possible to get a handle to a file that's been deleted,
    // so remove these bits.
    //
    pHandle->dwFlags &= ~LFC_DELETED;
}

/*++

 Does all the work of updating the linked list.
 
--*/
void
UpdateFileList(
    IN OperationType eType,
    IN LPWSTR        pwszFilePath,
    IN HANDLE        hFile,
    IN ULONG         ulCreateDisposition,
    IN BOOL          fExisting
    )
{
    UINT        uCount;
    DWORD       dwLen = 0;
    PLOG_HANDLE pHandle = NULL;

    switch (eType) {
    case eCreatedFile:
    case eOpenedFile:
        // 
        // Attempt to find the path in the list.
        // We need to check the CreateFile flags as they could
        // change an existing file.
        //
        pHandle = FindPathInList(pwszFilePath);

        if (pHandle) {
            //
            // If the file was created with the CREATE_ALWAYS flag,
            // and the file was an existing one, mark it changed.
            //
            if ((ulCreateDisposition == FILE_OVERWRITE_IF) && fExisting) {
                pHandle->dwFlags |= LFC_MODIFIED;
                
                if ((g_dwSettings & LFC_OPTION_UFW_WINDOWS) ||
                    (g_dwSettings & LFC_OPTION_UFW_PROGFILES)) {
                    CheckForUnapprovedFileWrite(pHandle);
                }
            }

            //
            // If the file was opened with the FILE_DELETE_ON_CLOSE flag,
            // mark it deleted.
            //
            if (ulCreateDisposition & FILE_DELETE_ON_CLOSE) {
                pHandle->dwFlags |= LFC_DELETED;
            }

            InsertHandleIntoList(hFile, pHandle);

            break;
        }

        //
        // The file path was not in the list, so we've never seen
        // this file before. We're going to add this guy to the list.
        //
        AddFileToList(hFile, pwszFilePath, fExisting, ulCreateDisposition);
        break;
    
    case eModifiedFile:
        //
        // No file path is available, so find the handle in the list.
        //
        pHandle = FindHandleInArray(hFile);

        if (pHandle) {            
            pHandle->dwFlags |= LFC_MODIFIED;

            if ((g_dwSettings & LFC_OPTION_UFW_WINDOWS) ||
                (g_dwSettings & LFC_OPTION_UFW_PROGFILES)) {
                CheckForUnapprovedFileWrite(pHandle);
            }
        }
        break;

    case eDeletedFile:
        //
        // Deletetion comes from two places. One provides a file path,
        // the other a handle. Determine which one we have.
        //
        if (hFile) {
            pHandle = FindHandleInArray(hFile);
        } else {
            pHandle = FindPathInList(pwszFilePath);
        }

        //
        // Rare case: If a handle wasn't available, deletion
        // is coming from NtDeleteFile, which hardly ever
        // gets called directly. Add the file path to the list
        // so we can track this deletion.
        //
        if (!pHandle && !hFile) {
            pHandle = AddFileToList(NULL, pwszFilePath, TRUE, 0);
        }

        if (pHandle) {            
            pHandle->dwFlags |= LFC_DELETED;

            if ((g_dwSettings & LFC_OPTION_UFW_WINDOWS) ||
                (g_dwSettings & LFC_OPTION_UFW_PROGFILES)) {
                CheckForUnapprovedFileWrite(pHandle);
            }
        }
        break;

    case eRenamedFile:
        {
            PLOG_HANDLE pSrcHandle = NULL;
            PLOG_HANDLE pDestHandle = NULL;
            WCHAR       wszFullPath[MAX_PATH * 2];
            WCHAR*      pSlash = NULL;
            UINT        cbCopy;

            //
            // A rename is two separate operations in one.
            // * Delete of an existing file.
            // * Create of a new file.
            // 
            // In this case, we attempt to find the destination file
            // in our list. If the file is not there, we add to the
            // list, then mark it as modified.
            //
            // As far as the source file, we mark it as deleted since it's
            // gone from the disk after the rename.
            //
            pSrcHandle = FindHandleInArray(hFile);

            if (pSrcHandle) {
                pDestHandle = FindPathInList(pwszFilePath);
    
                if (!pDestHandle) {
                    //
                    // The rename will only contain the new file name,
                    // not the path. Build a full path to the new file
                    // prior to adding it to the list.
                    //
                    wcsncpy(wszFullPath,
                            pSrcHandle->pwszFilePath,
                            wcslen(pSrcHandle->pwszFilePath) + 1);
    
                    pSlash = wcsrchr(wszFullPath, '\\');
    
                    if (pSlash) {
                        *++pSlash = '\0';
                    }
    
                    wcscat(wszFullPath, pwszFilePath);
    
                    pDestHandle = AddFileToList((HANDLE)-1,
                                                wszFullPath,
                                                fExisting,
                                                ulCreateDisposition);
                }
    
                if (pDestHandle) {
                    pDestHandle->dwFlags  = 0;
                    pDestHandle->dwFlags |= LFC_MODIFIED;
    
                    if ((g_dwSettings & LFC_OPTION_UFW_WINDOWS) ||
                        (g_dwSettings & LFC_OPTION_UFW_PROGFILES)) {
                        CheckForUnapprovedFileWrite(pDestHandle);
                    }
                }
    
                pSrcHandle->dwFlags &= ~LFC_MODIFIED;
                pSrcHandle->dwFlags |= LFC_DELETED;
    
                if ((g_dwSettings & LFC_OPTION_UFW_WINDOWS) ||
                    (g_dwSettings & LFC_OPTION_UFW_PROGFILES)) {
                    CheckForUnapprovedFileWrite(pSrcHandle);
                }
            }
            break;
        }

    default:
        DPFN(eDbgLevelError, "[UpdateFileList] Invalid enum type!");
        return;
    }
}

/*++

 Given an NT path, convert it to a DOS path.
 
--*/
BOOL
ConvertNtPathToDosPath(
    IN     PUNICODE_STRING            pstrSource,
    IN OUT PRTL_UNICODE_STRING_BUFFER pstrDest
    )
{
    NTSTATUS    status;

    if (!pstrSource || !pstrDest) {
        DPFN(eDbgLevelError, "[ConvertNtPathToDosPath] Invalid parameter(s)");
        return FALSE;
    }

    status = ShimAssignUnicodeStringBuffer(pstrDest, pstrSource);

    if (!NT_SUCCESS(status)) {
        DPFN(eDbgLevelError, "[ConvertNtPathToDosPath] Failed to initialize DOS path buffer");
        return FALSE;
    }

    status = ShimNtPathNameToDosPathName(0, pstrDest, 0, NULL);

    if (!NT_SUCCESS(status)) {
        DPFN(eDbgLevelError, "[ConvertNtPathToDosPath] Failed to convert NT -> DOS path");
        return FALSE;
    }

    return TRUE;
}

NTSTATUS
APIHOOK(NtCreateFile)(
    OUT PHANDLE            FileHandle,
    IN  ACCESS_MASK        DesiredAccess,
    IN  POBJECT_ATTRIBUTES ObjectAttributes,
    OUT PIO_STATUS_BLOCK   IoStatusBlock,
    IN  PLARGE_INTEGER     AllocationSize OPTIONAL,
    IN  ULONG              FileAttributes,
    IN  ULONG              ShareAccess,
    IN  ULONG              CreateDisposition,
    IN  ULONG              CreateOptions,
    IN  PVOID              EaBuffer OPTIONAL,
    IN  ULONG              EaLength
    )
{
    RTL_UNICODE_STRING_BUFFER   DosPathBuffer;
    UCHAR                       PathBuffer[MAX_PATH * 2];
    NTSTATUS                    status;
    BOOL                        fExists = FALSE;
    BOOL                        fConverted = FALSE;
    CLock                       cLock;

    RtlInitUnicodeStringBuffer(&DosPathBuffer, PathBuffer, sizeof(PathBuffer));

    fConverted = ConvertNtPathToDosPath(ObjectAttributes->ObjectName, &DosPathBuffer);

    if (!fConverted) {
        DPFN(eDbgLevelError,
             "[NtCreateFile] Failed to convert NT path: %ls",
             ObjectAttributes->ObjectName->Buffer);
    }

    fExists = RtlDoesFileExists_U(DosPathBuffer.String.Buffer);

    status = ORIGINAL_API(NtCreateFile)(FileHandle,
                                        DesiredAccess,
                                        ObjectAttributes,
                                        IoStatusBlock,
                                        AllocationSize,
                                        FileAttributes,
                                        ShareAccess,
                                        CreateDisposition,
                                        CreateOptions,
                                        EaBuffer,
                                        EaLength);

    //
    // Three conditions are required before the file is added to the list.
    // 1. The file must be a file system object. RtlDoesFileExists_U will
    //    return FALSE if it's not.
    //
    // 2. We must have been able to convert the NT path to a DOS path.
    //
    // 3. The call to NtCreateFile must have succeeded.
    //
    if (RtlDoesFileExists_U(DosPathBuffer.String.Buffer) && fConverted && NT_SUCCESS(status)) {
        UpdateFileList(eCreatedFile,
                       DosPathBuffer.String.Buffer,
                       *FileHandle,
                       CreateDisposition,
                       fExists);
    }

    RtlFreeUnicodeStringBuffer(&DosPathBuffer);

    return status;
}

NTSTATUS
APIHOOK(NtOpenFile)(
    OUT PHANDLE            FileHandle,
    IN  ACCESS_MASK        DesiredAccess,
    IN  POBJECT_ATTRIBUTES ObjectAttributes,
    OUT PIO_STATUS_BLOCK   IoStatusBlock,
    IN  ULONG              ShareAccess,
    IN  ULONG              OpenOptions
    )
{
    RTL_UNICODE_STRING_BUFFER   DosPathBuffer;
    UCHAR                       PathBuffer[MAX_PATH * 2];
    NTSTATUS                    status;
    BOOL                        fConverted = FALSE;
    CLock                       cLock;

    RtlInitUnicodeStringBuffer(&DosPathBuffer, PathBuffer, sizeof(PathBuffer));

    fConverted = ConvertNtPathToDosPath(ObjectAttributes->ObjectName, &DosPathBuffer);

    if (!fConverted) {
        DPFN(eDbgLevelError,
             "[NtOpenFile] Failed to convert NT path: %ls",
             ObjectAttributes->ObjectName->Buffer);
    }

    status = ORIGINAL_API(NtOpenFile)(FileHandle,
                                      DesiredAccess,
                                      ObjectAttributes,
                                      IoStatusBlock,
                                      ShareAccess,
                                      OpenOptions);

    //
    // Two conditions are required before we add this handle to the list.
    // 1. We must have been able to convert the NT path to a DOS path.
    //
    // 2. The call to NtOpenFile must have succeeded.
    //
    if (fConverted && NT_SUCCESS(status)) {
        UpdateFileList(eOpenedFile,
                       DosPathBuffer.String.Buffer,
                       *FileHandle,
                       OpenOptions,
                       TRUE);
    }

    RtlFreeUnicodeStringBuffer(&DosPathBuffer);

    return status;
}

NTSTATUS
APIHOOK(NtClose)(
    IN HANDLE Handle
    )
{
    CLock   cLock;

    RemoveHandleFromArray(Handle);

    return ORIGINAL_API(NtClose)(Handle);
}

NTSTATUS
APIHOOK(NtWriteFile)(
    IN  HANDLE           FileHandle,
    IN  HANDLE           Event OPTIONAL,
    IN  PIO_APC_ROUTINE  ApcRoutine OPTIONAL,
    IN  PVOID            ApcContext OPTIONAL,
    OUT PIO_STATUS_BLOCK IoStatusBlock,
    IN  PVOID            Buffer,
    IN  ULONG            Length,
    IN  PLARGE_INTEGER   ByteOffset OPTIONAL,
    IN  PULONG           Key OPTIONAL
    )
{
    NTSTATUS    status;
    CLock       cLock;

    status = ORIGINAL_API(NtWriteFile)(FileHandle,
                                       Event,
                                       ApcRoutine,
                                       ApcContext,
                                       IoStatusBlock,
                                       Buffer,
                                       Length,
                                       ByteOffset,
                                       Key);

    //
    // Handle the case in which the caller is using overlapped I/O.
    //
    if (STATUS_PENDING == status) {
        status = NtWaitForSingleObject(Event, FALSE, NULL);
    }

    //
    // If the call to NtWriteFile succeeded, update the list.
    //
    if (NT_SUCCESS(status)) {
        UpdateFileList(eModifiedFile,
                       NULL,
                       FileHandle,
                       0,
                       TRUE);
    }

    return status;
}

NTSTATUS
APIHOOK(NtWriteFileGather)(
    IN  HANDLE                FileHandle,
    IN  HANDLE                Event OPTIONAL,
    IN  PIO_APC_ROUTINE       ApcRoutine OPTIONAL,
    IN  PVOID                 ApcContext OPTIONAL,
    OUT PIO_STATUS_BLOCK      IoStatusBlock,
    IN  PFILE_SEGMENT_ELEMENT SegmentArray,
    IN  ULONG                 Length,
    IN  PLARGE_INTEGER        ByteOffset OPTIONAL,
    IN  PULONG                Key OPTIONAL
    )
{
    NTSTATUS    status;
    CLock       cLock;
    
    status = ORIGINAL_API(NtWriteFileGather)(FileHandle,
                                             Event,
                                             ApcRoutine,
                                             ApcContext,
                                             IoStatusBlock,
                                             SegmentArray,
                                             Length,
                                             ByteOffset,
                                             Key);

    //
    // Handle the case in which the caller is using overlapped I/O.
    //
    if (STATUS_PENDING == status) {
        status = NtWaitForSingleObject(Event, FALSE, NULL);
    }

    //
    // If the call to NtWriteFileGather succeeded, update the list.
    //
    if (NT_SUCCESS(status)) {
        UpdateFileList(eModifiedFile,
                       NULL,
                       FileHandle,
                       0,
                       TRUE);
    }

    return status;
}

NTSTATUS
APIHOOK(NtSetInformationFile)(
    IN  HANDLE                 FileHandle,
    OUT PIO_STATUS_BLOCK       IoStatusBlock,
    IN  PVOID                  FileInformation,
    IN  ULONG                  Length,
    IN  FILE_INFORMATION_CLASS FileInformationClass
    )
{
    NTSTATUS                      status;
    CLock                         cLock;
    
    status = ORIGINAL_API(NtSetInformationFile)(FileHandle,
                                                IoStatusBlock,
                                                FileInformation,
                                                Length,
                                                FileInformationClass);

    //
    // This API is called for a variety of reasons, but were only
    // interested in a couple different cases.
    //
    if (NT_SUCCESS(status)) {
        switch (FileInformationClass) {
        case FileAllocationInformation:
        case FileEndOfFileInformation:
            
                UpdateFileList(eModifiedFile,
                               NULL,
                               FileHandle,
                               0,
                               TRUE);
                break;

        case FileRenameInformation:
            {
                PFILE_RENAME_INFORMATION    pRenameInfo = NULL;
                UNICODE_STRING              ustrTemp;
                RTL_UNICODE_STRING_BUFFER   ubufDosPath;
                WCHAR*                      pwszPathBuffer = NULL;
                WCHAR*                      pwszTempBuffer = NULL;
                DWORD                       dwPathBufSize = 0;


                pRenameInfo = (PFILE_RENAME_INFORMATION)FileInformation;

                pwszTempBuffer = (WCHAR*)MemAlloc(pRenameInfo->FileNameLength + sizeof(WCHAR));

                //
                // allow for possible expansion when converting to DOS path
                //
                dwPathBufSize = pRenameInfo->FileNameLength + MAX_PATH;
                pwszPathBuffer = (WCHAR*)MemAlloc(dwPathBufSize);

                if (!pwszTempBuffer || !pwszPathBuffer) {
                    goto outRename;
                }

                //
                // copy the string into a local buffer and terminate it.
                //
                memcpy(pwszTempBuffer, pRenameInfo->FileName, pRenameInfo->FileNameLength);
                pwszTempBuffer[pRenameInfo->FileNameLength / 2] = 0;

                RtlInitUnicodeString(&ustrTemp, pwszTempBuffer);
                RtlInitUnicodeStringBuffer(&ubufDosPath, (PUCHAR)pwszPathBuffer, dwPathBufSize);

                //
                // Convert the path from DOS to NT, and if successful,
                // update the list.
                //
                if (!ConvertNtPathToDosPath(&ustrTemp, &ubufDosPath)) {
                    DPFN(eDbgLevelError,
                         "[NtSetInformationFile] Failed to convert NT path: %ls",
                         pRenameInfo->FileName);
                } else {
                    UpdateFileList(eRenamedFile,
                                   ubufDosPath.String.Buffer,
                                   FileHandle,
                                   0,
                                   TRUE);
                }
outRename:
                if (pwszTempBuffer) {
                    MemFree(pwszTempBuffer);
                }
                if (pwszPathBuffer) {
                    MemFree(pwszPathBuffer);
                }

                
                break;
            }
            
        case FileDispositionInformation:
            {
                PFILE_DISPOSITION_INFORMATION pDisposition = NULL;
                
                pDisposition = (PFILE_DISPOSITION_INFORMATION)FileInformation;
    
                //
                // Determine if the file is being deleted.
                // Note that we have to undefine DeleteFile.
                //
                #undef DeleteFile
                if (pDisposition) {
                    if (pDisposition->DeleteFile) {
                        UpdateFileList(eDeletedFile,
                                       NULL,
                                       FileHandle,
                                       0,
                                       TRUE);
                    }
                }
                break;
            }
        }
    }
            
    return status;
}

NTSTATUS
APIHOOK(NtDeleteFile)(
    IN POBJECT_ATTRIBUTES ObjectAttributes
    )
{
    RTL_UNICODE_STRING_BUFFER   DosPathBuffer;
    UCHAR                       PathBuffer[MAX_PATH * 2];
    NTSTATUS                    status;
    BOOL                        fConverted = FALSE;
    CLock                       cLock;

    RtlInitUnicodeStringBuffer(&DosPathBuffer, PathBuffer, sizeof(PathBuffer));

    fConverted = ConvertNtPathToDosPath(ObjectAttributes->ObjectName, &DosPathBuffer);

    if (!fConverted) {
        DPFN(eDbgLevelError,
             "[NtDeleteFile] Failed to convert NT path: %ls",
             ObjectAttributes->ObjectName->Buffer);
    }

    status = ORIGINAL_API(NtDeleteFile)(ObjectAttributes);

    if (NT_SUCCESS(status)) {
        UpdateFileList(eDeletedFile,
                       DosPathBuffer.String.Buffer,
                       NULL,
                       0,
                       TRUE);
    }

    return status;
}

/*++

 Controls our property page that is displayed in the Verifer.

--*/
LRESULT CALLBACK
DlgOptions(
    HWND   hDlg,
    UINT   message,
    WPARAM wParam,
    LPARAM lParam
    )
{
    static LPCWSTR szExeName;

    switch (message) {
    case WM_INITDIALOG:

        //
        // find out what exe we're handling settings for
        //
        szExeName = ExeNameFromLParam(lParam);

        g_dwSettings = GetShimSettingDWORD(L"LogFileChanges", szExeName, L"LogSettings", 1);
        
        if (g_dwSettings & LFC_OPTION_ATTRIBUTES) {
            CheckDlgButton(hDlg, IDC_LFC_LOG_ATTRIBUTES, BST_CHECKED);
        }

        if (g_dwSettings & LFC_OPTION_UFW_WINDOWS) {
            CheckDlgButton(hDlg, IDC_LFC_UFW_WINDOWS, BST_CHECKED);
        }

        if (g_dwSettings & LFC_OPTION_UFW_PROGFILES) {
            CheckDlgButton(hDlg, IDC_LFC_UFW_PROGFILES, BST_CHECKED);
        }

        return TRUE;

    case WM_COMMAND:
        switch (LOWORD(wParam)) {
        case IDC_LFC_BTN_DEFAULT:
        
            g_dwSettings = 0;
            g_dwSettings = LFC_OPTION_ATTRIBUTES;

            CheckDlgButton(hDlg, IDC_LFC_LOG_ATTRIBUTES, BST_CHECKED);
            CheckDlgButton(hDlg, IDC_LFC_UFW_WINDOWS, BST_UNCHECKED);
            CheckDlgButton(hDlg, IDC_LFC_UFW_PROGFILES, BST_UNCHECKED);

            break;
        }
        break;

    case WM_NOTIFY:
        switch (((NMHDR FAR *) lParam)->code) {
    
        case PSN_APPLY:
            {
                UINT uState;

                g_dwSettings = 0;
            
                uState = IsDlgButtonChecked(hDlg, IDC_LFC_LOG_ATTRIBUTES);

                if (BST_CHECKED == uState) {
                    g_dwSettings = LFC_OPTION_ATTRIBUTES;
                }

                uState = IsDlgButtonChecked(hDlg, IDC_LFC_UFW_WINDOWS);

                if (BST_CHECKED == uState) {
                    g_dwSettings |= LFC_OPTION_UFW_WINDOWS;
                }

                uState = IsDlgButtonChecked(hDlg, IDC_LFC_UFW_PROGFILES);

                if (BST_CHECKED == uState) {
                    g_dwSettings |= LFC_OPTION_UFW_PROGFILES;
                }

                SaveShimSettingDWORD(L"LogFileChanges", szExeName, L"LogSettings", g_dwSettings);

            }
            break;
        }
        break;
    }

    return FALSE;
}

/*++

 Initialize the list head and the log file.

--*/
BOOL
InitializeShim(
    void
    )
{
    //
    // Initialize our list head.
    //
    InitializeListHead(&g_OpenHandleListHead);

    //
    // Get our settings and store them.
    //
    WCHAR szExe[100];

    GetCurrentExeName(szExe, 100);

    g_dwSettings = GetShimSettingDWORD(L"LogFileChanges", szExe, L"LogSettings", 1);

    //
    // Initialize our log file.
    //
    return InitializeLogFile();
}

/*++

 Handle process attach/detach notifications.

--*/
BOOL
NOTIFY_FUNCTION(
    DWORD fdwReason
    )
{
    if (fdwReason == DLL_PROCESS_ATTACH) {
        return InitializeShim();
    } else if (fdwReason == DLL_PROCESS_DETACH) {
        return WriteListToLogFile();
    }

    return TRUE;
}

SHIM_INFO_BEGIN()

    SHIM_INFO_DESCRIPTION(AVS_LOGFILECHANGES_DESC)
    SHIM_INFO_FRIENDLY_NAME(AVS_LOGFILECHANGES_FRIENDLY)
    SHIM_INFO_VERSION(1, 6)
    SHIM_INFO_INCLUDE_EXCLUDE("I:kernel32.dll E:rpcrt4.dll ntdll.dll")
    SHIM_INFO_OPTIONS_PAGE(IDD_LOGFILECHANGES_OPTIONS, DlgOptions)
    SHIM_INFO_FLAGS(AVRF_FLAG_NO_DEFAULT)

SHIM_INFO_END()

/*++

 Register hooked functions

--*/

HOOK_BEGIN

    CALL_NOTIFY_FUNCTION

    DUMP_VERIFIER_LOG_ENTRY(VLOG_LOGFILECHANGES_LOGLOC, 
                            AVS_LOGFILECHANGES_LOGLOC,
                            AVS_LOGFILECHANGES_LOGLOC_R,
                            AVS_LOGFILECHANGES_LOGLOC_URL)

    DUMP_VERIFIER_LOG_ENTRY(VLOG_LOGFILECHANGES_UFW, 
                            AVS_LOGFILECHANGES_UFW,
                            AVS_LOGFILECHANGES_UFW_R,
                            AVS_LOGFILECHANGES_UFW_URL)

    APIHOOK_ENTRY(NTDLL.DLL,                        NtCreateFile)
    APIHOOK_ENTRY(NTDLL.DLL,                          NtOpenFile)
    APIHOOK_ENTRY(NTDLL.DLL,                         NtWriteFile)
    APIHOOK_ENTRY(NTDLL.DLL,                   NtWriteFileGather)
    APIHOOK_ENTRY(NTDLL.DLL,                NtSetInformationFile)
    APIHOOK_ENTRY(NTDLL.DLL,                             NtClose)
    APIHOOK_ENTRY(NTDLL.DLL,                        NtDeleteFile)

HOOK_END

IMPLEMENT_SHIM_END
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\appcompat\shims\verifier\dxfileversioninfo.cpp ===
/*++

 Copyright (c) 2001 Microsoft Corporation

 Module Name:

   DXFileVersionInfo.cpp

 Abstract:

   This AppVerifier shim hooks GetFileVersionInfo and
   checks to see if the application is checking version
   information for any known DirectX files.
   
   See the FileVersionInfoLie shim for details on the problem.
   
 Notes:

   This is a general purpose shim.

 History:

   06/26/2001   rparsons    Created

--*/

#include "precomp.h"

IMPLEMENT_SHIM_BEGIN(DXFileVersionInfo)
#include "ShimHookMacro.h"

//
// verifier log entries
//
BEGIN_DEFINE_VERIFIER_LOG(DXFileVersionInfo)
    VERIFIER_LOG_ENTRY(VLOG_DXFILEVERSIONINFO_DXFILE)
END_DEFINE_VERIFIER_LOG(DXFileVersionInfo)

INIT_VERIFIER_LOG(DXFileVersionInfo);

APIHOOK_ENUM_BEGIN
    APIHOOK_ENUM_ENTRY(GetFileVersionInfoA)
    APIHOOK_ENUM_ENTRY(GetFileVersionInfoW)
APIHOOK_ENUM_END

// Keep a list of files to track.
typedef struct FILELIST {
    struct FILELIST* pNext;
    CString          csFileName;
} FILELIST, *PFILELIST;

PFILELIST   g_pFileListHead = NULL;
const int   g_nNumDirectX7a = 68;

WCHAR  *g_szDirectX7aFiles[g_nNumDirectX7a] =
    { L"dplay.dll",      L"d3dim.dll",        L"d3dim700.dll",
      L"d3dpmesh.dll",   L"d3dramp.dll",      L"d3drampf.dll",
      L"d3dref.dll",     L"d3drg16f.dll",     L"d3drg24f.dll",
      L"d3drg24x.dll",   L"d3dhalf.dll",      L"d3drg32f.dll",
      L"d3drg32x.dll",   L"d3drg55x.dll",     L"d3drg56x.dll",
      L"d3drg8f.dll",    L"d3drg8x.dll",      L"d3drgbf.dll",
      L"d3drgbxf.dll",   L"d3drm.dll",        L"d3drm16f.dll",
      L"d3drm24f.dll",   L"d3drm32f.dll",     L"d3drm8f.dll",
      L"d3dxof.dll",     L"ddhelp.exe",       L"ddraw.dll",
      L"ddraw16.dll",    L"ddrawex.dll",      L"devnode1.dll",
      L"devnode2.dll",   L"dinput.dll",       L"dmband.dll",
      L"dmcompos.dll",   L"dmime.dll",        L"dmloader.dll",
      L"dmstyle.dll",    L"dmsynth.dll",      L"dmusic.dll",
      L"dmusic16.dll",   L"dmusic32.dll",     L"dplayx.dll",
      L"dpmodemx.dll",   L"dpserial.dll",     L"dpwsock.dll",
      L"dpwsockx.dll",   L"dsetup.dll",       L"dsetup16.dll",
      L"dsetup32.dll",   L"dsetup6e.dll",     L"dsetup6j.dll",
      L"dsetupe.dll",    L"dsetupj.dll",      L"dsound.dll",
      L"dsound3d.dll",   L"dx7vb.dll",        L"dxmigr.dll",
      L"gcdef.dll",      L"gchand.dll",       L"msvcrt.dll",
      L"pid.dll",        L"vjoyd.vxd",        L"dinput.vxd",
      L"dsound.vxd",     L"joyhid.vxd",       L"mtrr.vxd",
      L"ddraw.vxd",      L"d3d8.dll"
    };

void
CheckDirectXFile(
    IN CString& csFileName
    )
{
    CSTRING_TRY {

        PFILELIST pFileList = g_pFileListHead;

        CString csFilePart;
        csFileName.GetLastPathComponent(csFilePart);

        //
        // Walk the list and perform a comparison. Report wrong-doers.
        //
        while (pFileList) {

            if (csFilePart.CompareNoCase(pFileList->csFileName) == 0) {
                VLOG(VLOG_LEVEL_ERROR, VLOG_DXFILEVERSIONINFO_DXFILE, "GetFileVersionInfo called for %ls", csFileName.Get());
                break;
            }
            
            pFileList = pFileList->pNext;
        }
        
    }
    CSTRING_CATCH {

        // Do nothing
    }
}

BOOL 
APIHOOK(GetFileVersionInfoA)(
    LPSTR  lpstrFilename,
    DWORD  dwHandle,
    DWORD  dwLen,
    LPVOID lpData
    )
{
    CString csFileName(lpstrFilename);

    //
    // See if they're requesting information on a known DX file.
    //
    CheckDirectXFile(csFileName);

    return ORIGINAL_API(GetFileVersionInfoA)( 
                        lpstrFilename, 
                        dwHandle, 
                        dwLen, 
                        lpData);
}

BOOL 
APIHOOK(GetFileVersionInfoW)(
    LPWSTR  lpstrFilename,
    DWORD   dwHandle,
    DWORD   dwLen,
    LPVOID  lpData
    )
{
    CString csFileName(lpstrFilename);

    //
    // See if they're requesting information on a known DX file.
    //
    CheckDirectXFile(csFileName);

    return ORIGINAL_API(GetFileVersionInfoW)( 
                        lpstrFilename, 
                        dwHandle, 
                        dwLen, 
                        lpData);
}

/*++

 Build the linked list of files to look for.

--*/
BOOL
BuildFileList(
    void
    )
{
    int         nCount;
    FILELIST*   pFileList = NULL;

    for (nCount = 0; nCount < g_nNumDirectX7a; nCount++) {
        //
        // Allocate a new node, then assign the file name
        // from our global array.
        //
        pFileList = new FILELIST;

        if (!pFileList) {
            LOGN(eDbgLevelError, "[BuildFileList] Failed to allocate memory");
            return FALSE;
        }

        pFileList->csFileName = g_szDirectX7aFiles[nCount];

        pFileList->pNext = g_pFileListHead;
        g_pFileListHead = pFileList;
        
    }
    
    return TRUE;
}

SHIM_INFO_BEGIN()

    SHIM_INFO_DESCRIPTION(AVS_DXFILEVERINFO_DESC)
    SHIM_INFO_FRIENDLY_NAME(AVS_DXFILEVERINFO_FRIENDLY)
    SHIM_INFO_VERSION(1, 2)

SHIM_INFO_END()

/*++

 Register hooked functions

--*/
BOOL
NOTIFY_FUNCTION(
    DWORD fdwReason
    )
{
    if (fdwReason == DLL_PROCESS_ATTACH) {
        return BuildFileList();
    }

    return TRUE;
}

HOOK_BEGIN

    CALL_NOTIFY_FUNCTION

    DUMP_VERIFIER_LOG_ENTRY(VLOG_DXFILEVERSIONINFO_DXFILE, 
                            AVS_DXFILEVERINFO_DXFILE,
                            AVS_DXFILEVERINFO_DXFILE_R,
                            AVS_DXFILEVERINFO_DXFILE_URL)

    APIHOOK_ENTRY(VERSION.DLL, GetFileVersionInfoA)
    APIHOOK_ENTRY(VERSION.DLL, GetFileVersionInfoW)

HOOK_END

IMPLEMENT_SHIM_END
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\appcompat\shims\verifier\logfilechanges.h ===
/*++

 Copyright (c) 2001 Microsoft Corporation

 Module Name:

   LogFileChanges.h

 Abstract:
 
   This AppVerifier shim hooks all the native file I/O APIs
   that change the state of the system and logs their
   associated data to a text file.

 Notes:

   This is a general purpose shim.

 History:

   08/17/2001   rparsons    Created

--*/
#ifndef __APPVERIFIER_LOGFILECHANGES_H_
#define __APPVERIFIER_LOGFILECHANGES_H_

#include "precomp.h"

//
// Length (in characters) of the largest element.
//
#define MAX_ELEMENT_SIZE 1024 * 10

//
// Length (in characters) of the longest operation type.
//
#define MAX_OPERATION_LENGTH 32

//
// Flags that indicate what state the file is in.
//
#define LFC_EXISTING    0x00000001
#define LFC_DELETED     0x00000002
#define LFC_MODIFIED    0x00000004
#define LFC_UNAPPRVFW   0x00000008

//
// Maximum number of handles we can track for a single file.
//
#define MAX_NUM_HANDLES 64

//
// We maintain a doubly linked list of file handles so we know what file is being modified
// during a file operation. 
//
typedef struct _LOG_HANDLE {
    LIST_ENTRY      Entry;
    HANDLE          hFile[MAX_NUM_HANDLES];     // array of file handles
    DWORD           dwFlags;                    // flags that relate to the state of the file
    LPWSTR          pwszFilePath;               // full path to the file
    UINT            cHandles;                   // number of handles open for this file
} LOG_HANDLE, *PLOG_HANDLE;

//
// Flags that define different settings in effect.
//
#define LFC_OPTION_ATTRIBUTES       0x00000001
#define LFC_OPTION_UFW_WINDOWS      0x00000002
#define LFC_OPTION_UFW_PROGFILES    0x00000004

//
// Enumeration for different operations.
//
typedef enum {
    eCreatedFile = 0,
    eOpenedFile,
    eDeletedFile,
    eModifiedFile,
    eRenamedFile
} OperationType;

#ifdef ARRAYSIZE
#undef ARRAYSIZE
#endif
#define ARRAYSIZE(a)  (sizeof(a)/sizeof(*a))

//
// Macros for memory allocation/deallocation.
//
#define MemAlloc(s)     RtlAllocateHeap(RtlProcessHeap(), HEAP_ZERO_MEMORY, (s))
#define MemFree(b)      RtlFreeHeap(RtlProcessHeap(), 0, (b))

//
// Keep us safe while we're playing with linked lists and shared resources.
//
static BOOL g_bInitialized = FALSE;

CRITICAL_SECTION g_csLogging;

class CLock
{
public:
    CLock()
    {
        if (!g_bInitialized)
        {
            InitializeCriticalSection(&g_csLogging);
            g_bInitialized = TRUE;            
        }

        EnterCriticalSection(&g_csLogging);
    }
    ~CLock()
    {
        LeaveCriticalSection(&g_csLogging);
    }
};

APIHOOK_ENUM_BEGIN

    APIHOOK_ENUM_ENTRY(NtDeleteFile)
    APIHOOK_ENUM_ENTRY(NtClose)
    APIHOOK_ENUM_ENTRY(NtCreateFile)
    APIHOOK_ENUM_ENTRY(NtOpenFile)
    APIHOOK_ENUM_ENTRY(NtWriteFile)
    APIHOOK_ENUM_ENTRY(NtWriteFileGather)
    APIHOOK_ENUM_ENTRY(NtSetInformationFile)

APIHOOK_ENUM_END

#endif // __APPVERIFIER_LOGFILECHANGES_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\appcompat\shims\verifier\filepaths.cpp ===
/*++

 Copyright (c) 2001 Microsoft Corporation

 Module Name:

   FilePaths.cpp

 Abstract:
 
   This AppVerifier shim hooks the APIs that require
   the caller to provide a path to a file or directory
   and attempts to ensure that the path is not a hardcoded
   one.

 Notes:

   This is a general purpose shim.
 
 Created:

   02/26/2001   clupu

 Modified:
 
  07/24/2001    rparsons    Added hooks for Nt* calls
                            Added checks for apps that use environment variables
                           
  09/04/2001    rparsons    Fixed a bug in the Massage functions where we would
                            stop processing a fake path as soon as we found a hardcode
                            path. Also, we now fix multiple fake paths in the same string.
                            
  10/17/2001    rparsons    Fixed bug where we wouldn't always report a bad path.
                            This was because the CString Find method is case sensitive,
                            but the paths we were comparing were mixed in case. Now all
                            paths are in lower case form prior to the comparison.
                            
  11/21/2001    rparsons    Fixed Raid bug # 492674. FilePaths did not contain an implementation
                            for SHFileOperation - apps that used this API would not get their
                            paths corrected, thus failing.
                            
  11/29/2001    rparsons    Fixed Raid bug # 497853. Removed the hooks for GetTempFileName as they
                            were causing a false positive to be generated. Also added code that
                            would handle cases where the user provides a path via a common dialog
                            and we provide a fake path to be massaged later.
                            
  12/11/2001    rparsons    Fixed Raid bug # 505599. Added hooks for all RegQueryValue* calls
                            and NtQueryValueKey. The Nt hook allows us to catch paths for
                            system components. 
--*/
#include "precomp.h"
#include "rtlutils.h"

IMPLEMENT_SHIM_BEGIN(FilePaths)
#include "ShimHookMacro.h"
#include "ShimCString.h"
#include "veriflog.h"
#include "ids.h"

APIHOOK_ENUM_BEGIN

    APIHOOK_ENUM_ENTRY(GetCommandLineA)
    APIHOOK_ENUM_ENTRY(GetCommandLineW)

    APIHOOK_ENUM_ENTRY(GetTempPathA)
    APIHOOK_ENUM_ENTRY(GetTempPathW)

    APIHOOK_ENUM_ENTRY(GetOpenFileNameA)
    APIHOOK_ENUM_ENTRY(GetOpenFileNameW)
    
    APIHOOK_ENUM_ENTRY(GetSaveFileNameA)
    APIHOOK_ENUM_ENTRY(GetSaveFileNameW)

    APIHOOK_ENUM_ENTRY(GetModuleFileNameA)
    APIHOOK_ENUM_ENTRY(GetModuleFileNameW)
    APIHOOK_ENUM_ENTRY(GetModuleFileNameExA)
    APIHOOK_ENUM_ENTRY(GetModuleFileNameExW)

    APIHOOK_ENUM_ENTRY(GetCurrentDirectoryA)
    APIHOOK_ENUM_ENTRY(GetCurrentDirectoryW)

    APIHOOK_ENUM_ENTRY(GetSystemDirectoryA)
    APIHOOK_ENUM_ENTRY(GetSystemDirectoryW)
    APIHOOK_ENUM_ENTRY(GetSystemWindowsDirectoryA)
    APIHOOK_ENUM_ENTRY(GetSystemWindowsDirectoryW)
    APIHOOK_ENUM_ENTRY(GetWindowsDirectoryA)
    APIHOOK_ENUM_ENTRY(GetWindowsDirectoryW)

    APIHOOK_ENUM_ENTRY(SHGetFolderPathA)
    APIHOOK_ENUM_ENTRY(SHGetFolderPathW)

    APIHOOK_ENUM_ENTRY(SHGetSpecialFolderPathA)
    APIHOOK_ENUM_ENTRY(SHGetSpecialFolderPathW)

    APIHOOK_ENUM_ENTRY(SHGetPathFromIDListA)
    APIHOOK_ENUM_ENTRY(SHGetPathFromIDListW)
    
    APIHOOK_ENUM_ENTRY(CreateProcessA)
    APIHOOK_ENUM_ENTRY(CreateProcessW)
    APIHOOK_ENUM_ENTRY(WinExec)
    APIHOOK_ENUM_ENTRY(ShellExecuteA)
    APIHOOK_ENUM_ENTRY(ShellExecuteW)
    APIHOOK_ENUM_ENTRY(ShellExecuteExA)
    APIHOOK_ENUM_ENTRY(ShellExecuteExW)

    APIHOOK_ENUM_ENTRY(GetPrivateProfileIntA)
    APIHOOK_ENUM_ENTRY(GetPrivateProfileIntW)
    APIHOOK_ENUM_ENTRY(GetPrivateProfileSectionA)
    APIHOOK_ENUM_ENTRY(GetPrivateProfileSectionW)
    APIHOOK_ENUM_ENTRY(GetPrivateProfileSectionNamesA)
    APIHOOK_ENUM_ENTRY(GetPrivateProfileSectionNamesW)
    APIHOOK_ENUM_ENTRY(GetPrivateProfileStringA)
    APIHOOK_ENUM_ENTRY(GetPrivateProfileStringW)
    APIHOOK_ENUM_ENTRY(GetPrivateProfileStructA)
    APIHOOK_ENUM_ENTRY(GetPrivateProfileStructW)

    APIHOOK_ENUM_ENTRY(WritePrivateProfileSectionA)
    APIHOOK_ENUM_ENTRY(WritePrivateProfileSectionW)
    APIHOOK_ENUM_ENTRY(WritePrivateProfileStringA)
    APIHOOK_ENUM_ENTRY(WritePrivateProfileStringW)
    APIHOOK_ENUM_ENTRY(WritePrivateProfileStructA)
    APIHOOK_ENUM_ENTRY(WritePrivateProfileStructW)

    APIHOOK_ENUM_ENTRY(CopyFileA)
    APIHOOK_ENUM_ENTRY(CopyFileW)
    APIHOOK_ENUM_ENTRY(CopyFileExA)
    APIHOOK_ENUM_ENTRY(CopyFileExW)
    APIHOOK_ENUM_ENTRY(CreateDirectoryA)
    APIHOOK_ENUM_ENTRY(CreateDirectoryW)
    APIHOOK_ENUM_ENTRY(CreateDirectoryExA)
    APIHOOK_ENUM_ENTRY(CreateDirectoryExW)

    APIHOOK_ENUM_ENTRY(CreateFileA)
    APIHOOK_ENUM_ENTRY(CreateFileW)
    APIHOOK_ENUM_ENTRY(DeleteFileA)
    APIHOOK_ENUM_ENTRY(DeleteFileW)

    APIHOOK_ENUM_ENTRY(FindFirstFileA)
    APIHOOK_ENUM_ENTRY(FindFirstFileW)
    APIHOOK_ENUM_ENTRY(FindFirstFileExA)
    APIHOOK_ENUM_ENTRY(FindFirstFileExW)

    APIHOOK_ENUM_ENTRY(GetBinaryTypeA)
    APIHOOK_ENUM_ENTRY(GetBinaryTypeW)
    APIHOOK_ENUM_ENTRY(GetFileAttributesA)
    APIHOOK_ENUM_ENTRY(GetFileAttributesW)
    APIHOOK_ENUM_ENTRY(GetFileAttributesExA)
    APIHOOK_ENUM_ENTRY(GetFileAttributesExW)
    APIHOOK_ENUM_ENTRY(SetFileAttributesA)
    APIHOOK_ENUM_ENTRY(SetFileAttributesW)

    APIHOOK_ENUM_ENTRY(MoveFileA)
    APIHOOK_ENUM_ENTRY(MoveFileW)
    APIHOOK_ENUM_ENTRY(MoveFileExA)
    APIHOOK_ENUM_ENTRY(MoveFileExW)
    APIHOOK_ENUM_ENTRY(MoveFileWithProgressA)
    APIHOOK_ENUM_ENTRY(MoveFileWithProgressW)

    APIHOOK_ENUM_ENTRY(RemoveDirectoryA)
    APIHOOK_ENUM_ENTRY(RemoveDirectoryW)
    APIHOOK_ENUM_ENTRY(SetCurrentDirectoryA)
    APIHOOK_ENUM_ENTRY(SetCurrentDirectoryW)
    APIHOOK_ENUM_ENTRY(LoadLibraryA)
    APIHOOK_ENUM_ENTRY(LoadLibraryW)
    APIHOOK_ENUM_ENTRY(LoadLibraryExA)
    APIHOOK_ENUM_ENTRY(LoadLibraryExW)

    APIHOOK_ENUM_ENTRY(SearchPathA)
    APIHOOK_ENUM_ENTRY(SearchPathW)

    APIHOOK_ENUM_ENTRY(SHFileOperationA)
    APIHOOK_ENUM_ENTRY(SHFileOperationW)

    APIHOOK_ENUM_ENTRY(ExpandEnvironmentStringsA)
    APIHOOK_ENUM_ENTRY(ExpandEnvironmentStringsW)

    APIHOOK_ENUM_ENTRY(GetFileVersionInfoSizeA)
    APIHOOK_ENUM_ENTRY(GetFileVersionInfoSizeW)
    APIHOOK_ENUM_ENTRY(GetFileVersionInfoA)
    APIHOOK_ENUM_ENTRY(GetFileVersionInfoW)

    APIHOOK_ENUM_ENTRY(OpenFile)

    APIHOOK_ENUM_ENTRY(RegQueryValueA)
    APIHOOK_ENUM_ENTRY(RegQueryValueW)
    APIHOOK_ENUM_ENTRY(RegQueryValueExA)
    APIHOOK_ENUM_ENTRY(RegQueryValueExW)

    APIHOOK_ENUM_ENTRY(RegSetValueA)
    APIHOOK_ENUM_ENTRY(RegSetValueW)
    APIHOOK_ENUM_ENTRY(RegSetValueExA)
    APIHOOK_ENUM_ENTRY(RegSetValueExW)

    APIHOOK_ENUM_ENTRY(NtCreateFile)
    APIHOOK_ENUM_ENTRY(NtOpenFile)
    APIHOOK_ENUM_ENTRY(NtQueryAttributesFile)
    APIHOOK_ENUM_ENTRY(NtQueryFullAttributesFile)
    APIHOOK_ENUM_ENTRY(NtCreateProcessEx)

    APIHOOK_ENUM_ENTRY(_lopen)
    APIHOOK_ENUM_ENTRY(_lcreat)
    
APIHOOK_ENUM_END

//
// verifier log entries
//
BEGIN_DEFINE_VERIFIER_LOG(FilePaths)
    VERIFIER_LOG_ENTRY(VLOG_HARDCODED_GETTEMPPATH)
    VERIFIER_LOG_ENTRY(VLOG_HARDCODED_WINDOWSPATH)
    VERIFIER_LOG_ENTRY(VLOG_HARDCODED_SYSWINDOWSPATH)
    VERIFIER_LOG_ENTRY(VLOG_HARDCODED_SYSTEMPATH)
    VERIFIER_LOG_ENTRY(VLOG_HARDCODED_PERSONALPATH)
    VERIFIER_LOG_ENTRY(VLOG_HARDCODED_COMMONPROGRAMS)
    VERIFIER_LOG_ENTRY(VLOG_HARDCODED_COMMONSTARTMENU)
    VERIFIER_LOG_ENTRY(VLOG_HARDCODED_PROGRAMS)
    VERIFIER_LOG_ENTRY(VLOG_HARDCODED_STARTMENU)
END_DEFINE_VERIFIER_LOG(FilePaths)

INIT_VERIFIER_LOG(FilePaths);


// This is a private define (shlapip.h) that can mess up ShellExecuteEx
#ifndef SEE_MASK_FILEANDURL
#define SEE_MASK_FILEANDURL       0x00400000
#endif

#define MAX_HARDCODED_PATHS 4

//
// Linked-list for SHFileOperation
//
typedef struct FILELIST {
    struct FILELIST*    pNext;
    UINT                cchSize;
    LPWSTR              pwszFilePath;
} FILELIST, *PFILELIST;

enum ListType {
    eFrom = 0,
    eTo
};

//
// Head of the linked-lists for SHFileOperation
//
PFILELIST   g_pFileListFromHead = NULL;
PFILELIST   g_pFileListToHead = NULL;

//
// Critical section to keep our linked list safe.
//
RTL_CRITICAL_SECTION    g_csLinkedList;

//
// Fake command-line for GetCommandLine calls.
//
LPSTR   g_pszCommandLineA;
LPWSTR  g_pwszCommandLineW;

typedef struct _PATH_INFO {
    char    szSimulatedPathA[256];
    WCHAR   szSimulatedPathW[256];

    char    szCorrectPathA[MAX_PATH];
    WCHAR   szCorrectPathW[MAX_PATH];

    int     nSimulatedPathLen;
    int     nCorrectPathLen;

    char    szHardCodedPathsA[MAX_HARDCODED_PATHS][MAX_PATH];
    WCHAR   szHardCodedPathsW[MAX_HARDCODED_PATHS][MAX_PATH];

    DWORD   dwIssueCode;
} PATH_INFO, *PPATH_INFO;


//
// the following enum and the g_Paths initializers must be kept in parallel
// Note: The paths must be in lower case for the comparison to work properly.
//
enum _PATH_NUM {
    PATH_TEMP = 0,
    PATH_WINDOWS,
    PATH_SYSTEM_WINDOWS,
    PATH_SYSTEM,
    PATH_PERSONAL,
    PATH_COMMON_PROGRAMS,
    PATH_COMMON_STARTMENU,
    PATH_PROGRAMS,
    PATH_STARTMENU
};

PATH_INFO g_Paths[] = {
    {
       "c:\\abc\\temppath\\123\\",
       L"c:\\abc\\temppath\\123\\",
       "",
       L"",
       0,
       0,
       {
           "\\temp\\",
           "",
           "",
           ""
       },
       {
           L"\\temp\\",
           L"",
           L"",
           L""
       },
       VLOG_HARDCODED_GETTEMPPATH
    },
    {
       "c:\\abc\\windowsdir\\123",
       L"c:\\abc\\windowsdir\\123",
       "",
       L"",
       0,
       0,
       {
           ":\\windows\\",
           ":\\winnt\\",
           "",
           ""
       },
       {
           L":\\windows\\",
           L":\\winnt\\",
           L"",
           L""
       },
       VLOG_HARDCODED_WINDOWSPATH
    },
    {
       "c:\\abc\\systemwindowsdir\\123",
       L"c:\\abc\\systemwindowsdir\\123",
       "",
       L"",
       0,
       0,
       {
           ":\\windows\\",
           ":\\winnt\\",
           "",
           ""
       },
       {
           L":\\windows\\",
           L":\\winnt\\",
           L"",
           L""
       },
       VLOG_HARDCODED_SYSWINDOWSPATH
    },
    {
       "c:\\abc\\systemdir\\123",
       L"c:\\abc\\systemdir\\123",
       "",
       L"",
       0,
       0,
       {
           "\\system\\",
           "\\system32\\",
           "",
           ""
       },
       {
           L"\\system\\",
           L"\\system32\\",
           L"",
           L""
       },
       VLOG_HARDCODED_SYSTEMPATH
    },
    {
       "c:\\abc\\personal\\123",
       L"c:\\abc\\personal\\123",
       "",
       L"",
       0,
       0,
       {
           "\\my documents\\",
           "",
           "",
           ""
       },
       {
           L"\\my documents\\",
           L"",
           L"",
           L""
       },
       VLOG_HARDCODED_PERSONALPATH
    },
    {
       "c:\\abc\\commonprograms\\123",
       L"c:\\abc\\commonprograms\\123",
       "",
       L"",
       0,
       0,
       {
           "\\all users\\start menu\\programs\\",
           "",
           "",
           ""
       },
       {
           L"\\all users\\start menu\\programs\\",
           L"",
           L"",
           L""
       },
       VLOG_HARDCODED_COMMONPROGRAMS
    },
    {
       "c:\\abc\\commonstartmenu\\123",
       L"c:\\abc\\commonstartmenu\\123",
       "",
       L"",
       0,
       0,
       {
           "\\all users\\start menu\\",
           "",
           "",
           ""
       },
       {
           L"\\all users\\start menu\\",
           L"",
           L"",
           L""
       },
       VLOG_HARDCODED_COMMONSTARTMENU
    },
    {
       "c:\\abc\\programs\\123",
       L"c:\\abc\\programs\\123",
       "",
       L"",
       0,
       0,
       {
           "\\start menu\\programs\\",
           "",
           "",
           ""
       },
       {
           L"\\start menu\\programs\\",
           L"",
           L"",
           L""
       },
       VLOG_HARDCODED_PROGRAMS
    },
    {
       "c:\\abc\\startmenu\\123",
       L"c:\\abc\\startmenu\\123",
       "",
       L"",
       0,
       0,
       {
           "\\start menu\\",
           "",
           "",
           ""
       },
       {
           L"\\start menu\\",
           L"",
           L"",
           L""
       },
       VLOG_HARDCODED_STARTMENU
    }

};

const int g_nPaths = sizeof(g_Paths)/sizeof(g_Paths[0]);

static BOOL g_bPathsInited = FALSE;

void
InitFakeCommandLine(
    void
    )
{
    int     cchSize = 0;
    int     nPathIndex;
    BOOL    fReplaced = FALSE;

    CString csCommandLine(GetCommandLineW());

    csCommandLine.MakeLower();

    //
    // Point them to the normal command-line at first.
    //
    g_pwszCommandLineW = GetCommandLineW();
    g_pszCommandLineA = GetCommandLineA();

    //
    // Replace real paths with simulated paths.
    //
    for (nPathIndex = 0; nPathIndex < g_nPaths; ++nPathIndex) {
        if (csCommandLine.Replace(g_Paths[nPathIndex].szCorrectPathW,
                                  g_Paths[nPathIndex].szSimulatedPathW)) {
            fReplaced = TRUE;
        }
    }

    if (fReplaced) {
        //
        // Allocate room on the heap and save the command line away.
        //
        cchSize = csCommandLine.GetLength();

        g_pwszCommandLineW = (LPWSTR)malloc(cchSize * sizeof(WCHAR));

        if (!g_pwszCommandLineW) {
            DPFN(eDbgLevelError, "[InitFakeCommandLine] No memory available");
            return;
        }

        g_pszCommandLineA = (LPSTR)malloc(cchSize);

        if (!g_pszCommandLineA) {
            DPFN(eDbgLevelError, "[InitFakeCommandLine] No memory available");
            free(g_pwszCommandLineW);
            return;
        }
        
        wcsncpy(g_pwszCommandLineW, csCommandLine.Get(), cchSize);
        strncpy(g_pszCommandLineA, csCommandLine.GetAnsi(), cchSize);
    }
}

void
InitPaths(
    void
    )
{
    g_bPathsInited = TRUE;

    //
    // Convert paths to lower case as this is necessary when performing
    // the comparison.
    //
    CharLowerA(g_Paths[PATH_TEMP].szCorrectPathA);
    CharLowerW(g_Paths[PATH_TEMP].szCorrectPathW);

    CharLowerA(g_Paths[PATH_WINDOWS].szCorrectPathA);
    CharLowerW(g_Paths[PATH_WINDOWS].szCorrectPathW);
    
    CharLowerA(g_Paths[PATH_SYSTEM_WINDOWS].szCorrectPathA);
    CharLowerW(g_Paths[PATH_SYSTEM_WINDOWS].szCorrectPathW);

    CharLowerA(g_Paths[PATH_SYSTEM].szCorrectPathA);
    CharLowerW(g_Paths[PATH_SYSTEM].szCorrectPathW);

    SHGetFolderPathA(NULL, CSIDL_PERSONAL, NULL, SHGFP_TYPE_CURRENT,  g_Paths[PATH_PERSONAL].szCorrectPathA);
    SHGetFolderPathW(NULL, CSIDL_PERSONAL, NULL, SHGFP_TYPE_CURRENT,  g_Paths[PATH_PERSONAL].szCorrectPathW);
    g_Paths[PATH_PERSONAL].nCorrectPathLen = strlen(g_Paths[PATH_PERSONAL].szCorrectPathA);
    g_Paths[PATH_PERSONAL].nSimulatedPathLen = strlen(g_Paths[PATH_PERSONAL].szSimulatedPathA);
    CharLowerA(g_Paths[PATH_PERSONAL].szCorrectPathA);
    CharLowerW(g_Paths[PATH_PERSONAL].szCorrectPathW);

    SHGetFolderPathA(NULL, CSIDL_STARTMENU, NULL, SHGFP_TYPE_CURRENT,  g_Paths[PATH_STARTMENU].szCorrectPathA);
    SHGetFolderPathW(NULL, CSIDL_STARTMENU, NULL, SHGFP_TYPE_CURRENT,  g_Paths[PATH_STARTMENU].szCorrectPathW);
    g_Paths[PATH_STARTMENU].nCorrectPathLen = strlen(g_Paths[PATH_STARTMENU].szCorrectPathA);
    g_Paths[PATH_STARTMENU].nSimulatedPathLen = strlen(g_Paths[PATH_STARTMENU].szSimulatedPathA);
    CharLowerA(g_Paths[PATH_STARTMENU].szCorrectPathA);
    CharLowerW(g_Paths[PATH_STARTMENU].szCorrectPathW);

    SHGetFolderPathA(NULL, CSIDL_COMMON_STARTMENU, NULL, SHGFP_TYPE_CURRENT,  g_Paths[PATH_COMMON_STARTMENU].szCorrectPathA);
    SHGetFolderPathW(NULL, CSIDL_COMMON_STARTMENU, NULL, SHGFP_TYPE_CURRENT,  g_Paths[PATH_COMMON_STARTMENU].szCorrectPathW);
    g_Paths[PATH_COMMON_STARTMENU].nCorrectPathLen = strlen(g_Paths[PATH_COMMON_STARTMENU].szCorrectPathA);
    g_Paths[PATH_COMMON_STARTMENU].nSimulatedPathLen = strlen(g_Paths[PATH_COMMON_STARTMENU].szSimulatedPathA);
    CharLowerA(g_Paths[PATH_COMMON_STARTMENU].szCorrectPathA);
    CharLowerW(g_Paths[PATH_COMMON_STARTMENU].szCorrectPathW);

    SHGetFolderPathA(NULL, CSIDL_PROGRAMS, NULL, SHGFP_TYPE_CURRENT,  g_Paths[PATH_PROGRAMS].szCorrectPathA);
    SHGetFolderPathW(NULL, CSIDL_PROGRAMS, NULL, SHGFP_TYPE_CURRENT,  g_Paths[PATH_PROGRAMS].szCorrectPathW);
    g_Paths[PATH_PROGRAMS].nCorrectPathLen = strlen(g_Paths[PATH_PROGRAMS].szCorrectPathA);
    g_Paths[PATH_PROGRAMS].nSimulatedPathLen = strlen(g_Paths[PATH_PROGRAMS].szSimulatedPathA);
    CharLowerA(g_Paths[PATH_PROGRAMS].szCorrectPathA);
    CharLowerW(g_Paths[PATH_PROGRAMS].szCorrectPathW);

    SHGetFolderPathA(NULL, CSIDL_COMMON_PROGRAMS, NULL, SHGFP_TYPE_CURRENT,  g_Paths[PATH_COMMON_PROGRAMS].szCorrectPathA);
    SHGetFolderPathW(NULL, CSIDL_COMMON_PROGRAMS, NULL, SHGFP_TYPE_CURRENT,  g_Paths[PATH_COMMON_PROGRAMS].szCorrectPathW);
    g_Paths[PATH_COMMON_PROGRAMS].nCorrectPathLen = strlen(g_Paths[PATH_COMMON_PROGRAMS].szCorrectPathA);
    g_Paths[PATH_COMMON_PROGRAMS].nSimulatedPathLen = strlen(g_Paths[PATH_COMMON_PROGRAMS].szSimulatedPathA);
    CharLowerA(g_Paths[PATH_COMMON_PROGRAMS].szCorrectPathA);
    CharLowerW(g_Paths[PATH_COMMON_PROGRAMS].szCorrectPathW);

    InitFakeCommandLine();
}

inline void
FPFreeA(
    LPSTR  lpMalloc,
    LPCSTR lpOrig
    )
{
    if (lpMalloc != lpOrig) {
        free((LPVOID)lpMalloc);
    }
}

inline void
FPFreeW(
    LPWSTR  lpMalloc,
    LPCWSTR lpOrig
    )
{
    if (lpMalloc != lpOrig) {
        free((LPVOID)lpMalloc);
    }
}

void
MassageRealPathToFakePathW(
    LPWSTR pwszPath,
    DWORD  cchBufferSize
    )
{
    int  nPathIndex;
    BOOL fReplaced = FALSE;
    
    if (!pwszPath || 0 == cchBufferSize) {
        return;
    }

    if (!g_bPathsInited) {
        InitPaths();
    }
    
    DPFN(eDbgLevelInfo, "[MassageRealPathToFakePath] '%ls'", pwszPath);

    CString csString(pwszPath);
    
    csString.MakeLower();

    //
    // Replace real paths with simulated paths.
    //
    for (nPathIndex = 0; nPathIndex < g_nPaths; ++nPathIndex) {
        if (csString.Replace(g_Paths[nPathIndex].szCorrectPathW,
                             g_Paths[nPathIndex].szSimulatedPathW)) {
            fReplaced = TRUE;
        }
    }

    if (fReplaced) {
        //
        // Ensure that the buffer is large enough to contain the new path.
        //
        if (cchBufferSize < (DWORD)csString.GetLength()) {
            DPFN(eDbgLevelError,
                 "[MassageRealPathToFakePath] Buffer is not large enough. Need %d have %lu",
                 csString.GetLength(), cchBufferSize);
            return;
        } else {
            wcscpy(pwszPath, csString);
        }
    }
}

void
MassageRealPathToFakePathA(
    LPSTR pszPath,
    DWORD cchBufferSize
    )
{
    int  nPathIndex;
    BOOL fReplaced = FALSE;
    
    if (!pszPath || 0 == cchBufferSize) {
        return;
    }

    if (!g_bPathsInited) {
        InitPaths();
    }
    
    DPFN(eDbgLevelInfo, "[MassageRealPathToFakePath] '%s'", pszPath);

    CString csString(pszPath);
    
    csString.MakeLower();

    //
    // Replace real paths with simulated paths.
    //
    for (nPathIndex = 0; nPathIndex < g_nPaths; ++nPathIndex) {
        if (csString.Replace(g_Paths[nPathIndex].szCorrectPathW,
                             g_Paths[nPathIndex].szSimulatedPathW)) {
            fReplaced = TRUE;
        }
    }

    if (fReplaced) {
        //
        // Ensure that the buffer is large enough to contain the new path.
        //
        if (cchBufferSize < (DWORD)csString.GetLength()) {
            DPFN(eDbgLevelError,
                 "[MassageRealPathToFakePath] Buffer is not large enough. Need %d have %lu",
                 csString.GetLength(), cchBufferSize);
            return;
        } else {
            lstrcpyA(pszPath, csString.GetAnsi());
        }
    }
}

LPWSTR
MassageStringForPathW(
    LPCWSTR pwszString
    )
{
    int     nPosition;
    int     nPathIndex, nHardcodedIndex;
    UINT    nLen = 0;
    UINT    cFakePaths = 0;
    LPWSTR  pwszPath;
    LPWSTR  pwszNew = NULL;
    CString csToken(L"");
    
    if (pwszString == NULL || *pwszString == 0) {
        return (LPWSTR)pwszString;
    }

    if (!g_bPathsInited) {
        InitPaths();
    }
    
    DPFN(eDbgLevelInfo, "[MassageStringForPathW] '%ls'", pwszString);

    //
    // Search the string for hardcoded paths first.
    //
    CString csString(pwszString);
    
    csString.MakeLower();
    
    for (nPathIndex = 0; nPathIndex < g_nPaths; ++nPathIndex) {

        for (nHardcodedIndex = 0; nHardcodedIndex < MAX_HARDCODED_PATHS; ++nHardcodedIndex) {
            pwszPath = g_Paths[nPathIndex].szHardCodedPathsW[nHardcodedIndex];

            if (!pwszPath[0]) {
                break;
            }

            nPosition = csString.Find(pwszPath);

            if (nPosition != -1) {
                VLOG(VLOG_LEVEL_ERROR,
                     g_Paths[nPathIndex].dwIssueCode,
                     "Hardcoded path found in path '%ls'.",
                     pwszString);
                break;
            }
            nPosition = 0;
        }
    }

    //
    // Now search for the fake paths that we substituted ourselves.
    //
    CStringToken csTokenList(csString, L" ");
    
    while (csTokenList.GetToken(csToken)) {
        
        csToken.MakeLower();
        for (nPathIndex = 0, nPosition = 0; nPathIndex < g_nPaths; ++nPathIndex) {
        
            nPosition = csToken.Find(g_Paths[nPathIndex].szSimulatedPathW);

            if (nPosition != -1) {
                cFakePaths++;
                break;
            }
            nPosition = 0;
        }
    }

    //
    // See if the string contained any fake paths. If not, we're done here.
    //
    if (!cFakePaths) {
        return (LPWSTR)pwszString;
    }

    //
    // Our string has simulated paths; replace them.
    //
    for (nPathIndex = 0; nPathIndex < g_nPaths; ++nPathIndex) {
        csString.Replace(g_Paths[nPathIndex].szSimulatedPathW,
                         g_Paths[nPathIndex].szCorrectPathW);
    }

    //
    // Allocate a string large enough to hold the corrected path and
    // give it back to the caller. They'll free it later.
    //
    nLen =  MAX_PATH * cFakePaths;
    nLen += csString.GetLength();

    pwszNew = (LPWSTR)malloc((nLen + 1) * sizeof(WCHAR));

    if (!pwszNew) {
        DPFN(eDbgLevelError,
             "[MassageStringForPathW] Failed to allocate memory");
        return (LPWSTR)pwszString;
    }

    wcscpy(pwszNew, csString);
    
    DPFN(eDbgLevelInfo,
         "[MassageStringForPathW] Replaced '%ls' with '%ls'",
         pwszString,
         pwszNew);
    
    return pwszNew;
}

LPSTR
MassageStringForPathA(
    LPCSTR pszString
    )
{
    int     nLen = 0, nRetLen = 0;
    WCHAR   wszTmp[MAX_PATH];
    LPWSTR  pwszReturn = NULL;
    LPSTR   pszNew = NULL;

    if (pszString == NULL || *pszString == 0) {
        return (LPSTR)pszString;
    }
    
    if (!g_bPathsInited) {
        InitPaths();
    }
    
    //
    // Convert from ANSI to Unicode so we can pass this on
    // to the Unicode version of the function.
    //
    nLen = MultiByteToWideChar(CP_ACP,
                               0,
                               pszString,
                               -1,
                               wszTmp,
                               ARRAYSIZE(wszTmp));

    if (!nLen) {
        DPFN(eDbgLevelError, "[MassageStringForPathA] Ansi -> Unicode failed");
        return (LPSTR)pszString;
    }

    pwszReturn = MassageStringForPathW(wszTmp);

    //
    // If the return is the same as the source, we're done.
    //
    if (!_wcsicmp(pwszReturn, wszTmp)) {
        return (LPSTR)pszString;
    }

    //
    // Allocate a buffer large enough to hold the return
    // and give it back to the caller as ANSI.
    //
    nRetLen = wcslen(pwszReturn) + 1;

    pszNew = (LPSTR)malloc(nRetLen);

    if (!pszNew) {
        DPFN(eDbgLevelError, "[MassageStringForPathA] No memory available");
        return (LPSTR)pszString;
    }

    nLen = WideCharToMultiByte(CP_ACP,
                               0,
                               pwszReturn,
                               -1,
                               pszNew,
                               nRetLen,
                               NULL,
                               NULL);

    if (!nLen) {
        DPFN(eDbgLevelError, "[MassageStringForPathA] Unicode -> Ansi failed");
        free(pszNew);
        return (LPSTR)pszString;
    }

    free(pwszReturn);
    
    return pszNew;
}

void
MassageNtPath(
    IN  POBJECT_ATTRIBUTES pObjectAttributes,
    OUT POBJECT_ATTRIBUTES pRetObjectAttributes
    )
{
    NTSTATUS                    status;
    PUNICODE_STRING             pstrObjectName = NULL;
    LPWSTR                      pwszString = NULL;
    RTL_UNICODE_STRING_BUFFER   DosPathBuffer;
    UCHAR                       PathBuffer[MAX_PATH * 2];
    BOOL                        TranslationStatus = FALSE;

    //
    // Preserve the existing attributes.
    //
    InitializeObjectAttributes(pRetObjectAttributes,
                               pObjectAttributes->ObjectName,
                               pObjectAttributes->Attributes,
                               pObjectAttributes->RootDirectory,
                               pObjectAttributes->SecurityDescriptor);

    //
    // Ensure that we have a valid source path to work with.
    //
    if (!pObjectAttributes->ObjectName->Buffer) {
        return;
    }

    DPFN(eDbgLevelInfo,
         "[MassageNtPath] '%ls'",
         pObjectAttributes->ObjectName->Buffer);

    //
    // Convert from an NT path to a DOS path.
    //
    RtlInitUnicodeStringBuffer(&DosPathBuffer,
                               PathBuffer,
                               sizeof(PathBuffer));
    
    status = ShimAssignUnicodeStringBuffer(&DosPathBuffer,
                                           pObjectAttributes->ObjectName);

    if (!NT_SUCCESS(status)) {
        DPFN(eDbgLevelError,
             "[MassageNtPath] Failed to initialize DOS path buffer");
        return;
    }

    status = ShimNtPathNameToDosPathName(0, &DosPathBuffer, NULL, NULL);
    
    if (!NT_SUCCESS(status)) {
        DPFN(eDbgLevelError,
             "[MassageNtPath] Failed to convert NT '%ls' to DOS path",
             pObjectAttributes->ObjectName->Buffer);
        goto cleanup;
    }

    //
    // Now check for a hardcoded path.
    //
    pwszString = MassageStringForPathW(DosPathBuffer.String.Buffer);

    //
    // Convert from a DOS path to an NT path name.
    //
    pstrObjectName = (PUNICODE_STRING)RtlAllocateHeap(RtlProcessHeap(),
                                                      HEAP_ZERO_MEMORY,
                                                      sizeof(UNICODE_STRING));

    if (!pstrObjectName) {
        DPFN(eDbgLevelError, "[MassageNtPath] Failed to allocate memory");
        goto cleanup;
    }

    TranslationStatus = RtlDosPathNameToNtPathName_U(pwszString,
                                                     pstrObjectName,
                                                     NULL,
                                                     NULL);

    if (!TranslationStatus) {
        DPFN(eDbgLevelError,
             "[MassageNtPath] Failed to convert DOS '%ls' to NT path",
             pwszString);
        goto cleanup;
    }

    //
    // Everything worked, so now we update the ObjectName and return it through
    // the structure.
    //
    pRetObjectAttributes->ObjectName = pstrObjectName;
    
cleanup:

    FPFreeW(pwszString, DosPathBuffer.String.Buffer);

    RtlFreeUnicodeStringBuffer(&DosPathBuffer);
}

inline
void
FPNtFree(
    IN POBJECT_ATTRIBUTES pOriginal,
    IN POBJECT_ATTRIBUTES pAllocated
    )
{
    RtlFreeUnicodeString(pAllocated->ObjectName);

    if (pOriginal->ObjectName != pAllocated->ObjectName) {
        RtlFreeHeap(RtlProcessHeap(), 0, pAllocated->ObjectName);
    }
}

LPSTR
APIHOOK(GetCommandLineA)(
    void
    )
{
    if (g_bPathsInited) {
        return g_pszCommandLineA;
    } else {
        return ORIGINAL_API(GetCommandLineA)();
    }
}

LPWSTR
APIHOOK(GetCommandLineW)(
    void
    )
{
    if (g_bPathsInited) {
        return g_pwszCommandLineW;
    } else {
        return ORIGINAL_API(GetCommandLineW)();
    }
}

DWORD
APIHOOK(GetFileAttributesA)(
    LPCSTR lpFileName           // name of file or directory
    )
{
    LPSTR lpszString = MassageStringForPathA(lpFileName);

    DWORD returnValue = ORIGINAL_API(GetFileAttributesA)(lpszString);

    FPFreeA(lpszString, lpFileName);

    return returnValue;
}

DWORD
APIHOOK(GetFileAttributesW)(
    LPCWSTR lpFileName          // name of file or directory
    )
{
    LPWSTR lpszString = MassageStringForPathW(lpFileName);

    DWORD returnValue = ORIGINAL_API(GetFileAttributesW)(lpszString);

    FPFreeW(lpszString, lpFileName);

    return returnValue;
}

BOOL
APIHOOK(SetFileAttributesA)(
    LPCSTR lpFileName,          // file name
    DWORD  dwFileAttributes     // attributes
    )
{
    LPSTR lpszString = MassageStringForPathA(lpFileName);

    DWORD returnValue = ORIGINAL_API(SetFileAttributesA)(lpszString, dwFileAttributes);

    FPFreeA(lpszString, lpFileName);

    return returnValue;
}

DWORD
APIHOOK(SetFileAttributesW)(
    LPCWSTR lpFileName,         // file name
    DWORD   dwFileAttributes    // attributes
    )
{
    LPWSTR lpszString = MassageStringForPathW(lpFileName);

    DWORD returnValue = ORIGINAL_API(SetFileAttributesW)(lpszString, dwFileAttributes);

    FPFreeW(lpszString, lpFileName);

    return returnValue;
}

BOOL
APIHOOK(GetFileAttributesExA)(
    LPCSTR lpFileName,                       // file or directory name
    GET_FILEEX_INFO_LEVELS fInfoLevelId,     // attribute 
    LPVOID                 lpFileInformation // attribute information 
    )
{
    LPSTR lpszString = MassageStringForPathA(lpFileName);

    BOOL returnValue = ORIGINAL_API(GetFileAttributesExA)(lpszString,
                                                          fInfoLevelId,
                                                          lpFileInformation);

    FPFreeA(lpszString, lpFileName);

    return returnValue;
}

BOOL
APIHOOK(GetFileAttributesExW)(
    LPCWSTR                lpFileName,       // file or directory name
    GET_FILEEX_INFO_LEVELS fInfoLevelId,     // attribute 
    LPVOID                 lpFileInformation // attribute information 
    )
{
    LPWSTR lpszString = MassageStringForPathW(lpFileName);

    BOOL returnValue = ORIGINAL_API(GetFileAttributesExW)(lpszString,
                                                          fInfoLevelId,
                                                          lpFileInformation);

    FPFreeW(lpszString, lpFileName);

    return returnValue;
}

BOOL
APIHOOK(CreateProcessA)(
    LPCSTR                  lpApplicationName,                 
    LPSTR                   lpCommandLine,                      
    LPSECURITY_ATTRIBUTES   lpProcessAttributes,
    LPSECURITY_ATTRIBUTES   lpThreadAttributes, 
    BOOL                    bInheritHandles,                     
    DWORD                   dwCreationFlags,                    
    LPVOID                  lpEnvironment,                     
    LPCSTR                  lpCurrentDirectory,                
    LPSTARTUPINFOA          lpStartupInfo,             
    LPPROCESS_INFORMATION   lpProcessInformation
    )
{
    LPSTR lpszStringAppName = MassageStringForPathA(lpApplicationName);
    LPSTR lpszStringCmdLine = MassageStringForPathA(lpCommandLine);
    
    BOOL returnValue = ORIGINAL_API(CreateProcessA)(lpszStringAppName,
                                                    lpszStringCmdLine,
                                                    lpProcessAttributes,
                                                    lpThreadAttributes, 
                                                    bInheritHandles,                     
                                                    dwCreationFlags,                    
                                                    lpEnvironment,                     
                                                    lpCurrentDirectory,                
                                                    lpStartupInfo,             
                                                    lpProcessInformation);

    FPFreeA(lpszStringAppName, lpApplicationName);
    FPFreeA(lpszStringCmdLine, lpCommandLine);

    return returnValue;
}


BOOL
APIHOOK(CreateProcessW)(
    LPCWSTR                 lpApplicationName,
    LPWSTR                  lpCommandLine,
    LPSECURITY_ATTRIBUTES   lpProcessAttributes,
    LPSECURITY_ATTRIBUTES   lpThreadAttributes,
    BOOL                    bInheritHandles,
    DWORD                   dwCreationFlags,
    LPVOID                  lpEnvironment,
    LPCWSTR                 lpCurrentDirectory,
    LPSTARTUPINFOW          lpStartupInfo,
    LPPROCESS_INFORMATION   lpProcessInformation
    )
{
    LPWSTR lpszStringAppName = MassageStringForPathW(lpApplicationName);
    LPWSTR lpszStringCmdLine = MassageStringForPathW(lpCommandLine);
    
    BOOL returnValue = ORIGINAL_API(CreateProcessW)(lpszStringAppName,
                                                    lpszStringCmdLine,
                                                    lpProcessAttributes,
                                                    lpThreadAttributes, 
                                                    bInheritHandles,                     
                                                    dwCreationFlags,                    
                                                    lpEnvironment,                     
                                                    lpCurrentDirectory,                
                                                    lpStartupInfo,             
                                                    lpProcessInformation);

    FPFreeW(lpszStringAppName, lpApplicationName);
    FPFreeW(lpszStringCmdLine, lpCommandLine);

    return returnValue;
}


UINT
APIHOOK(WinExec)(
    LPCSTR lpCmdLine,
    UINT   uCmdShow
    )
{
    LPSTR lpszString = MassageStringForPathA(lpCmdLine);

    UINT returnValue = ORIGINAL_API(WinExec)(lpszString, uCmdShow);

    FPFreeA(lpszString, lpCmdLine);

    return returnValue;
}


HINSTANCE
APIHOOK(ShellExecuteA)(
    HWND   hwnd, 
    LPCSTR lpVerb,
    LPCSTR lpFile, 
    LPCSTR lpParameters, 
    LPCSTR lpDirectory,
    INT    nShowCmd
    )
{
    LPSTR lpszStringFile = MassageStringForPathA(lpFile);
    LPSTR lpszStringDir = MassageStringForPathA(lpDirectory);

    HINSTANCE returnValue = ORIGINAL_API(ShellExecuteA)(hwnd,
                                                        lpVerb,
                                                        lpszStringFile,
                                                        lpParameters,
                                                        lpszStringDir,
                                                        nShowCmd);

    FPFreeA(lpszStringFile, lpFile);
    FPFreeA(lpszStringDir, lpDirectory);

    return returnValue;
}

/*++

    Convert Win9x paths to WinNT paths for ShellExecuteW

--*/

HINSTANCE
APIHOOK(ShellExecuteW)(
    HWND    hwnd, 
    LPCWSTR lpVerb,
    LPCWSTR lpFile, 
    LPCWSTR lpParameters, 
    LPCWSTR lpDirectory,
    INT     nShowCmd
    )
{
    LPWSTR lpszStringFile = MassageStringForPathW(lpFile);
    LPWSTR lpszStringDir = MassageStringForPathW(lpDirectory);

    HINSTANCE returnValue = ORIGINAL_API(ShellExecuteW)(hwnd,
                                                        lpVerb,
                                                        lpszStringFile,
                                                        lpParameters,
                                                        lpszStringDir,
                                                        nShowCmd);

    FPFreeW(lpszStringFile, lpFile);
    FPFreeW(lpszStringDir, lpDirectory);

    return returnValue;
}

BOOL
APIHOOK(ShellExecuteExA)(
    LPSHELLEXECUTEINFOA lpExecInfo
    )
{
    //
    // Check for this magical *internal* flag that tells the system
    // that lpExecInfo->lpFile is actually a file and URL combined with
    // a 0 byte seperator, (file\0url\0)
    // Since this is internal only, we should not be receiving bad paths.
    //
    if (lpExecInfo->fMask & SEE_MASK_FILEANDURL) {
        return ORIGINAL_API(ShellExecuteExA)(lpExecInfo);
    }

    LPSTR lpszStringFile = MassageStringForPathA(lpExecInfo->lpFile);
    LPSTR lpszStringDir = MassageStringForPathA(lpExecInfo->lpDirectory);
    
    LPCSTR lpFileSave = lpExecInfo->lpFile;
    LPCSTR lpDirSave  = lpExecInfo->lpDirectory;
    
    lpExecInfo->lpFile      = lpszStringFile;
    lpExecInfo->lpDirectory = lpszStringDir;
    
    BOOL returnValue = ORIGINAL_API(ShellExecuteExA)(lpExecInfo);
    
    lpExecInfo->lpFile      = lpFileSave;
    lpExecInfo->lpDirectory = lpDirSave;

    FPFreeA(lpszStringFile, lpFileSave);
    FPFreeA(lpszStringDir, lpDirSave);

    return returnValue;
}

/*++

    Convert Win9x paths to WinNT paths for ShellExecuteExW

--*/

BOOL
APIHOOK(ShellExecuteExW)(
    LPSHELLEXECUTEINFOW lpExecInfo
    )
{
    //
    // Check for this magical *internal* flag that tells the system
    // that lpExecInfo->lpFile is actually a file and URL combined with
    // a 0 byte seperator, (file\0url\0)
    // Since this is internal only, we should not be receiving bad paths.
    //
    if (lpExecInfo->fMask & SEE_MASK_FILEANDURL) {
        return ORIGINAL_API(ShellExecuteExW)(lpExecInfo);
    }

    LPWSTR lpszStringFile = MassageStringForPathW(lpExecInfo->lpFile);
    LPWSTR lpszStringDir = MassageStringForPathW(lpExecInfo->lpDirectory);
    
    LPCWSTR lpFileSave = lpExecInfo->lpFile;
    LPCWSTR lpDirSave  = lpExecInfo->lpDirectory;
    
    lpExecInfo->lpFile      = lpszStringFile;
    lpExecInfo->lpDirectory = lpszStringDir;
    
    BOOL returnValue = ORIGINAL_API(ShellExecuteExW)(lpExecInfo);
    
    lpExecInfo->lpFile      = lpFileSave;
    lpExecInfo->lpDirectory = lpDirSave;

    FPFreeW(lpszStringFile, lpFileSave);
    FPFreeW(lpszStringDir, lpDirSave);

    return returnValue;
}


UINT
APIHOOK(GetPrivateProfileIntA)(
    LPCSTR  lpAppName,          // section name
    LPCSTR  lpKeyName,          // key name
    INT     nDefault,           // return value if key name not found
    LPCSTR  lpFileName          // initialization file name
    )
{
    LPSTR lpszString = MassageStringForPathA(lpFileName);

    UINT returnValue = ORIGINAL_API(GetPrivateProfileIntA)(lpAppName,
                                                           lpKeyName,
                                                           nDefault,
                                                           lpszString);

    FPFreeA(lpszString, lpFileName);

    return returnValue;
}


UINT
APIHOOK(GetPrivateProfileIntW)(
    LPCWSTR lpAppName,          // section name
    LPCWSTR lpKeyName,          // key name
    INT     nDefault,           // return value if key name not found
    LPCWSTR lpFileName          // initialization file name
    )
{
    LPWSTR lpszString = MassageStringForPathW(lpFileName);

    UINT returnValue = ORIGINAL_API(GetPrivateProfileIntW)(lpAppName,
                                                           lpKeyName,
                                                           nDefault,
                                                           lpszString);

    FPFreeW(lpszString, lpFileName);

    return returnValue;
}


DWORD
APIHOOK(GetPrivateProfileSectionA)(
    LPCSTR  lpAppName,          // section name
    LPSTR   lpReturnedString,   // return buffer
    DWORD   nSize,              // size of return buffer
    LPCSTR  lpFileName          // initialization file name
    )
{
    LPSTR lpszString = MassageStringForPathA(lpFileName);

    DWORD returnValue = ORIGINAL_API(GetPrivateProfileSectionA)(lpAppName,
                                                                lpReturnedString,
                                                                nSize,
                                                                lpszString);

    FPFreeA(lpszString, lpFileName);

    return returnValue;
}


DWORD
APIHOOK(GetPrivateProfileSectionW)(
    LPCWSTR lpAppName,          // section name
    LPWSTR  lpReturnedString,   // return buffer
    DWORD   nSize,              // size of return buffer
    LPCWSTR lpFileName          // initialization file name
    )
{
    LPWSTR lpszString = MassageStringForPathW(lpFileName);

    DWORD returnValue = ORIGINAL_API(GetPrivateProfileSectionW)(lpAppName,
                                                                lpReturnedString,
                                                                nSize,
                                                                lpszString);

    FPFreeW(lpszString, lpFileName);

    return returnValue;
}


DWORD
APIHOOK(GetPrivateProfileSectionNamesA)(
    LPSTR  lpszReturnBuffer,    // return buffer
    DWORD  nSize,               // size of return buffer
    LPCSTR lpFileName           // initialization file name
    )
{
    LPSTR lpszString = MassageStringForPathA(lpFileName);

    DWORD returnValue = ORIGINAL_API(GetPrivateProfileSectionNamesA)(lpszReturnBuffer,
                                                                     nSize,
                                                                     lpszString);

    FPFreeA(lpszString, lpFileName);

    return returnValue;
}


DWORD
APIHOOK(GetPrivateProfileSectionNamesW)(
    LPWSTR  lpszReturnBuffer,   // return buffer
    DWORD   nSize,              // size of return buffer
    LPCWSTR lpFileName          // initialization file name
    )
{
    LPWSTR lpszString = MassageStringForPathW(lpFileName);

    DWORD returnValue = ORIGINAL_API(GetPrivateProfileSectionNamesW)(lpszReturnBuffer,
                                                                     nSize,
                                                                     lpszString);

    FPFreeW(lpszString, lpFileName);

    return returnValue;
}


DWORD
APIHOOK(GetPrivateProfileStringA)(
    LPCSTR lpAppName,           // section name
    LPCSTR lpKeyName,           // key name
    LPCSTR lpDefault,           // default string
    LPSTR  lpReturnedString,    // destination buffer
    DWORD  nSize,               // size of destination buffer
    LPCSTR lpFileName           // initialization file name
    )
{
    LPSTR lpszString = MassageStringForPathA(lpFileName);

    DWORD returnValue = ORIGINAL_API(GetPrivateProfileStringA)(lpAppName,
                                                               lpKeyName,
                                                               lpDefault,
                                                               lpReturnedString,
                                                               nSize,
                                                               lpszString);
    FPFreeA(lpszString, lpFileName);

    return returnValue;
}


DWORD
APIHOOK(GetPrivateProfileStringW)(
    LPCWSTR lpAppName,          // section name
    LPCWSTR lpKeyName,          // key name
    LPCWSTR lpDefault,          // default string
    LPWSTR  lpReturnedString,   // destination buffer
    DWORD   nSize,              // size of destination buffer
    LPCWSTR lpFileName          // initialization file name
    )
{
    LPWSTR lpszString = MassageStringForPathW(lpFileName);

    DWORD returnValue = ORIGINAL_API(GetPrivateProfileStringW)(lpAppName,
                                                               lpKeyName,
                                                               lpDefault,
                                                               lpReturnedString,
                                                               nSize,
                                                               lpszString);

    FPFreeW(lpszString, lpFileName);

    return returnValue;
}


BOOL
APIHOOK(GetPrivateProfileStructA)(
    LPCSTR lpszSection,         // section name
    LPCSTR lpszKey,             // key name
    LPVOID lpStruct,            // return buffer
    UINT   uSizeStruct,         // size of return buffer
    LPCSTR lpFileName           // initialization file name
    )
{
    LPSTR lpszString = MassageStringForPathA(lpFileName);

    BOOL returnValue = ORIGINAL_API(GetPrivateProfileStructA)(lpszSection,
                                                              lpszKey,
                                                              lpStruct,
                                                              uSizeStruct,
                                                              lpszString);

    FPFreeA(lpszString, lpFileName);

    return returnValue;
}


BOOL
APIHOOK(GetPrivateProfileStructW)(
    LPCWSTR lpszSection,        // section name
    LPCWSTR lpszKey,            // key name
    LPVOID  lpStruct,           // return buffer
    UINT    uSizeStruct,        // size of return buffer
    LPCWSTR lpFileName          // initialization file name
    )
{
    LPWSTR lpszString = MassageStringForPathW(lpFileName);

    BOOL returnValue = ORIGINAL_API(GetPrivateProfileStructW)(lpszSection,
                                                              lpszKey,
                                                              lpStruct,
                                                              uSizeStruct,
                                                              lpszString);

    FPFreeW(lpszString, lpFileName);

    return returnValue;
}


BOOL
APIHOOK(WritePrivateProfileSectionA)(
    LPCSTR lpAppName,           // section name
    LPCSTR lpString,            // data
    LPCSTR lpFileName           // file name
    )
{
    LPSTR lpszString = MassageStringForPathA(lpFileName);

    BOOL returnValue = ORIGINAL_API(WritePrivateProfileSectionA)(lpAppName,
                                                                 lpString,
                                                                 lpszString);

    FPFreeA(lpszString, lpFileName);

    return returnValue;
}


BOOL
APIHOOK(WritePrivateProfileSectionW)(
    LPCWSTR lpAppName,          // section name
    LPCWSTR lpString,           // data
    LPCWSTR lpFileName          // file name
    )
{
    LPWSTR lpszString = MassageStringForPathW(lpFileName);

    BOOL returnValue = ORIGINAL_API(WritePrivateProfileSectionW)(lpAppName,
                                                                 lpString,
                                                                 lpszString);

    FPFreeW(lpszString, lpFileName);

    return returnValue;
}


BOOL
APIHOOK(WritePrivateProfileStringA)(
    LPCSTR lpAppName,           // section name
    LPCSTR lpKeyName,           // key name
    LPCSTR lpString,            // string to add
    LPCSTR lpFileName           // initialization file
    )
{
    LPSTR lpszString = MassageStringForPathA(lpFileName);

    BOOL returnValue = ORIGINAL_API(WritePrivateProfileStringA)(lpAppName,
                                                                lpKeyName,
                                                                lpString,
                                                                lpszString);

    FPFreeA(lpszString, lpFileName);

    return returnValue;
}


BOOL
APIHOOK(WritePrivateProfileStringW)(
    LPCWSTR lpAppName,          // section name
    LPCWSTR lpKeyName,          // key name
    LPCWSTR lpString,           // string to add
    LPCWSTR lpFileName          // initialization file
    )
{
    LPWSTR lpszString = MassageStringForPathW(lpFileName);

    BOOL returnValue = ORIGINAL_API(WritePrivateProfileStringW)(lpAppName,
                                                                lpKeyName,
                                                                lpString,
                                                                lpszString);

    FPFreeW(lpszString, lpFileName);

    return returnValue;
}


BOOL APIHOOK(WritePrivateProfileStructA)(
    LPCSTR lpszSection,         // section name
    LPCSTR lpszKey,             // key name
    LPVOID lpStruct,            // data buffer
    UINT   uSizeStruct,         // size of data buffer
    LPCSTR lpFileName           // initialization file
    )
{
    LPSTR lpszString = MassageStringForPathA(lpFileName);

    BOOL returnValue = ORIGINAL_API(WritePrivateProfileStructA)(lpszSection,
                                                                lpszKey,
                                                                lpStruct,
                                                                uSizeStruct,
                                                                lpszString);

    FPFreeA(lpszString, lpFileName);

    return returnValue;
}


BOOL
APIHOOK(WritePrivateProfileStructW)(
    LPCWSTR lpszSection,        // section name
    LPCWSTR lpszKey,            // key name
    LPVOID  lpStruct,           // data buffer
    UINT    uSizeStruct,        // size of data buffer
    LPCWSTR lpFileName          // initialization file
    )
{
    LPWSTR lpszString = MassageStringForPathW(lpFileName);

    BOOL returnValue = ORIGINAL_API(WritePrivateProfileStructW)(lpszSection,
                                                                lpszKey,
                                                                lpStruct,
                                                                uSizeStruct,
                                                                lpszString);

    FPFreeW(lpszString, lpFileName);

    return returnValue;
}


BOOL
APIHOOK(CopyFileA)(
    LPCSTR lpExistingFileName,  // name of an existing file
    LPCSTR lpNewFileName,       // name of new file
    BOOL   bFailIfExists        // operation if file exists
    )
{
    LPSTR lpszStringExisting = MassageStringForPathA(lpExistingFileName);
    LPSTR lpszStringNew = MassageStringForPathA(lpNewFileName);
    
    BOOL returnValue = ORIGINAL_API(CopyFileA)(lpszStringExisting,
                                               lpszStringNew,
                                               bFailIfExists);

    FPFreeA(lpszStringExisting, lpExistingFileName);
    FPFreeA(lpszStringNew, lpNewFileName);

    return returnValue;
}


BOOL
APIHOOK(CopyFileW)(
    LPCWSTR lpExistingFileName, // name of an existing file
    LPCWSTR lpNewFileName,      // name of new file
    BOOL    bFailIfExists       // operation if file exists
    )
{
    LPWSTR lpszStringExisting = MassageStringForPathW(lpExistingFileName);
    LPWSTR lpszStringNew = MassageStringForPathW(lpNewFileName);
    
    BOOL returnValue = ORIGINAL_API(CopyFileW)(lpszStringExisting,
                                               lpszStringNew,
                                               bFailIfExists);

    FPFreeW(lpszStringExisting, lpExistingFileName);
    FPFreeW(lpszStringNew, lpNewFileName);

    return returnValue;
}


BOOL APIHOOK(CopyFileExA)(
    LPCSTR             lpExistingFileName,  // name of existing file
    LPCSTR             lpNewFileName,       // name of new file
    LPPROGRESS_ROUTINE lpProgressRoutine,   // callback function
    LPVOID             lpData,              // callback parameter
    LPBOOL             pbCancel,            // cancel status
    DWORD              dwCopyFlags          // copy options
    )
{
    LPSTR lpszStringExisting = MassageStringForPathA(lpExistingFileName);
    LPSTR lpszStringNew = MassageStringForPathA(lpNewFileName);

    BOOL returnValue = ORIGINAL_API(CopyFileExA)(lpszStringExisting,
                                                 lpszStringNew,
                                                 lpProgressRoutine,
                                                 lpData,
                                                 pbCancel,
                                                 dwCopyFlags);

    FPFreeA(lpszStringExisting, lpExistingFileName);
    FPFreeA(lpszStringNew, lpNewFileName);

    return returnValue;
}


BOOL
APIHOOK(CopyFileExW)(
    LPCWSTR            lpExistingFileName,  // name of existing file
    LPCWSTR            lpNewFileName,       // name of new file
    LPPROGRESS_ROUTINE lpProgressRoutine,   // callback function
    LPVOID             lpData,              // callback parameter
    LPBOOL             pbCancel,            // cancel status
    DWORD              dwCopyFlags          // copy options
    )
{
    LPWSTR lpszStringExisting = MassageStringForPathW(lpExistingFileName);
    LPWSTR lpszStringNew = MassageStringForPathW(lpNewFileName);

    BOOL returnValue = ORIGINAL_API(CopyFileExW)(lpszStringExisting,
                                                 lpszStringNew,
                                                 lpProgressRoutine,
                                                 lpData,
                                                 pbCancel,
                                                 dwCopyFlags);

    FPFreeW(lpszStringExisting, lpExistingFileName);
    FPFreeW(lpszStringNew, lpNewFileName);

    return returnValue;
}


BOOL
APIHOOK(CreateDirectoryA)(
    LPCSTR                lpPathName,           // directory name
    LPSECURITY_ATTRIBUTES lpSecurityAttributes  // SD
    )
{
    LPSTR lpszString = MassageStringForPathA(lpPathName);

    BOOL returnValue = ORIGINAL_API(CreateDirectoryA)(lpszString, lpSecurityAttributes);

    FPFreeA(lpszString, lpPathName);

    return returnValue;
}


BOOL
APIHOOK(CreateDirectoryW)(
    LPCWSTR               lpPathName,           // directory name
    LPSECURITY_ATTRIBUTES lpSecurityAttributes  // SD
    )
{
    LPWSTR lpszString = MassageStringForPathW(lpPathName);

    BOOL returnValue = ORIGINAL_API(CreateDirectoryW)(lpszString, lpSecurityAttributes);

    FPFreeW(lpszString, lpPathName);

    return returnValue;
}


BOOL
APIHOOK(CreateDirectoryExA)(
    LPCSTR                lpTemplateDirectory,   // template directory
    LPCSTR                lpNewDirectory,        // directory name
    LPSECURITY_ATTRIBUTES lpSecurityAttributes   // SD
    )
{
    LPSTR lpszStringTemplate = MassageStringForPathA(lpTemplateDirectory);
    LPSTR lpszStringNew = MassageStringForPathA(lpNewDirectory);
    
    BOOL returnValue = ORIGINAL_API(CreateDirectoryExA)(lpszStringTemplate,
                                                        lpszStringNew,
                                                        lpSecurityAttributes);

    FPFreeA(lpszStringTemplate, lpTemplateDirectory);
    FPFreeA(lpszStringNew, lpNewDirectory);

    return returnValue;
}


BOOL
APIHOOK(CreateDirectoryExW)(
    LPCWSTR               lpTemplateDirectory,  // template directory
    LPCWSTR               lpNewDirectory,       // directory name
    LPSECURITY_ATTRIBUTES lpSecurityAttributes  // SD
    )
{
    LPWSTR lpszStringTemplate = MassageStringForPathW(lpTemplateDirectory);
    LPWSTR lpszStringNew = MassageStringForPathW(lpNewDirectory);
    
    BOOL returnValue = ORIGINAL_API(CreateDirectoryExW)(lpszStringTemplate,
                                                        lpszStringNew,
                                                        lpSecurityAttributes);

    FPFreeW(lpszStringTemplate, lpTemplateDirectory);
    FPFreeW(lpszStringNew, lpNewDirectory);

    return returnValue;
}


HANDLE
APIHOOK(CreateFileA)(
    LPCSTR                lpFileName,            // file name
    DWORD                 dwDesiredAccess,       // access mode
    DWORD                 dwShareMode,           // share mode
    LPSECURITY_ATTRIBUTES lpSecurityAttributes,  // SD
    DWORD                 dwCreationDisposition, // how to create
    DWORD                 dwFlagsAndAttributes,  // file attributes
    HANDLE                hTemplateFile          // handle to template file
    )
{
    LPSTR lpszString = MassageStringForPathA(lpFileName);

    HANDLE returnValue = ORIGINAL_API(CreateFileA)(lpszString,
                                                   dwDesiredAccess,
                                                   dwShareMode,
                                                   lpSecurityAttributes,
                                                   dwCreationDisposition,
                                                   dwFlagsAndAttributes,
                                                   hTemplateFile);

    FPFreeA(lpszString, lpFileName);

    return returnValue;
}


HANDLE
APIHOOK(CreateFileW)(
    LPCWSTR               lpFileName,            // file name
    DWORD                 dwDesiredAccess,       // access mode
    DWORD                 dwShareMode,           // share mode
    LPSECURITY_ATTRIBUTES lpSecurityAttributes,  // SD
    DWORD                 dwCreationDisposition, // how to create
    DWORD                 dwFlagsAndAttributes,  // file attributes
    HANDLE                hTemplateFile          // handle to template file
    )
{
    LPWSTR lpszString = MassageStringForPathW(lpFileName);

    HANDLE returnValue = ORIGINAL_API(CreateFileW)(lpszString,
                                                   dwDesiredAccess,
                                                   dwShareMode,
                                                   lpSecurityAttributes,
                                                   dwCreationDisposition,
                                                   dwFlagsAndAttributes,
                                                   hTemplateFile);

    FPFreeW(lpszString, lpFileName);

    return returnValue;
}


BOOL
APIHOOK(DeleteFileA)(
    LPCSTR lpFileName           // file name
    )
{
    LPSTR lpszString = MassageStringForPathA(lpFileName);

    BOOL returnValue = ORIGINAL_API(DeleteFileA)(lpszString);

    FPFreeA(lpszString, lpFileName);

    return returnValue;
}


BOOL
APIHOOK(DeleteFileW)(
    LPCWSTR lpFileName          // file name
    )
{
    LPWSTR lpszString = MassageStringForPathW(lpFileName);

    BOOL returnValue = ORIGINAL_API(DeleteFileW)(lpszString);

    FPFreeW(lpszString, lpFileName);

    return returnValue;
}


HANDLE
APIHOOK(FindFirstFileA)(
    LPCSTR             lpFileName,      // file name
    LPWIN32_FIND_DATAA lpFindFileData   // data buffer
    )
{
    LPSTR lpszString = MassageStringForPathA(lpFileName);

    HANDLE returnValue = ORIGINAL_API(FindFirstFileA)(lpszString, lpFindFileData);

    FPFreeA(lpszString, lpFileName);

    return returnValue;
}


HANDLE
APIHOOK(FindFirstFileW)(
  LPCWSTR            lpFileName,        // file name
  LPWIN32_FIND_DATAW lpFindFileData     // data buffer
)
{
    LPWSTR lpszString = MassageStringForPathW(lpFileName);

    HANDLE returnValue = ORIGINAL_API(FindFirstFileW)(lpszString, lpFindFileData);

    FPFreeW(lpszString, lpFileName);

    return returnValue;
}


HANDLE
APIHOOK(FindFirstFileExA)(
    LPCSTR             lpFileName,       // file name
    FINDEX_INFO_LEVELS fInfoLevelId,     // information level
    LPVOID             lpFindFileData,   // information buffer
    FINDEX_SEARCH_OPS  fSearchOp,        // filtering type
    LPVOID             lpSearchFilter,   // search criteria
    DWORD              dwAdditionalFlags // additional search control
    )
{
    LPSTR lpszString = MassageStringForPathA(lpFileName);

    HANDLE returnValue = ORIGINAL_API(FindFirstFileExA)(lpszString,
                                                        fInfoLevelId,
                                                        lpFindFileData,
                                                        fSearchOp,
                                                        lpSearchFilter,
                                                        dwAdditionalFlags);

    FPFreeA(lpszString, lpFileName);

    return returnValue;
}


HANDLE
APIHOOK(FindFirstFileExW)(
    LPCWSTR            lpFileName,       // file name
    FINDEX_INFO_LEVELS fInfoLevelId,     // information level
    LPVOID             lpFindFileData,   // information buffer
    FINDEX_SEARCH_OPS  fSearchOp,        // filtering type
    LPVOID             lpSearchFilter,   // search criteria
    DWORD              dwAdditionalFlags // additional search control
    )
{
    LPWSTR lpszString = MassageStringForPathW(lpFileName);

    HANDLE returnValue = ORIGINAL_API(FindFirstFileExW)(lpszString,
                                                        fInfoLevelId,
                                                        lpFindFileData,
                                                        fSearchOp,
                                                        lpSearchFilter,
                                                        dwAdditionalFlags);

    FPFreeW(lpszString, lpFileName);

    return returnValue;
}


BOOL
APIHOOK(GetBinaryTypeA)(
    LPCSTR  lpApplicationName,      // full file path
    LPDWORD lpBinaryType            // binary type information
    )
{
    LPSTR lpszString = MassageStringForPathA(lpApplicationName);

    BOOL returnValue = ORIGINAL_API(GetBinaryTypeA)(lpszString, lpBinaryType);

    FPFreeA(lpszString, lpApplicationName);

    return returnValue;
}


BOOL
APIHOOK(GetBinaryTypeW)(
    LPCWSTR lpApplicationName,      // full file path
    LPDWORD lpBinaryType            // binary type information
    )
{
    LPWSTR lpszString = MassageStringForPathW(lpApplicationName);

    BOOL returnValue = ORIGINAL_API(GetBinaryTypeW)(lpszString, lpBinaryType);

    FPFreeW(lpszString, lpApplicationName);

    return returnValue;
}

BOOL
APIHOOK(MoveFileA)(
    LPCSTR lpExistingFileName,      // file name
    LPCSTR lpNewFileName            // new file name
    )
{
    LPSTR lpszStringExisting = MassageStringForPathA(lpExistingFileName);
    LPSTR lpszStringNew = MassageStringForPathA(lpNewFileName);
    
    BOOL returnValue = ORIGINAL_API(MoveFileA)(lpszStringExisting, lpszStringNew);

    FPFreeA(lpszStringExisting, lpExistingFileName);
    FPFreeA(lpszStringNew, lpNewFileName);
    
    return returnValue;
}


BOOL
APIHOOK(MoveFileW)(
    LPCWSTR lpExistingFileName,     // file name
    LPCWSTR lpNewFileName           // new file name
    )
{
    LPWSTR lpszStringExisting = MassageStringForPathW(lpExistingFileName);
    LPWSTR lpszStringNew = MassageStringForPathW(lpNewFileName);
    
    BOOL returnValue = ORIGINAL_API(MoveFileW)(lpszStringExisting, lpszStringNew);

    FPFreeW(lpszStringExisting, lpExistingFileName);
    FPFreeW(lpszStringNew, lpNewFileName);

    return returnValue;
}


BOOL
APIHOOK(MoveFileExA)(
    LPCSTR lpExistingFileName,      // file name
    LPCSTR lpNewFileName,           // new file name
    DWORD  dwFlags                  // move options
    )
{
    LPSTR lpszStringExisting = MassageStringForPathA(lpExistingFileName);
    LPSTR lpszStringNew = MassageStringForPathA(lpNewFileName);

    BOOL returnValue = ORIGINAL_API(MoveFileExA)(lpszStringExisting, lpszStringNew, dwFlags);

    FPFreeA(lpszStringExisting, lpExistingFileName);
    FPFreeA(lpszStringNew, lpNewFileName);

    return returnValue;
}


BOOL
APIHOOK(MoveFileExW)(
    LPCWSTR lpExistingFileName,     // file name
    LPCWSTR lpNewFileName,          // new file name
    DWORD   dwFlags                 // move options
    )
{
    LPWSTR lpszStringExisting = MassageStringForPathW(lpExistingFileName);
    LPWSTR lpszStringNew = MassageStringForPathW(lpNewFileName);

    BOOL returnValue = ORIGINAL_API(MoveFileExW)(lpszStringExisting, lpszStringNew, dwFlags);

    FPFreeW(lpszStringExisting, lpExistingFileName);
    FPFreeW(lpszStringNew, lpNewFileName);

    return returnValue;
}


BOOL
APIHOOK(MoveFileWithProgressA)(
    LPCSTR             lpExistingFileName,  // file name
    LPCSTR             lpNewFileName,       // new file name
    LPPROGRESS_ROUTINE lpProgressRoutine,   // callback function
    LPVOID             lpData,              // parameter for callback
    DWORD              dwFlags              // move options
    )
{
    LPSTR lpszStringExisting = MassageStringForPathA(lpExistingFileName);
    LPSTR lpszStringNew = MassageStringForPathA(lpNewFileName);

    BOOL returnValue = ORIGINAL_API(MoveFileWithProgressA)(lpszStringExisting,
                                                           lpszStringNew,
                                                           lpProgressRoutine,
                                                           lpData,
                                                           dwFlags);

    FPFreeA(lpszStringExisting, lpExistingFileName);
    FPFreeA(lpszStringNew, lpNewFileName);

    return returnValue;
}


BOOL
APIHOOK(MoveFileWithProgressW)(
    LPCWSTR            lpExistingFileName,  // file name
    LPCWSTR            lpNewFileName,       // new file name
    LPPROGRESS_ROUTINE lpProgressRoutine,   // callback function
    LPVOID             lpData,              // parameter for callback
    DWORD              dwFlags              // move options
    )
{
    LPWSTR lpszStringExisting = MassageStringForPathW(lpExistingFileName);
    LPWSTR lpszStringNew = MassageStringForPathW(lpNewFileName);

    BOOL returnValue = ORIGINAL_API(MoveFileWithProgressW)(lpExistingFileName,
                                                           lpNewFileName,
                                                           lpProgressRoutine,
                                                           lpData,
                                                           dwFlags);

    FPFreeW(lpszStringExisting, lpExistingFileName);
    FPFreeW(lpszStringNew, lpNewFileName);

    return returnValue;
}


BOOL
APIHOOK(RemoveDirectoryA)(
    LPCSTR lpPathName           // directory name
    )
{
    LPSTR lpszString = MassageStringForPathA(lpPathName);

    BOOL returnValue = ORIGINAL_API(RemoveDirectoryA)(lpszString);

    FPFreeA(lpszString, lpPathName);

    return returnValue;
}


BOOL
APIHOOK(RemoveDirectoryW)(
    LPCWSTR lpPathName          // directory name
    )
{
    LPWSTR lpszString = MassageStringForPathW(lpPathName);

    BOOL returnValue = ORIGINAL_API(RemoveDirectoryW)(lpszString);

    FPFreeW(lpszString, lpPathName);

    return returnValue;
}


BOOL
APIHOOK(SetCurrentDirectoryA)(
    LPCSTR lpPathName           // new directory name
    )
{
    LPSTR lpszString = MassageStringForPathA(lpPathName);

    BOOL returnValue = ORIGINAL_API(SetCurrentDirectoryA)(lpszString);

    FPFreeA(lpszString, lpPathName);

    return returnValue;
}


BOOL
APIHOOK(SetCurrentDirectoryW)(
    LPCWSTR lpPathName          // new directory name
    )
{
    LPWSTR lpszString = MassageStringForPathW(lpPathName);

    BOOL returnValue = ORIGINAL_API(SetCurrentDirectoryW)(lpszString);

    FPFreeW(lpszString, lpPathName);

    return returnValue;
}

HMODULE
APIHOOK(LoadLibraryA)(
    LPCSTR lpPathName
    )
{
    LPSTR lpszString = MassageStringForPathA(lpPathName);

    HMODULE returnValue = ORIGINAL_API(LoadLibraryA)(lpszString);

    FPFreeA(lpszString, lpPathName);

    return returnValue;
}

HMODULE
APIHOOK(LoadLibraryW)(
    LPCWSTR lpPathName
    )
{
    LPWSTR lpszString = MassageStringForPathW(lpPathName);

    HMODULE returnValue = ORIGINAL_API(LoadLibraryW)(lpszString);

    FPFreeW(lpszString, lpPathName);

    return returnValue;
}

HMODULE
APIHOOK(LoadLibraryExA)(
    LPCSTR  lpPathName,
    HANDLE  hFile,
    DWORD   dwFlags
    )
{
    LPSTR lpszString = MassageStringForPathA(lpPathName);

    HMODULE returnValue = ORIGINAL_API(LoadLibraryExA)(lpszString, hFile, dwFlags);

    FPFreeA(lpszString, lpPathName);

    return returnValue;
}

HMODULE
APIHOOK(LoadLibraryExW)(
    LPCWSTR lpPathName,
    HANDLE  hFile,
    DWORD   dwFlags
    )
{
    LPWSTR lpszString = MassageStringForPathW(lpPathName);

    HMODULE returnValue = ORIGINAL_API(LoadLibraryExW)(lpszString, hFile, dwFlags);

    FPFreeW(lpszString, lpPathName);

    return returnValue;
}

HFILE
APIHOOK(OpenFile)(
    LPCSTR     lpFileName,      // file name
    LPOFSTRUCT lpReOpenBuff,    // file information
    UINT       uStyle           // action and attributes
    )
{
    LPSTR lpszString = MassageStringForPathA(lpFileName);

    HFILE returnValue = ORIGINAL_API(OpenFile)(lpszString, lpReOpenBuff, uStyle);

    MassageRealPathToFakePathA(lpReOpenBuff->szPathName, OFS_MAXPATHNAME);

    FPFreeA(lpszString, lpFileName);

    return returnValue;
}

LONG 
APIHOOK(RegSetValueA)(
    HKEY   hKey,            // handle to key
    LPCSTR lpSubKey,        // subkey name
    DWORD  dwType,          // information type
    LPCSTR lpData,          // value data
    DWORD  cbData           // size of value data
    )
{
    LPSTR lpszString = MassageStringForPathA(lpData);

    //
    // Data key is length of string *not* including null byte.
    //
    if (lpszString != NULL) {
        cbData = strlen(lpszString);
    }

    LONG returnValue = ORIGINAL_API(RegSetValueA)(hKey,
                                                  lpSubKey,
                                                  dwType,
                                                  lpszString,
                                                  cbData);

    FPFreeA(lpszString, lpData);

    return returnValue;
}

LONG 
APIHOOK(RegSetValueW)(
    HKEY    hKey,           // handle to key
    LPCWSTR lpSubKey,       // subkey name
    DWORD   dwType,         // information type
    LPCWSTR lpData,         // value data
    DWORD   cbData          // size of value data
    )
{
    LPWSTR lpszString = MassageStringForPathW(lpData);

    //
    // Data key is length of string *not* including null byte.
    //
    if (lpszString) {
        cbData = wcslen(lpszString) * sizeof(WCHAR);
    }

    LONG returnValue = ORIGINAL_API(RegSetValueW)(hKey,
                                                  lpSubKey,
                                                  dwType, 
                                                  lpszString,
                                                  cbData);

    FPFreeW(lpszString, lpData);

    return returnValue;
}

LONG 
APIHOOK(RegSetValueExA)(
    HKEY   hKey,            // handle to key
    LPCSTR lpValueName,     // value name
    DWORD  Reserved,        // reserved
    DWORD  dwType,          // value type
    CONST BYTE *lpData,     // value data
    DWORD  cbData           // size of value data
    )
{
    if (dwType == REG_SZ || dwType == REG_EXPAND_SZ) {
        
        LPSTR lpszString = MassageStringForPathA((LPCSTR)lpData);

        //
        // Data key is length of string *not* including null byte.
        //
        if (lpszString) {
            cbData = strlen(lpszString);
        }

        LONG returnValue = ORIGINAL_API(RegSetValueExA)(hKey,
                                                        lpValueName,
                                                        Reserved,
                                                        dwType,
                                                        (CONST BYTE*)lpszString,
                                                        cbData);
        FPFreeA(lpszString, (LPCSTR)lpData);

        return returnValue;
    
    } else {
        //
        // Pass data on through.
        //
        LONG returnValue = ORIGINAL_API(RegSetValueExA)(hKey,
                                                        lpValueName,
                                                        Reserved,
                                                        dwType,
                                                        lpData,
                                                        cbData);
        return returnValue;

    }
}

LONG 
APIHOOK(RegSetValueExW)(
    HKEY    hKey,           // handle to key
    LPCWSTR lpValueName,    // value name
    DWORD   Reserved,       // reserved
    DWORD   dwType,         // value type
    CONST BYTE *lpData,     // value data
    DWORD   cbData          // size of value data
    )
{
    if (dwType == REG_SZ || dwType == REG_EXPAND_SZ) {
        
        LPWSTR lpszString = MassageStringForPathW((LPCWSTR)lpData);

        //
        // Data key is length of string *not* including null byte.
        //
        if (lpszString) {
            cbData = (wcslen(lpszString) + 1) * sizeof(WCHAR);
        }

        LONG returnValue = ORIGINAL_API(RegSetValueExW)(hKey,
                                                        lpValueName,
                                                        Reserved,
                                                        dwType,
                                                        (CONST BYTE*)lpszString,
                                                        cbData);
        FPFreeW(lpszString, (LPCWSTR)lpData);

        return returnValue;
    
    } else {
        //
        // Pass data on through.
        //
        LONG returnValue = ORIGINAL_API(RegSetValueExW)(hKey,
                                                        lpValueName,
                                                        Reserved,
                                                        dwType,
                                                        lpData,
                                                        cbData);
        return returnValue;
    }
    
}

LONG 
APIHOOK(RegQueryValueA)(
    HKEY   hKey,
    LPCSTR lpSubKey,
    LPSTR  lpValue,
    PLONG  lpcbValue
    )
{
    //
    // Obtain the size of the buffer prior to the call.
    // When the call is complete, lpcbValue will contain
    // the size of the data stored in the buffer. We
    // need the size of the buffer.
    //
    LONG cbValue = 0;
    
    if (lpcbValue) {
        cbValue = *lpcbValue;
    }

    LONG returnValue = ORIGINAL_API(RegQueryValueA)(hKey,
                                                    lpSubKey,
                                                    lpValue,
                                                    lpcbValue);

    if (ERROR_SUCCESS == returnValue) {
        MassageRealPathToFakePathA(lpValue, (DWORD)cbValue);
    }

    return returnValue;
}

LONG 
APIHOOK(RegQueryValueW)(
    HKEY    hKey,
    LPCWSTR lpSubKey,
    LPWSTR  lpValue,
    PLONG   lpcbValue
    )
{
    LONG cbValue = 0;

    if (lpcbValue) {
        cbValue = *lpcbValue;
    }

    LONG returnValue = ORIGINAL_API(RegQueryValueW)(hKey,
                                                    lpSubKey,
                                                    lpValue,
                                                    lpcbValue);

    if (ERROR_SUCCESS == returnValue) {
        MassageRealPathToFakePathW(lpValue, (DWORD)cbValue);
    }

    return returnValue;
}

LONG 
APIHOOK(RegQueryValueExA)(
    HKEY    hKey,
    LPCSTR  lpValueName,
    LPDWORD lpReserved,
    LPDWORD lpType,
    LPBYTE  lpData,
    LPDWORD lpcbData
    )
{
    DWORD cbData = 0;
    DWORD dwType = 0;

    if (lpcbData) {
        cbData = *lpcbData;
    }

    if (!lpType) {
        lpType = &dwType;
    }

    LONG returnValue = ORIGINAL_API(RegQueryValueExA)(hKey,
                                                      lpValueName,
                                                      lpReserved,
                                                      lpType,
                                                      lpData,
                                                      lpcbData);

    if (ERROR_SUCCESS == returnValue) {
        if (*lpType == REG_SZ || *lpType == REG_EXPAND_SZ) {
            MassageRealPathToFakePathA((LPSTR)lpData, cbData);
        }
    }
    
    return returnValue;
}

LONG 
APIHOOK(RegQueryValueExW)(
    HKEY    hKey,
    LPCWSTR lpValueName,
    LPDWORD lpReserved,
    LPDWORD lpType,
    LPBYTE  lpData,
    LPDWORD lpcbData
    )
{
    DWORD cbData = 0;
    DWORD dwType = 0;

    if (lpcbData) {
        cbData = *lpcbData;
    }

    if (!lpType) {
        lpType = &dwType;
    }

    LONG returnValue = ORIGINAL_API(RegQueryValueExW)(hKey,
                                                      lpValueName,
                                                      lpReserved,
                                                      lpType,
                                                      lpData,
                                                      lpcbData);

    if (ERROR_SUCCESS == returnValue) {
        if (*lpType == REG_SZ || *lpType == REG_EXPAND_SZ) {
            MassageRealPathToFakePathW((LPWSTR)lpData, cbData);
        }
    }

    return returnValue;
}

HFILE
APIHOOK(_lopen)(
    LPCSTR lpPathName,
    int    iReadWrite
    )
{
    LPSTR lpszString = MassageStringForPathA(lpPathName);

    HFILE returnValue = ORIGINAL_API(_lopen)(lpszString, iReadWrite);

    FPFreeA(lpszString, lpPathName);

    return returnValue;    
}

HFILE
APIHOOK(_lcreat)(
    LPCSTR lpPathName,
    int    iAttribute
    )
{
    LPSTR lpszString = MassageStringForPathA(lpPathName);

    HFILE returnValue = ORIGINAL_API(_lcreat)(lpszString, iAttribute);

    FPFreeA(lpszString, lpPathName);

    return returnValue;    
}

DWORD
APIHOOK(SearchPathA)(
    LPCSTR lpPath,        // search path
    LPCSTR lpFileName,    // file name
    LPCSTR lpExtension,   // file extension
    DWORD  nBufferLength, // size of buffer
    LPSTR  lpBuffer,      // found file name buffer
    LPSTR  *lpFilePart    // file component
    )
{
    LPSTR lpszStringPath = MassageStringForPathA(lpPath);
    LPSTR lpszStringFile = MassageStringForPathA(lpFileName);

    DWORD returnValue = ORIGINAL_API(SearchPathA)(lpszStringPath,
                                                  lpszStringFile,
                                                  lpExtension,
                                                  nBufferLength,
                                                  lpBuffer,
                                                  lpFilePart);

    FPFreeA(lpszStringPath, lpPath);
    FPFreeA(lpszStringFile, lpFileName);

    return returnValue;
}

DWORD
APIHOOK(SearchPathW)(
    LPCWSTR lpPath,         // search path
    LPCWSTR lpFileName,     // file name
    LPCWSTR lpExtension,    // file extension
    DWORD   nBufferLength,  // size of buffer
    LPWSTR  lpBuffer,       // found file name buffer
    LPWSTR  *lpFilePart     // file component
    )
{
    LPWSTR lpszStringPath = MassageStringForPathW(lpPath);
    LPWSTR lpszStringFile = MassageStringForPathW(lpFileName);

    DWORD returnValue = ORIGINAL_API(SearchPathW)(lpszStringPath,
                                                  lpszStringFile,
                                                  lpExtension,
                                                  nBufferLength,
                                                  lpBuffer,
                                                  lpFilePart);

    FPFreeW(lpszStringPath, lpPath);
    FPFreeW(lpszStringFile, lpFileName);

    return returnValue;
}

DWORD
APIHOOK(ExpandEnvironmentStringsA)(
    LPCSTR lpSrc,    // string with environment variables
    LPSTR  lpDst,    // string with expanded strings 
    DWORD  nSize     // maximum characters in expanded string
    )
{
    DWORD returnValue = ORIGINAL_API(ExpandEnvironmentStringsA)(lpSrc,
                                                                lpDst,
                                                                nSize);

    if (returnValue && (!(returnValue > nSize))) {
        LPSTR lpszString = MassageStringForPathA(lpDst);

        returnValue = ORIGINAL_API(ExpandEnvironmentStringsA)(lpszString,
                                                              lpDst,
                                                              nSize);

        FPFreeA(lpszString, lpDst);
    }

    return returnValue;
}

DWORD
APIHOOK(ExpandEnvironmentStringsW)(
    LPCWSTR lpSrc,    // string with environment variables
    LPWSTR  lpDst,    // string with expanded strings 
    DWORD   nSize     // maximum characters in expanded string
    )
{
    DWORD returnValue = ORIGINAL_API(ExpandEnvironmentStringsW)(lpSrc,
                                                                lpDst,
                                                                nSize);

    if (returnValue && (!(returnValue > nSize))) {
        LPWSTR lpszString = MassageStringForPathW(lpDst);

        returnValue = ORIGINAL_API(ExpandEnvironmentStringsW)(lpszString,
                                                              lpDst,
                                                              nSize);

        FPFreeW(lpszString, lpDst);
    }

    return returnValue;
}

DWORD
APIHOOK(GetFileVersionInfoSizeA)(
    LPSTR   lptstrFilename,   // file name
    LPDWORD lpdwHandle        // set to zero
    )
{
    LPSTR lpszString = MassageStringForPathA(lptstrFilename);

    DWORD returnValue = ORIGINAL_API(GetFileVersionInfoSizeA)(lpszString,
                                                              lpdwHandle);

    FPFreeA(lpszString, lptstrFilename);

    return returnValue;
}

DWORD
APIHOOK(GetFileVersionInfoSizeW)(
    LPWSTR   lptstrFilename,   // file name
    LPDWORD  lpdwHandle        // set to zero
    )
{
    LPWSTR lpszString = MassageStringForPathW(lptstrFilename);

    DWORD returnValue = ORIGINAL_API(GetFileVersionInfoSizeW)(lpszString,
                                                              lpdwHandle);

    FPFreeW(lpszString, lptstrFilename);

    return returnValue;
}

BOOL
APIHOOK(GetFileVersionInfoA)(
    LPSTR  lptstrFilename,    // file name
    DWORD  dwHandle,          // ignored
    DWORD  dwLen,             // size of buffer
    LPVOID lpData             // version information buffer
    )
{
    LPSTR lpszString = MassageStringForPathA(lptstrFilename);

    BOOL returnValue = ORIGINAL_API(GetFileVersionInfoA)(lpszString,
                                                         dwHandle,
                                                         dwLen,
                                                         lpData);

    FPFreeA(lpszString, lptstrFilename);

    return returnValue;
}

BOOL
APIHOOK(GetFileVersionInfoW)(
    LPWSTR  lptstrFilename,    // file name
    DWORD   dwHandle,          // ignored
    DWORD   dwLen,             // size of buffer
    LPVOID  lpData             // version information buffer
    )
{
    LPWSTR lpszString = MassageStringForPathW(lptstrFilename);

    BOOL returnValue = ORIGINAL_API(GetFileVersionInfoW)(lpszString,
                                                         dwHandle,
                                                         dwLen,
                                                         lpData);

    FPFreeW(lpszString, lptstrFilename);

    return returnValue;
}

BOOL
APIHOOK(GetOpenFileNameA)(
    LPOPENFILENAMEA lpofn   // initialization data
    )
{
    BOOL    fReturn = FALSE;

    fReturn = ORIGINAL_API(GetOpenFileNameA)(lpofn);

    if (fReturn) {
        MassageRealPathToFakePathA(lpofn->lpstrFile, lpofn->nMaxFile);
    }

    return fReturn;
}

BOOL
APIHOOK(GetOpenFileNameW)(
    LPOPENFILENAMEW lpofn   // initialization data
    )
{
    BOOL fReturn = ORIGINAL_API(GetOpenFileNameW)(lpofn);

    if (fReturn) {
        MassageRealPathToFakePathW(lpofn->lpstrFile, lpofn->nMaxFile);
    }

    return fReturn;
}

BOOL
APIHOOK(GetSaveFileNameA)(
    LPOPENFILENAMEA lpofn   // initialization data
    )
{
    BOOL fReturn = ORIGINAL_API(GetSaveFileNameA)(lpofn);

    if (fReturn) {
        MassageRealPathToFakePathA(lpofn->lpstrFile, lpofn->nMaxFile);
    }

    return fReturn;
}

BOOL
APIHOOK(GetSaveFileNameW)(
    LPOPENFILENAMEW lpofn   // initialization data
    )
{
    BOOL fReturn = ORIGINAL_API(GetSaveFileNameW)(lpofn);

    if (fReturn) {
        MassageRealPathToFakePathW(lpofn->lpstrFile, lpofn->nMaxFile);
    }

    return fReturn;
}

DWORD
APIHOOK(GetModuleFileNameA)(
    HMODULE hModule,      // handle to module
    LPSTR   lpFilename,   // path buffer
    DWORD   nSize         // size of buffer
    )
{
    DWORD dwReturn = ORIGINAL_API(GetModuleFileNameA)(hModule,
                                                      lpFilename,
                                                      nSize);

    if (dwReturn) {
        MassageRealPathToFakePathA(lpFilename, nSize);
    }

    return dwReturn;
}

DWORD
APIHOOK(GetModuleFileNameW)(
    HMODULE hModule,     // handle to module
    LPWSTR  lpFilename,  // path buffer
    DWORD   nSize        // size of buffer
    )
{
    DWORD dwReturn = ORIGINAL_API(GetModuleFileNameW)(hModule,
                                                      lpFilename,
                                                      nSize);
    if (dwReturn) {
        MassageRealPathToFakePathW(lpFilename, nSize);
    }

    return dwReturn;
}

DWORD
APIHOOK(GetModuleFileNameExA)(
    HANDLE  hProcess,     // handle to process
    HMODULE hModule,      // handle to module
    LPSTR   lpFilename,   // path buffer
    DWORD   nSize         // size of buffer
    )
{
    DWORD dwReturn = ORIGINAL_API(GetModuleFileNameExA)(hProcess,
                                                        hModule,
                                                        lpFilename,
                                                        nSize);
    if (dwReturn) {
        MassageRealPathToFakePathA(lpFilename, nSize);
    }

    return dwReturn;
}

DWORD
APIHOOK(GetModuleFileNameExW)(
    HANDLE  hProcess,     // handle to process
    HMODULE hModule,      // handle to module
    LPWSTR  lpFilename,   // path buffer
    DWORD   nSize         // size of buffer
    )
{
    DWORD dwReturn = ORIGINAL_API(GetModuleFileNameExW)(hProcess,
                                                        hModule,
                                                        lpFilename,
                                                        nSize);
    if (dwReturn) {
        MassageRealPathToFakePathW(lpFilename, nSize);
    }

    return dwReturn;
}

DWORD
APIHOOK(GetCurrentDirectoryA)(
    DWORD nBufferLength,  // size of directory buffer
    LPSTR lpBuffer        // directory buffer
    )
{
    DWORD dwReturn = ORIGINAL_API(GetCurrentDirectoryA)(nBufferLength,
                                                        lpBuffer);

    if (dwReturn) {
        MassageRealPathToFakePathA(lpBuffer, nBufferLength);
    }

    return dwReturn;
}

DWORD
APIHOOK(GetCurrentDirectoryW)(
    DWORD  nBufferLength,  // size of directory buffer
    LPWSTR lpBuffer        // directory buffer
    )
{
    DWORD dwReturn = ORIGINAL_API(GetCurrentDirectoryW)(nBufferLength,
                                                        lpBuffer);

    if (dwReturn) {
        MassageRealPathToFakePathW(lpBuffer, nBufferLength);
    }

    return dwReturn;
}

/*++

 Add a corrected path to the linked list.

--*/
BOOL
AddCorrectedPath(
    LPCWSTR  pwszCorrectedPath,
    ListType eType
    )
{
    int         nLen = 0;
    PFILELIST   pFile = NULL;
    LPWSTR      pwszFilePath = NULL;

    pFile = (PFILELIST)malloc(sizeof(FILELIST));

    if (!pFile) {
        DPFN(eDbgLevelError, "[AddCorrectedPath] No memory for new node!");
        return FALSE;
    }

    //
    // We allocate the memory here to make it easier to keep track of.
    // When we release the memory at the end, we can release all of it
    // from one place.
    //
    nLen = lstrlenW(pwszCorrectedPath) + 1;

    pwszFilePath = (LPWSTR)malloc(nLen * sizeof(WCHAR));

    if (!pwszFilePath) {
        DPFN(eDbgLevelError, "[AddCorrectedPath] No memory for wide path!");
        return FALSE;
    }

    wcsncpy(pwszFilePath, pwszCorrectedPath, nLen);

    pFile->cchSize      = nLen;
    pFile->pwszFilePath = pwszFilePath;

    //
    // Determine which list we should add this node to.
    //
    if (eType == eFrom) {
        pFile->pNext        = g_pFileListFromHead;
        g_pFileListFromHead = pFile;
    } else {
        pFile->pNext        = g_pFileListToHead;
        g_pFileListToHead   = pFile;
    }

    return TRUE;
}

/*++

 Build a list of strings separated by NULLs with two NULLs at the end.

--*/
LPWSTR
BuildStringList(
    ListType eListType
    )
{
    UINT        uMemSize = 0;
    PFILELIST   pFile = NULL;
    PFILELIST   pHead = NULL;
    LPWSTR      pwszReturn = NULL;
    LPWSTR      pwszNextString = NULL;

    //
    // Determine which list we're working with.
    //
    switch (eListType) {
    case eFrom:
        pHead = pFile = g_pFileListFromHead;
        break;
    
    case eTo:
        pHead = pFile = g_pFileListToHead;
        break;

    default:
        break;
    }

    //
    // Walk the list and determine how large of a block we'll need to allocate.
    //
    while (pFile) {
        uMemSize += pFile->cchSize;
        pFile = pFile->pNext;
    }

    if (!uMemSize) {
        DPFN(eDbgLevelError, "[BuildStringList] List is empty!");
        return NULL;
    }

    //
    // Allocate a block large enough to hold the strings with a NULL at the end.
    //
    pwszReturn = (LPWSTR)malloc(++uMemSize * sizeof(WCHAR));

    if (!pwszReturn) {
        DPFN(eDbgLevelError, "[BuildStringList] No memory for string!");
        return NULL;
    }

    //
    // Walk the linked list and build the list of Unicode strings.
    //
    pwszNextString  = pwszReturn;
    *pwszNextString = '\0';

    while (pHead) {
        wcsncpy(pwszNextString, pHead->pwszFilePath, pHead->cchSize);
        pwszNextString += pHead->cchSize;
        pHead = pHead->pNext;
    }

    *pwszNextString++ = '\0';

    return pwszReturn;
}

/*++

 Release memory that was allocated while processing SHFileOperation.

--*/
void
ReleaseMemAllocations(
    LPWSTR   pwszFinalPath,
    ListType eListType
    )
{
    PFILELIST  pHead = NULL;
    PFILELIST  pTemp = NULL;

    switch (eListType) {
    case eFrom:
        pHead = g_pFileListFromHead;
        break;
    
    case eTo:
        pHead = g_pFileListToHead;
        break;

    default:
        break;
    }

    //
    // Free the paths first, then the nodes next.
    //
    while (pHead) {
        if (pHead->pwszFilePath) {
            free(pHead->pwszFilePath);
        }

        pTemp = pHead;
        pHead = pHead->pNext;
        free(pTemp);
    }

    if (pwszFinalPath) {
        free(pwszFinalPath);
    }
}

/*++

 Build a linked list of corrected paths.

--*/
BOOL
BuildLinkedList(
    LPCWSTR  pwszOriginalPath,
    ListType eListType
    )
{
    UINT    uSize = 0;
    LPWSTR  pwszReturnPath = NULL;

    if (pwszOriginalPath) {
        while (TRUE) {
            pwszReturnPath = MassageStringForPathW(pwszOriginalPath);

            //
            // Add this corrected path to our list.
            //
            if (!AddCorrectedPath(pwszReturnPath, eListType)) {
                DPFN(eDbgLevelError,
                     "[BuildLinkedList] Failed to add wide path to linked list");
                return FALSE;
            }

            FPFreeW(pwszReturnPath, pwszOriginalPath);

            uSize = lstrlenW(pwszOriginalPath) + 1;
            pwszOriginalPath += uSize;

            if (*pwszOriginalPath == '\0') {
                break;
            }
        }
    }

    return TRUE;
}

BOOL
ConvertStringsToUnicode(
    LPWSTR*           pwszBuffer,
    LPSHFILEOPSTRUCTA lpFileOp,
    LPSHFILEOPSTRUCTW lpOutFileOp
    )
{
    UINT    uSize = 0;
    UINT    uWideSize = 0;
    UINT    uTotalSize = 0;
    UINT    uSizeTitle = 0;
    LPCSTR  pszAnsi = NULL;
    LPWSTR  pwszTemp = NULL;    
    
    //
    // Determine how large of a buffer we need to allocate.
    //
    if (lpFileOp->pFrom) {
        pszAnsi = lpFileOp->pFrom;
        
        do {
            uSize = lstrlenA(pszAnsi) + 1;
            uTotalSize += uSize;
            pszAnsi += uSize;
        } while (uSize != 1);
    }
    
    if (lpFileOp->pTo) {
        pszAnsi = lpFileOp->pTo;
        
        do {
            uSize = lstrlenA(pszAnsi) + 1;
            uTotalSize += uSize;
            pszAnsi += uSize;
        } while (uSize != 1);
    }
    
    if (lpFileOp->lpszProgressTitle) {
        uSizeTitle = lstrlenA(lpFileOp->lpszProgressTitle) + 1;
        uTotalSize += uSizeTitle;
    }
    
    if (uTotalSize != 0) {
        pwszTemp = *pwszBuffer = (LPWSTR)malloc(uTotalSize * sizeof(WCHAR));
        
        if (!*pwszBuffer) {
            DPFN(eDbgLevelError,
                 "[ConvertStringsToUnicode] No memory for buffer");
            return FALSE;
        }
    }

    //
    // Perform the ANSI to Unicode conversion.
    //
    if (lpFileOp->pFrom) {
        lpOutFileOp->pFrom = pwszTemp;
        pszAnsi = lpFileOp->pFrom;
        
        do {
            uSize = lstrlenA(pszAnsi) + 1;
            
            uWideSize = MultiByteToWideChar(
                CP_ACP,
                0,
                pszAnsi,
                uSize,
                pwszTemp,
                uSize);
            
            pszAnsi  += uSize;
            pwszTemp += uWideSize;
        } while (uSize != 1);
    } else {
        lpOutFileOp->pFrom = NULL;
    }
    
    if (lpFileOp->pTo) {
        lpOutFileOp->pTo = pwszTemp;
        pszAnsi  = lpFileOp->pTo;
        do {
            uSize = lstrlenA(pszAnsi) + 1;
            
            uWideSize = MultiByteToWideChar(
                CP_ACP,
                0,
                pszAnsi,
                uSize,
                pwszTemp,
                uSize);

            pszAnsi  += uSize;
            pwszTemp += uWideSize;
        } while (uSize != 1);
    } else {
        lpOutFileOp->pTo = NULL;
    }
    
    if (lpFileOp->lpszProgressTitle) {
        lpOutFileOp->lpszProgressTitle = pwszTemp;
        
        MultiByteToWideChar(
            CP_ACP,
            0,
            lpFileOp->lpszProgressTitle,
            uSizeTitle,
            pwszTemp,
            uSizeTitle);
    } else {
        lpOutFileOp->lpszProgressTitle = NULL;
    }

    return TRUE;
}

int
APIHOOK(SHFileOperationW)(
    LPSHFILEOPSTRUCTW lpFileOp
    )
{
    int     nReturn = 0;
    LPCWSTR pwszOriginalFrom = NULL;
    LPCWSTR pwszOriginalTo = NULL;
    LPWSTR  pwszFinalFrom = NULL;
    LPWSTR  pwszFinalTo = NULL;
    
    pwszOriginalFrom = lpFileOp->pFrom;
    pwszOriginalTo   = lpFileOp->pTo;

    RtlEnterCriticalSection(&g_csLinkedList);
    
    //
    // Build a linked list of the 'from' paths first,
    // and then process to 'to' paths.
    //
    if (!BuildLinkedList(pwszOriginalFrom, eFrom)) {
        DPFN(eDbgLevelError,
             "[SHFileOperationW] Failed to add 'from' path to linked list");
        goto exit;
    }

    if (!BuildLinkedList(pwszOriginalTo, eTo)) {
        DPFN(eDbgLevelError,
             "[SHFileOperationW] Failed to add 'to' path to linked list");
        goto exit;
    }

    //
    // All paths have been massaged - build a list of NULL
    // separated strings with a double NULL at the end.
    //
    pwszFinalFrom = BuildStringList(eFrom);

    if (!pwszFinalFrom) {
        DPFN(eDbgLevelError, "[SHFileOperationW] Failed to build 'from' list");
        goto exit;
    }

    pwszFinalTo = BuildStringList(eTo);

    if (!pwszFinalTo) {
        DPFN(eDbgLevelError, "[SHFileOperationW] Failed to build 'to' list");
        goto exit;
    }

    //
    // Package the strings back into the struct, call the original API
    // to get the results, and then free any memory we've allocated.
    //
    lpFileOp->pFrom = pwszFinalFrom;
    lpFileOp->pTo   = pwszFinalTo;

exit:

    RtlLeaveCriticalSection(&g_csLinkedList);

    nReturn = ORIGINAL_API(SHFileOperationW)(lpFileOp);

    ReleaseMemAllocations(pwszFinalFrom, eFrom);
    ReleaseMemAllocations(pwszFinalTo, eTo);

    g_pFileListFromHead = NULL;
    g_pFileListToHead = NULL;

    return nReturn;
}
    
int
APIHOOK(SHFileOperationA)(
    LPSHFILEOPSTRUCTA lpFileOp
    )
{
    int             nReturn = 0;
    LPWSTR          pwszBuffer = NULL;
    SHFILEOPSTRUCTW shfileop;

    memcpy(&shfileop, lpFileOp, sizeof(SHFILEOPSTRUCTW));

    if (!ConvertStringsToUnicode(&pwszBuffer, lpFileOp, &shfileop)) {
        DPFN(eDbgLevelError,
             "[SHFileOperationA] Failed to convert strings");
        goto exit;
    }

    nReturn = APIHOOK(SHFileOperationW)(&shfileop);

    //
    // Link up the two members that could have changed.
    //
    lpFileOp->fAnyOperationsAborted = shfileop.fAnyOperationsAborted;
    lpFileOp->hNameMappings         = shfileop.hNameMappings;

    if (pwszBuffer) {
        free(pwszBuffer);
    }
    
    return nReturn;

exit:

    return ORIGINAL_API(SHFileOperationA)(lpFileOp);
}

NTSTATUS
APIHOOK(NtCreateFile)(
    PHANDLE            FileHandle,
    ACCESS_MASK        DesiredAccess,
    POBJECT_ATTRIBUTES ObjectAttributes,
    PIO_STATUS_BLOCK   IoStatusBlock,
    PLARGE_INTEGER     AllocationSize,
    ULONG              FileAttributes,
    ULONG              ShareAccess,
    ULONG              CreateDisposition,
    ULONG              CreateOptions,
    PVOID              EaBuffer,
    ULONG              EaLength
    )
{
    OBJECT_ATTRIBUTES NewObjectAttributes;

    MassageNtPath(ObjectAttributes, &NewObjectAttributes);

    NTSTATUS status = ORIGINAL_API(NtCreateFile)(FileHandle,
                                                 DesiredAccess,
                                                 &NewObjectAttributes,
                                                 IoStatusBlock,
                                                 AllocationSize,
                                                 FileAttributes,
                                                 ShareAccess,
                                                 CreateDisposition,
                                                 CreateOptions,
                                                 EaBuffer,
                                                 EaLength);

    FPNtFree(ObjectAttributes, &NewObjectAttributes);
    
    return status;
}

NTSTATUS
APIHOOK(NtOpenFile)(
    PHANDLE            FileHandle,
    ACCESS_MASK        DesiredAccess,
    POBJECT_ATTRIBUTES ObjectAttributes,
    PIO_STATUS_BLOCK   IoStatusBlock,
    ULONG              ShareAccess,
    ULONG              OpenOptions
    )
{
    OBJECT_ATTRIBUTES NewObjectAttributes;
                                     
    MassageNtPath(ObjectAttributes, &NewObjectAttributes);

    NTSTATUS status = ORIGINAL_API(NtOpenFile)(FileHandle,
                                               DesiredAccess,
                                               &NewObjectAttributes,
                                               IoStatusBlock,
                                               ShareAccess,
                                               OpenOptions);

    FPNtFree(ObjectAttributes, &NewObjectAttributes);
    
    return status;
}

NTSTATUS
APIHOOK(NtQueryAttributesFile)(
    POBJECT_ATTRIBUTES      ObjectAttributes,
    PFILE_BASIC_INFORMATION FileInformation
    )
{
    OBJECT_ATTRIBUTES NewObjectAttributes;

    MassageNtPath(ObjectAttributes, &NewObjectAttributes);

    NTSTATUS status = ORIGINAL_API(NtQueryAttributesFile)(&NewObjectAttributes,
                                                          FileInformation);
    
    FPNtFree(ObjectAttributes, &NewObjectAttributes);

    return status;
}

NTSTATUS
APIHOOK(NtQueryFullAttributesFile)(
    POBJECT_ATTRIBUTES             ObjectAttributes,
    PFILE_NETWORK_OPEN_INFORMATION FileInformation
    )
{
    OBJECT_ATTRIBUTES NewObjectAttributes;

    MassageNtPath(ObjectAttributes, &NewObjectAttributes);

    NTSTATUS status = ORIGINAL_API(NtQueryFullAttributesFile)(&NewObjectAttributes,
                                                              FileInformation);
    
    FPNtFree(ObjectAttributes, &NewObjectAttributes);

    return status;
}

NTSTATUS
APIHOOK(NtCreateProcessEx)(
    PHANDLE            ProcessHandle,
    ACCESS_MASK        DesiredAccess,
    POBJECT_ATTRIBUTES ObjectAttributes,
    HANDLE             ParentProcess,
    ULONG              Flags,
    HANDLE             SectionHandle,
    HANDLE             DebugPort,
    HANDLE             ExceptionPort,
    ULONG              JobMemberLevel
    )
{
    OBJECT_ATTRIBUTES NewObjectAttributes;

    MassageNtPath(ObjectAttributes, &NewObjectAttributes);

    NTSTATUS status = ORIGINAL_API(NtCreateProcessEx)(ProcessHandle,
                                                      DesiredAccess,
                                                      &NewObjectAttributes,
                                                      ParentProcess,
                                                      Flags,
                                                      SectionHandle,
                                                      DebugPort,
                                                      ExceptionPort,
                                                      JobMemberLevel);
    
    FPNtFree(ObjectAttributes, &NewObjectAttributes);
    
    return status;
}

UINT
GetSimulatedPathA(
    LPSTR lpBuffer,
    UINT  unSize,
    int   nWhich
    )
{
    if (!g_bPathsInited) {
        InitPaths();
    }
    
    if (unSize > (DWORD)g_Paths[nWhich].nSimulatedPathLen) {
        strcpy(lpBuffer, g_Paths[nWhich].szSimulatedPathA);
        return g_Paths[nWhich].nSimulatedPathLen;
    } else {
        return g_Paths[nWhich].nSimulatedPathLen + 1;
    }
}

UINT
GetSimulatedPathW(
    LPWSTR lpBuffer,
    UINT   unSize,
    int    nWhich
    )
{
    if (!g_bPathsInited) {
        InitPaths();
    }
    
    if (unSize > (DWORD)g_Paths[nWhich].nSimulatedPathLen) {
        wcscpy(lpBuffer, g_Paths[nWhich].szSimulatedPathW);
        return g_Paths[nWhich].nSimulatedPathLen;
    } else {
        return g_Paths[nWhich].nSimulatedPathLen + 1;
    }
}

DWORD
APIHOOK(GetTempPathA)(
    DWORD nBufferLength,
    LPSTR lpBuffer
    )
{
    return GetSimulatedPathA(lpBuffer, nBufferLength, PATH_TEMP);
}

DWORD
APIHOOK(GetTempPathW)(
    DWORD  nBufferLength,
    LPWSTR lpBuffer
    )
{
    return GetSimulatedPathW(lpBuffer, nBufferLength, PATH_TEMP);
}

UINT
APIHOOK(GetWindowsDirectoryA)(
    LPSTR lpBuffer,
    UINT  unSize
    )
{
    return GetSimulatedPathA(lpBuffer, unSize, PATH_WINDOWS);
}

UINT
APIHOOK(GetWindowsDirectoryW)(
    LPWSTR lpBuffer,
    UINT   unSize
    )
{
    return GetSimulatedPathW(lpBuffer, unSize, PATH_WINDOWS);
}

UINT
APIHOOK(GetSystemWindowsDirectoryA)(
    LPSTR lpBuffer,
    UINT  unSize
    )
{
    return GetSimulatedPathA(lpBuffer, unSize, PATH_SYSTEM_WINDOWS);
}

UINT
APIHOOK(GetSystemWindowsDirectoryW)(
    LPWSTR lpBuffer,
    UINT   unSize
    )
{
    return GetSimulatedPathW(lpBuffer, unSize, PATH_SYSTEM_WINDOWS);
}

UINT
APIHOOK(GetSystemDirectoryA)(
    LPSTR lpBuffer,
    UINT  unSize
    )
{
    return GetSimulatedPathA(lpBuffer, unSize, PATH_SYSTEM);
}

UINT
APIHOOK(GetSystemDirectoryW)(
    LPWSTR lpBuffer,
    UINT   unSize
    )
{
    return GetSimulatedPathW(lpBuffer, unSize, PATH_SYSTEM);
}

BOOL
APIHOOK(SHGetSpecialFolderPathA)(
    HWND  hwndOwner,
    LPSTR lpszPath,
    int   nFolder,
    BOOL  fCreate
    )
{
    if (!g_bPathsInited) {
        InitPaths();
    }

    switch (nFolder) {
    case CSIDL_PERSONAL:
        strcpy(lpszPath, g_Paths[PATH_PERSONAL].szSimulatedPathA);
        return TRUE;
        break;

    case CSIDL_SYSTEM:
        strcpy(lpszPath, g_Paths[PATH_SYSTEM].szSimulatedPathA);
        return TRUE;
        break;

    case CSIDL_WINDOWS:
        strcpy(lpszPath, g_Paths[PATH_WINDOWS].szSimulatedPathA);
        return TRUE;
        break;

    case CSIDL_PROGRAMS:
        strcpy(lpszPath, g_Paths[PATH_PROGRAMS].szSimulatedPathA);
        return TRUE;
        break;

    case CSIDL_STARTMENU:
        strcpy(lpszPath, g_Paths[PATH_PROGRAMS].szSimulatedPathA);
        return TRUE;
        break;

    case CSIDL_COMMON_PROGRAMS:
        strcpy(lpszPath, g_Paths[PATH_COMMON_PROGRAMS].szSimulatedPathA);
        return TRUE;
        break;

    case CSIDL_COMMON_STARTMENU:
        strcpy(lpszPath, g_Paths[PATH_COMMON_STARTMENU].szSimulatedPathA);
        return TRUE;
        break;

    }

    //
    // the others we aren't nabbing
    //
    return ORIGINAL_API(SHGetSpecialFolderPathA)(hwndOwner, lpszPath, nFolder, fCreate);
}

BOOL
APIHOOK(SHGetSpecialFolderPathW)(
    HWND   hwndOwner,
    LPWSTR lpszPath,
    int    nFolder,
    BOOL   fCreate
    )
{
    if (!g_bPathsInited) {
        InitPaths();
    }

    switch (nFolder) {
    case CSIDL_PERSONAL:
        wcscpy(lpszPath, g_Paths[PATH_PERSONAL].szSimulatedPathW);
        return TRUE;
        break;

    case CSIDL_SYSTEM:
        wcscpy(lpszPath, g_Paths[PATH_SYSTEM].szSimulatedPathW);
        return TRUE;
        break;

    case CSIDL_WINDOWS:
        wcscpy(lpszPath, g_Paths[PATH_WINDOWS].szSimulatedPathW);
        return TRUE;
        break;

    case CSIDL_PROGRAMS:
        wcscpy(lpszPath, g_Paths[PATH_PROGRAMS].szSimulatedPathW);
        return TRUE;
        break;

    case CSIDL_STARTMENU:
        wcscpy(lpszPath, g_Paths[PATH_PROGRAMS].szSimulatedPathW);
        return TRUE;
        break;

    case CSIDL_COMMON_PROGRAMS:
        wcscpy(lpszPath, g_Paths[PATH_COMMON_PROGRAMS].szSimulatedPathW);
        return TRUE;
        break;

    case CSIDL_COMMON_STARTMENU:
        wcscpy(lpszPath, g_Paths[PATH_COMMON_STARTMENU].szSimulatedPathW);
        return TRUE;
        break;

    }

    //
    // the others we aren't nabbing
    //
    return ORIGINAL_API(SHGetSpecialFolderPathW)(hwndOwner, lpszPath, nFolder, fCreate);
}

HRESULT 
APIHOOK(SHGetFolderPathA)(
    HWND   hwndOwner,
    int    nFolder,
    HANDLE hToken,
    DWORD  dwFlags,
    LPSTR  pszPath
    )
{
    if (!g_bPathsInited) {
        InitPaths();
    }
    
    switch (nFolder) {
    case CSIDL_PERSONAL:
        strcpy(pszPath, g_Paths[PATH_PERSONAL].szSimulatedPathA);
        return S_OK;
        break;

    case CSIDL_SYSTEM:
        strcpy(pszPath, g_Paths[PATH_SYSTEM].szSimulatedPathA);
        return S_OK;
        break;

    case CSIDL_WINDOWS:
        strcpy(pszPath, g_Paths[PATH_WINDOWS].szSimulatedPathA);
        return S_OK;
        break;

    case CSIDL_PROGRAMS:
        strcpy(pszPath, g_Paths[PATH_PROGRAMS].szSimulatedPathA);
        return S_OK;
        break;

    case CSIDL_STARTMENU:
        strcpy(pszPath, g_Paths[PATH_PROGRAMS].szSimulatedPathA);
        return S_OK;
        break;

    case CSIDL_COMMON_PROGRAMS:
        strcpy(pszPath, g_Paths[PATH_COMMON_PROGRAMS].szSimulatedPathA);
        return S_OK;
        break;

    case CSIDL_COMMON_STARTMENU:
        strcpy(pszPath, g_Paths[PATH_COMMON_STARTMENU].szSimulatedPathA);
        return S_OK;
        break;

    }

    //
    // the others we aren't nabbing
    //
    return ORIGINAL_API(SHGetFolderPathA)(hwndOwner, nFolder, hToken, dwFlags, pszPath);
}

HRESULT 
APIHOOK(SHGetFolderPathW)(
    HWND   hwndOwner,
    int    nFolder,
    HANDLE hToken,
    DWORD  dwFlags,
    LPWSTR pszPath
    )
{
    if (!g_bPathsInited) {
        InitPaths();
    }
    
    switch (nFolder) {
    case CSIDL_PERSONAL:
        wcscpy(pszPath, g_Paths[PATH_PERSONAL].szSimulatedPathW);
        return S_OK;
        break;

    case CSIDL_SYSTEM:
        wcscpy(pszPath, g_Paths[PATH_SYSTEM].szSimulatedPathW);
        return S_OK;
        break;

    case CSIDL_WINDOWS:
        wcscpy(pszPath, g_Paths[PATH_WINDOWS].szSimulatedPathW);
        return S_OK;
        break;

    case CSIDL_PROGRAMS:
        wcscpy(pszPath, g_Paths[PATH_PROGRAMS].szSimulatedPathW);
        return S_OK;
        break;

    case CSIDL_STARTMENU:
        wcscpy(pszPath, g_Paths[PATH_PROGRAMS].szSimulatedPathW);
        return S_OK;
        break;

    case CSIDL_COMMON_PROGRAMS:
        wcscpy(pszPath, g_Paths[PATH_COMMON_PROGRAMS].szSimulatedPathW);
        return S_OK;
        break;

    case CSIDL_COMMON_STARTMENU:
        wcscpy(pszPath, g_Paths[PATH_COMMON_STARTMENU].szSimulatedPathW);
        return S_OK;
        break;

    }

    //
    // the others we aren't nabbing
    //
    return ORIGINAL_API(SHGetFolderPathW)(hwndOwner, nFolder, hToken, dwFlags, pszPath);
}

BOOL
APIHOOK(SHGetPathFromIDListA)(
    LPCITEMIDLIST pidl,
    LPSTR         pszPath
    )
{
    if (!g_bPathsInited) {
        InitPaths();
    }

    BOOL fReturn = ORIGINAL_API(SHGetPathFromIDListA)(pidl, pszPath);

    if (fReturn) {
        MassageRealPathToFakePathA(pszPath, MAX_PATH);
    }

    return fReturn;
}

BOOL
APIHOOK(SHGetPathFromIDListW)(
    LPCITEMIDLIST pidl,
    LPWSTR        pszPath
    )
{
    if (!g_bPathsInited) {
        InitPaths();
    }

    BOOL fReturn = ORIGINAL_API(SHGetPathFromIDListW)(pidl, pszPath);

    if (fReturn) {
        MassageRealPathToFakePathW(pszPath, MAX_PATH);
    }

    return fReturn;
}

SHIM_INFO_BEGIN()

    SHIM_INFO_DESCRIPTION(AVS_FILEPATHS_DESC)
    SHIM_INFO_FRIENDLY_NAME(AVS_FILEPATHS_FRIENDLY)
    SHIM_INFO_FLAGS(AVRF_FLAG_RUN_ALONE)
    SHIM_INFO_GROUPS(0)
    SHIM_INFO_VERSION(1, 5)
    SHIM_INFO_INCLUDE_EXCLUDE("E:ole32.dll oleaut32.dll")

SHIM_INFO_END()

BOOL
NOTIFY_FUNCTION(
    DWORD fdwReason
    )
{
    if (fdwReason == DLL_PROCESS_ATTACH) {
        //
        // Initialize a critical section to keep our linked list safe.
        //
        RtlInitializeCriticalSection(&g_csLinkedList);

        GetTempPathA(MAX_PATH, g_Paths[PATH_TEMP].szCorrectPathA);
        GetTempPathW(MAX_PATH, g_Paths[PATH_TEMP].szCorrectPathW);
        g_Paths[PATH_TEMP].nCorrectPathLen = strlen(g_Paths[PATH_TEMP].szCorrectPathA);
        g_Paths[PATH_TEMP].nSimulatedPathLen = strlen(g_Paths[PATH_TEMP].szSimulatedPathA);

        if (!GetWindowsDirectoryA(g_Paths[PATH_WINDOWS].szCorrectPathA, MAX_PATH)) {
            goto exit;
        }
        
        if (!GetWindowsDirectoryW(g_Paths[PATH_WINDOWS].szCorrectPathW, MAX_PATH)) {
            goto exit;
        }
        
        g_Paths[PATH_WINDOWS].nCorrectPathLen = strlen(g_Paths[PATH_WINDOWS].szCorrectPathA);
        g_Paths[PATH_WINDOWS].nSimulatedPathLen = strlen(g_Paths[PATH_WINDOWS].szSimulatedPathA);

        if (!GetSystemWindowsDirectoryA(g_Paths[PATH_SYSTEM_WINDOWS].szCorrectPathA, MAX_PATH)) {
            goto exit;
        }
        
        if (!GetSystemWindowsDirectoryW(g_Paths[PATH_SYSTEM_WINDOWS].szCorrectPathW, MAX_PATH)) {
            goto exit;
        }

        g_Paths[PATH_SYSTEM_WINDOWS].nCorrectPathLen = strlen(g_Paths[PATH_SYSTEM_WINDOWS].szCorrectPathA);
        g_Paths[PATH_SYSTEM_WINDOWS].nSimulatedPathLen = strlen(g_Paths[PATH_SYSTEM_WINDOWS].szSimulatedPathA);

        if (!GetSystemDirectoryA(g_Paths[PATH_SYSTEM].szCorrectPathA, MAX_PATH)) {
            goto exit;
        }

        if (!GetSystemDirectoryW(g_Paths[PATH_SYSTEM].szCorrectPathW, MAX_PATH)) {
            goto exit;
        }

        g_Paths[PATH_SYSTEM].nCorrectPathLen = strlen(g_Paths[PATH_SYSTEM].szCorrectPathA);
        g_Paths[PATH_SYSTEM].nSimulatedPathLen = strlen(g_Paths[PATH_SYSTEM].szSimulatedPathA);

        //
        // Catch apps that use ExpandEnvironmentStrings.
        //
        SetEnvironmentVariableW(L"TEMP", g_Paths[PATH_TEMP].szSimulatedPathW);
        SetEnvironmentVariableW(L"TMP", g_Paths[PATH_TEMP].szSimulatedPathW);
        SetEnvironmentVariableW(L"windir", g_Paths[PATH_WINDOWS].szSimulatedPathW);

    } 
    
    return TRUE;

exit:
    DPFN(eDbgLevelError,
         "[NOTIFY_FUNCTION] %lu Failed to initialize",
         GetLastError());

    return FALSE;
}

/*++

  Register hooked functions

--*/

HOOK_BEGIN

    CALL_NOTIFY_FUNCTION

    DUMP_VERIFIER_LOG_ENTRY(VLOG_HARDCODED_GETTEMPPATH, 
                            AVS_HARDCODED_GETTEMPPATH,
                            AVS_HARDCODED_GETTEMPPATH_R,
                            AVS_HARDCODED_GETTEMPPATH_URL)

    DUMP_VERIFIER_LOG_ENTRY(VLOG_HARDCODED_WINDOWSPATH, 
                            AVS_HARDCODED_WINDOWSPATH,
                            AVS_HARDCODED_WINDOWSPATH_R,
                            AVS_HARDCODED_WINDOWSPATH_URL)

    DUMP_VERIFIER_LOG_ENTRY(VLOG_HARDCODED_SYSWINDOWSPATH, 
                            AVS_HARDCODED_SYSWINDOWSPATH,
                            AVS_HARDCODED_SYSWINDOWSPATH_R,
                            AVS_HARDCODED_SYSWINDOWSPATH_URL)

    DUMP_VERIFIER_LOG_ENTRY(VLOG_HARDCODED_SYSTEMPATH, 
                            AVS_HARDCODED_SYSTEMPATH,
                            AVS_HARDCODED_SYSTEMPATH_R,
                            AVS_HARDCODED_SYSTEMPATH_URL)

    DUMP_VERIFIER_LOG_ENTRY(VLOG_HARDCODED_PERSONALPATH, 
                            AVS_HARDCODED_PERSONALPATH,
                            AVS_HARDCODED_PERSONALPATH_R,
                            AVS_HARDCODED_PERSONALPATH_URL)

    DUMP_VERIFIER_LOG_ENTRY(VLOG_HARDCODED_COMMONPROGRAMS, 
                            AVS_HARDCODED_COMMONPROGRAMS,
                            AVS_HARDCODED_COMMONPROGRAMS_R,
                            AVS_HARDCODED_COMMONPROGRAMS_URL)

    DUMP_VERIFIER_LOG_ENTRY(VLOG_HARDCODED_COMMONSTARTMENU, 
                            AVS_HARDCODED_COMMONSTARTMENU,
                            AVS_HARDCODED_COMMONSTARTMENU_R,
                            AVS_HARDCODED_COMMONSTARTMENU_URL)

    DUMP_VERIFIER_LOG_ENTRY(VLOG_HARDCODED_PROGRAMS, 
                            AVS_HARDCODED_PROGRAMS,
                            AVS_HARDCODED_PROGRAMS_R,
                            AVS_HARDCODED_PROGRAMS_URL)

    DUMP_VERIFIER_LOG_ENTRY(VLOG_HARDCODED_STARTMENU, 
                            AVS_HARDCODED_STARTMENU,
                            AVS_HARDCODED_STARTMENU_R,
                            AVS_HARDCODED_STARTMENU_URL)

    APIHOOK_ENTRY(KERNEL32.DLL,                  GetCommandLineA)
    APIHOOK_ENTRY(KERNEL32.DLL,                  GetCommandLineW)
    
    APIHOOK_ENTRY(KERNEL32.DLL,                     GetTempPathA)
    APIHOOK_ENTRY(KERNEL32.DLL,                     GetTempPathW)
    
    APIHOOK_ENTRY(KERNEL32.DLL,              GetSystemDirectoryA)
    APIHOOK_ENTRY(KERNEL32.DLL,              GetSystemDirectoryW)
    APIHOOK_ENTRY(KERNEL32.DLL,       GetSystemWindowsDirectoryA)
    APIHOOK_ENTRY(KERNEL32.DLL,       GetSystemWindowsDirectoryW)
    APIHOOK_ENTRY(KERNEL32.DLL,             GetWindowsDirectoryA)
    APIHOOK_ENTRY(KERNEL32.DLL,             GetWindowsDirectoryW)

    APIHOOK_ENTRY(SHELL32.DLL,                  SHGetFolderPathA)
    APIHOOK_ENTRY(SHELL32.DLL,                  SHGetFolderPathW)
    
    APIHOOK_ENTRY(SHELL32.DLL,           SHGetSpecialFolderPathA)
    APIHOOK_ENTRY(SHELL32.DLL,           SHGetSpecialFolderPathW)

    APIHOOK_ENTRY(SHELL32.DLL,              SHGetPathFromIDListA)
    APIHOOK_ENTRY(SHELL32.DLL,              SHGetPathFromIDListW)

    APIHOOK_ENTRY(COMDLG32.DLL,                 GetOpenFileNameA)
    APIHOOK_ENTRY(COMDLG32.DLL,                 GetOpenFileNameW)

    APIHOOK_ENTRY(COMDLG32.DLL,                 GetSaveFileNameA)
    APIHOOK_ENTRY(COMDLG32.DLL,                 GetSaveFileNameW)

    APIHOOK_ENTRY(KERNEL32.DLL,               GetModuleFileNameA)
    APIHOOK_ENTRY(KERNEL32.DLL,               GetModuleFileNameW)
    
    APIHOOK_ENTRY(PSAPI.DLL,                GetModuleFileNameExA)
    APIHOOK_ENTRY(PSAPI.DLL,                GetModuleFileNameExW)

    APIHOOK_ENTRY(KERNEL32.DLL,             GetCurrentDirectoryA)
    APIHOOK_ENTRY(KERNEL32.DLL,             GetCurrentDirectoryW)

    APIHOOK_ENTRY(KERNEL32.DLL,                   CreateProcessA)
    APIHOOK_ENTRY(KERNEL32.DLL,                   CreateProcessW)
    APIHOOK_ENTRY(KERNEL32.DLL,                          WinExec)

    APIHOOK_ENTRY(SHELL32.DLL,                     ShellExecuteA)
    APIHOOK_ENTRY(SHELL32.DLL,                     ShellExecuteW)
    APIHOOK_ENTRY(SHELL32.DLL,                   ShellExecuteExA)
    APIHOOK_ENTRY(SHELL32.DLL,                   ShellExecuteExW)

    APIHOOK_ENTRY(KERNEL32.DLL,            GetPrivateProfileIntA)
    APIHOOK_ENTRY(KERNEL32.DLL,            GetPrivateProfileIntW)
    APIHOOK_ENTRY(KERNEL32.DLL,        GetPrivateProfileSectionA)
    APIHOOK_ENTRY(KERNEL32.DLL,        GetPrivateProfileSectionW)
    APIHOOK_ENTRY(KERNEL32.DLL,   GetPrivateProfileSectionNamesA)
    APIHOOK_ENTRY(KERNEL32.DLL,   GetPrivateProfileSectionNamesW)
    APIHOOK_ENTRY(KERNEL32.DLL,         GetPrivateProfileStringA)
    APIHOOK_ENTRY(KERNEL32.DLL,         GetPrivateProfileStringW)
    APIHOOK_ENTRY(KERNEL32.DLL,         GetPrivateProfileStructA)
    APIHOOK_ENTRY(KERNEL32.DLL,         GetPrivateProfileStructW)

    APIHOOK_ENTRY(KERNEL32.DLL,      WritePrivateProfileSectionA)
    APIHOOK_ENTRY(KERNEL32.DLL,      WritePrivateProfileSectionW)
    APIHOOK_ENTRY(KERNEL32.DLL,       WritePrivateProfileStringA)
    APIHOOK_ENTRY(KERNEL32.DLL,       WritePrivateProfileStringW)
    APIHOOK_ENTRY(KERNEL32.DLL,       WritePrivateProfileStructA)
    APIHOOK_ENTRY(KERNEL32.DLL,       WritePrivateProfileStructW)

    // g_bFileRoutines)
    APIHOOK_ENTRY(KERNEL32.DLL,                        CopyFileA)
    APIHOOK_ENTRY(KERNEL32.DLL,                        CopyFileW)
    APIHOOK_ENTRY(KERNEL32.DLL,                      CopyFileExA)
    APIHOOK_ENTRY(KERNEL32.DLL,                      CopyFileExW)
    APIHOOK_ENTRY(KERNEL32.DLL,                 CreateDirectoryA)
    APIHOOK_ENTRY(KERNEL32.DLL,                 CreateDirectoryW)
    APIHOOK_ENTRY(KERNEL32.DLL,               CreateDirectoryExA)
    APIHOOK_ENTRY(KERNEL32.DLL,               CreateDirectoryExW)

    APIHOOK_ENTRY(KERNEL32.DLL,                      CreateFileA)
    APIHOOK_ENTRY(KERNEL32.DLL,                      CreateFileW)
    APIHOOK_ENTRY(KERNEL32.DLL,                      DeleteFileA)
    APIHOOK_ENTRY(KERNEL32.DLL,                      DeleteFileW)

    APIHOOK_ENTRY(KERNEL32.DLL,                   FindFirstFileA)
    APIHOOK_ENTRY(KERNEL32.DLL,                   FindFirstFileW)
    APIHOOK_ENTRY(KERNEL32.DLL,                 FindFirstFileExA)
    APIHOOK_ENTRY(KERNEL32.DLL,                 FindFirstFileExW)

    APIHOOK_ENTRY(KERNEL32.DLL,                   GetBinaryTypeA)
    APIHOOK_ENTRY(KERNEL32.DLL,                   GetBinaryTypeW)
    APIHOOK_ENTRY(KERNEL32.DLL,               GetFileAttributesA)
    APIHOOK_ENTRY(KERNEL32.DLL,               GetFileAttributesW)
    APIHOOK_ENTRY(KERNEL32.DLL,             GetFileAttributesExA)
    APIHOOK_ENTRY(KERNEL32.DLL,             GetFileAttributesExW)
    APIHOOK_ENTRY(KERNEL32.DLL,               SetFileAttributesA)
    APIHOOK_ENTRY(KERNEL32.DLL,               SetFileAttributesW)

    APIHOOK_ENTRY(KERNEL32.DLL,                        MoveFileA)
    APIHOOK_ENTRY(KERNEL32.DLL,                        MoveFileW)
    APIHOOK_ENTRY(KERNEL32.DLL,                      MoveFileExA)
    APIHOOK_ENTRY(KERNEL32.DLL,                      MoveFileExW)
    APIHOOK_ENTRY(KERNEL32.DLL,            MoveFileWithProgressA)
    APIHOOK_ENTRY(KERNEL32.DLL,            MoveFileWithProgressW)

    APIHOOK_ENTRY(KERNEL32.DLL,                 RemoveDirectoryA)
    APIHOOK_ENTRY(KERNEL32.DLL,                 RemoveDirectoryW)
    APIHOOK_ENTRY(KERNEL32.DLL,             SetCurrentDirectoryA)
    APIHOOK_ENTRY(KERNEL32.DLL,             SetCurrentDirectoryW)
    APIHOOK_ENTRY(KERNEL32.DLL,                     LoadLibraryA)
    APIHOOK_ENTRY(KERNEL32.DLL,                     LoadLibraryW)
    APIHOOK_ENTRY(KERNEL32.DLL,                   LoadLibraryExA)
    APIHOOK_ENTRY(KERNEL32.DLL,                   LoadLibraryExW)

    APIHOOK_ENTRY(KERNEL32.DLL,                      SearchPathA)
    APIHOOK_ENTRY(KERNEL32.DLL,                      SearchPathW)

    APIHOOK_ENTRY(KERNEL32.DLL,        ExpandEnvironmentStringsA)
    APIHOOK_ENTRY(KERNEL32.DLL,        ExpandEnvironmentStringsW)

    APIHOOK_ENTRY(VERSION.DLL,           GetFileVersionInfoSizeA)
    APIHOOK_ENTRY(VERSION.DLL,           GetFileVersionInfoSizeW)
    APIHOOK_ENTRY(VERSION.DLL,               GetFileVersionInfoA)
    APIHOOK_ENTRY(VERSION.DLL,               GetFileVersionInfoW)

    APIHOOK_ENTRY(SHELL32.DLL,                  SHFileOperationA)
    APIHOOK_ENTRY(SHELL32.DLL,                  SHFileOperationW)

    APIHOOK_ENTRY(KERNEL32.DLL,                         OpenFile)
    
    // 16 bit compatibility file routines
    APIHOOK_ENTRY(KERNEL32.DLL,                           _lopen)
    APIHOOK_ENTRY(KERNEL32.DLL,                          _lcreat)

    APIHOOK_ENTRY(ADVAPI32.DLL,                   RegQueryValueA)
    APIHOOK_ENTRY(ADVAPI32.DLL,                   RegQueryValueW)
    APIHOOK_ENTRY(ADVAPI32.DLL,                 RegQueryValueExA)
    APIHOOK_ENTRY(ADVAPI32.DLL,                 RegQueryValueExW)

    APIHOOK_ENTRY(ADVAPI32.DLL,                     RegSetValueA)
    APIHOOK_ENTRY(ADVAPI32.DLL,                     RegSetValueW)
    APIHOOK_ENTRY(ADVAPI32.DLL,                   RegSetValueExA)
    APIHOOK_ENTRY(ADVAPI32.DLL,                   RegSetValueExW)

    APIHOOK_ENTRY(NTDLL.DLL,                        NtCreateFile)
    APIHOOK_ENTRY(NTDLL.DLL,                          NtOpenFile)
    APIHOOK_ENTRY(NTDLL.DLL,               NtQueryAttributesFile)
    APIHOOK_ENTRY(NTDLL.DLL,           NtQueryFullAttributesFile)
    APIHOOK_ENTRY(NTDLL.DLL,                   NtCreateProcessEx)

HOOK_END

IMPLEMENT_SHIM_END
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\appcompat\shims\verifier\kernelmodedriverinstall.cpp ===
/*++

 Copyright (c) 2001 Microsoft Corporation

 Module Name:

   KernelModeDriverInstall.cpp

 Abstract:

   This AppVerifier shim detects if an application
   is attempting to install a kernel mode driver.
   It monitors calls to CreateService and monitors
   the registry where information about drivers is
   stored.

 Notes:

   This is a general purpose shim.

 History:

   09/30/2001   rparsons    Created
   10/03/2001   rparsons    Fixed Raid bug # 476193
   11/29/2001   rparsons    Fixed Raid bug # 499824

--*/

#include "precomp.h"

IMPLEMENT_SHIM_BEGIN(KernelModeDriverInstall)
#include "ShimHookMacro.h"

BEGIN_DEFINE_VERIFIER_LOG(KernelModeDriverInstall)
    VERIFIER_LOG_ENTRY(VLOG_KMODEDRIVER_INST)    
END_DEFINE_VERIFIER_LOG(KernelModeDriverInstall)

INIT_VERIFIER_LOG(KernelModeDriverInstall);

APIHOOK_ENUM_BEGIN

    APIHOOK_ENUM_ENTRY(CreateServiceA)
    APIHOOK_ENUM_ENTRY(CreateServiceW)
    APIHOOK_ENUM_ENTRY(NtSetValueKey)
    
APIHOOK_ENUM_END

//
// Initial size to use for a stack based buffer when
// performing a Nt registry API call.
//
#define MAX_INFO_LENGTH 512

//
// Constant for the 'ControlSet' & 'CurrentrControlSet' key path in the registry.
//
#define KMDI_CONTROLSET_KEY     L"REGISTRY\\MACHINE\\SYSTEM\\ControlSet"
#define KMDI_CURCONTROLSET_KEY  L"REGISTRY\\MACHINE\\SYSTEM\\CurrentControlSet"

//
// Constant for the 'Services' key path.
//
#define KMDI_SERVICES_KEY L"Services\\"

//
// Constant for the ValueName that we need to look for.
//
#define KMDI_VALUE_NAME L"Type"

//
// Constant for the Value that we need to look for.
//
#define KMDI_TYPE_VALUE 0x00000001L

//
// Macros for memory allocation/deallocation.
//
#define MemAlloc(s) RtlAllocateHeap(RtlProcessHeap(), HEAP_ZERO_MEMORY, (s));
#define MemFree(b)  RtlFreeHeap(RtlProcessHeap(), 0, (b));

SC_HANDLE
APIHOOK(CreateServiceA)(
    SC_HANDLE hSCManager,           // handle to SCM database 
    LPCSTR    lpServiceName,        // name of service to start
    LPCSTR    lpDisplayName,        // display name
    DWORD     dwDesiredAccess,      // type of access to service
    DWORD     dwServiceType,        // type of service
    DWORD     dwStartType,          // when to start service
    DWORD     dwErrorControl,       // severity of service failure
    LPCSTR    lpBinaryPathName,     // name of binary file
    LPCSTR    lpLoadOrderGroup,     // name of load ordering group
    LPDWORD   lpdwTagId,            // tag identifier
    LPCSTR    lpDependencies,       // array of dependency names
    LPCSTR    lpServiceStartName,   // account name 
    LPCSTR    lpPassword            // account password
    )
{
    SC_HANDLE scHandle;

    scHandle = ORIGINAL_API(CreateServiceA)(hSCManager,
                                            lpServiceName,
                                            lpDisplayName,
                                            dwDesiredAccess,
                                            dwServiceType,
                                            dwStartType,
                                            dwErrorControl,
                                            lpBinaryPathName,
                                            lpLoadOrderGroup,
                                            lpdwTagId,
                                            lpDependencies,
                                            lpServiceStartName,
                                            lpPassword);

    if (scHandle) {
        //
        // If the ServiceType flag specifies that this is a kernel
        // mode driver, raise a flag.
        //
        if (dwServiceType & SERVICE_KERNEL_DRIVER) {
            VLOG(VLOG_LEVEL_INFO,
                 VLOG_KMODEDRIVER_INST,
                 "CreateServiceA was called. The path to the driver is %hs",
                 lpBinaryPathName);
        }
    }

    return scHandle;
}

SC_HANDLE
APIHOOK(CreateServiceW)(
    SC_HANDLE hSCManager,           // handle to SCM database 
    LPCWSTR   lpServiceName,        // name of service to start
    LPCWSTR   lpDisplayName,        // display name
    DWORD     dwDesiredAccess,      // type of access to service
    DWORD     dwServiceType,        // type of service
    DWORD     dwStartType,          // when to start service
    DWORD     dwErrorControl,       // severity of service failure
    LPCWSTR   lpBinaryPathName,     // name of binary file
    LPCWSTR   lpLoadOrderGroup,     // name of load ordering group
    LPDWORD   lpdwTagId,            // tag identifier
    LPCWSTR   lpDependencies,       // array of dependency names
    LPCWSTR   lpServiceStartName,   // account name 
    LPCWSTR   lpPassword            // account password
    )
{
    SC_HANDLE scHandle;
    
    scHandle =  ORIGINAL_API(CreateServiceW)(hSCManager,
                                             lpServiceName,
                                             lpDisplayName,
                                             dwDesiredAccess,
                                             dwServiceType,
                                             dwStartType,
                                             dwErrorControl,
                                             lpBinaryPathName,
                                             lpLoadOrderGroup,
                                             lpdwTagId,
                                             lpDependencies,
                                             lpServiceStartName,
                                             lpPassword);

    if (scHandle) {
        //
        // If the ServiceType flag specifies that this is a kernel
        // mode driver, raise a flag.
        //
        if (dwServiceType & SERVICE_KERNEL_DRIVER) {
            VLOG(VLOG_LEVEL_INFO,
                 VLOG_KMODEDRIVER_INST,
                 "CreateServiceW was called. The path to the driver is %ls",
                 lpBinaryPathName);
        }
    }

    return scHandle;
}

/*++

 Validate the registry data we received and warn the user if a driver is being installed.

--*/
void
WarnUserIfKernelModeDriver(
    IN HANDLE          hKey,
    IN PUNICODE_STRING pstrValueName,
    IN ULONG           ulType,
    IN PVOID           pData
    )
{
    NTSTATUS                status;
    ULONG                   ulSize;
    BYTE                    KeyNameInfo[MAX_INFO_LENGTH];
    PKEY_NAME_INFORMATION   pKeyNameInfo;

    pKeyNameInfo = (PKEY_NAME_INFORMATION)KeyNameInfo;
    
    //
    // RegSetValue allows for NULL value names.
    // Ensure that we don't have one before going any further.
    //
    if (!pstrValueName->Buffer) {
        return;
    }

    //
    // Determine if the ValueName is 'Type'.
    // If not, we don't need to go any further.
    //
    if (_wcsicmp(pstrValueName->Buffer, KMDI_VALUE_NAME)) {
        DPFN(eDbgLevelInfo,
             "[WarnUserIfKernelModeDriver] ValueName is not '%ls'",
             KMDI_VALUE_NAME);
        return;
    }

    //
    // Determine if the type of the value is DWORD.
    // If not, we need don't need to go any further.
    //
    if (REG_DWORD != ulType) {
        DPFN(eDbgLevelInfo,
             "[WarnUserIfKernelModeDriver] ValueType is not REG_DWORD");
        return;
    }

    //
    // At this point, we have a value that is of type REG_DWORD and
    // has a name of 'Type'. Now we see if the key is a subkey of 'Services'.
    //
    status = NtQueryKey(hKey,
                        KeyNameInformation,
                        pKeyNameInfo,
                        MAX_INFO_LENGTH,
                        &ulSize);

    if ((STATUS_BUFFER_OVERFLOW == status) ||
        (STATUS_BUFFER_TOO_SMALL == status)) {
        //
        // Our stack based buffer wasn't large enough.
        // Allocate from the heap and call it again.
        //
        pKeyNameInfo = (PKEY_NAME_INFORMATION)MemAlloc(ulSize);

        if (!pKeyNameInfo) {
            DPFN(eDbgLevelError,
                 "[WarnUserIfKernelModeDriver] Failed to allocate memory");
            return;
        }

        status = NtQueryKey(hKey,
                            KeyNameInformation,
                            pKeyNameInfo,
                            ulSize,
                            &ulSize);
    }

    if (NT_SUCCESS(status)) {
        //
        // See if this key points to CurrentControlSet or ControlSet.
        //
        if (wcsistr(pKeyNameInfo->Name, KMDI_CURCONTROLSET_KEY) ||
            wcsistr(pKeyNameInfo->Name, KMDI_CONTROLSET_KEY)) {
            
            //
            // Now see if this key points to Services.
            //
            if (wcsistr(pKeyNameInfo->Name, KMDI_SERVICES_KEY)) {
                //
                // We've got a key under 'Services'.
                // If the Data has a value of 0x00000001, 
                // we've got a kernel mode driver being installed.
                //
                if ((*(DWORD*)pData == KMDI_TYPE_VALUE)) {
                    VLOG(VLOG_LEVEL_ERROR,
                         VLOG_KMODEDRIVER_INST,
                         "The driver was installed via the registry.");
                }
            }
        }
    }

    if (pKeyNameInfo != (PKEY_NAME_INFORMATION)KeyNameInfo) {
        MemFree(pKeyNameInfo);
    }
}

NTSTATUS
APIHOOK(NtSetValueKey)(
    IN HANDLE          KeyHandle,
    IN PUNICODE_STRING ValueName,
    IN ULONG           TitleIndex OPTIONAL,
    IN ULONG           Type,
    IN PVOID           Data,
    IN ULONG           DataSize
    )
{
    NTSTATUS    status;

    status = ORIGINAL_API(NtSetValueKey)(KeyHandle,
                                         ValueName,
                                         TitleIndex,
                                         Type,
                                         Data,
                                         DataSize);

    if (NT_SUCCESS(status)) {
        WarnUserIfKernelModeDriver(KeyHandle, ValueName, Type, Data);
    }

    return status;
}

SHIM_INFO_BEGIN()

    SHIM_INFO_DESCRIPTION(AVS_KMODEDRIVER_DESC)
    SHIM_INFO_FRIENDLY_NAME(AVS_KMODEDRIVER_FRIENDLY)
    SHIM_INFO_VERSION(1, 1)
    SHIM_INFO_INCLUDE_EXCLUDE("I:advapi32.dll")
    
SHIM_INFO_END()

/*++

 Register hooked functions

--*/

HOOK_BEGIN

    DUMP_VERIFIER_LOG_ENTRY(VLOG_KMODEDRIVER_INST, 
                            AVS_KMODEDRIVER_INST,
                            AVS_KMODEDRIVER_INST_R,
                            AVS_KMODEDRIVER_INST_URL)

    APIHOOK_ENTRY(ADVAPI32.DLL,     CreateServiceA)
    APIHOOK_ENTRY(ADVAPI32.DLL,     CreateServiceW)
    APIHOOK_ENTRY(NTDLL.DLL,         NtSetValueKey)

HOOK_END

IMPLEMENT_SHIM_END
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\appcompat\shims\verifier\logregistrychanges.h ===
/*++

 Copyright (c) 2001 Microsoft Corporation

 Module Name:

   LogRegistryChanges.h

 Abstract:
 
   This AppVerifier shim hooks all the registry APIs
   that change the state of the system and logs their
   associated data to a text file.

 Notes:

   This is a general purpose shim.

 History:

   08/17/2001   rparsons    Created

--*/
#ifndef __APPVERIFIER_LOGREGISTRYCHANGES_H_
#define __APPVERIFIER_LOGREGISTRYCHANGES_H_

#include "precomp.h"

//
// Length (in characters) of our initial buffer for logging data.
//
#define TEMP_BUFFER_SIZE 1024

//
// Length (in characters) of the longest value name we expect.
//
#define MAX_VALUENAME_SIZE 260

//
// Length (in characters) of any empty element used for key modifications.
//
#define KEY_ELEMENT_SIZE 64

//
// Length (in characters) of an empty element used for value modifications.
//
#define VALUE_ELEMENT_SIZE 640

//
// Length (in characters) of a predefined key handle.
//
#define MAX_ROOT_LENGTH 22

//
// Length (in characters) of the longest data type (i.e., REG_EXPAND_SZ)
//
#define MAX_DATA_TYPE_LENGTH 14

//
// Length (in characters) of the longest operation type (i.e., ReplaceKey)
//
#define MAX_OPERATION_LENGTH 11

//
// Count of predefined key handles that we refer to.
//
#define NUM_PREDEFINED_HANDLES 7

//
// Delta for memory allocations.
//
#define BUFFER_ALLOCATION_DELTA 1024

//
// Macros for memory allocation/deallocation.
//
#define MemAlloc(s)     RtlAllocateHeap(RtlProcessHeap(), HEAP_ZERO_MEMORY, (s))
#define MemReAlloc(b,s) RtlReAllocateHeap(RtlProcessHeap(), HEAP_ZERO_MEMORY, (b), (s))
#define MemFree(b)      RtlFreeHeap(RtlProcessHeap(), 0, (b))

//
// Macro that returns TRUE if the given registry handle is predefined.
//
#define IsPredefinedRegistryHandle( h )                                     \
    ((  ( h == HKEY_CLASSES_ROOT        )                                   \
    ||  ( h == HKEY_CURRENT_USER        )                                   \
    ||  ( h == HKEY_LOCAL_MACHINE       )                                   \
    ||  ( h == HKEY_USERS               )                                   \
    ||  ( h == HKEY_CURRENT_CONFIG      )                                   \
    ||  ( h == HKEY_PERFORMANCE_DATA    )                                   \
    ||  ( h == HKEY_DYN_DATA            ))                                  \
    ?   TRUE                                                                \
    :   FALSE )

//
// A doubly linked list of all the values associated with a particular key path.
//
typedef struct _KEY_DATA {
    LIST_ENTRY  Entry;
    DWORD       dwFlags;                            // flags that relate to the state of the value
    DWORD       dwOriginalValueType;                // value type of original key data
    DWORD       dwFinalValueType;                   // value type of final key data
    WCHAR       wszValueName[MAX_VALUENAME_SIZE];   // value name
    PVOID       pOriginalData;                      // original key data (stored on the heap)
    PVOID       pFinalData;                         // final key data (stored on the heap)
    DWORD       cbOriginalDataSize;                 // original key data buffer size (in bytes)
    DWORD       cbFinalDataSize;                    // final key data buffer size (in bytes)
} KEY_DATA, *PKEY_DATA;

//
// Maximum number of key handles we can track for a single registry path.
//
#define MAX_NUM_HANDLES 64

//
// We keep a doubly linked list of keys currently open so we know how to
// resolve a key handle to a full key path.
// 
typedef struct _LOG_OPEN_KEY {
    LIST_ENTRY  Entry;
    LIST_ENTRY  KeyData;                    // points to the data (if any) associated with this key
    HKEY        hKeyBase[MAX_NUM_HANDLES];  // array of key handles
    HKEY        hKeyRoot;                   // handle to predefined key
    DWORD       dwFlags;                    // flags that relate to the state of the key
    LPWSTR      pwszFullKeyPath;            // HKEY_LOCAL_MACHINE\Software\Microsoft\Windows...
    LPWSTR      pwszSubKeyPath;             // Software\Microsoft\Windows...
    UINT        cHandles;                   // number of handles open for this key path
} LOG_OPEN_KEY, *PLOG_OPEN_KEY;

//
// Flags that indicate what state the key is in.
//
#define LRC_EXISTING_KEY    0x00000001
#define LRC_DELETED_KEY     0x00000002
//
// Flags that indicate what state the value is in.
//
#define LRC_EXISTING_VALUE  0x00000001
#define LRC_DELETED_VALUE   0x00000002
#define LRC_MODIFIED_VALUE  0x00000004

//
// Enumeration for updating the key information.
//
typedef enum {
    eAddKeyHandle = 0,
    eRemoveKeyHandle,
    eDeletedKey,
    eStartModifyValue,
    eEndModifyValue,
    eStartDeleteValue,
    eEndDeleteValue
} UpdateType;

//
// The reg class that does all the real work.
//
class CLogRegistry {

public:

    LONG CreateKeyExA(
        HKEY                  hKey,
        LPCSTR                pszSubKey,
        DWORD                 Reserved,
        LPSTR                 pszClass,
        DWORD                 dwOptions,
        REGSAM                samDesired,
        LPSECURITY_ATTRIBUTES lpSecurityAttributes,
        PHKEY                 phkResult,
        LPDWORD               lpdwDisposition
        );

    LONG CreateKeyExW(
        HKEY                  hKey,
        LPCWSTR               pwszSubKey,
        DWORD                 Reserved,
        LPWSTR                pwszClass,
        DWORD                 dwOptions,
        REGSAM                samDesired,
        LPSECURITY_ATTRIBUTES lpSecurityAttributes,
        PHKEY                 phkResult,
        LPDWORD               lpdwDisposition
        );

    LONG OpenKeyExA(
        HKEY   hKey,
        LPCSTR pszSubKey,        
        DWORD  ulOptions,
        REGSAM samDesired,        
        PHKEY  phkResult        
        );

    LONG OpenKeyExW(
        HKEY    hKey,
        LPCWSTR pwszSubKey,
        DWORD   ulOptions,
        REGSAM  samDesired,
        PHKEY   phkResult
        );

    LONG OpenCurrentUser(
        REGSAM samDesired,
        PHKEY  phkResult
        );

    LONG OpenUserClassesRoot(
        HANDLE hToken,
        DWORD  dwOptions,
        REGSAM samDesired,
        PHKEY  phkResult
        );

    LONG SetValueA(
        HKEY   hKey,
        LPCSTR pszSubKey,
        DWORD  dwType,
        LPCSTR pszData,
        DWORD  cbData
        );

    LONG SetValueW(
        HKEY    hKey,
        LPCWSTR pwszSubKey,
        DWORD   dwType,
        LPCWSTR lpData,
        DWORD   cbData
        );

    LONG SetValueExA(
        HKEY        hKey, 
        LPCSTR      pszValueName, 
        DWORD       Reserved, 
        DWORD       dwType, 
        CONST BYTE* lpData, 
        DWORD       cbData
        );

    LONG SetValueExW(
        HKEY        hKey, 
        LPCWSTR     pwszValueName, 
        DWORD       Reserved, 
        DWORD       dwType, 
        CONST BYTE* lpData, 
        DWORD       cbData
        );

    LONG CloseKey(
        HKEY hKey
        );

    LONG DeleteKeyA(
        HKEY   hKey,
        LPCSTR pszSubKey
        );

    LONG DeleteKeyW(
        HKEY    hKey,
        LPCWSTR pwszSubKey
        );

    LONG DeleteValueA(
        HKEY    hKey,
        LPCSTR  pszValueName
        );

    LONG DeleteValueW(
        HKEY    hKey,
        LPCWSTR pwszValueName
        );

private:
    BOOL GetOriginalDataForKey(
        IN PLOG_OPEN_KEY pLogOpenKey,
        IN PKEY_DATA     pKeyData,
        IN LPCWSTR       pwszValueName
        );

    BOOL GetFinalDataForKey(
        IN PLOG_OPEN_KEY pLogOpenKey,
        IN PKEY_DATA     pKeyData,
        IN LPCWSTR       pwszValueName
        );       

    PLOG_OPEN_KEY AddSpecialKeyHandleToList(
        IN HKEY hKeyRoot,
        IN HKEY hKeyNew
        );

    PKEY_DATA AddValueNameToList(
        IN PLOG_OPEN_KEY pLogOpenKey,
        IN LPCWSTR       pwszValueName
        );

    HKEY ForceSubKeyIntoList(
        IN  HKEY    hKeyPredefined,
        IN  LPCWSTR pwszSubKey
        );

    PKEY_DATA FindValueNameInList(
        IN LPCWSTR       pwszValueName,
        IN PLOG_OPEN_KEY pOpenKey
        );

    PLOG_OPEN_KEY FindKeyPathInList(
        IN LPCWSTR pwszKeyPath
        );

    PLOG_OPEN_KEY RemoveKeyHandleFromArray(
        IN HKEY hKey
        );

    PLOG_OPEN_KEY FindKeyHandleInArray(
        IN HKEY hKey
        );

    PLOG_OPEN_KEY AddKeyHandleToList(
        IN HKEY    hKey,
        IN HKEY    hKeyNew,
        IN LPCWSTR pwszSubKeyPath,
        IN BOOL    fExisting
        );

    PLOG_OPEN_KEY UpdateKeyList(
        IN HKEY       hKeyRoot,
        IN HKEY       hKeyNew,
        IN LPCWSTR    pwszSubKey,
        IN LPCWSTR    pwszValueName,
        IN BOOL       fExisting,
        IN UpdateType eType
        );
};

//
// Keep us safe while we're playing with linked lists and shared resources.
//
static BOOL g_bInitialized = FALSE;

CRITICAL_SECTION g_csLogging;

class CLock
{
public:
    CLock()
    {
        if (!g_bInitialized)
        {
            InitializeCriticalSection(&g_csLogging);
            g_bInitialized = TRUE;            
        }

        EnterCriticalSection(&g_csLogging);
    }
    ~CLock()
    {
        LeaveCriticalSection(&g_csLogging);
    }
};

APIHOOK_ENUM_BEGIN

    APIHOOK_ENUM_ENTRY(RegOpenKeyA)
    APIHOOK_ENUM_ENTRY(RegOpenKeyW)
    APIHOOK_ENUM_ENTRY(RegOpenKeyExA)
    APIHOOK_ENUM_ENTRY(RegOpenKeyExW)
    APIHOOK_ENUM_ENTRY(RegOpenCurrentUser)
    APIHOOK_ENUM_ENTRY(RegOpenUserClassesRoot)
    APIHOOK_ENUM_ENTRY(RegCreateKeyA)
    APIHOOK_ENUM_ENTRY(RegCreateKeyW)
    APIHOOK_ENUM_ENTRY(RegCreateKeyExA)
    APIHOOK_ENUM_ENTRY(RegCreateKeyExW)
    APIHOOK_ENUM_ENTRY(RegCloseKey)
    APIHOOK_ENUM_ENTRY(RegQueryValueA)
    APIHOOK_ENUM_ENTRY(RegQueryValueW)
    APIHOOK_ENUM_ENTRY(RegQueryValueExA)
    APIHOOK_ENUM_ENTRY(RegQueryValueExW)
    APIHOOK_ENUM_ENTRY(RegQueryInfoKeyA)
    APIHOOK_ENUM_ENTRY(RegQueryInfoKeyW)
    APIHOOK_ENUM_ENTRY(RegSetValueA)
    APIHOOK_ENUM_ENTRY(RegSetValueW)
    APIHOOK_ENUM_ENTRY(RegSetValueExA)
    APIHOOK_ENUM_ENTRY(RegSetValueExW)
    APIHOOK_ENUM_ENTRY(RegDeleteKeyA)
    APIHOOK_ENUM_ENTRY(RegDeleteKeyW)
    APIHOOK_ENUM_ENTRY(RegDeleteValueA)
    APIHOOK_ENUM_ENTRY(RegDeleteValueW)

    APIHOOK_ENUM_ENTRY(WriteProfileStringA)
    APIHOOK_ENUM_ENTRY(WriteProfileStringW)
    APIHOOK_ENUM_ENTRY(WriteProfileSectionA)
    APIHOOK_ENUM_ENTRY(WriteProfileSectionW)

APIHOOK_ENUM_END

#endif // __APPVERIFIER_LOGREGISTRYCHANGES_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\appcompat\shims\verifier\precomp.h ===
#ifndef _VFSHIMS_PRECOMP_H_
#define _VFSHIMS_PRECOMP_H_

#include "ShimHook.h"

using namespace ShimLib;

#include "VerifLog.h"
#include "ids.h"

#endif // _VFSHIMS_PRECOMP_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\appcompat\shims\verifier\logstartandstop.cpp ===
/*++

 Copyright (c) 2000 Microsoft Corporation

 Module Name:

   LogStartAndStop.cpp

 Abstract:

   This DLL just adds start and stop messages to the verifier log

 Notes:

   This is a general purpose shim.

 History:

   06/05/2001 dmunsil  Created

--*/

#include "precomp.h"

IMPLEMENT_SHIM_BEGIN(LogStartAndStop)
#include "ShimHookMacro.h"

APIHOOK_ENUM_BEGIN
APIHOOK_ENUM_END

//
// verifier log entries
//
BEGIN_DEFINE_VERIFIER_LOG(LogStartAndStop)
    VERIFIER_LOG_ENTRY(VLOG_APP_STARTED)
    VERIFIER_LOG_ENTRY(VLOG_APP_STOPPED)
END_DEFINE_VERIFIER_LOG(LogStartAndStop)

INIT_VERIFIER_LOG(LogStartAndStop);

BOOL
NOTIFY_FUNCTION(
    DWORD fdwReason
    )
{
    if (fdwReason == SHIM_STATIC_DLLS_INITIALIZED) {

        VLOG(VLOG_LEVEL_INFO, VLOG_APP_STARTED, "The application started.");

    } else if (fdwReason == DLL_PROCESS_DETACH) {

        VLOG(VLOG_LEVEL_INFO, VLOG_APP_STOPPED, "The application stopped.");
    }
    
    return TRUE;
}

SHIM_INFO_BEGIN()

    SHIM_INFO_DESCRIPTION(AVS_LOGSTARTANDSTOP_DESC)
    SHIM_INFO_FRIENDLY_NAME(AVS_LOGSTARTANDSTOP_FRIENDLY)
    SHIM_INFO_VERSION(1, 2)
    SHIM_INFO_FLAGS(AVRF_FLAG_NO_WIN2K)

SHIM_INFO_END()

/*++

 Register hooked functions

--*/

HOOK_BEGIN
    DUMP_VERIFIER_LOG_ENTRY(VLOG_APP_STARTED, 
                            AVS_APP_STARTED,
                            AVS_APP_STARTED_R,
                            AVS_APP_STARTED_URL)

    DUMP_VERIFIER_LOG_ENTRY(VLOG_APP_STOPPED, 
                            AVS_APP_STOPPED,
                            AVS_APP_STOPPED_R,
                            AVS_APP_STOPPED_URL)

    CALL_NOTIFY_FUNCTION
HOOK_END


IMPLEMENT_SHIM_END
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\appcompat\shims\verifier\obsoleteapicalls.cpp ===
/*++

 Copyright (c) 2001 Microsoft Corporation

 Module Name:

   ObsoleteAPICalls.cpp

 Abstract:

   This AppVerifier shim hooks the API calls that are considered
   obsolete by the Platform SDK team and logs an entry.

 Notes:

   This is a general purpose shim.
   
   API calls are listed in alphabetical order to allow
   them to be quickly located in the shim and to allow
   new ones to be added in the proper location.

 History:

   09/30/2001   rparsons    Created
   10/10/2001   rparsons    Removed SetHandleCount

--*/

#include "precomp.h"

IMPLEMENT_SHIM_BEGIN(ObsoleteAPICalls)
#include "ShimHookMacro.h"

BEGIN_DEFINE_VERIFIER_LOG(ObsoleteAPICalls)
    VERIFIER_LOG_ENTRY(VLOG_OBSOLETECALLS_API)    
END_DEFINE_VERIFIER_LOG(ObsoleteAPICalls)

INIT_VERIFIER_LOG(ObsoleteAPICalls);

APIHOOK_ENUM_BEGIN

    APIHOOK_ENUM_ENTRY(_hread)
    APIHOOK_ENUM_ENTRY(_hwrite)
    APIHOOK_ENUM_ENTRY(_lclose)
    APIHOOK_ENUM_ENTRY(_lcreat)
    APIHOOK_ENUM_ENTRY(_llseek)
    APIHOOK_ENUM_ENTRY(_lopen)
    APIHOOK_ENUM_ENTRY(_lread)
    APIHOOK_ENUM_ENTRY(_lwrite)
    APIHOOK_ENUM_ENTRY(AnyPopup)
    APIHOOK_ENUM_ENTRY(CloseMetaFile)
    APIHOOK_ENUM_ENTRY(CopyLZFile)
    APIHOOK_ENUM_ENTRY(CopyMetaFileA)
    APIHOOK_ENUM_ENTRY(CopyMetaFileW)
    APIHOOK_ENUM_ENTRY(CreateDIBPatternBrush)
    APIHOOK_ENUM_ENTRY(CreateDiscardableBitmap)
    APIHOOK_ENUM_ENTRY(CreateMetaFileA)
    APIHOOK_ENUM_ENTRY(CreateMetaFileW)
    APIHOOK_ENUM_ENTRY(DeleteMetaFile)
    APIHOOK_ENUM_ENTRY(EnumFontFamiliesA)
    APIHOOK_ENUM_ENTRY(EnumFontFamiliesW)
    APIHOOK_ENUM_ENTRY(EnumFontFamProc)
    APIHOOK_ENUM_ENTRY(EnumFontsA)
    APIHOOK_ENUM_ENTRY(EnumFontsW)
    APIHOOK_ENUM_ENTRY(EnumFontsProc)
    APIHOOK_ENUM_ENTRY(EnumMetaFile)
    APIHOOK_ENUM_ENTRY(EnumMetaFileProc)
    APIHOOK_ENUM_ENTRY(FixBrushOrgEx)
    APIHOOK_ENUM_ENTRY(FloodFill)
    APIHOOK_ENUM_ENTRY(FreeResource)
    APIHOOK_ENUM_ENTRY(GetBitmapBits)
    APIHOOK_ENUM_ENTRY(GetCharWidthA)
    APIHOOK_ENUM_ENTRY(GetCharWidthW)
    APIHOOK_ENUM_ENTRY(GetClassWord)
    APIHOOK_ENUM_ENTRY(GetKBCodePage)
    APIHOOK_ENUM_ENTRY(GetMetaFileA)
    APIHOOK_ENUM_ENTRY(GetMetaFileW)
    APIHOOK_ENUM_ENTRY(GetMetaFileBitsEx)
    APIHOOK_ENUM_ENTRY(GetPrivateProfileIntA)
    APIHOOK_ENUM_ENTRY(GetPrivateProfileIntW)
    APIHOOK_ENUM_ENTRY(GetPrivateProfileSectionA)
    APIHOOK_ENUM_ENTRY(GetPrivateProfileSectionW)
    APIHOOK_ENUM_ENTRY(GetPrivateProfileSectionNamesA)
    APIHOOK_ENUM_ENTRY(GetPrivateProfileSectionNamesW)
    APIHOOK_ENUM_ENTRY(GetPrivateProfileStringA)
    APIHOOK_ENUM_ENTRY(GetPrivateProfileStringW)
    APIHOOK_ENUM_ENTRY(GetPrivateProfileStructA)
    APIHOOK_ENUM_ENTRY(GetPrivateProfileStructW)
    APIHOOK_ENUM_ENTRY(GetProfileIntA)
    APIHOOK_ENUM_ENTRY(GetProfileIntW)
    APIHOOK_ENUM_ENTRY(GetProfileSectionA)
    APIHOOK_ENUM_ENTRY(GetProfileSectionW)
    APIHOOK_ENUM_ENTRY(GetProfileStringA)
    APIHOOK_ENUM_ENTRY(GetProfileStringW)
    APIHOOK_ENUM_ENTRY(GetSysModalWindow)
    APIHOOK_ENUM_ENTRY(GetTextExtentPointA)
    APIHOOK_ENUM_ENTRY(GetTextExtentPointW)
    APIHOOK_ENUM_ENTRY(GetWindowWord)
    APIHOOK_ENUM_ENTRY(GlobalAlloc)
    APIHOOK_ENUM_ENTRY(GlobalCompact)
    APIHOOK_ENUM_ENTRY(GlobalFix)
    APIHOOK_ENUM_ENTRY(GlobalFlags)
    APIHOOK_ENUM_ENTRY(GlobalFree)
    APIHOOK_ENUM_ENTRY(GlobalHandle)
    APIHOOK_ENUM_ENTRY(GlobalLock)
    APIHOOK_ENUM_ENTRY(GlobalReAlloc)
    APIHOOK_ENUM_ENTRY(GlobalSize)
    APIHOOK_ENUM_ENTRY(GlobalUnfix)
    APIHOOK_ENUM_ENTRY(GlobalUnlock)
    APIHOOK_ENUM_ENTRY(GlobalUnWire)
    APIHOOK_ENUM_ENTRY(GlobalWire)
    APIHOOK_ENUM_ENTRY(IsBadHugeReadPtr)
    APIHOOK_ENUM_ENTRY(IsBadHugeWritePtr)
    APIHOOK_ENUM_ENTRY(LoadModule)
    APIHOOK_ENUM_ENTRY(LocalAlloc)
    APIHOOK_ENUM_ENTRY(LocalCompact)
    APIHOOK_ENUM_ENTRY(LocalDiscard)
    APIHOOK_ENUM_ENTRY(LocalFlags)
    APIHOOK_ENUM_ENTRY(LocalFree)
    APIHOOK_ENUM_ENTRY(LocalHandle)
    APIHOOK_ENUM_ENTRY(LocalLock)
    APIHOOK_ENUM_ENTRY(LocalReAlloc)
    APIHOOK_ENUM_ENTRY(LocalShrink)
    APIHOOK_ENUM_ENTRY(LocalSize)
    APIHOOK_ENUM_ENTRY(LocalUnlock)
    APIHOOK_ENUM_ENTRY(LZDone)
    APIHOOK_ENUM_ENTRY(LZStart)
    APIHOOK_ENUM_ENTRY(OpenFile)
    APIHOOK_ENUM_ENTRY(PlayMetaFile)
    APIHOOK_ENUM_ENTRY(PlayMetaFileRecord)
    APIHOOK_ENUM_ENTRY(PrinterMessageBoxA)
    APIHOOK_ENUM_ENTRY(PrinterMessageBoxW)
    APIHOOK_ENUM_ENTRY(RegCreateKeyA)
    APIHOOK_ENUM_ENTRY(RegCreateKeyW)
    APIHOOK_ENUM_ENTRY(RegEnumKeyA)
    APIHOOK_ENUM_ENTRY(RegEnumKeyW)
    APIHOOK_ENUM_ENTRY(RegOpenKeyA)
    APIHOOK_ENUM_ENTRY(RegOpenKeyW)
    APIHOOK_ENUM_ENTRY(RegQueryValueA)
    APIHOOK_ENUM_ENTRY(RegQueryValueW)
    APIHOOK_ENUM_ENTRY(RegSetValueA)
    APIHOOK_ENUM_ENTRY(RegSetValueW)
    APIHOOK_ENUM_ENTRY(SetBitmapBits)
    APIHOOK_ENUM_ENTRY(SetClassWord)
    APIHOOK_ENUM_ENTRY(SetDebugErrorLevel)
    APIHOOK_ENUM_ENTRY(SetMessageQueue)
    APIHOOK_ENUM_ENTRY(SetMetaFileBitsEx)
    APIHOOK_ENUM_ENTRY(SetSysModalWindow)
    APIHOOK_ENUM_ENTRY(SetWindowsHookA)
    APIHOOK_ENUM_ENTRY(SetWindowsHookW)
    APIHOOK_ENUM_ENTRY(SetWindowWord)
    APIHOOK_ENUM_ENTRY(UnhookWindowsHook)
    APIHOOK_ENUM_ENTRY(WaitForPrinterChange)
    APIHOOK_ENUM_ENTRY(WinExec)
    APIHOOK_ENUM_ENTRY(WNetAddConnectionA)
    APIHOOK_ENUM_ENTRY(WNetAddConnectionW)
    APIHOOK_ENUM_ENTRY(WritePrivateProfileSectionA)
    APIHOOK_ENUM_ENTRY(WritePrivateProfileSectionW)
    APIHOOK_ENUM_ENTRY(WritePrivateProfileStringA)
    APIHOOK_ENUM_ENTRY(WritePrivateProfileStringW)
    APIHOOK_ENUM_ENTRY(WritePrivateProfileStructA)
    APIHOOK_ENUM_ENTRY(WritePrivateProfileStructW)
    APIHOOK_ENUM_ENTRY(WriteProfileSectionA)
    APIHOOK_ENUM_ENTRY(WriteProfileSectionW)
    APIHOOK_ENUM_ENTRY(WriteProfileStringA)
    APIHOOK_ENUM_ENTRY(WriteProfileStringW)
    
APIHOOK_ENUM_END

LONG
APIHOOK(_hread)(
    HFILE  hFile,
    LPVOID lpBuffer,
    LONG   lBytes
  )
{
    VLOG(VLOG_LEVEL_WARNING, VLOG_OBSOLETECALLS_API, "API: _hread");

    return ORIGINAL_API(_hread)(hFile, lpBuffer, lBytes);
}

LONG
APIHOOK(_hwrite)(
    HFILE  hFile,
    LPCSTR lpBuffer,
    LONG   lBytes
  )
{
    VLOG(VLOG_LEVEL_WARNING, VLOG_OBSOLETECALLS_API, "API: _hwrite");

    return ORIGINAL_API(_hwrite)(hFile, lpBuffer, lBytes);
}

HFILE
APIHOOK(_lclose)(
    HFILE hFile
  )
{
    VLOG(VLOG_LEVEL_WARNING, VLOG_OBSOLETECALLS_API, "API: _lclose");

    return ORIGINAL_API(_lclose)(hFile);
}

HFILE
APIHOOK(_lcreat)(
    LPCSTR lpPathName,
    int    iAttribute
    )
{
    VLOG(VLOG_LEVEL_WARNING, VLOG_OBSOLETECALLS_API, "API: _lcreat");
    
    return ORIGINAL_API(_lcreat)(lpPathName, iAttribute);

}

LONG
APIHOOK(_llseek)(
    HFILE hFile,
    LONG  lOffset,
    int   iOrigin
  )
{
    VLOG(VLOG_LEVEL_WARNING, VLOG_OBSOLETECALLS_API, "API: _llseek");

    return ORIGINAL_API(_llseek)(hFile, lOffset, iOrigin);
}

HFILE
APIHOOK(_lopen)(
    LPCSTR lpPathName,
    int    iReadWrite
    )
{
    VLOG(VLOG_LEVEL_WARNING, VLOG_OBSOLETECALLS_API, "API: _lopen");
    
    return ORIGINAL_API(_lopen)(lpPathName, iReadWrite);
}

UINT
APIHOOK(_lread)(
    HFILE  hFile,
    LPVOID lpBuffer,
    UINT   uBytes
  )
{
    VLOG(VLOG_LEVEL_WARNING, VLOG_OBSOLETECALLS_API, "API: _lread");

    return ORIGINAL_API(_lread)(hFile, lpBuffer, uBytes);
}

UINT
APIHOOK(_lwrite)(
    HFILE  hFile,
    LPCSTR lpBuffer,
    UINT   uBytes
  )
{
    VLOG(VLOG_LEVEL_WARNING, VLOG_OBSOLETECALLS_API, "API: _lwrite");

    return ORIGINAL_API(_lwrite)(hFile, lpBuffer, uBytes);
}

BOOL
APIHOOK(AnyPopup)(
    void
    )
{
    VLOG(VLOG_LEVEL_WARNING, VLOG_OBSOLETECALLS_API, "API: AnyPopup");

    return ORIGINAL_API(AnyPopup)();
}

HMETAFILE
APIHOOK(CloseMetaFile)(
    HDC hdc
    )
{
    VLOG(VLOG_LEVEL_WARNING, VLOG_OBSOLETECALLS_API, "API: CloseMetaFile");

    return ORIGINAL_API(CloseMetaFile)(hdc);
}

LONG
APIHOOK(CopyLZFile)(
    int nUnknown1,
    int nUnknown2
    )
{
    VLOG(VLOG_LEVEL_WARNING, VLOG_OBSOLETECALLS_API, "API: CopyLZFile");

    return ORIGINAL_API(CopyLZFile)(nUnknown1, nUnknown2);
}

HMETAFILE
APIHOOK(CopyMetaFileA)(
    HMETAFILE hmfSrc,
    LPCSTR    lpszFile
    )
{
    VLOG(VLOG_LEVEL_WARNING, VLOG_OBSOLETECALLS_API, "API: CopyMetaFileA");

    return ORIGINAL_API(CopyMetaFileA)(hmfSrc, lpszFile);
}

HMETAFILE
APIHOOK(CopyMetaFileW)(
    HMETAFILE hmfSrc,
    LPCWSTR    lpszFile
    )
{
    VLOG(VLOG_LEVEL_WARNING, VLOG_OBSOLETECALLS_API, "API: CopyMetaFileW");

    return ORIGINAL_API(CopyMetaFileW)(hmfSrc, lpszFile);
}

HBRUSH
APIHOOK(CreateDIBPatternBrush)(
    HGLOBAL hglbDIBPacked,
    UINT    fuColorSpec
    )
{
    VLOG(VLOG_LEVEL_WARNING, VLOG_OBSOLETECALLS_API, "API: CreateDIBPatternBrush");

    return ORIGINAL_API(CreateDIBPatternBrush)(hglbDIBPacked, fuColorSpec);
}

HBITMAP
APIHOOK(CreateDiscardableBitmap)(
    HDC hdc,   
    int nWidth,
    int nHeight
    )
{
    VLOG(VLOG_LEVEL_WARNING, VLOG_OBSOLETECALLS_API, "API: CreateDiscardableBitmap");

    return ORIGINAL_API(CreateDiscardableBitmap)(hdc, nWidth, nHeight);
}

HDC
APIHOOK(CreateMetaFileA)(
    LPCSTR lpszFile
    )
{
    VLOG(VLOG_LEVEL_WARNING, VLOG_OBSOLETECALLS_API, "API: CreateMetaFileA");

    return ORIGINAL_API(CreateMetaFileA)(lpszFile);
}

HDC
APIHOOK(CreateMetaFileW)(
    LPCWSTR lpszFile
    )
{
    VLOG(VLOG_LEVEL_WARNING, VLOG_OBSOLETECALLS_API, "API: CreateMetaFileW");

    return ORIGINAL_API(CreateMetaFileW)(lpszFile);
}

BOOL
APIHOOK(DeleteMetaFile)(
    HMETAFILE hmf
    )
{
    VLOG(VLOG_LEVEL_WARNING, VLOG_OBSOLETECALLS_API, "API: DeleteMetaFile");

    return ORIGINAL_API(DeleteMetaFile)(hmf);
}

int
APIHOOK(EnumFontFamiliesA)(
    HDC          hdc,
    LPCSTR       lpszFamily,
    FONTENUMPROC lpEnumFontFamProc,
    LPARAM       lParam
    )
{
    VLOG(VLOG_LEVEL_WARNING, VLOG_OBSOLETECALLS_API, "API: EnumFontFamiliesA");

    return ORIGINAL_API(EnumFontFamiliesA)(hdc, lpszFamily, lpEnumFontFamProc, lParam);
}

int
APIHOOK(EnumFontFamiliesW)(
    HDC          hdc,
    LPCWSTR      lpszFamily,
    FONTENUMPROC lpEnumFontFamProc,
    LPARAM       lParam
    )
{
    VLOG(VLOG_LEVEL_WARNING, VLOG_OBSOLETECALLS_API, "API: EnumFontFamiliesW");

    return ORIGINAL_API(EnumFontFamiliesW)(hdc, lpszFamily, lpEnumFontFamProc, lParam);
}

int
APIHOOK(EnumFontFamProc)(
    ENUMLOGFONT   *lpelf,
    NEWTEXTMETRIC *lpntm,
    DWORD         FontType,
    LPARAM        lParam
    )
{
    VLOG(VLOG_LEVEL_WARNING, VLOG_OBSOLETECALLS_API, "API: EnumFontFamProc");

    return ORIGINAL_API(EnumFontFamProc)(lpelf, lpntm, FontType, lParam);
}

int
APIHOOK(EnumFontsA)(
    HDC          hdc,
    LPCSTR       lpFaceName,
    FONTENUMPROC lpFontFunc,
    LPARAM       lParam
    )
{
    VLOG(VLOG_LEVEL_WARNING, VLOG_OBSOLETECALLS_API, "API: EnumFontsA");

    return ORIGINAL_API(EnumFontsA)(hdc, lpFaceName, lpFontFunc, lParam);
}

int
APIHOOK(EnumFontsW)(
    HDC          hdc,
    LPCWSTR      lpFaceName,
    FONTENUMPROC lpFontFunc,
    LPARAM       lParam
    )
{
    VLOG(VLOG_LEVEL_WARNING, VLOG_OBSOLETECALLS_API, "API: EnumFontsW");

    return ORIGINAL_API(EnumFontsW)(hdc, lpFaceName, lpFontFunc, lParam);
}

int
APIHOOK(EnumFontsProc)(
    CONST LOGFONT    *lplf,
    CONST TEXTMETRIC *lptm,
    DWORD            dwType,
    LPARAM           lpData
    )
{
    VLOG(VLOG_LEVEL_WARNING, VLOG_OBSOLETECALLS_API, "API: EnumFontsProc");

    return ORIGINAL_API(EnumFontsProc)(lplf, lptm, dwType, lpData);
}

BOOL
APIHOOK(EnumMetaFile)(
    HDC        hdc,
    HMETAFILE  hmf,
    MFENUMPROC lpMetaFunc,
    LPARAM     lParam
    )
{
    VLOG(VLOG_LEVEL_WARNING, VLOG_OBSOLETECALLS_API, "API: EnumMetaFile");

    return ORIGINAL_API(EnumMetaFile)(hdc, hmf, lpMetaFunc, lParam);
}

int
APIHOOK(EnumMetaFileProc)(
    HDC         hDC,
    HANDLETABLE *lpHTable,
    METARECORD  *lpMFR,
    int         nObj,
    LPARAM      lpClientData
    )
{
    VLOG(VLOG_LEVEL_WARNING, VLOG_OBSOLETECALLS_API, "API: EnumMetaFileProc");

    return ORIGINAL_API(EnumMetaFileProc)(hDC, lpHTable, lpMFR, nObj, lpClientData);
}

BOOL
APIHOOK(FixBrushOrgEx)(
    HDC     hdc,
    int     nUnknown1,
    int     nUnknown2,
    LPPOINT lpPoint
    )
{
    VLOG(VLOG_LEVEL_WARNING, VLOG_OBSOLETECALLS_API, "API: FixBrushOrgEx");

    return ORIGINAL_API(FixBrushOrgEx)(hdc, nUnknown1, nUnknown2, lpPoint);
}

BOOL
APIHOOK(FloodFill)(
    HDC      hdc,
    int      nXStart,
    int      nYStart,
    COLORREF crFill
    )
{
    VLOG(VLOG_LEVEL_WARNING, VLOG_OBSOLETECALLS_API, "API: FloodFill");

    return ORIGINAL_API(FloodFill)(hdc, nXStart, nYStart, crFill);
}

BOOL
APIHOOK(FreeResource)(
    HGLOBAL hMem
    )
{
    VLOG(VLOG_LEVEL_WARNING, VLOG_OBSOLETECALLS_API, "API: FreeResource");

    return ORIGINAL_API(FreeResource)(hMem);
}

LONG
APIHOOK(GetBitmapBits)(
    HBITMAP hbmp,
    LONG    cbBuffer,
    LPVOID  lpvBits
    )
{
    VLOG(VLOG_LEVEL_WARNING, VLOG_OBSOLETECALLS_API, "API: GetBitmapBits");

    return ORIGINAL_API(GetBitmapBits)(hbmp, cbBuffer, lpvBits);
}

BOOL
APIHOOK(GetCharWidthA)(
    HDC   hdc,
    UINT  iFirstChar,
    UINT  iLastChar,
    LPINT lpBuffer
    )
{
    VLOG(VLOG_LEVEL_WARNING, VLOG_OBSOLETECALLS_API, "API: GetCharWidthA");

    return ORIGINAL_API(GetCharWidthA)(hdc, iFirstChar, iLastChar, lpBuffer);
}

BOOL
APIHOOK(GetCharWidthW)(
    HDC   hdc,
    UINT  iFirstChar,
    UINT  iLastChar,
    LPINT lpBuffer
    )
{
    VLOG(VLOG_LEVEL_WARNING, VLOG_OBSOLETECALLS_API, "API: GetCharWidthW");

    return ORIGINAL_API(GetCharWidthW)(hdc, iFirstChar, iLastChar, lpBuffer);
}

WORD
APIHOOK(GetClassWord)(
    HWND hWnd,
    int  nIndex
    )
{
    VLOG(VLOG_LEVEL_WARNING, VLOG_OBSOLETECALLS_API, "API: GetClassWord");

    return ORIGINAL_API(GetClassWord)(hWnd, nIndex);
}

UINT
APIHOOK(GetKBCodePage)(
    void
    )
{
    VLOG(VLOG_LEVEL_WARNING, VLOG_OBSOLETECALLS_API, "API: GetKBCodePage");

    return ORIGINAL_API(GetKBCodePage)();
}

HMETAFILE
APIHOOK(GetMetaFileA)(
    LPCSTR lpszString
    )
{
    VLOG(VLOG_LEVEL_WARNING, VLOG_OBSOLETECALLS_API, "API: GetMetaFileA");

    return ORIGINAL_API(GetMetaFileA)(lpszString);
}

HMETAFILE
APIHOOK(GetMetaFileW)(
    LPCWSTR lpszString
    )
{
    VLOG(VLOG_LEVEL_WARNING, VLOG_OBSOLETECALLS_API, "API: GetMetaFileW");

    return ORIGINAL_API(GetMetaFileW)(lpszString);
}

UINT
APIHOOK(GetMetaFileBitsEx)(
    HMETAFILE hmf,
    UINT      nSize,
    LPVOID    lpvData
    )
{
    VLOG(VLOG_LEVEL_WARNING, VLOG_OBSOLETECALLS_API, "API: GetMetaFileBitsEx");

    return ORIGINAL_API(GetMetaFileBitsEx)(hmf, nSize, lpvData);
}

UINT
APIHOOK(GetPrivateProfileIntA)(
    LPCSTR lpAppName,
    LPCSTR lpKeyName,
    INT    nDefault,
    LPCSTR lpFileName
    )
{
    VLOG(VLOG_LEVEL_WARNING, VLOG_OBSOLETECALLS_API, "API: GetPrivateProfileIntA");

    return ORIGINAL_API(GetPrivateProfileIntA)(lpAppName, lpKeyName, nDefault, lpFileName);
}

UINT
APIHOOK(GetPrivateProfileIntW)(
    LPCWSTR lpAppName,
    LPCWSTR lpKeyName,
    INT     nDefault,
    LPCWSTR lpFileName
    )
{
    VLOG(VLOG_LEVEL_WARNING, VLOG_OBSOLETECALLS_API, "API: GetPrivateProfileIntW");

    return ORIGINAL_API(GetPrivateProfileIntW)(lpAppName, lpKeyName, nDefault, lpFileName);
}

DWORD
APIHOOK(GetPrivateProfileSectionA)(
    LPCSTR lpAppName,       
    LPSTR  lpReturnedString,
    DWORD  nSize,
    LPCSTR lpFileName
    )
{
    VLOG(VLOG_LEVEL_WARNING, VLOG_OBSOLETECALLS_API, "API: GetPrivateProfileSectionA");

    return ORIGINAL_API(GetPrivateProfileSectionA)(lpAppName, lpReturnedString, nSize, lpFileName);
}

DWORD
APIHOOK(GetPrivateProfileSectionW)(
    LPCWSTR lpAppName,       
    LPWSTR  lpReturnedString,
    DWORD   nSize,
    LPCWSTR lpFileName
    )
{
    VLOG(VLOG_LEVEL_WARNING, VLOG_OBSOLETECALLS_API, "API: GetPrivateProfileSectionW");

    return ORIGINAL_API(GetPrivateProfileSectionW)(lpAppName, lpReturnedString, nSize, lpFileName);
}

DWORD
APIHOOK(GetPrivateProfileSectionNamesA)(
    LPSTR  lpszReturnBuffer,
    DWORD  nSize,
    LPCSTR lpFileName
    )
{
    VLOG(VLOG_LEVEL_WARNING, VLOG_OBSOLETECALLS_API, "API: GetPrivateProfileSectionNamesA");

    return ORIGINAL_API(GetPrivateProfileSectionNamesA)(lpszReturnBuffer, nSize, lpFileName);
}

DWORD
APIHOOK(GetPrivateProfileSectionNamesW)(
    LPWSTR  lpszReturnBuffer,
    DWORD   nSize,
    LPCWSTR lpFileName
    )
{
    VLOG(VLOG_LEVEL_WARNING, VLOG_OBSOLETECALLS_API, "API: GetPrivateProfileSectionNamesW");

    return ORIGINAL_API(GetPrivateProfileSectionNamesW)(lpszReturnBuffer, nSize, lpFileName);
}

DWORD
APIHOOK(GetPrivateProfileStringA)(
    LPCSTR lpAppName,       
    LPCSTR lpKeyName,       
    LPCSTR lpDefault,       
    LPSTR  lpReturnedString,
    DWORD  nSize,
    LPCSTR lpFileName
    )
{
    VLOG(VLOG_LEVEL_WARNING, VLOG_OBSOLETECALLS_API, "API: GetPrivateProfileStringA");

    return ORIGINAL_API(GetPrivateProfileStringA)(lpAppName, lpKeyName, lpDefault,
                                                  lpReturnedString, nSize, lpFileName);
}

DWORD
APIHOOK(GetPrivateProfileStringW)(
    LPCWSTR lpAppName,       
    LPCWSTR lpKeyName,       
    LPCWSTR lpDefault,       
    LPWSTR  lpReturnedString,
    DWORD   nSize,
    LPCWSTR lpFileName
    )
{
    VLOG(VLOG_LEVEL_WARNING, VLOG_OBSOLETECALLS_API, "API: GetPrivateProfileStringW");

    return ORIGINAL_API(GetPrivateProfileStringW)(lpAppName, lpKeyName, lpDefault,
                                                  lpReturnedString, nSize, lpFileName);
}

BOOL
APIHOOK(GetPrivateProfileStructA)(
    LPCSTR lpszSection,
    LPCSTR lpszKey,
    LPVOID lpStruct,
    UINT   uSizeStruct,
    LPCSTR szFile
    )
{
    VLOG(VLOG_LEVEL_WARNING, VLOG_OBSOLETECALLS_API, "API: GetPrivateProfileStructA");

    return ORIGINAL_API(GetPrivateProfileStructA)(lpszSection, lpszKey, lpStruct,
                                                  uSizeStruct, szFile);
}

BOOL
APIHOOK(GetPrivateProfileStructW)(
    LPCWSTR lpszSection,
    LPCWSTR lpszKey,
    LPVOID  lpStruct,
    UINT    uSizeStruct,
    LPCWSTR szFile
    )
{
    VLOG(VLOG_LEVEL_WARNING, VLOG_OBSOLETECALLS_API, "API: GetPrivateProfileStructW");

    return ORIGINAL_API(GetPrivateProfileStructW)(lpszSection, lpszKey, lpStruct,
                                                  uSizeStruct, szFile);
}

UINT
APIHOOK(GetProfileIntA)(
    LPCSTR lpAppName,
    LPCSTR lpKeyName,
    INT    nDefault
  )
{
    VLOG(VLOG_LEVEL_WARNING, VLOG_OBSOLETECALLS_API, "API: GetProfileIntA");

    return ORIGINAL_API(GetProfileIntA)(lpAppName, lpKeyName, nDefault);
}

UINT
APIHOOK(GetProfileIntW)(
    LPCWSTR lpAppName,
    LPCWSTR lpKeyName,
    INT     nDefault
  )
{
    VLOG(VLOG_LEVEL_WARNING, VLOG_OBSOLETECALLS_API, "API: GetProfileIntW");

    return ORIGINAL_API(GetProfileIntW)(lpAppName, lpKeyName, nDefault);
}

DWORD
APIHOOK(GetProfileSectionA)(
    LPCSTR lpAppName,
    LPSTR  lpReturnedString,
    DWORD  nSize
  )
{
    VLOG(VLOG_LEVEL_WARNING, VLOG_OBSOLETECALLS_API, "API: GetProfileSectionA");

    return ORIGINAL_API(GetProfileSectionA)(lpAppName, lpReturnedString, nSize);
}

DWORD
APIHOOK(GetProfileSectionW)(
    LPCWSTR lpAppName,
    LPWSTR  lpReturnedString,
    DWORD   nSize
  )
{
    VLOG(VLOG_LEVEL_WARNING, VLOG_OBSOLETECALLS_API, "API: GetProfileSectionW");

    return ORIGINAL_API(GetProfileSectionW)(lpAppName, lpReturnedString, nSize);
}

DWORD
APIHOOK(GetProfileStringA)(
    LPCSTR lpAppName,
    LPCSTR lpKeyName,
    LPCSTR lpDefault,
    LPSTR  lpReturnedString,
    DWORD  nSize
    )
{
    VLOG(VLOG_LEVEL_WARNING, VLOG_OBSOLETECALLS_API, "API: GetProfileStringA");

    return ORIGINAL_API(GetProfileStringA)(lpAppName, lpKeyName, lpDefault,
                                           lpReturnedString, nSize);
}

DWORD
APIHOOK(GetProfileStringW)(
    LPCWSTR lpAppName,
    LPCWSTR lpKeyName,
    LPCWSTR lpDefault,
    LPWSTR  lpReturnedString,
    DWORD   nSize
    )
{
    VLOG(VLOG_LEVEL_WARNING, VLOG_OBSOLETECALLS_API, "API: GetProfileStringW");

    return ORIGINAL_API(GetProfileStringW)(lpAppName, lpKeyName, lpDefault,
                                           lpReturnedString, nSize);
}

HWND
APIHOOK(GetSysModalWindow)(
    void
    )
{
    VLOG(VLOG_LEVEL_WARNING, VLOG_OBSOLETECALLS_API, "API: GetSysModalWindow");

    return ORIGINAL_API(GetSysModalWindow)();
}

BOOL
APIHOOK(GetTextExtentPointA)(
    HDC    hdc,
    LPCSTR lpString,
    int    cbString,
    LPSIZE lpSize
    )
{
    VLOG(VLOG_LEVEL_WARNING, VLOG_OBSOLETECALLS_API, "API: GetTextExtentPointA");

    return ORIGINAL_API(GetTextExtentPointA)(hdc, lpString, cbString, lpSize);
}

BOOL
APIHOOK(GetTextExtentPointW)(
    HDC     hdc,
    LPCWSTR lpString,
    int     cbString,
    LPSIZE  lpSize
    )
{
    VLOG(VLOG_LEVEL_WARNING, VLOG_OBSOLETECALLS_API, "API: GetTextExtentPointW");

    return ORIGINAL_API(GetTextExtentPointW)(hdc, lpString, cbString, lpSize);
}

WORD
APIHOOK(GetWindowWord)(
    HWND hWnd,
    int  nUnknown
    )
{
    VLOG(VLOG_LEVEL_WARNING, VLOG_OBSOLETECALLS_API, "API: GetWindowWord");

    return ORIGINAL_API(GetWindowWord)(hWnd, nUnknown);
}

HGLOBAL
APIHOOK(GlobalAlloc)(
    UINT   uFlags,
    SIZE_T dwBytes
    )
{
    VLOG(VLOG_LEVEL_WARNING, VLOG_OBSOLETECALLS_API, "API: GlobalAlloc");

    return ORIGINAL_API(GlobalAlloc)(uFlags, dwBytes);
}

DWORD
APIHOOK(GlobalCompact)(
    DWORD dwUnknown
    )
{
    VLOG(VLOG_LEVEL_WARNING, VLOG_OBSOLETECALLS_API, "API: GlobalCompact");

    return ORIGINAL_API(GlobalCompact)(dwUnknown);
}

void
APIHOOK(GlobalFix)(
    HGLOBAL hMem
    )
{
    VLOG(VLOG_LEVEL_WARNING, VLOG_OBSOLETECALLS_API, "API: GlobalFix");

    return ORIGINAL_API(GlobalFix)(hMem);
}

UINT
APIHOOK(GlobalFlags)(
    HGLOBAL hMem
    )
{
    VLOG(VLOG_LEVEL_WARNING, VLOG_OBSOLETECALLS_API, "API: GlobalFlags");

    return ORIGINAL_API(GlobalFlags)(hMem);
}

HGLOBAL
APIHOOK(GlobalFree)(
    HGLOBAL hMem
    )
{
    VLOG(VLOG_LEVEL_WARNING, VLOG_OBSOLETECALLS_API, "API: GlobalFree");

    return ORIGINAL_API(GlobalFree)(hMem);
}

HGLOBAL
APIHOOK(GlobalHandle)(
    LPCVOID pMem
    )
{
    VLOG(VLOG_LEVEL_WARNING, VLOG_OBSOLETECALLS_API, "API: GlobalHandle");

    return ORIGINAL_API(GlobalHandle)(pMem);
}

LPVOID
APIHOOK(GlobalLock)(
    HGLOBAL hMem
    )
{
    VLOG(VLOG_LEVEL_WARNING, VLOG_OBSOLETECALLS_API, "API: GlobalLock");

    return ORIGINAL_API(GlobalLock)(hMem);
}

HGLOBAL
APIHOOK(GlobalReAlloc)(
    HGLOBAL hMem,
    SIZE_T  dwBytes,
    UINT    uFlags
    )
{
    VLOG(VLOG_LEVEL_WARNING, VLOG_OBSOLETECALLS_API, "API: GlobalReAlloc");

    return ORIGINAL_API(GlobalReAlloc)(hMem, dwBytes, uFlags);
}

SIZE_T
APIHOOK(GlobalSize)(
    HGLOBAL hMem
    )
{
    VLOG(VLOG_LEVEL_WARNING, VLOG_OBSOLETECALLS_API, "API: GlobalSize");

    return ORIGINAL_API(GlobalSize)(hMem);
}

void
APIHOOK(GlobalUnfix)(
    HGLOBAL hMem
    )
{
    VLOG(VLOG_LEVEL_WARNING, VLOG_OBSOLETECALLS_API, "API: GlobalUnfix");

    return ORIGINAL_API(GlobalUnfix)(hMem);
}

BOOL
APIHOOK(GlobalUnlock)(
    HGLOBAL hMem
    )
{
    VLOG(VLOG_LEVEL_WARNING, VLOG_OBSOLETECALLS_API, "API: GlobalUnlock");

    return ORIGINAL_API(GlobalUnlock)(hMem);
}

BOOL
APIHOOK(GlobalUnWire)(
    HGLOBAL hMem
    )
{
    VLOG(VLOG_LEVEL_WARNING, VLOG_OBSOLETECALLS_API, "API: GlobalUnWire");

    return ORIGINAL_API(GlobalUnWire)(hMem);
}

char FAR*
APIHOOK(GlobalWire)(
    HGLOBAL hMem
    )
{
    VLOG(VLOG_LEVEL_WARNING, VLOG_OBSOLETECALLS_API, "API: GlobalWire");

    return ORIGINAL_API(GlobalWire)(hMem);
}

BOOL
APIHOOK(IsBadHugeReadPtr)(
    const void _huge* lp,
    DWORD cb
    )
{
    VLOG(VLOG_LEVEL_WARNING, VLOG_OBSOLETECALLS_API, "API: IsBadHugeReadPtr");

    return ORIGINAL_API(IsBadHugeReadPtr)(lp, cb);
}

BOOL
APIHOOK(IsBadHugeWritePtr)(
    const void _huge* lp,
    DWORD cb
    )
{
    VLOG(VLOG_LEVEL_WARNING, VLOG_OBSOLETECALLS_API, "API: IsBadHugeWritePtr");

    return ORIGINAL_API(IsBadHugeWritePtr)(lp, cb);
}

DWORD
APIHOOK(LoadModule)(
    LPCSTR lpModuleName,
    LPVOID lpParameterBlock
    )
{
    VLOG(VLOG_LEVEL_WARNING, VLOG_OBSOLETECALLS_API, "API: LoadModule");

    return ORIGINAL_API(LoadModule)(lpModuleName, lpParameterBlock);
}

HLOCAL
APIHOOK(LocalAlloc)(
    UINT   uFlags,
    SIZE_T uBytes
    )
{
    VLOG(VLOG_LEVEL_WARNING, VLOG_OBSOLETECALLS_API, "API: LocalAlloc");

    return ORIGINAL_API(LocalAlloc)(uFlags, uBytes);
}

UINT
APIHOOK(LocalCompact)(
    UINT uUnknown
    )
{
    VLOG(VLOG_LEVEL_WARNING, VLOG_OBSOLETECALLS_API, "API: LocalCompact");

    return ORIGINAL_API(LocalCompact)(uUnknown);
}

HLOCAL
APIHOOK(LocalDiscard)(
    HLOCAL hlocMem
    )
{
    VLOG(VLOG_LEVEL_WARNING, VLOG_OBSOLETECALLS_API, "API: LocalDiscard");

    return ORIGINAL_API(LocalDiscard)(hlocMem);
}

UINT
APIHOOK(LocalFlags)(
    HLOCAL hMem
    )
{
    VLOG(VLOG_LEVEL_WARNING, VLOG_OBSOLETECALLS_API, "API: LocalFlags");

    return ORIGINAL_API(LocalFlags)(hMem);
}

HLOCAL
APIHOOK(LocalFree)(
    HLOCAL hMem
    )
{
    VLOG(VLOG_LEVEL_WARNING, VLOG_OBSOLETECALLS_API, "API: LocalFree");

    return ORIGINAL_API(LocalFree)(hMem);
}

HLOCAL
APIHOOK(LocalHandle)(
    LPCVOID pMem
    )
{
    VLOG(VLOG_LEVEL_WARNING, VLOG_OBSOLETECALLS_API, "API: LocalHandle");

    return ORIGINAL_API(LocalHandle)(pMem);
}

LPVOID
APIHOOK(LocalLock)(
    HLOCAL hMem
    )
{
    VLOG(VLOG_LEVEL_WARNING, VLOG_OBSOLETECALLS_API, "API: LocalLock");

    return ORIGINAL_API(LocalLock)(hMem);
}

HLOCAL
APIHOOK(LocalReAlloc)(
    HLOCAL hMem,
    SIZE_T uBytes,
    UINT   uFlags
    )
{
    VLOG(VLOG_LEVEL_WARNING, VLOG_OBSOLETECALLS_API, "API: LocalReAlloc");

    return ORIGINAL_API(LocalReAlloc)(hMem, uBytes, uFlags);
}

UINT
APIHOOK(LocalShrink)(
    HLOCAL hMem,
    UINT   uUnknown
    )
{
    VLOG(VLOG_LEVEL_WARNING, VLOG_OBSOLETECALLS_API, "API: LocalShrink");

    return ORIGINAL_API(LocalShrink)(hMem, uUnknown);
}

UINT
APIHOOK(LocalSize)(
    HLOCAL hMem
    )
{
    VLOG(VLOG_LEVEL_WARNING, VLOG_OBSOLETECALLS_API, "API: LocalSize");

    return ORIGINAL_API(LocalSize)(hMem);
}

BOOL
APIHOOK(LocalUnlock)(
    HLOCAL hMem
    )
{
    VLOG(VLOG_LEVEL_WARNING, VLOG_OBSOLETECALLS_API, "API: LocalUnlock");

    return ORIGINAL_API(LocalUnlock)(hMem);
}

void
APIHOOK(LZDone)(
    void
    )
{
    VLOG(VLOG_LEVEL_WARNING, VLOG_OBSOLETECALLS_API, "API: LZDone");

    return ORIGINAL_API(LZDone)();
}

int
APIHOOK(LZStart)(
    void
    )
{
    VLOG(VLOG_LEVEL_WARNING, VLOG_OBSOLETECALLS_API, "API: LZStart");

    return ORIGINAL_API(LZStart)();
}

HFILE
APIHOOK(OpenFile)(
    LPCSTR     lpFileName,
    LPOFSTRUCT lpReOpenBuff,
    UINT       uStyle
    )
{
    VLOG(VLOG_LEVEL_WARNING, VLOG_OBSOLETECALLS_API, "API: OpenFile");

    return ORIGINAL_API(OpenFile)(lpFileName, lpReOpenBuff, uStyle);
}

BOOL
APIHOOK(PlayMetaFile)(
    HDC       hdc,
    HMETAFILE hmf
    )
{
    VLOG(VLOG_LEVEL_WARNING, VLOG_OBSOLETECALLS_API, "API: PlayMetaFile");

    return ORIGINAL_API(PlayMetaFile)(hdc, hmf);
}

BOOL
APIHOOK(PlayMetaFileRecord)(
    HDC           hdc,
    LPHANDLETABLE lpHandletable,
    LPMETARECORD  lpMetaRecord,
    UINT          nHandles
    )
{
    VLOG(VLOG_LEVEL_WARNING, VLOG_OBSOLETECALLS_API, "API: PlayMetaFileRecord");

    return ORIGINAL_API(PlayMetaFileRecord)(hdc, lpHandletable, lpMetaRecord, nHandles);
}

DWORD
APIHOOK(PrinterMessageBoxA)(
    HANDLE hPrinter,
    DWORD  Error,
    HWND   hWnd,
    LPSTR  pText,
    LPSTR  pCaption,
    DWORD  dwType
    )
{
    VLOG(VLOG_LEVEL_WARNING, VLOG_OBSOLETECALLS_API, "API: PrinterMessageBoxA");

    return ORIGINAL_API(PrinterMessageBoxA)(hPrinter, Error, hWnd, pText, pCaption, dwType);
}

DWORD
APIHOOK(PrinterMessageBoxW)(
    HANDLE hPrinter,
    DWORD  Error,
    HWND   hWnd,
    LPWSTR  pText,
    LPWSTR  pCaption,
    DWORD  dwType
    )
{
    VLOG(VLOG_LEVEL_WARNING, VLOG_OBSOLETECALLS_API, "API: PrinterMessageBoxW");

    return ORIGINAL_API(PrinterMessageBoxW)(hPrinter, Error, hWnd, pText, pCaption, dwType);
}

LONG
APIHOOK(RegCreateKeyA)(
    HKEY   hKey,
    LPCSTR lpSubKey,
    PHKEY  phkResult
    )
{
    VLOG(VLOG_LEVEL_WARNING, VLOG_OBSOLETECALLS_API, "API: RegCreateKeyA");

    return ORIGINAL_API(RegCreateKeyA)(hKey, lpSubKey, phkResult);
}

LONG
APIHOOK(RegCreateKeyW)(
    HKEY    hKey,
    LPCWSTR lpSubKey,
    PHKEY   phkResult
    )
{
    VLOG(VLOG_LEVEL_WARNING, VLOG_OBSOLETECALLS_API, "API: RegCreateKeyW");

    return ORIGINAL_API(RegCreateKeyW)(hKey, lpSubKey, phkResult);
}

LONG
APIHOOK(RegEnumKeyA)(
    HKEY  hKey,
    DWORD dwIndex,
    LPSTR lpName,
    DWORD cchName
    )
{
    VLOG(VLOG_LEVEL_WARNING, VLOG_OBSOLETECALLS_API, "API: RegEnumKeyA");

    return ORIGINAL_API(RegEnumKeyA)(hKey, dwIndex, lpName, cchName);
}

LONG
APIHOOK(RegEnumKeyW)(
    HKEY   hKey,
    DWORD  dwIndex,
    LPWSTR lpName,
    DWORD  cchName
    )
{
    VLOG(VLOG_LEVEL_WARNING, VLOG_OBSOLETECALLS_API, "API: RegEnumKeyW");

    return ORIGINAL_API(RegEnumKeyW)(hKey, dwIndex, lpName, cchName);
}

LONG 
APIHOOK(RegOpenKeyA)(
    HKEY  hKey,         
    LPSTR lpSubKey,  
    PHKEY phkResult
    )
{
    VLOG(VLOG_LEVEL_WARNING, VLOG_OBSOLETECALLS_API, "API: RegOpenKeyA");

    return ORIGINAL_API(RegOpenKeyA)(hKey, lpSubKey, phkResult);
}

LONG 
APIHOOK(RegOpenKeyW)(
    HKEY   hKey,         
    LPWSTR lpSubKey,  
    PHKEY  phkResult
    )
{
    VLOG(VLOG_LEVEL_WARNING, VLOG_OBSOLETECALLS_API, "API: RegOpenKeyW");

    return ORIGINAL_API(RegOpenKeyW)(hKey, lpSubKey, phkResult);
}

LONG 
APIHOOK(RegQueryValueA)(
    HKEY   hKey,
    LPCSTR lpSubKey,
    LPSTR  lpValue,
    PLONG  lpcbValue
    )
{
    VLOG(VLOG_LEVEL_WARNING, VLOG_OBSOLETECALLS_API, "API: RegQueryValueA");

    return ORIGINAL_API(RegQueryValueA)(hKey, lpSubKey, lpValue, lpcbValue);
}

LONG 
APIHOOK(RegQueryValueW)(
    HKEY    hKey,
    LPCWSTR lpSubKey,
    LPWSTR  lpValue,
    PLONG   lpcbValue
    )
{
    VLOG(VLOG_LEVEL_WARNING, VLOG_OBSOLETECALLS_API, "API: RegQueryValueW");

    return ORIGINAL_API(RegQueryValueW)(hKey, lpSubKey, lpValue, lpcbValue);
}

LONG      
APIHOOK(RegSetValueA)(
    HKEY   hKey, 
    LPCSTR lpSubKey, 
    DWORD  dwType, 
    LPCSTR lpData, 
    DWORD  cbData
    )
{
    VLOG(VLOG_LEVEL_WARNING, VLOG_OBSOLETECALLS_API, "API: RegSetValueA");

    return ORIGINAL_API(RegSetValueA)(hKey, lpSubKey, dwType, lpData, cbData);
}

LONG      
APIHOOK(RegSetValueW)(
    HKEY    hKey, 
    LPCWSTR lpSubKey, 
    DWORD   dwType, 
    LPCWSTR lpData, 
    DWORD   cbData
    )
{
    VLOG(VLOG_LEVEL_WARNING, VLOG_OBSOLETECALLS_API, "API: RegSetValueW");

    return ORIGINAL_API(RegSetValueW)(hKey, lpSubKey, dwType, lpData, cbData);
}

LONG
APIHOOK(SetBitmapBits)(
    HBITMAP    hbmp,
    DWORD      cBytes,
    CONST VOID *lpBits
    )
{
    VLOG(VLOG_LEVEL_WARNING, VLOG_OBSOLETECALLS_API, "API: SetBitmapBits");

    return ORIGINAL_API(SetBitmapBits)(hbmp, cBytes, lpBits);
}

WORD
APIHOOK(SetClassWord)(
    HWND hWnd,
    int  nIndex,
    WORD wNewWord
    )
{
    VLOG(VLOG_LEVEL_WARNING, VLOG_OBSOLETECALLS_API, "API: SetClassWord");

    return ORIGINAL_API(SetClassWord)(hWnd, nIndex, wNewWord);
}

void
APIHOOK(SetDebugErrorLevel)(
    DWORD dwLevel
    )
{
    VLOG(VLOG_LEVEL_WARNING, VLOG_OBSOLETECALLS_API, "API: SetDebugErrorLevel");

    return ORIGINAL_API(SetDebugErrorLevel)(dwLevel);
}

BOOL
APIHOOK(SetMessageQueue)(
    int nUnknown
    )
{
    VLOG(VLOG_LEVEL_WARNING, VLOG_OBSOLETECALLS_API, "API: SetMessageQueue");

    return ORIGINAL_API(SetMessageQueue)(nUnknown);
}

HMETAFILE
APIHOOK(SetMetaFileBitsEx)(
    UINT       nSize,
    CONST BYTE *lpData
    )
{
    VLOG(VLOG_LEVEL_WARNING, VLOG_OBSOLETECALLS_API, "API: SetMetaFileBitsEx");

    return ORIGINAL_API(SetMetaFileBitsEx)(nSize, lpData);
}

HWND
APIHOOK(SetSysModalWindow)(
    HWND hWnd
    )
{
    VLOG(VLOG_LEVEL_WARNING, VLOG_OBSOLETECALLS_API, "API: SetSysModalWindow");

    return ORIGINAL_API(SetSysModalWindow)(hWnd);
}

HHOOK
APIHOOK(SetWindowsHookA)(
    int      idHook,
    HOOKPROC lpfn
    )
{
    VLOG(VLOG_LEVEL_WARNING, VLOG_OBSOLETECALLS_API, "API: SetWindowsHookA");

    return ORIGINAL_API(SetWindowsHookA)(idHook, lpfn);
}

HHOOK
APIHOOK(SetWindowsHookW)(
    int      idHook,
    HOOKPROC lpfn
    )
{
    VLOG(VLOG_LEVEL_WARNING, VLOG_OBSOLETECALLS_API, "API: SetWindowsHookW");

    return ORIGINAL_API(SetWindowsHookW)(idHook, lpfn);
}

WORD
APIHOOK(SetWindowWord)(
    HWND hWnd,
    int  nUnknown,
    WORD wUnknown
    )
{
    VLOG(VLOG_LEVEL_WARNING, VLOG_OBSOLETECALLS_API, "API: SetWindowWord");

    return ORIGINAL_API(SetWindowWord)(hWnd, nUnknown, wUnknown);
}

BOOL
APIHOOK(UnhookWindowsHook)(
    int      idHook,
    HOOKPROC lpfn
    )
{
    VLOG(VLOG_LEVEL_WARNING, VLOG_OBSOLETECALLS_API, "API: UnhookWindowsHook");

    return ORIGINAL_API(UnhookWindowsHook)(idHook, lpfn);
}

DWORD
APIHOOK(WaitForPrinterChange)(
    HANDLE hPrinter,
    DWORD  Flags
    )
{
    VLOG(VLOG_LEVEL_WARNING, VLOG_OBSOLETECALLS_API, "API: WaitForPrinterChange");

    return ORIGINAL_API(WaitForPrinterChange)(hPrinter, Flags);
}

UINT
APIHOOK(WinExec)(
    LPCSTR lpCmdLine,
    UINT   uCmdShow
    )
{
    VLOG(VLOG_LEVEL_WARNING, VLOG_OBSOLETECALLS_API, "API: WinExec");

    return ORIGINAL_API(WinExec)(lpCmdLine, uCmdShow);
}

DWORD
APIHOOK(WNetAddConnectionA)(
    LPCSTR lpRemoteName,
    LPCSTR lpPassword,
    LPCSTR lpLocalName
    )
{
    VLOG(VLOG_LEVEL_WARNING, VLOG_OBSOLETECALLS_API, "API: WNetAddConnectionA");

    return ORIGINAL_API(WNetAddConnectionA)(lpRemoteName, lpPassword, lpLocalName);
}

DWORD
APIHOOK(WNetAddConnectionW)(
    LPCWSTR lpRemoteName,
    LPCWSTR lpPassword,
    LPCWSTR lpLocalName
    )
{
    VLOG(VLOG_LEVEL_WARNING, VLOG_OBSOLETECALLS_API, "API: WNetAddConnectionW");

    return ORIGINAL_API(WNetAddConnectionW)(lpRemoteName, lpPassword, lpLocalName);
}

BOOL
APIHOOK(WritePrivateProfileSectionA)(
    LPCSTR lpAppName,
    LPCSTR lpString,
    LPCSTR lpFileName
    )
{
    VLOG(VLOG_LEVEL_WARNING, VLOG_OBSOLETECALLS_API, "API: WritePrivateProfileSectionA");

    return ORIGINAL_API(WritePrivateProfileSectionA)(lpAppName, lpString, lpFileName);
}

BOOL
APIHOOK(WritePrivateProfileSectionW)(
    LPCWSTR lpAppName,
    LPCWSTR lpString,
    LPCWSTR lpFileName
    )
{
    VLOG(VLOG_LEVEL_WARNING, VLOG_OBSOLETECALLS_API, "API: WritePrivateProfileSectionW");

    return ORIGINAL_API(WritePrivateProfileSectionW)(lpAppName, lpString, lpFileName);
}

BOOL
APIHOOK(WritePrivateProfileStringA)(
    LPCSTR lpAppName,
    LPCSTR lpKeyName,
    LPCSTR lpString,
    LPCSTR lpFileName
    )
{
    VLOG(VLOG_LEVEL_WARNING, VLOG_OBSOLETECALLS_API, "API: WritePrivateProfileStringA");

    return ORIGINAL_API(WritePrivateProfileStringA)(lpAppName, lpKeyName,
                                                    lpString, lpFileName);
}

BOOL
APIHOOK(WritePrivateProfileStringW)(
    LPCWSTR lpAppName,
    LPCWSTR lpKeyName,
    LPCWSTR lpString,
    LPCWSTR lpFileName
    )
{
    VLOG(VLOG_LEVEL_WARNING, VLOG_OBSOLETECALLS_API, "API: WritePrivateProfileStringW");

    return ORIGINAL_API(WritePrivateProfileStringW)(lpAppName, lpKeyName,
                                                    lpString, lpFileName);
}

BOOL
APIHOOK(WritePrivateProfileStructA)(
    LPCSTR lpszSection,
    LPCSTR lpszKey,
    LPVOID lpStruct,
    UINT   uSizeStruct,
    LPCSTR szFile
    )
{
    VLOG(VLOG_LEVEL_WARNING, VLOG_OBSOLETECALLS_API, "API: WritePrivateProfileStructA");

    return ORIGINAL_API(WritePrivateProfileStructA)(lpszSection, lpszKey, lpStruct,
                                                    uSizeStruct, szFile);
}

BOOL
APIHOOK(WritePrivateProfileStructW)(
    LPCWSTR lpszSection,
    LPCWSTR lpszKey,
    LPVOID  lpStruct,
    UINT    uSizeStruct,
    LPCWSTR szFile
    )
{
    VLOG(VLOG_LEVEL_WARNING, VLOG_OBSOLETECALLS_API, "API: WritePrivateProfileStructW");

    return ORIGINAL_API(WritePrivateProfileStructW)(lpszSection, lpszKey, lpStruct,
                                                    uSizeStruct, szFile);
}

BOOL
APIHOOK(WriteProfileSectionA)(
    LPCSTR lpAppName,
    LPCSTR lpString
    )
{
    VLOG(VLOG_LEVEL_WARNING, VLOG_OBSOLETECALLS_API, "API: WriteProfileSectionA");

    return ORIGINAL_API(WriteProfileSectionA)(lpAppName, lpString);
}

BOOL
APIHOOK(WriteProfileSectionW)(
    LPCWSTR lpAppName,
    LPCWSTR lpString
    )
{
    VLOG(VLOG_LEVEL_WARNING, VLOG_OBSOLETECALLS_API, "API: WriteProfileSectionW");

    return ORIGINAL_API(WriteProfileSectionW)(lpAppName, lpString);
}

BOOL
APIHOOK(WriteProfileStringA)(
    LPCSTR lpAppName,
    LPCSTR lpKeyName,
    LPCSTR lpString
    )
{
    VLOG(VLOG_LEVEL_WARNING, VLOG_OBSOLETECALLS_API, "API: WriteProfileStringA");

    return ORIGINAL_API(WriteProfileStringA)(lpAppName, lpKeyName, lpString);
}

BOOL
APIHOOK(WriteProfileStringW)(
    LPCWSTR lpAppName,
    LPCWSTR lpKeyName,
    LPCWSTR lpString
    )
{
    VLOG(VLOG_LEVEL_WARNING, VLOG_OBSOLETECALLS_API, "API: WriteProfileStringW");

    return ORIGINAL_API(WriteProfileStringW)(lpAppName, lpKeyName, lpString);
}

SHIM_INFO_BEGIN()

    SHIM_INFO_DESCRIPTION(AVS_OBSOLETECALLS_DESC)
    SHIM_INFO_FRIENDLY_NAME(AVS_OBSOLETECALLS_FRIENDLY)
    SHIM_INFO_VERSION(2, 0)
    SHIM_INFO_INCLUDE_EXCLUDE("I:*")
    
SHIM_INFO_END()

/*++

 Register hooked functions

--*/

HOOK_BEGIN

    DUMP_VERIFIER_LOG_ENTRY(VLOG_OBSOLETECALLS_API, 
                            AVS_OBSOLETECALLS_API,
                            AVS_OBSOLETECALLS_API_R,
                            AVS_OBSOLETECALLS_API_URL)

    APIHOOK_ENTRY(KERNEL32.DLL,                                 _hread)
    APIHOOK_ENTRY(KERNEL32.DLL,                                _hwrite)
    APIHOOK_ENTRY(KERNEL32.DLL,                                _lclose)
    APIHOOK_ENTRY(KERNEL32.DLL,                                _lcreat)
    APIHOOK_ENTRY(KERNEL32.DLL,                                _llseek)
    APIHOOK_ENTRY(KERNEL32.DLL,                                 _lopen)
    APIHOOK_ENTRY(KERNEL32.DLL,                                 _lread)
    APIHOOK_ENTRY(KERNEL32.DLL,                                _lwrite)
    APIHOOK_ENTRY(USER32.DLL,                                 AnyPopup)
    APIHOOK_ENTRY(GDI32.DLL,                             CloseMetaFile)
    APIHOOK_ENTRY(LZ32.DLL,                                 CopyLZFile)
    APIHOOK_ENTRY(GDI32.DLL,                             CopyMetaFileA)
    APIHOOK_ENTRY(GDI32.DLL,                             CopyMetaFileW)
    APIHOOK_ENTRY(GDI32.DLL,                     CreateDIBPatternBrush)
    APIHOOK_ENTRY(GDI32.DLL,                   CreateDiscardableBitmap)
    APIHOOK_ENTRY(GDI32.DLL,                           CreateMetaFileA)
    APIHOOK_ENTRY(GDI32.DLL,                           CreateMetaFileW)
    APIHOOK_ENTRY(GDI32.DLL,                            DeleteMetaFile)
    APIHOOK_ENTRY(GDI32.DLL,                         EnumFontFamiliesA)
    APIHOOK_ENTRY(GDI32.DLL,                         EnumFontFamiliesW)
    APIHOOK_ENTRY(GDI32.DLL,                           EnumFontFamProc)
    APIHOOK_ENTRY(GDI32.DLL,                                EnumFontsA)
    APIHOOK_ENTRY(GDI32.DLL,                                EnumFontsW)
    APIHOOK_ENTRY(GDI32.DLL,                             EnumFontsProc)
    APIHOOK_ENTRY(GDI32.DLL,                              EnumMetaFile)
    APIHOOK_ENTRY(GDI32.DLL,                          EnumMetaFileProc)
    APIHOOK_ENTRY(GDI32.DLL,                             FixBrushOrgEx)
    APIHOOK_ENTRY(GDI32.DLL,                                 FloodFill)
    APIHOOK_ENTRY(KERNEL32.DLL,                           FreeResource)
    APIHOOK_ENTRY(GDI32.DLL,                             GetBitmapBits)
    APIHOOK_ENTRY(GDI32.DLL,                             GetCharWidthA)
    APIHOOK_ENTRY(GDI32.DLL,                             GetCharWidthW)
    APIHOOK_ENTRY(USER32.DLL,                             GetClassWord)
    APIHOOK_ENTRY(USER32.DLL,                            GetKBCodePage)
    APIHOOK_ENTRY(GDI32.DLL,                              GetMetaFileA)
    APIHOOK_ENTRY(GDI32.DLL,                              GetMetaFileW)
    APIHOOK_ENTRY(GDI32.DLL,                         GetMetaFileBitsEx)
    APIHOOK_ENTRY(KERNEL32.DLL,                  GetPrivateProfileIntA)
    APIHOOK_ENTRY(KERNEL32.DLL,                  GetPrivateProfileIntW)
    APIHOOK_ENTRY(KERNEL32.DLL,              GetPrivateProfileSectionA)
    APIHOOK_ENTRY(KERNEL32.DLL,              GetPrivateProfileSectionW)
    APIHOOK_ENTRY(KERNEL32.DLL,         GetPrivateProfileSectionNamesA)
    APIHOOK_ENTRY(KERNEL32.DLL,         GetPrivateProfileSectionNamesW)
    APIHOOK_ENTRY(KERNEL32.DLL,               GetPrivateProfileStringA)
    APIHOOK_ENTRY(KERNEL32.DLL,               GetPrivateProfileStringW)
    APIHOOK_ENTRY(KERNEL32.DLL,               GetPrivateProfileStructA)
    APIHOOK_ENTRY(KERNEL32.DLL,               GetPrivateProfileStructW)
    APIHOOK_ENTRY(KERNEL32.DLL,                         GetProfileIntA)
    APIHOOK_ENTRY(KERNEL32.DLL,                         GetProfileIntW)
    APIHOOK_ENTRY(KERNEL32.DLL,                     GetProfileSectionA)
    APIHOOK_ENTRY(KERNEL32.DLL,                     GetProfileSectionW)
    APIHOOK_ENTRY(KERNEL32.DLL,                      GetProfileStringA)
    APIHOOK_ENTRY(KERNEL32.DLL,                      GetProfileStringW)
    APIHOOK_ENTRY(USER32.DLL,                        GetSysModalWindow)
    APIHOOK_ENTRY(GDI32.DLL,                       GetTextExtentPointA)
    APIHOOK_ENTRY(GDI32.DLL,                       GetTextExtentPointW)
    APIHOOK_ENTRY(USER32.DLL,                            GetWindowWord)
    APIHOOK_ENTRY(KERNEL32.DLL,                            GlobalAlloc)
    APIHOOK_ENTRY(KERNEL32.DLL,                          GlobalCompact)
    APIHOOK_ENTRY(KERNEL32.DLL,                              GlobalFix)
    APIHOOK_ENTRY(KERNEL32.DLL,                            GlobalFlags)
    APIHOOK_ENTRY(KERNEL32.DLL,                             GlobalFree)
    APIHOOK_ENTRY(KERNEL32.DLL,                           GlobalHandle)
    APIHOOK_ENTRY(KERNEL32.DLL,                             GlobalLock)
    APIHOOK_ENTRY(KERNEL32.DLL,                          GlobalReAlloc)
    APIHOOK_ENTRY(KERNEL32.DLL,                             GlobalSize)
    APIHOOK_ENTRY(KERNEL32.DLL,                            GlobalUnfix)
    APIHOOK_ENTRY(KERNEL32.DLL,                           GlobalUnlock)
    APIHOOK_ENTRY(KERNEL32.DLL,                           GlobalUnWire)
    APIHOOK_ENTRY(KERNEL32.DLL,                             GlobalWire)
    APIHOOK_ENTRY(KERNEL32.DLL,                       IsBadHugeReadPtr)
    APIHOOK_ENTRY(KERNEL32.DLL,                      IsBadHugeWritePtr)
    APIHOOK_ENTRY(KERNEL32.DLL,                             LoadModule)
    APIHOOK_ENTRY(KERNEL32.DLL,                             LocalAlloc)
    APIHOOK_ENTRY(KERNEL32.DLL,                           LocalCompact)
    APIHOOK_ENTRY(KERNEL32.DLL,                           LocalDiscard)
    APIHOOK_ENTRY(KERNEL32.DLL,                             LocalFlags)
    APIHOOK_ENTRY(KERNEL32.DLL,                              LocalFree)
    APIHOOK_ENTRY(KERNEL32.DLL,                            LocalHandle)
    APIHOOK_ENTRY(KERNEL32.DLL,                              LocalLock)
    APIHOOK_ENTRY(KERNEL32.DLL,                           LocalReAlloc)
    APIHOOK_ENTRY(KERNEL32.DLL,                            LocalShrink)
    APIHOOK_ENTRY(KERNEL32.DLL,                              LocalSize)
    APIHOOK_ENTRY(KERNEL32.DLL,                            LocalUnlock)
    APIHOOK_ENTRY(LZ32.DLL,                                     LZDone)
    APIHOOK_ENTRY(LZ32.DLL,                                    LZStart)
    APIHOOK_ENTRY(KERNEL32.DLL,                               OpenFile)
    APIHOOK_ENTRY(GDI32.DLL,                              PlayMetaFile)
    APIHOOK_ENTRY(GDI32.DLL,                        PlayMetaFileRecord)
    APIHOOK_ENTRY(WINSPOOL.DRV,                     PrinterMessageBoxA)
    APIHOOK_ENTRY(WINSPOOL.DRV,                     PrinterMessageBoxW)
    APIHOOK_ENTRY(ADVAPI32.DLL,                          RegCreateKeyA)
    APIHOOK_ENTRY(ADVAPI32.DLL,                          RegCreateKeyW)
    APIHOOK_ENTRY(ADVAPI32.DLL,                            RegEnumKeyA)
    APIHOOK_ENTRY(ADVAPI32.DLL,                            RegEnumKeyW)
    APIHOOK_ENTRY(ADVAPI32.DLL,                            RegOpenKeyA)
    APIHOOK_ENTRY(ADVAPI32.DLL,                            RegOpenKeyW)
    APIHOOK_ENTRY(ADVAPI32.DLL,                         RegQueryValueA)
    APIHOOK_ENTRY(ADVAPI32.DLL,                         RegQueryValueW)
    APIHOOK_ENTRY(ADVAPI32.DLL,                           RegSetValueA)
    APIHOOK_ENTRY(ADVAPI32.DLL,                           RegSetValueW)
    APIHOOK_ENTRY(GDI32.DLL,                             SetBitmapBits)
    APIHOOK_ENTRY(USER32.DLL,                             SetClassWord)
    APIHOOK_ENTRY(USER32.DLL,                       SetDebugErrorLevel)
    APIHOOK_ENTRY(USER32.DLL,                          SetMessageQueue)
    APIHOOK_ENTRY(GDI32.DLL,                         SetMetaFileBitsEx)
    APIHOOK_ENTRY(USER32.DLL,                        SetSysModalWindow)
    APIHOOK_ENTRY(USER32.DLL,                          SetWindowsHookA)
    APIHOOK_ENTRY(USER32.DLL,                          SetWindowsHookW)
    APIHOOK_ENTRY(USER32.DLL,                            SetWindowWord)
    APIHOOK_ENTRY(USER32.DLL,                        UnhookWindowsHook)
    APIHOOK_ENTRY(WINSPOOL.DRV,                   WaitForPrinterChange)
    APIHOOK_ENTRY(KERNEL32.DLL,                                WinExec)
    APIHOOK_ENTRY(MPR.DLL,                          WNetAddConnectionA)
    APIHOOK_ENTRY(MPR.DLL,                          WNetAddConnectionW)
    APIHOOK_ENTRY(KERNEL32.DLL,            WritePrivateProfileSectionA)
    APIHOOK_ENTRY(KERNEL32.DLL,            WritePrivateProfileSectionW)
    APIHOOK_ENTRY(KERNEL32.DLL,             WritePrivateProfileStringA)
    APIHOOK_ENTRY(KERNEL32.DLL,             WritePrivateProfileStringW)
    APIHOOK_ENTRY(KERNEL32.DLL,             WritePrivateProfileStructA)
    APIHOOK_ENTRY(KERNEL32.DLL,             WritePrivateProfileStructW)
    APIHOOK_ENTRY(KERNEL32.DLL,                   WriteProfileSectionA)
    APIHOOK_ENTRY(KERNEL32.DLL,                   WriteProfileSectionW)
    APIHOOK_ENTRY(KERNEL32.DLL,                    WriteProfileStringA)
    APIHOOK_ENTRY(KERNEL32.DLL,                    WriteProfileStringW)

HOOK_END

IMPLEMENT_SHIM_END
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\appcompat\shims\verifier\registrychecks.cpp ===
/*++

 Copyright (c) 2001 Microsoft Corporation

 Module Name:

    RegistryChecks.cpp

 Abstract:
    Warn the app when it's trying to read from or write to inappropriate
    places in the registry.

 Notes:

    This is a general purpose shim.

 History:

    03/09/2001 maonis  Created
    09/04/2001 maonis  Since none of the paths we compare with exceed MAX_PATH - 1
                       characters, we only examine at most that many characters of 
                       the key paths to make sure there's no buffer overflow in 
                       the paths of open keys.
--*/

#include "precomp.h"

IMPLEMENT_SHIM_BEGIN(RegistryChecks)
#include "ShimHookMacro.h"
#include "RegistryChecks.h"

//
// verifier log entries
//
BEGIN_DEFINE_VERIFIER_LOG(RegistryChecks)
    VERIFIER_LOG_ENTRY(VLOG_HKCU_Console_READ)
    VERIFIER_LOG_ENTRY(VLOG_HKCU_ControlPanel_READ)
    VERIFIER_LOG_ENTRY(VLOG_HKCU_Environment_READ)
    VERIFIER_LOG_ENTRY(VLOG_HKCU_Identities_READ)
    VERIFIER_LOG_ENTRY(VLOG_HKCU_KeyboardLayout_READ)
    VERIFIER_LOG_ENTRY(VLOG_HKCU_Printers_READ)
    VERIFIER_LOG_ENTRY(VLOG_HKCU_RemoteAccess_READ)
    VERIFIER_LOG_ENTRY(VLOG_HKCU_SessionInformation_READ)
    VERIFIER_LOG_ENTRY(VLOG_HKCU_UNICODEProgramGroups_READ)
    VERIFIER_LOG_ENTRY(VLOG_HKCU_VolatileEnvironment_READ)
    VERIFIER_LOG_ENTRY(VLOG_HKCU_Windows31MigrationStatus_READ)
    VERIFIER_LOG_ENTRY(VLOG_HKLM_HARDWARE_READ)
    VERIFIER_LOG_ENTRY(VLOG_HKLM_SAM_READ)
    VERIFIER_LOG_ENTRY(VLOG_HKLM_SECURITY_READ)
    VERIFIER_LOG_ENTRY(VLOG_HKLM_SYSTEM_READ)
    VERIFIER_LOG_ENTRY(VLOG_HKCC_READ)
    VERIFIER_LOG_ENTRY(VLOG_HKUS_READ)
    VERIFIER_LOG_ENTRY(VLOG_NON_HKCU_WRITE)
END_DEFINE_VERIFIER_LOG(RegistryChecks)

INIT_VERIFIER_LOG(RegistryChecks);


const RCWARNING g_warnNoDirectRead[] = 
{
    {HKCU_Console_STR,                  VLOG_HKCU_Console_READ,                 NUM_OF_CHAR(HKCU_Console_STR)},
    {HKCU_ControlPanel_STR,             VLOG_HKCU_ControlPanel_READ,            NUM_OF_CHAR(HKCU_ControlPanel_STR)},
    {HKCU_Environment_STR,              VLOG_HKCU_Environment_READ,             NUM_OF_CHAR(HKCU_Environment_STR)},
    {HKCU_Identities_STR,               VLOG_HKCU_Identities_READ,              NUM_OF_CHAR(HKCU_Identities_STR)},
    {HKCU_KeyboardLayout_STR,           VLOG_HKCU_KeyboardLayout_READ,          NUM_OF_CHAR(HKCU_KeyboardLayout_STR)},
    {HKCU_Printers_STR,                 VLOG_HKCU_Printers_READ,                NUM_OF_CHAR(HKCU_Printers_STR)},
    {HKCU_RemoteAccess_STR,             VLOG_HKCU_RemoteAccess_READ,            NUM_OF_CHAR(HKCU_RemoteAccess_STR)},
    {HKCU_SessionInformation_STR,       VLOG_HKCU_SessionInformation_READ,      NUM_OF_CHAR(HKCU_SessionInformation_STR)},
    {HKCU_UNICODEProgramGroups_STR,     VLOG_HKCU_UNICODEProgramGroups_READ,    NUM_OF_CHAR(HKCU_UNICODEProgramGroups_STR)},
    {HKCU_VolatileEnvironment_STR,      VLOG_HKCU_VolatileEnvironment_READ,     NUM_OF_CHAR(HKCU_VolatileEnvironment_STR)},
    {HKCU_Windows31MigrationStatus_STR, VLOG_HKCU_Windows31MigrationStatus_READ,NUM_OF_CHAR(HKCU_Windows31MigrationStatus_STR)},
    {HKLM_HARDWARE_STR,                 VLOG_HKLM_HARDWARE_READ,                NUM_OF_CHAR(HKLM_HARDWARE_STR)},
    {HKLM_SAM_STR,                      VLOG_HKLM_SAM_READ,                     NUM_OF_CHAR(HKLM_SAM_STR)},
    {HKLM_SECURITY_STR,                 VLOG_HKLM_SECURITY_READ,                NUM_OF_CHAR(HKLM_SECURITY_STR)},
    {HKLM_SYSTEM_STR,                   VLOG_HKLM_SYSTEM_READ,                  NUM_OF_CHAR(HKLM_SYSTEM_STR)},
    {HKCC_STR,                          VLOG_HKCC_READ,                         NUM_OF_CHAR(HKCC_STR)},
    {HKUS_STR,                          VLOG_HKUS_READ,                         NUM_OF_CHAR(HKUS_STR)},
};

const UINT g_cWarnNDirectRead = sizeof(g_warnNoDirectRead) / sizeof(RCWARNING);

VOID
MakePathW(
    IN RCOPENKEY* key, 
    IN HKEY hKey,
    IN LPCWSTR lpSubKey, 
    IN OUT LPWSTR lpPath
    )
{
    if (key) {
        if (key->wszPath[0]) {
            //
            // We only care about at most MAX_PATH - 1 characters.
            //
            wcsncpy(lpPath, key->wszPath, MAX_PATH - 1);
        }
    } else {
        if (hKey == HKEY_CLASSES_ROOT) {
            wcscpy(lpPath, L"HKCR");
        } else if (hKey == HKEY_CURRENT_CONFIG) {
            wcscpy(lpPath, L"HKCC");
        } else if (hKey == HKEY_CURRENT_USER) {
            wcscpy(lpPath, L"HKCU");
        } else if (hKey == HKEY_LOCAL_MACHINE) {
            wcscpy(lpPath, L"HKLM");
        } else if (hKey == HKEY_USERS) {
            wcscpy(lpPath, L"HKUS");
        } else {
            wcscpy(lpPath, L"Not recognized");
        }
    }

    if (lpSubKey && *lpSubKey) {
        DWORD cLen = wcslen(lpPath);
        //
        // We only care about at most MAX_PATH - 1 characters.
        //
        if (cLen < MAX_PATH - 1) {
            lpPath[cLen] = L'\\';
            wcsncpy(lpPath + cLen + 1, lpSubKey, MAX_PATH - cLen - 2);
        }
    }

    lpPath[MAX_PATH - 1] = L'\0';
}

VOID CheckReading(
    IN LPCWSTR pwszPath
    )
{
    RCWARNING warn;

    for (UINT ui = 0; ui < g_cWarnNDirectRead; ++ui) {
        warn = g_warnNoDirectRead[ui];
        if (!_wcsnicmp(pwszPath, warn.wszPath, warn.cLen)) {
            VLOG(VLOG_LEVEL_ERROR, warn.dwAVStatus, "Read from dangerous registry entry '%ls'.", pwszPath);
        }
    }
}

// We warn for every tempt of writing to anything besides keys under HKCU.
// Note this applies to both Users and Admins/Power Users because when an 
// app is running it shouldn't write anything to non HKCU keys, which should
// be done during the installation time.
VOID CheckWriting(
    IN REGSAM samDesired,
    IN LPCWSTR pwszPath
    )
{
    if ((samDesired &~ STANDARD_RIGHTS_WRITE) & KEY_WRITE) {
        if (_wcsnicmp(pwszPath, L"HKCU", 4)) {
            VLOG(VLOG_LEVEL_ERROR, VLOG_NON_HKCU_WRITE, "Write to non-HKCU registry entry '%ls'.", pwszPath);
        }
    }
}

//
// simple locking.
//

static BOOL g_bInitialized = FALSE;

CRITICAL_SECTION g_csRegRedirect;

class CRRegLock
{
public:
    CRRegLock()
    {
        if (!g_bInitialized) {
            InitializeCriticalSection(&g_csRegRedirect);
            g_bInitialized = TRUE;            
        }

        EnterCriticalSection(&g_csRegRedirect);
    }
    ~CRRegLock()
    {
        LeaveCriticalSection(&g_csRegRedirect);
    }
};

//
// Implementation of the CRegistryChecks class.
//

RCOPENKEY* 
CRegistryChecks::FindKey(
    HKEY hKey
    )
{
    RCOPENKEY* key = keys;

    while (key) {
        if (key->hkBase == hKey) {
            return key;
        }

        key = key->next;
    }

    return NULL;
}

// We add the key to the front of the list because the most
// recently added keys are usually used/deleted first.
BOOL 
CRegistryChecks::AddKey(
    HKEY hKey,
    LPCWSTR pwszPath
    )
{
    RCOPENKEY* key = new RCOPENKEY;

    if (!key) {
        return FALSE;
    }

    key->hkBase = hKey;

    //
    // None of the key paths we need to check exceed MAX_PATH - 1 characters so
    // we only need to copy at most that many characters.
    //
    wcsncpy(key->wszPath, pwszPath, MAX_PATH - 1);
    key->wszPath[MAX_PATH - 1] = L'\0';

    key->next = keys;
    keys = key;

    return TRUE;
}

VOID 
CRegistryChecks::Check(    
    HKEY hKey,
    LPCSTR lpSubKey,
    BOOL fCheckRead,
    BOOL fCheckWrite,
    REGSAM samDesired
    )
{
    LPWSTR pwszSubKey = NULL;

    if (pwszSubKey = ToUnicode(lpSubKey)) {
        Check(hKey, pwszSubKey, fCheckRead, fCheckWrite);
        free(pwszSubKey);
    } else {
        DPFN(eDbgLevelError, "Failed to convert %s to unicode", lpSubKey);
    }
}

VOID 
CRegistryChecks::Check(    
    HKEY hKey,
    LPCWSTR lpSubKey,
    BOOL fCheckRead,
    BOOL fCheckWrite,
    REGSAM samDesired
    )
{
    RCOPENKEY* key = FindKey(hKey);
    WCHAR wszPath[MAX_PATH] = L"";
    MakePathW(key, hKey, lpSubKey, wszPath);

    if (fCheckRead) {
        CheckReading(wszPath);
    }

    if (fCheckWrite) {
        CheckWriting(samDesired, wszPath);
    }
}

LONG 
CRegistryChecks::OpenKeyExOriginalW(
    HKEY hKey,
    LPCWSTR lpSubKey,
    LPWSTR lpClass,
    DWORD dwOptions,
    REGSAM samDesired,
    LPSECURITY_ATTRIBUTES lpSecurityAttributes,
    PHKEY phkResult,
    LPDWORD lpdwDisposition,
    BOOL bCreate
    )
{
    if (bCreate) {
        return ORIGINAL_API(RegCreateKeyExW)(
            hKey, 
            lpSubKey,
            0,
            lpClass,
            dwOptions,
            samDesired,
            lpSecurityAttributes,
            phkResult,
            lpdwDisposition);
    } else {
        return ORIGINAL_API(RegOpenKeyExW)(
            hKey, 
            lpSubKey, 
            0, 
            samDesired, 
            phkResult);
    }
}

LONG 
CRegistryChecks::OpenKeyExA(
    HKEY hKey,
    LPCSTR lpSubKey,
    LPSTR lpClass,
    DWORD dwOptions,
    REGSAM samDesired,
    LPSECURITY_ATTRIBUTES lpSecurityAttributes,
    PHKEY phkResult,
    LPDWORD lpdwDisposition,
    BOOL bCreate
    )
{
    LONG lRet;
    LPWSTR pwszSubKey = NULL; 
    LPWSTR pwszClass = NULL;

    if (lpSubKey) {
        if (!(pwszSubKey = ToUnicode(lpSubKey))) {
            DPFN(eDbgLevelError, "Failed to convert %s to unicode", lpSubKey);
            return ERROR_NOT_ENOUGH_MEMORY;
        }
    }

    if (lpClass) {
        if (!(pwszClass = ToUnicode(lpClass)))
        {
            free(pwszSubKey);
            DPFN(eDbgLevelError, "Failed to convert %s to unicode", lpClass);
            return ERROR_NOT_ENOUGH_MEMORY;
        }
    }

    lRet = OpenKeyExW(
        hKey,
        pwszSubKey,
        pwszClass,
        dwOptions,
        samDesired,
        lpSecurityAttributes,
        phkResult,
        lpdwDisposition,
        bCreate);

    free(pwszSubKey);
    free(pwszClass);

    return lRet;
}

LONG 
CRegistryChecks::OpenKeyExW(
    HKEY hKey,
    LPCWSTR lpSubKey,
    LPWSTR lpClass,
    DWORD dwOptions,
    REGSAM samDesired,
    LPSECURITY_ATTRIBUTES lpSecurityAttributes,
    PHKEY phkResult,
    LPDWORD lpdwDisposition,
    BOOL bCreate
    )
{
    RCOPENKEY* key = FindKey(hKey);
    WCHAR wszPath[MAX_PATH] = L"";
    MakePathW(key, hKey, lpSubKey, wszPath);

    CheckReading(wszPath);
    CheckWriting(samDesired, wszPath);

    LONG lRes = OpenKeyExOriginalW(
        hKey,
        lpSubKey,
        lpClass,
        dwOptions,
        samDesired,
        lpSecurityAttributes,
        phkResult,
        lpdwDisposition,
        bCreate);

    if (lRes == ERROR_SUCCESS) {
        if (AddKey(*phkResult, wszPath)) {
            DPFN(eDbgLevelInfo, "[OpenKeyExW] success - adding key 0x%08x", *phkResult);
        } else {
            lRes = ERROR_INVALID_HANDLE;
        }            
    }

    return lRes;
}

LONG 
CRegistryChecks::QueryValueA(
    HKEY hKey,
    LPCSTR lpSubKey,
    LPSTR lpValue,
    PLONG lpcbValue
    )
{
    Check(hKey, lpSubKey, TRUE, FALSE);

    return ORIGINAL_API(RegQueryValueA)(
        hKey,
        lpSubKey,
        lpValue,
        lpcbValue);
}

LONG 
CRegistryChecks::QueryValueW(
    HKEY hKey,
    LPCWSTR lpSubKey,
    LPWSTR lpValue,
    PLONG lpcbValue
    )
{
    Check(hKey, lpSubKey, TRUE, FALSE);

    return ORIGINAL_API(RegQueryValueW)(
        hKey,
        lpSubKey,
        lpValue,
        lpcbValue);
}

LONG 
CRegistryChecks::QueryValueExA(
    HKEY    hKey,
    LPCSTR  lpValueName,
    LPDWORD lpReserved,
    LPDWORD lpType,
    LPBYTE  lpData,
    LPDWORD lpcbData
    )
{
    Check(hKey, L"", TRUE, FALSE);
    
    return ORIGINAL_API(RegQueryValueExA)(
        hKey, 
        lpValueName, 
        lpReserved,
        lpType, 
        lpData, 
        lpcbData);
}

LONG 
CRegistryChecks::QueryValueExW(
    HKEY    hKey,
    LPCWSTR lpValueName,
    LPDWORD lpReserved,
    LPDWORD lpType,
    LPBYTE  lpData,
    LPDWORD lpcbData
    )
{
    Check(hKey, L"", TRUE, FALSE);

    return ORIGINAL_API(RegQueryValueExW)(
        hKey, 
        lpValueName, 
        lpReserved,
        lpType, 
        lpData, 
        lpcbData);
}

LONG 
CRegistryChecks::QueryInfoKeyA(
    HKEY hKey,                
    LPSTR lpClass,           
    LPDWORD lpcbClass,        
    LPDWORD lpReserved,       
    LPDWORD lpcSubKeys,       
    LPDWORD lpcbMaxSubKeyLen, 
    LPDWORD lpcbMaxClassLen,  
    LPDWORD lpcValues,        
    LPDWORD lpcbMaxValueNameLen,
    LPDWORD lpcbMaxValueLen,  
    LPDWORD lpcbSecurityDescriptor,
    PFILETIME lpftLastWriteTime   
    )
{
    Check(hKey, L"", TRUE, FALSE);

    return ORIGINAL_API(RegQueryInfoKeyA)(
        hKey, 
        lpClass, 
        lpcbClass, 
        lpReserved,       
        lpcSubKeys,       
        lpcbMaxSubKeyLen, 
        lpcbMaxClassLen,  
        lpcValues,        
        lpcbMaxValueNameLen,
        lpcbMaxValueLen,  
        lpcbSecurityDescriptor,
        lpftLastWriteTime);
}

LONG 
CRegistryChecks::QueryInfoKeyW(
    HKEY hKey,                
    LPWSTR lpClass,           
    LPDWORD lpcbClass,        
    LPDWORD lpReserved,       
    LPDWORD lpcSubKeys,       
    LPDWORD lpcbMaxSubKeyLen, 
    LPDWORD lpcbMaxClassLen,  
    LPDWORD lpcValues,        
    LPDWORD lpcbMaxValueNameLen,
    LPDWORD lpcbMaxValueLen,  
    LPDWORD lpcbSecurityDescriptor,
    PFILETIME lpftLastWriteTime   
    )
{
    Check(hKey, L"", TRUE, FALSE);

    return ORIGINAL_API(RegQueryInfoKeyW)(
        hKey, 
        lpClass, 
        lpcbClass, 
        lpReserved,       
        lpcSubKeys,       
        lpcbMaxSubKeyLen, 
        lpcbMaxClassLen,  
        lpcValues,        
        lpcbMaxValueNameLen,
        lpcbMaxValueLen,  
        lpcbSecurityDescriptor,
        lpftLastWriteTime);
}

LONG 
CRegistryChecks::SetValueA(
    HKEY hKey,
    LPCSTR lpSubKey,
    DWORD dwType,
    LPCSTR lpData,
    DWORD cbData
    )
{
    Check(hKey, lpSubKey, FALSE, TRUE, KEY_WRITE);

    return ORIGINAL_API(RegSetValueA)(
        hKey,
        lpSubKey,
        dwType,
        lpData,
        cbData);
}

LONG 
CRegistryChecks::SetValueW(
    HKEY hKey,
    LPCWSTR lpSubKey,
    DWORD dwType,
    LPCWSTR lpData,
    DWORD cbData
    )
{
    Check(hKey, lpSubKey, FALSE, TRUE, KEY_WRITE);

    return ORIGINAL_API(RegSetValueW)(
        hKey,
        lpSubKey,
        dwType,
        lpData,
        cbData);
}

LONG 
CRegistryChecks::SetValueExA(
    HKEY hKey, 
    LPCSTR lpValueName, 
    DWORD Reserved, 
    DWORD dwType, 
    CONST BYTE * lpData, 
    DWORD cbData
    )
{
    Check(hKey, L"", FALSE, TRUE, KEY_WRITE);
    
    return ORIGINAL_API(RegSetValueExA)(
        hKey,
        lpValueName,
        Reserved,
        dwType,
        lpData,
        cbData);
}

LONG 
CRegistryChecks::SetValueExW(
    HKEY hKey, 
    LPCWSTR lpValueName, 
    DWORD Reserved, 
    DWORD dwType, 
    CONST BYTE * lpData, 
    DWORD cbData
    )
{
    Check(hKey, L"", FALSE, TRUE, KEY_WRITE);
    
    return ORIGINAL_API(RegSetValueExW)(
        hKey,
        lpValueName,
        Reserved,
        dwType,
        lpData,
        cbData);
}

LONG 
CRegistryChecks::EnumValueA(
    HKEY hKey,
    DWORD dwIndex,
    LPSTR lpValueName,
    LPDWORD lpcbValueName,
    LPDWORD lpReserved,
    LPDWORD lpType,
    LPBYTE lpData,
    LPDWORD lpcbData
    )
{
    Check(hKey, L"", TRUE, FALSE);

    return ORIGINAL_API(RegEnumValueA)(
        hKey,
        dwIndex,
        lpValueName,
        lpcbValueName,
        lpReserved,
        lpType,
        lpData,      
        lpcbData);
}

// If the key was not originated from HKCU,
// we enum at the original location.
LONG 
CRegistryChecks::EnumValueW(
    HKEY hKey,
    DWORD dwIndex,
    LPWSTR lpValueName,
    LPDWORD lpcbValueName,
    LPDWORD lpReserved,
    LPDWORD lpType,
    LPBYTE lpData,
    LPDWORD lpcbData
    )
{
    Check(hKey, L"", TRUE, FALSE);

    return ORIGINAL_API(RegEnumValueW)(
        hKey,
        dwIndex,
        lpValueName,
        lpcbValueName,
        lpReserved,
        lpType,
        lpData,      
        lpcbData);
}

LONG 
CRegistryChecks::EnumKeyExA(
    HKEY hKey,
    DWORD dwIndex,
    LPSTR lpName,
    LPDWORD lpcbName,
    LPDWORD lpReserved,
    LPSTR lpClass,
    LPDWORD lpcbClass,
    PFILETIME lpftLastWriteTime 
    )
{
    Check(hKey, L"", TRUE, FALSE);

    return ORIGINAL_API(RegEnumKeyExA)(
        hKey,
        dwIndex,
        lpName,
        lpcbName,
        lpReserved,
        lpClass,
        lpcbClass,
        lpftLastWriteTime);
}

// If the key was not originated from HKCU,
// we enum at the original location.
LONG 
CRegistryChecks::EnumKeyExW(
    HKEY hKey,
    DWORD dwIndex,
    LPWSTR lpName,
    LPDWORD lpcbName,
    LPDWORD lpReserved,
    LPWSTR lpClass,
    LPDWORD lpcbClass,
    PFILETIME lpftLastWriteTime 
    )
{
    Check(hKey, L"", TRUE, FALSE);

    return ORIGINAL_API(RegEnumKeyExW)(
        hKey,
        dwIndex,
        lpName,
        lpcbName,
        lpReserved,
        lpClass,
        lpcbClass,
        lpftLastWriteTime);
}

// Remove the key from the list.
LONG 
CRegistryChecks::CloseKey(
    HKEY hKey
    )
{
    RCOPENKEY* key = keys;
    RCOPENKEY* last = NULL;

    while (key) {
        if (key->hkBase == hKey) {
            if (last) {
                last->next = key->next; 
            } else {
                keys = key->next;
            }

            delete key;
            break;
        }

        last = key;
        key = key->next;
    }

    DPFN(eDbgLevelInfo, "[CloseKey] closing key 0x%08x", hKey);

    return ORIGINAL_API(RegCloseKey)(hKey);
}

LONG 
CRegistryChecks::DeleteKeyA(
    HKEY hKey,
    LPCSTR lpSubKey
    )
{
    Check(hKey, lpSubKey, FALSE, TRUE, KEY_WRITE);

    return ORIGINAL_API(RegDeleteKeyA)(
        hKey, 
        lpSubKey);
}

LONG 
CRegistryChecks::DeleteKeyW(
    HKEY hKey,
    LPCWSTR lpSubKey
    )
{
    Check(hKey, lpSubKey, FALSE, TRUE, KEY_WRITE);

    return ORIGINAL_API(RegDeleteKeyW)(
        hKey, 
        lpSubKey);
}

CRegistryChecks RRegistry;

//
// Hook APIs.
//

LONG 
APIHOOK(RegOpenKeyA)(
    HKEY hKey,         
    LPSTR lpSubKey,  
    PHKEY phkResult
    )
{
    CRRegLock Lock;

    return RRegistry.OpenKeyExA(
        hKey, 
        lpSubKey, 
        0, 
        REG_OPTION_NON_VOLATILE,
        MAXIMUM_ALLOWED, 
        NULL,
        phkResult,
        NULL,
        FALSE);
}

LONG 
APIHOOK(RegOpenKeyW)(
    HKEY hKey,         
    LPWSTR lpSubKey,  
    PHKEY phkResult
    )
{
    CRRegLock Lock;

    return RRegistry.OpenKeyExW(
        hKey, 
        lpSubKey, 
        0, 
        REG_OPTION_NON_VOLATILE,
        MAXIMUM_ALLOWED, 
        NULL,
        phkResult,
        NULL,
        FALSE);
}

LONG 
APIHOOK(RegOpenKeyExA)(
    HKEY hKey,         
    LPCSTR lpSubKey,  
    DWORD ulOptions,   
    REGSAM samDesired, 
    PHKEY phkResult
    )
{
    CRRegLock Lock;

    return RRegistry.OpenKeyExA(
        hKey, 
        lpSubKey, 
        0, 
        REG_OPTION_NON_VOLATILE,
        samDesired, 
        NULL,
        phkResult,
        NULL,
        FALSE);
}

LONG 
APIHOOK(RegOpenKeyExW)(
    HKEY hKey,         
    LPCWSTR lpSubKey,  
    DWORD ulOptions,   
    REGSAM samDesired, 
    PHKEY phkResult
    )
{
    CRRegLock Lock;

    return RRegistry.OpenKeyExW(
        hKey, 
        lpSubKey, 
        0, 
        REG_OPTION_NON_VOLATILE,
        samDesired, 
        NULL,
        phkResult,
        NULL,
        FALSE);
}

LONG 
APIHOOK(RegCreateKeyA)(
    HKEY hKey,         
    LPCSTR lpSubKey,
    PHKEY phkResult
    )
{
    CRRegLock Lock;

    return RRegistry.OpenKeyExA(
        hKey, 
        lpSubKey, 
        0,
        REG_OPTION_NON_VOLATILE,
        MAXIMUM_ALLOWED, 
        NULL,
        phkResult, 
        NULL,
        TRUE);
}

LONG 
APIHOOK(RegCreateKeyW)(
    HKEY hKey,         
    LPCWSTR lpSubKey,
    PHKEY phkResult
    )
{
    CRRegLock Lock;

    return RRegistry.OpenKeyExW(
        hKey, 
        lpSubKey, 
        0,
        REG_OPTION_NON_VOLATILE,
        MAXIMUM_ALLOWED, 
        NULL,
        phkResult, 
        NULL,
        TRUE);
}

LONG 
APIHOOK(RegCreateKeyExA)(
    HKEY hKey,                
    LPCSTR lpSubKey,         
    DWORD Reserved,           
    LPSTR lpClass,           
    DWORD dwOptions,          
    REGSAM samDesired,        
    LPSECURITY_ATTRIBUTES lpSecurityAttributes,
    PHKEY phkResult,          
    LPDWORD lpdwDisposition   
    )
{
    CRRegLock Lock;

    return RRegistry.OpenKeyExA(
        hKey, 
        lpSubKey,
        lpClass, 
        dwOptions,
        samDesired,
        lpSecurityAttributes,
        phkResult, 
        lpdwDisposition,
        TRUE);
}

LONG 
APIHOOK(RegCreateKeyExW)(
    HKEY hKey,                
    LPCWSTR lpSubKey,         
    DWORD Reserved,           
    LPWSTR lpClass,           
    DWORD dwOptions,          
    REGSAM samDesired,        
    LPSECURITY_ATTRIBUTES lpSecurityAttributes,
    PHKEY phkResult,          
    LPDWORD lpdwDisposition   
    )
{
    CRRegLock Lock;

    return RRegistry.OpenKeyExW(
        hKey, 
        lpSubKey,
        lpClass, 
        dwOptions,
        samDesired,
        lpSecurityAttributes,
        phkResult, 
        lpdwDisposition,
        TRUE);
}

LONG 
APIHOOK(RegQueryValueA)(
    HKEY    hKey,
    LPCSTR  lpSubKey,
    LPSTR lpValue,
    PLONG lpcbValue
    )
{
    CRRegLock Lock;

    return RRegistry.QueryValueA(
        hKey,
        lpSubKey,
        lpValue,
        lpcbValue);
}

LONG 
APIHOOK(RegQueryValueW)(
    HKEY    hKey,
    LPCWSTR  lpSubKey,
    LPWSTR  lpValue,
    PLONG lpcbValue
    )
{
    CRRegLock Lock;

    return RRegistry.QueryValueW(
        hKey,
        lpSubKey,
        lpValue,
        lpcbValue);
}

LONG 
APIHOOK(RegQueryValueExA)(
    HKEY    hKey,
    LPCSTR   lpValueName,
    LPDWORD lpReserved,
    LPDWORD lpType,
    LPBYTE  lpData,
    LPDWORD lpcbData
    )
{
    CRRegLock Lock;

    return RRegistry.QueryValueExA(
        hKey,
        lpValueName,
        lpReserved,
        lpType,
        lpData,
        lpcbData);
}

LONG 
APIHOOK(RegQueryValueExW)(
    HKEY    hKey,
    LPCWSTR lpValueName,
    LPDWORD lpReserved,
    LPDWORD lpType,
    LPBYTE  lpData,
    LPDWORD lpcbData
    )
{
    CRRegLock Lock;

    return RRegistry.QueryValueExW(
        hKey,
        lpValueName,
        lpReserved,
        lpType,
        lpData,
        lpcbData);
}

LONG 
APIHOOK(RegQueryInfoKeyA)(
    HKEY hKey,                
    LPSTR lpClass,           
    LPDWORD lpcbClass,        
    LPDWORD lpReserved,       
    LPDWORD lpcSubKeys,       
    LPDWORD lpcbMaxSubKeyLen, 
    LPDWORD lpcbMaxClassLen,  
    LPDWORD lpcValues,        
    LPDWORD lpcbMaxValueNameLen,
    LPDWORD lpcbMaxValueLen,  
    LPDWORD lpcbSecurityDescriptor,
    PFILETIME lpftLastWriteTime   
    )
{
    CRRegLock Lock;

    return RRegistry.QueryInfoKeyA(
        hKey,
        lpClass,           
        lpcbClass,        
        lpReserved,       
        lpcSubKeys,       
        lpcbMaxSubKeyLen, 
        lpcbMaxClassLen,  
        lpcValues,        
        lpcbMaxValueNameLen,
        lpcbMaxValueLen,  
        lpcbSecurityDescriptor,
        lpftLastWriteTime);
}

LONG 
APIHOOK(RegQueryInfoKeyW)(
    HKEY hKey,                
    LPWSTR lpClass,           
    LPDWORD lpcbClass,        
    LPDWORD lpReserved,       
    LPDWORD lpcSubKeys,       
    LPDWORD lpcbMaxSubKeyLen, 
    LPDWORD lpcbMaxClassLen,  
    LPDWORD lpcValues,        
    LPDWORD lpcbMaxValueNameLen,
    LPDWORD lpcbMaxValueLen,  
    LPDWORD lpcbSecurityDescriptor,
    PFILETIME lpftLastWriteTime   
    )
{
    CRRegLock Lock;

    return RRegistry.QueryInfoKeyW(
        hKey,
        lpClass,           
        lpcbClass,        
        lpReserved,       
        lpcSubKeys,       
        lpcbMaxSubKeyLen, 
        lpcbMaxClassLen,  
        lpcValues,        
        lpcbMaxValueNameLen,
        lpcbMaxValueLen,  
        lpcbSecurityDescriptor,
        lpftLastWriteTime);
}

LONG      
APIHOOK(RegSetValueA)(
    HKEY hKey, 
    LPCSTR lpSubKey, 
    DWORD dwType, 
    LPCSTR lpData, 
    DWORD cbData
    )
{
    CRRegLock Lock;

    return RRegistry.SetValueA(
        hKey,
        lpSubKey,
        dwType,
        lpData,
        cbData);
}

LONG      
APIHOOK(RegSetValueW)(
    HKEY hKey, 
    LPCWSTR lpSubKey, 
    DWORD dwType, 
    LPCWSTR lpData, 
    DWORD cbData
    )
{
    CRRegLock Lock;

    return RRegistry.SetValueW(
        hKey,
        lpSubKey,
        dwType,
        lpData,
        cbData);
}

LONG      
APIHOOK(RegSetValueExA)(
    HKEY hKey, 
    LPCSTR lpSubKey, 
    DWORD Reserved, 
    DWORD dwType, 
    CONST BYTE * lpData, 
    DWORD cbData
    )
{
    CRRegLock Lock;

    return RRegistry.SetValueExA(
        hKey,
        lpSubKey,
        Reserved,
        dwType,
        lpData,
        cbData);
}

LONG      
APIHOOK(RegSetValueExW)(
    HKEY hKey, 
    LPCWSTR lpSubKey, 
    DWORD Reserved, 
    DWORD dwType, 
    CONST BYTE * lpData, 
    DWORD cbData
    )
{
    CRRegLock Lock;

    return RRegistry.SetValueExW(
        hKey,
        lpSubKey,
        Reserved,
        dwType,
        lpData,
        cbData);
}

LONG 
APIHOOK(RegEnumValueA)(
    HKEY hKey,
    DWORD dwIndex,
    LPSTR lpValueName,
    LPDWORD lpcbValueName,
    LPDWORD lpReserved,
    LPDWORD lpType,
    LPBYTE lpData,
    LPDWORD lpcbData
    )
{
    CRRegLock Lock;

    return RRegistry.EnumValueA(
        hKey,
        dwIndex,
        lpValueName,
        lpcbValueName,
        lpReserved,
        lpType,
        lpData,      
        lpcbData);
}

LONG 
APIHOOK(RegEnumValueW)(
    HKEY hKey,
    DWORD dwIndex,
    LPWSTR lpValueName,
    LPDWORD lpcbValueName,
    LPDWORD lpReserved,
    LPDWORD lpType,
    LPBYTE lpData,
    LPDWORD lpcbData
    )
{
    CRRegLock Lock;

    return RRegistry.EnumValueW(
        hKey,
        dwIndex,
        lpValueName,
        lpcbValueName,
        lpReserved,
        lpType,
        lpData,      
        lpcbData);
}

LONG 
APIHOOK(RegEnumKeyA)(
    HKEY hKey,     
    DWORD dwIndex, 
    LPSTR lpName, 
    DWORD cbName  
    )
{
    CRRegLock Lock;

    return RRegistry.EnumKeyExA(
        hKey,
        dwIndex,
        lpName,
        &cbName,
        NULL,
        NULL,
        NULL,
        NULL); // can this be null???
}

LONG 
APIHOOK(RegEnumKeyW)(
    HKEY hKey,     
    DWORD dwIndex, 
    LPWSTR lpName, 
    DWORD cbName  
    )
{
    CRRegLock Lock;

    return RRegistry.EnumKeyExW(
        hKey,
        dwIndex,
        lpName,
        &cbName,
        NULL,
        NULL,
        NULL,
        NULL);
}

LONG 
APIHOOK(RegEnumKeyExA)(
    HKEY hKey,
    DWORD dwIndex,
    LPSTR lpName,
    LPDWORD lpcbName,
    LPDWORD lpReserved,
    LPSTR lpClass,
    LPDWORD lpcbClass,
    PFILETIME lpftLastWriteTime 
    )
{
    CRRegLock Lock;

    return RRegistry.EnumKeyExA(
        hKey,
        dwIndex,
        lpName,
        lpcbName,
        lpReserved,
        lpClass,
        lpcbClass,
        lpftLastWriteTime);
}

LONG 
APIHOOK(RegEnumKeyExW)(
    HKEY hKey,
    DWORD dwIndex,
    LPWSTR lpName,
    LPDWORD lpcbName,
    LPDWORD lpReserved,
    LPWSTR lpClass,
    LPDWORD lpcbClass,
    PFILETIME lpftLastWriteTime 
    )
{
    CRRegLock Lock;

    return RRegistry.EnumKeyExW(
        hKey,
        dwIndex,
        lpName,
        lpcbName,
        lpReserved,
        lpClass,
        lpcbClass,
        lpftLastWriteTime);
}

LONG 
APIHOOK(RegCloseKey)(HKEY hKey)
{
    CRRegLock Lock;

    return RRegistry.CloseKey(hKey);
}

LONG      
APIHOOK(RegDeleteKeyA)(
    HKEY hKey, 
    LPCSTR lpSubKey
    )
{
    CRRegLock Lock;

    return RRegistry.DeleteKeyA(hKey, lpSubKey);
}

LONG      
APIHOOK(RegDeleteKeyW)(
    HKEY hKey, 
    LPCWSTR lpSubKey
    )
{
    CRRegLock Lock;

    return RRegistry.DeleteKeyW(hKey, lpSubKey);
}

SHIM_INFO_BEGIN()

    SHIM_INFO_DESCRIPTION(AVS_REGISTRYCHECKS_DESC)
    SHIM_INFO_FRIENDLY_NAME(AVS_REGISTRYCHECKS_FRIENDLY)
    SHIM_INFO_VERSION(1, 2)
    SHIM_INFO_INCLUDE_EXCLUDE("E:msi.dll sxs.dll comctl32.dll ole32.dll oleaut32.dll")

SHIM_INFO_END()

/*++

 Register hooked functions

 Note we purposely ignore the cleanup because some apps call registry functions
 during process detach.

--*/

HOOK_BEGIN

    DUMP_VERIFIER_LOG_ENTRY(VLOG_HKCU_Console_READ, 
                            AVS_HKCU_Console_READ,
                            AVS_HKCU_Console_READ_R,
                            AVS_HKCU_Console_READ_URL)

    DUMP_VERIFIER_LOG_ENTRY(VLOG_HKCU_ControlPanel_READ, 
                            AVS_HKCU_ControlPanel_READ,
                            AVS_HKCU_ControlPanel_READ_R,
                            AVS_HKCU_ControlPanel_READ_URL)

    DUMP_VERIFIER_LOG_ENTRY(VLOG_HKCU_Environment_READ, 
                            AVS_HKCU_Environment_READ,
                            AVS_HKCU_Environment_READ_R,
                            AVS_HKCU_Environment_READ_URL)

    DUMP_VERIFIER_LOG_ENTRY(VLOG_HKCU_Identities_READ, 
                            AVS_HKCU_Identities_READ,
                            AVS_HKCU_Identities_READ_R,
                            AVS_HKCU_Identities_READ_URL)

    DUMP_VERIFIER_LOG_ENTRY(VLOG_HKCU_KeyboardLayout_READ, 
                            AVS_HKCU_KeyboardLayout_READ,
                            AVS_HKCU_KeyboardLayout_READ_R,
                            AVS_HKCU_KeyboardLayout_READ_URL)

    DUMP_VERIFIER_LOG_ENTRY(VLOG_HKCU_Printers_READ, 
                            AVS_HKCU_Printers_READ,
                            AVS_HKCU_Printers_READ_R,
                            AVS_HKCU_Printers_READ_URL)

    DUMP_VERIFIER_LOG_ENTRY(VLOG_HKCU_RemoteAccess_READ, 
                            AVS_HKCU_RemoteAccess_READ,
                            AVS_HKCU_RemoteAccess_READ_R,
                            AVS_HKCU_RemoteAccess_READ_URL)

    DUMP_VERIFIER_LOG_ENTRY(VLOG_HKCU_SessionInformation_READ, 
                            AVS_HKCU_SessionInformation_READ,
                            AVS_HKCU_SessionInformation_READ_R,
                            AVS_HKCU_SessionInformation_READ_URL)

    DUMP_VERIFIER_LOG_ENTRY(VLOG_HKCU_UNICODEProgramGroups_READ, 
                            AVS_HKCU_UNICODEProgramGroups_READ,
                            AVS_HKCU_UNICODEProgramGroups_READ_R,
                            AVS_HKCU_UNICODEProgramGroups_READ_URL)

    DUMP_VERIFIER_LOG_ENTRY(VLOG_HKCU_VolatileEnvironment_READ, 
                            AVS_HKCU_VolatileEnvironment_READ,
                            AVS_HKCU_VolatileEnvironment_READ_R,
                            AVS_HKCU_VolatileEnvironment_READ_URL)

    DUMP_VERIFIER_LOG_ENTRY(VLOG_HKCU_Windows31MigrationStatus_READ, 
                            AVS_HKCU_Windows31MigrationStatus_READ,
                            AVS_HKCU_Windows31MigrationStatus_READ_R,
                            AVS_HKCU_Windows31MigrationStatus_READ_URL)

    DUMP_VERIFIER_LOG_ENTRY(VLOG_HKLM_HARDWARE_READ, 
                            AVS_HKLM_HARDWARE_READ,
                            AVS_HKLM_HARDWARE_READ_R,
                            AVS_HKLM_HARDWARE_READ_URL)

    DUMP_VERIFIER_LOG_ENTRY(VLOG_HKLM_SAM_READ, 
                            AVS_HKLM_SAM_READ,
                            AVS_HKLM_SAM_READ_R,
                            AVS_HKLM_SAM_READ_URL)

    DUMP_VERIFIER_LOG_ENTRY(VLOG_HKLM_SECURITY_READ, 
                            AVS_HKLM_SECURITY_READ,
                            AVS_HKLM_SECURITY_READ_R,
                            AVS_HKLM_SECURITY_READ_URL)

    DUMP_VERIFIER_LOG_ENTRY(VLOG_HKLM_SYSTEM_READ, 
                            AVS_HKLM_SYSTEM_READ,
                            AVS_HKLM_SYSTEM_READ_R,
                            AVS_HKLM_SYSTEM_READ_URL)

    DUMP_VERIFIER_LOG_ENTRY(VLOG_HKCC_READ, 
                            AVS_HKCC_READ,
                            AVS_HKCC_READ_R,
                            AVS_HKCC_READ_URL)

    DUMP_VERIFIER_LOG_ENTRY(VLOG_HKUS_READ, 
                            AVS_HKUS_READ,
                            AVS_HKUS_READ_R,
                            AVS_HKUS_READ_URL)

    DUMP_VERIFIER_LOG_ENTRY(VLOG_NON_HKCU_WRITE, 
                            AVS_NON_HKCU_WRITE,
                            AVS_NON_HKCU_WRITE_R,
                            AVS_NON_HKCU_WRITE_URL)


    APIHOOK_ENTRY(ADVAPI32.DLL, RegOpenKeyA)
    APIHOOK_ENTRY(ADVAPI32.DLL, RegOpenKeyW)
    APIHOOK_ENTRY(ADVAPI32.DLL, RegOpenKeyExA)
    APIHOOK_ENTRY(ADVAPI32.DLL, RegOpenKeyExW)
    APIHOOK_ENTRY(ADVAPI32.DLL, RegCreateKeyA)
    APIHOOK_ENTRY(ADVAPI32.DLL, RegCreateKeyW)
    APIHOOK_ENTRY(ADVAPI32.DLL, RegCreateKeyExA)
    APIHOOK_ENTRY(ADVAPI32.DLL, RegCreateKeyExW)
    APIHOOK_ENTRY(ADVAPI32.DLL, RegCloseKey)
    APIHOOK_ENTRY(ADVAPI32.DLL, RegQueryValueA)
    APIHOOK_ENTRY(ADVAPI32.DLL, RegQueryValueW)
    APIHOOK_ENTRY(ADVAPI32.DLL, RegQueryValueExA)
    APIHOOK_ENTRY(ADVAPI32.DLL, RegQueryValueExW)
    APIHOOK_ENTRY(ADVAPI32.DLL, RegQueryInfoKeyA)
    APIHOOK_ENTRY(ADVAPI32.DLL, RegQueryInfoKeyW)
    APIHOOK_ENTRY(ADVAPI32.DLL, RegSetValueA)
    APIHOOK_ENTRY(ADVAPI32.DLL, RegSetValueW)
    APIHOOK_ENTRY(ADVAPI32.DLL, RegSetValueExA)
    APIHOOK_ENTRY(ADVAPI32.DLL, RegSetValueExW)
    APIHOOK_ENTRY(ADVAPI32.DLL, RegEnumValueA)
    APIHOOK_ENTRY(ADVAPI32.DLL, RegEnumValueW)
    APIHOOK_ENTRY(ADVAPI32.DLL, RegEnumKeyA)
    APIHOOK_ENTRY(ADVAPI32.DLL, RegEnumKeyW)
    APIHOOK_ENTRY(ADVAPI32.DLL, RegEnumKeyExA)
    APIHOOK_ENTRY(ADVAPI32.DLL, RegEnumKeyExW)
    APIHOOK_ENTRY(ADVAPI32.DLL, RegDeleteKeyA)
    APIHOOK_ENTRY(ADVAPI32.DLL, RegDeleteKeyW)

HOOK_END

IMPLEMENT_SHIM_END
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\appcompat\shims\verifier\logregistrychanges.cpp ===
/*++

 Copyright (c) 2001 Microsoft Corporation

 Module Name:

   LogRegistryChanges.cpp

 Abstract:
 
   This AppVerifier shim hooks all the registry APIs
   that change the state of the system and logs their
   associated data to a text file.

 Notes:

   This is a general purpose shim.

 History:

   08/17/2001   rparsons    Created
   09/20/2001   rparsons    File I/O operations use NT APIs
   09/23/2001   rparsons    VLOG with log file location
   10/06/2001   rparsons    Open key handles are never removed from the list

--*/
#include "precomp.h"
#include "rtlutils.h"

IMPLEMENT_SHIM_BEGIN(LogRegistryChanges)
#include "ShimHookMacro.h"
#include "ShimCString.h"
#include "LogRegistryChanges.h"

BEGIN_DEFINE_VERIFIER_LOG(LogRegistryChanges)
    VERIFIER_LOG_ENTRY(VLOG_LOGREGCHANGES_LOGLOC)    
END_DEFINE_VERIFIER_LOG(LogRegistryChanges)

INIT_VERIFIER_LOG(LogRegistryChanges);

//
// Stores the NT path to the file system log file for the current session.
//
UNICODE_STRING g_strLogFilePath;

//
// Stores the DOS path to the file system log file for the current session.
// This doesn't get freed.
//
LPWSTR g_pwszLogFilePath;

//
// Head of our open key handle linked list.
//
LIST_ENTRY g_OpenKeyListHead;

//
// Temporary buffer stored on the heap.
// Used when creating XML elements to log.
// This doesn't get freed.
//
LPWSTR g_pwszTempBuffer;

//
// Size of the temporary buffer above.
//
DWORD g_cbTempBufferSize;

//
// Stores the unique id used for NULL value names.
//
WCHAR g_wszUniqueId[MAX_PATH * 2];

//
// Temporary buffers stored on the heap.
// Used when extracting old & new data for logging.
// These don't get freed.
//
LPWSTR g_pwszOriginalData;
LPWSTR g_pwszFinalData;

//
// Size of the temporary buffers above.
//
DWORD g_cbOriginalDataBufferSize;
DWORD g_cbFinalDataBufferSize;

/*++

 Writes an entry to the log file.
 
--*/
void
WriteEntryToLog(
    IN LPCWSTR pwszEntry
    )
{
    int                 nLen = 0;
    HANDLE              hFile;
    OBJECT_ATTRIBUTES   ObjectAttributes;
    IO_STATUS_BLOCK     IoStatusBlock;
    LARGE_INTEGER       liOffset;
    NTSTATUS            status;

    //
    // Note that we have to use native APIs throughout this function
    // to avoid a problem with circular hooking. That is, if we simply
    // call WriteFile, which is exported from kernel32, it will call NtWriteFile,
    // which is a call that we hook, in turn leaving us in and endless loop.
    //
    
    //
    // Attempt to get a handle to our log file.
    //
    InitializeObjectAttributes(&ObjectAttributes,
                               &g_strLogFilePath,
                               OBJ_CASE_INSENSITIVE,
                               NULL,
                               NULL);

    status = NtCreateFile(&hFile,
                          FILE_APPEND_DATA | SYNCHRONIZE,
                          &ObjectAttributes,
                          &IoStatusBlock,
                          0,
                          FILE_ATTRIBUTE_NORMAL,
                          0,
                          FILE_OPEN,
                          FILE_NON_DIRECTORY_FILE | FILE_SYNCHRONOUS_IO_NONALERT,
                          NULL,
                          0);

    if (!NT_SUCCESS(status)) {
        DPFN(eDbgLevelError, "[WriteEntryToLog] Failed to open log");
        return;
    }
    
    //
    // Write the data out to the file.
    //
    nLen = wcslen(pwszEntry);

    IoStatusBlock.Status = 0;
    IoStatusBlock.Information = 0;

    liOffset.LowPart  = 0;
    liOffset.HighPart = 0;

    status = NtWriteFile(hFile,
                         NULL,
                         NULL,
                         NULL,
                         &IoStatusBlock,
                         (PVOID)pwszEntry,
                         (ULONG)(nLen) * sizeof(WCHAR),
                         &liOffset,
                         NULL);
    
    if (!NT_SUCCESS(status)) {
        DPFN(eDbgLevelError, "[WriteEntryToLog] 0x%X Failed to make entry", status);
        goto exit;
    }

exit:

    NtClose(hFile);

}

/*++

 Creates our log files using the local time.
 It goes into %windir%\AppPatch\VLog.
 
--*/
BOOL
InitializeLogFile(
    void
    )
{
    BOOL                fReturn = FALSE;
    HANDLE              hFile;
    SYSTEMTIME          st;
    UINT                nLen = 0;
    WCHAR               wszFileLog[64];
    WCHAR*              pwszLogFile = NULL;
    WCHAR*              pSlash = NULL;
    WCHAR*              pDot = NULL;
    WCHAR               wszModPathName[MAX_PATH];
    WCHAR               wszShortName[MAX_PATH];
    WCHAR               wszLogHdr[512];
    const WCHAR         wszLogDir[] = L"\\AppPatch\\VLog";
    WCHAR               wszUnicodeHdr = 0xFEFF;
    UNICODE_STRING      strLogFile;
    NTSTATUS            status;
    OBJECT_ATTRIBUTES   ObjectAttributes;
    IO_STATUS_BLOCK     IoStatusBlock;
    
    //
    // Format the log header.
    //
    if (!GetModuleFileName(NULL, wszModPathName, ARRAYSIZE(wszModPathName))) {
        wcscpy(wszModPathName, L"unknown");
    }

    if (_snwprintf(wszLogHdr,
                   ARRAYSIZE(wszLogHdr) - 1,
                   L"%lc<?xml version=\"1.0\" encoding=\"UTF-16\"?>\r\n<APPLICATION NAME=\"%ls\">\r\n",
                   wszUnicodeHdr,
                   wszModPathName) < 0) {
        DPFN(eDbgLevelError, "[InitializeLogFile] Buffer too small (1)");
        return FALSE;
    }
    
    //
    // Get the current time and set up the log file name.
    // The format of the log file name is this:
    // 'processname_registry_yyyymmdd_hhmmss.xml'
    //
    GetLocalTime(&st);

    //
    // Extract the name of this module without the path and extension.
    // Basically we trim off the extension first (if there is one.)
    // Next we find out where the directory path ends, then grab
    // the file portion and save it away.
    //
    wszShortName[0] = 0;
    pDot = wcsrchr(wszModPathName, '.');

    if (pDot) {
        *pDot = '\0';
    }

    pSlash = wcsrchr(wszModPathName, '\\');

    if (pSlash) {
        wcsncpy(wszShortName, ++pSlash, (wcslen(pSlash) + 1));
    }

    if (_snwprintf(wszFileLog,
                   ARRAYSIZE(wszFileLog) - 1,
                   L"%ls_registry_%02hu%02hu%02hu_%02hu%02hu%02hu.xml",
                   wszShortName,
                   st.wYear,
                   st.wMonth,
                   st.wDay,
                   st.wHour,
                   st.wMinute,
                   st.wSecond) < 0) {
        DPFN(eDbgLevelError, "[InitializeLogFile] Buffer too small (2)");
        return FALSE;
    }
        
    //
    // Set up the path our log file.
    //
    nLen = GetSystemWindowsDirectory(NULL, 0);

    if (0 == nLen) {
        DPFN(eDbgLevelError,
             "[InitializeLogFile] %lu Failed to get size for Windows directory path",
             GetLastError());
        return FALSE;
    }

    nLen += wcslen(wszFileLog);
    nLen += wcslen(wszLogDir);

    pwszLogFile = (LPWSTR)MemAlloc((nLen + 2) * sizeof(WCHAR));

    if (!pwszLogFile) {
        DPFN(eDbgLevelError, "[InitializeLogFile] No memory for log file");
        return FALSE;
    }

    nLen = GetSystemWindowsDirectory(pwszLogFile, (nLen + 2) * sizeof(WCHAR));

    if (0 == nLen) {
        DPFN(eDbgLevelError,
             "[InitializeLogFile] %lu Failed to get Windows directory path",
             GetLastError());
        return FALSE;
    }

    wcscat(pwszLogFile, wszLogDir);
    
    //
    // Ensure that the %windir%\AppPatch\VLog directory exists.
    // If it doesn't, attempt to create it.
    //
    if (-1 == GetFileAttributes(pwszLogFile)) {
        if (!CreateDirectory(pwszLogFile, NULL)) {
            DPFN(eDbgLevelError,
                 "[InitializeLogFile] %lu Failed to create VLog directory",
                 GetLastError());
            return FALSE;
        }
    }

    wcscat(pwszLogFile, L"\\");
    wcscat(pwszLogFile, wszFileLog);

    //
    // Save the pointer as we'll need it later.
    //
    g_pwszLogFilePath = pwszLogFile;

    //
    // Attempt to create the new log file.
    //
    RtlInitUnicodeString(&strLogFile, pwszLogFile);

    status = RtlDosPathNameToNtPathName_U(strLogFile.Buffer,
                                          &strLogFile,
                                          NULL,
                                          NULL);

    if (!NT_SUCCESS(status)) {
        DPFN(eDbgLevelError, "[InitializeLogFile] DOS -> NT failed");
        return FALSE;
    }

    InitializeObjectAttributes(&ObjectAttributes,
                               &strLogFile,
                               OBJ_CASE_INSENSITIVE,
                               NULL,
                               NULL);

    status = NtCreateFile(&hFile,
                          GENERIC_WRITE | SYNCHRONIZE,
                          &ObjectAttributes,
                          &IoStatusBlock,
                          NULL,
                          FILE_ATTRIBUTE_NORMAL,
                          0,
                          FILE_CREATE,
                          FILE_NON_DIRECTORY_FILE | FILE_SYNCHRONOUS_IO_NONALERT,
                          NULL,
                          0);

    if (!NT_SUCCESS(status)) {
        DPFN(eDbgLevelError,
             "[InitializeLogFile] 0x%X Failed to create log",
             status);
        goto cleanup;
    }

    NtClose(hFile);

    //
    // Save away the NT path to the file.
    //
    status = ShimDuplicateUnicodeString(RTL_DUPLICATE_UNICODE_STRING_NULL_TERMINATE | 
                                        RTL_DUPLICATE_UNICODE_STRING_ALLOCATE_NULL_STRING,
                                        &strLogFile,
                                        &g_strLogFilePath);

    if (!NT_SUCCESS(status)) {
        DPFN(eDbgLevelError,
             "[InitializeLogFile] Failed to save log file path");
        goto cleanup;
    }

    //
    // Write the header to the log.
    //                             
    WriteEntryToLog(wszLogHdr);

    fReturn = TRUE;

cleanup:

    RtlFreeUnicodeString(&strLogFile);

    return fReturn;
}

/*++

 Writes the closing element to the file and outputs the log file location.
 
--*/
BOOL
CloseLogFile(
    void
    )
{
    WCHAR   wszBuffer[] = L"</APPLICATION>";

    WriteEntryToLog(wszBuffer);

    VLOG(VLOG_LEVEL_INFO, VLOG_LOGREGCHANGES_LOGLOC, "%ls", g_pwszLogFilePath);

    return TRUE;
}

/*++

 Converts from ANSI to Unicode. The caller must free the buffer.
 
--*/
BOOL
ConvertAnsiToUnicode(
    IN  LPCSTR  pszAnsiString,
    OUT LPWSTR* pwszUnicodeString
    )
{
    int nLen = 0;

    nLen = lstrlenA(pszAnsiString);

    if (nLen) {    
        *pwszUnicodeString = (LPWSTR)MemAlloc((nLen + 1) * sizeof(WCHAR));
    
        if (!*pwszUnicodeString) {
            DPFN(eDbgLevelError,
                 "[ConvertAnsiToUnicode] Failed to allocate memory");
            return FALSE;
        }
    
        nLen = MultiByteToWideChar(CP_ACP,
                                   0,
                                   pszAnsiString,
                                   -1,
                                   *pwszUnicodeString,
                                   nLen + 1);

        if (!nLen) {
            DPFN(eDbgLevelError,
                 "[ConvertAnsiToUnicode] %lu Ansi -> Unicode failed",
                 GetLastError());
            MemFree(*pwszUnicodeString);
            return FALSE;
        }
    }

    return TRUE;
}

/*++

 Converts a list of NULL terminated strings from ANSI to Unicode.
 The caller must free the buffer.
 
--*/
BOOL
ConvertMultiSzToUnicode(
    IN  LPCSTR  pszAnsiStringList,
    OUT LPWSTR* pwszWideStringList
    )
{
    int     nLen = 0;
    UINT    uSize = 0;
    UINT    uWideSize = 0;
    UINT    uTotalSize = 0;
    LPCSTR  pszAnsi = NULL;
    LPWSTR  pwszTemp = NULL;

    if (!pszAnsiStringList) {
        DPFN(eDbgLevelError, "[ConvertMultiSzToUnicode] Invalid parameter");
        return FALSE;
    }

    pszAnsi = pszAnsiStringList;
    
    //
    // Determine how large of a buffer we need to allocate.
    //
    do {
        uSize = lstrlenA(pszAnsi) + 1;
        uTotalSize += uSize;
        pszAnsi += uSize;
    } while (uSize != 1);
    
    if (uTotalSize != 0) {
        pwszTemp = *pwszWideStringList = (LPWSTR)MemAlloc(uTotalSize * sizeof(WCHAR));
        
        if (!*pwszWideStringList) {
            DPFN(eDbgLevelError,
                 "[ConvertMultiSzToUnicode] No memory for buffer");
            return FALSE;
        }
    }

    //
    // Perform the ANSI to Unicode conversion.
    //
    pszAnsi = pszAnsiStringList;
        
    do {
        nLen = lstrlenA(pszAnsi) + 1;
            
        uWideSize = MultiByteToWideChar(
            CP_ACP,
            0,
            pszAnsi,
            -1,
            pwszTemp,
            nLen);
        
        pszAnsi  += nLen;
        pwszTemp += uWideSize;
    } while (nLen != 1);

    return TRUE;
}

/*++

 Given a predefined key handle such as HKEY_LOCAL_MACHINE, return a string.
 
--*/
BOOL
PredefinedKeyToString(
    IN  HKEY    hKey,
    OUT LPWSTR* pwszString
    )
{
    if (hKey == HKEY_CLASSES_ROOT) {
        wcscpy(*pwszString, L"HKEY_CLASSES_ROOT");
    }
    else if (hKey == HKEY_CURRENT_CONFIG) {
        wcscpy(*pwszString, L"HKEY_CURRENT_CONFIG");
    }
    else if (hKey == HKEY_CURRENT_USER) {
        wcscpy(*pwszString, L"HKEY_CURRENT_USER");
    }
    else if (hKey == HKEY_LOCAL_MACHINE) {
        wcscpy(*pwszString, L"HKEY_LOCAL_MACHINE");
    }
    else if (hKey == HKEY_USERS) {
        wcscpy(*pwszString, L"HKEY_USERS");
    }
    else if (hKey == HKEY_DYN_DATA) {
        wcscpy(*pwszString, L"HKEY_DYN_DATA");
    }
    else if (hKey == HKEY_PERFORMANCE_DATA) {
        wcscpy(*pwszString, L"HKEY_PERFORMANCE_DATA");
    }
    else {
        wcscpy(*pwszString, L"Not recognized");
        return FALSE;
    }

    return TRUE;
}

/*++

 Displays the name associated with this object.
 
--*/
#if DBG
void
PrintNameFromKey(
    IN HKEY hKey
    )
{
    NTSTATUS                status;
    WCHAR                   wszBuffer[MAX_PATH];
    OBJECT_NAME_INFORMATION *poni = NULL;

    wszBuffer[0] = 0;
    
    poni = (OBJECT_NAME_INFORMATION*)wszBuffer;

    status = NtQueryObject(hKey, ObjectNameInformation, poni, MAX_PATH, NULL);

    if (NT_SUCCESS(status)) {
        DPFN(eDbgLevelInfo,
             "Key 0x%08x has name: %ls",
             hKey,
             poni->Name.Buffer); 
    }
}
#endif // DBG

/*++

 Given a pointer to a key node, get the original data.
 
--*/
BOOL
CLogRegistry::GetOriginalDataForKey(
    IN PLOG_OPEN_KEY pLogOpenKey,
    IN PKEY_DATA     pKeyData,
    IN LPCWSTR       pwszValueName
    )
{
    BOOL    fReturn = FALSE;
    HKEY    hKeyLocal;
    DWORD   cbSize = 0, dwType = 0;
    LONG    lRetVal;
    
    if (!pLogOpenKey || !pKeyData) {
        DPFN(eDbgLevelError, "[GetOriginalDataForKey] Invalid parameter(s)");
        return FALSE;
    }
    
    lRetVal = RegOpenKeyEx(pLogOpenKey->hKeyRoot,
                           pLogOpenKey->pwszSubKeyPath,
                           0,
                           KEY_QUERY_VALUE,
                           &hKeyLocal);

    if (ERROR_SUCCESS != lRetVal) {
        DPFN(eDbgLevelError, "[GetOriginalDataForKey] Failed to open key");
        return FALSE;
    }
    
    //
    // Query the size of the data. If the data doesn't exist, return success.
    //
    lRetVal = RegQueryValueEx(hKeyLocal,
                              pwszValueName,
                              0,
                              &dwType,
                              NULL,
                              &cbSize);

    if (ERROR_SUCCESS != lRetVal) {
        if (ERROR_FILE_NOT_FOUND == lRetVal) {
            RegCloseKey(hKeyLocal);
            return TRUE;
        } else {
            DPFN(eDbgLevelError, "[GetOldDataForKey] Failed to get data size");
            goto cleanup;
        }
    }

    //
    // Update the flags to indicate that the value already exists.
    //
    pKeyData->dwFlags |= LRC_EXISTING_VALUE;

    //
    // Allocate a buffer large enough to store the old data.
    //
    if (dwType != REG_DWORD && dwType != REG_BINARY) {
        pKeyData->pOriginalData = (PVOID)MemAlloc(cbSize * sizeof(WCHAR));
        pKeyData->cbOriginalDataSize = cbSize * sizeof(WCHAR);
    } else {
        pKeyData->pOriginalData = (PVOID)MemAlloc(cbSize);
        pKeyData->cbOriginalDataSize = cbSize;
    }
    
    if (!pKeyData->pOriginalData) {
        DPFN(eDbgLevelError,
             "[GetOriginalDataForKey] Failed to allocate memory");
        goto cleanup;
    }

    pKeyData->dwOriginalValueType = dwType;

    //
    // Now make the call again this time getting the actual data.
    //
    lRetVal = RegQueryValueEx(hKeyLocal,
                              pwszValueName,
                              0,
                              0,
                              (LPBYTE)pKeyData->pOriginalData,
                              &cbSize);

    if (ERROR_SUCCESS != lRetVal) {
        DPFN(eDbgLevelError, "[GetOriginalDataForKey] Failed to get data");
        goto cleanup;
    }

    fReturn = TRUE;    

cleanup:

    RegCloseKey(hKeyLocal);   

    return fReturn;
}

/*++

 Given a pointer to a key node, get the final data.
 
--*/
BOOL
CLogRegistry::GetFinalDataForKey(
    IN PLOG_OPEN_KEY pLogOpenKey,
    IN PKEY_DATA     pKeyData,
    IN LPCWSTR       pwszValueName
    )
{
    BOOL    fReturn = FALSE;
    HKEY    hKeyLocal;
    DWORD   cbSize = 0, dwType = 0;
    LONG    lRetVal;
    PVOID   pTemp = NULL;
    
    if (!pLogOpenKey || !pKeyData) {
        DPFN(eDbgLevelError, "[GetFinalDataForKey] Invalid parameter(s)");
        return FALSE;
    }
    
    lRetVal = RegOpenKeyEx(pLogOpenKey->hKeyRoot,
                           pLogOpenKey->pwszSubKeyPath,
                           0,
                           KEY_QUERY_VALUE,
                           &hKeyLocal);

    if (ERROR_SUCCESS != lRetVal) {
        DPFN(eDbgLevelError, "[GetFinalDataForKey] Failed to open key");
        return FALSE;
    }
    
    //
    // Query the size of the data. If the data doesn't exist, return success.
    //
    lRetVal = RegQueryValueEx(hKeyLocal,
                              pwszValueName,
                              0,
                              &dwType,
                              NULL,
                              &cbSize);

    if (ERROR_SUCCESS != lRetVal) {
        if (ERROR_FILE_NOT_FOUND == lRetVal) {
            RegCloseKey(hKeyLocal);
            return TRUE;
        } else {
            DPFN(eDbgLevelError,
                 "[GetFinalDataForKey] Failed to get data size");
            goto cleanup;
        }
    }

    //
    // It's possible that multiple queries were issued against the same
    // key. If this is the case, the buffer to hold the data has already
    // been allocated. Determine if the block is large enough.
    //
    if (pKeyData->pFinalData) {
        if (dwType != REG_DWORD && dwType != REG_BINARY) {
            //
            // If MemReAlloc fails, we would lose the pointer that
            // we already had in pKeyData->pFinalData. This preserves
            // the pointer.
            //
            if (pKeyData->cbFinalDataSize < (cbSize * sizeof(WCHAR))) {
                pKeyData->cbFinalDataSize = cbSize * sizeof(WCHAR);
                pTemp = MemReAlloc(pKeyData->pFinalData,
                                   cbSize * sizeof(WCHAR));
            }
        } else {
            if (pKeyData->cbFinalDataSize < cbSize) {
                pKeyData->cbFinalDataSize = cbSize;
                pTemp = MemReAlloc(pKeyData->pFinalData,
                                   cbSize);
            }
        }
        
        if (pTemp) {
            pKeyData->pFinalData = pTemp;
        } else {
            DPFN(eDbgLevelError,
                 "[GetFinalDataForKey] Failed to reallocate memory");
            goto cleanup;
        }

    } else {
        if (dwType != REG_DWORD && dwType != REG_BINARY) {
            pKeyData->pFinalData = MemAlloc(cbSize * sizeof(WCHAR));
            pKeyData->cbFinalDataSize = cbSize * sizeof(WCHAR);
        } else {
            pKeyData->pFinalData = MemAlloc(cbSize);
            pKeyData->cbFinalDataSize = cbSize;
        }
    }

    if (!pKeyData->pFinalData) {
        DPFN(eDbgLevelError, "[GetFinalDataForKey] Failed to allocate memory");
        goto cleanup;
    }

    pKeyData->dwFinalValueType = dwType;

    //
    // Now make the call again this time getting the actual data.
    //
    lRetVal = RegQueryValueEx(hKeyLocal,
                              pwszValueName,
                              0,
                              0,
                              (LPBYTE)pKeyData->pFinalData,
                              &cbSize);

    if (ERROR_SUCCESS != lRetVal) {
        DPFN(eDbgLevelError, "[GetFinalDataForKey] Failed to get data");
        goto cleanup;
    }

    fReturn = TRUE;    

cleanup:

    RegCloseKey(hKeyLocal);   

    return fReturn;
}

/*++

 Given a value name, attempt to find it in the list.
 This function may not always return a pointer.
 
--*/
PKEY_DATA
CLogRegistry::FindValueNameInList(
    IN LPCWSTR       pwszValueName,
    IN PLOG_OPEN_KEY pOpenKey
    )
{
    BOOL        fFound = FALSE;
    PLIST_ENTRY pHead = NULL;
    PLIST_ENTRY pNext = NULL;
    PKEY_DATA   pFindData = NULL;

    if (!pwszValueName || !pOpenKey) {
        DPFN(eDbgLevelError, "[FindValueNameInList] Invalid parameter(s)");
        return NULL;
    }

    pHead = &pOpenKey->KeyData;
    pNext = pHead->Flink;

    while (pNext != pHead) {
        pFindData = CONTAINING_RECORD(pNext, KEY_DATA, Entry);

        if (!_wcsicmp(pwszValueName, pFindData->wszValueName)) {
            fFound = TRUE;
            break;
        }

        pNext = pNext->Flink;
    }

    return (fFound ? pFindData : NULL);
}

/*++

 Given a key path, attempt to locate it in the list.
 This function may not always return a pointer.
 
--*/
PLOG_OPEN_KEY
CLogRegistry::FindKeyPathInList(
    IN LPCWSTR pwszKeyPath
    )
{
    BOOL            fFound = FALSE;
    PLIST_ENTRY     pCurrent = NULL;
    PLOG_OPEN_KEY   pFindKey = NULL;

    if (!pwszKeyPath) {
        DPFN(eDbgLevelError, "[FindKeyPathInList] Invalid parameter");
        return NULL;
    }

    //
    // Attempt to locate the entry in the list.
    //
    pCurrent = g_OpenKeyListHead.Flink;

    while (pCurrent != &g_OpenKeyListHead) {
        pFindKey = CONTAINING_RECORD(pCurrent, LOG_OPEN_KEY, Entry);

        if (pFindKey->pwszFullKeyPath) {
            if (!_wcsicmp(pwszKeyPath, pFindKey->pwszFullKeyPath)) {
                fFound = TRUE;
                break;
            }
        }
        
        pCurrent = pCurrent->Flink;
    }

    return (fFound ? pFindKey : NULL);
}

/*++

 Given a key handle, remove it from the array in the list.
 
--*/
PLOG_OPEN_KEY
CLogRegistry::RemoveKeyHandleFromArray(
    IN HKEY hKey
    )
{
    UINT            uCount;
    PLIST_ENTRY     pCurrent = NULL;
    PLOG_OPEN_KEY   pFindKey = NULL;

    if (!hKey) {
        DPFN(eDbgLevelError,
             "[RemoveKeyHandleFromArray] Invalid key handle passed!");
        return NULL;
    }

    pCurrent = g_OpenKeyListHead.Flink;

    while (pCurrent != &g_OpenKeyListHead) {
        pFindKey = CONTAINING_RECORD(pCurrent, LOG_OPEN_KEY, Entry);

        //
        // Step through this guy's array looking for the handle.
        //
        for (uCount = 0; uCount < pFindKey->cHandles; uCount++) {
            //
            // If we find the handle, set the array element to NULL and
            // decrement the count of handles for this entry.
            //
            if (pFindKey->hKeyBase[uCount] == hKey) {
                DPFN(eDbgLevelInfo,
                     "[RemoveKeyHandleFromArray] Removing handle 0x%08x",
                     hKey);
                pFindKey->hKeyBase[uCount] = NULL;
                pFindKey->cHandles--;
                return pFindKey;
            }
        }

        pCurrent = pCurrent->Flink;
    }

    return NULL;
}

/*++

 Finds a key handle in the array.
 
--*/
PLOG_OPEN_KEY
CLogRegistry::FindKeyHandleInArray(
    IN HKEY hKey
    )
{
    UINT            uCount;
    BOOL            fFound = FALSE;
    PLOG_OPEN_KEY   pFindKey = NULL;
    PLIST_ENTRY     pCurrent = NULL;

    if (!hKey) {
        DPFN(eDbgLevelError,
             "[FindKeyHandleInArray] Invalid key handle passed!");
        return NULL;
    }

    pCurrent = g_OpenKeyListHead.Flink;

    while (pCurrent != &g_OpenKeyListHead) {
        pFindKey = CONTAINING_RECORD(pCurrent, LOG_OPEN_KEY, Entry);

        //
        // Step through this guy's array looking for the handle.
        //
        for (uCount = 0; uCount < pFindKey->cHandles; uCount++) {
            if (pFindKey->hKeyBase[uCount] == hKey) {
                fFound = TRUE;
                break;
            }
        }

        if (fFound) {
            break;
        }

        pCurrent = pCurrent->Flink;
    }

#if DBG
    if (!fFound) {
        //
        // Dear God - the key handle is not in the list!
        // Break into the debugger on checked builds.
        //
        DPFN(eDbgLevelError,
             "[FindKeyHandleInArray] Key 0x%08x not in list!",
             hKey);
        PrintNameFromKey(hKey);
        DbgBreakPoint();
    }
#endif // DBG

    return (fFound ? pFindKey : NULL);
}

/*++

 Given a predefined handle and a subkey path,
 open the key to force it into the list.
 
--*/
HKEY
CLogRegistry::ForceSubKeyIntoList(
    IN  HKEY    hKeyPredefined,
    IN  LPCWSTR pwszSubKey
    )
{
    LONG    lRetVal;
    HKEY    hKeyRet;
    
    if (!pwszSubKey) {
        DPFN(eDbgLevelError, "[ForceSubKeyIntoList] Invalid parameter");
        return NULL;
    }

    lRetVal = OpenKeyExW(hKeyPredefined,
                         pwszSubKey,
                         0,
                         KEY_WRITE,
                         &hKeyRet);

    if (ERROR_SUCCESS != lRetVal) {
        DPFN(eDbgLevelError, "[ForceSubKeyIntoList] Failed to open key");
        return NULL;
    }

    return hKeyRet;
}

/*++

 Add a non-predefined key handle to the array.
 
--*/
PLOG_OPEN_KEY
CLogRegistry::AddKeyHandleToList(
    IN HKEY    hKey,
    IN HKEY    hKeyNew,
    IN LPCWSTR pwszSubKeyPath,
    IN BOOL    fExisting
    )
{
    UINT            uCount;
    DWORD           dwLen = 0;
    PLOG_OPEN_KEY   pFindKey = NULL;
    PLOG_OPEN_KEY   pRetKey = NULL;
    PLOG_OPEN_KEY   pExistingFindKey = NULL;

    //
    // If hKeyNew, which is the key handle the caller received
    // from the function, is a predefined handle, we simply
    // call FindKeyInArray, which will return a pointer to the
    // list entry that contains that key handle. These handles
    // were added during initialization, so there's no chance
    // that the caller won't get a pointer back.
    //
    if (IsPredefinedRegistryHandle(hKeyNew)) {
        return FindKeyHandleInArray(hKeyNew);
    }

    //
    // We've got a usual case where a key has been opened, and
    // now the caller is opening a subkey underneath it.
    //
    pFindKey = FindKeyHandleInArray(hKey);

    //
    // If pFindKey ever comes back as NULL, something is really
    // wrong. Every OpenKey/CreateKey comes through us and goes
    // into the list (with the exception of predefined handles
    // which are already stored there.) Dump out as much data
    // as we can to figure out what went wrong.
    //
    if (!pFindKey) {
        DPFN(eDbgLevelError,
            "[AddKeyHandleToList] Key not found in list! Key Handle = 0x%08x  New key = 0x%08x  Path = %ls",
            hKey, hKeyNew, pwszSubKeyPath);
        return NULL;
    }
    
    pRetKey = (PLOG_OPEN_KEY)MemAlloc(sizeof(LOG_OPEN_KEY));

    if (!pRetKey) {
        DPFN(eDbgLevelError, "[AddKeyHandleToList] No memory available");
        return NULL;
    }

    //
    // Make room for the subkey path that will go into the new
    // node. If the node that we found has a subkey path stored,
    // take that into account also. 
    //
    if (pwszSubKeyPath) {
        dwLen = wcslen(pwszSubKeyPath);
    }

    if (pFindKey->pwszSubKeyPath) {
        dwLen += wcslen(pFindKey->pwszSubKeyPath);
    }

    if (pFindKey->pwszSubKeyPath || pwszSubKeyPath) {
        pRetKey->pwszSubKeyPath = (LPWSTR)MemAlloc((dwLen + 2) * sizeof(WCHAR));

        if (!pRetKey->pwszSubKeyPath) {
            DPFN(eDbgLevelError, "[AddKeyHandleToList] No memory for subkey path");
            goto cleanup;
        }
    }

    //
    // If the node that we found has a subkey path, take it
    // and copy it over to the new node and concatenate
    // the subkey path that we got passed. Otherwise just
    // store the path that was passed, if available.
    //
    if (pFindKey->pwszSubKeyPath && pwszSubKeyPath) {
        wcscpy(pRetKey->pwszSubKeyPath, pFindKey->pwszSubKeyPath);
        wcscat(pRetKey->pwszSubKeyPath, L"\\");
        wcscat(pRetKey->pwszSubKeyPath, pwszSubKeyPath);
    } else if (pwszSubKeyPath) {
        wcscpy(pRetKey->pwszSubKeyPath, pwszSubKeyPath);
    }

    //
    // Make room for the full key path. This will store a path
    // of something like HKEY_LOCAL_MACHINE\Software\Microsoft...
    // that will be used for logging purposes.
    //
    if (pRetKey->pwszSubKeyPath) {
        dwLen = wcslen(pRetKey->pwszSubKeyPath);
    }
        
    pRetKey->pwszFullKeyPath = (LPWSTR)MemAlloc((dwLen + 2 + MAX_ROOT_LENGTH) * sizeof(WCHAR));

    if (!pRetKey->pwszFullKeyPath) {
        DPFN(eDbgLevelError,
            "[AddKeyHandleToList] No memory for full key path");
        goto cleanup;
    }

    //
    // Convert the predefined handle to a string and store it in
    // the node that we're about to add to the list.
    //
    if (!PredefinedKeyToString(pFindKey->hKeyRoot, &pRetKey->pwszFullKeyPath)) {
        DPFN(eDbgLevelError,
             "[AddKeyHandleToList] PredefinedKey -> String failed");
        goto cleanup;
    }

    if (pwszSubKeyPath) {
        wcscat(pRetKey->pwszFullKeyPath, L"\\");
        wcscat(pRetKey->pwszFullKeyPath, pRetKey->pwszSubKeyPath);
    }

    //
    // At this point we have a full key path.
    // We attempt to find the path in the linked list.
    // If we find it, we're going to update the handle array and count for this guy.
    // If we don't find it, we're going to add a new entry to the list.
    //
    pExistingFindKey = FindKeyPathInList(pRetKey->pwszFullKeyPath);

    if (!pExistingFindKey) {
        //
        // Fill in information about this key and add it to the list.
        //
        pRetKey->hKeyBase[0]  = hKeyNew;
        pRetKey->hKeyRoot     = pFindKey->hKeyRoot;
        pRetKey->cHandles     = 1;
        pRetKey->dwFlags     |= fExisting ? LRC_EXISTING_KEY : 0;

        InitializeListHead(&pRetKey->KeyData);

        DPFN(eDbgLevelInfo, "[AddKeyHandleToList] Adding key: %p", pRetKey);

        InsertHeadList(&g_OpenKeyListHead, &pRetKey->Entry);

        return pRetKey;

    } else {
        //
        // Store this handle in the array and increment the handle count.
        // Make sure we don't overstep the array bounds.
        //
        for (uCount = 0; uCount < pExistingFindKey->cHandles; uCount++) {
            if (NULL == pExistingFindKey->hKeyBase[uCount]) {
                break;
            }
        }

        if (uCount >= MAX_NUM_HANDLES) {
            DPFN(eDbgLevelError, "[AddKeyHandleToList] Handle count reached");
            goto cleanup;
        }

        pExistingFindKey->hKeyBase[uCount] = hKeyNew;
        pExistingFindKey->dwFlags &= ~LRC_DELETED_KEY;
        pExistingFindKey->cHandles++;
    }

cleanup:

    if (pRetKey->pwszFullKeyPath) {
        MemFree(pRetKey->pwszFullKeyPath);
    }

    if (pRetKey) {
        MemFree(pRetKey);
    }

    return pExistingFindKey;
}

/*++

 Add a value to the list.
 
--*/
PKEY_DATA
CLogRegistry::AddValueNameToList(
    IN PLOG_OPEN_KEY pLogOpenKey,
    IN LPCWSTR       pwszValueName
    )
{
    PKEY_DATA   pKeyData = NULL;

    pKeyData = (PKEY_DATA)MemAlloc(sizeof(KEY_DATA));

    if (!pKeyData) {
        DPFN(eDbgLevelError, "[AddValueNameToList] Failed to allocate memory");
        return NULL;
    }

    if (!GetOriginalDataForKey(pLogOpenKey, pKeyData, pwszValueName)) {
        DPFN(eDbgLevelError,
             "[AddValueNameToList] Failed to get original data");
        goto cleanup;
    }

    if (pwszValueName) {
        wcsncpy(pKeyData->wszValueName, pwszValueName, MAX_PATH);
    } else {
        //
        // If the valuename is NULL, assign our unique id.
        //
        wcsncpy(pKeyData->wszValueName, g_wszUniqueId, wcslen(g_wszUniqueId));
    }

    InsertHeadList(&pLogOpenKey->KeyData, &pKeyData->Entry);

    return pKeyData;

cleanup:

    if (pKeyData) {
        MemFree(pKeyData);
    }

    return NULL;
}

/*++

 The entry point for modifying the linked list data.
 
--*/
PLOG_OPEN_KEY
CLogRegistry::UpdateKeyList(
    IN HKEY       hKeyRoot,
    IN HKEY       hKeyNew,
    IN LPCWSTR    pwszSubKey,
    IN LPCWSTR    pwszValueName,
    IN BOOL       fExisting,
    IN UpdateType eType
    )
{
    PKEY_DATA       pKeyData = NULL;
    PLOG_OPEN_KEY   pRetKey = NULL;

    switch (eType) {
    case eAddKeyHandle:
        pRetKey = AddKeyHandleToList(hKeyRoot, hKeyNew, pwszSubKey, fExisting);
        break;

    case eRemoveKeyHandle:
        pRetKey = RemoveKeyHandleFromArray(hKeyNew);
        break;

    case eStartModifyValue:
    case eStartDeleteValue:
        pRetKey = FindKeyHandleInArray(hKeyNew);

        if (!pRetKey) {
            DPFN(eDbgLevelError,
                 "[UpdateKeyList] Start Modify: Failed to find handle in array");
            break;
        }

        if (!pwszValueName) {
            pKeyData = FindValueNameInList(g_wszUniqueId, pRetKey);
        } else {
            pKeyData = FindValueNameInList(pwszValueName, pRetKey);
        }

        if (pKeyData) {
            //
            // If the caller is attempting to modify the value, and we've
            // already gotten data for it, don't do it again.
            // Also, if they're attempting to delete the value, and it's
            // been modified, don't do it again.
            //
            if ((pKeyData->pOriginalData || pKeyData->pFinalData) ||
                (pKeyData->dwFlags & LRC_MODIFIED_VALUE) &&
                (eStartDeleteValue == eType)) {
                break;
            }

            if (!GetOriginalDataForKey(pRetKey, pKeyData, pwszValueName)) {
                DPFN(eDbgLevelError,
                     "[UpdateKeyList] Start Modify: Failed to get original data");
                break;
            }
        } else {
            //
            // We've never seen this value before. Insert it into the list. 
            //
            if (!AddValueNameToList(pRetKey, pwszValueName)) {
                DPFN(eDbgLevelError,
                     "[UpdateKeyList] Start Modify: Failed to insert value");
                break;
            }
        }

        break;

    case eEndModifyValue:
    case eEndDeleteValue:
        pRetKey = FindKeyHandleInArray(hKeyNew);

        if (!pRetKey) {
            DPFN(eDbgLevelError,
                 "[UpdateKeyList] End Modify: Failed to find handle in array");
            break;
        }

        if (!pwszValueName) {
            pKeyData = FindValueNameInList(g_wszUniqueId, pRetKey);
        } else {
            pKeyData = FindValueNameInList(pwszValueName, pRetKey);
        }

        if (!pKeyData) {
            DPFN(eDbgLevelError,
                 "[UpdateKeyList] End Modify: Failed to find value in list");
            break;
        }
        
        if (eEndModifyValue == eType) {
            if (!GetFinalDataForKey(pRetKey, pKeyData, pwszValueName)) {
                DPFN(eDbgLevelError,
                     "[UpdateKeyList] End Modify: Failed to get final data");
                break;
            }

            pKeyData->dwFlags |= LRC_MODIFIED_VALUE;
        }
        else if (eEndDeleteValue == eType) {
            pKeyData->dwFlags |= LRC_DELETED_VALUE;
        }

        break;

    case eDeletedKey:
        pRetKey = FindKeyHandleInArray(hKeyNew);

        if (!pRetKey) {
            DPFN(eDbgLevelError,
                 "[UpdateKeyList] DeleteKey: Failed to find handle in array");
            break;
        }

        pRetKey->dwFlags |= LRC_DELETED_KEY;

        break;

    default:
        DPFN(eDbgLevelError, "[UpdateKeyList] Invalid enum type!");
        break;
    }

    return pRetKey;
}

/*++

 Formats the data to form an XML element and logs it.
 
--*/
void
FormatKeyDataIntoElement(
    IN LPCWSTR       pwszOperation,
    IN PLOG_OPEN_KEY pLogOpenKey
    )
{
    UINT    cbSize = 0;
    PVOID   pTemp = NULL;

    //
    // To make it easier to replace & ' " < and > with their
    // XML entities, we convert the data to CString.
    //
    CString csFullKeyPath(pLogOpenKey->pwszFullKeyPath);
    
    csFullKeyPath.Replace(L"&", L"&amp;");
    csFullKeyPath.Replace(L"<", L"&lt;");
    csFullKeyPath.Replace(L">", L"&gt;");
    csFullKeyPath.Replace(L"'", L"&apos;");
    csFullKeyPath.Replace(L"\"", L"&quot;");

    //
    // To keep allocations to a minimum, we allocate a global
    // buffer one time, then reallocate if the data we're
    // logging is larger than the buffer.
    //
    if (!g_cbTempBufferSize) {
        g_pwszTempBuffer = (LPWSTR)MemAlloc(TEMP_BUFFER_SIZE * sizeof(WCHAR));

        if (!g_pwszTempBuffer) {
            DPFN(eDbgLevelError, "[FormatKeyData] Failed to allocate memory");
            return;
        }

        g_cbTempBufferSize = TEMP_BUFFER_SIZE * sizeof(WCHAR);
    }

    g_pwszTempBuffer[0] = 0;

    //
    // Determine how large of a buffer we'll need.
    //
    cbSize += csFullKeyPath.GetLength();
    cbSize += MAX_OPERATION_LENGTH;
    cbSize += KEY_ELEMENT_SIZE;
    cbSize *= sizeof(WCHAR);

    if (cbSize > g_cbTempBufferSize) {
        //
        // Our global buffer is not large enough; reallocate.
        //
        pTemp = (LPWSTR)MemReAlloc(g_pwszTempBuffer,
                                   cbSize + BUFFER_ALLOCATION_DELTA);

        if (pTemp) {
            g_pwszTempBuffer = (LPWSTR)pTemp;
        } else {
            DPFN(eDbgLevelError,
                 "[FormatKeyData] Failed to reallocate memory");
            return;
        }

        g_cbTempBufferSize = cbSize + BUFFER_ALLOCATION_DELTA;
    }

    wsprintf(g_pwszTempBuffer,
             L"    <OPERATION TYPE=\"%ls\" KEY_PATH=\"%ls\"/>\r\n",
             pwszOperation,
             csFullKeyPath.Get());

    WriteEntryToLog(g_pwszTempBuffer);
}

void
FormatValueDataIntoElement(
    IN CString& csFullKeyPath,
    IN LPCWSTR  pwszOperation,
    IN LPCWSTR  pwszValueName,
    IN LPCWSTR  pwszOriginalValueType,
    IN LPCWSTR  pwszFinalValueType
    )
{
    UINT    cbSize = 0;
    int     nChars = 0;
    PVOID   pTemp = NULL;

    //
    // To keep allocations to a minimum, we allocate a global
    // buffer one time, then reallocate if the data we're
    // logging is larger than the buffer.
    //
    if (!g_cbTempBufferSize) {
        g_pwszTempBuffer = (LPWSTR)MemAlloc(TEMP_BUFFER_SIZE * sizeof(WCHAR));

        if (!g_pwszTempBuffer) {
            DPFN(eDbgLevelError,
                 "[FormatValueDataIntoElement] Failed to allocate memory");
            return;
        }

        g_cbTempBufferSize = TEMP_BUFFER_SIZE * sizeof(WCHAR);
    }

    //
    // Determine how large of a buffer we'll need.
    //
    cbSize += wcslen(pwszOperation);
    cbSize += wcslen(pwszOriginalValueType);
    cbSize += wcslen(pwszFinalValueType);
    cbSize += wcslen(g_pwszOriginalData);
    cbSize += wcslen(g_pwszFinalData);
    cbSize += csFullKeyPath.GetLength();
    cbSize += VALUE_ELEMENT_SIZE;

    if (pwszValueName) {
        cbSize += wcslen(pwszValueName);
    }

    cbSize *= sizeof(WCHAR);

    if (cbSize > g_cbTempBufferSize) {
        //
        // Our global buffer is not large enough; reallocate.
        //
        pTemp = (LPWSTR)MemReAlloc(g_pwszTempBuffer,
                                   cbSize + BUFFER_ALLOCATION_DELTA);

        if (pTemp) {
            g_pwszTempBuffer = (LPWSTR)pTemp;
        } else {
            DPFN(eDbgLevelError,
                 "[FormatValueDataIntoElement] Failed to reallocate memory");
            return;
        }

        g_cbTempBufferSize = cbSize + BUFFER_ALLOCATION_DELTA;
    }

    //
    // Open the <OPERATION> element.
    //
    nChars = wsprintf(g_pwszTempBuffer, L"    <OPERATION TYPE=\"%ls\" KEY_PATH=\"%ls\">\r\n",
                      pwszOperation,
                      csFullKeyPath.Get());

    //
    // Write the <VALUE_NAME> element.
    //
    if (pwszValueName) {
        nChars += wsprintf(g_pwszTempBuffer + nChars, L"        <VALUE_NAME><![CDATA[%ls]]></VALUE_NAME>\r\n",
                           pwszValueName);
    } else {
        nChars += wsprintf(g_pwszTempBuffer + nChars, L"        <VALUE_NAME/>\r\n");
    }

    //
    // Write the <ORIGINAL_DATA> element.
    //
    if (g_pwszOriginalData[0]) {
        nChars += wsprintf(g_pwszTempBuffer + nChars, L"        <ORIGINAL_DATA TYPE=\"%ls\"><![CDATA[%ls]]></ORIGINAL_DATA>\r\n",
                           pwszOriginalValueType,
                           g_pwszOriginalData);
    } else {
        nChars += wsprintf(g_pwszTempBuffer + nChars, L"        <ORIGINAL_DATA/>\r\n");
    }

    //
    // Write the <FINAL_DATA> element.
    //
    if (g_pwszFinalData[0]) {
        nChars += wsprintf(g_pwszTempBuffer + nChars, L"        <FINAL_DATA TYPE=\"%ls\"><![CDATA[%ls]]></FINAL_DATA>\r\n",
                           pwszFinalValueType,
                           g_pwszFinalData);
    } else {
        nChars += wsprintf(g_pwszTempBuffer + nChars, L"        <FINAL_DATA/>\r\n");
    }

    //
    // Close the <OPERATION> element. 
    //
    wsprintf(g_pwszTempBuffer + nChars, L"    </OPERATION>\r\n");

    WriteEntryToLog(g_pwszTempBuffer);

    return;
}

/*++

 Converts binary data into a readable string.
 
--*/
void
ExtractBinaryData(
    IN PVOID       pBinary,
    IN DWORD       dwDataSize,
    IN OUT LPWSTR* pwszString
    )
{
    int     nChars = 0;
    PBYTE   pByte = NULL;
    DWORD   dwLoop = 0;

    if (!pBinary || !pwszString) {
        DPFN(eDbgLevelError, "[ExtractBinaryData] Invalid parameter(s)");
        return;
    }

    pByte = (BYTE*)pBinary;
    dwLoop = dwDataSize / sizeof(WCHAR);
        
    while (dwLoop) {
        nChars += wsprintf(*pwszString + nChars, L"%lx", *pByte++);
        dwLoop--;
    }
}

/*++

 Converts a REG_MULTI_SZ to a readable string.
 
--*/
void
ExtractMultiSzStrings(
    IN     PVOID   pMultiSz,
    IN OUT LPWSTR* pwszString
    )
{
    int     nChars = 0;
    UINT    uSize = 0;
    LPWSTR  pwszTmp = NULL;

    if (!pMultiSz || !pwszString) {
        DPFN(eDbgLevelError, "[ExtractMultiSzStrings] Invalid parameter(s)");
        return;
    }
    
    //
    // Walk the list of NULL-terminated strings and put them in the buffer.
    //
    pwszTmp = (LPWSTR)pMultiSz;
    
    while (TRUE) {
        nChars += wsprintf(*pwszString + nChars, L" %ls", pwszTmp);

        uSize = wcslen(pwszTmp) + 1;
        pwszTmp += uSize;

        if (*pwszTmp == '\0') {
            break;
        }
    } 
}

/*++

 Formats the value data to form an XML element and logs it.
 
--*/
void
FormatValueData(
    IN LPCWSTR       pwszOperation,
    IN PKEY_DATA     pKeyData,
    IN PLOG_OPEN_KEY pLogOpenKey
    )
{
    WCHAR   wszFinalValueType[MAX_DATA_TYPE_LENGTH];
    WCHAR   wszOriginalValueType[MAX_DATA_TYPE_LENGTH];
    LPCWSTR pwszValueName = NULL;
    PVOID   pOriginalTmp = NULL;
    PVOID   pFinalTmp = NULL;

    //
    // If we haven't already, allocate buffers that we'll
    // use and reuse when getting original and final data.
    //
    if (!g_cbOriginalDataBufferSize) {
        g_pwszOriginalData = (LPWSTR)MemAlloc(TEMP_BUFFER_SIZE * sizeof(WCHAR));

        if (!g_pwszOriginalData) {
            DPFN(eDbgLevelError,
                 "[FormatValueData] Failed to allocate memory for old data");
            return;
        }

        g_cbOriginalDataBufferSize = TEMP_BUFFER_SIZE * sizeof(WCHAR);
    }

    if (!g_cbFinalDataBufferSize) {
        g_pwszFinalData = (LPWSTR)MemAlloc(TEMP_BUFFER_SIZE * sizeof(WCHAR));

        if (!g_pwszFinalData) {
            DPFN(eDbgLevelError,
                 "[FormatValueData] Failed to allocate memory for new data");
            return;
        }

        g_cbFinalDataBufferSize = TEMP_BUFFER_SIZE * sizeof(WCHAR);
    }

    g_pwszOriginalData[0] = 0;
    g_pwszFinalData[0] = 0;

    //
    // To make it easier to replace & ' " < and > with their
    // XML entities, we convert the data to CString.
    //
    CString csFullKeyPath(pLogOpenKey->pwszFullKeyPath);
    
    csFullKeyPath.Replace(L"&", L"&amp;");
    csFullKeyPath.Replace(L"<", L"&lt;");
    csFullKeyPath.Replace(L">", L"&gt;");
    csFullKeyPath.Replace(L"'", L"&apos;");
    csFullKeyPath.Replace(L"\"", L"&quot;");

    switch (pKeyData->dwOriginalValueType) {
    case REG_SZ:
        wcscpy(wszOriginalValueType, L"REG_SZ");
        break;
    case REG_EXPAND_SZ:
        wcscpy(wszOriginalValueType, L"REG_EXPAND_SZ");
        break;
    case REG_MULTI_SZ:
        wcscpy(wszOriginalValueType, L"REG_MULTI_SZ");
        break;
    case REG_DWORD:
        wcscpy(wszOriginalValueType, L"REG_DWORD");
        break;
    case REG_BINARY:
        wcscpy(wszOriginalValueType, L"REG_BINARY");
        break;
    default:
        wcscpy(wszOriginalValueType, L"Unknown");
        break;
    }

    switch (pKeyData->dwFinalValueType) {
    case REG_SZ:
        wcscpy(wszFinalValueType, L"REG_SZ");
        break;
    case REG_EXPAND_SZ:
        wcscpy(wszFinalValueType, L"REG_EXPAND_SZ");
        break;
    case REG_MULTI_SZ:
        wcscpy(wszFinalValueType, L"REG_MULTI_SZ");
        break;
    case REG_DWORD:
        wcscpy(wszFinalValueType, L"REG_DWORD");
        break;
    case REG_BINARY:
        wcscpy(wszFinalValueType, L"REG_BINARY");
        break;
    default:
        wcscpy(wszFinalValueType, L"Unknown");
        break;
    }

    //
    // If our temporary buffers are not large enough to store the data, reallocate.
    //
    if (pKeyData->cbOriginalDataSize > g_cbOriginalDataBufferSize) {
        pOriginalTmp = (LPWSTR)MemReAlloc(g_pwszOriginalData,
                                          pKeyData->cbOriginalDataSize + BUFFER_ALLOCATION_DELTA);

        if (pOriginalTmp) {
            g_pwszOriginalData = (LPWSTR)pOriginalTmp;
        } else {
            DPFN(eDbgLevelError,
                 "[FormatValueData] Failed to reallocate for original data");
            return;
        }

        g_cbOriginalDataBufferSize = pKeyData->cbOriginalDataSize + BUFFER_ALLOCATION_DELTA;
    }

    if (pKeyData->cbFinalDataSize > g_cbFinalDataBufferSize) {
        pFinalTmp = (LPWSTR)MemReAlloc(g_pwszFinalData,
                                       pKeyData->cbFinalDataSize + BUFFER_ALLOCATION_DELTA);

        if (pFinalTmp) {
            g_pwszFinalData = (LPWSTR)pFinalTmp;
        } else {
            DPFN(eDbgLevelError,
                 "[FormatValueData] Failed to reallocate for new data");
            return;
        }

        g_cbFinalDataBufferSize = pKeyData->cbFinalDataSize + BUFFER_ALLOCATION_DELTA;
    }

    //
    // Store the original and new data in the buffers.
    // Note that operations are performed differently based on the data type.
    //
    if (pKeyData->pOriginalData) {
        switch (pKeyData->dwOriginalValueType) {
        case REG_DWORD:
            wsprintf(g_pwszOriginalData, L"%lu", (*(DWORD*)pKeyData->pOriginalData));
            break;
            
        case REG_SZ:
        case REG_EXPAND_SZ:
            wcscpy(g_pwszOriginalData, (const WCHAR*)pKeyData->pOriginalData);
            break;

        case REG_MULTI_SZ:
            ExtractMultiSzStrings(pKeyData->pOriginalData,
                                  &g_pwszOriginalData);
            break;

        case REG_BINARY:
            ExtractBinaryData(pKeyData->pOriginalData,
                              pKeyData->cbOriginalDataSize,
                              &g_pwszOriginalData);
            break;

        default:
            DPFN(eDbgLevelError, "[FormatValueData] Unsupported value type");
            break;
        }
    }

    if (pKeyData->pFinalData) {
        switch (pKeyData->dwFinalValueType) {
        case REG_DWORD:
            wsprintf(g_pwszFinalData, L"%lu", (*(DWORD*)pKeyData->pFinalData));
            break;

        case REG_SZ:
        case REG_EXPAND_SZ:
            wcscpy(g_pwszFinalData, (const WCHAR*)pKeyData->pFinalData);
            break;

        case REG_MULTI_SZ:
            ExtractMultiSzStrings(pKeyData->pFinalData,
                                  &g_pwszFinalData);
            break;

        case REG_BINARY:
            ExtractBinaryData(pKeyData->pFinalData,
                              pKeyData->cbFinalDataSize,
                              &g_pwszFinalData);
            break;

        default:
            DPFN(eDbgLevelError, "[FormatValueData] Unsupported value type");
            break;
        }
    }
    
    //
    // Ensure that our unique id doesn't show up in the log.
    //
    if (_wcsicmp(pKeyData->wszValueName, g_wszUniqueId)) {
        pwszValueName = pKeyData->wszValueName;
    }

    //
    // Put the data into an XML element and log it.
    //
    FormatValueDataIntoElement(csFullKeyPath,
                               pwszOperation,
                               pwszValueName,
                               wszOriginalValueType,
                               wszFinalValueType);
}

/*++

 Determines the changes that took place on the specified key and
 if applicable, writes it to the log.
 
--*/
BOOL
EvaluateKeyChanges(
    IN PLOG_OPEN_KEY pLogOpenKey
    )
{
    if (!pLogOpenKey) {
        DPFN(eDbgLevelError, "[EvaluateKeyChanges] Invalid parameter");
        return FALSE;
    }

    //
    // 1. Check for deletion of an existing key.
    //
    if ((pLogOpenKey->dwFlags & LRC_DELETED_KEY) &&
        (pLogOpenKey->dwFlags & LRC_EXISTING_KEY)) {
        FormatKeyDataIntoElement(L"Deleted Key", pLogOpenKey);
        return TRUE;
    }

    //
    // 2. Check for creation of a new key.
    //
    if (!(pLogOpenKey->dwFlags & LRC_EXISTING_KEY) &&
        (!(pLogOpenKey->dwFlags & LRC_DELETED_KEY))) {
        FormatKeyDataIntoElement(L"Created Key", pLogOpenKey);
        return TRUE;
    }

    //
    // 3. Check for deletion of a non-existing key.
    // This is an indicator that we should not look for
    // changes to values below this key.
    //
    if (pLogOpenKey->dwFlags & LRC_DELETED_KEY) {
        return FALSE;
    }

    return TRUE;
}

/*++

 Determines the changes that took place on the specified value and
 if applicable, writes it to the log.
 
--*/
void
EvaluateValueChanges(
    IN PKEY_DATA     pKeyData,
    IN PLOG_OPEN_KEY pLogOpenKey
    )
{
    if (!pKeyData || !pLogOpenKey) {
        DPFN(eDbgLevelError, "[EvaluateValueChanges] Invalid parameter(s)");
        return;
    }

    //
    // 1. Check for deletion of an existing value.
    //
    if ((pKeyData->dwFlags & LRC_DELETED_VALUE) &&
        (pKeyData->dwFlags & LRC_EXISTING_VALUE)) {
        FormatValueData(L"Deleted Value", pKeyData, pLogOpenKey);
        return;
    }

    //
    // 2. Check for modification of an existing value.
    //
    if ((pKeyData->dwFlags & LRC_EXISTING_VALUE) &&
        (pKeyData->dwFlags & LRC_MODIFIED_VALUE)) {
        FormatValueData(L"Modified Value", pKeyData, pLogOpenKey);
        return;
    }

    //
    // 3. Check for creation of a new value value.
    //
    if ((pKeyData->dwFlags & LRC_MODIFIED_VALUE) &&
        (!(pKeyData->dwFlags & LRC_DELETED_VALUE) &&
        (!(pKeyData->dwFlags & LRC_EXISTING_VALUE)))) {
        FormatValueData(L"Created Value", pKeyData, pLogOpenKey);
        return;
    }
}

/*++

 Write the entire linked list out to the log file.
 
--*/
BOOL
WriteListToLogFile(
    void
    )
{
    PLIST_ENTRY   pKeyNext = NULL;
    PLIST_ENTRY   pValueHead = NULL;
    PLIST_ENTRY   pValueNext = NULL;
    PKEY_DATA     pKeyData = NULL;
    PLOG_OPEN_KEY pOpenKey = NULL;
    
    //
    // Write out modifications for keys.
    //
    pKeyNext = g_OpenKeyListHead.Blink;

    while (pKeyNext != &g_OpenKeyListHead) {
        pOpenKey = CONTAINING_RECORD(pKeyNext, LOG_OPEN_KEY, Entry);

        //
        // EvaluateKeyChanges will return TRUE if the key was not
        // deleted. If this is the case, continue the search and
        // evaluate changes to values within this key.
        //
        if (EvaluateKeyChanges(pOpenKey)) {
            //
            // Write out modifications for values.
            //
            pValueHead = &pOpenKey->KeyData;
            pValueNext = pValueHead->Blink;
    
            while (pValueNext != pValueHead) {
                pKeyData = CONTAINING_RECORD(pValueNext, KEY_DATA, Entry);
    
                EvaluateValueChanges(pKeyData, pOpenKey);
    
                pValueNext = pValueNext->Blink;
            }
        }
        
        pKeyNext = pKeyNext->Blink;
    }

    CloseLogFile();

    return TRUE;
}

//
// Begin implementation of the class.
//
LONG
CLogRegistry::CreateKeyExA(
    HKEY                  hKey,
    LPCSTR                pszSubKey,
    DWORD                 Reserved,
    LPSTR                 pszClass,
    DWORD                 dwOptions,
    REGSAM                samDesired,
    LPSECURITY_ATTRIBUTES lpSecurityAttributes,
    PHKEY                 phkResult,
    LPDWORD               lpdwDisposition
    )
{
    LPWSTR  pwszSubKey = NULL;
    LPWSTR  pwszClass = NULL;
    LONG    lRetVal;

    //
    // Stub out to CreateKeyExW.
    //
    if (pszSubKey) {
        if (!ConvertAnsiToUnicode(pszSubKey, &pwszSubKey)) {
            DPFN(eDbgLevelError, "[CreateKeyExA] Ansi -> Unicode failed");
            return ERROR_OUTOFMEMORY;
        }
    }

    if (pszClass) {
        if (!ConvertAnsiToUnicode(pszClass, &pwszClass)) {
            DPFN(eDbgLevelError, "[CreateKeyExA] Ansi to Unicode failed");
            return ERROR_OUTOFMEMORY;
        }
    }

    lRetVal = CreateKeyExW(
        hKey,
        pwszSubKey,
        Reserved,
        pwszClass,
        dwOptions,
        samDesired,
        lpSecurityAttributes,
        phkResult,
        lpdwDisposition);

    if (pwszSubKey) {
        MemFree(pwszSubKey);
    }

    if (pwszClass) {
        MemFree(pwszClass);
    }

    return lRetVal;
}

LONG
CLogRegistry::CreateKeyExW(
    HKEY                  hKey,
    LPCWSTR               pwszSubKey,
    DWORD                 Reserved,
    LPWSTR                pwszClass,
    DWORD                 dwOptions,
    REGSAM                samDesired,
    LPSECURITY_ATTRIBUTES lpSecurityAttributes,
    PHKEY                 phkResult,
    LPDWORD               lpdwDisposition
    )
{
    DWORD   dwDisposition = 0;
    LONG    lRetVal;
    BOOL    fExisting = FALSE;

    if (!lpdwDisposition) {
        lpdwDisposition = &dwDisposition;
    }

    lRetVal = ORIGINAL_API(RegCreateKeyExW)(
        hKey,
        pwszSubKey,
        Reserved,
        pwszClass,
        dwOptions,
        samDesired,
        lpSecurityAttributes,
        phkResult,
        lpdwDisposition);

    if (lRetVal == ERROR_SUCCESS) {
        if (REG_OPENED_EXISTING_KEY == *lpdwDisposition) {
            fExisting = TRUE;
        }

        UpdateKeyList(hKey,
                      *phkResult,
                      pwszSubKey,
                      NULL,
                      fExisting,
                      eAddKeyHandle);
    }

    return lRetVal;    
}

LONG 
CLogRegistry::OpenKeyExA(
    HKEY   hKey,
    LPCSTR pszSubKey,
    DWORD  ulOptions,
    REGSAM samDesired,    
    PHKEY  phkResult    
    )
{
    LPWSTR  pwszSubKey = NULL;
    LONG    lRetVal;

    //
    // Stub out to OpenKeyExW.
    //
    if (pszSubKey) {
        if (!ConvertAnsiToUnicode(pszSubKey, &pwszSubKey)) {
            DPFN(eDbgLevelError, "[OpenKeyExA] Ansi -> Unicode failed");
            return ERROR_OUTOFMEMORY;
        }
    }
     
    lRetVal = OpenKeyExW(
        hKey,
        pwszSubKey,
        ulOptions,
        samDesired,
        phkResult);

    if (pwszSubKey) {
        MemFree(pwszSubKey);
    }

    return lRetVal;
}

LONG 
CLogRegistry::OpenKeyExW(
    HKEY    hKey,
    LPCWSTR pwszSubKey,
    DWORD   ulOptions,
    REGSAM  samDesired,
    PHKEY   phkResult
    )
{
    LONG    lRetVal;
    
    lRetVal = ORIGINAL_API(RegOpenKeyExW)(
        hKey,
        pwszSubKey,
        ulOptions,
        samDesired,
        phkResult);
    
    if (lRetVal == ERROR_SUCCESS) {
        UpdateKeyList(hKey,
                      *phkResult,
                      pwszSubKey,
                      NULL,
                      TRUE,
                      eAddKeyHandle);
    }

    return lRetVal;
}

LONG
CLogRegistry::OpenCurrentUser(
    REGSAM samDesired,
    PHKEY  phkResult
    )
{
    LONG    lRetVal;

    lRetVal = ORIGINAL_API(RegOpenCurrentUser)(
        samDesired,
        phkResult);

    if (lRetVal == ERROR_SUCCESS) {
        UpdateKeyList(HKEY_CURRENT_USER,
                      *phkResult,
                      NULL,
                      NULL,
                      TRUE,
                      eAddKeyHandle);
    }

    return lRetVal;
}

LONG
CLogRegistry::OpenUserClassesRoot(
    HANDLE hToken,
    DWORD  dwOptions,
    REGSAM samDesired,
    PHKEY  phkResult
    )
{
    LONG    lRetVal;

    lRetVal = ORIGINAL_API(RegOpenUserClassesRoot)(
        hToken,
        dwOptions,
        samDesired,
        phkResult);

    if (lRetVal == ERROR_SUCCESS) {
        UpdateKeyList(HKEY_CLASSES_ROOT,
                      *phkResult,
                      NULL,
                      NULL,
                      TRUE,
                      eAddKeyHandle);
    }

    return lRetVal;
}

LONG 
CLogRegistry::SetValueA(
    HKEY   hKey,
    LPCSTR pszSubKey,
    DWORD  dwType,
    LPCSTR lpData,
    DWORD  cbData
    )
{
    LPWSTR  pwszSubKey = NULL;
    LPWSTR  pwszData = NULL;
    LONG    lRetVal;
    
    //
    // Stub out to SetValueW.
    //
    if (pszSubKey) {
        if (!ConvertAnsiToUnicode(pszSubKey, &pwszSubKey)) {
            DPFN(eDbgLevelError, "[SetValueA] Ansi -> Unicode failed");
            return ERROR_OUTOFMEMORY;
        }
    }

    if (lpData) {
        if (!ConvertAnsiToUnicode(lpData, &pwszData)) {
            DPFN(eDbgLevelError, "[SetValueA] Ansi to Unicode failed");
            return ERROR_OUTOFMEMORY;
        }
    }
    
    lRetVal = SetValueW(
        hKey,
        pwszSubKey,
        dwType,
        pwszData,
        cbData * sizeof(WCHAR));

    if (pwszSubKey) {
        MemFree(pwszSubKey);
    }

    if (pwszData) {
        MemFree(pwszData);
    }

    return lRetVal;
}

LONG 
CLogRegistry::SetValueW(
    HKEY    hKey,
    LPCWSTR pwszSubKey,
    DWORD   dwType,
    LPCWSTR lpData,
    DWORD   cbData
    )
{
    HKEY    hKeyLocal;
    LONG    lRetVal;

    //
    // Call OpenKeyEx to force this key to be added to the list.
    //
    if (pwszSubKey) {
        lRetVal = OpenKeyExW(hKey,
                             pwszSubKey,
                             0,
                             KEY_SET_VALUE,
                             &hKeyLocal);
    
        if (ERROR_SUCCESS != lRetVal) {
            DPFN(eDbgLevelError, "[SetValueW] Failed to open key");
            return lRetVal;
        }
    
        lRetVal = SetValueExW(hKeyLocal,
                              NULL,
                              0,
                              dwType,
                              (const BYTE*)lpData,
                              cbData);
    
        CloseKey(hKeyLocal);

        return lRetVal;
    }

    //
    // All other cases will be handled properly.
    //
    lRetVal = SetValueExW(hKey,
                          NULL,
                          0,
                          dwType,
                          (const BYTE*)lpData,
                          cbData);
    
    return lRetVal;
}

LONG 
CLogRegistry::SetValueExA(
    HKEY        hKey, 
    LPCSTR      pszValueName, 
    DWORD       Reserved, 
    DWORD       dwType, 
    CONST BYTE* lpData, 
    DWORD       cbData
    )
{    
    LPWSTR  pwszData = NULL;
    LPWSTR  pwszValueName = NULL;
    LONG    lRetVal;
    BOOL    fString = FALSE;

    //
    // Stub out to SetValueExW.
    //
    if (pszValueName) {
        if (!ConvertAnsiToUnicode(pszValueName, &pwszValueName)) {
            DPFN(eDbgLevelError, "[SetValueExA] Ansi -> Unicode failed");
            return ERROR_OUTOFMEMORY;
        }
    }

    if (REG_SZ == dwType || REG_EXPAND_SZ == dwType || REG_MULTI_SZ == dwType) {
        fString = TRUE;
    }

    //
    // If the data is of type string, convert it to Unicode.
    //
    if (lpData) {
        if (REG_MULTI_SZ == dwType) {
            if (!ConvertMultiSzToUnicode((LPCSTR)lpData, &pwszData)) {
                DPFN(eDbgLevelError, "[SetValueExA] Multi Sz to Unicode failed");
                return ERROR_OUTOFMEMORY;
            }
        }
        else if (REG_SZ == dwType || REG_EXPAND_SZ == dwType) {
            if (!ConvertAnsiToUnicode((LPCSTR)lpData, &pwszData)) {
                DPFN(eDbgLevelError, "[SetValueExA] Ansi to Unicode failed");
                return ERROR_OUTOFMEMORY;
            }
        }
    }

    if (fString) {
        lRetVal = SetValueExW(
            hKey,
            pwszValueName,
            Reserved,
            dwType,
            (const BYTE*)pwszData,
            cbData * sizeof(WCHAR));
    } else {
        lRetVal = SetValueExW(
            hKey,
            pwszValueName,
            Reserved,
            dwType,
            lpData,
            cbData);
    }

    if (pwszValueName) {
        MemFree(pwszValueName);
    }

    if (pwszData) {
        MemFree(pwszData);
    }

    return lRetVal;
}

LONG 
CLogRegistry::SetValueExW(
    HKEY        hKey, 
    LPCWSTR     pwszValueName, 
    DWORD       Reserved, 
    DWORD       dwType, 
    CONST BYTE* lpData, 
    DWORD       cbData
    )
{
    LONG    lRetVal;

    UpdateKeyList(NULL, hKey, NULL, pwszValueName, FALSE, eStartModifyValue);

    lRetVal = ORIGINAL_API(RegSetValueExW)(
        hKey,
        pwszValueName,
        Reserved,
        dwType,
        lpData,
        cbData);

    if (ERROR_SUCCESS == lRetVal) {
        UpdateKeyList(NULL, hKey, NULL, pwszValueName, FALSE, eEndModifyValue);
    }
        
    return lRetVal;
}

LONG 
CLogRegistry::CloseKey(
    HKEY hKey
    )
{
    UpdateKeyList(NULL, hKey, NULL, NULL, TRUE, eRemoveKeyHandle);

    return ORIGINAL_API(RegCloseKey)(hKey);
}

LONG 
CLogRegistry::DeleteKeyA(
    HKEY   hKey,
    LPCSTR pszSubKey
    )
{    
    LPWSTR  pwszSubKey = NULL;
    LONG    lRetVal;
    
    //
    // Stub out to DeleteKeyW.
    //
    if (pszSubKey) {
        if (!ConvertAnsiToUnicode(pszSubKey, &pwszSubKey)) {
            DPFN(eDbgLevelError, "[DeleteKeyA] Ansi -> Unicode failed");
            return ERROR_OUTOFMEMORY;
        }
    }

    lRetVal = DeleteKeyW(hKey, pwszSubKey);

    if (pwszSubKey) {
        MemFree(pwszSubKey);
    }

    return lRetVal;
}

LONG 
CLogRegistry::DeleteKeyW(
    HKEY    hKey,
    LPCWSTR pwszSubKey
    )
{
    LONG    lRetVal;
    HKEY    hKeyLocal;

    //
    // The caller can pass a predefined handle or an open key
    // handle. In all cases, we open the key they're passing
    // to force it into the list. Note that we mainly do
    // this for logging purposes only.
    //
    hKeyLocal = ForceSubKeyIntoList(hKey, pwszSubKey);    

    lRetVal = ORIGINAL_API(RegDeleteKeyW)(hKey, pwszSubKey);
    
    if (ERROR_SUCCESS == lRetVal && hKeyLocal) {
        UpdateKeyList(NULL, hKeyLocal, pwszSubKey, NULL, TRUE, eDeletedKey);
    }

    if (hKeyLocal) {
        CloseKey(hKeyLocal);
    }

    return lRetVal;
}

LONG
CLogRegistry::DeleteValueA(
    HKEY   hKey,
    LPCSTR pszValueName
    )
{
    LPWSTR  pwszValueName = NULL;
    LONG    lRetVal;
    
    //
    // Stub out to DeleteValueW.
    //
    if (pszValueName) {
        if (!ConvertAnsiToUnicode(pszValueName, &pwszValueName)) {
            DPFN(eDbgLevelError, "[DeleteValueA] Ansi -> Unicode failed");
            return ERROR_OUTOFMEMORY;
        }
    }

    lRetVal = DeleteValueW(hKey, pwszValueName);

    if (pwszValueName) {
        MemFree(pwszValueName);
    }

    return lRetVal;
}

LONG
CLogRegistry::DeleteValueW(
    HKEY    hKey,
    LPCWSTR pwszValueName
    )
{
    LONG    lRetVal;

    UpdateKeyList(NULL, hKey, NULL, pwszValueName, TRUE, eStartDeleteValue);
    
    lRetVal = ORIGINAL_API(RegDeleteValueW)(hKey, pwszValueName);

    if (ERROR_SUCCESS == lRetVal) {
        UpdateKeyList(NULL, hKey, NULL, pwszValueName, TRUE, eEndDeleteValue);
    }

    return lRetVal;
}

CLogRegistry clr;

//
// Implemenation of the actual Registry API hooks.
//
LONG 
APIHOOK(RegOpenKeyA)(
    HKEY  hKey,         
    LPSTR lpSubKey,  
    PHKEY phkResult
    )
{
    CLock   cLock;

    return clr.OpenKeyExA(
        hKey, 
        lpSubKey, 
        0,         
        MAXIMUM_ALLOWED, 
        phkResult);
}

LONG 
APIHOOK(RegOpenKeyW)(
    HKEY   hKey,         
    LPWSTR lpSubKey,  
    PHKEY  phkResult
    )
{
    CLock   cLock;

    return clr.OpenKeyExW(
        hKey, 
        lpSubKey,
        0,
        MAXIMUM_ALLOWED,
        phkResult);
}

LONG 
APIHOOK(RegOpenKeyExA)(
    HKEY   hKey,         
    LPCSTR lpSubKey,  
    DWORD  ulOptions,   
    REGSAM samDesired, 
    PHKEY  phkResult
    )
{
    CLock   cLock;

    return clr.OpenKeyExA(
        hKey, 
        lpSubKey, 
        ulOptions,         
        samDesired,       
        phkResult);
}

LONG 
APIHOOK(RegOpenKeyExW)(
    HKEY    hKey,         
    LPCWSTR lpSubKey,  
    DWORD   ulOptions,   
    REGSAM  samDesired, 
    PHKEY   phkResult
    )
{
    CLock   cLock;

    return clr.OpenKeyExW(
        hKey, 
        lpSubKey, 
        ulOptions,
        samDesired,         
        phkResult);
}

LONG
APIHOOK(RegOpenCurrentUser)(
    REGSAM samDesired,
    PHKEY  phkResult
    )
{
    CLock   cLock;

    return clr.OpenCurrentUser(
        samDesired,
        phkResult);
}

LONG
APIHOOK(RegOpenUserClassesRoot)(
    HANDLE hToken,
    DWORD  dwOptions,
    REGSAM samDesired,
    PHKEY  phkResult
    )
{
    CLock   cLock;

    return clr.OpenUserClassesRoot(
        hToken,
        dwOptions,
        samDesired,
        phkResult);
}

LONG 
APIHOOK(RegCreateKeyA)(
    HKEY   hKey,         
    LPCSTR lpSubKey,
    PHKEY  phkResult
    )
{
    CLock   cLock;

    return clr.CreateKeyExA(
        hKey,
        lpSubKey,
        0,
        NULL,
        REG_OPTION_NON_VOLATILE,
        MAXIMUM_ALLOWED,
        NULL,
        phkResult,
        NULL);
}

LONG 
APIHOOK(RegCreateKeyW)(
    HKEY    hKey,         
    LPCWSTR lpSubKey,
    PHKEY   phkResult
    )
{
    CLock   cLock;

    return clr.CreateKeyExW(
        hKey,
        lpSubKey,
        0,
        NULL,
        REG_OPTION_NON_VOLATILE,
        MAXIMUM_ALLOWED,
        NULL,
        phkResult,
        NULL);
}

LONG 
APIHOOK(RegCreateKeyExA)(
    HKEY                  hKey,                
    LPCSTR                lpSubKey,         
    DWORD                 Reserved,           
    LPSTR                 lpClass,           
    DWORD                 dwOptions,          
    REGSAM                samDesired,        
    LPSECURITY_ATTRIBUTES lpSecurityAttributes,
    PHKEY                 phkResult,          
    LPDWORD               lpdwDisposition   
    )
{
    CLock   cLock;

    return clr.CreateKeyExA(
        hKey,
        lpSubKey,
        Reserved,
        lpClass,
        dwOptions,
        samDesired,
        lpSecurityAttributes,
        phkResult,
        lpdwDisposition);
}

LONG 
APIHOOK(RegCreateKeyExW)(
    HKEY                  hKey,                
    LPCWSTR               lpSubKey,         
    DWORD                 Reserved,           
    LPWSTR                lpClass,           
    DWORD                 dwOptions,          
    REGSAM                samDesired,        
    LPSECURITY_ATTRIBUTES lpSecurityAttributes,
    PHKEY                 phkResult,          
    LPDWORD               lpdwDisposition   
    )
{
    CLock   cLock;

    return clr.CreateKeyExW(
        hKey,
        lpSubKey,
        Reserved,
        lpClass,
        dwOptions,
        samDesired,
        lpSecurityAttributes,
        phkResult,
        lpdwDisposition);
}

LONG      
APIHOOK(RegSetValueA)(
    HKEY   hKey, 
    LPCSTR lpSubKey, 
    DWORD  dwType, 
    LPCSTR lpData, 
    DWORD  cbData
    )
{
    CLock   cLock;

    return clr.SetValueA(
        hKey,
        lpSubKey,
        dwType,
        lpData,
        cbData);
}

LONG      
APIHOOK(RegSetValueW)(
    HKEY    hKey, 
    LPCWSTR lpSubKey, 
    DWORD   dwType, 
    LPCWSTR lpData, 
    DWORD   cbData
    )
{
    CLock   cLock;

    return clr.SetValueW(
        hKey,
        lpSubKey,
        dwType,
        lpData,
        cbData);
}

LONG      
APIHOOK(RegSetValueExA)(
    HKEY        hKey, 
    LPCSTR      lpSubKey, 
    DWORD       Reserved, 
    DWORD       dwType, 
    CONST BYTE* lpData, 
    DWORD       cbData
    )
{
    CLock   cLock;

    return clr.SetValueExA(
        hKey,
        lpSubKey,
        Reserved,
        dwType,
        lpData,
        cbData);
}

LONG      
APIHOOK(RegSetValueExW)(
    HKEY        hKey, 
    LPCWSTR     lpSubKey, 
    DWORD       Reserved, 
    DWORD       dwType, 
    CONST BYTE* lpData, 
    DWORD       cbData
    )
{
    CLock   cLock;

    return clr.SetValueExW(
        hKey,
        lpSubKey,
        Reserved,
        dwType,
        lpData,
        cbData);
}

LONG 
APIHOOK(RegCloseKey)(
    HKEY hKey
    )
{
    CLock   cLock;

    return clr.CloseKey(
        hKey);
}

LONG      
APIHOOK(RegDeleteKeyA)(
    HKEY   hKey, 
    LPCSTR lpSubKey
    )
{
    CLock   cLock;

    return clr.DeleteKeyA(
        hKey,
        lpSubKey);
}

LONG      
APIHOOK(RegDeleteKeyW)(
    HKEY    hKey, 
    LPCWSTR lpSubKey
    )
{
    CLock   cLock;

    return clr.DeleteKeyW(
        hKey,
        lpSubKey);
}

LONG
APIHOOK(RegDeleteValueA)(
    HKEY   hKey,
    LPCSTR lpValueName
    )
{
    CLock   cLock;

    return clr.DeleteValueA(
        hKey,
        lpValueName);
}

LONG
APIHOOK(RegDeleteValueW)(
    HKEY    hKey,
    LPCWSTR lpValueName
    )
{
    CLock   cLock;

    return clr.DeleteValueW(
        hKey,
        lpValueName);
}

/*++

 Creates a unique id used to represent NULL values on registry calls.

--*/
void
InitializeNullValueId(
    void
    )
{
    SYSTEMTIME  st;
    WCHAR*      pwszSlash = NULL;
    WCHAR       wszModPathName[MAX_PATH];
    WCHAR       wszShortName[MAX_PATH];

    //
    // Because there is a NULL valuename for every key in the registry,
    // we need a unique key that we can use to represent NULL in our list.
    //
    if (!GetModuleFileName(NULL, wszModPathName, ARRAYSIZE(wszModPathName))) {
        wcscpy(wszModPathName, L"uniqueexeidentifier");
    }

    pwszSlash = wcsrchr(wszModPathName, '\\');

    if (pwszSlash) {
        wcsncpy(wszShortName, ++pwszSlash, (wcslen(pwszSlash)+1));
    }
    
    GetLocalTime(&st);

    //
    // The format of our unique id will look like this:
    // processname.xxx-lrc-yymmdd-default
    //
    wsprintf(g_wszUniqueId,
             L"%ls-lrc-%02hu%02hu%02hu-default",
             wszShortName,
             st.wYear,
             st.wMonth,
             st.wDay);
}

/*++

 Adds the predefined key handles to the list.

--*/
BOOL
AddPredefinedHandlesToList(
    void
    )
{
    UINT            uCount;
    PLOG_OPEN_KEY   pKey = NULL;
    HKEY            rgKeys[NUM_PREDEFINED_HANDLES] = { HKEY_LOCAL_MACHINE,
                                                       HKEY_CLASSES_ROOT,
                                                       HKEY_CURRENT_USER,
                                                       HKEY_USERS,
                                                       HKEY_CURRENT_CONFIG,
                                                       HKEY_DYN_DATA,
                                                       HKEY_PERFORMANCE_DATA };
                                           
    for (uCount = 0; uCount < NUM_PREDEFINED_HANDLES; uCount++) {
        pKey = (PLOG_OPEN_KEY)MemAlloc(sizeof(LOG_OPEN_KEY));

        if (!pKey) {
            DPFN(eDbgLevelError,
                 "[AddPredefinedHandlesToList] No memory available");
            return FALSE;
        }

        pKey->pwszFullKeyPath = (LPWSTR)MemAlloc(MAX_ROOT_LENGTH * sizeof(WCHAR));

        if (!pKey->pwszFullKeyPath) {
            DPFN(eDbgLevelError,
                 "[AddPredefinedHandlesToList] Failed to allocate memory");
            return FALSE;
        }

        if (!PredefinedKeyToString(rgKeys[uCount], &pKey->pwszFullKeyPath)) {
            DPFN(eDbgLevelError,
                "[AddPredefinedHandlesToList] PredefinedKey -> String failed");
            return FALSE;
        }

        pKey->hKeyRoot         = rgKeys[uCount];
        pKey->hKeyBase[0]      = rgKeys[uCount];
        pKey->pwszSubKeyPath   = NULL;
        pKey->dwFlags          = LRC_EXISTING_KEY;
        pKey->cHandles         = 1;

        InitializeListHead(&pKey->KeyData);

        InsertHeadList(&g_OpenKeyListHead, &pKey->Entry);
    }

    return TRUE;
}

/*++

 Initialize the the list head and the log file.

--*/
BOOL
InitializeShim(
    void
    )
{
    CLock   cLock;

    //
    // Initialize our open key handle list head and the
    // key data list head.
    //
    InitializeListHead(&g_OpenKeyListHead);
    
    //
    // Add the predefined handles to the list.
    //
    if (!AddPredefinedHandlesToList()) {
        return FALSE;
    }

    InitializeNullValueId();

    //
    // Initialize our log file.
    //
    return InitializeLogFile();
}

/*++

 Handle process attach notification.

--*/
BOOL
NOTIFY_FUNCTION(
    DWORD fdwReason
    )
{
    if (fdwReason == DLL_PROCESS_ATTACH) {
        return InitializeShim();
    } else if (fdwReason == DLL_PROCESS_DETACH) {
        return WriteListToLogFile();
    }

    return TRUE;
}

SHIM_INFO_BEGIN()

    SHIM_INFO_DESCRIPTION(AVS_LOGREGCHANGES_DESC)
    SHIM_INFO_FRIENDLY_NAME(AVS_LOGREGCHANGES_FRIENDLY)
    SHIM_INFO_VERSION(1, 5)
    SHIM_INFO_FLAGS(AVRF_FLAG_NO_DEFAULT)

SHIM_INFO_END()

/*++

 Register hooked functions.

--*/

HOOK_BEGIN

    CALL_NOTIFY_FUNCTION

    DUMP_VERIFIER_LOG_ENTRY(VLOG_LOGREGCHANGES_LOGLOC, 
                            AVS_LOGREGCHANGES_LOGLOC,
                            AVS_LOGREGCHANGES_LOGLOC_R,
                            AVS_LOGREGCHANGES_LOGLOC_URL)

    APIHOOK_ENTRY(ADVAPI32.DLL,                      RegOpenKeyA)
    APIHOOK_ENTRY(ADVAPI32.DLL,                      RegOpenKeyW)
    APIHOOK_ENTRY(ADVAPI32.DLL,                    RegOpenKeyExA)
    APIHOOK_ENTRY(ADVAPI32.DLL,                    RegOpenKeyExW)
    APIHOOK_ENTRY(ADVAPI32.DLL,               RegOpenCurrentUser)
    APIHOOK_ENTRY(ADVAPI32.DLL,           RegOpenUserClassesRoot)
    
    APIHOOK_ENTRY(ADVAPI32.DLL,                    RegCreateKeyA)
    APIHOOK_ENTRY(ADVAPI32.DLL,                    RegCreateKeyW)
    APIHOOK_ENTRY(ADVAPI32.DLL,                  RegCreateKeyExA)
    APIHOOK_ENTRY(ADVAPI32.DLL,                  RegCreateKeyExW)

    APIHOOK_ENTRY(ADVAPI32.DLL,                     RegSetValueA)
    APIHOOK_ENTRY(ADVAPI32.DLL,                     RegSetValueW)
    APIHOOK_ENTRY(ADVAPI32.DLL,                   RegSetValueExA)
    APIHOOK_ENTRY(ADVAPI32.DLL,                   RegSetValueExW)

    APIHOOK_ENTRY(ADVAPI32.DLL,                    RegDeleteKeyA)
    APIHOOK_ENTRY(ADVAPI32.DLL,                    RegDeleteKeyW)

    APIHOOK_ENTRY(ADVAPI32.DLL,                  RegDeleteValueA)
    APIHOOK_ENTRY(ADVAPI32.DLL,                  RegDeleteValueW)

    APIHOOK_ENTRY(ADVAPI32.DLL,                      RegCloseKey)

HOOK_END

IMPLEMENT_SHIM_END
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\appcompat\shims\verifier\main.cpp ===
/*++

 Copyright (c) 2000 Microsoft Corporation

 Module Name:

    Main.cpp

 Abstract:

    Container for all verifier shims definitions.

 History:

    01/25/2000 clupu Created

--*/

#include "precomp.h"
#include "ShimHookMacro.h"
#include "veriflog.h"
#include "ids.h"

DECLARE_SHIM(FilePaths)
DECLARE_SHIM(HighVersionLie)
DECLARE_SHIM(RegistryChecks)
DECLARE_SHIM(LogStartAndStop)
DECLARE_SHIM(WindowsFileProtection)
DECLARE_SHIM(DXFileVersionInfo)
DECLARE_SHIM(LogRegistryChanges)
DECLARE_SHIM(LogFileChanges)
DECLARE_SHIM(ObsoleteAPICalls)
DECLARE_SHIM(KernelModeDriverInstall)
DECLARE_SHIM(SecurityChecks)

VOID MULTISHIM_NOTIFY_FUNCTION()(DWORD fdwReason)
{
    switch (fdwReason)
    {
        case DLL_PROCESS_ATTACH:
            
            DPF("VerifierShims", eDbgLevelSpew, "Verifier Shims initialized.");
            break;
    
        case DLL_PROCESS_DETACH:
            DPF("VerifierShims", eDbgLevelSpew, "Verifier Shims uninitialized.");
            break;

        case SHIM_PROCESS_DYING:
            //
            // Push our DLL to be the last one to be unloaded.
            //
            MakeShimUnloadLast(NULL);
            break;
        
        default:
            break;
    }
}

MULTISHIM_BEGIN()
    
    INIT_VLOG_SUPPORT()

    MULTISHIM_ENTRY(LogStartAndStop)
    MULTISHIM_ENTRY(FilePaths)
    MULTISHIM_ENTRY(HighVersionLie)
    MULTISHIM_ENTRY(RegistryChecks)
    MULTISHIM_ENTRY(WindowsFileProtection)
    MULTISHIM_ENTRY(DXFileVersionInfo)
    MULTISHIM_ENTRY(LogRegistryChanges)
    MULTISHIM_ENTRY(LogFileChanges)
    MULTISHIM_ENTRY(ObsoleteAPICalls)
    MULTISHIM_ENTRY(KernelModeDriverInstall)
    MULTISHIM_ENTRY(SecurityChecks)

    CALL_MULTISHIM_NOTIFY_FUNCTION()
MULTISHIM_END()

DECLARE_VERIFIER_DLL()

DECLARE_VERIFIER_SHIM(LogStartAndStop)
DECLARE_VERIFIER_SHIM(FilePaths)
DECLARE_VERIFIER_SHIM(HighVersionLie)
DECLARE_VERIFIER_SHIM(RegistryChecks)
DECLARE_VERIFIER_SHIM(WindowsFileProtection)
DECLARE_VERIFIER_SHIM(DXFileVersionInfo)
DECLARE_VERIFIER_SHIM(LogRegistryChanges)
DECLARE_VERIFIER_SHIM(LogFileChanges)
DECLARE_VERIFIER_SHIM(ObsoleteAPICalls)
DECLARE_VERIFIER_SHIM(KernelModeDriverInstall)
DECLARE_VERIFIER_SHIM(SecurityChecks)

ENUM_VERIFIER_SHIMS_BEGIN()

    ENUM_VERIFIER_SHIMS_ENTRY(LogStartAndStop)
    ENUM_VERIFIER_SHIMS_ENTRY(FilePaths)
    ENUM_VERIFIER_SHIMS_ENTRY(HighVersionLie)
    ENUM_VERIFIER_SHIMS_ENTRY(RegistryChecks)
    ENUM_VERIFIER_SHIMS_ENTRY(WindowsFileProtection)
    ENUM_VERIFIER_SHIMS_ENTRY(DXFileVersionInfo)
    ENUM_VERIFIER_SHIMS_ENTRY(LogRegistryChanges)
    ENUM_VERIFIER_SHIMS_ENTRY(LogFileChanges)
    ENUM_VERIFIER_SHIMS_ENTRY(ObsoleteAPICalls)
    ENUM_VERIFIER_SHIMS_ENTRY(KernelModeDriverInstall)
    ENUM_VERIFIER_SHIMS_ENTRY(SecurityChecks)

ENUM_VERIFIER_SHIMS_END()
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\appcompat\shims\verifier\registrychecks.h ===
/*++

 Copyright (c) 2001 Microsoft Corporation

 Module Name:

    RegistryChecks.h

 History:

    03/09/2001 maonis  Created

--*/

#ifndef __APPVERIFIER_REGCHK_H_
#define __APPVERIFIER_REGCHK_H_

#include "precomp.h"

//
// We keep a list of keys currently open so we know where a key is 
// originated from.
// 
struct RCOPENKEY
{
    RCOPENKEY *next;
    
    HKEY hkBase;
    WCHAR wszPath[MAX_PATH];
};

struct RCWARNING
{
    WCHAR wszPath[MAX_PATH];
    DWORD dwAVStatus;
    DWORD cLen;
};

#define HKCU_AppEvents_STR                  L"HKCU\\AppEvents"
#define HKCU_Console_STR                    L"HKCU\\Console"
#define HKCU_ControlPanel_STR               L"HKCU\\Control Panel"
#define HKCU_Environment_STR                L"HKCU\\Environment"
#define HKCU_Identities_STR                 L"HKCU\\Identities"
#define HKCU_KeyboardLayout_STR             L"HKCU\\Keyboard Layout"
#define HKCU_Printers_STR                   L"HKCU\\Printers"
#define HKCU_RemoteAccess_STR               L"HKCU\\RemoteAccess"
#define HKCU_SessionInformation_STR         L"HKCU\\SessionInformation"
#define HKCU_UNICODEProgramGroups_STR       L"HKCU\\UNICODE Program Groups"
#define HKCU_VolatileEnvironment_STR        L"HKCU\\Volatile Environment"
#define HKCU_Windows31MigrationStatus_STR   L"HKCU\\Windows 3.1 Migration Status"
#define HKLM_HARDWARE_STR                   L"HKLM\\HARDWARE"
#define HKLM_SAM_STR                        L"HKLM\\SAM"
#define HKLM_SECURITY_STR                   L"HKLM\\SECURITY"
#define HKLM_SYSTEM_STR                     L"HKLM\\SYSTEM"
#define HKCC_STR                            L"HKCC"
#define HKUS_STR                            L"HKUS"

#define NUM_OF_CHAR(x) sizeof(x) / 2 - 1

//
// The reg class that does all the real work.
//

class CRegistryChecks
{
public:

    LONG OpenKeyExA(
        HKEY hKey,
        LPCSTR lpSubKey,
        LPSTR lpClass,
        DWORD dwOptions,
        REGSAM samDesired,
        LPSECURITY_ATTRIBUTES lpSecurityAttributes,
        PHKEY phkResult,
        LPDWORD lpdwDisposition,
        BOOL bCreate
        );

    LONG OpenKeyExW(
        HKEY hKey,
        LPCWSTR lpSubKey,
        LPWSTR lpClass,
        DWORD dwOptions,
        REGSAM samDesired,
        LPSECURITY_ATTRIBUTES lpSecurityAttributes,
        PHKEY phkResult,
        LPDWORD lpdwDisposition,
        BOOL bCreate
        );

    LONG QueryValueA(
        HKEY hKey,
        LPCSTR lpSubKey,
        LPSTR lpValue,
        PLONG lpcbValue
        );

    LONG QueryValueW(
        HKEY hKey,
        LPCWSTR lpSubKey,
        LPWSTR lpValue,
        PLONG lpcbValue
        );

    LONG QueryValueExA(
        HKEY    hKey,
        LPCSTR   lpValueName,
        LPDWORD lpReserved,
        LPDWORD lpType,
        LPBYTE  lpData,
        LPDWORD lpcbData
        );

    LONG QueryValueExW(
        HKEY    hKey,
        LPCWSTR   lpValueName,
        LPDWORD lpReserved,
        LPDWORD lpType,
        LPBYTE  lpData,
        LPDWORD lpcbData
        );

    LONG QueryInfoKeyA(
        HKEY hKey,                
        LPSTR lpClass,           
        LPDWORD lpcbClass,        
        LPDWORD lpReserved,       
        LPDWORD lpcSubKeys,       
        LPDWORD lpcbMaxSubKeyLen, 
        LPDWORD lpcbMaxClassLen,  
        LPDWORD lpcValues,        
        LPDWORD lpcbMaxValueNameLen,
        LPDWORD lpcbMaxValueLen,  
        LPDWORD lpcbSecurityDescriptor,
        PFILETIME lpftLastWriteTime   
        );

    LONG QueryInfoKeyW(
        HKEY hKey,                
        LPWSTR lpClass,           
        LPDWORD lpcbClass,        
        LPDWORD lpReserved,       
        LPDWORD lpcSubKeys,       
        LPDWORD lpcbMaxSubKeyLen, 
        LPDWORD lpcbMaxClassLen,  
        LPDWORD lpcValues,        
        LPDWORD lpcbMaxValueNameLen,
        LPDWORD lpcbMaxValueLen,  
        LPDWORD lpcbSecurityDescriptor,
        PFILETIME lpftLastWriteTime   
        );

    LONG SetValueA(
        HKEY hKey,
        LPCSTR lpSubKey,
        DWORD dwType,
        LPCSTR lpData,
        DWORD cbData
        );

    LONG SetValueW(
        HKEY hKey,
        LPCWSTR lpSubKey,
        DWORD dwType,
        LPCWSTR lpData,
        DWORD cbData
        );

    LONG SetValueExA(
        HKEY hKey, 
        LPCSTR lpValueName, 
        DWORD Reserved, 
        DWORD dwType, 
        CONST BYTE * lpData, 
        DWORD cbData
        );

    LONG SetValueExW(
        HKEY hKey, 
        LPCWSTR lpValueName, 
        DWORD Reserved, 
        DWORD dwType, 
        CONST BYTE * lpData, 
        DWORD cbData
        );

    LONG EnumValueA(
        HKEY hKey,
        DWORD dwIndex,
        LPSTR lpValueName,
        LPDWORD lpcbValueName,
        LPDWORD lpReserved,
        LPDWORD lpType,
        LPBYTE lpData,
        LPDWORD lpcbData
        );

    LONG EnumValueW(
        HKEY hKey,
        DWORD dwIndex,
        LPWSTR lpValueName,
        LPDWORD lpcbValueName,
        LPDWORD lpReserved,
        LPDWORD lpType,
        LPBYTE lpData,
        LPDWORD lpcbData
        );

    LONG EnumKeyExA(
        HKEY hKey,
        DWORD dwIndex,
        LPSTR lpName,
        LPDWORD lpcbName,
        LPDWORD lpReserved,
        LPSTR lpClass,
        LPDWORD lpcbClass,
        PFILETIME lpftLastWriteTime 
        );

    LONG EnumKeyExW(
        HKEY hKey,
        DWORD dwIndex,
        LPWSTR lpName,
        LPDWORD lpcbName,
        LPDWORD lpReserved,
        LPWSTR lpClass,
        LPDWORD lpcbClass,
        PFILETIME lpftLastWriteTime 
        );

    LONG CloseKey(
        HKEY hKey
        );

    LONG DeleteKeyA(
        HKEY hKey,
        LPCSTR lpSubKey
        );

    LONG DeleteKeyW(
        HKEY hKey,
        LPCWSTR lpSubKey
        );

private:
    RCOPENKEY* FindKey(HKEY hKey);

    BOOL AddKey(
        HKEY hKey,
        LPCWSTR pwszPath
        );

    LONG OpenKeyExOriginalW(
        HKEY hKey,
        LPCWSTR lpSubKey,
        LPWSTR lpClass,
        DWORD dwOptions,
        REGSAM samDesired,
        LPSECURITY_ATTRIBUTES lpSecurityAttributes,
        PHKEY phkResult,
        LPDWORD lpdwDisposition,
        BOOL bCreate
        );

    VOID Check(    
        HKEY hKey,
        LPCSTR lpSubKey,
        BOOL fCheckRead,
        BOOL fCheckWrite,
        REGSAM samDesired = 0
        );

    VOID Check(    
        HKEY hKey,
        LPCWSTR lpSubKey,
        BOOL fCheckRead,
        BOOL fCheckWrite,
        REGSAM samDesired = 0
        );

    RCOPENKEY* keys;
};

APIHOOK_ENUM_BEGIN

    APIHOOK_ENUM_ENTRY(RegOpenKeyA)
    APIHOOK_ENUM_ENTRY(RegOpenKeyW)
    APIHOOK_ENUM_ENTRY(RegOpenKeyExA)
    APIHOOK_ENUM_ENTRY(RegOpenKeyExW)
    APIHOOK_ENUM_ENTRY(RegCreateKeyA)
    APIHOOK_ENUM_ENTRY(RegCreateKeyW)
    APIHOOK_ENUM_ENTRY(RegCreateKeyExA)
    APIHOOK_ENUM_ENTRY(RegCreateKeyExW)
    APIHOOK_ENUM_ENTRY(RegCloseKey)
    APIHOOK_ENUM_ENTRY(RegQueryValueA)
    APIHOOK_ENUM_ENTRY(RegQueryValueW)
    APIHOOK_ENUM_ENTRY(RegQueryValueExA)
    APIHOOK_ENUM_ENTRY(RegQueryValueExW)
    APIHOOK_ENUM_ENTRY(RegQueryInfoKeyA)
    APIHOOK_ENUM_ENTRY(RegQueryInfoKeyW)
    APIHOOK_ENUM_ENTRY(RegSetValueA)
    APIHOOK_ENUM_ENTRY(RegSetValueW)
    APIHOOK_ENUM_ENTRY(RegSetValueExA)
    APIHOOK_ENUM_ENTRY(RegSetValueExW)
    APIHOOK_ENUM_ENTRY(RegEnumValueA)
    APIHOOK_ENUM_ENTRY(RegEnumValueW)
    APIHOOK_ENUM_ENTRY(RegEnumKeyA)
    APIHOOK_ENUM_ENTRY(RegEnumKeyW)
    APIHOOK_ENUM_ENTRY(RegEnumKeyExA)
    APIHOOK_ENUM_ENTRY(RegEnumKeyExW)
    APIHOOK_ENUM_ENTRY(RegDeleteKeyA)
    APIHOOK_ENUM_ENTRY(RegDeleteKeyW)

APIHOOK_ENUM_END


#endif // __APPVERIFIER_REGCHK_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\appcompat\shims\verifier\sources.inc ===
!IF 0

Copyright (c) 1990  Microsoft Corporation

Module Name:

    sources.

!ENDIF

TARGETNAME=AcVerfyr

DLLDEF=..\verifier.def

TARGETTYPE=DYNLINK

SOURCES=..\verifier.rc                             \
        ..\Main.cpp                                \
        ..\FilePaths.cpp                           \
        ..\HighVersionLie.cpp                      \
        ..\LogStartAndStop.cpp                     \
        ..\RegistryChecks.cpp                      \
        ..\WindowsFileProtection.cpp               \
        ..\DXFileVersionInfo.cpp                   \
        ..\LogRegistryChanges.cpp                  \
        ..\LogFileChanges.cpp                      \
        ..\ObsoleteAPICalls.cpp                    \
        ..\KernelModeDriverInstall.cpp             \
        ..\SecurityChecks.cpp

C_DEFINES=$(C_DEFINES) -DSHIM_HOOKDLL_VERSION2

TARGETPATH=$(_OBJ_DIR)

INCLUDES=$(INCLUDES);                               \
         ..

TARGETLIBS=$(TARGETLIBS)                                                \
           $(WINDOWS_LIB_PATH)\avrflib.lib     \
           $(PROJECT_ROOT)\appcompat\sdbapi\lib\$(O)\sdbapil.lib        \
           $(SDK_LIB_PATH)\shell32.lib                                  \
           $(SDK_LIB_PATH)\advapi32.lib                                 \
           $(SDK_LIB_PATH)\user32.lib                                   \
           $(SDK_LIB_PATH)\ntdll.lib                                    \
           $(SDK_LIB_PATH)\sfc.lib                                      \
           $(SDK_LIB_PATH)\version.lib

PRECOMPILED_CXX=1
PRECOMPILED_INCLUDE=..\precomp.h
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\appcompat\shims\verifier\windowsfileprotection.cpp ===
/*++

 Copyright (c) 2001 Microsoft Corporation

 Module Name:

   WindowsFileProtection.cpp

 Abstract:

   This AppVerifier shim hooks the file I/O APIs that could
   potentially change a file under Windows File Protection.
   
   When one of the files is accessed or modified, an event
   is written to the log.

 Notes:

   This is a general purpose shim.

 History:

   06/25/2001   rparsons    Created
   
   11/26/2001   rparsons    Remove unused local variables.
                            Make SHFileOperation more efficent.

--*/

#include "precomp.h"
#include "rtlutils.h"
#include "sfc.h"

IMPLEMENT_SHIM_BEGIN(WindowsFileProtection)
#include "ShimHookMacro.h"

//
// verifier log entries
//
BEGIN_DEFINE_VERIFIER_LOG(WindowFileProtection)
    VERIFIER_LOG_ENTRY(VLOG_WFP_COPYFILE)
    VERIFIER_LOG_ENTRY(VLOG_WFP_MOVEFILE)
    VERIFIER_LOG_ENTRY(VLOG_WFP_DELETEFILE)
    VERIFIER_LOG_ENTRY(VLOG_WFP_REPLACEFILE)
    VERIFIER_LOG_ENTRY(VLOG_WFP_WRITEFILE)
    VERIFIER_LOG_ENTRY(VLOG_WFP_OPENFILE)
    VERIFIER_LOG_ENTRY(VLOG_WFP_SHFILEOP)
END_DEFINE_VERIFIER_LOG(WindowFileProtection)

INIT_VERIFIER_LOG(WindowFileProtection);

APIHOOK_ENUM_BEGIN

    APIHOOK_ENUM_ENTRY(CreateFileA)
    APIHOOK_ENUM_ENTRY(CreateFileW)
    APIHOOK_ENUM_ENTRY(OpenFile)
    
    APIHOOK_ENUM_ENTRY(CopyFileA)
    APIHOOK_ENUM_ENTRY(CopyFileW)
    APIHOOK_ENUM_ENTRY(CopyFileExA)
    APIHOOK_ENUM_ENTRY(CopyFileExW)
    APIHOOK_ENUM_ENTRY(DeleteFileA)
    APIHOOK_ENUM_ENTRY(DeleteFileW)
    APIHOOK_ENUM_ENTRY(MoveFileA)
    APIHOOK_ENUM_ENTRY(MoveFileW)
    APIHOOK_ENUM_ENTRY(MoveFileExA)
    APIHOOK_ENUM_ENTRY(MoveFileExW)
    APIHOOK_ENUM_ENTRY(MoveFileWithProgressA)
    APIHOOK_ENUM_ENTRY(MoveFileWithProgressW)
    APIHOOK_ENUM_ENTRY(ReplaceFileA)
    APIHOOK_ENUM_ENTRY(ReplaceFileW)
    APIHOOK_ENUM_ENTRY(SHFileOperationA)
    APIHOOK_ENUM_ENTRY(SHFileOperationW)

    APIHOOK_ENUM_ENTRY(_lcreat)
    APIHOOK_ENUM_ENTRY(_lopen)

    APIHOOK_ENUM_ENTRY(NtCreateFile)
    APIHOOK_ENUM_ENTRY(NtOpenFile)

APIHOOK_ENUM_END

/*++

 ANSI wrapper for SfcIsFileProtected.

--*/
BOOL
IsFileProtected(
    LPCSTR pszFileName
    )
{
    LPWSTR  pwszWideFileName = NULL;
    int     nLen = 0;
    BOOL    fReturn = FALSE;

    //
    // Convert from ANSI to Unicode.
    //
    nLen = lstrlenA(pszFileName);

    if (nLen) {
    
        pwszWideFileName = (LPWSTR)RtlAllocateHeap(RtlProcessHeap(),
                                                   HEAP_ZERO_MEMORY,
                                                   (nLen + 1) * sizeof(WCHAR));
        
        if (!pwszWideFileName) {
            DPFN(eDbgLevelError, "[IsFileProtected] Failed to allocate memory");
            return FALSE;
        }
    
        if (!MultiByteToWideChar(CP_ACP,
                                 0,
                                 pszFileName,
                                 -1,
                                 pwszWideFileName,
                                 nLen * sizeof(WCHAR))) {
            DPFN(eDbgLevelError, "[IsFileProtected] ANSI -> Unicode failed");
            goto cleanup;
        }
    
        fReturn = SfcIsFileProtected(NULL, pwszWideFileName);
    }

cleanup:

    if (pwszWideFileName) {
        RtlFreeHeap(RtlProcessHeap(), 0, pwszWideFileName);
    }

    return (fReturn);
}

/*++

 Wraps SfcIsFileProtected for NT path names.

--*/
BOOL
IsNtFileProtected(
    IN PUNICODE_STRING pstrNtFileName
    )
{
    NTSTATUS                    status;
    RTL_UNICODE_STRING_BUFFER   DosPath;
    BOOL                        fReturn = FALSE;
    UCHAR                       DosPathBuffer[MAX_PATH * 2];

    if (!pstrNtFileName) {
        DPFN(eDbgLevelError, "[IsNtFileProtected] Invalid parameter");
        return FALSE;
    }

    //
    // Convert from an NT path to a DOS path.
    //
    RtlInitUnicodeStringBuffer(&DosPath, DosPathBuffer, sizeof(DosPathBuffer));
    
    status = ShimAssignUnicodeStringBuffer(&DosPath, pstrNtFileName);

    if (!NT_SUCCESS(status)) {
        DPFN(eDbgLevelError, "[IsNtFileProtected] Failed to initialize DOS path buffer");
        return fReturn;
    }

    status = ShimNtPathNameToDosPathName(0, &DosPath, NULL, NULL);
    
    if (!NT_SUCCESS(status)) {
        DPFN(eDbgLevelError, "[IsNtFileProtected] Failed to convert NT \"%ls\" to DOS path",
            pstrNtFileName->Buffer);
        goto cleanup;
    }

    //
    // Now check for a protected file.
    //
    if (SfcIsFileProtected(NULL, DosPath.String.Buffer)) {
        fReturn = TRUE;
    }

cleanup:

    RtlFreeUnicodeStringBuffer(&DosPath);

    return (fReturn);
}

BOOL
APIHOOK(CopyFileA)(
    LPCSTR lpExistingFileName,  
    LPCSTR lpNewFileName,       
    BOOL   bFailIfExists        
    )
{
    //
    // Ensure that the destination is not protected.
    //
    if (!bFailIfExists && IsFileProtected(lpNewFileName)) {
        VLOG(VLOG_LEVEL_ERROR,
             VLOG_WFP_COPYFILE, 
             "API: CopyFileA  Filename: %s", 
             lpNewFileName);
    }

    return ORIGINAL_API(CopyFileA)(lpExistingFileName,
                                   lpNewFileName,
                                   bFailIfExists);
}

BOOL
APIHOOK(CopyFileW)(
    LPCWSTR lpExistingFileName,  
    LPCWSTR lpNewFileName,       
    BOOL    bFailIfExists        
    )
{
    //
    // Ensure that the destination is not protected.
    //
    if (!bFailIfExists && SfcIsFileProtected(NULL, lpNewFileName)) {
        VLOG(VLOG_LEVEL_ERROR,
             VLOG_WFP_COPYFILE, 
             "API: CopyFileW  Filename: %ls", 
             lpNewFileName);
    }
    
    return ORIGINAL_API(CopyFileW)(lpExistingFileName,
                                   lpNewFileName,
                                   bFailIfExists);
}

BOOL
APIHOOK(CopyFileExA)(
    LPCSTR             lpExistingFileName,
    LPCSTR             lpNewFileName,
    LPPROGRESS_ROUTINE lpProgressRoutine,
    LPVOID             lpData,
    LPBOOL             pbCancel,
    DWORD              dwCopyFlags
    )
{
    //
    // Ensure that the destination is not protected.
    //
    if (!(dwCopyFlags & COPY_FILE_FAIL_IF_EXISTS) && 
        IsFileProtected(lpNewFileName)) {
        VLOG(VLOG_LEVEL_ERROR,
             VLOG_WFP_COPYFILE,
             "API: CopyFileExA  Filename: %s", 
             lpNewFileName);
    }

    return ORIGINAL_API(CopyFileExA)(lpExistingFileName,
                                     lpNewFileName,
                                     lpProgressRoutine,
                                     lpData,
                                     pbCancel,
                                     dwCopyFlags);

}

BOOL
APIHOOK(CopyFileExW)(
    LPCWSTR            lpExistingFileName,
    LPCWSTR            lpNewFileName,
    LPPROGRESS_ROUTINE lpProgressRoutine,
    LPVOID             lpData,
    LPBOOL             pbCancel,
    DWORD              dwCopyFlags
    )
{
    //
    // Ensure that the destination is not protected.
    //
    if (!(dwCopyFlags & COPY_FILE_FAIL_IF_EXISTS) && 
        SfcIsFileProtected(NULL, lpNewFileName)) {
        VLOG(VLOG_LEVEL_ERROR,
             VLOG_WFP_COPYFILE,
             "API: CopyFileExW  Filename: %ls", 
             lpNewFileName);
    }

    return ORIGINAL_API(CopyFileExW)(lpExistingFileName,
                                     lpNewFileName,
                                     lpProgressRoutine,
                                     lpData,
                                     pbCancel,
                                     dwCopyFlags);

}

BOOL
APIHOOK(DeleteFileA)(
    LPCSTR lpFileName
    )
{
    if (IsFileProtected(lpFileName)) {
        VLOG(VLOG_LEVEL_ERROR,
             VLOG_WFP_DELETEFILE, 
             "API: DeleteFileA  Filename: %s", 
             lpFileName);
    }

    return ORIGINAL_API(DeleteFileA)(lpFileName);
}

BOOL
APIHOOK(DeleteFileW)(
    LPCWSTR lpFileName
    )
{
    if (SfcIsFileProtected(NULL, lpFileName)) {
        VLOG(VLOG_LEVEL_ERROR,
             VLOG_WFP_DELETEFILE, 
             "API: DeleteFileW  Filename: %ls", 
             lpFileName);
    }

    return ORIGINAL_API(DeleteFileW)(lpFileName);
}

BOOL
APIHOOK(MoveFileA)(
    LPCSTR lpExistingFileName,
    LPCSTR lpNewFileName
    )
{
    //
    // Ensure that the source or destination is not protected.
    //
    if (IsFileProtected(lpExistingFileName) || 
        IsFileProtected(lpNewFileName)) {
        VLOG(VLOG_LEVEL_ERROR,
             VLOG_WFP_MOVEFILE, 
             "API: MoveFileA  Filename: %s  Filename: %s",
             lpExistingFileName, 
             lpNewFileName);
    }

    return ORIGINAL_API(MoveFileA)(lpExistingFileName,
                                   lpNewFileName);
}

BOOL
APIHOOK(MoveFileW)(
    LPCWSTR lpExistingFileName,
    LPCWSTR lpNewFileName
    )
{
    //
    // Ensure that the source or destination is not protected.
    //
    if (SfcIsFileProtected(NULL, lpExistingFileName) || 
        SfcIsFileProtected(NULL, lpNewFileName)) {
        VLOG(VLOG_LEVEL_ERROR,
             VLOG_WFP_MOVEFILE, 
             "API: MoveFileW  Filename: %ls  Filename: %ls",
             lpExistingFileName,
             lpNewFileName);
    }

    return ORIGINAL_API(MoveFileW)(lpExistingFileName,
                                   lpNewFileName);
}

BOOL
APIHOOK(MoveFileExA)(
    LPCSTR lpExistingFileName,
    LPCSTR lpNewFileName,
    DWORD  dwFlags
    )
{
    //
    // Ensure that the source or destination is not protected.
    //
    if (IsFileProtected(lpExistingFileName) || 
        IsFileProtected(lpNewFileName)) {
        VLOG(VLOG_LEVEL_ERROR,
             VLOG_WFP_MOVEFILE, 
             "API: MoveFileExA  Filename: %s  Filename: %s",
             lpExistingFileName, 
             lpNewFileName);
    }

    return ORIGINAL_API(MoveFileExA)(lpExistingFileName,
                                     lpNewFileName,
                                     dwFlags);
}

BOOL
APIHOOK(MoveFileExW)(
    LPCWSTR lpExistingFileName,
    LPCWSTR lpNewFileName,
    DWORD   dwFlags
    )
{
    //
    // Ensure that the source or destination is not protected.
    //
    if (SfcIsFileProtected(NULL, lpExistingFileName) || 
        SfcIsFileProtected(NULL, lpNewFileName)) {
        VLOG(VLOG_LEVEL_ERROR,
             VLOG_WFP_MOVEFILE, "API: MoveFileExW  Filename: %ls  Filename: %ls",
             lpExistingFileName, 
             lpNewFileName);
    }

    return ORIGINAL_API(MoveFileExW)(lpExistingFileName,
                                     lpNewFileName,
                                     dwFlags);
}

BOOL
APIHOOK(MoveFileWithProgressA)(
    LPCSTR             lpExistingFileName,
    LPCSTR             lpNewFileName,
    LPPROGRESS_ROUTINE lpProgressRoutine,
    LPVOID             lpData,
    DWORD              dwFlags
    )
{
    //
    // Ensure that the source or destination is not protected.
    //
    if (IsFileProtected(lpExistingFileName) || 
        IsFileProtected(lpNewFileName)) {
        VLOG(VLOG_LEVEL_ERROR,
             VLOG_WFP_MOVEFILE,
             "API: MoveFileWithProgressA  Filename: %s  Filename: %s",
             lpExistingFileName,
             lpNewFileName);
    }

    return ORIGINAL_API(MoveFileWithProgressA)(lpExistingFileName,
                                               lpNewFileName,
                                               lpProgressRoutine,
                                               lpData,
                                               dwFlags);
}

BOOL
APIHOOK(MoveFileWithProgressW)(
    LPCWSTR            lpExistingFileName,
    LPCWSTR            lpNewFileName,
    LPPROGRESS_ROUTINE lpProgressRoutine,
    LPVOID             lpData,
    DWORD              dwFlags
    )
{
    //
    // Ensure that the source or destination is not protected.
    //
    if (SfcIsFileProtected(NULL, lpExistingFileName) || 
        SfcIsFileProtected(NULL, lpNewFileName)) {
        VLOG(VLOG_LEVEL_ERROR,
             VLOG_WFP_MOVEFILE, 
             "API: MoveFileWithProgressW  Filename: %ls  Filename: %ls",
             lpExistingFileName, 
             lpNewFileName);
    }

    return ORIGINAL_API(MoveFileWithProgressW)(lpExistingFileName,
                                               lpNewFileName,
                                               lpProgressRoutine,
                                               lpData,
                                               dwFlags);
}

BOOL
APIHOOK(ReplaceFileA)(
    LPCSTR lpReplacedFileName,
    LPCSTR lpReplacementFileName,
    LPCSTR lpBackupFileName,
    DWORD  dwReplaceFlags,
    LPVOID lpExclude,
    LPVOID lpReserved
    )
{
    //
    // Ensure that the destination is not protected.
    //
    if (IsFileProtected(lpReplacedFileName)) {
        VLOG(VLOG_LEVEL_ERROR, 
             VLOG_WFP_REPLACEFILE, 
             "API: ReplaceFileA  Filename: %s", 
             lpReplacedFileName);
    }

    return ORIGINAL_API(ReplaceFileA)(lpReplacedFileName,
                                      lpReplacementFileName,
                                      lpBackupFileName,
                                      dwReplaceFlags,
                                      lpExclude,
                                      lpReserved);
   
}

BOOL
APIHOOK(ReplaceFileW)(
    LPCWSTR lpReplacedFileName,
    LPCWSTR lpReplacementFileName,
    LPCWSTR lpBackupFileName,
    DWORD   dwReplaceFlags,
    LPVOID  lpExclude,
    LPVOID  lpReserved
    )
{
    //
    // Ensure that the destination is not protected.
    //
    if (SfcIsFileProtected(NULL, lpReplacedFileName)) {
        VLOG(VLOG_LEVEL_ERROR,
             VLOG_WFP_REPLACEFILE,
             "API: ReplaceFileW  Filename: %ls", 
             lpReplacedFileName);
    }

    return ORIGINAL_API(ReplaceFileW)(lpReplacedFileName,
                                      lpReplacementFileName,
                                      lpBackupFileName,
                                      dwReplaceFlags,
                                      lpExclude,
                                      lpReserved);
   
}

void
ReportProtectedFileA(
    LPCSTR pszFilePath
    )
{
    UINT uSize = 0;
    
    if (pszFilePath) {
        while (TRUE) {
            if (IsFileProtected(pszFilePath)) {
                VLOG(VLOG_LEVEL_ERROR,
                     VLOG_WFP_SHFILEOP,
                     "API: SHFileOperationA  Filename: %s", pszFilePath);
            }

            uSize = lstrlenA(pszFilePath) + 1;
            pszFilePath += uSize;

            if (*pszFilePath == '\0') {
                break;
            } 
        }
    }
}

void
ReportProtectedFileW(
    LPCWSTR pwszFilePath
    )
{
    UINT uSize = 0;
    
    if (pwszFilePath) {
        while (TRUE) {
            if (SfcIsFileProtected(NULL, pwszFilePath)) {
                VLOG(VLOG_LEVEL_ERROR,
                     VLOG_WFP_SHFILEOP,
                     "API: SHFileOperationW  Filename: %ls", pwszFilePath);
            }

            uSize = lstrlenW(pwszFilePath) + 1;
            pwszFilePath += uSize;

            if (*pwszFilePath == '\0') {
                break;
            } 
        }
    }
}

int
APIHOOK(SHFileOperationA)(
    LPSHFILEOPSTRUCTA lpFileOp
    )
{
    //
    // If they're going to rename files on collision, don't bother.
    //
    if (!(lpFileOp->fFlags & FOF_RENAMEONCOLLISION)) {
        ReportProtectedFileA(lpFileOp->pFrom);
        ReportProtectedFileA(lpFileOp->pTo);
    }
    
    return ORIGINAL_API(SHFileOperationA)(lpFileOp);
}

int
APIHOOK(SHFileOperationW)(
    LPSHFILEOPSTRUCTW lpFileOp
    )
{
    //
    // If they're going to rename files on collision, don't bother.
    //
    if (!(lpFileOp->fFlags & FOF_RENAMEONCOLLISION)) {
        ReportProtectedFileW(lpFileOp->pFrom);
        ReportProtectedFileW(lpFileOp->pTo);
    }
    
    return ORIGINAL_API(SHFileOperationW)(lpFileOp);
}

HANDLE
APIHOOK(CreateFileA)(
    LPCSTR                lpFileName,
    DWORD                 dwDesiredAccess,
    DWORD                 dwShareMode,
    LPSECURITY_ATTRIBUTES lpSecurityAttributes,
    DWORD                 dwCreationDisposition,
    DWORD                 dwFlagsAndAttributes,
    HANDLE                hTemplateFile
    )
{
    if (IsFileProtected(lpFileName) &&
        (dwDesiredAccess & GENERIC_WRITE ||
         dwDesiredAccess & GENERIC_READ)) {
        VLOG(VLOG_LEVEL_ERROR,
             VLOG_WFP_OPENFILE, 
             "API: CreateFileA  Filename: %s", 
             lpFileName);
    }

    return ORIGINAL_API(CreateFileA)(lpFileName,
                                     dwDesiredAccess,
                                     dwShareMode,
                                     lpSecurityAttributes,
                                     dwCreationDisposition,
                                     dwFlagsAndAttributes,
                                     hTemplateFile);
}

HANDLE
APIHOOK(CreateFileW)(
    LPCWSTR               lpFileName,
    DWORD                 dwDesiredAccess,
    DWORD                 dwShareMode,
    LPSECURITY_ATTRIBUTES lpSecurityAttributes,
    DWORD                 dwCreationDisposition,
    DWORD                 dwFlagsAndAttributes,
    HANDLE                hTemplateFile
    )
{
    if (SfcIsFileProtected(NULL, lpFileName) &&
         (dwDesiredAccess & GENERIC_WRITE ||
          dwDesiredAccess & GENERIC_READ)) {
        VLOG(VLOG_LEVEL_ERROR,
             VLOG_WFP_OPENFILE, 
             "API: CreateFileW  Filename: %ls", 
             lpFileName);
    }

    return ORIGINAL_API(CreateFileW)(lpFileName,
                                     dwDesiredAccess,
                                     dwShareMode,
                                     lpSecurityAttributes,
                                     dwCreationDisposition,
                                     dwFlagsAndAttributes,
                                     hTemplateFile);
}

HFILE
APIHOOK(OpenFile)(
    LPCSTR     lpFileName,
    LPOFSTRUCT lpReOpenBuff,
    UINT       uStyle
    )
{
    if (IsFileProtected(lpFileName) &&
        (uStyle & OF_READWRITE ||
         uStyle & OF_CREATE ||
         uStyle & OF_DELETE)) {
        VLOG(VLOG_LEVEL_ERROR,
             VLOG_WFP_OPENFILE,
             "API: OpenFile  Filename: %s", 
             lpFileName);
    }

    return ORIGINAL_API(OpenFile)(lpFileName,
                                  lpReOpenBuff,
                                  uStyle);
}

HFILE
APIHOOK(_lopen)(
    LPCSTR lpPathName,
    int    iReadWrite
    )
{
    if (IsFileProtected(lpPathName) && 
        (iReadWrite & OF_READWRITE ||
         iReadWrite & OF_WRITE)) {
        VLOG(VLOG_LEVEL_ERROR,
             VLOG_WFP_OPENFILE,
             "API: _lopen  Filename: %s", 
             lpPathName);
    }

    return ORIGINAL_API(_lopen)(lpPathName,
                                iReadWrite);
}

HFILE
APIHOOK(_lcreat)(
    LPCSTR lpPathName,
    int    iAttribute
    )
{
    if (IsFileProtected(lpPathName) && iAttribute != 1) {
        VLOG(VLOG_LEVEL_ERROR,
             VLOG_WFP_OPENFILE, 
             "API: _lcreat  Filename: %s", 
             lpPathName);
    }

    return ORIGINAL_API(_lcreat)(lpPathName,
                                 iAttribute);

}

NTSTATUS
APIHOOK(NtCreateFile)(
    PHANDLE            FileHandle,
    ACCESS_MASK        DesiredAccess,
    POBJECT_ATTRIBUTES ObjectAttributes,
    PIO_STATUS_BLOCK   IoStatusBlock,
    PLARGE_INTEGER     AllocationSize,
    ULONG              FileAttributes,
    ULONG              ShareAccess,
    ULONG              CreateDisposition,
    ULONG              CreateOptions,
    PVOID              EaBuffer,
    ULONG              EaLength
    )
{
    if (IsNtFileProtected(ObjectAttributes->ObjectName)) {
        VLOG(VLOG_LEVEL_ERROR, VLOG_WFP_OPENFILE,
             "API: NtCreateFile  Filename: %ls",
             ObjectAttributes->ObjectName->Buffer);
    }

    return ORIGINAL_API(NtCreateFile)(FileHandle,
                                      DesiredAccess,
                                      ObjectAttributes,
                                      IoStatusBlock,
                                      AllocationSize,
                                      FileAttributes,
                                      ShareAccess,
                                      CreateDisposition,
                                      CreateOptions,
                                      EaBuffer,
                                      EaLength);
   
}

NTSTATUS
APIHOOK(NtOpenFile)(
    PHANDLE            FileHandle,
    ACCESS_MASK        DesiredAccess,
    POBJECT_ATTRIBUTES ObjectAttributes,
    PIO_STATUS_BLOCK   IoStatusBlock,
    ULONG              ShareAccess,
    ULONG              OpenOptions
    )
{
    if (IsNtFileProtected(ObjectAttributes->ObjectName)) {
        VLOG(VLOG_LEVEL_ERROR, VLOG_WFP_OPENFILE,
             "API: NtOpenFile  Filename: %ls",
             ObjectAttributes->ObjectName->Buffer);
    }

    return ORIGINAL_API(NtOpenFile)(FileHandle,
                                    DesiredAccess,
                                    ObjectAttributes,
                                    IoStatusBlock,
                                    ShareAccess,
                                    OpenOptions);
    
}

SHIM_INFO_BEGIN()

    SHIM_INFO_DESCRIPTION(AVS_WINFILEPROTECT_DESC)
    SHIM_INFO_FRIENDLY_NAME(AVS_WINFILEPROTECT_FRIENDLY)
    SHIM_INFO_VERSION(1, 4)
    SHIM_INFO_INCLUDE_EXCLUDE("E:rpcrt4.dll kernel32.dll")

SHIM_INFO_END()

/*++

 Register hooked functions.

--*/
HOOK_BEGIN

    DUMP_VERIFIER_LOG_ENTRY(VLOG_WFP_COPYFILE, 
                            AVS_WFP_COPYFILE,
                            AVS_WFP_GENERAL_R,
                            AVS_WFP_GENERAL_URL)

    DUMP_VERIFIER_LOG_ENTRY(VLOG_WFP_MOVEFILE, 
                            AVS_WFP_MOVEFILE,
                            AVS_WFP_GENERAL_R,
                            AVS_WFP_GENERAL_URL)

    DUMP_VERIFIER_LOG_ENTRY(VLOG_WFP_DELETEFILE, 
                            AVS_WFP_DELETEFILE,
                            AVS_WFP_GENERAL_R,
                            AVS_WFP_GENERAL_URL)

    DUMP_VERIFIER_LOG_ENTRY(VLOG_WFP_REPLACEFILE, 
                            AVS_WFP_REPLACEFILE,
                            AVS_WFP_GENERAL_R,
                            AVS_WFP_GENERAL_URL)

    DUMP_VERIFIER_LOG_ENTRY(VLOG_WFP_WRITEFILE, 
                            AVS_WFP_WRITEFILE,
                            AVS_WFP_GENERAL_R,
                            AVS_WFP_GENERAL_URL)

    DUMP_VERIFIER_LOG_ENTRY(VLOG_WFP_OPENFILE, 
                            AVS_WFP_OPENFILE,
                            AVS_WFP_GENERAL_R,
                            AVS_WFP_GENERAL_URL)

    DUMP_VERIFIER_LOG_ENTRY(VLOG_WFP_SHFILEOP, 
                            AVS_WFP_SHFILEOP,
                            AVS_WFP_GENERAL_R,
                            AVS_WFP_GENERAL_URL)

    APIHOOK_ENTRY(KERNEL32.DLL,                      CreateFileA)
    APIHOOK_ENTRY(KERNEL32.DLL,                      CreateFileW)
    APIHOOK_ENTRY(KERNEL32.DLL,                         OpenFile)

    APIHOOK_ENTRY(KERNEL32.DLL,                        CopyFileA)
    APIHOOK_ENTRY(KERNEL32.DLL,                        CopyFileW)
    APIHOOK_ENTRY(KERNEL32.DLL,                      CopyFileExA)
    APIHOOK_ENTRY(KERNEL32.DLL,                      CopyFileExW)
    
    APIHOOK_ENTRY(KERNEL32.DLL,                      DeleteFileA)
    APIHOOK_ENTRY(KERNEL32.DLL,                      DeleteFileW)

    APIHOOK_ENTRY(KERNEL32.DLL,                        MoveFileA)
    APIHOOK_ENTRY(KERNEL32.DLL,                        MoveFileW)
    APIHOOK_ENTRY(KERNEL32.DLL,                      MoveFileExA)
    APIHOOK_ENTRY(KERNEL32.DLL,                      MoveFileExW)
    APIHOOK_ENTRY(KERNEL32.DLL,            MoveFileWithProgressA)
    APIHOOK_ENTRY(KERNEL32.DLL,            MoveFileWithProgressW)

    APIHOOK_ENTRY(KERNEL32.DLL,                     ReplaceFileA)
    APIHOOK_ENTRY(KERNEL32.DLL,                     ReplaceFileW)

    APIHOOK_ENTRY(SHELL32.DLL,                  SHFileOperationA)
    APIHOOK_ENTRY(SHELL32.DLL,                  SHFileOperationW)

    // 16-bit compatibility file routines.
    APIHOOK_ENTRY(KERNEL32.DLL,                           _lopen)
    APIHOOK_ENTRY(KERNEL32.DLL,                          _lcreat)

    APIHOOK_ENTRY(NTDLL.DLL,                        NtCreateFile)
    APIHOOK_ENTRY(NTDLL.DLL,                          NtOpenFile)

HOOK_END

IMPLEMENT_SHIM_END
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\appcompat\slayerui\whistler\shellextensions.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1999 - 2000
//
//  File:       ShellExtensions.h
//
//--------------------------------------------------------------------------

#ifndef __SHELLEXTENSIONS_H
#define __SHELLEXTENSIONS_H



class CLayerUIPropPage:
    IShellExtInit,
    IShellPropSheetExt,
    public CComObjectRoot,
    public CComCoClass<CLayerUIPropPage, &CLSID_ShimLayerPropertyPage>
{
    BEGIN_COM_MAP(CLayerUIPropPage)
        COM_INTERFACE_ENTRY(IShellExtInit)
        COM_INTERFACE_ENTRY(IShellPropSheetExt)
    END_COM_MAP()

public:
    DECLARE_REGISTRY_CLSID()

    CLayerUIPropPage();
    ~CLayerUIPropPage();

    //
    // IShellExtInit methods
    //
    STDMETHODIMP Initialize(LPCITEMIDLIST pIDFolder,
                            LPDATAOBJECT  pDataObj,
                            HKEY          hKeyID);
  
    //
    // IShellPropSheetExt methods
    //
    STDMETHODIMP AddPages(LPFNADDPROPSHEETPAGE lpfnAddPage,
                          LPARAM               lParam);

    STDMETHODIMP ReplacePage(UINT uPageID,
                             LPFNADDPROPSHEETPAGE lpfnReplacePage,
                             LPARAM lParam);
    
    friend INT_PTR CALLBACK
        LayerPageDlgProc(HWND   hdlg,
                         UINT   uMsg,
                         WPARAM wParam,
                         LPARAM lParam);

private:
    CComPtr<IDataObject>  m_spDataObj;

    TCHAR                 m_szFile[MAX_PATH];
};


#endif // __SHELLEXTENSIONS_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\appcompat\slayerui\whistler\slayerxp.cpp ===
// SlayerXP.cpp : Implementation of DLL Exports.


// Note: Proxy/Stub Information
//      To build a separate proxy/stub DLL, 
//      run nmake -f SlayerUIps.mk in the project directory.

#include "stdafx.h"
#include "resource.h"
#include <initguid.h>

#include "shlobjp.h"

#include "SlayerXP.h"

#include <stdio.h>
#include <stdarg.h>

#include "SlayerXP_i.c"

#include "ShellExtensions.h"

// {513d916f-2a8e-4f51-aeab-0cbc76fb1af8}
static const CLSID CLSID_ShimLayerPropertyPage = 
  {	0x513d916f, 0x2a8e, 0x4f51, { 0xae, 0xab, 0x0c, 0xbc, 0x76, 0xfb, 0x1a, 0xf8 } };


HINSTANCE g_hInstance;
CLayerUIModule _Module;

BEGIN_OBJECT_MAP(ObjectMap)
  OBJECT_ENTRY(CLSID_ShimLayerPropertyPage, CLayerUIPropPage)
END_OBJECT_MAP()

#if DBG

/////////////////////////////////////////////////////////////////////////////
// LogMsgDbg

void LogMsgDbg(
    LPTSTR pwszFmt,
    ... )
{
    WCHAR   gwszT[1024];
    va_list arglist;

    va_start(arglist, pwszFmt);
    _vsnwprintf(gwszT, 1023, pwszFmt, arglist);
    gwszT[1023] = 0;
    va_end(arglist);
    
    OutputDebugStringW(gwszT);
}

#endif // DBG

/////////////////////////////////////////////////////////////////////////////
// DLL Entry Point

extern "C"
BOOL WINAPI DllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID /*lpReserved*/)
{
    if (dwReason == DLL_PROCESS_ATTACH)
    {
        g_hInstance = hInstance;

        _Module.Init(ObjectMap, hInstance, &LIBID_SLAYERUILib);

        SHFusionInitializeFromModuleID(hInstance, SXS_MANIFEST_RESOURCE_ID);

        LinkWindow_RegisterClass();

        DisableThreadLibraryCalls(hInstance);
    }
    else if (dwReason == DLL_PROCESS_DETACH) {

        SHFusionUninitialize();

        _Module.Term();
    }

    return TRUE;    // ok
}

/////////////////////////////////////////////////////////////////////////////
// Used to determine whether the DLL can be unloaded by OLE

STDAPI DllCanUnloadNow(void)
{
    return (_Module.GetLockCount()==0) ? S_OK : S_FALSE;
}

/////////////////////////////////////////////////////////////////////////////
// Returns a class factory to create an object of the requested type

STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv)
{
    return _Module.GetClassObject(rclsid, riid, ppv);
}

/////////////////////////////////////////////////////////////////////////////
// DllRegisterServer - Adds entries to the system registry

STDAPI DllRegisterServer(void)
{
    // registers object, typelib and all interfaces in typelib
    return _Module.RegisterServer(TRUE);
}

/////////////////////////////////////////////////////////////////////////////
// DllUnregisterServer - Removes entries from the system registry

STDAPI DllUnregisterServer(void)
{
    return _Module.UnregisterServer(TRUE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\appcompat\shims\verifier\securitychecks.cpp ===
/*++

 Copyright (c) 2001 Microsoft Corporation

 Module Name:

   SecurityChecks.cpp

 Abstract:

   This AppVerifier shim hooks CreateProcess, CreateProcessAsUser,
   and WinExec and checks to see if some conditions exist that
   might allow trojan horse behavior to occur.
   
 Notes:

   This is a general purpose shim.

 History:

   12/13/2001   rparsons    Created

--*/

#include "precomp.h"

IMPLEMENT_SHIM_BEGIN(SecurityChecks)
#include "ShimHookMacro.h"

//
// verifier log entries
//
BEGIN_DEFINE_VERIFIER_LOG(SecurityChecks)
    VERIFIER_LOG_ENTRY(VLOG_SECURITYCHECKS_BADARGUMENTS)
    VERIFIER_LOG_ENTRY(VLOG_SECURITYCHECKS_WINEXEC)
    VERIFIER_LOG_ENTRY(VLOG_SECURITYCHECKS_NULL_DACL)
    VERIFIER_LOG_ENTRY(VLOG_SECURITYCHECKS_WORLDWRITE_DACL)
END_DEFINE_VERIFIER_LOG(SecurityChecks)

INIT_VERIFIER_LOG(SecurityChecks);

APIHOOK_ENUM_BEGIN
    APIHOOK_ENUM_ENTRY(CreateProcessA)
    APIHOOK_ENUM_ENTRY(CreateProcessW)
    APIHOOK_ENUM_ENTRY(CreateProcessAsUserA)
    APIHOOK_ENUM_ENTRY(CreateProcessAsUserW)
    APIHOOK_ENUM_ENTRY(WinExec)

	APIHOOK_ENUM_ENTRY(CreateFileA)	
	APIHOOK_ENUM_ENTRY(CreateFileW)
	APIHOOK_ENUM_ENTRY(CreateDesktopA)	
	APIHOOK_ENUM_ENTRY(CreateDesktopW)	
	APIHOOK_ENUM_ENTRY(CreateWindowStationA)
	APIHOOK_ENUM_ENTRY(CreateWindowStationW)
    
    APIHOOK_ENUM_ENTRY(RegCreateKeyExA)
    APIHOOK_ENUM_ENTRY(RegCreateKeyExW)
    APIHOOK_ENUM_ENTRY(RegSaveKeyA)
    APIHOOK_ENUM_ENTRY(RegSaveKeyW)
    APIHOOK_ENUM_ENTRY(RegSaveKeyExA)
    APIHOOK_ENUM_ENTRY(RegSaveKeyExW)

    APIHOOK_ENUM_ENTRY(CreateFileMappingA)
    APIHOOK_ENUM_ENTRY(CreateFileMappingW)
    APIHOOK_ENUM_ENTRY(CreateJobObjectA)
    APIHOOK_ENUM_ENTRY(CreateJobObjectW)
    APIHOOK_ENUM_ENTRY(CreateThread)
    APIHOOK_ENUM_ENTRY(CreateRemoteThread)

    APIHOOK_ENUM_ENTRY(CreateDirectoryA)
    APIHOOK_ENUM_ENTRY(CreateDirectoryW)
    APIHOOK_ENUM_ENTRY(CreateDirectoryExA)
    APIHOOK_ENUM_ENTRY(CreateDirectoryExW)
    APIHOOK_ENUM_ENTRY(CreateHardLinkA)
    APIHOOK_ENUM_ENTRY(CreateHardLinkW)
    APIHOOK_ENUM_ENTRY(CreateMailslotA)
    APIHOOK_ENUM_ENTRY(CreateMailslotW)
    APIHOOK_ENUM_ENTRY(CreateNamedPipeA)
    APIHOOK_ENUM_ENTRY(CreateNamedPipeW)
    APIHOOK_ENUM_ENTRY(CreatePipe)
    APIHOOK_ENUM_ENTRY(CreateMutexA)
    APIHOOK_ENUM_ENTRY(CreateMutexW)
    APIHOOK_ENUM_ENTRY(CreateSemaphoreA)
    APIHOOK_ENUM_ENTRY(CreateSemaphoreW)
    APIHOOK_ENUM_ENTRY(CreateWaitableTimerA)
    APIHOOK_ENUM_ENTRY(CreateWaitableTimerW)

    //APIHOOK_ENUM_ENTRY(ClusterRegCreateKey)
    //APIHOOK_ENUM_ENTRY(CreateNtmsMediaPoolA)
    //APIHOOK_ENUM_ENTRY(CreateNtmsMediaPoolW)

APIHOOK_ENUM_END

BYTE g_ajSidBuffer[SECURITY_MAX_SID_SIZE];
PSID g_pWorldSid = NULL;

WCHAR g_wszWinDir[MAX_PATH];
DWORD g_dwWinDirLen = 0;

void
InitWorldSid(
    void
    )
{
    DWORD dwSidSize = sizeof(g_ajSidBuffer);

    if (CreateWellKnownSid(WinWorldSid, NULL, g_ajSidBuffer, &dwSidSize)) {
        g_pWorldSid = g_ajSidBuffer;
    } else {
        g_pWorldSid = NULL;
    }
}

void
CheckSecurityDescriptor(
    PSECURITY_DESCRIPTOR    pSecurityDescriptor,
    LPCWSTR                 szCaller,
    LPCWSTR                 szParam,
    LPCWSTR                 szName
    )
{
    BOOL                    bDaclPresent = FALSE;
    BOOL                    bDaclDefaulted = FALSE;
    PACL                    pDacl = NULL;

    if (!pSecurityDescriptor || !szName || !szName[0]) {
        //
        // there's no attributes, so they get the default, which is fine,
        // or the object doesn't have a name, so it can't be highjacked
        //
        return;
    }

    if (GetSecurityDescriptorDacl(pSecurityDescriptor, &bDaclPresent, &pDacl, &bDaclDefaulted)) {
        if (bDaclPresent) {
            if (!pDacl) {
                //
                // we have a NULL dacl -- log a problem
                //
                VLOG(VLOG_LEVEL_ERROR,
                     VLOG_SECURITYCHECKS_NULL_DACL,
                     "Called %ls, and specified a NULL DACL in %ls for object '%ls.'",
                     szCaller,
                     szParam,
                     szName);
                return;
            }

            if (!g_pWorldSid) {
                //
                // we never were able to get the world Sid
                //
                return;
            }

            for (DWORD i = 0; i < pDacl->AceCount; ++i) {
                PACE_HEADER     pAceHeader = NULL;
                PSID            pSID;
                ACCESS_MASK     dwAccessMask;

                if (!GetAce(pDacl, i, (LPVOID*)&pAceHeader)) {
                    continue;
                }

                //
                // if it's not some form of ACCESS_ALLOWED ACE, we aren't interested
                //
                if (pAceHeader->AceType == ACCESS_ALLOWED_ACE_TYPE) {

                    pSID = &(((PACCESS_ALLOWED_ACE)pAceHeader)->SidStart);
                    dwAccessMask = ((PACCESS_ALLOWED_ACE)pAceHeader)->Mask;

                } else if (pAceHeader->AceType == ACCESS_ALLOWED_OBJECT_ACE_TYPE) {

                    PACCESS_ALLOWED_OBJECT_ACE pAAOAce = (PACCESS_ALLOWED_OBJECT_ACE)pAceHeader;

                    //
                    // who the heck came up with this system? The Sid starts at a different place
                    // depending on the flags. Anyone ever heard of multiple structs? Sigh.
                    //
                    if ((pAAOAce->Flags & ACE_OBJECT_TYPE_PRESENT) && (pAAOAce->Flags & ACE_INHERITED_OBJECT_TYPE_PRESENT)) {

                        pSID = &(pAAOAce->SidStart);

                    } else if ((pAAOAce->Flags & ACE_OBJECT_TYPE_PRESENT) || (pAAOAce->Flags & ACE_INHERITED_OBJECT_TYPE_PRESENT)){

                        pSID = (PSID)&(pAAOAce->InheritedObjectType);

                    } else {

                        pSID = (PSID)&(pAAOAce->ObjectType);
                    }

                    dwAccessMask = ((PACCESS_ALLOWED_OBJECT_ACE)pAceHeader)->Mask;

                } else {
                    continue;
                }

                //
                // check the validity of the SID, just to be safe
                //
                if (!IsValidSid(pSID)) {

                    continue;
                }


                //
                // if the SID is the world, and the access mask allows WRITE_DAC and WRITE_OWNER, we have a problem
                //
                if ((dwAccessMask & (WRITE_DAC | WRITE_OWNER)) && EqualSid(pSID, g_pWorldSid)) {
                    VLOG(VLOG_LEVEL_ERROR,
                         VLOG_SECURITYCHECKS_WORLDWRITE_DACL,
                         "Called %ls, and specified a DACL with WRITE_DAC and/or WRITE_OWNER for WORLD in %ls for object '%ls.'",
                         szCaller,
                         szParam,
                         szName);
                    return;
                }

            }

        }

    }

}

void
CheckSecurityAttributes(
    LPSECURITY_ATTRIBUTES   pSecurityAttrib,
    LPCWSTR                 szCaller,
    LPCWSTR                 szParam,
    LPCWSTR                 szName
    )
{
    PSECURITY_DESCRIPTOR    pSecurityDescriptor = NULL;

    if (!pSecurityAttrib) {
        //
        // there's no attributes, so they get the default, which is fine
        //
        return;
    }

    pSecurityDescriptor = (PSECURITY_DESCRIPTOR)pSecurityAttrib->lpSecurityDescriptor;

    CheckSecurityDescriptor(pSecurityDescriptor, szCaller, szParam, szName);
}

void
CheckCreateProcess(
    LPCWSTR		pwszApplicationName,
    LPCWSTR		pwszCommandLine,
    LPCWSTR		pwszCaller
    )
{
    //
    // if applicationname is non-null, there's no problem
    //
    if (pwszApplicationName) {
        return;
    }

    //
    // if there's no command line, there's a problem, but not one we want to solve
    //
    if (!pwszCommandLine) {
        return;
    }

    //
    // if there are no spaces, no problem
    //
    LPWSTR pSpaceLoc = wcschr(pwszCommandLine, L' ');
    if (!pSpaceLoc) {
        return;
    }

    //
    // if the beginning of the command line is quoted, no problem
    //
    if (pwszCommandLine[0] == L'\"') {
        return;
    }

    //
    // if the phrase '.exe ' appears before the first space, we'll call that good
    //
    LPWSTR pExeLoc = wcsistr(pwszCommandLine, L".exe ");
    if (pExeLoc && pExeLoc < pSpaceLoc) {
        return;
    }

    //
    // if the first part of the command line is windir, we'll call that good
    //
    if (g_dwWinDirLen && _wcsnicmp(pwszCommandLine, g_wszWinDir, g_dwWinDirLen) == 0) {
        return;
    }


	if (_wcsicmp(pwszCaller, L"winexec") == 0) {
		VLOG(VLOG_LEVEL_ERROR,
			 VLOG_SECURITYCHECKS_BADARGUMENTS,
			 "Called %ls with command line '%ls'. The command line has spaces, and the exe name is not in quotes.",
			 pwszCaller,
			 pwszCommandLine);
    } else {
		VLOG(VLOG_LEVEL_ERROR,
			 VLOG_SECURITYCHECKS_BADARGUMENTS,
			 "Called %ls with command line '%ls'. The lpApplicationName argument is NULL, lpCommandLine has spaces, and the exe name is not in quotes.",
			 pwszCaller,
			 pwszCommandLine);
    }
}

void
CheckForNoPathInFileName(
    LPCWSTR  pwszFilePath,
    LPCWSTR  pwszCaller
    )
{
    if (!pwszFilePath || !pwszCaller) {
        return;
    }

    //
    // skip quotes and space if necessary
    //
    DWORD dwBegin = 0;
    while (pwszFilePath[dwBegin] == L'\"' || pwszFilePath[dwBegin] == L' ') {
        dwBegin++;
    }

    //
    // if there's nothing left of the string, get out
    //
    if (!pwszFilePath[dwBegin] || !pwszFilePath[dwBegin + 1]) {
        return;
    }

    //
    // check for DOS (x:...) and UNC (\\...) full paths
    //
    if (pwszFilePath[dwBegin + 1] == L':' || (pwszFilePath[dwBegin] == L'\\' && pwszFilePath[dwBegin + 1] == L'\\')) {
        //
        // full path
        //
        return;
    }

    VLOG(VLOG_LEVEL_ERROR,
         VLOG_SECURITYCHECKS_BADARGUMENTS,
         "Called '%ls' with '%ls' specified. Use a full path to the file to ensure that you get the executable you want, and not a malicious exe with the same name.",
         pwszCaller,
         pwszFilePath);
}

BOOL 
APIHOOK(CreateProcessA)(
    LPCSTR                lpApplicationName,
    LPSTR                 lpCommandLine,
    LPSECURITY_ATTRIBUTES lpProcessAttributes, 
    LPSECURITY_ATTRIBUTES lpThreadAttributes, 
    BOOL                  bInheritHandles,
    DWORD                 dwCreationFlags,
    LPVOID                lpEnvironment,
    LPCSTR                lpCurrentDirectory,
    LPSTARTUPINFOA        lpStartupInfo, 
    LPPROCESS_INFORMATION lpProcessInformation 
    )
{
    LPWSTR pwszApplicationName = ToUnicode(lpApplicationName);
    LPWSTR pwszCommandLine = ToUnicode(lpCommandLine);

    CheckCreateProcess(pwszApplicationName, pwszCommandLine, L"CreateProcess");

    if (pwszApplicationName) {
        CheckForNoPathInFileName(pwszApplicationName, L"CreateProcess");
        
        CheckSecurityAttributes(lpProcessAttributes, L"CreateProcess", L"lpProcessAttributes", pwszApplicationName);
        CheckSecurityAttributes(lpThreadAttributes, L"CreateProcess", L"lpThreadAttributes", pwszApplicationName);
    } else {
        CheckForNoPathInFileName(pwszCommandLine, L"CreateProcess");
        
        CheckSecurityAttributes(lpProcessAttributes, L"CreateProcess", L"lpProcessAttributes", pwszCommandLine);
        CheckSecurityAttributes(lpThreadAttributes, L"CreateProcess", L"lpThreadAttributes", pwszCommandLine);
    }

    if (pwszApplicationName) {
        free(pwszApplicationName);
        pwszApplicationName = NULL;
    }
    if (pwszCommandLine) {
        free(pwszCommandLine);
        pwszCommandLine = NULL;
    }

    return ORIGINAL_API(CreateProcessA)(lpApplicationName,
                                        lpCommandLine,
                                        lpProcessAttributes,
                                        lpThreadAttributes,
                                        bInheritHandles,
                                        dwCreationFlags,
                                        lpEnvironment,
                                        lpCurrentDirectory,
                                        lpStartupInfo,
                                        lpProcessInformation);
}

BOOL 
APIHOOK(CreateProcessW)(
    LPCWSTR               lpApplicationName,
    LPWSTR                lpCommandLine,
    LPSECURITY_ATTRIBUTES lpProcessAttributes,
    LPSECURITY_ATTRIBUTES lpThreadAttributes,
    BOOL                  bInheritHandles,
    DWORD                 dwCreationFlags,
    LPVOID                lpEnvironment,
    LPWSTR                lpCurrentDirectory,
    LPSTARTUPINFOW        lpStartupInfo,
    LPPROCESS_INFORMATION lpProcessInformation
    )
{
    CheckCreateProcess(lpApplicationName, lpCommandLine, L"CreateProcess");

    if (lpApplicationName) {
        CheckForNoPathInFileName(lpApplicationName, L"CreateProcess");
        
        CheckSecurityAttributes(lpProcessAttributes, L"CreateProcess", L"lpProcessAttributes", lpApplicationName);
        CheckSecurityAttributes(lpThreadAttributes, L"CreateProcess", L"lpThreadAttributes", lpApplicationName);
    } else {
        CheckForNoPathInFileName(lpCommandLine, L"CreateProcess");
    
        CheckSecurityAttributes(lpProcessAttributes, L"CreateProcess", L"lpProcessAttributes", lpCommandLine);
        CheckSecurityAttributes(lpThreadAttributes, L"CreateProcess", L"lpThreadAttributes", lpCommandLine);
    }


    return ORIGINAL_API(CreateProcessW)(lpApplicationName,
                                        lpCommandLine,
                                        lpProcessAttributes,
                                        lpThreadAttributes,
                                        bInheritHandles,
                                        dwCreationFlags,
                                        lpEnvironment,
                                        lpCurrentDirectory,
                                        lpStartupInfo,
                                        lpProcessInformation);
}

BOOL 
APIHOOK(CreateProcessAsUserA)(
    HANDLE                hToken,
    LPCSTR                lpApplicationName,
    LPSTR                 lpCommandLine,
    LPSECURITY_ATTRIBUTES lpProcessAttributes, 
    LPSECURITY_ATTRIBUTES lpThreadAttributes, 
    BOOL                  bInheritHandles,
    DWORD                 dwCreationFlags,
    LPVOID                lpEnvironment,
    LPCSTR                lpCurrentDirectory,
    LPSTARTUPINFOA        lpStartupInfo, 
    LPPROCESS_INFORMATION lpProcessInformation 
    )
{
    LPWSTR pwszApplicationName = ToUnicode(lpApplicationName);
    LPWSTR pwszCommandLine = ToUnicode(lpCommandLine);

    CheckCreateProcess(pwszApplicationName, pwszCommandLine, L"CreateProcessAsUser");

    if (pwszApplicationName) {
        CheckForNoPathInFileName(pwszApplicationName, L"CreateProcessAsUser");

        CheckSecurityAttributes(lpProcessAttributes, L"CreateProcessAsUser", L"lpProcessAttributes", pwszApplicationName);
        CheckSecurityAttributes(lpThreadAttributes, L"CreateProcessAsUser", L"lpThreadAttributes", pwszApplicationName);
    } else {
        CheckForNoPathInFileName(pwszCommandLine, L"CreateProcessAsUser");
        
        CheckSecurityAttributes(lpProcessAttributes, L"CreateProcessAsUser", L"lpProcessAttributes", pwszCommandLine);
        CheckSecurityAttributes(lpThreadAttributes, L"CreateProcessAsUser", L"lpThreadAttributes", pwszCommandLine);
    }

    if (pwszApplicationName) {
        free(pwszApplicationName);
        pwszApplicationName = NULL;
    }
    if (pwszCommandLine) {
        free(pwszCommandLine);
        pwszCommandLine = NULL;
    }

    return ORIGINAL_API(CreateProcessAsUserA)(hToken,
                                              lpApplicationName,
                                              lpCommandLine,
                                              lpProcessAttributes,    
                                              lpThreadAttributes,
                                              bInheritHandles,
                                              dwCreationFlags,
                                              lpEnvironment,
                                              lpCurrentDirectory,
                                              lpStartupInfo,
                                              lpProcessInformation);
}

BOOL 
APIHOOK(CreateProcessAsUserW)(
    HANDLE                hToken,
    LPCWSTR               lpApplicationName,
    LPWSTR                lpCommandLine,
    LPSECURITY_ATTRIBUTES lpProcessAttributes,
    LPSECURITY_ATTRIBUTES lpThreadAttributes,
    BOOL                  bInheritHandles,
    DWORD                 dwCreationFlags,
    LPVOID                lpEnvironment,
    LPWSTR                lpCurrentDirectory,
    LPSTARTUPINFOW        lpStartupInfo,
    LPPROCESS_INFORMATION lpProcessInformation
    )
{
    CheckCreateProcess(lpApplicationName, lpCommandLine, L"CreateProcessAsUser");

    if (lpApplicationName) {
        CheckForNoPathInFileName(lpApplicationName, L"CreateProcessAsUser");
    
        CheckSecurityAttributes(lpProcessAttributes, L"CreateProcessAsUser", L"lpProcessAttributes", lpApplicationName);
        CheckSecurityAttributes(lpThreadAttributes, L"CreateProcessAsUser", L"lpThreadAttributes", lpApplicationName);
    } else {
        CheckForNoPathInFileName(lpCommandLine, L"CreateProcessAsUser");
    
        CheckSecurityAttributes(lpProcessAttributes, L"CreateProcessAsUser", L"lpProcessAttributes", lpCommandLine);
        CheckSecurityAttributes(lpThreadAttributes, L"CreateProcessAsUser", L"lpThreadAttributes", lpCommandLine);
    }

    return ORIGINAL_API(CreateProcessAsUserW)(hToken,
                                              lpApplicationName,
                                              lpCommandLine,
                                              lpProcessAttributes,
                                              lpThreadAttributes,
                                              bInheritHandles,
                                              dwCreationFlags,
                                              lpEnvironment,
                                              lpCurrentDirectory,
                                              lpStartupInfo,
                                              lpProcessInformation);
}

UINT 
APIHOOK(WinExec)(
    LPCSTR lpCmdLine, 
    UINT   uCmdShow 
    )
{
    LPWSTR pwszCmdLine = ToUnicode(lpCmdLine);

    VLOG(VLOG_LEVEL_ERROR, VLOG_SECURITYCHECKS_WINEXEC, "Called WinExec.");

    CheckForNoPathInFileName(pwszCmdLine, L"WinExec");

    CheckCreateProcess(NULL, pwszCmdLine, L"WinExec");

    if (pwszCmdLine) {
        free(pwszCmdLine);
        pwszCmdLine = NULL;
    }

    return ORIGINAL_API(WinExec)(lpCmdLine, uCmdShow);
}


HANDLE
APIHOOK(CreateFileA)(
    LPCSTR                lpFileName,            // file name
    DWORD                 dwDesiredAccess,       // access mode
    DWORD                 dwShareMode,           // share mode
    LPSECURITY_ATTRIBUTES lpSecurityAttributes,  // SD
    DWORD                 dwCreationDisposition, // how to create
    DWORD                 dwFlagsAndAttributes,  // file attributes
    HANDLE                hTemplateFile          // handle to template file
    )
{
    LPWSTR pwszName = ToUnicode(lpFileName);

    CheckSecurityAttributes(lpSecurityAttributes, L"CreateFile", L"lpSecurityAttributes", pwszName);

    if (pwszName) {
        free(pwszName);
        pwszName = NULL;
    }
    
    return ORIGINAL_API(CreateFileA)(lpFileName,
                                     dwDesiredAccess,
                                     dwShareMode,
                                     lpSecurityAttributes,
                                     dwCreationDisposition,
                                     dwFlagsAndAttributes,
                                     hTemplateFile);

}


HANDLE
APIHOOK(CreateFileW)(
    LPCWSTR               lpFileName,            // file name
    DWORD                 dwDesiredAccess,       // access mode
    DWORD                 dwShareMode,           // share mode
    LPSECURITY_ATTRIBUTES lpSecurityAttributes,  // SD
    DWORD                 dwCreationDisposition, // how to create
    DWORD                 dwFlagsAndAttributes,  // file attributes
    HANDLE                hTemplateFile          // handle to template file
    )
{
    CheckSecurityAttributes(lpSecurityAttributes, L"CreateFile", L"lpSecurityAttributes", lpFileName);
    
    return ORIGINAL_API(CreateFileW)(lpFileName,
                                     dwDesiredAccess,
                                     dwShareMode,
                                     lpSecurityAttributes,
                                     dwCreationDisposition,
                                     dwFlagsAndAttributes,
                                     hTemplateFile);
}


HDESK 
APIHOOK(CreateDesktopA)(
    LPCSTR lpszDesktop,          // name of new desktop
    LPCSTR lpszDevice,           // reserved; must be NULL
    LPDEVMODEA pDevmode,         // reserved; must be NULL
    DWORD dwFlags,               // desktop interaction
    ACCESS_MASK dwDesiredAccess, // access of returned handle
    LPSECURITY_ATTRIBUTES lpsa   // security attributes
    )
{
    LPWSTR pwszName = ToUnicode(lpszDesktop);

    CheckSecurityAttributes(lpsa, L"CreateDesktop", L"lpsa", pwszName);

    if (pwszName) {
        free(pwszName);
        pwszName = NULL;
    }
    
    return ORIGINAL_API(CreateDesktopA)(lpszDesktop,        
                                        lpszDevice,         
                                        pDevmode,         
                                        dwFlags,              
                                        dwDesiredAccess,
                                        lpsa);
}

HDESK 
APIHOOK(CreateDesktopW)(
    LPCWSTR lpszDesktop,         // name of new desktop
    LPCWSTR lpszDevice,          // reserved; must be NULL
    LPDEVMODEW pDevmode,         // reserved; must be NULL
    DWORD dwFlags,               // desktop interaction
    ACCESS_MASK dwDesiredAccess, // access of returned handle
    LPSECURITY_ATTRIBUTES lpsa   // security attributes
    )
{
    CheckSecurityAttributes(lpsa, L"CreateDesktop", L"lpsa", lpszDesktop);

    return ORIGINAL_API(CreateDesktopW)(lpszDesktop,        
                                        lpszDevice,         
                                        pDevmode,         
                                        dwFlags,              
                                        dwDesiredAccess,
                                        lpsa);
}



HWINSTA 
APIHOOK(CreateWindowStationA)(
    LPSTR lpwinsta,              // new window station name
    DWORD dwReserved,            // reserved; must be zero
    ACCESS_MASK dwDesiredAccess, // requested access
    LPSECURITY_ATTRIBUTES lpsa   // security attributes
    )
{
    LPWSTR pwszName = ToUnicode(lpwinsta);

    CheckSecurityAttributes(lpsa, L"CreateWindowStation", L"lpsa", pwszName);

    if (pwszName) {
        free(pwszName);
        pwszName = NULL;
    }
    
    return ORIGINAL_API(CreateWindowStationA)(lpwinsta,        
                                              dwReserved,         
                                              dwDesiredAccess,
                                              lpsa);
}

HWINSTA 
APIHOOK(CreateWindowStationW)(
    LPWSTR lpwinsta,             // new window station name
    DWORD dwReserved,            // reserved; must be zero
    ACCESS_MASK dwDesiredAccess, // requested access
    LPSECURITY_ATTRIBUTES lpsa   // security attributes
    )
{
    CheckSecurityAttributes(lpsa, L"CreateWindowStation", L"lpsa", lpwinsta);

    return ORIGINAL_API(CreateWindowStationW)(lpwinsta,        
                                              dwReserved,         
                                              dwDesiredAccess,
                                              lpsa);
}


LONG 
APIHOOK(RegCreateKeyExA)(
    HKEY                  hKey,                
    LPCSTR                lpSubKey,         
    DWORD                 Reserved,           
    LPSTR                 lpClass,           
    DWORD                 dwOptions,          
    REGSAM                samDesired,        
    LPSECURITY_ATTRIBUTES lpSecurityAttributes,
    PHKEY                 phkResult,          
    LPDWORD               lpdwDisposition   
    )
{
    LPWSTR pwszName = ToUnicode(lpSubKey);

    CheckSecurityAttributes(lpSecurityAttributes, L"RegCreateKeyEx", L"lpSecurityAttributes", pwszName);

    if (pwszName) {
        free(pwszName);
        pwszName = NULL;
    }
    
    return ORIGINAL_API(RegCreateKeyExA)(hKey,
                                         lpSubKey,
                                         Reserved,
                                         lpClass,
                                         dwOptions,
                                         samDesired,
                                         lpSecurityAttributes,
                                         phkResult,
                                         lpdwDisposition);
}

LONG 
APIHOOK(RegCreateKeyExW)(
    HKEY                  hKey,                
    LPCWSTR               lpSubKey,         
    DWORD                 Reserved,           
    LPWSTR                lpClass,           
    DWORD                 dwOptions,          
    REGSAM                samDesired,        
    LPSECURITY_ATTRIBUTES lpSecurityAttributes,
    PHKEY                 phkResult,          
    LPDWORD               lpdwDisposition   
    )
{
    CheckSecurityAttributes(lpSecurityAttributes, L"RegCreateKeyEx", L"lpSecurityAttributes", lpSubKey);
    
    return ORIGINAL_API(RegCreateKeyExW)(hKey,
                                         lpSubKey,
                                         Reserved,
                                         lpClass,
                                         dwOptions,
                                         samDesired,
                                         lpSecurityAttributes,
                                         phkResult,
                                         lpdwDisposition);
}

LONG 
APIHOOK(RegSaveKeyA)(
    HKEY                    hKey,                 // handle to key
    LPCSTR                  lpFile,               // data file
    LPSECURITY_ATTRIBUTES   lpSecurityAttributes  // SD
    )
{
    LPWSTR pwszName = ToUnicode(lpFile);

    CheckSecurityAttributes(lpSecurityAttributes, L"RegSaveKey", L"lpSecurityAttributes", pwszName);

    if (pwszName) {
        free(pwszName);
        pwszName = NULL;
    }
    
    return ORIGINAL_API(RegSaveKeyA)(hKey,
                                     lpFile,
                                     lpSecurityAttributes);
}

LONG 
APIHOOK(RegSaveKeyW)(
    HKEY                    hKey,                 // handle to key
    LPCWSTR                 lpFile,               // data file
    LPSECURITY_ATTRIBUTES   lpSecurityAttributes  // SD
    )
{
    CheckSecurityAttributes(lpSecurityAttributes, L"RegSaveKey", L"lpSecurityAttributes", lpFile);
    
    return ORIGINAL_API(RegSaveKeyW)(hKey,
                                     lpFile,
                                     lpSecurityAttributes);
}

LONG 
APIHOOK(RegSaveKeyExA)(
    HKEY                    hKey,                 // handle to key
    LPCSTR                  lpFile,               // data file
    LPSECURITY_ATTRIBUTES   lpSecurityAttributes, // SD
    DWORD                   Flags
    )
{
    LPWSTR pwszName = ToUnicode(lpFile);

    CheckSecurityAttributes(lpSecurityAttributes, L"RegSaveKeyEx", L"lpSecurityAttributes", pwszName);

    if (pwszName) {
        free(pwszName);
        pwszName = NULL;
    }
    
    return ORIGINAL_API(RegSaveKeyExA)(hKey,
                                     lpFile,
                                     lpSecurityAttributes,
                                     Flags);
}

LONG 
APIHOOK(RegSaveKeyExW)(
    HKEY                    hKey,                 // handle to key
    LPCWSTR                 lpFile,               // data file
    LPSECURITY_ATTRIBUTES   lpSecurityAttributes, // SD
    DWORD                   Flags
    )
{
    CheckSecurityAttributes(lpSecurityAttributes, L"RegSaveKeyEx", L"lpSecurityAttributes", lpFile);
    
    return ORIGINAL_API(RegSaveKeyExW)(hKey,
                                       lpFile,
                                       lpSecurityAttributes,
                                       Flags);
}

HANDLE 
APIHOOK(CreateFileMappingA)(
    HANDLE hFile,              
    LPSECURITY_ATTRIBUTES lpAttributes,
    DWORD flProtect,           
    DWORD dwMaximumSizeHigh,   
    DWORD dwMaximumSizeLow,    
    LPCSTR lpName             
    )
{
    LPWSTR pwszName = ToUnicode(lpName);

    CheckSecurityAttributes(lpAttributes, L"CreateFileMapping", L"lpAttributes", pwszName);

    if (pwszName) {
        free(pwszName);
        pwszName = NULL;
    }
    
    return ORIGINAL_API(CreateFileMappingA)(hFile, 
                                           lpAttributes, 
                                           flProtect, 
                                           dwMaximumSizeHigh, 
                                           dwMaximumSizeLow, 
                                           lpName);
}

HANDLE 
APIHOOK(CreateFileMappingW)(
    HANDLE hFile,              
    LPSECURITY_ATTRIBUTES lpAttributes,
    DWORD flProtect,           
    DWORD dwMaximumSizeHigh,   
    DWORD dwMaximumSizeLow,    
    LPCWSTR lpName             
    )
{
    CheckSecurityAttributes(lpAttributes, L"CreateFileMapping", L"lpAttributes", lpName);
    
    return ORIGINAL_API(CreateFileMappingW)(hFile, 
                                            lpAttributes, 
                                            flProtect, 
                                            dwMaximumSizeHigh, 
                                            dwMaximumSizeLow, 
                                            lpName);
}

HANDLE 
APIHOOK(CreateJobObjectA)(
    LPSECURITY_ATTRIBUTES   lpJobAttributes,  // SD
    LPCSTR                  lpName            // job name 
    )
{
    LPWSTR pwszName = ToUnicode(lpName);

    CheckSecurityAttributes(lpJobAttributes, L"CreateJobObject", L"lpJobAttributes", pwszName);

    if (pwszName) {
        free(pwszName);
        pwszName = NULL;
    }
    
    return ORIGINAL_API(CreateJobObjectA)(lpJobAttributes,
                                          lpName);
}

HANDLE 
APIHOOK(CreateJobObjectW)(
    LPSECURITY_ATTRIBUTES   lpJobAttributes,  // SD
    LPCWSTR                 lpName            // job name 
    )
{
    CheckSecurityAttributes(lpJobAttributes, L"CreateJobObject", L"lpJobAttributes", lpName);
    
    return ORIGINAL_API(CreateJobObjectW)(lpJobAttributes,
                                          lpName);
}


HANDLE
APIHOOK(CreateThread)(
    LPSECURITY_ATTRIBUTES   lpThreadAttributes, // SD
    SIZE_T                  dwStackSize,        // initial stack size
    LPTHREAD_START_ROUTINE  lpStartAddress,     // thread function
    LPVOID                  lpParameter,        // thread argument
    DWORD                   dwCreationFlags,    // creation option
    LPDWORD                 lpThreadId          // thread identifier
    )
{
    CheckSecurityAttributes(lpThreadAttributes, L"CreateThread", L"lpThreadAttributes", L"Unnamed thread");
    
    return ORIGINAL_API(CreateThread)(lpThreadAttributes,
                                      (DWORD)dwStackSize,
                                      lpStartAddress,
                                      lpParameter,    
                                      dwCreationFlags,
                                      lpThreadId);      
}

HANDLE 
APIHOOK(CreateRemoteThread)(
    HANDLE                  hProcess,           // handle to process
    LPSECURITY_ATTRIBUTES   lpThreadAttributes, // SD
    SIZE_T                  dwStackSize,        // initial stack size
    LPTHREAD_START_ROUTINE  lpStartAddress,     // thread function
    LPVOID                  lpParameter,        // thread argument
    DWORD                   dwCreationFlags,    // creation option
    LPDWORD                 lpThreadId          // thread identifier
    )
{
    CheckSecurityAttributes(lpThreadAttributes, L"CreateRemoteThread", L"lpThreadAttributes", L"Unnamed thread");
    
    return ORIGINAL_API(CreateRemoteThread)(hProcess, 
                                            lpThreadAttributes,
                                            dwStackSize,
                                            lpStartAddress,
                                            lpParameter,    
                                            dwCreationFlags,
                                            lpThreadId);      
}




BOOL
APIHOOK(CreateDirectoryA)(
    LPCSTR                lpPathName,           // directory name
    LPSECURITY_ATTRIBUTES lpSecurityAttributes  // SD
    )
{
    LPWSTR pwszName = ToUnicode(lpPathName);

    CheckSecurityAttributes(lpSecurityAttributes, L"CreateDirectory", L"lpSecurityAttributes", pwszName);

    if (pwszName) {
        free(pwszName);
        pwszName = NULL;
    }
    
    return ORIGINAL_API(CreateDirectoryA)(lpPathName, 
                                          lpSecurityAttributes);
}


BOOL
APIHOOK(CreateDirectoryW)(
    LPCWSTR               lpPathName,           // directory name
    LPSECURITY_ATTRIBUTES lpSecurityAttributes  // SD
    )
{
    CheckSecurityAttributes(lpSecurityAttributes, L"CreateDirectory", L"lpSecurityAttributes", lpPathName);
    
    return ORIGINAL_API(CreateDirectoryW)(lpPathName, 
                                          lpSecurityAttributes);
}


BOOL
APIHOOK(CreateDirectoryExA)(
    LPCSTR                lpTemplateDirectory,   // template directory
    LPCSTR                lpNewDirectory,        // directory name
    LPSECURITY_ATTRIBUTES lpSecurityAttributes   // SD
    )
{
    LPWSTR pwszName = ToUnicode(lpNewDirectory);

    CheckSecurityAttributes(lpSecurityAttributes, L"CreateDirectoryEx", L"lpSecurityAttributes", pwszName);

    if (pwszName) {
        free(pwszName);
        pwszName = NULL;
    }
    
    return ORIGINAL_API(CreateDirectoryExA)(lpTemplateDirectory,
                                            lpNewDirectory,
                                            lpSecurityAttributes);

}


BOOL
APIHOOK(CreateDirectoryExW)(
    LPCWSTR               lpTemplateDirectory,  // template directory
    LPCWSTR               lpNewDirectory,       // directory name
    LPSECURITY_ATTRIBUTES lpSecurityAttributes  // SD
    )
{
    CheckSecurityAttributes(lpSecurityAttributes, L"CreateDirectoryEx", L"lpSecurityAttributes", lpNewDirectory);
    
    return ORIGINAL_API(CreateDirectoryExW)(lpTemplateDirectory,
                                            lpNewDirectory,
                                            lpSecurityAttributes);

}

BOOL 
APIHOOK(CreateHardLinkA)(
    LPCSTR                  lpFileName,          // link name name
    LPCSTR                  lpExistingFileName,  // target file name
    LPSECURITY_ATTRIBUTES   lpSecurityAttributes  
    )
{
    LPWSTR pwszName = ToUnicode(lpFileName);

    CheckSecurityAttributes(lpSecurityAttributes, L"CreateHardLink", L"lpSecurityAttributes", pwszName);

    if (pwszName) {
        free(pwszName);
        pwszName = NULL;
    }
    
    return ORIGINAL_API(CreateHardLinkA)(lpFileName,
                                         lpExistingFileName,
                                         lpSecurityAttributes);


}

BOOL 
APIHOOK(CreateHardLinkW)(
    LPCWSTR                 lpFileName,          // link name name
    LPCWSTR                 lpExistingFileName,  // target file name
    LPSECURITY_ATTRIBUTES   lpSecurityAttributes  
    )
{
    CheckSecurityAttributes(lpSecurityAttributes, L"CreateHardLink", L"lpSecurityAttributes", lpFileName);
    
    return ORIGINAL_API(CreateHardLinkW)(lpFileName,
                                         lpExistingFileName,
                                         lpSecurityAttributes);


}


HANDLE 
APIHOOK(CreateMailslotA)(
    LPCSTR                  lpName,              // mailslot name
    DWORD                   nMaxMessageSize,     // maximum message size
    DWORD                   lReadTimeout,        // read time-out interval
    LPSECURITY_ATTRIBUTES   lpSecurityAttributes // inheritance option
    )
{
    LPWSTR pwszName = ToUnicode(lpName);

    CheckSecurityAttributes(lpSecurityAttributes, L"CreateMailslot", L"lpSecurityAttributes", pwszName);

    if (pwszName) {
        free(pwszName);
        pwszName = NULL;
    }
    
    return ORIGINAL_API(CreateMailslotA)(lpName,
                                         nMaxMessageSize,
                                         lReadTimeout,
                                         lpSecurityAttributes);
}

HANDLE 
APIHOOK(CreateMailslotW)(
    LPCWSTR                 lpName,              // mailslot name
    DWORD                   nMaxMessageSize,     // maximum message size
    DWORD                   lReadTimeout,        // read time-out interval
    LPSECURITY_ATTRIBUTES   lpSecurityAttributes // inheritance option
    )
{
    CheckSecurityAttributes(lpSecurityAttributes, L"CreateMailslot", L"lpSecurityAttributes", lpName);
    
    return ORIGINAL_API(CreateMailslotW)(lpName,
                                         nMaxMessageSize,
                                         lReadTimeout,
                                         lpSecurityAttributes);
}


HANDLE 
APIHOOK(CreateNamedPipeA)(
    LPCSTR                  lpName,                 // pipe name
    DWORD                   dwOpenMode,             // pipe open mode
    DWORD                   dwPipeMode,             // pipe-specific modes
    DWORD                   nMaxInstances,          // maximum number of instances
    DWORD                   nOutBufferSize,         // output buffer size
    DWORD                   nInBufferSize,          // input buffer size
    DWORD                   nDefaultTimeOut,        // time-out interval
    LPSECURITY_ATTRIBUTES   lpSecurityAttributes    // SD
    )
{
    LPWSTR pwszName = ToUnicode(lpName);

    CheckSecurityAttributes(lpSecurityAttributes, L"CreateNamedPipe", L"lpSecurityAttributes", pwszName);

    if (pwszName) {
        free(pwszName);
        pwszName = NULL;
    }
    
    return ORIGINAL_API(CreateNamedPipeA)(lpName,
                                          dwOpenMode, 
                                          dwPipeMode,
                                          nMaxInstances,      
                                          nOutBufferSize,     
                                          nInBufferSize,      
                                          nDefaultTimeOut,    
                                          lpSecurityAttributes);
}

HANDLE 
APIHOOK(CreateNamedPipeW)(
    LPCWSTR                 lpName,                 // pipe name
    DWORD                   dwOpenMode,             // pipe open mode
    DWORD                   dwPipeMode,             // pipe-specific modes
    DWORD                   nMaxInstances,          // maximum number of instances
    DWORD                   nOutBufferSize,         // output buffer size
    DWORD                   nInBufferSize,          // input buffer size
    DWORD                   nDefaultTimeOut,        // time-out interval
    LPSECURITY_ATTRIBUTES   lpSecurityAttributes    // SD
    )
{
    CheckSecurityAttributes(lpSecurityAttributes, L"CreateNamedPipe", L"lpSecurityAttributes", lpName);
    
    return ORIGINAL_API(CreateNamedPipeW)(lpName,
                                          dwOpenMode, 
                                          dwPipeMode,
                                          nMaxInstances,      
                                          nOutBufferSize,     
                                          nInBufferSize,      
                                          nDefaultTimeOut,    
                                          lpSecurityAttributes);
}

BOOL 
APIHOOK(CreatePipe)(
    PHANDLE                 hReadPipe,         // read handle
    PHANDLE                 hWritePipe,        // write handle
    LPSECURITY_ATTRIBUTES   lpPipeAttributes,  // security attributes
    DWORD                   nSize              // pipe size
    )
{
    CheckSecurityAttributes(lpPipeAttributes, L"CreatePipe", L"lpPipeAttributes", L"Unnamed pipe");
    
    return ORIGINAL_API(CreatePipe)(hReadPipe,
                                    hWritePipe,
                                    lpPipeAttributes,
                                    nSize);
}

HANDLE 
APIHOOK(CreateMutexA)(
    LPSECURITY_ATTRIBUTES lpMutexAttributes,  // SD
    BOOL bInitialOwner,                       // initial owner
    LPCSTR lpName                             // object name
    )
{
    LPWSTR pwszName = ToUnicode(lpName);

    CheckSecurityAttributes(lpMutexAttributes, L"CreateMutex", L"lpMutexAttributes", pwszName);

    if (pwszName) {
        free(pwszName);
        pwszName = NULL;
    }
    
    return ORIGINAL_API(CreateMutexA)(lpMutexAttributes,
                                      bInitialOwner,
                                      lpName);
}

HANDLE 
APIHOOK(CreateMutexW)(
    LPSECURITY_ATTRIBUTES lpMutexAttributes,  // SD
    BOOL bInitialOwner,                       // initial owner
    LPCWSTR lpName                            // object name
    )
{
    CheckSecurityAttributes(lpMutexAttributes, L"CreateMutex", L"lpMutexAttributes", lpName);
    
    return ORIGINAL_API(CreateMutexW)(lpMutexAttributes,
                                      bInitialOwner,
                                      lpName);
}

HANDLE 
APIHOOK(CreateSemaphoreA)(
    LPSECURITY_ATTRIBUTES lpSemaphoreAttributes, // SD
    LONG lInitialCount,                          // initial count
    LONG lMaximumCount,                          // maximum count
    LPCSTR lpName                                // object name
    )
{
    LPWSTR pwszName = ToUnicode(lpName);

    CheckSecurityAttributes(lpSemaphoreAttributes, L"CreateSemaphore", L"lpSemaphoreAttributes", pwszName);

    if (pwszName) {
        free(pwszName);
        pwszName = NULL;
    }
    
    return ORIGINAL_API(CreateSemaphoreA)(lpSemaphoreAttributes,
                                          lInitialCount,
                                          lMaximumCount,
                                          lpName);
}

HANDLE 
APIHOOK(CreateSemaphoreW)(
    LPSECURITY_ATTRIBUTES lpSemaphoreAttributes, // SD
    LONG lInitialCount,                          // initial count
    LONG lMaximumCount,                          // maximum count
    LPCWSTR lpName                               // object name
    )
{
    CheckSecurityAttributes(lpSemaphoreAttributes, L"CreateSemaphore", L"lpSemaphoreAttributes", lpName);
    
    return ORIGINAL_API(CreateSemaphoreW)(lpSemaphoreAttributes,
                                          lInitialCount,
                                          lMaximumCount,
                                          lpName);
}


HANDLE
APIHOOK(CreateWaitableTimerA)(
    IN LPSECURITY_ATTRIBUTES lpTimerAttributes,
    IN BOOL bManualReset,
    IN LPCSTR lpTimerName
    )
{
    LPWSTR pwszName = ToUnicode(lpTimerName);

    CheckSecurityAttributes(lpTimerAttributes, L"CreateWaitableTimer", L"lpTimerAttributes", pwszName);

    if (pwszName) {
        free(pwszName);
        pwszName = NULL;
    }
    
    return ORIGINAL_API(CreateWaitableTimerA)(lpTimerAttributes,
                                              bManualReset,
                                              lpTimerName);
}

HANDLE
APIHOOK(CreateWaitableTimerW)(
    IN LPSECURITY_ATTRIBUTES lpTimerAttributes,
    IN BOOL bManualReset,
    IN LPCWSTR lpTimerName
    )
{
    CheckSecurityAttributes(lpTimerAttributes, L"CreateWaitableTimer", L"lpTimerAttributes", lpTimerName);
    
    return ORIGINAL_API(CreateWaitableTimerW)(lpTimerAttributes,
                                              bManualReset,
                                              lpTimerName);
}

#if 0
LONG 
WINAPI 
APIHOOK(ClusterRegCreateKey)(
    HKEY hKey,                                   
    LPCWSTR lpszSubKey,                          
    DWORD dwOptions,                             
    REGSAM samDesired,                           
    LPSECURITY_ATTRIBUTES lpSecurityAttributes,  
    PHKEY phkResult,                             
    LPDWORD lpdwDisposition                      
    )
{
    CheckSecurityAttributes(lpSecurityAttributes, L"ClusterRegCreateKey", L"lpSecurityAttributes");
    
    return ORIGINAL_API(ClusterRegCreateKey)(hKey,
                                             lpszSubKey,
                                             dwOptions,
                                             samDesired,
                                             lpSecurityAttributes,
                                             phkResult,
                                             lpdwDisposition);
}


DWORD 
WINAPI 
APIHOOK(CreateNtmsMediaPoolA)(
    HANDLE hSession,
    LPCSTR lpPoolName,
    LPNTMS_GUID lpMediaType,
    DWORD dwAction,
    LPSECURITY_ATTRIBUTES lpSecurityAttributes,
    LPNTMS_GUID lpPoolId            // OUT
    )
{
    CheckSecurityAttributes(lpSecurityAttributes, L"CreateNtmsMediaPool", L"lpSecurityAttributes");
    
    return ORIGINAL_API(CreateNtmsMediaPoolA)(hSession,
                                             lpPoolName,
                                             lpMediaType,
                                             dwAction,
                                             lpSecurityAttributes,
                                             lpPoolId);

}

DWORD WINAPI 
APIHOOK(CreateNtmsMediaPoolW)(
    HANDLE hSession,
    LPCWSTR lpPoolName,
    LPNTMS_GUID lpMediaType,
    DWORD dwAction,
    LPSECURITY_ATTRIBUTES lpSecurityAttributes,
    LPNTMS_GUID lpPoolId            // OUT
    )
{
    CheckSecurityAttributes(lpSecurityAttributes, L"CreateNtmsMediaPool", L"lpSecurityAttributes");
    
    return ORIGINAL_API(CreateNtmsMediaPoolW)(hSession,
                                             lpPoolName,
                                             lpMediaType,
                                             dwAction,
                                             lpSecurityAttributes,
                                             lpPoolId);
}

#endif



SHIM_INFO_BEGIN()

    SHIM_INFO_DESCRIPTION(AVS_SECURITYCHECKS_DESC)
    SHIM_INFO_FRIENDLY_NAME(AVS_SECURITYCHECKS_FRIENDLY)
    SHIM_INFO_FLAGS(0)
    SHIM_INFO_GROUPS(0)    
    SHIM_INFO_VERSION(2, 3)
    SHIM_INFO_INCLUDE_EXCLUDE("I:*")

SHIM_INFO_END()

/*++

 Register hooked functions.

--*/
HOOK_BEGIN

    if (fdwReason == DLL_PROCESS_ATTACH) {
        DWORD dwSize;

        InitWorldSid();

        dwSize = GetSystemWindowsDirectoryW(g_wszWinDir, ARRAYSIZE(g_wszWinDir));
        if (dwSize == 0 || dwSize > ARRAYSIZE(g_wszWinDir)) {
            g_wszWinDir[0] = 0;
        }
        g_dwWinDirLen = wcslen(g_wszWinDir);
    }

    DUMP_VERIFIER_LOG_ENTRY(VLOG_SECURITYCHECKS_BADARGUMENTS, 
                            AVS_SECURITYCHECKS_BADARGUMENTS,
                            AVS_SECURITYCHECKS_BADARGUMENTS_R,
                            AVS_SECURITYCHECKS_BADARGUMENTS_URL)

    DUMP_VERIFIER_LOG_ENTRY(VLOG_SECURITYCHECKS_WINEXEC, 
                            AVS_SECURITYCHECKS_WINEXEC,
                            AVS_SECURITYCHECKS_WINEXEC_R,
                            AVS_SECURITYCHECKS_WINEXEC_URL)

    DUMP_VERIFIER_LOG_ENTRY(VLOG_SECURITYCHECKS_NULL_DACL, 
                            AVS_SECURITYCHECKS_NULL_DACL,
                            AVS_SECURITYCHECKS_NULL_DACL_R,
                            AVS_SECURITYCHECKS_NULL_DACL_URL)

    DUMP_VERIFIER_LOG_ENTRY(VLOG_SECURITYCHECKS_WORLDWRITE_DACL, 
                            AVS_SECURITYCHECKS_WORLDWRITE_DACL,
                            AVS_SECURITYCHECKS_WORLDWRITE_DACL_R,
                            AVS_SECURITYCHECKS_WORLDWRITE_DACL_URL)

    APIHOOK_ENTRY(KERNEL32.DLL,                 CreateProcessA)
    APIHOOK_ENTRY(KERNEL32.DLL,                 CreateProcessW)
    APIHOOK_ENTRY(ADVAPI32.DLL,                 CreateProcessAsUserA)
    APIHOOK_ENTRY(ADVAPI32.DLL,                 CreateProcessAsUserW)
    APIHOOK_ENTRY(KERNEL32.DLL,                 WinExec)

    APIHOOK_ENTRY(KERNEL32.DLL,                 CreateFileA)
    APIHOOK_ENTRY(KERNEL32.DLL,                 CreateFileW)
    APIHOOK_ENTRY(USER32.DLL,                   CreateDesktopA)
    APIHOOK_ENTRY(USER32.DLL,                   CreateDesktopW)
    APIHOOK_ENTRY(USER32.DLL,                   CreateWindowStationA)
    APIHOOK_ENTRY(USER32.DLL,                   CreateWindowStationW)

    APIHOOK_ENTRY(ADVAPI32.DLL,                 RegCreateKeyExA)
    APIHOOK_ENTRY(ADVAPI32.DLL,                 RegCreateKeyExW)
    APIHOOK_ENTRY(ADVAPI32.DLL,                 RegSaveKeyA)
    APIHOOK_ENTRY(ADVAPI32.DLL,                 RegSaveKeyW)
    APIHOOK_ENTRY(ADVAPI32.DLL,                 RegSaveKeyExA)
    APIHOOK_ENTRY(ADVAPI32.DLL,                 RegSaveKeyExW)

    APIHOOK_ENTRY(KERNEL32.DLL,                 CreateFileMappingA)
    APIHOOK_ENTRY(KERNEL32.DLL,                 CreateFileMappingW)
    APIHOOK_ENTRY(KERNEL32.DLL,                 CreateJobObjectA)
    APIHOOK_ENTRY(KERNEL32.DLL,                 CreateJobObjectW)
    APIHOOK_ENTRY(KERNEL32.DLL,                 CreateThread)
    APIHOOK_ENTRY(KERNEL32.DLL,                 CreateRemoteThread)
    APIHOOK_ENTRY(KERNEL32.DLL,                 CreateDirectoryA)
    APIHOOK_ENTRY(KERNEL32.DLL,                 CreateDirectoryW)
    APIHOOK_ENTRY(KERNEL32.DLL,                 CreateDirectoryExA)
    APIHOOK_ENTRY(KERNEL32.DLL,                 CreateDirectoryExW)
    APIHOOK_ENTRY(KERNEL32.DLL,                 CreateHardLinkA)
    APIHOOK_ENTRY(KERNEL32.DLL,                 CreateHardLinkW)
    APIHOOK_ENTRY(KERNEL32.DLL,                 CreateMailslotA)
    APIHOOK_ENTRY(KERNEL32.DLL,                 CreateMailslotW)
    APIHOOK_ENTRY(KERNEL32.DLL,                 CreateNamedPipeA)
    APIHOOK_ENTRY(KERNEL32.DLL,                 CreateNamedPipeW)
    APIHOOK_ENTRY(KERNEL32.DLL,                 CreatePipe)
    APIHOOK_ENTRY(KERNEL32.DLL,                 CreateMutexA)
    APIHOOK_ENTRY(KERNEL32.DLL,                 CreateMutexW)
    APIHOOK_ENTRY(KERNEL32.DLL,                 CreateSemaphoreA)
    APIHOOK_ENTRY(KERNEL32.DLL,                 CreateSemaphoreW)
    APIHOOK_ENTRY(KERNEL32.DLL,                 CreateWaitableTimerA)
    APIHOOK_ENTRY(KERNEL32.DLL,                 CreateWaitableTimerW)

HOOK_END



IMPLEMENT_SHIM_END
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\appcompat\slayerui\whistler\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by SlayerXP.rc
//
#define IDS_PROJNAME                    100
#define IDD_LAYER_PROPPAGE              101
#define IDC_LAYER_NAME                  1005
#define IDC_DISABLE_OTHER_FIXES         1006
#define IDC_LEARN                       1009
#define IDC_TEXT_INSTRUCTIONS           1013
#define IDC_DISABLECICERO               1014

#define IDS_LAYER_WIN95_EXT             2000
#define IDS_LAYER_WIN98_EXT             2001
#define IDS_LAYER_NT4_EXT               2002
#define IDS_LAYER_WIN2K_EXT             2003
#define IDS_COMPAT_UNAVAILABLE          2004
#define IDS_COMPAT_UNAVAILABLE_SYSTEM   2005
#define IDS_COMPATIBILITY               2006

#define IDC_USE_LAYER                   5000
#define IDC_256COLORS                   5001
#define IDC_640X480                     5002
#define IDC_ENABLE_THEMES               5003

#define IDS_INPUT_SETTINGS_GROUP        6001

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        201
#define _APS_NEXT_COMMAND_VALUE         32768
#define _APS_NEXT_CONTROL_VALUE         1015
#define _APS_NEXT_SYMED_VALUE           102
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\appcompat\slayerui\whistler\stdafx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
//  stdafx.pch will be the pre-compiled header
//  stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"

#ifdef _ATL_STATIC_REGISTRY
#include <statreg.h>
#include <statreg.cpp>
#endif

#include <atlimpl.cpp>

#include "ShellExtensions.h"

typedef DWORD (*PFNSHDeleteKeyW)(HKEY hkey, LPWSTR pszSubkey);

HRESULT WINAPI
CLayerUIModule::UpdateRegistryCLSID(
    const CLSID& clsid,
    BOOL         bRegister
    )
{
    static const TCHAR szIPS32[] = _T("InprocServer32");
    static const TCHAR szCLSID[] = _T("CLSID");
    static const TCHAR szPropPageExt[] = _T("ShimLayer Property Page");

    TCHAR* pszExtName;
    DWORD  cbExtNameSize;

    HRESULT hRes = S_OK;

    LPOLESTR lpOleStrCLSIDValue;
    
    if (clsid != CLSID_ShimLayerPropertyPage) {
        LogMsg(_T("[UpdateRegistryCLSID] unknown CLSID!\n"));
        return E_FAIL;
    }
    
    ::StringFromCLSID(clsid, &lpOleStrCLSIDValue);

    HKEY hkey = NULL;
    LONG lRes;
    
    if (bRegister) {
        
        TCHAR szBuffer[MAX_PATH];
        DWORD keyType = 0;

        //
        // Write the key for registration. Include the value to specify
        // the threading model.
        //
        _stprintf(szBuffer, _T("%s\\%s\\%s"), szCLSID, lpOleStrCLSIDValue, szIPS32);
        
        lRes = RegCreateKey(HKEY_CLASSES_ROOT, szBuffer, &hkey);

        if (lRes != ERROR_SUCCESS) {
            LogMsg(_T("[UpdateRegistryCLSID] failed to open/create \"%s\"\n"),
                   szBuffer);
            goto Exit;
        }
        
        ::GetModuleFileName(m_hInst, szBuffer, MAX_PATH);
        
        lRes = RegSetValueEx(hkey,
                             NULL,
                             0,
                             REG_SZ,
                             (BYTE*)szBuffer,
                             (lstrlen(szBuffer) + 1) * sizeof(TCHAR));
        
        if (lRes != ERROR_SUCCESS) {
            LogMsg(_T("[UpdateRegistryCLSID] failed to write value \"%s\"\n"),
                   szBuffer);
            goto Exit;
        }
        
        lRes = RegSetValueEx(hkey,
                             _T("ThreadingModel"),
                             0,
                             REG_SZ,
                             (BYTE*)_T("Apartment"),
                             sizeof(_T("Apartment")));
        
        if (lRes != ERROR_SUCCESS) {
            LogMsg(_T("[UpdateRegistryCLSID] failed to write \"ThreadingModel\"\n"));
            goto Exit;
        }

        RegCloseKey(hkey);
        hkey = NULL;

        //
        // Open the key with the name of the .exe extension and
        // add the keys to support the shell extensions.
        //
        _stprintf(szBuffer,
                  _T("lnkfile\\shellex\\PropertySheetHandlers\\%s"),
                  szPropPageExt);

        pszExtName = (TCHAR*)szPropPageExt;
        cbExtNameSize = sizeof(szPropPageExt) + sizeof(TCHAR);
        
        lRes = RegCreateKey(HKEY_CLASSES_ROOT, szBuffer, &hkey);
        
        if (lRes != ERROR_SUCCESS) {
            goto Exit;
        }

        lRes = RegSetValueEx(hkey,
                             NULL,
                             0,
                             REG_SZ,
                             (BYTE*)lpOleStrCLSIDValue,
                             (lstrlen(lpOleStrCLSIDValue) + 1) * sizeof(TCHAR));

        if (lRes != ERROR_SUCCESS) {
            LogMsg(_T("[UpdateRegistryCLSID] failed to add the shell extension handler\n"));
            goto Exit;
        }
        
        RegCloseKey(hkey);
        hkey = NULL;

        //
        // Now add the shell extension to the approved list.
        //
        lRes = RegCreateKey(HKEY_LOCAL_MACHINE,
                            _T("SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Shell Extensions\\Approved"),
                            &hkey);
        
        if (lRes != ERROR_SUCCESS) {
            LogMsg(_T("[UpdateRegistryCLSID] failed to approve the shell extension handler\n"));
            goto Exit;
        }
        
        lRes = RegSetValueEx(hkey,
                             lpOleStrCLSIDValue,
                             0,
                             REG_SZ,
                             (BYTE*)pszExtName,
                             cbExtNameSize);

        if (lRes != ERROR_SUCCESS) {
            LogMsg(_T("[UpdateRegistryCLSID] failed to approve the shell extension handler\n"));
            goto Exit;
        }

Exit:        
        if (hkey != NULL) {
            RegCloseKey(hkey);
            hkey = NULL;
        }
            
        hRes = HRESULT_FROM_WIN32(lRes);
    
    } else {
        //
        // Time to clean up.
        //
        PFNSHDeleteKeyW pfnSHDeleteKey;

        HMODULE hmod = LoadLibrary(_T("Shlwapi.dll"));

        if (hmod == NULL) {
            LogMsg(_T("[UpdateRegistryCLSID] failed to load Shlwapi.dll\n"));
            return E_FAIL;
        }
        
        pfnSHDeleteKey = (PFNSHDeleteKeyW)GetProcAddress(hmod, "SHDeleteKeyW");

        if (pfnSHDeleteKey == NULL) {
            FreeLibrary(hmod);
            LogMsg(_T("[UpdateRegistryCLSID] cannot get Shlwapi!SHDeleteKeyW\n"));
            return E_FAIL;
        }

        lRes = RegOpenKey(HKEY_CLASSES_ROOT, szCLSID, &hkey);
        
        if (lRes == ERROR_SUCCESS) {
            (*pfnSHDeleteKey)(hkey, lpOleStrCLSIDValue);
            
            RegCloseKey(hkey);
            hkey = NULL;
        }

        lRes = RegOpenKey(HKEY_CLASSES_ROOT, _T("lnkfile\\shellex"), &hkey);
        
        if (lRes == ERROR_SUCCESS) {
            
            (*pfnSHDeleteKey)(hkey, _T("PropertySheetHandlers\\ShimLayer Property Page"));
            
            RegCloseKey(hkey);
            hkey = NULL;
        }
        
        lRes = RegOpenKey(HKEY_LOCAL_MACHINE,
                          _T("SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Shell Extensions\\Approved"),
                          &hkey);
        
        if (lRes == ERROR_SUCCESS) {
            RegDeleteValue(hkey, lpOleStrCLSIDValue);
            
            RegCloseKey(hkey);
            hkey = NULL;
        }

        FreeLibrary(hmod);
    }

    //
    // Notify the shell of our changes
    //
    SHChangeNotify(SHCNE_ASSOCCHANGED, SHCNF_IDLIST, NULL, NULL);

    ::CoTaskMemFree(lpOleStrCLSIDValue);
    
    return hRes;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\appcompat\slayerui\whistler\stdafx.h ===
// stdafx.h : include file for standard system include files,
//      or project specific include files that are used frequently,
//      but are changed infrequently

#if !defined(AFX_STDAFX_H__88E11F15_58D2_477F_9D30_DBF092670E6A__INCLUDED_)
#define AFX_STDAFX_H__88E11F15_58D2_477F_9D30_DBF092670E6A__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#define STRICT
#ifndef _WIN32_WINNT
#define _WIN32_WINNT 0x0400
#endif
#define _ATL_APARTMENT_THREADED


#include <atlbase.h>

//You may derive a class from CComModule and use it if you want to override
//something, but do not change the name of _Module

#if ( _ATL_VER >= 0x0300 )
#define _ATL_NO_UUIDOF 
#endif


using namespace ATL;

class CLayerUIModule : public CComModule
{
public:
	HRESULT WINAPI UpdateRegistryCLSID(const CLSID& clsid, BOOL bRegister);
};

#define DECLARE_REGISTRY_CLSID()                                        \
static HRESULT WINAPI UpdateRegistry(BOOL bRegister)                    \
{                                                                       \
    return _Module.UpdateRegistryCLSID(GetObjectCLSID(), bRegister);    \
}

extern CLayerUIModule _Module;

#include <atlcom.h>

#include <shellapi.h>
#include <shlobj.h>

extern const CLSID CLSID_ShimLayerPropertyPage;

#if DBG

    void LogMsgDbg(LPTSTR pszFmt, ...);
    
    #define LogMsg  LogMsgDbg
#else

    #define LogMsg

#endif // DBG


#include "shfusion.h"
#include "shimdb.h"

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__88E11F15_58D2_477F_9D30_DBF092670E6A__INCLUDED)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\appcompat\slayerui\win2k\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by SlayerUI.rc
//
#define IDS_PROJNAME                    100
#define IDD_LAYER_PROPPAGE              101
#define IDC_USE_LAYER                   1004
#define IDC_LAYER_NAME                  1005
#define IDC_DISABLE_OTHER_FIXES         1006

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        201
#define _APS_NEXT_COMMAND_VALUE         32768
#define _APS_NEXT_CONTROL_VALUE         1007
#define _APS_NEXT_SYMED_VALUE           102
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\appcompat\slayerui\whistler\shellextensions.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 2000
//
//  File:      ShellExtensions.cpp
//
//  Contents:  object to implement propertypage extensions
//             for Win2k shim layer
//
//  History:   23-september-00 clupu    Created
//
//
//--------------------------------------------------------------------------

#include "stdafx.h"
#include "resource.h"
#include "xpsp1res.h"
#include "ShellExtensions.h"
#include <sfc.h>

UINT    g_DllRefCount = 0;

extern HINSTANCE g_hInstance;

typedef struct _LAYER_INFO {
    WCHAR   wszInternalName[32];
    UINT    nstrFriendlyName;
} LAYER_INFO, *PLAYER_INFO;

//
// internal definitions of layer names
//
#define STR_LAYER_WIN95             L"WIN95"
#define STR_LAYER_WIN98             L"WIN98"
#define STR_LAYER_WINNT             L"NT4SP5"
#define STR_LAYER_WIN2K             L"WIN2000"
#define STR_LAYER_256COLOR          L"256COLOR"
#define STR_LAYER_LORES             L"640X480"
#define STR_LAYER_DISABLETHEMES     L"DISABLETHEMES"
#define STR_LAYER_DISABLECICERO     L"DISABLECICERO"

const LAYER_INFO g_LayerInfo[] =
{
    {
        STR_LAYER_WIN95,
        IDS_LAYER_WIN95_EXT
    },
    {
        STR_LAYER_WIN98,
        IDS_LAYER_WIN98_EXT,
    },
    {
        STR_LAYER_WINNT,
        IDS_LAYER_NT4_EXT
    },
    {
        STR_LAYER_WIN2K,
        IDS_LAYER_WIN2K_EXT
    }
};

#define NUM_LAYERS (sizeof(g_LayerInfo)/sizeof(g_LayerInfo[0]))

typedef BOOL (STDAPICALLTYPE *_pfn_AllowPermLayer)(WCHAR* pwszPath);
typedef BOOL (STDAPICALLTYPE *_pfn_GetPermLayers)(WCHAR* pwszPath, WCHAR *pwszLayers, DWORD *pdwBytes, DWORD dwFlags);
typedef BOOL (STDAPICALLTYPE *_pfn_SetPermLayers)(WCHAR* pwszPath, WCHAR *pwszLayers, BOOL bMachine);

HINSTANCE g_hAppHelp = NULL;
HINSTANCE g_hQfeRes = NULL;
_pfn_AllowPermLayer g_pfnAllowPermLayer = NULL;
_pfn_GetPermLayers g_pfnGetPermLayers = NULL;
_pfn_SetPermLayers g_pfnSetPermLayers = NULL;

BOOL InitAppHelpCalls(void)
{
    HINSTANCE hAppHelp;

    if (g_hAppHelp) {
        //
        // we're already inited
        //
        return TRUE;
    }

    hAppHelp = LoadLibrary(TEXT("apphelp.dll"));
    if (!hAppHelp) {
        LogMsg(_T("[InitAppHelpCalls] Can't get handle to apphelp.dll.\n"));
        return FALSE;
    }

    g_pfnAllowPermLayer = (_pfn_AllowPermLayer)GetProcAddress(hAppHelp, "AllowPermLayer");
    g_pfnGetPermLayers = (_pfn_GetPermLayers)GetProcAddress(hAppHelp, "GetPermLayers");
    g_pfnSetPermLayers = (_pfn_SetPermLayers)GetProcAddress(hAppHelp, "SetPermLayers");

    if (!g_pfnAllowPermLayer || !g_pfnGetPermLayers || !g_pfnSetPermLayers) {
        LogMsg(_T("[InitAppHelpCalls] Can't get function pointers.\n"));
        return FALSE;
    }

    //
    // this needs to be here at the end to avoid a race condition
    //
    g_hAppHelp = hAppHelp;

    return TRUE;
}

//////////////////////////////////////////////////////////////////////////
// SetLayerInfo
//
BOOL
SetLayerInfo(
    TCHAR* szPath,
    int    nMainLayer,
    BOOL   b256,
    BOOL   b640,
    BOOL   bDisableThemes,
    BOOL   bDisableCicero)
{
    WCHAR wszLayers[256];

    //
    // build layer string
    //
    wszLayers[0] = 0;
    if (nMainLayer >= 0 && nMainLayer < NUM_LAYERS) {
        wcscat(wszLayers, g_LayerInfo[nMainLayer].wszInternalName);
    }

    if (b256) {
        if (wszLayers[0]) {
            wcscat(wszLayers, L" ");
        }
        wcscat(wszLayers, STR_LAYER_256COLOR);
    }

    if (b640) {
        if (wszLayers[0]) {
            wcscat(wszLayers, L" ");
        }
        wcscat(wszLayers, STR_LAYER_LORES);
    }

    if (bDisableThemes) {
        if (wszLayers[0]) {
            wcscat(wszLayers, L" ");
        }
        wcscat(wszLayers, STR_LAYER_DISABLETHEMES);
    }

    if (bDisableCicero) {
        if (wszLayers[0]) {
            wcscat(wszLayers, L" ");
        }
        wcscat(wszLayers, STR_LAYER_DISABLECICERO);
    }

    //
    // set it
    //
    return g_pfnSetPermLayers(szPath, wszLayers, FALSE);

}


//////////////////////////////////////////////////////////////////////////
// GetLayerInfo
//
BOOL
GetLayerInfo(
    TCHAR* szPath,
    int*   pnMainLayer,
    BOOL*  pb256,
    BOOL*  pb640,
    BOOL*  pbDisableThemes,
    BOOL*  pbDisableCicero)
{
    WCHAR wszLayers[256];
    DWORD dwBytes = sizeof(wszLayers);
    int i;

    if (!pnMainLayer || !pb256 || !pb640 || !pbDisableThemes || !pbDisableCicero) {
        LogMsg(_T("[GetLayerInfo] NULL param passed in\n"));
        return FALSE;
    }

    //
    // get layer string
    //
    if (!g_pfnGetPermLayers(szPath, wszLayers, &dwBytes, GPLK_ALL)) {
        *pnMainLayer = -1;
        *pb256 = FALSE;
        *pb640 = FALSE;
        *pbDisableThemes = FALSE;
        *pbDisableCicero = FALSE;

        return TRUE;
    }

    LogMsg(_T("[GetLayerInfo] Layers \"%s\"\n"), wszLayers);

    //
    // Make the layer string upper case, so we'll match case-insensitive
    //
    _wcsupr(wszLayers);

    //
    // find the first layer that matches
    //
    *pnMainLayer = -1;
    for (i = 0; i < NUM_LAYERS; ++i) {
        if (wcsstr(wszLayers, g_LayerInfo[i].wszInternalName) != NULL) {
            *pnMainLayer = i;
        }
    }

    if (wcsstr(wszLayers, STR_LAYER_256COLOR) != NULL) {
        *pb256 = TRUE;
    } else {
        *pb256 = FALSE;
    }

    if (wcsstr(wszLayers, STR_LAYER_LORES) != NULL) {
        *pb640 = TRUE;
    } else {
        *pb640 = FALSE;
    }

    if (wcsstr(wszLayers, STR_LAYER_DISABLETHEMES) != NULL) {
        *pbDisableThemes = TRUE;
        LogMsg(_T("[GetLayerInfo] Themes disabled\n"));
    } else {
        *pbDisableThemes = FALSE;
        LogMsg(_T("[GetLayerInfo] Themes enabled\n"));
    }

    if (wcsstr(wszLayers, STR_LAYER_DISABLECICERO) != NULL) {
        *pbDisableCicero = TRUE;
        LogMsg(_T("[GetLayerInfo] Cicero disabled\n"));
    } else {
        *pbDisableCicero = FALSE;
        LogMsg(_T("[GetLayerInfo] Cicero enabled\n"));
    }

    return TRUE;
}

void
NotifyDataChanged(HWND hDlg)
{
    HWND hParent;

    if (!hDlg) {
        LogMsg(_T("[NotifyDataChanged] NULL handle passed in\n"));
        return;
    }

    hParent = GetParent(hDlg);

    if (!hParent) {
        LogMsg(_T("[NotifyDataChanged] Can't get get prop sheet parent\n"));
        return;
    }

    PropSheet_Changed(hParent, hDlg);
}


BOOL
SearchGroupForSID(
    DWORD dwGroup,
    BOOL* pfIsMember
    )
{
    PSID                     pSID;
    SID_IDENTIFIER_AUTHORITY SIDAuth = SECURITY_NT_AUTHORITY;
    BOOL                     fRes = TRUE;

    if (!AllocateAndInitializeSid(&SIDAuth,
                                  2,
                                  SECURITY_BUILTIN_DOMAIN_RID,
                                  dwGroup,
                                  0,
                                  0,
                                  0,
                                  0,
                                  0,
                                  0,
                                  &pSID)) {
        LogMsg(_T("[SearchGroupForSID] AllocateAndInitializeSid failed 0x%x\n"), GetLastError());
        fRes = FALSE;
    }

    if (!CheckTokenMembership(NULL, pSID, pfIsMember)) {
        LogMsg(_T("[SearchGroupForSID] CheckTokenMembership failed 0x%x\n"), GetLastError());
        fRes = FALSE;
    }

    FreeSid(pSID);

    return fRes;
}


//////////////////////////////////////////////////////////////////////////
// LayerPageDlgProc
//
//  The dialog proc for the layer property page.

INT_PTR CALLBACK
LayerPageDlgProc(
    HWND   hdlg,
    UINT   uMsg,
    WPARAM wParam,
    LPARAM lParam)
{
    int wCode       = LOWORD(wParam);
    int wNotifyCode = HIWORD(wParam);
    int nLayer      = -1;
    BOOL b256       = FALSE;
    BOOL b640       = FALSE;
    BOOL bDTh       = FALSE;
    BOOL bDCicero   = FALSE;

    switch (uMsg) {
    case WM_INITDIALOG:
        {
            PROPSHEETPAGE*    ppsp      = (PROPSHEETPAGE*)lParam;
            DWORD             dwFlags   = 0;
            CLayerUIPropPage* pPropPage = (CLayerUIPropPage*)ppsp->lParam;
            BOOL              bSystemBinary;
            int i;

            LogMsg(_T("[LayerPageDlgProc] WM_INITDIALOG - item \"%s\"\n"),
                   pPropPage->m_szFile);

            //
            // Store the name of the EXE/LNK in the dialog.
            //
            SetWindowLongPtr(hdlg, GWLP_USERDATA, (LONG_PTR)pPropPage->m_szFile);

            //
            // Add the names of the layers.
            //
            for (i = 0; i < NUM_LAYERS; ++i) {
                TCHAR szFriendlyName[100];

                if (LoadString(g_hInstance, g_LayerInfo[i].nstrFriendlyName, szFriendlyName, 100)) {
                    SendDlgItemMessage(hdlg,
                                       IDC_LAYER_NAME,
                                       CB_ADDSTRING,
                                       0,
                                       (LPARAM)szFriendlyName);
                }
            }

            //
            // Check if the EXE is SFPed.
            //
            bSystemBinary = SfcIsFileProtected(0, pPropPage->m_szFile);

            //
            // Check to see if we can change layers on this file
            //
            if (!g_pfnAllowPermLayer(pPropPage->m_szFile) || bSystemBinary) {

                TCHAR szTemp[256] = _T("");

                SendDlgItemMessage(hdlg, IDC_LAYER_NAME, CB_SETCURSEL, 0, 0);
                EnableWindow(GetDlgItem(hdlg, IDC_USE_LAYER), FALSE);
                EnableWindow(GetDlgItem(hdlg, IDC_256COLORS), FALSE);
                EnableWindow(GetDlgItem(hdlg, IDC_640X480), FALSE);
                EnableWindow(GetDlgItem(hdlg, IDC_ENABLE_THEMES), FALSE);
                EnableWindow(GetDlgItem(hdlg, IDC_DISABLECICERO), FALSE);

                //
                // Change the text on the static object
                //
                if (bSystemBinary) {
                    LoadString(g_hInstance, IDS_COMPAT_UNAVAILABLE_SYSTEM, szTemp, 256);
                } else {
                    LoadString(g_hInstance, IDS_COMPAT_UNAVAILABLE, szTemp, 256);
                }

                SendDlgItemMessage(hdlg, IDC_TEXT_INSTRUCTIONS, WM_SETTEXT, 0, (LPARAM)szTemp);

            } else {
                //
                // Read the layer storage for info on this item.
                //
                GetLayerInfo(pPropPage->m_szFile, &nLayer, &b256, &b640, &bDTh, &bDCicero);

                //
                // Select the appropriate layer for this item. If no info
                // is available in the layer store, default to the Win9x layer.
                //

                if (nLayer != -1) {
                    SendDlgItemMessage(hdlg, IDC_LAYER_NAME, CB_SETCURSEL, nLayer, 0);
                    EnableWindow(GetDlgItem(hdlg, IDC_LAYER_NAME), TRUE);
                    SendDlgItemMessage(hdlg, IDC_USE_LAYER, BM_SETCHECK, BST_CHECKED, 0);

                } else {
                    SendDlgItemMessage(hdlg, IDC_LAYER_NAME, CB_SETCURSEL, 0, 0);
                    EnableWindow(GetDlgItem(hdlg, IDC_LAYER_NAME), FALSE);
                    SendDlgItemMessage(hdlg, IDC_USE_LAYER, BM_SETCHECK, BST_UNCHECKED, 0);
                }

                if (b256) {
                    SendDlgItemMessage(hdlg, IDC_256COLORS, BM_SETCHECK, BST_CHECKED, 0);
                }
                if (b640) {
                    SendDlgItemMessage(hdlg, IDC_640X480, BM_SETCHECK, BST_CHECKED, 0);
                }
                if (bDTh) {
                    SendDlgItemMessage(hdlg, IDC_ENABLE_THEMES, BM_SETCHECK, BST_CHECKED, 0);
                }
                if (bDCicero) {
                    SendDlgItemMessage(hdlg, IDC_DISABLECICERO, BM_SETCHECK, BST_CHECKED, 0);
                }
            }

            break;
        }
        
    case WM_HELP:
        {
            LPHELPINFO lphi;

            lphi = (LPHELPINFO)lParam;
            if (lphi->iContextType == HELPINFO_WINDOW) {
                WinHelp((HWND)lphi->hItemHandle,
                        L"Windows.hlp",
                        HELP_CONTEXTPOPUP,
                        (DWORD)lphi->iCtrlId);

                MessageBeep(0);
            }
            break;;
       }
   case WM_COMMAND:
        {

            switch (wNotifyCode) {

            case CBN_SELCHANGE:
                NotifyDataChanged(hdlg);
                return TRUE;
            }

            switch (wCode) {

            case IDC_256COLORS:
            case IDC_640X480:
            case IDC_ENABLE_THEMES:
            case IDC_DISABLECICERO:
                NotifyDataChanged(hdlg);
                break;


            case IDC_USE_LAYER:
                if (SendDlgItemMessage(hdlg, IDC_USE_LAYER, BM_GETCHECK, 0, 0) == BST_CHECKED) {
                    EnableWindow(GetDlgItem(hdlg, IDC_LAYER_NAME), TRUE);

                } else {
                    EnableWindow(GetDlgItem(hdlg, IDC_LAYER_NAME), FALSE);
                }
                NotifyDataChanged(hdlg);
                break;

            default:
                return FALSE;
            }
            break;
        }

    case WM_NOTIFY:
        {
            NMHDR *pHdr = (NMHDR*)lParam;

            switch (pHdr->code) {
            case NM_CLICK:
            case NM_RETURN:
                {
                    if ((int)wParam != IDC_LEARN) {
                        break;
                    }

                    SHELLEXECUTEINFO sei = { 0 };

                    sei.cbSize = sizeof(SHELLEXECUTEINFO);
                    sei.fMask  = SEE_MASK_DOENVSUBST;
                    sei.hwnd   = hdlg;
                    sei.nShow  = SW_SHOWNORMAL;
                    sei.lpFile = _T("hcp://services/subsite?node=TopLevelBucket_4/")
                                 _T("Fixing_a_problem&topic=MS-ITS%3A%25HELP_LOCATION")
                                 _T("%25%5Cmisc.chm%3A%3A/compatibility_tab_and_wizard.htm")
                                 _T("&select=TopLevelBucket_4/Fixing_a_problem/")
                                 _T("Application_and_software_problems");

                    ShellExecuteEx(&sei);
                    break;
                }
            case PSN_APPLY:
                {
                    TCHAR *szFile;

                    szFile = (TCHAR*)GetWindowLongPtr(hdlg, GWLP_USERDATA);

                    if (szFile) {
                        if (SendDlgItemMessage(hdlg, IDC_USE_LAYER, BM_GETCHECK, 0, 0) == BST_CHECKED) {
                            LRESULT retval;

                            retval = SendDlgItemMessage(hdlg, IDC_LAYER_NAME, CB_GETCURSEL, 0, 0);
                            if (retval == CB_ERR) {
                                LogMsg(_T("[LayerPageDlgProc] Can't get combobox selection\n"));
                                nLayer = -1;
                            } else {
                                nLayer = (int)retval;
                            }
                        } else {
                            nLayer = -1;
                        }

                        b256 = SendDlgItemMessage(hdlg, IDC_256COLORS, BM_GETCHECK, 0, 0) == BST_CHECKED;
                        b640 = SendDlgItemMessage(hdlg, IDC_640X480, BM_GETCHECK, 0, 0) == BST_CHECKED;
                        bDTh = SendDlgItemMessage(hdlg, IDC_ENABLE_THEMES, BM_GETCHECK, 0, 0) == BST_CHECKED;
                        bDCicero = SendDlgItemMessage(hdlg, IDC_DISABLECICERO, BM_GETCHECK, 0, 0) == BST_CHECKED;

                        SetLayerInfo(szFile, nLayer, b256, b640, bDTh, bDCicero);
                    } else {
                        LogMsg(_T("[LayerPageDlgProc] Can't get file name from WindowLong\n"));
                    }

                    SetWindowLongPtr(hdlg, DWLP_MSGRESULT, PSNRET_NOERROR);

                    break;
                }
            }
            return TRUE;
        }

    default:
        return FALSE;
    }

    return TRUE;
}

//////////////////////////////////////////////////////////////////////////
// LayerPageCallbackProc
//
//  The callback for the property page.

UINT CALLBACK
LayerPageCallbackProc(
    HWND            hwnd,
    UINT            uMsg,
    LPPROPSHEETPAGE ppsp
    )
{
    switch (uMsg) {
    case PSPCB_RELEASE:
        if (ppsp->lParam != 0) {
            CLayerUIPropPage* pPropPage = (CLayerUIPropPage*)(ppsp->lParam);

            LogMsg(_T("[LayerPageCallbackProc] releasing CLayerUIPropPage\n"));

            pPropPage->Release();
        }

        if (g_hQfeRes) {
            FreeLibrary(g_hQfeRes);
            g_hQfeRes = NULL;
        }

        break;
    }

    return 1;
}


BOOL
GetExeFromLnk(
    TCHAR* pszLnk,
    TCHAR* pszExe,
    int    cchSize
    )
{
    HRESULT         hres;
    IShellLink*     psl = NULL;
    IPersistFile*   pPf = NULL;
    TCHAR           szArg[MAX_PATH];
    BOOL            bSuccess = FALSE;

    IShellLinkDataList* psldl;
    EXP_DARWIN_LINK*    pexpDarwin;

    hres = CoCreateInstance(CLSID_ShellLink,
                            NULL,
                            CLSCTX_INPROC_SERVER,
                            IID_IShellLink,
                            (LPVOID*)&psl);
    if (FAILED(hres)) {
        LogMsg(_T("[GetExeFromLnk] CoCreateInstance failed\n"));
        return FALSE;
    }

    hres = psl->QueryInterface(IID_IPersistFile, (LPVOID*)&pPf);

    if (FAILED(hres)) {
        LogMsg(_T("[GetExeFromLnk] QueryInterface for IPersistFile failed\n"));
        goto cleanup;
    }

    //
    // Load the link file.
    //
    hres = pPf->Load(pszLnk, STGM_READ);

    if (FAILED(hres)) {
        LogMsg(_T("[GetExeFromLnk] failed to load link \"%s\"\n"),
               pszLnk);
        goto cleanup;
    }

    //
    // See if this is a DARWIN link.
    //

    hres = psl->QueryInterface(IID_IShellLinkDataList, (LPVOID*)&psldl);

    if (FAILED(hres)) {
        LogMsg(_T("[GetExeFromLnk] failed to get IShellLinkDataList.\n"));
    } else {
        hres = psldl->CopyDataBlock(EXP_DARWIN_ID_SIG, (void**)&pexpDarwin);

        if (SUCCEEDED(hres)) {
            LogMsg(_T("[GetExeFromLnk] this is a DARWIN link \"%s\".\n"),
                   pszLnk);
            goto cleanup;
        }
    }

    //
    // Resolve the link.
    //
    hres = psl->Resolve(NULL,
                        SLR_NOTRACK | SLR_NOSEARCH | SLR_NO_UI | SLR_NOUPDATE);

    if (FAILED(hres)) {
        LogMsg(_T("[GetExeFromLnk] failed to resolve the link \"%s\"\n"),
               pszLnk);
        goto cleanup;
    }

    pszExe[0] = 0;

    //
    // Get the path to the link target.
    //
    hres = psl->GetPath(pszExe,
                        cchSize,
                        NULL,
                        SLGP_UNCPRIORITY);

    if (FAILED(hres)) {
        LogMsg(_T("[GetExeFromLnk] failed to get the path for link \"%s\"\n"),
               pszLnk);
        goto cleanup;
    }

    bSuccess = TRUE;

cleanup:

    if (pPf != NULL) {
        pPf->Release();
    }

    psl->Release();

    return bSuccess;
}


//////////////////////////////////////////////////////////////////////////
// CLayerUIPropPage

CLayerUIPropPage::CLayerUIPropPage()
{
    LogMsg(_T("[CLayerUIPropPage::CLayerUIPropPage]\n"));
}

CLayerUIPropPage::~CLayerUIPropPage()
{
    LogMsg(_T("[CLayerUIPropPage::~CLayerUIPropPage]\n"));
}

//////////////////////////////////////////////////////////////////////////
//
// Function: ValidateExecutableFile
// 
// This function exists also in compatUI.dll for the purpose of validating
// the file as being acceptable for compatibility handling. It looks at the
// file extension to determine whether a given file is "acceptable"
//

BOOL
ValidateExecutableFile(
    LPCTSTR pszPath,
    BOOL    bValidateFileExists,
    BOOL*   pbIsLink
    )
{
    LPTSTR rgExt[] = {  // this list should be sorted 
            _T("BAT"),
            _T("CMD"),
            _T("COM"),
            _T("EXE"),
            _T("LNK"),
            _T("PIF")
            };
    LPTSTR pExt;
    TCHAR  szLnk[] = _T("LNK");
    int i;
    int iCmp = 1;

    pExt = PathFindExtension(pszPath);
    if (pExt == NULL || *pExt == TEXT('\0')) {
        return FALSE;
    }
    ++pExt; // move past '.' 

    for (i = 0; i < sizeof(rgExt)/sizeof(rgExt[0]) && iCmp > 0; ++i) {
        iCmp = _tcsicmp(pExt, rgExt[i]);          
    }

    if (iCmp) {
        return FALSE;
    }

    if (pbIsLink) {
        *pbIsLink = !_tcsicmp(pExt, szLnk);
    }

    return bValidateFileExists ? PathFileExists(pszPath) : TRUE;
}
    

//////////////////////////////////////////////////////////////////////////
// IShellExtInit methods

STDMETHODIMP
CLayerUIPropPage::Initialize(
    LPCITEMIDLIST pIDFolder,
    LPDATAOBJECT  pDataObj,
    HKEY          hKeyID
    )
{
    LogMsg(_T("[CLayerUIPropPage::Initialize]\n"));

    if (pDataObj == NULL) {
        LogMsg(_T("\t failed. bad argument.\n"));
        return E_INVALIDARG;
    }

    //
    // init the apphelp calls
    //
    if (!InitAppHelpCalls()) {
        LogMsg(_T("\t failed. couldn't init apphelp calls.\n"));
        return  E_FAIL;
    }

    //
    // Store a pointer to the data object
    //
    m_spDataObj = pDataObj;

    //
    // If a data object pointer was passed in, save it and
    // extract the file name.
    //
    STGMEDIUM   medium;
    UINT        uCount;
    FORMATETC   fe = {CF_HDROP, NULL, DVASPECT_CONTENT, -1,
                      TYMED_HGLOBAL};

    if (SUCCEEDED(m_spDataObj->GetData(&fe, &medium))) {

        //
        // Get the file name from the CF_HDROP.
        //
        uCount = DragQueryFile((HDROP)medium.hGlobal, (UINT)-1,
                               NULL, 0);
        if (uCount > 0) {

            TCHAR  szExe[MAX_PATH];
            BOOL   bIsLink = FALSE;

            DragQueryFile((HDROP)medium.hGlobal, 0, szExe,
                          sizeof(szExe) / sizeof(TCHAR));

            LogMsg(_T("\tProp page for: \"%s\".\n"), szExe);

            m_szFile[0] = 0;

            if (ValidateExecutableFile(szExe, TRUE, &bIsLink)) {
                
                
                if (bIsLink) {
                    //
                    // the file is a link indeed, get the contents
                    //
                    if (!GetExeFromLnk(szExe, m_szFile, MAX_PATH)) {

                        //
                        // can't get exe from the link, m_szFile[0] == 0
                        //
                        LogMsg(_T("Couldn't convert \"%s\" to EXE.\n"), m_szFile);
                        
                    } else {

                        LogMsg(_T("\tLNK points to: \"%s\".\n"), m_szFile);
                        //
                        // check to see if it's a shortcut to an EXE file
                        //
                        if (!ValidateExecutableFile(m_szFile, FALSE, NULL)) {
                            //
                            // shortcut points to a file of the unsupported type, reset the name
                            //
                            LogMsg(_T("\tNot an EXE file. Won't init prop page.\n"), m_szFile);
                            m_szFile[0] = 0;
                        }
                    }        
                } else {
                    //
                    // not a link, just copy the filename
                    //

                    _tcscpy(m_szFile, szExe);
                    
                }
            } else {
                //
                // this is the case when the file is not .lnk, exe or other recognizable type
                //
                LogMsg(_T("\tNot an EXE or LNK file. Won't init prop page.\n"), m_szFile);
            }
               
                
        }

        ReleaseStgMedium(&medium);
    } else {
        LogMsg(_T("\t failed to get the data.\n"));
    }

    return NOERROR;
}

//////////////////////////////////////////////////////////////////////////
// IShellPropSheetExt methods


STDMETHODIMP
CLayerUIPropPage::AddPages(
    LPFNADDPROPSHEETPAGE lpfnAddPage,
    LPARAM               lParam
    )
{
    PROPSHEETPAGE  psp;
    HPROPSHEETPAGE hPage;
    TCHAR          szCompatibility[128] = _T("");
    BOOL           fIsGuest = FALSE;
    HINSTANCE      hInstRes = _Module.m_hInst;
    
    LogMsg(_T("[CLayerUIPropPage::AddPages]\n"));

    if (m_szFile[0] == 0) {
        return S_OK;
    }

    //
    // Disable the property page for guests
    //
    if (!SearchGroupForSID(DOMAIN_ALIAS_RID_GUESTS, &fIsGuest)) {
        LogMsg(_T("\tFailed to lookup the GUEST account\n"));
        return S_OK;
    }

    if (fIsGuest) {
        LogMsg(_T("\tDisable the compatibility page for the GUEST account\n"));
        return S_OK;
    }

    if (!LoadString(g_hInstance, IDS_COMPATIBILITY, szCompatibility, 128)) {
        LogMsg(_T("\tFailed to load \"Compatibility\" resource string\n"));
        return S_OK;
    }

    g_hQfeRes = LoadLibrary(_T("xpsp1res.dll"));

    if (g_hQfeRes) {
        hInstRes = g_hQfeRes;
    }
    
    psp.dwSize        = sizeof(psp);
    psp.dwFlags       = PSP_USEREFPARENT | PSP_USETITLE | PSP_USECALLBACK;
    psp.hInstance     = hInstRes;
    psp.pszTemplate   = MAKEINTRESOURCE(IDD_LAYER_PROPPAGE);
    psp.hIcon         = 0;
    psp.pszTitle      = szCompatibility;
    psp.pfnDlgProc    = (DLGPROC)LayerPageDlgProc;
    psp.pcRefParent   = &g_DllRefCount;
    psp.pfnCallback   = LayerPageCallbackProc;
    psp.lParam        = (LPARAM)this;

    LogMsg(_T("\titem           \"%s\".\n"), m_szFile);
    LogMsg(_T("\tg_DllRefCount  %d.\n"), g_DllRefCount);

    AddRef();

    hPage = CreatePropertySheetPage(&psp);
            
    if (hPage != NULL) {

        if (lpfnAddPage(hPage, lParam)) {
            return S_OK;
        } else {
            DestroyPropertySheetPage(hPage);
            Release();
            return S_OK;
        }
    } else {
        return E_OUTOFMEMORY;
    }

    return E_FAIL;
}

STDMETHODIMP
CLayerUIPropPage::ReplacePage(
    UINT                 uPageID,
    LPFNADDPROPSHEETPAGE lpfnReplacePage,
    LPARAM               lParam
    )
{
    LogMsg(_T("[CLayerUIPropPage::ReplacePage]\n"));
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\appcompat\slayerui\win2k\shellextensions.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1999 - 2000
//
//  File:       ShellExtensions.h
//
//--------------------------------------------------------------------------

#ifndef __SHELLEXTENSIONS_H
#define __SHELLEXTENSIONS_H

#define LI_WIN95    0x00000001
#define LI_NT4      0x00000002
#define LI_WIN98    0x00000004

#define LS_MAGIC    0x07036745

void InitLayerStorage(BOOL bDelete);
void CheckForRights(void);

//
// LayeredItemOperation flags
//
#define LIO_READITEM    1
#define LIO_ADDITEM     2
#define LIO_DELETEITEM  3

typedef struct tagLayerStorageHeader {
    DWORD       dwItemCount;    // number of items in the file
    DWORD       dwMagic;        // magic to identify the file
    SYSTEMTIME  timeLast;       // time of last access
} LayerStorageHeader, *PLayerStorageHeader;


typedef struct tagLayeredItem {
    WCHAR   szItemName[MAX_PATH];
    DWORD   dwFlags;

} LayeredItem, *PLayeredItem;


class CLayerUIPropPage:
    IShellExtInit,
    IShellPropSheetExt,
    public CComObjectRoot,
    public CComCoClass<CLayerUIPropPage, &CLSID_ShimLayerPropertyPage>
{
    BEGIN_COM_MAP(CLayerUIPropPage)
        COM_INTERFACE_ENTRY(IShellExtInit)
        COM_INTERFACE_ENTRY(IShellPropSheetExt)
    END_COM_MAP()

public:
    DECLARE_REGISTRY_CLSID()

    CLayerUIPropPage();
    ~CLayerUIPropPage();

    //
    // IShellExtInit methods
    //
    STDMETHODIMP Initialize(LPCITEMIDLIST pIDFolder,
                            LPDATAOBJECT  pDataObj,
                            HKEY          hKeyID);
  
    //
    // IShellPropSheetExt methods
    //
    STDMETHODIMP AddPages(LPFNADDPROPSHEETPAGE lpfnAddPage,
                          LPARAM               lParam);

    STDMETHODIMP ReplacePage(UINT uPageID,
                             LPFNADDPROPSHEETPAGE lpfnReplacePage,
                             LPARAM lParam);
    
    friend INT_PTR CALLBACK
        LayerPageDlgProc(HWND   hdlg,
                         UINT   uMsg,
                         WPARAM wParam,
                         LPARAM lParam);

private:
    CComPtr<IDataObject>  m_spDataObj;

    TCHAR                 m_szFile[MAX_PATH];
};


#endif // __SHELLEXTENSIONS_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\appcompat\slayerui\win2k\shellextensions.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 2000
//
//  File:      ShellExtensions.cpp
//
//  Contents:  object to implement propertypage extensions
//             for Win2k shim layer
//
//  History:   23-september-00 clupu    Created
//             
//
//--------------------------------------------------------------------------

#include "stdafx.h"
#include "resource.h"
#include "ShellExtensions.h"

UINT    g_DllRefCount = 0;
BOOL    g_bExtEnabled = FALSE;
TCHAR   g_szLayerStorage[MAX_PATH] = _T("");

//////////////////////////////////////////////////////////////////////////
// InitLayerStorage
//
//  Get the name of the file that will be used to store
//  information about which EXEs/LNKs are layered.

void
InitLayerStorage(
    BOOL bDelete
    )
{
    GetSystemWindowsDirectory(g_szLayerStorage, MAX_PATH);
    
    if (g_szLayerStorage[lstrlen(g_szLayerStorage) - 1] == _T('\\')) {
        g_szLayerStorage[lstrlen(g_szLayerStorage) - 1] = 0;
    }
    
    lstrcat(g_szLayerStorage, _T("\\AppPatch\\LayerStorage.dat"));

    if (bDelete) {
        DeleteFile(g_szLayerStorage);
    }
}


//////////////////////////////////////////////////////////////////////////
// CheckForRights
//

#define APPCOMPAT_KEY         _T("System\\CurrentControlSet\\Control\\Session Manager\\AppCompatibility")
#define APPCOMPAT_TEST_SUBKEY _T("12181969-7036745")

void
CheckForRights(
    void
    )
{
    HKEY hkey = NULL, hkeyTest = NULL;
    LONG lRes;

    g_bExtEnabled = FALSE;
    
    lRes = RegOpenKey(HKEY_LOCAL_MACHINE, APPCOMPAT_KEY, &hkey);
    
    if (lRes != ERROR_SUCCESS) {
        LogMsg(_T("[CheckForRights] cannot open the appcompat key.\n")
               _T("The appcompat shell extension will be disabled\n"));
        return;
    }
    
    lRes = RegCreateKey(hkey, APPCOMPAT_TEST_SUBKEY, &hkeyTest);

    if (lRes != ERROR_SUCCESS) {
        LogMsg(_T("[CheckForRights] cannot create test registry key.\n")
               _T("The appcompat shell extension will be disabled\n"));
        goto cleanup;
    }
    
    RegCloseKey(hkeyTest);
    hkeyTest = NULL;
    
    lRes = RegDeleteKey(hkey, APPCOMPAT_TEST_SUBKEY);
    
    if (lRes != ERROR_SUCCESS) {
        LogMsg(_T("[CheckForRights] cannot delete test registry key.\n")
               _T("The appcompat shell extension will be disabled\n"));
        goto cleanup;
    }
    
    g_bExtEnabled = TRUE;

cleanup:
    if (hkey != NULL) {
        RegCloseKey(hkey);
    }
}


//////////////////////////////////////////////////////////////////////////
// CreateLayeredStorage
//
//  Create the file for layer storage.

void
CreateLayeredStorage(
    LPWSTR pszItem,
    DWORD  dwFlags
    )
{
    HANDLE hFile;

    hFile = CreateFile(g_szLayerStorage,
                       GENERIC_READ | GENERIC_WRITE,
                       FILE_SHARE_READ | FILE_SHARE_WRITE,
                       NULL,
                       CREATE_NEW,
                       0,
                       NULL);

    if (hFile == INVALID_HANDLE_VALUE) {
        LogMsg(_T("[CreateLayeredStorage] cannot create the storage file!\n"));
        return;
    }

    LayerStorageHeader Header;
    LayeredItem        Item;

    Header.dwItemCount = 1;
    Header.dwMagic     = LS_MAGIC;

    GetLocalTime(&Header.timeLast);

    ZeroMemory(&Item, sizeof(Item));

    Item.dwFlags = dwFlags;
    lstrcpy(Item.szItemName, pszItem);

    DWORD dwBytesWritten = 0;

    WriteFile(hFile, &Header, sizeof(Header), &dwBytesWritten, NULL);
    WriteFile(hFile, &Item,   sizeof(Item),   &dwBytesWritten, NULL);
    
    LogMsg(_T("[CreateLayeredStorage] storage file \"%s\" initialized\n"),
           g_szLayerStorage);
    
    CloseHandle(hFile);
}

//////////////////////////////////////////////////////////////////////////
// LayeredItemOperation
//
//  Add/Delete/Query items in the layer storage

void
LayeredItemOperation(
    LPWSTR  pszItem,
    DWORD   dwOp,
    LPDWORD lpdwFlags
    )
{
    LogMsg(_T("[LayeredItemOperation] op %d item \"%s\"\n"),
           dwOp, pszItem);

    HANDLE              hFile        = INVALID_HANDLE_VALUE;
    HANDLE              hFileMapping = NULL;
    DWORD               dwFileSize;
    PBYTE               pData        = NULL;
    PLayerStorageHeader pHeader      = NULL;
    PLayeredItem        pItems;
    PLayeredItem        pCrtItem     = NULL;
    int                 nLeft, nRight, nMid, nItem;
    BOOL                bShrinkFile  = FALSE;
    
    //
    // Make sure we don't corrupt the layer storage.
    //
    if (lstrlenW(pszItem) + 1 > MAX_PATH) {
        pszItem[MAX_PATH - 1] = 0;
    }
    
    hFile = CreateFile(g_szLayerStorage,
                       GENERIC_READ | GENERIC_WRITE,
                       FILE_SHARE_READ | FILE_SHARE_WRITE,
                       NULL,
                       OPEN_EXISTING,
                       0,
                       NULL);

    if (hFile == INVALID_HANDLE_VALUE) {
        
        LogMsg(_T("[LayeredItemOperation] the layer storage doesn't exist\n"));
        
        if (dwOp == LIO_READITEM) {
            *lpdwFlags = 0;
            return;
        }

        if (dwOp == LIO_DELETEITEM) {
            LogMsg(_T("[LayeredItemOperation] cannot delete item\n"));
            return;
        }

        //
        // The file doesn't exist and the operation is LIO_ADDITEM.
        // Create the file, write the item and get out.
        //
        CreateLayeredStorage(pszItem, *lpdwFlags);
        return;
    }

    //
    // The file already exists. Create a file mapping that will allow
    // for adding/deleting/querying the item.
    //
    dwFileSize = GetFileSize(hFile, NULL);

    hFileMapping = CreateFileMapping(hFile,
                                     NULL,
                                     PAGE_READWRITE,
                                     0,
                                     dwFileSize + (dwOp == LIO_ADDITEM ? sizeof(LayeredItem) : 0),
                                     NULL);

    if (hFileMapping == NULL) {
        LogMsg(_T("[LayeredItemOperation] CreateFileMapping failed 0x%X\n"),
               GetLastError());
        goto done;
    }

    pData = (PBYTE)MapViewOfFile(hFileMapping,
                                 FILE_MAP_READ | FILE_MAP_WRITE,
                                 0,
                                 0,
                                 0);
    
    if (pData == NULL) {
        LogMsg(_T("[LayeredItemOperation] MapViewOfFile failed 0x%X\n"),
               GetLastError());
        goto done;
    }

    pHeader = (PLayerStorageHeader)pData;

    pItems = (PLayeredItem)(pData + sizeof(LayerStorageHeader));

    //
    // Make sure it's our file.
    //
    if (dwFileSize < sizeof(LayerStorageHeader) || pHeader->dwMagic != LS_MAGIC) {
        LogMsg(_T("[LayeredItemOperation] invalid file magic 0x%0X\n"),
               pHeader->dwMagic);
        goto done;
    }

    //
    // Get the last access time.
    //
    GetLocalTime(&pHeader->timeLast);
    
    //
    // First search for the item. The array is sorted so we do binary search.
    //
    nItem = -1, nLeft = 0, nRight = (int)pHeader->dwItemCount - 1;

    while (nLeft <= nRight) {
        
        int nVal;
        
        nMid = (nLeft + nRight) / 2;

        pCrtItem  = pItems + nMid;
        
        nVal = lstrcmpi(pszItem, pCrtItem->szItemName);
        
        if (nVal == 0) {
            nItem = nMid;
            break;
        } else if (nVal < 0) {
            nRight = nMid - 1;
        } else {
            nLeft = nMid + 1;
        }
    }

    if (nItem == -1) {
        LogMsg(_T("[LayeredItemOperation] the item was not found in the file.\n"));

        if (dwOp == LIO_DELETEITEM) {
            goto done;
        }
        
        if (dwOp == LIO_READITEM) {
            *lpdwFlags = 0;
            goto done;
        }
        
        if (pHeader->dwItemCount == 0) {
            pCrtItem = pItems;
        } else {
            
            MoveMemory(pItems + nLeft + 1,
                       pItems + nLeft,
                       ((int)pHeader->dwItemCount - nLeft) * sizeof(LayeredItem));

            pCrtItem = pItems + nLeft;
        }
        
        ZeroMemory(pCrtItem, sizeof(LayeredItem));

        pCrtItem->dwFlags = *lpdwFlags;
        lstrcpy(pCrtItem->szItemName, pszItem);

        (pHeader->dwItemCount)++;
    } else {
        //
        // The item is already in the file.
        //
        LogMsg(_T("[LayeredItemOperation] the item is in the file\n"));

        if (dwOp == LIO_READITEM) {
            *lpdwFlags = pCrtItem->dwFlags;
            goto done;
        }
        
        if (dwOp == LIO_DELETEITEM) {
            MoveMemory(pItems + nItem,
                       pItems + nItem + 1,
                       ((int)pHeader->dwItemCount - nItem - 1) * sizeof(LayeredItem));
            
            (pHeader->dwItemCount)--;
        } else {
            //
            // Update the item's flags.
            //
            pCrtItem->dwFlags = *lpdwFlags;
        }
        
        //
        // We've found the item so shrink the file by one item.
        //
        bShrinkFile = TRUE;
    }
    
done:

    if (pData != NULL) {
        UnmapViewOfFile(pData);
    }

    if (hFileMapping != NULL) {
        CloseHandle(hFileMapping);
    }

    if (bShrinkFile) {
        SetFilePointer(hFile, - (int)sizeof(LayeredItem), NULL, FILE_END);
        SetEndOfFile(hFile);
    }
    
    if (hFile != INVALID_HANDLE_VALUE) {
        CloseHandle(hFile);
    }
}

//////////////////////////////////////////////////////////////////////////
// LayerSelection
//
//  The user changed the selection in the combo-box with the layers.
//  Persist the user's selection to the layer storage.

void
LayerSelection(
    HWND   hdlg,
    LPWSTR pszItem
    )
{
    //
    // See which layer is selected.
    //
    LPARAM lSel = SendDlgItemMessage(hdlg, IDC_LAYER_NAME, CB_GETCURSEL, 0, 0);

    if (lSel == CB_ERR) {
        LogMsg(_T("[LayerSelection] couldn't get the current selection\n"));
    } else {

        DWORD dwFlags;

        switch (lSel) {
        case 0:
            dwFlags = LI_WIN95;
            break;
        case 1:
            dwFlags = LI_WIN98;
            break;
        case 2:
            dwFlags = LI_NT4;
            break;
        default:
            LogMsg(_T("[LayerSelection] bad selection. default to Win9x\n"));
            dwFlags = LI_WIN95;
            break;
        }

        LayeredItemOperation(pszItem, LIO_ADDITEM, &dwFlags);
    }
}

//////////////////////////////////////////////////////////////////////////
// LayerPageDlgProc
//
//  The dialog proc for the layer property page.

INT_PTR CALLBACK
LayerPageDlgProc(
    HWND   hdlg,
    UINT   uMsg,
    WPARAM wParam,
    LPARAM lParam)
{
    int wCode = LOWORD(wParam);
    int wNotifyCode = HIWORD(wParam);

    switch (uMsg) {
    case WM_INITDIALOG:
    {
        PROPSHEETPAGE*    ppsp = (PROPSHEETPAGE*)lParam;
        DWORD             dwFlags = 0;
        CLayerUIPropPage* pPropPage = (CLayerUIPropPage*)ppsp->lParam;
        
        LogMsg(_T("[LayerPageDlgProc] WM_INITDIALOG - item \"%s\"\n"),
               pPropPage->m_szFile);
        
        //
        // Store the name of the EXE/LNK in the dialog.
        //
        SetWindowLong(hdlg, GWL_USERDATA, (LPARAM)pPropPage->m_szFile);
        
        //
        // Add the names of the layers.
        //
        SendDlgItemMessage(hdlg,
                           IDC_LAYER_NAME,
                           CB_ADDSTRING,
                           0,
                           (LPARAM)_T("Windows 95 Compatibility Layer"));
        
        SendDlgItemMessage(hdlg,
                           IDC_LAYER_NAME,
                           CB_ADDSTRING,
                           0,
                           (LPARAM)_T("Windows 98 Compatibility Layer"));
        
        SendDlgItemMessage(hdlg,
                           IDC_LAYER_NAME,
                           CB_ADDSTRING,
                           0,
                           (LPARAM)_T("Windows NT4 SP5 Compatibility Layer"));
        
        //
        // Read the layer storage for info on this item.
        //
        LayeredItemOperation(pPropPage->m_szFile, LIO_READITEM, &dwFlags);
        
        //
        // Select the appropriate layer for this item. If no info
        // is available in the layer store, default to the Win9x layer.
        //
        BOOL bEnable;
        
        switch (dwFlags) {
        case LI_WIN95:
            SendDlgItemMessage(hdlg, IDC_LAYER_NAME, CB_SETCURSEL, 0, 0);
            bEnable = TRUE;
            break;
        
        case LI_WIN98:
            SendDlgItemMessage(hdlg, IDC_LAYER_NAME, CB_SETCURSEL, 1, 0);
            bEnable = TRUE;
            break;
        
        case LI_NT4:
            SendDlgItemMessage(hdlg, IDC_LAYER_NAME, CB_SETCURSEL, 2, 0);
            bEnable = TRUE;
            break;
        
        default:
            SendDlgItemMessage(hdlg, IDC_LAYER_NAME, CB_SETCURSEL, 0, 0);
            bEnable = FALSE;
        }

        if (bEnable) {
            EnableWindow(GetDlgItem(hdlg, IDC_LAYER_NAME), TRUE);
            SendDlgItemMessage(hdlg, IDC_USE_LAYER, BM_SETCHECK, BST_CHECKED, 0);
        }
        
        break;
    }

    case WM_COMMAND:
    {
        LPWSTR pszItem;
        
        pszItem = (LPTSTR)GetWindowLong(hdlg, GWL_USERDATA);
        
        switch (wNotifyCode) {
        case CBN_SELCHANGE:
            LayerSelection(hdlg, pszItem);
            return TRUE;
        }
        
        switch (wCode) {
        
        case IDC_USE_LAYER:
            if (SendDlgItemMessage(hdlg, IDC_USE_LAYER, BM_GETCHECK, 0, 0) == BST_CHECKED) {
                EnableWindow(GetDlgItem(hdlg, IDC_LAYER_NAME), TRUE);
                LayerSelection(hdlg, pszItem);

            } else {
                EnableWindow(GetDlgItem(hdlg, IDC_LAYER_NAME), FALSE);
                LayeredItemOperation(pszItem, LIO_DELETEITEM, NULL);
            }
            break;

        default:
            return FALSE;
        }
        break;
    }

    default:
        return FALSE;
    }

    return TRUE;
}

//////////////////////////////////////////////////////////////////////////
// LayerPageCallbackProc
//
//  The callback for the property page.

UINT CALLBACK
LayerPageCallbackProc(
    HWND            hwnd,
    UINT            uMsg,
    LPPROPSHEETPAGE ppsp
    )
{
    switch (uMsg) {
    case PSPCB_RELEASE:
        if (ppsp->lParam != 0) {
            CLayerUIPropPage* pPropPage = (CLayerUIPropPage*)(ppsp->lParam);
            
            LogMsg(_T("[LayerPageCallbackProc] releasing CLayerUIPropPage\n"));
            
            pPropPage->Release();
        }
        break;
    }
    
    return 1;
}


BOOL
GetExeFromLnk(
    TCHAR* pszLnk,
    TCHAR* pszExe,
    int    cbSize
    )
{
    HRESULT         hres;
    IShellLink*     psl = NULL;
    IPersistFile*   pPf = NULL;
    WIN32_FIND_DATA wfd;
    TCHAR           szArg[MAX_PATH];
    BOOL            bSuccess = FALSE;
    
    IShellLinkDataList* psldl;
    EXP_DARWIN_LINK*    pexpDarwin;
    
    hres = CoCreateInstance(CLSID_ShellLink,
                            NULL,
                            CLSCTX_INPROC_SERVER,
                            IID_IShellLink,
                            (LPVOID*)&psl);
    if (FAILED(hres)) {
        LogMsg(_T("[GetExeFromLnk] CoCreateInstance failed\n"));
        return FALSE;
    }

    hres = psl->QueryInterface(IID_IPersistFile, (LPVOID*)&pPf);
    
    if (FAILED(hres)) {
        LogMsg(_T("[GetExeFromLnk] QueryInterface for IPersistFile failed\n"));
        goto cleanup;
    }

    //
    // Load the link file.
    //
    hres = pPf->Load(pszLnk, STGM_READ);
    
    if (FAILED(hres)) {
        LogMsg(_T("[GetExeFromLnk] failed to load link \"%s\"\n"),
               pszLnk);
        goto cleanup;
    }

    //
    // See if this is a DARWIN link.
    //

    hres = psl->QueryInterface(IID_IShellLinkDataList, (LPVOID*)&psldl);
    
    if (FAILED(hres)) {
        LogMsg(_T("[GetExeFromLnk] failed to get IShellLinkDataList.\n"));
    } else {
        hres = psldl->CopyDataBlock(EXP_DARWIN_ID_SIG, (void**)&pexpDarwin);
        
        if (SUCCEEDED(hres)) {
            LogMsg(_T("[GetExeFromLnk] this is a DARWIN link \"%s\".\n"),
                   pszLnk);
            goto cleanup;
        }
    }
    
    //
    // Resolve the link.
    //
    hres = psl->Resolve(NULL,
                        SLR_NOTRACK | SLR_NOSEARCH | SLR_NO_UI | SLR_NOUPDATE);
    
    if (FAILED(hres)) {
        LogMsg(_T("[GetExeFromLnk] failed to resolve the link \"%s\"\n"),
               pszLnk);
        goto cleanup;
    }
    
    pszExe[0] = _T('\"');
    
    //
    // Get the path to the link target.
    //
    hres = psl->GetPath(pszExe + 1,
                        cbSize,
                        &wfd,
                        SLGP_UNCPRIORITY);
                  
    if (FAILED(hres)) {
        LogMsg(_T("[GetExeFromLnk] failed to get the path for link \"%s\"\n"),
               pszLnk);
        goto cleanup;
    }

    szArg[0] = 0;

    hres = psl->GetArguments(szArg, MAX_PATH);

    if (SUCCEEDED(hres) && szArg[0] != 0) {
        lstrcat(pszExe, _T("\" "));
        lstrcat(pszExe, szArg);
    } else {
        lstrcat(pszExe, _T("\""));
    }

    bSuccess = TRUE;

cleanup:
    
    if (pPf != NULL) {
        pPf->Release();
    }
    
    psl->Release();

    return bSuccess;
}


//////////////////////////////////////////////////////////////////////////
// CLayerUIPropPage

CLayerUIPropPage::CLayerUIPropPage()
{
    LogMsg(_T("[CLayerUIPropPage::CLayerUIPropPage]\n"));
}

CLayerUIPropPage::~CLayerUIPropPage()
{
    LogMsg(_T("[CLayerUIPropPage::~CLayerUIPropPage]\n"));
}


//////////////////////////////////////////////////////////////////////////
// IShellExtInit methods

STDMETHODIMP
CLayerUIPropPage::Initialize(
    LPCITEMIDLIST pIDFolder, 
    LPDATAOBJECT  pDataObj,
    HKEY          hKeyID
    )
{
    LogMsg(_T("[CLayerUIPropPage::Initialize]\n"));

    if (!g_bExtEnabled) {
        return NOERROR;
    }
    
    if (pDataObj == NULL) {
        LogMsg(_T("\t failed. bad argument.\n"));
        return E_INVALIDARG;
    }

    //
    // Store a pointer to the data object
    //
    m_spDataObj = pDataObj;

    //
    // If a data object pointer was passed in, save it and
    // extract the file name.
    //
    STGMEDIUM   medium;
    UINT        uCount;
    FORMATETC   fe = {CF_HDROP, NULL, DVASPECT_CONTENT, -1, 
                      TYMED_HGLOBAL};

    if (SUCCEEDED(m_spDataObj->GetData(&fe, &medium))) {
        
        //
        // Get the file name from the CF_HDROP.
        //
        uCount = DragQueryFile((HDROP)medium.hGlobal, (UINT)-1, 
                               NULL, 0);
        if (uCount > 0) {
            
            TCHAR szExe[MAX_PATH];
            
            DragQueryFile((HDROP)medium.hGlobal, 0, szExe, 
                          sizeof(szExe) / sizeof(TCHAR));
            
            LogMsg(_T("\tlink \"%s\".\n"), szExe);

            if (!GetExeFromLnk(szExe, m_szFile, MAX_PATH * sizeof(TCHAR))) {
                m_szFile[0] = 0;
            }
            
            LogMsg(_T("\tfile \"%s\".\n"), m_szFile);
        }

        ReleaseStgMedium(&medium);
    } else {
        LogMsg(_T("\t failed to get the data.\n"));
    }
    
    return NOERROR;
}

//////////////////////////////////////////////////////////////////////////
// IShellPropSheetExt methods


STDMETHODIMP
CLayerUIPropPage::AddPages(
    LPFNADDPROPSHEETPAGE lpfnAddPage,
    LPARAM               lParam
    )
{
    PROPSHEETPAGE  psp;
    HPROPSHEETPAGE hPage;

    LogMsg(_T("[CLayerUIPropPage::AddPages]\n"));
    
    if (!g_bExtEnabled || m_szFile[0] == 0) {
        return S_OK;
    }
    
    psp.dwSize        = sizeof(psp);
    psp.dwFlags       = PSP_USEREFPARENT | PSP_USETITLE | PSP_USECALLBACK;
    psp.hInstance     = _Module.m_hInst;
    psp.pszTemplate   = MAKEINTRESOURCE(IDD_LAYER_PROPPAGE);
    psp.hIcon         = 0;
    psp.pszTitle      = _T("Compatibility");
    psp.pfnDlgProc    = (DLGPROC)LayerPageDlgProc;
    psp.pcRefParent   = &g_DllRefCount;
    psp.pfnCallback   = LayerPageCallbackProc;
    psp.lParam        = (LPARAM)this;

    LogMsg(_T("\titem           \"%s\".\n"), m_szFile);
    LogMsg(_T("\tg_DllRefCount  %d.\n"), g_DllRefCount);
    
    AddRef();
    
    hPage = CreatePropertySheetPage(&psp);
            
    if (hPage != NULL) {
        
        if (lpfnAddPage(hPage, lParam)) {
            return S_OK;
        } else {
            DestroyPropertySheetPage(hPage);
            Release();
            return S_OK;
        }
    } else {
        return E_OUTOFMEMORY;
    }
    
    return E_FAIL;
}

STDMETHODIMP
CLayerUIPropPage::ReplacePage(
    UINT                 uPageID,
    LPFNADDPROPSHEETPAGE lpfnReplacePage,
    LPARAM               lParam
    )
{
    LogMsg(_T("[CLayerUIPropPage::ReplacePage]\n"));
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\appcompat\slayerui\win2k\slayerui.cpp ===
// SlayerUI.cpp : Implementation of DLL Exports.


// Note: Proxy/Stub Information
//      To build a separate proxy/stub DLL, 
//      run nmake -f SlayerUIps.mk in the project directory.

#include "stdafx.h"
#include "resource.h"
#include <initguid.h>
#include "SlayerUI.h"

#include <stdio.h>
#include <stdarg.h>

#include "SlayerUI_i.c"

#include "ShellExtensions.h"


// {513d916f-2a8e-4f51-aeab-0cbc76fb1af8}
static const CLSID CLSID_ShimLayerPropertyPage = 
  {	0x513d916f, 0x2a8e, 0x4f51, { 0xae, 0xab, 0x0c, 0xbc, 0x76, 0xfb, 0x1a, 0xf8 } };

CLayerUIModule _Module;

BEGIN_OBJECT_MAP(ObjectMap)
  OBJECT_ENTRY(CLSID_ShimLayerPropertyPage, CLayerUIPropPage)
END_OBJECT_MAP()

#if DBG

/////////////////////////////////////////////////////////////////////////////
// LogMsgDbg

void LogMsgDbg(
    LPTSTR pwszFmt,
    ... )
{
    WCHAR   gwszT[1024];
    va_list arglist;

    va_start(arglist, pwszFmt);
    _vsnwprintf(gwszT, 1023, pwszFmt, arglist);
    gwszT[1023] = 0;
    va_end(arglist);
    
    OutputDebugStringW(gwszT);
}

#endif // DBG

/////////////////////////////////////////////////////////////////////////////
// DLL Entry Point

extern "C"
BOOL WINAPI DllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID /*lpReserved*/)
{
    if (dwReason == DLL_PROCESS_ATTACH)
    {
        _Module.Init(ObjectMap, hInstance, &LIBID_SLAYERUILib);

        InitLayerStorage(FALSE);

        //
        // Check for the registry rights
        //
        CheckForRights();

        DisableThreadLibraryCalls(hInstance);
    }
    else if (dwReason == DLL_PROCESS_DETACH)
        _Module.Term();
    return TRUE;    // ok
}

/////////////////////////////////////////////////////////////////////////////
// Used to determine whether the DLL can be unloaded by OLE

STDAPI DllCanUnloadNow(void)
{
    return (_Module.GetLockCount()==0) ? S_OK : S_FALSE;
}

/////////////////////////////////////////////////////////////////////////////
// Returns a class factory to create an object of the requested type

STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv)
{
    return _Module.GetClassObject(rclsid, riid, ppv);
}

/////////////////////////////////////////////////////////////////////////////
// DllRegisterServer - Adds entries to the system registry

STDAPI DllRegisterServer(void)
{
    // registers object, typelib and all interfaces in typelib
    return _Module.RegisterServer(TRUE);
}

/////////////////////////////////////////////////////////////////////////////
// DllUnregisterServer - Removes entries from the system registry

STDAPI DllUnregisterServer(void)
{
    return _Module.UnregisterServer(TRUE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\appcompat\slayerui\win2k\stdafx.h ===
// stdafx.h : include file for standard system include files,
//      or project specific include files that are used frequently,
//      but are changed infrequently

#if !defined(AFX_STDAFX_H__88E11F15_58D2_477F_9D30_DBF092670E6A__INCLUDED_)
#define AFX_STDAFX_H__88E11F15_58D2_477F_9D30_DBF092670E6A__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#define STRICT
#ifndef _WIN32_WINNT
#define _WIN32_WINNT 0x0400
#endif
#define _ATL_APARTMENT_THREADED


#include <atlbase.h>

//You may derive a class from CComModule and use it if you want to override
//something, but do not change the name of _Module

#if ( _ATL_VER >= 0x0300 )
#define _ATL_NO_UUIDOF 
#endif


using namespace ATL;

class CLayerUIModule : public CComModule
{
public:
	HRESULT WINAPI UpdateRegistryCLSID(const CLSID& clsid, BOOL bRegister);
};

#define DECLARE_REGISTRY_CLSID()                                        \
static HRESULT WINAPI UpdateRegistry(BOOL bRegister)                    \
{                                                                       \
    return _Module.UpdateRegistryCLSID(GetObjectCLSID(), bRegister);    \
}

extern CLayerUIModule _Module;

#include <atlcom.h>

#include <shellapi.h>
#include <shlobj.h>

extern const CLSID CLSID_ShimLayerPropertyPage;

#if DBG

    void LogMsgDbg(LPTSTR pszFmt, ...);
    
    #define LogMsg  LogMsgDbg
#else

    #define LogMsg

#endif // DBG


//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__88E11F15_58D2_477F_9D30_DBF092670E6A__INCLUDED)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\appcompat\tools\acbrowser\acbrowser.h ===
#ifndef _ACBROWSERWHISTLER_H
#define _ACBROWSERWHISTLER_H

#include <windows.h>

typedef enum {
    FIX_SHIM,
    FIX_PATCH,
    FIX_LAYER,
    FIX_FLAG
} FIXTYPE;

typedef enum {
    FLAG_USER,
    FLAG_KERNEL
} FLAGTYPE;

typedef struct tagFIX {
    
    struct tagFIX* pNext;
    
    char*       pszName;
    char*       pszDescription;
    ULONGLONG   ullMask;            // only for FIX_FLAG
    FLAGTYPE    flagType;           // only for FIX_FLAG
    FIXTYPE     fixType;
} FIX, *PFIX;

typedef struct tagFIXLIST {

    struct tagFIXLIST* pNext;

    PFIX pFix;

} FIXLIST, *PFIXLIST;


typedef enum {
    APPTYPE_NONE,
    APPTYPE_INC_NOBLOCK,
    APPTYPE_INC_HARDBLOCK,
    APPTYPE_MINORPROBLEM,
    APPTYPE_REINSTALL,
    APPTYPE_VERSIONSUB,
    APPTYPE_SHIM
} SEVERITY;

typedef struct tagAPPHELP {
    BOOL        bPresent;
    SEVERITY    severity;
    DWORD       htmlHelpId;
} APPHELP, *PAPPHELP;

typedef struct tagATTRIBUTE {
    struct tagATTRIBUTE* pNext;

    char*   pszText;

} ATTRIBUTE, *PATTRIBUTE;

typedef struct tagMATCHINGFILE {

    struct tagMATCHINGFILE* pNext;
    
    char*       pszName;
    PATTRIBUTE  pFirstAttribute;

} MATCHINGFILE, *PMATCHINGFILE;

typedef struct tagDBENTRY {
    
    struct tagDBENTRY* pNext;
    
    char*           pszExeName;
    char*           pszAppName;
    char            szGUID[48];
    
    PFIXLIST        pFirstShim;
    PFIXLIST        pFirstPatch;
    PFIXLIST        pFirstLayer;
    PFIXLIST        pFirstFlag;
    
    APPHELP         appHelp;
    
    PMATCHINGFILE   pFirstMatchingFile;
    int             nMatchingFiles;

    BOOL            bDisablePerUser;
    BOOL            bDisablePerMachine;

} DBENTRY, *PDBENTRY;


void LogMsg(LPSTR pszFmt, ... );
BOOL CenterWindow(HWND hWnd);

PDBENTRY
GetDatabaseEntries(
    void
    );

void
UpdateFixStatus(
    char* pszGUID,
    BOOL  bPerUser,
    BOOL  bPerMachine
    );

#endif // _ACBROWSERWHISTLER_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\appcompat\tools\acbrowser\acbrowser.c ===
#include "acBrowser.h"
#include "resource.h"

#include <commctrl.h>
#include <commdlg.h>
#include <stdlib.h>
#include <stdio.h>
#include <stdarg.h>

extern PDBENTRY g_pEntries;

#define SHOW_W_SHIMS        0x00000001
#define SHOW_W_FLAGS        0x00000002
#define SHOW_W_LAYERS       0x00000004
#define SHOW_W_PATCHES      0x00000008
#define SHOW_W_APPHELP      0x00000010

#define SHOW_WO_SHIMS       0x00000100
#define SHOW_WO_FLAGS       0x00000200
#define SHOW_WO_LAYERS      0x00000400
#define SHOW_WO_PATCHES     0x00000800
#define SHOW_WO_APPHELP     0x00001000

//
// These flags cannot occur simultaneously.
//
#define SHOW_MORETHAN5      0x00010000
#define SHOW_NOMATCHING     0x00020000

#define SHOW_DISABLED_ONLY  0x80000000

#define ID_SHOW_CONTENT     1234

//
// Global Variables
//

HINSTANCE g_hInstance;
HWND      g_hDlg;

HWND      g_hwndList;

HWND      g_hwndEntryTree;

int       g_nItems;

BOOL      g_bSortAppAsc;
BOOL      g_bSortExeAsc;

PDBENTRY  g_pSelEntry;

char      g_szBinary[MAX_PATH];

DWORD     g_dwCrtShowFlags = 0xFFFFFFFF;

#define COLUMN_APP      0
#define COLUMN_EXE      1

char* g_szSeverity[] = { "NONE",
                         "NOBLOCK",
                         "HARDBLOCK",
                         "MINORPROBLEM",
                         "REINSTALL",
                         "VERSIONSUB",
                         "SHIM"};

#define IDQ_ALL             0
#define IDQ_MORETHAN5       1
#define IDQ_NOMATCHING      2
                         
char* g_aszQueries[] = { "All entries",
                         "Entries with more than 5 extra matching files",
                         "Entries with no extra matching files",
                         ""
};


void
LogMsg(
    LPSTR pszFmt,
    ... )
{
    CHAR gszT[1024];
    va_list arglist;

    va_start(arglist, pszFmt);
    _vsnprintf(gszT, 1023, pszFmt, arglist);
    gszT[1023] = 0;
    va_end(arglist);
    
    OutputDebugString(gszT);
}

/*******************************************************************************
* CenterWindow
*
*  This function must be called at the WM_INIDIALOG in order to
*  move the dialog window centered in the client area of the
*  parent or owner window.
*******************************************************************************/
BOOL CenterWindow(
    HWND hWnd)
{
    RECT    rectWindow, rectParent, rectScreen;
    int     nCX, nCY;
    HWND    hParent;
    POINT   ptPoint;

    hParent =  GetParent(hWnd);
    if (hParent == NULL)
        hParent = GetDesktopWindow();

    GetWindowRect(hParent,            (LPRECT)&rectParent);
    GetWindowRect(hWnd,               (LPRECT)&rectWindow);
    GetWindowRect(GetDesktopWindow(), (LPRECT)&rectScreen);

    nCX = rectWindow.right  - rectWindow.left;
    nCY = rectWindow.bottom - rectWindow.top;

    ptPoint.x = ((rectParent.right  + rectParent.left) / 2) - (nCX / 2);
    ptPoint.y = ((rectParent.bottom + rectParent.top ) / 2) - (nCY / 2);

    if (ptPoint.x < rectScreen.left)
        ptPoint.x = rectScreen.left;
    if (ptPoint.x > rectScreen.right  - nCX)
        ptPoint.x = rectScreen.right  - nCX;
    if (ptPoint.y < rectScreen.top)
        ptPoint.y = rectScreen.top;
    if (ptPoint.y > rectScreen.bottom - nCY)
        ptPoint.y = rectScreen.bottom - nCY;

    if (GetWindowLong(hWnd, GWL_STYLE) & WS_CHILD)
        ScreenToClient(hParent, (LPPOINT)&ptPoint);

    if (!MoveWindow(hWnd, ptPoint.x, ptPoint.y, nCX, nCY, TRUE))
        return FALSE;

    return TRUE;
}

void
AddEntryToList(
    PDBENTRY pEntry
    )
{
    LVITEM lvi; 
    
    lvi.mask      = LVIF_TEXT | LVIF_PARAM;
    lvi.pszText   = pEntry->pszAppName;
    lvi.iItem     = g_nItems;
    lvi.iSubItem  = COLUMN_APP;
    lvi.lParam    = (LPARAM)pEntry;

    ListView_InsertItem(g_hwndList, &lvi);
    ListView_SetItemText(g_hwndList, g_nItems, COLUMN_EXE, pEntry->pszExeName);
    
    g_nItems++;
}

void
InsertColumnIntoListView(
    LPSTR    lpszColumn,
    DWORD    dwSubItem,
    DWORD    widthPercent
    )
{
    LVCOLUMN  lvc;
    RECT      rcClient;
    DWORD     width;

    GetWindowRect(g_hwndList, &rcClient);
    
    width = rcClient.right - rcClient.left -
                4 * GetSystemMetrics(SM_CXBORDER) -
                GetSystemMetrics(SM_CXVSCROLL);
    
    width = width * widthPercent / 100;
    
    lvc.mask     = LVCF_FMT | LVCF_TEXT | LVCF_SUBITEM | LVCF_WIDTH;
    lvc.fmt      = LVCFMT_LEFT;
    lvc.iSubItem = dwSubItem;
    lvc.cx       = width;
    lvc.pszText  = lpszColumn;
    
    ListView_InsertColumn(g_hwndList, dwSubItem, &lvc);
}

void
UpdateEntryTreeView(
    PDBENTRY pEntry
    )
{
    HTREEITEM       hItemExe;
    HTREEITEM       hMatchItem;
    HTREEITEM       hItemMatchingFiles;
    PMATCHINGFILE   pMatch;
    PFIXLIST        pFixList;
    TV_INSERTSTRUCT is;
    char            szText[256];
    
    TreeView_DeleteAllItems(g_hwndEntryTree);

    wsprintf(szText, "%s - %s", pEntry->pszExeName, pEntry->szGUID);
    
    is.hParent      = TVI_ROOT;
    is.hInsertAfter = TVI_LAST;
    is.item.mask    = TVIF_TEXT | TVIF_PARAM;
    is.item.lParam  = 0;
    is.item.pszText = szText;
    
    hItemExe = TreeView_InsertItem(g_hwndEntryTree, &is);
    
    if (pEntry->appHelp.bPresent) {
        
        wsprintf(szText, "AppHelp - %s",
                 g_szSeverity[pEntry->appHelp.severity]);
        
        is.hParent      = hItemExe;
        is.item.pszText = szText;

        TreeView_InsertItem(g_hwndEntryTree, &is);
    }
    
    if (pEntry->pFirstShim) {
        
        HTREEITEM hItemShims;
        
        is.hParent      = hItemExe;
        is.hInsertAfter = TVI_SORT;
        is.item.lParam  = 0;
        is.item.pszText = "Compatibility Fixes";

        hItemShims = TreeView_InsertItem(g_hwndEntryTree, &is);
        
        is.hParent = hItemShims;
        
        pFixList = pEntry->pFirstShim;

        while (pFixList) {
            is.item.lParam  = (LPARAM)pFixList->pFix->pszDescription;
            is.item.pszText = pFixList->pFix->pszName;
            
            TreeView_InsertItem(g_hwndEntryTree, &is);

            pFixList = pFixList->pNext;
        }
        
        TreeView_Expand(g_hwndEntryTree, hItemShims, TVE_EXPAND);
    }
    
    if (pEntry->pFirstPatch) {
        
        HTREEITEM hItemPatches;
        
        is.hParent      = hItemExe;
        is.hInsertAfter = TVI_SORT;
        is.item.lParam  = 0;
        is.item.pszText = "Compatibility Patches";

        hItemPatches = TreeView_InsertItem(g_hwndEntryTree, &is);
        
        is.hParent = hItemPatches;
        
        pFixList = pEntry->pFirstPatch;

        while (pFixList) {
            is.item.lParam  = (LPARAM)pFixList->pFix->pszDescription;
            is.item.pszText = pFixList->pFix->pszName;
            
            TreeView_InsertItem(g_hwndEntryTree, &is);

            pFixList = pFixList->pNext;
        }
        
        TreeView_Expand(g_hwndEntryTree, hItemPatches, TVE_EXPAND);
    }
    
    if (pEntry->pFirstFlag) {
        
        HTREEITEM hItemFlags;
        
        is.hParent      = hItemExe;
        is.hInsertAfter = TVI_SORT;
        is.item.lParam  = 0;
        is.item.pszText = "Compatibility Flags";

        hItemFlags = TreeView_InsertItem(g_hwndEntryTree, &is);
        
        is.hParent = hItemFlags;
        
        pFixList = pEntry->pFirstFlag;

        while (pFixList) {
            is.item.lParam  = (LPARAM)pFixList->pFix->pszDescription;
            is.item.pszText = pFixList->pFix->pszName;
            
            TreeView_InsertItem(g_hwndEntryTree, &is);

            pFixList = pFixList->pNext;
        }
        
        TreeView_Expand(g_hwndEntryTree, hItemFlags, TVE_EXPAND);
    }
    
    if (pEntry->pFirstLayer) {
        
        HTREEITEM hItemLayers;
        
        is.hParent      = hItemExe;
        is.hInsertAfter = TVI_SORT;
        is.item.lParam  = 0;
        is.item.pszText = "Compatibility Layers";

        hItemLayers = TreeView_InsertItem(g_hwndEntryTree, &is);
        
        is.hParent = hItemLayers;
        
        pFixList = pEntry->pFirstLayer;

        while (pFixList) {
            is.item.lParam  = (LPARAM)pFixList->pFix->pszDescription;
            is.item.pszText = pFixList->pFix->pszName;
            
            TreeView_InsertItem(g_hwndEntryTree, &is);

            pFixList = pFixList->pNext;
        }
        
        TreeView_Expand(g_hwndEntryTree, hItemLayers, TVE_EXPAND);
    }

    pMatch = pEntry->pFirstMatchingFile;

    is.hParent      = hItemExe;
    is.item.lParam  = 0;
    is.item.pszText = "Matching Files";

    hItemMatchingFiles = TreeView_InsertItem(g_hwndEntryTree, &is);
    
    while (pMatch) {
        
        PATTRIBUTE pAttr;
        
        is.hInsertAfter = TVI_SORT;
        is.hParent = hItemMatchingFiles;
        is.item.pszText = pMatch->pszName;

        hMatchItem = TreeView_InsertItem(g_hwndEntryTree, &is);

        pAttr = pMatch->pFirstAttribute;

        while (pAttr) {
            is.hParent      = hMatchItem;
            is.hInsertAfter = TVI_SORT;
            is.item.pszText = pAttr->pszText;

            TreeView_InsertItem(g_hwndEntryTree, &is);
            
            pAttr = pAttr->pNext;
        }

        pMatch = pMatch->pNext;
    }

    TreeView_Expand(g_hwndEntryTree, hItemMatchingFiles, TVE_EXPAND);

    TreeView_Expand(g_hwndEntryTree, hItemExe, TVE_EXPAND);
}

void
AppSelectedChanged(
    HWND   hdlg,
    int    nSel
    )
{
    LVITEM         lvi;
    PDBENTRY       pEntry;

    if (nSel == -1)
        return;

    lvi.iItem = nSel;
    lvi.iSubItem = 0;
    lvi.mask = LVIF_PARAM;

    ListView_GetItem(g_hwndList, &lvi);

    pEntry = (PDBENTRY)lvi.lParam;

    g_pSelEntry = pEntry;

    //
    // Update the entry tree view
    //
    UpdateEntryTreeView(pEntry);
    
    SendDlgItemMessage(hdlg, IDC_PER_USER, BM_SETCHECK,
                       (pEntry->bDisablePerUser ? BST_CHECKED : BST_UNCHECKED), 0);

    SendDlgItemMessage(hdlg, IDC_PER_MACHINE, BM_SETCHECK,
                       (pEntry->bDisablePerMachine ? BST_CHECKED : BST_UNCHECKED), 0);
}


int CALLBACK
CompareItems(
    LPARAM lParam1,
    LPARAM lParam2, 
    LPARAM column)
{
    PDBENTRY pItem1 = (PDBENTRY)lParam1;
    PDBENTRY pItem2 = (PDBENTRY)lParam2;
    int      nVal = 0;

    if (column == COLUMN_APP) {
        if (g_bSortAppAsc) {
            nVal = lstrcmpi(pItem1->pszAppName, pItem2->pszAppName);
        } else {
            nVal = lstrcmpi(pItem2->pszAppName, pItem1->pszAppName);
        }
    }

    if (column == COLUMN_EXE) {
        if (g_bSortExeAsc) {
            nVal = lstrcmpi(pItem1->pszExeName, pItem2->pszExeName);
        } else {
            nVal = lstrcmpi(pItem2->pszExeName, pItem1->pszExeName);
        }
    }
    return nVal;
}
 
void
ShowFixes(
    HWND  hdlg,
    DWORD dwShowFlags
    )
{
    PDBENTRY pEntry;
    char     szEntries[128];
    BOOL     bDontShow;
    
    if (dwShowFlags == g_dwCrtShowFlags) {
        return;
    }
    
    g_nItems = 0;

    SendMessage(g_hwndList, WM_SETREDRAW, FALSE, 0);
    
    ListView_DeleteAllItems(g_hwndList);
    
    pEntry = g_pEntries;

    while (pEntry != NULL) {
        
        bDontShow = (pEntry->pFirstShim == NULL && (dwShowFlags & SHOW_W_SHIMS) ||
                     pEntry->appHelp.bPresent == FALSE && (dwShowFlags & SHOW_W_APPHELP) ||
                     pEntry->pFirstFlag == NULL && (dwShowFlags & SHOW_W_FLAGS) ||
                     pEntry->pFirstPatch == NULL && (dwShowFlags & SHOW_W_PATCHES) ||
                     pEntry->pFirstLayer == NULL && (dwShowFlags & SHOW_W_LAYERS));

        bDontShow = bDontShow ||
                    (pEntry->pFirstShim && (dwShowFlags & SHOW_WO_SHIMS) ||
                     pEntry->appHelp.bPresent && (dwShowFlags & SHOW_WO_APPHELP) ||
                     pEntry->pFirstFlag && (dwShowFlags & SHOW_WO_FLAGS) ||
                     pEntry->pFirstPatch && (dwShowFlags & SHOW_WO_PATCHES) ||
                     pEntry->pFirstLayer && (dwShowFlags & SHOW_WO_LAYERS));
        
        if ((dwShowFlags & SHOW_DISABLED_ONLY) &&
            !pEntry->bDisablePerMachine &&
            !pEntry->bDisablePerUser) {

            bDontShow = TRUE;
        }

        if (dwShowFlags & SHOW_MORETHAN5) {
            if (pEntry->nMatchingFiles < 6) {
                bDontShow = TRUE;
            }
        }
        
        if (dwShowFlags & SHOW_NOMATCHING) {
            if (pEntry->nMatchingFiles > 1) {
                bDontShow = TRUE;
            }
        }
        
        if (!bDontShow) {
            AddEntryToList(pEntry);
        }

        pEntry = pEntry->pNext;
    }
    
    ListView_SortItems(g_hwndList, CompareItems, COLUMN_APP);
    
    wsprintf(szEntries, "%d entries. Use the headers to sort them.", g_nItems);
    
    SetDlgItemText(hdlg, IDC_ALL_ENTRIES, szEntries);
    
    SendMessage(g_hwndList, WM_SETREDRAW, TRUE, 0);

    g_dwCrtShowFlags = dwShowFlags;
}

void
DoInitDialog(
    HWND hdlg
    )
{
    HICON hIcon;
    int   i;
    
    g_hDlg = hdlg;

    CenterWindow(hdlg);

    g_hwndList = GetDlgItem(hdlg, IDC_LIST);
    
    ListView_SetExtendedListViewStyle(g_hwndList, 0x20);

    g_hwndEntryTree = GetDlgItem(hdlg, IDC_ENTRY);
    
    g_nItems = 0;

    InsertColumnIntoListView("Application", COLUMN_APP, 60);
    InsertColumnIntoListView("Main Binary", COLUMN_EXE, 40);
    
    g_bSortAppAsc = TRUE;
    g_bSortExeAsc = FALSE;

    //
    // Show the app icon.
    //
    hIcon = LoadIcon(g_hInstance, MAKEINTRESOURCE(IDI_APPICON));

    SetClassLongPtr(hdlg, GCLP_HICON, (LONG_PTR)hIcon);
    
    SendDlgItemMessage(hdlg, IDC_DC_APPHELP, BM_SETCHECK, BST_CHECKED, 0);
    SendDlgItemMessage(hdlg, IDC_DC_SHIMS, BM_SETCHECK, BST_CHECKED, 0);
    SendDlgItemMessage(hdlg, IDC_DC_FLAGS, BM_SETCHECK, BST_CHECKED, 0);
    SendDlgItemMessage(hdlg, IDC_DC_PATCHES, BM_SETCHECK, BST_CHECKED, 0);
    SendDlgItemMessage(hdlg, IDC_DC_LAYERS, BM_SETCHECK, BST_CHECKED, 0);

    //
    // Populate the statistics queries
    //
    for (i = 0; *g_aszQueries[i] != 0; i++) {
        SendDlgItemMessage(hdlg, IDC_STATISTICS, CB_ADDSTRING, 0, (LPARAM)g_aszQueries[i]);
    }
    
    SetCursor(NULL);
    
    SetTimer(hdlg, ID_SHOW_CONTENT, 100, NULL);
}

void
FilterAndShow(
    HWND hdlg
    )
{
    DWORD dwShowFlags = 0;

    if (SendDlgItemMessage(hdlg, IDC_W_APPHELP, BM_GETCHECK, 0, 0) == BST_CHECKED) {
        dwShowFlags |= SHOW_W_APPHELP;
    } else if (SendDlgItemMessage(hdlg, IDC_WO_APPHELP, BM_GETCHECK, 0, 0) == BST_CHECKED) {
        dwShowFlags |= SHOW_WO_APPHELP;
    }

    if (SendDlgItemMessage(hdlg, IDC_W_SHIMS, BM_GETCHECK, 0, 0) == BST_CHECKED) {
        dwShowFlags |= SHOW_W_SHIMS;
    } else if (SendDlgItemMessage(hdlg, IDC_WO_SHIMS, BM_GETCHECK, 0, 0) == BST_CHECKED) {
        dwShowFlags |= SHOW_WO_SHIMS;
    }

    if (SendDlgItemMessage(hdlg, IDC_W_PATCHES, BM_GETCHECK, 0, 0) == BST_CHECKED) {
        dwShowFlags |= SHOW_W_PATCHES;
    } else if (SendDlgItemMessage(hdlg, IDC_WO_PATCHES, BM_GETCHECK, 0, 0) == BST_CHECKED) {
        dwShowFlags |= SHOW_WO_PATCHES;
    }

    if (SendDlgItemMessage(hdlg, IDC_W_FLAGS, BM_GETCHECK, 0, 0) == BST_CHECKED) {
        dwShowFlags |= SHOW_W_FLAGS;
    } else if (SendDlgItemMessage(hdlg, IDC_WO_FLAGS, BM_GETCHECK, 0, 0) == BST_CHECKED) {
        dwShowFlags |= SHOW_WO_FLAGS;
    }

    if (SendDlgItemMessage(hdlg, IDC_W_LAYERS, BM_GETCHECK, 0, 0) == BST_CHECKED) {
        dwShowFlags |= SHOW_W_LAYERS;
    } else if (SendDlgItemMessage(hdlg, IDC_WO_LAYERS, BM_GETCHECK, 0, 0) == BST_CHECKED) {
        dwShowFlags |= SHOW_WO_LAYERS;
    }

    if (SendDlgItemMessage(hdlg, IDC_DISABLED_ONLY, BM_GETCHECK, 0, 0) == BST_CHECKED) {
        dwShowFlags |= SHOW_DISABLED_ONLY;
    }

    SendDlgItemMessage(hdlg, IDC_PER_USER, BM_SETCHECK, BST_UNCHECKED, 0);
    SendDlgItemMessage(hdlg, IDC_PER_MACHINE, BM_SETCHECK, BST_UNCHECKED, 0);
    
    ShowFixes(hdlg, dwShowFlags);
    
    TreeView_DeleteAllItems(g_hwndEntryTree);
}

void
OnSubmitChanges(
    HWND hdlg
    )
{
    BOOL bPerUser, bPerMachine;
    
    if (g_pSelEntry == NULL) {
        return;
    }

    bPerUser = (SendDlgItemMessage(hdlg, IDC_PER_USER, BM_GETCHECK, 0, 0) == BST_CHECKED);
    bPerMachine = (SendDlgItemMessage(hdlg, IDC_PER_MACHINE, BM_GETCHECK, 0, 0) == BST_CHECKED);

    UpdateFixStatus(g_pSelEntry->szGUID, bPerUser, bPerMachine);

    g_pSelEntry->bDisablePerUser = bPerUser;
    g_pSelEntry->bDisablePerMachine = bPerMachine;
}

INT_PTR CALLBACK
BrowseAppCompatDlgProc(
    HWND   hdlg,
    UINT   uMsg,
    WPARAM wParam,
    LPARAM lParam
    )
{
    int wCode = LOWORD(wParam);
    int wNotifyCode = HIWORD(wParam);

    switch (uMsg) {
    case WM_INITDIALOG:
        DoInitDialog(hdlg);
        break;

    case WM_TIMER:
        if (wParam == ID_SHOW_CONTENT) {
            KillTimer(hdlg, ID_SHOW_CONTENT);
            
            //
            // Read the database
            //
            GetDatabaseEntries();

            ShowFixes(hdlg, 0);
            
            SetCursor(LoadCursor(NULL, MAKEINTRESOURCE(IDC_ARROW)));
        }
        break;

    case WM_NOTIFY:
        if (wParam == IDC_LIST) {
            LPNMHDR pnm = (LPNMHDR)lParam;

            switch (pnm->code) {
            
            case LVN_COLUMNCLICK:
            {
                LPNMLISTVIEW pnmlv = (LPNMLISTVIEW)lParam;

                if (pnmlv->iSubItem == COLUMN_APP) {
                    g_bSortAppAsc = !g_bSortAppAsc;
                }

                if (pnmlv->iSubItem == COLUMN_EXE) {
                    g_bSortExeAsc = !g_bSortExeAsc;
                }
                
                ListView_SortItems(g_hwndList, CompareItems, pnmlv->iSubItem);
                
                break;
            }
            
            case LVN_ITEMCHANGED:
            {
                int nSel = ListView_GetSelectionMark(g_hwndList);
                
                AppSelectedChanged(hdlg, nSel);
                break;
            }

            case NM_CLICK:
            {    
                LVHITTESTINFO ht;
                int           nSel;

                GetCursorPos(&ht.pt);
                ScreenToClient(g_hwndList, &ht.pt);

                nSel = ListView_SubItemHitTest(g_hwndList, &ht);
            
                if (nSel != -1) {
                    ListView_SetItemState(g_hwndList,
                                          nSel,
                                          LVIS_SELECTED | LVIS_FOCUSED,
                                          LVIS_SELECTED | LVIS_FOCUSED);
                }
                
                AppSelectedChanged(hdlg, nSel);
                break;
            }
            default:
                break;
            }
        } else if (wParam == IDC_ENTRY) {
            LPNMHDR pnm = (LPNMHDR)lParam;

            switch (pnm->code) {
            
            case TVN_GETINFOTIP:
            {
                LPNMTVGETINFOTIP lpGetInfoTip = (LPNMTVGETINFOTIP)lParam;

                if (lpGetInfoTip->lParam != 0) {
                    lstrcpy(lpGetInfoTip->pszText, (char*)lpGetInfoTip->lParam);
                }

                break;
            }
            }
        }
        
        break;

    case WM_COMMAND:
        
        if (wNotifyCode == CBN_SELCHANGE) {
            
            int nSel;

            nSel = (int)SendDlgItemMessage(hdlg, IDC_STATISTICS, CB_GETCURSEL, 0, 0);

            switch (nSel) {
            case IDQ_ALL:
                ShowFixes(hdlg, (g_dwCrtShowFlags & ~(SHOW_MORETHAN5 | SHOW_NOMATCHING)));
                break;
            
            case IDQ_MORETHAN5:
                ShowFixes(hdlg, ((g_dwCrtShowFlags | SHOW_MORETHAN5) & ~SHOW_NOMATCHING));
                break;
            
            case IDQ_NOMATCHING:
                ShowFixes(hdlg, ((g_dwCrtShowFlags | SHOW_NOMATCHING) & ~SHOW_MORETHAN5));
                break;
            }
        }
        
        switch (wCode) {
        
        case IDC_PER_USER:
        case IDC_PER_MACHINE:
            OnSubmitChanges(hdlg);
            break;
        
        case IDC_W_APPHELP:
        case IDC_W_SHIMS:
        case IDC_W_FLAGS:
        case IDC_W_LAYERS:
        case IDC_W_PATCHES:
        case IDC_WO_APPHELP:
        case IDC_WO_SHIMS:
        case IDC_WO_FLAGS:
        case IDC_WO_LAYERS:
        case IDC_WO_PATCHES:
        case IDC_DC_APPHELP:
        case IDC_DC_SHIMS:
        case IDC_DC_FLAGS:
        case IDC_DC_LAYERS:
        case IDC_DC_PATCHES:
        
        case IDC_DISABLED_ONLY:
            FilterAndShow(hdlg);
            break;
        
        case IDCANCEL:
            EndDialog(hdlg, TRUE);
            break;

        default:
            return FALSE;
        }
        break;

    default:
        return FALSE;
    }

    return TRUE;
}

int APIENTRY WinMain(HINSTANCE hInstance,
                     HINSTANCE hPrevInstance,
                     LPSTR     lpCmdLine,
                     int       nCmdShow)
{
    InitCommonControls();

    g_hInstance = hInstance;

    DialogBox(hInstance,
              MAKEINTRESOURCE(IDD_DIALOG),
              GetDesktopWindow(),
              (DLGPROC)BrowseAppCompatDlgProc);

    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\appcompat\tools\acbrowser\dbsupport.c ===
#include "acBrowser.h"
#include <wchar.h>

#include <commctrl.h>
#include <psapi.h>

#include "shimdb.h"


#define SHIM_LOG_FILE       "shimlog.txt"

#define Alloc(cb)       \
            HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, cb)

#define Free(p)         \
            HeapFree(GetProcessHeap(), 0, p)

PDBENTRY g_pEntries;
PFIX     g_pFixes;


#define MAX_DATA_SIZE       1024
#define MAX_NAME            256
#define MAX_DESCRIPTION     1024

WCHAR g_wszData[MAX_DATA_SIZE];

char g_szName[MAX_NAME];
char g_szDescription[MAX_DESCRIPTION];


#define APPCOMPAT_DISABLED  0x03

//
// REGISTRY STUFF. Needs to be revised
//

#define APPCOMPAT_KEY "Software\\Microsoft\\Windows NT\\CurrentVersion\\AppCompatFlags"

BOOL
CheckRegistry(
    HKEY  hkeyRoot,
    char* pszGUID
    )
{
    LONG  status;
    HKEY  hkey = NULL;
    BOOL  bDisabled = FALSE;
    DWORD dwFlags;
    DWORD type;
    DWORD cbSize = sizeof(DWORD);

    status = RegOpenKey(hkeyRoot, APPCOMPAT_KEY, &hkey);

    if (status != ERROR_SUCCESS) {
        return FALSE;
    }

    status = RegQueryValueEx(hkey, pszGUID, NULL, &type, (LPBYTE)&dwFlags, &cbSize);

    if (status == ERROR_SUCCESS && type == REG_DWORD && (dwFlags & APPCOMPAT_DISABLED)) {
        bDisabled = TRUE;
    }

    RegCloseKey(hkey);

    return bDisabled;
}

BOOL
WriteRegistry(
    HKEY  hkeyRoot,
    char* pszKeyName
    )
{
    LONG  status;
    HKEY  hkey;
    DWORD dwValue = 0x03;
    DWORD dwDisposition = 0;
    BOOL  bDisabled = FALSE;

    status = RegCreateKeyEx(hkeyRoot,
                            APPCOMPAT_KEY,
                            0,
                            NULL,
                            REG_OPTION_NON_VOLATILE,
                            KEY_ALL_ACCESS,
                            NULL,
                            &hkey,
                            &dwDisposition);

    if (status != ERROR_SUCCESS) {
        LogMsg("Failed to set the value for \"%s\"\n", pszKeyName);
        return FALSE;
    }

    status = RegSetValueEx(hkey, pszKeyName, 0, REG_DWORD, (LPBYTE)&dwValue, sizeof(DWORD));

    RegCloseKey(hkey);

    if (status != ERROR_SUCCESS) {
        LogMsg("Failed to set the value for \"%s\"\n", pszKeyName);
        return FALSE;
    }

    return TRUE;
}

BOOL
DeleteRegistry(
    HKEY  hkeyRoot,
    char* pszKeyName
    )
{
    LONG  status;
    HKEY  hkey = NULL;
    DWORD dwValue = 0;
    DWORD dwDisposition = 0;
    BOOL  bDisabled = FALSE;

    status = RegOpenKey(hkeyRoot, APPCOMPAT_KEY, &hkey);

    if (status != ERROR_SUCCESS) {
        return TRUE;
    }

    status = RegDeleteValue(hkey, pszKeyName);

    RegCloseKey(hkey);

    return TRUE;
}

typedef void (*PFNFLUSHCACHE)(HWND, HINSTANCE, LPSTR, int);

void
FlushTheCache(
    void
    )
{
    HINSTANCE     hmod;
    PFNFLUSHCACHE pfnFlushCache;
    char          szPath[MAX_PATH];

    GetSystemDirectory(szPath, MAX_PATH);

    lstrcat(szPath, "\\apphelp.dll");

    hmod = LoadLibrary(szPath);

    if (hmod != NULL) {
        pfnFlushCache = (PFNFLUSHCACHE)GetProcAddress(hmod, "ShimFlushCache");

        if (pfnFlushCache != NULL) {
            (*pfnFlushCache)(0, 0, NULL, 0);
        }
    }
}

void
UpdateFixStatus(
    char* pszGUID,
    BOOL  bPerUser,
    BOOL  bPerMachine
    )
{
    if (bPerUser) {
        WriteRegistry(HKEY_CURRENT_USER, pszGUID);
    } else {
        DeleteRegistry(HKEY_CURRENT_USER, pszGUID);
    }

    if (bPerMachine) {
        WriteRegistry(HKEY_LOCAL_MACHINE, pszGUID);
    } else {
        DeleteRegistry(HKEY_LOCAL_MACHINE, pszGUID);
    }

    FlushTheCache();
}


PFIX
AllocFix(
    char*   pszFixName,
    char*   pszFixDescription,
    FIXTYPE type
    )
{
    PFIX   pFix;
    char*  pszAlloc;

    pFix = (PFIX)Alloc(sizeof(FIX));
    
    if (pFix == NULL) {
        LogMsg("Cannot allocate %d bytes\n", sizeof(FIX));
        return NULL;
    }

    if (pszFixName == NULL || *pszFixName == 0) {
        pFix->pszName = NULL;
    } else {
        pszAlloc = (char*)Alloc(lstrlen(pszFixName) + 1);
        pFix->pszName = pszAlloc;
        if (pszAlloc != NULL) {
            lstrcpy(pszAlloc, pszFixName);
        } else {
            LogMsg("Cannot allocate %d bytes\n", lstrlen(pszFixName) + 1);
            goto Error;
        }
    }

    if (pszFixDescription == NULL || *pszFixDescription == 0) {
        pFix->pszDescription = NULL;
    } else {
        pszAlloc = (char*)Alloc(lstrlen(pszFixDescription) + 1);
        pFix->pszDescription = pszAlloc;
        if (pszAlloc != NULL) {
            lstrcpy(pszAlloc, pszFixDescription);
        } else {
            LogMsg("Cannot allocate %d bytes\n", lstrlen(pszFixDescription) + 1);
            goto Error;
        }
    }
    
    pFix->fixType = type;
    pFix->pNext   = NULL;

    return pFix;

Error:
    if (pFix->pszName != NULL) {
        Free(pFix->pszName);
    }
    
    if (pFix->pszDescription != NULL) {
        Free(pFix->pszDescription);
    }
    
    Free(pFix);

    return NULL;
}


void
ReadFix(
    PDB     pdb,
    TAGID   tiFix,
    FIXTYPE type
    )
{
    TAGID     tiInfo;
    TAG       tWhich;
    PFIX      pFix;
    ULONGLONG ullUser = 0;
    ULONGLONG ullKernel = 0;

    tiInfo = SdbGetFirstChild(pdb, tiFix);

    g_szName[0] = 0;
    g_szDescription[0] = 0;

    while (tiInfo != 0) {
        tWhich = SdbGetTagFromTagID(pdb, tiInfo);

        switch (tWhich) {

        case TAG_NAME:
            if (SdbReadStringTag(pdb, tiInfo, g_wszData, MAX_NAME * sizeof(WCHAR))) {
                wsprintf(g_szName, "%ws", g_wszData);
            }
            break;

        case TAG_DESCRIPTION:
            if (SdbReadStringTag(pdb, tiInfo, g_wszData, MAX_DESCRIPTION * sizeof(WCHAR))) {
                wsprintf(g_szDescription, "%ws", g_wszData);
            }
            break;

        case TAG_FLAG_MASK_USER:
            ullUser = SdbReadQWORDTag(pdb, tiInfo, 0);
            break;

        case TAG_FLAG_MASK_KERNEL:
            ullKernel = SdbReadQWORDTag(pdb, tiInfo, 0);
            break;

        default:
            break;
        }

        tiInfo = SdbGetNextChild(pdb, tiFix, tiInfo);
    }

    pFix = AllocFix(g_szName, g_szDescription, type);

    if (pFix != NULL) {
        
        if (type == FIX_FLAG) {
            if (ullKernel == 0) {
                pFix->flagType = FLAG_USER;
                pFix->ullMask = ullUser;
            } else {
                pFix->flagType = FLAG_KERNEL;
                pFix->ullMask = ullKernel;
            }
        }
        
        pFix->pNext = g_pFixes;
        g_pFixes = pFix;
    }
}

void
ReadFixes(
    PDB   pdb,
    TAGID tiDatabase,
    TAGID tiLibrary
    )
{
    TAGID tiFix;

    tiFix = SdbFindFirstTag(pdb, tiLibrary, TAG_SHIM);

    while (tiFix != 0) {
        ReadFix(pdb, tiFix, FIX_SHIM);
        tiFix = SdbFindNextTag(pdb, tiLibrary, tiFix);
    }

    tiFix = SdbFindFirstTag(pdb, tiLibrary, TAG_PATCH);

    while (tiFix != 0) {
        ReadFix(pdb, tiFix, FIX_PATCH);
        tiFix = SdbFindNextTag(pdb, tiLibrary, tiFix);
    }

    tiFix = SdbFindFirstTag(pdb, tiLibrary, TAG_FLAG);

    while (tiFix != 0) {
        ReadFix(pdb, tiFix, FIX_FLAG);
        tiFix = SdbFindNextTag(pdb, tiLibrary, tiFix);
    }

    //
    // The LAYERs are under the DATABASE tag instead of LIBRARY :-(
    //
    tiFix = SdbFindFirstTag(pdb, tiDatabase, TAG_LAYER);

    while (tiFix != 0) {
        ReadFix(pdb, tiFix, FIX_LAYER);
        tiFix = SdbFindNextTag(pdb, tiDatabase, tiFix);
    }
}

PFIX
FindFix(
    char*    pszFixName,
    FIXTYPE  fixType
    )
{
    PFIX pFix = g_pFixes;

    while (pFix != NULL) {

        if (pFix->pszName && lstrcmpi(pszFixName, pFix->pszName) == 0) {
            return pFix;
        }

        pFix = pFix->pNext;
    }
    
    return NULL;
}

PFIX
FindFlagFix(
    ULONGLONG ullMask,
    FLAGTYPE  flagType
    )
{
    PFIX pFix = g_pFixes;

    while (pFix != NULL) {

        if (pFix->fixType == FIX_FLAG &&
            pFix->flagType == flagType &&
            pFix->ullMask == ullMask) {
            
            return pFix;
        }
        
        pFix = pFix->pNext;
    }
    
    return NULL;
}

BOOL
AddFlags(
    PDB      pdb,
    TAGID    tiFlags,
    PDBENTRY pEntry,
    FLAGTYPE flagType
    )
{
    ULONGLONG ullFlags;
    ULONGLONG ullMask = 1;
    PFIX      pFix;
    PFIXLIST  pFixList;
    int       i;
    
    ullFlags = SdbReadQWORDTag(pdb, tiFlags, 0);

    for (i = 0; i < sizeof(ULONGLONG) * 8; i++) {

        if (ullFlags & ullMask) {

            pFix = FindFlagFix(ullMask, flagType);

            if (pFix == NULL) {
                LogMsg("Cannot find flag fix ref\n");
            }

            pFixList = (PFIXLIST)Alloc(sizeof(FIXLIST));

            if (pFixList == NULL) {
                LogMsg("Cannot allocate %d bytes\n", sizeof(FIXLIST));
                return FALSE;
            }

            pFixList->pFix = pFix;
            pFixList->pNext = pEntry->pFirstFlag;

            pEntry->pFirstFlag = pFixList;
        }
        
        ullMask <<= 1;
    }
    
    return TRUE;
}


BOOL
AddFix(
    PDB      pdb,
    TAGID    tiFix,
    PDBENTRY pEntry,
    FIXTYPE  fixType
    )
{
    TAGID     tiName;
    char      szFixName[MAX_NAME];
    PFIX      pFix;
    PFIXLIST* ppHead;
    PFIXLIST  pFixList;

    tiName = SdbFindFirstTag(pdb, tiFix, TAG_NAME);

    if (!SdbReadStringTag(pdb, tiName, g_wszData, MAX_NAME * sizeof(WCHAR))) {
        LogMsg("Cannot read the name of the fix\n");
        return FALSE;
    }

    wsprintf(szFixName, "%ws", g_wszData);

    pFix = FindFix(szFixName, fixType);

    if (pFix == NULL) {
        LogMsg("Cannot find fix ref for: \"%s\" type %d\n", szFixName, fixType);
        return FALSE;
    }

    switch (fixType) {
    case FIX_SHIM:
        ppHead = &pEntry->pFirstShim;
        break;
    
    case FIX_PATCH:
        ppHead = &pEntry->pFirstPatch;
        break;
    
    case FIX_FLAG:
        ppHead = &pEntry->pFirstFlag;
        break;
    
    case FIX_LAYER:
        ppHead = &pEntry->pFirstLayer;
        break;
    }

    pFixList = (PFIXLIST)Alloc(sizeof(FIXLIST));

    if (pFixList == NULL) {
        LogMsg("Cannot allocate %d bytes\n", sizeof(FIXLIST));
        return FALSE;
    }

    pFixList->pFix = pFix;
    pFixList->pNext = *ppHead;

    *ppHead = pFixList;
    
    return TRUE;
}

void
AddAttr(
    char*         pszAttr,
    PMATCHINGFILE pMatch
    )
{
    PATTRIBUTE pAttr;

    pAttr = (PATTRIBUTE)Alloc(sizeof(ATTRIBUTE));

    if (pAttr) {
        pAttr->pszText = (char*)Alloc(lstrlen(pszAttr) + 1);

        if (pAttr->pszText) {
            lstrcpy(pAttr->pszText, pszAttr);

            pAttr->pNext = pMatch->pFirstAttribute;

            pMatch->pFirstAttribute = pAttr;
        } else {
            Free(pAttr);
        }
    }
}

VOID
PrintBinVer(
    char*          pszText,
    LARGE_INTEGER* pliBinVer
    )
{
    wsprintf(pszText, "%d", HIWORD(pliBinVer->HighPart));
    pszText += lstrlen(pszText);

    if (LOWORD(pliBinVer->HighPart) == 0xFFFF) {
        return;
    }
    
    wsprintf(pszText, ".%d", LOWORD(pliBinVer->HighPart));
    pszText += lstrlen(pszText);

    if (HIWORD(pliBinVer->LowPart) == 0xFFFF) {
        return;
    }
    
    wsprintf(pszText, ".%d", HIWORD(pliBinVer->LowPart));
    pszText += lstrlen(pszText);
    
    if (LOWORD(pliBinVer->LowPart) == 0xFFFF) {
        return;
    }
    
    wsprintf(pszText, ".%d", LOWORD(pliBinVer->LowPart));
    pszText += lstrlen(pszText);
}

BOOL
AddMatchingFile(
    PDB      pdb,
    TAGID    tiMatch,
    PDBENTRY pEntry
    )
{
    TAGID         tiMatchInfo;
    TAG           tWhich;
    DWORD         dw;
    LARGE_INTEGER li;
    PMATCHINGFILE pMatch;
    char          szStr[128];
    char          szAttr[256];

    pMatch = (PMATCHINGFILE)Alloc(sizeof(MATCHINGFILE));

    if (pMatch == NULL) {
        return FALSE;
    }

    tiMatchInfo = SdbGetFirstChild(pdb, tiMatch);

    while (tiMatchInfo != 0) {
        tWhich = SdbGetTagFromTagID(pdb, tiMatchInfo);

        switch (tWhich) {

        case TAG_NAME:
            if (SdbReadStringTag(pdb, tiMatchInfo, g_wszData, MAX_NAME * sizeof(WCHAR))) {
                wsprintf(szAttr, "%ws", g_wszData);
                
                pMatch->pszName = (char*)Alloc(lstrlen(szAttr) + 1);

                if (pMatch->pszName) {
                    lstrcpy(pMatch->pszName, szAttr);
                }
            }
            break;

        case TAG_SIZE:
            dw = SdbReadDWORDTag(pdb, tiMatchInfo, 0);
            
            if (dw != 0) {
                wsprintf(szAttr, "File Size: 0x%X", dw);
                AddAttr(szAttr, pMatch);
            }
            break;

        case TAG_CHECKSUM:
            dw = SdbReadDWORDTag(pdb, tiMatchInfo, 0);
            
            if (dw != 0) {
                wsprintf(szAttr, "File CheckSum: 0x%X", dw);
                AddAttr(szAttr, pMatch);
            }
            break;

        case TAG_COMPANY_NAME:
            if (SdbReadStringTag(pdb, tiMatchInfo, g_wszData, MAX_DATA_SIZE * sizeof(WCHAR))) {
                wsprintf(szStr, "%ws", g_wszData);

                wsprintf(szAttr, "Company Name: %s", szStr);
                AddAttr(szAttr, pMatch);
            }
            break;

        case TAG_PRODUCT_NAME:
            if (SdbReadStringTag(pdb, tiMatchInfo, g_wszData, MAX_DATA_SIZE * sizeof(WCHAR))) {
                wsprintf(szStr, "%ws", g_wszData);

                wsprintf(szAttr, "Product Name: %s", szStr);
                AddAttr(szAttr, pMatch);
            }
            break;

        case TAG_PRODUCT_VERSION:
            if (SdbReadStringTag(pdb, tiMatchInfo, g_wszData, MAX_DATA_SIZE * sizeof(WCHAR))) {
                wsprintf(szStr, "%ws", g_wszData);

                wsprintf(szAttr, "Product Version: %s", szStr);
                AddAttr(szAttr, pMatch);
            }
            break;

        case TAG_FILE_DESCRIPTION:
            if (SdbReadStringTag(pdb, tiMatchInfo, g_wszData, MAX_DATA_SIZE * sizeof(WCHAR))) {
                wsprintf(szStr, "%ws", g_wszData);

                wsprintf(szAttr, "File Description: %s", szStr);
                AddAttr(szAttr, pMatch);
            }
            break;

        case TAG_BIN_FILE_VERSION:
            li.QuadPart = SdbReadQWORDTag(pdb, tiMatchInfo, 0);
            
            if (li.HighPart != 0 || li.LowPart != 0) {

                PrintBinVer(szStr, &li);
                
                wsprintf(szAttr, "Binary File Version: %s", szStr);
                AddAttr(szAttr, pMatch);
            }
            
            break;

        case TAG_BIN_PRODUCT_VERSION:
            li.QuadPart = SdbReadQWORDTag(pdb, tiMatchInfo, 0);
            
            if (li.HighPart != 0 || li.LowPart != 0) {

                PrintBinVer(szStr, &li);
                
                wsprintf(szAttr, "Binary Product Version: %s", szStr);
                AddAttr(szAttr, pMatch);
            }
            break;

        default:
            break;
        }
        tiMatchInfo = SdbGetNextChild(pdb, tiMatch, tiMatchInfo);
    }

    pMatch->pNext = pEntry->pFirstMatchingFile;

    pEntry->pFirstMatchingFile = pMatch;

    (pEntry->nMatchingFiles)++;

    return TRUE;
}

void
AddEntry(
    PDB   pdb,
    TAGID tiExe
    )
{
    TAGID     tiExeInfo;
    TAGID     tiSeverity, tiHelpId;
    char      szStr[MAX_NAME];
    TAG       tWhich;
    PDBENTRY  pEntry;

    tiExeInfo = SdbGetFirstChild(pdb, tiExe);

    pEntry = (PDBENTRY)Alloc(sizeof(DBENTRY));

    if (pEntry == NULL) {
        LogMsg("Cannot allocate %d bytes\n", sizeof(DBENTRY));
        return;
    }

    pEntry->pNext = g_pEntries;
    g_pEntries = pEntry;

    while (tiExeInfo != 0) {
        tWhich = SdbGetTagFromTagID(pdb, tiExeInfo);

        switch (tWhich) {

        case TAG_NAME:
            if (SdbReadStringTag(pdb, tiExeInfo, g_wszData, MAX_NAME * sizeof(WCHAR))) {
                wsprintf(szStr, "%ws", g_wszData);

                pEntry->pszExeName = (char*)Alloc(lstrlen(szStr) + 1);

                if (pEntry->pszExeName) {
                    lstrcpy(pEntry->pszExeName, szStr);
                }
            }
            break;

        case TAG_APP_NAME:
            if (SdbReadStringTag(pdb, tiExeInfo, g_wszData, MAX_NAME * sizeof(WCHAR))) {
                wsprintf(szStr, "%ws", g_wszData);

                pEntry->pszAppName = (char*)Alloc(lstrlen(szStr) + 1);

                if (pEntry->pszAppName) {
                    lstrcpy(pEntry->pszAppName, szStr);
                }
            }
            break;

        case TAG_MATCHING_FILE:
            AddMatchingFile(pdb, tiExeInfo, pEntry);
            break;

        case TAG_APPHELP:
            pEntry->appHelp.bPresent = TRUE;
            
            tiSeverity = SdbFindFirstTag(pdb, tiExeInfo, TAG_PROBLEMSEVERITY);
            pEntry->appHelp.severity = (SEVERITY)SdbReadDWORDTag(pdb, tiSeverity, 0);

            tiHelpId = SdbFindFirstTag(pdb, tiExeInfo, TAG_HTMLHELPID);
            pEntry->appHelp.htmlHelpId = SdbReadDWORDTag(pdb, tiHelpId, 0);

            break;

        case TAG_SHIM_REF:
            AddFix(pdb, tiExeInfo, pEntry, FIX_SHIM);
            break;

        case TAG_PATCH_REF:
            AddFix(pdb, tiExeInfo, pEntry, FIX_PATCH);
            break;

        case TAG_LAYER:
            AddFix(pdb, tiExeInfo, pEntry, FIX_LAYER);
            break;

        case TAG_FLAG_MASK_USER:
            AddFlags(pdb, tiExeInfo, pEntry, FLAG_USER);
            break;

        case TAG_FLAG_MASK_KERNEL:
            AddFlags(pdb, tiExeInfo, pEntry, FLAG_KERNEL);
            break;

        case TAG_EXE_ID:
        {
            GUID  guid;
            PVOID p;

            p = SdbGetBinaryTagData(pdb, tiExeInfo);

            if (p != NULL) {
                memcpy(&guid, p, sizeof(GUID));
                
                wsprintf(pEntry->szGUID,
                         "{%08x-%04x-%04x-%02x%02x-%02x%02x%02x%02x%02x%02x}",
                         guid.Data1,
                         guid.Data2,
                         guid.Data3,
                         guid.Data4[0],
                         guid.Data4[1],
                         guid.Data4[2],
                         guid.Data4[3],
                         guid.Data4[4],
                         guid.Data4[5],
                         guid.Data4[6],
                         guid.Data4[7]);
            }
            break;
        }

        default:
            break;
        }
        tiExeInfo = SdbGetNextChild(pdb, tiExe, tiExeInfo);
    }
    
    pEntry->bDisablePerMachine = CheckRegistry(HKEY_LOCAL_MACHINE, pEntry->szGUID);
    pEntry->bDisablePerUser = CheckRegistry(HKEY_CURRENT_USER, pEntry->szGUID);
}


PDBENTRY
GetDatabaseEntries(
    void
    )
{
    WCHAR wszShimDB[MAX_PATH] = L"";
    PDB   pdb;
    TAGID tiDatabase, tiLibrary, tiExe;

    GetSystemWindowsDirectoryW(wszShimDB, MAX_PATH);
    wcscat(wszShimDB, L"\\AppPatch\\sysmain.sdb");

    //
    // Open sysmain.sdb shim database
    //
    pdb = SdbOpenDatabase(wszShimDB, DOS_PATH);

    if (pdb == NULL) {
        LogMsg("Cannot open shim DB \"%ws\"\n", wszShimDB);
        goto Cleanup;
    }

    tiDatabase = SdbFindFirstTag(pdb, TAGID_ROOT, TAG_DATABASE);

    if (tiDatabase == 0) {
        LogMsg("Cannot find TAG_DATABASE\n");
        goto Cleanup;
    }

    tiLibrary = SdbFindFirstTag(pdb, tiDatabase, TAG_LIBRARY);

    if (tiLibrary == 0) {
        LogMsg("Cannot find TAG_LIBRARY\n");
        goto Cleanup;
    }

    ReadFixes(pdb, tiDatabase, tiLibrary);
    
    //
    // Loop through the EXEs.
    //
    tiExe = SdbFindFirstTag(pdb, tiDatabase, TAG_EXE);

    while (tiExe != 0) {
        AddEntry(pdb, tiExe);

        tiExe = SdbFindNextTag(pdb, tiDatabase, tiExe);
    }

Cleanup:
    if (pdb != NULL) {
        SdbCloseDatabase(pdb);
    }

    return g_pEntries;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\appcompat\tools\acbrowser\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by BrowseAppCompat.rc
//
#define IDD_DIALOG                      101
#define IDI_APPICON                     102

#define IDC_LIST                        1000
#define IDC_ENTRY                       1001
#define IDC_ALL_ENTRIES                 1002
#define IDC_PER_USER                    1011
#define IDC_PER_MACHINE                 1012
#define IDC_STATISTICS                  1021
#define IDC_W_APPHELP                   1023
#define IDC_WO_APPHELP                  1024
#define IDC_W_PATCHES                   1025
#define IDC_WO_PATCHES                  1026
#define IDC_W_FLAGS                     1027
#define IDC_WO_FLAGS                    1028
#define IDC_W_LAYERS                    1029
#define IDC_WO_LAYERS                   1030
#define IDC_DC_APPHELP                  1031
#define IDC_DC_PATCHES                  1032
#define IDC_W_SHIMS                     1033
#define IDC_WO_SHIMS                    1034
#define IDC_DC_SHIMS                    1035
#define IDC_DC_FLAGS                    1036
#define IDC_DC_LAYERS                   1037
#define IDC_DISABLED_ONLY               1038


// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        102
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1019
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\appcompat\slayerui\win2k\stdafx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
//  stdafx.pch will be the pre-compiled header
//  stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"

#ifdef _ATL_STATIC_REGISTRY
#include <statreg.h>
#include <statreg.cpp>
#endif

#include <atlimpl.cpp>

#include "ShellExtensions.h"

typedef DWORD (*PFNSHDeleteKeyW)(HKEY hkey, LPWSTR pszSubkey);

HRESULT WINAPI
CLayerUIModule::UpdateRegistryCLSID(
    const CLSID& clsid,
    BOOL         bRegister
    )
{
    static const TCHAR szIPS32[] = _T("InprocServer32");
    static const TCHAR szCLSID[] = _T("CLSID");
    static const TCHAR szPropPageExt[] = _T("ShimLayer Property Page");

    TCHAR* pszExtName;
    DWORD  cbExtNameSize;

    HRESULT hRes = S_OK;

    LPOLESTR lpOleStrCLSIDValue;
    
    if (clsid != CLSID_ShimLayerPropertyPage) {
        LogMsg(_T("[UpdateRegistryCLSID] unknown CLSID!\n"));
        return E_FAIL;
    }
    
    ::StringFromCLSID(clsid, &lpOleStrCLSIDValue);

    HKEY hkey = NULL;
    LONG lRes;
    
    if (bRegister) {
        
        TCHAR szBuffer[MAX_PATH];
        DWORD keyType = 0;

        //
        // Write the key for registration. Include the value to specify
        // the threading model.
        //
        _stprintf(szBuffer, _T("%s\\%s\\%s"), szCLSID, lpOleStrCLSIDValue, szIPS32);
        
        lRes = RegCreateKey(HKEY_CLASSES_ROOT, szBuffer, &hkey);

        if (lRes != ERROR_SUCCESS) {
            LogMsg(_T("[UpdateRegistryCLSID] failed to open/create \"%s\"\n"),
                   szBuffer);
            goto Exit;
        }
        
        ::GetModuleFileName(m_hInst, szBuffer, MAX_PATH);
        
        lRes = RegSetValueEx(hkey,
                             NULL,
                             0,
                             REG_SZ,
                             (BYTE*)szBuffer,
                             (lstrlen(szBuffer) + 1) * sizeof(TCHAR));
        
        if (lRes != ERROR_SUCCESS) {
            LogMsg(_T("[UpdateRegistryCLSID] failed to write value \"%s\"\n"),
                   szBuffer);
            goto Exit;
        }
        
        lRes = RegSetValueEx(hkey,
                             _T("ThreadingModel"),
                             0,
                             REG_SZ,
                             (BYTE*)_T("Apartment"),
                             sizeof(_T("Apartment")));
        
        if (lRes != ERROR_SUCCESS) {
            LogMsg(_T("[UpdateRegistryCLSID] failed to write \"ThreadingModel\"\n"));
            goto Exit;
        }

        RegCloseKey(hkey);
        hkey = NULL;

        //
        // Open the key with the name of the .exe extension and
        // add the keys to support the shell extensions.
        //
        _stprintf(szBuffer,
                  _T("lnkfile\\shellex\\PropertySheetHandlers\\%s"),
                  szPropPageExt);

        pszExtName = (TCHAR*)szPropPageExt;
        cbExtNameSize = sizeof(szPropPageExt) + sizeof(TCHAR);
        
        lRes = RegCreateKey(HKEY_CLASSES_ROOT, szBuffer, &hkey);
        
        if (lRes != ERROR_SUCCESS) {
            goto Exit;
        }

        lRes = RegSetValueEx(hkey,
                             NULL,
                             0,
                             REG_SZ,
                             (BYTE*)lpOleStrCLSIDValue,
                             (lstrlen(lpOleStrCLSIDValue) + 1) * sizeof(TCHAR));

        if (lRes != ERROR_SUCCESS) {
            LogMsg(_T("[UpdateRegistryCLSID] failed to add the shell extension handler\n"));
            goto Exit;
        }
        
        RegCloseKey(hkey);
        hkey = NULL;

        //
        // Now add the shell extension to the approved list.
        //
        lRes = RegCreateKey(HKEY_LOCAL_MACHINE,
                            _T("SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Shell Extensions\\Approved"),
                            &hkey);
        
        if (lRes != ERROR_SUCCESS) {
            LogMsg(_T("[UpdateRegistryCLSID] failed to approve the shell extension handler\n"));
            goto Exit;
        }
        
        lRes = RegSetValueEx(hkey,
                             lpOleStrCLSIDValue,
                             0,
                             REG_SZ,
                             (BYTE*)pszExtName,
                             cbExtNameSize);

        if (lRes != ERROR_SUCCESS) {
            LogMsg(_T("[UpdateRegistryCLSID] failed to approve the shell extension handler\n"));
            goto Exit;
        }

Exit:        
        if (hkey != NULL) {
            RegCloseKey(hkey);
            hkey = NULL;
        }
            
        hRes = HRESULT_FROM_WIN32(lRes);
    
    } else {
        //
        // Time to clean up.
        //
        PFNSHDeleteKeyW pfnSHDeleteKey;

        HMODULE hmod = LoadLibrary(_T("Shlwapi.dll"));

        if (hmod == NULL) {
            LogMsg(_T("[UpdateRegistryCLSID] failed to load Shlwapi.dll\n"));
            return E_FAIL;
        }
        
        pfnSHDeleteKey = (PFNSHDeleteKeyW)GetProcAddress(hmod, "SHDeleteKeyW");

        if (pfnSHDeleteKey == NULL) {
            FreeLibrary(hmod);
            LogMsg(_T("[UpdateRegistryCLSID] cannot get Shlwapi!SHDeleteKeyW\n"));
            return E_FAIL;
        }

        lRes = RegOpenKey(HKEY_CLASSES_ROOT, szCLSID, &hkey);
        
        if (lRes == ERROR_SUCCESS) {
            (*pfnSHDeleteKey)(hkey, lpOleStrCLSIDValue);
            
            RegCloseKey(hkey);
            hkey = NULL;
        }

        lRes = RegOpenKey(HKEY_CLASSES_ROOT, _T("lnkfile\\shellex"), &hkey);
        
        if (lRes == ERROR_SUCCESS) {
            
            (*pfnSHDeleteKey)(hkey, _T("PropertySheetHandlers\\ShimLayer Property Page"));
            
            RegCloseKey(hkey);
            hkey = NULL;
        }
        
        lRes = RegOpenKey(HKEY_LOCAL_MACHINE,
                          _T("SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Shell Extensions\\Approved"),
                          &hkey);
        
        if (lRes == ERROR_SUCCESS) {
            RegDeleteValue(hkey, lpOleStrCLSIDValue);
            
            RegCloseKey(hkey);
            hkey = NULL;
        }

        FreeLibrary(hmod);
    }

    //
    // Delete the layer storage.
    //
    InitLayerStorage(TRUE);
    
    //
    // Notify the shell of our changes
    //
    SHChangeNotify(SHCNE_ASSOCCHANGED, SHCNF_IDLIST, NULL, NULL);

    ::CoTaskMemFree(lpOleStrCLSIDValue);
    
    return hRes;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\appcompat\tools\acbrowserwin2k\acbrowser.c ===
// BrowseAppCompat.cpp : Defines the entry point for the application.
//

#include "acBrowser.h"
#include "resource.h"

#include <commctrl.h>
#include <stdlib.h>
#include <stdio.h>
#include <stdarg.h>

/*
 * Global Variables
 */

HINSTANCE g_hInstance;
HWND      g_hDlg;

HWND      g_hwndList;

HFONT     g_hFont;
int       g_nItems;

BOOL g_bEnable;
BOOL g_bDelete;


#define CHANGE_NOCHANGE 0
#define CHANGE_ENABLE   1
#define CHANGE_DISABLE  2
#define CHANGE_DELETE   3


#define COLUMN_APP      0
#define COLUMN_STATUS   1
#define COLUMN_CHANGE   2

typedef struct tagREGITEM {
    char*     pszApp;
    char*     pszShim;
    char*     pszAttr;
    int       nItem;
    BOOL      bShim;
    BOOL      bEnabled;
    int       change;
} REGITEM, *PREGITEM;


/*********************************************************************
* LogMsg
*
*********************************************************************/
void LogMsg(
    LPSTR pszFmt,
    ... )
{
    CHAR gszT[1024];
    va_list arglist;

    va_start(arglist, pszFmt);
    _vsnprintf(gszT, 1023, pszFmt, arglist);
    gszT[1023] = 0;
    va_end(arglist);
    
    OutputDebugString(gszT);
}

/*******************************************************************************
* CenterWindow
*
*  This function must be called at the WM_INIDIALOG in order to
*  move the dialog window centered in the client area of the
*  parent or owner window.
*******************************************************************************/
BOOL CenterWindow(
    HWND hWnd)
{
    RECT    rectWindow, rectParent, rectScreen;
    int     nCX, nCY;
    HWND    hParent;
    POINT   ptPoint;

    hParent =  GetParent(hWnd);
    if (hParent == NULL)
        hParent = GetDesktopWindow();

    GetWindowRect(hParent,            (LPRECT)&rectParent);
    GetWindowRect(hWnd,               (LPRECT)&rectWindow);
    GetWindowRect(GetDesktopWindow(), (LPRECT)&rectScreen);

    nCX = rectWindow.right  - rectWindow.left;
    nCY = rectWindow.bottom - rectWindow.top;

    ptPoint.x = ((rectParent.right  + rectParent.left) / 2) - (nCX / 2);
    ptPoint.y = ((rectParent.bottom + rectParent.top ) / 2) - (nCY / 2);

    if (ptPoint.x < rectScreen.left)
        ptPoint.x = rectScreen.left;
    if (ptPoint.x > rectScreen.right  - nCX)
        ptPoint.x = rectScreen.right  - nCX;
    if (ptPoint.y < rectScreen.top)
        ptPoint.y = rectScreen.top;
    if (ptPoint.y > rectScreen.bottom - nCY)
        ptPoint.y = rectScreen.bottom - nCY;

    if (GetWindowLong(hWnd, GWL_STYLE) & WS_CHILD)
        ScreenToClient(hParent, (LPPOINT)&ptPoint);

    if (!MoveWindow(hWnd, ptPoint.x, ptPoint.y, nCX, nCY, TRUE))
        return FALSE;

    return TRUE;
}

/*********************************************************************
* AddShimToList
*
*********************************************************************/
VOID AddShimToList(
    char* pszApp,
    char* pszShim,
    char* pszData,
    BOOL  bEnabled,
    BOOL  bShim)
{
    char*    pszAppAlloc;
    char*    pszShimAlloc;
    char*    pszDataAlloc;
    char     szDisp[128];
    PREGITEM pItem;
    LVITEM   lvi; 
    
    pszAppAlloc = (char*)HeapAlloc(GetProcessHeap(), 0, lstrlen(pszApp) + 1);

    if (pszAppAlloc == NULL) {
        LogMsg("AddApp: error trying to allocate %d bytes\n", lstrlen(pszApp) + 1);
        return;
    }
    lstrcpy(pszAppAlloc, pszApp);
    
    pszShimAlloc = (char*)HeapAlloc(GetProcessHeap(), 0, lstrlen(pszShim) + 1);

    if (pszShimAlloc == NULL) {
        HeapFree(GetProcessHeap(), 0, pszAppAlloc);
        LogMsg("AddApp: error trying to allocate %d bytes\n", lstrlen(pszShim) + 1);
        return;
    }
    lstrcpy(pszShimAlloc, pszShim);
    
    pszDataAlloc = (char*)HeapAlloc(GetProcessHeap(), 0, lstrlen(pszData) + 1);

    if (pszDataAlloc == NULL) {
        HeapFree(GetProcessHeap(), 0, pszAppAlloc);
        HeapFree(GetProcessHeap(), 0, pszShimAlloc);
        LogMsg("AddApp: error trying to allocate %d bytes\n", lstrlen(pszData) + 1);
        return;
    }
    lstrcpy(pszDataAlloc, pszData);
    
    pItem = (PREGITEM)HeapAlloc(GetProcessHeap(), 0, sizeof(REGITEM));
    
    if (pItem == NULL) {
        HeapFree(GetProcessHeap(), 0, pszAppAlloc);
        HeapFree(GetProcessHeap(), 0, pszShimAlloc);
        HeapFree(GetProcessHeap(), 0, pszDataAlloc);
        LogMsg("AddApp: error trying to allocate %d bytes\n", sizeof(REGITEM));
        return;
    }

    wsprintf(szDisp, "%s (%s)",pszAppAlloc ,pszShimAlloc);
    
    pItem->pszApp   = pszAppAlloc;
    pItem->pszShim  = pszShimAlloc;
    pItem->pszAttr  = pszDataAlloc;
    pItem->bEnabled = bEnabled;
    pItem->change   = CHANGE_NOCHANGE;
    pItem->bShim    = bShim;
    
    // Initialize LVITEM members that are common to all items.
    lvi.mask      = LVIF_TEXT | LVIF_PARAM;
    lvi.pszText   = szDisp;
    lvi.iItem     = g_nItems;
    lvi.iSubItem  = 0;
    lvi.lParam    = (LPARAM)pItem;

    pItem->nItem  = ListView_InsertItem(g_hwndList, &lvi);

    lvi.mask      = LVIF_TEXT;
    lvi.iItem     = g_nItems++;
    lvi.iSubItem  = COLUMN_STATUS;
    
    if (bShim) {
        lvi.pszText = (bEnabled ? "enabled" : "DISABLED");
    } else {
        lvi.pszText = "";
    }

    ListView_SetItem(g_hwndList, &lvi);
}

/*********************************************************************
* InsertColumnIntoListView
*
*********************************************************************/
VOID
InsertColumnIntoListView(
    LPSTR    lpszColumn,
    DWORD    dwSubItem,
    DWORD    widthPercent)
{
    LVCOLUMN  lvc;
    RECT      rcClient;
    DWORD     width;

    GetWindowRect(g_hwndList, &rcClient);
    
    width = rcClient.right - rcClient.left -
                4 * GetSystemMetrics(SM_CXBORDER) -
                GetSystemMetrics(SM_CXVSCROLL);
    
    width = width * widthPercent / 100;
    
    lvc.mask     = LVCF_FMT | LVCF_TEXT | LVCF_SUBITEM | LVCF_WIDTH;
    lvc.fmt      = LVCFMT_LEFT;
    lvc.iSubItem = dwSubItem;
    lvc.cx       = width;
    lvc.pszText  = lpszColumn;
    
    ListView_InsertColumn(g_hwndList, dwSubItem, &lvc);
}

/*********************************************************************
* DoInitDialog
*
*********************************************************************/
VOID
DoInitDialog(
    HWND hdlg)
{
    g_hDlg = hdlg;

    CenterWindow(hdlg);

    g_hFont = CreateFont(15,
                         0, 0, 0, FW_EXTRALIGHT, 0, 0, 0, 0, 0,
                         0, 0, 0, (LPSTR)"Courier New");
    
    g_hwndList = GetDlgItem(hdlg, IDC_LIST);
    
    g_nItems = 0;

    SendDlgItemMessage(hdlg, IDC_ATTR_USED, WM_SETFONT, (WPARAM)g_hFont, 0);
    
    SetDlgItemText(hdlg,
                   IDC_ATTR_USED,
                   "Select a shim to see what attributes are used to identify the application");
    
    InsertColumnIntoListView("Application", COLUMN_APP,    60);
    InsertColumnIntoListView("Status",      COLUMN_STATUS, 20);
    InsertColumnIntoListView("Change",      COLUMN_CHANGE, 20);

    g_bEnable = TRUE;
    g_bDelete = TRUE;

    EnumShimmedApps_Win2000(AddShimToList, FALSE);
}

/*********************************************************************
* DoDeleteListItem
*
*********************************************************************/
VOID
DoDeleteListItem(
    LPARAM lParam)
{
    LPNMLISTVIEW pnmv = (LPNMLISTVIEW)lParam;

    if (pnmv->iSubItem == 0) {
        PREGITEM pItem = (PREGITEM)pnmv->lParam;

        HeapFree(GetProcessHeap(), 0, pItem->pszApp);
        HeapFree(GetProcessHeap(), 0, pItem->pszAttr);
        
        if (pItem->pszShim != NULL) {
            HeapFree(GetProcessHeap(), 0, pItem->pszShim);
        }
        pItem->pszApp  = NULL;
        pItem->pszAttr = NULL;
        pItem->pszShim = NULL;
    
        HeapFree(GetProcessHeap(), 0, pItem);
    }
}

/*********************************************************************
* DoSelectionChanged
*
*********************************************************************/
VOID
DoSelectionChanged(
    HWND   hdlg,
    LPARAM lParam)
{
    LVITEM   lvi;
    PREGITEM pItem;

    int nSel = ListView_GetSelectionMark(g_hwndList);

    if (nSel == -1)
        return;

    lvi.iItem = nSel;
    lvi.iSubItem = 0;
    lvi.mask = LVIF_PARAM;

    ListView_GetItem(g_hwndList, &lvi);

    pItem = (PREGITEM)lvi.lParam;

    SetDlgItemText(hdlg, IDC_ATTR_USED, pItem->pszAttr);

    if (!pItem->bShim) {
        EnableWindow(GetDlgItem(hdlg, IDC_ENABLE), FALSE);
        EnableWindow(GetDlgItem(hdlg, IDC_DELETE), FALSE);
    } else {
        EnableWindow(GetDlgItem(hdlg, IDC_ENABLE), TRUE);
        EnableWindow(GetDlgItem(hdlg, IDC_DELETE), TRUE);
        
        if (pItem->bEnabled) {
            switch (pItem->change) {
            case CHANGE_NOCHANGE:
                SetDlgItemText(hdlg, IDC_ENABLE, "&Disable");
                SetDlgItemText(hdlg, IDC_DELETE, "Dele&te");

                g_bEnable = FALSE;
                g_bDelete = TRUE;
                break;
            case CHANGE_DISABLE:
                SetDlgItemText(hdlg, IDC_ENABLE, "&Enable");
                SetDlgItemText(hdlg, IDC_DELETE, "Dele&te");

                g_bEnable = TRUE;
                g_bDelete = TRUE;
                break;
            case CHANGE_DELETE:
                SetDlgItemText(hdlg, IDC_ENABLE, "&Disable");
                SetDlgItemText(hdlg, IDC_DELETE, "Undo Dele&te");

                g_bEnable = FALSE;
                g_bDelete = FALSE;
                break;
            }
        } else {
            switch (pItem->change) {
            case CHANGE_NOCHANGE:
                SetDlgItemText(hdlg, IDC_ENABLE, "&Enable");
                SetDlgItemText(hdlg, IDC_DELETE, "Dele&te");

                g_bEnable = TRUE;
                g_bDelete = TRUE;
                break;
            case CHANGE_ENABLE:
                SetDlgItemText(hdlg, IDC_ENABLE, "&Disable");
                SetDlgItemText(hdlg, IDC_DELETE, "Dele&te");

                g_bEnable = FALSE;
                g_bDelete = TRUE;
                break;
            case CHANGE_DELETE:
                SetDlgItemText(hdlg, IDC_ENABLE, "&Enable");
                SetDlgItemText(hdlg, IDC_DELETE, "Undo Dele&te");

                g_bEnable = TRUE;
                g_bDelete = FALSE;
                break;
            }
        }
    }
}

/*********************************************************************
* OnEnable
*
*********************************************************************/
VOID
OnEnable(
    HWND hdlg)
{
    PREGITEM pItem;
    int      nSel = ListView_GetSelectionMark(g_hwndList);

    LVITEM lvi;
    
    lvi.iItem    = nSel;
    lvi.iSubItem = COLUMN_APP;
    lvi.mask     = LVIF_PARAM;

    ListView_GetItem(g_hwndList, &lvi);

    pItem = (PREGITEM)lvi.lParam;
    
    lvi.mask     = LVIF_TEXT;
    lvi.iItem    = nSel;
    lvi.iSubItem = COLUMN_CHANGE;
    
    if (g_bEnable) {
        lvi.pszText = (pItem->bEnabled ? "" : "enable");
        pItem->change = (pItem->bEnabled ? CHANGE_NOCHANGE : CHANGE_ENABLE);
        SetDlgItemText(hdlg, IDC_ENABLE, "&Disable");
    } else {
        lvi.pszText = (pItem->bEnabled ? "disable" : "");
        pItem->change = (pItem->bEnabled ? CHANGE_DISABLE : CHANGE_NOCHANGE);
        SetDlgItemText(hdlg, IDC_ENABLE, "&Enable");
    }
    
    SetDlgItemText(hdlg, IDC_DELETE, "Dele&te");
    g_bDelete = TRUE;

    g_bEnable = !g_bEnable;

    ListView_SetItem(g_hwndList, &lvi);
}

/*********************************************************************
* OnDelete
*
*********************************************************************/
VOID
OnDelete(
    HWND hdlg)
{
    PREGITEM pItem;
    LVITEM   lvi;
	int      nSel = ListView_GetSelectionMark(g_hwndList);
    
    lvi.iItem    = nSel;
    lvi.iSubItem = COLUMN_APP;
    lvi.mask     = LVIF_PARAM;

    ListView_GetItem(g_hwndList, &lvi);

    pItem = (PREGITEM)lvi.lParam;
    
    lvi.mask     = LVIF_TEXT;
    lvi.iItem    = nSel;
    lvi.iSubItem = COLUMN_CHANGE;
    
    if (g_bDelete) {
        SetDlgItemText(hdlg, IDC_DELETE, "Undo Dele&te");
        lvi.pszText = "delete";
        pItem->change = CHANGE_DELETE;
    } else {
        SetDlgItemText(hdlg, IDC_DELETE, "Dele&te");
        lvi.pszText = "";
        pItem->change = CHANGE_NOCHANGE;
    }
    
    if (pItem->bEnabled) {
        SetDlgItemText(hdlg, IDC_ENABLE, "&Disable");
    }
    g_bDelete = !g_bDelete;
    
    ListView_SetItem(g_hwndList, &lvi);
}

/*********************************************************************
* OnShowOnlyShims
*
*********************************************************************/
VOID
OnShowOnlyShims(
    HWND hdlg)
{
    BOOL bOnlyShims;
    
    bOnlyShims = (SendDlgItemMessage(hdlg,
                                     IDC_ONLY_SHIMS,
                                     BM_GETCHECK,
                                     0,
                                     0) == BST_CHECKED);
    
    SendMessage(g_hwndList, WM_SETREDRAW, FALSE, 0);
    
    g_nItems = 0;
    
    ListView_DeleteAllItems(g_hwndList);
    
    g_bEnable = TRUE;
    g_bDelete = TRUE;

    EnumShimmedApps_Win2000(AddShimToList, bOnlyShims);

    SendMessage(g_hwndList, WM_SETREDRAW, TRUE, 0);
}

/*********************************************************************
* OnApply
*
*********************************************************************/
VOID
OnApply(
    HWND hdlg)
{
    LVITEM   lvi;
    PREGITEM pItem;
    int      i;
    
    lvi.iSubItem = COLUMN_APP;
    lvi.mask     = LVIF_PARAM;

    for (i = 0; i < g_nItems; i++) {
        lvi.iItem = i;
        
        ListView_GetItem(g_hwndList, &lvi);

        pItem = (PREGITEM)lvi.lParam;

        if (pItem->change == CHANGE_NOCHANGE)
            continue;
    
        switch (pItem->change) {
        case CHANGE_ENABLE:
            EnableShim_Win2000(pItem->pszApp, pItem->pszShim);
            break;
        case CHANGE_DISABLE:
            DisableShim_Win2000(pItem->pszApp, pItem->pszShim);
            break;
        case CHANGE_DELETE:
            DeleteShim_Win2000(pItem->pszApp, pItem->pszShim);
            break;
        }
    }

    SetDlgItemText(hdlg, IDC_DELETE, "Dele&te");
    SetDlgItemText(hdlg, IDC_ENABLE, "&Enable");

    OnShowOnlyShims(hdlg);
}

/*********************************************************************
* OnPrint
*
*********************************************************************/

char g_szDisplay[1024 * 1024];

VOID
OnDisplayAll(
    HWND hdlg)
{
    LVITEM   lvi;
    PREGITEM pItem;
    char*    pszDisplay = g_szDisplay;
    int      i;
    
    lvi.iSubItem = COLUMN_APP;
    lvi.mask     = LVIF_PARAM;

    for (i = 0; i < g_nItems; i++) {
        lvi.iItem = i;
        
        ListView_GetItem(g_hwndList, &lvi);

        pItem = (PREGITEM)lvi.lParam;

        lstrcpy(pszDisplay, pItem->pszAttr);
        lstrcat(pszDisplay, "\r\n");
        pszDisplay += lstrlen(pszDisplay);
    }
    SetDlgItemText(hdlg, IDC_ATTR_USED, g_szDisplay);
}

/*********************************************************************
* BrowseAppCompatDlgProc
*
*********************************************************************/
INT_PTR CALLBACK
BrowseAppCompatDlgProc(
    HWND   hdlg,
    UINT   uMsg,
    WPARAM wParam,
    LPARAM lParam)
{
    int wCode = LOWORD(wParam);
    int wNotifyCode = HIWORD(wParam);

    switch (uMsg) {
    case WM_INITDIALOG:
        DoInitDialog(hdlg);
        break;

    case WM_NOTIFY:
        if (wParam == IDC_LIST) {
            LPNMHDR pnm = (LPNMHDR)lParam;

            switch (pnm->code) {
            case LVN_DELETEITEM:
                DoDeleteListItem(lParam);
                break;
            
            case LVN_ITEMCHANGED:
            case NM_CLICK:
                DoSelectionChanged(hdlg, lParam);
                break;
            
            default:
                break;
            }
        }
        break;

    case WM_COMMAND:
        switch (wCode) {
        
        case IDC_ENABLE:
            OnEnable(hdlg);
            break;
        
        case IDC_DELETE:
            OnDelete(hdlg);
            break;
        
        case IDC_APPLY:
            OnApply(hdlg);
            break;
        
        case IDC_ONLY_SHIMS:
            OnShowOnlyShims(hdlg);
            break;
        
        case IDC_DISPLAY_ALL:
            OnDisplayAll(hdlg);
            break;

        case IDCANCEL:
            EndDialog(hdlg, TRUE);
            break;

        default:
            return FALSE;
        }
        break;

    default:
        return FALSE;
    }

    return TRUE;
}

int APIENTRY WinMain(HINSTANCE hInstance,
                     HINSTANCE hPrevInstance,
                     LPSTR     lpCmdLine,
                     int       nCmdShow)
{
    InitCommonControls();

    g_hInstance = hInstance;

    DialogBox(hInstance,
              MAKEINTRESOURCE(IDD_DIALOG),
              GetDesktopWindow(),
              (DLGPROC)BrowseAppCompatDlgProc);

	return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\appcompat\tools\acbrowserwin2k\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by BrowseAppCompat.rc
//
#define IDD_DIALOG1                     101
#define IDD_DIALOG                      101
#define IDC_LIST                        1000
#define IDC_ENABLE                      1002
#define IDC_DELETE                      1003
#define IDC_APPLY                       1004
#define IDC_EDIT1                       1005
#define IDC_ATTR_USED                   1005
#define IDC_ONLY_SHIMS                  1006
#define IDC_DISPLAY_ALL                 1007

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        102
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1008
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\appcompat\tools\acbrowserwin2k\acbrowser.h ===
#ifndef _ACBROWSER_H
#define _ACBROWSER_H

#include <windows.h>

#define APPTYPE_TYPE_MASK     0x000000FF

#define APPTYPE_INC_NOBLOCK   0x00000001
#define APPTYPE_INC_HARDBLOCK 0x00000002
#define APPTYPE_MINORPROBLEM  0x00000003
#define APPTYPE_REINSTALL     0x00000004
#define APPTYPE_VERSION       0x00000005
#define APPTYPE_SHIM          0x00000006

typedef VOID (*PFNADDSHIM)(char* pszApp,
                           char* pszShim,
                           char* pszAttributes,
                           BOOL  bEnabled,
                           BOOL  bShim);


void LogMsg(LPSTR pszFmt, ... );
BOOL CenterWindow(HWND hWnd);

BOOL
EnumShimmedApps_Win2000(
    PFNADDSHIM pfnAddShim,
    BOOL       bOnlyShims);

BOOL
EnableShim_Win2000(
    char* pszApp,
    char* pszShim);

BOOL
DisableShim_Win2000(
    char* pszApp,
    char* pszShim);

BOOL
DeleteShim_Win2000(
    char* pszApp,
    char* pszShim);

#endif // _ACBROWSER_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\appcompat\tools\acbrowserwin2k\acbwin2000.c ===
#include "acBrowser.h"

#include "..\acFileAttr\acFileAttr.h"

typedef struct tagKEYHEADER{
    DWORD Size;
    DWORD MsgId;
    DWORD AppType;
} KEYHEADER, *PKEYHEADER;


char g_szData[2048];

VOID
PrintHeader(
    KEYHEADER* pheader,
    char*      pszAppName,
    char*      pszShimData)
{
    char* pszOut = g_szData;

    lstrcpy(pszOut, "Application state: ");
    
    switch (pheader->AppType & APPTYPE_TYPE_MASK) {
    case APPTYPE_INC_NOBLOCK:
        lstrcat(pszOut, "Incompatible - no hard block\r\n");
        break;
    case APPTYPE_INC_HARDBLOCK:
        lstrcat(pszOut, "Incompatible - hard block\r\n");
        break;
    case APPTYPE_MINORPROBLEM:
        lstrcat(pszOut, "Minor problems\r\n");
        break;
    case APPTYPE_REINSTALL:
        lstrcat(pszOut, "Reinstall\r\n");
        break;
    case APPTYPE_VERSION:
        lstrcat(pszOut, "Version substitute\r\n");
        break;
    case APPTYPE_SHIM:
        lstrcat(pszOut, "Shim\r\n");
        break;
    default:
        lstrcat(pszOut, "AppsHelp\r\n");
        break;
    }
    
    pszOut = g_szData + lstrlen(g_szData);
    
    if (pszShimData == NULL) {
        wsprintf(pszOut, "Message ID: %d\r\n\r\n", pheader->MsgId);
    } else {
        wsprintf(pszOut, "Shim fix: %s\r\n\r\n", pszShimData);
    }

    pszOut = g_szData + lstrlen(g_szData);
    
    wsprintf(pszOut, "Attributes for %s:\r\n", pszAppName);
}

#define MAX_EXE_NAME        64
#define MAX_VALUE_LENGTH    64      // in most cases this is a number but
                                    // it can be a string as well
#define MAX_BLOB_SIZE       2048

BYTE g_data[MAX_BLOB_SIZE];

BOOL
EnumShimmedApps_Win2000(
    PFNADDSHIM pfnAddShim,
    BOOL       bOnlyShims)
{
    LONG     status;
    HKEY     hkey, hkeyApp;
    DWORD    cbSize;
    DWORD    cbData;
    DWORD    cbShimData;
    FILETIME ft;
    DWORD    dwType;
    char     szAppName[MAX_EXE_NAME];
    char     szValueName[MAX_VALUE_LENGTH];
    char     szShimValueName[128];
    char     szShimData[256];
    BOOL     bEnabled;
    DWORD    dwValue;
    
    KEYHEADER header;
   
    status = RegOpenKey(HKEY_LOCAL_MACHINE,
                        "System\\CurrentControlSet\\Control\\Session Manager\\AppCompatibility",
                        &hkey);

    if (status != ERROR_SUCCESS) {
        LogMsg("Failed to open AppCompatibility registry key\n");
        return FALSE;
    }
    
    // loop through all the binaries listed under the AppCompatibility key
    for (dwValue = 0; ; dwValue++) {
        
        DWORD dwV;

        // we'll only read binary names that are less then MAX_EXE_NAME
        // in size.
        cbSize = MAX_EXE_NAME;
        
        status = RegEnumKeyEx(
                        hkey,
                        dwValue,
                        szAppName,
                        &cbSize,
                        NULL,
                        NULL,
                        NULL,
                        &ft);

        // get out if no more entries
        if (status != ERROR_SUCCESS) {
            break;
        }
        
        // get the handle to the registry key for this app
        status = RegOpenKey(hkey,
                            szAppName,
                            &hkeyApp);
        
        // this should not fail but let's be cautious
        if (status != ERROR_SUCCESS) {
            LogMsg("Failed to open reg key for '%s'\n", szAppName);
            continue;
        }

        // loop through all the shims and AppsHelp entries for the
        // current app.
        for (dwV = 0; ; dwV++) {
            
            char* pszData;
            
            cbSize = MAX_VALUE_LENGTH;
            cbData = MAX_BLOB_SIZE;
            
            cbShimData = 256;

            status = RegEnumValue(
                            hkeyApp,
                            dwV,
                            szValueName,
                            &cbSize,
                            NULL,
                            &dwType,
                            (LPBYTE)&g_data,
                            &cbData);
            
            if (status != ERROR_SUCCESS) {
                break;
            }

            // we're only interested in the binary values
            if (dwType != REG_BINARY) {
                continue;
            }

            CopyMemory(&header, g_data, sizeof(KEYHEADER));

            // it must me a valid blob
            if (header.Size != sizeof(KEYHEADER)) {
                LogMsg("Invalid blob\n");
                continue;
            }            
            
            bEnabled = TRUE;

            // now let's look for an enabled shim entry
            wsprintf(szShimValueName, "DllPatch-%s", szValueName);

            status = RegQueryValueEx(
                            hkeyApp,
                            szShimValueName,
                            NULL,
                            &dwType,
                            (LPBYTE)szShimData,
                            &cbShimData);
        
            if (status != ERROR_SUCCESS) {
                
                // how about a disabled shim entry
                wsprintf(szShimValueName, "-DllPatch-%s", szValueName);

                status = RegQueryValueEx(
                                hkeyApp,
                                szShimValueName,
                                NULL,
                                &dwType,
                                (LPBYTE)szShimData,
                                &cbShimData);
        
                if (status != ERROR_SUCCESS) {
                    
                    // this is not a shim. If only shim entries are
                    // requested go to the next entry.
                    if (bOnlyShims) {
                        continue;
                    }
                    
                    // This is an AppsHelp entry.
                    PrintHeader(&header, szAppName, NULL);
                    pszData = g_szData + lstrlen(g_szData);
                    
                    if (BlobToString(g_data + sizeof(KEYHEADER),
                                     cbData - sizeof(KEYHEADER) - sizeof(DWORD),
                                     pszData)) {
                        (*pfnAddShim)(szAppName, szValueName, g_szData, TRUE, FALSE);
                    } else {
                        LogMsg("Failed to dump blob for AppsHelp entry: app '%s' entry '%s'\n",
                               szAppName, szValueName);
                    }
                    continue;
                }
                bEnabled = FALSE;
            }
            // This is a shim.
            PrintHeader(&header, szAppName, szShimData);
            pszData = g_szData + lstrlen(g_szData);
            
            if (BlobToString(g_data + sizeof(KEYHEADER),
                             cbData - sizeof(KEYHEADER) - sizeof(DWORD),
                             pszData)) {
                (*pfnAddShim)(szAppName, szValueName, g_szData, bEnabled, TRUE);
            } else {
                LogMsg("Failed to dump blob for shim entry: app '%s' entry '%s'\n",
                       szAppName, szValueName);
            }
        }
        
        RegCloseKey(hkeyApp);
    }

    RegCloseKey(hkey);

    return TRUE;
}

BOOL
EnableShim_Win2000(
    char* pszApp,
    char* pszShim)
{
    LONG     status;
    HKEY     hkey;
    char     szAppKey[128];
    char     szShimValueName[128];
    char     szData[256];
    DWORD    cbSize, dwType;
    BOOL     bRet = FALSE;
    
    wsprintf(szAppKey, "%s\\%s",
             "System\\CurrentControlSet\\Control\\Session Manager\\AppCompatibility",
             pszApp);
    
    status = RegOpenKey(HKEY_LOCAL_MACHINE,
                        szAppKey,
                        &hkey);

    if (status != ERROR_SUCCESS) {
        LogMsg("Failed to open registry key %s\n", szAppKey);
        return FALSE;
    }
    
    wsprintf(szShimValueName, "-DllPatch-%s", pszShim);
    
    cbSize = 256;
    status = RegQueryValueEx(hkey,
                             szShimValueName,
                             NULL,
                             &dwType,
                             (LPBYTE)szData,
                             &cbSize);
    
    if (status != ERROR_SUCCESS || dwType != REG_SZ || cbSize >= 256) {
        LogMsg("Error reading key %s\n", szShimValueName);
        goto Cleanup;
    }
    
    status = RegDeleteValue(hkey, szShimValueName);
    
    if (status != ERROR_SUCCESS) {
        LogMsg("Couldn't delete key %s\n", szShimValueName);
        goto Cleanup;
    }
    
    wsprintf(szShimValueName, "DllPatch-%s", pszShim);

    status = RegSetValueEx(hkey,
                           szShimValueName,
                           0,
                           REG_SZ,
                           (LPBYTE)szData,
                           cbSize);
    
    if (status != ERROR_SUCCESS) {
        LogMsg("Couldn't set value key %s\n", szShimValueName);
        goto Cleanup;
    }
    
    bRet = TRUE;

Cleanup:    
    RegCloseKey(hkey);
    return bRet;
}

BOOL
DisableShim_Win2000(
    char* pszApp,
    char* pszShim)
{
    LONG     status;
    HKEY     hkey;
    char     szAppKey[128];
    char     szShimValueName[128];
    char     szData[256];
    DWORD    cbSize, dwType;
    BOOL     bRet = FALSE;
    
    wsprintf(szAppKey, "%s\\%s",
             "System\\CurrentControlSet\\Control\\Session Manager\\AppCompatibility",
             pszApp);
    
    status = RegOpenKey(HKEY_LOCAL_MACHINE,
                        szAppKey,
                        &hkey);

    if (status != ERROR_SUCCESS) {
        LogMsg("Failed to open registry key %s\n", szAppKey);
        return FALSE;
    }
    
    wsprintf(szShimValueName, "DllPatch-%s", pszShim);
    
    cbSize = 256;
    status = RegQueryValueEx(hkey,
                             szShimValueName,
                             NULL,
                             &dwType,
                             (LPBYTE)szData,
                             &cbSize);
    
    if (status != ERROR_SUCCESS || dwType != REG_SZ || cbSize >= 256) {
        LogMsg("Error reading key %s\n", szShimValueName);
        goto Cleanup;
    }
    
    status = RegDeleteValue(hkey, szShimValueName);
    
    if (status != ERROR_SUCCESS) {
        LogMsg("Couldn't delete key %s\n", szShimValueName);
        goto Cleanup;
    }
    
    wsprintf(szShimValueName, "-DllPatch-%s", pszShim);

    status = RegSetValueEx(hkey,
                           szShimValueName,
                           0,
                           REG_SZ,
                           (LPBYTE)szData,
                           cbSize);
    
    if (status != ERROR_SUCCESS) {
        LogMsg("Couldn't set value key %s\n", szShimValueName);
        goto Cleanup;
    }
    
    bRet = TRUE;

Cleanup:    
    RegCloseKey(hkey);
    return bRet;
}

BOOL
DeleteShim_Win2000(
    char* pszApp,
    char* pszShim)
{
    LONG     status;
    HKEY     hkey;
    char     szAppKey[128];
    char     szShimValueName[128];
    
    wsprintf(szAppKey, "%s\\%s",
             "System\\CurrentControlSet\\Control\\Session Manager\\AppCompatibility",
             pszApp);
    
    status = RegOpenKey(HKEY_LOCAL_MACHINE,
                        szAppKey,
                        &hkey);

    if (status != ERROR_SUCCESS) {
        LogMsg("Failed to open registry key %s\n", szAppKey);
        return FALSE;
    }
    
    wsprintf(szShimValueName, "DllPatch-%s", pszShim);
    status = RegDeleteValue(hkey, szShimValueName);
    
    wsprintf(szShimValueName, "-DllPatch-%s", pszShim);
    status = RegDeleteValue(hkey, szShimValueName);
    
    RegCloseKey(hkey);
    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\appcompat\tools\acfileattr\attr.h ===
#ifndef _ATTR_H
#define _ATTR_H

#include "windows.h"

#include "acFileAttr.h"

#if DBG
    void LogMsgDbg(LPSTR pszFmt, ...);
    
    #define LogMsg  LogMsgDbg
#else
    #define LogMsg
#endif // DBG

struct tagFILEATTR;
struct tagFILEATTRMGR;

typedef struct tagFILEATTRVALUE {
    char*           pszValue;           // allocated
    DWORD           dwFlags;
    DWORD           dwValue;            // in case it has a DWORD value
    WORD            wValue[4];          // for Bin Ver cases
    WORD            wMask[4];           // for mask Bin Ver cases
} FILEATTRVALUE, *PFILEATTRVALUE;

typedef struct tagVERSION_STRUCT {
    PSTR                pszFile;                // the name of the file
    UINT                dwSize;                 // the size of the version structure
    PBYTE               VersionBuffer;          // the buffer filled by GetFileVersionInfo
    VS_FIXEDFILEINFO*   FixedInfo;
    UINT                FixedInfoSize;

} VERSION_STRUCT, *PVERSION_STRUCT;

typedef struct tagFILEATTRMGR {

    FILEATTRVALUE   arrAttr[VTID_LASTID - 2];
    VERSION_STRUCT  ver;
    BOOL            bInitialized;

} FILEATTRMGR, *PFILEATTRMGR;


typedef BOOL (*PFNQUERYVALUE)(PFILEATTRMGR pMgr, PFILEATTRVALUE pFileAttr);
typedef int  (*PFNBLOBTOSTRING)(BYTE* pBlob, char* pszOut);
typedef int  (*PFNDUMPTOBLOB)(DWORD dwId, PFILEATTRVALUE pFileAttr, BYTE* pBlob);

#define ATTR_FLAG_AVAILABLE     0x00000001
#define ATTR_FLAG_SELECTED      0x00000002

typedef struct tagFILEATTR {
    DWORD           dwId;
    char*           pszDisplayName;
    char*           pszNameXML;
    PFNQUERYVALUE   QueryValue;
    PFNBLOBTOSTRING BlobToString;
    PFNDUMPTOBLOB   DumpToBlob;
} FILEATTR, *PFILEATTR;



// query functions

BOOL QueryFileSize(PFILEATTRMGR pMgr, PFILEATTRVALUE pFileAttr);
BOOL QueryModuleType(PFILEATTRMGR pMgr, PFILEATTRVALUE pFileAttr);
BOOL QueryBinFileVer(PFILEATTRMGR pMgr, PFILEATTRVALUE pFileAttr);
BOOL QueryBinProductVer(PFILEATTRMGR pMgr, PFILEATTRVALUE pFileAttr);
BOOL QueryFileDateHi(PFILEATTRMGR pMgr, PFILEATTRVALUE pFileAttr);
BOOL QueryFileDateLo(PFILEATTRMGR pMgr, PFILEATTRVALUE pFileAttr);
BOOL QueryFileVerOs(PFILEATTRMGR pMgr, PFILEATTRVALUE pFileAttr);
BOOL QueryFileVerType(PFILEATTRMGR pMgr, PFILEATTRVALUE pFileAttr);
BOOL QueryFileCheckSum(PFILEATTRMGR pMgr, PFILEATTRVALUE pFileAttr);
BOOL QueryFilePECheckSum(PFILEATTRMGR pMgr, PFILEATTRVALUE pFileAttr);
BOOL QueryCompanyName(PFILEATTRMGR pMgr, PFILEATTRVALUE pFileAttr);
BOOL QueryProductVersion(PFILEATTRMGR pMgr, PFILEATTRVALUE pFileAttr);
BOOL QueryProductName(PFILEATTRMGR pMgr, PFILEATTRVALUE pFileAttr);
BOOL QueryFileDescription(PFILEATTRMGR pMgr, PFILEATTRVALUE pFileAttr);
BOOL QueryFileVersion(PFILEATTRMGR pMgr, PFILEATTRVALUE pFileAttr);
BOOL QueryOriginalFileName(PFILEATTRMGR pMgr, PFILEATTRVALUE pFileAttr);
BOOL QueryInternalName(PFILEATTRMGR pMgr, PFILEATTRVALUE pFileAttr);
BOOL QueryLegalCopyright(PFILEATTRMGR pMgr, PFILEATTRVALUE pFileAttr);
BOOL Query16BitDescription(PFILEATTRMGR pMgr, PFILEATTRVALUE pFileAttr);


// dumping to blob functions

int DumpDWORD(DWORD dwId, PFILEATTRVALUE pFileAttr, BYTE* pBlob);
int DumpBinVer(DWORD dwId, PFILEATTRVALUE pFileAttr, BYTE* pBlob);
int DumpString(DWORD dwId, PFILEATTRVALUE pFileAttr, BYTE* pBlob);
int DumpUpToBinVer(DWORD dwId, PFILEATTRVALUE pFileAttr, BYTE* pBlob);



// blob to string functions:

int BlobToStringDWORD(BYTE* pBlob, char* pszOut);
int BlobToStringLong(BYTE* pBlob, char* pszOut);
int BlobToStringBinVer(BYTE* pBlob, char* pszOut);
int BlobToStringString(BYTE* pBlob, char* pszOut);
int BlobToStringUpToBinVer(BYTE* pBlob, char* pszOut);



#endif // _ATTR_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\appcompat\tools\acfileattr\acfileattr.c ===
#include "acFileAttr.h"
#include "attr.h"
#include "version.h"

#include <assert.h>

extern FILEATTR g_arrFileAttr[];

LPVOID
Alloc(
    SIZE_T cbSize)
{
    return HeapAlloc(GetProcessHeap(), 0, cbSize);
}

BOOL
Free(
    LPVOID p)
{
    return HeapFree(GetProcessHeap(), 0, p);
}



BOOL APIENTRY
DllMain(
    HANDLE hModule, 
    DWORD  ul_reason, 
    LPVOID lpReserved)
{
    return TRUE;
}

VOID
CleanupFileManager(
    PFILEATTRMGR pMgr)
{
    int i;

    for (i = 0; i < VTID_LASTID - 2; i++) {
        Free(pMgr->arrAttr[i].pszValue);
        
        pMgr->arrAttr[i].pszValue = NULL;
        
        pMgr->arrAttr[i].dwFlags = 0;
        pMgr->arrAttr[i].dwValue = 0;
    }
    DeleteVersionStruct(&pMgr->ver);

    Free(pMgr);
}

HANDLE
ReadFileAttributes(
    LPCSTR pszFile,
    int*   pnCount
    )
{
    int i;
    
    PFILEATTRMGR pMgr = (PFILEATTRMGR)Alloc(sizeof(FILEATTRMGR));

    if (pMgr == NULL) {
        LogMsg("ReadFileAttributes: Failed to allocate %d bytes\n",
               sizeof(FILEATTRMGR));
        *pnCount = 0;
        return NULL;
    }

    ZeroMemory(pMgr, sizeof(FILEATTRMGR));
    
    pMgr->ver.pszFile = (PSTR)pszFile;
    
    // initialize the version information

    InitVersionStruct(&pMgr->ver);

    // query the values for each attribute

    for (i = 0; i < VTID_LASTID - 2; i++) {
        g_arrFileAttr[i].QueryValue(pMgr, pMgr->arrAttr + i);
    }

    // Post processing
    
    if (pMgr->arrAttr[VTID_FILEDATEHI - VTID_REQFILE - 1].dwValue == 0 &&
        pMgr->arrAttr[VTID_FILEDATELO - VTID_REQFILE - 1].dwValue == 0) {

        pMgr->arrAttr[VTID_FILEDATEHI - VTID_REQFILE - 1].dwFlags = 0;
        pMgr->arrAttr[VTID_FILEDATELO - VTID_REQFILE - 1].dwFlags = 0;
    }

    // mark that the initialization was successful

    pMgr->bInitialized = TRUE;

    *pnCount = i;
    
    return pMgr;
}

int
GetAttrIndex(
    DWORD Id)
{
    int nInd;

    for (nInd = 0; nInd < VTID_LASTID - 2; nInd++) {
        if (g_arrFileAttr[nInd].dwId == Id) {
            return nInd;
        }
    }
    return -1;
}

DWORD
GetAttrId(
    int nAttrInd)
{
    return g_arrFileAttr[nAttrInd].dwId;
}


BOOL
IsAttrAvailable(
    HANDLE hFileMgr,
    int    nAttrInd)
{
    PFILEATTRMGR pMgr = (PFILEATTRMGR)hFileMgr;

    return (pMgr->arrAttr[nAttrInd].dwFlags & ATTR_FLAG_AVAILABLE);
}

PSTR
GetAttrName(
    int nAttrInd)
{
    return g_arrFileAttr[nAttrInd].pszDisplayName;
}

PSTR
GetAttrNameXML(
    int nAttrInd)
{
    return g_arrFileAttr[nAttrInd].pszNameXML;
}

PSTR
GetAttrValue(
    HANDLE hFileMgr,
    int    nAttrInd)
{
    PFILEATTRMGR pMgr = (PFILEATTRMGR)hFileMgr;

    return pMgr->arrAttr[nAttrInd].pszValue;
}

BOOL
SelectAttr(
    HANDLE hFileMgr,
    int    nAttrInd,
    BOOL   bSelect)
{
    PFILEATTRMGR pMgr = (PFILEATTRMGR)hFileMgr;

    if (!(pMgr->arrAttr[nAttrInd].dwFlags & ATTR_FLAG_AVAILABLE)) {
        LogMsg("Attribute %s not available. Cannot be selected\n",
               g_arrFileAttr[nAttrInd].pszDisplayName);
        return FALSE;
    }
    
    if (bSelect) {
        pMgr->arrAttr[nAttrInd].dwFlags |= ATTR_FLAG_SELECTED;
    } else {
        pMgr->arrAttr[nAttrInd].dwFlags &= ~ATTR_FLAG_SELECTED;
    }
    
    return TRUE;
}

BOOL
IsAttrSelected(
    HANDLE hFileMgr,
    int    nAttrInd)
{
    PFILEATTRMGR pMgr = (PFILEATTRMGR)hFileMgr;

    return (pMgr->arrAttr[nAttrInd].dwFlags & ATTR_FLAG_SELECTED);
}

int
Dump(
    HANDLE hFileMgr,
    int    nAttrInd,
    BYTE*  pBlob)
{
    PFILEATTRMGR pMgr = (PFILEATTRMGR)hFileMgr;

    return g_arrFileAttr[nAttrInd].DumpToBlob(nAttrInd + VTID_REQFILE + 1,
                                              pMgr->arrAttr + nAttrInd,
                                              pBlob);
}

BOOL
BlobToString(
    BYTE* pBlob,
    DWORD cbSize,
    char* pszBuff)
{
    
    DWORD attrId;
    DWORD cbRet;

    pszBuff += lstrlen(pszBuff);
    
    attrId = *(DWORD*)pBlob;
    
    while (attrId) {

        if (attrId >= VTID_LASTID) {
            LogMsg("Unsupported attribute %d\n", attrId);
            return FALSE;
        }

        if (attrId == VTID_REQFILE) {

            pBlob += sizeof(DWORD);
            
            cbRet = *(DWORD*)pBlob;
            
            if (!cbRet) {
                // should never happen
                cbRet = 1;
            }
            pBlob += sizeof(DWORD);

            wsprintf(pszBuff, "\r\nAttributes for %ws:\r\n", pBlob);
            pszBuff += lstrlen(pszBuff);
            
            pBlob += cbRet;

        } else {

            wsprintf(pszBuff, "  %-22s   ", g_arrFileAttr[attrId - VTID_REQFILE - 1].pszDisplayName);
            pszBuff += lstrlen(pszBuff);
            
            pBlob += sizeof(DWORD);
        
            cbRet = g_arrFileAttr[attrId - VTID_REQFILE - 1].BlobToString(pBlob, pszBuff);

            pszBuff += lstrlen(pszBuff);
            pBlob += cbRet;
        }
        attrId = *(DWORD*)pBlob;
    }
    
    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\appcompat\tools\acfileattr\acfileattr.h ===
#ifndef _ACFILEATTR_H
#define _ACFILEATTR_H

#include "windows.h"

//
// These are the attribute IDs for all the attributes
//
// Do not change any values in this enum. You can only add new values
// immediately above VTID_LASTID
//
typedef enum {
    VTID_BAD_VTID           = 0,    // do not use or change !!!
    VTID_REQFILE            = 1,    // this should never change !!!
    VTID_FILESIZE           = VTID_REQFILE + 1,
    VTID_EXETYPE            = VTID_REQFILE + 2,
    VTID_BINFILEVER         = VTID_REQFILE + 3,
    VTID_BINPRODUCTVER      = VTID_REQFILE + 4,
    VTID_FILEDATEHI         = VTID_REQFILE + 5,
    VTID_FILEDATELO         = VTID_REQFILE + 6,
    VTID_FILEVEROS          = VTID_REQFILE + 7,
    VTID_FILEVERTYPE        = VTID_REQFILE + 8,
    VTID_CHECKSUM           = VTID_REQFILE + 9,
    VTID_PECHECKSUM         = VTID_REQFILE +10,
    VTID_COMPANYNAME        = VTID_REQFILE +11,
    VTID_PRODUCTVERSION     = VTID_REQFILE +12,
    VTID_PRODUCTNAME        = VTID_REQFILE +13,
    VTID_FILEDESCRIPTION    = VTID_REQFILE +14,
    VTID_FILEVERSION        = VTID_REQFILE +15,
    VTID_ORIGINALFILENAME   = VTID_REQFILE +16,
    VTID_INTERNALNAME       = VTID_REQFILE +17,
    VTID_LEGALCOPYRIGHT     = VTID_REQFILE +18,
    VTID_16BITDESCRIPTION   = VTID_REQFILE +19,
    VTID_UPTOBINPRODUCTVER  = VTID_REQFILE +20,

    // add new versions here

    VTID_LASTID
};

#ifdef __cplusplus
extern "C"
{
#endif

HANDLE
ReadFileAttributes(
    LPCSTR pszFile,
    int*   pnCount);

VOID
CleanupFileManager(
    HANDLE hFileMgr);

int
GetAttrIndex(
    DWORD Id);

DWORD
GetAttrId(
    int nAttrInd);

BOOL
IsAttrAvailable(
    HANDLE hFileMgr,
    int    nAttrInd);

PSTR
GetAttrName(
    int nAttrInd);

PSTR
GetAttrNameXML(
    int nAttrInd);

PSTR
GetAttrValue(
    HANDLE hFileMgr,
    int    nAttrInd);

BOOL
SelectAttr(
    HANDLE hFileMgr,
    int    nAttrInd,
    BOOL   bSelect);

BOOL
IsAttrSelected(
    HANDLE hFileMgr,
    int    nAttrInd);

int
Dump(
    HANDLE hFileMgr,
    int    nAttrInd,
    BYTE*  pBlob);

BOOL
BlobToString(
    BYTE* pBlob,
    DWORD cbSize,
    char* pszBuff);

#ifdef __cplusplus
}
#endif


LPVOID Alloc(SIZE_T cbSize);
BOOL   Free(LPVOID p);

#endif // _ACFILEATTR_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\appcompat\tools\acfileattr\attr.c ===
#include "acFileAttr.h"
#include "attr.h"
#include "version.h"

#include <assert.h>
#include <imagehlp.h>
#include <stdio.h>

// the global array with all the file attributes

FILEATTR g_arrFileAttr[] =
{
    {VTID_FILESIZE,         "File Size",                    "SIZE",                     QueryFileSize,         BlobToStringLong,       DumpDWORD},
    {VTID_EXETYPE,          "Module Type",                  "MODULETYPE*",              QueryModuleType,       BlobToStringDWORD,      DumpDWORD},
    {VTID_BINFILEVER,       "Binary File Version",          "BIN_FILE_VERSION",         QueryBinFileVer,       BlobToStringBinVer,     DumpBinVer},
    {VTID_BINPRODUCTVER,    "Binary Product Version",       "BIN_PRODUCT_VERSION",      QueryBinProductVer,    BlobToStringBinVer,     DumpBinVer},
    {VTID_FILEDATEHI,       "File Date (HI)",               "VERFILEDATEHI",            QueryFileDateHi,       BlobToStringDWORD,      DumpDWORD},
    {VTID_FILEDATELO,       "File Date (LO)",               "VERFILEDATELO",            QueryFileDateLo,       BlobToStringDWORD,      DumpDWORD},
    {VTID_FILEVEROS,        "File OS Version",              "VERFILEOS",                QueryFileVerOs,        BlobToStringDWORD,      DumpDWORD},
    {VTID_FILEVERTYPE,      "File Type",                    "VERFILETYPE",              QueryFileVerType,      BlobToStringDWORD,      DumpDWORD},
    {VTID_CHECKSUM,         "File CheckSum",                "CHECKSUM",                 QueryFileCheckSum,     BlobToStringDWORD,      DumpDWORD},
    {VTID_PECHECKSUM,       "File Header CheckSum",         "PECHECKSUM",               QueryFilePECheckSum,   BlobToStringDWORD,      DumpDWORD},
    {VTID_COMPANYNAME,      "Company Name",                 "COMPANY_NAME",             QueryCompanyName,      BlobToStringString,     DumpString},
    {VTID_PRODUCTVERSION,   "Product Version",              "PRODUCT_VERSION",          QueryProductVersion,   BlobToStringString,     DumpString},
    {VTID_PRODUCTNAME,      "Product Name",                 "PRODUCT_NAME",             QueryProductName,      BlobToStringString,     DumpString},
    {VTID_FILEDESCRIPTION,  "File Description",             "FILE_DESCRIPTION",         QueryFileDescription,  BlobToStringString,     DumpString},
    {VTID_FILEVERSION,      "File Version",                 "FILEVERSION",              QueryFileVersion,      BlobToStringString,     DumpString},
    {VTID_ORIGINALFILENAME, "Original File Name",           "ORIGINALFILENAME",         QueryOriginalFileName, BlobToStringString,     DumpString},
    {VTID_INTERNALNAME,     "Internal Name",                "INTERNALNAME",             QueryInternalName,     BlobToStringString,     DumpString},
    {VTID_LEGALCOPYRIGHT,   "Legal Copyright",              "LEGALCOPYRIGHT",           QueryLegalCopyright,   BlobToStringString,     DumpString},
    {VTID_16BITDESCRIPTION, "16 Bit Description",           "S16BITDESCRIPTION",        Query16BitDescription, BlobToStringString,     DumpString},
    {VTID_UPTOBINPRODUCTVER,"Up To Binary Product Version", "UPTO_BIN_PRODUCT_VERSION", QueryBinProductVer,    BlobToStringUpToBinVer, DumpUpToBinVer}
};

#define FAIL_IF_NO_VERSION()                                            \
{                                                                       \
    if (pMgr->ver.FixedInfoSize < sizeof(VS_FIXEDFILEINFO)) {           \
        LogMsg("No version info\n");                                    \
        return FALSE;                                                   \
    }                                                                   \
}

#define ALLOC_VALUE_AND_RETURN()                                        \
{                                                                       \
    pFileAttr->pszValue = (PSTR)Alloc(lstrlen(szBuffer) + 1);           \
                                                                        \
    if (pFileAttr->pszValue == NULL) {                                  \
        LogMsg("QueryAttr: memory allocation error\n");                 \
        return FALSE;                                                   \
    }                                                                   \
                                                                        \
    lstrcpy(pFileAttr->pszValue, szBuffer);                             \
                                                                        \
    pFileAttr->dwFlags = ATTR_FLAG_AVAILABLE;                           \
                                                                        \
    return TRUE;                                                        \
}

#define QUERYENTRY(szEntryName)                                         \
{                                                                       \
    pFileAttr->pszValue = QueryVersionEntry(&pMgr->ver, szEntryName);   \
                                                                        \
    if (pFileAttr->pszValue == NULL) {                                  \
        LogMsg("QueryEntry: attribute %s N/A\n", szEntryName);          \
        return FALSE;                                                   \
    }                                                                   \
    pFileAttr->dwFlags = ATTR_FLAG_AVAILABLE;                           \
                                                                        \
    return TRUE;                                                        \
}

#if DBG

void LogMsgDbg(
    LPSTR pszFmt, ... )
{
    CHAR gszT[1024];
    va_list arglist;

    va_start(arglist, pszFmt);
    _vsnprintf(gszT, 1023, pszFmt, arglist);
    gszT[1023] = 0;
    va_end(arglist);
    
    OutputDebugString(gszT);
}

#endif // DBG


// dump to blob functions

int
DumpDWORD(
    DWORD          dwId,
    PFILEATTRVALUE pFileAttr,
    BYTE*          pBlob)
{
    *(DWORD*)pBlob = dwId;

    pBlob += sizeof(DWORD);

    *(DWORD*)pBlob = sizeof(DWORD);

    pBlob += sizeof(DWORD);

    *(DWORD*)pBlob = pFileAttr->dwValue;
    return (3 * sizeof(DWORD));
}

int
DumpString(
    DWORD          dwId,
    PFILEATTRVALUE pFileAttr,
    BYTE*          pBlob)
{
    int   strLen, nWideChars;
    WCHAR wszOut[256];

    strLen = lstrlen(pFileAttr->pszValue);
    
    nWideChars = MultiByteToWideChar(
                    CP_ACP,
                    0,
                    pFileAttr->pszValue,
                    strLen,
                    wszOut,
                    256);
                
    wszOut[nWideChars] = 0;

    *(DWORD*)pBlob = dwId;

    pBlob += sizeof(DWORD);

    *(DWORD*)pBlob = (nWideChars + 1) * sizeof(WCHAR);

    pBlob += sizeof(DWORD);

    CopyMemory(pBlob, wszOut, (nWideChars + 1) * sizeof(WCHAR));
    
    return (2 * sizeof(DWORD) + (nWideChars + 1) * sizeof(WCHAR));
}

int
DumpBinVer(
    DWORD          dwId,
    PFILEATTRVALUE pFileAttr,
    BYTE*          pBlob)
{
    *(DWORD*)pBlob = dwId;

    pBlob += sizeof(DWORD);

    *(DWORD*)pBlob = 8 * sizeof(WORD);

    pBlob += sizeof(DWORD);

    CopyMemory(pBlob, pFileAttr->wValue, 4 * sizeof(WORD));

    pBlob += (4 * sizeof(WORD));

    CopyMemory(pBlob, pFileAttr->wMask, 4 * sizeof(WORD));
    
    return (8 * sizeof(WORD) + 2 * sizeof(DWORD));
}

int
DumpUpToBinVer(
    DWORD          dwId,
    PFILEATTRVALUE pFileAttr,
    BYTE*          pBlob)
{
    *(DWORD*)pBlob = dwId;

    pBlob += sizeof(DWORD);

    *(DWORD*)pBlob = 4 * sizeof(WORD);

    pBlob += sizeof(DWORD);

    CopyMemory(pBlob, pFileAttr->wValue, 4 * sizeof(WORD));

    return (4 * sizeof(WORD) + 2 * sizeof(DWORD));
}


// blob to string functions

int
BlobToStringBinVer(
    BYTE* pBlob,
    char* pszOut)
{
    DWORD dwSize;
    
    // read the size first
    dwSize = *(DWORD*)pBlob;

    if (dwSize != 8 * sizeof(WORD)) {
        LogMsg("BlobToStringBinVer: invalid blob\n");
        return -1;
    }

    pBlob += sizeof(DWORD);
        
    wsprintf(pszOut, "Ver %d.%d.%d.%d Mask %04X.%04X.%04X.%04X\r\n",
             *((WORD*)pBlob + 3),
             *((WORD*)pBlob + 2),
             *((WORD*)pBlob + 1),
             *((WORD*)pBlob + 0),
             *((WORD*)pBlob + 7),
             *((WORD*)pBlob + 6),
             *((WORD*)pBlob + 5),
             *((WORD*)pBlob + 4));

    return sizeof(DWORD) + 8 * sizeof(WORD);
}

int
BlobToStringUpToBinVer(
    BYTE* pBlob,
    char* pszOut)
{
    DWORD dwSize;
    
    // read the size first
    dwSize = *(DWORD*)pBlob;

    if (dwSize != 4 * sizeof(WORD)) {
        LogMsg("BlobToStringUpToBinVer: invalid blob\n");
        return -1;
    }

    pBlob += sizeof(DWORD);
        
    wsprintf(pszOut, "Ver %d.%d.%d.%d\r\n",
             *((WORD*)pBlob + 3),
             *((WORD*)pBlob + 2),
             *((WORD*)pBlob + 1),
             *((WORD*)pBlob + 0));

    return sizeof(DWORD) + 4 * sizeof(WORD);
}

int
BlobToStringDWORD(
    BYTE* pBlob,
    char* pszOut)
{
    DWORD dwSize;
    
    // read the size first
    dwSize = *(DWORD*)pBlob;

    if (dwSize != sizeof(DWORD)) {
        LogMsg("BlobToStringDWORD: invalid blob\n");
        return -1;
    }
    
    pBlob += sizeof(DWORD);
        
    wsprintf(pszOut, "0x%X\r\n", *(DWORD*)pBlob);
    
    return 2 * sizeof(DWORD);
}

int
BlobToStringLong(
    BYTE* pBlob,
    char* pszOut)
{
    DWORD dwSize;
    
    // read the size first
    dwSize = *(DWORD*)pBlob;

    if (dwSize != sizeof(DWORD)) {
        LogMsg("BlobToStringLong: invalid blob\n");
        return -1;
    }
    
    pBlob += sizeof(DWORD);
        
    wsprintf(pszOut, "%d\r\n", *(ULONG*)pBlob);
    
    return 2 * sizeof(DWORD);
}

int
BlobToStringString(
    BYTE* pBlob,
    char* pszOut)
{
    DWORD dwSize;
    
    // read the size first
    dwSize = *(DWORD*)pBlob;

    pBlob += sizeof(DWORD);

    WideCharToMultiByte(
                CP_ACP,
                0,
                (LPCWSTR)pBlob,
                (int)dwSize,
                pszOut,
                (int)dwSize,
                NULL,
                NULL);
    
    lstrcat(pszOut, "\r\n");
    
    return sizeof(DWORD) + (int)dwSize;
}


// query functions

BOOL
QueryFileSize(
    PFILEATTRMGR   pMgr, 
    PFILEATTRVALUE pFileAttr)
{
    char            szBuffer[64];
    HANDLE          findHandle;
    WIN32_FIND_DATA findData;

    findHandle = FindFirstFile(pMgr->ver.pszFile, &findData);
    
    if (findHandle == INVALID_HANDLE_VALUE) {
        LogMsg("QueryFileSize: file not found\n");
        return FALSE;
    }
    
    pFileAttr->dwValue = findData.nFileSizeLow;
    
    FindClose(findHandle);

    wsprintf(szBuffer, "%d", pFileAttr->dwValue);
    
    ALLOC_VALUE_AND_RETURN();
}

BOOL
QueryModuleType(
    PFILEATTRMGR   pMgr, 
    PFILEATTRVALUE pFileAttr)
{
    // not implemented
    
    return FALSE;
}

BOOL
QueryBinFileVer(
    PFILEATTRMGR   pMgr, 
    PFILEATTRVALUE pFileAttr)
{
    ULONGLONG binFileVer;
    char      szBuffer[64];

    FAIL_IF_NO_VERSION();
    
    *((PDWORD)(&binFileVer)) = pMgr->ver.FixedInfo->dwFileVersionLS;
    *(((PDWORD)(&binFileVer)) + 1) = pMgr->ver.FixedInfo->dwFileVersionMS;

    CopyMemory(pFileAttr->wValue, &binFileVer, 4 * sizeof(WORD));
    
    wsprintf(szBuffer, "%d.%d.%d.%d",
             pFileAttr->wValue[3],
             pFileAttr->wValue[2],
             pFileAttr->wValue[1],
             pFileAttr->wValue[0]);
    
    pFileAttr->wMask[0] = pFileAttr->wMask[1] = pFileAttr->wMask[2] = pFileAttr->wMask[3] = 0xFFFF;
    
    ALLOC_VALUE_AND_RETURN();
}

BOOL
QueryBinProductVer(
    PFILEATTRMGR   pMgr, 
    PFILEATTRVALUE pFileAttr)
{
    ULONGLONG binProdVer;
    char      szBuffer[64];

    FAIL_IF_NO_VERSION();
    
    *((PDWORD)(&binProdVer)) = pMgr->ver.FixedInfo->dwProductVersionLS;
    *(((PDWORD)(&binProdVer)) + 1) = pMgr->ver.FixedInfo->dwProductVersionMS;

    CopyMemory(pFileAttr->wValue, &binProdVer, 4 * sizeof(WORD));
    
    wsprintf(szBuffer, "%d.%d.%d.%d",
             pFileAttr->wValue[3],
             pFileAttr->wValue[2],
             pFileAttr->wValue[1],
             pFileAttr->wValue[0]);
    
    pFileAttr->wMask[0] = pFileAttr->wMask[1] = pFileAttr->wMask[2] = pFileAttr->wMask[3] = 0xFFFF;
    
    ALLOC_VALUE_AND_RETURN();
}

BOOL
QueryFileDateHi(
    PFILEATTRMGR   pMgr, 
    PFILEATTRVALUE pFileAttr)
{
    char szBuffer[64];

    FAIL_IF_NO_VERSION();
    
    pFileAttr->dwValue = pMgr->ver.FixedInfo->dwFileDateMS;

    wsprintf(szBuffer, "0x%X", pFileAttr->dwValue);
    
    ALLOC_VALUE_AND_RETURN();
}

BOOL
QueryFileDateLo(
    PFILEATTRMGR   pMgr, 
    PFILEATTRVALUE pFileAttr)
{
    char szBuffer[64];

    FAIL_IF_NO_VERSION();
    
    pFileAttr->dwValue = pMgr->ver.FixedInfo->dwFileDateLS;

    wsprintf(szBuffer, "0x%X", pFileAttr->dwValue);
    
    ALLOC_VALUE_AND_RETURN();
}

BOOL
QueryFileVerOs(
    PFILEATTRMGR   pMgr, 
    PFILEATTRVALUE pFileAttr)
{
    char szBuffer[64];

    FAIL_IF_NO_VERSION();
    
    pFileAttr->dwValue = pMgr->ver.FixedInfo->dwFileOS;

    wsprintf(szBuffer, "0x%X", pFileAttr->dwValue);
    
    ALLOC_VALUE_AND_RETURN();
}

BOOL QueryFileVerType(
    PFILEATTRMGR   pMgr, 
    PFILEATTRVALUE pFileAttr)
{
    char szBuffer[64];

    FAIL_IF_NO_VERSION();
    
    pFileAttr->dwValue = pMgr->ver.FixedInfo->dwFileType;

    wsprintf(szBuffer, "0x%X", pFileAttr->dwValue);
    
    ALLOC_VALUE_AND_RETURN();
}

// ComputeFileCheckSum
//
//   computes the check sum for 4096 bytes starting at offset 512.
//   The offset and the size of the chunk are modified if the
//   file size is too small.
DWORD
ComputeFileCheckSum(
    PSTR             pszFile,
    WIN32_FIND_DATA* pFindData)
{
    INT    i,size     = 4096;
    DWORD  startAddr  = 512;
    HANDLE fileHandle = INVALID_HANDLE_VALUE;
    PCHAR  buffer     = NULL;
    DWORD  checkSum   = 0;
    DWORD  dontCare;

    if (pFindData->nFileSizeLow < (ULONG)size) {
        //
        // File size is less than 4096. We set the start address to 0 and set the size for the checksum
        // to the actual file size.
        //
        startAddr = 0;
        size = pFindData->nFileSizeLow;
    
    } else if (startAddr + size > pFindData->nFileSizeLow) {
        //
        // File size is too small. We set the start address so that size of checksum can be 4096 bytes
        //
        startAddr = pFindData->nFileSizeLow - size;
    }
    
    if (size <= 3) {
        //
        // we need at least 3 bytes to be able to do something here.
        //
        return 0;
    }
    
    __try {
        buffer = (PCHAR)HeapAlloc(GetProcessHeap(), 0, size);
        
        if (buffer == NULL) {
            __leave;
        }
        
        fileHandle = CreateFile(pszFile,
                                GENERIC_READ,
                                FILE_SHARE_READ,
                                NULL,
                                OPEN_EXISTING,
                                0,
                                NULL);
        
        if (fileHandle == INVALID_HANDLE_VALUE) {
            __leave;
        }

        if (SetFilePointer(fileHandle, startAddr, NULL, FILE_BEGIN) != startAddr) {
            __leave;
        }

        if (!ReadFile(fileHandle, buffer, size, &dontCare, NULL)) {
            __leave;
        }
        
        for (i = 0; i<(size - 3); i+=4) {
            checkSum += *((PDWORD) (buffer + i));
            checkSum = _rotr(checkSum ,1);
        }
    }
    __finally {
        if (fileHandle != INVALID_HANDLE_VALUE) {
            CloseHandle (fileHandle);
        }
        if (buffer != NULL) {
            HeapFree(GetProcessHeap(), 0, buffer);
        }
    }
    return checkSum;
}


BOOL QueryFileCheckSum(
    PFILEATTRMGR   pMgr, 
    PFILEATTRVALUE pFileAttr)
{
    WIN32_FIND_DATA findData;
    HANDLE          findHandle;
    char            szBuffer[64];

    findHandle = FindFirstFile(pMgr->ver.pszFile, &findData);
    
    if (findHandle == INVALID_HANDLE_VALUE) {

        LogMsg("QueryFileCheckSum: Cannot find file %s\n",
               pMgr->ver.pszFile);
        
        return FALSE;
    }
    
    pFileAttr->dwValue = ComputeFileCheckSum(pMgr->ver.pszFile, &findData);
    
    FindClose(findHandle);

    wsprintf(szBuffer, "0x%X", pFileAttr->dwValue);
    
    ALLOC_VALUE_AND_RETURN();
}

// GetImageNtHeader
//
//   This function returns the address of the NT Header.
//   Returns the address of the NT Header.
PIMAGE_NT_HEADERS
GetImageNtHeader(
    IN PVOID Base)
{
    PIMAGE_NT_HEADERS NtHeaders;

    if (Base != NULL && Base != (PVOID)-1) {
        if (((PIMAGE_DOS_HEADER)Base)->e_magic == IMAGE_DOS_SIGNATURE) {
            NtHeaders = (PIMAGE_NT_HEADERS)((PCHAR)Base + ((PIMAGE_DOS_HEADER)Base)->e_lfanew);
            if (NtHeaders->Signature == IMAGE_NT_SIGNATURE) {
                return NtHeaders;
            }
        }
    }
    
    return NULL;
}

BOOL
GetHeaderCheckSum(
    PFILEATTRMGR pMgr,
    DWORD* pdwCheckSum)
{
    HANDLE              fileHandle;
    DWORD               bytesRead;
    IMAGE_DOS_HEADER    dh;
    LOADED_IMAGE        image;
    DWORD               sign;
    PWORD               signNE = (PWORD)&sign;
    BOOL                result = FALSE;

    *pdwCheckSum = 0;

    fileHandle = CreateFile(pMgr->ver.pszFile,
                            GENERIC_READ,
                            FILE_SHARE_READ,
                            NULL,
                            OPEN_EXISTING,
                            0,
                            NULL);
    
    if (fileHandle == INVALID_HANDLE_VALUE) {
        return FALSE;
    }
    
    __try {
        __try {
            if (!ReadFile(fileHandle, &dh, sizeof(IMAGE_DOS_HEADER), &bytesRead, NULL) ||
                bytesRead != sizeof (IMAGE_DOS_HEADER)) {
                __leave;
            }
            
            if (dh.e_magic != IMAGE_DOS_SIGNATURE) {
                __leave;
            }
            
            if (SetFilePointer(fileHandle, dh.e_lfanew, NULL, FILE_BEGIN) != (DWORD)dh.e_lfanew) {
                __leave;
            }
            
            if (!ReadFile(fileHandle, &sign, sizeof(DWORD), &bytesRead, NULL) ||
                bytesRead != sizeof (DWORD)) {
                __leave;
            }
            
            CloseHandle(fileHandle);
            fileHandle = INVALID_HANDLE_VALUE;

            if (sign == IMAGE_NT_SIGNATURE) {

                if (MapAndLoad(pMgr->ver.pszFile, NULL, &image, FALSE, TRUE)) {
                    
                    PIMAGE_NT_HEADERS NtHeaders;
                    
                    __try {

                        NtHeaders = GetImageNtHeader(image.MappedAddress);
                        
                        if (NtHeaders != NULL) {
                            if (NtHeaders->OptionalHeader.Magic == IMAGE_NT_OPTIONAL_HDR32_MAGIC) {
                                *pdwCheckSum = ((PIMAGE_NT_HEADERS32)NtHeaders)->OptionalHeader.CheckSum;
                            } else if (NtHeaders->OptionalHeader.Magic == IMAGE_NT_OPTIONAL_HDR64_MAGIC) {
                                *pdwCheckSum = ((PIMAGE_NT_HEADERS64)NtHeaders)->OptionalHeader.CheckSum;
                            }
                            result = TRUE;
                        }
                    }
                    __except (1) {
                        LogMsg("Access violation while examining %s\n", pMgr->ver.pszFile);
                    }

                    UnMapAndLoad(&image);
                }
                
            }
        }
        __finally {
            if (fileHandle != INVALID_HANDLE_VALUE) {
                CloseHandle(fileHandle);
            }
        }
    }
    __except (EXCEPTION_EXECUTE_HANDLER) {
        CloseHandle(fileHandle);
        result = FALSE;
    }
    
    return result;
}

BOOL
QueryFilePECheckSum(
    PFILEATTRMGR   pMgr, 
    PFILEATTRVALUE pFileAttr)
{
    char szBuffer[64];

    if (!GetHeaderCheckSum(pMgr, &pFileAttr->dwValue) || pFileAttr->dwValue == 0) {
        LogMsg("QueryFilePECheckSum: Cannot get the header check sum for %s\n",
               pMgr->ver.pszFile);
        
        return FALSE;
    }
    
    wsprintf(szBuffer, "0x%X", pFileAttr->dwValue);
    
    ALLOC_VALUE_AND_RETURN();
}

BOOL
QueryCompanyName(
    PFILEATTRMGR   pMgr, 
    PFILEATTRVALUE pFileAttr)
{
    FAIL_IF_NO_VERSION();
    QUERYENTRY("COMPANYNAME");
}

BOOL
QueryProductVersion(
    PFILEATTRMGR   pMgr, 
    PFILEATTRVALUE pFileAttr)
{
    FAIL_IF_NO_VERSION();
    QUERYENTRY("PRODUCTVERSION");
}

BOOL
QueryProductName(
    PFILEATTRMGR   pMgr, 
    PFILEATTRVALUE pFileAttr)
{
    FAIL_IF_NO_VERSION();
    QUERYENTRY("PRODUCTNAME");
}

BOOL
QueryFileDescription(
    PFILEATTRMGR   pMgr, 
    PFILEATTRVALUE pFileAttr)
{
    FAIL_IF_NO_VERSION();
    QUERYENTRY("FILEDESCRIPTION");
}

BOOL
QueryFileVersion(
    PFILEATTRMGR   pMgr, 
    PFILEATTRVALUE pFileAttr)
{
    FAIL_IF_NO_VERSION();
    QUERYENTRY("FILEVERSION");
}

BOOL
QueryOriginalFileName(
    PFILEATTRMGR   pMgr, 
    PFILEATTRVALUE pFileAttr)
{
    FAIL_IF_NO_VERSION();
    QUERYENTRY("ORIGINALFILENAME");
}

BOOL
QueryInternalName(
    PFILEATTRMGR   pMgr, 
    PFILEATTRVALUE pFileAttr)
{
    FAIL_IF_NO_VERSION();
    QUERYENTRY("INTERNALNAME");
}

BOOL
QueryLegalCopyright(
    PFILEATTRMGR   pMgr, 
    PFILEATTRVALUE pFileAttr)
{
    FAIL_IF_NO_VERSION();
    QUERYENTRY("LEGALCOPYRIGHT");
}

BOOL
Query16BitDescription(
    PFILEATTRMGR   pMgr, 
    PFILEATTRVALUE pFileAttr)
{
    //char szBuffer[64];
    
    pFileAttr->dwValue = 0;
    //wsprintf(szBuffer, "0x%X", pFileAttr->dwValue);

    return FALSE;
    
    //ALLOC_VALUE_AND_RETURN();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\appcompat\tools\acfileattr\version.c ===
#include "version.h"
#include "acFileAttr.h"

#include <ctype.h>
#include <stdio.h>
#include <stdlib.h>
#include <imagehlp.h>

// InitVersionStruct
//
//   Reads the version information for the specified file
BOOL
InitVersionStruct(
    IN OUT PVERSION_STRUCT pVer)
{
    DWORD dwNull = 0;
    
    //
    // Allocate enough memory for the version stamp
    //

    pVer->dwSize = GetFileVersionInfoSize(pVer->pszFile, &dwNull);
    
    if (pVer->dwSize == 0) {
        LogMsg("File %s does not have version info\n", pVer->pszFile);
        return FALSE;
    }

    pVer->VersionBuffer = (PBYTE)Alloc(pVer->dwSize);
    
    if (pVer->VersionBuffer == NULL) {
        
        LogMsg("InitVersionStruct: failed to allocate %d bytes\n", pVer->dwSize);
        return FALSE;
    }
    
    //
    // Now get the version info from the file
    //

    if (!GetFileVersionInfo(
             pVer->pszFile,
             0,
             pVer->dwSize,
             pVer->VersionBuffer)) {
        
        LogMsg("GetFileVersionInfo failed with 0x%x for file %s\n",
              GetLastError(),
              pVer->pszFile);
        
        DeleteVersionStruct(pVer);
        return FALSE;
    }

    // Extract the fixed info

    VerQueryValue(
        pVer->VersionBuffer,
        "\\",
        (LPVOID*)&pVer->FixedInfo,
        &pVer->FixedInfoSize);

    return TRUE;
}

// DeleteVersionStruct
//
//   Delete all the memory allocated for this version structure
VOID
DeleteVersionStruct(
    IN PVERSION_STRUCT pVer)
{
    if (pVer != NULL && pVer->VersionBuffer != NULL) {
        
        Free(pVer->VersionBuffer);
        pVer->VersionBuffer = NULL;
        
        ZeroMemory(pVer, sizeof(VERSION_STRUCT));
    }
}



static DWORD g_adwLangs[] = {0x000004B0, 0x000004E4, 0x040904B0, 0x040904E4, 0};

#define MAX_VERSION_STRING  256

// QueryVersionEntry
//
//   Queries the file's version structure returning the
//   value for a specific entry
PSTR
QueryVersionEntry(
    IN OUT PVERSION_STRUCT pVer,
    IN     PSTR            pszField)
{
    TCHAR  szTemp[MAX_VERSION_STRING] = "";
    TCHAR* szReturn = NULL;
    int    i;
    UINT   unLen;

    for (i = 0; g_adwLangs[i]; ++i) {

        sprintf(szTemp, "\\StringFileInfo\\%08X\\%s", g_adwLangs[i], pszField);
        
        if (VerQueryValue(pVer->VersionBuffer, szTemp, (PVOID*)&szReturn, &unLen)) {
            char* pszValue;

            pszValue = Alloc(lstrlen(szReturn) + 1);
            
            if (pszValue == NULL) {
                LogMsg("QueryVersionEntry: failed to allocate %d bytes\n",
                       lstrlen(szReturn) + 1);
                return NULL;
            }
            lstrcpy(pszValue, szReturn);
            return pszValue;
        }
    }
    
    return NULL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\appcompat\tools\acfileattr\version.h ===
#ifndef _VERSION_H
#define _VERSION_H

#include "windows.h"
#include "attr.h"

PSTR
QueryVersionEntry(
    IN OUT PVERSION_STRUCT pVer,
    IN     PSTR            pszField);

BOOL
InitVersionStruct(
    IN OUT PVERSION_STRUCT pVer);

VOID
DeleteVersionStruct(
    IN PVERSION_STRUCT pVer);


#endif // _VERSION_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\appcompat\tools\appsearch\afxres.h ===
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) 1992-1998 Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#ifndef __AFXRES_H__
#define __AFXRES_H__

#ifdef RC_INVOKED
#ifndef _INC_WINDOWS
#define _INC_WINDOWS
	#include "winres.h"           // extract from windows header
#endif
#endif

#ifdef _AFX_MINREBUILD
#pragma component(minrebuild, off)
#endif

#ifdef APSTUDIO_INVOKED
#define APSTUDIO_HIDDEN_SYMBOLS
#endif

/////////////////////////////////////////////////////////////////////////////
// MFC resource types (see Technical note TN024 for implementation details)

#ifndef RC_INVOKED
#define RT_DLGINIT  MAKEINTRESOURCE(240)
#define RT_TOOLBAR  MAKEINTRESOURCE(241)
#endif

/////////////////////////////////////////////////////////////////////////////

#ifdef APSTUDIO_INVOKED
#undef APSTUDIO_HIDDEN_SYMBOLS
#endif

/////////////////////////////////////////////////////////////////////////////
// General style bits etc

// ControlBar styles
#define CBRS_ALIGN_LEFT     0x1000L
#define CBRS_ALIGN_TOP      0x2000L
#define CBRS_ALIGN_RIGHT    0x4000L
#define CBRS_ALIGN_BOTTOM   0x8000L
#define CBRS_ALIGN_ANY      0xF000L

#define CBRS_BORDER_LEFT    0x0100L
#define CBRS_BORDER_TOP     0x0200L
#define CBRS_BORDER_RIGHT   0x0400L
#define CBRS_BORDER_BOTTOM  0x0800L
#define CBRS_BORDER_ANY     0x0F00L

#define CBRS_TOOLTIPS       0x0010L
#define CBRS_FLYBY          0x0020L
#define CBRS_FLOAT_MULTI    0x0040L
#define CBRS_BORDER_3D      0x0080L
#define CBRS_HIDE_INPLACE   0x0008L
#define CBRS_SIZE_DYNAMIC   0x0004L
#define CBRS_SIZE_FIXED     0x0002L
#define CBRS_FLOATING       0x0001L

#define CBRS_GRIPPER        0x00400000L

#define CBRS_ORIENT_HORZ    (CBRS_ALIGN_TOP|CBRS_ALIGN_BOTTOM)
#define CBRS_ORIENT_VERT    (CBRS_ALIGN_LEFT|CBRS_ALIGN_RIGHT)
#define CBRS_ORIENT_ANY     (CBRS_ORIENT_HORZ|CBRS_ORIENT_VERT)

#define CBRS_ALL            0x0040FFFFL

// the CBRS_ style is made up of an alignment style and a draw border style
//  the alignment styles are mutually exclusive
//  the draw border styles may be combined
#define CBRS_NOALIGN        0x00000000L
#define CBRS_LEFT           (CBRS_ALIGN_LEFT|CBRS_BORDER_RIGHT)
#define CBRS_TOP            (CBRS_ALIGN_TOP|CBRS_BORDER_BOTTOM)
#define CBRS_RIGHT          (CBRS_ALIGN_RIGHT|CBRS_BORDER_LEFT)
#define CBRS_BOTTOM         (CBRS_ALIGN_BOTTOM|CBRS_BORDER_TOP)

/////////////////////////////////////////////////////////////////////////////
// Standard window components

// Mode indicators in status bar - these are routed like commands
#define ID_INDICATOR_EXT                0xE700  // extended selection indicator
#define ID_INDICATOR_CAPS               0xE701  // cap lock indicator
#define ID_INDICATOR_NUM                0xE702  // num lock indicator
#define ID_INDICATOR_SCRL               0xE703  // scroll lock indicator
#define ID_INDICATOR_OVR                0xE704  // overtype mode indicator
#define ID_INDICATOR_REC                0xE705  // record mode indicator
#define ID_INDICATOR_KANA               0xE706  // kana lock indicator

#define ID_SEPARATOR                    0   // special separator value

#ifndef RC_INVOKED  // code only
// Standard control bars (IDW = window ID)
#define AFX_IDW_CONTROLBAR_FIRST        0xE800
#define AFX_IDW_CONTROLBAR_LAST         0xE8FF

#define AFX_IDW_TOOLBAR                 0xE800  // main Toolbar for window
#define AFX_IDW_STATUS_BAR              0xE801  // Status bar window
#define AFX_IDW_PREVIEW_BAR             0xE802  // PrintPreview Dialog Bar
#define AFX_IDW_RESIZE_BAR              0xE803  // OLE in-place resize bar
#define AFX_IDW_REBAR                   0xE804  // COMCTL32 "rebar" Bar
#define AFX_IDW_DIALOGBAR               0xE805  // CDialogBar

// Note: If your application supports docking toolbars, you should
//  not use the following IDs for your own toolbars.  The IDs chosen
//  are at the top of the first 32 such that the bars will be hidden
//  while in print preview mode, and are not likely to conflict with
//  IDs your application may have used succesfully in the past.

#define AFX_IDW_DOCKBAR_TOP             0xE81B
#define AFX_IDW_DOCKBAR_LEFT            0xE81C
#define AFX_IDW_DOCKBAR_RIGHT           0xE81D
#define AFX_IDW_DOCKBAR_BOTTOM          0xE81E
#define AFX_IDW_DOCKBAR_FLOAT           0xE81F

// Macro for mapping standard control bars to bitmask (limit of 32)
#define AFX_CONTROLBAR_MASK(nIDC)   (1L << (nIDC - AFX_IDW_CONTROLBAR_FIRST))

// parts of Main Frame
#define AFX_IDW_PANE_FIRST              0xE900  // first pane (256 max)
#define AFX_IDW_PANE_LAST               0xE9ff
#define AFX_IDW_HSCROLL_FIRST           0xEA00  // first Horz scrollbar (16 max)
#define AFX_IDW_VSCROLL_FIRST           0xEA10  // first Vert scrollbar (16 max)

#define AFX_IDW_SIZE_BOX                0xEA20  // size box for splitters
#define AFX_IDW_PANE_SAVE               0xEA21  // to shift AFX_IDW_PANE_FIRST
#endif //!RC_INVOKED

#ifndef APSTUDIO_INVOKED

// common style for form views
#define AFX_WS_DEFAULT_VIEW             (WS_CHILD | WS_VISIBLE | WS_BORDER)

#endif //!APSTUDIO_INVOKED

/////////////////////////////////////////////////////////////////////////////
// Standard app configurable strings

// for application title (defaults to EXE name or name in constructor)
#define AFX_IDS_APP_TITLE               0xE000
// idle message bar line
#define AFX_IDS_IDLEMESSAGE             0xE001
// message bar line when in shift-F1 help mode
#define AFX_IDS_HELPMODEMESSAGE         0xE002
// document title when editing OLE embedding
#define AFX_IDS_APP_TITLE_EMBEDDING     0xE003
// company name
#define AFX_IDS_COMPANY_NAME            0xE004
// object name when server is inplace
#define AFX_IDS_OBJ_TITLE_INPLACE       0xE005

/////////////////////////////////////////////////////////////////////////////
// Standard Commands

// File commands
#define ID_FILE_NEW                     0xE100
#define ID_FILE_OPEN                    0xE101
#define ID_FILE_CLOSE                   0xE102
#define ID_FILE_SAVE                    0xE103
#define ID_FILE_SAVE_AS                 0xE104
#define ID_FILE_PAGE_SETUP              0xE105
#define ID_FILE_PRINT_SETUP             0xE106
#define ID_FILE_PRINT                   0xE107
#define ID_FILE_PRINT_DIRECT            0xE108
#define ID_FILE_PRINT_PREVIEW           0xE109
#define ID_FILE_UPDATE                  0xE10A
#define ID_FILE_SAVE_COPY_AS            0xE10B
#define ID_FILE_SEND_MAIL               0xE10C

#define ID_FILE_MRU_FIRST               0xE110
#define ID_FILE_MRU_FILE1               0xE110          // range - 16 max
#define ID_FILE_MRU_FILE2               0xE111
#define ID_FILE_MRU_FILE3               0xE112
#define ID_FILE_MRU_FILE4               0xE113
#define ID_FILE_MRU_FILE5               0xE114
#define ID_FILE_MRU_FILE6               0xE115
#define ID_FILE_MRU_FILE7               0xE116
#define ID_FILE_MRU_FILE8               0xE117
#define ID_FILE_MRU_FILE9               0xE118
#define ID_FILE_MRU_FILE10              0xE119
#define ID_FILE_MRU_FILE11              0xE11A
#define ID_FILE_MRU_FILE12              0xE11B
#define ID_FILE_MRU_FILE13              0xE11C
#define ID_FILE_MRU_FILE14              0xE11D
#define ID_FILE_MRU_FILE15              0xE11E
#define ID_FILE_MRU_FILE16              0xE11F
#define ID_FILE_MRU_LAST                0xE11F

// Edit commands
#define ID_EDIT_CLEAR                   0xE120
#define ID_EDIT_CLEAR_ALL               0xE121
#define ID_EDIT_COPY                    0xE122
#define ID_EDIT_CUT                     0xE123
#define ID_EDIT_FIND                    0xE124
#define ID_EDIT_PASTE                   0xE125
#define ID_EDIT_PASTE_LINK              0xE126
#define ID_EDIT_PASTE_SPECIAL           0xE127
#define ID_EDIT_REPEAT                  0xE128
#define ID_EDIT_REPLACE                 0xE129
#define ID_EDIT_SELECT_ALL              0xE12A
#define ID_EDIT_UNDO                    0xE12B
#define ID_EDIT_REDO                    0xE12C

// Window commands
#define ID_WINDOW_NEW                   0xE130
#define ID_WINDOW_ARRANGE               0xE131
#define ID_WINDOW_CASCADE               0xE132
#define ID_WINDOW_TILE_HORZ             0xE133
#define ID_WINDOW_TILE_VERT             0xE134
#define ID_WINDOW_SPLIT                 0xE135
#ifndef RC_INVOKED      // code only
#define AFX_IDM_WINDOW_FIRST            0xE130
#define AFX_IDM_WINDOW_LAST             0xE13F
#define AFX_IDM_FIRST_MDICHILD          0xFF00  // window list starts here
#endif //!RC_INVOKED

// Help and App commands
#define ID_APP_ABOUT                    0xE140
#define ID_APP_EXIT                     0xE141
#define ID_HELP_INDEX                   0xE142
#define ID_HELP_FINDER                  0xE143
#define ID_HELP_USING                   0xE144
#define ID_CONTEXT_HELP                 0xE145      // shift-F1
// special commands for processing help
#define ID_HELP                         0xE146      // first attempt for F1
#define ID_DEFAULT_HELP                 0xE147      // last attempt

// Misc
#define ID_NEXT_PANE                    0xE150
#define ID_PREV_PANE                    0xE151

// Format
#define ID_FORMAT_FONT                  0xE160

// OLE commands
#define ID_OLE_INSERT_NEW               0xE200
#define ID_OLE_EDIT_LINKS               0xE201
#define ID_OLE_EDIT_CONVERT             0xE202
#define ID_OLE_EDIT_CHANGE_ICON         0xE203
#define ID_OLE_EDIT_PROPERTIES          0xE204
#define ID_OLE_VERB_FIRST               0xE210     // range - 16 max
#ifndef RC_INVOKED      // code only
#define ID_OLE_VERB_LAST                0xE21F
#endif //!RC_INVOKED

// for print preview dialog bar
#define AFX_ID_PREVIEW_CLOSE            0xE300
#define AFX_ID_PREVIEW_NUMPAGE          0xE301      // One/Two Page button
#define AFX_ID_PREVIEW_NEXT             0xE302
#define AFX_ID_PREVIEW_PREV             0xE303
#define AFX_ID_PREVIEW_PRINT            0xE304
#define AFX_ID_PREVIEW_ZOOMIN           0xE305
#define AFX_ID_PREVIEW_ZOOMOUT          0xE306

// View commands (same number used as IDW used for control bar)
#define ID_VIEW_TOOLBAR                 0xE800
#define ID_VIEW_STATUS_BAR              0xE801
#define ID_VIEW_REBAR                   0xE804
#define ID_VIEW_AUTOARRANGE         0xE805
	// E810 -> E81F must be kept in order for RANGE macros
#define ID_VIEW_SMALLICON               0xE810
#define ID_VIEW_LARGEICON               0xE811
#define ID_VIEW_LIST                   0xE812
#define ID_VIEW_DETAILS                 0xE813
#define ID_VIEW_LINEUP                  0xE814
#define ID_VIEW_BYNAME                  0xE815
#define AFX_ID_VIEW_MINIMUM              ID_VIEW_SMALLICON
#define AFX_ID_VIEW_MAXIMUM              ID_VIEW_BYNAME
	// E800 -> E8FF reserved for other control bar commands

// RecordForm commands
#define ID_RECORD_FIRST                 0xE900
#define ID_RECORD_LAST                  0xE901
#define ID_RECORD_NEXT                  0xE902
#define ID_RECORD_PREV                  0xE903

/////////////////////////////////////////////////////////////////////////////
// Standard control IDs

#ifdef IDC_STATIC
#undef IDC_STATIC
#endif
#define IDC_STATIC              (-1)     // all static controls

/////////////////////////////////////////////////////////////////////////////
// Standard string error/warnings

#ifndef RC_INVOKED      // code only
#define AFX_IDS_SCFIRST                 0xEF00
#endif //!RC_INVOKED

#define AFX_IDS_SCSIZE                  0xEF00
#define AFX_IDS_SCMOVE                  0xEF01
#define AFX_IDS_SCMINIMIZE              0xEF02
#define AFX_IDS_SCMAXIMIZE              0xEF03
#define AFX_IDS_SCNEXTWINDOW            0xEF04
#define AFX_IDS_SCPREVWINDOW            0xEF05
#define AFX_IDS_SCCLOSE                 0xEF06
#define AFX_IDS_SCRESTORE               0xEF12
#define AFX_IDS_SCTASKLIST              0xEF13

#define AFX_IDS_MDICHILD                0xEF1F

#define AFX_IDS_DESKACCESSORY           0xEFDA

// General strings
#define AFX_IDS_OPENFILE                0xF000
#define AFX_IDS_SAVEFILE                0xF001
#define AFX_IDS_ALLFILTER               0xF002
#define AFX_IDS_UNTITLED                0xF003
#define AFX_IDS_SAVEFILECOPY            0xF004
#define AFX_IDS_PREVIEW_CLOSE           0xF005
#define AFX_IDS_UNNAMED_FILE            0xF006
#define AFX_IDS_HIDE                    0xF011

// MFC Standard Exception Error messages
#define AFX_IDP_NO_ERROR_AVAILABLE      0xF020
#define AFX_IDS_NOT_SUPPORTED_EXCEPTION 0xF021
#define AFX_IDS_RESOURCE_EXCEPTION      0xF022
#define AFX_IDS_MEMORY_EXCEPTION        0xF023
#define AFX_IDS_USER_EXCEPTION          0xF024

// Printing and print preview strings
#define AFX_IDS_PRINTONPORT             0xF040
#define AFX_IDS_ONEPAGE                 0xF041
#define AFX_IDS_TWOPAGE                 0xF042
#define AFX_IDS_PRINTPAGENUM            0xF043
#define AFX_IDS_PREVIEWPAGEDESC         0xF044
#define AFX_IDS_PRINTDEFAULTEXT         0xF045
#define AFX_IDS_PRINTDEFAULT            0xF046
#define AFX_IDS_PRINTFILTER             0xF047
#define AFX_IDS_PRINTCAPTION            0xF048
#define AFX_IDS_PRINTTOFILE             0xF049


// OLE strings
#define AFX_IDS_OBJECT_MENUITEM         0xF080
#define AFX_IDS_EDIT_VERB               0xF081
#define AFX_IDS_ACTIVATE_VERB           0xF082
#define AFX_IDS_CHANGE_LINK             0xF083
#define AFX_IDS_AUTO                    0xF084
#define AFX_IDS_MANUAL                  0xF085
#define AFX_IDS_FROZEN                  0xF086
#define AFX_IDS_ALL_FILES               0xF087
// dynamically changing menu items
#define AFX_IDS_SAVE_MENU               0xF088
#define AFX_IDS_UPDATE_MENU             0xF089
#define AFX_IDS_SAVE_AS_MENU            0xF08A
#define AFX_IDS_SAVE_COPY_AS_MENU       0xF08B
#define AFX_IDS_EXIT_MENU               0xF08C
#define AFX_IDS_UPDATING_ITEMS          0xF08D
// COlePasteSpecialDialog defines
#define AFX_IDS_METAFILE_FORMAT         0xF08E
#define AFX_IDS_DIB_FORMAT              0xF08F
#define AFX_IDS_BITMAP_FORMAT           0xF090
#define AFX_IDS_LINKSOURCE_FORMAT       0xF091
#define AFX_IDS_EMBED_FORMAT            0xF092
// other OLE utility strings
#define AFX_IDS_PASTELINKEDTYPE         0xF094
#define AFX_IDS_UNKNOWNTYPE             0xF095
#define AFX_IDS_RTF_FORMAT              0xF096
#define AFX_IDS_TEXT_FORMAT             0xF097
// OLE datatype format error strings
#define AFX_IDS_INVALID_CURRENCY        0xF098
#define AFX_IDS_INVALID_DATETIME        0xF099
#define AFX_IDS_INVALID_DATETIMESPAN    0xF09A

// General error / prompt strings
#define AFX_IDP_INVALID_FILENAME        0xF100
#define AFX_IDP_FAILED_TO_OPEN_DOC      0xF101
#define AFX_IDP_FAILED_TO_SAVE_DOC      0xF102
#define AFX_IDP_ASK_TO_SAVE             0xF103
#define AFX_IDP_FAILED_TO_CREATE_DOC    0xF104
#define AFX_IDP_FILE_TOO_LARGE          0xF105
#define AFX_IDP_FAILED_TO_START_PRINT   0xF106
#define AFX_IDP_FAILED_TO_LAUNCH_HELP   0xF107
#define AFX_IDP_INTERNAL_FAILURE        0xF108      // general failure
#define AFX_IDP_COMMAND_FAILURE         0xF109      // command failure
#define AFX_IDP_FAILED_MEMORY_ALLOC     0xF10A
#define AFX_IDP_UNREG_DONE              0xF10B
#define AFX_IDP_UNREG_FAILURE           0xF10C
#define AFX_IDP_DLL_LOAD_FAILED         0xF10D
#define AFX_IDP_DLL_BAD_VERSION         0xF10E

// DDV parse errors
#define AFX_IDP_PARSE_INT               0xF110
#define AFX_IDP_PARSE_REAL              0xF111
#define AFX_IDP_PARSE_INT_RANGE         0xF112
#define AFX_IDP_PARSE_REAL_RANGE        0xF113
#define AFX_IDP_PARSE_STRING_SIZE       0xF114
#define AFX_IDP_PARSE_RADIO_BUTTON      0xF115
#define AFX_IDP_PARSE_BYTE              0xF116
#define AFX_IDP_PARSE_UINT              0xF117
#define AFX_IDP_PARSE_DATETIME          0xF118
#define AFX_IDP_PARSE_CURRENCY          0xF119

// CFile/CArchive error strings for user failure
#define AFX_IDP_FAILED_INVALID_FORMAT   0xF120
#define AFX_IDP_FAILED_INVALID_PATH     0xF121
#define AFX_IDP_FAILED_DISK_FULL        0xF122
#define AFX_IDP_FAILED_ACCESS_READ      0xF123
#define AFX_IDP_FAILED_ACCESS_WRITE     0xF124
#define AFX_IDP_FAILED_IO_ERROR_READ    0xF125
#define AFX_IDP_FAILED_IO_ERROR_WRITE   0xF126

// OLE errors / prompt strings
#define AFX_IDP_STATIC_OBJECT           0xF180
#define AFX_IDP_FAILED_TO_CONNECT       0xF181
#define AFX_IDP_SERVER_BUSY             0xF182
#define AFX_IDP_BAD_VERB                0xF183
#define AFX_IDS_NOT_DOCOBJECT                0xF184
#define AFX_IDP_FAILED_TO_NOTIFY        0xF185
#define AFX_IDP_FAILED_TO_LAUNCH        0xF186
#define AFX_IDP_ASK_TO_UPDATE           0xF187
#define AFX_IDP_FAILED_TO_UPDATE        0xF188
#define AFX_IDP_FAILED_TO_REGISTER      0xF189
#define AFX_IDP_FAILED_TO_AUTO_REGISTER 0xF18A
#define AFX_IDP_FAILED_TO_CONVERT       0xF18B
#define AFX_IDP_GET_NOT_SUPPORTED       0xF18C
#define AFX_IDP_SET_NOT_SUPPORTED       0xF18D
#define AFX_IDP_ASK_TO_DISCARD          0xF18E
#define AFX_IDP_FAILED_TO_CREATE        0xF18F

// MAPI errors / prompt strings
#define AFX_IDP_FAILED_MAPI_LOAD        0xF190
#define AFX_IDP_INVALID_MAPI_DLL        0xF191
#define AFX_IDP_FAILED_MAPI_SEND        0xF192

#define AFX_IDP_FILE_NONE               0xF1A0
#define AFX_IDP_FILE_GENERIC            0xF1A1
#define AFX_IDP_FILE_NOT_FOUND          0xF1A2
#define AFX_IDP_FILE_BAD_PATH           0xF1A3
#define AFX_IDP_FILE_TOO_MANY_OPEN      0xF1A4
#define AFX_IDP_FILE_ACCESS_DENIED      0xF1A5
#define AFX_IDP_FILE_INVALID_FILE       0xF1A6
#define AFX_IDP_FILE_REMOVE_CURRENT     0xF1A7
#define AFX_IDP_FILE_DIR_FULL           0xF1A8
#define AFX_IDP_FILE_BAD_SEEK           0xF1A9
#define AFX_IDP_FILE_HARD_IO            0xF1AA
#define AFX_IDP_FILE_SHARING            0xF1AB
#define AFX_IDP_FILE_LOCKING            0xF1AC
#define AFX_IDP_FILE_DISKFULL           0xF1AD
#define AFX_IDP_FILE_EOF                0xF1AE

#define AFX_IDP_ARCH_NONE               0xF1B0
#define AFX_IDP_ARCH_GENERIC            0xF1B1
#define AFX_IDP_ARCH_READONLY           0xF1B2
#define AFX_IDP_ARCH_ENDOFFILE          0xF1B3
#define AFX_IDP_ARCH_WRITEONLY          0xF1B4
#define AFX_IDP_ARCH_BADINDEX           0xF1B5
#define AFX_IDP_ARCH_BADCLASS           0xF1B6
#define AFX_IDP_ARCH_BADSCHEMA          0xF1B7

#define AFX_IDS_OCC_SCALEUNITS_PIXELS   0xF1C0

// 0xf200-0xf20f reserved

// font names and point sizes
#define AFX_IDS_STATUS_FONT             0xF230
#define AFX_IDS_TOOLTIP_FONT            0xF231
#define AFX_IDS_UNICODE_FONT            0xF232
#define AFX_IDS_MINI_FONT               0xF233

// ODBC Database errors / prompt strings
#ifndef RC_INVOKED      // code only
#define AFX_IDP_SQL_FIRST                       0xF280
#endif //!RC_INVOKED
#define AFX_IDP_SQL_CONNECT_FAIL                0xF281
#define AFX_IDP_SQL_RECORDSET_FORWARD_ONLY      0xF282
#define AFX_IDP_SQL_EMPTY_COLUMN_LIST           0xF283
#define AFX_IDP_SQL_FIELD_SCHEMA_MISMATCH       0xF284
#define AFX_IDP_SQL_ILLEGAL_MODE                0xF285
#define AFX_IDP_SQL_MULTIPLE_ROWS_AFFECTED      0xF286
#define AFX_IDP_SQL_NO_CURRENT_RECORD           0xF287
#define AFX_IDP_SQL_NO_ROWS_AFFECTED            0xF288
#define AFX_IDP_SQL_RECORDSET_READONLY          0xF289
#define AFX_IDP_SQL_SQL_NO_TOTAL                0xF28A
#define AFX_IDP_SQL_ODBC_LOAD_FAILED            0xF28B
#define AFX_IDP_SQL_DYNASET_NOT_SUPPORTED       0xF28C
#define AFX_IDP_SQL_SNAPSHOT_NOT_SUPPORTED      0xF28D
#define AFX_IDP_SQL_API_CONFORMANCE             0xF28E
#define AFX_IDP_SQL_SQL_CONFORMANCE             0xF28F
#define AFX_IDP_SQL_NO_DATA_FOUND               0xF290
#define AFX_IDP_SQL_ROW_UPDATE_NOT_SUPPORTED    0xF291
#define AFX_IDP_SQL_ODBC_V2_REQUIRED            0xF292
#define AFX_IDP_SQL_NO_POSITIONED_UPDATES       0xF293
#define AFX_IDP_SQL_LOCK_MODE_NOT_SUPPORTED     0xF294
#define AFX_IDP_SQL_DATA_TRUNCATED              0xF295
#define AFX_IDP_SQL_ROW_FETCH                   0xF296
#define AFX_IDP_SQL_INCORRECT_ODBC              0xF297
#define AFX_IDP_SQL_UPDATE_DELETE_FAILED        0xF298
#define AFX_IDP_SQL_DYNAMIC_CURSOR_NOT_SUPPORTED    0xF299
#define AFX_IDP_SQL_FIELD_NOT_FOUND             0xF29A
#define AFX_IDP_SQL_BOOKMARKS_NOT_SUPPORTED     0xF29B
#define AFX_IDP_SQL_BOOKMARKS_NOT_ENABLED       0xF29C

// ODBC Database strings
#define AFX_IDS_DELETED                         0xF29D

// DAO Database errors / prompt strings
#ifndef RC_INVOKED      // code only
#define AFX_IDP_DAO_FIRST                       0xF2B0
#endif //!RC_INVOKED
#define AFX_IDP_DAO_ENGINE_INITIALIZATION       0xF2B0
#define AFX_IDP_DAO_DFX_BIND                    0xF2B1
#define AFX_IDP_DAO_OBJECT_NOT_OPEN             0xF2B2

// ICDAORecordset::GetRows Errors
//  These are not placed in DAO Errors collection
//  and must be handled directly by MFC.
#define AFX_IDP_DAO_ROWTOOSHORT                 0xF2B3
#define AFX_IDP_DAO_BADBINDINFO                 0xF2B4
#define AFX_IDP_DAO_COLUMNUNAVAILABLE           0xF2B5

/////////////////////////////////////////////////////////////////////////////
// Strings for ISAPI support

#define AFX_IDS_HTTP_TITLE              0xF2D1
#define AFX_IDS_HTTP_NO_TEXT            0xF2D2
#define AFX_IDS_HTTP_BAD_REQUEST        0xF2D3
#define AFX_IDS_HTTP_AUTH_REQUIRED      0xF2D4
#define AFX_IDS_HTTP_FORBIDDEN          0xF2D5
#define AFX_IDS_HTTP_NOT_FOUND          0xF2D6
#define AFX_IDS_HTTP_SERVER_ERROR       0xF2D7
#define AFX_IDS_HTTP_NOT_IMPLEMENTED    0xF2D8

/////////////////////////////////////////////////////////////////////////////
// AFX implementation - control IDs (AFX_IDC)

// Parts of dialogs
#define AFX_IDC_LISTBOX                 100
#define AFX_IDC_CHANGE                  101

// for print dialog
#define AFX_IDC_PRINT_DOCNAME           201
#define AFX_IDC_PRINT_PRINTERNAME       202
#define AFX_IDC_PRINT_PORTNAME          203
#define AFX_IDC_PRINT_PAGENUM           204

// Property Sheet control id's (determined with Spy++)
#define ID_APPLY_NOW                    0x3021
#define ID_WIZBACK                      0x3023
#define ID_WIZNEXT                      0x3024
#define ID_WIZFINISH                    0x3025
#define AFX_IDC_TAB_CONTROL             0x3020

/////////////////////////////////////////////////////////////////////////////
// IDRs for standard components

#ifndef RC_INVOKED  // code only
// These are really COMMDLG dialogs, so there usually isn't a resource
// for them, but these IDs are used as help IDs.
#define AFX_IDD_FILEOPEN                28676
#define AFX_IDD_FILESAVE                28677
#define AFX_IDD_FONT                    28678
#define AFX_IDD_COLOR                   28679
#define AFX_IDD_PRINT                   28680
#define AFX_IDD_PRINTSETUP              28681
#define AFX_IDD_FIND                    28682
#define AFX_IDD_REPLACE                 28683
#endif //!RC_INVOKED

// Standard dialogs app should leave alone (0x7801->)
#define AFX_IDD_NEWTYPEDLG              30721
#define AFX_IDD_PRINTDLG                30722
#define AFX_IDD_PREVIEW_TOOLBAR         30723

// Dialogs defined for OLE2UI library
#define AFX_IDD_INSERTOBJECT            30724
#define AFX_IDD_CHANGEICON              30725
#define AFX_IDD_CONVERT                 30726
#define AFX_IDD_PASTESPECIAL            30727
#define AFX_IDD_EDITLINKS               30728
#define AFX_IDD_FILEBROWSE              30729
#define AFX_IDD_BUSY                    30730

#define AFX_IDD_OBJECTPROPERTIES        30732
#define AFX_IDD_CHANGESOURCE            30733

// Standard cursors (0x7901->)
	// AFX_IDC = Cursor resources
#define AFX_IDC_CONTEXTHELP             30977       // context sensitive help
#define AFX_IDC_MAGNIFY                 30978       // print preview zoom
#define AFX_IDC_SMALLARROWS             30979       // splitter
#define AFX_IDC_HSPLITBAR               30980       // splitter
#define AFX_IDC_VSPLITBAR               30981       // splitter
#define AFX_IDC_NODROPCRSR              30982       // No Drop Cursor
#define AFX_IDC_TRACKNWSE               30983       // tracker
#define AFX_IDC_TRACKNESW               30984       // tracker
#define AFX_IDC_TRACKNS                 30985       // tracker
#define AFX_IDC_TRACKWE                 30986       // tracker
#define AFX_IDC_TRACK4WAY               30987       // tracker
#define AFX_IDC_MOVE4WAY                30988       // resize bar (server only)

// Mini frame window bitmap ID
#define AFX_IDB_MINIFRAME_MENU          30994

// CheckListBox checks bitmap ID
#define AFX_IDB_CHECKLISTBOX_NT         30995
#define AFX_IDB_CHECKLISTBOX_95         30996

// AFX standard accelerator resources
#define AFX_IDR_PREVIEW_ACCEL           30997

// AFX standard ICON IDs (for MFC V1 apps) (0x7A01->)
#define AFX_IDI_STD_MDIFRAME            31233
#define AFX_IDI_STD_FRAME               31234

/////////////////////////////////////////////////////////////////////////////
// AFX OLE control implementation - control IDs (AFX_IDC)

// Font property page
#define AFX_IDC_FONTPROP                1000
#define AFX_IDC_FONTNAMES               1001
#define AFX_IDC_FONTSTYLES              1002
#define AFX_IDC_FONTSIZES               1003
#define AFX_IDC_STRIKEOUT               1004
#define AFX_IDC_UNDERLINE               1005
#define AFX_IDC_SAMPLEBOX               1006

// Color property page
#define AFX_IDC_COLOR_BLACK             1100
#define AFX_IDC_COLOR_WHITE             1101
#define AFX_IDC_COLOR_RED               1102
#define AFX_IDC_COLOR_GREEN             1103
#define AFX_IDC_COLOR_BLUE              1104
#define AFX_IDC_COLOR_YELLOW            1105
#define AFX_IDC_COLOR_MAGENTA           1106
#define AFX_IDC_COLOR_CYAN              1107
#define AFX_IDC_COLOR_GRAY              1108
#define AFX_IDC_COLOR_LIGHTGRAY         1109
#define AFX_IDC_COLOR_DARKRED           1110
#define AFX_IDC_COLOR_DARKGREEN         1111
#define AFX_IDC_COLOR_DARKBLUE          1112
#define AFX_IDC_COLOR_LIGHTBROWN        1113
#define AFX_IDC_COLOR_DARKMAGENTA       1114
#define AFX_IDC_COLOR_DARKCYAN          1115
#define AFX_IDC_COLORPROP               1116
#define AFX_IDC_SYSTEMCOLORS            1117

// Picture porperty page
#define AFX_IDC_PROPNAME                1201
#define AFX_IDC_PICTURE                 1202
#define AFX_IDC_BROWSE                  1203
#define AFX_IDC_CLEAR                   1204

/////////////////////////////////////////////////////////////////////////////
// IDRs for OLE control standard components

// Standard propery page dialogs app should leave alone (0x7E01->)
#define AFX_IDD_PROPPAGE_COLOR         32257
#define AFX_IDD_PROPPAGE_FONT          32258
#define AFX_IDD_PROPPAGE_PICTURE       32259

#define AFX_IDB_TRUETYPE               32384

/////////////////////////////////////////////////////////////////////////////
// Standard OLE control strings

// OLE Control page strings
#define AFX_IDS_PROPPAGE_UNKNOWN        0xFE01
#define AFX_IDS_COLOR_DESKTOP           0xFE04
#define AFX_IDS_COLOR_APPWORKSPACE      0xFE05
#define AFX_IDS_COLOR_WNDBACKGND        0xFE06
#define AFX_IDS_COLOR_WNDTEXT           0xFE07
#define AFX_IDS_COLOR_MENUBAR           0xFE08
#define AFX_IDS_COLOR_MENUTEXT          0xFE09
#define AFX_IDS_COLOR_ACTIVEBAR         0xFE0A
#define AFX_IDS_COLOR_INACTIVEBAR       0xFE0B
#define AFX_IDS_COLOR_ACTIVETEXT        0xFE0C
#define AFX_IDS_COLOR_INACTIVETEXT      0xFE0D
#define AFX_IDS_COLOR_ACTIVEBORDER      0xFE0E
#define AFX_IDS_COLOR_INACTIVEBORDER    0xFE0F
#define AFX_IDS_COLOR_WNDFRAME          0xFE10
#define AFX_IDS_COLOR_SCROLLBARS        0xFE11
#define AFX_IDS_COLOR_BTNFACE           0xFE12
#define AFX_IDS_COLOR_BTNSHADOW         0xFE13
#define AFX_IDS_COLOR_BTNTEXT           0xFE14
#define AFX_IDS_COLOR_BTNHIGHLIGHT      0xFE15
#define AFX_IDS_COLOR_DISABLEDTEXT      0xFE16
#define AFX_IDS_COLOR_HIGHLIGHT         0xFE17
#define AFX_IDS_COLOR_HIGHLIGHTTEXT     0xFE18
#define AFX_IDS_REGULAR                 0xFE19
#define AFX_IDS_BOLD                    0xFE1A
#define AFX_IDS_ITALIC                  0xFE1B
#define AFX_IDS_BOLDITALIC              0xFE1C
#define AFX_IDS_SAMPLETEXT              0xFE1D
#define AFX_IDS_DISPLAYSTRING_FONT      0xFE1E
#define AFX_IDS_DISPLAYSTRING_COLOR     0xFE1F
#define AFX_IDS_DISPLAYSTRING_PICTURE   0xFE20
#define AFX_IDS_PICTUREFILTER           0xFE21
#define AFX_IDS_PICTYPE_UNKNOWN         0xFE22
#define AFX_IDS_PICTYPE_NONE            0xFE23
#define AFX_IDS_PICTYPE_BITMAP          0xFE24
#define AFX_IDS_PICTYPE_METAFILE        0xFE25
#define AFX_IDS_PICTYPE_ICON            0xFE26
#define AFX_IDS_COLOR_PPG               0xFE28
#define AFX_IDS_COLOR_PPG_CAPTION       0xFE29
#define AFX_IDS_FONT_PPG                0xFE2A
#define AFX_IDS_FONT_PPG_CAPTION        0xFE2B
#define AFX_IDS_PICTURE_PPG             0xFE2C
#define AFX_IDS_PICTURE_PPG_CAPTION     0xFE2D
#define AFX_IDS_PICTUREBROWSETITLE      0xFE30
#define AFX_IDS_BORDERSTYLE_0           0xFE31
#define AFX_IDS_BORDERSTYLE_1           0xFE32

// OLE Control verb names
#define AFX_IDS_VERB_EDIT               0xFE40
#define AFX_IDS_VERB_PROPERTIES         0xFE41

// OLE Control internal error messages
#define AFX_IDP_PICTURECANTOPEN         0xFE83
#define AFX_IDP_PICTURECANTLOAD         0xFE84
#define AFX_IDP_PICTURETOOLARGE         0xFE85
#define AFX_IDP_PICTUREREADFAILED       0xFE86

// Standard OLE Control error strings
#define AFX_IDP_E_ILLEGALFUNCTIONCALL       0xFEA0
#define AFX_IDP_E_OVERFLOW                  0xFEA1
#define AFX_IDP_E_OUTOFMEMORY               0xFEA2
#define AFX_IDP_E_DIVISIONBYZERO            0xFEA3
#define AFX_IDP_E_OUTOFSTRINGSPACE          0xFEA4
#define AFX_IDP_E_OUTOFSTACKSPACE           0xFEA5
#define AFX_IDP_E_BADFILENAMEORNUMBER       0xFEA6
#define AFX_IDP_E_FILENOTFOUND              0xFEA7
#define AFX_IDP_E_BADFILEMODE               0xFEA8
#define AFX_IDP_E_FILEALREADYOPEN           0xFEA9
#define AFX_IDP_E_DEVICEIOERROR             0xFEAA
#define AFX_IDP_E_FILEALREADYEXISTS         0xFEAB
#define AFX_IDP_E_BADRECORDLENGTH           0xFEAC
#define AFX_IDP_E_DISKFULL                  0xFEAD
#define AFX_IDP_E_BADRECORDNUMBER           0xFEAE
#define AFX_IDP_E_BADFILENAME               0xFEAF
#define AFX_IDP_E_TOOMANYFILES              0xFEB0
#define AFX_IDP_E_DEVICEUNAVAILABLE         0xFEB1
#define AFX_IDP_E_PERMISSIONDENIED          0xFEB2
#define AFX_IDP_E_DISKNOTREADY              0xFEB3
#define AFX_IDP_E_PATHFILEACCESSERROR       0xFEB4
#define AFX_IDP_E_PATHNOTFOUND              0xFEB5
#define AFX_IDP_E_INVALIDPATTERNSTRING      0xFEB6
#define AFX_IDP_E_INVALIDUSEOFNULL          0xFEB7
#define AFX_IDP_E_INVALIDFILEFORMAT         0xFEB8
#define AFX_IDP_E_INVALIDPROPERTYVALUE      0xFEB9
#define AFX_IDP_E_INVALIDPROPERTYARRAYINDEX 0xFEBA
#define AFX_IDP_E_SETNOTSUPPORTEDATRUNTIME  0xFEBB
#define AFX_IDP_E_SETNOTSUPPORTED           0xFEBC
#define AFX_IDP_E_NEEDPROPERTYARRAYINDEX    0xFEBD
#define AFX_IDP_E_SETNOTPERMITTED           0xFEBE
#define AFX_IDP_E_GETNOTSUPPORTEDATRUNTIME  0xFEBF
#define AFX_IDP_E_GETNOTSUPPORTED           0xFEC0
#define AFX_IDP_E_PROPERTYNOTFOUND          0xFEC1
#define AFX_IDP_E_INVALIDCLIPBOARDFORMAT    0xFEC2
#define AFX_IDP_E_INVALIDPICTURE            0xFEC3
#define AFX_IDP_E_PRINTERERROR              0xFEC4
#define AFX_IDP_E_CANTSAVEFILETOTEMP        0xFEC5
#define AFX_IDP_E_SEARCHTEXTNOTFOUND        0xFEC6
#define AFX_IDP_E_REPLACEMENTSTOOLONG       0xFEC7

/////////////////////////////////////////////////////////////////////////////

#ifdef _AFX_MINREBUILD
#pragma component(minrebuild, on)
#endif

#endif //__AFXRES_H__

/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\appcompat\tools\appsearch\appsearch.cpp ===
// AppSearch
//
// Tool for searching a user's hard drives and locating
// applications that can be patched
// 
// Author: t-michkr (9 June 2000)
//
// AppSearch.cpp
// User-interface

// We make use of some Win2K/IE5 common controls
#include <windows.h>
#include <commctrl.h>
#include <comdef.h>
#include <shlwapi.h>
#include <shlobj.h>
#include <shellapi.h>
#include <assert.h>
#include "main.h"
#include "searchdb.h"
#include "filebrowser.h"
#include "resource.h"

// Compare data, used for sorting listview items.
struct SCompareParam
{
    HWND hwList;
    int iSubItem;
};

// Size of some static controls
const int c_nStaticLineHeight = 2;
const int c_nResultFrameWidth = 2;

// Minimum height of the result window
const int c_nResultListHeight = 201;

// ID's of controls we create ourselves
const int c_iStaticLineID   = 50;
const int c_iResultListID   = 51;
const int c_iResultFrameID  = 52;
const int c_iStatusBarID    = 53;
const int c_iFindAnimID     = 54;

// Positions of menu items (these will be needed to be changed
// if the menu is altered)
const int c_iViewMenuPos    = 2;
const int c_iArrangeIconsPos = 5;

// List view column info
const int c_nListColumnWidth = 250;
const int c_nNumListColumns = 2;
const int c_iListColumnNameIDS[c_nNumListColumns] = {
    IDS_LISTNAME, IDS_LISTPATH};

// Number of children that need to be adjusted on resize
const int c_nChildren   = 6;

// ID's of children that need to be adjusted on resize
int g_aiChildrenIDs[c_nChildren] = {IDC_BROWSE, IDC_FINDNOW, IDC_STOP, IDC_CLEARALL,
                                    IDC_DRIVELIST, c_iFindAnimID};

// Margins of those children, determined from dialog box in HandleInitDialog().
int g_aiChildrenMargins[c_nChildren];

// Minimum window width and window height, determined from dialog box
// in HandleInitDialog().
int g_nMinWindowWidth;
int g_nWindowHeight;

// Whether or not the user is browsing through menus, used for displaying
// menu help text.
BOOL g_fInMenu = FALSE;

// Instance of this app.
HINSTANCE g_hinst   = 0;

// Original window proc for the list view control.
WNDPROC pfnLVOrgWndProc = 0;

// Subclassed window proc for list view, intercepts WM_PAINT messages
// and writes "No items in view" if empty.
LRESULT CALLBACK LVWndProc(HWND hwnd, UINT uiMsg, WPARAM wParam, LPARAM lParam);

// Dialog proc for main application dialog.
BOOL CALLBACK DialogProc(HWND hwndDlg, UINT uiMsg, WPARAM wParam, LPARAM lParam);

// Display shimming information for specified exe.
void ShowShimInfo(HWND hwnd, TCHAR* szAppPath);

// Returns an allocated string with resource ID id, or 0 on failure.
TCHAR* LoadStringResource(UINT id);

// Print an error box with message in string resource uiMsg.
void Error(HWND hwnd, UINT uiMsg);

// Compare entries in the listview, used for sorting.
int CALLBACK CompareListEntries(LPARAM lParam1, LPARAM lParam2, LPARAM lParamSort);

// Start searching the AppCompat database.
void StartSearch(HWND hwnd);

// Terminate the current search, does nothing if no search is active.
void StopSearch(HWND hwnd);

// Remove all results shown
void ClearResults(HWND hwnd);

// Update the status bar with the new message.
void UpdateStatus(HWND hwnd, PTSTR szMsg);

// Add a new app to the list
void AddApp(SMatchedExe* pme, HWND hwList);

// Message Handlers.
BOOL HandleInitDialog(HWND hwnd);
void HandleBrowse(HWND hwnd);
void HandleCommand(HWND hwnd, int iCtrlID, HWND hwChild);
void HandleEnterMenuLoop(HWND hwnd);
void HandleExitMenuLoop(HWND hwnd);
void HandleGetMinMaxInfo(HWND hwnd, LPMINMAXINFO pmmi);
void HandleMenuSelect(HWND hwnd, HMENU hMenu, UINT uiMenuID, UINT uiFlags);
void HandleNotify(HWND hwnd, int iCtrlID, void* pvArg);
void HandleSearchAddApp(HWND hwnd);
void HandleSearchUpdate(HWND hwnd, PTSTR szMsg);
void HandleSize(HWND hwnd, int iWidth, int iHeight);
void HandleSizing(HWND hwnd, int iEdge, LPRECT pRect);

// Program entry point.
int WINAPI WinMain(HINSTANCE hInstance, HINSTANCE, PSTR, int)
{
    // Save our global instance handle.
    g_hinst = hInstance;

    // Make sure the common controls DLL is loaded.
    INITCOMMONCONTROLSEX icc;
    icc.dwSize = sizeof(icc);
    // We use the list view, status bar, tree control, animate, 
    // tooltip, and comboboxex classes
    icc.dwICC = ICC_USEREX_CLASSES | ICC_LISTVIEW_CLASSES | ICC_BAR_CLASSES
        | ICC_TREEVIEW_CLASSES | ICC_ANIMATE_CLASS | ICC_TAB_CLASSES ;

    if(InitCommonControlsEx(&icc) == FALSE)
        return 0;

    // Run the actual dialog for the application
    return DialogBox(g_hinst, MAKEINTRESOURCE(IDD_MAINDIALOG),
        0, DialogProc);    
}

// Dialog proc for main dialog.
BOOL CALLBACK DialogProc(HWND hwndDlg, UINT uiMsg, WPARAM wParam, LPARAM lParam)
{
    switch(uiMsg)
    {
        // Do basic initialization, return FALSE means do not continue
        // creating the window.
    case WM_INITDIALOG:
        return HandleInitDialog(hwndDlg);
        break;

        // Control sizing, to maintain a minimum dialog size.
    case WM_SIZE:        
        HandleSize(hwndDlg, LOWORD(lParam), HIWORD(lParam));
        break;

        // Control sizing, to maintain a minimum dialog box size.
    case WM_SIZING:
        HandleSizing(hwndDlg, wParam, reinterpret_cast<LPRECT>(lParam));
        break;

        // Control maximizing, to maintain dialog size.
    case WM_GETMINMAXINFO:
        HandleGetMinMaxInfo(hwndDlg, reinterpret_cast<LPMINMAXINFO>(lParam));
        break;    

        // Handle child control messages
    case WM_COMMAND:
        HandleCommand(hwndDlg, LOWORD(wParam), reinterpret_cast<HWND>(lParam));
        break;

        // Handle notifications from child controls
    case WM_NOTIFY:
        HandleNotify(hwndDlg, static_cast<int>(wParam),
            reinterpret_cast<void*>(lParam));
        
        break;

        // Print help messages when user goes over a menu item.
    case WM_MENUSELECT:
        HandleMenuSelect(hwndDlg, reinterpret_cast<HMENU>(lParam), 
            LOWORD(wParam), HIWORD(wParam));
        break;

        // Note when user starts browsing through a menu.
    case WM_ENTERMENULOOP:
        HandleEnterMenuLoop(hwndDlg);
        break;
        
        // Note when user exits a menu.
    case WM_EXITMENULOOP:
        HandleExitMenuLoop(hwndDlg);
        break;

        // Search thread just found another app.
    case WM_SEARCHDB_ADDAPP:
        HandleSearchAddApp(hwndDlg);
        break;

        // Search thread is looking through a new directory
    case WM_SEARCHDB_UPDATE:
        HandleSearchUpdate(hwndDlg, reinterpret_cast<PTSTR>(lParam));
        break;

        // Search thread is complete.
    case WM_SEARCHDB_DONE:
        // Cleanup any leftover apps (just in case this message
        // is received before WM_SEARCHDB_ADDAPP)
        HandleSearchAddApp(hwndDlg);

        // Terminate search
        StopSearch(hwndDlg);
        break;        

        // User wants to close this dialog
    case WM_CLOSE:
        // Terminate search
        StopSearch(hwndDlg);
        EndDialog(hwndDlg, TRUE);
        break;

    default:
        return FALSE;
    }

    return TRUE;
}

// Do basic dialog box initialization.
BOOL HandleInitDialog(HWND hwnd)
{
    // Change the application icon
    HICON hIcon;
    hIcon = LoadIcon(g_hinst, MAKEINTRESOURCE(IDI_APP));
    if(!hIcon)
        return FALSE;
    
    // For SetClassLongPtr(), a return value of zero may not be an
    // error, if the previous value was not set.  Setting the 
    // last error to 0 and checking for that value indicates
    // success.

    // BUGBUG
    // In Whistler, SetClassLongPtr returns an error, but still 
    // sets the correct icon.  No error is returned for Win2K.
    SetClassLongPtr(hwnd, GCLP_HICON, reinterpret_cast<LONG_PTR>(hIcon));
    SetClassLongPtr(hwnd, GCLP_HICONSM, reinterpret_cast<LONG_PTR>(hIcon));

    // Get minimum dimensions of dialog
    RECT rcWindow;

    if(!GetWindowRect(hwnd, &rcWindow))
        return FALSE;

    g_nMinWindowWidth = rcWindow.right - rcWindow.left;
    g_nWindowHeight = rcWindow.bottom - rcWindow.top;

    // Add a static line across the top (We can't put this in the resource template)
    RECT rectCl;
    if(!GetClientRect(hwnd, &rectCl))
        return FALSE;

    HWND hwStaticLine = CreateWindow(TEXT("static"),TEXT(""),
        SS_ETCHEDHORZ | WS_CHILD | WS_VISIBLE, rectCl.top, rectCl.left,
        rectCl.right - rectCl.left, c_nStaticLineHeight, hwnd, 
        reinterpret_cast<HMENU>(c_iStaticLineID), g_hinst, 0);

    if(!hwStaticLine)
        return FALSE;

    // Fill the combobox.
    HWND hwComboBox = GetDlgItem(hwnd, IDC_DRIVELIST);
    if(!hwComboBox)
        return FALSE;

    SHFILEINFO sfi;
    HIMAGELIST himagelist = reinterpret_cast<HIMAGELIST>(SHGetFileInfo(TEXT("C:\\"), 0, &sfi, sizeof(sfi),
        SHGFI_SYSICONINDEX | SHGFI_SMALLICON));

    LRESULT lr = SendMessage(hwComboBox, CBEM_SETIMAGELIST, 0, 
        reinterpret_cast<LPARAM>(himagelist));
    
    assert(lr == NULL);
      
    COMBOBOXEXITEM cbitem;
    ZeroMemory(&cbitem, sizeof(cbitem));
    cbitem.mask = CBEIF_TEXT | CBEIF_INDENT | CBEIF_IMAGE 
        | CBEIF_SELECTEDIMAGE;
    cbitem.iItem = -1;
    cbitem.pszText = LoadStringResource(IDS_ALLDRIVES);
    if(!cbitem.pszText)
        return FALSE;

    cbitem.cchTextMax = lstrlen(cbitem.pszText) + 1;

    cbitem.iIndent = 0;

    LPITEMIDLIST pidl;
    SHGetFolderLocation(0, CSIDL_DRIVES, 0, 0, &pidl);

    SHGetFileInfo(reinterpret_cast<PTSTR>(pidl), 0, &sfi, sizeof(sfi), 
        SHGFI_SYSICONINDEX | SHGFI_PIDL);

    cbitem.iImage = sfi.iIcon;
    cbitem.iSelectedImage = sfi.iIcon;

    if(SendMessage(hwComboBox, CBEM_INSERTITEM, 0, 
        reinterpret_cast<LPARAM>(&cbitem)))
    {
        delete cbitem.pszText;
        return FALSE;
    }

    delete cbitem.pszText;

    LPMALLOC pMalloc;
    SHGetMalloc(&pMalloc);
    pMalloc->Free(pidl);
    pMalloc->Release();

    TCHAR* szDrives = 0;
    DWORD dwLen = GetLogicalDriveStrings(0, 0);
    if(dwLen != 0)
    {
        szDrives = new TCHAR[dwLen+1];
        if(!szDrives)
        {
            Error(hwnd, IDS_NOMEMSTOPPROG);
            return FALSE;
        }
    }
    else 
        return FALSE;

    if(!GetLogicalDriveStrings(dwLen, szDrives))
    {
        delete szDrives;
        return FALSE;
    }

    TCHAR* szCurrDrive = szDrives;
    while(*szCurrDrive)
    {
        if(GetDriveType(szCurrDrive)==DRIVE_FIXED)
        {
            SHGetFileInfo(szCurrDrive, 0, &sfi, sizeof(sfi), SHGFI_SYSICONINDEX);

            cbitem.pszText = szCurrDrive;
            cbitem.cchTextMax = lstrlen(cbitem.pszText) + 1;
            cbitem.iIndent = 1;
            cbitem.iImage = sfi.iIcon;
            cbitem.iSelectedImage = sfi.iIcon;

            SendMessage(hwComboBox, CBEM_INSERTITEM, 0, 
                reinterpret_cast<LPARAM>(&cbitem));
        }

        szCurrDrive += lstrlen(szCurrDrive)+1;
    }

    delete szDrives;
    if(SendMessage(hwComboBox, CB_SETCURSEL, 0, 0)== -1)            
        return FALSE;    

    // Add the animation control.
    HWND hwChild;
    RECT rcChild;    
    POINT pt;

    HWND hwAnim = Animate_Create(hwnd, c_iFindAnimID, 
        WS_CHILD | ACS_CENTER | ACS_TRANSPARENT, g_hinst);

    hwChild = GetDlgItem(hwnd, IDC_ANIMSPACEHOLDER);
    GetWindowRect(hwChild, &rcChild);    

    DestroyWindow(hwChild);
    pt.x = rcChild.left;
    pt.y = rcChild.top;
    ScreenToClient(hwnd, &pt);
    SetWindowPos(hwAnim, 0, pt.x, pt.y, rcChild.right-rcChild.left,
        rcChild.bottom - rcChild.top, SWP_NOZORDER);

    Animate_Open(hwAnim, MAKEINTRESOURCE(IDR_FINDAVI));    

    ShowWindow(hwAnim, SW_SHOW);

    // Get margins of all child window controls
    pt.x = 0;
    pt.y = 0;
    for(int i = 0; i < c_nChildren; i++)
    {
        hwChild = GetDlgItem(hwnd, g_aiChildrenIDs[i]);
        if(!hwChild)
            return FALSE;

        if(!GetWindowRect(hwChild, &rcChild))
            return FALSE;

        pt.x = rcChild.right;
    
        if(!ScreenToClient(hwnd, &pt))
            return FALSE;

        g_aiChildrenMargins[i] = rectCl.right - pt.x;
    }

    // Setup default checked state
    HMENU hMenu = GetMenu(hwnd);
    if(!hMenu)
        return FALSE;

    CheckMenuRadioItem(hMenu, ID_VIEW_LARGEICONS,
        ID_VIEW_ASDETAILS, ID_VIEW_ASDETAILS, MF_BYCOMMAND);

    if(InitSearchDB() == FALSE)
        return FALSE;

    return TRUE;
}

// Display a browse dialog box, so that the user can select
// a specific path to search in.
void HandleBrowse(HWND hwnd)
{
    // Show the browse dialog box, and get user response.
    TCHAR* szPath = BrowseForFolder(hwnd, 0, 
        BF_SELECTDIRECTORIES |  BF_HARDDRIVES);

    // If they didn't select cancel . . .
    if(szPath)
    {
        HWND hwDirSelBox = GetDlgItem(hwnd, IDC_DRIVELIST);        
        if(!hwDirSelBox)
        {            
            DestroyWindow(hwnd);
            return;
        }

        // For some reason, SHGetFileInfo doesn't work
        // properly if the drive isn't terminated with '\'
        if(szPath[lstrlen(szPath)-1] == TEXT(':'))
            lstrcat(szPath, TEXT("\\"));

        // Insert this item into the edit control of the combo box.
        SHFILEINFO sfi;

        COMBOBOXEXITEM cbim;
        cbim.mask = CBEIF_IMAGE | CBEIF_TEXT | CBEIF_SELECTEDIMAGE;
        cbim.iItem = -1;
        cbim.pszText = szPath;
        cbim.cchTextMax = lstrlen(szPath);

        SHGetFileInfo(szPath, 0, &sfi, sizeof(sfi), 
            SHGFI_SYSICONINDEX);

        cbim.iImage = sfi.iIcon;
        cbim.iSelectedImage = sfi.iIcon;

        if(!SendMessage(hwDirSelBox, CBEM_SETITEM, 0, 
            reinterpret_cast<LPARAM>(&cbim)))
        {         
            DestroyWindow(hwnd);
            return;
        }

        // For some reason, the icon in the edit box isn't updated
        // unless the box is selected, loses focus, and then regains
        // focus, so do that here.
        if(!SetFocus(hwDirSelBox))
        {         
            DestroyWindow(hwnd);
            return;
        }            

        if(!SetFocus(GetDlgItem(hwnd, IDC_BROWSE)))
        {         
            DestroyWindow(hwnd);
            return;
        }

        if(!SetFocus(hwDirSelBox))
        {            
            DestroyWindow(hwnd);
            return;
        }               
    }
}

// Handle a command from a child input control.
void HandleCommand(HWND hwnd, int iCtrlID, HWND)
{
    HMENU hMenu;
    HWND hwList;
    DWORD dwStyle, dwExStyle;
    SHELLEXECUTEINFO shExecInfo;
    SCompareParam cp;

    switch(iCtrlID)
    {    
    // MENU COMMANDS        
 
    case ID_APPSELECT_SHOWSHIMINFO:
    case ID_FILE_SHOWSHIMINFO:
        // Get list view control
        hwList = GetDlgItem(hwnd, c_iResultListID);
        if(hwList)
        {
            int nCount = ListView_GetItemCount(hwList);
            int i;
            // Loop through all items finding a selected one.
            for(i = 0; i < nCount; i++)
            {
                if(ListView_GetItemState(hwList, i, LVIS_SELECTED) 
                    & LVIS_SELECTED)
                    break;
            }

            // None found, we're done.
            if(i == nCount)
                break;

            TCHAR szBuffer[c_nMaxStringLength];

            ListView_GetItemText(hwList, i, 1,
                szBuffer, c_nMaxStringLength);

            ShowShimInfo(hwnd, szBuffer);

        }

        break;
        // Use selected properties
    case ID_APPSELECT_PROPERTIES:
    case ID_FILE_PROPERTIES:

        // Get list view control
        hwList = GetDlgItem(hwnd, c_iResultListID);
        if(hwList)
        {
            int nCount = ListView_GetItemCount(hwList);
            int i;
            // Loop through all items finding a selected one.
            for(i = 0; i < nCount; i++)
            {
                if(ListView_GetItemState(hwList, i, LVIS_SELECTED) 
                    & LVIS_SELECTED)
                    break;
            }

            // None found, we're done.
            if(i == nCount)
                break;

            TCHAR szBuffer[c_nMaxStringLength];

            ListView_GetItemText(hwList, i, 1,
                szBuffer, c_nMaxStringLength);

            ZeroMemory(&shExecInfo, sizeof(shExecInfo));
            shExecInfo.cbSize = sizeof(shExecInfo);
            shExecInfo.lpFile = szBuffer;
            shExecInfo.lpVerb = TEXT("properties");
            shExecInfo.fMask = SEE_MASK_INVOKEIDLIST;
            ShellExecuteEx(&shExecInfo);   
        }
        
        break;       

    case ID_FILE_EXIT:
        EndDialog(hwnd, TRUE);
        break;

    case ID_EDIT_SELECTALL:
        hwList = GetDlgItem(hwnd, c_iResultListID);
        if(hwList)
        {
            int nCount = ListView_GetItemCount(hwList);
            for(int i = 0; i < nCount; i++)
                ListView_SetItemState(hwList, i, LVIS_SELECTED, LVIS_SELECTED);
        }
        break;

    case ID_EDIT_INVERTSELECTION:
        hwList = GetDlgItem(hwnd, c_iResultListID);
        if(hwList)
        {
            int nCount = ListView_GetItemCount(hwList);
            for(int i = 0; i < nCount; i++)            
                ListView_SetItemState(hwList, i, 
                    LVIS_SELECTED ^ ListView_GetItemState(hwList, i, LVIS_SELECTED),
                    LVIS_SELECTED);
        }
        break;
    
    case ID_VIEW_LARGEICONS:
    case ID_VIEW_SMALLICONS:
    case ID_VIEW_ASLIST:
    case ID_VIEW_ASDETAILS:
        hMenu = GetMenu(hwnd);
        CheckMenuRadioItem(hMenu, ID_VIEW_LARGEICONS,
            ID_VIEW_ASDETAILS, iCtrlID, MF_BYCOMMAND);
        
        dwStyle = WS_CHILD | WS_VISIBLE | LVS_SHOWSELALWAYS;
        dwExStyle = LVS_EX_LABELTIP;
        switch(iCtrlID)
        {
        case ID_VIEW_LARGEICONS:
            dwStyle |= LVS_ICON;
            break;
        case ID_VIEW_SMALLICONS:
            dwStyle |= LVS_SMALLICON;
            break;
        case ID_VIEW_ASLIST:
            dwStyle |= LVS_LIST;
            break;
        case ID_VIEW_ASDETAILS:
            dwStyle |= LVS_REPORT;
            dwExStyle |= LVS_EX_FULLROWSELECT;
            break;
        }
        hwList = GetDlgItem(hwnd, c_iResultListID);

        if(hwList)
        {
            SetWindowLongPtr(hwList, GWL_STYLE, dwStyle);
            ListView_SetExtendedListViewStyleEx(hwList, 0, dwExStyle);            
        }

        break;

    case ID_VIEW_ARRANGEICONS_BYNAME:
        hwList = GetDlgItem(hwnd, c_iResultListID);        
        cp.hwList = hwList;
        cp.iSubItem = 0;

        if(hwList)
            ListView_SortItemsEx(hwList, CompareListEntries, &cp);
        break;

    case ID_VIEW_ARRANGEICONS_BYPATH:
        hwList = GetDlgItem(hwnd, c_iResultListID);        
        cp.hwList = hwList;
        cp.iSubItem = 1;
        if(hwList)
            ListView_SortItemsEx(hwList, CompareListEntries, &cp);
        break;

    case ID_VIEW_CHOOSECOLUMNS:
        break;
    case ID_VIEW_REFRESH:                
        StartSearch(hwnd);
        break;
        
    // PUSH BUTTON COMMANDS
    case IDC_BROWSE:
        HandleBrowse(hwnd);
        break;

    case IDC_FINDNOW:
        StartSearch(hwnd);
        break;
    case IDC_STOP:
        StopSearch(hwnd);
        break;

    case IDC_CLEARALL:
        ClearResults(hwnd);
        break;
    }

}

void HandleSize(HWND hwnd, int /*nWidth*/, int /*nHeight*/)
{
    RECT rectCl;
    GetClientRect(hwnd, &rectCl);
    HWND hwStatic = GetDlgItem(hwnd, c_iStaticLineID);
    if(!hwStatic)
    {
        DestroyWindow(hwnd);
        return;
    }

    MoveWindow(hwStatic,rectCl.left, rectCl.top, rectCl.right-rectCl.left,
        c_nStaticLineHeight, TRUE);
    
    // Adjust list box and status bar at the bottom of the window
    HWND hwListBox, hwStatusBar, hwListFrame;
    hwListFrame = GetDlgItem(hwnd, c_iResultFrameID);
    hwListBox = GetDlgItem(hwnd, c_iResultListID);
    hwStatusBar= GetDlgItem(hwnd, c_iStatusBarID);
    
    assert(hwListBox == 0 ? !hwStatusBar && !hwListFrame : true);

    if(hwListBox && hwStatusBar && hwListFrame)
    {
        RECT rectWnd;
        GetWindowRect(hwnd, &rectWnd);
        
        POINT ptListTop;
        ptListTop.x = 0;
        ptListTop.y = rectWnd.top + g_nWindowHeight;
        ScreenToClient(hwnd, &ptListTop);        

        RECT rectSB;       
        GetClientRect(hwStatusBar, &rectSB);

        POINT ptStatusTop;
        ptStatusTop.x = 0;
        ptStatusTop.y = rectWnd.bottom - (rectSB.bottom - rectSB.top);
        ScreenToClient(hwnd, &ptStatusTop);

        MoveWindow(hwListFrame, rectCl.left, ptListTop.y, rectCl.right - rectCl.left,
            ptStatusTop.y - ptListTop.y, TRUE);
        
        MoveWindow(hwListBox, rectCl.left + c_nResultFrameWidth, 
            ptListTop.y + c_nResultFrameWidth,
            rectCl.right - rectCl.left - 2 * c_nResultFrameWidth, 
            ptStatusTop.y - ptListTop.y - 2 * c_nResultFrameWidth,
            TRUE);
        
        MoveWindow(hwStatusBar, rectCl.left, ptStatusTop.y, 
            rectCl.right - rectCl.left, rectSB.bottom - rectSB.top, TRUE);                             
    }
    
    // Adjust all controls
    RECT rcChild;
    HWND hwChild;
    POINT ptTop;
    int iWidth, iHeight;
        
    for(int i = 0; i < c_nChildren; i++)
    {    
        hwChild = GetDlgItem(hwnd, g_aiChildrenIDs[i]);
        if(!hwChild)
        {
            DestroyWindow(hwnd);
            return;
        }

        GetClientRect(hwChild, &rcChild);
                
        iWidth = rcChild.right - rcChild.left;

        iHeight = rcChild.bottom - rcChild.top;    

        ptTop.x = rcChild.left;
        ptTop.y = rcChild.top;
        ClientToScreen(hwChild, &ptTop);
        ScreenToClient(hwnd, &ptTop);

        if(g_aiChildrenIDs[i] == IDC_DRIVELIST)        
            iWidth = rectCl.right - g_aiChildrenMargins[i] - ptTop.x;

        if(g_aiChildrenIDs[i] == IDC_DRIVELIST)
            MoveWindow(hwChild, ptTop.x, ptTop.y, iWidth, iHeight, TRUE);
        else
            MoveWindow(hwChild, rectCl.right - g_aiChildrenMargins[i] - iWidth,
                ptTop.y, iWidth, iHeight, TRUE);
    }
    
    for(i = 0; i < c_nChildren; i++)
        InvalidateRect(GetDlgItem(hwnd, g_aiChildrenIDs[i]), 0, TRUE);

}

void HandleSizing(HWND hwnd, int iEdge, LPRECT pRect)
{
    if((pRect->right - pRect->left) < g_nMinWindowWidth)
    {
        if(iEdge == WMSZ_BOTTOMLEFT || iEdge == WMSZ_LEFT
            || iEdge == WMSZ_TOPLEFT)
        {
            pRect->left = pRect->right - g_nMinWindowWidth;
        }
        else if(iEdge == WMSZ_BOTTOMRIGHT || iEdge == WMSZ_RIGHT 
            || iEdge == WMSZ_TOPRIGHT)
        {
            pRect->right = pRect->left + g_nMinWindowWidth;
        }
        // Should never get here
        else
        {
            OutputDebugString(TEXT("Weird sizing stuff in HandleSizing\n"));
        }
    }

    if(GetDlgItem(hwnd, c_iResultListID))
    {
        HWND hwStatusBar = GetDlgItem(hwnd, c_iStatusBarID);
        RECT rectStatus;
        GetClientRect(hwStatusBar, &rectStatus);
        if((pRect->bottom - pRect->top) < (g_nWindowHeight + 
            c_nResultListHeight))
        {
            if(iEdge == WMSZ_BOTTOM || iEdge == WMSZ_BOTTOMLEFT ||
                iEdge == WMSZ_BOTTOMRIGHT)
            {
                pRect->bottom = pRect->top + (g_nWindowHeight + 
                    c_nResultListHeight);
            }
            else if((iEdge == WMSZ_TOP) || (iEdge == WMSZ_TOPLEFT) 
                || (iEdge == WMSZ_TOPRIGHT))
            {
                pRect->top = pRect->bottom - (g_nWindowHeight + 
                    c_nResultListHeight);
            }
            // Should never get here
            else
            {
                OutputDebugString(TEXT("Weird sizing stuff in HandleSizing\n"));
            }
        } 
    }
    else
    {
        if((pRect->bottom - pRect->top) != g_nWindowHeight)
        {
            if(iEdge == WMSZ_BOTTOM || iEdge == WMSZ_BOTTOMLEFT ||
                iEdge == WMSZ_BOTTOMRIGHT)
            {
                pRect->bottom = pRect->top + g_nWindowHeight;
            }
            else if((iEdge == WMSZ_TOP) || (iEdge == WMSZ_TOPLEFT)
                || (iEdge == WMSZ_TOPRIGHT))
            {
                pRect->top = pRect->bottom - g_nWindowHeight;
            }
            // Should never get here
            else
            {
                OutputDebugString(TEXT("Weird sizing stuff in HandleSizing\n"));
            }
        } 
    }
}

void HandleGetMinMaxInfo(HWND hwnd, LPMINMAXINFO pmmi)
{
    // Maximize normally if we have the result list box
    if(GetDlgItem(hwnd, c_iResultListID))    
        return;

    pmmi->ptMaxSize.y = g_nWindowHeight;
}

void HandleNotify(HWND hwnd, int iCtrlID, void* pvArg)
{
    LPNMHDR pHdr = reinterpret_cast<LPNMHDR>(pvArg);
    LPNMLISTVIEW pnmlvItem = reinterpret_cast<LPNMLISTVIEW>(pvArg);
   
    HWND hwList;
    HMENU hMenu;

    switch(iCtrlID)
    {
    case c_iResultListID:
        
        hwList = GetDlgItem(hwnd, c_iResultListID);

        switch(pHdr->code)
        {
        case NM_RCLICK:
            
            // Check if the click is on any row
            if(pnmlvItem->iItem != -1)
            {
                // Create a context sensitive menu.
                HMENU hmContext = LoadMenu(g_hinst, 
                    MAKEINTRESOURCE(IDM_APPSELECT));

                hmContext = GetSubMenu(hmContext, 0);

                ClientToScreen(GetDlgItem(hwnd, c_iResultListID), 
                    &pnmlvItem->ptAction);

                TrackPopupMenuEx(hmContext, 0, 
                    pnmlvItem->ptAction.x,
                    pnmlvItem->ptAction.y, hwnd, 0);
            }
            else
            {
                // FIXME
                // Create the shortcut menu
            }
        

            break;

        case LVN_ITEMCHANGED:
            hwList = GetDlgItem(hwnd, c_iResultListID);
            if(hwList)
            {
                int nCount = ListView_GetItemCount(hwList);
                int i;
                for(i = 0; i < nCount; i++)
                {
                    if(ListView_GetItemState(hwList, i, LVIS_SELECTED) 
                        & LVIS_SELECTED)
                        break;
                }

                hMenu = GetMenu(hwnd);
                if(i == nCount)
                {
                    EnableMenuItem(hMenu, ID_FILE_SHOWSHIMINFO, 
                        MF_BYCOMMAND | MF_GRAYED);
                    EnableMenuItem(hMenu, ID_FILE_PROPERTIES,
                        MF_BYCOMMAND | MF_GRAYED);
                }
                else
                {
                    EnableMenuItem(hMenu, ID_FILE_SHOWSHIMINFO, 
                        MF_BYCOMMAND | MF_ENABLED);
                    EnableMenuItem(hMenu, ID_FILE_PROPERTIES,
                        MF_BYCOMMAND | MF_ENABLED);
                }
            }
            break;
        }
    default:
        break;
    }
}

void HandleMenuSelect(HWND hwnd, HMENU hMenu, UINT uiMenuID, UINT uiFlags)
{
    HWND hwStatusBar = GetDlgItem(hwnd,c_iStatusBarID);
    if(!hwStatusBar)
        return;
    
    TCHAR* szText = 0;
    if(uiFlags & MF_POPUP)
    {
        if(hMenu != GetMenu(hwnd))
        {
            // Not a top-level menu

            // Go through all lower-level submenus
            
            // Right now only submenu is Arrange Icons
            szText = LoadStringResource(IDS_VIEW_ARRANGEICONS);
        }
    }
    else
    {
        switch(uiMenuID)
        {
		case ID_FILE_SHOWSHIMINFO:
			szText = LoadStringResource(IDS_FILE_SHOWSHIM);
			break;

        case ID_FILE_DOWNLOADPATCH:
            szText = LoadStringResource(IDS_FILE_DOWNLOADPATCH);
            break;

        case ID_FILE_PROPERTIES:
            szText = LoadStringResource(IDS_FILE_PROPERTIES);
            break;

        case ID_FILE_SAVESEARCH:
            szText = LoadStringResource(IDS_FILE_SAVESEARCH);
            break;

        case ID_FILE_EXIT:
            szText = LoadStringResource(IDS_FILE_EXIT);
            break;

        case ID_EDIT_SELECTALL:
            szText = LoadStringResource(IDS_EDIT_SELECTALL);
            break;

        case ID_EDIT_INVERTSELECTION:
            szText = LoadStringResource(IDS_EDIT_INVERTSELECTION);
            break;

        case ID_VIEW_LARGEICONS:
            szText = LoadStringResource(IDS_VIEW_LARGEICONS);
            break;

        case ID_VIEW_SMALLICONS:
            szText = LoadStringResource(IDS_VIEW_SMALLICONS);
            break;

        case ID_VIEW_ASLIST:
            szText = LoadStringResource(IDS_VIEW_ASLIST);
            break;

        case ID_VIEW_ASDETAILS:
            szText = LoadStringResource(IDS_VIEW_ASDETAILS);
            break;

        case ID_VIEW_ARRANGEICONS_BYNAME:
            szText = LoadStringResource(IDS_VIEW_ARRANGEICONS_BYNAME);
            break;

        case ID_VIEW_ARRANGEICONS_BYPATH:
            szText = LoadStringResource(IDS_VIEW_ARRANGEICONS_BYPATH);
            break;

        case ID_VIEW_CHOOSECOLUMNS:
            szText = LoadStringResource(IDS_VIEW_CHOOSECOLUMNS);
            break;

        case ID_VIEW_REFRESH:
            szText = LoadStringResource(IDS_VIEW_REFRESH);
            break;

        case ID_HELP_HELPTOPICS:
            szText = LoadStringResource(IDS_HELP_HELPTOPICS);
            break;

        case ID_HELP_WHATSTHIS:
            szText = LoadStringResource(IDS_HELP_WHATSTHIS);
            break;                   
        }
    }

    if(szText)
    {
        SetWindowText(hwStatusBar, szText);
        delete szText;
    }
    else
        SetWindowText(hwStatusBar, TEXT(""));
}

void HandleEnterMenuLoop(HWND hwnd)
{
    UpdateStatus(hwnd, TEXT(""));
    g_fInMenu = TRUE;
}

void HandleExitMenuLoop(HWND hwnd)
{
    UpdateStatus(hwnd, LoadStringResource(IDS_SEARCHDONE));
    g_fInMenu = FALSE;
}

void HandleSearchAddApp(HWND hwnd)
{
    HWND hwList = GetDlgItem(hwnd, c_iResultListID);
    if(!hwList)
        return;

    SMatchedExe* pme;
    while( (pme = GetMatchedExe()) != 0)    
        AddApp(pme, hwList);

    delete pme;
}

void HandleSearchUpdate(HWND hwnd, PTSTR szMsg)
{
    if(g_fInMenu == FALSE)
        UpdateStatus(hwnd, szMsg);

    delete szMsg;
}

int CALLBACK CompareListEntries(LPARAM lParam1, LPARAM lParam2, LPARAM lParamSort)
{
    SCompareParam* pCompParam = reinterpret_cast<SCompareParam*>(lParamSort);
    TCHAR szBuffer1[c_nMaxStringLength];
    TCHAR szBuffer2[c_nMaxStringLength];

    ListView_GetItemText(pCompParam->hwList, lParam1, pCompParam->iSubItem,
        szBuffer1, c_nMaxStringLength);

    ListView_GetItemText(pCompParam->hwList, lParam2, pCompParam->iSubItem,
        szBuffer2, c_nMaxStringLength);

    return lstrcmp(szBuffer1, szBuffer2);
}

void UpdateStatus(HWND hwnd, PTSTR szMsg)
{
    HWND hwStatus = GetDlgItem(hwnd, c_iStatusBarID);
    if(!hwStatus)
        return;

    SetWindowText(hwStatus, szMsg);
}

void AddApp(SMatchedExe* pme, HWND hwList)
{
    int iItem, iImage;
    HICON hIcon;

    HIMAGELIST himl = ListView_GetImageList(hwList, LVSIL_NORMAL);
    if(!himl)
    {
        himl = ImageList_Create(GetSystemMetrics(SM_CXICON),
            GetSystemMetrics(SM_CYICON), ILC_COLOR | ILC_MASK, 0, 0);
        if(!himl)
        {
            DestroyWindow(GetParent(hwList));
            return;
        }
        hIcon = LoadIcon(0, MAKEINTRESOURCE(IDI_APPLICATION));
       
        ImageList_AddIcon(himl, hIcon);
        ListView_SetImageList(hwList, himl, LVSIL_NORMAL);
    }
    HIMAGELIST himlSm = ListView_GetImageList(hwList, LVSIL_SMALL);
    if(!himlSm)
    {
        himlSm = ImageList_Create(GetSystemMetrics(SM_CXSMICON),
            GetSystemMetrics(SM_CYSMICON), ILC_COLOR | ILC_MASK, 0, 0);
        if(!himlSm)
        {
            DestroyWindow(GetParent(hwList));
            return;
        }
        hIcon = LoadIcon(0, MAKEINTRESOURCE(IDI_APPLICATION));
       
        ImageList_AddIcon(himlSm, hIcon);
        ListView_SetImageList(hwList, himlSm, LVSIL_SMALL);
    }

    hIcon = ExtractIcon(g_hinst, pme->szPath, 0);
    
    if(!hIcon)
    {
        iImage = 0;
    }
    else
    {
        iImage = ImageList_AddIcon(himl, hIcon);
        if(iImage == -1)
            iImage = 0;

        int iImageSm = ImageList_AddIcon(himlSm, hIcon);
        assert(iImage == iImageSm);
        DestroyIcon(hIcon);
    }


    iItem = ListView_GetItemCount(hwList);    

    // Add app to the list view.
    LVITEM lvItem;
    lvItem.mask = LVIF_IMAGE | LVIF_TEXT;
    lvItem.iItem = iItem;
    lvItem.iSubItem = 0;
    lvItem.pszText = pme->szAppName;
    lvItem.cchTextMax = lstrlen(pme->szAppName);
    lvItem.iImage = iImage;
    ListView_InsertItem(hwList, &lvItem);

    lvItem.mask = LVIF_TEXT;
    lvItem.iItem = iItem;
    lvItem.iSubItem = 1;
    lvItem.pszText = pme->szPath;
    lvItem.cchTextMax = lstrlen(pme->szPath);
    ListView_SetItem(hwList, &lvItem);    
 
    // If no items were in view prior, refresh view 
    //(otherwise "There are no items . . ." message will stay in listview.
    if(iItem == 0)    
        RedrawWindow(hwList, 0, 0, RDW_ERASE | RDW_INVALIDATE | RDW_ERASENOW);    
}

// Start searching the database
void StartSearch(HWND hwnd)
{
    HWND hwList, hwStatus, hwResultFrame;
    hwList = GetDlgItem(hwnd, c_iResultListID);
    hwStatus = GetDlgItem(hwnd, c_iStatusBarID);
    hwResultFrame = GetDlgItem(hwnd, c_iResultFrameID);

    // Both should be NULL or both non-NULL
    assert( (hwList == 0) ? (hwStatus == 0 && hwResultFrame == 0) : true);

    if(!hwList)
    { 
        // Expand the window to encompass the new lsitview.
        RECT rectWnd;
        GetWindowRect(hwnd, &rectWnd);
        MoveWindow(hwnd, rectWnd.left, rectWnd.top,
            rectWnd.right - rectWnd.left, 
            c_nResultListHeight + g_nWindowHeight, TRUE);


        // See if use has checked show small icons, large icons, etc.,
        // and set appropriate listview style.
        MENUITEMINFO mii;
        HMENU hMenu = GetMenu(hwnd);
        ZeroMemory(&mii, sizeof(mii));
        mii.cbSize = sizeof(mii);
        mii.fMask = MIIM_STATE;

        DWORD dwStyle = WS_CHILD | WS_VISIBLE | LVS_SHOWSELALWAYS;
        DWORD dwExStyle = LVS_EX_LABELTIP;
        GetMenuItemInfo(hMenu, ID_VIEW_LARGEICONS, FALSE, &mii);
        if(mii.fState & MFS_CHECKED)
            dwStyle |= LVS_ICON;        

        ZeroMemory(&mii, sizeof(mii));
        mii.cbSize = sizeof(mii);
        mii.fMask = MIIM_STATE;
        GetMenuItemInfo(hMenu, ID_VIEW_SMALLICONS, FALSE, &mii);
        if(mii.fState & MFS_CHECKED)
            dwStyle |= LVS_SMALLICON;

        ZeroMemory(&mii, sizeof(mii));
        mii.cbSize = sizeof(mii);
        mii.fMask = MIIM_STATE;
        GetMenuItemInfo(hMenu, ID_VIEW_ASLIST, FALSE, &mii);
        if(mii.fState & MFS_CHECKED)
            dwStyle |= LVS_LIST;

        ZeroMemory(&mii, sizeof(mii));
        mii.cbSize = sizeof(mii);
        mii.fMask = MIIM_STATE;
        GetMenuItemInfo(hMenu, ID_VIEW_ASDETAILS, FALSE, &mii);
        if(mii.fState & MFS_CHECKED)
        {
            dwStyle |= LVS_REPORT;
            dwExStyle |= LVS_EX_FULLROWSELECT;
        }
        
        // Create the status bar.
        TCHAR* szCaption = LoadStringResource(IDS_SEARCHING);
        if(!szCaption)
        {
            DestroyWindow(hwnd);
            return;
        }

        hwStatus = CreateStatusWindow(WS_CHILD | WS_VISIBLE,
            szCaption, hwnd, c_iStatusBarID);
        if(!hwStatus)
        {
            DestroyWindow(hwnd);
            return;
        }

        delete szCaption;

        RECT rectCl;
        RECT rectSB;

        GetClientRect(hwnd, &rectCl);
        GetClientRect(hwnd, &rectSB);

        // Round about way of getting top coordinate of
        // status bar to a client coordinate in main window
        POINT ptStatusTop;
        ptStatusTop.x = 0;
        ptStatusTop.y = rectSB.top;
        ClientToScreen(hwStatus, &ptStatusTop);
        ScreenToClient(hwnd, &ptStatusTop);
        
        // Bottom of window prior to resizing
        POINT ptListTop;
        ptListTop.x = 0;
        ptListTop.y = rectWnd.bottom;
        ScreenToClient(hwnd, &ptListTop);

        // Create static frame around listview.
        hwResultFrame = CreateWindowEx(0, TEXT("static"), TEXT(""),
            WS_VISIBLE | WS_CHILD | SS_BLACKRECT | SS_SUNKEN,
            rectCl.left, ptListTop.y, rectCl.right-rectCl.left,
            ptStatusTop.y - ptListTop.y,
            hwnd, reinterpret_cast<HMENU>(c_iResultFrameID), g_hinst, 0);

        if(!hwResultFrame)
        {
            DestroyWindow(hwnd);
            return;
        }

        // Create the listview window.
        hwList = CreateWindowEx(0, WC_LISTVIEW, TEXT(""), 
            dwStyle, rectCl.left + c_nResultFrameWidth, 
            ptListTop.y + c_nResultFrameWidth, 
            rectCl.right - rectCl.left - 2 * c_nResultFrameWidth, 
            ptStatusTop.y - ptListTop.y - c_nResultFrameWidth, 
            hwnd,reinterpret_cast<HMENU>(c_iResultListID), g_hinst, 0);

        if(!hwList)
        {
            DestroyWindow(hwnd);
            return;
        }

        // Subclass the window
        pfnLVOrgWndProc = 
            reinterpret_cast<WNDPROC>(GetWindowLongPtr(hwList, GWL_WNDPROC));
        
        SetWindowLongPtr(hwList, GWL_WNDPROC, 
            reinterpret_cast<UINT_PTR>(LVWndProc));                

        ListView_SetExtendedListViewStyleEx(hwList, 0, dwExStyle);

        // Insert listview columns.
        for(int i = 0; i < c_nNumListColumns; i++)
        {
            LVCOLUMN lvCol;
            lvCol.mask = LVCF_FMT | LVCF_TEXT | LVCF_ORDER | LVCF_WIDTH |
                LVCF_SUBITEM;
            lvCol.fmt = LVCFMT_LEFT;
            lvCol.pszText = LoadStringResource(c_iListColumnNameIDS[i]);
            lvCol.cchTextMax = lstrlen(lvCol.pszText);
            lvCol.iSubItem = i;
            lvCol.iOrder = i;
            lvCol.cx = c_nListColumnWidth;

            ListView_InsertColumn(hwList, i, &lvCol);
        
            delete lvCol.pszText;
        }

        // "Remaximize" if it is already maximized
        if(GetWindowLongPtr(hwnd, GWL_STYLE) & WS_MAXIMIZE)
        {
            HWND hwDesktop = GetDesktopWindow();
            RECT rcDesktop;
            GetClientRect(hwDesktop, &rcDesktop);
            MoveWindow(hwnd, rcDesktop.left, rcDesktop.top,
                rcDesktop.right - rcDesktop.left, rcDesktop.bottom - rcDesktop.top,
                TRUE);

            // Set correct restore position
            WINDOWPLACEMENT wndpl;
            GetWindowPlacement(hwnd, &wndpl);
            wndpl.rcNormalPosition.bottom = wndpl.rcNormalPosition.top +
                g_nWindowHeight + c_nResultListHeight;
            
            SetWindowPlacement(hwnd, &wndpl);

        }
    }

    // If it exists, just reset the content
    else
    {
        TCHAR* szMsg;
        TCHAR* szCaption;
        szMsg = LoadStringResource(IDS_CLRALLMSG);
        szCaption = LoadStringResource(IDS_CLRALLCAPTION);
        if(!szMsg || !szCaption)
        {
            DestroyWindow(hwnd);
            return;
        }

        if(MessageBox(hwnd, szMsg, szCaption, MB_ICONINFORMATION |
            MB_OKCANCEL) == IDOK)        
            ListView_DeleteAllItems(GetDlgItem(hwnd, c_iResultListID));
        else
            return;
    }
    
    // Enable the view options related to the result list
    HMENU hMenu;
    hMenu = GetMenu(hwnd);

    HMENU hmView = GetSubMenu(hMenu, c_iViewMenuPos);    

    EnableMenuItem(hmView, c_iArrangeIconsPos, MF_BYPOSITION | MF_ENABLED);
    EnableMenuItem(hMenu, ID_VIEW_ARRANGEICONS_BYPATH, MF_BYCOMMAND | MF_ENABLED);
    EnableMenuItem(hMenu, ID_VIEW_CHOOSECOLUMNS, MF_BYCOMMAND | MF_ENABLED);
    EnableMenuItem(hMenu, ID_VIEW_REFRESH, MF_BYCOMMAND | MF_ENABLED);    

    EnableWindow(GetDlgItem(hwnd, IDC_STOP), TRUE);
    EnableWindow(GetDlgItem(hwnd, IDC_CLEARALL), TRUE);

    // Find out what to search for
    HWND hwComboBox = GetDlgItem(hwnd, IDC_DRIVELIST);
    
    // If zero is selected, search for everything.
    if(SendMessage(hwComboBox, CB_GETCURSEL, 0, 0)==0)
        SearchDB(0, hwnd);
    else
    {
        TCHAR szBuffer[MAX_PATH+1];
        COMBOBOXEXITEM cbim;
        cbim.mask = CBEIF_TEXT;
        cbim.iItem = -1;
        cbim.pszText = szBuffer;
        cbim.cchTextMax = MAX_PATH;
        SendMessage(hwComboBox, CBEM_GETITEM, 0, 
            reinterpret_cast<LPARAM>(&cbim));

        if(szBuffer[lstrlen(szBuffer)-1] != TEXT('\\'))
            lstrcat(szBuffer, TEXT("\\"));

        SearchDB(szBuffer, hwnd);
    }

    // Start animating the icon.
    HWND hwAnim = GetDlgItem(hwnd, c_iFindAnimID);
    Animate_Play(hwAnim, 0, -1, -1);
}

// Terminate the search.
void StopSearch(HWND hwnd)
{
    // Stop searching the database.
    StopSearchDB();

    // Can't click "STOP" or anymore.
    EnableWindow(GetDlgItem(hwnd, IDC_STOP), FALSE);

    // Update with a search complete if not in menu.
    if(g_fInMenu == FALSE)
        UpdateStatus(hwnd, LoadStringResource(IDS_SEARCHDONE));

    // Stop animating the icon.
    HWND hwAnim = GetDlgItem(hwnd, c_iFindAnimID);
    Animate_Stop(hwAnim);
}

// Remove result window.
void ClearResults(HWND hwnd)
{
    TCHAR* szMsg;
    TCHAR* szCaption;
    szMsg = LoadStringResource(IDS_CLRALLMSG);
    szCaption = LoadStringResource(IDS_CLRALLCAPTION);
    if(!szMsg || !szCaption)
    {
        DestroyWindow(hwnd);
        return;
    }

    if(MessageBox(hwnd, szMsg, szCaption, MB_ICONINFORMATION |
        MB_OKCANCEL) == IDCANCEL)
        return;

    // Stop the search
    StopSearch(hwnd);

    // Get rid of all result-related windows.
    HWND hwCtrl;
    if( (hwCtrl = GetDlgItem(hwnd, c_iResultListID)) != 0)
        DestroyWindow(hwCtrl);    

    if( (hwCtrl = GetDlgItem(hwnd, c_iStatusBarID)) != 0)    
        DestroyWindow(hwCtrl);    
    
    if( (hwCtrl = GetDlgItem(hwnd, c_iResultFrameID)) != 0)    
        DestroyWindow(hwCtrl);    

    // Restore original window size.
    RECT rect;
    GetWindowRect(hwnd, &rect);
    MoveWindow(hwnd, rect.left, rect.top, rect.right - rect.left, 
        g_nWindowHeight, TRUE);

    // Do cleanup if we were maximized
    if(GetWindowLongPtr(hwnd, GWL_STYLE) & WS_MAXIMIZE)
    {
        // Set correct restore position
        WINDOWPLACEMENT wndpl;
        GetWindowPlacement(hwnd, &wndpl);
        wndpl.rcNormalPosition.bottom = wndpl.rcNormalPosition.top +
            g_nWindowHeight;
        
        SetWindowPlacement(hwnd, &wndpl);
    }

    // Disable the view options related to the result list
    HMENU hMenu;
    hMenu = GetMenu(hwnd);

    EnableMenuItem(hMenu, ID_FILE_DOWNLOADPATCH, MF_BYCOMMAND | MF_GRAYED);
    EnableMenuItem(hMenu, ID_FILE_PROPERTIES, MF_BYCOMMAND | MF_GRAYED);
    
    HMENU hmView = GetSubMenu(hMenu, c_iViewMenuPos);

    EnableMenuItem(hmView, c_iArrangeIconsPos, MF_BYPOSITION | MF_GRAYED);
    EnableMenuItem(hMenu, ID_VIEW_ARRANGEICONS_BYPATH, MF_BYCOMMAND | MF_GRAYED);
    EnableMenuItem(hMenu, ID_VIEW_CHOOSECOLUMNS, MF_BYCOMMAND | MF_GRAYED);
    EnableMenuItem(hMenu, ID_VIEW_REFRESH, MF_BYCOMMAND | MF_GRAYED);

    EnableWindow(GetDlgItem(hwnd, IDC_CLEARALL), FALSE);
}

// Subclass for listview, customize painting.
LRESULT CALLBACK LVWndProc(HWND hwnd, UINT uiMsg, WPARAM wParam, LPARAM lParam)
{
    // Only bother if it's a PAINT message and no items are in listbox.
    if((uiMsg == WM_PAINT) && (ListView_GetItemCount(hwnd) == 0))
    {        
        // Get rectangle for text.
        RECT rc;
        GetWindowRect(hwnd, &rc);
        POINT pt;
        pt.x = rc.left;
        pt.y = rc.top;
        ScreenToClient(hwnd, &pt);
        rc.left = pt.x;
        rc.top = pt.y;
        pt.x = rc.right;
        pt.y = rc.bottom;
        ScreenToClient(hwnd, &pt);
        rc.right = pt.x;
        rc.bottom = pt.y;

        HWND hwHeader = ListView_GetHeader(hwnd);
        if(hwHeader)
        {
            RECT rcHeader;
            Header_GetItemRect(hwHeader, 0, &rcHeader);
            rc.top += rcHeader.bottom;
        }

        rc.top += 10;

        // Do the default painting of the listview paint.
        InvalidateRect(hwnd, &rc, TRUE);
        CallWindowProc(pfnLVOrgWndProc, hwnd, uiMsg, wParam, lParam);

        HDC hdc = GetDC(hwnd);

        SaveDC(hdc);

        SetTextColor(hdc, GetSysColor(COLOR_WINDOWTEXT));
        SetBkColor(hdc, GetSysColor(COLOR_WINDOW));
        HFONT hFont = static_cast<HFONT>(GetStockObject(ANSI_VAR_FONT));
        SelectObject(hdc, hFont);

        // Get message to print.
        TCHAR* szMsg = LoadStringResource(IDS_EMPTYLIST);        

        DrawText(hdc, szMsg, -1, &rc, DT_CENTER | DT_WORDBREAK 
            | DT_NOPREFIX | DT_NOCLIP);

        RestoreDC(hdc, -1);
        ReleaseDC(hwnd, hdc);

        delete szMsg;
        return 0;
    } else if(uiMsg == WM_NOTIFY)
    {
        HWND hwHeader = ListView_GetHeader(hwnd);
        if(hwHeader)
        {
            if(static_cast<int>(wParam) == GetDlgCtrlID(hwHeader))
            {
                LPNMHEADER pHdr = reinterpret_cast<LPNMHEADER>(lParam);
                
                if(pHdr->hdr.code == HDN_ITEMCHANGED)                
                {
                    RECT rc;
                    GetClientRect(hwHeader, &rc);
                    POINT pt;
                    pt.y = rc.bottom;
                    ClientToScreen(hwHeader, &pt);
                    ScreenToClient(hwnd, &pt);
                    GetClientRect(hwnd, &rc);
                    rc.top = pt.y;
                    InvalidateRect(hwnd, &rc, TRUE);
                }
            }
        }

        return CallWindowProc(pfnLVOrgWndProc, hwnd, uiMsg, wParam, lParam);

    }
    else    
        return CallWindowProc(pfnLVOrgWndProc, hwnd, uiMsg, wParam, lParam);
}

// Allocate a new string and copy a string resource into it.
TCHAR* LoadStringResource(UINT uID)
{
    TCHAR szBuffer[c_nMaxStringLength];
    TCHAR* szRet = 0;

    if(LoadString(g_hinst, uID, szBuffer, c_nMaxStringLength))
    {
        szRet = new TCHAR[lstrlen(szBuffer)+1];
        if(szRet)
            lstrcpy(szRet, szBuffer);
    }

    return szRet;
}

// Print an error message box in hwnd, with string resource with id as 
// message.
void Error(HWND hwnd, UINT id)
{
    PTSTR szMsg = LoadStringResource(id);
    PTSTR szCaption = LoadStringResource(IDS_ERROR);
    if(szMsg && szCaption)
        MessageBox(hwnd, szMsg, szCaption, MB_OK | MB_ICONERROR);

    if(szMsg)
        delete szMsg;

    if(szCaption)
        delete szCaption;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\appcompat\tools\appsearch\main.h ===
#ifndef MAIN_H
#define MAIN_H

#include <windows.h>

const int c_nMaxStringLength    = 1024;

extern HINSTANCE g_hinst;

void Error(HWND hwnd, UINT uiMsg);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\appcompat\tools\appsearch\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by AppSearch.rc
//
#define ID_APPSELECT_PROPERTIES         0
#define IDS_APPNAME                     1
#define IDS_ALLDRIVES                   1
#define IDS_FINDNOW                     2
#define IDS_CLRALLMSG                   2
#define IDS_STOP                        3
#define ID_CLEARALL                     3
#define IDS_CLRALLCAPTION               3
#define IDS_CLEARALL                    4
#define IDS_LISTNAME                    4
#define IDS_LISTPATH                    5
#define IDS_FILE_CREATESHORTCUT         6
#define IDS_FILE_PROPERTIES             7
#define IDS_FILE_SAVESEARCH             8
#define IDS_FILE_EXIT                   9
#define IDS_EDIT_SELECTALL              10
#define IDS_EDIT_INVERTSELECTION        11
#define IDS_VIEW_FILTER                 12
#define IDS_VIEW_LARGEICONS             13
#define IDS_VIEW_SMALLICONS             14
#define IDS_VIEW_ARRANGEICONS           17
#define IDS_VIEW_ARRANGEICONS_BYNAME    18
#define IDS_VIEW_ARRANGEICONS_BYPATH    19
#define IDS_VIEW_CHOOSECOLUMNS          20
#define IDS_VIEW_REFRESH                21
#define IDS_HELP_HELPTOPICS             22
#define IDS_HELP_WHATSTHIS              23
#define IDS_FILE_DOWNLOADPATCH          24
#define IDS_SEARCHDONE                  25
#define IDS_LISTVERSION                 26
#define IDS_LISTCOMPANY                 27
#define IDS_EMPTYLIST                   28
#define IDS_NOMEMSTOPSEARCH             29
#define IDS_NOMEMSTOPPROG               30
#define IDS_ERROR                       31
#define IDS_SEARCHING                   32
#define IDS_INVALIDPATH                 33
#define IDS_FILE_SHOWSHIM               34
#define IDM_MAINMENU                    102
#define IDI_APP                         103
#define IDD_MAINDIALOG                  104
#define IDI_DRIVE                       112
#define IDI_ALLDRIVES                   113
#define IDM_APPSELECT                   117
#define IDD_BROWSE                      121
#define IDI_FOLDER                      122
#define IDI_FOLDEROPEN                  123
#define IDD_SHIMINFO                    124
#define IDR_FINDAVI                     131
#define ID_FINDNOW                      1000
#define ID_STOP                         1001
#define IDC_FINDNOW                     1002
#define IDC_CLEARALL                    1004
#define IDC_DRIVELIST                   1006
#define IDC_IN                          1007
#define IDC_BROWSE                      1010
#define IDC_STOP                        1011
#define IDC_APPICON                     1020
#define IDC_DIRTREE                     1025
#define IDC_SHIMLIST                    1027
#define IDC_SHIMDESC                    1028
#define IDC_FILELISTCOMBO               1031
#define IDC_ANIMSPACEHOLDER             1034
#define ID_FILE_CREATESHORTCUT          40001
#define ID_FILE_PROPERTIES              40002
#define ID_FILE_SAVESEARCH              40003
#define ID_EDIT_SELECTALL               40005
#define ID_EDIT_INVERTSELECTION         40006
#define ID_VIEW_FILTER                  40007
#define ID_VIEW_LARGEICONS              40008
#define ID_VIEW_SMALLICONS              40009
#define ID_VIEW_CHOOSECOLUMNS           40012
#define ID_VIEW_REFRESH                 40013
#define ID_VIEW_ARRANGEICONS_BYNAME     40014
#define ID_VIEW_ARRANGEICONS_BYPATH     40015
#define ID_HELP_HELPTOPICS              40016
#define ID_HELP_WHATSTHIS               40017
#define ID_FILE_EXIT                    40018
#define ID_APPSELECT_DOWNLOAD           40031
#define ID_FILE_DOWNLOADPATCH           40032
#define ID_APPSELECT_SHOWSHIMINFO       40033
#define ID_FILE_SHOWSHIMINFO            40034
#define ID_VIEW_ASLIST                  40036
#define ID_VIEW_ASDETAILS               40037
#define IDS_VIEW_ASLIST					40038
#define IDS_VIEW_ASDETAILS				40039

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NO_MFC                     1
#define _APS_NEXT_RESOURCE_VALUE        132
#define _APS_NEXT_COMMAND_VALUE         40035
#define _APS_NEXT_CONTROL_VALUE         1035
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\appcompat\tools\appsearch\filebrowser.h ===
#ifndef FILEBROWSER_H
#define FILEBROWSER_H

#include <windows.h>

const int BF_SELECTDIRECTORIES  = 0x01;
const int BF_SELECTFILES        = 0x02;
const int BF_HARDDRIVES         = 0x04;
const int BF_FLOPPYDRIVES       = 0x08;
const int BF_NETWORKDRIVES      = 0x10;
const int BF_CDROMDRIVES        = 0x20;

// Display browse dialog box, and return dir string.  String does
// not need to be freed, will be overwritten by subsequent calls.
PTSTR BrowseForFolder(HWND hwnd, PTSTR szInitialPath, UINT uiFlags);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\appcompat\tools\appsearch\searchdb.cpp ===
// AppSearch
//
// Tool for searching a user's hard drives and locating
// applications that can be patched, and downloading those
// patches from Windows Update
// 
// Author: t-michkr (9 June 2000)
//
// searchdb.cpp
// Functions for searching the shim database.
#include <windows.h>
#include <assert.h>

extern "C"
{
    #include <shimdb.h>
}

#include "searchdb.h"
#include "main.h"
#include "resource.h"

// Private message used internally to stop a search.
const int WM_SEARCHDB_STOP      = WM_SEARCHDB_BASE + 3;

// Some globals needed by the shimdb library
typedef PVOID (*PFNRTLALLOCATEHEAP)(PVOID, ULONG, SIZE_T);
typedef BOOL (*PFNRTLFREEHEAP)(PVOID, ULONG, PVOID);

extern "C"
{
    PFNRTLALLOCATEHEAP g_pfnRtlAllocateHeap;
    PFNRTLFREEHEAP g_pfnRtlFreeHeap;
    PVOID g_pShimHeap;
}

HSDB g_hSDB;

// Parameters to search thread
struct SSearchThreadParam
{
    PTSTR szPath;
    HWND hwCaller;

    ~SSearchThreadParam()
    {
        if(szPath)
            delete szPath;
        szPath = 0;
    }
};

// A node in the queue of matched EXE's.
struct SMatchedExeQueueNode
{
    SMatchedExe* pMatchedExe;
    SMatchedExeQueueNode* pNext;
};

// Our queue of matched EXE's
static SMatchedExeQueueNode* g_pHead = 0, *g_pTail = 0;

// Handle of the search thread
static HANDLE       g_hThread   = 0;

// The ID of the search thread
static DWORD        g_dwThreadID      = 0;

// Lock for mutual exclusion
static CRITICAL_SECTION     g_csLock;

// Internal functions
static BOOL AddQueueItem(SMatchedExe* pme);
static BOOL SearchDirectory(PTSTR szDir, HWND hwCaller);
static unsigned int __stdcall SearchThread(SSearchThreadParam* pstp);
static BOOL NotifyExeFound(HWND hwnd, PCTSTR szAppName, PCTSTR szPath);

// Add an exe to the queue of found exe's.
BOOL AddQueueItem(SMatchedExe* pme)
{
    assert(pme);
    SMatchedExeQueueNode* pNewNode = new SMatchedExeQueueNode;
    if(!pNewNode)
    {
        Error(0, IDS_NOMEMSTOPSEARCH);
        return FALSE;
    }

    pNewNode->pMatchedExe = pme;
    pNewNode->pNext = 0;

    EnterCriticalSection(&g_csLock);

    if(g_pHead == 0)
        g_pHead = g_pTail = pNewNode;
    else
    {
        g_pTail->pNext = pNewNode;
        g_pTail = pNewNode;
    }

    LeaveCriticalSection(&g_csLock);

    return TRUE;
}

// Return a single exe from the list, NULL if empty.
SMatchedExe* GetMatchedExe()
{
    SMatchedExe*            pRet        = 0;
    SMatchedExeQueueNode*   pNewHead    = 0;
    EnterCriticalSection(&g_csLock);
    if(g_pHead != NULL)
    {
        pRet = g_pHead->pMatchedExe;
        pNewHead = g_pHead->pNext;
        delete g_pHead;
        g_pHead = pNewHead;
    }
    
    LeaveCriticalSection(&g_csLock);

    return pRet;
}

// Called recursively, TRUE return means continue, FALSE
// means terminate.
BOOL SearchDirectory(PTSTR szPath, HWND hwCaller)
{
    // Send an update to the caller window . . .
    TCHAR* szTemp = new TCHAR[lstrlen(szPath) + 1];
    if(!szTemp)
    {
        Error(0, IDS_NOMEMSTOPSEARCH);
        return FALSE;
    }

    lstrcpy(szTemp, szPath);
    PostMessage(hwCaller, WM_SEARCHDB_UPDATE, 0, reinterpret_cast<LPARAM>(szTemp));

    WIN32_FIND_DATA fileFindData;
    HANDLE hSearch;

    PTSTR szSearchPath;
    MSG msg;

    // Check if we've been told to terminate.
    if(PeekMessage(&msg, 0, 0, 0, PM_REMOVE))
    {
        if(msg.message == WM_SEARCHDB_STOP)
            return FALSE;
    }

    szSearchPath = new TCHAR[lstrlen(szPath)+lstrlen(TEXT("*.exe")) +1];
    if(!szSearchPath)
    {
        Error(0, IDS_NOMEMSTOPSEARCH);
        return FALSE;
    }
    
    wsprintf(szSearchPath, TEXT("%s*.exe"), szPath);
    
    hSearch = FindFirstFile(szSearchPath, &fileFindData);

    delete szSearchPath;
    szSearchPath = 0;

    if(hSearch != INVALID_HANDLE_VALUE)
    {
        do
        {
            if(!(fileFindData.dwFileAttributes & 
                (FILE_ATTRIBUTE_SYSTEM | FILE_ATTRIBUTE_HIDDEN
                | FILE_ATTRIBUTE_DIRECTORY)))
            {

                PTSTR szExePath;

                szExePath = new TCHAR[lstrlen(szPath)+
                    lstrlen(fileFindData.cFileName)+1];
                if(!szExePath)
                {
                    Error(0, IDS_NOMEMSTOPSEARCH);
                    return FALSE;
                }

                wsprintf(szExePath, TEXT("%s%s"), szPath, 
                    fileFindData.cFileName);

                SDBQUERYRESULT sdbQuery;
                
                ZeroMemory(&sdbQuery, sizeof(SDBQUERYRESULT));

                SdbGetMatchingExe(g_hSDB, szExePath, NULL, NULL, SDBGMEF_IGNORE_ENVIRONMENT, &sdbQuery);
                
                if(sdbQuery.atrExes[0] != TAGREF_NULL)
                {
                    DWORD dwNumExes;

                    //
                    // count the exes
                    //
                    for (dwNumExes = 0; dwNumExes < SDB_MAX_EXES; ++dwNumExes) {
                        if (sdbQuery.atrExes[dwNumExes] == TAGREF_NULL) {
                            break;
                        }
                    }

                    //
                    // for now, just get the info for the last exe in the list, which will
                    // be the one with specific info for this app.
                    // BUGBUG -- is this the right thing to do? dmunsil
                    //
                    TAGREF trExe = sdbQuery.atrExes[dwNumExes - 1];
                    TCHAR  szAppName[c_nMaxStringLength] = TEXT("");
                    TAGREF trAppName = SdbFindFirstTagRef(g_hSDB, trExe, TAG_APP_NAME);

                    if(trAppName == TAGREF_NULL)
                        wsprintf(szAppName, TEXT("%s%s"), szPath, fileFindData.cFileName);
                    else
                        SdbReadStringTagRef(g_hSDB, trAppName, szAppName, c_nMaxStringLength);

                    NotifyExeFound(hwCaller, szAppName, szExePath);

                    SdbReleaseMatchingExe(g_hSDB, trExe);
                }
                delete szExePath;
                szExePath = 0;
            }
        } while(FindNextFile(hSearch, &fileFindData));
        
        FindClose(hSearch);
    }

    // Recurse into subdirectories

    // Unsure how to do attribute based search, let's just
    // look for everything and take note of directories.
    szSearchPath = new TCHAR[lstrlen(szPath)+2];    
    if(!szSearchPath)
    {
        Error(0, IDS_NOMEMSTOPSEARCH);
        return FALSE;
    }

    wsprintf(szSearchPath, TEXT("%s*"), szPath);
    hSearch = FindFirstFile(szSearchPath, &fileFindData);
    delete szSearchPath;
    szSearchPath = 0;

    if(hSearch != INVALID_HANDLE_VALUE)
    {
        do
        {
            if(fileFindData.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY)
            {
                // Don't do an infinite directory recursion
                if( !((lstrcmp(fileFindData.cFileName, TEXT(".")) == 0) ||
                    (lstrcmp(fileFindData.cFileName, TEXT("..")) == 0)))
                {
                    szSearchPath = new TCHAR[lstrlen(szPath)+
                        lstrlen(fileFindData.cFileName)+2]; 

                    if(!szSearchPath)
                    {
                        Error(0, IDS_NOMEMSTOPSEARCH);
                        return FALSE;
                    }


                    wsprintf(szSearchPath, TEXT("%s%s\\"), szPath, 
                        fileFindData.cFileName);

                    if(SearchDirectory(szSearchPath, hwCaller) == FALSE)
                    {
                        FindClose(hSearch);
                        delete szSearchPath;
                        return FALSE;
                    }
                    delete szSearchPath;
                    szSearchPath = 0;
                }
            }
        } while(FindNextFile(hSearch, &fileFindData));

        FindClose(hSearch);
    }

    return TRUE;
}

// Wrapper thread for database search.
unsigned int __stdcall SearchThread(SSearchThreadParam* pstp)
{    
    if((g_hSDB = SdbInitDatabase(0, NULL)) == NULL)
        return 0;

    // If NULL is passed in, just search all user drives.
    if(pstp->szPath == 0)
    {
        DWORD dwLength = GetLogicalDriveStrings(0,0);

        TCHAR* szDrives = new TCHAR[dwLength+1];
        if(szDrives)
        {
            GetLogicalDriveStrings(dwLength, szDrives);
            TCHAR* szCurrDrive = szDrives;
            while(*szCurrDrive)
            {
                if(GetDriveType(szCurrDrive) == DRIVE_FIXED)            
                    if(!SearchDirectory(szCurrDrive, pstp->hwCaller))
                        break;
        
                szCurrDrive += lstrlen(szCurrDrive) + 1;
            }
        }
        else
            Error(pstp->hwCaller, IDS_NOMEMSTOPSEARCH);
    }
    else
        SearchDirectory(pstp->szPath, pstp->hwCaller);

    // Notify caller that search is complete.
    PostMessage(pstp->hwCaller, WM_SEARCHDB_DONE, 0, 0);

    delete pstp;

    SdbReleaseDatabase(g_hSDB);

    return 0;
}

// Notify caller that an exe has been found.
BOOL NotifyExeFound(HWND hwnd, PCTSTR szAppName, PCTSTR szPath)
{
    SMatchedExe* pme = 0;

    pme = new SMatchedExe;
    if(!pme)
    {
        Error(0, IDS_NOMEMSTOPSEARCH);
        return FALSE;
    }


    pme->szAppName = new TCHAR[lstrlen(szAppName)+1];
    if(!pme->szAppName)
    {
        Error(0, IDS_NOMEMSTOPSEARCH);
        return FALSE;
    }
    lstrcpy(pme->szAppName, szAppName);

    pme->szPath = new TCHAR[lstrlen(szPath)+1];
    if(!pme->szPath)
    {
        Error(0, IDS_NOMEMSTOPSEARCH);
        return FALSE;
    }
    lstrcpy(pme->szPath, szPath);

    // Add to the queue of found exe's
    if(!AddQueueItem(pme))
        return FALSE;

    // Notify the caller.
    PostMessage(hwnd, WM_SEARCHDB_ADDAPP, 0, 0);

    return TRUE;
}

// SearchDB()
// Will search a user's hard drives looking for applications
// that have entries in the AppCompat database.
// szDrives is a string similar in format to
// the string returned by GetLogicalDriveStrings()
// If 0 is passed, it will call GetLogicalDriveStrings()
// and parse all hard drives.
// Messages will be posted to the caller window
// in response to events
BOOL SearchDB(PCTSTR szPath, HWND hwCaller)
{
    SSearchThreadParam* p = new SSearchThreadParam;
    if(!p)
    {
        Error(hwCaller, IDS_NOMEMSTOPSEARCH);
        return FALSE;
    }

    p->hwCaller = hwCaller;
    if(szPath)
    {
        p->szPath = new TCHAR[lstrlen(szPath)+1];
        if(!p->szPath)
        {
            Error(hwCaller, IDS_NOMEMSTOPSEARCH);
            return FALSE;
        }
        lstrcpy(p->szPath, szPath);
    }
    else
        p->szPath = NULL;

    if(g_hThread)
        StopSearchDB();

    g_hThread = CreateThread(0, 0, 
        reinterpret_cast<LPTHREAD_START_ROUTINE>(SearchThread), p,
        0, &g_dwThreadID);

    if(g_hThread == NULL)
        return FALSE;

    return TRUE;
}

// Terminate the search.
void StopSearchDB()
{
    // As long as the thread is active
    if(g_hThread && (WaitForSingleObject(g_hThread, 0) != WAIT_OBJECT_0))
    {
        // Post in a while to ensure that the message queue was
        // created.
        while((PostThreadMessage(g_dwThreadID, WM_SEARCHDB_STOP, 0, 0)==FALSE)
            && (GetLastError() != ERROR_INVALID_THREAD_ID))
            Sleep(0);        

        if(GetLastError() != ERROR_INVALID_THREAD_ID)
            WaitForSingleObject(g_hThread, INFINITE);               
    }

    if(g_hThread)
        CloseHandle(g_hThread);

    g_hThread = 0;
}

// Setup all globals needed.
BOOL InitSearchDB()
{
    InitializeCriticalSection(&g_csLock);
    g_pShimHeap = GetProcessHeap();
    g_pfnRtlAllocateHeap = HeapAlloc;
    g_pfnRtlFreeHeap = HeapFree;
    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\appcompat\tools\appsearch\searchdb.h ===
#ifndef SEARCHDB_H
#define SEARCHDB_H

#include <windows.h>

// Messages for communication with search thread and caller
const int WM_SEARCHDB_BASE      = WM_USER + 0xabba;
const int WM_SEARCHDB_UPDATE    = WM_SEARCHDB_BASE;
const int WM_SEARCHDB_ADDAPP    = WM_SEARCHDB_BASE    + 1;
const int WM_SEARCHDB_DONE      = WM_SEARCHDB_BASE  + 2;

// An exe that has an entry in the database
struct SMatchedExe
{
    // App Name (Like "Final Fantasy VII")
    PTSTR szAppName;
    
    // Path (Like C:\Program Files\SquareSoft\FinalFantasy7\ff7.exe")
    PTSTR szPath;

    SMatchedExe() : szAppName(0), szPath(0)
    {}

    ~SMatchedExe()
    {
        if(szAppName)
            delete szAppName;
        if(szPath)
            delete szPath;        

        szAppName = szPath = 0;
    }
};

SMatchedExe* GetMatchedExe();
BOOL SearchDB(PCTSTR szDrives, HWND hwCaller);
void FreeMatchedExe(SMatchedExe* pme);
void StopSearchDB();
BOOL InitSearchDB();

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\appcompat\tools\appsearch\browsedlg.cpp ===
// BrowseDlg.cpp
// Dialog box to enable user to select a directory and/or files.

// Author: t-michkr (June 22, 2000)

#include <windows.h>
#include <commctrl.h>
#include <shlwapi.h>
#include <shellapi.h>
#include <tchar.h>
#include <assert.h>
#include "main.h"
#include "filebrowser.h"
#include "resource.h"

// Display browse dialog box, and return dir string.
PSTR BrowseForFolder(HWND hwnd, PSTR szInitialPath, UINT uiFlags);

// Expand a tree item to include sub items.
void AddTreeSubItems(HWND hwTree, HTREEITEM hParent);

// Remove a tree item's subitems
void RemoveTreeSubItems(HWND hwTree, HTREEITEM hParent);

void CheckTreeSubItems(HWND hwTree, HTREEITEM hChild);

// Given a path, select the appropriate item in the tree.
// If path is invalid, it will expand as much as possible 
// (until invalid element appears)
void SelectItemFromFullPath(HWND hwTree, PTSTR szPath);

// Get full item path.  Assumes szPath is a buffer of MAX_PATH size,
// initialized with '\0'.
void GetItemPath(HWND hwTree, HTREEITEM hItem, PTSTR szPath);

// Browse dialog proc
BOOL CALLBACK BrowseDialogProc(HWND hwnd, UINT uiMsg, WPARAM wParam, LPARAM lParam);

// Browse dialog box message handlers.
BOOL HandleInitBrowse(HWND hwnd);
void HandleBrowseCommand(HWND hwnd, UINT uiCtrlID, UINT uiNotify, HWND hwChild);
void HandleBrowseNotify(HWND hwnd, void* pvArg);

// Buffer to hold returned path
static TCHAR s_szPathBuffer[MAX_PATH];
static PTSTR s_szInitialPath = 0;
static UINT s_uiFlags;
static HIMAGELIST s_himlSystem = 0;

// Create browse dialog box, and return a path string, or
// NULL if cancel was selected.
PTSTR BrowseForFolder(HWND hwnd, PTSTR szInitialPath, UINT uiFlags)
{
    CoInitialize(0);

    s_szInitialPath = szInitialPath;
    s_uiFlags = uiFlags;

    PTSTR szRet = reinterpret_cast<TCHAR*>(DialogBox(GetModuleHandle(0), 
        MAKEINTRESOURCE(IDD_BROWSE), hwnd, BrowseDialogProc));

    CoUninitialize();
    return szRet;
}

// Browse dialog box proc.
BOOL CALLBACK BrowseDialogProc(HWND hwnd, UINT uiMsg, WPARAM wParam, LPARAM lParam)
{
    switch(uiMsg)
    {
    case WM_INITDIALOG:
        return HandleInitBrowse(hwnd);
        break;
    case WM_COMMAND:
        HandleBrowseCommand(hwnd, LOWORD(wParam), HIWORD(wParam),
            reinterpret_cast<HWND>(lParam));
        break;
    case WM_NOTIFY:
        HandleBrowseNotify(hwnd, reinterpret_cast<void*>(lParam));
        break;
    default:
        return FALSE;
    }

    return TRUE;
}

// Dialog box initialization, init tree and root tree items.
BOOL HandleInitBrowse(HWND hwnd)
{
    // Get the treeview control
    HWND hwTree = GetDlgItem(hwnd, IDC_DIRTREE);
    if(!hwTree)
        return FALSE;

    SHFILEINFO sfi;

    TreeView_SetImageList(hwTree, reinterpret_cast<HIMAGELIST>(SHGetFileInfo(TEXT("C:\\"),
        0,&sfi, sizeof(SHFILEINFO), SHGFI_SYSICONINDEX | SHGFI_SMALLICON)), 
        TVSIL_NORMAL);

    // Get all user drives
    DWORD dwLength = GetLogicalDriveStrings(0,0);
    if(dwLength == 0)
        return FALSE;

    TCHAR* szDrives = new TCHAR[dwLength+1];
    if(!szDrives)     
        return FALSE;    

    GetLogicalDriveStrings(dwLength, szDrives);
    TCHAR* szCurrDrive = szDrives;

    // Go through each drive
    while(*szCurrDrive)
    {
        // Only pay attention to fixed drives (non-network, non-CD, non-floppy)
        if(((GetDriveType(szCurrDrive) == DRIVE_FIXED) && (s_uiFlags & BF_HARDDRIVES))
            || ((GetDriveType(szCurrDrive) == DRIVE_REMOVABLE) && (s_uiFlags & BF_FLOPPYDRIVES))
            || ((GetDriveType(szCurrDrive) == DRIVE_CDROM) && (s_uiFlags & BF_CDROMDRIVES))
            || ((GetDriveType(szCurrDrive) == DRIVE_REMOTE) && (s_uiFlags & BF_NETWORKDRIVES)))
        {
            SHGetFileInfo(szCurrDrive, 0, &sfi, sizeof(sfi), 
                SHGFI_SYSICONINDEX);

            // Get rid of the terminating '\'
            szCurrDrive[lstrlen(szCurrDrive)-1] = TEXT('\0');

            // Insert a disk drive item into the tree root.
            TVINSERTSTRUCT tvis;
            tvis.hParent = TVI_ROOT;
            tvis.hInsertAfter = TVI_LAST;
            tvis.itemex.mask = TVIF_IMAGE | TVIF_SELECTEDIMAGE| TVIF_TEXT;
            tvis.itemex.iImage = sfi.iIcon;
            tvis.itemex.iSelectedImage = sfi.iIcon;
            tvis.itemex.pszText = szCurrDrive;
            tvis.itemex.cchTextMax = lstrlen(szCurrDrive);

            HTREEITEM hTreeItem = TreeView_InsertItem(hwTree, &tvis);
            
            assert(hTreeItem);

            // Add subitems to the item
            AddTreeSubItems(hwTree, hTreeItem);

            // Move to next drive
            szCurrDrive += lstrlen(szCurrDrive) + 2;
        }
        else        
            // Move to next drive.
            szCurrDrive += lstrlen(szCurrDrive) + 1;
    }

    delete szDrives;

    // Select the first element.
    HTREEITEM hItem = TreeView_GetChild(hwTree, TVI_ROOT);
    TreeView_SelectItem(hwTree, hItem);

    // Force tree to update, and restore original focus
    SetFocus(hwTree);
    SetFocus(GetDlgItem(hwnd, IDOK));

    return TRUE;
}

// Catch notification messages, so we can control expansion/collapsing.
void HandleBrowseNotify(HWND hwnd, void* pvArg)
{
    // Get tree control
    HWND hwTree = GetDlgItem(hwnd, IDC_DIRTREE);
    HWND hwFileList = GetDlgItem(hwnd, IDC_FILELISTCOMBO);
    if(!hwTree || !hwFileList)
    {
        DestroyWindow(GetParent(hwnd));
        return;
    }

    HTREEITEM hItem;
    TCHAR szPath[MAX_PATH] = TEXT("\0");

    // Get notification headers
    NMHDR* pHdr = reinterpret_cast<NMHDR*>(pvArg);
    LPNMTREEVIEW pnmTreeView = reinterpret_cast<LPNMTREEVIEW>(pvArg);    

    switch(pHdr->code)
    {
        // Expanding or collapsing, called for each child.
    case TVN_ITEMEXPANDED:

        // If we're expanding, get the sub items of all children
        if(pnmTreeView->action & TVE_EXPAND)
        {
            // Switch our parent to an open folder icon.
            if(TreeView_GetParent(hwTree, pnmTreeView->itemNew.hItem))
            {
                szPath[0] = TEXT('\0');
                GetItemPath(hwTree, pnmTreeView->itemNew.hItem, szPath);
                SHFILEINFO sfi;

                SHGetFileInfo(szPath, 0, &sfi, sizeof(sfi), 
                    SHGFI_SYSICONINDEX | SHGFI_OPENICON);

                TVITEMEX tvitemex;
                tvitemex.mask = TVIF_IMAGE | TVIF_SELECTEDIMAGE | TVIF_HANDLE;
                tvitemex.hItem = pnmTreeView->itemNew.hItem;
                tvitemex.iImage = sfi.iIcon;
                tvitemex.iSelectedImage = sfi.iIcon;

                TreeView_SetItem(hwTree, &tvitemex);
            }

            // Add all sub-items to this item.
            AddTreeSubItems(hwTree, pnmTreeView->itemNew.hItem);

            // Go through each child, and and check if expansion should be allowed
            HTREEITEM hChild = TreeView_GetChild(hwTree, pnmTreeView->itemNew.hItem);
            while(hChild != NULL)
            {
                CheckTreeSubItems(hwTree, hChild);                
                hChild = TreeView_GetNextSibling(hwTree, hChild);
            }
        }
        else if(pnmTreeView->action & TVE_COLLAPSE)
        {
            // Switch parent to a closed icon.
            if(TreeView_GetParent(hwTree, pnmTreeView->itemNew.hItem))
            {
                szPath[0] = TEXT('\0');
                GetItemPath(hwTree, pnmTreeView->itemNew.hItem, szPath);
                SHFILEINFO sfi;

                SHGetFileInfo(szPath, 0, &sfi, sizeof(sfi), 
                    SHGFI_SYSICONINDEX | SHGFI_OPENICON);

                TVITEMEX tvitemex;
                tvitemex.mask = TVIF_IMAGE |  TVIF_SELECTEDIMAGE | TVIF_HANDLE;
                tvitemex.hItem = pnmTreeView->itemNew.hItem;
                tvitemex.iImage = sfi.iIcon;
                tvitemex.iSelectedImage = sfi.iIcon;

                TreeView_SetItem(hwTree, &tvitemex);
            }

            // Remove all subitems for every child.
            RemoveTreeSubItems(hwTree, pnmTreeView->itemNew.hItem);
            CheckTreeSubItems(hwTree, pnmTreeView->itemNew.hItem);            
        }
        break;
    case TVN_SELCHANGED:

        // Only bother updating edit box if the tree has the focus
        if(GetFocus() == hwTree)
        {
            GetItemPath(hwTree, pnmTreeView->itemNew.hItem, szPath);
            SetWindowText(hwFileList, szPath);         
        }

        break;

        // When treeview gains focus, make sure file list and tree view
        // selection are in sync.
    case NM_SETFOCUS:        
        hItem = TreeView_GetSelection(hwTree);        

        GetItemPath(hwTree, hItem, szPath);
        SetWindowText(hwFileList, szPath);         
        break;
    }
}

// Handle a command message.
void HandleBrowseCommand(HWND hwnd, UINT uiCtrlID, UINT uiNotify, HWND hwCtrl)
{
    HWND hwTree = GetDlgItem(hwnd, IDC_DIRTREE);    
    HTREEITEM hSelected;
    TVITEMEX tvItem;

    TCHAR szPath[MAX_PATH];

    switch(uiCtrlID)
    {
        // Get path of item, and return it.
    case IDOK:               
        // Retrieve item from tree view.
        hSelected = TreeView_GetSelection(hwTree);
        if(!hSelected)
        {
            MessageBeep(0);
            break;
        }
        
        s_szPathBuffer[0] = TEXT('\0');
        
        GetItemPath(hwTree, hSelected, s_szPathBuffer);
        if(s_szPathBuffer[lstrlen(s_szPathBuffer)-1]== TEXT('\\'))
            s_szPathBuffer[lstrlen(s_szPathBuffer)-1] = TEXT('\0');

        // Validate the path
        if(GetFileAttributes(s_szPathBuffer)==static_cast<DWORD>(-1))
            Error(hwnd, IDS_INVALIDPATH);
        else 
            EndDialog(hwnd, reinterpret_cast<INT_PTR>(s_szPathBuffer));        

        break;

    case IDCANCEL:
        // User selected cancel, just return null.
        EndDialog(hwnd, 0);
        break;

    case IDC_FILELISTCOMBO:
        switch(uiNotify)
        {
        case CBN_EDITCHANGE:
            SendMessage(hwCtrl, WM_GETTEXT, MAX_PATH, 
                reinterpret_cast<LPARAM>(szPath));

            SelectItemFromFullPath(hwTree, szPath);
            break;

        case CBN_DROPDOWN:            
            // clear the combo box.
            SendMessage(hwCtrl, CB_RESETCONTENT, 0, 0);

            // Fill the combo box with all the lowest level items under
            // treeview selection
            hSelected = TreeView_GetSelection(hwTree);
            tvItem.mask = TVIF_STATE | TVIF_HANDLE;
            tvItem.hItem = hSelected;            

            TreeView_GetItem(hwTree, &tvItem);

            if(tvItem.state & TVIS_EXPANDED)
            {
                szPath[0] = TEXT('\0');
                GetItemPath(hwTree, hSelected, szPath);

                SendMessage(hwCtrl, CB_ADDSTRING, 0, 
                    reinterpret_cast<LPARAM>(szPath));

                HTREEITEM hItem = TreeView_GetChild(hwTree, tvItem.hItem);
                while(hItem)
                {
                    szPath[0] = TEXT('\0');
                    GetItemPath(hwTree, hItem, szPath);
                    SendMessage(hwCtrl, CB_ADDSTRING, 0, 
                        reinterpret_cast<LPARAM>(szPath));
                    hItem = TreeView_GetNextSibling(hwTree, hItem);
                }
            }
            else
            {
                HTREEITEM hItem;
                hItem = TreeView_GetParent(hwTree, tvItem.hItem);
                hItem = TreeView_GetChild(hwTree, hItem);
  
                while(hItem)
                {
                    szPath[0] = TEXT('\0');
                    GetItemPath(hwTree, hItem, szPath);
                    SendMessage(hwCtrl, CB_ADDSTRING, 0, 
                        reinterpret_cast<LPARAM>(szPath));
                    hItem = TreeView_GetNextSibling(hwTree, hItem);
                }
            }

            break;
        }
        break;
    };
}

// Expand an item to get its full path.
void GetItemPath(HWND hwTree, HTREEITEM hItem, PTSTR szPath)
{
    assert(hwTree);
    assert(hItem);
    assert(szPath);
    assert(szPath[0] == TEXT('\0'));

    // Recurse to get parent's path.
    HTREEITEM hParent = TreeView_GetParent(hwTree, hItem);
    if(hParent)
    {
        GetItemPath(hwTree, hParent, szPath);
        lstrcat(szPath, TEXT("\\"));
    }

    // Get item text, concatenate on current path..
    TVITEMEX tvItem;

    tvItem.mask = TVIF_TEXT | TVIF_HANDLE;
    tvItem.hItem = hItem;
    tvItem.pszText = szPath + lstrlen(szPath);
    tvItem.cchTextMax = MAX_PATH - lstrlen(szPath);
    
    TreeView_GetItem(hwTree, &tvItem);
}

// Remove all subitems below an element.
void RemoveTreeSubItems(HWND hwTree, HTREEITEM hParent)
{
    assert(hwTree);
    
    // Go through each child and delete.
    HTREEITEM hChild = TreeView_GetChild(hwTree, hParent);
    while(hChild != NULL)
    {
        HTREEITEM hSibling = TreeView_GetNextSibling(hwTree, hChild);

        // Recursively delete all subitems in this child.
        RemoveTreeSubItems(hwTree, hChild);

        // Remove this item.
        TreeView_DeleteItem(hwTree, hChild);

        // Move to next.
        hChild = hSibling;        
    }
}

// Add items below an element.
void AddTreeSubItems(HWND hwTree, HTREEITEM hParent)
{
    assert(hwTree);

    // Clear-out (to ensure we don't add items twice)
    RemoveTreeSubItems(hwTree, hParent);

    // Do an early out if the item has already been expanded
    TVITEMEX tvitem;
    tvitem.mask = TVIF_CHILDREN | TVIF_HANDLE;
    tvitem.hItem = hParent;
    TreeView_GetItem(hwTree, &tvitem);
    if(tvitem.cChildren)
        return;
    
    // Do a search on all directories
    TCHAR szPath[MAX_PATH] = TEXT("");
    GetItemPath(hwTree, hParent, szPath);

    WIN32_FIND_DATA findData;

    lstrcat(szPath, TEXT("\\*.*"));

    HANDLE hSearch = FindFirstFile(szPath, &findData);
    if(hSearch == INVALID_HANDLE_VALUE)
        return;

    do
    {
        // Ignore if a relative directory (. or ..)
        // or if no select files were selected and it is not a directory
        // otherwise
        if((findData.cFileName[0] != TEXT('.')) &&
            ((!(s_uiFlags & BF_SELECTFILES) && 
            (findData.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY)) ||
            (s_uiFlags & BF_SELECTFILES)))
        {
            SHFILEINFO sfi;

            szPath[0] = TEXT('\0');
            GetItemPath(hwTree, hParent, szPath);
            lstrcat(szPath, TEXT("\\"));
            lstrcat(szPath, findData.cFileName);
            SHGetFileInfo(szPath, 0, &sfi, sizeof(sfi), 
                SHGFI_SYSICONINDEX);
            
            // Insert an item representing this directory.
            TVINSERTSTRUCT tvis;
            tvis.hParent = hParent;
            tvis.hInsertAfter = TVI_SORT;
            tvis.itemex.mask = TVIF_IMAGE | TVIF_SELECTEDIMAGE | TVIF_TEXT;
            tvis.itemex.iImage = sfi.iIcon;
            tvis.itemex.iSelectedImage = sfi.iIcon;
            tvis.itemex.pszText = findData.cFileName;
            tvis.itemex.cchTextMax = lstrlen(findData.cFileName);

            TreeView_InsertItem(hwTree, &tvis);            
        }        

        // Move to next file.
    } while(FindNextFile(hSearch, &findData));

    FindClose(hSearch);
}

void CheckTreeSubItems(HWND hwTree, HTREEITEM hParent)
{
    assert(hwTree);

    // Do a search on all directories
    TCHAR szPath[MAX_PATH] = TEXT("");
    GetItemPath(hwTree, hParent, szPath);

    WIN32_FIND_DATA findData;

    lstrcat(szPath, TEXT("\\*.*"));

    HANDLE hSearch = FindFirstFile(szPath, &findData);
    if(hSearch == INVALID_HANDLE_VALUE)
        return;

    do
    {
        // Ignore if a relative directory (. or ..)
        // or if no select files were selected and it is not a directory
        // otherwise
        if((findData.cFileName[0] != TEXT('.')) &&
            ((!(s_uiFlags & BF_SELECTFILES) && 
            (findData.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY)) ||
            (s_uiFlags & BF_SELECTFILES)))
        {
            SHFILEINFO sfi;

            szPath[0] = TEXT('\0');
            GetItemPath(hwTree, hParent, szPath);
            lstrcat(szPath, TEXT("\\"));
            lstrcat(szPath, findData.cFileName);
            SHGetFileInfo(szPath, 0, &sfi, sizeof(sfi), 
                SHGFI_SYSICONINDEX);
            
            // Insert an item representing this directory.
            TVINSERTSTRUCT tvis;
            tvis.hParent = hParent;
            tvis.hInsertAfter = TVI_SORT;
            tvis.itemex.mask = TVIF_IMAGE | TVIF_SELECTEDIMAGE | TVIF_TEXT;
            tvis.itemex.iImage = sfi.iIcon;
            tvis.itemex.iSelectedImage = sfi.iIcon;
            tvis.itemex.pszText = findData.cFileName;
            tvis.itemex.cchTextMax = lstrlen(findData.cFileName);

            TreeView_InsertItem(hwTree, &tvis);

            FindClose(hSearch);
            return;
        }        

        // Move to next file.
    } while(FindNextFile(hSearch, &findData));

    FindClose(hSearch);
}

// Given a relative path and a tree item, select a subitem from the relative path.
// Returns true if item successfully selected, false otherwise.
bool SelectSubitemFromPartialPath(HWND hwTree, HTREEITEM hItem, PTSTR szPath)
{
    bool fExpandIt = false;
    TCHAR* szPathDelim = _tcschr(szPath, TEXT('\\'));

    if(szPathDelim)
    {
        if(szPathDelim == szPath)
            return false;
        *szPathDelim = TEXT('\0');
        if(szPathDelim[1] == TEXT('\0'))
        {
            szPathDelim = 0;
            fExpandIt = true;
        }
    }

    // Find this path.
    HTREEITEM hClosestChild = 0;
    HTREEITEM hChild = TreeView_GetChild(hwTree, hItem);
    while(hChild)
    {
        TCHAR szItemPath[MAX_PATH];

        TVITEMEX tvitem;
        tvitem.mask = TVIF_HANDLE | TVIF_TEXT;
        tvitem.hItem = hChild;
        tvitem.pszText = szItemPath;
        tvitem.cchTextMax = MAX_PATH;

        TreeView_GetItem(hwTree, &tvitem);

        if(lstrcmpi(szPath,tvitem.pszText) == 0)
            break;
        else if((StrStrI(tvitem.pszText, szPath) == tvitem.pszText) && !fExpandIt)
        {
            hClosestChild = hChild;
            break;
        }

        hChild = TreeView_GetNextSibling(hwTree, hChild);
    }

    if(!hChild)
    {
        if(!hClosestChild)
            return false;
        else
        {
            hChild = hClosestChild;
            szPathDelim = 0;
        }
    }

    // If nothing more on the path, select this item,
    // or expand and continue
    if(szPathDelim == 0)
    {
        if(fExpandIt)        
            TreeView_Expand(hwTree, hChild, TVE_EXPAND);

        TreeView_SelectItem(hwTree, hChild);
    }
    else
    {
        if(fExpandIt)        
            TreeView_Expand(hwTree, hChild, TVE_EXPAND);        

        if(!SelectSubitemFromPartialPath(hwTree, hChild, szPathDelim+1))
            return false;
    }

    return true;
}

// Given a path, select the appropriate item in the tree.
// If path is invalid, it will expand as much as possible 
// (until invalid element appears)
// szPath is trashed.
void SelectItemFromFullPath(HWND hwTree, PTSTR szPath)
{
    if(!SelectSubitemFromPartialPath(hwTree, 0, szPath))
        TreeView_SelectItem(hwTree, 0);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\appcompat\tools\appsearch\shiminfo.cpp ===
// AppSearch
//
// Tool for searching a user's hard drives and locating
// applications that can be patched
// 
// Author: t-michkr (9 June 2000)
//
// shiminfo.cpp
// Display information on the shims used by an app.
#include <windows.h>

extern "C"
{
    #include <shimdb.h>
}

#include <assert.h>
#include <tchar.h>
#include "main.h"
#include "resource.h"

HSDB g_hSDBx;

struct SShimInfo
{
    TCHAR* szName;
    TCHAR* szDesc;

    SShimInfo() : szName(0), szDesc(0) {}

    ~SShimInfo()
    {
        if(szName)
            delete szName;
        if(szDesc)
            delete szDesc;        

        szName = szDesc = 0;
    }
};

const int c_nMaxShimList = 16;

static int nNumShims = 0;
static SShimInfo* apShimInfo[c_nMaxShimList];

// Shim dialog proc.
BOOL CALLBACK ShimInfoDialogProc(HWND hwnd, UINT uiMsg, WPARAM wParam, 
                                 LPARAM lParam);

// Shim dialog message handlers.
BOOL HandleShimInfoInitDialog(HWND hwnd, TCHAR* szAppPath);
void HandleShimInfoCommand(HWND hwnd, UINT uiCtrl, UINT uiNotify);

// ShowShimInfo
// Display dialog box showing which shims are imported by an app.
void ShowShimInfo(HWND hwnd, TCHAR* szAppPath)
{
    if((g_hSDBx = SdbInitDatabase(0, NULL)) == NULL)
        return;

    DialogBoxParam(g_hinst, MAKEINTRESOURCE(IDD_SHIMINFO), hwnd,
        ShimInfoDialogProc, reinterpret_cast<LPARAM>(szAppPath));

    for(int i = 0; i < nNumShims; i++)
    {
        if(apShimInfo[i])
            delete apShimInfo[i];
    }

    nNumShims = 0;
    
    SdbReleaseDatabase(g_hSDBx);
}

// Dialog proc for shim info dialog.
BOOL CALLBACK ShimInfoDialogProc(HWND hwnd, UINT uiMsg, WPARAM wParam, 
                                 LPARAM lParam)
{
    switch(uiMsg)
    {
    case WM_INITDIALOG:
        return HandleShimInfoInitDialog(hwnd, reinterpret_cast<TCHAR*>(lParam));
        break;

    case WM_COMMAND:
        HandleShimInfoCommand(hwnd, LOWORD(wParam), HIWORD(wParam));        
        break;        

    default:
        return FALSE;
    }

    return TRUE;
}

// Init dialog, add all shims used by app.
BOOL HandleShimInfoInitDialog(HWND hwnd, TCHAR* szAppPath)
{
    DWORD dwNumExes = 0;

    assert(szAppPath);

    TCHAR szBuffer[c_nMaxStringLength];
    GetWindowText(hwnd, szBuffer, c_nMaxStringLength);

    lstrcat(szBuffer, TEXT(" - "));

    if(_tcsrchr(szAppPath, TEXT('\\')))    
        lstrcat(szBuffer, _tcsrchr(szAppPath, TEXT('\\'))+1);
    else
        lstrcat(szBuffer, szAppPath);

    SetWindowText(hwnd, szBuffer);

    // Find the EXE in the database
    SDBQUERYRESULT sdbQuery;

    ZeroMemory(&sdbQuery, sizeof(SDBQUERYRESULT));

    SdbGetMatchingExe(g_hSDBx, szAppPath, NULL, NULL, SDBGMEF_IGNORE_ENVIRONMENT, &sdbQuery);

    for (dwNumExes = 0; dwNumExes < SDB_MAX_EXES; ++dwNumExes) {
        if (sdbQuery.atrExes[dwNumExes] == TAGREF_NULL) {
            break;
        }
    }
    
    if (dwNumExes)
    {
        //
        // for now, just get the info for the last exe in the list, which will
        // be the one with specific info for this app.
        // BUGBUG -- is this the right thing to do? dmunsil
        //
        TAGREF trExe = sdbQuery.atrExes[dwNumExes - 1];

        // Get all shims used by this app.
        TAGREF trShimDLL = SdbFindFirstTagRef(g_hSDBx, trExe, TAG_SHIM_REF);
        
        while(trShimDLL)
        {
            // Get the name of the shim.
            TCHAR szBuffer[c_nMaxStringLength];
            TAGREF trName = SdbFindFirstTagRef(g_hSDBx, trShimDLL, TAG_NAME);
            if(SdbReadStringTagRef(g_hSDBx, trName, szBuffer, c_nMaxStringLength))
            {
                SShimInfo* pShim = new SShimInfo;
                if(!pShim)
                    return FALSE;

                pShim->szName = new TCHAR[lstrlen(szBuffer)+1];
                if(!pShim->szName)
                {
                    delete pShim;
                    return FALSE;
                }

                lstrcpy(pShim->szName, szBuffer);

                // Have to read description from
                // actual DLL entry, not the reference.
                TAGREF trRealDLL = SdbGetShimFromShimRef(g_hSDBx, trShimDLL);
                if(trRealDLL)
                {
                    TAGREF trDesc = SdbFindFirstTagRef(g_hSDBx, trRealDLL, TAG_DESCRIPTION);
                    if(SdbReadStringTagRef(g_hSDBx, trDesc, szBuffer, c_nMaxStringLength))
                    {
                        pShim->szDesc = new TCHAR[lstrlen(szBuffer)+1];
                        if(!pShim->szDesc)
                        {
                            delete pShim;
                            return FALSE;
                        }

                        lstrcpy(pShim->szDesc, szBuffer);
                    }
                }
                                        
                // Add the shim to the list
                HWND hwList = GetDlgItem(hwnd, IDC_SHIMLIST);
                if(hwList)
                {                    
                    
                    int i = SendMessage(hwList, LB_ADDSTRING, 0, 
                        reinterpret_cast<LPARAM>(pShim->szName));
                    if(i != LB_ERR)
                    {
                        SendMessage(hwList, LB_SETITEMDATA, i, nNumShims);
                        apShimInfo[nNumShims] = pShim;
                        nNumShims++;
                    }
                    else
                        delete pShim;
                }                
            }
            
            // Move to next shim.
            trShimDLL = SdbFindNextTagRef(g_hSDBx, trExe, trShimDLL);
        }
    }
    return TRUE;
}

// Handle command messages
void HandleShimInfoCommand(HWND hwnd, UINT uiCtrl, UINT uiNotify)
{
    HWND hwList, hwDesc;
    int iItem, iShim;
    switch(uiCtrl)
    {
    case IDOK:
        EndDialog(hwnd, 0);
        break;

    case IDC_SHIMLIST:
        switch(uiNotify)
        {
        case LBN_SELCHANGE:
            // On a sel change, show the new shim description.
            hwList = GetDlgItem(hwnd, IDC_SHIMLIST);
            iItem = SendMessage(hwList, LB_GETCURSEL, 0, 0);
            if(iItem == LB_ERR)
                break;

            iShim = SendMessage(hwList, LB_GETITEMDATA, iItem, 0);
            if(iShim == LB_ERR)
                break;

            hwDesc = GetDlgItem(hwnd, IDC_SHIMDESC);
            SetWindowText(hwDesc, apShimInfo[iShim]->szDesc);

            break;
        }
        break;
    }

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\appcompat\tools\compatadmin\afxres.h ===
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) 1992-1998 Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#ifndef __AFXRES_H__
#define __AFXRES_H__

#ifdef RC_INVOKED
#ifndef _INC_WINDOWS
#define _INC_WINDOWS
	#include "winres.h"           // extract from windows header
#endif
#endif

#ifdef _AFX_MINREBUILD
#pragma component(minrebuild, off)
#endif

#ifdef APSTUDIO_INVOKED
#define APSTUDIO_HIDDEN_SYMBOLS
#endif

/////////////////////////////////////////////////////////////////////////////
// MFC resource types (see Technical note TN024 for implementation details)

#ifndef RC_INVOKED
#define RT_DLGINIT  MAKEINTRESOURCE(240)
#define RT_TOOLBAR  MAKEINTRESOURCE(241)
#endif

/////////////////////////////////////////////////////////////////////////////

#ifdef APSTUDIO_INVOKED
#undef APSTUDIO_HIDDEN_SYMBOLS
#endif

/////////////////////////////////////////////////////////////////////////////
// General style bits etc

// ControlBar styles
#define CBRS_ALIGN_LEFT     0x1000L
#define CBRS_ALIGN_TOP      0x2000L
#define CBRS_ALIGN_RIGHT    0x4000L
#define CBRS_ALIGN_BOTTOM   0x8000L
#define CBRS_ALIGN_ANY      0xF000L

#define CBRS_BORDER_LEFT    0x0100L
#define CBRS_BORDER_TOP     0x0200L
#define CBRS_BORDER_RIGHT   0x0400L
#define CBRS_BORDER_BOTTOM  0x0800L
#define CBRS_BORDER_ANY     0x0F00L

#define CBRS_TOOLTIPS       0x0010L
#define CBRS_FLYBY          0x0020L
#define CBRS_FLOAT_MULTI    0x0040L
#define CBRS_BORDER_3D      0x0080L
#define CBRS_HIDE_INPLACE   0x0008L
#define CBRS_SIZE_DYNAMIC   0x0004L
#define CBRS_SIZE_FIXED     0x0002L
#define CBRS_FLOATING       0x0001L

#define CBRS_GRIPPER        0x00400000L

#define CBRS_ORIENT_HORZ    (CBRS_ALIGN_TOP|CBRS_ALIGN_BOTTOM)
#define CBRS_ORIENT_VERT    (CBRS_ALIGN_LEFT|CBRS_ALIGN_RIGHT)
#define CBRS_ORIENT_ANY     (CBRS_ORIENT_HORZ|CBRS_ORIENT_VERT)

#define CBRS_ALL            0x0040FFFFL

// the CBRS_ style is made up of an alignment style and a draw border style
//  the alignment styles are mutually exclusive
//  the draw border styles may be combined
#define CBRS_NOALIGN        0x00000000L
#define CBRS_LEFT           (CBRS_ALIGN_LEFT|CBRS_BORDER_RIGHT)
#define CBRS_TOP            (CBRS_ALIGN_TOP|CBRS_BORDER_BOTTOM)
#define CBRS_RIGHT          (CBRS_ALIGN_RIGHT|CBRS_BORDER_LEFT)
#define CBRS_BOTTOM         (CBRS_ALIGN_BOTTOM|CBRS_BORDER_TOP)

/////////////////////////////////////////////////////////////////////////////
// Standard window components

// Mode indicators in status bar - these are routed like commands
#define ID_INDICATOR_EXT                0xE700  // extended selection indicator
#define ID_INDICATOR_CAPS               0xE701  // cap lock indicator
#define ID_INDICATOR_NUM                0xE702  // num lock indicator
#define ID_INDICATOR_SCRL               0xE703  // scroll lock indicator
#define ID_INDICATOR_OVR                0xE704  // overtype mode indicator
#define ID_INDICATOR_REC                0xE705  // record mode indicator
#define ID_INDICATOR_KANA               0xE706  // kana lock indicator

#define ID_SEPARATOR                    0   // special separator value

#ifndef RC_INVOKED  // code only
// Standard control bars (IDW = window ID)
#define AFX_IDW_CONTROLBAR_FIRST        0xE800
#define AFX_IDW_CONTROLBAR_LAST         0xE8FF

#define AFX_IDW_TOOLBAR                 0xE800  // main Toolbar for window
#define AFX_IDW_STATUS_BAR              0xE801  // Status bar window
#define AFX_IDW_PREVIEW_BAR             0xE802  // PrintPreview Dialog Bar
#define AFX_IDW_RESIZE_BAR              0xE803  // OLE in-place resize bar
#define AFX_IDW_REBAR                   0xE804  // COMCTL32 "rebar" Bar
#define AFX_IDW_DIALOGBAR               0xE805  // CDialogBar

// Note: If your application supports docking toolbars, you should
//  not use the following IDs for your own toolbars.  The IDs chosen
//  are at the top of the first 32 such that the bars will be hidden
//  while in print preview mode, and are not likely to conflict with
//  IDs your application may have used succesfully in the past.

#define AFX_IDW_DOCKBAR_TOP             0xE81B
#define AFX_IDW_DOCKBAR_LEFT            0xE81C
#define AFX_IDW_DOCKBAR_RIGHT           0xE81D
#define AFX_IDW_DOCKBAR_BOTTOM          0xE81E
#define AFX_IDW_DOCKBAR_FLOAT           0xE81F

// Macro for mapping standard control bars to bitmask (limit of 32)
#define AFX_CONTROLBAR_MASK(nIDC)   (1L << (nIDC - AFX_IDW_CONTROLBAR_FIRST))

// parts of Main Frame
#define AFX_IDW_PANE_FIRST              0xE900  // first pane (256 max)
#define AFX_IDW_PANE_LAST               0xE9ff
#define AFX_IDW_HSCROLL_FIRST           0xEA00  // first Horz scrollbar (16 max)
#define AFX_IDW_VSCROLL_FIRST           0xEA10  // first Vert scrollbar (16 max)

#define AFX_IDW_SIZE_BOX                0xEA20  // size box for splitters
#define AFX_IDW_PANE_SAVE               0xEA21  // to shift AFX_IDW_PANE_FIRST
#endif //!RC_INVOKED

#ifndef APSTUDIO_INVOKED

// common style for form views
#define AFX_WS_DEFAULT_VIEW             (WS_CHILD | WS_VISIBLE | WS_BORDER)

#endif //!APSTUDIO_INVOKED

/////////////////////////////////////////////////////////////////////////////
// Standard app configurable strings

// for application title (defaults to EXE name or name in constructor)
#define AFX_IDS_APP_TITLE               0xE000
// idle message bar line
#define AFX_IDS_IDLEMESSAGE             0xE001
// message bar line when in shift-F1 help mode
#define AFX_IDS_HELPMODEMESSAGE         0xE002
// document title when editing OLE embedding
#define AFX_IDS_APP_TITLE_EMBEDDING     0xE003
// company name
#define AFX_IDS_COMPANY_NAME            0xE004
// object name when server is inplace
#define AFX_IDS_OBJ_TITLE_INPLACE       0xE005

/////////////////////////////////////////////////////////////////////////////
// Standard Commands

// File commands
#define ID_FILE_NEW                     0xE100
#define ID_FILE_OPEN                    0xE101
#define ID_FILE_CLOSE                   0xE102
#define ID_FILE_SAVE                    0xE103
#define ID_FILE_SAVE_AS                 0xE104
#define ID_FILE_PAGE_SETUP              0xE105
#define ID_FILE_PRINT_SETUP             0xE106
#define ID_FILE_PRINT                   0xE107
#define ID_FILE_PRINT_DIRECT            0xE108
#define ID_FILE_PRINT_PREVIEW           0xE109
#define ID_FILE_UPDATE                  0xE10A
#define ID_FILE_SAVE_COPY_AS            0xE10B
#define ID_FILE_SEND_MAIL               0xE10C

#define ID_FILE_MRU_FIRST               0xE110
#define ID_FILE_MRU_FILE1               0xE110          // range - 16 max
#define ID_FILE_MRU_FILE2               0xE111
#define ID_FILE_MRU_FILE3               0xE112
#define ID_FILE_MRU_FILE4               0xE113
#define ID_FILE_MRU_FILE5               0xE114
#define ID_FILE_MRU_FILE6               0xE115
#define ID_FILE_MRU_FILE7               0xE116
#define ID_FILE_MRU_FILE8               0xE117
#define ID_FILE_MRU_FILE9               0xE118
#define ID_FILE_MRU_FILE10              0xE119
#define ID_FILE_MRU_FILE11              0xE11A
#define ID_FILE_MRU_FILE12              0xE11B
#define ID_FILE_MRU_FILE13              0xE11C
#define ID_FILE_MRU_FILE14              0xE11D
#define ID_FILE_MRU_FILE15              0xE11E
#define ID_FILE_MRU_FILE16              0xE11F
#define ID_FILE_MRU_LAST                0xE11F

// Edit commands
#define ID_EDIT_CLEAR                   0xE120
#define ID_EDIT_CLEAR_ALL               0xE121
#define ID_EDIT_COPY                    0xE122
#define ID_EDIT_CUT                     0xE123
#define ID_EDIT_FIND                    0xE124
#define ID_EDIT_PASTE                   0xE125
#define ID_EDIT_PASTE_LINK              0xE126
#define ID_EDIT_PASTE_SPECIAL           0xE127
#define ID_EDIT_REPEAT                  0xE128
#define ID_EDIT_REPLACE                 0xE129
#define ID_EDIT_SELECT_ALL              0xE12A
#define ID_EDIT_UNDO                    0xE12B
#define ID_EDIT_REDO                    0xE12C

// Window commands
#define ID_WINDOW_NEW                   0xE130
#define ID_WINDOW_ARRANGE               0xE131
#define ID_WINDOW_CASCADE               0xE132
#define ID_WINDOW_TILE_HORZ             0xE133
#define ID_WINDOW_TILE_VERT             0xE134
#define ID_WINDOW_SPLIT                 0xE135
#ifndef RC_INVOKED      // code only
#define AFX_IDM_WINDOW_FIRST            0xE130
#define AFX_IDM_WINDOW_LAST             0xE13F
#define AFX_IDM_FIRST_MDICHILD          0xFF00  // window list starts here
#endif //!RC_INVOKED

// Help and App commands
#define ID_APP_ABOUT                    0xE140
#define ID_APP_EXIT                     0xE141
#define ID_HELP_INDEX                   0xE142
#define ID_HELP_FINDER                  0xE143
#define ID_HELP_USING                   0xE144
#define ID_CONTEXT_HELP                 0xE145      // shift-F1
// special commands for processing help
#define ID_HELP                         0xE146      // first attempt for F1
#define ID_DEFAULT_HELP                 0xE147      // last attempt

// Misc
#define ID_NEXT_PANE                    0xE150
#define ID_PREV_PANE                    0xE151

// Format
#define ID_FORMAT_FONT                  0xE160

// OLE commands
#define ID_OLE_INSERT_NEW               0xE200
#define ID_OLE_EDIT_LINKS               0xE201
#define ID_OLE_EDIT_CONVERT             0xE202
#define ID_OLE_EDIT_CHANGE_ICON         0xE203
#define ID_OLE_EDIT_PROPERTIES          0xE204
#define ID_OLE_VERB_FIRST               0xE210     // range - 16 max
#ifndef RC_INVOKED      // code only
#define ID_OLE_VERB_LAST                0xE21F
#endif //!RC_INVOKED

// for print preview dialog bar
#define AFX_ID_PREVIEW_CLOSE            0xE300
#define AFX_ID_PREVIEW_NUMPAGE          0xE301      // One/Two Page button
#define AFX_ID_PREVIEW_NEXT             0xE302
#define AFX_ID_PREVIEW_PREV             0xE303
#define AFX_ID_PREVIEW_PRINT            0xE304
#define AFX_ID_PREVIEW_ZOOMIN           0xE305
#define AFX_ID_PREVIEW_ZOOMOUT          0xE306

// View commands (same number used as IDW used for control bar)
#define ID_VIEW_TOOLBAR                 0xE800
#define ID_VIEW_STATUS_BAR              0xE801
#define ID_VIEW_REBAR                   0xE804
#define ID_VIEW_AUTOARRANGE         0xE805
	// E810 -> E81F must be kept in order for RANGE macros
#define ID_VIEW_SMALLICON               0xE810
#define ID_VIEW_LARGEICON               0xE811
#define ID_VIEW_LIST                   0xE812
#define ID_VIEW_DETAILS                 0xE813
#define ID_VIEW_LINEUP                  0xE814
#define ID_VIEW_BYNAME                  0xE815
#define AFX_ID_VIEW_MINIMUM              ID_VIEW_SMALLICON
#define AFX_ID_VIEW_MAXIMUM              ID_VIEW_BYNAME
	// E800 -> E8FF reserved for other control bar commands

// RecordForm commands
#define ID_RECORD_FIRST                 0xE900
#define ID_RECORD_LAST                  0xE901
#define ID_RECORD_NEXT                  0xE902
#define ID_RECORD_PREV                  0xE903

/////////////////////////////////////////////////////////////////////////////
// Standard control IDs

#ifdef IDC_STATIC
#undef IDC_STATIC
#endif
#define IDC_STATIC              (-1)     // all static controls

/////////////////////////////////////////////////////////////////////////////
// Standard string error/warnings

#ifndef RC_INVOKED      // code only
#define AFX_IDS_SCFIRST                 0xEF00
#endif //!RC_INVOKED

#define AFX_IDS_SCSIZE                  0xEF00
#define AFX_IDS_SCMOVE                  0xEF01
#define AFX_IDS_SCMINIMIZE              0xEF02
#define AFX_IDS_SCMAXIMIZE              0xEF03
#define AFX_IDS_SCNEXTWINDOW            0xEF04
#define AFX_IDS_SCPREVWINDOW            0xEF05
#define AFX_IDS_SCCLOSE                 0xEF06
#define AFX_IDS_SCRESTORE               0xEF12
#define AFX_IDS_SCTASKLIST              0xEF13

#define AFX_IDS_MDICHILD                0xEF1F

#define AFX_IDS_DESKACCESSORY           0xEFDA

// General strings
#define AFX_IDS_OPENFILE                0xF000
#define AFX_IDS_SAVEFILE                0xF001
#define AFX_IDS_ALLFILTER               0xF002
#define AFX_IDS_UNTITLED                0xF003
#define AFX_IDS_SAVEFILECOPY            0xF004
#define AFX_IDS_PREVIEW_CLOSE           0xF005
#define AFX_IDS_UNNAMED_FILE            0xF006
#define AFX_IDS_HIDE                    0xF011

// MFC Standard Exception Error messages
#define AFX_IDP_NO_ERROR_AVAILABLE      0xF020
#define AFX_IDS_NOT_SUPPORTED_EXCEPTION 0xF021
#define AFX_IDS_RESOURCE_EXCEPTION      0xF022
#define AFX_IDS_MEMORY_EXCEPTION        0xF023
#define AFX_IDS_USER_EXCEPTION          0xF024

// Printing and print preview strings
#define AFX_IDS_PRINTONPORT             0xF040
#define AFX_IDS_ONEPAGE                 0xF041
#define AFX_IDS_TWOPAGE                 0xF042
#define AFX_IDS_PRINTPAGENUM            0xF043
#define AFX_IDS_PREVIEWPAGEDESC         0xF044
#define AFX_IDS_PRINTDEFAULTEXT         0xF045
#define AFX_IDS_PRINTDEFAULT            0xF046
#define AFX_IDS_PRINTFILTER             0xF047
#define AFX_IDS_PRINTCAPTION            0xF048
#define AFX_IDS_PRINTTOFILE             0xF049


// OLE strings
#define AFX_IDS_OBJECT_MENUITEM         0xF080
#define AFX_IDS_EDIT_VERB               0xF081
#define AFX_IDS_ACTIVATE_VERB           0xF082
#define AFX_IDS_CHANGE_LINK             0xF083
#define AFX_IDS_AUTO                    0xF084
#define AFX_IDS_MANUAL                  0xF085
#define AFX_IDS_FROZEN                  0xF086
#define AFX_IDS_ALL_FILES               0xF087
// dynamically changing menu items
#define AFX_IDS_SAVE_MENU               0xF088
#define AFX_IDS_UPDATE_MENU             0xF089
#define AFX_IDS_SAVE_AS_MENU            0xF08A
#define AFX_IDS_SAVE_COPY_AS_MENU       0xF08B
#define AFX_IDS_EXIT_MENU               0xF08C
#define AFX_IDS_UPDATING_ITEMS          0xF08D
// COlePasteSpecialDialog defines
#define AFX_IDS_METAFILE_FORMAT         0xF08E
#define AFX_IDS_DIB_FORMAT              0xF08F
#define AFX_IDS_BITMAP_FORMAT           0xF090
#define AFX_IDS_LINKSOURCE_FORMAT       0xF091
#define AFX_IDS_EMBED_FORMAT            0xF092
// other OLE utility strings
#define AFX_IDS_PASTELINKEDTYPE         0xF094
#define AFX_IDS_UNKNOWNTYPE             0xF095
#define AFX_IDS_RTF_FORMAT              0xF096
#define AFX_IDS_TEXT_FORMAT             0xF097
// OLE datatype format error strings
#define AFX_IDS_INVALID_CURRENCY        0xF098
#define AFX_IDS_INVALID_DATETIME        0xF099
#define AFX_IDS_INVALID_DATETIMESPAN    0xF09A

// General error / prompt strings
#define AFX_IDP_INVALID_FILENAME        0xF100
#define AFX_IDP_FAILED_TO_OPEN_DOC      0xF101
#define AFX_IDP_FAILED_TO_SAVE_DOC      0xF102
#define AFX_IDP_ASK_TO_SAVE             0xF103
#define AFX_IDP_FAILED_TO_CREATE_DOC    0xF104
#define AFX_IDP_FILE_TOO_LARGE          0xF105
#define AFX_IDP_FAILED_TO_START_PRINT   0xF106
#define AFX_IDP_FAILED_TO_LAUNCH_HELP   0xF107
#define AFX_IDP_INTERNAL_FAILURE        0xF108      // general failure
#define AFX_IDP_COMMAND_FAILURE         0xF109      // command failure
#define AFX_IDP_FAILED_MEMORY_ALLOC     0xF10A
#define AFX_IDP_UNREG_DONE              0xF10B
#define AFX_IDP_UNREG_FAILURE           0xF10C
#define AFX_IDP_DLL_LOAD_FAILED         0xF10D
#define AFX_IDP_DLL_BAD_VERSION         0xF10E

// DDV parse errors
#define AFX_IDP_PARSE_INT               0xF110
#define AFX_IDP_PARSE_REAL              0xF111
#define AFX_IDP_PARSE_INT_RANGE         0xF112
#define AFX_IDP_PARSE_REAL_RANGE        0xF113
#define AFX_IDP_PARSE_STRING_SIZE       0xF114
#define AFX_IDP_PARSE_RADIO_BUTTON      0xF115
#define AFX_IDP_PARSE_BYTE              0xF116
#define AFX_IDP_PARSE_UINT              0xF117
#define AFX_IDP_PARSE_DATETIME          0xF118
#define AFX_IDP_PARSE_CURRENCY          0xF119

// CFile/CArchive error strings for user failure
#define AFX_IDP_FAILED_INVALID_FORMAT   0xF120
#define AFX_IDP_FAILED_INVALID_PATH     0xF121
#define AFX_IDP_FAILED_DISK_FULL        0xF122
#define AFX_IDP_FAILED_ACCESS_READ      0xF123
#define AFX_IDP_FAILED_ACCESS_WRITE     0xF124
#define AFX_IDP_FAILED_IO_ERROR_READ    0xF125
#define AFX_IDP_FAILED_IO_ERROR_WRITE   0xF126

// OLE errors / prompt strings
#define AFX_IDP_STATIC_OBJECT           0xF180
#define AFX_IDP_FAILED_TO_CONNECT       0xF181
#define AFX_IDP_SERVER_BUSY             0xF182
#define AFX_IDP_BAD_VERB                0xF183
#define AFX_IDS_NOT_DOCOBJECT                0xF184
#define AFX_IDP_FAILED_TO_NOTIFY        0xF185
#define AFX_IDP_FAILED_TO_LAUNCH        0xF186
#define AFX_IDP_ASK_TO_UPDATE           0xF187
#define AFX_IDP_FAILED_TO_UPDATE        0xF188
#define AFX_IDP_FAILED_TO_REGISTER      0xF189
#define AFX_IDP_FAILED_TO_AUTO_REGISTER 0xF18A
#define AFX_IDP_FAILED_TO_CONVERT       0xF18B
#define AFX_IDP_GET_NOT_SUPPORTED       0xF18C
#define AFX_IDP_SET_NOT_SUPPORTED       0xF18D
#define AFX_IDP_ASK_TO_DISCARD          0xF18E
#define AFX_IDP_FAILED_TO_CREATE        0xF18F

// MAPI errors / prompt strings
#define AFX_IDP_FAILED_MAPI_LOAD        0xF190
#define AFX_IDP_INVALID_MAPI_DLL        0xF191
#define AFX_IDP_FAILED_MAPI_SEND        0xF192

#define AFX_IDP_FILE_NONE               0xF1A0
#define AFX_IDP_FILE_GENERIC            0xF1A1
#define AFX_IDP_FILE_NOT_FOUND          0xF1A2
#define AFX_IDP_FILE_BAD_PATH           0xF1A3
#define AFX_IDP_FILE_TOO_MANY_OPEN      0xF1A4
#define AFX_IDP_FILE_ACCESS_DENIED      0xF1A5
#define AFX_IDP_FILE_INVALID_FILE       0xF1A6
#define AFX_IDP_FILE_REMOVE_CURRENT     0xF1A7
#define AFX_IDP_FILE_DIR_FULL           0xF1A8
#define AFX_IDP_FILE_BAD_SEEK           0xF1A9
#define AFX_IDP_FILE_HARD_IO            0xF1AA
#define AFX_IDP_FILE_SHARING            0xF1AB
#define AFX_IDP_FILE_LOCKING            0xF1AC
#define AFX_IDP_FILE_DISKFULL           0xF1AD
#define AFX_IDP_FILE_EOF                0xF1AE

#define AFX_IDP_ARCH_NONE               0xF1B0
#define AFX_IDP_ARCH_GENERIC            0xF1B1
#define AFX_IDP_ARCH_READONLY           0xF1B2
#define AFX_IDP_ARCH_ENDOFFILE          0xF1B3
#define AFX_IDP_ARCH_WRITEONLY          0xF1B4
#define AFX_IDP_ARCH_BADINDEX           0xF1B5
#define AFX_IDP_ARCH_BADCLASS           0xF1B6
#define AFX_IDP_ARCH_BADSCHEMA          0xF1B7

#define AFX_IDS_OCC_SCALEUNITS_PIXELS   0xF1C0

// 0xf200-0xf20f reserved

// font names and point sizes
#define AFX_IDS_STATUS_FONT             0xF230
#define AFX_IDS_TOOLTIP_FONT            0xF231
#define AFX_IDS_UNICODE_FONT            0xF232
#define AFX_IDS_MINI_FONT               0xF233

// ODBC Database errors / prompt strings
#ifndef RC_INVOKED      // code only
#define AFX_IDP_SQL_FIRST                       0xF280
#endif //!RC_INVOKED
#define AFX_IDP_SQL_CONNECT_FAIL                0xF281
#define AFX_IDP_SQL_RECORDSET_FORWARD_ONLY      0xF282
#define AFX_IDP_SQL_EMPTY_COLUMN_LIST           0xF283
#define AFX_IDP_SQL_FIELD_SCHEMA_MISMATCH       0xF284
#define AFX_IDP_SQL_ILLEGAL_MODE                0xF285
#define AFX_IDP_SQL_MULTIPLE_ROWS_AFFECTED      0xF286
#define AFX_IDP_SQL_NO_CURRENT_RECORD           0xF287
#define AFX_IDP_SQL_NO_ROWS_AFFECTED            0xF288
#define AFX_IDP_SQL_RECORDSET_READONLY          0xF289
#define AFX_IDP_SQL_SQL_NO_TOTAL                0xF28A
#define AFX_IDP_SQL_ODBC_LOAD_FAILED            0xF28B
#define AFX_IDP_SQL_DYNASET_NOT_SUPPORTED       0xF28C
#define AFX_IDP_SQL_SNAPSHOT_NOT_SUPPORTED      0xF28D
#define AFX_IDP_SQL_API_CONFORMANCE             0xF28E
#define AFX_IDP_SQL_SQL_CONFORMANCE             0xF28F
#define AFX_IDP_SQL_NO_DATA_FOUND               0xF290
#define AFX_IDP_SQL_ROW_UPDATE_NOT_SUPPORTED    0xF291
#define AFX_IDP_SQL_ODBC_V2_REQUIRED            0xF292
#define AFX_IDP_SQL_NO_POSITIONED_UPDATES       0xF293
#define AFX_IDP_SQL_LOCK_MODE_NOT_SUPPORTED     0xF294
#define AFX_IDP_SQL_DATA_TRUNCATED              0xF295
#define AFX_IDP_SQL_ROW_FETCH                   0xF296
#define AFX_IDP_SQL_INCORRECT_ODBC              0xF297
#define AFX_IDP_SQL_UPDATE_DELETE_FAILED        0xF298
#define AFX_IDP_SQL_DYNAMIC_CURSOR_NOT_SUPPORTED    0xF299
#define AFX_IDP_SQL_FIELD_NOT_FOUND             0xF29A
#define AFX_IDP_SQL_BOOKMARKS_NOT_SUPPORTED     0xF29B
#define AFX_IDP_SQL_BOOKMARKS_NOT_ENABLED       0xF29C

// ODBC Database strings
#define AFX_IDS_DELETED                         0xF29D

// DAO Database errors / prompt strings
#ifndef RC_INVOKED      // code only
#define AFX_IDP_DAO_FIRST                       0xF2B0
#endif //!RC_INVOKED
#define AFX_IDP_DAO_ENGINE_INITIALIZATION       0xF2B0
#define AFX_IDP_DAO_DFX_BIND                    0xF2B1
#define AFX_IDP_DAO_OBJECT_NOT_OPEN             0xF2B2

// ICDAORecordset::GetRows Errors
//  These are not placed in DAO Errors collection
//  and must be handled directly by MFC.
#define AFX_IDP_DAO_ROWTOOSHORT                 0xF2B3
#define AFX_IDP_DAO_BADBINDINFO                 0xF2B4
#define AFX_IDP_DAO_COLUMNUNAVAILABLE           0xF2B5

/////////////////////////////////////////////////////////////////////////////
// Strings for ISAPI support

#define AFX_IDS_HTTP_TITLE              0xF2D1
#define AFX_IDS_HTTP_NO_TEXT            0xF2D2
#define AFX_IDS_HTTP_BAD_REQUEST        0xF2D3
#define AFX_IDS_HTTP_AUTH_REQUIRED      0xF2D4
#define AFX_IDS_HTTP_FORBIDDEN          0xF2D5
#define AFX_IDS_HTTP_NOT_FOUND          0xF2D6
#define AFX_IDS_HTTP_SERVER_ERROR       0xF2D7
#define AFX_IDS_HTTP_NOT_IMPLEMENTED    0xF2D8

/////////////////////////////////////////////////////////////////////////////
// AFX implementation - control IDs (AFX_IDC)

// Parts of dialogs
#define AFX_IDC_LISTBOX                 100
#define AFX_IDC_CHANGE                  101

// for print dialog
#define AFX_IDC_PRINT_DOCNAME           201
#define AFX_IDC_PRINT_PRINTERNAME       202
#define AFX_IDC_PRINT_PORTNAME          203
#define AFX_IDC_PRINT_PAGENUM           204

// Property Sheet control id's (determined with Spy++)
#define ID_APPLY_NOW                    0x3021
#define ID_WIZBACK                      0x3023
#define ID_WIZNEXT                      0x3024
#define ID_WIZFINISH                    0x3025
#define AFX_IDC_TAB_CONTROL             0x3020

/////////////////////////////////////////////////////////////////////////////
// IDRs for standard components

#ifndef RC_INVOKED  // code only
// These are really COMMDLG dialogs, so there usually isn't a resource
// for them, but these IDs are used as help IDs.
#define AFX_IDD_FILEOPEN                28676
#define AFX_IDD_FILESAVE                28677
#define AFX_IDD_FONT                    28678
#define AFX_IDD_COLOR                   28679
#define AFX_IDD_PRINT                   28680
#define AFX_IDD_PRINTSETUP              28681
#define AFX_IDD_FIND                    28682
#define AFX_IDD_REPLACE                 28683
#endif //!RC_INVOKED

// Standard dialogs app should leave alone (0x7801->)
#define AFX_IDD_NEWTYPEDLG              30721
#define AFX_IDD_PRINTDLG                30722
#define AFX_IDD_PREVIEW_TOOLBAR         30723

// Dialogs defined for OLE2UI library
#define AFX_IDD_INSERTOBJECT            30724
#define AFX_IDD_CHANGEICON              30725
#define AFX_IDD_CONVERT                 30726
#define AFX_IDD_PASTESPECIAL            30727
#define AFX_IDD_EDITLINKS               30728
#define AFX_IDD_FILEBROWSE              30729
#define AFX_IDD_BUSY                    30730

#define AFX_IDD_OBJECTPROPERTIES        30732
#define AFX_IDD_CHANGESOURCE            30733

// Standard cursors (0x7901->)
	// AFX_IDC = Cursor resources
#define AFX_IDC_CONTEXTHELP             30977       // context sensitive help
#define AFX_IDC_MAGNIFY                 30978       // print preview zoom
#define AFX_IDC_SMALLARROWS             30979       // splitter
#define AFX_IDC_HSPLITBAR               30980       // splitter
#define AFX_IDC_VSPLITBAR               30981       // splitter
#define AFX_IDC_NODROPCRSR              30982       // No Drop Cursor
#define AFX_IDC_TRACKNWSE               30983       // tracker
#define AFX_IDC_TRACKNESW               30984       // tracker
#define AFX_IDC_TRACKNS                 30985       // tracker
#define AFX_IDC_TRACKWE                 30986       // tracker
#define AFX_IDC_TRACK4WAY               30987       // tracker
#define AFX_IDC_MOVE4WAY                30988       // resize bar (server only)

// Mini frame window bitmap ID
#define AFX_IDB_MINIFRAME_MENU          30994

// CheckListBox checks bitmap ID
#define AFX_IDB_CHECKLISTBOX_NT         30995
#define AFX_IDB_CHECKLISTBOX_95         30996

// AFX standard accelerator resources
#define AFX_IDR_PREVIEW_ACCEL           30997

// AFX standard ICON IDs (for MFC V1 apps) (0x7A01->)
#define AFX_IDI_STD_MDIFRAME            31233
#define AFX_IDI_STD_FRAME               31234

/////////////////////////////////////////////////////////////////////////////
// AFX OLE control implementation - control IDs (AFX_IDC)

// Font property page
#define AFX_IDC_FONTPROP                1000
#define AFX_IDC_FONTNAMES               1001
#define AFX_IDC_FONTSTYLES              1002
#define AFX_IDC_FONTSIZES               1003
#define AFX_IDC_STRIKEOUT               1004
#define AFX_IDC_UNDERLINE               1005
#define AFX_IDC_SAMPLEBOX               1006

// Color property page
#define AFX_IDC_COLOR_BLACK             1100
#define AFX_IDC_COLOR_WHITE             1101
#define AFX_IDC_COLOR_RED               1102
#define AFX_IDC_COLOR_GREEN             1103
#define AFX_IDC_COLOR_BLUE              1104
#define AFX_IDC_COLOR_YELLOW            1105
#define AFX_IDC_COLOR_MAGENTA           1106
#define AFX_IDC_COLOR_CYAN              1107
#define AFX_IDC_COLOR_GRAY              1108
#define AFX_IDC_COLOR_LIGHTGRAY         1109
#define AFX_IDC_COLOR_DARKRED           1110
#define AFX_IDC_COLOR_DARKGREEN         1111
#define AFX_IDC_COLOR_DARKBLUE          1112
#define AFX_IDC_COLOR_LIGHTBROWN        1113
#define AFX_IDC_COLOR_DARKMAGENTA       1114
#define AFX_IDC_COLOR_DARKCYAN          1115
#define AFX_IDC_COLORPROP               1116
#define AFX_IDC_SYSTEMCOLORS            1117

// Picture porperty page
#define AFX_IDC_PROPNAME                1201
#define AFX_IDC_PICTURE                 1202
#define AFX_IDC_BROWSE                  1203
#define AFX_IDC_CLEAR                   1204

/////////////////////////////////////////////////////////////////////////////
// IDRs for OLE control standard components

// Standard propery page dialogs app should leave alone (0x7E01->)
#define AFX_IDD_PROPPAGE_COLOR         32257
#define AFX_IDD_PROPPAGE_FONT          32258
#define AFX_IDD_PROPPAGE_PICTURE       32259

#define AFX_IDB_TRUETYPE               32384

/////////////////////////////////////////////////////////////////////////////
// Standard OLE control strings

// OLE Control page strings
#define AFX_IDS_PROPPAGE_UNKNOWN        0xFE01
#define AFX_IDS_COLOR_DESKTOP           0xFE04
#define AFX_IDS_COLOR_APPWORKSPACE      0xFE05
#define AFX_IDS_COLOR_WNDBACKGND        0xFE06
#define AFX_IDS_COLOR_WNDTEXT           0xFE07
#define AFX_IDS_COLOR_MENUBAR           0xFE08
#define AFX_IDS_COLOR_MENUTEXT          0xFE09
#define AFX_IDS_COLOR_ACTIVEBAR         0xFE0A
#define AFX_IDS_COLOR_INACTIVEBAR       0xFE0B
#define AFX_IDS_COLOR_ACTIVETEXT        0xFE0C
#define AFX_IDS_COLOR_INACTIVETEXT      0xFE0D
#define AFX_IDS_COLOR_ACTIVEBORDER      0xFE0E
#define AFX_IDS_COLOR_INACTIVEBORDER    0xFE0F
#define AFX_IDS_COLOR_WNDFRAME          0xFE10
#define AFX_IDS_COLOR_SCROLLBARS        0xFE11
#define AFX_IDS_COLOR_BTNFACE           0xFE12
#define AFX_IDS_COLOR_BTNSHADOW         0xFE13
#define AFX_IDS_COLOR_BTNTEXT           0xFE14
#define AFX_IDS_COLOR_BTNHIGHLIGHT      0xFE15
#define AFX_IDS_COLOR_DISABLEDTEXT      0xFE16
#define AFX_IDS_COLOR_HIGHLIGHT         0xFE17
#define AFX_IDS_COLOR_HIGHLIGHTTEXT     0xFE18
#define AFX_IDS_REGULAR                 0xFE19
#define AFX_IDS_BOLD                    0xFE1A
#define AFX_IDS_ITALIC                  0xFE1B
#define AFX_IDS_BOLDITALIC              0xFE1C
#define AFX_IDS_SAMPLETEXT              0xFE1D
#define AFX_IDS_DISPLAYSTRING_FONT      0xFE1E
#define AFX_IDS_DISPLAYSTRING_COLOR     0xFE1F
#define AFX_IDS_DISPLAYSTRING_PICTURE   0xFE20
#define AFX_IDS_PICTUREFILTER           0xFE21
#define AFX_IDS_PICTYPE_UNKNOWN         0xFE22
#define AFX_IDS_PICTYPE_NONE            0xFE23
#define AFX_IDS_PICTYPE_BITMAP          0xFE24
#define AFX_IDS_PICTYPE_METAFILE        0xFE25
#define AFX_IDS_PICTYPE_ICON            0xFE26
#define AFX_IDS_COLOR_PPG               0xFE28
#define AFX_IDS_COLOR_PPG_CAPTION       0xFE29
#define AFX_IDS_FONT_PPG                0xFE2A
#define AFX_IDS_FONT_PPG_CAPTION        0xFE2B
#define AFX_IDS_PICTURE_PPG             0xFE2C
#define AFX_IDS_PICTURE_PPG_CAPTION     0xFE2D
#define AFX_IDS_PICTUREBROWSETITLE      0xFE30
#define AFX_IDS_BORDERSTYLE_0           0xFE31
#define AFX_IDS_BORDERSTYLE_1           0xFE32

// OLE Control verb names
#define AFX_IDS_VERB_EDIT               0xFE40
#define AFX_IDS_VERB_PROPERTIES         0xFE41

// OLE Control internal error messages
#define AFX_IDP_PICTURECANTOPEN         0xFE83
#define AFX_IDP_PICTURECANTLOAD         0xFE84
#define AFX_IDP_PICTURETOOLARGE         0xFE85
#define AFX_IDP_PICTUREREADFAILED       0xFE86

// Standard OLE Control error strings
#define AFX_IDP_E_ILLEGALFUNCTIONCALL       0xFEA0
#define AFX_IDP_E_OVERFLOW                  0xFEA1
#define AFX_IDP_E_OUTOFMEMORY               0xFEA2
#define AFX_IDP_E_DIVISIONBYZERO            0xFEA3
#define AFX_IDP_E_OUTOFSTRINGSPACE          0xFEA4
#define AFX_IDP_E_OUTOFSTACKSPACE           0xFEA5
#define AFX_IDP_E_BADFILENAMEORNUMBER       0xFEA6
#define AFX_IDP_E_FILENOTFOUND              0xFEA7
#define AFX_IDP_E_BADFILEMODE               0xFEA8
#define AFX_IDP_E_FILEALREADYOPEN           0xFEA9
#define AFX_IDP_E_DEVICEIOERROR             0xFEAA
#define AFX_IDP_E_FILEALREADYEXISTS         0xFEAB
#define AFX_IDP_E_BADRECORDLENGTH           0xFEAC
#define AFX_IDP_E_DISKFULL                  0xFEAD
#define AFX_IDP_E_BADRECORDNUMBER           0xFEAE
#define AFX_IDP_E_BADFILENAME               0xFEAF
#define AFX_IDP_E_TOOMANYFILES              0xFEB0
#define AFX_IDP_E_DEVICEUNAVAILABLE         0xFEB1
#define AFX_IDP_E_PERMISSIONDENIED          0xFEB2
#define AFX_IDP_E_DISKNOTREADY              0xFEB3
#define AFX_IDP_E_PATHFILEACCESSERROR       0xFEB4
#define AFX_IDP_E_PATHNOTFOUND              0xFEB5
#define AFX_IDP_E_INVALIDPATTERNSTRING      0xFEB6
#define AFX_IDP_E_INVALIDUSEOFNULL          0xFEB7
#define AFX_IDP_E_INVALIDFILEFORMAT         0xFEB8
#define AFX_IDP_E_INVALIDPROPERTYVALUE      0xFEB9
#define AFX_IDP_E_INVALIDPROPERTYARRAYINDEX 0xFEBA
#define AFX_IDP_E_SETNOTSUPPORTEDATRUNTIME  0xFEBB
#define AFX_IDP_E_SETNOTSUPPORTED           0xFEBC
#define AFX_IDP_E_NEEDPROPERTYARRAYINDEX    0xFEBD
#define AFX_IDP_E_SETNOTPERMITTED           0xFEBE
#define AFX_IDP_E_GETNOTSUPPORTEDATRUNTIME  0xFEBF
#define AFX_IDP_E_GETNOTSUPPORTED           0xFEC0
#define AFX_IDP_E_PROPERTYNOTFOUND          0xFEC1
#define AFX_IDP_E_INVALIDCLIPBOARDFORMAT    0xFEC2
#define AFX_IDP_E_INVALIDPICTURE            0xFEC3
#define AFX_IDP_E_PRINTERERROR              0xFEC4
#define AFX_IDP_E_CANTSAVEFILETOTEMP        0xFEC5
#define AFX_IDP_E_SEARCHTEXTNOTFOUND        0xFEC6
#define AFX_IDP_E_REPLACEMENTSTOOLONG       0xFEC7

/////////////////////////////////////////////////////////////////////////////

#ifdef _AFX_MINREBUILD
#pragma component(minrebuild, on)
#endif

#endif //__AFXRES_H__

/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\appcompat\tools\compatadmin\assert.cpp ===
#include "compatadmin.h"

// Record the current exception handler.

//CGrabException  ExceptHandler;

// Define support structure for WM_INITDIALOG

typedef struct {
    LPTSTR  szLine;
    LPTSTR  szFile;
    LPTSTR  szCause;
    LPTSTR  szDesc;
    BOOL    bException;
} ASSERTSTRINGS, *PASSERTSTRINGS;

// Prototype of dialog procedure.

BOOL CALLBACK AssertDlg(HWND hDlg, UINT uMsg, WPARAM wParam, LPARAM lParam);

// Main support function for the assert() macro.

int _ASSERT(int nLine, LPCTSTR szFilename, LPCTSTR szAssert, LPCTSTR szDsc)
{
    ASSERTSTRINGS    Str;
    TCHAR            szLine[40];
    TCHAR            szFile[MAX_PATH_BUFFSIZE];
    TCHAR            szCause[MAX_PATH_BUFFSIZE];
    TCHAR            szDesc[MAX_PATH_BUFFSIZE];

    // Construct dialog text.

    wsprintf(szLine, TEXT("Line Number:\t%d"),nLine);
    wsprintf(szFile, TEXT("Filename:\t%s"),szFilename);
    wsprintf(szCause,TEXT("Cause:\t\t%s"),szAssert);
    wsprintf(szDesc, TEXT("Description:\t%s"),szDsc);

    Str.szLine = szLine;
    Str.szFile = szFile;
    Str.szCause = szCause;
    Str.szDesc = szDesc;

    // Determine if we're in an exception handler. We do this now rather
    // than WM_INITDIALOG time because USER32 has an exception handler,
    // and that causes us to throw up the exception handler all the time.
    // Since we don't throw the exception inside the dialog proc, that
    // would have us comparing against the wrong handler.

    Str.bException = ExceptHandler.InHandler();

    // Throw up the dialog to display the assertion.

    return DialogBoxParam(GetModuleHandle(NULL),MAKEINTRESOURCE(IDD_ASSERTION),NULL,(DLGPROC)AssertDlg,(LPARAM)&Str);
}

// Main dialog box procedure.

BOOL CALLBACK AssertDlg(HWND hDlg, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    switch ( uMsg ) {
    // Setup to display the dialog with the appropriate values.
    
    case    WM_INITDIALOG:
        {
            PASSERTSTRINGS  pStr = (PASSERTSTRINGS) lParam;

            // Update the strings

            SetDlgItemText(hDlg,IDC_LINE,pStr->szLine);
            SetDlgItemText(hDlg,IDC_FILE,pStr->szFile);
            SetDlgItemText(hDlg,IDC_CAUSE,pStr->szCause);
            SetDlgItemText(hDlg,IDC_DESC,pStr->szDesc);

            // Hide the exception button if it doesn't exist.

            if ( !pStr->bException )
                ShowWindow(GetDlgItem(hDlg,IDC_EXCEPTION),SW_HIDE);
        }
        break;

        // Process commands.

    case    WM_COMMAND:
        switch ( LOWORD(wParam) ) {
        case    IDC_BREAK:
            EndDialog(hDlg,ASSERT_BREAK);
            break;
        case    IDC_ABORT:
            EndDialog(hDlg,ASSERT_ABORT);
            break;
        case    IDC_EXCEPTION:
            EndDialog(hDlg,ASSERT_EXCEPT);
            break;
        case    IDC_IGNORE:
            EndDialog(hDlg,ASSERT_IGNORE);
            break;
        }
    }

    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\appcompat\tools\compatadmin\capphelpwizard.h ===
#ifndef __WIZARD_H
    #include "wizard.h"
#endif    



#define  __CAPPHELPWIZARD_H


class CAppHelpWizard: public CShimWizard{
public:

    
    UINT nPresentHelpId;
    BOOL bBlock;
    CSTRING  strMessageSummary;
    CSTRING  strURL;

    
    BOOL  BeginWizard(HWND hParent);

    CAppHelpWizard()
    {
        nPresentHelpId = -1;
        bBlock = FALSE;
        
    }

};

extern BOOL CALLBACK SelectFiles    (HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam);

BOOL CALLBACK GetAppInfo            (HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam);

BOOL CALLBACK GetMessageType        (HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam);

BOOL CALLBACK GetMessageInformation (HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam);

BOOL CALLBACK AppWizardDone            (HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\appcompat\tools\compatadmin\cdatabaseglobal.h ===
#ifndef __DATABASE
    #include "CDatabase.h"
    #define __DATABASE
#endif    

class CDatabaseGlobal : public CDatabase{

};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\appcompat\tools\compatadmin\cdatabase.h ===
#include "DBDataStructures.h"

#ifndef __DATABASE
    #define __DATABASE
#endif    
class CSTRING;

class CDatabase {
public:


    static CSTRING     m_DBName;
    static GUID        m_DBGuid;
    static PDB         m_pDB;
    static CSTRING     m_szCurrentDatabase;//  Name of the SDB File

    PDBRECORD   m_pRecordHead;
    PSHIMDESC   m_pShimList;
    PDBLAYER    m_pLayerList;
    PAPPHELP    m_pAppHelp;

    static UINT        m_uStandardImages;
    
    BOOL        m_bDirty;

    void
    ReadAppHelp(
        void);


    BOOL
    AddAppHelp(
        TAGID tiAppHelp
        );



    

protected:
    

private:

    BOOL    STDCALL WriteString(HANDLE hFile, CSTRING & szString, BOOL bAutoCR);
    void    STDCALL ResolveMatch(CSTRING & szStr, PMATCHENTRY pMatch);

public:

    CDatabase()
    {
            m_pDB = NULL;
            m_pRecordHead = NULL;
            m_pShimList = NULL;
            m_pLayerList = NULL;
            m_pAppHelp = NULL;

            m_DBName.Init();
            m_szCurrentDatabase = TEXT("Untitled.SDB");

            m_bDirty = FALSE;

        //m_ShimList.Init();
        //m_LayerList.Init();
    }

    ~CDatabase()
    {
        m_DBName.Release();
        m_szCurrentDatabase.Release();

        //
        //BUGBUG
        //

        // When/where is the layetlsit and the layerlist freed ?

        //m_ShimList.Release();
        //m_LayerList.Release();
    }

    BOOL    STDCALL NewDatabase(BOOL bShowDialog);
    BOOL    STDCALL ChangeDatabaseName(void);
    BOOL    STDCALL CloseDatabase(void);

    /*.........................NOT USED .....................

    //BOOL    STDCALL ReadShim(TAGID, CShimDesc **);

    //CShimDesc * ReadShim(TAGID tShim);
    //BOOL    STDCALL ReadLayer(TAGID tLayer, CLayer **);
    //BOOL    STDCALL ReadRecord(TAGID tRecord, CDBRecord **);
    //BOOL    STDCALL ReadLayer(TAGID tLayer, PDBLAYER);
    //BOOL    STDCALL AddLayer(PDBLAYER);

    
    ...........................................................*/


    //BOOL    STDCALL ReadShim(TAGID tShim, PSHIMDESC);
    
    UINT    STDCALL DeleteRecord(PDBRECORD pRecord);

    BOOL    STDCALL OpenDatabase(CSTRING & szFilename, BOOL bGlobal);
    BOOL    STDCALL InsertRecord(PDBRECORD pRecord);
    static BOOL    STDCALL ReadRecord(TAGID tagParent, PDBRECORD pRecord, PDB pDB = NULL);
    static CSTRING STDCALL ReadDBString(TAGID tagID, PDB pDB = NULL);
    void    STDCALL ReadShims(BOOL bPermanent);
    void    STDCALL AddShim(TAGID tShim, BOOL bShim, BOOL bPermanent, BOOL bLayer);
    BOOL    STDCALL SaveDatabase(CSTRING & szFilename);

    CSTRINGList * STDCALL DisassembleRecord(PDBRECORD pRecordIn, BOOL bChildren, BOOL bSiblings, BOOL bIncludeLocalLayers, BOOL bFullXML, BOOL bAllowGlobal, BOOL bTestRun);

    BOOL    STDCALL WriteXML(CSTRING & szFilename, CSTRINGList * pString);
    static  BOOL    STDCALL InvokeCompiler(CSTRING & szInCommandLine);

    static DWORD   STDCALL GetEntryFlags(HKEY hKeyRoot, GUID & Guid);
    static BOOL    STDCALL SetEntryFlags(HKEY hKeyRoot, GUID & Guid, DWORD dwFlags);

    static BOOL CleanUp(); //Delete the test.sdb

    

    static BOOL SystemDB(CSTRING Filename)
    {
        
    
        HSDB hSDB   = SdbInitDatabase(HID_DOS_PATHS, Filename);
        PDB pDB     = SdbOpenDatabase(Filename,DOS_PATH);
        BOOL bSystemDB = FALSE;
        if ( NULL == pDB )
        return FALSE;




        TAGID tiDatabase = SdbFindFirstTag(pDB, TAGID_ROOT, TAG_DATABASE);
        
        if ( 0 != tiDatabase ) {

            TAGID tName;

            // Read in the database and name.

            tName = SdbFindFirstTag(pDB, tiDatabase, TAG_NAME);

            if ( 0 != tName ){
                CSTRING dbName = ReadDBString(tName, pDB); 

                if (dbName == TEXT("Microsoft Windows Application Compatibility Message Database")) 
                    bSystemDB = TRUE;
                
                
                }//if ( 0 != tName 

            }//if ( 0 != tiDatabase )

        SdbCloseDatabase(pDB);
        return bSystemDB;

    }//static BOOL SystemDB(CSTRING szFilename)
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\appcompat\tools\compatadmin\cdatabaselocal.h ===
#ifndef __DATABASE
    #include "CDatabase.h"
#endif   



#ifndef __CAPPHELPWIZARD_H
    #include "CAppHelpWizard.h"     
#endif    

class CDatabaseLocal : public CDatabase {
    
    
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\appcompat\tools\compatadmin\capphelpwizard.cpp ===
#include "compatadmin.h"
#include "Controls.h"

#ifndef __CAPPHELPWIZARD_H
    #include "CAppHelpWizard.h"
#endif    

#define NOBLOCK     1
#define BLOCK       2


                    
#define PAGE_GETAPP_INFO                0               
#define PAGE_GET_MATCH_FILES            1 
#define PAGE_GETMESSAGE_TYPE            2 
#define PAGE_GETMESSAGE_INFORMATION     3 
#define PAGE_DONE                       4 

#define NUM_PAGES (PAGE_DONE + 1)





extern CShimWizard* g_pCurrentWizard;
UINT g_nMAXHELPID = 0;

BOOL
DeleteAppHelp (
    UINT nHelpID
    );

BOOL
WipeAppHelp(
    PDBRECORD pRecord
    );



BOOL  
CAppHelpWizard::BeginWizard(
    HWND hParent
    )

{
    
    PROPSHEETPAGE   Pages[NUM_PAGES];

    ZeroMemory(&m_Record,sizeof(m_Record));

    //
    // BUGBUG: This can overwrite the existing guid.
    //

    CoCreateGuid(&m_Record.guidID);

    // Setup wizard variables
    g_pCurrentWizard = this;
    g_pCurrentWizard->m_uType = TYPE_APPHELP;

    
    // begin the wizard

    PROPSHEETHEADER Header;

    Header.dwSize = sizeof(PROPSHEETHEADER);
    Header.dwFlags = PSH_WIZARD97 | PSH_PROPSHEETPAGE | PSH_HEADER;
    Header.hwndParent = hParent;
    Header.hInstance = g_hInstance;
    Header.pszCaption = MAKEINTRESOURCE(IDS_WIZARD);
    Header.nStartPage = 0;
    Header.ppsp = Pages;
    Header.nPages = NUM_PAGES;
    Header.pszbmHeader = MAKEINTRESOURCE(IDB_WIZBMP);
    
    
    
    Pages[PAGE_GETAPP_INFO].dwSize = sizeof(PROPSHEETPAGE);
    Pages[PAGE_GETAPP_INFO].dwFlags = PSP_USEHEADERSUBTITLE;
    Pages[PAGE_GETAPP_INFO].hInstance = g_hInstance;
    Pages[PAGE_GETAPP_INFO].pszTemplate = MAKEINTRESOURCE(IDD_APPHELP1);
    Pages[PAGE_GETAPP_INFO].pfnDlgProc = (DLGPROC)GetAppInfo;
    Pages[PAGE_GETAPP_INFO].pszHeaderSubTitle = TEXT("Give Application information");


    Pages[PAGE_GET_MATCH_FILES].dwSize = sizeof(PROPSHEETPAGE);
    Pages[PAGE_GET_MATCH_FILES].dwFlags = PSP_USEHEADERSUBTITLE;
    Pages[PAGE_GET_MATCH_FILES].hInstance = g_hInstance;
    Pages[PAGE_GET_MATCH_FILES].pszTemplate = MAKEINTRESOURCE(IDD_ADDWIZARD7);
    Pages[PAGE_GET_MATCH_FILES].pfnDlgProc = (DLGPROC)SelectFiles;
    Pages[PAGE_GET_MATCH_FILES].pszHeaderSubTitle = TEXT("Select files used for application identification");


    
    Pages[PAGE_GETMESSAGE_TYPE].dwSize = sizeof(PROPSHEETPAGE);
    Pages[PAGE_GETMESSAGE_TYPE].dwFlags = PSP_USEHEADERSUBTITLE;
    Pages[PAGE_GETMESSAGE_TYPE].hInstance = g_hInstance;
    Pages[PAGE_GETMESSAGE_TYPE].pszTemplate = MAKEINTRESOURCE(IDD_APPHELP2);
    Pages[PAGE_GETMESSAGE_TYPE].pfnDlgProc = (DLGPROC)GetMessageType;
    Pages[PAGE_GETMESSAGE_TYPE].pszHeaderSubTitle = TEXT("Enter Message Type");
    

    Pages[PAGE_GETMESSAGE_INFORMATION].dwSize = sizeof(PROPSHEETPAGE);
    Pages[PAGE_GETMESSAGE_INFORMATION].dwFlags = PSP_USEHEADERSUBTITLE;
    Pages[PAGE_GETMESSAGE_INFORMATION].hInstance = g_hInstance;
    Pages[PAGE_GETMESSAGE_INFORMATION].pszTemplate = MAKEINTRESOURCE(IDD_APPHELP3);
    Pages[PAGE_GETMESSAGE_INFORMATION].pfnDlgProc = (DLGPROC)GetMessageInformation;
    Pages[PAGE_GETMESSAGE_INFORMATION].pszHeaderSubTitle = TEXT("Enter message information");
    

    Pages[PAGE_DONE].dwSize = sizeof(PROPSHEETPAGE);
    Pages[PAGE_DONE].dwFlags = PSP_USEHEADERSUBTITLE;
    Pages[PAGE_DONE].hInstance = g_hInstance;
    Pages[PAGE_DONE].pszTemplate = MAKEINTRESOURCE(IDD_APPHELPDONE);
    Pages[PAGE_DONE].pfnDlgProc = (DLGPROC)AppWizardDone;
    Pages[PAGE_DONE].pszHeaderSubTitle = TEXT("Custom AppHelp has been created !");

    
    if ( 0 < PropertySheet(&Header) ) {
        PDBRECORD pRecord = new DBRECORD;

        if ( NULL != pRecord ) {
            ZeroMemory(pRecord,sizeof(DBRECORD));

            pRecord->szEXEName = m_Record.szEXEName;
            pRecord->szAppName = m_Record.szAppName;
            
            pRecord->guidID = m_Record.guidID;
            pRecord->pEntries = m_Record.pEntries;

            g_theApp.GetDBLocal().InsertRecord(pRecord);

            return TRUE;
        }
    }else{

        //
        // Cancel  pressed, we migth have to delete the new  apphelp in the Database.
        //

        if (nPresentHelpId != -1) {
            DeleteAppHelp(g_nMAXHELPID);
            nPresentHelpId = -1;
            --g_nMAXHELPID;
        }
    }

    return FALSE;
}


//////////////////////////////////////////////////////
//      Dilaog Box routines                         //            

//////////////////////////////////////////////////////

BOOL
CALLBACK
GetAppInfo(
    HWND hDlg, 
    UINT uMsg, 
    WPARAM wParam, 
    LPARAM lParam
    )

{

    switch ( uMsg ) {
    case    WM_INITDIALOG:
        {

            //
            // Heading
            //

            HWND hParent = GetParent(hDlg);
            SetWindowText(hParent,TEXT("Create a custom AppHelp message"));


            //
            // Limit the length of the text boxes
            //

            SendMessage( 
                GetDlgItem(hDlg,IDC_APPNAME),              // handle to destination window 
                EM_LIMITTEXT,             // message to send
                (WPARAM) LIMIT_APP_NAME,          // text length
                (LPARAM) 0
                );

            SendMessage( 
                GetDlgItem(hDlg,IDC_EXEPATH),              // handle to destination window 
                EM_LIMITTEXT,             // message to send
                (WPARAM) MAX_PATH,          // text length
                (LPARAM) 0
                );
            
            if ( 0 == g_pCurrentWizard->m_Record.szAppName.Length() )
                g_pCurrentWizard->m_Record.szAppName = TEXT("No Name");

            
            SetDlgItemText(hDlg,IDC_APPNAME, g_pCurrentWizard->m_Record.szAppName);

            if ( g_pCurrentWizard->m_Record.szAppName == TEXT("No Name") )
                SendMessage(GetDlgItem(hDlg,IDC_APPNAME),EM_SETSEL,0,-1);

            // Force proper Next button state.

            SHAutoComplete(GetDlgItem(hDlg,IDC_EXEPATH), AUTOCOMPLETE);

            SendMessage(hDlg,WM_COMMAND,MAKEWPARAM(IDC_APPNAME,EN_CHANGE),0);
        }
        break;

    case    WM_NOTIFY:
        {
            NMHDR * pHdr = (NMHDR *) lParam;

            switch ( pHdr->code ) {
            case    PSN_SETACTIVE:
                {
                    SendMessage(hDlg,WM_COMMAND,MAKEWPARAM(IDC_NAME,EN_CHANGE),0);
                    
                }
                break;

            case    PSN_WIZNEXT:
                {
                    TCHAR szTemp[MAX_STRING_SIZE];
                    TCHAR szEXEPath[MAX_PATH_BUFFSIZE];

                    GetDlgItemText(hDlg,IDC_APPNAME,szTemp,MAX_STRING_SIZE);

                    CSTRING::Trim(szTemp);

                    g_pCurrentWizard->m_Record.szAppName = szTemp;


                    GetDlgItemText(hDlg,IDC_EXEPATH,szEXEPath,MAX_PATH_BUFFSIZE);


                    CSTRING::Trim(szEXEPath);

                    HANDLE hFile = CreateFile (szEXEPath,
                                               0,
                                               0,
                                               NULL,
                                               OPEN_EXISTING,
                                               FILE_ATTRIBUTE_NORMAL,
                                               NULL);

                    if ( INVALID_HANDLE_VALUE == hFile ) {
                        MessageBox(hDlg,TEXT("Unable to locate specified file"),TEXT("Invalid file name"),MB_OK);

                        SetWindowLongPtr(hDlg,DWLP_MSGRESULT,-1);
                        return -1;
                    }
                    
                    g_pCurrentWizard->m_szLongName = szEXEPath;

                    CSTRING str = szEXEPath;
                    

                    g_pCurrentWizard->m_Record.szEXEName = str;
                    g_pCurrentWizard->m_Record.szEXEName.ShortFilename();
                }
                break;
            }
        }
        break;

    case    WM_COMMAND:
        switch ( LOWORD(wParam) ) {
        case    IDC_EXEPATH:
        case    IDC_APPNAME:
            if ( EN_CHANGE == HIWORD(wParam) ) {

                TCHAR szTemp[MAX_STRING_SIZE];

                GetDlgItemText(hDlg,IDC_APPNAME,szTemp,MAX_STRING_SIZE);

                BOOL    bEnable = ( CSTRING::Trim(szTemp) > 0) ? TRUE:FALSE;

                bEnable &=  (GetWindowTextLength(GetDlgItem(hDlg,IDC_EXEPATH)) > 0) ? TRUE:FALSE;
                DWORD   dwFlags = PSWIZB_BACK;

                if ( bEnable )
                    dwFlags |= PSWIZB_NEXT;

                SendMessage(GetParent(hDlg),PSM_SETWIZBUTTONS,0, dwFlags);
            }
            break;

           case    IDC_BROWSE:
            {
            CSTRING szFilename;

            HWND hwndFocus = GetFocus();

            if ( g_theApp.GetFilename(TEXT("Find executable"),
                                      TEXT("EXE File (*.EXE)\0*.EXE\0All files (*.*)\0*.*\0\0"),
                                      TEXT(""),
                                      TEXT("EXE"),
                                      OFN_PATHMUSTEXIST | OFN_FILEMUSTEXIST,
                                      TRUE,
                                      szFilename)) {
                

                SetDlgItemText(hDlg,IDC_EXEPATH,szFilename);

                // Force proper Next button state.

                SendMessage(hDlg,WM_COMMAND,MAKEWPARAM(IDC_EXEPATH,EN_CHANGE),0);
            }

            SetFocus( hwndFocus );
        }
        break;

        }//switch ( LOWORD(wParam) ) 
    }// switch ( uMsg )

        return FALSE;
}//end of GetAppName(HWND hDlg, UINT uMsg, WPARAM wParam, LPARAM lParam)



BOOL
CALLBACK
GetMessageType (
    HWND hDlg, 
    UINT uMsg, 
    WPARAM wParam, 
    LPARAM lParam)
{
    switch ( uMsg ) {
    case    WM_INITDIALOG:
        {

            SendMessage(GetDlgItem(hDlg,IDC_NOBLOCK),
                        BM_SETCHECK,              // message to send
                        (WPARAM) 1,          // check state
                        (LPARAM) 0          // not used; must be zero
                        );

            return TRUE;
        }
    case    WM_NOTIFY:
        {
            NMHDR * pHdr = (NMHDR *) lParam;

            switch ( pHdr->code ) {
            
            case    PSN_WIZNEXT:
                {
                    int iReturn = SendMessage(GetDlgItem(hDlg,IDC_NOBLOCK),
                                              BM_GETCHECK,              // message to send
                                              (WPARAM) 1,          // check state
                                              (LPARAM) 0          // not used; must be zero
                                              );

                    if (iReturn == BST_CHECKED) {
                        ((CAppHelpWizard*)g_pCurrentWizard)->bBlock = FALSE;
                    }else{
                        ((CAppHelpWizard*)g_pCurrentWizard)->bBlock = TRUE;
                    }

                    return TRUE;
                }
            case PSN_SETACTIVE:
                {
                    DWORD dwFlags = PSWIZB_NEXT | PSWIZB_BACK;

                    SendMessage(GetParent(hDlg),PSM_SETWIZBUTTONS,0, dwFlags);
                    return TRUE;
                }
                
            }//switch( pHdr->code )
        break;    
        }
        
    }//SWITCH

 return FALSE;
    
}//end of GetMessageType        (HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam)

BOOL 
CALLBACK 
GetMessageInformation (
    HWND hDlg, 
    UINT uMsg, 
    WPARAM wParam, 
    LPARAM lParam
    )

{
    
    switch ( uMsg ) {
    case    WM_INITDIALOG:
        {
            //
            // Set the maximum length of the text boxes
            //


            SendMessage( 
                GetDlgItem(hDlg,IDC_URL),              // handle to destination window 
                EM_LIMITTEXT,             // message to send
                (WPARAM) 1024,          // text length
                (LPARAM) 0
                );

            SendMessage( 
                GetDlgItem(hDlg,IDC_MSG_SUMMARY),              // handle to destination window 
                EM_LIMITTEXT,             // message to send
                (WPARAM) 1024,          // text length
                (LPARAM) 0
                );


            // Force proper Next button state.

            SendMessage(hDlg,WM_COMMAND,MAKEWPARAM(IDC_MSG_SUMMARY,EN_CHANGE),0);
        }
        break;

    case    WM_NOTIFY:
        {
            NMHDR * pHdr = (NMHDR *) lParam;

            switch ( pHdr->code ) {
            case    PSN_SETACTIVE:
                {
                    SendMessage(hDlg,WM_COMMAND,MAKEWPARAM(IDC_MSG_SUMMARY,EN_CHANGE),0);
                    
                }
                break;

            case    PSN_WIZNEXT:
                {

                    PAPPHELP pAppHelp = new APPHELP;

                    if (pAppHelp == NULL) {
                        MEM_ERR;
                        return FALSE;
                    }

                    pAppHelp->HTMLHELPID = ++g_nMAXHELPID;

                    ((CAppHelpWizard*)g_pCurrentWizard)->nPresentHelpId = pAppHelp->HTMLHELPID;

                    TCHAR szTemp[2048];

                    *szTemp  = 0;

                    
                    GetDlgItemText(hDlg,IDC_MSG_SUMMARY,szTemp,1024);
                    pAppHelp->strMessage = szTemp;

                    
                    //
                    // Add the APPHELP message in the Library.
                    //

                    pAppHelp->pNext = g_theApp.GetDBLocal().m_pAppHelp;
                    g_theApp.GetDBLocal().m_pAppHelp = pAppHelp;

                    //
                    // Add the AppHelp for the entry
                    //

                    
                    PHELPENTRY  pHelp = new HELPENTRY;


                    
                    if ( NULL != pHelp ) {
                

                        pHelp->Entry.uType = ENTRY_APPHELP;

                        pHelp->uHelpID = ((CAppHelpWizard*)g_pCurrentWizard)->nPresentHelpId;
                        pHelp->bBlock  = ((CAppHelpWizard*)g_pCurrentWizard)->bBlock ;

                        if (pHelp->bBlock) {
                            pHelp->uSeverity = BLOCK;
                        }else{
                            pHelp->uSeverity = NOBLOCK;
                        }

                        *szTemp  = 0;
                        GetDlgItemText(hDlg,IDC_URL,szTemp,1024);
                        pHelp->strURL = szTemp;


                        pHelp->Entry.pNext = ((CAppHelpWizard*)g_pCurrentWizard)->m_Record.pEntries;

                        ((CAppHelpWizard*)g_pCurrentWizard)->m_Record.pEntries  = (PDBENTRY)pHelp;

                    }else{

                        MEM_ERR;

                    }


                    
                 return TRUE;   
                 }
                
            }
        }
        break;

    case    WM_COMMAND:

        switch ( LOWORD(wParam) ) {
        
        
        case    IDC_MSG_SUMMARY:
            if ( EN_CHANGE == HIWORD(wParam) ) {
                BOOL    bEnable = (GetWindowTextLength(GetDlgItem(hDlg,IDC_MSG_SUMMARY)) > 0) ? TRUE:FALSE;
        
                DWORD   dwFlags = PSWIZB_BACK;

                if ( bEnable )
                    dwFlags |= PSWIZB_NEXT;

                SendMessage(GetParent(hDlg),PSM_SETWIZBUTTONS,0, dwFlags);
            }
            break;

        }//switch ( LOWORD(wParam) ) 
    }// switch ( uMsg )

    return FALSE;
}//end of GetMessageInformation (HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam)


BOOL
CALLBACK
AppWizardDone (
    HWND hDlg, 
    UINT uMsg, 
    WPARAM wParam, 
    LPARAM lParam)

{
    switch ( uMsg ) {
    
    case    WM_NOTIFY:
        {
            NMHDR * pHdr = (NMHDR *) lParam;

            switch ( pHdr->code ) {
            
            case    PSN_SETACTIVE:
                SendMessage(GetParent(hDlg),PSM_SETWIZBUTTONS, 0, PSWIZB_BACK | PSWIZB_FINISH);
                return TRUE;

            case PSN_WIZBACK:
                {
                    //
                    // We have to delete the apphelp message that has been added to the library.
                    //

                    if (((CAppHelpWizard*)g_pCurrentWizard)->nPresentHelpId != -1) {
                    
                        DeleteAppHelp(g_nMAXHELPID);
                        --g_nMAXHELPID;

                        ((CAppHelpWizard*)g_pCurrentWizard)->nPresentHelpId = -1;

                        WipeAppHelp(&((CAppHelpWizard*)g_pCurrentWizard)->m_Record);
                    }

                    break;
                }

            }
        }
        break;


    case    WM_COMMAND:
        switch ( LOWORD(wParam) ) {

        case    IDC_TESTRUN:
            {
                HWND hndFocus = GetFocus();
                g_theApp.TestRun(&g_pCurrentWizard->m_Record,&g_pCurrentWizard->m_szLongName,NULL,hDlg);

                SetFocus(hndFocus);
                return TRUE;

            }
            break;
        }
        break;
    }

    return FALSE;

}//end of WizardDone            (HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam)

BOOL
DeleteAppHelp (
    UINT nHelpID
    )
{

    PAPPHELP pAppHelp = g_theApp.GetDBLocal().m_pAppHelp,
             pPrev = NULL;

    while (pAppHelp){

        if (pAppHelp->HTMLHELPID == nHelpID) {

            if (pPrev == NULL) {

                //
                // This is the first element
                //

                g_theApp.GetDBLocal().m_pAppHelp = g_theApp.GetDBLocal().m_pAppHelp->pNext;

            }else{

                pPrev->pNext = pAppHelp->pNext;
            }

            delete pAppHelp;
            return TRUE;

        }else{

            pPrev       = pAppHelp;
            pAppHelp    = pAppHelp->pNext;
        }
    }

    return FALSE;
}

BOOL
WipeAppHelp(
    PDBRECORD pRecord
    )
{

    PDBENTRY pEntry = pRecord->pEntries;

    PDBENTRY pPrev  = NULL;

    while (pEntry) {

        if (  ENTRY_APPHELP == pEntry->uType) {

            if (pPrev == NULL) {
                
                pRecord->pEntries = pEntry->pNext;

            }
            else{
                pPrev->pNext = pEntry->pNext;
            }

            delete pEntry;
            return TRUE;

        }else{
            pEntry = pEntry->pNext;
        }
    }

    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\appcompat\tools\compatadmin\cdatabase.cpp ===
/*

Note
==============
 
That when we call Opendatabase(bGlobal = TRUE ) then we remove all the entries for the database.
In the case when we had only one DB object, this meant removing all entries, local as well as global
from the DB, but when we have got two DBs, this will only remove the entries for the present DB


Opendatabase(bGlobal = TRUE ) is called only during WM_CREATE of the CApplication otherwise,
bGlobal = FALSE.

If we want others to view other system dbs, then we might have have to take care of this.

*/



#include "compatadmin.h"
#include "psapi.h"
extern UINT g_nMAXHELPID;

CSTRING g_szDBName;
BOOL    g_bNew = FALSE;

BOOL
DeleteAppHelp (
    UINT nHelpID
    );

bool
InstallDatabase(
    TCHAR *szPath,
    TCHAR *szOptions
    );




 CSTRING     CDatabase::m_DBName;
 GUID        CDatabase::m_DBGuid;
 PDB         CDatabase::m_pDB;
 CSTRING     CDatabase::m_szCurrentDatabase;//  Name of the SDB File
 UINT        CDatabase::m_uStandardImages;


 //
 //Checks whether the 2 PDBENTRIES have the same mathcign files.
 //
int CheckMatch(const PDBENTRY pExistEntry, const PDBENTRY pNewEntry);


BOOL CDatabase::ChangeDatabaseName(void)
{
    if ( !g_bNew )
        g_szDBName = m_DBName;

    if ( g_szDBName.Length() == 0 ) {
        MEM_ERR;
        return FALSE;
    }

    if ( FALSE == DialogBox(g_hInstance,MAKEINTRESOURCE(IDD_NEWDATABASE),g_theApp.m_hWnd,(DLGPROC)NewDatabaseProc) )
        return FALSE;

    if ( !g_bNew )
        if ( m_DBName != g_szDBName ) {
            m_DBName = g_szDBName;

            m_bDirty = TRUE;

            g_theApp.UpdateView();
        }

    m_DBName = g_szDBName;

    return TRUE;
}

BOOL CDatabase::NewDatabase(BOOL bShowDialog)
{
    g_szDBName = TEXT("No Name");

    g_bNew = TRUE;

    if ( bShowDialog )
        if ( !ChangeDatabaseName() )
            return FALSE;

    g_bNew = FALSE;

    CloseDatabase();

    CDatabase::m_DBName = g_szDBName;

    m_szCurrentDatabase = TEXT("");

    g_theApp.UpdateView();

    return TRUE;    
}

BOOL CDatabase::CloseDatabase(void)
{
    // delete only the local database

    PDBRECORD pWalk = m_pRecordHead;
    PDBRECORD pPrev = pWalk, pNext;//Not needed, just to satisfy Prefast!

    while ( NULL != pWalk ) {
        if ( ! pWalk->bGlobal ) {
            pNext = pWalk->pNext;

            if ( pWalk == m_pRecordHead ) {
                m_pRecordHead = pWalk->pNext;
            }

            else
                pPrev->pNext = pWalk->pNext;

            delete pWalk;
            pWalk = pNext;



        } else {
            pPrev = pWalk;
            pWalk = pWalk->pNext;
        }
    }

    // Remove local layers

    PDBLAYER pLayer = m_pLayerList;
    PDBLAYER pHold;

    while ( NULL != pLayer ) {
        if ( !pLayer->bPermanent ) {
            PDBLAYER pNext = pLayer->pNext;

            if ( pLayer == m_pLayerList )
                m_pLayerList = pLayer->pNext;
            else
                pHold->pNext = pLayer->pNext;

            delete pLayer;

            pLayer = pNext;

            continue;
        }

        pHold = pLayer;
        pLayer = pLayer->pNext;
    }

    ZeroMemory(&m_DBGuid,sizeof(GUID));

/*
    m_DBName = "No Name";

    m_szCurrentDatabase = "";

    g_theApp.UpdateView();
*/
    m_bDirty = FALSE;

    return TRUE;
}

UINT CDatabase::DeleteRecord(PDBRECORD pRecord)
{
    PDBRECORD pWalk;
    PDBRECORD pHoldRecord;

    pWalk = m_pRecordHead;

    while ( NULL != pWalk ) {
        if ( pWalk == pRecord ) {
            // Remove root level record.

            PDBENTRY pEntry = pWalk->pEntries;

            while ( NULL != pEntry ) {
                PDBENTRY pHoldEntry = pEntry->pNext;

                if (pEntry->uType == ENTRY_APPHELP) {

                    DeleteAppHelp( ((PHELPENTRY)pEntry)->uHelpID );
                }

                delete pEntry;

                pEntry = pHoldEntry;
            }

            if ( NULL != pWalk->pDup ) {
                // Replace with duplicate

                pWalk->pDup->pNext = pWalk->pNext;

                if ( pWalk == m_pRecordHead )
                    m_pRecordHead = pWalk->pDup;
                else
                    pHoldRecord->pNext = pWalk->pDup;
            } else {
                if ( pWalk == m_pRecordHead )
                    m_pRecordHead = m_pRecordHead->pNext;
                else
                    pHoldRecord->pNext = pWalk->pNext;
            }

            delete pWalk;

            m_bDirty = TRUE;

            return DELRES_RECORDREMOVED;
        }

        if ( NULL != pWalk->pDup ) {
            PDBRECORD pWalk2 = pWalk->pDup;
            PDBRECORD pHold2;

            while ( NULL != pWalk2 ) {
                if ( pWalk2 == pRecord )
                    break;

                pHold2 = pWalk2;
                pWalk2 = pWalk2->pDup;
            }

            if ( NULL != pWalk2 ) {
                // Remove the duplicate entry.

                if ( pWalk2 == pWalk->pDup )
                    pWalk->pDup = pWalk2->pDup;
                else
                    pHold2->pDup = pWalk2->pDup;

                PDBENTRY pEntry = pWalk2->pEntries;

                while ( NULL != pEntry ) {
                    PDBENTRY pHoldEntry = pEntry->pNext;

                    delete pEntry;

                    pEntry = pHoldEntry;
                }

                delete pWalk2;

                m_bDirty = TRUE;

                return DELRES_DUPREMOVED;
            }
        }

        pHoldRecord = pWalk;
        pWalk = pWalk->pNext;
    }

    return DELRES_FAILED;
}

BOOL CDatabase::OpenDatabase(CSTRING & szFilename, BOOL bGlobal)
{
    if ( NULL == g_hSDB ) {
        TCHAR   szShimDB[MAX_PATH_BUFFSIZE] ;

        *szShimDB = 0;
        

        GetSystemWindowsDirectory(szShimDB, MAX_PATH);
        lstrcat(szShimDB,TEXT("\\AppPatch"));

        CSTRING szStr = szShimDB;

        if ( szStr.Length() == 0 ) {
            MEM_ERR;
            return FALSE;
        }

        g_hSDB = SdbInitDatabase(HID_DOS_PATHS,(LPCWSTR) szStr);
    }

#ifndef UNICODE

    WCHAR   wszFilename[MAX_PATH_BUFFSIZE];

    ZeroMemory(wszFilename,sizeof(wszFilename));

    MultiByteToWideChar (CP_ACP,MB_PRECOMPOSED,szFilename,lstrlen(szFilename),wszFilename,MAX_PATH);

    m_pDB = SdbOpenDatabase(wszFilename,DOS_PATH);
#else
    m_pDB = SdbOpenDatabase(szFilename.pszString,DOS_PATH);

#endif


    if ( NULL == m_pDB )
        return FALSE;

    if ( bGlobal ) {
        // Delete the previous database from memory

        
        while ( NULL != m_pRecordHead ) {
            PDBRECORD pHold = m_pRecordHead->pNext;

            delete m_pRecordHead;

            m_pRecordHead = pHold;
        }
    } else {
        CloseDatabase();
    }

    ReadShims(bGlobal);

    ReadAppHelp();

    // Load in the contents of the database.

    TAGID   tiDatabase, tiExe;
    UINT    uShims=0;
    UINT    uEntries=0;
    UINT    uAppHelp=0;
    UINT    uLayers=0;

    tiDatabase = SdbFindFirstTag(CDatabase::m_pDB, TAGID_ROOT, TAG_DATABASE);

    if ( 0 != tiDatabase ) {
        if ( !bGlobal ) {
            TAGID tName;

            // Read in the database GUID and name.

            tName = SdbFindFirstTag(m_pDB, tiDatabase, TAG_NAME);

            if ( 0 != tName )
                m_DBName = ReadDBString(tName);

            tName = SdbFindFirstTag(m_pDB, tiDatabase, TAG_DATABASE_ID);

            if ( 0 != tName )
                SdbReadBinaryTag(m_pDB,tName,(PBYTE)&m_DBGuid,sizeof(GUID));
        }

        tiExe = SdbFindFirstTag(CDatabase::m_pDB, tiDatabase, TAG_EXE);



        while ( 0 != tiExe ) {
            PDBRECORD pRecord = new DBRECORD;
            MSG         Msg;

            while ( PeekMessage(&Msg,NULL,0,0,PM_REMOVE) ) {
                TranslateMessage(&Msg);
                DispatchMessage(&Msg);
            }

            ++uEntries;

            if ( NULL != pRecord ) {
                if ( ReadRecord(tiExe,pRecord) ) {
                    pRecord->bGlobal = bGlobal;

                    InsertRecord(pRecord);
                }
            }

            tiExe = SdbFindNextTag(CDatabase::m_pDB, tiDatabase, tiExe);
        }
    }

    if ( !bGlobal ) {
        //
        // BUGBUG Consider using shlwapi function to find a filename
        //
        LPTSTR szFile = _tcsrchr( (LPTSTR)szFilename, TEXT('\\'));
        if (szFile == NULL) {
            szFile = szFilename;
        } else {
            ++szFile; // or move to the next char CharNext
        }

/*
        wsprintf(szWindowTitle,"Application Management Console (%s)",szFile+1);

        SetWindowText(g_theApp.m_hWnd,szWindowTitle);
*/
        m_szCurrentDatabase = szFilename;
    }
/*
    TCHAR szTemp[80];

    wsprintf(szTemp,"Entries: %d (L: %d S: %d AH: %d)",uEntries,uLayers, uShims,uAppHelp);

    SendMessage(m_hStatusBar,SB_SETTEXT,1,(LPARAM) szTemp);
*/
    DWORD dwFlags = GetFileAttributes(szFilename);

    if ( 0 != (dwFlags & FILE_ATTRIBUTE_READONLY) )
        g_theApp.SetStatusText(2,CSTRING(TEXT("Read Only")));
    else
        g_theApp.SetStatusText(2,CSTRING(TEXT("")));

    g_theApp.UpdateView();

    SdbCloseDatabase(m_pDB);

    m_pDB = NULL;

    return TRUE;
}

BOOL CDatabase::InsertRecord(PDBRECORD pRecord)
{
    // Insert into the list.

    /***
    This routine inserts the passed pRecord into the list pointed by  m_pRecordHead. 
    This routine also checks if there is some other files are already associated with this App. and if
    yes it makes the pDup record of that exe to point to pRecord. pRecord->pDup will
    point to whatever that entry's pDup pointed to.     */

    

    if ( NULL != m_pRecordHead ) {

        if (pRecord->bGlobal == FALSE) {
        
    }



        PDBRECORD pWalk = m_pRecordHead;
        PDBRECORD pHold = NULL;
        int       nResult;

        do {
            nResult = lstrcmpi(pWalk->szAppName,pRecord->szAppName);

            // If less OR Equal

            //CHANGE (-1 != )
            if ( 0 <= nResult )
                break;

            pHold = pWalk;
            pWalk = pWalk->pNext;
        }
        while ( NULL != pWalk );

        // Insert it right here.

        if ( 0 == nResult ) {
            // The strings are equal. Simply add shim/apphelp information
            // to this .EXE entry.

            
                PDBRECORD pSameAppExes      = pWalk;
                PDBRECORD  pSameAppExesPrev = NULL;


                if (pRecord->bGlobal){

                     pRecord->pDup = pWalk->pDup;
                     pWalk->pDup = pRecord;

                }else{
                //
                //We do not want to perform the extra check on system entries.
                // 

                 
                while (pSameAppExes) {

                    if (pSameAppExes->szEXEName == pRecord->szEXEName   ) {

                        //
                        //Same exe, must check the matching files and if same then we must add these entries to the present exe.
                        //

                        
                        
                        
                        int check = CheckMatch(pSameAppExes->pEntries, pRecord->pEntries);
                        if (check) {
                        
                          
                        int result =   MessageBox(g_theApp.m_hWnd,
                                                  TEXT("An existing file with the same name and similar matching information was found\n")
                                                  TEXT("Do you wish to update the previous fix with the modified entries?\n\n"),
                                                  TEXT("CompatAdmin"), 
                                                   MB_ICONWARNING | MB_YESNO|MB_DEFBUTTON1 | MB_APPLMODAL 
                                               );

                      if (result == IDYES) {
                          //
                          //Add all the entries, except the Matcbing file to this exe entry
                          //

                          if (pSameAppExes->szLayerName.Length() &&
                              pRecord->szLayerName.Length() &&
                              ! (pRecord->szLayerName == pSameAppExes->szLayerName)
                              ) {

                              //
                              //The new entry contains a layer as well !
                              //

                              
                              CSTRING message;
                              message.sprintf(TEXT("Do you want to replace the compatibiltu mode for File: \"%s\" in Application \"%s\" \?\nPresent Compatability mode = %s\nNew Compatibility mode = %s"),
                                              (LPCTSTR)pSameAppExes->szEXEName,(LPCTSTR)pSameAppExes->szAppName,
                                              (LPCTSTR)pSameAppExes->szLayerName,(LPCTSTR)pRecord->szLayerName
                                              );

                              
                              int result = MessageBox(g_theApp.m_hWnd,message,TEXT("CompatAdmin"),MB_ICONWARNING | MB_YESNO);

                              if (result == IDYES) {
                                  pSameAppExes->szLayerName = pRecord->szLayerName;
                              }
                          }
                          else if(!pSameAppExes->szLayerName.Length() && pRecord->szLayerName.Length()){
                              //
                              //Add the layer directly
                              //

                              pSameAppExes->szLayerName = pRecord->szLayerName;


                          }
                                                    
                          while ( pRecord->pEntries ) {


                              PDBENTRY pNext = pRecord->pEntries->pNext;
                              
            
                              if ( pRecord->pEntries->uType != ENTRY_MATCH ) {
                
                              //
                              //Take out the first entry.
                              //

                                  pRecord->pEntries->pNext = pSameAppExes->pEntries;
                                  pSameAppExes->pEntries   = pRecord->pEntries;
                                  pRecord->pEntries        = pNext;
                                continue;
                                }
                              else break;

                          }//while ( pRecord->pEntries )



                          PDBENTRY pPrev = pRecord->pEntries;
                          PDBENTRY pTemp = pRecord->pEntries;

                          //
                          //We are here means the first entry is a match entry  or NULL. First loop will do nothing.
                          //

                          while( pTemp ){
                          
                          
                            if (pTemp->uType != ENTRY_MATCH) {
                                    //
                                    //Add this to the list of entries for the exe
                                    //

                                    //1. splice this entry from pRecord->pEntries
                                    pPrev->pNext = pTemp->pNext;

                                    //2. Add it to the front of the entrties of the prev. file
                                    pTemp->pNext =   pSameAppExes->pEntries;

                                    //3. 

                                    pSameAppExes->pEntries = pTemp;

                                    //4. Move on for the other entries in pRecord

                                      pTemp = pPrev->pNext;
                              }else{
                                  pPrev = pTemp;
                                  pTemp = pTemp->pNext;

                              }//if (pTemp->uType != ENTRY_MATCH ELSE
                          }//while( pTemp )

                        pRecord->DestroyAll();

                     }//if reuslt == IDYES
                     else{ //IDNO
                         pRecord->DestroyAll();
                         ;
                     }

                    break;
                      }//if (check)

                    }//if (pSameAppExes->szEXEName == pRecord->szEXEName
                    
                        
                    pSameAppExesPrev    = pSameAppExes;
                    pSameAppExes        = pSameAppExes->pDup;
                        
                    
                    
                }//while (pSameAppExes) 

                //
                //We have not found any  exe within this app that has the same matching info as this one. 
                //So we haev to add this to the end
                //

                if (pSameAppExes == NULL ) {

                        if ( NULL != pHold ) {
                          pRecord->pNext = pWalk->pNext;
                          pHold->pNext = pRecord;
                          pWalk->pNext = NULL;
                          pRecord->pDup = pWalk;



                         } else { // First element
                            pRecord->pNext =m_pRecordHead->pNext;
                            m_pRecordHead = pRecord;
                            pRecord->pDup = pWalk;
                         }

                }

              }//else for the outer loop. above the while 

        } else {

            if ( NULL != pHold ) {
                pRecord->pNext = pHold->pNext;
                pHold->pNext = pRecord;
            } else { // First element
                pRecord->pNext = m_pRecordHead;
                m_pRecordHead = pRecord;
            }
        }
    } else { //fIRST AND ONLY ELEMENT
        pRecord->pNext = NULL;
        m_pRecordHead = pRecord;

    }


    return TRUE;
}

BOOL CDatabase::ReadRecord(TAGID tagParent, PDBRECORD pRecord, PDB pDB)
{
    TAGID       Info;
    PDBENTRY    pLast = NULL;

    if ( NULL == pDB )
        pDB = CDatabase::m_pDB;

    // Entries with flags are ignored and not displayed

    Info = SdbFindFirstTag(pDB, tagParent, TAG_FLAG); //K Did not find this TAG_FLAG IN THE SDB Database !!!

    if ( 0 != Info )
        return FALSE;

    ZeroMemory(pRecord,sizeof(DBRECORD));

    Info = SdbGetFirstChild(pDB,tagParent);

    while ( 0 != Info ) {
        TAG tag;

        tag = SdbGetTagFromTagID(pDB,Info);

        switch ( tag ) {
        case    TAG_NAME:
            {
                pRecord->szEXEName = ReadDBString(Info,pDB);
            }
            break;

        case    TAG_LAYER:
            {
                TAGID   Layer = SdbGetFirstChild(pDB,Info);

                while ( 0 != Layer ) {
                    TAG Tag = SdbGetTagFromTagID(pDB,Layer);

                    switch ( Tag ) {
                    case    TAG_NAME:
                        pRecord->szLayerName = ReadDBString(Layer,pDB);
                        break;
                    }

                    Layer = SdbGetNextChild(pDB,Info,Layer);
                }
            }
            break;

        case    TAG_APP_NAME:
            {
                pRecord->szAppName = ReadDBString(Info,pDB);
            }
            break;

        case    TAG_MATCHING_FILE:
            {
                TAGID       MatchInfo;
                TAG         Tag;
                PMATCHENTRY pEntry = new MATCHENTRY;

                if ( NULL != pEntry ) {
                    ZeroMemory(pEntry,sizeof(MATCHENTRY));

                    pEntry->Entry.uType = ENTRY_MATCH;
                    pEntry->Entry.pNext = NULL;

                    MatchInfo = SdbGetFirstChild(pDB,Info);

                    while ( 0 != MatchInfo ) {
                        Tag = SdbGetTagFromTagID(pDB,MatchInfo);

                        switch ( Tag ) {
                        case    TAG_NAME:
                            pEntry->szMatchName = ReadDBString(MatchInfo,pDB);
                            break;
                        case    TAG_SIZE:
                            pEntry->dwSize = SdbReadDWORDTag(pDB,MatchInfo,0);
                            break;
                        case    TAG_CHECKSUM:
                            pEntry->dwChecksum = SdbReadDWORDTag(pDB,MatchInfo,0);
                            break;
                        case    TAG_BIN_FILE_VERSION:
                            pEntry->FileVersion.QuadPart = SdbReadQWORDTag(pDB,MatchInfo,0);
                            break;
                        case    TAG_FILE_VERSION:
                            pEntry->szFileVersion = ReadDBString(MatchInfo,pDB);
                            break;
                        case    TAG_BIN_PRODUCT_VERSION:
                            pEntry->ProductVersion.QuadPart = SdbReadQWORDTag(pDB,MatchInfo,0);
                            break;
                        case    TAG_PRODUCT_VERSION:
                            pEntry->szProductVersion = ReadDBString(MatchInfo,pDB);
                            break;
                        case    TAG_FILE_DESCRIPTION:
                            pEntry->szDescription = ReadDBString(MatchInfo,pDB);
                            break;
                        case    TAG_COMPANY_NAME:
                            pEntry->szCompanyName = ReadDBString(MatchInfo,pDB);
                            break;
                        }

                        MatchInfo = SdbGetNextChild(pDB,Info,MatchInfo);
                    }

    

                    /***
                    Here's what he probably meant. He has used the pEntry->Entry.pNext
                    to actually link up the the differnrent match entries for the EXE.
                    pLast points to the last pEntry. !!!! This is SOMETHING.
                    
                    */

                    //Note that pEntry is a variable of type PMATCHENTRY

                    if ( NULL != pLast )
                        pLast->pNext = (PDBENTRY) pEntry;
                    else
                        pRecord->pEntries = (PDBENTRY) pEntry;

                    pLast = (PDBENTRY) pEntry;
                }
            }
            break;

        case    TAG_PATCH_REF:
        case    TAG_SHIM_REF:
            {
                PSHIMENTRY  pEntry = new SHIMENTRY;

                //Note that pEntry is a variable of type PSHIMENTRY

                if ( NULL != pEntry ) {
                    TAGID   tiShimName;

                    ZeroMemory(pEntry,sizeof(SHIMENTRY));

                    pEntry->Entry.uType = ENTRY_SHIM;
                    pEntry->Entry.pNext = NULL;

                    tiShimName = SdbFindFirstTag(pDB,Info,TAG_NAME);

                    pEntry->szShimName = ReadDBString(tiShimName,pDB);

                    tiShimName = SdbFindFirstTag(pDB,Info,TAG_COMMAND_LINE);

                    if ( 0 != tiShimName )
                        pEntry->szCmdLine = ReadDBString(tiShimName,pDB);

                    if ( NULL != pLast )
                        pLast->pNext = (PDBENTRY) pEntry;
                    else
                        pRecord->pEntries = (PDBENTRY) pEntry;

                    // Look up the specific shim this entry is associated with.

                    PSHIMDESC pWalk = g_theApp.GetDBGlobal().m_pShimList;

                    while ( NULL != pWalk ) {
                        // == is  overloaded in the CSTRING class

                        if ( pEntry->szShimName == pWalk->szShimName ) {
                            pEntry->pDesc = pWalk;
                            break;
                        }

                        pWalk = pWalk->pNext;
                    }

                    pLast = (PDBENTRY) pEntry;
                }
            }
            break;

        case    TAG_APPHELP:
            {
                PHELPENTRY  pHelp = new HELPENTRY;

                if ( NULL != pHelp ) {
                    TAGID   tTemp;

                    pHelp->Entry.uType = ENTRY_APPHELP;
                    pHelp->Entry.pNext = NULL;

                    tTemp = SdbFindFirstTag(pDB, Info, TAG_PROBLEMSEVERITY);
                    pHelp->uSeverity = SdbReadDWORDTag(pDB, tTemp, 0);

                    tTemp = SdbFindFirstTag(pDB, Info, TAG_HTMLHELPID);
                    pHelp->uHelpID = SdbReadDWORDTag(pDB, tTemp, 0);

                    if ( NULL != pLast )
                        pLast->pNext = (PDBENTRY) pHelp;
                    else
                        pRecord->pEntries = (PDBENTRY) pHelp;

                    pLast = (PDBENTRY) pHelp;
                }

                pRecord->uLayer = LAYER_APPHELP;
            }
            break;

        case    TAG_EXE_ID:
            {
                LPGUID pGUID = (GUID*)SdbGetBinaryTagData(pDB, Info);

                if ( NULL != pGUID )
                    pRecord->guidID = *pGUID;
            }
            break;
        }

        Info = SdbGetNextChild(pDB,tagParent,Info);
    }


    pRecord->dwUserFlags = GetEntryFlags(HKEY_CURRENT_USER,pRecord->guidID);
    pRecord->dwGlobalFlags = GetEntryFlags(HKEY_LOCAL_MACHINE,pRecord->guidID);

    return TRUE;
}

CSTRING STDCALL CDatabase::ReadDBString(TAGID tagID, PDB pDB)
{
    CSTRING Str;
    WCHAR   szAppName[1024];

    if ( NULL == pDB )
        pDB = CDatabase::m_pDB;

    ZeroMemory(szAppName,sizeof(szAppName));

    if ( !SdbReadStringTag(pDB,tagID,szAppName,sizeof(szAppName)/sizeof(WCHAR)) )
        return Str;

#ifndef UNICODE
#define  SIZE 1024
    TCHAR   szString[SIZE];

    *szString = TEXT('\0');

    WideCharToMultiByte(CP_ACP,WC_COMPOSITECHECK,szAppName, -1, szString, SIZE, NULL, NULL);

    Str = szString;
#else

    Str = szAppName;

#endif

    return Str;
}

BOOL
CDatabase::AddAppHelp(
    TAGID tiAppHelp
    )
{
    TAGID tiInfo;

    PAPPHELP pAppHelp = new APPHELP;

    if (pAppHelp == NULL) {
        MEM_ERR;
        goto error;
    }

    tiInfo = SdbGetFirstChild(m_pDB,tiAppHelp);

    while ( 0 != tiInfo ) {
        TAG tag;

        tag = SdbGetTagFromTagID(m_pDB,tiInfo);

        switch ( tag ) {
        case TAG_HTMLHELPID:
            pAppHelp->HTMLHELPID =  SdbReadDWORDTag(m_pDB, tiInfo, 0);

            if (pAppHelp->HTMLHELPID > g_nMAXHELPID ){

                g_nMAXHELPID = pAppHelp->HTMLHELPID;

            }

            break;

        case TAG_LINK:
            {
                TAGID tagLink  =  SdbFindFirstTag(m_pDB, tiAppHelp,TAG_LINK);

                if (tagLink) {
                    tagLink = SdbFindFirstTag(m_pDB, tagLink, TAG_LINK_URL);
                    pAppHelp->strURL = ReadDBString(tagLink, m_pDB);
                }
                   
            }
            break;
        case TAG_APPHELP_DETAILS:
            {
                pAppHelp->strMessage = ReadDBString(tiInfo, m_pDB);
            }
            break;
        }

        tiInfo = SdbGetNextChild(m_pDB, tiAppHelp, tiInfo);

    }//while

    //
    // Now add this to the database apphelp list
    //

    pAppHelp->pNext  = m_pAppHelp;
    m_pAppHelp       = pAppHelp;
    

    //
    // TODO: Cleanup this as well at end (when opening a new database)
    //
    return TRUE;

error:
    if (pAppHelp) {
        delete pAppHelp;
    }

    return FALSE;
         
}

void
CDatabase::ReadAppHelp(
    void
    )
{

    TAGID   tiInfo;

    // Read just the AppHelp

    tiInfo = SdbFindFirstTag(m_pDB, TAGID_ROOT, TAG_DATABASE);

    if ( 0 != tiInfo ) {

        TAGID tiAppHelp = SdbFindFirstTag(m_pDB, tiInfo, TAG_APPHELP);

        while (tiAppHelp) {
            AddAppHelp(tiAppHelp);
            tiAppHelp = SdbFindNextTag(m_pDB, tiInfo, tiAppHelp);
        }
        
    }

}



void CDatabase::ReadShims(BOOL bPermanent)
/*
 This function reads the shims,layers and patches (but not flags) from the database.
 After this funciton returns we will have proper values in the 
 1. m_pShimList
 2. m_pLayerList
*/

{
    TAGID   tShim;

    // Read just the shims

    tShim = SdbFindFirstTag(m_pDB, TAGID_ROOT, TAG_DATABASE);

    if ( 0 != tShim ) {
        TAGID tLib = SdbFindFirstTag(m_pDB, tShim, TAG_LIBRARY);
        TAGID tEntry;

        // Read the shims

        tEntry = SdbFindFirstTag(m_pDB, tLib, TAG_SHIM);

        while ( 0 != tEntry ) {
            AddShim(tEntry,TRUE, bPermanent,FALSE);

            tEntry = SdbFindNextTag(m_pDB, tLib, tEntry);
        }

        // Read the patches

        tEntry = SdbFindFirstTag(m_pDB, tLib, TAG_PATCH);

        while ( 0 != tEntry ) {
            AddShim(tEntry,FALSE,bPermanent,FALSE);

            tEntry = SdbFindNextTag(m_pDB, tLib, tEntry);
        }

        // Read Layers

        tEntry = SdbFindFirstTag(m_pDB, tShim, TAG_LAYER);

        while ( 0 != tEntry ) {

            PDBLAYER    pLayer = new DBLAYER;

            if ( NULL != pLayer ) {
                TAGID   tShims;
                TAGID   tName;

                ZeroMemory(pLayer,sizeof(DBLAYER));

                pLayer->bPermanent = bPermanent;

                tName = SdbFindFirstTag(m_pDB, tEntry, TAG_NAME);

                if ( 0 != tName )
                    pLayer->szLayerName = ReadDBString(tName);

                pLayer->pNext = m_pLayerList;//add this layer to the list of layers for this database
                m_pLayerList = pLayer;

                tShims = SdbFindFirstTag(m_pDB, tEntry, TAG_SHIM_REF);



                while ( 0 != tShims ) {
                    AddShim(tShims,FALSE,bPermanent,TRUE);

                    tShims = SdbFindNextTag(m_pDB, tEntry, tShims);
                }
            }

            tEntry = SdbFindNextTag(m_pDB, tShim, tEntry);
        }
    }
}

/*
BOOL CDatabase::ReadShim(TAGID tShim, PSHIMDESC pDesc)
{
    TAGID       tInfo;
    TAG         tLabel;

    tInfo = SdbGetFirstChild(m_pDB,tShim);

    if ( 0 == tShim )
        return FALSE;

    while ( 0 != tInfo ) {
        tLabel = SdbGetTagFromTagID(m_pDB, tInfo);

        switch ( tLabel ) {
        case    TAG_GENERAL:
            pDesc->bGeneral = TRUE;
            break;

        case    TAG_NAME:
            pDesc->szShimName = ReadDBString(tInfo);
            break;

        case    TAG_COMMAND_LINE:
            pDesc->szShimCommandLine = ReadDBString(tInfo);
            break;

        case    TAG_DLLFILE:
            pDesc->szShimDLLName = ReadDBString(tInfo);
            break;

        case    TAG_DESCRIPTION:
            pDesc->szShimDesc = ReadDBString(tInfo);
            break;
        }

        tInfo = SdbGetNextChild(m_pDB, tShim, tInfo);
    }

    return TRUE;
}

*/
void CDatabase::AddShim(TAGID tShim, BOOL bShim, BOOL bPermanent, BOOL bLayer)
{
    TAGID       tInfo;
    TAG         tLabel;
    PSHIMDESC   pDesc = new SHIMDESC;

    if ( NULL == pDesc ){
        CMemException cmem;
        throw cmem;
        return;
    }
        

    ZeroMemory(pDesc,sizeof(SHIMDESC));

    pDesc->bShim = bShim;
    //pDesc->bPermanent = bPermanent;



    pDesc->bGeneral = FALSE;

    tInfo = SdbGetFirstChild(m_pDB,tShim);

    while ( 0 != tInfo ) {
        tLabel = SdbGetTagFromTagID(m_pDB, tInfo);



        switch ( tLabel ) {
        case    TAG_GENERAL:
            pDesc->bGeneral = TRUE;
            break;
        case    TAG_NAME:
            pDesc->szShimName = ReadDBString(tInfo);
            break;
        case    TAG_COMMAND_LINE:
            pDesc->szShimCommandLine = ReadDBString(tInfo);
            break;

        case    TAG_DLLFILE:
            pDesc->szShimDLLName = ReadDBString(tInfo);
            break;
        case    TAG_DESCRIPTION:
            pDesc->szShimDesc = ReadDBString(tInfo);
            break;
        }

        tInfo = SdbGetNextChild(m_pDB, tShim, tInfo);
    }

    if ( !bLayer ) { //This is just a shim,

                //
                //Add in a a sorted manner
                //    
                
               if ( (m_pShimList == NULL) || pDesc->szShimName < m_pShimList->szShimName ) {

                   //
                   //Add at the beginning
                   //

                   pDesc->pNext = m_pShimList;
                   m_pShimList  = pDesc;

               }
               else{

                   //
                   // Add into the LL.
                   //

                   PSHIMDESC   pPrev   = m_pShimList;
                   PSHIMDESC   pTemp   = m_pShimList->pNext;
                   while (pTemp) {
                       if (pDesc->szShimName <= pTemp->szShimName && pDesc->szShimName > pPrev->szShimName) {

                           //
                           //This is the position to insert
                           //
                        break;
                       }
                       else{

                           pPrev = pTemp;
                           pTemp = pTemp->pNext;
                       }
                   }//while(pTemp)

                   pDesc->pNext = pTemp;
                   pPrev->pNext = pDesc;
               }


                                

    } else{ //This is a SHIM REF for a layer
        /*........................................................................

        This is executed in the following scenario. We are actually adding the list of layers for the database.
        Now when we find SHIM REFS we want to add them to the particular layer.
        
        OK  Now this adds this shim  as the first entry of the m_pLayerList.Till now we have already added the new layer into 
        the Linked list headed by m_pLayerList
        
        The following Code has been executed in the ReadShims() function
        
        <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
        
           PDBLAYER pLayer = new DBLAYER;
           pLayer->pNext = m_pLayerList;//add this layer to the list of layers for this database
           m_pLayerList = pLayer;
         
        >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
        
        So the m_pLayerList now points to the new layer added, obviously the LL headed by  m_pLayerList is 
        NOT arranged lexi wise on the names of the layers. The shims in the the LL  m_pLayerList->pShimList are also 
        NOT arranged lexi wise on the names of the shims.
        
                
        
        ........................................................................*/

        pDesc->pNext = m_pLayerList->pShimList;
        m_pLayerList->pShimList = pDesc;
    }
}

BOOL CDatabase::SaveDatabase(CSTRING & szFilename)
{
    CSTRINGList   * pXML = DisassembleRecord(m_pRecordHead,TRUE,TRUE,TRUE,TRUE,FALSE, FALSE);
    BOOL            bResult;
    CSTRING         szTempFilename;
    TCHAR           szPath[MAX_PATH_BUFFSIZE];

    if ( NULL == pXML )
        return FALSE;

    
    GetSystemWindowsDirectory(szPath, MAX_PATH);
    lstrcat(szPath,TEXT("\\AppPatch\\Temp.XML"));

    szTempFilename = szPath;

    bResult = WriteXML(szTempFilename,pXML);

    if ( pXML != NULL ) {

        delete pXML;
    }


    if ( !bResult ) {
        MessageBox(g_theApp.m_hWnd,TEXT("Unable to save temporary file."),TEXT("File save error"),MB_OK);
        return FALSE;
    }

    CSTRING szCommandLine;

    szCommandLine.sprintf(TEXT("custom \"%s\" \"%s\""),
                          (LPCTSTR)szTempFilename,
                          (LPCTSTR)szFilename);

    if ( !InvokeCompiler(szCommandLine) ) {
        
        DeleteFile(szTempFilename);
        return FALSE;
    }

    DeleteFile(szTempFilename);

    m_szCurrentDatabase = szFilename;

    m_bDirty = FALSE;

    g_theApp.UpdateView(TRUE);

    return TRUE;
}

void CDatabase::ResolveMatch(CSTRING & szStr, PMATCHENTRY pMatch)
{
    if ( 0 != pMatch->dwSize ) {
        CSTRING szTemp;

        szTemp.sprintf(TEXT(" SIZE=\"%d\""),pMatch->dwSize);
        szStr.strcat(szTemp);
    }

    if ( 0 != pMatch->dwChecksum ) {
        CSTRING szTemp;

        szTemp.sprintf(TEXT(" CHECKSUM=\"0x%08X\""),pMatch->dwChecksum);
        szStr.strcat(szTemp);
    }

    if ( pMatch->szCompanyName.Length() > 0 ) {
        CSTRING szTemp;

        szTemp.sprintf(TEXT(" COMPANY_NAME=\"%s\""),(LPCTSTR) pMatch->szCompanyName);
        szStr.strcat(szTemp);
    }

    if ( pMatch->szDescription.Length() > 0 ) {
        CSTRING szTemp;

        szTemp.sprintf(TEXT(" FILE_DESCRIPTION=\"%s\""),(LPCTSTR) pMatch->szDescription);
        szStr.strcat(szTemp);
    }

    if ( pMatch->szFileVersion.Length() > 0 ) {
        CSTRING szTemp;

        szTemp.sprintf(TEXT(" FILE_VERSION=\"%s\""),(LPCTSTR) pMatch->szFileVersion);
        szStr.strcat(szTemp);
    }

    if ( pMatch->szProductVersion.Length() > 0 ) {
        CSTRING szTemp;

        szTemp.sprintf(TEXT(" PRODUCT_VERSION=\"%s\""),(LPCTSTR) pMatch->szProductVersion);
        szStr.strcat(szTemp);
    }

    if ( 0 != pMatch->ProductVersion.QuadPart ) {
        CSTRING szTemp;
        TCHAR   szFormat[80];

        FormatVersion(pMatch->ProductVersion,szFormat);

        szTemp.sprintf(TEXT(" BIN_PRODUCT_VERSION=\"%s\""),szFormat);
        szStr.strcat(szTemp);
    }

    if ( 0 != pMatch->FileVersion.QuadPart ) {
        CSTRING szTemp;
        TCHAR   szFormat[80];

        FormatVersion(pMatch->FileVersion,szFormat);

        szTemp.sprintf(TEXT(" BIN_FILE_VERSION=\"%s\""),szFormat);
        szStr.strcat(szTemp);
    }
}

//
// BUGBUG -- there is code in sdbapi to do something like this
// concerning file attributes (in particular in grabmiapi.c
// perhaps we should use that stuff here to decode
//

CSTRINGList * CDatabase::DisassembleRecord(PDBRECORD pRecordIn, BOOL bChildren, BOOL bSiblings, BOOL bIncludeLocalLayers, BOOL bFullXML, BOOL bAllowGlobal, BOOL bTestRun)
{

    //
    //Create a new GUID for test run
    //

    CSTRINGList * pList = new CSTRINGList;

    if ( NULL == pList )
        return NULL;

    if ( bFullXML ) {
        CSTRING DB;
        CSTRING ID;

        pList->AddString(TEXT("<?xml version=\"1.0\" encoding=\"Windows-1252\"?>"));

        if ( 0 == m_DBGuid.Data1 )
            CoCreateGuid(&m_DBGuid);

        ID.GUID(m_DBGuid);

        if (bTestRun) {

            GUID testGuid;
            CoCreateGuid(&testGuid);
            ID.GUID(testGuid);
        }

        DB.sprintf(TEXT("<DATABASE NAME=\"%s\" ID=\"%s\">"),(LPCTSTR)m_DBName,(LPCTSTR)ID);

        pList->AddString(DB);
    }

    if ( bIncludeLocalLayers || g_theApp.GetDBLocal().m_pAppHelp != NULL ) {
        PDBLAYER    pWalk = g_theApp.GetDBLocal().m_pLayerList;
        BOOL        bLocalLayerToAdd = FALSE;

        while ( NULL != pWalk ) {
            if ( !pWalk->bPermanent )
                bLocalLayerToAdd = TRUE;

            pWalk = pWalk->pNext;
        }

        if ( bLocalLayerToAdd || g_theApp.GetDBLocal().m_pAppHelp != NULL) {
            CSTRING szTemp;
            

            szTemp.sprintf(TEXT("<LIBRARY>"));
            pList->AddString(szTemp,(PVOID)1);


            pWalk = g_theApp.GetDBLocal().m_pLayerList;

            while ( NULL != pWalk ) {
                if ( !pWalk->bPermanent ) {
                    PSHIMDESC pShims = pWalk->pShimList;

                    szTemp.sprintf(TEXT("<LAYER NAME=\"%s\">"),(LPCTSTR)(pWalk->szLayerName));
                    pList->AddString(szTemp,(PVOID)2);


                    while ( NULL != pShims ) {
                        szTemp.sprintf(TEXT("<SHIM NAME=\"%s\"/>"),(LPCTSTR)(pShims->szShimName));

                        pList->AddString(szTemp,(PVOID)3);
                        pShims = pShims->pNext;
                    }

                    pList->AddString(TEXT("</LAYER>"),(PVOID)2);
                }

                pWalk = pWalk->pNext;
            }


            //
            // Add the AppHelp  Messages
            //

            PAPPHELP pAppHelp = g_theApp.GetDBLocal().m_pAppHelp;

            while (pAppHelp) {

                // TODO: When we get the proper message names, after the change to shimdbc, INLCUDE that one

                CSTRING strName;

                strName.sprintf(TEXT("%u"), pAppHelp->HTMLHELPID);
                szTemp.sprintf(TEXT("<MESSAGE NAME = \"%s\" >"), strName.pszString);
                pList->AddString(szTemp,(PVOID)2);

                pList->AddString(TEXT("<SUMMARY>"),(PVOID)3);

                pList->AddString(pAppHelp->strMessage, (PVOID)4);

                pList->AddString(TEXT("</SUMMARY>"),(PVOID)3);

                pList->AddString(TEXT("</MESSAGE>"),(PVOID)2);

                pAppHelp = pAppHelp->pNext;

            }

            // AppHelp Added to Library


            pList->AddString(TEXT("</LIBRARY>"),(PVOID)1);
        }
    }

    while ( NULL != pRecordIn ) {
        PDBRECORD pRecord = pRecordIn;

        while ( NULL != pRecord ) {
            if ( bAllowGlobal || !pRecord->bGlobal ) {
                CSTRING     szTemp;
                PDBENTRY    pEntry = pRecord->pEntries;

                szTemp.sprintf(TEXT("<APP NAME=\"%s\" VENDOR=\"Unknown\">"),(LPCTSTR)(pRecord->szAppName));

                pList->AddString(szTemp,(PVOID)1);

                if ( 0 == pRecord->guidID.Data1 )
                    szTemp.sprintf(TEXT("<EXE NAME=\"%s\""),(LPCTSTR)pRecord->szEXEName);
                else {
                    CSTRING szGUID;

                    szGUID.GUID(pRecord->guidID);

                    szTemp.sprintf(TEXT("<EXE NAME=\"%s\" ID=\"%s\""),(LPCTSTR)pRecord->szEXEName,(LPCTSTR)szGUID);
                }

                while ( NULL != pEntry ) {
                    if ( ENTRY_MATCH == pEntry->uType ) {
                        PMATCHENTRY pMatch = (PMATCHENTRY) pEntry;

                        if ( pMatch->szMatchName == TEXT("*") )
                            ResolveMatch(szTemp,pMatch);
                    }

                    pEntry = pEntry->pNext;
                }

                szTemp.strcat(TEXT(">"));

                pList->AddString(szTemp,(PVOID) 2);

                // Add matching information

                pEntry = pRecord->pEntries;

                while ( NULL != pEntry ) {
                    if ( ENTRY_MATCH == pEntry->uType ) {
                        PMATCHENTRY pMatch = (PMATCHENTRY) pEntry;

                        if ( pMatch->szMatchName != TEXT("*") ) {
                            szTemp.sprintf(TEXT("<MATCHING_FILE NAME=\"%s\""),(LPCTSTR)pMatch->szMatchName);
                            ResolveMatch(szTemp,pMatch);
                            szTemp.strcat(TEXT("/>"));

                            pList->AddString(szTemp,(PVOID) 3);
                        }
                    }

                    pEntry = pEntry->pNext;
                }

                // Add Layer information

                BOOL bLayerFound = FALSE; //There are layers for this thing

                if ( pRecord->szLayerName.Length() > 0 ) {
                    szTemp.sprintf(TEXT("<LAYER NAME=\"%s\">"),(LPCTSTR)pRecord->szLayerName);
                    pList->AddString(szTemp,(PVOID)3);
                    pList->AddString(TEXT("</LAYER>"),(PVOID)3);

                    bLayerFound = TRUE;

                }

                

                if (g_bWin2K && bLayerFound) {

                        szTemp = TEXT("<SHIM NAME= \"Win2kPropagateLayer\"/>");
                        pList->AddString(szTemp,(PVOID)3);

                    }
                
                
                // Add shim information

                pEntry = pRecord->pEntries;


                


                while ( NULL != pEntry ) {
                    if ( ENTRY_SHIM == pEntry->uType ) {
                        PSHIMENTRY pShim = (PSHIMENTRY) pEntry;

                        if ( 0 == pShim->szCmdLine.Length() )
                            szTemp.sprintf(TEXT("<SHIM NAME=\"%s\"/>"),(LPCTSTR)pShim->szShimName);
                        else
                            szTemp.sprintf(TEXT("<SHIM NAME=\"%s\" COMMAND_LINE=\"%s\"/>"),(LPCTSTR)pShim->szShimName,(LPCTSTR)pShim->szCmdLine);

                        pList->AddString(szTemp,(PVOID) 3);
                    }

                    pEntry = pEntry->pNext;
                }

                //
                //Do the AppHelp Part
                //

                
                pEntry = pRecord->pEntries;

                while ( NULL != pEntry ) {
                    if ( ENTRY_APPHELP == pEntry->uType ) {

                        PHELPENTRY pHelp = (PHELPENTRY)pEntry;

                        CSTRING strBlock;

                        if (pHelp->bBlock) {
                            strBlock = TEXT("YES");
                        }else{
                            strBlock = TEXT("NO");
                        }

                        CSTRING strName;
                        strName.sprintf(TEXT("%u"), pHelp->uHelpID);

                        CSTRING strHelpID;
                        strHelpID.sprintf(TEXT("%u"), pHelp->uHelpID);
                        
                        
                        if (pHelp->strURL.Length()) {
                        
                        szTemp.sprintf(TEXT("<APPHELP MESSAGE = \"%s\"  BLOCK = \"%s\"  HTMLHELPID = \"%s\" DETAILS_URL = \"%s\" />"),
                                       strName.pszString, 
                                       strBlock.pszString,
                                       strHelpID.pszString,
                                       pHelp->strURL.pszString);
                        }else{

                            szTemp.sprintf(TEXT("<APPHELP MESSAGE = \"%s\"  BLOCK = \"%s\"  HTMLHELPID = \"%s\" />"),
                                       strName.pszString, 
                                       strBlock.pszString,
                                       strHelpID.pszString);
                        }



                        pList->AddString(szTemp,(PVOID) 3);

                        

                    }

                    pEntry = pEntry->pNext;
                }
                
                // End of AppHelp Part



                pList->AddString(TEXT("</EXE>"),(PVOID) 2);

                pList->AddString(TEXT("</APP>"),(PVOID) 1);
            }

            if ( !bChildren )
                break;

            pRecord = pRecord->pDup;
        }

        if ( !bSiblings )
            break;

        pRecordIn = pRecordIn->pNext;
    }

    if ( bFullXML )
        pList->AddString(TEXT("</DATABASE>"));

    return pList;
}

BOOL CDatabase::WriteString(HANDLE hFile, CSTRING & szString, BOOL bAutoCR)
{
    DWORD dwBytesWritten;
    

    if ( !WriteFile(hFile, (LPCSTR)szString, szString.Length() ,&dwBytesWritten,NULL) )
        return FALSE;

    if ( bAutoCR ) {
        CHAR szCR[]={13,10};

        if ( !WriteFile(hFile,szCR,sizeof(szCR) ,&dwBytesWritten,NULL) )
            return FALSE;
    }

    return TRUE;
}

BOOL CDatabase::WriteXML(CSTRING & szFilename, CSTRINGList * pString)
{
    HANDLE        hFile;
    
    if ( NULL == pString )
        return FALSE;

    hFile = CreateFile(szFilename,GENERIC_WRITE,0,NULL,CREATE_ALWAYS,FILE_ATTRIBUTE_NORMAL,NULL);

    if ( INVALID_HANDLE_VALUE == hFile ) {
        return FALSE;
    }

    PSTRLIST pWalk = pString->m_pHead;
    CSTRING  szTemp;

    while ( NULL != pWalk ) {
        UINT uTabs = pWalk->uExtraData;

        while ( uTabs > 0 ) {
            szTemp = TEXT("    ");
            WriteString(hFile,szTemp,FALSE);
            

            --uTabs;
        }

        WriteString(hFile,pWalk->szStr,TRUE);
        
        pWalk = pWalk->pNext;
    }

    CloseHandle(hFile);

    return TRUE;
}

BOOL CDatabase::InvokeCompiler(CSTRING & szInCommandLine)
{

    
    CSTRING szCommandLine = szInCommandLine;
    szCommandLine.sprintf(TEXT("shimdbc.exe %s"), (LPCTSTR) szInCommandLine);
    BOOL bReturn = TRUE;
    
    
    

    g_theApp.SetStatusText(
        1,
        CSTRING(TEXT("Creating fix database..."))
        );

    if (!ShimdbcExecute( szCommandLine ) ) {
        MessageBox(NULL,TEXT("There was a problem in executing the compiler. The database could not be created succesfully\nThe database file might be write-protected."), TEXT("Compiler Error"),MB_ICONERROR);
        bReturn = FALSE;
    }

    g_theApp.SetStatusText(
        1,
        CSTRING(TEXT(""))
        );


    
    return bReturn;
}

DWORD CDatabase::GetEntryFlags(HKEY hKeyRoot, GUID & Guid)
{
    LONG    status;
    HKEY    hkey = NULL;
    DWORD   dwFlags;
    DWORD   type;
    DWORD   cbSize = sizeof(DWORD);
    CSTRING szGUID;

    szGUID.GUID(Guid);

    status = RegOpenKey(hKeyRoot, APPCOMPAT_KEY, &hkey);

    if ( ERROR_SUCCESS != status ) {
        status = RegCreateKey(hKeyRoot,APPCOMPAT_KEY,&hkey);

        if ( ERROR_SUCCESS != status )
            return 0;
    }

    status = RegQueryValueEx(hkey, szGUID, NULL, &type, (LPBYTE)&dwFlags, &cbSize);

    if ( ERROR_SUCCESS != status || REG_DWORD != type )
        dwFlags = 0;

    RegCloseKey(hkey);

    return dwFlags;
}

BOOL CDatabase::SetEntryFlags(HKEY hKeyRoot, GUID & Guid, DWORD dwFlags)
{
    LONG    status;
    HKEY    hkey = NULL;
    CSTRING szGUID;

    szGUID.GUID(Guid);

    status = RegOpenKey(hKeyRoot, APPCOMPAT_KEY, &hkey);

    if ( ERROR_SUCCESS != status ) {
        status = RegCreateKey(hKeyRoot,APPCOMPAT_KEY,&hkey);

        if ( ERROR_SUCCESS != status )
            return 0;
    }

    status = RegSetValueEx(hkey, szGUID, 0, REG_DWORD, (LPBYTE) &dwFlags, sizeof(DWORD));

    RegCloseKey(hkey);

    return( (ERROR_SUCCESS == status) ? TRUE:FALSE );
}

BOOL CALLBACK NewDatabaseProc(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    switch ( uMsg ) {
    case    WM_INITDIALOG:
        {
            
            SendMessage( 
                GetDlgItem(hWnd,IDC_NAME),              // handle to destination window 
                EM_LIMITTEXT,             // message to send
                (WPARAM) LIMIT_APP_NAME,          // text length
                (LPARAM) 0
                );

            
            
            if ( g_bNew )
                SetWindowText(hWnd,TEXT("New database"));

            SetWindowText(GetDlgItem(hWnd,IDC_NAME),(LPCTSTR)g_szDBName);
            SetFocus(GetDlgItem(hWnd,IDC_NAME));
            SendMessage(GetDlgItem(hWnd,IDC_NAME),EM_SETSEL,0,-1);

            SHAutoComplete(GetDlgItem(hWnd,IDC_NAME), AUTOCOMPLETE);
        }
        return TRUE;

    case    WM_COMMAND:
        switch ( LOWORD(wParam) ) {
        case    IDC_NAME:
            {
                if ( EN_UPDATE == HIWORD(wParam) ) {
                    TCHAR   szText[MAX_PATH_BUFFSIZE];
                    GetWindowText(GetDlgItem(hWnd,IDC_NAME),szText,MAX_PATH);
                    
                    EnableWindow(GetDlgItem(hWnd,IDOK),(CSTRING::Trim(szText) == 0) ? FALSE:TRUE);
                }
            }
            break;

        case    IDOK:
            {
                TCHAR   szText[MAX_PATH_BUFFSIZE];

                GetWindowText(GetDlgItem(hWnd,IDC_NAME),szText,MAX_PATH);

                CSTRING::Trim(szText);

                g_szDBName = szText;

                EndDialog(hWnd,TRUE);
            }
            break;
        case    IDCANCEL:
            EndDialog(hWnd,FALSE);
            break;
        }
    }

    return FALSE;
}

BOOL CDatabase::CleanUp()
{
    TCHAR  szShimDB[MAX_PATH_BUFFSIZE] = _T("");

    GetSystemWindowsDirectory(szShimDB, MAX_PATH);
    lstrcat(szShimDB, _T("\\AppPatch"));
    lstrcat(szShimDB, TEXT("\\test.sdb"));


    InstallDatabase(szShimDB, TEXT("-q -u"));

    DeleteFile(szShimDB);
    
    return TRUE;

}

int CheckMatch
(   IN PDBENTRY pExistEntry,
    IN PDBENTRY pNewEntry
)

{

    PMATCHENTRY pMatchExist = NULL, pMatchNew = NULL;
    
    //
    //Populate the list of existing match entries
    //

    while (pExistEntry) {
        if (pExistEntry->uType == ENTRY_MATCH) {

            PMATCHENTRY pMatchTemp = new MATCHENTRY;
            *pMatchTemp = *(PMATCHENTRY)pExistEntry;

            if (pMatchExist == NULL) {

                pMatchExist                 = pMatchTemp;
                pMatchExist->Entry.pNext    = NULL;
                pExistEntry = pExistEntry->pNext;
                continue;
                
            }

            pMatchTemp->Entry.pNext = (PDBENTRY)pMatchExist;
            pMatchExist             = (PMATCHENTRY)pMatchTemp;
        
        }

        pExistEntry = pExistEntry->pNext;

    }//while (pExistEntry)

    //
    //Populate the match entries for the new record
    //


    

    while (pNewEntry) {
        if (pNewEntry->uType == ENTRY_MATCH) {

            PMATCHENTRY pMatchTemp = new MATCHENTRY;
            PMATCHENTRY match = (PMATCHENTRY)pNewEntry;
            
            *pMatchTemp = *match;


            if (pMatchNew == NULL) {

                pMatchNew                 = pMatchTemp;
                pMatchNew->Entry.pNext    = NULL;

                pNewEntry = pNewEntry->pNext;
                continue;
                
            }


            pMatchTemp->Entry.pNext = (PDBENTRY)pMatchNew;
            pMatchNew               = (PMATCHENTRY)pMatchTemp;

        
        }

        pNewEntry = pNewEntry->pNext;

    }//while (pENewEntry)

    //
    //Now check if each and every entry of the pMatchNew is in the existing match list
    //


    PMATCHENTRY tempNew, tempExist;

    tempNew     = pMatchNew;

    
   
    BOOL found;
    while (tempNew) {

        tempExist   = pMatchExist;
        found = FALSE;

        while (tempExist) {

            
            if (*tempExist == *tempNew) {
                found = TRUE;
            
                break;
            }
            else{
            
                tempExist = (PMATCHENTRY)tempExist->Entry.pNext;
            }
            
            
        }
        if ( found == FALSE) 
            break;

        tempNew = (PMATCHENTRY)tempNew->Entry.pNext;
    }


    //
    //Do the clean-up
    //

     

     while(pMatchExist){
         tempExist = pMatchExist;
         pMatchExist = (PMATCHENTRY)pMatchExist->Entry.pNext;
         delete tempExist;
     }

     while(pMatchNew){
         tempExist      = pMatchNew;
         pMatchNew    = (PMATCHENTRY)pMatchNew->Entry.pNext;
         delete tempExist;
     }

     return ( (tempNew ==  NULL) || found);

}


bool
InstallDatabase(
    TCHAR *szPath,
    TCHAR *szOptions
    )
{
    TCHAR szSystemDir[MAX_PATH];

    *szSystemDir = 0;

    GetWindowsDirectory(szSystemDir,MAX_PATH);
    
    CSTRING strSdbInstCommandLine;

    strSdbInstCommandLine.sprintf(TEXT("%s\\System32\\sdbInst.exe %s \"%s\" "),
                                  szSystemDir,
                                  szOptions,
                                  szPath
                                 );

    if ( !g_theApp.InvokeEXE(NULL,strSdbInstCommandLine.pszString,true,false,false) ) {
            MessageBox(g_theApp.m_hWnd,
                       TEXT("There was a problem In executing the data base installer."),
                       TEXT("CompatAdmin"),
                       MB_ICONERROR
                       );    
            return false;

    }

    return true;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\appcompat\tools\compatadmin\compatadmin.cpp ===
// CompatAdmin.cpp : Defines the entry point for the application.
//

#include "compatadmin.h"
BOOL g_DEBUG = FALSE;

HINSTANCE       g_hInstance;
CApplication    g_theApp;


int APIENTRY WinMain(HINSTANCE hInstance,
                     HINSTANCE hPrevInstance,
                     LPSTR     lpCmdLine,
                     int       nCmdShow)
{
    g_hInstance = hInstance;


    ;



    //This is the main window. Note that this is not a child window !

    if ( !g_theApp.Create(TEXT("AMCClass"),
                          TEXT("Application Management Console"),
                          0,0,
                          640,480,
                          NULL,
                          0,
                          WS_EX_CLIENTEDGE,
                          WS_OVERLAPPEDWINDOW | WS_VISIBLE | WS_CLIPCHILDREN) ) {
        return -1;
    }

    return g_theApp.MessagePump();
    
    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\appcompat\tools\compatadmin\capplication.cpp ===
//#define __DEBUG 1

#include "compatadmin.h"
#include "dbviewer.h"
#include "dbsearch.h"
#include "xmldialog.h"
#include "psapi.h"


BOOL g_bWin2K = FALSE;

void __cdecl Terminate_Handler()
{

    MessageBox(NULL,TEXT("Uncaught Exception raised!"),TEXT("Error"),MB_ICONERROR);
    WIN_MSG();
    abort();
}

 
/*....................................................................................*/
BOOL 
SearchGroupForSID(
                 DWORD dwGroup, 
                 BOOL* pfIsMember
                 )
{
    PSID                     pSID = NULL;
    SID_IDENTIFIER_AUTHORITY SIDAuth = SECURITY_NT_AUTHORITY;
    BOOL                     fRes = TRUE;

    if ( !AllocateAndInitializeSid(&SIDAuth,
                                   2,
                                   SECURITY_BUILTIN_DOMAIN_RID,
                                   dwGroup,
                                   0,
                                   0,
                                   0,
                                   0,
                                   0,
                                   0,
                                   &pSID) ) {

        fRes = FALSE;
    }

    if ( !CheckTokenMembership(NULL, pSID, pfIsMember) ) {

        fRes = FALSE;
    }

    if (pSID)
        FreeSid(pSID);

    return fRes;
}

BOOL 
IsAdmin(
       void
       )
{
    BOOL fIsUser, fIsAdmin;

    if ( !SearchGroupForSID(DOMAIN_ALIAS_RID_USERS, &fIsUser) || 
         !SearchGroupForSID(DOMAIN_ALIAS_RID_ADMINS, &fIsAdmin)  

         // || !SearchGroupForSID(DOMAIN_ALIAS_RID_POWER_USERS, &fIsPowerUser)
       ) {
        return FALSE;
    }

    return(fIsUser && fIsAdmin );
}


/*....................................................................................*/

CDatabase& CApplication::GetDBGlobal()
{
    return (this->m_DBGlobal);
}

CDatabase& CApplication::GetDBLocal()
{
    return (this->m_DBLocal);
}



//*****************************************************************************
//
// Global Variables
//
//*****************************************************************************

UINT    g_uDPFLevel        = DPF_LEVEL;
UINT    g_uProfileDPFLevel = DPF_LEVEL;
TESTRUN g_TestRun;
HANDLE  g_hTestRunExec;
CSTRING g_szTestFile;

BOOL CALLBACK SplashProc(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam);

//*****************************************************************************
//  Class:      CApplication
//
//  Function:   Constructor
//
//  Notes:      None
//
//  History:
//
//      A-COWEN         Nov 8, 2000         Implemented it.
//*****************************************************************************

CApplication::CApplication()
{


    

    if ( !IsAdmin() ) {// Admin rights

        MessageBox(NULL,TEXT("You need administrative rights to run this program. Please contact your system administrator"),TEXT("CompatAdmin"),MB_ICONERROR);
#ifndef __DEBUG
        ExitThread(1);
#endif

    }


    
    //
    //Check if the OS is Win2k
    //

    OSVERSIONINFO osvi;

    osvi.dwOSVersionInfoSize = sizeof(OSVERSIONINFO);

    GetVersionEx (&osvi);

    if ((osvi.dwMajorVersion == 5) && (osvi.dwMinorVersion == 0)) {
      g_bWin2K = TRUE;
    }




    set_terminate(Terminate_Handler);

    CDatabase::CleanUp();

    
    g_uButtons = 0;
    m_hDialog = NULL;
    m_hAccelerator = NULL;
    m_hKey = NULL;
    m_pCurrentView = NULL;
    m_hMenu = NULL;

    /*   Moved to CDatabase::CDatabase
    m_pDB = NULL;
    m_pRecordHead = NULL;
    m_pShimList = NULL;
    m_pLayerList = NULL;
    */

    m_MainButtons[g_uButtons].iBitmap = 0;
    m_MainButtons[g_uButtons].idCommand = ID_FILE_NEWDATABASE;
    m_MainButtons[g_uButtons].fsState = TBSTATE_ENABLED;
    m_MainButtons[g_uButtons].fsStyle = TBSTYLE_BUTTON;
    m_MainButtons[g_uButtons].dwData = 0;
    m_MainButtons[g_uButtons].iString = 0;

    ++g_uButtons;

    m_MainButtons[g_uButtons].iBitmap = 1;
    m_MainButtons[g_uButtons].idCommand = ID_FILE_OPENDATABASE;
    m_MainButtons[g_uButtons].fsState = TBSTATE_ENABLED;
    m_MainButtons[g_uButtons].fsStyle = TBSTYLE_BUTTON;
    m_MainButtons[g_uButtons].dwData = 0;
    m_MainButtons[g_uButtons].iString = 0;

    ++g_uButtons;

    m_MainButtons[g_uButtons].iBitmap = 2;
    m_MainButtons[g_uButtons].idCommand = ID_FILE_SAVEDATABASE;
    m_MainButtons[g_uButtons].fsState = TBSTATE_ENABLED;
    m_MainButtons[g_uButtons].fsStyle = TBSTYLE_BUTTON;
    m_MainButtons[g_uButtons].dwData = 0;
    m_MainButtons[g_uButtons].iString = 0;

    ++g_uButtons;
/*
    // Email

    m_MainButtons[g_uButtons].iBitmap = 3;
    m_MainButtons[g_uButtons].idCommand = 3;
    m_MainButtons[g_uButtons].fsState = TBSTATE_ENABLED;
    m_MainButtons[g_uButtons].fsStyle = TBSTYLE_BUTTON;
    m_MainButtons[g_uButtons].dwData = 0;
    m_MainButtons[g_uButtons].iString = 0;

    ++g_uButtons;

    // Print

    m_MainButtons[g_uButtons].iBitmap = 6;
    m_MainButtons[g_uButtons].idCommand = 0;
    m_MainButtons[g_uButtons].fsState = TBSTATE_ENABLED;
    m_MainButtons[g_uButtons].fsStyle = TBSTYLE_SEP;
    m_MainButtons[g_uButtons].dwData = 0;
    m_MainButtons[g_uButtons].iString = 0;

    ++g_uButtons;

    m_MainButtons[g_uButtons].iBitmap = 4;
    m_MainButtons[g_uButtons].idCommand = 4;
    m_MainButtons[g_uButtons].fsState = TBSTATE_ENABLED;
    m_MainButtons[g_uButtons].fsStyle = TBSTYLE_BUTTON;
    m_MainButtons[g_uButtons].dwData = 0;
    m_MainButtons[g_uButtons].iString = 0;

    ++g_uButtons;

    // Print preview

    m_MainButtons[g_uButtons].iBitmap = 5;
    m_MainButtons[g_uButtons].idCommand = 5;
    m_MainButtons[g_uButtons].fsState = TBSTATE_ENABLED;
    m_MainButtons[g_uButtons].fsStyle = TBSTYLE_BUTTON;
    m_MainButtons[g_uButtons].dwData = 0;
    m_MainButtons[g_uButtons].iString = 0;

    ++g_uButtons;
*/
    m_MainButtons[g_uButtons].iBitmap = 6;
    m_MainButtons[g_uButtons].idCommand = 0;
    m_MainButtons[g_uButtons].fsState = TBSTATE_ENABLED;
    m_MainButtons[g_uButtons].fsStyle = TBSTYLE_SEP;
    m_MainButtons[g_uButtons].dwData = 0;
    m_MainButtons[g_uButtons].iString = 0;

    ++g_uButtons;

    m_MainButtons[g_uButtons].iBitmap = 20;
    m_MainButtons[g_uButtons].idCommand = ID_WINDOWS_SEARCHFORFIXES;
    m_MainButtons[g_uButtons].fsState = TBSTATE_ENABLED;
    m_MainButtons[g_uButtons].fsStyle = TBSTYLE_BUTTON;
    m_MainButtons[g_uButtons].dwData = 0;
    m_MainButtons[g_uButtons].iString = 0;

    ++g_uButtons;

    m_MainButtons[g_uButtons].iBitmap = 14;
    m_MainButtons[g_uButtons].idCommand = ID_WINDOWS_DATABASEVIEWER;
    m_MainButtons[g_uButtons].fsState = TBSTATE_ENABLED;
    m_MainButtons[g_uButtons].fsStyle = TBSTYLE_BUTTON;
    m_MainButtons[g_uButtons].dwData = 0;
    m_MainButtons[g_uButtons].iString = 0;

    ++g_uButtons;

    m_MainButtons[g_uButtons].iBitmap = 6;
    m_MainButtons[g_uButtons].idCommand = 0;
    m_MainButtons[g_uButtons].fsState = TBSTATE_ENABLED;
    m_MainButtons[g_uButtons].fsStyle = TBSTYLE_SEP;
    m_MainButtons[g_uButtons].dwData = 0;
    m_MainButtons[g_uButtons].iString = 0;

    ++g_uButtons;
}

//*****************************************************************************
//  Class:      CApplication
//
//  Function:   msgCreate
//
//  Notes:      Perform application initialization.
//
//  History:
//
//      A-COWEN         Nov 8, 2000         Initial Implementation: Center
//                                          window and open registry.
//*****************************************************************************

void CApplication::msgCreate(void)
{
    RECT    rRect;
    int     nX;
    int     nY;

    m_hAccelerator = LoadAccelerators(g_hInstance,MAKEINTRESOURCE(IDR_ACCELERATOR1) );

    m_hMenu = LoadMenu(g_hInstance, MAKEINTRESOURCE(IDR_MAINMENU));

    m_hToolBitmap = LoadBitmap(g_hInstance,MAKEINTRESOURCE(IDR_MAINTOOLBAR));

    SetMenu(m_hWnd,m_hMenu);

    WINDOWPLACEMENT Place;

    Place.length = sizeof(WINDOWPLACEMENT);
    Place.flags = 0;
    Place.showCmd = SW_SHOW;

    // Center the application window on the screen.

    GetWindowRect(m_hWnd,&rRect);

    // Compute actual width and height

    rRect.right -= rRect.left;
    rRect.bottom -= rRect.top;

    // Resolve X,Y location required to center whole window.

    nX = (GetSystemMetrics(SM_CXSCREEN) - rRect.right) / 2;
    nY = (GetSystemMetrics(SM_CYSCREEN) - rRect.bottom) / 2;

    // Move the window to the center location.

    ::MoveWindow(m_hWnd,nX,nY,rRect.right,rRect.bottom,TRUE);

    Place.showCmd = SW_SHOW;
    Place.rcNormalPosition.left = nX;
    Place.rcNormalPosition.top = nY;
    Place.rcNormalPosition.right = rRect.right;
    Place.rcNormalPosition.bottom = rRect.top;

    ReadReg(TEXT("WNDPLACE"),&Place,sizeof(WINDOWPLACEMENT));

    // Open the registry.

    if ( ERROR_SUCCESS != ::RegOpenKeyEx(HKEY_CURRENT_USER,APP_KEY,0,KEY_ALL_ACCESS, &m_hKey) ) {
        if ( ::RegCreateKeyEx(HKEY_CURRENT_USER,APP_KEY,0,TEXT(""),REG_OPTION_NON_VOLATILE, KEY_ALL_ACCESS, NULL, &m_hKey, NULL) != ERROR_SUCCESS ) {
            MessageBox(NULL,TEXT("There was an error while launching the program. The program will now terminate"),TEXT("Error"),MB_ICONERROR);
            ExitThread(1);
        }

    }

    // Read default profile information for the application.

    ReadReg(TEXT("DPFLEVEL"),&g_uDPFLevel,sizeof(UINT));
    ReadReg(TEXT("PROFILEDPF"),&g_uProfileDPFLevel,sizeof(UINT));

    // Create the status bar

    InitCommonControls();

    m_hStatusBar = CreateStatusWindow(  WS_CHILD | WS_VISIBLE | SBARS_SIZEGRIP | WS_CLIPSIBLINGS,
                                        TEXT(""),
                                        m_hWnd,
                                        STATUS_ID);

    // Create the toolbar
/*
    m_hToolBar = CreateToolbarEx(   m_hWnd,
                                    WS_CHILD | WS_VISIBLE | WS_CLIPSIBLINGS | WS_BORDER | TBSTYLE_FLAT | TBSTYLE_TOOLTIPS,
                                    TOOLBAR_ID,
                                    23,
                                    g_hInstance,
                                    IDR_MAINTOOLBAR,
                                    m_MainButtons,
                                    g_uButtons,
                                    16, 16,
                                    16, 16,
                                    sizeof(TBBUTTON));

    // Add common control system images to the toolbar

    TBADDBITMAP Bmp;

    Bmp.hInst = HINST_COMMCTRL;
    Bmp.nID   = IDB_STD_SMALL_COLOR;

    m_uStandardImages = SendMessage(g_theApp.m_hToolBar,TB_ADDBITMAP,1,(LPARAM) &Bmp);
*/
    // Create the views used in the app

    m_ViewList[VIEW_DATABASE].pView = new CDBView;

    if ( NULL != m_ViewList[VIEW_DATABASE].pView )


        if ( !m_ViewList[VIEW_DATABASE].pView->Initialize() ) {
            DPF(1,TEXT("Creating the DB View failed"));
        }

        /// dddd what is happening here....
    m_ViewList[VIEW_SEARCHDB].pView = new CDBSearch;


    if ( NULL != m_ViewList[VIEW_SEARCHDB].pView )
        if ( !m_ViewList[VIEW_SEARCHDB].pView->Initialize() ) {
            DPF(1,TEXT("Creating the DB Search View failed"));
        }

    m_DBLocal.NewDatabase(FALSE);
    // The above function swith FALSE paramter closes the databases and makes other changes such as  
    // activates  the view etc, so that the cahnges are seen in the window heading





    TCHAR   szShimDB[MAX_PATH_BUFFSIZE];

    GetSystemWindowsDirectory(szShimDB, MAX_PATH);
    lstrcat(szShimDB,TEXT("\\AppPatch\\sysmain.sdb"));

    //Create the opening Modeless Dlg box
    HWND hSplash = CreateDialog(g_hInstance,MAKEINTRESOURCE(IDD_SPLASH),m_hWnd,(DLGPROC)SplashProc);

    ShowWindow(hSplash,SW_SHOWNORMAL);
    UpdateWindow(hSplash);

    if ( !m_DBGlobal.OpenDatabase( CSTRING(szShimDB),TRUE) ){
        MessageBox(NULL,szShimDB,TEXT("Failed to open the data base !"),MB_OK);
    }




    if ( NULL != m_DBGlobal.m_pDB ) {

        SdbCloseDatabase(m_DBGlobal.m_pDB);
    }

    

    DestroyWindow(hSplash);

    GetDBGlobal().m_pDB = NULL;

    // Activate the default view.

    ActivateView(m_ViewList[VIEW_DATABASE].pView);

    //SetWindowPlacement(m_hWnd,&Place);
}

//*****************************************************************************
//  Class:      CApplication
//
//  Function:   ActivateView
//
//  Notes:      Deactivate the current view and activate the view specified.
//
//  History:
//
//      A-COWEN         Nov 29, 2000         Implemented it.
//*****************************************************************************

void CApplication::ActivateView(CView * pView, BOOL fNewCreate )
{
    if ( NULL != m_pCurrentView ) {
        ShowWindow(m_pCurrentView->m_hWnd,SW_HIDE);

        m_pCurrentView->Deactivate();//Does nothing !!
    }

    // Make sure only the main toolbar buttons are active
/*
    while (TRUE == SendMessage(m_hToolBar,TB_DELETEBUTTON,g_uButtons,0));
*/
    m_pCurrentView = pView;

    RECT    rRect;

    GetWindowRect(m_hWnd,&rRect);

    if ( NULL != pView ) {
        ShowWindow(pView->m_hWnd,SW_SHOW);
        UpdateWindow(pView->m_hWnd);

        pView->Activate(fNewCreate);

        if ( NULL == pView->m_hMenu )
            SetMenu(m_hWnd,m_hMenu);
        else
            SetMenu(m_hWnd,pView->m_hMenu);
    }

    // Cause the views to be resized to fit in the current parent window.

    msgResize(rRect.right - rRect.left, rRect.bottom - rRect.top);
}

//*****************************************************************************
//  Class:      CApplication
//
//  Function:   ReadReg
//
//  Notes:      Simplified registry profile routine. This is only
//              valid after msgCreate is called. ReadReg always references
//              the application's registry profile.
//
//  History:
//
//      A-COWEN         Nov 8, 2000         Implemented it.
//*****************************************************************************

UINT CApplication::ReadReg(
                          LPCTSTR szKey,
                          PVOID pData,
                          UINT uSize)
{
    ULONG uBytes = uSize;
    ULONG uType;

    //
    // we are calling registry fns here with no regard for an underlying type 
    //

    if ( FAILED(::RegQueryValueEx(m_hKey,szKey,NULL,&uType,(LPBYTE) pData, &uBytes)) )
        return(UINT) -1;

    // Return the number of bytes read.

    return uBytes;
}

//*****************************************************************************
//  Class:      CApplication
//
//  Function:   WriteReg
//
//  Notes:      Simplified registry profile writing routine. This is only
//              valid after msgCreate is called. WriteReg always references
//              the application's registry profile.
//
//  History:
//
//      A-COWEN         Nov 8, 2000         Implemented it.
//*****************************************************************************

UINT CApplication::WriteReg(
                           LPCTSTR szKey,
                           UINT uType,
                           PVOID pData,
                           UINT uSize)
{
    if ( FAILED(::RegSetValueEx(m_hKey,szKey,0,uType,(const BYTE *) pData, uSize)) )
        return(UINT) -1;

    // Return the number of bytes written.

    return uSize;
}

//*****************************************************************************
//  Class:      CApplication
//
//  Function:   msgClose
//
//  Notes:      Monitor for application shutdown. When a close was requested,
//              at the application level, it's time to shutdown the application.
//              Also close registry profile.
//
//  History:
//
//      A-COWEN         Nov 8, 2000         Implemented it.
//*****************************************************************************

void CApplication::msgClose(void)
{
    // Post WM_QUIT to the message queue.

    SendMessage(m_hWnd,WM_COMMAND,ID_FILE_EXIT,(LPARAM)m_hWnd);
}

//*****************************************************************************
//  Class:      CApplication
//
//  Function:   msgResize
//
//  Notes:      Watch for notifications to resize the main window. Update child
//              windows appropriately.
//
//  History:
//
//      A-COWEN         Nov 8, 2000         Implemented it.
//*****************************************************************************

void CApplication::msgResize(UINT uWidth, UINT uHeight)
{
    // Resize the current view.

    if ( NULL != m_pCurrentView ) {
        RECT    rRect;
        UINT    uToolSize = 0;
        UINT    uStatusSize;

        //GetWindowRect(m_hToolBar,&rRect);
        //uToolSize = rRect.bottom - rRect.top;

        GetWindowRect(m_hStatusBar,&rRect);
        uStatusSize = rRect.bottom - rRect.top;

        GetClientRect(m_hWnd,&rRect);

        MoveWindow( m_pCurrentView->m_hWnd,
                    0, uToolSize,
                    rRect.right, rRect.bottom - (uToolSize + uStatusSize),
                    TRUE);
    }

    UINT uWidths[] = {uWidth - 300, uWidth - 100, -1};
    

    SendMessage(m_hStatusBar,SB_SETPARTS,sizeof(uWidths)/sizeof(UINT),(LPARAM) uWidths);

    SendMessage(m_hStatusBar,SB_SETTEXTW,(sizeof(uWidths)/sizeof(UINT)) | SBT_NOBORDERS,(LPARAM)TEXT(""));

    // Move and resize the status bar, then force repaint.

    SendMessage(m_hStatusBar,WM_SIZE,0,0);
    

    // Resize the toolbar

    //SendMessage(m_hToolBar,WM_SIZE,0,0);
}

//*****************************************************************************
//  Class:      CApplication
//
//  Function:   msgNotify
//
//  Notes:      Watch for notifications to the parent. If the notifications
//              are not handled by the main application class, they are passed
//              to the current viewport for processing.
//
//  History:
//
//      A-COWEN         Jan 23, 2000         Added comment.
//*****************************************************************************

void CApplication::msgNotify(LPNMHDR pHdr)
{
    // Send any unprocessed notifications to the view.

    //
    // BUGBUG : Please move all the strings to the .rc file
    // let's write a method in CSTRING that allows you to load them 
    // from the resource file
    //

    switch ( pHdr->code ) {
    case    TBN_GETINFOTIP:
        {
            LPNMTBGETINFOTIP pTip = (LPNMTBGETINFOTIP) pHdr;
            static TCHAR * szTips[] = { TEXT("New Database"),
                TEXT("Open Database"),
                TEXT("Save Database"),
                TEXT("Send Database via Email"),
                TEXT("Print"),
                TEXT("Print Preview"),
                TEXT("Search for fixes"),
                TEXT("Database View")};

            switch ( pTip->iItem ) {
            case    ID_FILE_NEWDATABASE:
                lstrcpy(pTip->pszText,TEXT("New Database"));
                break;

            case    ID_FILE_OPENDATABASE:
                lstrcpy(pTip->pszText,TEXT("Open Database"));
                break;

            case    ID_FILE_SAVEDATABASE:
                lstrcpy(pTip->pszText,TEXT("Save Database"));
                break;

            case    ID_WINDOWS_SEARCHFORFIXES:
                lstrcpy(pTip->pszText,TEXT("Search for fixes"));
                break;

            case    ID_WINDOWS_DATABASEVIEWER:
                lstrcpy(pTip->pszText,TEXT("Database View"));
                break;



            }
        }
        break;
    }

    if ( NULL != m_pCurrentView )
        m_pCurrentView->msgNotify(pHdr);
}

void CApplication::msgChar(TCHAR chChar)
{
    // Send any unprocessed notifications to the view.

    
    if ( NULL != m_pCurrentView )
        m_pCurrentView->msgChar(chChar);
}

//*****************************************************************************
//  Class:      CApplication
//
//  Function:   msgCommand
//
//  Notes:      Watch for user input that indicates an action we should take.
//              If it's not a global action, pass the command on to the current
//              view to handle it.
//
//  History:
//
//      A-COWEN         Nov 31, 2000         Implemented it.
//*****************************************************************************

void CApplication::msgCommand(UINT uID, HWND hSender)
{
    switch ( uID ) {
    case    ID_FILE_NEWDATABASE:
        {
            HWND hWnd = GetFocus();

            if ( GetDBLocal().m_bDirty ) {
                int nResult = MessageBox(m_hWnd,TEXT("The current database has changed\nWould you like to save the current database changes?"),TEXT("CompatAdmin"),MB_YESNOCANCEL | MB_ICONWARNING);

                if ( IDCANCEL == nResult )
                    break;

                if ( IDYES == nResult )
                    SendMessage(m_hWnd,WM_COMMAND,ID_FILE_SAVEDATABASE,(LPARAM)m_hWnd);
            }

            GetDBLocal().NewDatabase(TRUE);

            UpdateView();

            SetFocus(hWnd);
        }
        break;

    case    ID_HELP_ABOUT:
        {
            ShellAbout(m_hWnd,TEXT("Application Compatibility Administrator"),TEXT(""),LoadIcon(g_hInstance,MAKEINTRESOURCE(IDI_COMPATADMIN)));
        }
        break;

    case    ID_FILE_EXIT:
        {
            if ( m_DBLocal.m_bDirty ) {
                int nResult = MessageBox(m_hWnd,TEXT("The current database has changed\nWould you like to save the current database changes?"),TEXT("CompatAdmin"),MB_YESNOCANCEL  | MB_ICONWARNING);

                if ( IDCANCEL == nResult )
                    break;

                if ( IDYES == nResult )
                    SendMessage(m_hWnd,WM_COMMAND,ID_FILE_SAVEDATABASE,(LPARAM)m_hWnd);
            }

            WINDOWPLACEMENT Place;

            Place.length = sizeof(WINDOWPLACEMENT);

            GetWindowPlacement(m_hWnd,&Place);

            WriteReg(TEXT("WNDPLACE"),REG_BINARY,&Place,sizeof(WINDOWPLACEMENT));

            CDatabase::CleanUp();

            PostQuitMessage(0);

            m_ViewList[VIEW_DATABASE].pView->msgClose();
            m_ViewList[VIEW_SEARCHDB].pView->msgClose();

            // Close the registry

            ::RegCloseKey(m_hKey);
        }
        break;

    case    ID_FILE_OPENDATABASE:
        {
            OPENFILENAME    ofn;
            TCHAR           szFilename[MAX_PATH_BUFFSIZE];
            TCHAR           szShimDB[MAX_PATH_BUFFSIZE];
            HWND            hWnd = GetFocus();

            *szFilename = *szShimDB = 0;

            if ( GetDBLocal().m_bDirty ) {
                int nResult = MessageBox(m_hWnd,TEXT("The current database has changed\nWould you like to save the current database changes?"),TEXT("CompatAdmin"),MB_YESNOCANCEL  | MB_ICONWARNING);

                if ( IDCANCEL == nResult )
                    break;

                if ( IDYES == nResult )
                    SendMessage(m_hWnd,WM_COMMAND,ID_FILE_SAVEDATABASE,(LPARAM)m_hWnd);
            }

            GetSystemWindowsDirectory(szShimDB, MAX_PATH);
            lstrcat(szShimDB, TEXT("\\AppPatch"));

            ZeroMemory(&ofn,sizeof(OPENFILENAME));
            ZeroMemory(szFilename,sizeof(szFilename));

            ofn.lStructSize     = sizeof(OPENFILENAME);
            ofn.hwndOwner       = m_hWnd;
            ofn.hInstance       = g_hInstance;
            ofn.lpstrFilter     = TEXT("Compatibility DB (*.SDB)\0*.SDB\0\0");
            ofn.lpstrFile       = szFilename;
            ofn.nMaxFile        = MAX_PATH;
            //ofn.lpstrInitialDir = szShimDB;
            ofn.lpstrTitle      = TEXT("Open Compatibility Database");
            ofn.Flags           = OFN_FILEMUSTEXIST | OFN_PATHMUSTEXIST| OFN_HIDEREADONLY;
            ofn.lpstrDefExt     = TEXT("SDB");

            if ( GetOpenFileName(&ofn) ) {
                CSTRING szFileCheck = szFilename;

                szFileCheck.ShortFilename();

                if ( CDatabase::SystemDB(szFilename) ) {
                    MessageBox(m_hWnd,TEXT("Access to this database is restricted. \nIf you have created this custom database, please change the name of the database or contact the provider of this database"),TEXT("Access violation"),MB_ICONERROR);
                } 
                    if ( ! m_DBLocal.OpenDatabase(CSTRING(szFilename),FALSE) ) {
                    MessageBox(m_hWnd,TEXT("An error occured attempting to open the database specified."),TEXT("Unable to open database"),MB_OK | MB_ICONERROR);
                }
            }

            SetFocus(hWnd);
        }
        break;

    case    ID_FILE_SAVEDATABASE:
        {
            CSTRING szFilename;
            HWND hWnd = GetFocus();

            if ( GetDBLocal().m_szCurrentDatabase.Length() == 0 ) {
                if ( GetFilename(TEXT("Save Database"),TEXT("Compatibility DB (*.SDB)\0*.SDB\0\0"), TEXT(""), TEXT("SDB"), OFN_PATHMUSTEXIST | OFN_OVERWRITEPROMPT, FALSE, szFilename) )
                    GetDBLocal().SaveDatabase(szFilename);
            } else
                m_DBLocal.SaveDatabase(GetDBLocal().m_szCurrentDatabase);

            SetFocus(hWnd);
            
            UpdateView();
        }
        break;

    case    ID_FILE_SAVEDATABASEAS:
        {
            CSTRING szFilename;
            
            HWND hWnd = GetFocus();

            if ( GetFilename(TEXT("Save Database As"),TEXT("Compatibility DB (*.SDB)\0*.SDB\0\0"), TEXT(""), TEXT("SDB"), OFN_PATHMUSTEXIST | OFN_OVERWRITEPROMPT, FALSE, szFilename) ) {
                m_DBLocal.SaveDatabase(szFilename);

                SetFocus(hWnd);

                UpdateView();
            }
        }
        break;

    case    ID_WINDOWS_SEARCHFORFIXES:
        {
            SetStatusText(0,CSTRING(TEXT("Search for fixes")));
            SetStatusText(2,CSTRING(TEXT("")));


            ActivateView(m_ViewList[VIEW_SEARCHDB].pView);
        }
        break;

    case    ID_WINDOWS_DATABASEVIEWER:
        {   
            

            ActivateView(m_ViewList[VIEW_DATABASE].pView,FALSE);
            
        }
        break;

    default:
        if ( NULL != m_pCurrentView )
            m_pCurrentView->msgCommand(uID,hSender);
    }
}


//*****************************************************************************
//  Class:      CApplication
//
//  Function:   MessagePump
//
//  Notes:      The main application message pump.
//
//  History:
//
//      A-COWEN         Nov 8, 2000         Implemented it.
//*****************************************************************************

int CApplication::MessagePump(void)
{
    MSG msg;

    while ( GetMessage(&msg,NULL,0,0) ) {
        // Support modeless dialog message processing. If the message
        // is destined for a modeless dialog, do not translate and dispatch
        // as IsDialogMessage() will do that automatically.




        if ( NULL == m_hDialog || !IsDialogMessage(m_hDialog,&msg) ) {
            // Provide accelerator support. If an accelerator
            // is translated, do not call TranslateMessage().

            if ( NULL == m_hAccelerator || !TranslateAccelerator(this->m_hWnd,m_hAccelerator,&msg) )
                TranslateMessage(&msg);

            // Finally, dispatch the message to the window procedure.

            DispatchMessage(&msg);
        }
    }

    // GetMessage() returns FALSE when WM_QUIT is received.
    // Return the value from WM_QUIT, which is provided in WPARAM
    // from PostQuitMessage();

    return msg.wParam;
}

//*****************************************************************************
//  Class:      CApplication
//
//  Function:   AddToolbarButton
//
//  Notes:      Adds a button to the toolbar
//
//  History:
//
//      A-COWEN         Jan 23, 2000         Added comment.
//*****************************************************************************

BOOL CApplication::AddToolbarButton(UINT uBmp, UINT uCmd, UINT uState, UINT uStyle)
{
/*
    TBBUTTON    Button;

    Button.iBitmap      = uBmp;
    Button.idCommand    = uCmd;
    Button.fsState      = (BYTE) uState;
    Button.fsStyle      = (BYTE) uStyle;
    Button.dwData       = 0;
    Button.iString      = 0;

    if (0 == SendMessage(g_theApp.m_hToolBar,TB_ADDBUTTONS,1,(LPARAM) &Button))
        return FALSE;
*/
    return TRUE;
}

//*****************************************************************************
//  Class:      CApplication
//
//  Function:   SetButtonState
//
//  Notes:      Sets the button state for a toolbar button.
//
//  History:
//
//      A-COWEN         Jan 23, 2000         Added comment.
//*****************************************************************************

BOOL CApplication::SetButtonState(UINT uCmd, UINT uState)
{
/*
    TBBUTTONINFO    Info;

    Info.cbSize = sizeof(Info);
    Info.dwMask = TBIF_STATE;
    Info.fsState = (BYTE) uState;

    return SendMessage(g_theApp.m_hToolBar,TB_SETBUTTONINFO,uCmd,(LPARAM) &Info) ? TRUE:FALSE;
*/

    return FALSE;
}

//*****************************************************************************
//  Class:      CApplication
//
//  Function:   GetFilename
//
//  Notes:      General purpose function used for OpenFileName and GetSaveFileName
//              common control functions.
//
//  History:
//
//      A-COWEN         Jan 23, 2000         Added comment.
//*****************************************************************************

BOOL CApplication::GetFilename(LPCTSTR szTitle, LPCTSTR szFilter, LPCTSTR szDefaultFile, LPCTSTR szDefExt, DWORD dwFlags, BOOL bOpen, CSTRING & szStr)
{
    OPENFILENAME    ofn;
    TCHAR           szFilename[MAX_PATH_BUFFSIZE];
    BOOL            bResult;

    ZeroMemory(&ofn,sizeof(OPENFILENAME));
    ZeroMemory(szFilename,sizeof(szFilename));


    //Used lstrcpyn to  satisfy PREFast
    lstrcpyn(szFilename,szDefaultFile,sizeof(szFilename)/sizeof(TCHAR));

    

    ofn.lStructSize     = sizeof(OPENFILENAME);
    ofn.hwndOwner       = m_hWnd;
    ofn.hInstance       = g_hInstance;
    ///iii Perhaps this too is incorrect
    ofn.lpstrFilter     = szFilter;
    ofn.lpstrFile       = szFilename;
    ofn.nMaxFile        = MAX_PATH;
    ofn.lpstrInitialDir = szDefaultFile;
    ofn.lpstrTitle      = szTitle;
    ofn.Flags           = dwFlags | OFN_NOREADONLYRETURN | OFN_HIDEREADONLY;
    ofn.lpstrDefExt     = szDefExt;

    BOOL valid = FALSE; //whether path is too long / ends with .SDB or not applicable for save mode only
    while (valid == FALSE) {

    

        if ( bOpen )
            bResult = GetOpenFileName(&ofn);
        else
            bResult = GetSaveFileName(&ofn);

        if ( !bResult )
            return FALSE;

        szStr = szFilename;

        if (bOpen) {
            return TRUE;
        }

        //
        //Do stuff to make sure that the file being saved has a .SDB extension and the filename is not
        //too long so that a .SDB file name does not get appended to it.
        //
        
        if ( szStr.isNULL() ) {
            continue;
        }

        if (!szStr.EndsWith(TEXT(".sdb"))){
            if (szStr.Length() <= (MAX_PATH - 1 - 4)) {
                szStr.strcat(TEXT(".sdb"));
                valid = TRUE;
                
            }
                        
        }else{
            valid = TRUE;
        }

        if (valid == FALSE) {
            CSTRING message =TEXT("The path you entered: ");
            message.strcat(szStr);
            message.strcat(TEXT("\nis too long. Please enter a shorter path"));
            
            MessageBox(m_hWnd, message,TEXT("CompatAdmin"),MB_ICONWARNING);

        }
    }//while

    
    return TRUE;
}

//*****************************************************************************
//  Class:      CApplication
//
//  Function:   InvokeEXE
//
//  Notes:      Invoke an executable with the specified command line. Then
//              wait for the executable to finish if desired.
//
//  History:
//
//      A-COWEN         Jan 23, 2000         Added comment.
//*****************************************************************************

BOOL CApplication::InvokeEXE(LPCTSTR szEXE, LPCTSTR szCommandLine, BOOL bWait, BOOL bDialog, BOOL bConsole)
{
    
    
    BOOL                bCreate;
    STARTUPINFO         Start;
    PROCESS_INFORMATION Out;

    ZeroMemory(&Start,sizeof(STARTUPINFO));
    Start.cb = sizeof(STARTUPINFO);

    bCreate = CreateProcess(    szEXE,
                                (LPWSTR)szCommandLine,
                                NULL,
                                NULL,
                                FALSE,
                                ((bConsole) ? 0:CREATE_NO_WINDOW) | NORMAL_PRIORITY_CLASS,
                                NULL,
                                NULL,
                                &Start,
                                &Out);

    
    if ( bCreate && bWait ) {

        CloseHandle(Out.hThread);
        g_hTestRunExec = Out.hProcess;

        

        DialogBoxParam(g_hInstance,MAKEINTRESOURCE(IDD_WAIT),m_hWnd,(DLGPROC)TestRunWait,(LPARAM)bDialog);
    }

    CloseHandle(Out.hProcess);
    return bCreate ? TRUE:FALSE;
}

// FlushCache code taken from SDBInst.

typedef void (CALLBACK *pfn_ShimFlushCache)(HWND, HINSTANCE, LPSTR, int);

void FlushCache(void)
{
    HMODULE hAppHelp;
    pfn_ShimFlushCache pShimFlushCache;

    hAppHelp = LoadLibraryW(L"apphelp.dll");

    if ( hAppHelp ) {
        pShimFlushCache = (pfn_ShimFlushCache)GetProcAddress(hAppHelp, "ShimFlushCache");//PARAMS(HMODULE,LPCSTR)

        if ( pShimFlushCache ) {
            pShimFlushCache(NULL, NULL, NULL, 0);
        }
    }

}

//*****************************************************************************


//  Class:      CApplication
//
//  Function:   TestRun
//
//  Notes:      Execute the application defined by the specified record, with
//              the shim or layer information defined in that record. The
//              filename and commandline are overridable.
//
//  History:
//
//      A-COWEN         Jan 23, 2000         Added comment.
//*****************************************************************************




BOOL CApplication::TestRun(PDBRECORD pRecord, CSTRING * pszFile, CSTRING * pszCommandLine, HWND hParent)
{
    CSTRING szCommandLine;
    BOOL    bResult;
    TCHAR   szPath[MAX_PATH_BUFFSIZE];
    TCHAR   szSystemDir[MAX_PATH_BUFFSIZE];

    if ( NULL != pszFile )
        g_szTestFile = *pszFile;
    else
        g_szTestFile = pRecord->szEXEName;

    if ( NULL == pszCommandLine ) {
        if ( 0 == DialogBox(g_hInstance,MAKEINTRESOURCE(IDD_TESTRUN),hParent,(DLGPROC)TestRunDlg) )
            return FALSE;
    }

    //
    // UnInstall and remove the earlier Test.SDB file
    //

    CDatabase::CleanUp();

    //
    // Now make the XML, ,SDB  and call InVokeExe
    //

    CSTRINGList * pXML = m_DBLocal.DisassembleRecord(pRecord,FALSE,FALSE,TRUE,TRUE,FALSE, TRUE);

    if ( GetCurrentDirectory(MAX_PATH,szPath) == 0 ) {

        #ifdef __DEBUG
        MessageBox(NULL,TEXT("Unable to execute GetCurrentDirectory(...)"), TEXT("Error"),MB_ICONWARNING);
        #endif
        
        return FALSE;
    }



    if ( GetWindowsDirectory(szSystemDir,MAX_PATH) == 0 ) {

        #ifdef __DEBUG
        MessageBox(NULL,TEXT("Unable to execute GetWindowsDirectory(...)"), TEXT("Error"),MB_ICONWARNING);
        #endif
        return FALSE;
    }


    if ( NULL != pXML ) {
        CSTRING szFile;

        lstrcpy(szPath,szSystemDir);

        szFile.sprintf(TEXT("%s\\AppPatch\\SysTest.XML"),szPath);

        if ( !m_DBLocal.WriteXML(szFile,pXML) ) {
            MessageBox(g_theApp.m_hWnd,TEXT("Unable to save temporary file."),TEXT("File save error"),MB_OK);
            return FALSE;
        }


        delete pXML;
    } else
        return FALSE;

    if ( lstrlen(szPath) == 3 )
        szPath[2] = 0;

    szCommandLine.sprintf(TEXT("custom  \"%s\\AppPatch\\SysTest.XML\" \"%s\\AppPatch\\Test.SDB\""),szPath,szSystemDir);
    
    bResult = CDatabase::InvokeCompiler(szCommandLine);

    if ( bResult ) {
        
        CSTRING szCommandLine;

        //
        // BUGBUG why no windbg? 
        //
        if ( g_TestRun.bNTSD )
            szCommandLine = TEXT("NTSD.EXE ");
        else
            if ( g_TestRun.bMSDEV )
            szCommandLine = TEXT("MSDEV.EXE ");

        // Invoke the application

        szCommandLine.strcat(g_szTestFile);

        szCommandLine.strcat(TEXT(" "));

        if ( NULL != pszCommandLine )
            szCommandLine.strcat(*pszCommandLine);
        else
            szCommandLine.strcat(g_TestRun.szCommandLine);

        // If there's a layer, set the environment

        /*
        if (pRecord->szLayerName.Length() > 0)
            //SetEnvironmentVariable(TEXT("__COMPAT_LAYER"),pRecord->szLayerName);
            
        */

        FlushCache();

        
        
        
        CSTRING strSdbInstCommandLine;
        strSdbInstCommandLine.sprintf(TEXT("%s\\System32\\sdbInst.exe  -q  %s\\AppPatch\\Test.SDB  "),(LPCTSTR)szSystemDir,(LPCTSTR)szSystemDir);
              

        if ( !InvokeEXE(NULL,strSdbInstCommandLine.pszString,TRUE,TRUE,TRUE) ) {
            MessageBox(m_hWnd,TEXT("There was a problem In executing the data base installer."),TEXT("CompatAdmin"),MB_ICONERROR);

        }

        if ( !InvokeEXE(NULL,szCommandLine.pszString,TRUE,TRUE,TRUE) ) {
            MessageBox(m_hWnd,TEXT("There was a problem executing the specified program.\nPlease provide the complete path of the executable and try again.\nPlease check that this is a executable file"),TEXT("Execution Failure"),MB_ICONERROR);

        }

        /*
        strSdbInstCommandLine.sprintf(TEXT("%s\\System32\\sdbInst.exe   -u %s\\AppPatch\\Test.SDB  "),(LPCTSTR)szSystemDir,(LPCTSTR)szSystemDir);

        if ( !InvokeEXE(NULL,strSdbInstCommandLine.pszString,TRUE,TRUE,TRUE) ) {
             MessageBox(m_hWnd,TEXT("There was a problem In executing the data base installer."),TEXT("CompatAdmin"),MB_ICONERROR);

        }
        */


        



        //SetEnvironmentVariable(TEXT("__COMPAT_LAYER"),NULL);
    }

#ifdef __DEBUG
MessageBox(g_theApp.m_hWnd,TEXT("Now about to delete the SysTest.* files "),TEXT("Now"),MB_OK);
#endif


    szCommandLine.sprintf(TEXT("%s\\AppPatch\\SysTest.XML"),szPath);


    
    BOOL bReturnCode;
    bReturnCode = DeleteFile(szCommandLine);
    
    /*
    szCommandLine.sprintf(TEXT("%s\\AppPatch\\Test.SDB"),szSystemDir);
    bReturnCode = DeleteFile(szCommandLine);
    */
    
    



    return bResult;
}

//*****************************************************************************
//  Class:      CApplication
//
//  Function:   TestRunWait
//
//  Notes:      Basic dialog that is displayed while waiting for an application
//              to complete. The dialog is invoked by the InvokeEXE function.
//
//  History:
//
//      A-COWEN         Jan 23, 2000         Added comment.
//*****************************************************************************

BOOL CALLBACK
TestRunWait(
    HWND hWnd, 
    UINT uMsg, 
    WPARAM wParam, 
    LPARAM lParam
    )
{

    // 
    // BUGBUG: I had to use WM_USER+1024  when lParam == 0, WE do not want to show the dialog, because the dialog is
    // getting showed even if we call ShowWindow(hWnd,SW_HIDE); calling this seems to have no effect !!
    //

    switch (uMsg) {
    
    case WM_INITDIALOG:
        if (lParam == 0) {
            SendMessage(hWnd, WM_USER + 1024, 0, 0);
            ShowWindow(hWnd, SW_HIDE);
        } else {
            ShowWindow(hWnd,SW_SHOW);
            SetTimer(hWnd, 0, 50, NULL);
        }
        return TRUE;

    case WM_TIMER:
        {
            DWORD dwResult = WaitForSingleObject(g_hTestRunExec,10);

            if (dwResult != WAIT_TIMEOUT) {
               KillTimer(hWnd,0);
               EndDialog(hWnd,0);
            }
            break;
        }

    case WM_USER + 1024:
        {
            //
            // NOTE: This will not return to the dialog, and it will not get shown.
            //       But if the process takes a long time to execute the background
            //       might get white-washed :-( [Theoretically]
            //       Please explore this one.
            //
            

            DWORD dwResult = WaitForSingleObject(g_hTestRunExec, INFINITE);
            
            EndDialog(hWnd,0);
        }
        break;

    }

    return FALSE;
}
//*****************************************************************************


//  Class:      CApplication
//
//  Function:   TestRunDlg
//
//  Notes:      Dialog handling procedure that queries the user for the command
//              line and debugging options for a test run.
//
//  History:
//
//      A-COWEN         Jan 23, 2000         Added comment.
//*****************************************************************************

BOOL CALLBACK TestRunDlg(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    switch ( uMsg ) {
    case    WM_INITDIALOG:
        {
            SetWindowText(GetDlgItem(hWnd,IDC_EXE),g_szTestFile);

            SendDlgItemMessage(hWnd,IDC_NONE,BM_SETCHECK,BST_CHECKED,0);
        }
        break;

    case    WM_COMMAND:
        switch ( LOWORD(wParam) ) {
        case    IDC_BROWSE:
            {
                HWND hwndFocus = GetFocus();
                
                CSTRING szFilename;

                

                if ( g_theApp.GetFilename(TEXT("Find Program"),
                                          TEXT("Executable (*.EXE)\0*.EXE\0All Files (*.*)\0*.*\0\0"), 
                                          g_szTestFile, 
                                          TEXT(""), 
                                          OFN_PATHMUSTEXIST | OFN_FILEMUSTEXIST, 
                                          TRUE, 
                                          szFilename) ) {
                    g_szTestFile = szFilename;

                    SetWindowText(GetDlgItem(hWnd,IDC_EXE),g_szTestFile);
                }
                
                SetFocus( hwndFocus );

            }
            break;

        case    IDOK:
            {
                TCHAR szCmdLine[MAX_PATH_BUFFSIZE];

                if ( BST_CHECKED == SendDlgItemMessage(hWnd,IDC_NTSD,BM_GETCHECK,0,0) )
                    g_TestRun.bNTSD = TRUE;
                else
                    g_TestRun.bNTSD = FALSE;

                if ( BST_CHECKED == SendDlgItemMessage(hWnd,IDC_MSDEV,BM_GETCHECK,0,0) )
                    g_TestRun.bMSDEV = TRUE;
                else
                    g_TestRun.bMSDEV = FALSE;

                GetWindowText(GetDlgItem(hWnd,IDC_COMMANDLINE),szCmdLine,MAX_PATH);

                g_TestRun.szCommandLine = szCmdLine;

                GetWindowText(GetDlgItem(hWnd,IDC_EXE),szCmdLine,MAX_PATH);

                g_szTestFile = szCmdLine;

                EndDialog(hWnd,1);
            }
            break;
        case    IDCANCEL:
            EndDialog(hWnd,0);
            break;
        }
    }

    return FALSE;
}

//*****************************************************************************
//  Class:      CApplication
//
//  Function:   SetStatusText
//
//  Notes:      Provides basic functionality to access the status bar for the
//              main application window.
//
//  History:
//
//      A-COWEN         Jan 23, 2000         Added comment.
//*****************************************************************************

LRESULT CApplication::MsgProc(
                        UINT        uMsg,
                        WPARAM      wParam,
                        LPARAM      lParam)
{
  
    switch ( uMsg ) {
        case   WM_SETFOCUS:{
            if (m_pCurrentView == NULL ) break;

            if ( m_pCurrentView ==  m_ViewList[VIEW_DATABASE].pView ){
                if ( g_hWndLastFocus ) SetFocus(g_hWndLastFocus);                      
            }else{
                if (m_pCurrentView == m_ViewList[VIEW_SEARCHDB].pView) {

                    SetFocus( ((CDBSearch*)m_pCurrentView)->m_hListView );
                }
            }
                                                                                       
            break;


        }
    }
   

    return CWindow::MsgProc(uMsg,wParam,lParam);

}

BOOL CApplication::SetStatusText(UINT uTab, CSTRING & szText)
{

    
    SendMessage(m_hStatusBar,SB_SETTEXT,uTab,(LPARAM)(szText.pszString));
    

    return TRUE;
}

//*****************************************************************************
//  Class:      CApplication
//
//  Function:   UpdateView
//
//  Notes:      Provides basic functionality to force the application to update
//              the current view.
//
//  History:
//
//      A-COWEN         Jan 23, 2000         Added comment.
//*****************************************************************************



void CApplication::UpdateView(BOOL bWindowOnly)
{
    TCHAR   szWindowTitle[1024];
    CSTRING szName;

    if ( (CDatabase::m_szCurrentDatabase != NULL) && (CDatabase::m_szCurrentDatabase.Length() > 0  ))
        szName = CDatabase::m_szCurrentDatabase;
    else
        szName = TEXT("Untitled.SDB");

    if ( szName.Length() == 0 ) {
        MEM_ERR;
        return;
    }


    szName.ShortFilename();

    wsprintf(szWindowTitle,
             TEXT("Application Fix Management Console (%s) %s"),
             (LPCTSTR)szName,
             
             GetDBLocal().m_bDirty ? TEXT("*"):TEXT(""));

    SetWindowText(g_theApp.m_hWnd,szWindowTitle);

    // what is the meaning of bWindowOnly ??

    if ( NULL != m_pCurrentView && !bWindowOnly )
        m_pCurrentView->Update();
}

BOOL CALLBACK SplashProc(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    return FALSE;
}

DWORD WIN_MSG()
{
    LPVOID lpMsgBuf = NULL;

    DWORD returnVal;
    FormatMessage( 
        FORMAT_MESSAGE_ALLOCATE_BUFFER | 
        FORMAT_MESSAGE_FROM_SYSTEM | 
        FORMAT_MESSAGE_IGNORE_INSERTS,
        NULL,
        returnVal = GetLastError(),
        MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT), // Default language
        (LPTSTR) &lpMsgBuf,
        0,
        NULL 
    );
    

    // Display the string.
    MessageBox( NULL, (LPCTSTR)lpMsgBuf, TEXT("Error"), MB_OK | MB_ICONINFORMATION );
    // Free the buffer.
    LocalFree( lpMsgBuf );
    return returnVal;


}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\appcompat\tools\compatadmin\controls.cpp ===
#include "windows.h"

UINT GetRadioStatus(HWND hDlg, UINT uiId)
{
    
return SendMessage(GetDlgItem(hDlg,uiId),
                      BM_GETCHECK,
                      (WPARAM) 0,         
                      (LPARAM) 0 
                     );

}
UINT SetRadioStatus(HWND hDlg, UINT uiId, UINT uiStatus)
{

    return SendMessage(GetDlgItem(hDlg,uiId),
                       BM_SETCHECK,
                       (WPARAM) uiStatus,         
                       (LPARAM) 0
                      );

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\appcompat\tools\compatadmin\compatadmin.h ===
// Standard defines used by the application.

#define MEM_ERR  MessageBox(NULL,TEXT("The System is running low on memory ! Please close some programs and try again."),TEXT("Error"),MB_ICONWARNING|MB_OK);

#include "afxres.h"

#define LIMIT_APP_NAME 150 // Maximum size of app names, to be restricted on the UI Text box
#define MAX_PATH_BUFFSIZE  (MAX_PATH+1)

#define UNICODE
#define _UNICODE

#include <tchar.h>

#define STRICT
#include <windows.h>
#include <commctrl.h>
#include <Commdlg.h>
#include <stdarg.h>
#include <stdio.h>
#include <shellapi.h>
#include <objbase.h>
#include <exception>
#include <Shlwapi.h>
#include <cassert>

#define AUTOCOMPLETE  SHACF_FILESYSTEM | SHACF_AUTOSUGGEST_FORCE_ON

extern "C"
{
#include "shimdb.h"

BOOL ShimdbcExecute(LPCWSTR lpszCmdLine);

}



#include "resource.h"
#include "utils.h"

#ifndef STDCALL
    #define STDCALL  _cdecl
#endif

#ifndef MSGAPI
    #define MSGAPI  virtual void STDCALL
#endif

#include "CDatabase.h"
#include "CDatabaseGlobal.h"
#include "CDatabaseLocal.h"

// For stability purposes, we use RTTI to verify values returned by Windows
// when they are cast to pointers. Use of dynamic_cast<> not only pre-validates
// the pointer, it validates the type of pointer for polymorphic types.

//#ifndef _CPPRTTI
//    #error Build error: Must be compiled with RTTI enabled. (/GR-)
//#endif

#define APP_KEY         TEXT("Software\\Microsoft\\CompatConsole")
#define APPCOMPAT_KEY   TEXT("Software\\Microsoft\\Windows NT\\CurrentVersion\\AppCompatFlags")

//*****************************************************************************
// Global Variables
//*****************************************************************************

// g_hInstance: Defined in CompatAdmin.CPP

extern BOOL g_bWin2K; // Is the OS WIN2K


extern HINSTANCE g_hInstance;
extern HSDB      g_hSDB;
extern HWND      g_hWndLastFocus;

DWORD WIN_MSG(); // Formats and prints last error 

// g_uDPFLevel: Defined in CApplication.CPP

extern UINT     g_uDPFLevel;

// g_uProfileDPFLevel: Defined in CApplication.CPP

extern UINT     g_uProfileDPFLevel;

class CApplication;

// g_theApp: Defined in CompatAdmin.CPP

extern CApplication g_theApp;

// The number of views used by the app

enum {
    VIEW_DATABASE=0,
    VIEW_SEARCHDB,
    VIEW_FORCEDWORD=0xFFFFFFFF
};

#define MAX_VIEWS   15


// Child Window ID's used by the app

#define BASE_ID     (MAX_VIEWS+1)
#define STATUS_ID   (BASE_ID)
#define TOOLBAR_ID  (BASE_ID+1)


// Slider window define

#define SLIDER_WIDTH    5


// Main toolbar info

#define MAINBUTTONS     11

#define IMAGE_NEWFILE       0
#define IMAGE_OPENFILE      1
#define IMAGE_SAVEFILE      2
#define IMAGE_EMAIL         3
#define IMAGE_PRINT         4
#define IMAGE_PRINTPREVIEW  5
#define IMAGE_DISABLEUSER   6
#define IMAGE_DISABLEGLOBAL 7
#define IMAGE_DLL           8
#define IMAGE_APPHELP       24
#define IMAGE_APPLICATION   10
#define IMAGE_SHIM          23
#define IMAGE_WARNING       12
#define IMAGE_VIEWHELP      13
#define IMAGE_VIEWSHIM      14
#define IMAGE_SHIMWIZARD    15
#define IMAGE_SHOWXML       16
#define IMAGE_VIEWGLOBAL    17
#define IMAGE_VIEWPATCH     18
#define IMAGE_DRIVESEARCH   19
#define IMAGE_GUID          20
#define IMAGE_SHOWLAYERS    21
#define IMAGE_VIEWDISABLED  22
#define IMAGE_LAYERS        25

#define IMAGE_PROPERTIES    (CDatabase::m_uStandardImages + STD_PROPERTIES)
#define IMAGE_DELETE        (CDatabase::m_uStandardImages + STD_DELETE)

void FormatVersion(LARGE_INTEGER liVer, LPTSTR szText);

//*****************************************************************************
//
// Class:       CWindow
//
// Purpose:     CWindow is the core class for the application. It wraps the Win32
//              User related APIs that govern window management, into a small and
//              easy to use class. The functionality is purposefully small, and
//              limited in scope. This provides the framework for building the
//              rest of the windows classes, simplifying the rest of the code
//              and reusing as much code as possible.
//
// Additional:  For additional information, see CompatAdmin.DOC.
//
// History
//
//  A-COWEN     Nov 7, 2000         Wrote it.
//
//*****************************************************************************

class CWindow {
    // Class variables

public:

    HWND    m_hWnd;

    // Class support functions.

private:

    static LRESULT CALLBACK MsgProc(HWND        hWnd, 
                                    UINT        uMsg,
                                    WPARAM      wParam,
                                    LPARAM      lParam);

    // Public access functions.

public:

    virtual BOOL STDCALL Create    (LPCTSTR      szClassName,
                                    LPCTSTR      szWindowTitle,
                                    int         nX,
                                    int         nY,
                                    int         nWidth,
                                    int         nHeight,
                                    CWindow   * pParent,
                                    HMENU       nMenuID,
                                    DWORD       dwExFlags,
                                    DWORD       dwFlags);

    virtual LRESULT STDCALL MsgProc(UINT        uMsg,
                                    WPARAM      wParam,
                                    LPARAM      lParam);

    virtual void STDCALL Refresh    (void);
    

    // Message pump callbacks.

public:

    MSGAPI  msgCreate              (void);
    MSGAPI  msgClose               (void);
    MSGAPI  msgCommand             (UINT uID,
                                    HWND hSender);

    MSGAPI  msgChar                (TCHAR chChar);

    MSGAPI  msgNotify              (LPNMHDR pHdr);

    MSGAPI  msgResize              (UINT uWidth, 
                                    UINT uHeight);

    MSGAPI  msgPaint               (HDC hDC);

    MSGAPI  msgEraseBackground     (HDC hDC);

    
        
};

typedef struct {
    NMHDR   Hdr;
    PVOID   pData;
} LISTVIEWNOTIFY, *PLISTVIEWNOTIFY;

#define LVN_SELCHANGED  (WM_USER+1024)

typedef struct _tagList {
    //CSTRING             szText;
    TCHAR               szText[MAX_PATH_BUFFSIZE*2];
    UINT                uImageIndex;
    PVOID               pData;
    struct _tagList   * pNext;

    _tagList()
    {
        //szText.Init();
    }

    ~_tagList()
    {
        //szText.Release();
    }

} LIST, *PLIST;


class CListView: public CWindow {
private:


    UINT    m_nEntries;
    UINT    m_uCaptionBottom;
    UINT    m_uTextHeight;
    PLIST   m_pList;
    PLIST   m_pSelected;
    PLIST   m_pFreeList;
    PLIST   m_pTail;// Points to the tail of the free list.
    UINT    m_uTop;
    UINT    m_uPageSize;
    PLIST   m_pCurrent;
    UINT    m_uCurrent;
    HFONT   m_hCaptionFont;
    HFONT   m_hListFont;
    HBRUSH  m_hGrayBrush;
    HBRUSH  m_hWindowBrush;
    HBRUSH  m_hSelectedBrush;

    HPEN    m_hLinePen;
    BOOL    m_bHilight;

    BOOL    FindEntry(UINT uIndex);

public:
    PLIST getSelected();
    CListView();
    ~CListView();

    // List view procedures

    BOOL            STDCALL AddEntry(CSTRING &, UINT uImage, PVOID pData);
    BOOL            STDCALL RemoveEntry(UINT);
    BOOL            STDCALL RemoveAllEntries(void);

    UINT            STDCALL GetNumEntries(void);
    CSTRING         STDCALL GetEntryName(UINT);
    UINT            STDCALL GetEntryImage(UINT);
    PVOID           STDCALL GetEntryData(UINT);
    UINT            STDCALL GetSelectedEntry(void);
    void            STDCALL ShowHilight(BOOL);

    // Window procedures

    MSGAPI  msgCreate              (void);

    virtual LRESULT STDCALL MsgProc(UINT        uMsg,
                                    WPARAM      wParam,
                                    LPARAM      lParam);

    MSGAPI  msgChar                (TCHAR chChar);
    MSGAPI  msgPaint               (HDC hDC);
    MSGAPI  msgEraseBackground     (HDC hDC);
};

class CView;

BOOL CALLBACK TestRunDlg(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam);
BOOL CALLBACK TestRunWait(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam);

typedef struct {
    CSTRING     szCommandLine;
    BOOL        bNTSD;
    BOOL        bLogging;
    BOOL        bMSDEV;
} TESTRUN, *PTESTRUN;

class CApplication: public CWindow {
    typedef struct {
        CView * pView;
    } VIEWLIST, *PVIEWLIST;

private:
    CDatabaseGlobal     m_DBGlobal;
    CDatabaseLocal      m_DBLocal;
    CDatabase          *m_pDBCurrent;

    HWND        m_hDialog;    

    HKEY        m_hKey;
    HACCEL      m_hAccelerator;
    CView     * m_pCurrentView;
    VIEWLIST    m_ViewList[MAX_VIEWS];

protected:

    friend class CView;
    friend class CDBView;

    TBBUTTON    m_MainButtons[MAINBUTTONS];
    UINT        g_uButtons;

    HWND        m_hStatusBar;
    HWND        m_hToolBar;
    HMENU       m_hMenu;
    HBITMAP     m_hToolBitmap;

public:

    CApplication();
    
    CDatabase& GetDBLocal() ;
    CDatabase& GetDBGlobal();
    virtual LRESULT STDCALL MsgProc(UINT        uMsg,
                                    WPARAM      wParam,
                                    LPARAM      lParam);


    // Utility

    BOOL GetFilename(LPCTSTR szTitle, LPCTSTR szFilter, LPCTSTR szDefaultFile, LPCTSTR szDefExt, DWORD dwFlags, BOOL bOpen, CSTRING & szStr);
    BOOL InvokeEXE(LPCTSTR szEXE, LPCTSTR szCommandLine, BOOL bWait, BOOL bDialog = TRUE, BOOL bConsole = FALSE);
    BOOL TestRun(PDBRECORD, CSTRING * szFile, CSTRING * szCommandLine, HWND hParent);
//        BOOL InsertRecord(PDBRECORD pRecord);
//        BOOL InvokeCompiler(LPTSTR szCommandLine);


    // Database Management
/*
        virtual DWORD STDCALL   GetEntryFlags(HKEY,GUID &);
        virtual BOOL STDCALL    SetEntryFlags(HKEY,GUID &,DWORD);
        virtual BOOL STDCALL    OpenDatabase(LPTSTR szFilename, BOOL bGlobal);
        virtual BOOL STDCALL    SaveDatabase(LPTSTR szFilename);
        virtual void STDCALL    AddShim(TAGID, BOOL, BOOL, BOOL);
        virtual void STDCALL    ReadShims(BOOL);
        virtual BOOL STDCALL    ReadRecord(TAGID, PDBRECORD);
        virtual CSTRING STDCALL ReadDBString(TAGID);
*/
    // Toolbar access

    virtual BOOL STDCALL    AddToolbarButton(UINT uBmp, UINT uCmd, UINT uState, UINT uStyle);
    virtual BOOL STDCALL    SetButtonState(UINT uCmd, UINT uState);

    // Status bar access

    virtual BOOL STDCALL    SetStatusText(UINT uSpace, CSTRING & szText);

    // The main application message pump.

    virtual int STDCALL MessagePump(void);

    

    // View management

    void STDCALL ActivateView(CView *, BOOL fNewCreate = TRUE);
    void STDCALL UpdateView(BOOL bWindowOnly = FALSE);

    // Profile management.

    UINT STDCALL ReadReg           (LPCTSTR szKey,
                                    PVOID pData,
                                    UINT uSize);

    UINT STDCALL WriteReg          (LPCTSTR szKey,
                                    UINT uType,
                                    PVOID pData,
                                    UINT uSize);

    // Overloaded message procs

    MSGAPI  msgCreate              (void);
    MSGAPI  msgClose               (void);

    MSGAPI  msgNotify              (LPNMHDR pHdr);
    MSGAPI  msgChar                (TCHAR chChar);

    MSGAPI  msgResize              (UINT uWidth, 
                                    UINT uHeight);

    MSGAPI  msgCommand             (UINT uID,
                                    HWND hSender);

};

class CView: public CWindow {
public:

    HMENU   m_hMenu;

public:

    CView();

    virtual BOOL    Initialize     (void);

    // Activate/Deactivate code. Overload to update the toolbar,
    // menus.. etc.

    virtual BOOL    Activate       (BOOL fNewCreate =TRUE);
    virtual BOOL    Deactivate     (void);

    // Update: Tells the view that something in the database has
    // changed. It should update the screen if appropriate.

    virtual void    Update         (BOOL fNewCreate =TRUE);
};

//*****************************************************************************
//
// Support Class:   CGrabException
//
// Purpose:         Record the current exception handler, and compare against
//                  at a future date.
//
// Notes:           Practically speaking the class grabs the exception handler
//                  immediately when the application starts, and before the
//                  user has a chance to setup any exception handling. The
//                  assertion macro can then compare against the current value.
//                  if they're the same there's no exception handler, so hide
//                  the exception button. Otherwise throwing the exception will
//                  throw to the kernel's exception handler and crash the app.
//
// History
//
//  A-COWEN     Nov 7, 2000         Wrote it.
//
//*****************************************************************************

/*
class CGrabException {
private:

    PVOID m_pDefaultHandler;

public:

    CGrabException()
    {
        PVOID pCurrent;

        __asm
        {
            mov eax,fs:[0]
            mov pCurrent,eax
        }

        m_pDefaultHandler = pCurrent;
    }

    BOOL InHandler(void)
    {
        PVOID pCurrent;

        __asm
        {
            mov eax,fs:[0]
            mov pCurrent,eax
        }

        return(pCurrent == m_pDefaultHandler) ? FALSE:TRUE;
    }
};
*/
//*****************************************************************************
//
// Support macro:   assert_s, assert, ASSERT, ASSERT_S
//
// Purpose:         Updates the standard assert macro to provide additional
//                  debugging information.
//
// Notes:           For more information, see CompatAdmin.DOC
//
// History
//
//  A-COWEN     Nov 7, 2000         Wrote it.
//
//*****************************************************************************

#define ASSERT_BREAK    0
#define ASSERT_EXCEPT   1
#define ASSERT_ABORT    2
#define ASSERT_IGNORE   3

/*

int _ASSERT(int nLine, LPCTSTR szFile, LPCTSTR szCause, LPCTSTR szDesc);

#ifdef _DEBUG
    #define assert_s(x,y)   if (!(x))                                          \
                            {                                                  \
                                int nResult = _ASSERT(__LINE__,__FILE__,#x,y); \
                                                                               \
                                if (ASSERT_BREAK == nResult)                   \
                                    __asm {int 3};                             \
                                                                               \
                                if (ASSERT_EXCEPT == nResult)                  \
                                    throw;                                     \
                                                                               \
                                if (ASSERT_ABORT == nResult)                   \
                                    ExitProcess(-1);                           \
                            }

    #ifndef assert
        #define assert(x)   assert_s(x,TEXT(""))
    #endif  // assert

#else   // _DEBUG

    #define assert_s(x,y)

    #ifndef assert
        #define assert(x)   assert_s(x,TEXT(""))
    #endif  // assert

#endif  // _DEBUG

#define ASSERT(x)       assert(x)
#define ASSERT_S(x,y)   assert_s(x,y)

*/

//*****************************************************************************
//
// Support macro:   DPF
//
// Purpose:         Inline function implementation of a common macro, DPF.
//                  DPF stands for DebugPrintF. This implementation has a
//                  limit of 512 byte final constructed string, and will
//                  append a \n only if one doesn't already exist. Variable
//                  arguments are fully supported.
//
// Notes:           For more information, see CompatAdmin.DOC
//
// History
//
//  A-COWEN     Nov 8, 2000         Wrote it.
//
//*****************************************************************************

#ifndef DPF_LEVEL
    #define DPF_LEVEL   1
#endif

inline void _cdecl DPF(UINT nLevel, LPCTSTR szFormat, ...)
{

#ifdef NODPF

    if ( nLevel > g_uDPFLevel )
        return;

    TCHAR   szString[512];
    va_list list;

    va_start(list,szFormat);

    vsprintf(szString,szFormat,list);

    if ( TEXT('\n') != szString[::lstrlen(szString)-1] )
        lstrcat(szString,TEXT("\n"));

    ::OutputDebugString(szString);

#endif
}

//*****************************************************************************
//
// Support macro:   BEGIN_PROFILE/END_PROFILE
//
// Purpose:         Profile basic profiling macros for tracing performance
//                  problems. 
//
// Notes:           These macros are fully nestable. For each BEGIN_PROFILE,
//                  one of the END_PROFILE macros must be used.
//                  
//                  For more information, see CompatAdmin.DOC
//
// History
//
//  A-COWEN     Nov 8, 2000         Wrote it.
//
//*****************************************************************************

#ifndef PROFILE_DPF
    #define PROFILE_DPF   1
#endif

#ifndef NOPROFILE

    #define BEGIN_PROFILE(x)   {                                       \
                                LARGE_INTEGER   liStart;           \
                                LARGE_INTEGER   liStop;            \
                                LPTSTR          szProfileName = x; \
                                                                   \
                                QueryPerformanceCounter(&liStart);

    #define END_PROFILE             QueryPerformanceCounter(&liStop);  \
                                                                   \
                                LARGE_INTEGER   liFreq;            \
                                                                   \
                                QueryPerformanceFrequency(&liFreq);\
                                                                   \
                                DPF(g_uProfileDPFLevel,TEXT("Profile: %s (%d ticks, %f seconds)"),szProfileName,(int)(liStop.QuadPart - liStart.QuadPart),(float)(liStop.QuadPart - liStart.QuadPart)/(float)liFreq.QuadPart); \
                            }

#else

    #define BEGIN_PROFILE(x)
    #define END_PROFILE

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\appcompat\tools\compatadmin\clistview.cpp ===
#include "compatadmin.h"

#define LARGE_PAD   4
#define SMALL_PAD   (LARGE_PAD / 2)

HWND g_hWndLastFocus = NULL;
CListView::CListView()
{
    m_pList = NULL;
    m_pSelected = NULL;
    m_pCurrent;
    m_nEntries = 0;
    m_uCurrent = -1;
    m_uTop = 0;
    m_bHilight = FALSE;
    m_pFreeList = NULL;
}

CListView::~CListView()
{
    RemoveAllEntries();
}

BOOL CListView::AddEntry(CSTRING & szName, UINT uImage, PVOID pData)
{
    PLIST pNew;

    if ( NULL != m_pFreeList ) {
        pNew = m_pFreeList;
        m_pFreeList = m_pFreeList->pNext;
    } else {
        pNew = new LIST;

        if ( NULL == pNew )
            return FALSE;
    }

    //pNew->szText = szName;
    lstrcpyn(pNew->szText,szName,sizeof(pNew->szText) / sizeof(TCHAR));
    pNew->pNext = NULL;
    pNew->uImageIndex = uImage;
    pNew->pData = pData;

    PLIST pWalk = m_pList;
    PLIST pHold;

    //This code is for adding the node in a sorted fashion.
    while ( NULL != pWalk ) {
        if ( 0 > lstrcmp(szName.pszString,pWalk->szText ))
            break;

        pHold = pWalk;
        pWalk = pWalk->pNext;
    }

    if ( pWalk == m_pList ) {
        // Insert at head.

        pNew->pNext = m_pList; //NULL ?
        m_pList = pNew;
    } else {
        // Insert in place or at tail.

        pNew->pNext = pWalk;
        pHold->pNext = pNew;
    }

    ++m_nEntries;
    m_uCurrent = -1;

    // Adjust scrollbar

    SCROLLINFO  Info;

    Info.cbSize = sizeof(SCROLLINFO);
    Info.fMask = SIF_RANGE;
    Info.nMin = 0;
    Info.nMax = m_nEntries;

    SetScrollInfo(m_hWnd,SB_VERT,&Info,TRUE);

    return TRUE;
}

BOOL CListView::RemoveEntry(UINT uIndex)
{
    PLIST pWalk = m_pList;
    PLIST pHold;

    if ( NULL == m_pList )
        return FALSE;

    while ( NULL != pWalk && 0 != uIndex ) {
        --uIndex;
        pHold = pWalk;
        pWalk = pWalk->pNext;
    }

    if ( pWalk == m_pList )
        m_pList = m_pList->pNext;
    else
        pHold->pNext = pWalk->pNext;

    if ( pWalk == m_pSelected ) {
        m_pSelected = NULL;
        m_pCurrent = NULL;

        // Send the notification to the parent regarding
        // new selection.

        LISTVIEWNOTIFY  lvn;

        lvn.Hdr.hwndFrom = m_hWnd;
        lvn.Hdr.idFrom = 0;
        lvn.Hdr.code = LVN_SELCHANGED;
        lvn.pData = NULL;

        SendMessage(GetParent(m_hWnd),WM_NOTIFY,0,(LPARAM) &lvn);
    }

    pWalk->pNext = m_pFreeList;
    m_pFreeList  = pWalk;

    //delete pWalk;

    --m_nEntries;
    m_uCurrent = -1;

    // Adjust scrollbar

    SCROLLINFO  Info;

    Info.cbSize = sizeof(SCROLLINFO);
    Info.fMask = SIF_RANGE;
    Info.nMin = 0;
    Info.nMax = m_nEntries;

    SetScrollInfo(m_hWnd,SB_VERT,&Info,TRUE);

    return TRUE;
}

PLIST CListView::getSelected()
{
    return(this->m_pSelected);
}

BOOL CListView::RemoveAllEntries(void)
{
    while ( NULL != m_pList ) {
        PLIST pHold = m_pList->pNext;

        m_pList->pNext = m_pFreeList;
        m_pFreeList = m_pList;

        //delete m_pList;

        m_pList = pHold;
    }

    m_uCurrent = -1;
    m_nEntries = 0;
    m_uTop = 0;

    // Hide the scroll bar

    SCROLLINFO  Info;

    Info.cbSize = sizeof(SCROLLINFO);
    Info.fMask = SIF_RANGE;
    Info.nMin = 0;
    Info.nMax = 0;

    SetScrollInfo(m_hWnd,SB_VERT,&Info,TRUE);

    LISTVIEWNOTIFY  lvn;

    lvn.Hdr.hwndFrom = m_hWnd;
    lvn.Hdr.idFrom = 0;
    lvn.Hdr.code = LVN_SELCHANGED;
    lvn.pData = NULL;

    SendMessage(GetParent(m_hWnd),WM_NOTIFY,0,(LPARAM) &lvn);

    return TRUE;
}

UINT CListView::GetNumEntries(void)
{
    return m_nEntries;
}

CSTRING CListView::GetEntryName(UINT uIndex)
{
    if ( !FindEntry(uIndex) )
        return CSTRING(TEXT(""));

    return m_pCurrent->szText;
}

UINT CListView::GetEntryImage(UINT uIndex)
{
    if ( !FindEntry(uIndex) )
        return -1;

    return m_pCurrent->uImageIndex;
}

PVOID CListView::GetEntryData(UINT uIndex)
{
    if ( !FindEntry(uIndex) )
        return NULL;

    return m_pCurrent->pData;
}

UINT CListView::GetSelectedEntry(void)
{
    PLIST pWalk = m_pList;
    UINT  uIndex = 0;

    while ( NULL != pWalk ) {
        //K if (pWalk == m_pSelected)
        if ( pWalk == m_pSelected )
            return uIndex;

        ++uIndex;
        pWalk = pWalk->pNext;
    }

    return -1;
}

BOOL CListView::FindEntry(UINT uIndex)
{
    PLIST pWalk = m_pList;

    if ( m_uCurrent > m_nEntries )
        m_uCurrent = -1;

    if ( m_uCurrent == uIndex )
        return TRUE;

    while ( NULL != pWalk && 0 != uIndex ) {
        --uIndex;
        pWalk = pWalk->pNext;
    }

    if ( NULL == pWalk )
        return FALSE;

    m_uCurrent = uIndex;

    m_pCurrent = pWalk;

    return TRUE;
}

void CListView::msgCreate(void)
{
    HDC hDC = GetDC(NULL);

    // Create fonts we're going to use

    m_hCaptionFont = CreateFont(-MulDiv(9, GetDeviceCaps(hDC, LOGPIXELSY), 72),
                                0,
                                0,0,
                                FW_BOLD,
                                FALSE,
                                FALSE,
                                FALSE,
                                DEFAULT_CHARSET,
                                OUT_DEFAULT_PRECIS,
                                CLIP_DEFAULT_PRECIS,
                                DEFAULT_QUALITY,
                                DEFAULT_PITCH | FF_SWISS,
                                NULL);

    m_hListFont = CreateFont(   -MulDiv(8, GetDeviceCaps(hDC, LOGPIXELSY), 72),
                                0,
                                0,0,
                                FW_THIN,
                                FALSE,
                                FALSE,
                                FALSE,
                                DEFAULT_CHARSET,
                                OUT_DEFAULT_PRECIS,
                                CLIP_DEFAULT_PRECIS,
                                DEFAULT_QUALITY,
                                DEFAULT_PITCH | FF_SWISS,
                                NULL);

    // Create pens

    m_hLinePen = (HPEN) GetStockObject(DC_PEN);
    SetDCPenColor(hDC,RGB(00,00,0xff));


    // Create brushes

    m_hGrayBrush = GetSysColorBrush(COLOR_INACTIVECAPTION);

    m_hWindowBrush = GetSysColorBrush(COLOR_WINDOW);

    //m_hWindowBrush = CreateSolidBrush(RGB(255,255,176));

    m_hSelectedBrush = GetSysColorBrush(COLOR_HIGHLIGHT);

    // Release the DC

    ReleaseDC(NULL,hDC);
}

void CListView::msgPaint(HDC hWindowDC)
{
    RECT    rRect;

    GetClientRect(m_hWnd,&rRect);

    // Update the scroll bar

    SCROLLINFO  Info;

    Info.cbSize = sizeof(SCROLLINFO);
    Info.fMask = SIF_POS | SIF_TRACKPOS | SIF_RANGE;
    Info.nPos = m_uTop;
    Info.nTrackPos = m_uTop;
    Info.nMin = 0;
    Info.nMax = m_nEntries;

    SetScrollInfo(m_hWnd,SB_VERT,&Info,TRUE);

    // Create a working DC

    HDC     hDC = CreateCompatibleDC(hWindowDC);
    HBITMAP hBmp = CreateCompatibleBitmap(hWindowDC,rRect.right,rRect.bottom);
    HBITMAP hBmpOld;

    hBmpOld = (HBITMAP) SelectObject(hDC,hBmp);

    // Erase the background

    FillRect(hDC,&rRect,m_hWindowBrush);

    // Render the caption

    RECT    rCaptionRect = rRect;
    TCHAR   szCaption[MAX_PATH_BUFFSIZE];
    SIZE    CaptionSize;

    GetWindowText(m_hWnd,szCaption,sizeof(szCaption)/sizeof(TCHAR));

    
    SelectObject(hDC,m_hCaptionFont);

    GetTextExtentPoint32(hDC,szCaption,lstrlen(szCaption),&CaptionSize);

    rCaptionRect.bottom = CaptionSize.cy + LARGE_PAD;

    m_uCaptionBottom = rCaptionRect.bottom + SMALL_PAD;

    if ( m_hWnd == GetFocus() )
        FillRect(hDC,&rCaptionRect,GetSysColorBrush(COLOR_ACTIVECAPTION));
    else
        FillRect(hDC,&rCaptionRect,GetSysColorBrush(COLOR_INACTIVECAPTION));

    SetTextColor(hDC,GetSysColor(COLOR_CAPTIONTEXT));

    SetBkMode(hDC,TRANSPARENT);

    ExtTextOut( hDC,
                rCaptionRect.left + 15,
                rCaptionRect.top + 3,
                ETO_CLIPPED,
                &rCaptionRect,
                szCaption,
                lstrlen(szCaption),
                NULL);

    MoveToEx(hDC,rCaptionRect.left,rCaptionRect.bottom,NULL);
    

    SelectObject(hDC,GetStockObject(DC_PEN));

    SetDCPenColor(hDC,GetSysColor(COLOR_BTNFACE));

    LineTo(hDC,rCaptionRect.right,rCaptionRect.bottom);

    // Render the list of items.

    PLIST   pWalk = m_pList;
    SIZE    TextSize;
    UINT    uTop = rCaptionRect.bottom + SMALL_PAD;
    RECT    rText;
    UINT    uCount=0;

    // Determine the count so we know background color

    while ( NULL != pWalk && uCount != m_uTop ) {
        ++uCount;
        pWalk = pWalk->pNext;
    }

    // Set the fonts

    SelectObject(hDC,m_hListFont);
    SelectObject(hDC,m_hLinePen);

    // Compute page size

    GetTextExtentPoint32(hDC,TEXT("Wxypq"),5,&TextSize);

    m_uTextHeight = TextSize.cy + LARGE_PAD;

    m_uPageSize = (rRect.bottom - rCaptionRect.bottom) / (m_uTextHeight + SMALL_PAD);

    // Draw the actual items.

    while ( NULL != pWalk ) {
        LPTSTR  szText =  pWalk->szText;
        UINT    uLen = lstrlen(pWalk->szText); //.Length();
        HBRUSH  hBrush;

        // Select background and foreground colors

        if ( 0 == (uCount % 2) )
            // hBrush = m_hGrayBrush;
            hBrush = m_hWindowBrush;

        else
            hBrush = m_hWindowBrush;

        /*Here we decide whether the selected item has to be shown as, highlighted 
        or not*/


        if ( m_pSelected == pWalk )
            if ( m_hWnd == GetFocus() )
                hBrush = m_hSelectedBrush;
            else
                hBrush =  m_hGrayBrush;


        ++uCount;

        // Compute rects

        SetRect(&rText,rRect.left,uTop,rRect.right,uTop + m_uTextHeight);

        // Set the colors

        

        FillRect(hDC,&rText,hBrush);


        // Draw the image.


        /*SelectObject(hDC, GetStockObject(DC_BRUSH));
        SetDCBrushColor(hDC,RGB(0,200,0));
        

        Ellipse(hDC, rText.left+5,rText.top, rText.left+15,rText.top + 10);
        */

        //10 dia.

        if ( m_pSelected == pWalk ) {

            SetTextColor(hDC,GetSysColor(COLOR_HIGHLIGHTTEXT));

        } else{
            
            SetTextColor(hDC,0);
            
        }
            
       // Draw the text

        ExtTextOut( hDC,
                    rText.left + 20,
                    rText.top + SMALL_PAD,
                    ETO_CLIPPED,
                    &rText,
                    szText,
                    uLen,
                    NULL);

        // Draw separator line

        MoveToEx(hDC,rText.left,rText.bottom-1,NULL);
        LineTo(hDC,rText.right,rText.bottom-1);

        uTop += m_uTextHeight;

        if ( uTop > (UINT)rRect.bottom )
            break;

        pWalk = pWalk->pNext;
    }//while ( NULL != pWalk )

    // Blit the working surface to the window

    BitBlt( hWindowDC,
            0,0,
            rRect.right,rRect.bottom,
            hDC,
            0,0,
            SRCCOPY);

    // Release the working DC

    SelectObject(hDC,hBmpOld);
    DeleteDC(hDC);
    DeleteObject(hBmp);
}

void CListView::ShowHilight(BOOL bHilight)
{
    /*
    At one time either the m_bHilihgt of the Globallist (CDBView:m_GlobalList)
    or the   local list  (CDBView:m_LocalList)  would be on. ShowHilight would
    therefore be always be called in pair, one TRUE and another FALSE.
    
    When the msgPaint of the ListView gets called because of ListView:Refresh, then 
    depending upon, whether the bHilight is TRUE or FALSE; a *  is drawn alongwith
    the caption  for the window.
    
    */

    m_bHilight = bHilight;

    Refresh();
}

void CListView::msgEraseBackground(HDC hDC)
{
    // Do nothing. msgPaint will handle the entire window.
}

void CListView::msgChar(TCHAR chChar)
{
    
    PLIST   pWalk = m_pList;
    UINT    uCount = 0;

    chChar = (TCHAR) toupper(chChar);

    while ( NULL != pWalk ) {
        TCHAR chUpper = (TCHAR) toupper(((LPCTSTR)pWalk->szText)[0]);

        if ( chUpper == chChar )
            break;

        ++uCount;

        pWalk = pWalk->pNext;
    }

    if ( uCount != m_nEntries )
        m_uTop = uCount;

    if ( NULL != pWalk ) {
        m_pCurrent = pWalk;

        m_uCurrent = m_uTop;

        m_pSelected = m_pCurrent;

        // Send the notification to the parent regarding
        // new selection.

        LISTVIEWNOTIFY  lvn;

        lvn.Hdr.hwndFrom = m_hWnd;
        lvn.Hdr.idFrom = 0;
        lvn.Hdr.code = LVN_SELCHANGED;
        lvn.pData = m_pCurrent->pData;

        SendMessage(GetParent(m_hWnd),WM_NOTIFY,0,(LPARAM) &lvn);
    }

    Refresh();
}

LRESULT CListView::MsgProc(UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    switch ( uMsg ) {
    case    WM_LBUTTONDOWN:
        {
            UINT uY = HIWORD(lParam);

            SetFocus(m_hWnd);

            NMHDR Hdr;

            Hdr.hwndFrom = m_hWnd;
            Hdr.idFrom = 0;
            Hdr.code = NM_SETFOCUS;

            SendMessage(GetParent(m_hWnd),WM_NOTIFY,0,(LPARAM) &Hdr);

            // On the caption? Nothing to do then.

            if ( uY < m_uCaptionBottom )
                break;

            uY = m_uTop + (((uY - m_uCaptionBottom) / m_uTextHeight));

            m_uCurrent = -1;

            if ( FindEntry(uY) ) {
                m_pSelected = m_pCurrent;

                // Send the notification to the parent regarding
                // new selection.

                LISTVIEWNOTIFY  lvn;

                lvn.Hdr.hwndFrom = m_hWnd;
                lvn.Hdr.idFrom = 0;
                lvn.Hdr.code = LVN_SELCHANGED;
                lvn.pData = m_pCurrent->pData;

                SendMessage(GetParent(m_hWnd),WM_NOTIFY,0,(LPARAM) &lvn);

                // Redraw the list view with the new selection.

                Refresh();
            }

            m_uCurrent = uY;
        }
        break;

    case    WM_SETFOCUS:
        {
            NMHDR Hdr;

            Hdr.hwndFrom = m_hWnd;
            Hdr.idFrom = 0;
            Hdr.code = NM_SETFOCUS;

            SendMessage(GetParent(m_hWnd),WM_NOTIFY,0,(LPARAM) &Hdr);
            Refresh();
            break;


        }

    case    WM_KILLFOCUS:
        {
            g_hWndLastFocus = this->m_hWnd;


            Refresh();
        }
        break;

    case    WM_KEYDOWN:
        {
            BOOL    bSnap = FALSE;

            switch ( wParam ) {
            case    VK_TAB:
                {
                    NMKEY Key;

                    Key.hdr.hwndFrom = m_hWnd;
                    Key.hdr.idFrom = 0;
                    Key.hdr.code = NM_KEYDOWN;
                    Key.nVKey = VK_TAB;

                    SendMessage(GetParent(m_hWnd),WM_NOTIFY,0,(LPARAM) &Key);
                }
                break;

            case    VK_HOME:
                {
                    m_uCurrent = 0;

                    bSnap = TRUE;
                }
                break;

            case    VK_END:
                {
                    m_uCurrent = m_nEntries-1;

                    bSnap = TRUE;
                }
                break;
            case    VK_PRIOR:
                {
                    if ( m_uCurrent > m_uPageSize )
                        m_uCurrent -= m_uPageSize;
                    else
                        m_uCurrent = 0;

                    bSnap = TRUE;
                }
                break;
            case    VK_NEXT:
                {
                    if ( m_uCurrent + m_uPageSize < m_nEntries )
                        m_uCurrent += m_uPageSize;

                    bSnap = TRUE;
                }
                break;
            case    VK_UP:
                {
                    if ( m_uCurrent > 0 )
                        --m_uCurrent;

                    bSnap = TRUE;
                }
                break;

            case    VK_DOWN:
                {
                    if ( m_uCurrent < m_nEntries )
                        ++m_uCurrent;

                    bSnap = TRUE;
                }
                break;
            }


            if ( bSnap ) {
                if ( (int)m_uCurrent >= 0 ) {
                    while ( (int)m_uTop >= (int)m_uCurrent )
                        m_uTop -= m_uPageSize;

                    if ( (int)m_uTop < 0 )
                        m_uTop = 0;

                    while ( m_uTop + m_uPageSize <= m_uCurrent )
                        m_uTop += m_uPageSize;
                } else
                    m_uCurrent = 0;

                UINT uHold = m_uCurrent;

                m_uCurrent = -1;

                if ( FindEntry(uHold) ) {
                    m_pSelected = m_pCurrent;

                    // Send the notification to the parent regarding
                    // new selection.

                    LISTVIEWNOTIFY  lvn;

                    lvn.Hdr.hwndFrom = m_hWnd;
                    lvn.Hdr.idFrom = 0;
                    lvn.Hdr.code = LVN_SELCHANGED;
                    lvn.pData = m_pCurrent->pData;

                    SendMessage(GetParent(m_hWnd),WM_NOTIFY,0,(LPARAM) &lvn);
                }

                m_uCurrent = uHold;

                Refresh();
            }
        }
        break;

    case    WM_ACTIVATE:
        {
            if ( WA_INACTIVE != wParam )
                SetFocus(m_hWnd);
        }
        break;

    case    WM_VSCROLL:
        {
            switch ( LOWORD(wParam) ) {
            case    SB_THUMBPOSITION:
            case    SB_THUMBTRACK:
                {
                    m_uTop = HIWORD(wParam);
                }
                break;

            case    SB_PAGEUP:
                {
                    if ( m_uTop > m_uPageSize )
                        m_uTop -= m_uPageSize;
                    else
                        m_uTop = 0;
                }
                break;

            case    SB_PAGEDOWN:
                {
                    if ( m_uTop + m_uPageSize < m_nEntries )
                        m_uTop += m_uPageSize;
                }
                break;

            case    SB_LINEUP:
                {
                    if ( m_uTop > 0 )
                        --m_uTop;
                }
                break;

            case    SB_LINEDOWN:
                {
                    if ( m_uTop < m_nEntries )
                        if ( m_uTop + m_uPageSize < m_nEntries )
                            ++m_uTop;
                }
                break;
            }

            Refresh();
        }
        break;
    }

    return CWindow::MsgProc(uMsg,wParam,lParam);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\appcompat\tools\compatadmin\cview.cpp ===
#include "compatadmin.h"

CView::CView()
{
    m_hMenu = NULL;
}

BOOL CView::Initialize(void)
{
    return TRUE;
}

BOOL CView::Activate(BOOL fNewCreate)
{
    // If there's a custom menu with this view, set it.

    if (NULL != m_hMenu)
        SetMenu(g_theApp.m_hWnd,m_hMenu);
    else
        SetMenu(g_theApp.m_hWnd,g_theApp.m_hMenu);

    // Perform additional initialization here. For instance, adding buttons
    // to the toolbar.

    return TRUE;
}

BOOL CView::Deactivate(void)
{
    // Perform any cleanup required here. For instance, remove any custom entries
    // from the toolbar.

    return TRUE;
}

void CView::Update(BOOL fNewCreate)
{
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\appcompat\tools\compatadmin\controls.h ===
UINT GetRadioStatus(HWND hDlg, UINT uiId);
UINT SetRadioStatus(HWND hDlg, UINT uiId, UINT uiStatus);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\appcompat\tools\compatadmin\cwindow.cpp ===
#include "compatadmin.h"


BOOL CWindow::Create(
                    LPCTSTR      szClassName,
                    LPCTSTR      szWindowTitle,
                    int         nX,
                    int         nY,
                    int         nWidth,
                    int         nHeight,
                    CWindow   * pParent,
                    HMENU       nMenuID,
                    DWORD       dwExFlags,
                    DWORD       dwFlags)
{
    HWND    hParent = NULL;
    HMENU   hMenu = LoadMenu(g_hInstance,MAKEINTRESOURCE(nMenuID));
    int     nTries = 0;

    if ( NULL == hMenu )
        hMenu =  nMenuID;

    if ( NULL != pParent )
        hParent = pParent->m_hWnd;

    do {
        // Attempt to create the window as provided to the class.
        // If this fails that means that the window class does not exist and we have to make a new window
        //class


        m_hWnd = ::CreateWindowEx(  dwExFlags,
                                    szClassName,
                                    szWindowTitle,
                                    dwFlags,
                                    nX,
                                    nY,
                                    nWidth,
                                    nHeight,
                                    hParent,
                                    hMenu,
                                    g_hInstance,
                                    this);// This is the window-creation application data

        // Failed?

        if ( NULL == m_hWnd ) {
            // If the creation failed, register the class
            // and try again. 

            WNDCLASS    wc;

            ZeroMemory(&wc,sizeof(wc));

            wc.style            = CS_DBLCLKS;
            wc.lpfnWndProc      = MsgProc;
            wc.hInstance        = g_hInstance;
            wc.hIcon            = ::LoadIcon(g_hInstance,MAKEINTRESOURCE(IDI_COMPATADMIN));
            wc.hCursor          = ::LoadCursor(g_hInstance,TEXT("AppCursor"));

            if ( NULL == wc.hCursor )
                wc.hCursor          = ::LoadCursor(NULL,IDC_ARROW);

            wc.hbrBackground    = (HBRUSH) (COLOR_WINDOW + 1);
            wc.lpszClassName    = szClassName;

            // If the registration failed, it's probably already
            // registered. Failure is then severe enough to fail
            // the call immediately.

            if ( 0 == ::RegisterClass(&wc)){
            
                MessageBox(NULL,TEXT("This program needs an operating system with UNICODE support to execute properly !"),TEXT("Error"),MB_ICONERROR);
                return FALSE;
            }
        }

        ++nTries;
    }
    while ( NULL == m_hWnd && 1 >= nTries );

    return(NULL == m_hWnd) ? FALSE:TRUE;
}

void CWindow::Refresh(void)
{
    InvalidateRect(m_hWnd,NULL,TRUE);
    UpdateWindow(m_hWnd);
}

void CWindow::msgCommand(UINT uID,HWND hSender)
{
}

void CWindow::msgCreate(void)
{
}

void CWindow::msgClose(void)
{
}

void CWindow::msgResize(UINT uWidth, UINT uHeight)
{
}

void CWindow::msgPaint(HDC hDC)
{
}

void CWindow::msgEraseBackground(HDC hDC)
{
    RECT    rRect;

    GetClientRect(m_hWnd,&rRect);

    ++rRect.right;
    ++rRect.bottom;

    FillRect(hDC,&rRect,(HBRUSH) (COLOR_WINDOW + 1));
}

void CWindow::msgChar(TCHAR chChar)
{
}

void CWindow::msgNotify(LPNMHDR pHdr)
{
}

LRESULT CWindow::MsgProc(
                        UINT        uMsg,
                        WPARAM      wParam,
                        LPARAM      lParam)
{
    switch ( uMsg ) {
    

    case    WM_KEYDOWN:
        {
        }
        break;

    case    WM_CHAR:
        {
            msgChar((TCHAR)wParam);
        }
        break;

    case    WM_CREATE:
        {
            msgCreate();
        }
        break;

    case    WM_CLOSE:
        {
            msgClose();
        }
        break;

    case    WM_COMMAND:
        {
            msgCommand(LOWORD(wParam),(HWND)lParam);
        }
        break;

    case    WM_NOTIFY:
        {
            msgNotify((LPNMHDR) lParam);
        }
        break;

    case    WM_PAINT:
        {
            HDC         hDC;
            PAINTSTRUCT ps;
            int         nSave;

            hDC = ::BeginPaint(m_hWnd,&ps);

            nSave = SaveDC(hDC);

            msgPaint(hDC);

            RestoreDC(hDC,nSave);

            ::EndPaint(m_hWnd,&ps);
        }
        break;

    case    WM_ERASEBKGND:
        {
            HDC hDC = (HDC) wParam;

            msgEraseBackground(hDC);
        }
        return 1;

    case    WM_SIZE:
        {
            UINT uWidth = LOWORD(lParam);
            UINT uHeight = HIWORD(lParam);

            msgResize(uWidth,uHeight);
        }
        break;

    default:
        return DefWindowProc(m_hWnd,uMsg,wParam,lParam);
    }

    return 0;
}

//RTTI needed.

LRESULT CALLBACK CWindow::MsgProc(
                                 HWND hWnd, 
                                 UINT uMsg, 
                                 WPARAM wParam, 
                                 LPARAM lParam)
{
    CWindow * pWnd;

    // Wrap this in a try-except. If we assert inside the window proc,
    // RTTI may throw instead of return NULL.

    __try
    {
        pWnd = dynamic_cast<CWindow *> ((CWindow *)GetWindowLongPtr(hWnd,GWLP_USERDATA));
    }
    __except(1)
    {
        pWnd = NULL;
    }

    // If the window is being created, record the "this" pointer with the window.

    if ( WM_CREATE == uMsg ) {
        LPCREATESTRUCT  lpCS = (LPCREATESTRUCT) lParam;

        pWnd = dynamic_cast<CWindow *> ((CWindow *) lpCS->lpCreateParams);

        assert(NULL != pWnd);//TEXT("CreateWindow was called on a class owned by CWindow outside of CWindow::Create()"));

        // Write the class pointer.

        if ( NULL != pWnd ) {
            pWnd->m_hWnd = hWnd;

            ::SetWindowLongPtr(hWnd,GWLP_USERDATA,(LONG_PTR) pWnd);
        } else {
            // Critical failure. CreateWindow was called on a class that we
            // own, but wasn't called through the class. Fail the create call.

            return -1;
        }
    }

    assert(((CWindow *) GetWindowLongPtr(hWnd,GWLP_USERDATA)) == pWnd);//,TEXT("GetWindowLongPtr data has been corrupted"));

    // Dispatch the message to the class based window proc

    if ( NULL != pWnd )
        return pWnd->MsgProc(uMsg,wParam,lParam);

    // The window hasn't recorded the class "this" pointer yet. So,
    // perform default processing on the message.

    return DefWindowProc(hWnd,uMsg,wParam,lParam);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\appcompat\tools\compatadmin\customlayer.h ===
enum
{
    LAYERMODE_ADD=0,
    LAYERMODE_EDIT,
    LAYERMODE_COPY,
    LAYERMODE_REMOVE,
};

class CCustomLayer
{
    public:

        UINT    m_uMode;
        HWND hDlg;

    public:

        BOOL AddCustomLayer(void);
        BOOL EditCustomLayer(void);
        BOOL RemoveCustomLayer(void);
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\appcompat\tools\compatadmin\dbdatastructures.h ===
// Database access structures


typedef enum SHIMTYPE {
    SHIMTYPE_SHIM=0,
    SHIMTYPE_PATCH,
    SHIMTYPE_FORCEDWORD=0xFFFFFFFF
} SHIMTYPE;

typedef enum SHIMPURPOSE {
    SHIMPURPOSE_GENERAL=0,
    SHIMPURPOSE_APPSPECIFIC,
    SHIMPURPOSE_FORCEDWORD=0xFFFFFFFF
} SHIMPURPOSE;

typedef struct _tagAPPHELP{

    struct _tagAPPHELP *pNext;

    CSTRING  strMsgName;
    CSTRING  strMessage;
    CSTRING  strURL;
    UINT     HTMLHELPID;
    BOOL     bBlock;   
} APPHELP, * PAPPHELP;


typedef struct _tagDBE {
    UINT                uType;
    UINT                uIconID;
    struct _tagDBE    * pNext;
} DBENTRY, *PDBENTRY;

typedef struct _tagShim {
    CSTRING             szShimName;
    CSTRING             szShimDLLName;
    CSTRING             szShimCommandLine;
    CSTRING             szShimDesc;
    BOOL                bShim;              // TRUE if shim, FALSE if patch.
    BOOL                bGeneral;
    struct _tagShim   * pNext;

public:

    _tagShim()
    {
        szShimName.Init();
        szShimDLLName.Init();
        szShimCommandLine.Init();
        szShimDesc.Init();
        pNext = NULL;
    }

    ~_tagShim()
    {
        szShimName.Release();
        szShimDLLName.Release();
        szShimCommandLine.Release();
        szShimDesc.Release();
    }

    void operator = (_tagShim Old)
    {
        szShimName = Old.szShimName;
        szShimDLLName = Old.szShimDLLName;
        szShimCommandLine = Old.szShimCommandLine;
        szShimDesc = Old.szShimDesc;
        bShim = Old.bShim;
        bGeneral = Old.bGeneral;
    }

} SHIMDESC, *PSHIMDESC;



typedef struct _shimEntry {
    DBENTRY     Entry;
    CSTRING     szShimName;
    CSTRING     szCmdLine;
    PSHIMDESC   pDesc;

public:

    _shimEntry()
    {
        szShimName.Init();
        szCmdLine.Init();
        pDesc = NULL;
    }

    ~_shimEntry()
    {
        szShimName.Release();
        szCmdLine.Release();
    }

} SHIMENTRY, *PSHIMENTRY;

typedef struct {
    DBENTRY     Entry;
    UINT        uSeverity;
    BOOL        bBlock;

    UINT        uHelpID;
    CSTRING     strMessageName; //Not used at the moment
    CSTRING     strURL;


} HELPENTRY, *PHELPENTRY;



typedef struct tagMatchEntry{
    DBENTRY         Entry;
    CSTRING         szMatchName;
    CSTRING         szFullName;
    DWORD           dwSize;
    DWORD           dwChecksum;
    LARGE_INTEGER   FileVersion;
    LARGE_INTEGER   ProductVersion;
    CSTRING         szCompanyName;
    CSTRING         szDescription;
    CSTRING         szFileVersion;
    CSTRING         szProductVersion;

    BOOL operator == (struct tagMatchEntry &val)
    {
        BOOL b1 = this->szCompanyName           == val.szCompanyName,
             b2 = this->szDescription           == val.szDescription,
             b3 = this->szFileVersion           == val.szFileVersion,
             
             b4 = this->szMatchName             == val.szMatchName,
             b5= this->szProductVersion        == val.szProductVersion,
             b6 = this->FileVersion.QuadPart    == val.FileVersion.QuadPart, 
             b7 = this->ProductVersion.QuadPart == val.ProductVersion.QuadPart;

        
        return ( this->dwChecksum       == val.dwChecksum              &&  
                 this->dwSize           == val.dwSize                  &&  
                 b1 &&
                 b2 &&
                 b3 &&
                 b4 &&
                 b5 &&
                 b6 &&
                 b7 
               
                             
                 );
    }

} MATCHENTRY, *PMATCHENTRY, **PPMATCHENTRY;

typedef struct _tagLAYER {
    CSTRING             szLayerName;
    BOOL                bPermanent;
    PSHIMDESC           pShimList;
    struct _tagLAYER  * pNext;
} DBLAYER, *PDBLAYER;


typedef struct _tagDBR {
    CSTRING             szEXEName;
    CSTRING             szAppName;
    CSTRING             szLayerName;
    GUID                guidID;
    DWORD               dwUserFlags;
    DWORD               dwGlobalFlags;
    UINT                uLayer;
    BOOL                bGlobal;
    PDBENTRY            pEntries;
    struct _tagDBR    * pNext;
    struct _tagDBR    * pDup;

    _tagDBR()
    {
        szEXEName.Init();
        szAppName.Init();
        szLayerName.Init();
        pNext = NULL;
        pDup = NULL;
    }

    ~_tagDBR()
    {
        szEXEName.Release();
        szAppName.Release();
        szLayerName.Release();
    }
    void DestroyAll()
    {
        //TODO: Implement this function.;

    }

} DBRECORD, *PDBRECORD;


enum {
    LAYER_APPHELP=1,
    LAYER_FORCEDWORD=0xFFFFFFFF
};

enum {
    ENTRY_SHIM=1,
    ENTRY_MATCH,
    ENTRY_APPHELP,
    ENTRY_UI,
    ENTRY_SUBMATCH,
    ENTRY_FORCEDWORD=0xFFFFFFFF
};

enum {
    MATCH_NAME=0,
    MATCH_SIZE,
    MATCH_CHECKSUM,
    MATCH_FILEVERSION,
    MATCH_PRODUCTVERSION,
    MATCH_COMPANY,
    MATCH_DESCRIPTION,
    MATCH_FILEVERSTRING,
    MATCH_PRODUCTVERSTRING,
    MATCH_FORCEDWORD=0xFFFFFFFF
};


#define DELRES_FAILED           0
#define DELRES_RECORDREMOVED    1
#define DELRES_DUPREMOVED       2

BOOL CALLBACK NewDatabaseProc(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\appcompat\tools\compatadmin\customlayer.cpp ===
//#define __DEBUG

#include "compatadmin.h"
#include "customlayer.h"

BOOL CALLBACK CustomLayerProc(HWND hDlg, UINT uMsg, WPARAM wParam, LPARAM lParam);
BOOL CALLBACK EditLayerProc(HWND hDlg, UINT uMsg, WPARAM wParam, LPARAM lParam);

BOOL CheckExistingLayer(CSTRING & szNewLayerName);

PDBLAYER        g_pLayer;
CCustomLayer  * g_pCustomLayer;

BOOL CCustomLayer::AddCustomLayer(void)
{
    g_pLayer = NULL;
    g_pCustomLayer = this;

    m_uMode = LAYERMODE_ADD;

    if ( TRUE == DialogBox(g_hInstance,MAKEINTRESOURCE(IDD_CUSTOMLAYER),g_theApp.m_hWnd,(DLGPROC)CustomLayerProc) )
        return TRUE;

    return FALSE;
}

BOOL CCustomLayer::EditCustomLayer(void)
{
    g_pLayer = NULL;

    /*
    
    
    
    */

    g_pCustomLayer = this;

    m_uMode = LAYERMODE_EDIT;

    if ( TRUE == DialogBoxParam(g_hInstance,MAKEINTRESOURCE(IDD_SELECTLAYER),g_theApp.m_hWnd,(DLGPROC)EditLayerProc,FALSE) ) {
        if ( TRUE == DialogBox(g_hInstance,MAKEINTRESOURCE(IDD_CUSTOMLAYER),g_theApp.m_hWnd,(DLGPROC)CustomLayerProc) )
            return TRUE;
    }

    return FALSE;
}

BOOL CCustomLayer::RemoveCustomLayer(void)
{
    g_pLayer = NULL;
    g_pCustomLayer = this;

    m_uMode = LAYERMODE_REMOVE;

    if ( TRUE == DialogBoxParam(g_hInstance,MAKEINTRESOURCE(IDD_SELECTLAYER),g_theApp.m_hWnd,(DLGPROC)EditLayerProc,FALSE) ) {
        PDBLAYER pWalk = g_theApp.GetDBLocal().m_pLayerList;
        PDBLAYER pHold;
        PDBRECORD   pRec = g_theApp.GetDBLocal().m_pRecordHead;

        // Validate the layer to remove.

        //g_pLayer has been properly set in the EditLayerProc  function. Now it's not NULL

        while ( NULL != pRec ) {
            BOOL bInUse = FALSE;

            if ( (g_pLayer != NULL ) && (pRec->szLayerName == g_pLayer->szLayerName) ) //PREfast
                bInUse = TRUE;

            PDBRECORD pDups = pRec->pDup;

            while ( NULL != pDups ) {
                if ( (g_pLayer != NULL) && (pDups->szLayerName == g_pLayer->szLayerName) ) // PREfast !
                    bInUse = TRUE;

                pDups = pDups->pDup;
            }

            if ( bInUse ) {
                MessageBox(g_theApp.m_hWnd,TEXT("Cannot remove custom layer while it's in use"),TEXT("Unable to remove custom layer"),MB_OK);
                return FALSE;
            }

            pRec = pRec->pNext;
        }

        while ( NULL != pWalk ) {
            if ( g_pLayer == pWalk ) {
                if ( pWalk == g_theApp.GetDBLocal().m_pLayerList )
                    g_theApp.GetDBLocal().m_pLayerList = pWalk->pNext;
                else
                    pHold->pNext = pWalk->pNext;

                delete pWalk;

                return TRUE;
            }

            pHold = pWalk;
            pWalk = pWalk->pNext;
        }
    }

    return FALSE;
}

void SyncList(HWND hDlg, UINT uMaster, UINT uSlave)

//For all those strings that appear in uMaster, remove them from uSlave

// For ADD:  the params passed are IDC_LAYERLIST,IDC_SHIMLIST
//For REMOVE: SyncList(hDlg,IDC_SHIMLIST,IDC_LAYERLIST);
{
    UINT    uTotal = SendDlgItemMessage(hDlg,uMaster,LB_GETCOUNT,0,0);
    UINT    uCount;
    TCHAR   szText[1024];

    for ( uCount=0; uCount<uTotal; ++uCount ) {
        int nIndex;

        SendDlgItemMessage(hDlg,uMaster,LB_GETTEXT,uCount,(LPARAM) szText);

        nIndex = SendDlgItemMessage(hDlg,uSlave,LB_FINDSTRING,0,(LPARAM) szText);


        //The DONE button might need to be disabled if there are no items in the IDC_LAYERLIST (2nd list box)
        if ( LB_ERR != nIndex )
            SendDlgItemMessage(hDlg,uSlave,LB_DELETESTRING,nIndex,0);


    }

    SendMessage(hDlg,WM_COMMAND,MAKELONG(IDC_NAME,EN_UPDATE),0);
}

BOOL CALLBACK CustomLayerProc(HWND hDlg, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    
    static BOOL bNameChanged = FALSE;// Did the user change the name of the layer
    static CSTRING szPresentLayerName; // The IDC_NAME when the WM_INITDIALOG is called

    /*
    
    This is ued when we are editing a layer.
    Suppose we change the name of the layer then, we have to make this name change in the DBRECORD::szLayerName
    for all those EXEs which have this  layer in the present database
    
    */


    /*
    With all the items in the Listbox IDC_SHIMLIST (The first list box), in the data section we have the
    pointer to the corresponding SHIMDESC in the g_theApp.m_pShimList (The list of shims,populated from the sysmain.sdb
    
    Only GENERAL shims are shown in the list.
    */

    switch ( uMsg ) {
    case    WM_INITDIALOG:
        {
                            
            
            SendMessage( 
                GetDlgItem(hDlg,IDC_NAME),              // handle to destination window 
                EM_LIMITTEXT,             // message to send
                (WPARAM) 150,          // text length
                (LPARAM) 0
                );


            if (g_pLayer != NULL ) {
                
                szPresentLayerName = g_pLayer->szLayerName ;

            }
            else {

                szPresentLayerName = NULL;
                bNameChanged = FALSE;

            }



            
            PSHIMDESC pWalk = g_theApp.GetDBGlobal().m_pShimList;

            while ( NULL != pWalk ) {
                if ( pWalk->bGeneral ) {
                    //int nItem = SendDlgItemMessage(hDlg,IDC_SHIMLIST,LB_ADDSTRING,0,(LPARAM) (LPSTR) (pWalk->szShimName));
                    int nItem = SendDlgItemMessage(hDlg,IDC_SHIMLIST,LB_ADDSTRING,0,(LPARAM)  (pWalk->szShimName).pszString);

                    if ( LB_ERR != nItem )
                        SendDlgItemMessage(hDlg,IDC_SHIMLIST,LB_SETITEMDATA,nItem,(LPARAM) pWalk);
                }

                pWalk = pWalk->pNext;
            }

            /*g_pLayer will be NULL when the Dialog box is invoked for adding a layer. 
            When the IDD_CUSTOMLAYER dilaog box is invoked after a EDIT or a REMOVE option, then
            this variable will point to the layer selected.
            */


            if ( NULL != g_pLayer ) {
                PSHIMDESC pWalk = g_pLayer->pShimList;

                // Turn off repaints

                SendDlgItemMessage(hDlg,IDC_SHIMLIST,WM_SETREDRAW,FALSE,0);
                SendDlgItemMessage(hDlg,IDC_LAYERLIST,WM_SETREDRAW,FALSE,0);

                SendDlgItemMessage(hDlg,IDC_NAME,WM_SETTEXT,0,(LPARAM) (LPCTSTR) g_pLayer->szLayerName);

                // Move the items over to the add side.

                while ( NULL != pWalk ) {
                    int nIndex = SendDlgItemMessage(hDlg,IDC_SHIMLIST,LB_FINDSTRING,0,(LPARAM)(LPCTSTR) pWalk->szShimName);

                    if ( LB_ERR != nIndex ) {
                        SendDlgItemMessage(hDlg,IDC_SHIMLIST,LB_SETSEL,TRUE,nIndex);

                        SendMessage(hDlg,WM_COMMAND,IDC_ADD,0);
                    }

                    pWalk = pWalk->pNext;
                }

                SendDlgItemMessage(hDlg,IDC_SHIMLIST,WM_SETREDRAW,TRUE,0);
                SendDlgItemMessage(hDlg,IDC_LAYERLIST,WM_SETREDRAW,TRUE,0);

                InvalidateRect(GetDlgItem(hDlg,IDC_SHIMLIST),NULL,TRUE);
                UpdateWindow(GetDlgItem(hDlg,IDC_SHIMLIST));
                InvalidateRect(GetDlgItem(hDlg,IDC_LAYERLIST),NULL,TRUE);
                UpdateWindow(GetDlgItem(hDlg,IDC_LAYERLIST));
            }//if (NULL != g_pLayer)

            SendMessage(hDlg,WM_COMMAND,MAKELONG(IDC_NAME,EN_UPDATE),0);

            SetFocus( GetDlgItem(hDlg, IDC_NAME) );

        }
        break;

    case    WM_COMMAND:
        switch ( LOWORD(wParam) ) {
        case    IDC_NAME:
            {

                /*The DONE button will be enabled only if the IDC_NAME, text box is non-empty and the 
                the number of elements in the IDC_LAYERLIST is > 0
                */


                if ( EN_UPDATE == HIWORD(wParam) ) {

                     if ( g_pLayer != NULL ) bNameChanged = TRUE; // The existing name has been  changed.


                    TCHAR   szText[MAX_PATH_BUFFSIZE];
                    UINT    uTotal = SendDlgItemMessage(hDlg,IDC_LAYERLIST,LB_GETCOUNT,0,0);
                    BOOL    bEnable = TRUE;

                    if ( 0 == uTotal || uTotal == LB_ERR )
                        bEnable = FALSE;

                    GetWindowText(GetDlgItem(hDlg,IDC_NAME),szText,MAX_PATH);


                    if ( CSTRING::Trim(szText) == 0 ) bEnable = FALSE;



                    EnableWindow(GetDlgItem(hDlg,IDOK),bEnable ? TRUE:FALSE);
                }
            }
            break;

        case    IDC_REMOVEALL:
            {
                SendDlgItemMessage(hDlg,IDC_SHIMLIST,WM_SETREDRAW,FALSE,0);
                SendDlgItemMessage(hDlg,IDC_LAYERLIST,WM_SETREDRAW,FALSE,0);

                int nCount;

                do {
                    nCount = SendDlgItemMessage(hDlg,IDC_LAYERLIST,LB_GETCOUNT,0,0);

                    SendDlgItemMessage(hDlg,IDC_LAYERLIST,LB_SETSEL,TRUE,0);

                    SendMessage(hDlg,WM_COMMAND,IDC_REMOVE,0);
                }
                while ( 0 != nCount );

                SendDlgItemMessage(hDlg,IDC_SHIMLIST,WM_SETREDRAW,TRUE,0);
                SendDlgItemMessage(hDlg,IDC_LAYERLIST,WM_SETREDRAW,TRUE,0);

                InvalidateRect(GetDlgItem(hDlg,IDC_SHIMLIST),NULL,TRUE);
                UpdateWindow(GetDlgItem(hDlg,IDC_SHIMLIST));
                InvalidateRect(GetDlgItem(hDlg,IDC_LAYERLIST),NULL,TRUE);
                UpdateWindow(GetDlgItem(hDlg,IDC_LAYERLIST));
            }
            break;

        case    IDC_COPY:
            {
                PDBLAYER pHold = g_pLayer;

                g_pCustomLayer->m_uMode = LAYERMODE_COPY;

                HWND hwndFocus = GetFocus();

                //The parameter TRUE in "DialogBoxParam" means load the list of global layers and the cutomr layers, FALSE means load the
                //lsit of custom layers. The names of the layers are obatained from g_theApp.pLayerList.

                if ( TRUE == DialogBoxParam(g_hInstance,MAKEINTRESOURCE(IDD_SELECTLAYER),g_theApp.m_hWnd,(DLGPROC)EditLayerProc,TRUE) ) {
                    //Now g_pLayer points to the layer which the user has selected.
                    PDBLAYER pCopy = g_pLayer;

                    //Now g_pLayer again reveerts back to its old value ! Perhaps this can be NULL as well
                    g_pLayer = pHold;

                    // Remove everything.

                    //SendMessage(hDlg,WM_COMMAND,IDC_REMOVEALL,0);

                    if ( NULL != pCopy ) {
                        PSHIMDESC pWalk = pCopy->pShimList;

                        // Turn off repaints

                        SendDlgItemMessage(hDlg,IDC_SHIMLIST,WM_SETREDRAW,FALSE,0);
                        SendDlgItemMessage(hDlg,IDC_LAYERLIST,WM_SETREDRAW,FALSE,0);

                        // Move the items over to the add side.

                        while ( NULL != pWalk ) {
                            int nIndex = SendDlgItemMessage(hDlg,IDC_SHIMLIST,LB_FINDSTRING,0,(LPARAM)(LPCTSTR) pWalk->szShimName);

                            if ( LB_ERR != nIndex ) {
                                SendDlgItemMessage(hDlg,IDC_SHIMLIST,LB_SETSEL,TRUE,nIndex);

                                SendMessage(hDlg,WM_COMMAND,IDC_ADD,0);
                            }

                            pWalk = pWalk->pNext;
                        }

                        SendDlgItemMessage(hDlg,IDC_SHIMLIST,WM_SETREDRAW,TRUE,0);
                        SendDlgItemMessage(hDlg,IDC_LAYERLIST,WM_SETREDRAW,TRUE,0);

                        InvalidateRect(GetDlgItem(hDlg,IDC_SHIMLIST),NULL,TRUE);
                        UpdateWindow(GetDlgItem(hDlg,IDC_SHIMLIST));
                        InvalidateRect(GetDlgItem(hDlg,IDC_LAYERLIST),NULL,TRUE);
                        UpdateWindow(GetDlgItem(hDlg,IDC_LAYERLIST));
                    }
                }//if (TRUE == DialogBoxParam(g_hInstance,MAKEINTRESOURCE(IDD_SELECTLAYER),g_theApp.m_hWnd,EditLayerProc,TRUE))

                SetFocus( hwndFocus );

            }
            break;

        case    IDC_ADD:
            {

                // PB. Remember #shims should not become more than this !!!
                int nItems[1024];
                int nCount;
                int nTotal;

                // Enumerate all the selected items and add them to the layer list

                nTotal = SendDlgItemMessage(hDlg,IDC_SHIMLIST,LB_GETSELITEMS,sizeof(nItems)/sizeof(int),(LPARAM) &nItems);

                for ( nCount=0; nCount < nTotal; ++nCount ) {
                    PSHIMDESC   pShim = (PSHIMDESC) SendDlgItemMessage(hDlg,IDC_SHIMLIST,LB_GETITEMDATA,nItems[nCount],0);
                    int         nIndex;

                    nIndex = SendDlgItemMessage(hDlg,IDC_LAYERLIST,LB_ADDSTRING,0,(LPARAM)(LPCTSTR) pShim->szShimName);

                    if ( LB_ERR != nIndex )
                        SendDlgItemMessage(hDlg,IDC_LAYERLIST,LB_SETITEMDATA,nIndex,(LPARAM) pShim);
                }

                SyncList(hDlg,IDC_LAYERLIST,IDC_SHIMLIST);
            }
            break;

        case    IDC_REMOVE:
            {
                int nItems[1024];
                int nCount;
                int nTotal;

                // Enumerate all the selected items and add them to the shim list

                nTotal = SendDlgItemMessage(hDlg,IDC_LAYERLIST,LB_GETSELITEMS,sizeof(nItems)/sizeof(int),(LPARAM) &nItems);

                for ( nCount=0; nCount < nTotal; ++nCount ) {
                    PSHIMDESC   pShim = (PSHIMDESC) SendDlgItemMessage(hDlg,IDC_LAYERLIST,LB_GETITEMDATA,nItems[nCount],0);
                    int         nIndex;

                    nIndex = SendDlgItemMessage(hDlg,IDC_SHIMLIST,LB_ADDSTRING,0,(LPARAM)(LPCTSTR) pShim->szShimName);

                    if ( LB_ERR != nIndex )
                        SendDlgItemMessage(hDlg,IDC_SHIMLIST,LB_SETITEMDATA,nIndex,(LPARAM) pShim);
                }

                SyncList(hDlg,IDC_SHIMLIST,IDC_LAYERLIST);
            }
            break;

        case    IDOK://DONE Button
            {
                PDBLAYER    pLayer;

                // Creating a new layer list.

                
                TCHAR szText[MAX_PATH_BUFFSIZE];
                SendDlgItemMessage(hDlg,IDC_NAME,WM_GETTEXT,MAX_PATH,(LPARAM) szText);
                CSTRING strLayerName = szText;
                strLayerName.Trim();
               
                //
                //Check if the new name already exists, if yes give error.
                //

                
                if ( ( g_pLayer == NULL && CheckExistingLayer(strLayerName)) 
                     ||
                     (g_pLayer != NULL && g_pLayer->szLayerName != strLayerName && CheckExistingLayer(strLayerName) )
                     
                   )
                    
                    
                    {
                    MessageBox(hDlg,
                               TEXT("A layer with the specified name already exists."),
                               TEXT("Duplicate Layer"),
                               MB_ICONWARNING
                               );
                    break;
                }
                
                

                if ( NULL == g_pLayer )
                    pLayer = new DBLAYER;
                else {

                    /*
                    This will be called when this CustomLayerProc() has been called 
                    beause the user chose Edit or Remove Custom layer.
                    In the member functions :
                    
                    1. EditCustomLayer
                    2. RemoveCustomLayer
                    
                    g_pLayer is made NULL
                    
                    In EditLayerProc,  The g_pLayer is set to  the particular PDBLAYER entry in the linked list
                    headed by g_theApp.pLayerList, which has the same name as the selectd layer
                    
                    */
                    pLayer = g_pLayer;

                    // Clear all the shims.

                    while ( NULL != pLayer->pShimList ) {
                        PSHIMDESC pHold = pLayer->pShimList->pNext;

                        if ( pLayer->pShimList != NULL )
                            delete pLayer->pShimList;

                        pLayer->pShimList = pHold;
                    }
                }

                if ( NULL != pLayer ) {


                    
                    int nCount;
                    int nTotal;

                    if ( NULL == g_pLayer )
                        ZeroMemory(pLayer,sizeof(DBLAYER));

                    SendDlgItemMessage(hDlg,IDC_NAME,WM_GETTEXT,MAX_PATH,(LPARAM) szText);

                    

                    TCHAR *pStart = szText,
                    *pEnd   = szText + lstrlen(szText) - 1,
                              szNewText[MAX_PATH_BUFFSIZE];

                    while ( *pStart== TEXT(' ') )                           ++pStart;

                    while ( (pEnd >= pStart) && ( *pEnd == TEXT(' ') ) ) --pEnd;

                    *( pEnd + 1) = TEXT('\0');//Keep it safe

                    



                    if ( *pStart == TEXT('\0') ) {
                        //This is just for protection, DONE will be disabled if the "Name " Text field is blank or has all spaces
                        MessageBox(NULL,TEXT("Please give a valid name for the layer"),TEXT("Invalid layer name"),MB_ICONWARNING);
                    }


                    else {
                        lstrcpyn(szNewText,pStart, MAX_PATH); 

                        if ( lstrcmpi(szText,szNewText) != 0 ) {
                            SetWindowText(GetDlgItem(hDlg,IDC_NAME), szNewText);

                            lstrcpyn(szText,szNewText,MAX_PATH);
                        }
                    }//else


                    pLayer->szLayerName = szText;

                    nTotal = SendDlgItemMessage(hDlg,IDC_LAYERLIST,LB_GETCOUNT,0,0);

                    // Enumerate all the shims listed and add to the layer.

                    for ( nCount=0; nCount < nTotal; ++nCount ) {
                        PSHIMDESC   pShim = (PSHIMDESC) SendDlgItemMessage(hDlg,IDC_LAYERLIST,LB_GETITEMDATA,nCount,0);
                        PSHIMDESC   pNew = new SHIMDESC;

                        if ( NULL == pNew ) {
                            MEM_ERR;
                            break;
                            //continue;
                        }


                        *pNew = *pShim;
/*
                                        pNew->szShimName = pShim->szShimName;
                                        pNew->szShimDLLName = pShim->szShimDLLName;
                                        pNew->szShimCommandLine = pShim->szShimCommandLine;
                                        pNew->szShimDesc = pShim->szShimDesc;
                                        pNew->bShim = pNew->bShim;
                                        pNew->bPermanent = pNew->bPermanent;
*/
                        pNew->pNext = pLayer->pShimList;

                        pLayer->pShimList = pNew;
                    }

                    if ( NULL == g_pLayer )
                    //CORRECTIT: That means this is a add option, better to check the mode of the class
                    {
                        pLayer->bPermanent = FALSE;
                        pLayer->pNext = g_theApp.GetDBLocal().m_pLayerList;
                        g_theApp.GetDBLocal().m_pLayerList = pLayer;
                    }
                    else if ( bNameChanged) {
                        //
                        //Replace the existing name in the DBRECORDs with the new name.
                        //

                        PDBRECORD pRecordApps = g_theApp.GetDBLocal().m_pRecordHead;
                        
                        while (pRecordApps) {

                            PDBRECORD pRecordExe = pRecordApps;
                            while (pRecordExe) {

                                if (pRecordExe->szLayerName == szPresentLayerName) {
                                pRecordExe->szLayerName = szText; // New name
                                }
                                
                                pRecordExe = pRecordExe->pDup;
                            
                            }// while (pRecordExe) 

                            pRecordApps = pRecordApps->pNext;    
                            
                        }//while (pRecordApps) 

                    }//else if ( bChanged)
                }

                EndDialog(hDlg,TRUE);
            }
            break;

        case    IDCANCEL:
            {
                EndDialog(hDlg,FALSE);
            }
            break;
        }
    }

    return FALSE;
}

BOOL CALLBACK EditLayerProc(HWND hDlg, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    switch ( uMsg ) {
    case    WM_INITDIALOG:
        {
            
            
            
            switch ( g_pCustomLayer->m_uMode ) {
            case    LAYERMODE_COPY:
                {
                    SetWindowText(hDlg,TEXT("Select Mode To Copy"));
                }
                break;

            case    LAYERMODE_EDIT:
                {
                    SetWindowText(hDlg,TEXT("Edit Compatibility Mode"));
                }
                break;
            case    LAYERMODE_REMOVE:
                {
                    SetWindowText(hDlg,TEXT("Remove Compatibility Mode"));
                }
                break;
            }

            PDBLAYER    pWalk = g_theApp.GetDBGlobal().m_pLayerList;
            
            for( int iLoop = 0; iLoop <= 1; ++ iLoop){

                 while ( NULL != pWalk ) {

                //Add if this is a local/custom layer or we we want to show the layers(Permanent and custom),
                //because we are in copy layer option.

                    if ( !pWalk->bPermanent || TRUE == lParam ) {
                        int nIndex = SendDlgItemMessage(hDlg,IDC_LIST,LB_ADDSTRING,0,(LPARAM)(LPCTSTR)pWalk->szLayerName);

                        if ( LB_ERR != nIndex )
                            SendDlgItemMessage(hDlg,IDC_LIST,LB_SETITEMDATA,nIndex,(LPARAM) pWalk);
                    }

                pWalk = pWalk->pNext;
                }
                pWalk =  g_theApp.GetDBLocal().m_pLayerList;
            }//for


            // Force button update/ Make it disabled basically

            //SendMessage(hDlg,WM_COMMAND,IDC_LIST,0);

            //
            //Select the first item of the list box
            //

            SendMessage( 
              (HWND) GetDlgItem(hDlg,IDC_LIST),              // handle to destination window 
                LB_SETCURSEL,             // message to send
            (WPARAM) 0,          // item index
            (LPARAM) 0          // not used; must be zero
            );

           SetFocus( GetDlgItem (hDlg, IDC_LIST) );
        }
        break;

    case    WM_COMMAND:
        {
            switch ( LOWORD(wParam) ) {
            case    IDC_LIST:
                {
                    if ( LB_ERR == SendMessage(GetDlgItem(hDlg,IDC_LIST),LB_GETCURSEL,0,0) )
                        EnableWindow(GetDlgItem(hDlg,IDOK),FALSE);
                    else
                        EnableWindow(GetDlgItem(hDlg,IDOK),TRUE);
                }
                break;

            case    IDOK:
                {
                    int nIndex = SendMessage(GetDlgItem(hDlg,IDC_LIST),LB_GETCURSEL,0,0);

                    //Make g_pLayer point to the selected layer.

                    g_pLayer = (PDBLAYER) SendDlgItemMessage(hDlg,IDC_LIST,LB_GETITEMDATA,nIndex,0);

                    EndDialog(hDlg,1);
                }
                break;

            case    IDCANCEL:
                EndDialog(hDlg,0);
                break;
            }
        }
        break;
    }

    return FALSE;
}

BOOL CheckExistingLayer(CSTRING & szNewLayerName)
{
    PDBLAYER pLayer = g_theApp.GetDBLocal().m_pLayerList;

    

    while (pLayer != NULL) {
        if ( pLayer->szLayerName == szNewLayerName ) break;
        else pLayer = pLayer->pNext;
    }

    if  (pLayer != NULL) return TRUE;

    pLayer = g_theApp.GetDBGlobal().m_pLayerList;

    while (pLayer != NULL) {
        if ( pLayer->szLayerName == szNewLayerName ) break;
        else pLayer = pLayer->pNext;
    }

    if  (pLayer != NULL) return TRUE;

    return FALSE;

}//CheckExistingLayer(CSTRING &)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\appcompat\tools\compatadmin\dbsearch.cpp ===
#include "compatadmin.h"
#include "dbsearch.h"

// Taken from sdbp.h

#define PDB_MAIN            0x00000000
#define PDB_TEST            0x10000000
#define PDB_LOCAL           0x20000000

#define TAGREF_STRIP_TAGID  0x0FFFFFFF
#define TAGREF_STRIP_PDB    0xF0000000

HANDLE      g_hSearchThread = NULL;
CDBSearch * g_pSearch = NULL;
HWND        g_hUpdateWnd;
HWND        g_hListWnd;
CRITICAL_SECTION g_CritSect;
DWORD       g_dwMainThread;
BOOL        g_bAbort;

typedef struct {
    TCHAR   szDrive[MAX_PATH_BUFFSIZE];
    BOOL    bSearch;
} DRIVELIST, *PDRIVELIST;

#define MAX_DRIVES  128

DRIVELIST   g_SearchDrives[MAX_DRIVES];
TCHAR       g_szWildcard[MAX_PATH_BUFFSIZE];

BOOL PopulateFromExes   (PSEARCHLIST pNew, TAGID   ID,PDB  pDB, TAGREF tagref);
BOOL PopulateFromLayers (PSEARCHLIST pNew, TAGID   ID,PDB  pDB, TAGREF tagref, CSTRING strLayersInExes[]);

CDBSearch::CDBSearch()
{
    m_pList = NULL;
    m_hListView = NULL;
    InitializeCriticalSection(&g_CritSect);
    g_dwMainThread = GetCurrentThreadId();
}

BOOL CDBSearch::Initialize(void)
{


    if ( !Create(    TEXT("DBViewClass"),
                     TEXT("Search View"),//Not displayed, used for diagnostics with SPY++
                     0,0,
                     10,10,
                     &g_theApp,
                     (HMENU)VIEW_DATABASE,
                     0,
                     WS_CHILD | WS_CLIPSIBLINGS | WS_CLIPCHILDREN) ) {
        return FALSE;
    }

    m_hMenu = LoadMenu(g_hInstance,MAKEINTRESOURCE(IDR_SEARCHMENU));

    m_hListView = CreateWindowEx(   0,
                                    WC_LISTVIEW,
                                    TEXT(""),
                                    WS_CHILD | WS_VISIBLE | WS_BORDER | WS_CLIPSIBLINGS | LVS_REPORT | LVS_OWNERDRAWFIXED,
                                    0,0,
                                    10,10,
                                    m_hWnd,
                                    NULL,
                                    g_hInstance,
                                    NULL);

    g_hListWnd = m_hListView;

    LONG uStyle = ListView_GetExtendedListViewStyle(m_hListView);

    ListView_SetExtendedListViewStyle(m_hListView,LVS_EX_FULLROWSELECT | uStyle);

    // Add the list view columns

    LV_COLUMN   Col;

    Col.mask = LVCF_TEXT | LVCF_WIDTH;
    Col.pszText = TEXT("Affected File");
    Col.cchTextMax = lstrlen(Col.pszText);
    Col.cx = 200;

    ListView_InsertColumn(m_hListView,0,&Col);

    Col.pszText = TEXT("Application");
    Col.cchTextMax = lstrlen(Col.pszText);
    Col.cx = 150;

    ListView_InsertColumn(m_hListView,1,&Col);

    Col.pszText = TEXT("Action");
    Col.cchTextMax = lstrlen(Col.pszText);
    Col.cx = 100;

    ListView_InsertColumn(m_hListView,2,&Col);

    Col.pszText = TEXT("Database");
    Col.cchTextMax = lstrlen(Col.pszText);
    Col.cx = 100;

    ListView_InsertColumn(m_hListView,3,&Col);

    /*

    // This was for the settings field
    
    Col.pszText = TEXT("Settings");
    Col.cchTextMax = lstrlen(Col.pszText);
    Col.cx = 100;
    

    ListView_InsertColumn(m_hListView,4,&Col);
    
    */
/*
    Col.pszText = "Local Setting";
    Col.cchTextMax = lstrlen(Col.pszText);
    Col.cx = 100;

    ListView_InsertColumn(m_hListView,5,&Col);
*/
    m_hFillBrush = CreateSolidBrush(RGB(235,235,235));

    return TRUE;
}

void CDBSearch::Update(BOOL fNotUsed)
{
    while ( NULL != m_pList ) {
        PSEARCHLIST pHold = m_pList->pNext;

        delete m_pList;
        m_pList = pHold;
    }

    ListView_DeleteAllItems(m_hListView);

    g_pSearch = this;

    PostMessage(m_hWnd,WM_USER+1024,0,0);

    // Add everything to the list view.
}

BOOL CDBSearch::Activate(BOOL fNotUsed)
{
    //K if (NULL == m_pList)
    Update(fNotUsed);

    return TRUE;
}

void CDBSearch::msgCommand(UINT uID, HWND hSender)
{
    switch ( uID ) {
    case    ID_SEARCH_NEWSEARCH:
        {
            Update();
        }
        break;
    }
}

void CDBSearch::msgResize(UINT uWidth, UINT uHeight)
{
    MoveWindow(m_hListView,0,0,uWidth,uHeight,TRUE);

    InvalidateRect(m_hListView,NULL,TRUE);
    UpdateWindow(m_hListView);

    Refresh();
}

LRESULT CDBSearch::MsgProc(UINT uMsg,WPARAM wParam, LPARAM lParam)
{
    switch ( uMsg ) {
    
    case    WM_USER+1024:
        {
            g_hListWnd = m_hWnd;

            // Enumerate the drives and ask for query

            if ( 0 != DialogBox(g_hInstance,MAKEINTRESOURCE(IDD_DRIVELIST),m_hWnd,(DLGPROC)SelectDrivesProc) )
                PostMessage(m_hWnd,WM_USER+1025,0,0);
        }
        break;

    case    WM_USER+1025:
        {
            UINT uCount;

            for ( uCount=0; uCount<MAX_DRIVES; ++uCount ) {
                if ( g_SearchDrives[uCount].bSearch )
                    DialogBoxParam(g_hInstance,MAKEINTRESOURCE(IDD_SEARCH),m_hWnd,(DLGPROC)SearchProc,(LPARAM)g_SearchDrives[uCount].szDrive);
            }
        }

        // DON'T BREAK. Allow a natural update.

    case    WM_USER+1026:
        {
            // Now add everything we've found to the list view.

            EnterCriticalSection(&g_CritSect);

            ListView_DeleteAllItems(m_hListView);

            PSEARCHLIST pWalk = m_pList;
            int         nItem = 0;

            while ( NULL != pWalk ) {
                LV_ITEM Item;

                Item.mask = TVIF_TEXT | TVIF_PARAM;
                Item.iItem = nItem;
                Item.iSubItem = 0;
                Item.pszText = pWalk->szFilename;
                Item.cchTextMax = lstrlen(Item.pszText);
                Item.lParam = (LPARAM) pWalk;

                ListView_InsertItem(m_hListView,&Item);

                Item.mask = TVIF_TEXT;
                Item.iItem = nItem;
                Item.iSubItem = 1;
                Item.pszText = pWalk->szApplication;
                Item.cchTextMax = lstrlen(Item.pszText);
                Item.lParam = (LPARAM) pWalk;

                ListView_InsertItem(m_hListView,&Item);

                ++nItem;

                pWalk = pWalk->pNext;
            }

            LeaveCriticalSection(&g_CritSect);
        }
        break;

    case    WM_DRAWITEM:
        {
            LPDRAWITEMSTRUCT    pDraw = (LPDRAWITEMSTRUCT) lParam;
            HDC                 hDC = CreateCompatibleDC(pDraw->hDC);
            HBITMAP             hBmp = CreateCompatibleBitmap(pDraw->hDC,pDraw->rcItem.right - pDraw->rcItem.left,pDraw->rcItem.bottom - pDraw->rcItem.top);
            HBITMAP             hOldBmp = (HBITMAP) SelectObject(hDC,hBmp);
            HFONT               hFont = (HFONT) SendMessage(m_hListView,WM_GETFONT,0,0);
            PSEARCHLIST         pList;
            LVITEM              Item;
            RECT                rBmpRect;

            hFont = (HFONT) SelectObject(hDC,hFont);

            SetRect(&rBmpRect,0,0,pDraw->rcItem.right - pDraw->rcItem.left,pDraw->rcItem.bottom - pDraw->rcItem.top);

            Item.mask = LVIF_PARAM;
            Item.iItem = pDraw->itemID;
            Item.iSubItem = 0;

            LV_COLUMN   Col;

            Col.mask = LVCF_WIDTH;

            ListView_GetColumn(m_hListView,0,&Col);

            Col.cx = pDraw->rcItem.right;

            ListView_GetItem(m_hListView,&Item);

            if ( 0 != (pDraw->itemState & ODS_FOCUS) ) {
                FillRect(hDC,&rBmpRect,GetSysColorBrush(COLOR_HIGHLIGHT));
                SetBkColor(hDC,GetSysColor(COLOR_HIGHLIGHT));

            } else{
            
                FillRect(hDC,&rBmpRect,(HBRUSH) GetStockObject(WHITE_BRUSH));
                SetBkColor(hDC,RGB(255,255,255));
            } 

            
            MoveToEx(hDC,Col.cx-1,0,NULL);
            //LineTo(hDC,Col.cx-1,rBmpRect.bottom);

            MoveToEx(hDC,0,rBmpRect.bottom-1,NULL);
            //LineTo(hDC,rBmpRect.right,rBmpRect.bottom-1);

            // Draw the actual name.

            pList = (PSEARCHLIST) Item.lParam;

            LPTSTR szText = pList->Record.szEXEName;

            RECT rClipRect = rBmpRect;

            rClipRect.left = 20;
            rClipRect.right = Col.cx - 2;
            --rClipRect.bottom;

            // Icon

            SHFILEINFO  Info;

            ZeroMemory(&Info,sizeof(Info));

            SHGetFileInfo(pList->szFilename,FILE_ATTRIBUTE_NORMAL,&Info,sizeof(Info),SHGFI_ICON | SHGFI_SMALLICON);

            // NOTE: We don't use ImageList_Draw because it cannot stretch.

            DrawIconEx(hDC,5,0,Info.hIcon,rBmpRect.bottom,rBmpRect.bottom,0,NULL,DI_NORMAL);

            // Filename

           

            ExtTextOut( hDC,
                        10 + rBmpRect.bottom, 0,
                        ETO_OPAQUE | ETO_CLIPPED,
                        &rClipRect,
                        szText, lstrlen(szText),
                        NULL);

            // App name.



            Col.mask = LVCF_WIDTH;

            ListView_GetColumn(m_hListView,0,&Col);

            rClipRect.left = Col.cx;

            ListView_GetColumn(m_hListView,1,&Col);

            rClipRect.right = rClipRect.left + Col.cx;

            CSTRING strText;
            strText.sprintf(TEXT("%s"),TEXT("  "));

            if ( ! pList->Record.szAppName.isNULL() ) 
                strText.strcat( pList->Record.szAppName );
            
            

            ExtTextOut( hDC,
                        rClipRect.left, 0,
                        ETO_OPAQUE | ETO_CLIPPED,
                        &rClipRect,
                        strText, strText.Length(),
                        NULL);

            Col.mask = LVCF_WIDTH;

            ListView_GetColumn(m_hListView,2,&Col);

            rClipRect.left = rClipRect.right;
            rClipRect.right = rClipRect.left + Col.cx;

            CSTRING szTemp;

            

            if ( pList->Record.szLayerName.Length() > 0 ) 
                szTemp.sprintf(TEXT("Layer: %s;"),(LPCTSTR) pList->Record.szLayerName);
            
            PDBENTRY    pEntry = pList->Record.pEntries;
            BOOL bShim = FALSE, bAppHelp = FALSE, bPatchFlag = FALSE;

            while ( NULL != pEntry ) {
               if ( ENTRY_SHIM == pEntry->uType ){
                        
                   bShim = TRUE;
                }

                else if ( ENTRY_APPHELP == pEntry->uType ){
                   bAppHelp = TRUE;
                }
                else if (ENTRY_MATCH != pEntry->uType) {
                   bPatchFlag = TRUE;

                }

                  pEntry = pEntry->pNext;
            }
            

            if (bShim) {
                szTemp.strcat(TEXT("Custom Fix"));
                szTemp.strcat(TEXT(";"));

            }

            if (bAppHelp) {
                szTemp.strcat(TEXT("AppHelp"));
                szTemp.strcat(TEXT(";"));

            }

            if (bPatchFlag) {
                szTemp.strcat(TEXT("Patch/Flag"));
                szTemp.strcat(TEXT(";"));

            }

            if(szTemp.Length() == 0 ){
                szTemp = TEXT("Patch/Flag;");
            }

            szTemp.SetChar(szTemp.Length()-1, TEXT('\0'));
                                                          

            strText.sprintf(TEXT("%s"),TEXT("  "));

            if ( !szTemp.isNULL() ) 
                strText.strcat( szTemp );

            ExtTextOut( hDC,
                        rClipRect.left, 0,
                        ETO_OPAQUE | ETO_CLIPPED,
                        &rClipRect,
                        strText, strText.Length(),
                        NULL);

            Col.mask = LVCF_WIDTH;

            ListView_GetColumn(m_hListView,3,&Col);

            rClipRect.left = rClipRect.right;
            rClipRect.right = rClipRect.left + Col.cx;

            
            strText.sprintf(TEXT("%s"),TEXT("  "));

            if ( ! pList->szDatabase.isNULL() ) 
                strText.strcat( pList->szDatabase );

            ExtTextOut( hDC,
                        rClipRect.left, 0,
                        ETO_OPAQUE | ETO_CLIPPED,
                        &rClipRect,
                        strText, strText.Length(),
                        NULL);


            /* This was for the settings field.
            
            Col.mask = LVCF_WIDTH;

            ListView_GetColumn(m_hListView,4,&Col);

            rClipRect.left = rClipRect.right;
            rClipRect.right = rClipRect.left + Col.cx;

            if ( 0 == pList->Record.dwGlobalFlags )
                szText = TEXT("Enabled");
            else
                szText = TEXT("Disabled");

            strText.sprintf(TEXT("%s %s"),TEXT("  "),szText );

            ExtTextOut( hDC,
                        rClipRect.left, 0,
                        ETO_OPAQUE | ETO_CLIPPED,
                        &rClipRect,
                        strText, strText.Length(),
                        NULL);
            */

            Col.mask = LVCF_WIDTH;

            ListView_GetColumn(m_hListView,5,&Col);

            rClipRect.left = rClipRect.right;
            rClipRect.right = rClipRect.left + Col.cx;


            BitBlt( pDraw->hDC,
                    pDraw->rcItem.left,
                    pDraw->rcItem.top,
                    (pDraw->rcItem.right - pDraw->rcItem.left),
                    (pDraw->rcItem.bottom - pDraw->rcItem.top)+1,
                    hDC,
                    0,0,
                    SRCCOPY);

            SelectObject(hDC,hOldBmp);
            SelectObject(hDC,hFont);

            DeleteObject(hBmp);
            DeleteDC(hDC);
        }
        break;
    }

    return CView::MsgProc(uMsg,wParam,lParam);
}

void SearchDrive(LPCTSTR szDir)
{
    HANDLE          hFile;
    WIN32_FIND_DATA Data;
    TCHAR           szCurrentDir[MAX_PATH_BUFFSIZE];
    BOOL            bAbort = FALSE;

    GetCurrentDirectory(sizeof(szCurrentDir)/sizeof(TCHAR),szCurrentDir);

    

    // Make a check here. This can fail if removable media is not present and
    // user selects cancel.

    if ( !SetCurrentDirectory(szDir) )
        return;

    SetWindowText(g_hUpdateWnd,szDir);

    hFile = FindFirstFile(g_szWildcard,&Data);

    if ( INVALID_HANDLE_VALUE != hFile ) {
        do {
            CSTRING         szStr;

            szStr.sprintf(TEXT("%s"),szDir);

            if ( TEXT('\\') != szDir[lstrlen(szDir)-1] )
                   szStr.strcat(TEXT("\\"));

            szStr.strcat(Data.cFileName);

            SDBQUERYRESULT  Res;

            ZeroMemory(&Res,sizeof(SDBQUERYRESULT));


            // Determine if this file is affected in any way.

            if ( 0 == (Data.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) ) {
                if ( SdbGetMatchingExe(g_hSDB, (LPCTSTR)szStr,NULL, NULL, SDBGMEF_IGNORE_ENVIRONMENT, &Res) ) {
                    

                    // Yes, it is. Add it to the list of managed files.

                        TAGID   ID;
                        PDB     pDB;

                        

                        //
                        //First read in the exes
                        //

                        
                        

                        CSTRING strLayersInExes[SDB_MAX_EXES];

                        

                        for (int nExeLoop = 0; nExeLoop < SDB_MAX_EXES; ++nExeLoop) {
                            if (Res.atrExes[nExeLoop] ) {

                                SdbTagRefToTagID(g_hSDB,Res.atrExes[nExeLoop],&pDB,&ID);

                                PSEARCHLIST pNew = new SEARCHLIST;

                                if (pNew == NULL) {

                                    MEM_ERR;
                                    return;
                                }

                                pNew->szFilename = szStr;

                                PopulateFromExes(pNew,ID,pDB,Res.atrExes[nExeLoop]);
                                strLayersInExes[nExeLoop] = pNew->Record.szLayerName;
                            }
                        }

                        //
                        //Now look for the layers.
                        //

                        
                        for (int nLayerLoop = 0; nLayerLoop < SDB_MAX_LAYERS; ++nLayerLoop) {
                            if (Res.atrLayers[nLayerLoop] ) {

                                SdbTagRefToTagID(g_hSDB,Res.atrLayers[nLayerLoop],&pDB,&ID);

                                PSEARCHLIST pNew = new SEARCHLIST;

                                if (pNew == NULL) {

                                    MEM_ERR;
                                    return;
                                }

                                pNew->szFilename = szStr;

                                PopulateFromLayers(pNew,ID,pDB,Res.atrLayers[nLayerLoop], strLayersInExes);
                                
                            }
                        }


                         


                        

                        // NOTE: SendNotifyMessage is thread safe.

                        SendNotifyMessage(g_hListWnd,WM_USER+1026,0,0);
                    
                }
            }

            EnterCriticalSection(&g_CritSect);

            bAbort = g_bAbort;

            LeaveCriticalSection(&g_CritSect);
        }
        while ( FindNextFile(hFile,&Data) && !bAbort );

        FindClose(hFile);
    }//if (INVALID_HANDLE_VALUE != hFile)

    // Now go through separately and walk the sub-directories.

    hFile = FindFirstFile(TEXT("*.*"),&Data);

    if ( INVALID_HANDLE_VALUE != hFile ) {
        do {
            if ( 0 != (Data.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) ) {
                BOOL bForbidden = FALSE;

                if ( TEXT('.') == Data.cFileName[0] )
                    bForbidden = TRUE;

                if ( 0 == lstrcmp(TEXT("LocalService"),Data.cFileName) )
                    bForbidden = TRUE;

                if ( 0 == lstrcmp(TEXT("NetworkService"),Data.cFileName) )
                    bForbidden = TRUE;

                if ( 0 == lstrcmp(TEXT("System Volume Information"),Data.cFileName) )
                    bForbidden = TRUE;

                if ( !bForbidden ) {
                    TCHAR szPath[MAX_PATH_BUFFSIZE];

                    lstrcpy(szPath,szDir);

                    if ( lstrlen(szPath) > 3 )
                        lstrcat(szPath,TEXT("\\"));

                    lstrcat(szPath,Data.cFileName);

                    SearchDrive(szPath);
                }
            }

            EnterCriticalSection(&g_CritSect);

            bAbort = g_bAbort;

            LeaveCriticalSection(&g_CritSect);
        }
        while ( FindNextFile(hFile,&Data) && !bAbort );

        FindClose(hFile);
    }

    SetCurrentDirectory(szCurrentDir);
}

DWORD WINAPI SearchThread(LPVOID pParam)
{
    SearchDrive((LPCTSTR)pParam);

    return 0;
}

BOOL CALLBACK SearchProc(HWND hDlg, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    switch ( uMsg ) {
    case    WM_INITDIALOG:
        {
            DWORD   dwID;

            SetTimer(hDlg,0,1,NULL);

            g_hUpdateWnd = GetDlgItem(hDlg,IDC_SEARCHTEXT);

            // Begin searching the drive on a separate thread.

            g_hSearchThread = CreateThread(NULL, 0, SearchThread, (PVOID)lParam, 0, &dwID);
        }
        return TRUE;

    case    WM_TIMER:
        {
            // Done searching? If not, wait

            if ( NULL != g_hSearchThread ) {
                if ( WAIT_OBJECT_0 == WaitForSingleObject(g_hSearchThread,0) ) {
                    CloseHandle(g_hSearchThread);
                    g_hSearchThread = NULL;
                }
            } else
                EndDialog(hDlg,0);
        }
        break;

    case    WM_COMMAND:
        {
            switch ( LOWORD(wParam) ) {
            case    IDCANCEL:
                {
                    EnterCriticalSection(&g_CritSect);

                    g_bAbort = TRUE;

                    LeaveCriticalSection(&g_CritSect);
                }
                break;
            }
        }
        break;
    }

    return FALSE;
}

BOOL CALLBACK SelectDrivesProc(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    switch ( uMsg ) {
    case    WM_INITDIALOG:
        {
            
            SendMessage( 
                GetDlgItem(hWnd,IDC_WILDCARD),              // handle to destination window 
                EM_LIMITTEXT,             // message to send
                (WPARAM) MAX_PATH,          // text length
                (LPARAM) 0
                );

            
            TCHAR   szDrives[4096];

            *szDrives = 0;

            LPTSTR  szWalk = szDrives;
            int     nCount = 0;
            TCHAR   szIcons[MAX_PATH_BUFFSIZE];

            g_bAbort = FALSE;

            GetSystemDirectory(szIcons,MAX_PATH);

            lstrcat(szIcons,TEXT("\\shell32.dll"));

            HIMAGELIST hImage = ImageList_Create(16,16,ILC_COLORDDB | ILC_MASK,0,1);

            HICON   hIcon;

            // Floppy: 0

            ExtractIconEx(szIcons,6,NULL,&hIcon,1);

            ImageList_AddIcon(hImage,hIcon);

            // Fixed disk: 1

            ExtractIconEx(szIcons,8,NULL,&hIcon,1);

            ImageList_AddIcon(hImage,hIcon);

            // Network: 2

            ExtractIconEx(szIcons,9,NULL,&hIcon,1);

            ImageList_AddIcon(hImage,hIcon);

            // CD ROM: 3

            ExtractIconEx(szIcons,11,NULL,&hIcon,1);

            ImageList_AddIcon(hImage,hIcon);

            // RAM Disk: 4

            ExtractIconEx(szIcons,12,NULL,&hIcon,1);

            ImageList_AddIcon(hImage,hIcon);

            TreeView_SetImageList(GetDlgItem(hWnd,IDC_DRIVELIST),hImage,TVSIL_NORMAL);

            SetWindowText(GetDlgItem(hWnd,IDC_WILDCARD),TEXT("*.EXE"));

            GetLogicalDriveStrings(sizeof(szDrives)/sizeof(TCHAR),szDrives);

            while ( lstrlen(szWalk) > 0 ) {  //Can be replaced by while(*szWalk).
                TVINSERTSTRUCT Item;
                TCHAR           szString[MAX_PATH_BUFFSIZE];
                UINT            uType = GetDriveType(szWalk);

                if ( DRIVE_REMOVABLE != uType && DRIVE_NO_ROOT_DIR != uType ) {
                    TCHAR   szVolume[MAX_PATH_BUFFSIZE];
                    TCHAR   szDriveFormat[MAX_PATH_BUFFSIZE];
                    DWORD   dwSerial;
                    DWORD   dwLen;
                    DWORD   dwFlags;

                    szVolume[0] = 0;
                    szDriveFormat[0] = 0;

                    GetVolumeInformation(szWalk,
                                         szVolume,
                                         sizeof(szVolume)/sizeof(TCHAR),
                                         &dwSerial,
                                         &dwLen,
                                         &dwFlags,
                                         szDriveFormat,
                                         sizeof(szDriveFormat)/sizeof(TCHAR));

                    if ( lstrlen(szVolume) == 0 )
                        lstrcpy(szVolume,TEXT("No Volume"));

                    _snwprintf(szString,sizeof(szString)/sizeof(TCHAR), TEXT("%s - %s"),szWalk,szVolume);
                } else
                    lstrcpy(szString,szWalk);

                Item.hParent = TVI_ROOT;
                Item.hInsertAfter = TVI_LAST;
                Item.item.mask  = TVIF_TEXT | TVIF_PARAM | TVIF_IMAGE | TVIF_SELECTEDIMAGE;
                Item.item.pszText = szString;
                Item.item.cchTextMax = lstrlen(Item.item.pszText);

                switch ( uType ) {
                case    DRIVE_REMOVABLE:
                    Item.item.iImage = 0;
                    Item.item.iSelectedImage = 0;
                    break;
                case    DRIVE_FIXED:
                    Item.item.iImage = 1;
                    Item.item.iSelectedImage = 1;
                    break;
                case    DRIVE_REMOTE:
                    Item.item.iImage = 2;
                    Item.item.iSelectedImage = 2;
                    break;
                case    DRIVE_CDROM:
                    Item.item.iImage = 3;
                    Item.item.iSelectedImage = 3;
                    break;
                case    DRIVE_RAMDISK:
                    Item.item.iImage = 4;
                    Item.item.iSelectedImage = 4;
                    break;
                }

                Item.item.lParam = nCount;

                lstrcpy(g_SearchDrives[nCount].szDrive,szWalk);
                g_SearchDrives[nCount].bSearch = FALSE;

                nCount++;

                TreeView_InsertItem(GetDlgItem(hWnd,IDC_DRIVELIST),&Item);

                szWalk += lstrlen(szWalk) +  1;
            }
        }
        return TRUE;

    case    WM_NOTIFY:
        {
            NMHDR * pHdr = (NMHDR *) lParam;

            switch ( pHdr->code ) {
            
            case    NM_CLICK:
                {

                    TVHITTESTINFO   ht;
                    HWND            hTree = GetDlgItem(hWnd,IDC_DRIVELIST);

                    GetCursorPos(&ht.pt);
                    ScreenToClient(hTree, &ht.pt);

                    TreeView_HitTest(hTree,&ht);

                    if ( 0 != ht.hItem )
                        TreeView_SelectItem(hTree,ht.hItem);
                }
                break;                          


                /*
                case    TVN_SELCHANGED:
                        
                        HWND            hTree = GetDlgItem(hWnd,IDC_DRIVELIST);
                        LPNMTREEVIEW pnmtv = (LPNMTREEVIEW) lParam;

                        //((pnmtv->itemNew).state & TVIS_SELECTED) ? 
                        TreeView_SelectItem(hTree,(pnmtv->itemNew).hItem);
                        break;
                */

            }//switch(pHdr->code)
        }
        break;


    case    WM_COMMAND:
        switch ( LOWORD(wParam) ) {
        case    IDCANCEL:
            EndDialog(hWnd,0);
            break;

        case    IDOK:
            {
                HTREEITEM   hItem;
                HWND        hTree = GetDlgItem(hWnd,IDC_DRIVELIST);

                GetWindowText(GetDlgItem(hWnd,IDC_WILDCARD),g_szWildcard,MAX_PATH);

                hItem = TreeView_GetRoot(hTree);

                //EFF: Probably we can make the change that when we select or click the 
                //Tree control, then we can make toggle g_SearchDrives[Item.lParam].bSearch 

                while ( NULL != hItem ) {
                    TVITEM  Item;

                    Item.mask = TVIF_STATE | TVIF_PARAM;
                    Item.hItem = hItem;

                    TreeView_GetItem(hTree,&Item);

                    if ( 0 != (Item.state & 0x2000) )
                        g_SearchDrives[Item.lParam].bSearch = TRUE;

                    hItem = TreeView_GetNextSibling(hTree,hItem);
                }

                EndDialog(hWnd,1);
            }
            break;
        }
    }

    return FALSE;
}

void CDBSearch::msgChar(TCHAR ch)
{
    SendMessage(this->m_hListView,WM_CHAR,(WPARAM)ch, 0x8000 );
}


BOOL PopulateFromExes(PSEARCHLIST pNew, TAGID   ID,PDB  pDB, TAGREF tagref)

{             
    //
    //We have to populate the pNew->szFileName before calling this function.
    //
    
    BOOL valid = CDatabase::ReadRecord(ID,&pNew->Record,pDB);

     

    switch ( tagref & TAGREF_STRIP_PDB ) { 
    case    PDB_MAIN:                                                  
        pNew->szDatabase = TEXT("Global");                             
        break;                                                         
    case    PDB_TEST:                                                  
        pNew->szDatabase = TEXT("Test");                               
        break;                                                         
                                                   
    case    PDB_LOCAL:                                                 
        pNew->szDatabase = TEXT("Local");                              
        break;                                                         
    }                                                                  
                
    pNew->pNext = g_pSearch->m_pList;          
                                                           
    pNew->Record.szEXEName = pNew->szFilename; 
                                                                                              
    EnterCriticalSection(&g_CritSect);                                 
                                                   
    g_pSearch->m_pList = pNew;                                         
                                                   
    LeaveCriticalSection(&g_CritSect);                                 
        
    return valid;                        
        
                            
}                                                  

BOOL PopulateFromLayers(PSEARCHLIST pNew, TAGID   ID,PDB  pDB, TAGREF tagref, CSTRING strLayersInExes[] )

{             
    //
    //We have to populate the pNew->szFileName before calling this function.
    //
    
         

     //
     //For those global entries which do not have layers but shims etc.
     //

    
     BOOL valid = CDatabase::ReadRecord(ID,&pNew->Record,pDB);

     pNew->Record.szLayerName   = pNew->Record.szEXEName;

     pNew->Record.szEXEName     = pNew->szFilename;

     pNew->Record.pEntries      = NULL;


     if (pNew->Record.szLayerName.isNULL() ) {
         return TRUE;
     }

     //
     //We are looking for the layers and must not add a layer that has already been found
     //

     for (int nLoop  = 0; nLoop < SDB_MAX_EXES; ++nLoop ){

           if (strLayersInExes[nLoop] == pNew->Record.szLayerName) {
               return FALSE;
        }
     }//for (int nLoop  = 0; nLoop < MAX_EXES, ++nLoop)


    

    switch ( tagref & TAGREF_STRIP_PDB ) { 
    case    PDB_MAIN:                                                  
        pNew->szDatabase = TEXT("Global");                             
        break;                                                         
    case    PDB_TEST:                                                  
        pNew->szDatabase = TEXT("Test");                               
        break;                                                         
                                                   
    case    PDB_LOCAL:                                                 
        pNew->szDatabase = TEXT("Local");                              
        break;                                                         
    }                                                                  
                
    pNew->pNext = g_pSearch->m_pList;          
                                                           
    pNew->Record.szEXEName = pNew->szFilename;

    pNew->Record.szAppName = TEXT("<No name available: Fix possibly created using Compatibility Wizard>");
                                                                                              
    EnterCriticalSection(&g_CritSect);                                 
                                                   
    g_pSearch->m_pList = pNew;                                         
                                                   
    LeaveCriticalSection(&g_CritSect);                                 
        
    return TRUE;                        
        
                            
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\appcompat\tools\compatadmin\dbviewer.cpp ===
//#define __DEBUG2
//This var. is TRUE if we want the TVN_SELCHANGED to be processed process after a NM_RCLCK msg, 
//this is FALSE when we send Tree_SelectItem(, NULL)




#include "compatadmin.h"
#include "dbviewer.h"
#include "xmldialog.h"

#ifndef __CAPPHELPWIZARD_H
    #include "CAppHelpWizard.h"
#endif    

#include "customlayer.h"

//#define __DEBUG       

HSDB      g_hSDB = NULL;
WNDPROC g_OldTreeProc = NULL;

extern HWND g_hWndLastFocus;
extern BOOL g_DEBUG;

BOOL g_do_notProcess = FALSE;

LRESULT CALLBACK TreeViewProc(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    switch ( uMsg ) {
    case    WM_KEYDOWN:
        {
            if ( VK_TAB == wParam ) {
                NMKEY Key;

                Key.hdr.hwndFrom = hWnd;
                Key.hdr.idFrom = 0;
                Key.hdr.code = NM_KEYDOWN;
                Key.nVKey = VK_TAB;

                SendMessage(GetParent(hWnd),WM_NOTIFY,0,(LPARAM) &Key);
            }
        }
        break;
    case WM_KILLFOCUS:
        g_hWndLastFocus = hWnd;
        break;
    }

    return CallWindowProc(g_OldTreeProc,hWnd,uMsg,wParam,lParam);
}

CDBView::CDBView()
{
    m_pCurrentRecord = NULL;
    m_pListRecord = NULL;
    m_uContext = -1;
    m_hSelectedItem = NULL;
    m_bDrag = FALSE;
}

BOOL CDBView::Initialize(void)
{

    if ( !Create(    TEXT("DBViewClass"),
                     TEXT("This is  the first window in the DBViewer::Initialize"),
                     0,0,
                     10,10,
                     &g_theApp,
                     (HMENU)VIEW_DATABASE,
                     0,
                     WS_CHILD | WS_CLIPSIBLINGS | WS_CLIPCHILDREN) ) {
        return FALSE;
    }
    // These two windows are child of the window created above. So now we have 3 generations.....

    if ( ! m_GlobalList.Create(TEXT("CListView"),
                               TEXT("Microsoft Application Database"),
                               0,0,10,10,
                               this,
                               0,
                               0,
                               WS_CHILD | WS_VISIBLE | WS_CLIPCHILDREN | WS_CLIPSIBLINGS | WS_VISIBLE | WS_VSCROLL | WS_BORDER)
       ) return FALSE;

    if ( !m_LocalList.Create(TEXT("CListView"),
                             TEXT("Untitled.SDB"),
                             0,0,10,10,
                             this,
                             0,
                             0,
                             WS_CHILD | WS_VISIBLE | WS_CLIPCHILDREN | WS_CLIPSIBLINGS | WS_VISIBLE | WS_VSCROLL | WS_BORDER)
       )
        return FALSE;


    m_hMenu = LoadMenu(g_hInstance,MAKEINTRESOURCE(IDR_DBVIEWER));

    // Create the listview for displaying the applications in the database.

    m_uListSize = 250;

    g_theApp.ReadReg(TEXT("DBVIEW_SIZE"),&m_uListSize,sizeof(UINT));

    RECT    rRect;

    GetClientRect(g_theApp.m_hWnd,&rRect);

    m_uListHeight = rRect.bottom / 2  -2 ;

    g_theApp.ReadReg(TEXT("DBVIEW_HEIGHT"),&m_uListHeight,sizeof(UINT));

    m_hListView = CreateWindowEx(   0,
                                    WC_LISTVIEW,
                                    TEXT(""),
                                    WS_CHILD |/* WS_VISIBLE |*/ WS_BORDER | WS_CLIPSIBLINGS | LVS_REPORT | LVS_OWNERDRAWFIXED,
                                    0,0,
                                    10,10,
                                    m_hWnd,
                                    NULL,
                                    g_hInstance,
                                    NULL);

    // Subclass the window to prevent paint flashing.

    LONG uStyle = ListView_GetExtendedListViewStyle(m_hListView);

    ListView_SetExtendedListViewStyle(m_hListView,LVS_EX_FULLROWSELECT | uStyle);

    CoInitialize(NULL);

    // Create the treeview for showing the files affected by the application

    m_hTreeView = CreateWindowEx(   0,
                                    WC_TREEVIEW,
                                    TEXT(""),
                                    WS_CHILD | WS_VISIBLE | WS_BORDER | WS_CLIPSIBLINGS | TVS_HASLINES | TVS_LINESATROOT | TVS_HASBUTTONS | TVS_INFOTIP,
                                    0,0,
                                    10,10,
                                    m_hWnd,
                                    NULL,
                                    g_hInstance,
                                    NULL);
    //PREFIX
    if ( m_hTreeView == NULL ) {
        return FALSE;
    }

    g_OldTreeProc = (WNDPROC) GetWindowLongPtr(m_hTreeView,GWLP_WNDPROC);

    SetWindowLongPtr(m_hTreeView,GWLP_WNDPROC,(LONG_PTR) TreeViewProc);

    m_hImageList = ImageList_Create(16,15,ILC_COLORDDB | ILC_MASK,24,1);


    ImageList_Add(m_hImageList,LoadBitmap(g_hInstance,MAKEINTRESOURCE(IDR_MAINTOOLBAR)),NULL);

    ImageList_AddIcon(m_hImageList,LoadIcon(g_hInstance,MAKEINTRESOURCE(IDI_FIXES)));
    ImageList_AddIcon(m_hImageList,LoadIcon(g_hInstance,MAKEINTRESOURCE(IDI_HELP)));
    ImageList_AddIcon(m_hImageList,LoadIcon(g_hInstance,MAKEINTRESOURCE(IDI_MODE)));

    ZeroMemory(&m_uImageRedirector,sizeof(m_uImageRedirector));

    TreeView_SetImageList(m_hTreeView,m_hImageList,TVSIL_NORMAL);

    // Create the headers for the report list view.

    LV_COLUMN   Col;

    Col.mask = LVCF_TEXT | LVCF_WIDTH;
    Col.pszText = TEXT("Application");
    Col.cchTextMax = lstrlen(Col.pszText);
    Col.cx = m_uListSize;

    ListView_InsertColumn(m_hListView,0,&Col);
/*
    Col.pszText = "Layer";
    Col.cchTextMax = lstrlen(Col.pszText);
    Col.cx = (m_uListSize - Col.cx)-1;

    ListView_InsertColumn(m_hListView,1,&Col);
*/
/*
    LOGBRUSH    Brush;

    Brush.lbStyle = BS_SOLID;
    Brush.lbColor = RGB(235,235,235);

    m_hFillBrush = CreateBrushIndirect(&Brush);
*/
    MENUITEMINFO    Info;

    Info.cbSize = sizeof(MENUITEMINFO);
    Info.fMask = MIIM_STATE;
    Info.fState = MF_CHECKED;

    SetMenuItemInfo(m_hMenu,ID_VIEW_VIEWSHIMFIXES,MF_BYCOMMAND,&Info);
    SetMenuItemInfo(m_hMenu,ID_VIEW_VIEWLAYERFIXES,MF_BYCOMMAND,&Info);
    SetMenuItemInfo(m_hMenu,ID_VIEW_VIEWAPPHELPENTRIES,MF_BYCOMMAND,&Info);
    SetMenuItemInfo(m_hMenu,ID_VIEW_VIEWPATCHES,MF_BYCOMMAND,&Info);

    SyncMenu();

    return TRUE;
}

void CDBView::msgClose(void)
{
    //g_theApp.WriteReg("DBVIEW_HEIGHT",REG_DWORD,&m_uListHeight,sizeof(UINT));
    //g_theApp.WriteReg("DBVIEW_SIZE",REG_DWORD,&m_uListSize,sizeof(UINT));
}

BOOL CDBView::Activate(BOOL fNewCreate)
{

    if ( g_hWndLastFocus != NULL ) SetFocus(g_hWndLastFocus   );
    else                           SetFocus(m_LocalList.m_hWnd);
   
        

    
    g_theApp.AddToolbarButton(  IMAGE_SHIMWIZARD,
                                DBCMD_FIXWIZARD,
                                (NULL == CDatabase::m_pDB) ? 0:TBSTATE_ENABLED,
                                TBSTYLE_BUTTON);

    g_theApp.AddToolbarButton(  0,
                                0,
                                0,
                                TBSTYLE_SEP);

    g_theApp.AddToolbarButton(  IMAGE_DISABLEUSER,
                                DBCMD_DISABLEUSER,
                                (NULL == CDatabase::m_pDB) ? 0:TBSTATE_ENABLED,
                                TBSTYLE_BUTTON);

    g_theApp.AddToolbarButton(  IMAGE_DISABLEGLOBAL,
                                DBCMD_DISABLEGLOBAL,
                                (NULL == CDatabase::m_pDB) ? 0:TBSTATE_ENABLED,
                                TBSTYLE_BUTTON);
/*
    g_theApp.AddToolbarButton(  IMAGE_PROPERTIES,
                                DBCMD_PROPERTIES,
                                TBSTATE_ENABLED,
                                TBSTYLE_BUTTON);
    */
    g_theApp.AddToolbarButton(  IMAGE_DELETE,
                                DBCMD_DELETE,
                                0,
                                TBSTYLE_BUTTON);

    g_theApp.AddToolbarButton(  0,
                                0,
                                0,
                                TBSTYLE_SEP);

    g_theApp.AddToolbarButton(  IMAGE_VIEWSHIM,
                                DBCMD_VIEWSHIMS,
                                TBSTATE_ENABLED,
                                TBSTYLE_BUTTON | TBSTYLE_CHECK);

    g_theApp.AddToolbarButton(  IMAGE_VIEWHELP,
                                DBCMD_VIEWAPPHELP,
                                TBSTATE_ENABLED,
                                TBSTYLE_BUTTON | TBSTYLE_CHECK);

    g_theApp.AddToolbarButton(  IMAGE_VIEWPATCH,
                                DBCMD_VIEWPATCH,
                                TBSTATE_ENABLED,
                                TBSTYLE_BUTTON | TBSTYLE_CHECK);

    g_theApp.AddToolbarButton(  IMAGE_SHOWLAYERS,
                                DBCMD_VIEWLAYERS,
                                TBSTATE_ENABLED,
                                TBSTYLE_BUTTON | TBSTYLE_CHECK);

    g_theApp.AddToolbarButton(  IMAGE_VIEWDISABLED,
                                DBCMD_VIEWDISABLED,
                                TBSTATE_ENABLED,
                                TBSTYLE_BUTTON | TBSTYLE_CHECK);


/*
    g_theApp.AddToolbarButton(  IMAGE_VIEWGLOBAL,
                                DBCMD_VIEWGLOBAL,
                                TBSTATE_ENABLED,
                                TBSTYLE_BUTTON | TBSTYLE_CHECK);
*/
    //SendMessage(g_theApp.m_hToolBar,TB_CHECKBUTTON,DBCMD_VIEWSHIMS,MAKELONG(TRUE,0));
    //SendMessage(g_theApp.m_hToolBar,TB_CHECKBUTTON,DBCMD_VIEWAPPHELP,MAKELONG(TRUE,0));
    //SendMessage(g_theApp.m_hToolBar,TB_CHECKBUTTON,DBCMD_VIEWPATCH,MAKELONG(TRUE,0));
    //SendMessage(g_theApp.m_hToolBar,TB_CHECKBUTTON,DBCMD_VIEWLAYERS,MAKELONG(TRUE,0));

    SyncStates(ID_VIEW_VIEWSHIMFIXES,DBCMD_VIEWSHIMS,TRUE,FALSE);
    SyncStates(ID_VIEW_VIEWLAYERFIXES,DBCMD_VIEWLAYERS,TRUE,FALSE);
    SyncStates(ID_VIEW_SHOWDISABLEDENTRIES,DBCMD_VIEWDISABLED,TRUE,FALSE);
    SyncStates(ID_VIEW_VIEWPATCHES,DBCMD_VIEWPATCH,TRUE,FALSE);
    SyncStates(ID_VIEW_VIEWAPPHELPENTRIES,DBCMD_VIEWAPPHELP,TRUE,FALSE);

    Update(fNewCreate);

    return TRUE;
}

int CALLBACK lvSortAscend(LPARAM p1, LPARAM p2, LPARAM p3)
{
    PDBRECORD    pRecord1 = (PDBRECORD) p1;
    PDBRECORD    pRecord2 = (PDBRECORD) p2;

    return lstrcmpi(pRecord1->szAppName,pRecord2->szAppName);
}

void CDBView::Update(BOOL fNewCreate)
{



    BOOL bShowShims = (MF_CHECKED == GetMenuState(m_hMenu,ID_VIEW_VIEWSHIMFIXES,MF_BYCOMMAND)) ? TRUE:FALSE;
    BOOL bShowApphelp = (MF_CHECKED == GetMenuState(m_hMenu,ID_VIEW_VIEWAPPHELPENTRIES,MF_BYCOMMAND)) ? TRUE:FALSE;
    BOOL bShowPatch = (MF_CHECKED == GetMenuState(m_hMenu,ID_VIEW_VIEWPATCHES,MF_BYCOMMAND)) ? TRUE:FALSE;
    BOOL bShowLayers = (MF_CHECKED == GetMenuState(m_hMenu,ID_VIEW_VIEWLAYERFIXES,MF_BYCOMMAND)) ? TRUE:FALSE;
    BOOL bShowDisabledOnly = (MF_CHECKED == GetMenuState(m_hMenu,ID_VIEW_SHOWDISABLEDENTRIES,MF_BYCOMMAND)) ? TRUE:FALSE;
    TCHAR szTemp[MAX_PATH_BUFFSIZE];
    CSTRING szName;

    
    
        HWND hWnd = GetFocus();
    //The GetFocus function retrieves the handle to the window that has the 
    //keyboard focus, if the window is attached to the calling thread's message queue.

    if ( m_GlobalList.m_hWnd != hWnd && m_hTreeView != hWnd && m_LocalList.m_hWnd != hWnd ) {
        SetFocus(m_GlobalList.m_hWnd);
    }

      

    if ( g_theApp.GetDBLocal().m_szCurrentDatabase.Length() > 0 )
        szName = g_theApp.GetDBLocal().m_szCurrentDatabase;//Name of the SDB File
    else
        szName = TEXT("Untitled.SDB");

    if ( szName.Length() == 0 ) {
        MEM_ERR;
        return;
    }
    szName.ShortFilename();

    _snwprintf(szTemp,sizeof(szTemp)/sizeof(TCHAR), TEXT("%s (%s)"),(LPCTSTR)szName,(LPCTSTR)g_theApp.GetDBLocal().m_DBName);


    //First the name of the SDB, then the name of the database.

    SetWindowText(m_LocalList.m_hWnd,szTemp);

    if ( NULL == g_theApp.GetDBLocal().m_pDB )
    //K The database is closed, that is we are working on the system DB
    {
        g_theApp.SetButtonState(DBCMD_FIXWIZARD,0);
    }

    g_theApp.SetButtonState(DBCMD_FIXWIZARD,TBSTATE_ENABLED);

    // Enumerate the applications

    //SendMessage(m_hListView,WM_SETREDRAW,FALSE,0);
    SendMessage(m_GlobalList.m_hWnd,WM_SETREDRAW,FALSE,0);
    




    if ( fNewCreate ) {
        m_GlobalList.RemoveAllEntries();
        m_LocalList.RemoveAllEntries();

    }




    // Clear and update the list view with current information.



    PDBRECORD pWalk = g_theApp.GetDBGlobal().m_pRecordHead;
    PDBRECORD pWalk2 = g_theApp.GetDBGlobal().m_pRecordHead;

    int nItem = 0;

    for (int iLoop = 0 ; iLoop <= 1 ; ++iLoop) {
    
    while ( NULL != pWalk2 && fNewCreate )//For all exes 
    //Loop control by pWalk2
    {
        BOOL        bShow = FALSE;
        pWalk = pWalk2;

        while ( NULL != pWalk )
        //Follows all exes of the same application as that of the pWalk2 exe
        // including pWalk2, with the help of the pWalk->pDup
        {
            //LV_ITEM     Item;
            PDBENTRY    pEntry = pWalk->pEntries;

            if ( 0 != pWalk->szLayerName.Length() && bShowLayers )
                bShow = TRUE;

            while ( NULL != pEntry && !bShow ) {// Not for layers
                /*
                Note that both Shims and Patches have the same uTupe as 
                ENTRY_SHIM and they are distinguished by only the SHIMDESC.bSim
                */

                if ( ENTRY_SHIM == pEntry->uType ) {
                    PSHIMENTRY pShim = (PSHIMENTRY) pEntry;

                    if ( NULL != pShim->pDesc ) {
                        if ( bShowShims && pShim->pDesc->bShim )//This is a shim and not Patch
                            bShow = TRUE;

                        if ( bShowPatch && !pShim->pDesc->bShim )//Patch
                            bShow = TRUE;
                    } else
                          #ifdef __DEBUG
                          __asm int 3;//Trap to debugger.
                                     
                           #endif
                           ;
                }       


                if ( ENTRY_APPHELP == pEntry->uType && bShowApphelp )
                    bShow = TRUE;

                pEntry = pEntry->pNext;
            }



            if ( bShow ) {
                // Determine if we're showing disabled only.
                /* This "if" condition is TRUE then it means that the entry is enabled but we
                are interested in viwing only "disabled entries".
                
                So we skip this EXE entry and look for other exes/entries in the same 
                application as this one, hoping to find one that is disabled.
                So that this application can be included in the list of
                applications to be shown
                 
                */
                if ( 0 == pWalk->dwUserFlags && 0 == pWalk->dwGlobalFlags && bShowDisabledOnly ) {
                    bShow = FALSE;
                    pWalk = pWalk->pDup;
                    continue;//Go to next file of the same application
                }
                break;
            }
            pWalk = pWalk->pDup;//Go to next file of the same application, bShow was FALSE
        }//while (NULL != pWalk)

        if ( bShow ) {
            if ( pWalk2->bGlobal )
                m_GlobalList.AddEntry(pWalk2->szAppName,0,pWalk2);
            else
                m_LocalList.AddEntry(pWalk2->szAppName,0,pWalk2);
        }



        pWalk2 = pWalk2->pNext;// Go to the next exe.

    }//while (NULL != pWalk2 && fNewCreate) 
    pWalk = g_theApp.GetDBLocal().m_pRecordHead;  
    pWalk2 = g_theApp.GetDBLocal().m_pRecordHead; 
    } //for

    //ListView_SortItems(m_hListView,lvSortAscend,0);
    // Update the list view

    //SendMessage(m_hListView,WM_SETREDRAW,TRUE,0);
    //UpdateWindow(m_hListView);



    SendMessage(m_GlobalList.m_hWnd,WM_SETREDRAW,TRUE,0);


    m_GlobalList.Refresh();
    m_LocalList.Refresh();


}

void CDBView::msgResize(UINT uWidth, UINT uHeight)
{
    //MoveWindow(m_hListView,0,0,m_uListSize,uHeight/2,TRUE);

    MoveWindow(m_GlobalList.m_hWnd,0,0,m_uListSize,m_uListHeight,TRUE);
    MoveWindow(m_LocalList.m_hWnd,0,m_uListHeight + SLIDER_WIDTH,m_uListSize,(uHeight - m_uListHeight) - SLIDER_WIDTH,TRUE);

    MoveWindow(m_hTreeView,m_uListSize + SLIDER_WIDTH,0,uWidth - m_uListSize,uHeight,TRUE);

    //InvalidateRect(m_hListView,NULL,TRUE);
    //UpdateWindow(m_hListView);
    UpdateWindow(m_hTreeView);

    Refresh();
}

void CDBView::RefreshTree(void)
{
    SendMessage(m_hTreeView,WM_SETREDRAW,FALSE,0);

    TreeView_DeleteAllItems(m_hTreeView);

    PDBRECORD pRecord = m_pListRecord;

    while ( NULL != pRecord ) {
        AddRecordToTree(pRecord);

        pRecord = pRecord->pDup;
    }

    SendMessage(m_hTreeView,WM_SETREDRAW,TRUE,0);

    SyncMenu();
}

void CDBView::msgCommand(UINT uID, HWND hSender)
{
    switch ( uID ) {
    case    ID_DATABASE_CHANGEDATABASENAME:
        {
            g_theApp.GetDBLocal().ChangeDatabaseName();

            m_LocalList.Refresh();
        }
        break;

    case    ID_FILE_EXPORTXML:
    case    ID_DATABASE_GENERATEXML:
        {
            CXMLDialog  XML;

            XML.BeginXMLView(g_theApp.GetDBLocal().m_pRecordHead,m_hWnd,TRUE,TRUE,TRUE,TRUE,FALSE);
        }
        break;

    case    ID_EDIT_ADDMATCHINGINFORMATION:
    case    ID_NA2_ADDMATCHINGINFORMATION:
        {
            CSTRING szFilename;

            
            if (m_pCurrentRecord == NULL) {
                    MessageBox(this->m_hWnd, TEXT("Please select a file for the specified operation\nYou might need to re-select the application on the left first."), TEXT("CompatAdmin"),MB_ICONWARNING);
                    break;
                }

            
            
            if ( g_theApp.GetFilename(TEXT("Find matching file"),TEXT("All files (*.*)\0*.*\0\0"),TEXT(""),TEXT(""),OFN_PATHMUSTEXIST | OFN_FILEMUSTEXIST,TRUE,szFilename) ) {
                CShimWizard     Wiz;
                PMATCHENTRY     pEntry = new MATCHENTRY;
                if ( pEntry == NULL ) {
                    MEM_ERR;
                    break;
                }

                
                if (m_pCurrentRecord == NULL) {
                    MessageBox(this->m_hWnd, TEXT("Please select a file for the specified operation\nYou might need to re-select the application on the left first."), TEXT("Compatadmin"),MB_ICONWARNING);
                    break;
                }


                PDBENTRY        pWalk = m_pCurrentRecord->pEntries;
                PMATCHENTRY     pSrc = NULL;
                CSTRING         szCheck = szFilename;
                szCheck.ShortFilename();

                while ( NULL != pWalk ) {
                    if ( ENTRY_MATCH == pWalk->uType ) {
                        PMATCHENTRY pTest = (PMATCHENTRY) pWalk;
                        CSTRING     szShort = pTest->szMatchName;

                        szShort.ShortFilename();

                        if ( pTest->szMatchName == TEXT("*") )
                            pSrc = pTest;

                        if ( szShort == szCheck ) {
                            MessageBox(m_hWnd,TEXT("This file is already being used for matching information. To update, please remove and re-add it."),TEXT("File matching error"),MB_OK);
                            return;
                        }
                    }

                    pWalk = pWalk->pNext;
                }

                //BUG: NULL pSrc
                //if (pSrc->szFullName.Length() == 0)

                if ( (pSrc->szFullName.Length() == 0) ) {
                    CSTRING szSrc;

                    MessageBox(m_hWnd,TEXT("In order to properly resolve the relative path of the file to be matched, the source executable must be specified.\n\nThis next step will ask for the source executable location."),TEXT("Locate source executable"),MB_ICONWARNING);

                    if ( g_theApp.GetFilename(TEXT("Find source executable"),TEXT("All files (*.*)\0*.*\0\0"),TEXT(""),TEXT(""),OFN_PATHMUSTEXIST | OFN_FILEMUSTEXIST,TRUE,szSrc) ) {
                        szCheck = szSrc;

                        szCheck.ShortFilename();

                        if ( szCheck == m_pCurrentRecord->szEXEName )
                            pSrc->szFullName = szSrc;
                        else {
                            MessageBox(m_hWnd,TEXT("The source executable must have the same name as file to be fixed"),TEXT("Source file error"),MB_ICONERROR);
                            break;
                        }
                    } else
                        break;
                }

                // BUGBUG: THIS SUCKS. Move GetFileAttributes() et al to someplace
                // more utility oriented.. like CDatabase or something.

                if ( NULL != pEntry ) {
                    ZeroMemory(pEntry,sizeof(MATCHENTRY));

                    HANDLE hFile = CreateFile((LPCTSTR) szFilename,GENERIC_READ,0,NULL,OPEN_EXISTING,FILE_ATTRIBUTE_NORMAL,NULL);

                    if ( INVALID_HANDLE_VALUE != hFile ) {
                        pEntry->dwSize = GetFileSize(hFile,NULL);

                        CloseHandle(hFile);
                    }

                    pEntry->Entry.uType = ENTRY_MATCH;
                    pEntry->Entry.uIconID = 0;
                    pEntry->szFullName = szFilename;

                    if (szFilename.RelativeFile(pSrc->szFullName) == FALSE) {

                        //
                        //The matching file is not on the same drive as the matching file
                        //

                        MessageBox( NULL,
                                    TEXT("The matching file and the matched file are not on the same drive."),
                                    TEXT("Matching Error"),
                                    MB_ICONWARNING
                                    );


                        break;


                    }



                    pEntry->szMatchName = szFilename;

                    Wiz.GetFileAttributes(pEntry);

                    // Take this file and add it to the current record.

                    // Insert at the end

                    PDBENTRY pWalk = m_pCurrentRecord->pEntries;
                    PDBENTRY pHold = NULL;

                    while ( NULL != pWalk ) {
                        pHold = pWalk;
                        pWalk = pWalk->pNext;
                    }

                    if ( pHold != NULL ) {
                        pHold->pNext = (PDBENTRY) pEntry;
                    }


                    pEntry->Entry.pNext = NULL;

                    // Update the tree.

                    RefreshTree();

                    g_theApp.GetDBLocal().m_bDirty = TRUE;
                    g_theApp.UpdateView(TRUE);
                }
            }
        }//case    ID_NA2_ADDMATCHINGINFORMATION:
        break;

    case    ID_DATABASE_REMOVEENTRY:
    case    ID_NA_REMOVEANENTRY:
        {
            HTREEITEM hParent = TreeView_GetParent(m_hTreeView,m_hSelectedItem);

            while ( NULL != hParent ) {
                HTREEITEM hNew = TreeView_GetParent(m_hTreeView,hParent);

                if ( NULL != hNew )
                    hParent = hNew;
                else
                    break;
            }

            //
            //hParent is the item whose parent is NULL
            //

            if ( NULL == hParent )
                hParent = m_hSelectedItem;

            DeleteDBWithTree(hParent);

        }
        break;


    case    ID_EDIT_REMOVEMATCHINGINFORMATION:
    case    ID_NA2_REMOVEMATCHINGINFORMATION:
        {
            DeleteDBWithTree(m_hSelectedItem);
        }
        break;

    case    ID_DATABASE_DEFINECUSTOMLAYER:
        {
            CCustomLayer    Layer;
            HWND            hWnd = GetFocus();

            if ( Layer.AddCustomLayer() ) {
                g_theApp.GetDBLocal().m_bDirty = TRUE;

                g_theApp.UpdateView(TRUE);

                SetFocus(hWnd);

                SyncMenu();
            }
        }
        break;

    case    ID_DATABASE_EDITCUSTOMCOMPATIBILITYMODE:
        {
            CCustomLayer    Layer;

            if ( Layer.EditCustomLayer() ) {
                g_theApp.GetDBLocal().m_bDirty = TRUE;

                g_theApp.UpdateView(TRUE);
            }
        }
        break;

    case    ID_DATABASE_REMOVECUSTOMCOMPATIBILITYMODE:
        {
            CCustomLayer    Layer;
            HWND            hWnd = GetFocus();

            if ( Layer.RemoveCustomLayer() ) {
                g_theApp.GetDBLocal().m_bDirty = TRUE;

                g_theApp.UpdateView(TRUE);

                SetFocus(hWnd);

                SyncMenu();
            }
        }
        break;

    case    DBCMD_VIEWSHIMS:
        SyncStates(ID_VIEW_VIEWSHIMFIXES,DBCMD_VIEWSHIMS,TRUE,FALSE);
        Update();
        break;

    case    DBCMD_VIEWDISABLED:
        SyncStates(ID_VIEW_SHOWDISABLEDENTRIES,DBCMD_VIEWDISABLED,TRUE,FALSE);
        Update();
        break;

    case    ID_VIEW_VIEWSHIMFIXES:
        SyncStates(ID_VIEW_VIEWSHIMFIXES,DBCMD_VIEWSHIMS,FALSE,TRUE);
        Update();
        break;

    case    DBCMD_VIEWPATCH:
        SyncStates(ID_VIEW_VIEWPATCHES,DBCMD_VIEWPATCH,TRUE,FALSE);
        Update();
        break;

    case    DBCMD_VIEWLAYERS:
        SyncStates(ID_VIEW_VIEWLAYERFIXES,DBCMD_VIEWLAYERS,TRUE,FALSE);
        Update();
        break;

    case    DBCMD_VIEWAPPHELP:
        SyncStates(ID_VIEW_VIEWAPPHELPENTRIES,DBCMD_VIEWAPPHELP,TRUE,FALSE);
        Update();
        break;

    case    ID_VIEW_VIEWAPPHELPENTRIES:
        SyncStates(ID_VIEW_VIEWAPPHELPENTRIES,DBCMD_VIEWAPPHELP,FALSE,TRUE);
        Update();
        break;

    case    ID_VIEW_VIEWLAYERFIXES:
        SyncStates(ID_VIEW_VIEWLAYERFIXES,DBCMD_VIEWLAYERS,FALSE,TRUE);
        Update();
        break;

    case    ID_VIEW_VIEWPATCHES:
        SyncStates(ID_VIEW_VIEWPATCHES,DBCMD_VIEWPATCH,FALSE,TRUE);
        Update();
        break;

    case    ID_VIEW_SHOWDISABLEDENTRIES:
        SyncStates(ID_VIEW_SHOWDISABLEDENTRIES,DBCMD_VIEWDISABLED,FALSE,TRUE);
        Update();
        break;


    case    ID_TEST_TESTRUN:
    case    ID_TESTRUN:
        {
            HWND hwndFocus = GetFocus();
            if ( NULL != m_pCurrentRecord )
                g_theApp.TestRun(m_pCurrentRecord,NULL,NULL,g_theApp.m_hWnd);

            SetFocus(hwndFocus);
        }
        break;

    case    ID_VIEWXML:
        {
            CXMLDialog  XML;

            if ( NULL != m_pCurrentRecord )
                XML.BeginXMLView(m_pCurrentRecord,m_hWnd,FALSE);
            else
                XML.BeginXMLView(m_pListRecord,m_hWnd,TRUE);
        }
        break;

    case ID_DATABASE_CREATENEWAPPHELPMESSAGE:
        {
            CAppHelpWizard wizAppHelp;

            if ( wizAppHelp.BeginWizard(m_hWnd) ) {
                g_theApp.GetDBLocal().m_bDirty = TRUE;

                g_theApp.UpdateView(TRUE);

                Update();
            }            
            break;
        }

    case    ID_ADDENTRY:
    case    ID_DATABASE_ADDANENTRY:
    case    DBCMD_FIXWIZARD:
        {
            CShimWizard Wiz;

            if ( Wiz.BeginWizard(m_hWnd) ) {
                g_theApp.GetDBLocal().m_bDirty = TRUE;

                g_theApp.UpdateView(TRUE);

                Update();
            }
        }
        break;

    case    ID_EDIT_ENABLEDISABLEGLOBALLY:
    case    ID_DISABLEGLOBALLY:
    case    DBCMD_DISABLEGLOBAL:
        {
                        
            if ( NULL == m_pCurrentRecord )
                break;

            //DWORD   dwFlags = DialogBoxParam(g_hInstance,MAKEINTRESOURCE(IDD_DISABLE),m_hWnd,DisableDialog,(LPARAM) m_pCurrentRecord->dwGlobalFlags);

            
            DWORD dwFlags = !m_pCurrentRecord->dwGlobalFlags;

            //if (dwFlags != m_pCurrentRecord->dwGlobalFlags)
            //{
            // Save new flags

            m_pCurrentRecord->dwGlobalFlags = dwFlags;

            // Update the registry

            CDatabase::SetEntryFlags(HKEY_LOCAL_MACHINE,m_pCurrentRecord->guidID,dwFlags);

            // Refresh tree view

            SendMessage(m_hTreeView,WM_SETREDRAW,FALSE,0);

            PDBRECORD pHoldCurrent = m_pCurrentRecord;

            TreeView_DeleteAllItems(m_hTreeView);

            PDBRECORD pRecord = m_pListRecord;

            while ( NULL != pRecord ) {
                AddRecordToTree(pRecord);

                pRecord = pRecord->pDup;
            }

            SendMessage(m_hTreeView,WM_SETREDRAW,TRUE,0);

            InvalidateRect(m_hListView,NULL,TRUE);
            UpdateWindow(m_hListView);

            TreeView_SelectItem(m_hTreeView,NULL);

            m_pCurrentRecord = pHoldCurrent;

            SyncMenu();
            //}
        }
        break;

    case    ID_EDIT_ENABLEDISABLELOCALLY:
    case    ID_DISABLEFORUSER:
    case    DBCMD_DISABLEUSER:
        {
            if ( NULL == m_pCurrentRecord )
                break;

            //DWORD   dwFlags = DialogBoxParam(g_hInstance,MAKEINTRESOURCE(IDD_DISABLE),m_hWnd,DisableDialog,(LPARAM) m_pCurrentRecord->dwUserFlags | 0x80000000);

            DWORD dwFlags = !m_pCurrentRecord->dwUserFlags;

            //if (dwFlags != m_pCurrentRecord->dwUserFlags)
            //{
            // Save new flags

            m_pCurrentRecord->dwUserFlags = dwFlags;

            // Update the registry

            CDatabase::SetEntryFlags(HKEY_CURRENT_USER,m_pCurrentRecord->guidID,dwFlags);

            // Refresh tree view

            SendMessage(m_hTreeView,WM_SETREDRAW,FALSE,0);

            PDBRECORD pHoldCurrent = m_pCurrentRecord;

            TreeView_DeleteAllItems(m_hTreeView);

            PDBRECORD pRecord = m_pListRecord;

            while ( NULL != pRecord ) {
                AddRecordToTree(pRecord);

                pRecord = pRecord->pDup;
            }

            SendMessage(m_hTreeView,WM_SETREDRAW,TRUE,0);
            InvalidateRect(m_hListView,NULL,TRUE);
            UpdateWindow(m_hListView);

            TreeView_SelectItem(m_hTreeView,NULL);

            m_pCurrentRecord = pHoldCurrent;

            SyncMenu();
            //}
        }
        break;
    }
}

void CDBView::msgPaint(HDC hDC)
{
    RECT    rRect;

    // Draw the slider bar

    GetClientRect(m_hWnd,&rRect);

    SetRect(&rRect,m_uListSize+1,0,m_uListSize + SLIDER_WIDTH - 1,rRect.bottom);
    FillRect(hDC,&rRect,(HBRUSH) (COLOR_BTNFACE + 1));

    SetRect(&rRect,m_uListSize-1,0,m_uListSize+1,rRect.bottom);
    FillRect(hDC,&rRect,(HBRUSH) GetStockObject(WHITE_BRUSH));

    SetRect(&rRect,m_uListSize+SLIDER_WIDTH - 1,0,m_uListSize + SLIDER_WIDTH + 1,rRect.bottom);
    FillRect(hDC,&rRect,(HBRUSH) GetStockObject(GRAY_BRUSH));

    
    // Draw horizontal bar.

    SetRect(&rRect,0,m_uListHeight ,rRect.right,m_uListHeight + SLIDER_WIDTH - 1);
    FillRect(hDC,&rRect,(HBRUSH) (COLOR_BTNFACE + 1));

    SetRect(&rRect,0,m_uListHeight + SLIDER_WIDTH,rRect.right,m_uListHeight + SLIDER_WIDTH + 1);
    FillRect(hDC,&rRect,(HBRUSH) GetStockObject(GRAY_BRUSH));
}

void CDBView::AddRecordToTree(PDBRECORD pRecord)
{
    PDBENTRY        pEntry;
    HTREEITEM       hRoot;
    HTREEITEM       hShim = NULL;
    HTREEITEM       hMatch = NULL;
    HTREEITEM       hAppHelp = NULL;
    UINT            uImage;

    uImage = LookupFileImage(pRecord->szEXEName,IMAGE_APPLICATION);

    // Add the main .EXE/.DLL or other file that's affected by this record.

    if ( 0 != (pRecord->dwUserFlags | pRecord->dwGlobalFlags) )
        uImage = IMAGE_WARNING;

    hRoot = AddTreeItem(TVI_ROOT,
                        TVIF_TEXT | TVIF_STATE | TVIF_IMAGE | TVIF_SELECTEDIMAGE | TVIF_PARAM,
                        TVIS_EXPANDED,
                        pRecord->szEXEName,
                        uImage,
                        (LPARAM) pRecord);
/*
    if (0 != pRecord->guidID.Data1)
    {
        TCHAR   szGUID[80];

        // NOTE: We could use StringFromGUID2, or StringfromIID, but that
        // would require loading OLE32.DLL. Unless we have to, avoid it.

        wsprintf(szGUID, "{%08x-%04x-%04x-%02x%02x-%02x%02x%02x%02x%02x%02x}",
                 pRecord->guidID.Data1,
                 pRecord->guidID.Data2,
                 pRecord->guidID.Data3,
                 pRecord->guidID.Data4[0],
                 pRecord->guidID.Data4[1],
                 pRecord->guidID.Data4[2],
                 pRecord->guidID.Data4[3],
                 pRecord->guidID.Data4[4],
                 pRecord->guidID.Data4[5],
                 pRecord->guidID.Data4[6],
                 pRecord->guidID.Data4[7]);

        AddTreeItem(  hRoot,
                      TVIF_TEXT | TVIF_IMAGE | TVIF_SELECTEDIMAGE,
                      0,
                      szGUID,
                      IMAGE_GUID);
    }
*/
    //
    //The tree tip is done here
    //

    if ( 0 != pRecord->dwGlobalFlags ) {
        PDBTREETIP   pTip = &m_TipList[m_uNextTip++];

        pTip->uType = ENTRY_UI;
        pTip->uContext = 3;

        if ( pRecord->bGlobal )
            pTip->uContext = 2;

        HTREEITEM   hGlobal;

        hGlobal = AddTreeItem(  hRoot,
                                TVIF_TEXT | TVIF_STATE | TVIF_IMAGE | TVIF_SELECTEDIMAGE | TVIF_PARAM,
                                TVIS_EXPANDED,
                                TEXT("Disabled"),
                                IMAGE_DISABLEGLOBAL,
                                (LPARAM) pTip);

        //WriteFlagsToTree(hGlobal,pRecord->dwGlobalFlags);
    }
/*
    if (0 != pRecord->dwUserFlags)
    {
        PDBTREETIP   pTip = &m_TipList[m_uNextTip++];

        pTip->uType = ENTRY_UI;
        pTip->uContext = 3;

        if (pRecord->bGlobal)
            pTip->uContext = 2;

        HTREEITEM   hUser;
        
        hUser = AddTreeItem(hRoot,
                            TVIF_TEXT | TVIF_STATE | TVIF_IMAGE | TVIF_SELECTEDIMAGE | TVIF_PARAM,
                            TVIS_EXPANDED,
                            "Disabled Locally",
                            IMAGE_DISABLEUSER,
                            (LPARAM) pTip);

        //WriteFlagsToTree(hUser,pRecord->dwUserFlags);
    }
*/
    pEntry = pRecord->pEntries;

    BOOL bHasMatch = FALSE;
    BOOL bHasShim = FALSE;
    BOOL bHasAppHelp = FALSE;
    BOOL bHasLayer = FALSE;

    while ( NULL != pEntry ) {
        if ( ENTRY_MATCH == pEntry->uType )
            bHasMatch = TRUE;

        if ( ENTRY_SHIM == pEntry->uType )
            bHasShim = TRUE;

        if ( pRecord->szLayerName.Length() > 0 )
            bHasLayer = TRUE;

        if ( ENTRY_APPHELP == pEntry->uType )
            bHasAppHelp = TRUE;

        pEntry = pEntry->pNext;
    }

    if ( bHasAppHelp ) {
        PDBTREETIP   pTip = &m_TipList[m_uNextTip++];

        pTip->uType = ENTRY_UI;
        pTip->uContext = 3;

        if ( pRecord->bGlobal )
            pTip->uContext = 2;

        hAppHelp = AddTreeItem( hRoot,
                                TVIF_TEXT | TVIF_STATE | TVIF_IMAGE | TVIF_SELECTEDIMAGE | TVIF_PARAM,
                                TVIS_EXPANDED,
                                TEXT("Application Help"),
                                IMAGE_APPHELP,
                                (LPARAM) pTip);
    }

    if ( bHasLayer ) {
        PDBTREETIP   pTip = &m_TipList[m_uNextTip++];

        pTip->uType = ENTRY_UI;
        pTip->uContext = 3;

        if ( pRecord->bGlobal )
            pTip->uContext = 2;

        TCHAR   szText[ MAX_PATH * 10 ];

        wsprintf(szText,TEXT("Applied Compatibility Modes: %s"),pRecord->szLayerName);

        hShim = AddTreeItem(hRoot,
                            TVIF_TEXT | TVIF_STATE | TVIF_IMAGE | TVIF_SELECTEDIMAGE | TVIF_PARAM,
                            TVIS_EXPANDED,
                            szText,
                            IMAGE_LAYERS,
                            (LPARAM) pTip);
    }

    if ( bHasShim ) {
        PDBTREETIP   pTip = &m_TipList[m_uNextTip++];

        pTip->uType = ENTRY_UI;
        pTip->uContext = 3;

        if ( pRecord->bGlobal )
            pTip->uContext = 2;

        hShim = AddTreeItem(hRoot,
                            TVIF_TEXT | TVIF_STATE | TVIF_IMAGE | TVIF_SELECTEDIMAGE | TVIF_PARAM,
                            0,
                            TEXT("Applied Compatability Fixes"),
                            IMAGE_SHIM,
                            (LPARAM) pTip);
    }

    if ( bHasMatch ) {
        PDBTREETIP   pTip = &m_TipList[m_uNextTip++];

        pTip->uType = ENTRY_UI;
        pTip->uContext = 3;

        if ( pRecord->bGlobal )
            pTip->uContext = 2;

        hMatch = AddTreeItem(hRoot,
                             TVIF_TEXT | TVIF_STATE | TVIF_PARAM,
                             0, //TVIS_EXPANDED,
                             TEXT("File Matching"),
                             0,
                             (LPARAM) pTip);
    }

    pEntry = pRecord->pEntries;

    while ( NULL != pEntry ) {
        switch ( pEntry->uType ) {
        case    ENTRY_APPHELP:
            {
                PHELPENTRY  pHelp = (PHELPENTRY) pEntry;
                PDBTREETIP  pTip = &m_TipList[m_uNextTip++];
                TCHAR     * szText[]={  TEXT("None"),
                    TEXT("Non-Blocking"),
                    TEXT("Hard Block"),
                    TEXT("Minor Problem"),
                    TEXT("Reinstall application"),
                    TEXT("Version Sub"),
                    TEXT("Shim")};

                pTip->uType = ENTRY_APPHELP;
                pTip->pHelp = pHelp;
                pTip->uContext = 0;

                if ( pRecord->bGlobal )
                    pTip->uContext = 2;

                AddTreeItem(hAppHelp,
                            TVIF_TEXT | TVIF_PARAM,
                            0,
                            szText[pHelp->uSeverity],
                            0,
                            (LPARAM) pTip);
            }
            break;
        case    ENTRY_SHIM:
            {
                PSHIMENTRY  pShim = (PSHIMENTRY) pEntry;
                PSHIMDESC   pDesc;
                HTREEITEM   hShimName;

                pDesc = g_theApp.GetDBGlobal().m_pShimList;

                while ( NULL != pDesc ) {
                    if ( 0 == lstrcmpi(pDesc->szShimName,pShim->szShimName) )
                        break;

                    pDesc=pDesc->pNext;
                }

                PDBTREETIP   pTip = &m_TipList[m_uNextTip++];

                pTip->uType = ENTRY_SHIM;
                pTip->pShim = pDesc;
                pTip->uContext = 0;

                if ( pRecord->bGlobal )
                    pTip->uContext = 2;

                TCHAR   szText[MAX_PATH * 10];

                if ( NULL != pDesc ) {
                    if ( pDesc->bShim )
                        wsprintf(szText,TEXT("Compat Fix: %s"),pShim->szShimName);
                    else
                        wsprintf(szText,TEXT("Patch: %s"),pShim->szShimName);
                } else
                    lstrcpy(szText,pShim->szShimName);

                //
                //Always look up the image or use the default image for all the shims. the foll 2 lines not required
                //
                //
                //Also look for the include, exclude items.

                if ( 0 == pShim->Entry.uIconID )
                    pShim->Entry.uIconID = LookupFileImage(pShim->szShimName,IMAGE_APPLICATION);

                hShimName = AddTreeItem(hShim,
                                        TVIF_TEXT | TVIF_PARAM | TVIF_IMAGE | TVIF_SELECTEDIMAGE,
                                        0,
                                        szText,
                                        IMAGE_SHIM,//pShim->Entry.uIconID,
                                        (LPARAM) pTip);

                if ( lstrlen(pShim->szCmdLine) > 0 ) {
                    wsprintf(szText,TEXT("Command Line: %s"),(LPCTSTR) pShim->szCmdLine);

                    AddTreeItem(hShimName,
                                TVIF_TEXT,
                                0,
                                szText);
                }
            }
            break;

        case    ENTRY_MATCH:
            {
                PMATCHENTRY     pMatch = (PMATCHENTRY) pEntry;
                TCHAR           szText[MAX_PATH * 10];
                HTREEITEM       hFile = hMatch;

                if ( lstrlen(pMatch->szMatchName) > 0 ) {
                    PDBTREETIP   pTip = &m_TipList[m_uNextTip++];

                    pTip->uType = ENTRY_MATCH;
                    pTip->pMatch = pMatch;
                    pTip->uContext = 1;

                    if ( pRecord->bGlobal )
                        pTip->uContext = 2;

                    if ( TEXT('*') != *(LPCTSTR)pMatch->szMatchName )
                        wsprintf(szText,TEXT("Match File: %s"),pMatch->szMatchName);
                    else {
                        pTip->uContext = 3;
                        wsprintf(szText,TEXT("Match File: %s"),pRecord->szEXEName);
                    }

                    if ( 0 == pMatch->Entry.uIconID )
                        pMatch->Entry.uIconID = LookupFileImage(pMatch->szMatchName,IMAGE_APPLICATION);

                    hFile = AddTreeItem(hMatch,
                                        TVIF_TEXT | TVIF_PARAM | TVIF_IMAGE | TVIF_SELECTEDIMAGE,
                                        0,
                                        szText,
                                        pMatch->Entry.uIconID,
                                        (LPARAM) pTip);
                }

                if ( lstrlen(pMatch->szDescription) > 0 ) {
                    wsprintf(szText,TEXT("Description: %s"),pMatch->szDescription);

                    PDBTREETIP   pTip = &m_TipList[m_uNextTip++];

                    pTip->uType = ENTRY_SUBMATCH;
                    pTip->pMatch = pMatch;
                    pTip->uID = MATCH_DESCRIPTION;
                    pTip->uContext = 3;

                    if ( pRecord->bGlobal )
                        pTip->uContext = 2;

                    AddTreeItem(hFile,
                                TVIF_TEXT | TVIF_PARAM,
                                0,
                                szText,
                                0,
                                (LPARAM) pTip);
                }

                if ( lstrlen(pMatch->szCompanyName) > 0 ) {
                    wsprintf(szText,TEXT("Company Name: %s"),pMatch->szCompanyName);

                    PDBTREETIP   pTip = &m_TipList[m_uNextTip++];

                    pTip->uType = ENTRY_SUBMATCH;
                    pTip->pMatch = pMatch;
                    pTip->uID = MATCH_COMPANY;
                    pTip->uContext = 3;

                    if ( pRecord->bGlobal )
                        pTip->uContext = 2;

                    AddTreeItem(hFile,
                                TVIF_TEXT | TVIF_PARAM,
                                0,
                                szText,
                                0,
                                (LPARAM) pTip);
                }

                if ( pMatch->dwSize > 0 ) {
                    DWORD   dwSize = pMatch->dwSize;
                    TCHAR   szSize[80];

                    FormatFileSize(pMatch->dwSize,szSize);

                    wsprintf(szText,TEXT("File Size: %s bytes"),szSize);

                    PDBTREETIP   pTip = &m_TipList[m_uNextTip++];

                    pTip->uType = ENTRY_SUBMATCH;
                    pTip->pMatch = pMatch;
                    pTip->uID = MATCH_SIZE;
                    pTip->uContext = 3;

                    if ( pRecord->bGlobal )
                        pTip->uContext = 2;

                    AddTreeItem(hFile,
                                TVIF_TEXT | TVIF_PARAM,
                                0,
                                szText,
                                0,
                                (LPARAM) pTip);
                }

                if ( pMatch->dwChecksum > 0 ) {
                    wsprintf(szText,TEXT("Checksum: %08X"),pMatch->dwChecksum);

                    PDBTREETIP   pTip = &m_TipList[m_uNextTip++];

                    pTip->uType = ENTRY_SUBMATCH;
                    pTip->pMatch = pMatch;
                    pTip->uID = MATCH_CHECKSUM;
                    pTip->uContext = 3;

                    if ( pRecord->bGlobal )
                        pTip->uContext = 2;

                    AddTreeItem(hFile,
                                TVIF_TEXT | TVIF_PARAM,
                                0,
                                szText,
                                0,
                                (LPARAM) pTip);
                }

                if ( lstrlen(pMatch->szProductVersion) > 0 ) {
                    wsprintf(szText,TEXT("Product Version: %s"),pMatch->szProductVersion);

                    PDBTREETIP   pTip = &m_TipList[m_uNextTip++];

                    pTip->uType = ENTRY_SUBMATCH;
                    pTip->pMatch = pMatch;
                    pTip->uID = MATCH_PRODUCTVERSTRING;
                    pTip->uContext = 3;

                    if ( pRecord->bGlobal )
                        pTip->uContext = 2;

                    AddTreeItem(hFile,
                                TVIF_TEXT | TVIF_PARAM,
                                0,
                                szText,
                                0,
                                (LPARAM) pTip);
                }

                if ( lstrlen(pMatch->szFileVersion) > 0 ) {
                    wsprintf(szText,TEXT("File Version: %s"),pMatch->szFileVersion);

                    PDBTREETIP   pTip = &m_TipList[m_uNextTip++];

                    pTip->uType = ENTRY_SUBMATCH;
                    pTip->pMatch = pMatch;
                    pTip->uID = MATCH_FILEVERSTRING;
                    pTip->uContext = 3;

                    if ( pRecord->bGlobal )
                        pTip->uContext = 2;

                    AddTreeItem(hFile,
                                TVIF_TEXT | TVIF_PARAM,
                                0,
                                szText,
                                0,
                                (LPARAM) pTip);
                }

                if ( pMatch->FileVersion.QuadPart > 0 ) {
                    wsprintf(   szText,
                                TEXT("Binary File Version: %u.%u.%u.%u"),
                                HIWORD(pMatch->FileVersion.HighPart),
                                LOWORD(pMatch->FileVersion.HighPart),
                                HIWORD(pMatch->FileVersion.LowPart),
                                LOWORD(pMatch->FileVersion.LowPart));

                    PDBTREETIP   pTip = &m_TipList[m_uNextTip++];

                    pTip->uType = ENTRY_SUBMATCH;
                    pTip->pMatch = pMatch;
                    pTip->uID = MATCH_FILEVERSION;
                    pTip->uContext = 3;

                    if ( pRecord->bGlobal )
                        pTip->uContext = 2;

                    AddTreeItem(hFile,
                                TVIF_TEXT | TVIF_PARAM,
                                0,
                                szText,
                                0,
                                (LPARAM) pTip);
                }

                if ( pMatch->ProductVersion.QuadPart > 0 ) {
                    wsprintf(   szText,
                                TEXT("Binary Product Version: %u.%u.%u.%u"),
                                HIWORD(pMatch->ProductVersion.HighPart),
                                LOWORD(pMatch->ProductVersion.HighPart),
                                HIWORD(pMatch->ProductVersion.LowPart),
                                LOWORD(pMatch->ProductVersion.LowPart));

                    PDBTREETIP   pTip = &m_TipList[m_uNextTip++];

                    pTip->uType = ENTRY_SUBMATCH;
                    pTip->pMatch = pMatch;
                    pTip->uID = MATCH_PRODUCTVERSION;
                    pTip->uContext = 3;

                    if ( pRecord->bGlobal )
                        pTip->uContext = 2;

                    AddTreeItem(hFile,
                                TVIF_TEXT | TVIF_PARAM,
                                0,
                                szText,
                                0,
                                (LPARAM) pTip);
                }
            }
            break;
        }

        pEntry = pEntry->pNext;
    }
}

void CDBView::msgChar(TCHAR chChar)
{
    // send notifications to the list views to update their views.

    m_GlobalList.msgChar(chChar);
    m_LocalList.msgChar(chChar);
}

void CDBView::DeleteDBWithTree(HTREEITEM hItem)
{
    HTREEITEM       hHold = NULL;
    TV_ITEM         Item;
    PDBRECORD       pRecord;
    HTREEITEM       hParent = hItem;

    // Lookup the current record.

    while ( NULL != hParent ) {
        hHold = hParent;

        hParent = TreeView_GetParent(m_hTreeView,hParent);
    }

    //PREFAST
    if ( hHold == NULL ) {
        return;
    }

    Item.mask = TVIF_PARAM;
    Item.hItem = hHold;

    TreeView_GetItem(m_hTreeView,&Item);

    pRecord = (PDBRECORD) Item.lParam;

    if ( pRecord->bGlobal ) {
        MessageBeep(MB_OK);
        return;
    }

    g_theApp.GetDBLocal().m_bDirty = TRUE;

    g_theApp.UpdateView(TRUE);

    if ( hHold != hItem ) {
        PDBENTRY    pEntry;
        PDBENTRY    pWalk;
        PDBENTRY    pHold;
        PDBTREETIP  pTip;

        Item.mask = TVIF_PARAM;
        Item.hItem = hItem;

        TreeView_GetItem(m_hTreeView,&Item);

        // Delete only the entry information;

        pTip = (PDBTREETIP) Item.lParam;

        if ( NULL == pTip ) {
            MessageBeep(MB_OK);
            return;
        }

        if ( ENTRY_UI == pTip->uType )
            return;

        if ( ENTRY_SUBMATCH == pTip->uType ) {
            PMATCHENTRY pMatch = pTip->pMatch;

            switch ( pTip->uID ) {
            case    MATCH_NAME:
                MessageBeep(MB_OK);
                return;

            case    MATCH_SIZE:
                pMatch->dwSize = 0;
                break;

            case    MATCH_CHECKSUM:
                pMatch->dwChecksum = 0;
                break;

            case    MATCH_FILEVERSION:
                pMatch->FileVersion.QuadPart = 0;
                break;

            case    MATCH_PRODUCTVERSION:
                pMatch->ProductVersion.QuadPart = 0;
                break;

            case    MATCH_COMPANY:
                pMatch->szCompanyName.Release();
                break;

            case    MATCH_DESCRIPTION:
                pMatch->szDescription.Release();
                break;

            case    MATCH_FILEVERSTRING:
                pMatch->szFileVersion.Release();
                break;

            case    MATCH_PRODUCTVERSTRING:
                pMatch->szProductVersion.Release();
                break;
            }
        } else {
            pEntry = (PDBENTRY) pTip->pShim;

            pWalk = pRecord->pEntries;

            while ( NULL != pWalk ) {
                if ( pEntry == pWalk )
                    break;

                pHold = pWalk;
                pWalk = pWalk->pNext;
            }

            if ( NULL == pWalk )
                return;

            if ( ENTRY_MATCH == pEntry->uType ) {
                // Cannot delete self reference

                PMATCHENTRY pMatch = (PMATCHENTRY) pEntry;

                if ( pMatch->szMatchName == TEXT("*") ) {
                    MessageBeep(MB_OK);
                    return;
                }
            } else {
                MessageBeep(MB_OK);
                return;
            }

            if ( pWalk == pRecord->pEntries )
                pRecord->pEntries = pRecord->pEntries->pNext;
            else
                pHold->pNext = pEntry->pNext;
        }
    } else {
        if ( DELRES_RECORDREMOVED == g_theApp.GetDBLocal().DeleteRecord(pRecord) )
            Update();
    }

    TreeView_DeleteItem(m_hTreeView,hItem);
}

void CDBView::msgNotify(LPNMHDR pHdr)
{
    switch ( pHdr->code ) {
    case    NM_KEYDOWN:
        {
            LPNMKEY pKey = (LPNMKEY) pHdr;

            if ( VK_TAB == pKey->nVKey ) {
                if ( pKey->hdr.hwndFrom == m_LocalList.m_hWnd ) {
                    SetFocus(m_hTreeView);

                }

                else if ( pKey->hdr.hwndFrom == m_GlobalList.m_hWnd ) {
                    SetFocus(m_hTreeView);

                }

                else if ( pKey->hdr.hwndFrom == m_hTreeView ) {
                    if (g_hWndLastFocus != NULL ) {
                        if (g_hWndLastFocus == m_LocalList.m_hWnd)      SetFocus(m_GlobalList.m_hWnd);
                                                                
                            
                        else                                            SetFocus(m_LocalList.m_hWnd);

                        
                    }
                    else
                        SetFocus(m_LocalList.m_hWnd);
                }//else if ( pKey->hdr.hwndFrom == m_hTreeView )
            }//if ( VK_TAB == pKey->nVKey )
        }
        break;

    case    LVN_SELCHANGED:////This is a user defined NM. Here we are building the tree..... 

        {
            PLISTVIEWNOTIFY plvn = (PLISTVIEWNOTIFY) pHdr;

            if ( pHdr->hwndFrom == m_GlobalList.m_hWnd )
                g_theApp.SetStatusText(2,CSTRING(TEXT("Read Only")));
            else
                g_theApp.SetStatusText(2,CSTRING(TEXT("")));

            g_theApp.SetButtonState(DBCMD_DISABLEGLOBAL, 0);
            g_theApp.SetButtonState(DBCMD_DISABLEUSER, 0);

            // Update the tree view.

            SendMessage(m_hTreeView,WM_SETREDRAW,FALSE,0);

            TreeView_DeleteAllItems(m_hTreeView);

            PDBRECORD pRecord = (PDBRECORD) plvn->pData;

            if ( m_pListRecord != pRecord )
                m_pCurrentRecord = NULL;

            m_pListRecord = pRecord;

            UINT uFiles = 0;

            m_uNextTip = 0;

            while ( NULL != pRecord ) {
                ++uFiles;

                AddRecordToTree(pRecord);

                pRecord = pRecord->pDup;
            }

            SendMessage(m_hTreeView,WM_SETREDRAW,TRUE,0);
            UpdateWindow(m_hTreeView);

            TCHAR szText[MAX_PATH * 10];

            if (uFiles == 0) 
                lstrcpy(szText,TEXT("No affected file found"));
            else
                wsprintf(szText,TEXT("%d affected file(s) found associated with this application"),uFiles);

            SetWindowText(g_theApp.m_hStatusBar,szText);

            SyncMenu();
        }
        break;

    case    NM_SETFOCUS:
        {
            if ( pHdr->hwndFrom == m_GlobalList.m_hWnd ) {
                m_GlobalList.ShowHilight(TRUE);
                m_LocalList.ShowHilight(FALSE);

                SendMessage(m_hTreeView,WM_SETREDRAW,FALSE,0);
                TreeView_DeleteAllItems(m_hTreeView);
                SendMessage(m_hTreeView,WM_SETREDRAW,TRUE,0);

                UINT uEntry = m_GlobalList.GetSelectedEntry();

                if ( -1 != uEntry ) {
                    m_pListRecord = (PDBRECORD)m_GlobalList.GetEntryData(uEntry);
                    RefreshTree();
                } else
                    m_pListRecord = NULL;

                m_pCurrentRecord = NULL;

                SyncMenu();
            }

            if ( pHdr->hwndFrom == m_LocalList.m_hWnd ) {
                m_GlobalList.ShowHilight(FALSE);
                m_LocalList.ShowHilight(TRUE);

                SendMessage(m_hTreeView,WM_SETREDRAW,FALSE,0);
                TreeView_DeleteAllItems(m_hTreeView);
                SendMessage(m_hTreeView,WM_SETREDRAW,TRUE,0);

                UINT uEntry = m_LocalList.GetSelectedEntry();

                if ( -1 != uEntry ) {
                    m_pListRecord = (PDBRECORD)m_LocalList.GetEntryData(uEntry);
                    RefreshTree();
                } else
                    m_pListRecord = NULL;

                m_pCurrentRecord = NULL;

                SyncMenu();
            }

            if ( pHdr->hwndFrom == m_GlobalList.m_hWnd )
                g_theApp.SetStatusText(2,CSTRING(TEXT("Read Only")));
            else if ( pHdr->hwndFrom == m_LocalList.m_hWnd )
                g_theApp.SetStatusText(2,CSTRING(TEXT("")));

            PDBRECORD pRecord = m_pListRecord;

            UINT uFiles = 0;

            while ( NULL != pRecord ) {
                ++uFiles;

                pRecord = pRecord->pDup;
            }

            TCHAR szText[MAX_PATH * 10];

            if (uFiles == 0) 
                lstrcpy(szText,TEXT("No affected file found"));
            else
                wsprintf(szText,TEXT("%d affected file(s) found associated with this application."),uFiles);

            SetWindowText(g_theApp.m_hStatusBar,szText);
        }
        break;

    case    NM_RCLICK:
        {
            if ( pHdr->hwndFrom == m_hTreeView ) {

                #ifdef __DEBUG
                MessageBox(NULL,TEXT("NM_RCLICK"),TEXT("NM_RCLICK"),MB_OK);
            
                #endif
                TVHITTESTINFO   ht;

                GetCursorPos(&ht.pt);
                ScreenToClient(m_hTreeView, &ht.pt);

                TreeView_HitTest(m_hTreeView,&ht);

                if ( 0 != ht.hItem ){
                    g_do_notProcess = TRUE;
                    TreeView_SelectItem(m_hTreeView,NULL);
                    g_do_notProcess = FALSE;
                    TreeView_SelectItem(m_hTreeView,ht.hItem);
                }
                    
            }
        }
        break;

    case    TVN_KEYDOWN:
        {
            LPNMTVKEYDOWN pKey = (LPNMTVKEYDOWN) pHdr;

            switch ( pKey->wVKey ) {
            case    VK_DELETE:
                {
                    DeleteDBWithTree(m_hSelectedItem);
                }
                break;
            }
        }
        break;

    
    case    TVN_SELCHANGED:
        {

            //MessageBox(NULL,NULL,NULL,MB_OK);            
            if (g_do_notProcess) {
                break;
            }

            LPNMTREEVIEW    pItem = (LPNMTREEVIEW) pHdr;

            if ( pItem == NULL ) {
                break;
            }

            BOOL            bEnabled = FALSE;
            HTREEITEM       hItem = TreeView_GetParent(m_hTreeView,pItem->itemNew.hItem);
            HTREEITEM       hHold = pItem->itemNew.hItem;
            TV_ITEM         Item;
            PDBTREETIP      pTip = (PDBTREETIP) pItem->itemNew.lParam;

            m_hSelectedItem = pItem->itemNew.hItem;

            // Lookup the current record.

            while ( NULL != hItem ) {
                hHold = hItem;

                hItem = TreeView_GetParent(m_hTreeView,hItem);
            }

            // Determine which context menu to use.

            // Root level item.

            if ( pItem->itemNew.hItem == hHold )
                m_uContext = 0;
            else
                if ( NULL != pTip )
                m_uContext = pTip->uContext;
            else
                m_uContext = 0;

            Item.mask = TVIF_PARAM;
            Item.hItem = hHold;

            TreeView_GetItem(m_hTreeView,&Item);

            //
            //The m_pCurrentRecord is changed here !!
            //


            

            m_pCurrentRecord = (PDBRECORD) Item.lParam;

            #ifdef __DEBUG
            CSTRING message;

            message.sprintf(
                TEXT("%s : % u Message: = %u"),
                      TEXT(__FILE__),
                      __LINE__, 
                     TEXT("m_pCurrentRecord"),
                     m_pCurrentRecord 
                     );

            MessageBox(NULL,message,TEXT("Inside TVN_SELCHANGED/NM_RCLICK"),MB_OK);
            #endif


            if ( NULL != m_pCurrentRecord ) {
                g_theApp.SetButtonState(DBCMD_DISABLEGLOBAL,TBSTATE_ENABLED);
                g_theApp.SetButtonState(DBCMD_DISABLEUSER,TBSTATE_ENABLED);

                if ( m_pCurrentRecord->bGlobal )
                    m_uContext = 2;
            } else {
                g_theApp.SetButtonState(DBCMD_DISABLEGLOBAL, 0);
                g_theApp.SetButtonState(DBCMD_DISABLEUSER, 0);
            }

            SyncMenu();
        }
        break;

    case    LVN_ITEMCHANGED:
        {
            g_theApp.SetButtonState(DBCMD_DISABLEGLOBAL, 0);
            g_theApp.SetButtonState(DBCMD_DISABLEUSER, 0);

            // Update the tree view.

            SendMessage(m_hTreeView,WM_SETREDRAW,FALSE,0);

            TreeView_DeleteAllItems(m_hTreeView);

            LPNMLISTVIEW    pList = (LPNMLISTVIEW) pHdr;
            PDBRECORD       pRecord = (PDBRECORD) pList->lParam;

            if ( m_pListRecord != pRecord )
                m_pCurrentRecord = NULL;

            m_pListRecord = pRecord;

            UINT uFiles = 0;

            m_uNextTip = 0;

            do {
                ++uFiles;

                AddRecordToTree(pRecord);

                pRecord = pRecord->pDup;
            }
            while ( NULL != pRecord );

            SendMessage(m_hTreeView,WM_SETREDRAW,TRUE,0);
            UpdateWindow(m_hTreeView);

            SyncMenu();

            TCHAR szText[MAX_PATH * 10];

            wsprintf(szText,TEXT("%d files affected"),uFiles);

            SetWindowText(g_theApp.m_hStatusBar,szText);
        }
        break;

    case    TBN_GETINFOTIP:
        {
            LPNMTBGETINFOTIP pTip = (LPNMTBGETINFOTIP) pHdr;
            static TCHAR * szTips[] = { TEXT("Properties"),
                TEXT("Delete Entry"),
                TEXT("Enable/Disable for user"),
                TEXT("Enable/Disable global"),
                TEXT("View Shims"),
                TEXT("View Application Help"),
                TEXT("Application Fix Wizard"),
                TEXT("View Global Database"),
                TEXT("View Patches"),
                TEXT("View Compatibility Modes"),
                TEXT("View Disabled")};

            switch ( pTip->iItem ) {
            case    DBCMD_PROPERTIES:
            case    DBCMD_DELETE:
            case    DBCMD_DISABLEUSER:
            case    DBCMD_DISABLEGLOBAL:
            case    DBCMD_VIEWSHIMS:
            case    DBCMD_VIEWAPPHELP:
            case    DBCMD_FIXWIZARD:
            case    DBCMD_VIEWPATCH:
            case    DBCMD_VIEWLAYERS:
            case    DBCMD_VIEWDISABLED:
                lstrcpy(pTip->pszText,szTips[pTip->iItem - DBCMD_PROPERTIES]);
                break;
            }
        }
        break;

    case    TVN_GETINFOTIP:
        {
            LPNMTVGETINFOTIP pTip = (LPNMTVGETINFOTIP) pHdr;

            *(pTip->pszText) = 0;

            GenerateTreeToolTip((PDBTREETIP) pTip->lParam,pTip->pszText);
        }
        break;
    }
}

LRESULT CDBView::MsgProc(UINT uMsg,WPARAM wParam, LPARAM lParam)
{
    switch ( uMsg ) {
    case    WM_LBUTTONDOWN:
        {
            SetCapture(m_hWnd);

            if ( LOWORD(lParam) > m_uListSize - SLIDER_WIDTH/2 ) {
                m_uCapturePos = LOWORD(lParam);
                m_bHorzDrag = TRUE;
            } else {
                m_uCapturePos = HIWORD(lParam);
                m_bHorzDrag = FALSE;
            }

            m_bDrag = TRUE;
        }
        break;

    case    WM_CONTEXTMENU:
        {
            
            UINT    uX = LOWORD(lParam);
            UINT    uY = HIWORD(lParam);
            HWND    hWnd = (HWND) wParam;

            if ( hWnd == m_hTreeView ) {
                
                #ifdef  __DEBUG
                    MessageBox(NULL,TEXT("WM_CONTEXT"),TEXT("WM_CONTEXT"),MB_OK);
                #endif

                TVHITTESTINFO   ht;

                GetCursorPos(&ht.pt);
                ScreenToClient(m_hTreeView, &ht.pt);

                TreeView_HitTest(m_hTreeView,&ht);

                if ( 0 != ht.hItem ) {
                    TVITEM  Item;

                    Item.mask = TVIF_PARAM;
                    Item.hItem = ht.hItem;
                    TreeView_GetItem(m_hTreeView,&Item);

                    HTREEITEM hParent = TreeView_GetParent(m_hTreeView,ht.hItem);

                    HMENU   hMenu = LoadMenu(g_hInstance,MAKEINTRESOURCE(IDR_DBVCONTEXT1));
                    HMENU   hContext = NULL;

                    if ( NULL == hParent ) {
                        PDBRECORD pRecord = (PDBRECORD) Item.lParam;

                        if ( pRecord->bGlobal )
                            hContext = GetSubMenu(hMenu,2);
                        else
                            hContext = GetSubMenu(hMenu,3);
                    } else {
                        PDBTREETIP pTip = (PDBTREETIP) Item.lParam;

                        if ( NULL != pTip )
                            hContext = GetSubMenu(hMenu,pTip->uContext);
                    }

                    if ( hContext == NULL ) { //prefast
                        break;
                    }

                    if ( NULL != m_pCurrentRecord ) {
                        MENUITEMINFO    Info;

                        Info.cbSize = sizeof(MENUITEMINFO);
                        Info.fMask = MIIM_STRING;
/*
                                if (0 == m_pCurrentRecord->dwUserFlags)
                                    Info.dwTypeData = "Disable for User";
                                else
                                    Info.dwTypeData = "Enable for User";

                                SetMenuItemInfo(hContext,ID_DISABLEFORUSER,MF_BYCOMMAND,&Info);
*/
                        if ( 0 == m_pCurrentRecord->dwGlobalFlags )
                            Info.dwTypeData = TEXT("Disable Entry");
                        else
                            Info.dwTypeData = TEXT("Enable Entry");

                        SetMenuItemInfo(hContext,ID_DISABLEGLOBALLY,MF_BYCOMMAND,&Info);
                    }

                    

                    TrackPopupMenuEx(hContext,
                                     TPM_LEFTALIGN | TPM_TOPALIGN,
                                     uX,
                                     uY,
                                     m_hWnd,
                                     NULL);

                   DestroyMenu(hMenu); 
                }

            }
        }
        break;

    case    WM_LBUTTONUP:
        m_bDrag = FALSE;
        ReleaseCapture();
        break;

    case    WM_MOUSEMOVE:
        {
            if ( LOWORD(lParam) > m_uListSize - SLIDER_WIDTH/2 )
                SetCursor(LoadCursor(NULL,IDC_SIZEWE));
            else
                SetCursor(LoadCursor(NULL,IDC_SIZENS));

            if ( 0 != (wParam & MK_LBUTTON) && m_bDrag ) {
                RECT    rRect;
                short int nX = (short int) LOWORD(lParam);
                short int nY = (short int) HIWORD(lParam);

                if ( m_bHorzDrag )
                    m_uListSize = m_uCapturePos + (nX - m_uCapturePos);
                else
                    m_uListHeight = m_uCapturePos + (nY - m_uCapturePos);

                GetClientRect(m_hWnd,&rRect);

                if ( (int)m_uListHeight < 100 )
                    m_uListHeight = 100;

                if ( (int)m_uListSize < 100 )
                    m_uListSize = 100;

                if ( (int)m_uListHeight > (int)(rRect.bottom * 0.75f) )
                    m_uListHeight = (UINT)(rRect.bottom * 0.75f);

                if ( (int)m_uListSize > (int)(rRect.right * 0.75f) )
                    m_uListSize = (UINT)(rRect.right * 0.75f);

                msgResize(rRect.right,rRect.bottom);
            }
        }
        break;

    case    WM_DRAWITEM:

        {

            //***Probably this is never called.


            LPDRAWITEMSTRUCT    pDraw = (LPDRAWITEMSTRUCT) lParam;
            LV_ITEM             Item;
            HDC                 hDC = CreateCompatibleDC(pDraw->hDC);
            HBITMAP             hBmp = CreateCompatibleBitmap(pDraw->hDC,pDraw->rcItem.right - pDraw->rcItem.left,pDraw->rcItem.bottom - pDraw->rcItem.top);
            HBITMAP             hOldBmp = (HBITMAP) SelectObject(hDC,hBmp);
            RECT                rBmpRect;
            HFONT               hFont = (HFONT) SendMessage(m_hListView,WM_GETFONT,0,0);
            HBRUSH              hFillBrush = GetSysColorBrush(COLOR_WINDOW);

            hFont = (HFONT) SelectObject(hDC,hFont);

            SetRect(&rBmpRect,0,0,pDraw->rcItem.right - pDraw->rcItem.left,pDraw->rcItem.bottom - pDraw->rcItem.top);

            Item.mask = LVIF_PARAM;
            Item.iItem = pDraw->itemID;
            Item.iSubItem = 0;

            LV_COLUMN   Col;

            Col.mask = LVCF_WIDTH;

            ListView_GetColumn(m_hListView,0,&Col);

            Col.cx = pDraw->rcItem.right;

            ListView_GetItem(m_hListView,&Item);

            pDraw->rcItem.right = m_uListSize;

            if ( 0 != (pDraw->itemState & ODS_FOCUS) ) {
                //FillRect(pDraw->hDC,&pDraw->rcItem,GetSysColorBrush(COLOR_HIGHLIGHT));
                FillRect(hDC,&rBmpRect,GetSysColorBrush(COLOR_HIGHLIGHT));
                SetBkColor(hDC,GetSysColor(COLOR_HIGHLIGHT));

            } else
                if ( 0 == pDraw->itemID % 2 ) {
                //FillRect(pDraw->hDC,&pDraw->rcItem,(HBRUSH) GetStockObject(WHITE_BRUSH));
                FillRect(hDC,&rBmpRect,(HBRUSH) GetStockObject(WHITE_BRUSH));

                SetBkColor(hDC,RGB(255,255,255));
            } else {
                //FillRect(pDraw->hDC,&pDraw->rcItem,hFillBrush);
                FillRect(hDC,&rBmpRect,hFillBrush);
                SetBkColor(hDC,RGB(235,235,235));
            }

            //SelectObject(pDraw->hDC,(HPEN) GetStockObject(BLACK_PEN));
            SelectObject(hDC,(HPEN) GetStockObject(BLACK_PEN));

            //MoveToEx(pDraw->hDC,Col.cx-1,pDraw->rcItem.top,NULL);
            //LineTo(pDraw->hDC,Col.cx-1,pDraw->rcItem.bottom);

            MoveToEx(hDC,Col.cx-1,0,NULL);
            LineTo(hDC,Col.cx-1,rBmpRect.bottom);

            //MoveToEx(pDraw->hDC,pDraw->rcItem.left,pDraw->rcItem.bottom-1,NULL);
            //LineTo(pDraw->hDC,pDraw->rcItem.right,pDraw->rcItem.bottom-1);

            MoveToEx(hDC,0,rBmpRect.bottom-1,NULL);
            LineTo(hDC,rBmpRect.right,rBmpRect.bottom-1);

            // Draw the actual name.

            PDBRECORD pRecord = (PDBRECORD) Item.lParam;

            //pDraw->rcItem.right = Col.cx - 2;
            //pDraw->rcItem.bottom --;

            BOOL bDisableUser = FALSE;
            BOOL bDisableGlobal = FALSE;
            BOOL bShim = FALSE;
            BOOL bHelp = FALSE;

            PDBRECORD pWalk = pRecord;

            while ( NULL != pWalk ) {
                if ( 0 != pWalk->dwUserFlags )
                    bDisableUser = TRUE;

                if ( 0 != pWalk->dwGlobalFlags )
                    bDisableGlobal = TRUE;

                PDBENTRY pEntry = pWalk->pEntries;

                while ( NULL != pEntry ) {
                    if ( ENTRY_SHIM == pEntry->uType )
                        bShim = TRUE;

                    if ( ENTRY_APPHELP == pEntry->uType )
                        bHelp = TRUE;

                    pEntry = pEntry->pNext;
                }

                pWalk = pWalk->pDup;
            }

            {
                HDC     hBmpDC  = CreateCompatibleDC(hDC);
                HBITMAP hOldBmp = (HBITMAP) SelectObject(hBmpDC,g_theApp.m_hToolBitmap);
                UINT    uIndex;

                if ( bShim )
                    uIndex = IMAGE_SHIM;

                if ( bHelp )
                    uIndex = IMAGE_APPHELP;

                if ( bDisableGlobal | bDisableUser ) {
                    uIndex = IMAGE_WARNING;
                    SetTextColor(hDC,RGB(128,128,128));
                }

                // Draw the appropriate bitmap

                UINT uSize = pDraw->rcItem.bottom - pDraw->rcItem.top;

                if ( IMAGE_SHIM != uIndex )
                    StretchBlt( hDC,
                                3,0,
                                uSize - 1, uSize - 1,
                                hBmpDC,
                                16 * uIndex,0,
                                16,16,
                                SRCCOPY);

                SelectObject(hBmpDC,hOldBmp);
                DeleteDC(hBmpDC);
            }

            LPTSTR szText = pRecord->szAppName;

            if ( 0 == lstrlen(szText) )
                szText = pRecord->szEXEName;

            //ExtTextOut(pDraw->hDC,pDraw->rcItem.left + 20, pDraw->rcItem.top, ETO_OPAQUE | ETO_CLIPPED, &pDraw->rcItem, szText, lstrlen(szText), NULL);

            RECT rClipRect = rBmpRect;

            rClipRect.left = 20;
            rClipRect.right = Col.cx - 2;
            --rClipRect.bottom;

            ExtTextOut( hDC,
                        20, 0,
                        ETO_OPAQUE | ETO_CLIPPED,
                        &rClipRect,
                        szText, lstrlen(szText),
                        NULL);

            BitBlt( pDraw->hDC,
                    pDraw->rcItem.left,
                    pDraw->rcItem.top,
                    (pDraw->rcItem.right - pDraw->rcItem.left),
                    (pDraw->rcItem.bottom - pDraw->rcItem.top)+1,
                    hDC,
                    0,0,
                    SRCCOPY);

            SelectObject(hDC,hOldBmp);
            SelectObject(hDC,hFont);

            DeleteObject(hBmp);
            DeleteDC(hDC);
        }
        break;
    }

    return CView::MsgProc(uMsg,wParam,lParam);
}

void CDBView::GenerateTreeToolTip(PDBTREETIP pTip, LPTSTR szText)
{
    if ( NULL != pTip )
        switch ( pTip->uType ) {
        case    ENTRY_SHIM:
            {
                PSHIMDESC   pShim = pTip->pShim;

                if (NULL == pShim ) {
                    return;
                }

                if (  0 != pShim->szShimDesc.Length() ){
                    lstrcpy(szText,pShim->szShimDesc);

                }else{

                    if (pShim->bGeneral == false) {

                        lstrcpy(szText,TEXT("No description available"));

                    }
                    
                }
                    

            }
            break;

        case    ENTRY_APPHELP:
            {
                PHELPENTRY pHelp = pTip->pHelp;
                TCHAR * szToolHelp[] = {
                    TEXT("No application help is available. Nothing will be done."),
                    TEXT("An update may be available for the application.\nThis application will execute."),
                    TEXT("This application is not allowed to execute\non this machine."),
                    TEXT("This application will run with minor problems."),
                    TEXT("The application needs to be reinstalled."),
                    TEXT("Versionsub"),
                    TEXT("Shim")};

                if ( NULL != pHelp )
                    lstrcpy(szText,szToolHelp[pHelp->uSeverity]);
            }
            break;

        case    ENTRY_MATCH:
            {
                PMATCHENTRY pMatch = pTip->pMatch;
                TCHAR       szTemp[1024];

                wsprintf(szText,TEXT("Match File: %s\n"),pMatch->szMatchName);

                if ( lstrlen(pMatch->szDescription) > 0 ) {
                    wsprintf(szTemp,TEXT("Description: %s\n"),pMatch->szDescription);
                    lstrcat(szText,szTemp);
                }

                if ( lstrlen(pMatch->szCompanyName) > 0 ) {
                    wsprintf(szTemp,TEXT("Company Name: %s\n"),pMatch->szCompanyName);
                    lstrcat(szText,szTemp);
                }

                if ( pMatch->dwSize > 0 ) {
                    TCHAR   szSize[80];

                    FormatFileSize(pMatch->dwSize,szSize);

                    wsprintf(szTemp,TEXT("File Size: %s bytes\n"),szSize);
                    lstrcat(szText,szTemp);
                }

                if ( pMatch->dwChecksum > 0 ) {
                    wsprintf(szTemp,TEXT("Checksum: %08X\n"),pMatch->dwChecksum);
                    lstrcat(szText,szTemp);
                }

                if ( lstrlen(pMatch->szProductVersion) > 0 ) {
                    wsprintf(szTemp,TEXT("Product Version: %s\n"),pMatch->szProductVersion);
                    lstrcat(szText,szTemp);
                }

                if ( lstrlen(pMatch->szFileVersion) > 0 ) {
                    wsprintf(szTemp,TEXT("File Version: %s\n"),pMatch->szFileVersion);
                    lstrcat(szText,szTemp);
                }
                if ( pMatch->FileVersion.QuadPart > 0 ) {
                    wsprintf(   szTemp,
                                TEXT("File Version: %u.%04u.%04u.%04u\n"),
                                HIWORD(pMatch->FileVersion.HighPart),
                                LOWORD(pMatch->FileVersion.HighPart),
                                HIWORD(pMatch->FileVersion.LowPart),
                                LOWORD(pMatch->FileVersion.LowPart));

                    lstrcat(szText,szTemp);
                }
                if ( pMatch->ProductVersion.QuadPart > 0 ) {
                    wsprintf(   szTemp,
                                TEXT("Product Version: %u.%04u.%04u.%04u\n"),
                                HIWORD(pMatch->ProductVersion.HighPart),
                                LOWORD(pMatch->ProductVersion.HighPart),
                                HIWORD(pMatch->ProductVersion.LowPart),
                                LOWORD(pMatch->ProductVersion.LowPart));

                    lstrcat(szText,szTemp);
                }

                // Terminate 1 character early... effectively removing
                // the very last <CR>.

                szText[lstrlen(szText)-1] = 0;
            }
            break;
        }
}

void FormatFileSize(UINT uSize, LPTSTR szText)
{
    DWORD   dwSize = uSize;
    DWORD   dwMax = 1000000000;
    BOOL    bFirst = TRUE;

    szText[0] = 0;

    while ( dwSize > 0 ) {
        if ( dwSize / dwMax > 0 ) {
            TCHAR szTemp[5];

            if ( bFirst )
                wsprintf(szTemp,TEXT("%d,"),dwSize/dwMax);
            else
                wsprintf(szTemp,TEXT("%03d,"),dwSize/dwMax);

            bFirst = FALSE;

            lstrcat(szText,szTemp);
        }

        dwSize -= (dwSize / dwMax) * dwMax;
        dwMax /= 1000;
    }

    szText[lstrlen(szText)-1] = 0;
}

void FormatVersion(LARGE_INTEGER liVer, LPTSTR szText)
{
    wsprintf(   szText,
                TEXT("%u.%u.%u.%u"),
                HIWORD(liVer.HighPart),
                LOWORD(liVer.HighPart),
                HIWORD(liVer.LowPart),
                LOWORD(liVer.LowPart));
}

HTREEITEM CDBView::AddTreeItem(HTREEITEM hParent,DWORD dwFlags,DWORD dwState,LPCTSTR szText,UINT uImage, LPARAM lParam)
{
    TVINSERTSTRUCT Item;

    Item.hParent = hParent;
    Item.hInsertAfter = TVI_LAST;
    Item.item.mask  = dwFlags;
    Item.item.stateMask = dwState;
    Item.item.state = dwState;
    Item.item.pszText = (LPTSTR) szText;
    Item.item.cchTextMax = lstrlen(Item.item.pszText);
    Item.item.iImage = uImage;
    Item.item.iSelectedImage = Item.item.iImage;
    Item.item.lParam = lParam;

    return TreeView_InsertItem(m_hTreeView,&Item);
}

UINT CDBView::LookupFileImage(LPCTSTR szFilename, UINT uDefault)
{
    return uDefault;

    SHFILEINFO  Info;
    HIMAGELIST  hList;
    UINT        uImage;

    ZeroMemory(&Info,sizeof(Info));

    hList = (HIMAGELIST) SHGetFileInfo(szFilename,FILE_ATTRIBUTE_NORMAL,&Info,sizeof(Info),SHGFI_ICON | SHGFI_SMALLICON | SHGFI_USEFILEATTRIBUTES);

    if ( NULL != hList ) {
        if ( 0 == m_uImageRedirector[Info.iIcon] )
            m_uImageRedirector[Info.iIcon] = ImageList_AddIcon(m_hImageList,Info.hIcon);

        uImage = m_uImageRedirector[Info.iIcon];
    } else
        uImage = uDefault;

    return uImage;
}

void CDBView::WriteFlagsToTree(HTREEITEM hParent, DWORD dwFlags)
{

    //
    // NOT USED ANYWHERE !!!
    //
    if ( 0 != (dwFlags & SHIMREG_DISABLE_SHIM) ) {
        AddTreeItem(hParent,
                    TVIF_TEXT | TVIF_IMAGE | TVIF_SELECTEDIMAGE,
                    0,
                    TEXT("Disable Shims"),
                    IMAGE_WARNING);
    }

    if ( 0 != (dwFlags & SHIMREG_DISABLE_APPHELP) ) {
        AddTreeItem(hParent,
                    TVIF_TEXT | TVIF_IMAGE | TVIF_SELECTEDIMAGE,
                    0,
                    TEXT("Disable App Help"),
                    IMAGE_WARNING);
    }

    if ( 0 != (dwFlags & SHIMREG_DISABLE_LAYER) ) {
        AddTreeItem(hParent,
                    TVIF_TEXT | TVIF_IMAGE | TVIF_SELECTEDIMAGE,
                    0,
                    TEXT("Disable Layer"),
                    IMAGE_WARNING);
    }

    if ( 0 != (dwFlags & SHIMREG_APPHELP_NOUI) ) {
        AddTreeItem(hParent,
                    TVIF_TEXT | TVIF_IMAGE | TVIF_SELECTEDIMAGE,
                    0,
                    TEXT("Disable UI"),
                    IMAGE_WARNING);
    }

}

BOOL CALLBACK DisableDialog(HWND hDlg, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    switch ( uMsg ) {
    case    WM_INITDIALOG:
        {
            SetWindowLongPtr(hDlg,GWLP_USERDATA,lParam);

            if ( 0 != (lParam & SHIMREG_DISABLE_SHIM) )
                SendDlgItemMessage(hDlg,IDC_SHIMS,BM_SETCHECK,BST_CHECKED,0);

            if ( 0 != (lParam & SHIMREG_DISABLE_APPHELP) )
                SendDlgItemMessage(hDlg,IDC_APPHELP,BM_SETCHECK,BST_CHECKED,0);

            if ( 0 != (lParam & SHIMREG_DISABLE_LAYER) )
                SendDlgItemMessage(hDlg,IDC_LAYERS,BM_SETCHECK,BST_CHECKED,0);

            if ( 0 != (lParam & SHIMREG_APPHELP_NOUI) )
                SendDlgItemMessage(hDlg,IDC_HELPUI,BM_SETCHECK,BST_CHECKED,0);

            if ( 0 != (lParam & 0x80000000) )
                SetWindowText(hDlg,TEXT("Set user specific app flags"));
            else
                SetWindowText(hDlg,TEXT("Set global application flags"));
        }
        return TRUE;

    case    WM_COMMAND:
        switch ( LOWORD(wParam) ) {
        case    IDC_DISABLEALL:
            {
                SendDlgItemMessage(hDlg,IDC_SHIMS,BM_SETCHECK,BST_CHECKED,0);
                SendDlgItemMessage(hDlg,IDC_APPHELP,BM_SETCHECK,BST_CHECKED,0);
                SendDlgItemMessage(hDlg,IDC_LAYERS,BM_SETCHECK,BST_CHECKED,0);
                SendDlgItemMessage(hDlg,IDC_HELPUI,BM_SETCHECK,BST_CHECKED,0);
            }
            break;

        case    IDOK:
            {
                DWORD dwFlags = 0;

                // Construct final flags

                dwFlags |= (SendDlgItemMessage(hDlg,IDC_SHIMS,BM_GETCHECK,0,0) == BST_CHECKED) ? SHIMREG_DISABLE_SHIM:0;
                dwFlags |= (SendDlgItemMessage(hDlg,IDC_LAYERS,BM_GETCHECK,0,0) == BST_CHECKED) ? SHIMREG_DISABLE_LAYER:0;
                dwFlags |= (SendDlgItemMessage(hDlg,IDC_HELPUI,BM_GETCHECK,0,0) == BST_CHECKED) ? SHIMREG_APPHELP_NOUI:0;
                dwFlags |= (SendDlgItemMessage(hDlg,IDC_APPHELP,BM_GETCHECK,0,0) == BST_CHECKED) ? SHIMREG_DISABLE_APPHELP:0;

                // Terminate the dialog.

                EndDialog(hDlg,dwFlags);
            }
            break;
        case    IDCANCEL:
            {
                DWORD   dwState = GetWindowLongPtr(hDlg, GWLP_USERDATA);

                EndDialog(hDlg,dwState);
            }
            break;
        }
        break;
    }

    return FALSE;
}

void CDBView::SyncStates(UINT uMenuCMD, UINT uToolCmd, BOOL bToolbar, BOOL bToggle)
{
    BOOL bOn = FALSE;
/*
    if (bToolbar)
        bOn = SendMessage(g_theApp.m_hToolBar,TB_ISBUTTONCHECKED,uToolCmd,0) ? TRUE:FALSE;        
    else
    {
*/
    UINT uState = GetMenuState(m_hMenu,uMenuCMD,MF_BYCOMMAND);

    bOn = (0 != (uState & MF_CHECKED)) ? TRUE:FALSE;
//    }

    if ( bToggle )
        bOn = !bOn;

    MENUITEMINFO    Info;

    Info.cbSize = sizeof(MENUITEMINFO);
    Info.fMask = MIIM_STATE;
    Info.fState = bOn ? MF_CHECKED:0;

//    SendMessage(g_theApp.m_hToolBar,TB_CHECKBUTTON,uToolCmd,MAKELONG(bOn ? TRUE:FALSE,0));

    SetMenuItemInfo(m_hMenu,uMenuCMD,MF_BYCOMMAND,&Info);

    //return;

    //Update();
}

void CDBView::SyncMenu(void)
{

    //
    //Enables or disables the entries in the menu
    //

    // This varaile reflects whether we should disable entries because we are working on the global database.

    BOOL bDisableGlobal=TRUE;

    

    if ( NULL != m_pListRecord )
        bDisableGlobal = m_pListRecord->bGlobal;
    else
        if ( m_LocalList.m_hWnd == GetFocus() )
        bDisableGlobal = FALSE;

    MENUITEMINFO    Info;

    Info.cbSize = sizeof(MENUITEMINFO);
    Info.fMask = MIIM_STATE;
    Info.fState = bDisableGlobal ? MFS_DISABLED:MFS_ENABLED;

    //
    //Disable the enties if we are working on a global database.
    //

    SetMenuItemInfo(m_hMenu,ID_DATABASE_CHANGEDATABASENAME,MF_BYCOMMAND,&Info);
    //SetMenuItemInfo(m_hMenu,ID_DATABASE_ADDANENTRY,MF_BYCOMMAND,&Info);
    SetMenuItemInfo(m_hMenu,ID_DATABASE_DEFINECUSTOMLAYER,MF_BYCOMMAND,&Info);

    SetMenuItemInfo(m_hMenu,ID_DATABASE_CREATENEWAPPHELPMESSAGE,MF_BYCOMMAND,&Info);



    SetMenuItemInfo(m_hMenu,ID_FILE_SAVEDATABASE,MF_BYCOMMAND,&Info);
    SetMenuItemInfo(m_hMenu,ID_FILE_SAVEDATABASEAS,MF_BYCOMMAND,&Info);

    Info.fState = MFS_DISABLED;

    SetMenuItemInfo(m_hMenu,ID_DATABASE_EDITCUSTOMCOMPATIBILITYMODE,MF_BYCOMMAND,&Info);
    SetMenuItemInfo(m_hMenu,ID_DATABASE_REMOVECUSTOMCOMPATIBILITYMODE,MF_BYCOMMAND,&Info);

    //
    //Disable add matching, removing matching, remove entry
    //


    SetMenuItemInfo(m_hMenu,ID_EDIT_ADDMATCHINGINFORMATION,MF_BYCOMMAND,&Info);
    SetMenuItemInfo(m_hMenu,ID_EDIT_REMOVEMATCHINGINFORMATION,MF_BYCOMMAND,&Info);
    SetMenuItemInfo(m_hMenu,ID_DATABASE_REMOVEENTRY,MF_BYCOMMAND,&Info);
    
    
    
    if ( !bDisableGlobal ) {
        HTREEITEM   hItem;

        Info.cbSize = sizeof(MENUITEMINFO);
        Info.fMask = MIIM_STATE;
        Info.fState = MFS_ENABLED;

        // Determine if file matching stuff is presently selected to enable remove.

        hItem = TreeView_GetSelection(m_hTreeView);

        if ( NULL != hItem ) {
            TVITEM  Item;

            Item.mask = TVIF_PARAM;
            Item.hItem = hItem;
            TreeView_GetItem(m_hTreeView,&Item);

            PDBTREETIP pTip = (PDBTREETIP) Item.lParam;

            // The tip is only valid if not on the root.

            if ( NULL != pTip && NULL != TreeView_GetParent(m_hTreeView,hItem) )
                if ( 1 == pTip->uContext )
                    SetMenuItemInfo(m_hMenu,ID_EDIT_REMOVEMATCHINGINFORMATION,MF_BYCOMMAND,&Info);
        }

        // Determine if we can edit or remove compat modes

        PDBLAYER pWalk = g_theApp.GetDBLocal().m_pLayerList;

        while ( NULL != pWalk ) {
            if ( !pWalk->bPermanent )
                break;

            pWalk = pWalk->pNext;
        }

        if ( NULL != pWalk ) {
            SetMenuItemInfo(m_hMenu,ID_DATABASE_EDITCUSTOMCOMPATIBILITYMODE,MF_BYCOMMAND,&Info);
            SetMenuItemInfo(m_hMenu,ID_DATABASE_REMOVECUSTOMCOMPATIBILITYMODE,MF_BYCOMMAND,&Info);
        }

        // Determine if we can remove the entry

        if ( NULL != m_pCurrentRecord ) {
            SetMenuItemInfo(m_hMenu,ID_EDIT_ADDMATCHINGINFORMATION,MF_BYCOMMAND,&Info);
            SetMenuItemInfo(m_hMenu,ID_DATABASE_REMOVEENTRY,MF_BYCOMMAND,&Info);
        }
    }

    if ( NULL == m_pCurrentRecord )
        Info.fState = MFS_DISABLED;
    else
        Info.fState = MFS_ENABLED;

    SetMenuItemInfo(m_hMenu,ID_TEST_TESTRUN,MF_BYCOMMAND,&Info);
    SetMenuItemInfo(m_hMenu,ID_EDIT_ENABLEDISABLEGLOBALLY,MF_BYCOMMAND,&Info);
    SetMenuItemInfo(m_hMenu,ID_EDIT_ENABLEDISABLELOCALLY,MF_BYCOMMAND,&Info);

    if ( NULL != m_pCurrentRecord ) {
        // Find this one and make sure it's selected.

        if ( NULL == TreeView_GetSelection(m_hTreeView) ) {
            HTREEITEM hItem = TreeView_GetRoot(m_hTreeView);
            TVITEM    Item;

            while ( NULL != hItem ) {
                Item.mask = TVIF_PARAM;
                Item.hItem = hItem;

                TreeView_GetItem(m_hTreeView,&Item);

                if ( Item.lParam == (LPARAM) m_pCurrentRecord ) {
                    TreeView_SelectItem(m_hTreeView,hItem);
                    break;
                }

                hItem = TreeView_GetNextItem(m_hTreeView,hItem,TVGN_NEXT);
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\appcompat\tools\compatadmin\dbsearch.h ===
typedef struct  _tagSearch {
    CSTRING             szDatabase;
    CSTRING             szFilename;
    CSTRING             szApplication;
    DBRECORD            Record;
    struct _tagSearch * pNext;

    _tagSearch()
    {
        szDatabase.Init();
        szFilename.Init();
        szApplication.Init();
    }

    ~_tagSearch()
    {
        szDatabase.Release();
        szFilename.Release();
        szApplication.Release();
    }

} SEARCHLIST, *PSEARCHLIST;

class CDBSearch: public CView {
public:

    HWND        m_hListView;
    PSEARCHLIST m_pList;
    HBRUSH      m_hFillBrush;

public:

    CDBSearch();

    BOOL    Initialize              (void);
    /*
    ...................................................................
    This "fNotUsd" flag is not used in the member funcs of this class. This is just to ensure that this 
    function does get called. And that we do not end up calling the respective function
    of CVIEW class. Activate is called with a value of FALSE from CApplication, when the user presses
    the View->DBView menu. In that case a vale of FALSE to CApplication::Activateview means  that 
    we do not want the items of the global and the local lists to be removed and created afresh.
    
     
    
    
    ...................................................................
    */
    void    Update                  (BOOL fNotUsed = TRUE);

    BOOL    Activate                (BOOL fNotUsed = TRUE);

    MSGAPI  msgCommand              (UINT uID, HWND hSender);

    MSGAPI  msgChar                 (TCHAR ch);

    MSGAPI  msgResize              (UINT uWidth, 
                                    UINT uHeight);

    virtual LRESULT STDCALL MsgProc(UINT        uMsg,
                                    WPARAM      wParam,
                                    LPARAM      lParam);
};

BOOL CALLBACK SearchProc(HWND hDlg, UINT uMsg, WPARAM wParam, LPARAM lParam);
BOOL CALLBACK SelectDrivesProc(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\appcompat\tools\compatadmin\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Visual C++ generated include file.
// Used by compatadmin.rc
//
#define IDS_WIZARD                      1
#define VS_VERSION_INFO                 1
#define IDS_APPHELP                     2
#define IDD_ASSERTION                   101
#define IDD_CMD_LINE                    103
#define IDR_MAINTOOLBAR                 104
#define IDR_MAINMENU                    106
#define IDD_DISABLE                     107
#define IDR_DBVCONTEXT1                 113
#define IDD_XML                         114
#define IDR_DBVIEWER                    117
#define IDD_CUSTOMLAYER                 119
#define IDD_TESTRUN                     120
#define IDD_WAIT                        121
#define IDD_ADDWIZARD                   122
#define IDD_ADDWIZARD2                  123
#define IDD_ADDWIZARD3                  124
#define IDD_ADDWIZARD4                  125
#define IDB_WIZBMP                      126
#define IDD_ADDWIZARDDONE               127
#define IDD_ADDWIZARD5                  128
#define IDD_ADDWIZARD6                  129
#define IDD_ADDWIZARD7                  130
#define IDD_SEARCH                      131
#define IDR_SEARCHMENU                  132
#define IDD_DRIVELIST                   133
#define IDD_NEWDATABASE                 134
#define IDD_SELECTLAYER                 135
#define IDI_COMPATADMIN                 138
#define IDI_FIXES                       139
#define IDI_HELP                        140
#define IDI_MODE                        141
#define IDD_SPLASH                      144
#define IDD_APPHELP2                    145
#define IDR_ACCELERATOR1                146
#define IDD_APPHELP3                    146
#define IDD_APPHELP1                    147
#define IDD_APPHELPDONE                 148
#define ID_DATABASE_CREATENEWAPPHELPMESSAGE149 149
#define IDC_ABORT                       1000
#define IDC_BREAK                       1001
#define IDC_IGNORE                      1002
#define IDC_EXCEPTION                   1003
#define IDC_FILE                        1004
#define IDC_CAUSE                       1005
#define IDC_DESC                        1006
#define IDC_LINE                        1007
#define IDC_SHIMS                       1007
#define IDC_LINENUMBER                  1008
#define IDC_APPHELP                     1008
#define IDC_LAYERS                      1009
#define IDC_DRIVERS                     1010
#define IDC_HELPUI                      1011
#define IDC_DISABLEALL                  1012
#define IDC_EDIT1                       1013
#define IDC_URL                         1013
#define IDC_BROWSE                      1014
#define IDC_PREV                        1015
#define IDC_NEXT                        1016
#define IDC_FINISH                      1017
#define IDC_GENERATE                    1019
#define IDC_MANUAL                      1020
#define IDC_LAYERLIST                   1022
#define IDC_SHIM                        1023
#define IDC_SHIM_CMD_LINE               1023
#define IDC_SHIM_NAME                   1024
#define IDC_SHIMLIST                    1025
#define IDC_CMDLINE                     1026
#define IDC_SHIMLIST2                   1026
#define IDC_SHIMDESC                    1027
#define IDC_XML                         1028
#define IDC_SAVEXML                     1029
#define IDC_VIEWXML                     1031
#define IDC_TESTRUN                     1032
#define IDC_VIEWFIX                     1033
#define IDC_NAME                        1034
#define IDC_ADD                         1039
#define IDC_REMOVE                      1040
#define IDC_COPY                        1041
#define IDC_REMOVEALL                   1043
#define IDC_LOG                         1044
#define IDC_COMMANDLINE                 1047
#define IDC_MSDEV                       1048
#define IDC_NONE                        1049
#define IDC_NTSD                        1050
#define IDC_BUTTON1                     1051
#define IDC_TITLE                       1052
#define IDC_STATUS                      1053
#define IDC_FILELIST                    1054
#define IDC_REMOVEFILES                 1055
#define IDC_ADDFILES                    1056
#define IDC_SEARCHANIMATION             1057
#define IDC_DRIVELIST                   1058
#define IDC_WILDCARD                    1059
#define IDC_SEARCHTEXT                  1060
#define IDC_CLEARALL                    1061
#define IDC_EXE                         1062
#define IDC_LIST                        1063
#define IDC_RADIO1                      1064
#define IDC_BLOCK                       1064
#define IDC_RADIO2                      1065
#define IDC_NOBLOCK                     1065
#define IDC_RADIO2_1                    1066
#define IDC_RADIO2_2                    1067
#define IDC_TEMPLATELIST                1068
#define IDC_CLEAR                       1068
#define IDC_MSGNAME                     1069
#define IDC_EDIT2                       1070
#define IDC_APPHELPMESSAGE              1070
#define IDC_EDIT3                       1071
#define IDC_EDIT4                       1072
#define IDC_EDIT5                       1073
#define IDC_CHECK1                      1074
#define IDC_EDIT6                       1075
#define IDC_MSG_SUMMARY                 1076
#define IDC_MSG_DETAIL                  1077
#define IDC_APPNAME                     6001
#define IDC_EXEPATH                     6002
#define ID_BUTTON40001                  40001
#define ID_FILE_OPENDATABASE            40002
#define ID_FILE_CLOSEDATABASE           40003
#define ID_FILE_NEWDATABASE             40004
#define ID_FILE_SAVEDATABASE            40005
#define ID_BUTTON40006                  40006
#define ID_BUTTON40007                  40007
#define ID_BUTTON40008                  40008
#define ID_BUTTON40009                  40009
#define ID_BUTTON40010                  40010
#define ID_BUTTON40011                  40011
#define ID_BUTTON40012                  40012
#define ID_BUTTON40013                  40013
#define ID_BUTTON40014                  40014
#define ID_BUTTON40015                  40015
#define ID_BUTTON40017                  40017
#define ID_BUTTON40018                  40018
#define ID_BUTTON40019                  40019
#define ID_BUTTON40020                  40020
#define ID_BUTTON40021                  40021
#define ID_BUTTON40022                  40022
#define ID_ADDENTRY                     40023
#define ID_NA_EDITANENTRY               40024
#define ID_NA_REMOVEANENTRY             40025
#define ID_TESTRUN                      40027
#define ID_DISABLEGLOBALLY              40028
#define ID_DISABLEFORUSER               40029
#define ID_VIEWXML                      40030
#define ID_DATABASE_GENERATEXML         40032
#define ID_TEST_TESTRUN                 40033
#define ID_DATABASE_ADDANENTRY          40034
#define ID_DATABASE_REMOVEENTRY         40035
#define ID_DATABASE_EDITENTRY           40036
#define ID_VIEW_VIEWSHIMFIXES           40037
#define ID_VIEW_VIEWLAYERFIXES          40038
#define ID_VIEW_VIEWAPPHELPENTRIES      40039
#define ID_VIEW_VIEWGLOBALFIXES         40040
#define ID_HELP_ABOUT                   40041
#define ID_BUTTON40042                  40042
#define ID_BUTTON40043                  40043
#define ID_BUTTON40044                  40044
#define ID_DATABASE_DEFINECUSTOMLAYER   40045
#define ID_VIEW_VIEWPATCHES             40048
#define ID_FILE_EXPORTXML               40050
#define ID_FILE_SAVEDATABASEAS          40051
#define ID_FILE_IIMPORTXML              40052
#define ID_BUTTON40053                  40053
#define ID_WINDOWS_DATABASEVIEWER       40054
#define ID_WINDOWS_SEARCHFORFIXES       40055
#define ID_SEARCH_NEWSEARCH             40056
#define ID_VIEW_SHOWDISABLEDENTRIES     40057
#define ID_EDIT_EDITMATCHINGINFORMATION 40058
#define ID_BUTTON40060                  40060
#define ID_BUTTON40061                  40061
#define ID_DATABASE_CHANGEDATABASENAME  40062
#define ID_NA2_ADDMATCHINGINFORMATION   40063
#define ID_NA2_REMOVEMATCHINGINFORMATION 40064
#define ID_FILE_EXIT                    40065
#define ID_N5_VIEWENTRYINDATABASE       40066
#define ID_DATABASE_EDITCUSTOMCOMPATIBILITYMODE 40067
#define ID_DATABASE_REMOVECUSTOMCOMPATIBILITYMODE 40068
#define ID_EDIT_ADDMATCHINGINFORMATION  40069
#define ID_EDIT_REMOVEMATCHINGINFORMATION 40070
#define ID_EDIT_ENABLEDISABLEGLOBALLY   40071
#define ID_EDIT_ENABLEDISABLELOCALLY    40072
#define ID_DATABASE_CREATENEWAPPHELPMESSAGE 40073

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        150
#define _APS_NEXT_COMMAND_VALUE         40080
#define _APS_NEXT_CONTROL_VALUE         1069
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\appcompat\tools\compatadmin\dbviewer.h ===
#define DBCMD_PROPERTIES    (WM_USER+1024)
#define DBCMD_DELETE        (DBCMD_PROPERTIES+1)
#define DBCMD_DISABLEUSER   (DBCMD_PROPERTIES+2)
#define DBCMD_DISABLEGLOBAL (DBCMD_PROPERTIES+3)
#define DBCMD_VIEWSHIMS     (DBCMD_PROPERTIES+4)
#define DBCMD_VIEWAPPHELP   (DBCMD_PROPERTIES+5)
#define DBCMD_FIXWIZARD     (DBCMD_PROPERTIES+6)
#define DBCMD_VIEWGLOBAL    (DBCMD_PROPERTIES+7)
#define DBCMD_VIEWPATCH     (DBCMD_PROPERTIES+8)
#define DBCMD_VIEWLAYERS    (DBCMD_PROPERTIES+9)
#define DBCMD_VIEWDISABLED  (DBCMD_PROPERTIES+10)

typedef struct {
    UINT uType;
    union {
        PSHIMDESC   pShim;
        PMATCHENTRY pMatch;
        PHELPENTRY  pHelp;
    };
    UINT uID;
    UINT uContext;
} DBTREETIP, *PDBTREETIP;

#define MAX_TIPS    1024

class CDBView: public CView {
    HWND        m_hListView;
    UINT        m_uListSize;
    UINT        m_uListHeight;
    HWND        m_hTreeView;
    HBRUSH      m_hFillBrush;
    UINT        m_uCapturePos;
    DBTREETIP   m_TipList[MAX_TIPS];
    UINT        m_uNextTip;
    HIMAGELIST  m_hImageList;
    UINT        m_uImageRedirector[1024];
    PDBRECORD   m_pCurrentRecord;
    HTREEITEM   m_hSelectedItem;
    PDBRECORD   m_pListRecord;
    BOOL        m_bHorzDrag;
    UINT        m_uContext;
    BOOL        m_bDrag;

    CListView   m_GlobalList;
    CListView   m_LocalList;

public:

    CDBView();

    BOOL    Initialize              (void);
    void    Update                  (BOOL fNewCreate = TRUE);

    BOOL    Activate                (BOOL fNewCreate = TRUE);

    // Utility functions

    void    GenerateTreeToolTip    (PDBTREETIP,LPTSTR);
    HTREEITEM   AddTreeItem        (HTREEITEM hParent,
                                    DWORD dwFlags,
                                    DWORD dwState = 0,
                                    LPCTSTR szText = TEXT(""),
                                    UINT uImage = 0,
                                    LPARAM lParam = 0);

    void    RefreshTree(void);

    void    DeleteDBWithTree       (HTREEITEM hItem);
    MSGAPI  msgClose               (void);

    UINT    LookupFileImage        (LPCTSTR szFilename, UINT uDefault);
    void    AddRecordToTree        (PDBRECORD);
    void    WriteFlagsToTree       (HTREEITEM hParent, DWORD dwFlags);
    void    SyncMenu               (void);
    void    SyncStates             (UINT uMenuCMD,
                                    UINT uToolCmd,
                                    BOOL bToolbar,
                                    BOOL bToggle);

    // Messages being examined.

    MSGAPI  msgPaint               (HDC hDC);

    MSGAPI  msgResize              (UINT uWidth, 
                                    UINT uHeight);

    MSGAPI  msgChar                (TCHAR chChar);

    MSGAPI  msgNotify              (LPNMHDR pHdr);
    MSGAPI  msgCommand             (UINT uID,
                                    HWND hSender);


    virtual LRESULT STDCALL MsgProc(UINT        uMsg,
                                    WPARAM      wParam,
                                    LPARAM      lParam);
};

void FormatFileSize(UINT uSize, LPTSTR szText);
void FormatVersion(LARGE_INTEGER liVer, LPTSTR szText);

BOOL CALLBACK DisableDialog(HWND, UINT, WPARAM, LPARAM);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\appcompat\tools\compatadmin\utils.h ===
//*****************************************************************************
//
// Support Class:   CSTRING
//
// Purpose:         Handle strings for the application. CSTRING does smart memory
//                  management for strings.
//
// Notes:           For more information, see CompatAdmin.DOC
//
// History
//
//  A-COWEN     Dec 12, 2000         Wrote it.
//
//*****************************************************************************

#define MAX_STRING_SIZE 2048

#ifndef UNICODE
    #define UNICODE
#endif    

#ifndef _UNICODE
    #define _UNICODE
#endif    


#include "stdarg.h"

class CMemException {
private:
    TCHAR   m_szMessageHeading[100];
    TCHAR   m_szMessage[512]       ; 
public:
    CMemException()
    {
         
        _tcscpy(m_szMessageHeading,TEXT("Insufficient Memory Exception"));
        _tcscpy(m_szMessage, TEXT("Insufficient Memory Exception"));

    }
    void SetString(TCHAR* szMsg )
    {
        int nch = _sntprintf(m_szMessage, 
                             sizeof(m_szMessage)/sizeof(TCHAR), 
                             TEXT("%s : %s"), m_szMessageHeading, szMsg);
        #ifdef __DEBUG
            if (nch < 0) {
                MessageBox(NULL,TEXT("Please make the error message Short"),TEXT("Long Error Message"), MB_ICONWARNING);
            }
        #endif

    }
    TCHAR* GetString()
    {
        return m_szMessage;
    }

};


class CSTRING {
public:

    WCHAR   * pszString;
    LPSTR     pszANSI;
    
public:

    CSTRING()
    {
        Init();
     
    }

    CSTRING(CSTRING & Str)
    {
        Init();
        SetString(Str.pszString);
    }

    CSTRING(LPTSTR szString)
    {
        Init();
        SetString(szString);
    }

    CSTRING(UINT uID)
    {
        Init();
        SetString(uID);
    }

    ~CSTRING()
    {
        Release();
    }

    void Init()
    {
        pszString = NULL;
        pszANSI = NULL;
    }

    void Release(void)
    {
        if ( NULL != pszString )
            delete pszString;

        if ( NULL != pszANSI )
            delete pszANSI;


        pszString = NULL;
        pszANSI = NULL;
    }

    BOOL SetString(UINT uID)
    {
        TCHAR szString[MAX_STRING_SIZE];

        if ( 0 != LoadString(GetModuleHandle(NULL), uID, szString, MAX_STRING_SIZE) )
            return SetString(szString);

        return FALSE;
    }

    BOOL SetString(LPCTSTR szStringIn)
    {
        if ( pszString == szStringIn )
            return TRUE;

        Release();

        if ( NULL == szStringIn )
            return TRUE;

        UINT uLen = _tcslen(szStringIn) + 1;

        pszString = new TCHAR[uLen];

        if ( NULL != pszString )
            _tcscpy(pszString,szStringIn);
        else {

            CMemException memException;
            throw memException;
            return FALSE;
        }


        return TRUE;
    }

    operator LPCSTR()
    {

       

        if (pszANSI != NULL) delete pszANSI;

        int cbSize = WideCharToMultiByte(CP_ACP,WC_COMPOSITECHECK,this->pszString, -1, NULL, 0, NULL, NULL);        
        pszANSI = (LPSTR) new CHAR [cbSize+1];

        ZeroMemory(pszANSI,sizeof(pszANSI) );

        if (pszANSI == NULL) {
            MEM_ERR;
            return NULL;
        }

        WideCharToMultiByte(CP_ACP,WC_COMPOSITECHECK,this->pszString, -1, pszANSI, cbSize+1, NULL, NULL);
        
        return pszANSI;
    }

    operator LPWSTR()
    {
        return pszString;
    }
    operator LPCWSTR()
    {

        return pszString;

    }

    CSTRING& operator =(LPCWSTR szStringIn)
    {
#ifndef UNICODE
        TCHAR   szTemp[MAX_STRING_SIZE];
        int nLength = lstrlenW(szStringIn);

        WideCharToMultiByte(CP_ACP,WC_COMPOSITECHECK,szStringIn,nLength,szTemp,MAX_STRING_SIZE,NULL,NULL);

        szTemp[nLength] = 0;

        SetString(szTemp);

#else
        SetString(szStringIn);
#endif

        return *this;
    }


    CSTRING& operator =(CSTRING & szStringIn)
    {
        
            SetString(szStringIn.pszString);
        
        

        return  *this;

    }


    BOOL operator == (CSTRING & szString)
    {
        if (NULL == pszString && NULL == szString.pszString) {
            return TRUE;
        }



        if ( NULL == pszString || NULL == szString.pszString)
            return FALSE;

        if ( 0 == lstrcmpi(szString.pszString,pszString) )
            return TRUE;

        return FALSE;
    }

    BOOL operator == (LPCTSTR szString)
    {
        
        if (NULL == pszString && NULL == szString) {
            return TRUE;
        }

        
        if ( NULL == pszString || NULL == szString)
            return FALSE;

        if ( 0 == lstrcmpi(szString,pszString) )
            return TRUE;

        return FALSE;
    }

    BOOL operator != (CSTRING & szString)
    {
        if (NULL == pszString && NULL == szString.pszString) {
            return FALSE;
        }

        
        if ( NULL == pszString || NULL == szString.pszString)
            return TRUE;

        if ( 0 == lstrcmpi(szString.pszString,pszString) )
            return FALSE;

        return TRUE;
    }

    BOOL operator != (LPCTSTR szString)
    {
        if ( NULL == pszString )
            return TRUE;

        if ( 0 == lstrcmpi(szString,pszString) )
            return FALSE;

        return TRUE;
    }

    BOOL operator <= (CSTRING &szString)
    {
        return ( (lstrcmpi (*this,szString) <= 0 ) ? TRUE : FALSE);
    }

    BOOL operator < (CSTRING &szString)
    {
        return ( (lstrcmpi (*this,szString) < 0 ) ? TRUE : FALSE);
    }

    BOOL operator >= (CSTRING &szString)
    {
        return ( (lstrcmpi (*this,szString) >= 0 ) ? TRUE : FALSE);
    }

    BOOL operator > (CSTRING &szString)
    {
        return ( (lstrcmpi (*this,szString) > 0 ) ? TRUE : FALSE);
    }





    void __cdecl sprintf(LPCTSTR szFormat, ...)
    {
        va_list list;
        TCHAR   szTemp[MAX_STRING_SIZE];

        va_start(list,szFormat);
        
        int cch = _vsntprintf(szTemp, sizeof(szTemp)/sizeof(szTemp[0]), szFormat, list);
        

        #ifdef __DEBUG
        if (cch < 0) {
            DBGPRINT((sdlError,("CSTRING::sprintf"), ("%s"), TEXT("Too long for _vsntprintf()") ) );
        }
        #endif


        SetString(szTemp);
    }

    UINT Trim()
    {
        

        CSTRING szTemp = *this;

        UINT uOrig_length =   Length();

        TCHAR *pStart       = szTemp.pszString,
              *pEnd         = szTemp.pszString + uOrig_length  - 1;
                              

       while ( *pStart== TEXT(' ') )                           ++pStart;

       while ( (pEnd >= pStart) && ( *pEnd == TEXT(' ') ) ) --pEnd;

       *( pEnd + 1) = TEXT('\0');//Keep it safe

       
       UINT nLength = pEnd - pStart;
       ++nLength; // For the character

       //
       //If no trimming has been done, return right away
       //
       if ( uOrig_length == nLength ) {
           return nLength;
       }


       SetString(pStart);

       return ( nLength);
    }

    BOOL SetChar(int nPos, TCHAR chValue)
    {
        //Pos is 0 based 

        int length =  Length();
        if (nPos >= length || length <= 0 ) {
            return FALSE;
        }

        this->pszString[nPos] = chValue;
        return TRUE;

    }
    static Trim(IN OUT LPTSTR str)
    {
        UINT uOrig_length = lstrlen(str); // Original length
        TCHAR *pStart       = str,
              *pEnd         = str + uOrig_length - 1;
                              

       while ( *pStart== TEXT(' ') )                           ++pStart;

       while ( (pEnd >= pStart) && ( *pEnd == TEXT(' ') ) ) --pEnd;

       *( pEnd + 1) = TEXT('\0');//Keep it safe



       
       UINT nLength = pEnd - pStart;
       ++nLength; // For the character

       //
       //If no trimming has been done, return right away
       //
       if ( uOrig_length == nLength ) {
           return nLength;
       }
       
       wmemmove(str,pStart, (nLength+1) * sizeof(TCHAR) ); // +1 for the 0 character.
       return (nLength);

    }
    BOOL EndsWith(LPCTSTR szSuffix)
    {
         const TCHAR* pStr = this->pszString;
         const TCHAR* pPos = NULL;
         pPos = _tcsrchr(pStr,TEXT('.'));

         if (pPos != NULL ) 
             if (_tcsicmp(pPos,szSuffix) == 0 ) return TRUE;

         return FALSE;
         

    }
    PCTSTR strcat(CSTRING & szStr)
    {
        return strcat((LPCTSTR)szStr);
    }

    LPCTSTR strcat(LPCTSTR pString)
    {
        
        if (pString == NULL) {
            return pszString;
        }

        int nLengthCat = _tcslen(pString);
        int nLengthStr = Length();
        
                
        TCHAR *szTemp = new TCHAR [nLengthStr + nLengthCat + 1];
        
        

        if ( szTemp == NULL ) {
            CMemException memException;
            throw memException;
            return NULL;

        }

        szTemp[0] = 0;

        //
        // Copy only if pszString != NULL. Otherwise we will get mem exception/garbage value
        //

        if (nLengthStr ) _tcsncpy(szTemp, pszString, nLengthStr);                   


        _tcsncpy(szTemp+nLengthStr, pString, nLengthCat);
        szTemp[nLengthStr + nLengthCat] = TEXT('\0');

        Release();
        pszString = szTemp;

        return pszString;
    }//strcat

    BOOL isNULL()
    {
        return(this->pszString == NULL);
    }

    int Length(void)
    {
        if ( NULL == pszString )
            return 0;

        return lstrlen(pszString);
    }

    void GUID(GUID & Guid)
    {
        TCHAR   szGUID[80];

        // NOTE: We could use StringFromGUID2, or StringfromIID, but that
        // would require loading OLE32.DLL. Unless we have to, avoid it.
        // OR you could use functions in SDBAPI 

        _stprintf(szGUID, TEXT("{%08x-%04x-%04x-%02x%02x-%02x%02x%02x%02x%02x%02x}"),
                 Guid.Data1,
                 Guid.Data2,
                 Guid.Data3,
                 Guid.Data4[0],
                 Guid.Data4[1],
                 Guid.Data4[2],
                 Guid.Data4[3],
                 Guid.Data4[4],
                 Guid.Data4[5],
                 Guid.Data4[6],
                 Guid.Data4[7]);

        SetString(szGUID);
    }

    void ShortFilename(void)
    {
        TCHAR   szTemp[MAX_PATH_BUFFSIZE];
        LPTSTR  szHold;

        // BUGBUG consider using shlwapi PathFindFileName

        _tcscpy(szTemp,pszString);

        LPTSTR  szWalk = szTemp;

        szHold = szWalk;

        while ( 0 != *szWalk ) {
            //
            // use _tcsrchr BUGBUG
            //
            if ( TEXT('\\') == *szWalk )
                szHold = szWalk+1;

            ++szWalk;
        }

        SetString(szHold);
    }

    BOOL RelativeFile(CSTRING & szPath)
    {
        return RelativeFile((LPCTSTR)szPath);
    }

    //
    // BUGBUG : consider using shlwapi PathRelativePathTo
    //
    BOOL RelativeFile(LPCTSTR pExeFile)
    {
        LPCTSTR pMatchFile = pszString;
        int     nLenExe = 0;
        int     nLenMatch = 0;
        LPCTSTR pExe    = NULL;
        LPCTSTR pMatch  = NULL;
        LPTSTR  pReturn = NULL;
        TCHAR   result[MAX_PATH_BUFFSIZE]; 
        LPTSTR  resultIdx = result;
        BOOL    bCommonBegin = FALSE; // Indicates if the paths have a common beginning

        *result = TEXT('\0');
        //
        // Ensure that the beginning of the path matches between the two files
        //
        // BUGBUG this code has to go -- look into replacing this with Shlwapi Path* 
        //
        //
        pExe = _tcschr(pExeFile, TEXT('\\'));
        pMatch = _tcschr(pMatchFile, TEXT('\\'));

        while ( pExe && pMatch ) {

            nLenExe = pExe - pExeFile;
            nLenMatch = pMatch - pMatchFile;

            if ( nLenExe != nLenMatch ) {
                break;
            }

            if ( !(_tcsnicmp(pExeFile, pMatchFile, nLenExe) == 0) ) {
                break;
            }

            bCommonBegin = TRUE;
            pExeFile = pExe + 1;
            pMatchFile = pMatch + 1;

            pExe = _tcschr(pExeFile, TEXT('\\'));
            pMatch = _tcschr(pMatchFile, TEXT('\\'));
        }

        //
        // Walk the path and put '..\' where necessary
        //
        if ( bCommonBegin ) {

            while ( pExe ) {
                _tcscpy(resultIdx, TEXT("..\\"));
                resultIdx = resultIdx + 3;
                pExeFile  = pExe + 1;
                pExe = _tcschr(pExeFile, TEXT('\\'));
            }

            _tcscpy(resultIdx, pMatchFile);

            SetString(result);
        }
        else{

           return FALSE;
        }

        return TRUE;
            
    }
};

//
// BUGBUG: consider using list class from STL
//
// 

template <class T> class CList {
protected:

    typedef struct _tagList {
        T                   Entry;
        struct _tagList   * pNext;
    } LIST, *PLIST;

    PLIST   m_pHead;
    PLIST   m_pCurrent;
    PLIST   m_pFindPrev;

private:

    PLIST Find(T * pData)
    {
        PLIST pWalk = m_pHead;

        m_pFindPrev = NULL;

        while ( NULL != pWalk ) {
            if ( pData == &pWalk->Entry )
                return pWalk;

            m_pFindPrev = pWalk;
            pWalk = pWalk->pNext;
        }

        return NULL;
    }

public:

    CList()
    {
        Init();
    }

    ~CList()
    {
        Release();
    }

    void Init(void)
    {
        m_pHead = NULL;
        m_pCurrent = NULL;
    }

    void Release(void)
    {
        while ( NULL != m_pHead ) {
            PLIST pHold = m_pHead->pNext;

            delete m_pHead;

            m_pHead = pHold;
        }
    }

    T * First(void)
    {
        m_pCurrent = m_pHead;

        if ( NULL == m_pHead )
            return NULL;

        return &m_pHead->Entry;
    }

    T * Next(void)
    {
        if ( NULL != m_pCurrent ) {
            m_pCurrent = m_pCurrent->pNext;

            if ( NULL != m_pCurrent )
                return &m_pCurrent->Entry;
        }

        return NULL;
    }

    BOOL Insert(T * pInsert, T * pAfter = NULL)
    {
        PLIST pNew = new LIST;

        if ( NULL == pNew )
            return FALSE;

        pNew->Entry = *pInsert;

        if ( NULL == pAfter ) {
            pNew->pNext = m_pHead;
            m_pHead = pNew;
        } else {
            PLIST pHold = Find(pAfter);

            if ( NULL == pHold ) {
                delete pNew;
                return FALSE;
            }

            pNew->pNext = pHold->pNext;
            pHold->pNext = pNew;
        }

        return TRUE;
    }

    T * Insert(T * pAfter = NULL)
    {
        PLIST pNew = new LIST;

        if ( NULL == pNew )
            return NULL;

        if ( NULL == pAfter ) {
            pNew->pNext = m_pHead;
            m_pHead = pNew;
        } else {
            PLIST pHold = Find(pAfter);

            if ( NULL == pHold ) {
                delete pNew;
                return NULL;
            }

            pNew->pNext = pHold->pNext;
            pHold->pNext = pNew;
        }

        return &pNew->Entry;
    }

    BOOL Delete(T * pEntry)
    {
        PLIST pHold = Find(pEntry);

        if ( NULL == pHold )
            return FALSE;

        if ( NULL != m_pFindPrev ) {
            m_pFindPrev->pNext = pHold->pNext;
            delete pHold;
        } else {
            m_pHead = m_pHead->pNext;
            delete m_pHead;
        }

        m_pCurrent = NULL;

        return TRUE;
    }
};

typedef struct _tagSList {
    CSTRING             szStr;
    union {
        PVOID           pExtraData;
        UINT            uExtraData;
        DWORD           dwExtraData;
        int             nExtraData;
    };
    struct _tagSList  * pNext;
} STRLIST, *PSTRLIST;

class CSTRINGList {
public:

    PSTRLIST    m_pHead;
    PSTRLIST    m_pTail;

public:

    CSTRINGList()
    {
        m_pHead = NULL;
        m_pTail = NULL;
    }

    ~CSTRINGList()
    {
        while ( NULL != m_pHead ) {
            PSTRLIST pHold = m_pHead->pNext;
            delete m_pHead;
            m_pHead = pHold;
        }
    }

    BOOL        AddString(CSTRING & Str, PVOID pExtraData = NULL)
    {
        return AddString((LPCTSTR)Str,pExtraData);
    }

    BOOL        AddString(LPCTSTR pStr, PVOID pExtraData = NULL)
    {
        PSTRLIST pNew = new STRLIST;

        if ( NULL == pNew )
            return FALSE;

        pNew->szStr = pStr;
        pNew->pExtraData = pExtraData;
        pNew->pNext = NULL;

        if ( NULL == m_pTail ) {
            m_pHead = m_pTail = pNew;
        } else {
            m_pTail->pNext = pNew;
            m_pTail = pNew;
        }

        return TRUE;
    }
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\appcompat\tools\compatadmin\wizard.cpp ===
#include "compatadmin.h"

#ifndef __WIZARD_H
    #include "wizard.h"
#endif    

#include "xmldialog.h"

CShimWizard * g_pCurrentWizard = NULL;


#define MAX_DESC_LENGTH     40

#define PAGE_INTRO          0
#define PAGE_APPNAME        1
#define PAGE_LAYERNAME      2
#define PAGE_SELFILES1      3
#define PAGE_DONE           3
#define PAGE_SHIMS          4
#define PAGE_SHIMNAME       5
#define PAGE_SELECTFILES    6

BOOL CShimWizard::BeginWizard(HWND hParent)
{
    PROPSHEETPAGE   Pages[11];

    ZeroMemory(&m_Record,sizeof(m_Record));

    CoCreateGuid(&m_Record.guidID);

    // Setup wizard variables

    g_pCurrentWizard = this;

    // Set default application settings

    m_uType = TYPE_LAYER;

    // begin the wizard

    PROPSHEETHEADER Header;

    Header.dwSize = sizeof(PROPSHEETHEADER);
    Header.dwFlags = PSH_WIZARD97 | PSH_PROPSHEETPAGE | PSH_HEADER;
    Header.hwndParent = hParent;
    Header.hInstance = g_hInstance;
    Header.pszCaption = /*"Create an application fix";//*/MAKEINTRESOURCE(IDS_WIZARD);
    Header.nStartPage = 0;
    Header.ppsp = Pages;
    Header.nPages = 7;
    Header.pszbmHeader = MAKEINTRESOURCE(IDB_WIZBMP);

    Pages[PAGE_INTRO].dwSize = sizeof(PROPSHEETPAGE);
    Pages[PAGE_INTRO].dwFlags = PSP_USEHEADERSUBTITLE;
    Pages[PAGE_INTRO].hInstance = g_hInstance;
    Pages[PAGE_INTRO].pszTemplate = MAKEINTRESOURCE(IDD_ADDWIZARD);
    Pages[PAGE_INTRO].pfnDlgProc = (DLGPROC)EntryPoint;
    Pages[PAGE_INTRO].pszHeaderSubTitle = TEXT("Select method");

    Pages[PAGE_APPNAME].dwSize = sizeof(PROPSHEETPAGE);
    Pages[PAGE_APPNAME].dwFlags = PSP_USEHEADERSUBTITLE;
    Pages[PAGE_APPNAME].hInstance = g_hInstance;
    Pages[PAGE_APPNAME].pszTemplate = MAKEINTRESOURCE(IDD_ADDWIZARD3);
    Pages[PAGE_APPNAME].pfnDlgProc = (DLGPROC)GetAppName;
    Pages[PAGE_APPNAME].pszHeaderSubTitle = TEXT("Enter an application name");

    Pages[PAGE_LAYERNAME].dwSize = sizeof(PROPSHEETPAGE);
    Pages[PAGE_LAYERNAME].dwFlags = PSP_USEHEADERSUBTITLE;
    Pages[PAGE_LAYERNAME].hInstance = g_hInstance;
    Pages[PAGE_LAYERNAME].pszTemplate = MAKEINTRESOURCE(IDD_ADDWIZARD2);
    Pages[PAGE_LAYERNAME].pfnDlgProc = (DLGPROC)SelectLayer;
    Pages[PAGE_LAYERNAME].pszHeaderSubTitle = TEXT("Select the files and compatibility mode");
/*
    Pages[PAGE_SELFILES1].dwSize = sizeof(PROPSHEETPAGE);
    Pages[PAGE_SELFILES1].dwFlags = PSP_USEHEADERSUBTITLE;
    Pages[PAGE_SELFILES1].hInstance = g_hInstance;
    Pages[PAGE_SELFILES1].pszTemplate = MAKEINTRESOURCE(IDD_ADDWIZARD4);
    Pages[PAGE_SELFILES1].pfnDlgProc = SelectMatching;
    Pages[PAGE_SELFILES1].pszHeaderSubTitle = "How would you like to identify the application?";
*/
    Pages[PAGE_DONE].dwSize = sizeof(PROPSHEETPAGE);
    Pages[PAGE_DONE].dwFlags = PSP_USEHEADERSUBTITLE;
    Pages[PAGE_DONE].hInstance = g_hInstance;
    Pages[PAGE_DONE].pszTemplate = MAKEINTRESOURCE(IDD_ADDWIZARDDONE);
    Pages[PAGE_DONE].pfnDlgProc = (DLGPROC)WizardDone;
    Pages[PAGE_DONE].pszHeaderSubTitle = TEXT("You have successfully created an application fix");

    Pages[PAGE_SHIMS].dwSize = sizeof(PROPSHEETPAGE);
    Pages[PAGE_SHIMS].dwFlags = PSP_USEHEADERSUBTITLE;
    Pages[PAGE_SHIMS].hInstance = g_hInstance;
    Pages[PAGE_SHIMS].pszTemplate = MAKEINTRESOURCE(IDD_ADDWIZARD5);
    Pages[PAGE_SHIMS].pfnDlgProc = (DLGPROC)SelectShims;
    Pages[PAGE_SHIMS].pszHeaderSubTitle = TEXT("Select the fixes to apply to the application");

    Pages[PAGE_SHIMNAME].dwSize = sizeof(PROPSHEETPAGE);
    Pages[PAGE_SHIMNAME].dwFlags = PSP_USEHEADERSUBTITLE;
    Pages[PAGE_SHIMNAME].hInstance = g_hInstance;
    Pages[PAGE_SHIMNAME].pszTemplate = MAKEINTRESOURCE(IDD_ADDWIZARD6);
    Pages[PAGE_SHIMNAME].pfnDlgProc = (DLGPROC)SelectLayer;
    Pages[PAGE_SHIMNAME].pszHeaderSubTitle = TEXT("Select the file to create the fix for");

    Pages[PAGE_SELECTFILES].dwSize = sizeof(PROPSHEETPAGE);
    Pages[PAGE_SELECTFILES].dwFlags = PSP_USEHEADERSUBTITLE;
    Pages[PAGE_SELECTFILES].hInstance = g_hInstance;
    Pages[PAGE_SELECTFILES].pszTemplate = MAKEINTRESOURCE(IDD_ADDWIZARD7);
    Pages[PAGE_SELECTFILES].pfnDlgProc = (DLGPROC)SelectFiles;
    Pages[PAGE_SELECTFILES].pszHeaderSubTitle = TEXT("Select files used for application identification");

    if ( 0 < PropertySheet(&Header) ) {
        PDBRECORD pRecord = new DBRECORD;

        if ( NULL != pRecord ) {
            ZeroMemory(pRecord,sizeof(DBRECORD));

            pRecord->szEXEName = m_Record.szEXEName;
            pRecord->szAppName = m_Record.szAppName;
            pRecord->szLayerName = m_Record.szLayerName;
            pRecord->guidID = m_Record.guidID;
            pRecord->pEntries = m_Record.pEntries;

            g_theApp.GetDBLocal().InsertRecord(pRecord);
           
            return TRUE;
        }
    }
    
    return FALSE;
}

BOOL CALLBACK EntryPoint(HWND hDlg, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    switch ( uMsg ) {
    case    WM_INITDIALOG:
        {
            HWND hParent = GetParent(hDlg);

            SetWindowText(hParent,TEXT("Create an application fix"));

            if ( TYPE_LAYER == g_pCurrentWizard->m_uType )
                SendDlgItemMessage(hDlg,IDC_LAYERS,BM_SETCHECK,BST_CHECKED,0);

            if ( TYPE_SHIM == g_pCurrentWizard->m_uType )
                SendDlgItemMessage(hDlg,IDC_SHIM,BM_SETCHECK,BST_CHECKED,0);

            if ( TYPE_APPHELP == g_pCurrentWizard->m_uType )
                SendDlgItemMessage(hDlg,IDC_APPHELP,BM_SETCHECK,BST_CHECKED,0);
        }
        break;

    case    WM_NOTIFY:
        {
            NMHDR * pHdr = (NMHDR *) lParam;

            switch ( pHdr->code ) {
            case    PSN_SETACTIVE:
                SendMessage(GetParent(hDlg),PSM_SETWIZBUTTONS, 0, PSWIZB_NEXT);
                break;

            case    PSN_WIZNEXT:
                {
                    if ( BST_CHECKED == SendDlgItemMessage(hDlg,IDC_LAYERS,BM_GETCHECK,0,0) ) {
                        if ( g_pCurrentWizard->m_uType != TYPE_LAYER )
                            g_pCurrentWizard->WipeRecord(TRUE,TRUE,TRUE);

                        g_pCurrentWizard->m_uType = TYPE_LAYER;
                    }

                    if ( BST_CHECKED == SendDlgItemMessage(hDlg,IDC_SHIM,BM_GETCHECK,0,0) ) {
                        if ( g_pCurrentWizard->m_uType != TYPE_SHIM )
                            g_pCurrentWizard->WipeRecord(TRUE,TRUE,TRUE);

                        g_pCurrentWizard->m_uType = TYPE_SHIM;
                    }
                }
                break;
            }
        }
        break;
    }

    return FALSE;
}

#define FRIENDLY_NAME   TEXT("My Application Fix")

BOOL CALLBACK GetAppName(HWND hDlg, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    switch ( uMsg ) {
    case    WM_INITDIALOG:
        {
            
            SendMessage( 
                GetDlgItem(hDlg,IDC_NAME),              // handle to destination window 
                EM_LIMITTEXT,             // message to send
                (WPARAM) LIMIT_APP_NAME,          // text length
                (LPARAM) 0
                );

            SHAutoComplete(GetDlgItem(hDlg,IDC_NAME), AUTOCOMPLETE);

            if ( 0 == g_pCurrentWizard->m_Record.szAppName.Length() )
                g_pCurrentWizard->m_Record.szAppName = FRIENDLY_NAME;

            SetDlgItemText(hDlg,IDC_NAME, g_pCurrentWizard->m_Record.szAppName);

            if ( g_pCurrentWizard->m_Record.szAppName == FRIENDLY_NAME )
                SendMessage(GetDlgItem(hDlg,IDC_NAME),EM_SETSEL,0,-1);

            // Force proper Next button state.

            SendMessage(hDlg,WM_COMMAND,MAKEWPARAM(IDC_NAME,EN_CHANGE),0);
        }
        break;

    case    WM_NOTIFY:
        {
            NMHDR * pHdr = (NMHDR *) lParam;

            switch ( pHdr->code ) {
            case    PSN_SETACTIVE:
                {
                    SendMessage(hDlg,WM_COMMAND,MAKEWPARAM(IDC_NAME,EN_CHANGE),0);

                    if ( TYPE_LAYER == g_pCurrentWizard->m_uType )
                        SetWindowText(GetDlgItem(hDlg,IDC_TITLE),TEXT("Enter the name of the application to create a compatibility layer for"));
                    else
                        SetWindowText(GetDlgItem(hDlg,IDC_TITLE),TEXT("Enter the name of the application to create a fix for"));
                }
                break;

            case    PSN_WIZNEXT:
                {
                    TCHAR szTemp[MAX_STRING_SIZE];

                    GetDlgItemText(hDlg,IDC_NAME,szTemp,MAX_STRING_SIZE);

                    CSTRING::Trim(szTemp);

                    g_pCurrentWizard->m_Record.szAppName = szTemp;

                    if ( TYPE_SHIM == g_pCurrentWizard->m_uType ) {
                        SetWindowLongPtr(hDlg,DWLP_MSGRESULT,IDD_ADDWIZARD6);

                        return IDD_ADDWIZARD6;
                    }
                }
                break;
            }
        }
        break;

    case    WM_COMMAND:
        switch ( LOWORD(wParam) ) {
        case    IDC_NAME:
            if ( EN_CHANGE == HIWORD(wParam) ) {

                TCHAR   szText[MAX_PATH_BUFFSIZE];
                
                GetWindowText(GetDlgItem(hDlg,IDC_NAME),szText,MAX_PATH);

                BOOL    bEnable = ( CSTRING::Trim(szText) > 0) ? TRUE:FALSE;

                DWORD   dwFlags = PSWIZB_BACK;

                if ( bEnable )
                    dwFlags |= PSWIZB_NEXT;

                SendMessage(GetParent(hDlg),PSM_SETWIZBUTTONS,0, dwFlags);
            }
            break;
        }
    }

    return FALSE;
}

BOOL CALLBACK SelectLayer(HWND hDlg, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    switch ( uMsg ) {
    case    WM_INITDIALOG:
        {
           
            SendMessage( 
                GetDlgItem(hDlg,IDC_NAME),              // handle to destination window 
                EM_LIMITTEXT,             // message to send
                (WPARAM) MAX_PATH,          // text length
                (LPARAM) 0
                );

            SetDlgItemText(hDlg,IDC_NAME,g_pCurrentWizard->m_szLongName);

            SHAutoComplete(GetDlgItem(hDlg,IDC_NAME), AUTOCOMPLETE);

            // Force proper Next button state.

            SendMessage(hDlg,WM_COMMAND,MAKEWPARAM(IDC_NAME,EN_CHANGE),0);
        }
        break;

    case    WM_NOTIFY:
        {
            NMHDR * pHdr = (NMHDR *) lParam;

            switch ( pHdr->code ) {
            case    PSN_SETACTIVE:
                {
                    if ( TYPE_LAYER == g_pCurrentWizard->m_uType ) {
                        
                        int         nSelIndex = -1;

                        // Remove all strings.

                        //g_pCurrentWizard->WipeRecord(TRUE,TRUE,FALSE);

                        while ( CB_ERR != SendDlgItemMessage(hDlg,IDC_LAYERLIST,CB_DELETESTRING,0,0) );

                        // Re-add the strings.

                        PDBLAYER    pWalk = g_theApp.GetDBGlobal().m_pLayerList;

                        for ( int iLoop = 0 ; iLoop <= 1 ; ++ iLoop ){
                            //
                            // Do both for the local and the global Databases
                            //
                        
                            while ( NULL != pWalk ) {
                                if ( CB_ERR == SendDlgItemMessage(hDlg,IDC_LAYERLIST,CB_FINDSTRINGEXACT,0,(LPARAM)(LPCTSTR)pWalk->szLayerName) ) {
                                    int nIndex;

                                    nIndex = SendDlgItemMessage(hDlg,IDC_LAYERLIST,CB_ADDSTRING,0,(LPARAM)(LPTSTR)pWalk->szLayerName);

                                    if ( CB_ERR != nIndex ) {
                                        SendDlgItemMessage(hDlg,IDC_LAYERLIST,CB_SETITEMDATA,nIndex,(LPARAM)pWalk);

                                    // Select this index if it's the current layer name.
/*
                                                    if (0 == lstrcmp(g_pCurrentWizard->m_Record.szLayerName,(LPSTR)pWalk->szLayerName))
                                                        nSelIndex = nIndex;
*/
                                    }
                                }

                            pWalk = pWalk->pNext;
                            }
                            pWalk = g_theApp.GetDBLocal().m_pLayerList;
                            
                        } //for


                        nSelIndex = SendDlgItemMessage(hDlg,IDC_LAYERLIST,CB_FINDSTRINGEXACT,0,(LPARAM)(LPCTSTR)g_pCurrentWizard->m_Record.szLayerName);

                        if ( -1 != nSelIndex )
                            SendDlgItemMessage(hDlg,IDC_LAYERLIST,CB_SETCURSEL,nSelIndex,0);
                    }

                    SendMessage(hDlg,WM_COMMAND,MAKEWPARAM(IDC_NAME,EN_CHANGE),0);
                }
                break;

            case    PSN_WIZNEXT:
                {
                    TCHAR   szTemp[MAX_STRING_SIZE];

                    GetDlgItemText(hDlg,IDC_NAME,szTemp,MAX_PATH);

                    CSTRING::Trim(szTemp);

                    HANDLE hFile = CreateFile (szTemp,0,0,NULL,OPEN_EXISTING,FILE_ATTRIBUTE_NORMAL,NULL);

                    if ( INVALID_HANDLE_VALUE == hFile ) {
                        MessageBox(hDlg,TEXT("Unable to locate specified file"),TEXT("Invalid file name"),MB_OK);

                        SetWindowLongPtr(hDlg,DWLP_MSGRESULT,-1);
                        return -1;
                    }

                    CloseHandle(hFile);

                    DWORD dwExeType;

                    GetBinaryType(szTemp, &dwExeType);

                    BOOL bExe = FALSE;// Is this an .exe file

                    CSTRING strTemp = szTemp;

                    if ( strTemp.EndsWith(TEXT(".exe")) ) bExe = TRUE;

                    //
                    // Check if this is "shimmable"
                    //

                    CSTRING msg;

                    if (    (dwExeType & SCS_DOS_BINARY) && bExe )
                            msg = TEXT("This is a DOS Application\n");
                    

                    else if ( (dwExeType & SCS_WOW_BINARY) && bExe)
                            msg = TEXT("This is a 16 bit Windows Application\n");
                        
                    else if ((dwExeType & SCS_PIF_BINARY) && bExe )
                             msg = TEXT("This is a PIF Binary Application\n"); 

                    else if ( (dwExeType & SCS_POSIX_BINARY) && bExe)
                              msg = msg = TEXT("This is a POSIX Binary Application\n");

                    else if ( (dwExeType & SCS_OS216_BINARY) && bExe)
                            msg = TEXT("This is a OS2 16 bit Application\n");

                        
                    if (msg.Length() > 0) {

                        //
                        //So this application cannot be fixed
                        //

                        MessageBox(hDlg,
                                   msg.strcat( TEXT("The fix may not get applied properly for this application") ), 
                                   TEXT("Warning!"),
                                   MB_ICONWARNING
                                    );

                        //SetWindowLongPtr(hDlg,DWLP_MSGRESULT,-1);
                        //return -1;


                    }
                        
                    ////check - out

                    if (strTemp != g_pCurrentWizard->m_szLongName) {

                        //
                        //The file name was changed. Either this is the first time that the user has come here, or has moved back and changed the file name
                        // Remove all the mathcing info

                        g_pCurrentWizard->WipeRecord(TRUE, FALSE, FALSE);

                    }

                    ////


                    g_pCurrentWizard->m_szLongName = szTemp;
                    g_pCurrentWizard->m_Record.szEXEName = g_pCurrentWizard->ShortFile(g_pCurrentWizard->m_szLongName);

                    if ( TYPE_LAYER == g_pCurrentWizard->m_uType ) {
                        int     nIndex;

                        nIndex = SendDlgItemMessage(hDlg,IDC_LAYERLIST,CB_GETCURSEL,0,0);

                        SendDlgItemMessage(hDlg,IDC_LAYERLIST,CB_GETLBTEXT,nIndex,(LPARAM)szTemp);

                        g_pCurrentWizard->m_Record.szLayerName = szTemp;
                    } else {
                        SetWindowLongPtr(hDlg,DWLP_MSGRESULT,IDD_ADDWIZARD5);

                        return IDD_ADDWIZARD6;
                    }

                    SetWindowLongPtr(hDlg,DWLP_MSGRESULT,IDD_ADDWIZARD7);

                    return IDD_ADDWIZARD7;
                }
                break;

            case    PSN_WIZBACK:
                {
                    TCHAR   szTemp[MAX_STRING_SIZE];

                    GetDlgItemText(hDlg,IDC_NAME,szTemp,MAX_STRING_SIZE);

                    CSTRING::Trim(szTemp);

                    g_pCurrentWizard->m_szLongName = szTemp;

                    if ( TYPE_LAYER == g_pCurrentWizard->m_uType ) {
                        int     nIndex;

                        nIndex = SendDlgItemMessage(hDlg,IDC_LAYERLIST,CB_GETCURSEL,0,0);

                        SendDlgItemMessage(hDlg,IDC_LAYERLIST,CB_GETLBTEXT,nIndex,(LPARAM)szTemp);

                        g_pCurrentWizard->m_Record.szLayerName = szTemp;
                    } else {
                        SetWindowLongPtr(hDlg,DWLP_MSGRESULT,IDD_ADDWIZARD3);

                        return IDD_ADDWIZARD3;
                    }

                }
                break;
            }
        }
        break;

    case    WM_COMMAND:
        switch ( LOWORD(wParam) ) {
        case    IDC_LAYERLIST:
            {
                if ( CBN_SELCHANGE == HIWORD(wParam) )
                    SendMessage(hDlg,WM_COMMAND,MAKEWPARAM(IDC_NAME,EN_CHANGE),0);
            }
            break;

        case    IDC_NAME:
            if ( EN_CHANGE == HIWORD(wParam) ) {

                TCHAR   szText[MAX_PATH_BUFFSIZE];
                
                GetWindowText(GetDlgItem(hDlg,IDC_NAME),szText,MAX_PATH);


                BOOL    bEnable = (CSTRING::Trim(szText) > 0) ? TRUE:FALSE;

                DWORD   dwFlags = PSWIZB_BACK;

                if ( bEnable )
                    dwFlags |= PSWIZB_NEXT;

                HWND hLayer = GetDlgItem(hDlg,IDC_LAYERLIST);

                if ( NULL != hLayer ) {
                    // A layer must be selected as well.

                    int nSel = SendMessage(hLayer,CB_GETCURSEL,0,0);

                    if ( CB_ERR == nSel )
                        dwFlags &= ~PSWIZB_NEXT;
                }

                SendMessage(GetParent(hDlg),PSM_SETWIZBUTTONS,0, dwFlags);
            }
            break;

        case    IDC_BROWSE:
            {
                CSTRING szFilename;

                HWND hwndFocus = GetFocus();

                if ( g_theApp.GetFilename(TEXT("Find executable"),TEXT("EXE File (*.EXE)\0*.EXE\0All files (*.*)\0*.*\0\0"),TEXT(""),TEXT("EXE"),OFN_PATHMUSTEXIST | OFN_FILEMUSTEXIST,TRUE,szFilename) ) {
                    
                    g_pCurrentWizard->m_Record.szEXEName = g_pCurrentWizard->ShortFile(szFilename);

                    SetDlgItemText(hDlg, IDC_NAME, szFilename);

                    SendMessage(hDlg,WM_COMMAND,MAKEWPARAM(IDC_NAME,EN_CHANGE),0);
                }

                SetFocus( hwndFocus );
            }
            break;
        }
        break;
    }

    return FALSE;
}

BOOL CALLBACK SelectMatching(HWND hDlg, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    switch ( uMsg ) {
    case    WM_INITDIALOG:
        {
            SendDlgItemMessage(hDlg,IDC_GENERATE,BM_SETCHECK,BST_CHECKED,0);
        }
        break;

    case    WM_NOTIFY:
        {
            NMHDR * pHdr = (NMHDR *) lParam;

            switch ( pHdr->code ) {
            case    PSN_SETACTIVE:
                SendMessage(GetParent(hDlg),PSM_SETWIZBUTTONS, 0, PSWIZB_BACK | PSWIZB_NEXT);
                break;

            case    PSN_WIZNEXT:
                {
                    if ( BST_CHECKED == SendDlgItemMessage(hDlg,IDC_GENERATE,BM_GETCHECK,0,0) ) {
                        HCURSOR hRestore;
                        CSTRING szFile = g_pCurrentWizard->m_szLongName;

                        LPTSTR szWalk = _tcsrchr( (LPTSTR)szFile, TEXT('\\'));

                        // 
                        // current directory extraction from the szFile
                        //
                                                
                        if (NULL == szWalk) {
                            // ? 

                        } else {
                            *szWalk = 0;
                        }

                        SetCurrentDirectory(szFile);

                        g_pCurrentWizard->m_bManualMatch = FALSE;

                        hRestore = SetCursor(LoadCursor(NULL,IDC_WAIT));
                        g_pCurrentWizard->GrabMatchingInfo();
                        SetCursor(hRestore);
                    }

                    if ( BST_CHECKED == SendDlgItemMessage(hDlg,IDC_MANUAL,BM_GETCHECK,0,0) ) {
                        WIN32_FIND_DATA Data;
                        HANDLE          hFile;
                        PMATCHENTRY     pMatch = NULL;

                        g_pCurrentWizard->m_bManualMatch = TRUE;

                        hFile = FindFirstFile(g_pCurrentWizard->m_szLongName,&Data);

                        if ( INVALID_HANDLE_VALUE != hFile ) {
                            g_pCurrentWizard->AddMatchFile(&pMatch,g_pCurrentWizard->m_szLongName);

                            g_pCurrentWizard->GetFileAttributes(pMatch);

                            if ( !g_pCurrentWizard->InsertMatchingInfo(pMatch) )
                                delete pMatch;

                            //pMatch->Entry.pNext = g_pCurrentWizard->m_Record.pEntries;
                            //g_pCurrentWizard->m_Record.pEntries = (PDBENTRY) pMatch;
                        }
                    }

                    SetWindowLongPtr(hDlg,DWLP_MSGRESULT,IDD_ADDWIZARD7);

                    return IDD_ADDWIZARD7;
                }
                break;

            case    PSN_WIZBACK:
                {
                    if ( TYPE_LAYER == g_pCurrentWizard->m_uType ) {
                        SetWindowLongPtr(hDlg,DWLP_MSGRESULT,IDD_ADDWIZARD2);

                        return IDD_ADDWIZARD2;
                    } else
                        if ( TYPE_SHIM == g_pCurrentWizard->m_uType ) {
                        SetWindowLongPtr(hDlg,DWLP_MSGRESULT,IDD_ADDWIZARD5);

                        return IDD_ADDWIZARD5;
                    }
                }
                break;
            }
        }
        break;
    }

    return FALSE;

}

BOOL CALLBACK WizardDone(HWND hDlg, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    switch ( uMsg ) {
    
    case    WM_NOTIFY:
        {
            NMHDR * pHdr = (NMHDR *) lParam;

            switch ( pHdr->code ) {
            case    PSN_WIZBACK:

                SetWindowLongPtr(hDlg,DWLP_MSGRESULT,IDD_ADDWIZARD7);

                return IDD_ADDWIZARD7;

            case    PSN_SETACTIVE:
                SendMessage(GetParent(hDlg),PSM_SETWIZBUTTONS, 0, PSWIZB_BACK | PSWIZB_FINISH);
            }
        }
        break;


    case    WM_COMMAND:
        switch ( LOWORD(wParam) ) {
        case    IDC_VIEWXML:
            {
                CXMLDialog  XML;

                XML.BeginXMLView(&g_pCurrentWizard->m_Record,hDlg,FALSE,FALSE,TRUE);
            }
            break;

        case    IDC_TESTRUN:
            {
                HWND hndFocus = GetFocus();
                g_theApp.TestRun(&g_pCurrentWizard->m_Record,&g_pCurrentWizard->m_szLongName,NULL,hDlg);

                SetFocus(hndFocus);

            }
            break;
        }
        break;
    }

    return FALSE;
}


void SelectShims_TreeDoubleClicked(HWND hDlg);


BOOL CALLBACK SelectShims(HWND hDlg, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    switch ( uMsg ) {
    case    WM_INITDIALOG:
        {
            

            TVINSERTSTRUCT  Item;
            PSHIMDESC       pWalk = g_theApp.GetDBGlobal().m_pShimList;

            Item.hParent = TVI_ROOT;
            Item.hInsertAfter = TVI_LAST;
            Item.item.mask = TVIF_TEXT | TVIF_PARAM;

            while ( NULL != pWalk ) {
                if ( pWalk->bGeneral ) {
                    PSHIMENTRY pNew = new SHIMENTRY;

                    if ( NULL != pNew ) {
                        pNew->Entry.uType = ENTRY_SHIM;
                        pNew->Entry.uIconID = 0;
                        pNew->Entry.pNext = NULL;
                        pNew->szShimName = pWalk->szShimName;
                        pNew->szCmdLine = pWalk->szShimCommandLine;
                        pNew->pDesc = pWalk;

                        Item.item.pszText = (LPTSTR) pWalk->szShimName;
                        Item.item.cchTextMax = lstrlen(Item.item.pszText);
                        Item.item.lParam = (LPARAM) pNew;

                        TreeView_InsertItem(GetDlgItem(hDlg,IDC_SHIMLIST),&Item);
                    }
                }

                pWalk = pWalk->pNext;
            }

            SetTimer(hDlg,0,100,NULL);
        }
        break;

    case    WM_COMMAND:
        {
            switch ( LOWORD(wParam) ) {
            case    IDC_CLEARALL:
                {
                    HTREEITEM   hItem;
                    HWND        hTree = GetDlgItem(hDlg,IDC_SHIMLIST);

                    hItem = TreeView_GetRoot(hTree);

                    while ( NULL != hItem ) {
                        TVITEM  Item;

                        Item.mask = TVIF_STATE;
                        Item.hItem = hItem;

                        TreeView_GetItem(hTree,&Item);

                        if ( 0 != (Item.state & 0x2000) ) {
                            Item.state &= 0xFFFFDFFF;
                            Item.state |= 0x1000;

                            TreeView_SetItemState(hTree,hItem,Item.state,0xFFFFFFFF);
                        }

                        hItem = TreeView_GetNextSibling(hTree,hItem);
                    }

                    // Recount

                    SetTimer(hDlg,0,100,NULL);
                }
                break;
            }
        }
        break;

    case    WM_TIMER:
        {
            UINT        uTotal = 0;
            UINT        uSelected = 0;
            HTREEITEM   hItem;
            HWND        hTree = GetDlgItem(hDlg,IDC_SHIMLIST);
            CSTRING     szText;

            KillTimer(hDlg,0);

            // Count the selected shims

            hItem = TreeView_GetRoot(hTree);

            while ( NULL != hItem ) {
                TVITEM  Item;

                Item.mask = TVIF_STATE;
                Item.hItem = hItem;

                TreeView_GetItem(hTree,&Item);

                if ( 0 != (Item.state & 0x2000) )
                    ++uSelected;

                ++uTotal;

                hItem = TreeView_GetNextSibling(hTree,hItem);
            }

            szText.sprintf(TEXT("Selected %d of %d"),uSelected,uTotal);

            SetWindowText(GetDlgItem(hDlg,IDC_STATUS),(LPCTSTR)szText);

            DWORD   dwFlags = PSWIZB_BACK | PSWIZB_NEXT;

            if ( 0 == uSelected )
                dwFlags &= ~PSWIZB_NEXT;

            SendMessage(GetParent(hDlg),PSM_SETWIZBUTTONS,0, dwFlags);
        }
        break;

    case    WM_DESTROY:
        {
            HTREEITEM   hItem;
            HWND        hTree = GetDlgItem(hDlg,IDC_SHIMLIST);

            hItem = TreeView_GetRoot(hTree);

            while ( NULL != hItem ) {
                TVITEM  Item;

                Item.mask = TVIF_STATE | TVIF_PARAM;
                Item.hItem = hItem;

                TreeView_GetItem(hTree,&Item);

                PSHIMENTRY pEntry = (PSHIMENTRY) Item.lParam;

                PDBENTRY pWalk = g_pCurrentWizard->m_Record.pEntries;

                while ( NULL != pWalk ) {
                    if ( pWalk == (PDBENTRY)pEntry )
                        break;

                    pWalk = pWalk->pNext;
                }

                if ( NULL == pWalk )
                    delete pEntry;

                hItem = TreeView_GetNextSibling(hTree,hItem);
            }
        }
        break;

    case    WM_NOTIFY:
        {
            NMHDR * pHdr = (NMHDR *) lParam;

            switch ( pHdr->code ) {
            case NM_RETURN:{
                SelectShims_TreeDoubleClicked(hDlg);
                return TRUE;

            }

            case PSN_SETACTIVE:

                
                SetTimer(hDlg,0,100,NULL);
                break;


            case NM_DBLCLK:
                {
                   SelectShims_TreeDoubleClicked(hDlg);
                }//case NM_DBLCLK:


                break;
            case    NM_CLICK:
                {
                    TVHITTESTINFO   ht;
                    HWND            hTree = GetDlgItem(hDlg,IDC_SHIMLIST);

                    GetCursorPos(&ht.pt);
                    ScreenToClient(hTree, &ht.pt);

                    TreeView_HitTest(hTree,&ht);

                    if ( 0 != ht.hItem )
                        TreeView_SelectItem(hTree,ht.hItem);

                    SetTimer(hDlg,0,100,NULL);
                }
                break;


            case    PSN_WIZBACK:

                SetWindowLongPtr(hDlg,DWLP_MSGRESULT,IDD_ADDWIZARD6);

                return IDD_ADDWIZARD6;

            case    PSN_WIZNEXT:
                {
                    // Build the shim list.

                    HTREEITEM   hItem;
                    HWND        hTree = GetDlgItem(hDlg,IDC_SHIMLIST);

                    // Wipe shims and layers, but not matching info.

                    g_pCurrentWizard->WipeRecord(FALSE,TRUE,TRUE);

                    hItem = TreeView_GetRoot(hTree);

                    while ( NULL != hItem ) {
                        TVITEM  Item;

                        Item.mask = TVIF_STATE | TVIF_PARAM;
                        Item.hItem = hItem;

                        TreeView_GetItem(hTree,&Item);

                        PSHIMENTRY pEntry = (PSHIMENTRY) Item.lParam;

                        pEntry->Entry.pNext = NULL;

                        if ( 0 != (Item.state & 0x2000) ) {
                            pEntry->Entry.pNext = g_pCurrentWizard->m_Record.pEntries;
                            g_pCurrentWizard->m_Record.pEntries = (PDBENTRY) pEntry;
                        }

                        hItem = TreeView_GetNextSibling(hTree,hItem);
                    }

                    //SetWindowLong(hDlg,DWL_MSGRESULT,IDD_ADDWIZARD4);

                    //return IDD_ADDWIZARD4;

                    SetWindowLongPtr(hDlg,DWLP_MSGRESULT,IDD_ADDWIZARD7);

                    return IDD_ADDWIZARD7;
                }
                break;

            case   TVN_KEYDOWN:{
            

                    LPNMTVKEYDOWN pTvkd = (LPNMTVKEYDOWN) lParam ;
                    HWND        hTree = GetDlgItem(hDlg,IDC_SHIMLIST);
                    if (pTvkd->wVKey == VK_SPACE ) {

                         

                         if (TreeView_GetSelection(hTree) != NULL ){

                          SetTimer(hDlg,0,100,NULL);

                         }
                    }

                    break;
            }

            case    TVN_SELCHANGED:
                {
                    LPNMTREEVIEW pTree = (LPNMTREEVIEW) lParam;
                    PSHIMENTRY pEntry = (PSHIMENTRY) pTree->itemOld.lParam;
                    TCHAR       szCmdLine[MAX_PATH_BUFFSIZE];

                    /* K BUG why is this required !
                    if ( NULL != pEntry ) {
                        GetWindowText(GetDlgItem(hDlg,IDC_CMDLINE),szCmdLine,MAX_PATH);

                        pEntry->szCmdLine = szCmdLine;
                    }
                    */
                    pEntry = (PSHIMENTRY) pTree->itemNew.lParam;

                    PSHIMDESC pDesc = (PSHIMDESC) pEntry->pDesc;

                    SetWindowText(GetDlgItem(hDlg,IDC_SHIMDESC),(LPCTSTR) pDesc->szShimDesc);
                    SetWindowText(GetDlgItem(hDlg,IDC_CMDLINE),(LPCTSTR) pEntry->szCmdLine);
                }
                break;
            }
        }
        break;
    }

    return FALSE;
}

BOOL CALLBACK SelectFiles(HWND hDlg, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    switch ( uMsg ) {
    case    WM_INITDIALOG:
        {
            PostMessage(hDlg,WM_USER+1024,0,0);

            
        }
        break;

    case    WM_USER+1024:
        {
            PDBENTRY    pWalk;

            TreeView_DeleteAllItems(GetDlgItem(hDlg,IDC_FILELIST));

            pWalk = g_pCurrentWizard->m_Record.pEntries;

            TVINSERTSTRUCT  Item;

            ZeroMemory(&Item,sizeof(TVINSERTSTRUCT));

            Item.hParent = TVI_ROOT;
            Item.hInsertAfter = TVI_LAST;
            Item.item.mask = TVIF_TEXT | TVIF_PARAM;
            Item.item.lParam = (LPARAM) NULL;
            Item.item.pszText = g_pCurrentWizard->m_Record.szEXEName;
            Item.item.cchTextMax = lstrlen(Item.item.pszText);

            TreeView_InsertItem(GetDlgItem(hDlg,IDC_FILELIST),&Item);

            while ( NULL != pWalk ) {
                if ( ENTRY_MATCH == pWalk->uType ) {
                    TVINSERTSTRUCT  Item;
                    PMATCHENTRY     pMatch = (PMATCHENTRY) pWalk;

                    if ( pMatch->szMatchName != TEXT("*") ) {
                        ZeroMemory(&Item,sizeof(TVINSERTSTRUCT));

                        Item.hParent = TVI_ROOT;
                        Item.hInsertAfter = TVI_LAST;
                        Item.item.mask = TVIF_TEXT | TVIF_PARAM;
                        Item.item.lParam = (LPARAM) pMatch;
                        Item.item.pszText = pMatch->szMatchName;
                        Item.item.cchTextMax = lstrlen(Item.item.pszText);

                        TreeView_InsertItem(GetDlgItem(hDlg,IDC_FILELIST),&Item);
                    }
                }

                pWalk = pWalk->pNext;
            }
        }
        break;

    case    WM_NOTIFY:
        {
            NMHDR * pHdr = (NMHDR *) lParam;

            switch ( pHdr->code ) {
            case    PSN_SETACTIVE:
                {
                    SendMessage(GetParent(hDlg),PSM_SETWIZBUTTONS, 0, PSWIZB_BACK | PSWIZB_NEXT);

                    // Force refresh of files in list.

                    PostMessage(hDlg,WM_USER+1024,0,0);
                }
                break;

            case    PSN_WIZBACK:
                {
                    PMATCHENTRY pWalk = (PMATCHENTRY) g_pCurrentWizard->m_Record.pEntries;
                    PMATCHENTRY pPrev;
                    CSTRING     szFile = g_pCurrentWizard->m_szLongName;

                    szFile.ShortFilename();

                    // Remove the matching info for the current file if it exists. Otherwise,
                    // it's possible that if the file is changed, we'll have bogus information
                    // about it.

                    while ( NULL != pWalk ) {
                        if ( ENTRY_MATCH == pWalk->Entry.uType )
                            if ( pWalk->szMatchName == szFile || pWalk->szMatchName == TEXT("*") ) {
                                // Remove this entry.

                                if ( pWalk == (PMATCHENTRY) g_pCurrentWizard->m_Record.pEntries )
                                    g_pCurrentWizard->m_Record.pEntries = g_pCurrentWizard->m_Record.pEntries->pNext;
                                else
                                    pPrev->Entry.pNext = pWalk->Entry.pNext;

                                delete pWalk;

                                break;
                            }

                        pPrev = pWalk;
                        pWalk = (PMATCHENTRY) pWalk->Entry.pNext;
                    }

                    if ( TYPE_LAYER == g_pCurrentWizard->m_uType ) {
                        SetWindowLongPtr(hDlg,DWLP_MSGRESULT,IDD_ADDWIZARD2);

                        return IDD_ADDWIZARD2;
                    } else if ( TYPE_SHIM == g_pCurrentWizard->m_uType ) {
                        SetWindowLongPtr(hDlg,DWLP_MSGRESULT,IDD_ADDWIZARD5);

                        return IDD_ADDWIZARD5;
                    }
                     else if (TYPE_APPHELP == g_pCurrentWizard->m_uType ) {
                            return IDD_APPHELP1;
                     }
                }
                break;

            case    PSN_WIZNEXT:
                {
                    PMATCHENTRY     pMatch = NULL;

                    // Add self. Self should always be included here.

                    g_pCurrentWizard->AddMatchFile(&pMatch,g_pCurrentWizard->m_szLongName);

                    g_pCurrentWizard->GetFileAttributes(pMatch);

                    if ( !g_pCurrentWizard->InsertMatchingInfo(pMatch) )
                        delete pMatch;

                    //pMatch->Entry.pNext = g_pCurrentWizard->m_Record.pEntries;
                    //g_pCurrentWizard->m_Record.pEntries = (PDBENTRY) pMatch;

                    if  (TYPE_APPHELP == g_pCurrentWizard->m_uType)
                    return TRUE;

                    SetWindowLongPtr(hDlg,DWLP_MSGRESULT,IDD_ADDWIZARDDONE);
                }
                return IDD_ADDWIZARDDONE;
            }
        }
        break;

    case    WM_COMMAND:
        switch ( LOWORD(wParam) ) {
        case    IDC_GENERATE:
            {
                HCURSOR hRestore;
                CSTRING szFile = g_pCurrentWizard->m_szLongName;
                LPTSTR  szWalk = (LPTSTR) szFile + szFile.Length() - 1;

                while ( TEXT('\\') != *szWalk )
                    --szWalk;

                ++szWalk;
                *szWalk = 0;

                SetCurrentDirectory(szFile);

                g_pCurrentWizard->m_bManualMatch = FALSE;

                hRestore = SetCursor(LoadCursor(NULL,IDC_WAIT));
                g_pCurrentWizard->GrabMatchingInfo();
                SetCursor(hRestore);

                PostMessage(hDlg,WM_USER+1024,0,0);
            }
            break;

        case    IDC_ADDFILES:
            {
                CSTRING szFilename;

                HWND hwndFocus = GetFocus();

                if ( g_theApp.GetFilename(TEXT("Find Matching File"),TEXT("EXE File (*.EXE)\0*.EXE\0All Files(*.*)\0*.*\0\0"),TEXT(""),TEXT(""),OFN_PATHMUSTEXIST | OFN_FILEMUSTEXIST,TRUE,szFilename) ) {
                    CSTRING szCheck = szFilename;

                    szCheck.ShortFilename();

                    PDBENTRY    pWalk;

                    pWalk = g_pCurrentWizard->m_Record.pEntries;

                    while ( NULL != pWalk ) {
                        if ( ENTRY_MATCH == pWalk->uType ) {
                            PMATCHENTRY pTest = (PMATCHENTRY) pWalk;
                            CSTRING     szShort = pTest->szMatchName;

                            szShort.ShortFilename();

                            if ( szShort == szCheck ) {
                                MessageBox(hDlg,TEXT("This file is already being used for matching information. To update, please remove and re-add it."),TEXT("File matching error"),MB_OK);
                                return FALSE;
                            }
                        }

                        pWalk = pWalk->pNext;
                    }

                    //WIN32_FIND_DATA Data;
                    //HANDLE          hFile;

                    //hFile = FindFirstFile(szFilename,&Data);

                    //if (INVALID_HANDLE_VALUE != hFile)
                    {
                        PMATCHENTRY     pMatch = NULL;

                        g_pCurrentWizard->AddMatchFile(&pMatch,szFilename);

                        g_pCurrentWizard->GetFileAttributes(pMatch);

                        if ( !g_pCurrentWizard->InsertMatchingInfo(pMatch) )
                            delete pMatch;

                        //pMatch->Entry.pNext = g_pCurrentWizard->m_Record.pEntries;
                        //g_pCurrentWizard->m_Record.pEntries = (PDBENTRY) pMatch;

                        //FindClose(hFile);

                        PostMessage(hDlg,WM_USER+1024,0,0);
                    }
                }

                SetFocus( hwndFocus );
            }
            break;

        case    IDC_REMOVEALL:
            {
                PDBENTRY    pWalk;
                PDBENTRY    pHold;

                pWalk = g_pCurrentWizard->m_Record.pEntries;

                while ( NULL != pWalk ) {
                    if ( ENTRY_MATCH == pWalk->uType ) {
                        if ( g_pCurrentWizard->m_Record.pEntries == pWalk ) {
                            g_pCurrentWizard->m_Record.pEntries = pWalk->pNext;
                            pHold = g_pCurrentWizard->m_Record.pEntries;
                        } else
                            pHold->pNext = pWalk->pNext;

                        delete pWalk;

                        pWalk = pHold;
                    } else {
                        pHold = pWalk;
                        pWalk = pWalk->pNext;
                    }
                }

                PostMessage(hDlg,WM_USER+1024,0,0);
            }
            break;

        case    IDC_REMOVEFILES:
            {
                HTREEITEM   hItem = TreeView_GetSelection(GetDlgItem(hDlg,IDC_FILELIST));

                if ( NULL != hItem ) {
                    TVITEM  Item;

                    Item.mask = TVIF_PARAM;
                    Item.hItem = hItem;

                    TreeView_GetItem(GetDlgItem(hDlg,IDC_FILELIST),&Item);

                    PDBENTRY    pWalk;
                    PDBENTRY    pHold;

                    if ( NULL == Item.lParam ) {
                        MessageBeep(MB_OK);
                        MessageBox(NULL,TEXT("This file is required for file matching"),TEXT("Matching error"),MB_OK);
                        break;
                    }

                    pWalk = g_pCurrentWizard->m_Record.pEntries;

                    while ( NULL != pWalk ) {
                        if ( pWalk == (PDBENTRY) Item.lParam )
                            break;

                        pHold = pWalk;
                        pWalk = pWalk->pNext;
                    }

                    if ( pWalk == g_pCurrentWizard->m_Record.pEntries )
                        g_pCurrentWizard->m_Record.pEntries = pWalk->pNext;
                    else
                        pHold->pNext = pWalk->pNext;

                    delete pWalk;

                    PostMessage(hDlg,WM_USER+1024,0,0);
                }
            }
            break;
        }
        break;
    }

    return FALSE;
}

void CShimWizard::WipeRecord(BOOL bMatching, BOOL bShims, BOOL bLayer, BOOL bAppHelp)
{
    //BUGBUG :  Deletion not done correctly.

    //
    // Matching files are deleted, shims are not ??
    //


    PDBENTRY pWalk = m_Record.pEntries;
    PDBENTRY pPrev = pWalk;//prefast

    while ( NULL != pWalk ) {
        PDBENTRY pHold = pWalk->pNext;
        BOOL     bRemove = FALSE;

        if ( ENTRY_SHIM == pWalk->uType && bShims )
            bRemove = TRUE;
        else
            if ( ENTRY_MATCH == pWalk->uType && bMatching ) {
            bRemove = TRUE;

            delete pWalk;
        }

#ifdef _DEBUG

        if ( bRemove ) {
            if ( m_Record.pEntries != pWalk )
                if ( pPrev == pHold )
                    __asm int 3;
        }

#endif

        if ( bRemove ) {
            if ( m_Record.pEntries == pWalk )
                m_Record.pEntries = pHold;
            else
                pPrev->pNext = pHold;
        } else
            pPrev = pWalk;

        pWalk = pHold;
    }

    if ( bLayer )
        m_Record.szLayerName = TEXT("");
}

typedef struct tagATTRINFO2 {

    TAG      tAttrID;        // tag for this attribute (includes type)
    DWORD    dwFlags;        // flags : such as "not avail" or "not there yet"

    union {     // anonymous union with values
        ULONGLONG   ullAttr; // QWORD  value (TAG_TYPE_QWORD)
        DWORD       dwAttr;  // DWORD  value (TAG_TYPE_DWORD)
        TCHAR*      lpAttr;  // WCHAR* value (TAG_TYPE_STRINGREF)
    };

} ATTRINFO2, *PATTRINFO2;

void CShimWizard::GetFileAttributes(PMATCHENTRY pNew)
{
    PATTRINFO2  pAttribs;
    DWORD       dwAttribCount;
    CSTRING     szFile = pNew->szFullName;
    BOOL        bIs16Bit = FALSE; 
/*
    DWORD       dwType;

    GetBinaryType(szFile,&dwType);

    if (SCS_WOW_BINARY == dwType)
        bIs16Bit = TRUE;
*/
    if ( szFile.Length() == 0 ) {
        MEM_ERR;
        return;
    }

    if ( SdbGetFileAttributes((LPCTSTR)szFile,(PATTRINFO *)&pAttribs,&dwAttribCount) ) {
        UINT uCount;

        for ( uCount=0; uCount<dwAttribCount; ++uCount ) {
            if ( 0 != (pAttribs[uCount].dwFlags & ATTRIBUTE_AVAILABLE) ) {
                switch ( pAttribs[uCount].tAttrID ) {
                case    TAG_COMPANY_NAME:
                    pNew->szCompanyName = (LPCTSTR)pAttribs[uCount].lpAttr;
                    break;

                case    TAG_PRODUCT_VERSION:
                    pNew->szProductVersion = (LPCTSTR)pAttribs[uCount].lpAttr;
                    break;

                case    TAG_FILE_DESCRIPTION:
                    pNew->szDescription = (LPCTSTR)pAttribs[uCount].lpAttr;
                    break;

                case    TAG_FILE_VERSION:
                    pNew->szFileVersion = (LPCTSTR)pAttribs[uCount].lpAttr;
                    break;

                case    TAG_CHECKSUM:
                    pNew->dwChecksum = pAttribs[uCount].dwAttr;
                    break;

                case    TAG_BIN_FILE_VERSION:
                    {
                        if ( !bIs16Bit )
                            pNew->FileVersion.QuadPart = pAttribs[uCount].ullAttr;
                    }
                    break;

                case    TAG_BIN_PRODUCT_VERSION:
                    {
                        if ( !bIs16Bit )
                            pNew->ProductVersion.QuadPart = pAttribs[uCount].ullAttr;
                    }
                    break;
                }
            }
        }

        SdbFreeFileAttributes((PATTRINFO)pAttribs);
    }
}

void CShimWizard::AddMatchFile(PPMATCHENTRY ppHead, CSTRING & szFilename)
{
    PMATCHENTRY pNew;
    PMATCHENTRY pWalk;
    PMATCHENTRY pHold;
    BOOL        bInsertHead=FALSE;
    CSTRING     szFile; // = RelativePath();
    //TCHAR       szCurrentPath[MAX_PATH_BUFFSIZE];

    pNew = new MATCHENTRY;

    if ( NULL == pNew )
        return;

    ZeroMemory(pNew,sizeof(MATCHENTRY));

    //GetCurrentDirectory(MAX_PATH,szCurrentPath);

    //if (lstrlen(szCurrentPath) == 3)
    //szCurrentPath[2] = 0;

    //szFile.sprintf("%s\\%s",szCurrentPath,pData->cFileName);
    //szFile = szCurrentPath;

    ///szFile.strcat(pData->cFileName);

    //pNew->szFullName.sprintf("%s\\%s",szCurrentPath,pData->cFileName);

    pNew->szFullName = szFilename;

    //szFile.strcat(pData->cFileName);

    szFile = pNew->szFullName;
    szFile.RelativeFile(m_szLongName);

    pNew->Entry.uType = ENTRY_MATCH;
    pNew->szMatchName = szFile;

    HANDLE hFile = CreateFile((LPCTSTR) szFilename,GENERIC_READ,0,NULL,OPEN_EXISTING,FILE_ATTRIBUTE_NORMAL,NULL);

    if ( INVALID_HANDLE_VALUE != hFile ) {
        //pNew->dwSize = pData->nFileSizeLow;

        pNew->dwSize = GetFileSize(hFile,NULL);

        CloseHandle(hFile);
    }

    pWalk = *ppHead;

    // Walk the list to determine where to insert it.

    while ( NULL != pWalk ) {
        if ( pWalk->dwSize < pNew->dwSize )
            break;

        pHold = pWalk;
        pWalk = (PMATCHENTRY) pWalk->Entry.pNext;
    }

    // Insert it into the head if the head is NULL, OR if this file is
    // the same as the file being fixed.

    CSTRING szShort = szFilename;

    if ( szShort.Length() == 0 ) {
        MEM_ERR;
        return;
    }

    szShort.ShortFilename();

    if ( NULL == *ppHead || 0 == lstrcmpi(szShort,m_Record.szEXEName) ) {//0 == lstrcmpi(pData->cFileName,m_Record.szEXEName))
        bInsertHead = TRUE;

        //if (0 == lstrcmpi(pData->cFileName,m_Record.szEXEName))
        if ( 0 == lstrcmpi(szShort,m_Record.szEXEName) )
            pNew->szMatchName = TEXT("*");
    } else
        if ( *ppHead == pWalk )
        bInsertHead = TRUE;

    if ( NULL != pWalk && pWalk->szMatchName == pNew->szMatchName ) {
        // Duplicate here. Refuse.

        delete pNew;

        return;
    }

    if ( bInsertHead ) {
        if ( NULL != *ppHead && 0 == lstrcmpi(pNew->szMatchName,TEXT("*")) ) {
            // If the file to fix has aleady been added at the head, special
            // case this insert.

            pNew->Entry.pNext = (*ppHead)->Entry.pNext;
            (*ppHead)->Entry.pNext = (PDBENTRY) pNew;
        } else {
            // Standard head insert.

            pNew->Entry.pNext = (PDBENTRY) *ppHead;
            *ppHead = pNew;
        }
    } else {
        pNew->Entry.pNext = (PDBENTRY) pWalk;
        pHold->Entry.pNext =(PDBENTRY) pNew;
    }
}

void CShimWizard::WalkDirectory(PMATCHENTRY * ppHead, LPCTSTR szDirectory, int nDepth)
{
    HANDLE          hFile;
    WIN32_FIND_DATA Data;
    TCHAR           szCurrentDir[MAX_PATH_BUFFSIZE] = TEXT("");
    int             nFiles=0;

    if ( 2 <= nDepth )
        return;

    CSTRING szShortName = m_szLongName;
    szShortName.ShortFilename();

    // Save the current directory

    GetCurrentDirectory(MAX_PATH,szCurrentDir);

    // Set to the new directory

    SetCurrentDirectory(szDirectory);

    // Generate automated matching file information.

    hFile = FindFirstFile(TEXT("*.*"),&Data);

    if ( INVALID_HANDLE_VALUE == hFile ) {
        SetCurrentDirectory(szCurrentDir);
        return;
    }

    do {
        if ( 0 == (Data.dwFileAttributes & (FILE_ATTRIBUTE_HIDDEN | FILE_ATTRIBUTE_SYSTEM)) )
            if ( FILE_ATTRIBUTE_DIRECTORY == (Data.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) ) {
                if ( TEXT('.') != Data.cFileName[0] )
                    WalkDirectory(ppHead,Data.cFileName,nDepth+1);
            } else {
                ++nFiles;

                if ( nFiles >= 100 )
                    break;

                if ( 0 != lstrcmpi(szShortName,Data.cFileName) )
                    if ( 0 == (Data.dwFileAttributes & (FILE_ATTRIBUTE_HIDDEN | FILE_ATTRIBUTE_SYSTEM)) ) {
                        CSTRING szFilename;

                        if ( lstrlen(szCurrentDir) > 3 )
                            szFilename.sprintf(TEXT("%s\\%s\\%s"),szCurrentDir,szDirectory,Data.cFileName);
                        else
                            szFilename.sprintf(TEXT("%s%s\\%s"),szCurrentDir,szDirectory,Data.cFileName);

                        AddMatchFile(ppHead,szFilename);
                    }
            }
    }
    while ( FindNextFile(hFile,&Data) );

    FindClose(hFile);

    // Restore old directory

    SetCurrentDirectory(szCurrentDir);
}

CSTRING CShimWizard::ShortFile(CSTRING & szStr)
{
    LPTSTR  szTemp = szStr;
    CSTRING szRet;
    LPTSTR  szWalk = szTemp;

    while ( 0 != *szWalk ) {
        if ( TEXT('\\') == *szWalk )
            szTemp = szWalk+1;

        ++szWalk;
    }

    szRet = szTemp;

    return szRet;
}

void CShimWizard::GrabMatchingInfo(void)
{
    PMATCHENTRY     pHead = NULL;

    // Delete any matching info which might have already been bound to the record.

    PDBENTRY pEntry = m_Record.pEntries;
    PDBENTRY pPrev = m_Record.pEntries;

    while ( NULL != pEntry ) {
        PDBENTRY pHold = pEntry->pNext;

        if ( ENTRY_MATCH == pEntry->uType ) {
            delete pEntry;

            if ( pEntry == m_Record.pEntries ) {
                m_Record.pEntries = pHold;
                pPrev = m_Record.pEntries;
            } else
                pPrev->pNext = pHold;
        } else
            pPrev = pEntry;

        pEntry = pHold;
    }

    // Generate automated matching file information.

    WalkDirectory(&pHead,TEXT("."),0);

    // Now, take the first X entries and discard the rest.

    int         nCount = MAX_AUTO_MATCH;
    PMATCHENTRY pWalk = pHead;
    PMATCHENTRY pTerm = NULL;

    while ( NULL != pWalk ) {
        if ( 0 >= nCount ) {
            PMATCHENTRY pHold = (PMATCHENTRY) pWalk->Entry.pNext;

            delete pWalk;

            pWalk = pHold;
        } else {
            --nCount;

            if ( 1 == nCount )
                pTerm = (PMATCHENTRY) pWalk->Entry.pNext;

            pWalk = (PMATCHENTRY) pWalk->Entry.pNext;
        }
    }

    if ( NULL != pTerm )
        pTerm->Entry.pNext = NULL;

    pWalk = pHead;

    while ( NULL != pWalk ) {
        GetFileAttributes(pWalk);
        pWalk = (PMATCHENTRY)pWalk->Entry.pNext;
    }

    // Bind this data to the record.

    pWalk = pHead;

    // Find the end....

    while ( NULL != pWalk && NULL != pWalk->Entry.pNext ) {
        PMATCHENTRY pHold = (PMATCHENTRY) pWalk->Entry.pNext;

        GetFileAttributes(pWalk);

        if ( !InsertMatchingInfo(pWalk) )
            delete pWalk;

        pWalk = pHold;

    }
}

BOOL CShimWizard::InsertMatchingInfo(PMATCHENTRY pNew)
{
    PDBENTRY pWalk = m_Record.pEntries;
    PDBENTRY pHold;

    while ( NULL != pWalk ) {
        if ( ENTRY_MATCH == pWalk->uType ) {
            PMATCHENTRY pThis = (PMATCHENTRY) pWalk;

            if ( pThis->szMatchName == pNew->szMatchName )
                return FALSE;

            if ( 0 < lstrcmpi(pThis->szMatchName,pNew->szMatchName) )
                break;
        }

        pHold = pWalk;
        pWalk = pWalk->pNext;
    }

    if ( pWalk == m_Record.pEntries ) {
        pNew->Entry.pNext = m_Record.pEntries;
        m_Record.pEntries = (PDBENTRY) pNew;
    } else {
        pNew->Entry.pNext = pWalk;
        pHold->pNext = (PDBENTRY) pNew;
    }

    return TRUE;
}

INT_PTR CALLBACK
EditCmdLineDlgProc(
    HWND   hdlg,
    UINT   uMsg,
    WPARAM wParam,
    LPARAM lParam
    )
/*++
    EditCmdLineDlgProc

    Description:    Handles messages for the edit control.

--*/
{
    int wCode = LOWORD(wParam);
    int wNotifyCode = HIWORD(wParam);

    switch (uMsg) {
    case WM_INITDIALOG:
    {
        
        SendMessage( 
                GetDlgItem(hdlg,IDC_SHIM_CMD_LINE),              // handle to destination window 
                EM_LIMITTEXT,             // message to send
                (WPARAM) 256,          // text length
                (LPARAM) 0
                );

        SHAutoComplete(GetDlgItem(hdlg,IDC_SHIM_CMD_LINE), AUTOCOMPLETE);

        PSHIMENTRY pShimEntry;

        pShimEntry = (PSHIMENTRY)lParam;
        
        

        SetWindowLongPtr(hdlg, DWLP_USER, lParam);
        
        SetDlgItemText(hdlg, IDC_SHIM_NAME, pShimEntry->szShimName);
        
        if ( pShimEntry->szCmdLine.Length() > 0 ) {
            SetDlgItemText(hdlg, IDC_SHIM_CMD_LINE, pShimEntry->szCmdLine);
        }
        break;
    }
    case WM_COMMAND:
        switch (wCode) {

        case IDOK:
        {
            
            PSHIMENTRY  pShimEntry;
            TCHAR szCmdLine[1024] = _T("");
            
            pShimEntry = ( PSHIMENTRY)GetWindowLongPtr(hdlg, DWLP_USER);

            GetDlgItemText(hdlg, IDC_SHIM_CMD_LINE, szCmdLine, sizeof(szCmdLine)/sizeof(TCHAR));

            if (*szCmdLine != 0) {
                pShimEntry->szCmdLine =  szCmdLine;

            } else {
                pShimEntry->szCmdLine.Release(); 
                
            }
            
            EndDialog(hdlg, TRUE);
            break;
        }
        case IDCANCEL:
            EndDialog(hdlg, FALSE);
            break;

        default:
            return FALSE;
        }
        break;

    default:
        return FALSE;
    }

    return TRUE;
}


void SelectShims_TreeDoubleClicked(HWND hDlg)
{

    HWND            hTree = GetDlgItem(hDlg,IDC_SHIMLIST);
    HTREEITEM hItem;                                                                                                    
    TVITEM    tvi;                                                                                                      
                                                                                                            
    hItem = TreeView_GetSelection(hTree);                                                                               
                                                                                                    
    if (hItem == NULL) return;                                                                                          
                                                                                                                    
                                                                                                    
    tvi.hItem = hItem;                                                                                                  
    tvi.mask  = TVIF_HANDLE | TVIF_PARAM;                                                                               
    TreeView_GetItem(hTree, &tvi);                                                                                      
                                                                                                        
    PSHIMENTRY pEntry = (PSHIMENTRY) tvi.lParam;                                                                        
                                                                                                        
    ///////                                                                                                             
    if (DialogBoxParam(g_hInstance,                                                                                     
            MAKEINTRESOURCE(IDD_CMD_LINE),                                                                           
            hDlg,                                                                                                    
            EditCmdLineDlgProc,                                                                                      
            (LPARAM)pEntry)) {                                                                                       
                                                                                                    
        TCHAR szText[1024];                                                                                             
                                                                                                                
        tvi.mask    = TVIF_HANDLE | TVIF_TEXT;                                                                          
                                                                                                                    
                                                                                                    
        if ( pEntry->szCmdLine.Length() == 0 ) {                                                                        
            tvi.pszText = pEntry->szShimName;                                                                           
        } else {                                                                                                        
            wsprintf(szText, _T("%s - (%s)"), (LPCTSTR)pEntry->szShimName, (LPCTSTR)pEntry->szCmdLine);                 
            tvi.pszText = szText;                                                                                       
        }                                                                                                               
                                                                                                    
        TreeView_SetItem(hTree, &tvi);                                                                                  
    }                                                                                                                   
                ///////
}//void SelectShims_TreeDoubleClicked(HWND hDlg)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\appcompat\tools\compatadmin\xmldialog.cpp ===
#include "compatadmin.h"
#include "XMLDialog.h"

CXMLDialog  * g_pXMLDialog = NULL;

#define QUOTE   '"'

BOOL CXMLDialog::BeginXMLView(PDBRECORD pRecord, HWND hParent, BOOL bChildren, BOOL bSib, BOOL bLocalLayer, BOOL bFullXML, BOOL bGlobal)
{
    m_pRecord = pRecord;
    g_pXMLDialog = this;
    m_bChildren = bChildren;

    m_pList = g_theApp.GetDBLocal().DisassembleRecord(m_pRecord,m_bChildren,bSib,bLocalLayer,bFullXML,bGlobal, FALSE);

    DialogBox(g_hInstance,MAKEINTRESOURCE(IDD_XML),hParent,(DLGPROC)XMLDlgProc);

    delete m_pList;

    return TRUE;
}

BOOL CXMLDialog::DlgProc(UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    switch ( uMsg ) {
    case    WM_INITDIALOG:
        {
            // Convert record into XML strings to be displayed.

            if ( NULL != m_pList ) {
                PSTRLIST pWalk = m_pList->m_pHead;

                while ( NULL != pWalk ) {
                    UINT uTabs = pWalk->uExtraData;

                    while ( uTabs > 0 ) {
                        SendDlgItemMessage(m_hDlg,IDC_XML,EM_REPLACESEL,FALSE,(LPARAM)"     ");
                        --uTabs;
                    }

                    SendDlgItemMessage(m_hDlg,IDC_XML,EM_REPLACESEL,FALSE,(LPARAM)(LPCTSTR) pWalk->szStr);
                    SendDlgItemMessage(m_hDlg,IDC_XML,EM_REPLACESEL,FALSE,(LPARAM)"\r\n");
                    pWalk = pWalk->pNext;
                }
            }
        }
        break;

    case    WM_COMMAND:
        switch ( LOWORD(wParam) ) {
        case    IDC_SAVEXML:
            {
                CSTRING szFilename;

                if ( g_theApp.GetFilename(TEXT("Save XML to file"),TEXT("XML File (*.XML)\0*.XML\0\0"),TEXT(""),TEXT("XML"),OFN_PATHMUSTEXIST | OFN_OVERWRITEPROMPT,FALSE,szFilename) )
                    g_theApp.GetDBLocal().WriteXML(szFilename,m_pList);
            }
            break;

        case    IDOK:
            {
                EndDialog(m_hDlg,1);
            }
            break;

        case    IDCANCEL:
            {
                EndDialog(m_hDlg,0);
            }
            break;
        }
    }

    return FALSE;
}

BOOL CALLBACK XMLDlgProc(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    if ( NULL != g_pXMLDialog ) {
        g_pXMLDialog->m_hDlg = hWnd;
        return g_pXMLDialog->DlgProc(uMsg,wParam,lParam);
    }

    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\appcompat\tools\compatadmin\xmldialog.h ===
class CXMLDialog
{
    public:

        HWND            m_hDlg;
        PDBRECORD       m_pRecord;
        BOOL            m_bChildren;
        CSTRINGList   * m_pList;

    public:

        BOOL BeginXMLView(PDBRECORD pRecord, HWND hParent, BOOL, BOOL bSibling = FALSE, BOOL bLayers = FALSE, BOOL bFullXML = TRUE, BOOL bAllowGlobal = TRUE);
        BOOL DlgProc(UINT uMsg, WPARAM wParam, LPARAM lParam);
};

BOOL CALLBACK XMLDlgProc(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\appcompat\tools\compatadmin\wizard.h ===
#ifndef __WIZARD_H
    #define __WIZARD_H
#endif

    
#define STAGE_ENTRY         0
#define STAGE_LAYER1        1
#define STAGE_FILEMATCH     2
#define STAGE_SHIM1         3
#define STAGE_SHIM2         4
#define STAGE_SHIM3         5
#define STAGE_APPNAME       6
#define STAGE_DONE          7
#define STAGE_FINISH        8
#define STAGE_CANCEL        -1

#define MAX_AUTO_MATCH      7

enum {
    TYPE_LAYER=0,
    TYPE_SHIM,
    TYPE_APPHELP,
    TYPE_FORCEDWORD=0xFFFFFFFF
};


class CShimWizard {
public:

    HWND        m_hDlg;
    UINT        m_uType;
    DBRECORD    m_Record;
    CSTRING     m_szLongName;
    BOOL        m_bManualMatch;

public:

    void STDCALL    WipeRecord(BOOL bMatching, BOOL bShims, BOOL bLayers, BOOL bAppHelp = FALSE);
    void STDCALL    GrabMatchingInfo(void);
    void STDCALL    GetFileAttributes(PMATCHENTRY pNew);
    void STDCALL    AddMatchFile(PPMATCHENTRY, CSTRING & szFile);
    void STDCALL    WalkDirectory(PMATCHENTRY * ppHead, LPCTSTR szDirectory, int nDepth);

    CSTRING STDCALL ShortFile(CSTRING &);
    BOOL STDCALL    InsertMatchingInfo(PMATCHENTRY pNew);
    //CSTRING STDCALL RelativePath(void);

    BOOL STDCALL    BeginWizard(HWND hParent);
};

BOOL CALLBACK EntryPoint(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam);
BOOL CALLBACK GetAppName(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam);
BOOL CALLBACK SelectLayer(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam);
BOOL CALLBACK SelectMatching(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam);
BOOL CALLBACK SelectShims(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam);
BOOL CALLBACK SelectFiles(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam);
BOOL CALLBACK WizardDone(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam);
INT_PTR CALLBACK EditCmdLineDlgProc(HWND   hdlg,UINT   uMsg,WPARAM wParam,LPARAM lParam);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\appcompat\tools\dumpsdb\dumpsdb.cpp ===
/*--

Copyright (c) 1999  Microsoft Corporation

Module Name:

    dumpsdb.c

Abstract:

    code for a dump tool for shim db files

Author:

    dmunsil 02/02/2000

Revision History:

Notes:

    This program dumps a text representation of all of the data in a shim db file.

--*/

#define _UNICODE

#define WIN
#define FLAT_32
#define TRUE_IF_WIN32   1
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#define _WINDOWS
#include <windows.h>
#include <stdio.h>

extern "C" {
#include "shimdb.h"
}


BOOL bDumpDB(PDB pdb, TAGID tiParent, WCHAR *szIndent, BOOL bWithTagIDs);
BOOL bGetTypeName(TAG tWhich, WCHAR *szName);



extern "C" int __cdecl wmain(int argc, wchar_t *argv[])
{
    PDB    pdb;
    int    nReturn = 0;
    LPWSTR szDB = NULL;

    BOOL bSuccess;
    BOOL bWithTagIDs = TRUE;

    WCHAR szIndent[500];
    WCHAR szArg[500];
    WCHAR szDbID[128];

    PSDBDATABASEINFO psdbInfo = NULL;

    if (argc < 2 || (argv[1][1] == '?')) {
        wprintf(L"    Usage: dumpsdb foo.sdb > foo.txt\n");
        return 1;
    }

    if ((argv[1][0] == '/' || argv[1][0] == '-') &&
        (argv[1][1] == 'd' || argv[1][1] == 'D')) {
        bWithTagIDs = FALSE;
        szDB = argv[2];
    } else {
        szDB = argv[1];
    }

    // Open the DB.
    pdb = SdbOpenDatabase(szDB, DOS_PATH);

    if (pdb == NULL) {
        nReturn = 1;
        wprintf(L"Error: can't open DB \"%s\"\n", szDB);
        return 0;
    }

    SdbGetDatabaseInformationByName(szDB, &psdbInfo);

    SdbGUIDToString(&psdbInfo->guidDB, szDbID);
    
    wprintf(L"Dumping DB \"%s %s. Version %d.%d.\"\n",
            szDB,
            szDbID,
            psdbInfo->dwVersionMajor,
            psdbInfo->dwVersionMinor);

    wcscpy(szIndent, L"");

    SdbFreeDatabaseInformation(psdbInfo);

    bSuccess = bDumpDB(pdb, TAGID_ROOT, szIndent, bWithTagIDs);


    wprintf(L"Closing DB.\n");
    SdbCloseDatabase(pdb);

    return nReturn;
}

BOOL bGetTypeName(TAG tWhich, WCHAR *szName)
{
    DWORD i;

    LPCWSTR pName = SdbTagToString(tWhich);
    if (NULL != pName) {
        wcscpy(szName, pName);
        return TRUE;
    }

    swprintf(szName, L"!unknown_tag!");

    return TRUE;
}

BOOL bDumpDB(PDB pdb, TAGID tiParent, WCHAR *szIndent, BOOL bWithTagIDs)
{
    TAGID tiTemp;
    WCHAR szTemp[200];
    WCHAR szNewIndent[200];


    tiTemp = SdbGetFirstChild(pdb, tiParent);
    while (tiTemp) {
        TAG tWhich;
        TAG_TYPE ttType;
        DWORD dwData;
        LARGE_INTEGER liData;
        WCHAR szData[1000];

        tWhich = SdbGetTagFromTagID(pdb, tiTemp);
        ttType = GETTAGTYPE(tWhich);

        if (!bGetTypeName(tWhich, szTemp)) {
            wprintf(L"Error getting Tag name. Tag: 0x%4.4X\n", (DWORD)tWhich);
            return FALSE;
        }

        if (bWithTagIDs) {
            wprintf(L"%s0x%8.8X | 0x%4.4X | %-13s ", szIndent, tiTemp, tWhich, szTemp);
        } else {
            wprintf(L"%s%-13s ", szIndent, szTemp);

            if (wcsstr(szTemp, L"_TAGID")) {
                tiTemp = SdbGetNextChild(pdb, tiParent, tiTemp);
                continue;
            }
        }

        switch (ttType) {
        case TAG_TYPE_NULL:
            wprintf(L" | NULL |\n");
            break;

        case TAG_TYPE_BYTE:
            dwData = SdbReadBYTETag(pdb, tiTemp, 0);
            wprintf(L" | BYTE | 0x%2.2X\n", dwData);
            break;

        case TAG_TYPE_WORD:
            dwData = SdbReadWORDTag(pdb, tiTemp, 0);
            if (tWhich == TAG_INDEX_KEY || tWhich == TAG_INDEX_TAG) {

                // for index tags and keys, we'd like to see what the names are
                if (!bGetTypeName((TAG)dwData, szTemp)) {
                    wprintf(L"Error getting Tag name. Tag: 0x%4.4X\n", dwData);
                    return FALSE;
                }
                wprintf(L" | WORD | 0x%4.4X (%s)\n", dwData, szTemp);
            } else {
                wprintf(L" | WORD | 0x%4.4X\n", dwData);
            }
            break;

        case TAG_TYPE_DWORD:
            dwData = SdbReadDWORDTag(pdb, tiTemp, 0);
            wprintf(L" | DWORD | 0x%8.8X\n", dwData);
            break;

        case TAG_TYPE_QWORD:
            liData.QuadPart = SdbReadQWORDTag(pdb, tiTemp, 0);
            wprintf(L" | QWORD | 0x%8.8X%8.8X\n", liData.HighPart, liData.LowPart);
            break;

        case TAG_TYPE_STRINGREF:
            if (!SdbReadStringTag(pdb, tiTemp, szData, 1000 * sizeof(WCHAR))) {
                wcscpy(szData, L"(error)");
            }
            wprintf(L" | STRINGREF | %s\n", szData);
            break;

        case TAG_TYPE_STRING:
            dwData = SdbGetTagDataSize(pdb, tiTemp);
            if (!SdbReadStringTag(pdb, tiTemp, szData, 1000)) {
                wcscpy(szData, L"(error)");
            }
            wprintf(L" | STRING | Size 0x%8.8X | %s\n", dwData, szData);
            break;

        case TAG_TYPE_BINARY:
            dwData = SdbGetTagDataSize(pdb, tiTemp);
            wprintf(L" | BINARY | Size 0x%8.8X", dwData);
            switch(tWhich) {
            case TAG_INDEX_BITS:
               {
                  char szKey[9];
                  DWORD dwRecords;
                  INDEX_RECORD *pRecords;
                  DWORD i;

                  wprintf(L"\n");
                  ZeroMemory(szKey, 9);
                  dwRecords = dwData / sizeof(INDEX_RECORD);
                  pRecords = (INDEX_RECORD *)SdbGetBinaryTagData(pdb, tiTemp);
                  for (i = 0; i < dwRecords; ++i) {
                     char *szRevKey;
                     int j;

                     szRevKey = (char *)&pRecords[i].ullKey;
                     for (j = 0; j < 8; ++j) {
                         szKey[j] = isprint(szRevKey[7-j]) ? szRevKey[7-j] : '.';
                     }
                     if (bWithTagIDs) {
                         wprintf(L"%s   Key: 0x%I64X (\"%-8S\"), TAGID: 0x%08X\n",
                             szIndent, pRecords[i].ullKey, szKey, pRecords[i].tiRef);
                     } else {
                         wprintf(L"%s   Key: 0x%I64X (\"%-8S\")\n",
                             szIndent, pRecords[i].ullKey, szKey);
                     }
                  }
               }
               break;
            case TAG_EXE_ID:
            case TAG_MSI_PACKAGE_ID:
            case TAG_DATABASE_ID:
               // this is exe id -- which happens to be GUID which we do understand
               {
                  GUID *pGuid;
                  UNICODE_STRING sGuid;

                  pGuid = (GUID*)SdbGetBinaryTagData(pdb, tiTemp);

                  // convert this thing to string
                  if (pGuid && NT_SUCCESS(RtlStringFromGUID(*pGuid, &sGuid))) {
                     wprintf(L" | %s", sGuid.Buffer);
                     RtlFreeUnicodeString(&sGuid);
                  }

                  wprintf(L"\n");
               }
               break;

            default:
               wprintf(L"\n");
               break;
            }
            break;

        case TAG_TYPE_LIST:
            dwData = SdbGetTagDataSize(pdb, tiTemp);
            wprintf(L" | LIST | Size 0x%8.8X\n", dwData);
            wcscpy(szNewIndent, szIndent);
            wcscat(szNewIndent, L"  ");
            bDumpDB(pdb, tiTemp, szNewIndent, bWithTagIDs);
            wprintf(L"%s-end- %s\n", szIndent, szTemp);
            break;

        default:
            dwData = SdbGetTagDataSize(pdb, tiTemp);
            wprintf(L" | UNKNOWN | Size 0x%8.8X\n", dwData);
            break;
        }

        tiTemp = SdbGetNextChild(pdb, tiParent, tiTemp);
    }
    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\appcompat\tools\infstrip\infstrip.cpp ===
#include <windows.h>
#include <stdio.h>

int _cdecl main(int argc, char** argv)
{
	if(argc != 3)
	{
		fprintf(stderr, "Usage: infstrip <filename> <token>\n");
		return -1;
	}

	HANDLE hFile;
	hFile = CreateFile(argv[1], GENERIC_READ, FILE_SHARE_READ,
		NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL | FILE_FLAG_SEQUENTIAL_SCAN, NULL);
	if(hFile == INVALID_HANDLE_VALUE)
	{
		fprintf(stderr, "Unable to open file %s\n", argv[1]);
		return -1;
	}

	HANDLE hMap = CreateFileMapping(hFile, NULL, PAGE_READONLY,0,0,
		NULL);
	if(!hMap)
	{
		fprintf(stderr, "Unable to open file %s\n", argv[1]);
		return -1;
	}

	void* pFile;

	pFile = MapViewOfFile(hMap, FILE_MAP_READ, 0, 0, 0);
	if(!pFile)
	{
		fprintf(stderr, "Unable to open file %s\n", argv[1]);
		return -1;
	}

	char* pStart = reinterpret_cast<char*>(pFile);
	char* szSearchString = argv[2];
	DWORD dwSize = GetFileSize(hFile, NULL);
	char* pEnd = pStart + dwSize - 1;
	int iPos = strlen(szSearchString)-1;
	DWORD dwtruncationpoint = dwSize;


	for(; pEnd >= pStart; pEnd--)
	{
		if(*pEnd == szSearchString[iPos])
		{
			// Match.
			
			// Found the complete string.
			if(iPos == 0)
			{
				// Mark this as the truncation point.
				dwtruncationpoint = pEnd-pStart;
				iPos = strlen(szSearchString)-1;
				continue;
			}

			iPos--;
		}
		else
		{
			// Reset.
			iPos = strlen(szSearchString)-1;
		}
	}

	// Copy the file
	char* pNewFile = new char[dwtruncationpoint];
	memcpy(pNewFile, pStart, dwtruncationpoint);


	// Close the previous file.
	UnmapViewOfFile(pFile);
	CloseHandle(hMap);
	CloseHandle(hFile);

	// Truncate the file
	hFile = CreateFile(argv[1], GENERIC_WRITE, FILE_SHARE_READ,
		NULL, TRUNCATE_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);
	if(hFile == INVALID_HANDLE_VALUE)
	{
		fprintf(stderr, "Error truncating file");
		return -1;
	}

	DWORD dwWritten = 0;
	if(!WriteFile(hFile, pNewFile, dwtruncationpoint, &dwWritten, NULL))
	{
		fprintf(stderr, "Error writing file");
		return -1;
	}
	CloseHandle(hFile);
	return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\appcompat\tools\fileversioninfo\fileversioninfo.cpp ===
//+--------------------------------------------------------------------------
//
// Microsoft Windows
// Copyright (C) Microsoft Corporation, 2000
//
// File:        FileVersionInfo.cpp
//
// Contents:    Code for generating matching information for files in a given
//              directory and it's subdirectories.
//
// History:     18-Jul-00   jdoherty        Created.  
//
//---------------------------------------------------------------------------


#include <windows.h>
#include <stdlib.h>
#include <stdio.h>
#include <shlobj.h>

                                                
BOOL MyStoreFileVersionInfo( CHAR *szFileName, CHAR *szFileOutName );
void CheckVerQueryStats ( LPVOID lpData );

// Needed by GetFileVersionInfo stubs
typedef struct StringTable 
{ 
    WORD wLength; 
    WORD wValueLength; 
    WORD wType; 
    CHAR szKey[8]; 
} ST; 

typedef struct StringFileInfo 
{ 
    WORD wLength; 
    WORD wValueLength; 
    WORD wType; 
    CHAR szKey[sizeof("StringFileInfo")]; 
    ST st; 
} SFI; 

typedef struct tagVERHEAD 
{
    WORD wTotLen;
    WORD wValLen;
    WORD wType;         // always 0 
    CHAR szKey[(sizeof("VS_VERSION_INFO")+3)&~03];
    VS_FIXEDFILEINFO vsf;
    SFI sfi;
} VERHEAD;

int __cdecl main(int argc, CHAR* argv[])
{
    LPTSTR szCommandLine = {'\0'};

    if (argc > 3)
    {
        printf("The correct usage is:\n\tFileVerInfo.exe [filename including path]\n");
        getchar();
        return 0;
    }
    printf("Attempting to retrieve file version info for: %s\n", argv[1]);

    if(!MyStoreFileVersionInfo(argv[1], argv[2]))
    {
        printf("There was a problem retrieving the information.\n");
        getchar();
        return 0;
    }

    else
        szCommandLine = GetCommandLine();
        printf("The command line contained: %s\n", szCommandLine);
        printf("Operation completed successfully");

    getchar();

	return 0;
}

/*
    This function retrieves the version information for the file specified and stores the
    information on the users desktop, FileVerInfo.bin
*/
BOOL MyStoreFileVersionInfo ( CHAR *szFileName, CHAR *szFileOutName )
{
    LPDWORD lpdwHandle = 0;
    DWORD dwBytesToWrite = GetFileVersionInfoSizeA(szFileName, lpdwHandle);
    DWORD lpdwBytesWritten = 0;
    LPVOID lpData= malloc(dwBytesToWrite);
    CHAR lpPath[MAX_PATH] = {'\0'};
    HANDLE hfile;
    
    if( !dwBytesToWrite )
    {
        printf("There was a problem in GetFileVersionInfoSize()\n");
        printf("GLE reports error %d\n", GetLastError());
        return FALSE;
    }
    if ( !GetFileVersionInfoA(szFileName, NULL, dwBytesToWrite, lpData) )
    {
        printf("There was a problem in GetFileVersionInfo()\n");
        return FALSE;
    }

    CheckVerQueryStats(lpData);

    strcat( lpPath, ".\\" );
    if ( szFileOutName )
    {
        strcat( lpPath, szFileOutName );
        strcat( lpPath, ".bin" );
    }
    else
        strcat(lpPath, ".\\FileVerInfo.bin");

    hfile = CreateFileA(lpPath, 
                        GENERIC_WRITE, 
                        0, 
                        NULL, 
                        CREATE_ALWAYS, 
                        FILE_ATTRIBUTE_NORMAL,
                        NULL);
    
    if (hfile == INVALID_HANDLE_VALUE)
    {
        printf("There was a problem opening %s\n", lpPath);
        return FALSE;
    }

    printf("About to write to file: %s\n", lpPath);

    WriteFile( hfile, lpData, dwBytesToWrite, &lpdwBytesWritten, NULL );

    CloseHandle (hfile);

    return TRUE;
}

/*
    This function displays the minor version and the SFI version to the screen
*/
void CheckVerQueryStats ( LPVOID lpData )
{
    PUINT puLen = 0;

    printf("The minor version is: \t%x\n",((VERHEAD*) lpData)->vsf.dwFileVersionMS);
    printf("The SFI version is: \t%s\n",((VERHEAD*) lpData)->sfi.st.szKey);
    
    return;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\appcompat\tools\fcopy\fcopy.cpp ===
#include "windows.h"
#include <stdio.h>

BOOL
ForceCopy(
    LPCSTR lpszSourceFileName,
    LPCSTR lpszDestFileName
    )
/*++

  Params: lpszSourceFileName   Pointer to the source file.
          lpzDestFileName      Pointer to the destination file.

  Return: TRUE on success, FALSE otherwise.

  Desc:   Attempts to copy a file. If it's in use, move it and replace on reboot.

--*/
{
    char szTempPath[MAX_PATH];
    char szDelFileName[MAX_PATH];

    if (!CopyFileA(lpszSourceFileName, lpszDestFileName, FALSE)) {
        
        if (GetTempPathA(MAX_PATH, szTempPath) == 0) {
            printf("GetTempPath failed with 0x%x\n", GetLastError());
            return FALSE;
        }

        if (GetTempFileNameA(szTempPath, "DEL", 0, szDelFileName) == 0) {
            printf("GetTempFileName failed with 0x%x\n", GetLastError());
            return FALSE;
        }

        if (!MoveFileExA(lpszDestFileName, szDelFileName, MOVEFILE_REPLACE_EXISTING)) {
            printf("MoveFileEx failed with 0x%x\n", GetLastError());
            return FALSE;
        }

        if (!MoveFileExA(szDelFileName, NULL, MOVEFILE_DELAY_UNTIL_REBOOT)) {
            printf("MoveFileEx failed with 0x%x\n", GetLastError());
            return FALSE;
        }

        if (!CopyFileA(lpszSourceFileName, lpszDestFileName, FALSE)) {
            printf("CopyFile failed with 0x%x\n", GetLastError());
            return FALSE;
        }
    }

    return TRUE;
}

int __cdecl
main(
    int   argc,
    CHAR* argv[]
    )
{
    if (argc != 3) {
        printf("Usage: forcecopy SourceFile DestFile\n");
        return 0;
    }
    
    return ForceCopy(argv[1], argv[2]);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\appcompat\tools\qfixapp\dbsupport.h ===
#ifndef _SHIMWHISTLER_H
#define _SHIMWHISTLER_H

#include "qfixapp.h"

PFIX
ReadFixesFromSdb(
    LPTSTR  pszSdb,
    BOOL    bAllShims
    );

#define CFF_APPENDLAYER         0x00000001
#define CFF_SHOWXML             0x00000002
#define CFF_SHIMLOG             0x00000004
#define CFF_USELAYERTAB         0x00000008
#define CFF_ADDW2KSUPPORT       0x00000020

BOOL
CollectFix(
    HWND    hListLayers,
    HWND    hTreeShims,
    HWND    hTreeFiles,
    LPCTSTR pszShortName,
    LPCTSTR pszFullPath,
    DWORD   dwFlags,
    LPTSTR  pszFileCreated
    );

void
CleanupSupportForApp(
    TCHAR* pszShortName
    );

void
ShowShimLog(
    void
    );

BOOL
IsSDBFromSP2(
    void
    );

#endif // _SHIMWHISTLER_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\appcompat\tools\grabmi\grabmi.cpp ===
//+--------------------------------------------------------------------------
//
// Microsoft Windows
// Copyright (C) Microsoft Corporation, 2000
//
// File:        GrabMI.cpp
//
// Contents:    Code for generating matching information for files in a given
//              directory and it's subdirectories.
//
// History:     18-Jul-00   jdoherty        Created.  
//              16-Dec-00   jdoherty        Modified to use SDBAPI routines.
//              29-Dec-00   prashkud        Modified to take space in the filepath
//                                          
//      
//
//---------------------------------------------------------------------------

#include <windows.h>
#include <TCHAR.h>
#include <stdio.h>
#include <conio.h>

#ifdef __cplusplus
extern "C" {
#include "shimdb.h"
typedef BOOL 
(SDBAPI*PFNSdbGrabMatchingInfoA)(
                     LPCSTR szMatchingPath,
                     DWORD dwFilter,
                     LPCSTR szFile
                   );
typedef BOOL 
(SDBAPI*PFNSdbGrabMatchingInfoW)(
                     LPCWSTR szMatchingPath,
                     DWORD dwFilter,
                     LPCWSTR szFile
                   );
}
#endif

typedef GMI_RESULT
(SDBAPI  *PFNSdbGrabMatchingInfoExA)(
    LPCSTR szMatchingPath,     // path to begin gathering information
    DWORD   dwFilterAndFlags,             // specifies the types of files to be added to matching
    LPCSTR szFile,             // full path to file where information will be stored
    PFNGMIProgressCallback pfnCallback,
    LPVOID                 lpvCallbackParameter
    );

typedef GMI_RESULT
(SDBAPI  *PFNSdbGrabMatchingInfoExW)(
    LPCWSTR szMatchingPath,     // path to begin gathering information
    DWORD   dwFilterAndFlags,             // specifies the types of files to be added to matching
    LPCWSTR szFile,             // full path to file where information will be stored
    PFNGMIProgressCallback pfnCallback,
    LPVOID                 lpvCallbackParameter
    );


//
// Filters needed for SdbGrabMatchingInfo
//
/*
#define GRABMI_FILTER_NORMAL        0
#define GRABMI_FILTER_PRIVACY       1
#define GRABMI_FILTER_DRIVERS       2
#define GRABMI_FILTER_VERBOSE       3
#define GRABMI_FILTER_SYSTEM        4
#define GRABMI_FILTER_THISFILEONLY  5
*/

void ProperUsage();


BOOL CALLBACK _GrabmiCallback(
    LPVOID    lpvCallbackParam, // application-defined parameter
    LPCTSTR   lpszRoot,         // root directory path
    LPCTSTR   lpszRelative,     // relative path
    PATTRINFO pAttrInfo,        // attributes
    LPCWSTR   pwszXML           // resulting xml
    )         
{
    static int State = 0;
    static TCHAR szIcon[] = TEXT("||//--\\\\");
    State = ++State % (ARRAYSIZE(szIcon)-1);
    _tcprintf(TEXT("%c\r"), szIcon[State]);
    return TRUE;
}



int __cdecl main(int argc, TCHAR* argv[])
{
    TCHAR szRootDir[MAX_PATH] = {'\0'};             // original root directory for matching
    TCHAR szFile[MAX_PATH] = {'\0'};                // File to store information to
    TCHAR szCommandLine[MAX_PATH]={'\0'};           // command line passed to winexec
    TCHAR szMessage[MAX_PATH]={'\0'};               // error message to display
    DWORD dwFilter = GRABMI_FILTER_NORMAL;          // specifies filter for matching
    DWORD dwFilterFlags = 0;
    BOOL bDestinationSelected = FALSE;
    BOOL bDisplayFile = TRUE;
    OSVERSIONINFO VersionInfo;
    int  iRetCode = 0;
    BOOL bUseApphelp = FALSE;

    static int Cnt = 0;
 
    PFNSdbGrabMatchingInfoExA pfnGrabA = NULL;
    PFNSdbGrabMatchingInfoExW pfnGrabW = NULL;
    HMODULE hLib;

    VersionInfo.dwOSVersionInfoSize = sizeof(OSVERSIONINFO);

    if (GetVersionEx(&VersionInfo) == FALSE) {
        wsprintf (szMessage, TEXT("Unable to get version info.\n"));
        goto eh;
    }
    
    // check OS version to load the correct version
    // of sdbapi

    // set to debug 9x binaries on WinXP
    // VersionInfo.dwPlatformId = VER_PLATFORM_WIN32_WINDOWS;

    switch (VersionInfo.dwPlatformId) {
        case VER_PLATFORM_WIN32_NT:

            if (VersionInfo.dwMajorVersion >= 5) {  
                if (VersionInfo.dwMajorVersion == 5) { // Check minor version for WinXP
                    bUseApphelp = VersionInfo.dwMinorVersion >= 1;
                } else {
                    bUseApphelp = TRUE;
                }
            }
            hLib = LoadLibrary(bUseApphelp ? TEXT("apphelp.dll") : TEXT("sdbapiu.dll"));
            if (hLib == NULL) {
                wsprintf (szMessage, TEXT("Could not load sdbapiu.dll.\n"));
                goto eh;
            }
            pfnGrabW = (PFNSdbGrabMatchingInfoExW)GetProcAddress(hLib, TEXT("SdbGrabMatchingInfoEx"));
            if (pfnGrabW == NULL) {
                wsprintf (szMessage, TEXT("Unable to get proc address for SdbGrabMatchingInfo\n"));
                goto eh;
            }
            break;
        case VER_PLATFORM_WIN32_WINDOWS:
            hLib = LoadLibraryA(TEXT("sdbapi.dll"));
            if (hLib == NULL) {
                wsprintf (szMessage, TEXT("Could not load sdbapi.dll.\n"));
                goto eh;
            }

            pfnGrabA = (PFNSdbGrabMatchingInfoExA)GetProcAddress(hLib, TEXT("SdbGrabMatchingInfoEx"));
            if (pfnGrabA == NULL) {
                wsprintf (szMessage, TEXT("Unable to get proc address for SdbGrabMatchingInfo\n"));
                goto eh;
            }
            break;
        default:
            wsprintf (szMessage, TEXT("Unknown platform\n"));
            goto eh;
    }

    // Parse the command line for flags
    if( argc >= 2) {
        int i = 1;
        while (i < argc){
            LPCTSTR pch = argv[i];
            TCHAR   ch  = *pch;
            if (ch == TEXT('-') || ch == TEXT('/')) {
                ch = *++pch;
                ++pch;
                switch(_totupper(ch)) {
                case TEXT('F'):
                    if (*pch == TEXT('\0')) {
                        ++i;
                        if (i < argc && _istalnum(*argv[i])) {
                            pch = argv[i];
                        } else {
                            // error - missing filename
                            wsprintf (szMessage,  TEXT("You must provide a file with a .txt extension to save to.\n") );
                            goto HandleUsage;
                        }
                    } 
                    
                    lstrcpy(szFile, pch);
                    bDestinationSelected=TRUE;
                    break;
                            
                case TEXT('?'):
                case TEXT('H'): // help ? 
                    HandleUsage:
                    ProperUsage();
                    goto eh;

                case TEXT('D'):
                    dwFilter = GRABMI_FILTER_DRIVERS;
                    break;

                case TEXT('O'):
                    dwFilter = GRABMI_FILTER_THISFILEONLY;
                    break;

                case TEXT('V'):
                    dwFilter = GRABMI_FILTER_VERBOSE;
                    break;

                case TEXT('Q'):
                    bDisplayFile = FALSE;
                    break;

                case TEXT('P'):
                    dwFilter = GRABMI_FILTER_PRIVACY;
                    break;

                case TEXT('S'):
                    dwFilter = GRABMI_FILTER_SYSTEM;
                    break;
    
                case TEXT('A'):
                    dwFilterFlags |= GRABMI_FILTER_APPEND;
                    break;

                case TEXT('N'):
                    dwFilterFlags |= GRABMI_FILTER_NOCLOSE;
                    break;
                    
                default:
                    // unrecognized arg goes here
                    wsprintf(szMessage, TEXT("Unrecognized argument, RTFM: %s\n"), argv[i]);
                    goto HandleUsage;
                    break;
                }
            } else {
                // unnamed argument
                if (++Cnt > 1) {
                    
                    // error - more than one file specified -- we do not support it for now
                    //
                    wsprintf(szMessage, TEXT("More than one file specified %s\n"), argv[i]);
                    goto HandleUsage;
                }

                lstrcpy(szRootDir, argv[i]);
            }

            ++i;
        }
    }

    if (!bDestinationSelected) {
        GetSystemDirectory( szFile, MAX_PATH );
        LPTSTR pchBackslash;

        pchBackslash = _tcschr(szFile, TEXT('\\'));

        lstrcpy (pchBackslash, TEXT("\\matchinginfo.txt"));
        bDestinationSelected=TRUE;
    }

    if ( (_tcsicmp(szRootDir ,TEXT(".")) == 0) || szRootDir[0] == '\0' ) {
        // The root path wasn't specified.  Get the current path or
        // the path to the drivers depending on command line
        if (dwFilter == GRABMI_FILTER_DRIVERS && (_tcsicmp(szRootDir ,TEXT(".")) != 0)) {
            GetSystemDirectory( szRootDir, MAX_PATH );
            lstrcat( szRootDir, TEXT("\\drivers") );
        } else {
            GetCurrentDirectory( MAX_PATH, szRootDir );
        }
    }

    // if we are using sdbapiu.dll we need to call it with 
    // unicode parameters
    if (VersionInfo.dwPlatformId == VER_PLATFORM_WIN32_NT) {
        WCHAR wszRootDir[MAX_PATH] ={'\0'};
        WCHAR wszFile[MAX_PATH] ={'\0'};
        int cchWideChar;
     
        cchWideChar = MultiByteToWideChar(
                            CP_ACP, 
                            0, 
                            szRootDir, 
                            -1, 
                            NULL, 
                            0 );
        //
        // check for error!!!
        //
        if ((DWORD)cchWideChar > MAX_PATH) {
            wsprintf (szMessage, TEXT("Unable to convert szRootDir to wszRootDir.\n"));
            goto eh;
        }

        MultiByteToWideChar(
            CP_ACP, 
            0, 
            szRootDir, 
            -1, 
            wszRootDir, 
            cchWideChar );

        cchWideChar = MultiByteToWideChar(
                            CP_ACP, 
                            0, 
                            szFile, 
                            -1, 
                            NULL, 
                            0 );
        //
        // check for error!!!
        //
        if ((DWORD)cchWideChar > MAX_PATH) {
            wsprintf (szMessage, TEXT("Unable to convert szFile to wszFile.\n"));
            goto eh;
        }

        MultiByteToWideChar(
            CP_ACP, 
            0, 
            szFile, 
            -1, 
            wszFile, 
            cchWideChar );
        // now make call to SdbGrabMatchingInfo with Unicode parameters
        if ((pfnGrabW (wszRootDir, dwFilter|dwFilterFlags, wszFile, _GrabmiCallback, NULL)) != GMI_SUCCESS) {
            wsprintf (szMessage, TEXT("Unable to grab matching information from %s.\n"), szRootDir);
            goto eh;
        }
        wsprintf (szMessage, TEXT("Matching information retrieved successfully.\n"));
        

    }
    else if (VersionInfo.dwPlatformId == VER_PLATFORM_WIN32_WINDOWS){
        // otherwise call SdbGrabMatchingInfo as normal
        if ((pfnGrabA (szRootDir, dwFilter|dwFilterFlags, szFile, _GrabmiCallback, NULL)) != GMI_SUCCESS) {
            wsprintf (szMessage, TEXT("Unable to grab matching information from %s.\n"), szRootDir);
            goto eh;
        }
        wsprintf (szMessage, TEXT("Matching information retrieved successfully.\n"));
    }
    else {
        wsprintf (szMessage, TEXT("Unknown OS Platform.\n"));
        goto eh;
    }

    if (bDisplayFile) {

        if (VersionInfo.dwPlatformId == VER_PLATFORM_WIN32_NT) {
            lstrcpy (szCommandLine, TEXT("notepad "));
        }
        else {
            lstrcpy (szCommandLine, TEXT("write "));
        }
        lstrcat (szCommandLine, szFile);
            
        WinExec (szCommandLine, SW_SHOW);
    }
eh:
    
    if (*szMessage) {
        _tprintf (TEXT("%s"), szMessage);
        iRetCode = 1;
    }
    return iRetCode;
}

/*++

 Function Description:
    
    This function simply prints out the proper usage for GrabMI.

 Arguments:

 Return Value: 
    
    VOID.

 History:

    jdoherty Created    8/2/00

--*/
void ProperUsage()
{

    _tprintf (TEXT("\nGrabMI can be used in one of the following ways:\n")
                        TEXT(" *** The following flags can be used with other flags: \n")
                        TEXT("     -f, -a, -n, and -h \n")
                        TEXT("     otherwise the last flag specified will be the one used.\n")
                        TEXT(" *** By default information will be stored in %%systemdrive%%\\matchinginfo.txt\n\n")
                        TEXT("   grabmi [path to start generating info ie. c:\\progs]\n")
                        TEXT("      Grabs matching information from the path specified. Limits the\n")
                        TEXT("      information gathered to 10 miscellaneous files per directory,\n")
                        TEXT("      and includes all files with extensions .icd, .exe, .dll, \n")
                        TEXT("      .msi, ._mp\n\n")
                        TEXT("   grabmi [-d]\n")
                        TEXT("      Grabs matching information from %%windir%%\\system32\\drivers. \n")
                        TEXT("      The format of the information is slightly different in this case\n")
                        TEXT("      and only information for *.sys files will be grabbed.\n\n")
                        TEXT("   grabmi [-f drive:\\filename.txt]\n")
                        TEXT("      The matching information is stored in a file specified by the user.\n\n")
                        TEXT("   grabmi [-h or -?]\n")
                        TEXT("      Displays this help.\n\n")
                        TEXT("   grabmi [-o]\n")
                        TEXT("      Grabs information for the file specified.  If a file was not specified \n")
                        TEXT("      the call will fail.  If the destination file exists then the information\n")
                        TEXT("      will be concatenated to the end of the existing file.\n\n")
                        TEXT("   grabmi [-p]\n")
                        TEXT("      Grabs information for files with .icd, .exe, .dll, .msi, ._mp extensions. \n")
                        TEXT("      No more, no less.\n\n")
                        TEXT("   grabmi [-q]\n")
                        TEXT("      Grabs matching information and does not display the file when completed.\n\n")
                        TEXT("   grabmi [-s]\n")
                        TEXT("      Grabs information for the following system files: \n")
                        TEXT("      advapi32.dll, gdi32.dll, ntdll.dll, kernel32.dll, winsock.dll\n")
                        TEXT("      ole32.dll, oleaut32.dll, shell32.dll, user32.dll, and wininet.dll \n\n")
                        TEXT("   grabmi [-v]\n")
                        TEXT("      Grabs matching information for all files. \n\n")
                        TEXT("   grabmi [-a]\n")
                        TEXT("      Appends new matching information to the existing matching\n")
                        TEXT("      information file. \n\n")
                        TEXT("   grabmi [-n]\n")
                        TEXT("      Allows to append more information to the file later (see -a). \n\n")
                        TEXT("Grab Matching Information Help\n"));
    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\appcompat\tools\qfixapp\qfixapp.h ===
#ifndef _QSHIMAPP_H
#define _QSHIMAPP_H

typedef enum {    
    uSelect     = 0,
    uDeselect,
    uReverse
} SELECTION;

#define ACCESS_READ         0x01
#define ACCESS_WRITE        0x02

#define BML_ADDTOLISTVIEW   0x00000001
#define BML_DELFRLISTVIEW   0x00000002
#define BML_GETFRLISTVIEW   0x00000004

typedef struct tagModule {
    struct tagModule*   pNext;
    TCHAR*              pszName;
    BOOL                fInclude;
} MODULE, *PMODULE;

typedef struct tagFIX {
    struct tagFIX*  pNext;
    BOOL            bLayer;
    BOOL            bFlag;
    TCHAR*          pszName;
    TCHAR*          pszDesc;
    TCHAR*          pszCmdLine;
    struct tagFIX** parrShim;
    struct tagModule* pModule;
    TCHAR**         parrCmdLine;
    ULONGLONG       ullFlagMask;
} FIX, *PFIX;

#define NUM_TABS        2

typedef struct tag_DlgHdr { 
    HWND        hTab;                   // tab control 
    HWND        hDisplay[NUM_TABS];     // dialog box handles
    RECT        rcDisplay;              // display rectangle for each tab
    DLGTEMPLATE *pRes[NUM_TABS];        // DLGTEMPLATE structure 
    DLGPROC     pDlgProc[NUM_TABS];
} DLGHDR, *PDLGHDR;

#if DBG

    void LogMsgDbg(LPTSTR pszFmt, ...);
    
    #define LogMsg  LogMsgDbg
#else

    #define LogMsg

#endif // DBG

BOOL
CenterWindow(
    HWND hWnd
    );

void
HandleModuleListNotification(
    HWND   hdlg,
    LPARAM lParam
    );

void 
DoFileSave(
    HWND hDlg
    );

BOOL
InstallSDB(
    TCHAR* pszFileName,
    BOOL   fInstall
    );

INT_PTR CALLBACK
FixesTabDlgProc(
    HWND   hdlg,
    UINT   uMsg,
    WPARAM wParam,
    LPARAM lParam
    );

INT_PTR CALLBACK
LayersTabDlgProc(
    HWND   hdlg,
    UINT   uMsg,
    WPARAM wParam,
    LPARAM lParam
    );

void
ShowAvailableFixes(
    HWND hList
    );

void
HandleShimListNotification(
    HWND   hdlg,
    LPARAM lParam
    );

#endif // _QSHIMAPP_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\appcompat\tools\qfixapp\qfixapp.cpp ===
/***************************************************************************
* Quick fix application tools
*
* Author: clupu (Feb 16, 2000)
*
* History:
*
* rparsons  -   11/10/2000    -    Modified titles on common dialogs
*
* rparsons  -   11/23/2000    -    Added ability to save XML to file
*
* rparsons  -   11/25/2000    -    Modified to allow matching file on a
*                                  different drive to be selected
*
* rparsons  -   05/19/2001    -    Added context menu on file tree.
*                                  Added URL for WU package.
*                                  Added Remove Matching button.
*                                  Converted shim list to list view.
*
* rparsons  -   07/06/2001    -    Converted static tab control to use
*                                  child dialogs.
*
\**************************************************************************/

#include "afxwin.h"
#include "commctrl.h"
#include "commdlg.h"
#include "shlwapi.h"
#include "shellapi.h"
#include "shlobj.h"
#include "shlobjp.h"    // needed for Link Window support
#include "uxtheme.h"    // needed for tab control theme support
#include "resource.h"
#include <tchar.h>
#include <aclapi.h>

#include "QFixApp.h"
#include "dbSupport.h"

extern "C" {
#include "shimdb.h"
}

CWinApp theApp;

/*
 * Global Variables
 */

HINSTANCE g_hInstance;
HWND      g_hDlg;
HWND      g_hLayersDlg;
HWND      g_hFixesDlg;

HWND      g_hwndTab;
HWND      g_hwndListLayers;

TCHAR     g_szAppTitle[64];

TCHAR     g_szBinary[MAX_PATH];         // the full path of the main binary being shimmed
TCHAR     g_szShortName[128];           // the short name of the main EXE

TCHAR     g_szParentExeName[MAX_PATH];  // the short name of the parent EXE
TCHAR     g_szParentExeFullPath[MAX_PATH]; // the full path of the parent EXE

TCHAR     g_szSDBToDelete[MAX_PATH];    // the SDB file to delete from a previous 'Run'

int       g_nCrtTab;

HWND      g_hwndShimList;               // the handle to the list view control
                                        // containing all the shims available

HWND      g_hwndFilesTree;              // the handle to the tree view control
                                        // containing the matching files selected

HWND      g_hwndModuleList;             // the handle to the list view control
                                        // containing module information

BOOL      g_bSimpleEdition;             // simple or dev edition

BOOL      g_fW2K;                       // Win2K or XP

RECT      g_rcDlgBig, g_rcDlgSmall;     // rectangle of the simple and the dev edition
                                        // of the dialog

BOOL      g_bAllShims;

BOOL      g_bSelectedParentExe;         // flag to indicate if a parent EXE has been
                                        // selected

PFIX      g_pFixHead;

TCHAR     g_szXPUrl[] = _T("hcp://services/subsite?node=TopLevelBucket_4/")
                        _T("Fixing_a_problem&topic=MS-ITS%3A%25HELP_LOCATION")
                        _T("%25%5Cmisc.chm%3A%3A/compatibility_tab_and_wizard.htm")
                        _T("&select=TopLevelBucket_4/Fixing_a_problem/")
                        _T("Application_and_software_problems");

TCHAR     g_szW2KUrl[] = _T("http://www.microsoft.com/windows2000/")
                         _T("downloads/tools/appcompat/");


#define ID_COUNT_SHIMS  1234

typedef HRESULT (*PFNEnableThemeDialogTexture)(HWND hwnd, DWORD dwFlags);

#if DBG

void
LogMsgDbg(
    LPTSTR pszFmt,
    ... 
    )
/*++
    LogMsgDbg

    Description:    DbgPrint.

--*/
{
    TCHAR gszT[1024];
    va_list arglist;

    va_start(arglist, pszFmt);
    _vsntprintf(gszT, 1023, pszFmt, arglist);
    gszT[1023] = 0;
    va_end(arglist);

    OutputDebugString(gszT);
}

#endif // DBG

BOOL
IsUserAnAdministrator(
    void
    )
/*++
    IsUserAnAdministrator

    Description:    Determine if the currently logged on user is an admin.

--*/
{
    HANDLE                      hToken;
    DWORD                       dwStatus = 0, dwAccessMask = 0;
    DWORD                       dwAccessDesired = 0, dwACLSize = 0;
    DWORD                       dwStructureSize = sizeof(PRIVILEGE_SET);
    PACL                        pACL = NULL;
    PSID                        psidAdmin = NULL;
    BOOL                        fReturn = FALSE;
    PRIVILEGE_SET               ps;
    GENERIC_MAPPING             GenericMapping;
    PSECURITY_DESCRIPTOR        psdAdmin           = NULL;
    SID_IDENTIFIER_AUTHORITY    SystemSidAuthority = SECURITY_NT_AUTHORITY;

    // AccessCheck() requires an impersonation token
    if (!ImpersonateSelf(SecurityImpersonation)) {
        goto cleanup;
    }

    // Attempt to access the token for the current thread
    if (!OpenThreadToken(GetCurrentThread(),
                         TOKEN_QUERY,
                         FALSE,
                         &hToken)) {
        
        if (GetLastError() != ERROR_NO_TOKEN) {
             goto cleanup;
        }
    
        // If the thread does not have an access token, we'll 
        // examine the access token associated with the process.
        if (!OpenProcessToken(GetCurrentProcess(),
                              TOKEN_QUERY,
                              &hToken)) {
            goto cleanup;
        }
        
    }

    // Build a SID for administrators group
    if (!AllocateAndInitializeSid(&SystemSidAuthority,
                                  2,
                                  SECURITY_BUILTIN_DOMAIN_RID,
                                  DOMAIN_ALIAS_RID_ADMINS,
                                  0, 0, 0, 0, 0, 0,
                                  &psidAdmin)) {
        goto cleanup;
    }
    
    // Allocate memory for the security descriptor
    psdAdmin = HeapAlloc(GetProcessHeap(),
                         HEAP_ZERO_MEMORY,
                         SECURITY_DESCRIPTOR_MIN_LENGTH);

    if (psdAdmin == NULL) {
         goto cleanup;
    }
    
    // Initialize the new security descriptor
    if (!InitializeSecurityDescriptor(psdAdmin,
                                      SECURITY_DESCRIPTOR_REVISION)) {
         goto cleanup;
    }
    
    // Compute size needed for the ACL
    dwACLSize = sizeof(ACL) + sizeof(ACCESS_ALLOWED_ACE) +
                GetLengthSid(psidAdmin) - sizeof(DWORD);

    // Allocate memory for ACL
    pACL = (PACL) HeapAlloc(GetProcessHeap(),
                            HEAP_ZERO_MEMORY,
                            dwACLSize);

    if (pACL == NULL) {
         goto cleanup;
    }
    
    // Initialize the new ACL
    if (!InitializeAcl(pACL,
                       dwACLSize,
                       ACL_REVISION2)) {
         goto cleanup;
    }
    
    dwAccessMask = ACCESS_READ | ACCESS_WRITE;

    // Add the access-allowed ACE to the DACL
    if (!AddAccessAllowedAce(pACL,
                             ACL_REVISION2,
                             dwAccessMask,
                             psidAdmin)) {
         goto cleanup;
    }
    
    // Set our DACL to the security descriptor
    if (!SetSecurityDescriptorDacl(psdAdmin,
                                   TRUE,
                                   pACL,
                                   FALSE)) {
         goto cleanup;
    }
    
    // AccessCheck is sensitive about the format of the
    // security descriptor; set the group & owner
    SetSecurityDescriptorGroup(psdAdmin, psidAdmin, FALSE);
    SetSecurityDescriptorOwner(psdAdmin, psidAdmin, FALSE);

    // Ensure that the SD is valid
    if (!IsValidSecurityDescriptor(psdAdmin)) {
         goto cleanup;
    }
    
    dwAccessDesired = ACCESS_READ;

    // Initialize GenericMapping structure even though we
    // won't be using generic rights.
    GenericMapping.GenericRead    = ACCESS_READ;
    GenericMapping.GenericWrite   = ACCESS_WRITE;
    GenericMapping.GenericExecute = 0;
    GenericMapping.GenericAll     = ACCESS_READ | ACCESS_WRITE;

    // After all that work, it boils down to this call
    if (!AccessCheck(psdAdmin,
                     hToken,
                     dwAccessDesired,
                     &GenericMapping,
                     &ps,           
                     &dwStructureSize,
                     &dwStatus,
                     &fReturn)) {
        goto cleanup;
    }
    
    RevertToSelf();

cleanup:

    if (pACL) {
        HeapFree(GetProcessHeap(), 0, pACL);
    }
    
    if (psdAdmin){
        HeapFree(GetProcessHeap(), 0, psdAdmin);
    }
        
    if (psidAdmin){
        FreeSid(psidAdmin);
    }
    
    return (fReturn);
}

BOOL
CheckForSDB(
    void
    )
/*++
    CheckForSDB

    Description:    Attempts to locate sysmain.sdb in the apppatch directory.

--*/
{
    HANDLE  hFile;
    TCHAR   szSDBPath[MAX_PATH];
    BOOL    fResult = FALSE;

    if (!GetSystemWindowsDirectory(szSDBPath, MAX_PATH)) {
        return FALSE;
    }

    _tcscat(szSDBPath, _T("\\apppatch\\sysmain.sdb"));

    hFile = CreateFile(szSDBPath,
                       GENERIC_READ,
                       FILE_SHARE_READ | FILE_SHARE_WRITE,
                       NULL,
                       OPEN_EXISTING,
                       FILE_ATTRIBUTE_NORMAL,
                       NULL);

    if (INVALID_HANDLE_VALUE != hFile) {
        CloseHandle(hFile);
        fResult = TRUE;
    }

    return (fResult);
}

void
AddModuleToListView(
    TCHAR*  pModuleName,
    UINT    uOption
    )
/*++
    AddModuleToListView

    Description:    Adds the specified module to the list view.

--*/
{
    LVITEM  lvi;
    int     nIndex;
    TCHAR   szInclude[MAX_PATH];
    TCHAR   szExclude[MAX_PATH];

    LoadString(g_hInstance, IDS_INCLUDE_HDR, szInclude, MAX_PATH);
    LoadString(g_hInstance, IDS_EXCLUDE_HDR, szExclude, MAX_PATH);

    lvi.mask     = LVIF_TEXT | LVIF_PARAM;
    lvi.lParam   = uOption == BST_CHECKED ? 1 : 0;
    lvi.pszText  = uOption == BST_CHECKED ? szInclude : szExclude;
    lvi.iItem    = ListView_GetItemCount(g_hwndModuleList);
    lvi.iSubItem = 0;

    nIndex = ListView_InsertItem(g_hwndModuleList, &lvi);

    ListView_SetItemText(g_hwndModuleList,
                         nIndex,
                         1,
                         pModuleName);
}

void
BuildModuleListForShim(
    PFIX  pFix,
    DWORD dwFlags
    )
/*++
    BuildModuleListForShim

    Description:    Based on the flag, adds modules to the list view for
                    the specified shim or retrieves them and adds them
                    to the linked list.
                    
--*/
{
    PMODULE pModule, pModuleTmp, pModuleNew;
    int     nItemCount = 0, nIndex;
    LVITEM  lvi;
    TCHAR   szBuffer[MAX_PATH];

    if (dwFlags & BML_ADDTOLISTVIEW) {
        
        //
        // Walk the linked list and add the modules to the list view.
        //
        pModule = pFix->pModule;

        while (pModule) {
            
            AddModuleToListView(pModule->pszName,
                                pModule->fInclude ? BST_CHECKED : 0);

            pModule = pModule->pNext;
        }
        
    }
     
    if (dwFlags & BML_DELFRLISTVIEW) {

        pModule = pFix->pModule;
        
        while (NULL != pModule) {

            pModuleTmp = pModule->pNext;

            HeapFree(GetProcessHeap(), 0, pModule->pszName);
            HeapFree(GetProcessHeap(), 0, pModule);

            pModule = pModuleTmp;
        }

        pFix->pModule = NULL;

    }

    if (dwFlags & BML_GETFRLISTVIEW) {
    
        pModule = pFix->pModule;
        
        while (NULL != pModule) {

            pModuleTmp = pModule->pNext;

            HeapFree(GetProcessHeap(), 0, pModule->pszName);
            HeapFree(GetProcessHeap(), 0, pModule);

            pModule = pModuleTmp;
        }

        pFix->pModule = NULL;

        //
        // Get each shim from the list view and add it to the list.
        //
        nItemCount = ListView_GetItemCount(g_hwndModuleList);

        if (nItemCount == 0) {
            return;
        }

        for (nIndex = nItemCount - 1; nIndex >= 0; nIndex--) {
        
            lvi.mask     = LVIF_PARAM;
            lvi.iItem    = nIndex;
            lvi.iSubItem = 0;

            ListView_GetItem(g_hwndModuleList, &lvi);

            ListView_GetItemText(g_hwndModuleList, nIndex, 1, szBuffer, MAX_PATH);
    
            pModuleNew = (PMODULE)HeapAlloc(GetProcessHeap(),
                                            HEAP_ZERO_MEMORY,
                                            sizeof(MODULE));
    
            pModuleNew->pszName = (TCHAR*)HeapAlloc(GetProcessHeap(),
                                                    HEAP_ZERO_MEMORY,
                                                    sizeof(TCHAR) * (lstrlen(szBuffer) + 1));
    
            if (pModuleNew == NULL || pModuleNew->pszName == NULL) {
                LogMsg(_T("[BuildModuleListForShim] Couldn't allocate memory to store module info."));
                return;
            }
            
            lstrcpy(pModuleNew->pszName, szBuffer);
            pModuleNew->fInclude = (BOOL)lvi.lParam;

            pModuleNew->pNext = pFix->pModule;
            pFix->pModule = pModuleNew;
        }
    }
}

int
CountShims(
    BOOL fCountSelected
    )
/*++
    CountShims

    Description:    Counts the number of selected shims in the list and
                    updates the text on the dialog.
--*/
{
    int     cShims = 0, nTotalShims, nShims = 0;
    BOOL    fReturn;
    TCHAR   szShims[MAX_PATH];
    TCHAR   szTemp[MAX_PATH];

    cShims = ListView_GetItemCount(g_hwndShimList);

    if (fCountSelected) {
        
        for (nTotalShims = 0; nTotalShims < cShims; nTotalShims++) {
    
            fReturn = ListView_GetCheckState(g_hwndShimList, nTotalShims);
    
            if (fReturn) {
                nShims++;
            }
        }
    }

    LoadString(g_hInstance, IDS_SEL_CAPTION, szTemp, MAX_PATH);
    wsprintf(szShims, szTemp, nShims, cShims);

    SetDlgItemText(g_hFixesDlg, IDC_SELECTED_SHIMS, szShims);

    return (cShims);
}

void
DisplayAttrContextMenu(
    POINT* pt
    )
/*++
    DisplayAttrContextMenu

    Description:    Displays a popup menu for the attributes tree.
    
--*/

{
    HMENU hPopupMenu, hTrackPopup;
                                              
    //
    // Load the popup menu and display it.
    //
    hPopupMenu = LoadMenu(g_hInstance, MAKEINTRESOURCE(IDM_ATTR_POPUP));

    if (hPopupMenu == NULL) {
        return;
    }

    hTrackPopup = GetSubMenu(hPopupMenu, 0);

    TrackPopupMenu(hTrackPopup,
                   TPM_LEFTBUTTON | TPM_NOANIMATION | TPM_LEFTALIGN,
                   pt->x, pt->y, 0, g_hDlg, NULL);

    DestroyMenu(hPopupMenu);
}

void
InsertListViewColumn(
    HWND   hWndListView,
    LPTSTR lpColumnName,
    BOOL   fCenter,
    int    nColumnID,
    int    nSize
    )
/*++
    InsertListViewColumn

    Description:    Wrapper for ListView_InsertColumn.
    
--*/
{
    LV_COLUMN   lvColumn;

    if (fCenter) {
        lvColumn.mask = LVCF_WIDTH | LVCF_TEXT | LVCF_SUBITEM | LVCF_FMT;
    } else {
        lvColumn.mask = LVCF_WIDTH | LVCF_TEXT | LVCF_SUBITEM;
    }

    //
    // Fill in the structure and add the column.
    //
    lvColumn.fmt        =   LVCFMT_CENTER;
    lvColumn.cx         =   nSize;
    lvColumn.iSubItem   =   0;
    lvColumn.pszText    =   lpColumnName; 
    ListView_InsertColumn(hWndListView, nColumnID, &lvColumn);
}


void
EnableTabBackground(
    HWND hDlg
    )
{
    PFNEnableThemeDialogTexture pFnEnableThemeDialogTexture;
    HMODULE                     hUxTheme;
    
    hUxTheme = (HMODULE)LoadLibrary(_T("uxtheme.dll"));
    if (hUxTheme) {
        pFnEnableThemeDialogTexture = (PFNEnableThemeDialogTexture)
                                            GetProcAddress(hUxTheme, "EnableThemeDialogTexture");
        if (pFnEnableThemeDialogTexture) {
            pFnEnableThemeDialogTexture(hDlg, ETDT_USETABTEXTURE);
        }
        
        FreeLibrary(hUxTheme);
    }
}


void
HandleLayersDialogInit(
    HWND hDlg
    )
{
    HWND    hParent;
    DLGHDR* pHdr;

    g_hLayersDlg = hDlg;
    
    hParent = GetParent(hDlg);

    pHdr = (DLGHDR*)GetWindowLongPtr(hParent, DWLP_USER);

    //
    // Position the dialog within the tab.
    //
    SetWindowPos(hDlg, HWND_TOP, 
                 pHdr->rcDisplay.left, pHdr->rcDisplay.top,
                 pHdr->rcDisplay.right - pHdr->rcDisplay.left,
                 pHdr->rcDisplay.bottom - pHdr->rcDisplay.top,
                 0);

    g_hwndListLayers = GetDlgItem(hDlg, IDC_LAYERS);

    EnableTabBackground(hDlg);
}

BOOL
HandleFixesDialogInit(
    HWND hDlg
    )
{
    HWND    hParent;
    DLGHDR* pHdr;
    int     nCount = 0;
    TCHAR   szColumn[MAX_PATH];

    g_hFixesDlg = hDlg;
    
    hParent = GetParent(hDlg);

    pHdr = (DLGHDR*)GetWindowLongPtr(hParent, DWLP_USER);

    //
    // Position the dialog within the tab.
    //
    SetWindowPos(hDlg, HWND_TOP, 
                 pHdr->rcDisplay.left, pHdr->rcDisplay.top,
                 pHdr->rcDisplay.right - pHdr->rcDisplay.left,
                 pHdr->rcDisplay.bottom - pHdr->rcDisplay.top,
                 0);

    g_hwndShimList = GetDlgItem(hDlg, IDC_SHIMS);

    //
    // Set up the shim list.
    //
    LoadString(g_hInstance, IDS_FIXNAME_COLUMN, szColumn, MAX_PATH);
    InsertListViewColumn(g_hwndShimList, szColumn, FALSE, 0, 200);
    LoadString(g_hInstance, IDS_CMDLINE_COLUMN, szColumn, MAX_PATH);
    InsertListViewColumn(g_hwndShimList, szColumn, TRUE, 1, 59);
    LoadString(g_hInstance, IDS_MODULE_COLUMN, szColumn, MAX_PATH);
    InsertListViewColumn(g_hwndShimList, szColumn, TRUE, 2, 52);

    ListView_SetExtendedListViewStyle(g_hwndShimList,
                                      LVS_EX_CHECKBOXES | LVS_EX_FULLROWSELECT);

    //
    // Query the database and show the available general purpose fixes.
    //
    ShowAvailableFixes(g_hwndShimList);

    nCount = CountShims(FALSE);

    if (!nCount) {
        return FALSE;
    }

    ListView_SetItemCount(g_hwndShimList, nCount);

    EnableTabBackground(hDlg);

    return TRUE;
}

DLGTEMPLATE*
LockDlgRes(
    LPCTSTR lpResName
    ) 
{ 
    HRSRC hrsrc = FindResource(NULL, lpResName, RT_DIALOG); 

    if (NULL == hrsrc) {
        return NULL;
    }
    
    HGLOBAL hglb = LoadResource(g_hInstance, hrsrc);

    if (NULL == hglb) {
        return NULL;
    }
    
    return (DLGTEMPLATE*)LockResource(hglb); 
}

void
InitTabs(
    HWND hMainDlg,
    HWND hTab
    )
{
    DLGHDR* pHdr;
    TCITEM  tcitem;
    RECT    rcTab;
    int     nCount;
    TCHAR   szTabText[MAX_PATH];
    TCHAR   szError[MAX_PATH];
    
    pHdr = (DLGHDR*)HeapAlloc(GetProcessHeap(),
                              HEAP_ZERO_MEMORY,
                              sizeof(DLGHDR));

    if (NULL == pHdr) {
        LoadString(g_hInstance, IDS_TAB_SETUP_FAIL, szError, MAX_PATH);
        MessageBox(hMainDlg, szError, g_szAppTitle, MB_OK | MB_ICONERROR);
        return;
    }

    //
    // Save away a pointer to the structure.
    //
    SetWindowLongPtr(hMainDlg, DWLP_USER, (LONG_PTR)pHdr);
    
    //
    // Save away the handle to the tab control.
    //
    pHdr->hTab = hTab;

    //
    // Add the tabs.
    //
    LoadString(g_hInstance, IDS_TAB_FIRST_TEXT, szTabText, MAX_PATH);
    tcitem.mask     = TCIF_TEXT | TCIF_PARAM;
    tcitem.pszText  = szTabText;
    tcitem.lParam   = 0;
    TabCtrl_InsertItem(pHdr->hTab, 0, &tcitem);

    LoadString(g_hInstance, IDS_TAB_SECOND_TEXT, szTabText, MAX_PATH);
    tcitem.pszText = szTabText;
    tcitem.lParam  = 1;
    TabCtrl_InsertItem(pHdr->hTab, 1, &tcitem);

    //
    // Lock the resources for two child dialog boxes.
    //
    pHdr->pRes[0] = LockDlgRes(MAKEINTRESOURCE(IDD_LAYERS_TAB));
    pHdr->pDlgProc[0] = LayersTabDlgProc;
    pHdr->pRes[1] = LockDlgRes(MAKEINTRESOURCE(IDD_FIXES_TAB));
    pHdr->pDlgProc[1] = FixesTabDlgProc;

    //
    // Determine the bounding rectangle for all child dialog boxes.
    //
    GetWindowRect(pHdr->hTab, &rcTab);
    TabCtrl_AdjustRect(pHdr->hTab, FALSE, &rcTab);
    InflateRect(&rcTab, 1, 1);
    rcTab.left -= 2;
    
    MapWindowPoints(NULL, hMainDlg, (LPPOINT)&rcTab, 2);

    pHdr->rcDisplay = rcTab;

    //
    // Create both dialog boxes.
    //
    for (nCount = 0; nCount < NUM_TABS; nCount++) {
        pHdr->hDisplay[nCount] = CreateDialogIndirect(g_hInstance,
                                                      pHdr->pRes[nCount],
                                                      hMainDlg,
                                                      pHdr->pDlgProc[nCount]);
    }
}

TCHAR* 
GetRelativePath(
    TCHAR* pExeFile,
    TCHAR* pMatchFile
    )
/*++
    GetRelativePath

    Description:    Returns a relative path based on an EXE and a matching file.
                    The caller must free the memory using free.

--*/
{
    int     nLenExe = 0;
    int     nLenMatch = 0;
    TCHAR*  pExe    = NULL;
    TCHAR*  pMatch  = NULL;
    TCHAR*  pReturn = NULL;
    TCHAR   result[MAX_PATH] = { _T('\0') };
    TCHAR*  resultIdx = result;
    BOOL    bCommonBegin = FALSE; // Indicates if the paths have a common beginning

    //
    // Ensure that the beginning of the path matches between the two files
    //
    pExe = _tcschr(pExeFile, _T('\\'));
    pMatch = _tcschr(pMatchFile, _T('\\'));

    while (pExe && pMatch) {
        
        nLenExe = (int)(pExe - pExeFile);
        nLenMatch = (int)(pMatch - pMatchFile);

        if (nLenExe != nLenMatch) {
            break;
        }

        if (!(_tcsnicmp(pExeFile, pMatchFile, nLenExe) == 0)) {
            break;
        }

        bCommonBegin = TRUE;
        pExeFile = pExe + 1;
        pMatchFile = pMatch + 1;

        pExe = _tcschr(pExeFile, _T('\\'));
        pMatch = _tcschr(pMatchFile, _T('\\'));
    }

    //
    // Walk the path and put '..\' where necessary
    //
    if (bCommonBegin) {
        
        while (pExe) {

            lstrcpy(resultIdx, _T("..\\"));
            resultIdx = resultIdx + 3;
            pExeFile  = pExe + 1;
            pExe = _tcschr(pExeFile, _T('\\'));
        }

        lstrcpy(resultIdx, pMatchFile);
        
        pReturn = (TCHAR*)HeapAlloc(GetProcessHeap(),
                                    HEAP_ZERO_MEMORY,
                                    sizeof(TCHAR) * (lstrlen(result) + 1));
        
        if (NULL == pReturn) {
            return NULL;
        }

        lstrcpy(pReturn, result);

        return pReturn;
    }

    // the two paths don't have a common beginning,
    // and there is no relative path
    return NULL;
}

void 
SaveEntryToFile(
    HWND    hDlg,
    HWND    hEdit,
    LPCTSTR lpFileName
    )
/*++
    SaveEntryToFile

    Description:    Writes the XML out to a file.

--*/
{
    int     nLen = 0;
    DWORD   dwBytesWritten = 0;
    HANDLE  hFile = NULL;
    LPTSTR  lpData = NULL;
    TCHAR   szError[MAX_PATH];

    //
    // Determine how much space we need for the buffer, then allocate it.
    //
    nLen = GetWindowTextLength(hEdit);

    if (nLen) {

        lpData = (LPTSTR)HeapAlloc(GetProcessHeap(),
                                   HEAP_ZERO_MEMORY,
                                   nLen * 2 * sizeof(TCHAR));

        if (lpData == NULL) {
            LoadString(g_hInstance, IDS_BUFFER_ALLOC_FAIL, szError, MAX_PATH);
            MessageBox(hDlg, szError, g_szAppTitle, MB_OK | MB_ICONERROR);
            return;
        }

        //
        // Get the text out of the text box and write it out to our file.
        // 
        GetWindowText(hEdit, lpData, nLen * 2);

        hFile = CreateFile(lpFileName,
                           GENERIC_WRITE,
                           0,
                           NULL,
                           CREATE_ALWAYS,
                           FILE_ATTRIBUTE_NORMAL,
                           NULL);
        
        if (hFile == INVALID_HANDLE_VALUE) {
            LoadString(g_hInstance, IDS_FILE_CREATE_FAIL, szError, MAX_PATH);
            MessageBox(hDlg, szError, g_szAppTitle, MB_OK | MB_ICONERROR);
            goto Cleanup;
        }

        WriteFile(hFile, lpData, nLen * 2, &dwBytesWritten, NULL);

        CloseHandle(hFile);
        
    }

Cleanup:

    HeapFree(GetProcessHeap(), 0, lpData);
    
}

void 
DoFileSave(
    HWND hDlg
    )
/*++
    DoFileSave

    Description:    Displays the common dialog allowing for file save.

--*/
{
    
    int             nAnswer;
    TCHAR           szError[MAX_PATH];
    TCHAR           szFilter[MAX_PATH] = _T("");
    TCHAR           szTemp[MAX_PATH+1] = _T("");
    OPENFILENAME    ofn = {0};

    szTemp[0] = 0;

    LoadString(g_hInstance, IDS_SAVE_FILTER, szFilter, MAX_PATH);

    ofn.lStructSize       = sizeof(OPENFILENAME);
    ofn.hwndOwner         = hDlg;
    ofn.hInstance         = NULL;
    ofn.lpstrFilter       = szFilter;
    ofn.lpstrCustomFilter = (LPTSTR)NULL;
    ofn.nMaxCustFilter    = 0;
    ofn.nFilterIndex      = 1;
    ofn.lpstrFile         = szTemp;
    ofn.nMaxFile          = sizeof(szTemp);
    ofn.lpstrTitle        = NULL;
    ofn.lpstrFileTitle    = NULL;
    ofn.nMaxFileTitle     = 0;
    ofn.lpstrInitialDir   = NULL;
    ofn.nFileOffset       = 0;
    ofn.nFileExtension    = 0;
    ofn.lpstrDefExt       = _T("xml");
    ofn.lCustData         = 0;
    ofn.Flags             = OFN_PATHMUSTEXIST | OFN_FILEMUSTEXIST | 
                            OFN_HIDEREADONLY  | OFN_OVERWRITEPROMPT;

    if (GetSaveFileName(&ofn)) {
        SaveEntryToFile(hDlg, GetDlgItem(hDlg, IDC_XML), szTemp);
    }
}

void
GetTopLevelWindowIntoView(
    HWND hwnd
    )
{
    RECT    rectWindow, rectScreen;
    int     nCx, nCy, nCxScreen, nCyScreen;
    int     dx = 0, dy = 0;
    HWND    hwndDesktop;

    if (GetWindowLong(hwnd, GWL_STYLE) & WS_CHILD) {
        return;
    }
    
    hwndDesktop = GetDesktopWindow();

    GetWindowRect(hwnd, &rectWindow);
    GetWindowRect(hwndDesktop, &rectScreen);

    nCx = rectWindow.right  - rectWindow.left;
    nCy = rectWindow.bottom - rectWindow.top;
    
    nCxScreen = rectScreen.right  - rectScreen.left;
    nCyScreen = rectScreen.bottom - rectScreen.top;

    //
    // Make it fix on the x coord.
    //
    if (rectWindow.left < rectScreen.left) {
        dx = rectScreen.left - rectWindow.left;

        rectWindow.left += dx;
        rectWindow.right += dx;
    }
    
    if (rectWindow.right > rectScreen.right) {
        if (nCx < nCxScreen) {
            dx = rectScreen.right - rectWindow.right;
            
            rectWindow.left += dx;
            rectWindow.right += dx;
        }
    }

    //
    // Make it fix on the y coord.
    //
    if (rectWindow.top < rectScreen.top) {
        dy = rectScreen.top - rectWindow.top;

        rectWindow.top += dy;
        rectWindow.bottom += dy;
    }
    
    if (rectWindow.bottom > rectScreen.bottom) {
        if (nCy < nCyScreen) {
            dy = rectScreen.bottom - rectWindow.bottom;
            
            rectWindow.top += dy;
            rectWindow.bottom += dy;
        }
    }

    if (dx != 0 || dy != 0) {
        MoveWindow(hwnd, rectWindow.left, rectWindow.top, nCx, nCy, TRUE);
    }
}

BOOL
CenterWindow(
    HWND hWnd
    )
/*++
    CenterWindow

    Description:    Centers the window specified in hWnd.

--*/
{
    RECT    rectWindow, rectParent, rectScreen;
    int     nCX, nCY;
    HWND    hParent;
    POINT   ptPoint;

    hParent =  GetParent(hWnd);
    
    if (hParent == NULL) {
        hParent = GetDesktopWindow();
    }

    GetWindowRect(hParent, &rectParent);
    GetWindowRect(hWnd, &rectWindow);
    GetWindowRect(GetDesktopWindow(), &rectScreen);

    nCX = rectWindow.right  - rectWindow.left;
    nCY = rectWindow.bottom - rectWindow.top;

    ptPoint.x = ((rectParent.right  + rectParent.left) / 2) - (nCX / 2);
    ptPoint.y = ((rectParent.bottom + rectParent.top ) / 2) - (nCY / 2);

    if (ptPoint.x < rectScreen.left) {
        ptPoint.x = rectScreen.left;
    }
    
    if (ptPoint.x > rectScreen.right  - nCX) {
        ptPoint.x = rectScreen.right  - nCX;
    }
    
    if (ptPoint.y < rectScreen.top) {
        ptPoint.y = rectScreen.top;
    }
    
    if (ptPoint.y > rectScreen.bottom - nCY) {
        ptPoint.y = rectScreen.bottom - nCY;
    }

    if (GetWindowLong(hWnd, GWL_STYLE) & WS_CHILD) {
        ScreenToClient(hParent, (LPPOINT)&ptPoint);
    }

    if (!MoveWindow(hWnd, ptPoint.x, ptPoint.y, nCX, nCY, TRUE)) {
        return FALSE;
    }

    return TRUE;
}

void
ReplaceCmdLine(
    PFIX   pFix,
    TCHAR* pszNewCmdLine
    )
/*++
    ReplaceCmdLine

    Description:    Replaces the command line for a shim DLL.

--*/
{
    TCHAR   szError[MAX_PATH];

    if (pFix->pszCmdLine != NULL) {
        HeapFree(GetProcessHeap(), 0, pFix->pszCmdLine);
        pFix->pszCmdLine = NULL;
    }

    if (pszNewCmdLine == NULL) {
        return;
    
    } else if ((*pszNewCmdLine == '"') && (_tcslen(pszNewCmdLine)==1)) {
        LoadString(g_hInstance, IDS_INVALID_CMD_LINE, szError, MAX_PATH);
        MessageBox(g_hDlg, szError, g_szAppTitle, MB_OK | MB_ICONEXCLAMATION);
        return;
    }
    
    pFix->pszCmdLine = (TCHAR*)HeapAlloc(GetProcessHeap(),
                                         HEAP_ZERO_MEMORY,
                                         sizeof(TCHAR) * (lstrlen(pszNewCmdLine) + 1));

    if (pFix->pszCmdLine != NULL) {
        lstrcpy(pFix->pszCmdLine, pszNewCmdLine);
    } else {
        LogMsg(_T("[ReplaceCmdLine] failed to replace the cmd line for \"%s\"\n"),
               pFix->pszName);
    }
}

void
DeselectAllShims(
    HWND hdlg
    )
/*++
    DeselectAllShims

    Description:    Removes selections for all shims listed.

--*/
{
    int     cShims, nIndex;
    LVITEM  lvi;
    UINT    uState;

    //
    // Walk all the shims in the list view and deselect them.
    //
    ZeroMemory(&lvi, sizeof(lvi));

    cShims = ListView_GetItemCount(g_hwndShimList);

    for (nIndex = 0; nIndex < cShims; nIndex++) {

        PFIX pFix;
        
        lvi.iItem     = nIndex;
        lvi.mask      = LVIF_STATE | LVIF_PARAM;
        lvi.stateMask = LVIS_STATEIMAGEMASK;
        
        ListView_GetItem(g_hwndShimList, &lvi);

        pFix = (PFIX)lvi.lParam;

        //
        // Clear the check box, removes the 'X', clear the command line,
        // and clear the modules.
        //
        ListView_SetItemText(g_hwndShimList, nIndex, 1, _T(""));
        ListView_SetItemText(g_hwndShimList, nIndex, 2, _T(""));
        ListView_SetCheckState(g_hwndShimList, nIndex, FALSE);
        ReplaceCmdLine(pFix, NULL);
        BuildModuleListForShim(pFix, BML_DELFRLISTVIEW);
    }
    
    //
    // Update the count of selected shims.
    //
    SetTimer(hdlg, ID_COUNT_SHIMS, 100, NULL);
}

void
AddMatchingFile(
    HWND    hdlg,
    LPCTSTR pszFullPath,
    LPCTSTR pszRelativePath,
    BOOL    bMainEXE
    )
/*++
    AddMatchingFile

    Description:    Adds a matching file and it's attributes to the tree.

--*/
{
    PATTRINFO      pAttrInfo;
    TVINSERTSTRUCT is;
    HTREEITEM      hParent;
    DWORD          i;
    DWORD          dwAttrCount;
    TCHAR          szItem[MAX_PATH];

    //
    // Call the attribute manager to get all the attributes for this file.
    //
    SdbGetFileAttributes(pszFullPath, &pAttrInfo, &dwAttrCount);

    is.hParent      = TVI_ROOT;
    is.hInsertAfter = TVI_LAST;
    is.item.lParam  = (LPARAM)pAttrInfo;
    is.item.mask    = TVIF_TEXT | TVIF_PARAM;
    is.item.pszText = (LPTSTR)pszRelativePath;

    hParent = TreeView_InsertItem(g_hwndFilesTree, &is);

    is.hParent = hParent;

    is.item.mask    = TVIF_TEXT | TVIF_STATE | TVIF_PARAM | TVIF_IMAGE | TVIF_SELECTEDIMAGE;
    is.item.pszText = szItem;

    is.item.iImage         = 0;
    is.item.iSelectedImage = 1;
    
    //
    // By default the attributes are not selected. To have them selected
    // by default you need to replace the following 1 with 2.
    //
    is.item.state          = INDEXTOSTATEIMAGEMASK(1);
    is.item.stateMask      = TVIS_STATEIMAGEMASK;

    //
    // Loop through all the attributes and show the ones that are available.
    //
    for (i = 0; i < dwAttrCount; i++) {

        if (!SdbFormatAttribute(&pAttrInfo[i], szItem, MAX_PATH)) {
            continue;
        }
        
        //
        // EXETYPE is a bogus attribute. Don't show it!
        //
        is.item.lParam = i;
        TreeView_InsertItem(g_hwndFilesTree, &is);
    }

    TreeView_Expand(g_hwndFilesTree, hParent, TVE_EXPAND);
}

void
BrowseForApp(
    HWND hdlg
    )
/*++
    BrowseForApp

    Description:    Browse for the main executable for which a shim
                    will be applied.
--*/
{
    TCHAR        szFilter[MAX_PATH] = _T("");
    TCHAR        szTitle[MAX_PATH] = _T("");
    OPENFILENAME ofn = {0};
    
    g_szBinary[0] = 0;

    LoadString(g_hInstance, IDS_BROWSE_FILTER, szFilter, MAX_PATH);
    LoadString(g_hInstance, IDS_BROWSE_TITLE, szTitle, MAX_PATH);

    ofn.lStructSize       = sizeof(OPENFILENAME);
    ofn.hwndOwner         = hdlg;
    ofn.hInstance         = NULL;
    ofn.lpstrFilter       = szFilter;
    ofn.lpstrCustomFilter = NULL;
    ofn.nMaxCustFilter    = 0;
    ofn.nFilterIndex      = 0;
    ofn.lpstrFile         = g_szBinary;
    ofn.nMaxFile          = MAX_PATH;
    ofn.lpstrFileTitle    = g_szShortName;
    ofn.nMaxFileTitle     = 128;
    ofn.lpstrInitialDir   = NULL;
    ofn.lpstrTitle        = szTitle;
    ofn.Flags             = OFN_FILEMUSTEXIST | OFN_PATHMUSTEXIST | OFN_HIDEREADONLY;
    ofn.lpstrDefExt       = _T("exe");

    if (GetOpenFileName(&ofn)) {

        TCHAR szMainEXE[128];

        // the parent exe defaults to the same as the EXE
        lstrcpy(g_szParentExeName, g_szShortName);
        lstrcpy(g_szParentExeFullPath, g_szBinary);
        g_bSelectedParentExe = FALSE;

        SetDlgItemText(hdlg, IDC_BINARY, g_szBinary);

        EnableWindow(GetDlgItem(hdlg, IDC_ADD_MATCHING), TRUE);
        EnableWindow(GetDlgItem(hdlg, IDC_RUN), TRUE);
        EnableWindow(GetDlgItem(hdlg, IDC_CREATEFILE), TRUE);
        EnableWindow(GetDlgItem(hdlg, IDC_SHOWXML), TRUE);

        TreeView_DeleteAllItems(g_hwndFilesTree);

        wsprintf(szMainEXE, _T("Main executable (%s)"), g_szShortName);

        AddMatchingFile(hdlg, g_szBinary, szMainEXE, TRUE);
    }
}

void
PromptAddMatchingFile(
    HWND hdlg
    )
/*++
    PromptAddMatchingFile

    Description:    Show the open file dialog to allow the user
                    to add a matching file.
--*/
{
    TCHAR        szFullPath[MAX_PATH+1] = _T("");
    TCHAR        szShortName[128] = _T("");
    TCHAR        szRelativePath[MAX_PATH] = _T("");
    TCHAR        szFilter[MAX_PATH] = _T("");
    TCHAR        szTitle[MAX_PATH] = _T("");
    TCHAR        szParentTitle[MAX_PATH] = _T("");
    TCHAR        szInitialPath[MAX_PATH] = _T("");
    TCHAR        szDrive[_MAX_DRIVE] = _T("");
    TCHAR        szDir[_MAX_DIR] = _T("");
    TCHAR*       pMatch = NULL;
    TCHAR        szError[MAX_PATH];
    OPENFILENAME ofn = {0};

    szInitialPath[0] = 0;

    LoadString(g_hInstance, IDS_MATCH_FILTER, szFilter, MAX_PATH);
    LoadString(g_hInstance, IDS_MATCH_TITLE, szTitle, MAX_PATH);

    if (g_szParentExeFullPath[0]) {
        _tsplitpath(g_szParentExeFullPath, szDrive, szDir, NULL, NULL);
        lstrcpy(szInitialPath, szDrive);
        lstrcat(szInitialPath, szDir);
    }

    ofn.lStructSize       = sizeof(OPENFILENAME);
    ofn.hwndOwner         = hdlg;
    ofn.hInstance         = NULL;
    ofn.lpstrFilter       = szFilter;
    ofn.lpstrCustomFilter = NULL;
    ofn.nMaxCustFilter    = 0;
    ofn.nFilterIndex      = 0;
    ofn.lpstrFile         = szFullPath;
    ofn.nMaxFile          = MAX_PATH;
    ofn.lpstrFileTitle    = szShortName;
    ofn.nMaxFileTitle     = 128;
    ofn.lpstrInitialDir   = NULL;
    ofn.lpstrTitle        = szTitle;
    ofn.Flags             = OFN_FILEMUSTEXIST | OFN_PATHMUSTEXIST | OFN_HIDEREADONLY;
    ofn.lpstrDefExt       = _T("EXE");

    if (GetOpenFileName(&ofn)) {
        //
        // Determine if the matching file is on the same drive
        // as the EXE that was selected.
        //
        if (!PathIsSameRoot(szFullPath,
                            g_szParentExeFullPath) && !g_bSelectedParentExe) {

            TCHAR szParentFile[MAX_PATH];

            //
            // Prompt the user for the parent EXE.
            //
            szParentFile[0] = 0;
            szInitialPath[0] = 0;
            
            if (szFullPath[0]) {
                _tsplitpath(szFullPath, szDrive, szDir, NULL, NULL);
                lstrcpy(szInitialPath, szDrive);
                lstrcat(szInitialPath, szDir);
            }

            LoadString(g_hInstance, IDS_PARENT_TITLE, szParentTitle, MAX_PATH);

            ofn.lpstrTitle = szParentTitle;
            ofn.lpstrFile  = szParentFile;
            ofn.nMaxFile   = sizeof(szParentFile);

            if (GetOpenFileName(&ofn) == TRUE) { 
                lstrcpy(g_szParentExeName, szShortName);
                lstrcpy(g_szParentExeFullPath, szParentFile);
                g_bSelectedParentExe = TRUE;
            }
        }
        
        //
        // Check the drive letters to see which drive the match file is on
        // then calculate a relative path to the matching file.
        //
        if (PathIsSameRoot(szFullPath, g_szParentExeFullPath)) {
            pMatch = GetRelativePath(g_szParentExeFullPath, szFullPath);
        
        } else if (PathIsSameRoot(szFullPath, g_szBinary)) {
            pMatch = GetRelativePath(g_szBinary, szFullPath);

        } else {
            LoadString(g_hInstance, IDS_MATCH_PATH_NOT_RELATIVE, szError, MAX_PATH);
            MessageBox(hdlg, szError, g_szAppTitle, MB_OK | MB_ICONEXCLAMATION);
            return;
        }

        if (pMatch) {
            //
            // Finally add the maching file and free the memory
            //
            AddMatchingFile(hdlg, szFullPath, pMatch, FALSE);
            
            HeapFree(GetProcessHeap(), 0, pMatch);
        }
    }
}

void
ShowAvailableFixes(
    HWND hList
    )
/*++
    ShowAvailableFixes

    Description:    Query the shim database and populate the
                    shim list with all the available shims.
--*/
{
    LVITEM lvitem;
    PFIX   pFix;
    TCHAR  szError[MAX_PATH];
    UINT   uCount = 0;

    g_pFixHead = ReadFixesFromSdb(_T("sysmain.sdb"), g_bAllShims);
    
    if (g_pFixHead == NULL) {
        LoadString(g_hInstance, IDS_SDB_READ_FAIL, szError, MAX_PATH); 
        MessageBox(NULL, szError, g_szAppTitle, MB_OK | MB_ICONERROR);
        return;
    }

    //
    // Walk the list and add all the fixes to the list view.
    //
    pFix = g_pFixHead;

    while (pFix != NULL) {
        
        if (pFix->bLayer) {
            LPARAM lInd;
            
            lInd = SendMessage(g_hwndListLayers, LB_ADDSTRING, 0, (LPARAM)pFix->pszName);
            SendMessage(g_hwndListLayers, LB_SETITEMDATA, lInd, (LPARAM)pFix);
        } else {
            lvitem.mask      = LVIF_TEXT | LVIF_PARAM | LVIF_STATE;
            lvitem.lParam    = (LPARAM)pFix;
            lvitem.pszText   = pFix->pszName;
            lvitem.iItem     = ListView_GetItemCount(g_hwndShimList);
            lvitem.iSubItem  = 0;
            lvitem.state     = INDEXTOSTATEIMAGEMASK(1);
            lvitem.stateMask = LVIS_STATEIMAGEMASK;

            ListView_InsertItem(hList, &lvitem);
        }

        pFix = pFix->pNext;
    }
}

BOOL
InstallSDB(
    TCHAR* pszFileName,
    BOOL   fInstall
    )
/*++
    InstallSDB

    Description:    Launch SDBInst to install or uninstall
                    the specified SDB.

--*/
{
    TCHAR               szCmd[MAX_PATH];
    TCHAR               szExePath[MAX_PATH];
    TCHAR*              pExt = NULL;
    STARTUPINFO         si;
    PROCESS_INFORMATION pi;

    GetSystemDirectory(szExePath, MAX_PATH);

    _tcscat(szExePath, _T("\\sdbinst.exe"));

    if (GetFileAttributes(szExePath) == -1) {
        return FALSE;
    }

    wsprintf(szCmd,
             fInstall ? _T("%s -q %s") : _T("%s -q -u %s"),
             szExePath,
             pszFileName);

    ZeroMemory(&si, sizeof(si));
    si.cb = sizeof(si);

    if (!CreateProcess(NULL,
                       szCmd,
                       NULL,
                       NULL,
                       FALSE,
                       NORMAL_PRIORITY_CLASS | CREATE_NO_WINDOW,
                       NULL,
                       NULL,
                       &si,
                       &pi)) {

        LogMsg(_T("[InstallSDB] CreateProcess \"%s\" failed 0x%X\n"),
               szCmd, GetLastError());
        return FALSE;
    }

    // Wait for SDBInst to complete it's work.
    WaitForSingleObject(pi.hProcess, INFINITE);

    CloseHandle(pi.hThread);
    CloseHandle(pi.hProcess);

    return TRUE;
}

void
CreateSupportForApp(
    HWND hdlg
    )
/*++
    CreateSupportForApp

    Description:    Build an SDB for the application and offer the user
                    the chance to install it.
--*/
{
    BOOL    bok;
    TCHAR   szFileCreated[MAX_PATH];
    TCHAR   szError[MAX_PATH];
    TCHAR   szTemp[MAX_PATH];
    int     nAnswer;
    
    bok = CollectFix(g_hwndListLayers,
                     g_hwndShimList,
                     g_hwndFilesTree,
                     g_szShortName,
                     g_szBinary,
                     (g_nCrtTab == 0 ? CFF_USELAYERTAB : 0) |
                     (g_fW2K ? CFF_ADDW2KSUPPORT : 0),
                     szFileCreated);
    
    if (!bok) {
        LoadString(g_hInstance, IDS_FIX_CREATE_FAIL, szError, MAX_PATH);
        MessageBox(hdlg, szError, g_szAppTitle, MB_OK | MB_ICONERROR);
    } else {
        LoadString(g_hInstance, IDS_CREATE_FIX, szTemp, MAX_PATH);
        wsprintf(szError, szTemp, szFileCreated);
        
        nAnswer = MessageBox(hdlg, szError, g_szAppTitle, MB_YESNO | MB_ICONQUESTION);

        if (IDYES == nAnswer) {
            bok = InstallSDB(szFileCreated, TRUE);

            if (!bok) {
                LoadString(g_hInstance, IDS_INSTALL_FIX_FAIL, szError, MAX_PATH);
                MessageBox(hdlg, szError, g_szAppTitle, MB_OK | MB_ICONERROR);
            } else {
                LoadString(g_hInstance, IDS_INSTALL_FIX_OK, szError, MAX_PATH);
                MessageBox(hdlg, szError, g_szAppTitle, MB_OK | MB_ICONINFORMATION);
            }
        }
    }
}

BOOL
ShowXML(
    HWND hdlg
    )
/*++
    ShowXML

    Description:    Show the XML for the current selections.

--*/
{
    BOOL    bok;
    TCHAR   szError[MAX_PATH];

    bok = CollectFix(g_hwndListLayers,
                     g_hwndShimList,
                     g_hwndFilesTree,
                     g_szShortName,
                     g_szBinary,
                     CFF_SHOWXML |
                     (g_nCrtTab == 0 ? CFF_USELAYERTAB : 0) |
                     (g_fW2K ? CFF_ADDW2KSUPPORT : 0),
                     NULL);

    if (!bok) {
        LoadString(g_hInstance, IDS_TOO_MANY_FILES, szError, MAX_PATH);
        MessageBox(hdlg, szError, g_szAppTitle, MB_OK | MB_ICONEXCLAMATION);
    }
    
    return (bok);
}

void
RunTheApp(
    HWND hdlg
    )
/*++
    RunTheApp

    Description:    Run the selected app.

--*/
{
    STARTUPINFO         si;
    PROCESS_INFORMATION pi;
    TCHAR               szFileCreated[MAX_PATH];
    TCHAR               szCmdLine[MAX_PATH];
    TCHAR               szError[MAX_PATH];
    TCHAR               szRun[MAX_PATH];
    TCHAR*              pszCmd;
    TCHAR*              pszDir;
    TCHAR*              psz;
    BOOL                bok;

    //
    // Cleanup for the previous app.
    //
    CleanupSupportForApp(g_szShortName);

    bok = CollectFix(g_hwndListLayers,
                     g_hwndShimList,
                     g_hwndFilesTree,
                     g_szShortName,
                     g_szBinary,
                     CFF_SHIMLOG |
                     CFF_APPENDLAYER |
                     (g_nCrtTab == 0 ? CFF_USELAYERTAB : 0) |
                     (g_fW2K ? CFF_ADDW2KSUPPORT : 0),
                     szFileCreated);
    
    if (!bok) {
        LoadString(g_hInstance, IDS_ADD_SUPPORT_FAIL, szError, MAX_PATH);
        MessageBox(hdlg, szError, g_szAppTitle, MB_OK | MB_ICONERROR);
        return;
    }

    //
    // We need to install the fix for them.
    //
    if (!(InstallSDB(szFileCreated, TRUE))) {
        LoadString(g_hInstance, IDS_INSTALL_FIX_FAIL, szError, MAX_PATH);
        MessageBox(g_hDlg, szError, g_szAppTitle, MB_OK | MB_ICONERROR);
        return;
    }
    
    ZeroMemory(&si, sizeof(si));
    si.cb = sizeof(si);

    //
    // Try to run the app.
    //
    GetDlgItemText(hdlg, IDC_CMD_LINE, szCmdLine, MAX_PATH);

    if (szCmdLine[0] == 0) {
        wsprintf(szRun, _T("\"%s\""), g_szBinary);
    } else {
        wsprintf(szRun, _T("\"%s\" %s"), g_szBinary, szCmdLine);
    }

    pszCmd = szRun;
    pszDir = g_szBinary;

    //
    // We need to change the current directory or some
    // apps won't run.
    //
    psz = pszDir + lstrlen(pszDir) - 1;

    while (psz > pszDir && *psz != _T('\\')) {
        psz--;
    }

    if (psz > pszDir) {
        *psz = 0;
        SetCurrentDirectory(pszDir);
        *psz = _T('\\');
    }

    LogMsg(_T("[RunTheApp] : %s\n"), pszCmd);
    
    if (!CreateProcess(NULL,
                       pszCmd,
                       NULL,
                       NULL,
                       FALSE,
                       NORMAL_PRIORITY_CLASS,
                       NULL,
                       NULL,
                       &si,
                       &pi)) {

        LogMsg(_T("[RunTheApp] CreateProcess failed 0x%X\n"), GetLastError());
        return;
    }

    CloseHandle(pi.hThread);
    CloseHandle(pi.hProcess);

    //
    // Save this SDB for later so we can remove it.
    //
    lstrcpy(g_szSDBToDelete, szFileCreated);
}

void
ExpandCollapseDialog(
    HWND hdlg,
    BOOL bHide
    )
/*++
    ExpandCollapseDialog

    Description:    Change the current view of the dialog.

--*/
{
    TCHAR   szSimple[64];
    TCHAR   szAdvanced[64];
    int     i, nShow;
    DWORD   arrId[] = {IDC_ADD_MATCHING,
                       IDC_FILE_ATTRIBUTES_STATIC,
                       IDC_ATTRIBUTES,
                       IDC_CREATEFILE,
                       0};

    if (!bHide) {
        SetWindowPos(hdlg, NULL, 0, 0,
                     g_rcDlgBig.right - g_rcDlgBig.left,
                     g_rcDlgBig.bottom - g_rcDlgBig.top,
                     SWP_NOMOVE | SWP_NOZORDER);
        nShow = SW_SHOW;
        g_bSimpleEdition = FALSE;
        LoadString(g_hInstance, IDS_SIMPLE_TEXT, szSimple, 64);
        SetDlgItemText(hdlg, IDC_DETAILS, szSimple);
        SendDlgItemMessage(hdlg, IDC_CREATEFILE, BM_SETCHECK, BST_CHECKED, 0);

        //
        // Make sure the dialog is in view.
        //
        GetTopLevelWindowIntoView(hdlg);
    } else {
        nShow = SW_HIDE;
        g_bSimpleEdition = TRUE;
        LoadString(g_hInstance, IDS_ADVANCED_TEXT, szAdvanced, 64);
        SetDlgItemText(hdlg, IDC_DETAILS, szAdvanced);
        SendDlgItemMessage(hdlg, IDC_CREATEFILE, BM_SETCHECK, BST_UNCHECKED, 0);
    }

    for (i = 0; arrId[i] != 0; i++) {
        ShowWindow(GetDlgItem(hdlg, arrId[i]), nShow);
    }

    if (bHide) {
        SetWindowPos(hdlg, NULL, 0, 0,
                     g_rcDlgSmall.right - g_rcDlgSmall.left,
                     g_rcDlgSmall.bottom - g_rcDlgSmall.top,
                     SWP_NOMOVE | SWP_NOZORDER);
    }
}

void
LayerChanged(
    HWND hdlg
    )
/*++
    LayerChanged

    Description:    Changing the layer has the effect of selecting the
                    shims that the layer consists of.
--*/
{
    LRESULT   lSel;
    PFIX      pFix;
    LVITEM    lvi;
    int       nIndex, cShims = 0;

    lSel = SendMessage(g_hwndListLayers, LB_GETCURSEL, 0, 0);

    if (lSel == LB_ERR) {
        LogMsg(_T("[LayerChanged] No layer selected.\n"));
        return;
    }
    
    pFix = (PFIX)SendMessage(g_hwndListLayers, LB_GETITEMDATA, lSel, 0);

    if (pFix->parrShim == NULL) {
        LogMsg(_T("[LayerChanged] No array of DLLs.\n"));
        return;
    }

    // Remove any prior selections.
    DeselectAllShims(g_hFixesDlg);

    //
    // Loop through all the items in the shim list and make the
    // appropriate selections.
    //
    cShims = ListView_GetItemCount(g_hwndShimList);

    for (nIndex = 0; nIndex < cShims; nIndex++) {

        PFIX  pFixItem;
        TCHAR szText[1024];
        int   nInd = 0;
        
        lvi.mask     = LVIF_PARAM;
        lvi.iItem    = nIndex;
        lvi.iSubItem = 0; 

        ListView_GetItem(g_hwndShimList, &lvi);
        
        pFixItem = (PFIX)lvi.lParam;

        //
        // See if this shim DLL is in the array for the selected layer.
        //
        while (pFix->parrShim[nInd] != NULL) {
            
            if (pFix->parrShim[nInd] == pFixItem) {
                break;
            }
            
            nInd++;
        }

        //
        // Put a check next to this shim DLL. If he has a command line,
        // put an 'X' in the CmdLine subitem.
        //
        if (pFix->parrShim[nInd] != NULL) {
            ListView_SetCheckState(g_hwndShimList, nIndex, TRUE);
        } else {
            ListView_SetCheckState(g_hwndShimList, nIndex, FALSE);
        }

        if (pFix->parrCmdLine[nInd] != NULL) {
            ReplaceCmdLine(pFixItem, pFix->parrCmdLine[nInd]);
            ListView_SetItemText(g_hwndShimList, nIndex, 1, _T("X"));
        }

        ListView_SetItem(g_hwndShimList, &lvi);
    }
    
    //
    // Update the count of selected shims.
    //
    SetTimer(g_hFixesDlg, ID_COUNT_SHIMS, 100, NULL);
}

BOOL
InitMainDialog(
    HWND hdlg
    )
/*++
    InitMainDialog

    Description:    Init routine called during WM_INITDIALOG for
                    the main dialog of QFixApp.
--*/
{
    HICON      hIcon;
    RECT       rcList, rcTree;
    HIMAGELIST hImage;
    TCHAR      szText[MAX_PATH];

    //
    // Initialize globals.
    //
    g_szParentExeFullPath[0] = 0;
    g_szBinary[0] = 0;
    g_hDlg = hdlg;

    //
    // The dialog has two views. Calculate the size of the smaller
    // view and show the simpler view by default.
    //
    GetWindowRect(hdlg, &g_rcDlgBig);

    GetWindowRect(GetDlgItem(hdlg, IDC_ATTRIBUTES), &rcList);
    GetWindowRect(GetDlgItem(hdlg, IDC_TAB_FIXES), &rcTree);

    g_rcDlgSmall.left   = g_rcDlgBig.left;
    g_rcDlgSmall.top    = g_rcDlgBig.top;
    g_rcDlgSmall.bottom = g_rcDlgBig.bottom;
    g_rcDlgSmall.right  = g_rcDlgBig.right -
                            (rcList.right - rcList.left) -
                            (rcList.left - rcTree.right);

    ExpandCollapseDialog(hdlg, TRUE);

    CenterWindow(hdlg);

    //
    // Disable a bunch of controls.
    //
    EnableWindow(GetDlgItem(hdlg, IDC_ADD_MATCHING), FALSE);
    EnableWindow(GetDlgItem(hdlg, IDC_REMOVE_MATCHING), FALSE);
    EnableWindow(GetDlgItem(hdlg, IDC_RUN), FALSE);
    EnableWindow(GetDlgItem(hdlg, IDC_CREATEFILE), FALSE);
    EnableWindow(GetDlgItem(hdlg, IDC_SHOWXML), FALSE);

    //
    // Show the app icon.
    //
    hIcon = LoadIcon(g_hInstance, MAKEINTRESOURCE(IDI_ICON));

    SetClassLongPtr(hdlg, GCLP_HICON, (LONG_PTR)hIcon);

    g_hwndTab        = GetDlgItem(hdlg, IDC_TAB_FIXES);
    g_hwndFilesTree  = GetDlgItem(hdlg, IDC_ATTRIBUTES);

    //
    // Set up the tab control.
    //
    InitTabs(hdlg, g_hwndTab);
    
    hImage = ImageList_LoadImage(g_hInstance,
                                 MAKEINTRESOURCE(IDB_BMP_CHECK),
                                 16,
                                 0,
                                 CLR_DEFAULT,
                                 IMAGE_BITMAP,
                                 LR_LOADTRANSPARENT);

    if (hImage != NULL) {
        TreeView_SetImageList(g_hwndFilesTree, hImage, TVSIL_STATE);
    } else {
        LogMsg(_T("[InitMainDialog] Failed to load imagelist\n"));
    }

    //
    // Set the text for the link window.
    //
    LoadString(g_hInstance,
               g_fW2K ? IDS_W2K_LINK : IDS_XP_LINK,
               szText,
               MAX_PATH);
    SetDlgItemText(g_hDlg, IDC_DOWNLOAD_WU, szText);

    //
    // Try selecting the Win95 layer.
    //
    SendMessage(g_hwndListLayers, LB_SELECTSTRING, (WPARAM)(-1), (LPARAM)_T("Win95"));

    LayerChanged(hdlg);

    TabCtrl_SetCurFocus(g_hwndTab, 0);
    ShowWindow(g_hLayersDlg, SW_SHOWNORMAL);

    return TRUE;
}

void
FileTreeToggleSelection(
    HTREEITEM hItem,
    int       uMode
    )
/*++
    FileTreeToggleSelection

    Description:    Changes the selection on the attributes tree.

--*/
{
    UINT   State;
    TVITEM item;

    switch (uMode) 
    {
        case uSelect:
            State = INDEXTOSTATEIMAGEMASK(2);
            break;
            
        case uDeselect:
            State = INDEXTOSTATEIMAGEMASK(1);
            break;
    
        case uReverse:
        {
            item.mask      = TVIF_HANDLE | TVIF_STATE;
            item.hItem     = hItem;
            item.stateMask = TVIS_STATEIMAGEMASK;
        
            TreeView_GetItem(g_hwndFilesTree, &item);
        
            State = item.state & TVIS_STATEIMAGEMASK;
        
            if (State) {
                if (((State >> 12) & 0x03) == 2) {
                    State = INDEXTOSTATEIMAGEMASK(1);
                } else {
                    State = INDEXTOSTATEIMAGEMASK(2);
                }
            }
            break;
        }
    }
    
    item.mask      = TVIF_HANDLE | TVIF_STATE;
    item.hItem     = hItem;
    item.state     = State;
    item.stateMask = TVIS_STATEIMAGEMASK;

    TreeView_SetItem(g_hwndFilesTree, &item);
}

void
SelectAttrsInTree(
    BOOL fSelect
    )
/*++
    SelectAttrsInTree

    Description:    Walks each attribute in tree and reverses it's selection.
    
--*/
{
    HTREEITEM hItem, hChildItem;
    
    hItem = TreeView_GetSelection(g_hwndFilesTree);
    
    hChildItem = TreeView_GetChild(g_hwndFilesTree, hItem);

    FileTreeToggleSelection(hChildItem, fSelect ? uSelect : uDeselect);

    while (hChildItem) {
        hChildItem = TreeView_GetNextSibling(g_hwndFilesTree, hChildItem);
        FileTreeToggleSelection(hChildItem, fSelect ? uSelect : uDeselect);
    }
}

void
ShimListToggleSelection(
    int nItem,
    int uMode
    )
/*++
    ShimListToggleSelection

    Description:    Changes the selection on the shim list.

--*/
{
    UINT    uState;

    switch (uMode) 
    {
        case uSelect:
            ListView_SetCheckState(g_hwndShimList, nItem, TRUE);
            break;
            
        case uDeselect:
            ListView_SetCheckState(g_hwndShimList, nItem, FALSE);
            break;
    
        case uReverse:
            
            uState = ListView_GetItemState(g_hwndShimList,
                                           nItem,
                                           LVIS_STATEIMAGEMASK);

            if (uState) {
                if (((uState >> 12) & 0x03) == 2) {
                    uState = INDEXTOSTATEIMAGEMASK(2);
                } else {
                    uState = INDEXTOSTATEIMAGEMASK(1);
                }
            }

            ListView_SetItemState(g_hwndShimList, nItem, uState,
                                  LVIS_STATEIMAGEMASK);

            break;
    }
}

void
HandleTabNotification(
    HWND   hdlg,
    LPARAM lParam
    )
/*++
    HandleTabNotification

    Description:    Handle all the notifications we care about for the tab.

--*/
{
    LPNMHDR pnm = (LPNMHDR)lParam;
    int     ind = 0;

    switch (pnm->code) {

    case TCN_SELCHANGE:
    {
        int nSel;

        DLGHDR *pHdr = (DLGHDR*)GetWindowLongPtr(hdlg, DWLP_USER); 

        nSel = TabCtrl_GetCurSel(pHdr->hTab);

        if (-1 == nSel) {
            break;
        }

        g_nCrtTab = nSel;

        if (nSel == 0) {
            ShowWindow(pHdr->hDisplay[1], SW_HIDE);
            ShowWindow(pHdr->hDisplay[0], SW_SHOW);
        } else {
            ShowWindow(pHdr->hDisplay[0], SW_HIDE);
            ShowWindow(pHdr->hDisplay[1], SW_SHOW);
        }
        
        break;
    }

    default:
        break;
    }
}

INT_PTR CALLBACK
OptionsDlgProc(
    HWND   hdlg,
    UINT   uMsg,
    WPARAM wParam,
    LPARAM lParam
    )
/*++
    OptionsDlgProc

    Description:    Handles messages for the options dialog.

--*/
{
    int wCode = LOWORD(wParam);
    int wNotifyCode = HIWORD(wParam);

    switch (uMsg) {
    case WM_INITDIALOG:
    {
        PFIX    pFix;
        TCHAR   szTitle[MAX_PATH];
        TCHAR   szTemp[MAX_PATH];
        TCHAR   szType[64];
        TCHAR   szModuleName[128];

        pFix = (PFIX)lParam;

        LoadString(g_hInstance, IDS_MOD_TYPE, szType, 64);
        LoadString(g_hInstance, IDS_MOD_NAME, szModuleName, 128);
        LoadString(g_hInstance, IDS_OPTIONS_TITLE, szTemp, MAX_PATH);
        
        CenterWindow(hdlg);

        SetWindowLongPtr(hdlg, DWLP_USER, lParam);
        
        EnableWindow(GetDlgItem(hdlg, IDC_REMOVE), FALSE);

        g_hwndModuleList = GetDlgItem(hdlg, IDC_MOD_LIST);

        InsertListViewColumn(g_hwndModuleList, szType, FALSE, 0, 75);
        InsertListViewColumn(g_hwndModuleList, szModuleName, FALSE, 1, 115);

        ListView_SetExtendedListViewStyle(g_hwndModuleList, LVS_EX_FULLROWSELECT);

        wsprintf(szTitle, szTemp, pFix->pszName);
        
        SetWindowText(hdlg, szTitle);
        
        if (NULL != pFix->pszCmdLine) {
            SetDlgItemText(hdlg, IDC_SHIM_CMD_LINE, pFix->pszCmdLine);
        }
        
        CheckDlgButton(hdlg, IDC_INCLUDE, BST_CHECKED);

        // Add any modules to the list view.
        BuildModuleListForShim(pFix, BML_ADDTOLISTVIEW);

        break;
    }
    
    case WM_NOTIFY:
        HandleModuleListNotification(hdlg, lParam);
        break;

    case WM_COMMAND:
        switch (wCode) {

        case IDC_ADD:
        {
            TCHAR   szModName[MAX_PATH];
            TCHAR   szError[MAX_PATH];
            LVITEM  lvi;
            UINT    uInclude, uExclude;

            GetDlgItemText(hdlg, IDC_MOD_NAME, szModName, MAX_PATH);

            if (*szModName == 0) {
                LoadString(g_hInstance, IDS_NO_MOD, szError, MAX_PATH);
                MessageBox(hdlg, szError, g_szAppTitle, MB_ICONEXCLAMATION | MB_OK);
                SetFocus(GetDlgItem(hdlg, IDC_MOD_NAME));
                break;
            }

            uInclude = IsDlgButtonChecked(hdlg, IDC_INCLUDE);
            uExclude = IsDlgButtonChecked(hdlg, IDC_EXCLUDE);

            if ((BST_CHECKED == uInclude) || (BST_CHECKED == uExclude)) {
                AddModuleToListView(szModName, uInclude);
                SetDlgItemText(hdlg, IDC_MOD_NAME, _T(""));
                SetFocus(GetDlgItem(hdlg, IDC_MOD_NAME));
            } else {
                LoadString(g_hInstance, IDS_NO_INCEXC, szError, MAX_PATH);
                MessageBox(hdlg, szError, g_szAppTitle, MB_ICONEXCLAMATION | MB_OK);
                SetFocus(GetDlgItem(hdlg, IDC_INCLUDE));
                break;
            }
            break;
            
        }
        case IDC_REMOVE:
        {   int nIndex;

            nIndex = ListView_GetSelectionMark(g_hwndModuleList);

            ListView_DeleteItem(g_hwndModuleList, nIndex);

            EnableWindow(GetDlgItem(hdlg, IDC_REMOVE), FALSE);

            SetFocus(GetDlgItem(hdlg, IDC_MOD_NAME));

            break;
        }
        case IDOK:
        {
            PFIX  pFix;
            TCHAR szCmdLine[1024] = _T("");
            
            pFix = (PFIX)GetWindowLongPtr(hdlg, DWLP_USER);

            GetDlgItemText(hdlg, IDC_SHIM_CMD_LINE, szCmdLine, 1023);

            if (*szCmdLine != 0) {
                ReplaceCmdLine(pFix, szCmdLine);
            } else {
                ReplaceCmdLine(pFix, NULL);
            }
            
            // Retrieve any modules from the list view.
            BuildModuleListForShim(pFix, BML_GETFRLISTVIEW);
            
            EndDialog(hdlg, TRUE);
            break;
        }
        case IDCANCEL:
            EndDialog(hdlg, FALSE);
            break;

        default:
            return FALSE;
        }
        break;

    default:
        return FALSE;
    }

    return TRUE;
}

INT_PTR CALLBACK
MsgBoxDlgProc(
    HWND   hdlg,
    UINT   uMsg,
    WPARAM wParam,
    LPARAM lParam
    )
/*++
    MsgBoxDlgProc

    Description:    Displays a message box dialog so we can use the hyperlink.

--*/
{
    int wCode = LOWORD(wParam);
    int wNotifyCode = HIWORD(wParam);

    switch (uMsg) {
    
    case WM_INITDIALOG:
    {
        TCHAR   szLink[MAX_PATH];
        UINT    uNoSDB;

        uNoSDB = (UINT)lParam;
        
        CenterWindow(hdlg);

        //
        // Use the parameter to determine what text to display.
        //
        if (uNoSDB) {
            LoadString(g_hInstance, IDS_W2K_NO_SDB, szLink, MAX_PATH);
            SetDlgItemText(hdlg, IDC_MESSAGE, szLink);
        } else {
            LoadString(g_hInstance, IDS_SP2_SDB, szLink, MAX_PATH);
            SetDlgItemText(hdlg, IDC_MESSAGE, szLink);
        }

        LoadString(g_hInstance, IDS_MSG_LINK, szLink, MAX_PATH);
        SetDlgItemText(hdlg, IDC_MSG_LINK, szLink);
        
        break;
    }

    case WM_NOTIFY:
        if (wParam == IDC_MSG_LINK) {
            
            NMHDR* pHdr = (NMHDR*)lParam;

            if (pHdr->code == NM_CLICK || pHdr->code == NM_RETURN) {
                
                SHELLEXECUTEINFO sei = { 0 };
                
                sei.cbSize = sizeof(SHELLEXECUTEINFO);
                sei.fMask  = SEE_MASK_DOENVSUBST;
                sei.hwnd   = hdlg;
                sei.nShow  = SW_SHOWNORMAL;
                sei.lpFile = g_szW2KUrl;

                ShellExecuteEx(&sei);
                break;
            }
        }
        break;
    
    case WM_COMMAND:
        switch (wCode) {
            
        case IDCANCEL:
            EndDialog(hdlg, TRUE);
            break;
        
        default:
            return FALSE;
        }
        break;

    default:
        return FALSE;
    }

    return TRUE;
}

INT_PTR CALLBACK
LayersTabDlgProc(
    HWND   hdlg,
    UINT   uMsg,
    WPARAM wParam,
    LPARAM lParam
    )
/*++
    LayersTabDlgProc

    Description:    Handle messages for the layers tab.

--*/
{
    int wCode = LOWORD(wParam);
    int wNotifyCode = HIWORD(wParam);

    switch (uMsg) {
    
    case WM_INITDIALOG:
        HandleLayersDialogInit(hdlg);
        break;
    
    case WM_COMMAND:

        if (wNotifyCode == LBN_SELCHANGE && wCode == IDC_LAYERS) {
            LayerChanged(hdlg);
            break;
        }

        switch (wCode) {
            
        case IDCANCEL:
            EndDialog(hdlg, TRUE);
            break;
        
        default:
            return FALSE;
        }
        break;

    default:
        return FALSE;
    }

    return TRUE;
}

INT_PTR CALLBACK
FixesTabDlgProc(
    HWND   hdlg,
    UINT   uMsg,
    WPARAM wParam,
    LPARAM lParam
    )
/*++
    LayersDlgProc

    Description:    Handle messages for the fixes tab.

--*/
{
    int wCode = LOWORD(wParam);
    int wNotifyCode = HIWORD(wParam);

    switch (uMsg) {
    
    case WM_INITDIALOG:
        if (!HandleFixesDialogInit(hdlg)) {
            EndDialog(g_hDlg, 0);
        }
        break;

    case WM_NOTIFY:
        if (wParam == IDC_SHIMS) {
            HandleShimListNotification(hdlg, lParam);
        }
        break;

    case WM_TIMER:
        if (wParam == ID_COUNT_SHIMS) {
            KillTimer(hdlg, ID_COUNT_SHIMS);
            CountShims(TRUE);
        }
        break;
    
    case WM_COMMAND:
        switch (wCode) {
            
        case IDCANCEL:
            EndDialog(hdlg, TRUE);
            break;

        case IDC_CLEAR_SHIMS:
            DeselectAllShims(hdlg);
            break;
        
        default:
            return FALSE;
        }
        break;

    default:
        return FALSE;
    }

    return TRUE;
}

void
HandleModuleListNotification(
    HWND   hdlg,
    LPARAM lParam
    )
/*++
    HandleModuleListNotification

    Description:    Handle all the notifications we care about for the
                    shim list.
--*/
{
    LPNMHDR pnm = (LPNMHDR)lParam;

    switch (pnm->code) {

    case NM_CLICK:
    {
        LVHITTESTINFO lvhti;
        LVITEM        lvi;
        
        GetCursorPos(&lvhti.pt);
        ScreenToClient(g_hwndShimList, &lvhti.pt);

        ListView_HitTest(g_hwndShimList, &lvhti);

        //
        // If the user clicked on a list view item,
        // enable the Remove button.
        //
        if (lvhti.flags & LVHT_ONITEMLABEL) {
            EnableWindow(GetDlgItem(hdlg, IDC_REMOVE), TRUE);
        }

        break;
    }
    default:
        break;
    }
}

void
HandleShimListNotification(
    HWND   hdlg,
    LPARAM lParam
    )
/*++
    HandleShimListNotification

    Description:    Handle all the notifications we care about for the
                    shim list.
--*/
{
    LPNMHDR pnm = (LPNMHDR)lParam;

    switch (pnm->code) {

    case NM_CLICK:
    {
        LVHITTESTINFO lvhti;
        LVITEM        lvi;
        
        GetCursorPos(&lvhti.pt);
        ScreenToClient(g_hwndShimList, &lvhti.pt);

        ListView_HitTest(g_hwndShimList, &lvhti);

        //
        // If the check box state has changed,
        // toggle the selection. Either way,
        // maintain selection as we go.
        //
        if (lvhti.flags & LVHT_ONITEMSTATEICON) {
            ShimListToggleSelection(lvhti.iItem, uReverse);
        }
        
        ListView_SetItemState(g_hwndShimList,
                              lvhti.iItem,
                              LVIS_FOCUSED | LVIS_SELECTED,
                              0x000F);

        SetTimer(hdlg, ID_COUNT_SHIMS, 100, NULL);
        break;
    }
    
    case NM_DBLCLK:
    {
        LVITEM  lvi;
        TCHAR   szShimName[MAX_PATH];
        int     nItem;
        PFIX    pFix;

        nItem = ListView_GetSelectionMark(g_hwndShimList);

        if (-1 == nItem) {
            break;
        }

        lvi.mask  = LVIF_PARAM;
        lvi.iItem = nItem;

        ListView_GetItem(g_hwndShimList, &lvi);

        pFix = (PFIX)lvi.lParam;

        // If this is a shim, display the options dialog.
        if (!pFix->bFlag) {

            if (DialogBoxParam(g_hInstance,
                               MAKEINTRESOURCE(IDD_OPTIONS),
                               hdlg,
                               OptionsDlgProc,
                               (LPARAM)pFix)) {
    
                if (NULL != pFix->pszCmdLine) {
                    ListView_SetItemText(g_hwndShimList, nItem, 1, _T("X"));
                } else {
                    ListView_SetItemText(g_hwndShimList, nItem, 1, _T(""));
                }

                if (NULL != pFix->pModule) {
                    ListView_SetItemText(g_hwndShimList, nItem, 2, _T("X"));
                } else {
                    ListView_SetItemText(g_hwndShimList, nItem, 2, _T(""));
                }
            }
        } else {
            MessageBeep(MB_ICONEXCLAMATION);
        }
        break;
    }
    
    case LVN_ITEMCHANGED:
    {
        LPNMLISTVIEW lpnmlv;
        PFIX         pFix;

        lpnmlv = (LPNMLISTVIEW)lParam;
        pFix = (PFIX)lpnmlv->lParam;

        //
        // Only change the text if our selection has changed.
        // If we don't do this, the text goes bye-bye when
        // the user clicks the Clear button.
        //
        if ((lpnmlv->uChanged & LVIF_STATE) &&
            (lpnmlv->uNewState & LVIS_SELECTED)) {
            SetDlgItemText(hdlg, IDC_SHIM_DESCRIPTION, pFix->pszDesc);
            ListView_SetSelectionMark(g_hwndShimList, lpnmlv->iItem);
        }
        break;
    }
    default:
        break;
    }
}

void
HandleAttributeTreeNotification(
    HWND   hdlg,
    LPARAM lParam
    )
/*++
    HandleAttributeTreeNotification

    Description:    Handle all the notifications we care about for the
                    file attributes tree.
--*/
{
    LPNMHDR pnm = (LPNMHDR)lParam;

    switch (pnm->code) {

    case NM_CLICK:
    {
        TVHITTESTINFO HitTest;
        HTREEITEM     hParentItem;

        GetCursorPos(&HitTest.pt);
        ScreenToClient(g_hwndFilesTree, &HitTest.pt);

        TreeView_HitTest(g_hwndFilesTree, &HitTest);

        if (HitTest.flags & TVHT_ONITEMSTATEICON) {
            FileTreeToggleSelection(HitTest.hItem, uReverse);
        
        } else if (HitTest.flags & TVHT_ONITEMLABEL) {

            HWND        hwndButton;
            HTREEITEM   hItem, hRoot;
            
            hwndButton = GetDlgItem(hdlg, IDC_REMOVE_MATCHING);

            hItem = TreeView_GetParent(g_hwndFilesTree, HitTest.hItem);

            hRoot = TreeView_GetRoot(g_hwndFilesTree);

            //
            // If the selected item has no parent and it's not
            // the root, enable the remove matching button.
            //
            if ((NULL == hItem) && (hRoot != HitTest.hItem)) {
                EnableWindow(hwndButton, TRUE);
            } else {
                EnableWindow(hwndButton, FALSE);
            }
        }
        break;
    }

    case NM_RCLICK:
    {
        TVHITTESTINFO HitTest;
        POINT         pt;

        GetCursorPos(&HitTest.pt);
        
        pt.x = HitTest.pt.x;
        pt.y = HitTest.pt.y;

        ScreenToClient(g_hwndFilesTree, &HitTest.pt);

        TreeView_HitTest(g_hwndFilesTree, &HitTest);

        if (HitTest.flags & TVHT_ONITEMLABEL) 
        {
            HTREEITEM hItem, hParentItem;

            TreeView_SelectItem(g_hwndFilesTree, HitTest.hItem);

            //
            // If the selected item has no parent, we assume that a
            // matching file was right-clicked.
            //
            hParentItem = TreeView_GetParent(g_hwndFilesTree, HitTest.hItem);

            if (NULL == hParentItem) {
                DisplayAttrContextMenu(&pt);
            }
        }
        break;
    }
    case TVN_KEYDOWN:
    {
        LPNMTVKEYDOWN lpKeyDown = (LPNMTVKEYDOWN)lParam;
        HTREEITEM     hItem;

        if (lpKeyDown->wVKey == VK_SPACE) {

            hItem = TreeView_GetSelection(g_hwndFilesTree);

            if (hItem != NULL) {
                FileTreeToggleSelection(hItem, uReverse);
            }
        } else if (lpKeyDown->wVKey == VK_DELETE) {

            HTREEITEM hParentItem;

            hItem = TreeView_GetSelection(g_hwndFilesTree);
            
            hParentItem = TreeView_GetParent(g_hwndFilesTree, hItem);

            if (hParentItem == NULL) {
                if (TreeView_GetPrevSibling(g_hwndFilesTree, hItem) != NULL) {
                    TreeView_DeleteItem(g_hwndFilesTree, hItem);
                }
            }
        }
        break;
    }
    default:
        break;
    }
}

INT_PTR CALLBACK
QFixAppDlgProc(
    HWND   hdlg,
    UINT   uMsg,
    WPARAM wParam,
    LPARAM lParam
    )
/*++
    QFixAppDlgProc

    Description:    The dialog proc of QFixApp.

--*/
{
    int wCode = LOWORD(wParam);
    int wNotifyCode = HIWORD(wParam);

    switch (uMsg) {
    case WM_INITDIALOG:
        if (!InitMainDialog(hdlg)) {
            EndDialog(hdlg, TRUE);
        }
        break;

    case WM_NOTIFY:
        if (wParam == IDC_SHIMS) {
            HandleShimListNotification(hdlg, lParam);
        } else if (wParam == IDC_ATTRIBUTES) {
            HandleAttributeTreeNotification(hdlg, lParam);
        } else if (wParam == IDC_TAB_FIXES) {
            HandleTabNotification(hdlg, lParam);
        } else if (wParam == IDC_DOWNLOAD_WU) {
            
            NMHDR* pHdr = (NMHDR*)lParam;

            if (pHdr->code == NM_CLICK || pHdr->code == NM_RETURN) {
                
                SHELLEXECUTEINFO sei = { 0 };
                
                sei.cbSize = sizeof(SHELLEXECUTEINFO);
                sei.fMask  = SEE_MASK_DOENVSUBST;
                sei.hwnd   = hdlg;
                sei.nShow  = SW_SHOWNORMAL;
                sei.lpFile = g_fW2K ? g_szW2KUrl : g_szXPUrl;

                ShellExecuteEx(&sei);
                break;
            }
        }
        break;

    case WM_DESTROY:
    {
        DLGHDR* pHdr;

        //
        // Destory the dialogs and remove any misc files.
        //
        pHdr = (DLGHDR*)GetWindowLongPtr(hdlg, DWLP_USER);

        DestroyWindow(pHdr->hDisplay[0]);
        DestroyWindow(pHdr->hDisplay[1]);

        CleanupSupportForApp(g_szShortName);

        break;
    }

    case WM_COMMAND:
        
        if (wNotifyCode == LBN_SELCHANGE && wCode == IDC_LAYERS) {
            LayerChanged(hdlg);
            break;
        }
        
        switch (wCode) {

        case IDC_RUN:
            RunTheApp(hdlg);
            break;

        case IDC_BROWSE:
            BrowseForApp(hdlg);
            break;
        
        case IDC_DETAILS:
            ExpandCollapseDialog(hdlg, !g_bSimpleEdition);
            break;

        case IDC_CREATEFILE:
            CreateSupportForApp(hdlg);
            break;
        
        case IDC_SHOWXML:
            ShowXML(hdlg);
            break;

        case IDC_ADD_MATCHING:
            PromptAddMatchingFile(hdlg);
            break;

        case IDC_VIEW_LOG:
            ShowShimLog();
            break;

        case IDCANCEL:
            EndDialog(hdlg, TRUE);
            break;

        case IDM_SELECT_ALL:
            SelectAttrsInTree(TRUE);
            break;

        case IDM_CLEAR_ALL:
            SelectAttrsInTree(FALSE);
            break;

        case IDC_REMOVE_MATCHING:
        {
            HTREEITEM   hParentItem, hItem;
            TCHAR       szError[MAX_PATH];

            hItem = TreeView_GetSelection(g_hwndFilesTree);

            if (NULL == hItem) {
                LoadString(g_hInstance, IDS_NO_SELECTION, szError, MAX_PATH);
                MessageBox(hdlg, szError, g_szAppTitle, MB_ICONEXCLAMATION | MB_OK);
                return TRUE;
            }
            
            hParentItem = TreeView_GetParent(g_hwndFilesTree, hItem);

            if (hParentItem == NULL) {
                if (TreeView_GetPrevSibling(g_hwndFilesTree, hItem) != NULL) {
                    TreeView_DeleteItem(g_hwndFilesTree, hItem);
                    EnableWindow(GetDlgItem(hdlg, IDC_REMOVE_MATCHING), FALSE);
                }
            }
            break;
        }

        default:
            return FALSE;
        }
        break;

    default:
        return FALSE;
    }

    return TRUE;
}


int WINAPI
wWinMain(
    HINSTANCE hInst,
    HINSTANCE hInstPrev,
    LPTSTR    lpszCmd,
    int       swShow
    )
/*++
    WinMain

    Description:    Application entry point.

--*/
{
    BOOL                    fSP2 = FALSE;
    TCHAR                   szError[MAX_PATH];
    OSVERSIONINFO           osvi;
    INITCOMMONCONTROLSEX    icex;
    
    icex.dwSize    = sizeof(INITCOMMONCONTROLSEX);
    icex.dwICC     = ICC_LISTVIEW_CLASSES | ICC_TREEVIEW_CLASSES | ICC_TAB_CLASSES;

    if (!InitCommonControlsEx(&icex)) {
        InitCommonControls();
    }

    LoadString(g_hInstance, IDS_APP_TITLE, g_szAppTitle, 64);

    LinkWindow_RegisterClass();

    g_hInstance = hInst;

    osvi.dwOSVersionInfoSize = sizeof(osvi);

    GetVersionEx(&osvi);

    //
    // See if they're an administrator - bail if not.
    //
    if (!(IsUserAnAdministrator())) {
        LoadString(g_hInstance, IDS_NOT_ADMIN, szError, MAX_PATH);
        MessageBox(NULL, szError, g_szAppTitle, MB_ICONERROR | MB_OK);
        return 0;
    }

    //
    // See if we're running on Windows 2000.
    //
    if ((osvi.dwMajorVersion == 5 && osvi.dwMinorVersion == 0)) {
        g_fW2K = TRUE;
    }

    // See if we're running on SP2
    if (!(_tcscmp(osvi.szCSDVersion, _T("Service Pack 2")))) {
        fSP2 = TRUE;
    }

    //
    // Attempt to locate the SDB in the AppPatch directory.
    //
    if (!CheckForSDB()) {
        if (g_fW2K) {
            DialogBoxParam(hInst,
                           MAKEINTRESOURCE(IDD_MSGBOX_SDB),
                           GetDesktopWindow(),
                           MsgBoxDlgProc,
                           (LPARAM)1);
            return 0;
        } else {
            LoadString(g_hInstance, IDS_XP_NO_SDB, szError, MAX_PATH);
            MessageBox(GetDesktopWindow(), szError, g_szAppTitle, MB_OK | MB_ICONEXCLAMATION);
            return 0;
        }
    }

    //
    // If this is SP2, and the SDB is older, bail out.
    //
    if (fSP2) {
        if (IsSDBFromSP2()) {
            DialogBoxParam(hInst,
                           MAKEINTRESOURCE(IDD_MSGBOX_SP2),
                           GetDesktopWindow(),
                           MsgBoxDlgProc,
                           (LPARAM)0);
            return 0;
        }
    }

    LogMsg(_T("[WinMain] Command line \"%s\"\n"), lpszCmd);

    //
    // Check for command line options.
    //
    if (*lpszCmd == _T('a') || *lpszCmd == _T('A')) {
        g_bAllShims = TRUE;
    }

    DialogBox(hInst,
              MAKEINTRESOURCE(IDD_DIALOG),
              GetDesktopWindow(),
              QFixAppDlgProc);

    return 1;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\appcompat\tools\runcompat\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by runcompat.rc
//
#define IDD_DIALOG1                     101
#define IDD_MAIN                        101
#define IDD_LOG_INFO                    102
#define IDC_EDIT_COMMAND_LINE           1000
#define IDC_BUTTON_BROWSE               1001
#define IDC_LIST_LAYER                  1003
#define IDC_CHECK_LOG                   1004
#define IDC_BUTTON_VIEW_LOG             1005
#define IDC_BUTTON_CLEAR_LOG            1006
#define IDC_EDIT_HEADER                 1007
#define IDC_EDIT_ERRORS                 1008
#define IDC_EDIT_WARNINGS               1009
#define IDC_EDIT_OTHER                  1010
#define IDC_BUTTON_PARSE_LOG            1011
#define IDC_CHECK_DISABLE_EXISTING      1012
#define IDC_BUTTON_HELP                 1014

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        104
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1015
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\appcompat\tools\qfixapp\dbsupport.cpp ===
/***************************************************************************
* This file contains functions that are specific for the shim mechanism
* implemented in Whistler
*
* Author: clupu (Feb 16, 2000)
*
* History:
*
* rparsons  -   11/27/2000    -    Fixed a bug that caused SDB name to be truncated.
*                                  Example: Yoda's Challenege became Yoda's
*
\**************************************************************************/

#include "windows.h"
#include "commctrl.h"
#include "shlwapi.h"
#include <tchar.h>

#include "qfixapp.h"
#include "dbSupport.h"
#include "resource.h"

#define _WANT_TAG_INFO

extern "C" {
#include "shimdb.h"

BOOL
ShimdbcExecute(
    LPCWSTR lpszCmdLine
    );
}


extern HINSTANCE g_hInstance;
extern HWND      g_hDlg;
extern TCHAR     g_szSDBToDelete[MAX_PATH];
extern TCHAR     g_szAppTitle[64];

#define MAX_CMD_LINE         1024
#define MAX_SHIM_DESCRIPTION 1024
#define MAX_SHIM_NAME        128

#define MAX_BUFFER_SIZE      1024

#define SHIM_FILE_LOG_NAME  _T("QFixApp.log")

// Temp buffer to read UNICODE strings from the database.
TCHAR   g_szData[MAX_BUFFER_SIZE];

#define MAX_XML_SIZE        1024 * 16

TCHAR   g_szXML[MAX_XML_SIZE];

TCHAR   g_szQFixAppLayerName[] = _T("!#RunLayer");


INT_PTR CALLBACK
ShowXMLDlgProc(
    HWND   hdlg,
    UINT   uMsg,
    WPARAM wParam,
    LPARAM lParam
    )
/*++
    ShowXMLDlgProc

    Description:    Show the dialog with the XML for the current selections.

--*/
{
    int wCode = LOWORD(wParam);
    int wNotifyCode = HIWORD(wParam);

    switch (uMsg) {
    case WM_INITDIALOG:
        CenterWindow(hdlg);
        SetDlgItemText(hdlg, IDC_XML, (LPTSTR)lParam);
        break;

    case WM_COMMAND:
        switch (wCode) {

        case IDCANCEL:
            EndDialog(hdlg, TRUE);
            break;

        case IDC_SAVE_XML:
            DoFileSave(hdlg);
            EndDialog(hdlg, TRUE);
            break;

        default:
            return FALSE;
        }
        break;

    default:
        return FALSE;
    }

    return TRUE;
}

LPTSTR
ReadAndAllocateString(
    PDB   pdb,
    TAGID tiString
    )
{
    TCHAR* psz;

    g_szData[0] = 0;

    SdbReadStringTag(pdb, tiString, g_szData, MAX_BUFFER_SIZE);

    if (g_szData[0] == 0) {
        LogMsg(_T("[ReadAndAllocateString] Couldn't read the string.\n"));
        return NULL;
    }

    psz = (LPTSTR)HeapAlloc(GetProcessHeap(),
                            HEAP_ZERO_MEMORY,
                            sizeof(TCHAR) * (lstrlen(g_szData) + 1));

    if (NULL == psz) {
        return NULL;
    } else {
        lstrcpy(psz, g_szData);
    }

    return psz;
}


PFIX
ParseTagFlag(
    PDB   pdb,
    TAGID tiFlag,
    BOOL  bAllFlags
    )
/*++
    ParseTagFlag

    Description:    Parse a Flag tag for the NAME, DESCRIPTION and MASK

--*/
{
    TAGID     tiFlagInfo;
    TAG       tWhichInfo;
    PFIX      pFix         = NULL;
    TCHAR*    pszName      = NULL;
    TCHAR*    pszDesc      = NULL;
    ULONGLONG ull;
    BOOL      bGeneral     = (bAllFlags ? TRUE : FALSE);
    
    tiFlagInfo = SdbGetFirstChild(pdb, tiFlag);

    while (tiFlagInfo != 0) {
        tWhichInfo = SdbGetTagFromTagID(pdb, tiFlagInfo);

        switch (tWhichInfo) {
        case TAG_GENERAL:
            bGeneral = TRUE;
            break;

        case TAG_NAME:
            pszName = ReadAndAllocateString(pdb, tiFlagInfo);
            break;

        case TAG_DESCRIPTION:
            pszDesc = ReadAndAllocateString(pdb, tiFlagInfo);
            break;

        case TAG_FLAG_MASK_KERNEL:
        case TAG_FLAG_MASK_USER:
            //
            // Read the mask even if we're not using it anywhere yet...
            //
            ull = SdbReadQWORDTag(pdb, tiFlagInfo, 0);
            break;
        
        default:
            break;
        }
        
        tiFlagInfo = SdbGetNextChild(pdb, tiFlag, tiFlagInfo);
    }

    if (!bGeneral) {
        goto cleanup;
    }
    
    //
    // Done. Add the fix to the list.
    //
    pFix = (PFIX)HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, sizeof(FIX));

    if (pFix == NULL || pszName == NULL) {
        
cleanup:        
        if (pFix != NULL) {
            HeapFree(GetProcessHeap(), 0, pFix);
        }
        
        if (pszName != NULL) {
            HeapFree(GetProcessHeap(), 0, pszName);
        }
        
        if (pszDesc != NULL) {
            HeapFree(GetProcessHeap(), 0, pszDesc);
        }
        
        return NULL;
    }

    pFix->pszName     = pszName;
    pFix->bLayer      = FALSE;
    pFix->bFlag       = TRUE;
    pFix->ullFlagMask = ull;

    if (pszDesc != NULL) {
        pFix->pszDesc = pszDesc;
    } else {
        TCHAR* pszNone;
        
        pszNone = (TCHAR*)HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, MAX_PATH);
        
        if (NULL == pszNone) {
            return NULL;
        }

        *pszNone = 0;

        LoadString(g_hInstance, IDS_NO_DESCR_AVAIL, pszNone, MAX_PATH);
        pFix->pszDesc = pszNone;
    }
    
    return pFix;
}

PFIX
ParseTagShim(
    PDB   pdb,
    TAGID tiShim,
    BOOL  bAllShims
    )
/*++
    ParseTagShim

    Description:    Parse a Shim tag for the NAME, SHORTNAME, DESCRIPTION ...

--*/
{
    TAGID     tiShimInfo;
    TAG       tWhichInfo;
    PFIX      pFix         = NULL;
    TCHAR*    pszName      = NULL;
    TCHAR*    pszDesc      = NULL;
    BOOL      bGeneral     = (bAllShims ? TRUE : FALSE);
    
    tiShimInfo = SdbGetFirstChild(pdb, tiShim);

    while (tiShimInfo != 0) {
        tWhichInfo = SdbGetTagFromTagID(pdb, tiShimInfo);

        switch (tWhichInfo) {
        case TAG_GENERAL:
            bGeneral = TRUE;
            break;

        case TAG_NAME:
            pszName = ReadAndAllocateString(pdb, tiShimInfo);
            break;

        case TAG_DESCRIPTION:
            pszDesc = ReadAndAllocateString(pdb, tiShimInfo);
            break;

        default:
            break;
        }
        tiShimInfo = SdbGetNextChild(pdb, tiShim, tiShimInfo);
    }

    if (!bGeneral) {
        goto cleanup;
    }
    
    //
    // Done. Add the fix to the list.
    //
    pFix = (PFIX)HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, sizeof(FIX));

    if (pFix == NULL || pszName == NULL) {
        
cleanup:        
        if (pFix != NULL) {
            HeapFree(GetProcessHeap(), 0, pFix);
        }
        
        if (pszName != NULL) {
            HeapFree(GetProcessHeap(), 0, pszName);
        }
        
        if (pszDesc != NULL) {
            HeapFree(GetProcessHeap(), 0, pszDesc);
        }
        
        return NULL;
    }

    pFix->pszName = pszName;
    pFix->bLayer  = FALSE;
    pFix->bFlag   = FALSE;

    //
    // If we didn't find a description, load it from the resource table.
    //
    if (pszDesc != NULL) {
        pFix->pszDesc = pszDesc;
    } else {
        TCHAR* pszNone;
        
        pszNone = (TCHAR*)HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, MAX_PATH);
        
        if (NULL == pszNone) {
            return NULL;
        }

        *pszNone = 0;

        LoadString(g_hInstance, IDS_NO_DESCR_AVAIL, pszNone, MAX_PATH);
        pFix->pszDesc = pszNone;
    }
    
    return pFix;
}

PFIX
ParseTagLayer(
    PDB   pdb,
    TAGID tiLayer,
    PFIX  pFixHead
    )
/*++
    ParseTagLayer

    Description:    Parse a LAYER tag for the NAME and the SHIMs that it contains.

--*/
{
    PFIX    pFix = NULL;
    TAGID   tiName;
    TAGID   tiShim;
    int     nShimCount, nInd;
    TCHAR*  pszName = NULL;
    PFIX*   parrShim = NULL;
    TCHAR** parrCmdLine = NULL;

    tiName = SdbFindFirstTag(pdb, tiLayer, TAG_NAME);

    if (tiName == TAGID_NULL) {
        LogMsg(_T("[ParseTagLayer] Failed to get the name of the layer.\n"));
        return NULL;
    }
    
    pszName = ReadAndAllocateString(pdb, tiName);
    
    //
    // Now loop through all the SHIMs that this LAYER consists of and
    // allocate an array to keep all the pointers to the SHIMs' pFix
    // structures. We do this in 2 passes. First we calculate how many
    // SHIMs are in the layer, then we lookup their appropriate pFix-es.
    //
    tiShim = SdbFindFirstTag(pdb, tiLayer, TAG_SHIM_REF);

    nShimCount = 0;

    while (tiShim != TAGID_NULL) {
        nShimCount++;
        tiShim = SdbFindNextTag(pdb, tiLayer, tiShim);
    }
    
    parrShim = (PFIX*)HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, sizeof(PFIX) * (nShimCount + 1));
    parrCmdLine = (TCHAR**)HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, sizeof(TCHAR*) * (nShimCount + 1));

    //
    // Done. Add the fix to the list.
    //
    pFix = (PFIX)HeapAlloc(GetProcessHeap(), 0, sizeof(FIX));

    if (pFix == NULL || parrCmdLine == NULL || pszName == NULL || parrShim == NULL) {
        
cleanup:        
        if (pFix != NULL) {
            HeapFree(GetProcessHeap(), 0, pFix);
        }
        
        if (parrCmdLine != NULL) {
            HeapFree(GetProcessHeap(), 0, parrCmdLine);
        }
        
        if (parrShim != NULL) {
            HeapFree(GetProcessHeap(), 0, parrShim);
        }
        
        if (pszName != NULL) {
            HeapFree(GetProcessHeap(), 0, pszName);
        }
        
        LogMsg(_T("[ParseTagLayer] Memory allocation error.\n"));
        return NULL;
    }

    //
    // Now fill out the array of PFIX pointers and cmd lines.
    //
    tiShim = SdbFindFirstTag(pdb, tiLayer, TAG_SHIM_REF);

    nInd = 0;

    while (tiShim != TAGID_NULL) {
        TCHAR szShimName[MAX_SHIM_NAME] = _T("");
        PFIX  pFixWalk;
        
        tiName = SdbFindFirstTag(pdb, tiShim, TAG_NAME);

        if (tiName == TAGID_NULL) {
            LogMsg(_T("[ParseTagLayer] Failed to get the name of the Shim.\n"));
            goto cleanup;
        }

        SdbReadStringTag(pdb, tiName, szShimName, MAX_SHIM_NAME);

        if (szShimName[0] == 0) {
            LogMsg(_T("[ParseTagLayer] Couldn't read the name of the Shim.\n"));
            goto cleanup;
        }

        pFixWalk = pFixHead;

        while (pFixWalk != NULL) {
            if (!pFixWalk->bLayer) {
                if (lstrcmpi(pFixWalk->pszName, szShimName) == 0) {
                    parrShim[nInd] = pFixWalk;

                    //
                    // Now get the command line for this Shim in the layer.
                    //
                    tiName = SdbFindFirstTag(pdb, tiShim, TAG_COMMAND_LINE);

                    if (tiName != TAGID_NULL) {
                        parrCmdLine[nInd] = ReadAndAllocateString(pdb, tiName);
                    }

                    nInd++;
                    
                    break;
                }
            }
            
            pFixWalk = pFixWalk->pNext;
        }
        
        tiShim = SdbFindNextTag(pdb, tiLayer, tiShim);
    }
    
    pFix->pszName     = pszName;
    pFix->bLayer      = TRUE;
    pFix->bFlag       = FALSE;
    pFix->parrShim    = parrShim;
    pFix->parrCmdLine = parrCmdLine;

    return pFix;
}

BOOL
IsSDBFromSP2(
    void
    )
/*++
    IsSDBFromSP2

    Description:    Determine if the SDB is from Service Pack 2.

--*/
{
    BOOL    fResult = FALSE;
    PDB     pdb;
    TAGID   tiDatabase;
    TAGID   tiLibrary;
    TAGID   tiChild;
    PFIX    pFix;
    TCHAR   szSDBPath[MAX_PATH];

    if (!GetSystemWindowsDirectory(szSDBPath, MAX_PATH)) {
        return FALSE;
    }

    _tcscat(szSDBPath, _T("\\apppatch\\sysmain.sdb"));

    //
    // Open the shim database.
    //
    pdb = SdbOpenDatabase(szSDBPath, DOS_PATH);

    if (!pdb) {
        LogMsg(_T("[IsSDBFromSP2] Cannot open shim DB '%s'\n"), szSDBPath);
        return FALSE;
    }

    //
    // Now browse the shim DB and look only for tags Shim within
    // the LIBRARY list tag.
    //
    tiDatabase = SdbFindFirstTag(pdb, TAGID_ROOT, TAG_DATABASE);

    if (tiDatabase == TAGID_NULL) {
        LogMsg(_T("[IsSDBFromSP2] Cannot find TAG_DATABASE under the root tag\n"));
        goto Cleanup;
    }

    //
    // Get TAG_LIBRARY.
    //
    tiLibrary = SdbFindFirstTag(pdb, tiDatabase, TAG_LIBRARY);

    if (tiLibrary == TAGID_NULL) {
        LogMsg(_T("[IsSDBFromSP2] Cannot find TAG_LIBRARY under the TAG_DATABASE tag\n"));
        goto Cleanup;
    }

    //
    // Loop get the first shim in the library.
    //
    tiChild = SdbFindFirstTag(pdb, tiLibrary, TAG_SHIM);

    if (tiChild == NULL) {
        goto Cleanup;
    }

    //
    // Get information about the first shim listed.
    //
    pFix = ParseTagShim(pdb, tiChild, TRUE);

    if (NULL == pFix) {
        goto Cleanup;
    }

    //
    // If the first shim listed is 2GbGetDiskFreeSpace, this is SP2.
    //
    if (!(_tcsicmp(pFix->pszName, _T("2GbGetDiskFreeSpace.dll")))) {
        fResult = TRUE;
    }

Cleanup:
    SdbCloseDatabase(pdb);

    return (fResult);
}

PFIX
ReadFixesFromSdb(
    LPTSTR pszSdb,
    BOOL   bAllFixes
    )
/*++
    ReadFixesFromSdb

    Description:    Query the database and enumerate all available shims fixes.

--*/
{
    int     nLen = 0;
    TCHAR*  pszShimDB = NULL;
    PDB     pdb;
    TAGID   tiDatabase;
    TAGID   tiLibrary;
    TAGID   tiChild;
    PFIX    pFixHead = NULL;
    PFIX    pFix;

    nLen = lstrlen(pszSdb);

    if (0 == nLen) {
        LogMsg(_T("[ReadFixesFromSdb] Invalid SDB path passed through pszSdb\n"));
        return NULL;
    }

    pszShimDB = (TCHAR*)HeapAlloc(GetProcessHeap(),
                                  HEAP_ZERO_MEMORY,
                                  (nLen + MAX_PATH)*sizeof(TCHAR));

    if (pszShimDB == NULL) {
        LogMsg(_T("[ReadFixesFromSdb] Failed to allocate memory\n"));
        return NULL;
    }

    GetSystemWindowsDirectory(pszShimDB, MAX_PATH);
    lstrcat(pszShimDB, _T("\\AppPatch\\"));
    lstrcat(pszShimDB, pszSdb);

    //
    // Open the shim database.
    //
    pdb = SdbOpenDatabase(pszShimDB, DOS_PATH);

    if (!pdb) {
        LogMsg(_T("[ReadFixesFromSdb] Cannot open shim DB '%s'\n"), pszShimDB);
        return NULL;
    }

    //
    // Now browse the shim DB and look only for tags Shim within
    // the LIBRARY list tag.
    //
    tiDatabase = SdbFindFirstTag(pdb, TAGID_ROOT, TAG_DATABASE);

    if (tiDatabase == TAGID_NULL) {
        LogMsg(_T("[ReadFixesFromSdb] Cannot find TAG_DATABASE under the root tag\n"));
        goto Cleanup;
    }

    //
    // Get TAG_LIBRARY.
    //
    tiLibrary = SdbFindFirstTag(pdb, tiDatabase, TAG_LIBRARY);

    if (tiLibrary == TAGID_NULL) {
        LogMsg(_T("[ReadFixesFromSdb] Cannot find TAG_LIBRARY under the TAG_DATABASE tag\n"));
        goto Cleanup;
    }

    //
    // Loop through all TAG_SHIM tags within TAG_LIBRARY.
    //
    tiChild = SdbFindFirstTag(pdb, tiLibrary, TAG_SHIM);

    while (tiChild != TAGID_NULL) {
        pFix = ParseTagShim(pdb, tiChild, bAllFixes);

        if (pFix != NULL) {
            pFix->pNext = pFixHead;
            pFixHead    = pFix;
        }

        tiChild = SdbFindNextTag(pdb, tiLibrary, tiChild);
    }

    //
    // Loop through all TAG_FLAG tags within TAG_LIBRARY.
    //
    tiChild = SdbFindFirstTag(pdb, tiLibrary, TAG_FLAG);

    while (tiChild != TAGID_NULL) {
        pFix = ParseTagFlag(pdb, tiChild, bAllFixes);

        if (pFix != NULL) {
            pFix->pNext = pFixHead;
            pFixHead    = pFix;
        }

        tiChild = SdbFindNextTag(pdb, tiLibrary, tiChild);
    }

    //
    // Loop through all TAG_LAYER tags within TAG_DATABASE.
    //
    tiChild = SdbFindFirstTag(pdb, tiDatabase, TAG_LAYER);
    
    while (tiChild != TAGID_NULL) {
        
        pFix = ParseTagLayer(pdb, tiChild, pFixHead);
        
        if (pFix != NULL) {
            pFix->pNext = pFixHead;
            pFixHead    = pFix;
        }
        
        tiChild = SdbFindNextTag(pdb, tiDatabase, tiChild);
    }

Cleanup:
    SdbCloseDatabase(pdb);

    HeapFree(GetProcessHeap(), 0, pszShimDB);

    return pFixHead;
}

#define ADD_AND_CHECK(cbSizeX, cbCrtSizeX, pszDst)                  \
{                                                                   \
    TCHAR* pszSrc = szBuffer;                                       \
                                                                    \
    while (*pszSrc != 0) {                                          \
                                                                    \
        if (cbSizeX - cbCrtSizeX <= 5) {                            \
            LogMsg(_T("[ADD_AND_CHECK] Out of space.\n"));          \
            return FALSE;                                           \
        }                                                           \
                                                                    \
        if (*pszSrc == _T('&')) {                                   \
            lstrcpy(pszDst, _T("&amp;"));                           \
            pszDst += 5;                                            \
            cbCrtSizeX += 5;                                        \
        } else {                                                    \
            *pszDst++ = *pszSrc;                                    \
            cbCrtSizeX++;                                           \
        }                                                           \
        pszSrc++;                                                   \
    }                                                               \
    *pszDst = 0;                                                    \
    cbCrtSizeX++;                                                   \
}

BOOL
CollectShims(
	HWND    hListShims,
	LPTSTR  pszXML,
    LPCTSTR pszLayerName,
    BOOL    fAddW2K,
	int     cbSize
	)
/*++
    CollectShims

    Description:    Collects all the shims from the list view
                    and generates the XML in pszXML

--*/
{
    int     cShims = 0, nShimsApplied = 0, nIndex;
    int     cbCrtSize = 0;
    BOOL    fReturn = FALSE;
    LVITEM  lvi;
    TCHAR   szBuffer[1024];

    //
    // Build the header, then walk each of the shims and
    // determine if they're selected.
    //
    wsprintf(szBuffer, _T("    <LIBRARY>\r\n        <LAYER NAME=\"%s\">\r\n"), pszLayerName + 2);
    ADD_AND_CHECK(cbSize, cbCrtSize, pszXML);

    cShims = ListView_GetItemCount(hListShims);

    for (nIndex = 0; nIndex < cShims; nIndex++) {

        fReturn = ListView_GetCheckState(hListShims, nIndex);

        if (fReturn) {
            //
            // This shim is selected - add it to the XML. 
            //
            lvi.mask     = LVIF_PARAM;
            lvi.iItem    = nIndex;
            lvi.iSubItem = 0;

            ListView_GetItem(hListShims, &lvi);

            PFIX pFix = (PFIX)lvi.lParam;
            PMODULE pModule = pFix->pModule;
            
            if (pFix->bFlag) {
                wsprintf(szBuffer, _T("            <FLAG NAME=\"%s\"/>\r\n"),
                         pFix->pszName);
                
            } else {

                //
                // Check for module include/exclude so we know how to open/close the XML.
                //
                if (NULL != pModule) {

                    if (NULL != pFix->pszCmdLine) {
                    
                        wsprintf(szBuffer, _T("            <SHIM NAME=\"%s\" COMMAND_LINE=\"%s\">\r\n"),
                             pFix->pszName,
                             pFix->pszCmdLine);
                    
                    } else {

                        wsprintf(szBuffer, _T("            <SHIM NAME=\"%s\">\r\n"),
                             pFix->pszName);

                    }

                    ADD_AND_CHECK(cbSize, cbCrtSize, pszXML);
                    
                    //
                    // Add the modules to the XML.
                    //
                    while (NULL != pModule) {
                        wsprintf(szBuffer, _T("                <%s MODULE=\"%s\"/>\r\n"),
                                 pModule->fInclude ? _T("INCLUDE") : _T("EXCLUDE"),
                                 pModule->pszName);
        
                        pModule = pModule->pNext;
        
                        ADD_AND_CHECK(cbSize, cbCrtSize, pszXML);
                    }

                    //
                    // Close the SHIM tag.
                    //
                    wsprintf(szBuffer, _T("            </SHIM>\r\n"),
                         pFix->pszName);

                } else {

                    //
                    // No include/exclude was provided - just build the shim tag normally.
                    //
                    if (NULL != pFix->pszCmdLine) {
                    
                        wsprintf(szBuffer, _T("            <SHIM NAME=\"%s\" COMMAND_LINE=\"%s\"/>\r\n"),
                             pFix->pszName,
                             pFix->pszCmdLine);
                    
                    } else {

                        wsprintf(szBuffer, _T("            <SHIM NAME=\"%s\"/>\r\n"),
                             pFix->pszName);

                    }
                }
            }
            
            ADD_AND_CHECK(cbSize, cbCrtSize, pszXML);
            
            nShimsApplied++;
        }
    }

    //
    // If this is Windows 2000, add Win2kPropagateLayer.
    //
    if (fAddW2K) {
        lstrcpy(szBuffer, _T("            <SHIM NAME=\"Win2kPropagateLayer\"/>\r\n"));
        ADD_AND_CHECK(cbSize, cbCrtSize, pszXML);
    }

    LogMsg(_T("[CollectShims] %d shim(s) selected\n"), nShimsApplied);
    
    //
    // Close the open tags.
    //
    lstrcpy(szBuffer, _T("        </LAYER>\r\n    </LIBRARY>\r\n"));
    
    ADD_AND_CHECK(cbSize, cbCrtSize, pszXML);
    
    return TRUE;
}

BOOL
CollectFileAttributes(
    HWND    hTreeFiles,
    LPTSTR  pszXML,
    int     cbSize,
    LPCTSTR pszShortName,
    DWORD   binaryType
    )
/*++
    CollectFileAttributes

    Description:    Collects the attributes of all the files in the tree
                    and generates the XML in pszXML.

--*/
{
    HTREEITEM hBinItem;
    HTREEITEM hItem;
    PATTRINFO pAttrInfo;
    UINT      State;
    TVITEM    item;
    int       cbCrtSize = 0;
    TCHAR     szItem[MAX_PATH];
    TCHAR     szBuffer[1024];

    wsprintf(szBuffer,
             _T("    <APP NAME=\"%s\" VENDOR=\"Unknown\">\r\n")
             _T("        <%s NAME=\"%s\""),
             pszShortName,
             (binaryType == SCS_32BIT_BINARY ? _T("EXE") : _T("EXE - ERROR: 16 BIT BINARY")),
             pszShortName);
    
    ADD_AND_CHECK(cbSize, cbCrtSize, pszXML);
    
    //
    // First get the main EXE.
    //
    hBinItem = TreeView_GetChild(hTreeFiles, TVI_ROOT);

    item.mask  = TVIF_HANDLE | TVIF_PARAM | TVIF_TEXT;
    item.hItem = hBinItem;
    item.pszText    = szItem;
    item.cchTextMax = MAX_PATH;

    TreeView_GetItem(hTreeFiles, &item);

    pAttrInfo = (PATTRINFO)(item.lParam);

    hItem = TreeView_GetChild(hTreeFiles, hBinItem);

    while (hItem != NULL) {
        item.mask  = TVIF_HANDLE | TVIF_PARAM | TVIF_STATE | TVIF_TEXT;
        item.hItem = hItem;

        TreeView_GetItem(hTreeFiles, &item);

        State = item.state & TVIS_STATEIMAGEMASK;

        if (State) {
            if (((State >> 12) & 0x03) == 2) {

                wsprintf(szBuffer, _T(" %s"), (LPSTR)item.pszText);
                
                ADD_AND_CHECK(cbSize, cbCrtSize, pszXML);
            }
        }

        hItem = TreeView_GetNextSibling(hTreeFiles, hItem);
    }
    
    lstrcpy(szBuffer, _T(">\r\n"));

    ADD_AND_CHECK(cbSize, cbCrtSize, pszXML);
    
    //
    // Done with the main binary. Now enumerate the matching files.
    //
    hBinItem = TreeView_GetNextSibling(hTreeFiles, hBinItem);

    while (hBinItem != NULL) {

        item.mask       = TVIF_HANDLE | TVIF_PARAM | TVIF_STATE | TVIF_TEXT;
        item.hItem      = hBinItem;
        item.pszText    = szItem;
        item.cchTextMax = MAX_PATH;

        TreeView_GetItem(hTreeFiles, &item);

        pAttrInfo = (PATTRINFO)(item.lParam);

        wsprintf(szBuffer, _T("            <MATCHING_FILE NAME=\"%s\""), szItem);
        
        ADD_AND_CHECK(cbSize, cbCrtSize, pszXML);
        
        hItem = TreeView_GetChild(hTreeFiles, hBinItem);

        while (hItem != NULL) {
            item.mask  = TVIF_HANDLE | TVIF_PARAM | TVIF_STATE | TVIF_TEXT;
            item.hItem = hItem;

            TreeView_GetItem(hTreeFiles, &item);

            State = item.state & TVIS_STATEIMAGEMASK;

            if (State) {
                if (((State >> 12) & 0x03) == 2) {

                    wsprintf(szBuffer, _T(" %s"), (LPSTR)item.pszText);

                    ADD_AND_CHECK(cbSize, cbCrtSize, pszXML);
                }
            }

            hItem = TreeView_GetNextSibling(hTreeFiles, hItem);
        }
        
        lstrcpy(szBuffer, _T("/>\r\n"));
        
        ADD_AND_CHECK(cbSize, cbCrtSize, pszXML);

        hBinItem = TreeView_GetNextSibling(hTreeFiles, hBinItem);
    }
    
    return TRUE;
}

BOOL
CreateSDBFile(
    LPCTSTR pszShortName,
    LPTSTR  pszSDBName
    )
/*++
    CreateSDBFile

    Description:    Creates the XML file on the user's hard drive and
                    generates the SDB using shimdbc.
--*/
{
    TCHAR*  psz = NULL;
    TCHAR*  pszTemp = NULL;
    TCHAR   szXMLFile[128];
    TCHAR   szSDBFile[128];
    TCHAR   szAppPatchDir[MAX_PATH] = _T("");
    WCHAR   szCompiler[MAX_PATH];
    HANDLE  hFile;
    DWORD   dwBytesWritten = 0;

    //
    // Create the XML file.
    //
    GetSystemWindowsDirectory(szAppPatchDir, MAX_PATH);
    lstrcat(szAppPatchDir, _T("\\AppPatch"));

    SetCurrentDirectory(szAppPatchDir);

    pszTemp = (TCHAR*)HeapAlloc(GetProcessHeap(),
                                HEAP_ZERO_MEMORY,
                                (lstrlen(pszShortName)+1)*sizeof(TCHAR));

    if (NULL == pszTemp) {
        LogMsg(_T("[CreateSDBFile] Failed to allocate memory\n"));
        return FALSE;
    }

    lstrcpy(pszTemp, pszShortName);

    psz = PathFindExtension(pszTemp);

    if (NULL == psz) {
        return FALSE;
    } else {
        *psz = '\0';
    }

    // Build the XML file path
    wsprintf(szXMLFile, _T("%s\\%s.xml"), szAppPatchDir, pszTemp);

    // Build the SDB file path
    wsprintf(szSDBFile, _T("%s\\%s.sdb"), szAppPatchDir, pszTemp);    

    hFile = CreateFile(szXMLFile,
                       GENERIC_WRITE,
                       0,
                       NULL,
                       CREATE_ALWAYS,
                       FILE_ATTRIBUTE_NORMAL,
                       NULL);

    if (hFile == INVALID_HANDLE_VALUE) {
        LogMsg(_T("[CreateSDBFile] CreateFile '%s' failed 0x%X.\n"),
               szXMLFile, GetLastError());
        return FALSE;
    }

    if (!(WriteFile(hFile,
                    g_szXML,
                    lstrlen(g_szXML) * sizeof(TCHAR),
                    &dwBytesWritten,
                    NULL))) {
        LogMsg(_T("[CreateSDBFile] WriteFile '%s' failed 0x%X.\n"),
               szXMLFile, GetLastError());
        CloseHandle(hFile);
        return FALSE;
    }

    CloseHandle(hFile);

    //
    // Set up the command line for shimdbc and generate an SDB.
    //
    wsprintf(szCompiler,
             _T("shimdbc.exe fix -q \"%s\" \"%s\""),
             szXMLFile,
             szSDBFile);
    
    if (!ShimdbcExecute(szCompiler)) {
        LogMsg(_T("[CreateSDBFile] CreateProcess \"%s\" failed 0x%X\n"),
               szCompiler, GetLastError());
        return FALSE;
    }

    // Give the SDB name back to the caller if they want it.
    if (pszSDBName) {
        lstrcpy(pszSDBName, szSDBFile); 
    }

    return TRUE;
}

BOOL
CollectFix(
    HWND    hListLayers,
    HWND    hListShims,
    HWND    hTreeFiles,
    LPCTSTR pszShortName,
    LPCTSTR pszFullPath,
    DWORD   dwFlags,
    LPTSTR  pszFileCreated
    )
/*++
    CollectFix

    Description:    Adds the necessary support to apply shim(s) for
                    the specified app.
--*/
{
    BOOL      fAddW2K = FALSE;
    TCHAR*    pszXML;
    TCHAR     szError[MAX_PATH];
    TCHAR     szXmlFile[MAX_PATH];
    TCHAR*    pszLayerName = NULL;
    TCHAR     szBuffer[1024];
    TCHAR     szLayer[128] = _T("!#");
    TCHAR     szUnicodeHdr[2] = { 0xFEFF, 0 };
    int       cbCrtXmlSize = 0, cbLength;
    int       cbXmlSize = MAX_XML_SIZE;
    DWORD     dwBinaryType = SCS_32BIT_BINARY;

    g_szXML[0]   = 0;
    pszXML   = g_szXML;
    
    //
    // Create a layer to run all the apps under it.
    //
    if (dwFlags & CFF_USELAYERTAB) {
        
        LRESULT lSel;
        
        lSel = SendMessage(hListLayers, LB_GETCURSEL, 0, 0);

        if (lSel == LB_ERR) {
            LoadString(g_hInstance, IDS_LAYER_SELECT, szError, MAX_PATH);
            MessageBox(g_hDlg, szError, g_szAppTitle, MB_OK | MB_ICONEXCLAMATION);
            return TRUE;
        }

        SendMessage(hListLayers, LB_GETTEXT, lSel, (LPARAM)(szLayer + 2));
        
        pszLayerName = szLayer;
    } else {
        pszLayerName = g_szQFixAppLayerName;
    }

    //
    // Determine the binary type.
    //
    GetBinaryType(pszFullPath, &dwBinaryType);
    
    //
    // Build the header for the XML.
    //
    wsprintf(szBuffer,
             _T("%s<?xml version=\"1.0\" encoding=\"UTF-16\"?>\r\n")
             _T("<DATABASE NAME=\"%s custom database\">\r\n"),
             szUnicodeHdr,
             pszShortName);
    
    
    ADD_AND_CHECK(cbXmlSize, cbCrtXmlSize, pszXML);

    //
    // If this is Windows 2000 and they're not using
    // a predefined layer, add Win2kPropagateLayer.
    //
    if ((dwFlags & CFF_ADDW2KSUPPORT) && !(dwFlags & CFF_USELAYERTAB)) {
        fAddW2K = TRUE;
    }

    //
    // If we're not using a predefined layer, build one manually.
    //
    if (!(dwFlags & CFF_USELAYERTAB)) {
        CollectShims(hListShims,
                     pszXML,
                     pszLayerName,
                     fAddW2K,
                     cbXmlSize - cbCrtXmlSize);
    }

    cbLength = lstrlen(pszXML);
    pszXML += cbLength;
    cbCrtXmlSize += cbLength + 1;

    //
    // Retrieve attributes and matching files from the tree.
    // If we're displaying the XML, pass the real binary type.
    // If we're not, which means we're creating fix support or
    // running the application, let the callee think it's a 32-bit module.
    //
    if (dwFlags & CFF_SHOWXML) {
        CollectFileAttributes(hTreeFiles,
                              pszXML,
                              cbXmlSize - cbCrtXmlSize,
                              pszShortName,
                              dwBinaryType);
    } else {
        CollectFileAttributes(hTreeFiles,
                              pszXML,
                              cbXmlSize - cbCrtXmlSize,
                              pszShortName,
                              SCS_32BIT_BINARY);

    }
    
    cbLength = lstrlen(pszXML);
    pszXML += cbLength;
    cbCrtXmlSize += cbLength + 1;

    //
    // Add our layer to this EXE. 
    //
    wsprintf(szBuffer, _T("            <LAYER NAME=\"%s\"/>\r\n"), pszLayerName + 2);
    ADD_AND_CHECK(cbXmlSize, cbCrtXmlSize, pszXML);

    //
    // Finally, close the open tags.
    //    
    lstrcpy(szBuffer, _T("        </EXE>\r\n    </APP>\r\n</DATABASE>"));
    ADD_AND_CHECK(cbXmlSize, cbCrtXmlSize, pszXML);
        
    LogMsg(_T("[CollectFix] XML:\n%s\n"), g_szXML);

    //
    // Display the XML if the user wants to see it.
    //
    if (dwFlags & CFF_SHOWXML) {
        DialogBoxParam(g_hInstance,
                       MAKEINTRESOURCE(IDD_XML),
                       g_hDlg,
                       ShowXMLDlgProc,
                       (LPARAM)(g_szXML + 1));
        return TRUE;
    }

    //
    // Create the SDB file for the user.
    //
    if (!(CreateSDBFile(pszShortName, pszFileCreated))) {
        return FALSE;
    }

    //
    // Delete the XML file that we created.
    //
    lstrcpy(szXmlFile, pszFileCreated);
    PathRenameExtension(szXmlFile, _T(".xml"));
    DeleteFile(szXmlFile);

    //
    // Set the SHIM_FILE_LOG env var.
    //
    if (dwFlags & CFF_SHIMLOG) {
        DeleteFile(SHIM_FILE_LOG_NAME);
        SetEnvironmentVariable(_T("SHIM_FILE_LOG"), SHIM_FILE_LOG_NAME);
    }

    return TRUE;
}

void
CleanupSupportForApp(
    TCHAR* pszShortName
    )
/*++
    CleanupSupportForApp

    Description:    Cleanup the mess after we're done with
                    the specified app.
--*/
{
    TCHAR*  pszShimDB = NULL;
    int     nLen = 0;

    nLen = lstrlen(pszShortName);

    pszShimDB = (TCHAR*)HeapAlloc(GetProcessHeap(),
                                  HEAP_ZERO_MEMORY,
                                  (nLen + MAX_PATH)*sizeof(TCHAR));

    if (NULL == pszShimDB) {
        LogMsg(_T("[CleanupSupportForApp] Failed to allocate memory\n"));
        return;
    }
    
    GetSystemWindowsDirectory(pszShimDB, MAX_PATH);
    lstrcat(pszShimDB, _T("\\AppPatch"));

    SetCurrentDirectory(pszShimDB);

    lstrcat(pszShimDB, _T("\\"));
    lstrcat(pszShimDB, pszShortName);

    //
    // Attempt to delete the XML file.
    //
    PathRenameExtension(pszShimDB, _T(".xml"));

    DeleteFile(pszShimDB);

    //
    // Remove the previous SDB file, if one exists.
    //
    if (g_szSDBToDelete[0]) {
        InstallSDB(g_szSDBToDelete, FALSE);
        DeleteFile(g_szSDBToDelete);
    }

    HeapFree(GetProcessHeap(), 0, pszShimDB);
}

void
ShowShimLog(
    void
    )
/*++
    ShowShimLog

    Description:    Show the shim log file in notepad.

--*/
{
    STARTUPINFO         si;
    PROCESS_INFORMATION pi;
    TCHAR               szCmd[MAX_PATH] = _T("");
    TCHAR               szError[MAX_PATH];

    GetSystemWindowsDirectory(szCmd, MAX_PATH);

    SetCurrentDirectory(szCmd);

    if (GetFileAttributes(_T("AppPatch\\") SHIM_FILE_LOG_NAME) == -1) {
        LoadString(g_hInstance, IDS_NO_LOGFILE, szError, MAX_PATH);
        MessageBox(NULL, szError, g_szAppTitle, MB_ICONEXCLAMATION | MB_OK);
        return;
    }

    lstrcat(szCmd, _T("\\notepad.exe AppPatch\\") SHIM_FILE_LOG_NAME);

    ZeroMemory(&si, sizeof(si));
    si.cb = sizeof(si);

    if (!CreateProcess(NULL,
                       szCmd,
                       NULL,
                       NULL,
                       FALSE,
                       NORMAL_PRIORITY_CLASS | CREATE_NO_WINDOW,
                       NULL,
                       NULL,
                       &si,
                       &pi)) {

        LogMsg(_T("[ShowShimLog] CreateProcess \"%s\" failed 0x%X\n"),
               szCmd, GetLastError());
        return;
    }

    CloseHandle(pi.hThread);
    CloseHandle(pi.hProcess);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\appcompat\tools\qfixapp\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by QFixApp.rc
//
#define IDS_MATCH_PATH_NOT_RELATIVE     1
#define IDS_BUFFER_ALLOC_FAIL           2
#define IDS_FILE_CREATE_FAIL            3
#define IDC_ADD                         3
#define IDS_SDB_READ_FAIL               4
#define IDC_REMOVE                      4
#define IDS_FIX_CREATE_FAIL             5
#define IDS_TOO_MANY_FILES              6
#define IDS_ADD_SUPPORT_FAIL            7
#define IDS_LAYER_SELECT                9
#define IDS_NO_LOGFILE                  10
#define IDS_NO_SELECTION                12
#define IDS_NO_MOD                      13
#define IDS_NO_INCEXC                   14
#define IDS_W2K_NO_SDB                  15
#define IDS_SP2_SDB                     16
#define IDS_CREATE_FIX                  17
#define IDS_INSTALL_FIX_FAIL            18
#define IDS_INSTALL_FIX_OK              19
#define IDS_W2K_LINK                    21
#define IDS_XP_LINK                     22
#define IDS_NO_16BIT                    23
#define IDS_NOT_ADMIN                   24
#define IDS_MSG_LINK                    25
#define IDS_INVALID_CMD_LINE            26
#define IDS_TAB_FIRST_TEXT              27
#define IDS_TAB_SECOND_TEXT             28
#define IDS_INCLUDE_HDR                 29
#define IDS_EXCLUDE_HDR                 30
#define IDS_SEL_CAPTION                 31
#define IDS_FIXNAME_COLUMN              32
#define IDS_CMDLINE_COLUMN              33
#define IDS_MODULE_COLUMN               34
#define IDS_XP_NO_SDB                   35
#define IDS_SAVE_FILTER                 36
#define IDS_APP_TITLE                   37
#define IDS_BROWSE_FILTER               38
#define IDS_BROWSE_TITLE                39
#define IDS_MATCH_FILTER                40
#define IDS_MATCH_TITLE                 41
#define IDS_PARENT_TITLE                42
#define IDS_SIMPLE_TEXT                 43
#define IDS_ADVANCED_TEXT               44
#define IDS_MOD_TYPE                    45
#define IDS_MOD_NAME                    46
#define IDS_OPTIONS_TITLE               47
#define IDS_TAB_SETUP_FAIL              48
#define IDS_REPLACE_FILE                49
#define IDS_NO_DESCR_AVAIL              50
#define IDD_DIALOG                      101
#define IDI_ICON                        102
#define IDD_XML                         103
#define IDB_BMP_CHECK                   104
#define IDM_ATTR_POPUP                  106
#define IDD_OPTIONS                     109
#define IDD_MSGBOX_SDB                  111
#define IDI_EXCLAIM                     112
#define IDD_MSGBOX_SP2                  113
#define IDD_LAYERS_TAB                  114
#define IDD_FIXES_TAB                   115
#define IDC_BINARY                      1000
#define IDC_XML                         1000
#define IDC_BROWSE                      1001
#define IDC_MOD_LIST                    1001
#define IDC_SHIMS                       1002
#define IDC_SHIM_DESCRIPTION            1003
#define IDC_RUN                         1004
#define IDC_DETAILS                     1005
#define IDC_ATTRIBUTES                  1007
#define IDC_REMOVE_MATCHING             1008
#define IDC_FILE_ATTRIBUTES_STATIC      1009
#define IDC_CREATEFILE                  1010
#define IDC_SHOWXML                     1011
#define IDC_SELECTED_SHIMS              1012
#define IDC_TAB_FIXES                   1014
#define IDC_CMD_LINE                    1015
#define IDC_VIEW_LOG                    1016
#define IDC_LAYERS                      1018
#define IDC_CLEAR_SHIMS                 1022
#define IDC_SHIM_CMD_LINE               1023
#define IDC_ADD_MATCHING                1024
#define IDC_SAVE_XML                    1026
#define IDC_MOD_NAME                    1032
#define IDC_DOWNLOAD_WU                 1033
#define IDC_INCLUDE                     1038
#define IDC_EXCLUDE                     1039
#define IDC_MESSAGE                     1043
#define IDC_MSG_LINK                    1044
#define IDM_SELECT_ALL                  40003
#define IDM_CLEAR_ALL                   40004

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        116
#define _APS_NEXT_COMMAND_VALUE         40002
#define _APS_NEXT_CONTROL_VALUE         1050
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\appcompat\tools\sdbinst\resource.h ===
#define IDS_APP_TITLE                       500
#define IDS_APP_ERROR_TITLE                 501


#define IDS_HELP_TEXT                       1000
#define IDS_UNABLE_TO_GET_FILE              1001
#define IDS_UNABLE_TO_OPEN_FILE             1002
#define IDS_NO_DB_TAG                       1003
#define IDS_NO_DB_ID                        1004
#define IDS_CANT_INSTALL_SYS                1005
#define IDS_ALREADY_INSTALLED               1006
#define IDS_NOT_INSTALLED                   1007
#define IDS_NEED_INSTALL_PERMISSION         1008
#define IDS_CANT_CREATE_REG_KEY             1009
#define IDS_NO_EXE_NAME                     1010
#define IDS_NO_EXE_NAME_PTR                 1011
#define IDS_CANT_CREATE_VALUE               1012
#define IDS_NEED_UNINSTALL_PERMISSION       1013
#define IDS_CANT_OPEN_REG_KEY               1014
#define IDS_CANT_DELETE_REG_KEY             1015
#define IDS_CANT_DELETE_REG_VALUE           1016
#define IDS_CANT_COPY_FILE                  1017
#define IDS_CANT_DELETE_FILE                1018
#define IDS_INSTALL_COMPLETE                1019
#define IDS_UNINSTALL_COMPLETE              1020
#define IDS_CANT_GET_ARGS                   1021
#define IDS_INVALID_SWITCH                  1022
#define IDS_TOO_MANY_ARGS                   1023
#define IDS_MUST_SPECIFY_SDB                1024
#define IDS_CANT_GET_FULL_PATH              1025
#define IDS_FOUND_SAME_ID                   1026
#define IDS_FAILED_UNINSTALL                1027
#define IDS_NEED_ARG                        1028
#define IDS_NO_FRIENDLY_NAME                1029
#define IDS_GUID_BAD_FORMAT                 1030
#define IDS_MISSING_PACKAGE_ID              1031
#define IDS_BUFFER_TOO_SMALL                1032
#define IDS_CANT_REGISTER_DB                1033
#define IDS_CANT_UNREGISTER_DB              1034
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\appcompat\tools\runcompat\runcompat.cpp ===
/*++

 Copyright (c) 2000 Microsoft Corporation

 Module Name:

   runcompat.cpp

 Abstract:

   This app sets an environment variable that tells the compat system in Whistler to run
   an app using a predefined set of fixes, called a "layer."

   Usage is:
      
        runcompat name_of_layer command_line

   Example:

        runcompat win95 notepad foo.txt

 Created:

   06/06/2000   dmunsil

 Modified:



--*/

#define UNICODE
#define _UNICODE

#include <windows.h>
#include <shellapi.h>
#include <stdio.h>
#include <stdlib.h>
#include "commdlg.h"
#include "resource.h"

extern "C" {
#include "shimdb.h"
}

// defines
const int MAX_COMMAND_LINE = 1000;
const int MAX_LAYER = 100;

// globals
WCHAR       gszCommandLine[MAX_COMMAND_LINE] = L"";
WCHAR       gszLayerName[MAX_LAYER] = L"";
BOOL        gbEnableLog = FALSE;
BOOL        gbDisableExisting = FALSE;
BOOL        gbCreateRegistryStub = FALSE;

HINSTANCE   ghInstance = NULL;

// forward function declarations
LRESULT CALLBACK DlgMain(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam);
void ViewFileLog(void);
void ClearFileLog(void);
void RunThatApp(void);
void GetNewCommandLine(HWND hDlg);
void EnumerateLayers(HWND hDlg);
void ParseFileLog(HWND hDlg);
LRESULT CALLBACK DlgParseLog(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam);
void ShowHelp(void);


extern "C" int APIENTRY wWinMain(HINSTANCE hInstance,
                                 HINSTANCE hPrevInstance,
                                 LPWSTR     lpCmdLine,
                                 int       nCmdShow)
{
    LPWSTR              *pszCommandItems = NULL;
    int                 nArgs = 0;
    int                 i;
    WCHAR               *szExt;
    DWORD               dwLen = 0;
    BOOL                bShowUI = FALSE;
    OSVERSIONINFO       osvi;

    ghInstance = hInstance;
    
    osvi.dwOSVersionInfoSize = sizeof(osvi);

    GetVersionEx(&osvi);

    if (osvi.dwMajorVersion == 5 && osvi.dwMinorVersion == 0) {
        //
        // It runs on Win2k. Make sure to create the stub registry entry for
        // the first EXE
        //
        gbCreateRegistryStub = TRUE;
    }
    
    if (!lpCmdLine || !lpCmdLine[0]) {
        bShowUI = TRUE;
    }
    
    pszCommandItems = CommandLineToArgvW(lpCmdLine, &nArgs);
    
    if (!pszCommandItems) {
        bShowUI = TRUE;
    } else {
        if (pszCommandItems[0][0] == '-' || pszCommandItems[0][0] == '/') {
            if (pszCommandItems[0][1] == '?' || pszCommandItems[0][1] == 'h' || pszCommandItems[0][1] == 'H') {
                ShowHelp();
                goto out;
            }
        }

        if (nArgs <= 1) {
            bShowUI = TRUE;
        } 
        if (nArgs >= 1) {
            wcscpy(gszLayerName, pszCommandItems[0]);
        }
    }
    
    if (bShowUI) {
        HWND hMainDlg = CreateDialog(hInstance, (LPCTSTR)IDD_MAIN, NULL, (DLGPROC)DlgMain);
        MSG msg;
        
        // Main message loop:
        while (GetMessage(&msg, NULL, 0, 0)) 
        {
            if (!IsDialogMessage(hMainDlg, &msg)) {
                TranslateMessage(&msg);
                DispatchMessage(&msg);
            }
        }
    } else {
        if (gszLayerName[0] == '!') {
            // strip the bang, even though we'll put it back later,
            // just so we disconnect the input syntax from the output syntax. That way we
            // can change one or the other separately.
            memmove(gszLayerName, gszLayerName + 1, wcslen(gszLayerName) * sizeof(WCHAR));
            gbDisableExisting = TRUE;
        } else {
            gbDisableExisting = FALSE;
        }

        wcscpy(gszCommandLine, pszCommandItems[1]);
        for (i = 2; i < nArgs; ++i) {
            wcscat(gszCommandLine, L" ");
            wcscat(gszCommandLine, pszCommandItems[i]);
        }
        
        RunThatApp();
        
    }
    
out:
    if (pszCommandItems) {
        GlobalFree((HGLOBAL)pszCommandItems);
    }
    
    return 0;
}

// Message handler for main dialog.
LRESULT CALLBACK DlgMain(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam)
{
    HDC hDC;
    
    switch (message)
    {
    case WM_INITDIALOG:
        {
            CheckDlgButton(hDlg, IDC_CHECK_LOG, BST_CHECKED);
            EnumerateLayers(hDlg);
            
            HWND hEdit = GetDlgItem(hDlg, IDC_EDIT_COMMAND_LINE);
            if (hEdit) {
                SetFocus(hEdit);
            }
            
            // we set the focus manually, so we can return FALSE here.
            return FALSE;
        }
        break;
        
    case WM_COMMAND:
        switch LOWORD(wParam) {
            
        case IDC_BUTTON_VIEW_LOG:
            ViewFileLog();
            break;
            
        case IDC_BUTTON_CLEAR_LOG:
            ClearFileLog();
            break;
            
        case IDC_BUTTON_PARSE_LOG:
            DialogBox(ghInstance, MAKEINTRESOURCE(IDD_LOG_INFO), hDlg, (DLGPROC)DlgParseLog);
            break;
            
        case IDC_BUTTON_BROWSE:
            GetNewCommandLine(hDlg);
            break;
            
        case IDC_BUTTON_HELP:
            ShowHelp();
            break;
            
        case IDOK:
            {
                int nSel;
                
                GetDlgItemText(hDlg, IDC_EDIT_COMMAND_LINE, gszCommandLine, MAX_COMMAND_LINE);
                gbEnableLog = (IsDlgButtonChecked(hDlg, IDC_CHECK_LOG) == BST_CHECKED);
                gbDisableExisting = (IsDlgButtonChecked(hDlg, IDC_CHECK_DISABLE_EXISTING) == BST_CHECKED);
                
                nSel = (int)SendDlgItemMessage(hDlg, IDC_LIST_LAYER, LB_GETCURSEL, 0, 0);
                if (nSel != LB_ERR) {
                    if (LB_ERR != SendDlgItemMessage(hDlg, IDC_LIST_LAYER, LB_GETTEXT, nSel, (LPARAM)gszLayerName)) {
                        RunThatApp();
                    }
                }
            }
            break;
            
        case IDCANCEL:
            EndDialog(hDlg, LOWORD(wParam));
            PostQuitMessage(0);
            return TRUE;
            break;
        }
    }
    return FALSE;
}

#define APPCOMPAT_KEY L"System\\CurrentControlSet\\Control\\Session Manager\\AppCompatibility"

void
AddRegistryStubForExe(
    void)
{
    BOOL   bBraket = FALSE;
    WCHAR* pwsz = gszCommandLine;
    WCHAR  wszExeName[128];

    while (*pwsz == L' ' || *pwsz == L'\t') {
        pwsz++;
    }

    while (*pwsz != 0) {

        if (*pwsz == L'\"') {
            bBraket = !bBraket;
        } else if (*pwsz == L' ' && !bBraket) {
            break;
        }

        pwsz++;
    }
    //
    // Now walk back to get the caracters
    //
    pwsz--;

    if (*pwsz == L'\"') {
        pwsz--;
    }

    WCHAR* pwszEnd;
    WCHAR* pwszStart = gszCommandLine;

    pwszEnd = pwsz + 1;

    while (pwsz >= gszCommandLine) {
        if (*pwsz == L'\\') {
            pwszStart = pwsz + 1;
            break;
        }
        pwsz--;
    }

    memcpy(wszExeName, pwszStart, (pwszEnd - pwszStart) * sizeof(WCHAR));

    wszExeName[pwszEnd - pwszStart] = 0;

    WCHAR wszKey[256];
    HKEY  hkey;
    DWORD type;
    DWORD cbData = 0;
    
    swprintf(wszKey, L"%s\\%s", APPCOMPAT_KEY, wszExeName);
    
    if (RegCreateKeyW(HKEY_LOCAL_MACHINE, wszKey, &hkey) != ERROR_SUCCESS) {
        // DPF_Log((eDbgLevelError, "Failed to open/create the appcompat key \"%s\"", szKey));
    } else {
        if (RegQueryValueExW(hkey, L"DllPatch-x", NULL, &type, NULL, &cbData) != ERROR_SUCCESS) {
            
            BYTE data[16] = {0x0c, 0, 0, 0, 0, 0, 0, 0,
                             0x06, 0, 0, 0, 0, 0, 0, 0};
            
            //
            // The value doesn't exist. Create it.
            //
            RegSetValueExW(hkey,
                           L"y",
                           NULL,
                           REG_BINARY,
                           data,
                           sizeof(data));

            data[0] = 0;

            RegSetValueExW(hkey,
                           L"DllPatch-y",
                           NULL,
                           REG_SZ,
                           data,
                           2);
        }
    }


    RegCloseKey(hkey);
}

void RunThatApp(void)
{
    STARTUPINFO         StartupInfo;
    PROCESS_INFORMATION ProcessInfo;
    SHELLEXECUTEINFO    ShellExecuteInfo;
    WCHAR               szLayer[MAX_LAYER];
    BOOL                bSuccess = TRUE;
    int                 nExt = 0;
    WCHAR               *szExt = NULL;

    // put a bang on the front if we're supposed to disable the existing
    // shims in the database
    if (gbDisableExisting) {
        wcscpy(szLayer, L"!");
    } else {
        szLayer[0] = 0;
    }
    wcscat(szLayer, gszLayerName);
    
    SetEnvironmentVariable(L"__COMPAT_LAYER", szLayer);
    
    if (gbEnableLog) {
        SetEnvironmentVariable(L"SHIM_FILE_LOG", L"shim.log");
    } else {
        SetEnvironmentVariable(L"SHIM_FILE_LOG", NULL);
    }

    if (gbCreateRegistryStub) {
        AddRegistryStubForExe();
    }
    
    // if the whole command line is a shell link, use
    // ShellExecuteEx, but otherwise use CreateProcess
    // for its simpler command-line handling

    nExt = wcslen(gszCommandLine) - 4;
    szExt = gszCommandLine + nExt;
    if (nExt > 0 && _wcsicmp(szExt, L".lnk") == 0) {

        ZeroMemory(&ShellExecuteInfo, sizeof(ShellExecuteInfo));
        ShellExecuteInfo.cbSize = sizeof(ShellExecuteInfo);
        ShellExecuteInfo.fMask = SEE_MASK_FLAG_NO_UI;
        ShellExecuteInfo.lpVerb = L"open";
        ShellExecuteInfo.lpFile = gszCommandLine;
        ShellExecuteInfo.nShow = SW_SHOW;

        bSuccess = ShellExecuteEx(&ShellExecuteInfo);

    } else {

        //
        // try to get the starting directory
        //
        LPWSTR *argv;
        int argc;
        WCHAR szWorkingBuffer[MAX_PATH];
        WCHAR *pszWorkingDir = NULL;

        //
        // try to get the starting directory
        //
        argv = CommandLineToArgvW(gszCommandLine, &argc);
        if (argv && argv[0] && argv[0][0] && argc) {

            //
            // we only set the working directory if they give us a full path.
            //
            if (argv[0][1] == L':' || argv[0][1] == L'\\') {

                //
                // get the working directory, if possible
                //
                WCHAR *szTemp = wcsrchr(argv[0], L'\\');
                if (szTemp) {
                    wcsncpy(szWorkingBuffer, argv[0], szTemp - argv[0]);
                    szWorkingBuffer[szTemp - argv[0]] = 0;
                    pszWorkingDir = szWorkingBuffer;
                }
            }

            GlobalFree(argv);
            argv = NULL;
        }

        ZeroMemory(&StartupInfo, sizeof(StartupInfo));
        StartupInfo.cb = sizeof(StartupInfo);
        ZeroMemory(&ProcessInfo, sizeof(ProcessInfo));
    
        bSuccess = TRUE;
        if (!CreateProcess(NULL,
            gszCommandLine,
            NULL,
            NULL,
            FALSE,
            0,
            NULL,
            pszWorkingDir,
            &StartupInfo,
            &ProcessInfo)) {

            bSuccess = FALSE;
        }
    }

    if (!bSuccess) {
        DWORD dwErr;
        WCHAR szMsg[1000];
        WCHAR szErr[1000];
        
        dwErr = GetLastError();
        
        if (!FormatMessage( 
            FORMAT_MESSAGE_FROM_SYSTEM | 
            FORMAT_MESSAGE_IGNORE_INSERTS,
            NULL,
            dwErr,
            MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT), // Default language
            szErr,
            999,
            NULL )) {

            wcscpy(szErr, L"(unknown)");
        }
        
        wsprintf(szMsg, L"Error 0x%08X:\n\n%s\nwhile executing command line \"%s\".", dwErr, szErr, gszCommandLine);
        MessageBox(NULL, szMsg, L"Error", MB_OK | MB_ICONEXCLAMATION); 
    }
    
    
    SetEnvironmentVariable(L"__COMPAT_LAYER", NULL);
    SetEnvironmentVariable(L"SHIM_FILE_LOG", NULL);
}

void GetNewCommandLine(HWND hDlg)
{
    OPENFILENAME ofn;
    WCHAR szFullPath[1000];
    
    szFullPath[0] = L'\0';
    
    ZeroMemory(&ofn, sizeof(OPENFILENAME));
    ofn.lStructSize = sizeof(OPENFILENAME);
    ofn.hwndOwner = hDlg;
    ofn.lpstrFile = szFullPath;
    ofn.nMaxFile = sizeof(szFullPath)/sizeof(szFullPath[0]);
    ofn.lpstrFilter = L"Exe\0*.EXE\0All\0*.*\0";
    ofn.nFilterIndex = 1;
    ofn.lpstrTitle = L"Select EXE to run";
    ofn.Flags = OFN_PATHMUSTEXIST | OFN_FILEMUSTEXIST | OFN_NODEREFERENCELINKS;
    
    // get the matching file name 
    if (GetOpenFileName(&ofn) == FALSE) {
        return;
    }

    if (wcschr(szFullPath, L' ')) {
        //
        // if there are spaces in the path, quote the whole thing.
        //
        WCHAR szFullPathTemp[1002];
        swprintf(szFullPathTemp, L"\"%s\"", szFullPath);
        wcscpy(szFullPath, szFullPathTemp);
    }

    
    SetDlgItemText(hDlg, IDC_EDIT_COMMAND_LINE, szFullPath);
    
}

void ViewFileLog(void)
{
    STARTUPINFO         StartupInfo;
    PROCESS_INFORMATION ProcessInfo;
    WCHAR szCommand[1000];
    
    // make sure we aren't shimming Notepad.
    SetEnvironmentVariable(L"__COMPAT_LAYER", NULL);
    SetEnvironmentVariable(L"SHIM_FILE_LOG", NULL);
    
    ZeroMemory(&StartupInfo, sizeof(StartupInfo));
    StartupInfo.cb = sizeof(StartupInfo);
    ZeroMemory(&ProcessInfo, sizeof(ProcessInfo));
    
    ExpandEnvironmentStringsW(L"notepad %windir%\\AppPatch\\shim.log", szCommand, 1000);
    
    CreateProcess(NULL,
        szCommand,
        NULL,
        NULL,
        FALSE,
        0,
        NULL,
        NULL,
        &StartupInfo,
        &ProcessInfo);
}

void ClearFileLog(void)
{
    WCHAR szPath[1000];
    WCHAR szMsg[1000];
    
    ExpandEnvironmentStringsW(L"%windir%\\AppPatch\\shim.log", szPath, 1000);
    
    DeleteFile(szPath);
    
    wsprintf(szMsg, L"Deleted file \"%s\".", szPath);
    
    MessageBox(NULL, szMsg, L"Cleared Log", MB_OK); 
}

void EnumerateLayers(HWND hDlg)
{
    PDB pdb = NULL;
    WCHAR wszPath[MAX_PATH];
    HWND hList;
    TAGID tiDatabase;
    TAGID tiLayer;
    
    hList = GetDlgItem(hDlg, IDC_LIST_LAYER);
    if (!hList) {
        goto out;
    }
    
    ExpandEnvironmentStringsW(L"%windir%\\AppPatch\\sysmain.sdb", wszPath, MAX_PATH);
    
    pdb = SdbOpenDatabase(wszPath, DOS_PATH);
    if (!pdb) {
        goto out;
    }
    
    tiDatabase = SdbFindFirstTag(pdb, TAGID_ROOT, TAG_DATABASE);
    if (!tiDatabase) {
        goto out;
    }
    
    tiLayer = SdbFindFirstTag(pdb, tiDatabase, TAG_LAYER);
    while (tiLayer) {
        TAGID tiName;
        WCHAR wszName[MAX_PATH];
        
        wszName[0] = 0;
        tiName = SdbFindFirstTag(pdb, tiLayer, TAG_NAME);
        if (tiName) {
            
            SdbReadStringTag(pdb, tiName, wszName, MAX_PATH * sizeof(WCHAR));
        }
        if (wszName[0]) {
            SendMessageW(hList, LB_ADDSTRING, 0, (LPARAM)wszName);
        }
        
        tiLayer = SdbFindNextTag(pdb, tiDatabase, tiLayer);
    }
    
out:
    if (pdb) {
        SdbCloseDatabase(pdb);
    }
    
    // select the first item that begins with "Win9" or the first one in the list, if
    // none match.
    if (LB_ERR == SendMessageW(hList, LB_SELECTSTRING, -1, (LPARAM)L"Win9")) {
        SendMessageW(hList, LB_SETCURSEL, 0, 0);
    }
}


void ParseFileLog(HWND hDlg)
{
    WCHAR szPath[1000];
    WCHAR szLine[1000];
    WCHAR szDate[50];
    WCHAR szTime[50];
    WCHAR szDll[200];
    DWORD dwLevel = 0;
    int nLast = 0;

    static WCHAR szHeader[10000];
    static WCHAR szWarnings[10000];
    static WCHAR szErrors[10000];
    static WCHAR szOther[10000];

    FILE *file = NULL;
    BOOL bInHeader = FALSE;
    
    ExpandEnvironmentStringsW(L"%windir%\\AppPatch\\shim.log", szPath, 1000);

    file = _wfopen(szPath, L"rt");

    if (!file) {
        goto out;
    }

    while (fgetws(szLine, 1000, file)) {
        if (wcsncmp(szLine, L"----", 4) == 0) {
            bInHeader = !bInHeader;
            if (bInHeader) {

                // we just started a new header, so clear everything
                szHeader[0] = 0;
                szErrors[0] = 0;
                szWarnings[0] = 0;
                szOther[0] = 0;
            }
            continue;
        }

        // remove the terminator(s)
        nLast = wcslen(szLine) - 1;
        while (nLast >= 0 && (szLine[nLast] == L'\n'|| szLine[nLast] == L'\r')) {
            szLine[nLast] = L'\0';
            nLast--;
        }

        if (bInHeader) {
            wcscat(szHeader, szLine);
            wcscat(szHeader, L"\r\n");
            continue;
        }

        dwLevel = 0;
        swscanf(szLine, L"%s %s %s %d", szDate, szTime, szDll, &dwLevel);

        _wcslwr(szDll);

        if (!wcsstr(szDll, L".dll") || dwLevel == 0) {
            WCHAR szError[1000];

            swprintf(szError, L"Unrecognized data in line: %s", szLine);
            OutputDebugStringW(szError);
            continue;
        }

        if (dwLevel == 1) {
            if (!wcsstr(szErrors, szDll)) {
                wcscat(szErrors, szDll);
                wcscat(szErrors, L"\r\n");
            }
        } else if (dwLevel == 2) {
            if (!wcsstr(szWarnings, szDll)) {
                wcscat(szWarnings, szDll);
                wcscat(szWarnings, L"\r\n");
            }
        } else {
            if (!wcsstr(szOther, szDll)) {
                wcscat(szOther, szDll);
                wcscat(szOther, L"\r\n");
            }
        }
    }

    SetDlgItemText(hDlg, IDC_EDIT_HEADER, szHeader);
    SetDlgItemText(hDlg, IDC_EDIT_ERRORS, szErrors);
    SetDlgItemText(hDlg, IDC_EDIT_WARNINGS, szWarnings);
    SetDlgItemText(hDlg, IDC_EDIT_OTHER, szOther);

out:
    if (file) {
        fclose(file);
    }
    return;
}

// Message handler for parse dialog.
LRESULT CALLBACK DlgParseLog(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam)
{
    HDC hDC;
    
    switch (message)
    {
    case WM_INITDIALOG:
        ParseFileLog(hDlg);
        break;
        
    case WM_COMMAND:
        switch LOWORD(wParam) {
            
        case IDOK:
        case IDCANCEL:
            EndDialog(hDlg, LOWORD(wParam));
            return TRUE;
            break;
        }
    }
    return FALSE;
}

void ShowHelp(void)
{
    MessageBox(NULL, L"Apply a compatibility layer in addition to any fixes in the database:\n\n"
        L"    runcompat (layer name) (command line)\n\n"
        L"Apply a compatibility layer and disable any existing fixes:\n\n"
        L"    runcompat !(layer name) (command line)\n\n"
        L"Run GUI version:\n\n"
        L"    runcompat", L"Runcompat Command-Line Usage", MB_OK);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\appcompat\tools\sdbinst\sdbinst.cpp ===
/*--

Copyright (c) 1999  Microsoft Corporation

Module Name:

    sdbinst.cpp

Abstract:

    installs custom SDB files into AppPatch\Custom, and adds registry entries to point
    to them

Author:

    dmunsil 12/29/2000

Revision History:

    Many people contributed over time.
    (in alphabetical order: clupu, dmunsil, rparsons, vadimb)
    
Notes:



--*/

#define _UNICODE

#define WIN
#define FLAT_32
#define TRUE_IF_WIN32   1
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#define _WINDOWS
#include <windows.h>
#include <shellapi.h>
#include <stdio.h>
#include <stddef.h>
#include <stdlib.h>
#include <assert.h>
#include <tchar.h>
#include <aclapi.h>

#include "resource.h"

extern "C" {
#include "shimdb.h"
}


BOOL    g_bQuiet;
BOOL    g_bWin2K;
WCHAR   g_wszCustom[MAX_PATH];

BOOL    g_bAllowPatches = FALSE;

HINSTANCE g_hInst;

HANDLE  g_hLogFile = INVALID_HANDLE_VALUE;

typedef enum _INSTALL_MODE {
    MODE_INSTALL,
    MODE_UNINSTALL,
    MODE_CLEANUP,
    MODE_CONVERT_FORMAT_NEW,
    MODE_CONVERT_FORMAT_OLD
} INSTALL_MODE;

#define UNINSTALL_KEY_PATH  L"Software\\Microsoft\\Windows\\CurrentVersion\\Uninstall\\"
#define APPCOMPAT_KEY       L"System\\CurrentControlSet\\Control\\Session Manager\\AppCompatibility"

DWORD g_dwWow64Key = (DWORD)-1;

void
__cdecl
vPrintError(
    UINT unRes,
    ...
    )
{
    WCHAR   szT[1024];
    WCHAR   wszFormat[1024];
    WCHAR   wszCaption[1024];
    va_list arglist;

    if (!g_bQuiet) {
        if (!LoadStringW(g_hInst, IDS_APP_ERROR_TITLE, wszCaption, 1024)) {
            return;
        }
        
        if (LoadStringW(g_hInst, unRes, wszFormat, 1024)) {
            va_start(arglist, unRes);
            _vsnwprintf(szT, 1023, wszFormat, arglist);
            szT[1022] = 0;
            va_end(arglist);

            MessageBoxW(NULL, szT, wszCaption, MB_OK | MB_ICONWARNING);
        }
    }
}

void
__cdecl
vPrintMessage(
    UINT unRes,
    ...
    )
{
    WCHAR   szT[1024];
    WCHAR   wszFormat[1024];
    WCHAR   wszCaption[1024];
    va_list arglist;

    if (!g_bQuiet) {
        if (!LoadStringW(g_hInst, IDS_APP_TITLE, wszCaption, 1024)) {
            return;
        }
        
        if (LoadStringW(g_hInst, unRes, wszFormat, 1024)) {
            va_start(arglist, unRes);
            _vsnwprintf(szT, 1023, wszFormat, arglist);
            szT[1022] = 0;
            va_end(arglist);

            MessageBoxW(NULL, szT, wszCaption, MB_OK | MB_ICONINFORMATION);
        }
    }
}

void
__cdecl
vLogMessage(
    LPCSTR pwszFormat,
    ...
    )
{
    CHAR    szT[1024];
    va_list arglist;
    int     nLength;

    va_start(arglist, pwszFormat);
    nLength = _vsnprintf(szT, CHARCOUNT(szT), pwszFormat, arglist);
    
    if (nLength < 0) {
        szT[1023] = '\0';
        nLength = sizeof(szT);
    } else {
        nLength *= sizeof(szT[0]);
    }

    va_end(arglist);

    if (g_hLogFile != INVALID_HANDLE_VALUE) {
        DWORD dwWritten;
        WriteFile(g_hLogFile, (LPVOID)szT, (DWORD)nLength, &dwWritten, NULL);
    }

    OutputDebugStringA(szT);
}

DWORD
GetWow64Flag(
    void
    )
{
    if (g_dwWow64Key == (DWORD)-1) {
        if (g_bWin2K) {
            g_dwWow64Key = 0; // no flag since there is no wow64 on win2k
        } else {
            g_dwWow64Key = KEY_WOW64_64KEY;
        }
    }

    return g_dwWow64Key;
}

VOID
OpenLogFile(
    VOID
    )
{
    WCHAR wszLogFile[MAX_PATH];
    CHAR  szBuffer[1024];

    GetSystemWindowsDirectoryW(wszLogFile, CHARCOUNT(wszLogFile));
    wcscat(wszLogFile, L"\\AppPatch\\SdbInst.Log");

    g_hLogFile = CreateFileW(wszLogFile,
                             GENERIC_WRITE,
                             FILE_SHARE_READ,
                             NULL,
                             CREATE_ALWAYS,
                             FILE_ATTRIBUTE_NORMAL,
                             NULL);
}

VOID
CloseLogFile(
    VOID
    )
{
    if (g_hLogFile != INVALID_HANDLE_VALUE) {
        CloseHandle(g_hLogFile);
    }
    g_hLogFile = INVALID_HANDLE_VALUE;
}

void
vPrintHelp(
    WCHAR* szAppName
    )
{
    vPrintMessage(IDS_HELP_TEXT, szAppName);
}

typedef void (CALLBACK *pfn_ShimFlushCache)(HWND, HINSTANCE, LPSTR, int);

void
vFlushCache(
    void
    )
{
    HMODULE hAppHelp;
    pfn_ShimFlushCache pShimFlushCache;


    hAppHelp = LoadLibraryW(L"apphelp.dll");
    if (hAppHelp) {
        pShimFlushCache = (pfn_ShimFlushCache)GetProcAddress(hAppHelp, "ShimFlushCache");
        if (pShimFlushCache) {
            pShimFlushCache(NULL, NULL, NULL, 0);
        }
    }
}

BOOL
bSearchGroupForSID(
    DWORD dwGroup,
    BOOL* pfIsMember
    )
{
    PSID                     pSID = NULL;
    SID_IDENTIFIER_AUTHORITY SIDAuth = SECURITY_NT_AUTHORITY;
    BOOL                     fRes = TRUE;

    if (!AllocateAndInitializeSid(&SIDAuth,
                                  2,
                                  SECURITY_BUILTIN_DOMAIN_RID,
                                  dwGroup,
                                  0,
                                  0,
                                  0,
                                  0,
                                  0,
                                  0,
                                  &pSID)) {
        return FALSE;
    }

    if (!pSID) {
        return FALSE;
    }

    if (!CheckTokenMembership(NULL, pSID, pfIsMember)) {
        fRes = FALSE;
    }

    FreeSid(pSID);

    return fRes;
}

BOOL
bCanRun(
    void
    )
{
    BOOL fIsAdmin;

    if (!bSearchGroupForSID(DOMAIN_ALIAS_RID_ADMINS, &fIsAdmin))
    {
        return FALSE;
    }

    return fIsAdmin;
}

WCHAR*
wszGetFileFromPath(
    WCHAR* wszPath
    )
{
    WCHAR* szTemp = wcsrchr(wszPath, L'\\');
    
    if (szTemp) {
        return szTemp + 1;
    }

    return NULL;
}

BOOL
bIsAlreadyInstalled(
    WCHAR* wszPath
    )
{
    DWORD dwCustomLen;
    DWORD dwInputLen;
    DWORD dwPos;

    dwCustomLen = wcslen(g_wszCustom);
    dwInputLen = wcslen(wszPath);

    if (_wcsnicmp(wszPath, g_wszCustom, dwCustomLen) != 0) {
        //
        // it's not in the custom directory
        //
        return FALSE;
    }

    for (dwPos = dwCustomLen; dwPos < dwInputLen; ++dwPos) {
        if (wszPath[dwPos] == L'\\') {
            //
            // it's in a subdirectory of Custom,
            //
            return FALSE;
        }
    }

    return TRUE;
}

BOOL
bGuidToPath(
    GUID*  pGuid,
    WCHAR* wszPath
    )
{
    UNICODE_STRING ustrGuid;

    if (!NT_SUCCESS(RtlStringFromGUID(*pGuid, &ustrGuid))) {
        return FALSE;
    }
    
    wcscpy(wszPath, g_wszCustom);
    wcscat(wszPath, ustrGuid.Buffer);
    wcscat(wszPath, L".sdb");

    RtlFreeUnicodeString(&ustrGuid);

    return TRUE;
}

BOOL
bGetGuid(
    WCHAR* wszSDB,
    GUID*  pGuid
    )
{
    PDB     pdb = NULL;
    TAGID   tiDatabase;
    TAGID   tiID;
    BOOL    bRet = FALSE;

    pdb = SdbOpenDatabase(wszSDB, DOS_PATH);
    
    if (!pdb) {
        vPrintError(IDS_UNABLE_TO_OPEN_FILE, wszSDB);
        bRet = FALSE;
        goto out;
    }

    tiDatabase = SdbFindFirstTag(pdb, TAGID_ROOT, TAG_DATABASE);
    
    if (!tiDatabase) {
        vPrintError(IDS_NO_DB_TAG, wszSDB);
        bRet = FALSE;
        goto out;
    }

    ZeroMemory(pGuid, sizeof(GUID));
    tiID = SdbFindFirstTag(pdb, tiDatabase, TAG_DATABASE_ID);
    
    if (tiID) {
        if (SdbReadBinaryTag(pdb, tiID, (PBYTE)pGuid, sizeof(GUID))) {
            bRet = TRUE;
        }
    }

    if (!bRet) {
        vPrintError(IDS_NO_DB_ID, wszSDB);
    }

out:
    if (pdb) {
        SdbCloseDatabase(pdb);
        pdb = NULL;
    }

    return bRet;
}

typedef enum _TIME_COMPARE {
    FILE_NEWER,
    FILE_SAME,
    FILE_OLDER
} TIME_COMPARE;

BOOL
bOldSdbInstalled(
    WCHAR* wszPath,
    WCHAR* wszOldPath
    )
{
    WIN32_FIND_DATAW FindData;
    GUID    guidMain;
    BOOL    bRet = FALSE;
    HANDLE  hFind;

    //
    // get the guid from the DB we're installing
    //
    if (!bGetGuid(wszPath, &guidMain)) {
        //
        // there's no info in this DB, so no way to tell.
        //
        return FALSE;
    }

    //
    // get the path to the current file
    //
    if (!bGuidToPath(&guidMain, wszOldPath)) {
        //
        // couldn't convert to path
        //
        return FALSE;
    }

    //
    // check to see if the file exists
    //
    hFind = FindFirstFileW(wszOldPath, &FindData);
    
    if (hFind != INVALID_HANDLE_VALUE) {
        //
        // yup
        //
        bRet = TRUE;
        FindClose(hFind);
    }

    return bRet;
}

BOOL 
IsKnownDatabaseGUID(
    GUID* pGuid
    )
{
    const GUID* rgpGUID[] = {
        &GUID_SYSMAIN_SDB,
        &GUID_APPHELP_SDB,
        &GUID_SYSTEST_SDB,
        &GUID_DRVMAIN_SDB,
        &GUID_MSIMAIN_SDB
    };

    int i;
    
    for (i = 0; i < ARRAYSIZE(rgpGUID); ++i) {
        if (*rgpGUID[i] == *pGuid) {
            return TRUE;
        }
    }

    return FALSE;
}

BOOL
DatabaseContainsPatch(
    WCHAR* wszSDB
    )
{
    PDB     pdb = NULL;
    TAGID   tiDatabase = TAGID_NULL;
    TAGID   tiLibrary = TAGID_NULL;
    TAGID   tiPatch = TAGID_NULL;
    BOOL    bRet = FALSE;

    pdb = SdbOpenDatabase(wszSDB, DOS_PATH);
    
    if (!pdb) {
        vPrintError(IDS_UNABLE_TO_OPEN_FILE, wszSDB);
        bRet = FALSE;
        goto out;
    }

    tiDatabase = SdbFindFirstTag(pdb, TAGID_ROOT, TAG_DATABASE);
    
    if (!tiDatabase) {
        vPrintError(IDS_NO_DB_TAG, wszSDB);
        bRet = FALSE;
        goto out;
    }

    tiLibrary = SdbFindFirstTag(pdb, tiDatabase, TAG_LIBRARY);
    if (!tiLibrary) {
        //
        // this isn't an error -- no library just means no patches
        //
        bRet = FALSE;
        goto out;
    }

    tiPatch = SdbFindFirstTag(pdb, tiLibrary, TAG_PATCH);
    if (tiPatch) {
        bRet = TRUE;
    } else {
        bRet = FALSE;
    }

out:
    if (pdb) {
        SdbCloseDatabase(pdb);
        pdb = NULL;
    }

    return bRet;
}

BOOL
bGetInternalNameAndID(
    WCHAR* wszSDB,
    WCHAR* wszInternalName,
    GUID*  pGuid
    )
{
    PDB     pdb = NULL;
    TAGID   tiDatabase;
    TAGID   tiName;
    TAGID   tiID;
    BOOL    bRet = FALSE;
    WCHAR*  wszTemp;

    pdb = SdbOpenDatabase(wszSDB, DOS_PATH);
    
    if (!pdb) {
        vPrintError(IDS_UNABLE_TO_OPEN_FILE, wszSDB);
        bRet = FALSE;
        goto out;
    }

    tiDatabase = SdbFindFirstTag(pdb, TAGID_ROOT, TAG_DATABASE);
    
    if (!tiDatabase) {
        vPrintError(IDS_NO_DB_TAG, wszSDB);
        bRet = FALSE;
        goto out;
    }

    tiName = SdbFindFirstTag(pdb, tiDatabase, TAG_NAME);
    
    if (tiName) {
        wszTemp = SdbGetStringTagPtr(pdb, tiName);
    }

    if (wszTemp) {
        wcscpy(wszInternalName, wszTemp);
    } else {
        wszInternalName[0] = 0;
    }

    ZeroMemory(pGuid, sizeof(GUID));
    tiID = SdbFindFirstTag(pdb, tiDatabase, TAG_DATABASE_ID);
    
    if (!tiID) {
        bRet = FALSE;
        goto out;
    }

    if (!SdbReadBinaryTag(pdb, tiID, (PBYTE)pGuid, sizeof(GUID))) {
        bRet = FALSE;
        goto out;
    }

    bRet = TRUE;

out:
    if (pdb) {
        SdbCloseDatabase(pdb);
        pdb = NULL;
    }

    return bRet;
}


BOOL
bFriendlyNameToFile(
    WCHAR* wszFriendlyName,
    WCHAR* wszFile,
    WCHAR* wszPath
    )
{
    WCHAR            wszSearchPath[MAX_PATH];
    WIN32_FIND_DATAW FindData;
    BOOL             bRet = FALSE;
    WCHAR            wszInternalTemp[256];
    WCHAR            wszFileTemp[MAX_PATH];
    GUID             guidTemp;
    HANDLE           hFind;

    wcscpy(wszSearchPath, g_wszCustom);
    wcscat(wszSearchPath, L"*.sdb");

    hFind = FindFirstFileW(wszSearchPath, &FindData);
    
    if (hFind == INVALID_HANDLE_VALUE) {
        return FALSE;
    }
    
    while (hFind != INVALID_HANDLE_VALUE) {

        wcscpy(wszFileTemp, g_wszCustom);
        wcscat(wszFileTemp, FindData.cFileName);

        if (!bGetInternalNameAndID(wszFileTemp, wszInternalTemp, &guidTemp)) {
            goto nextFile;
        }
        
        if (_wcsicmp(wszInternalTemp, wszFriendlyName) == 0) {
            bRet = TRUE;
            wcscpy(wszFile, FindData.cFileName);
            wcscpy(wszPath, wszFileTemp);
            FindClose(hFind);
            break;
        }

nextFile:
        if (!FindNextFileW(hFind, &FindData)) {
            FindClose(hFind);
            hFind = INVALID_HANDLE_VALUE;
        }
    }

    return bRet;

}

BOOL
bFindInstallName(
    WCHAR* wszPath,
    WCHAR* wszInstallPath
    )
{
    GUID guidMain;

    //
    // get the guid from the DB we're installing
    //
    if (!bGetGuid(wszPath, &guidMain)) {
        //
        // there's no info in this DB, so no way to tell.
        //
        return FALSE;
    }

    //
    // get the path to the current file
    //
    if (!bGuidToPath(&guidMain, wszInstallPath)) {
        //
        // couldn't convert to path
        //
        return FALSE;
    }

    return TRUE;
}

//
// this function is necessary because RegDeleteKey doesn't work right with
// a 32-bit app deleting 64-bit reg keys
//
LONG
LocalRegDeleteKeyW (
    IN HKEY    hKey,
    IN LPCWSTR lpSubKey
    )
{
    LONG  lRes;
    HKEY  hSubKey    = NULL;

    lRes = RegOpenKeyExW(hKey,
                         lpSubKey,
                         0,
                         KEY_ALL_ACCESS|GetWow64Flag(),
                         &hSubKey);
    if (lRes != ERROR_SUCCESS) {
        return lRes;
    }

    lRes = NtDeleteKey(hSubKey);

    RegCloseKey(hSubKey);

    return lRes;
}

VOID
InstallW2KData(
    WCHAR*  pszEntryName,
    LPCWSTR pszGuidDB
    )
{
    HKEY  hKey;
    WCHAR wszRegPath[MAX_PATH];
    DWORD dwDisposition, cbData;
    LONG  lResult = 0;
    BYTE  data[16] = {0x0c, 0, 0, 0, 0, 0, 0, 0,
                      0x06, 0, 0, 0, 0, 0, 0, 0};

    //
    // This is Windows 2000 - attempt to add custom SDB specific data.
    //
    wsprintfW(wszRegPath, L"%s\\%s", APPCOMPAT_KEY, pszEntryName);

    lResult = RegCreateKeyExW(HKEY_LOCAL_MACHINE,
                              wszRegPath,
                              0,
                              NULL,
                              0,
                              KEY_SET_VALUE,
                              NULL,
                              &hKey,
                              &dwDisposition);

    if (ERROR_SUCCESS != lResult) {
        if (ERROR_ACCESS_DENIED == lResult) {
            vPrintError(IDS_NEED_INSTALL_PERMISSION);
            return;
        } else {
            vPrintError(IDS_CANT_CREATE_REG_KEY, pszEntryName);
            return;
        }
    }

    //
    // Set the registry values.
    //
    lResult = RegSetValueExW(hKey,
                             pszGuidDB,
                             0,
                             REG_BINARY,
                             data,
                             sizeof(data));

    if (ERROR_SUCCESS != lResult) {
        
        RegCloseKey(hKey);
        
        if (ERROR_ACCESS_DENIED == lResult) {
            vPrintError(IDS_NEED_INSTALL_PERMISSION);
        } else {
            //
            // djm - can't use new strings for XP SP1
            //
            //vPrintError(IDS_CANT_SET_REG_VALUE, pszEntryName);
            vPrintError(IDS_CANT_CREATE_VALUE, pszEntryName);
        }
        return;
    }

    data[0] = 0;

    wsprintfW(wszRegPath, L"DllPatch-%s", pszGuidDB);
    
    lResult = RegSetValueExW(hKey,
                             wszRegPath,
                             0,
                             REG_SZ,
                             data,
                             2 * sizeof(WCHAR));

    if (ERROR_SUCCESS != lResult) {
        
        RegCloseKey(hKey);
        
        if (ERROR_ACCESS_DENIED == lResult) {
            vPrintError(IDS_NEED_INSTALL_PERMISSION);
        } else {
            //
            // djm - can't use new strings for XP SP1
            //
            //vPrintError(IDS_CANT_SET_REG_VALUE, pszEntryName);
            vPrintError(IDS_CANT_CREATE_VALUE, pszEntryName);
        }
        return;
    }

    RegCloseKey(hKey);
}

VOID
RemoveW2KData(
    WCHAR*  pszEntryName,
    LPCWSTR pszGuidDB
    )
{
    HKEY  hKey;
    WCHAR wszRegPath[MAX_PATH];
    LONG  lResult = 0;
    DWORD dwValues;

    //
    // This is Windows 2000 - attempt to remove custom SDB specific data.
    //
    wsprintfW(wszRegPath, L"%s\\%s", APPCOMPAT_KEY, pszEntryName);

    lResult = RegOpenKeyExW(HKEY_LOCAL_MACHINE,
                            wszRegPath,
                            0,
                            KEY_ALL_ACCESS|GetWow64Flag(),
                            &hKey);

    if (ERROR_SUCCESS != lResult) {
        if (ERROR_ACCESS_DENIED == lResult) {
            vPrintError(IDS_NEED_INSTALL_PERMISSION);
            return;
        } else {
            vPrintError(IDS_CANT_OPEN_REG_KEY, wszRegPath);
            return;
        }
    }

    RegDeleteValueW(hKey, pszGuidDB);
    
    wsprintfW(wszRegPath, L"DllPatch-%s", pszGuidDB);
    RegDeleteValueW(hKey, wszRegPath);

    //
    // Figure out if we should delete the key, if there aren't any more values left
    //
    lResult = RegQueryInfoKey(hKey,
                              NULL,
                              NULL,
                              NULL,
                              NULL,
                              NULL,
                              NULL,
                              &dwValues,
                              NULL,
                              NULL,
                              NULL,
                              NULL);
    RegCloseKey(hKey);
    hKey = NULL;
    
    if (dwValues != 0) {
        return;
    }
    
    lResult = RegOpenKeyExW(HKEY_LOCAL_MACHINE,
                            APPCOMPAT_KEY,
                            0,
                            KEY_ALL_ACCESS|GetWow64Flag(),
                            &hKey);
    
    if (ERROR_SUCCESS == lResult) {
        lResult = LocalRegDeleteKeyW(hKey, pszEntryName);
    }
    
    if (lResult != ERROR_SUCCESS) {
        vPrintError(IDS_CANT_DELETE_REG_KEY, pszEntryName, APPCOMPAT_KEY);
    }

    RegCloseKey(hKey);
}

// Caller is responsible for freeing the memory using delete [].
LPWSTR 
ExpandItem(
    LPCWSTR pwszItem
    )
{
    // Get the required length.
    DWORD cLenExpand = ExpandEnvironmentStringsW(pwszItem, NULL, 0);

    if (!cLenExpand)
    {
        return NULL;
    }

    //
    // Make room for "\\?\"
    //
    cLenExpand += 4;

    LPWSTR pwszItemExpand = new WCHAR [cLenExpand];
    if (!pwszItemExpand)
    {
        return NULL;
    }

    LPWSTR pwszTemp = pwszItemExpand;
    DWORD cTemp = cLenExpand;

    wcscpy(pwszItemExpand, L"\\\\?\\");
    pwszTemp += 4;
    cTemp -= 4;

    if (!ExpandEnvironmentStringsW(pwszItem, pwszTemp, cTemp))
    {
        return NULL;
    }
    
    return pwszItemExpand;
}

DWORD
GiveUsersWriteAccess(
    LPWSTR pwszDir
    )
{
    DWORD dwRes;
    PACL pOldDACL;
    PACL pNewDACL = NULL;
    SECURITY_DESCRIPTOR sd;
    PSECURITY_DESCRIPTOR pSD = &sd;
    GUID guidChildObjectType;   // GUID of object to control creation of
    PSID pTrusteeSID;           // trustee for new ACE
    EXPLICIT_ACCESS ea;
    SID_IDENTIFIER_AUTHORITY SIDAuth = SECURITY_NT_AUTHORITY;
    PSID pUsersSID = NULL;

    if ((dwRes = GetNamedSecurityInfoW(
        pwszDir, 
        SE_FILE_OBJECT, 
        DACL_SECURITY_INFORMATION,
        NULL, 
        NULL, 
        &pOldDACL, 
        NULL, 
        &pSD)) != ERROR_SUCCESS) {
        goto Cleanup; 
    }  

    if(!AllocateAndInitializeSid( 
        &SIDAuth, 
        2,
        SECURITY_BUILTIN_DOMAIN_RID,
        DOMAIN_ALIAS_RID_USERS, 
        0, 
        0, 
        0, 
        0, 
        0, 
        0,
        &pUsersSID)) {

        dwRes = ERROR_NOT_ENOUGH_MEMORY;
        goto Cleanup;
    }

    //
    // Initialize an EXPLICIT_ACCESS structure for the new ACE. 
    //
    ZeroMemory(&ea, sizeof(EXPLICIT_ACCESS));
    ea.grfAccessPermissions = FILE_ALL_ACCESS;
    ea.grfAccessMode = GRANT_ACCESS;
    ea.grfInheritance= SUB_CONTAINERS_AND_OBJECTS_INHERIT;
    ea.Trustee.TrusteeForm = TRUSTEE_IS_SID;
    ea.Trustee.TrusteeType = TRUSTEE_IS_GROUP;
    ea.Trustee.ptstrName = (LPTSTR) pUsersSID;

    //
    // Create a new ACL that merges the new ACE
    // into the existing DACL.
    //
    if ((dwRes = SetEntriesInAcl(1, &ea, pOldDACL, &pNewDACL)) != ERROR_SUCCESS) {
        goto Cleanup; 
    }

    dwRes = SetNamedSecurityInfoW(
        pwszDir, 
        SE_FILE_OBJECT, 
        DACL_SECURITY_INFORMATION,
        NULL, 
        NULL, 
        pNewDACL, 
        NULL);

Cleanup:

    if (pUsersSID) {
        FreeSid(pUsersSID);
    }
    
    return dwRes;
}

BOOL
SetupLUAAllUserDir(
    LPCWSTR pwszAllUserDir
    )
{
    BOOL bRes = FALSE;

    LPWSTR pwszExpandedDir = ExpandItem(pwszAllUserDir);

    if (!pwszExpandedDir) {
        //
        // djm - replacing new error messages with generic ones so we don't run afoul of the mui guys
        //
        //vPrintError(IDS_CANT_EXPAND_DIR, pwszAllUserDir);
        vPrintError(IDS_APP_ERROR_TITLE);
        return FALSE;
    }

    //
    // Create the directory if it doesn't already exist.
    //
    DWORD dwAttributes = GetFileAttributesW(pwszExpandedDir);

    if (dwAttributes != -1) {
        if (!(dwAttributes & FILE_ATTRIBUTE_DIRECTORY)) {

            //
            // djm - replacing new error messages with generic ones so we don't run afoul of the mui guys
            //
            //vPrintError(IDS_OBJECT_ALREADY_EXISTS, pwszExpandedDir);
            vPrintError(IDS_APP_ERROR_TITLE);

            goto Cleanup;
        }
    } else {
        if (!CreateDirectoryW(pwszExpandedDir, NULL)) {
            //
            // djm - replacing new error messages with generic ones so we don't run afoul of the mui guys
            //
            //vPrintError(IDS_CANT_CREATE_DIRECTORY, pwszExpandedDir, GetLastError());
            vPrintError(IDS_APP_ERROR_TITLE);
            goto Cleanup;
        }
    }

    //
    // Give the Users group full control access (power users can already modify
    // files in this directory).
    //
    if (GiveUsersWriteAccess((LPWSTR)pwszExpandedDir) != ERROR_SUCCESS) {
        //
        // djm - replacing new error messages with generic ones so we don't run afoul of the mui guys
        //
        //vPrintError(IDS_CANT_SET_ACLS, pwszExpandedDir);
        vPrintError(IDS_APP_ERROR_TITLE);
        goto Cleanup;
    }

    bRes = TRUE;

Cleanup:

    delete [] pwszExpandedDir;

    return bRes;
}

// buffer size is in characters (unicode)
BOOL 
InstallSdbEntry(
    WCHAR*    szEntryName,     // entry name (foo.exe or layer name)
    LPCWSTR   pszGuidDB,       // guid database id in string format
    PDB       pdb,
    TAGID     tiAction,        // the ACTION node.
    ULONGLONG ullSdbTimeStamp, // representation of a timestamp
    BOOL      bLayer           // true if layer name
    )
{
    LONG  lRes;
    WCHAR szRegPath[MAX_PATH];
    WCHAR szDBName[MAX_PATH];  // this is used in older (win2k) versions
    INT   nch;
    BOOL  bReturn = FALSE;
    HKEY  hKey    = NULL;

    wcsncpy(szDBName, pszGuidDB, MAX_PATH);
    szDBName[MAX_PATH - 1] = 0;

    wcsncat(szDBName, L".sdb", MAX_PATH);
    szDBName[MAX_PATH - 1] = 0;

    pszGuidDB = szDBName;
    
    //
    // If this is Win2K, add data to the AppCompatibility key.
    //
    if (g_bWin2K) {
        InstallW2KData(szEntryName, pszGuidDB);
    }

    // else we have a string
    nch = _snwprintf(szRegPath,
                     sizeof(szRegPath)/sizeof(szRegPath[0]),
                     (bLayer ? L"%s\\Layers\\%s": L"%s\\%s"),
                     APPCOMPAT_KEY_PATH_CUSTOM_W,
                     szEntryName);
    if (nch < 0) {
        // error
        vPrintError(IDS_BUFFER_TOO_SMALL);
        goto HandleError;
    }


    lRes = RegCreateKeyExW(HKEY_LOCAL_MACHINE,
                           szRegPath,
                           0,
                           NULL,
                           REG_OPTION_NON_VOLATILE,
                           KEY_ALL_ACCESS|GetWow64Flag(),
                           NULL,
                           &hKey,
                           NULL);

    //
    // on install, we want to quit if we hit an error.
    // BUGBUG - should we undo whatever we've already completed?
    //
    if (lRes != ERROR_SUCCESS) {
        vPrintError(IDS_CANT_CREATE_REG_KEY, szRegPath);
        goto HandleError;
    }

    lRes = RegSetValueExW(hKey,
                          pszGuidDB,
                          0,
                          REG_QWORD,
                          (PBYTE)&ullSdbTimeStamp,
                          sizeof(ullSdbTimeStamp));

    if (lRes != ERROR_SUCCESS) {
        vPrintError(IDS_CANT_CREATE_VALUE, szRegPath);
        goto HandleError;
    }

    LPWSTR szAllUserDir = NULL;

    if (tiAction) {

        //
        // the ACTION node in the EXE shimmed with LUA looks like this:
        //
        //  <ACTION NAME="REDIRECT" TYPE="ChangeACLs">
        //      <DATA NAME="AllUserDir" VALUETYPE="STRING" 
        //          VALUE="%ALLUSERSPROFILE%\Application Data\Fireworks 3"/>
        //      </ACTION>
        //
        TAGID tiName, tiType, tiData, tiValue;
        LPWSTR szName, szType, szData;

        if ((tiName = SdbFindFirstTag(pdb, tiAction, TAG_NAME)) &&
            (szName = SdbGetStringTagPtr(pdb, tiName))) {

            if (!wcscmp(szName, L"REDIRECT")) {
                
                if ((tiType = SdbFindFirstTag(pdb, tiAction, TAG_ACTION_TYPE)) &&
                    (szType = SdbGetStringTagPtr(pdb, tiType))) {

                    if (!wcscmp(szType, L"ChangeACLs")) {

                        if ((tiData = SdbFindFirstTag(pdb, tiAction, TAG_DATA)) &&
                            (tiValue = SdbFindFirstTag(pdb, tiData, TAG_DATA_STRING)) &&
                            (szAllUserDir = SdbGetStringTagPtr(pdb, tiValue))) {
                            
                            if (!SetupLUAAllUserDir(szAllUserDir)) {
                                goto HandleError;
                            }
                        }
                    }
                }
            }
        }
    }

    bReturn = TRUE;

HandleError:

    if (hKey != NULL) {
        RegCloseKey(hKey);
    }

    return bReturn;
}


BOOL
UninstallSdbEntry(
    WCHAR*    szEntryName,      // foo.exe or layer name
    LPCWSTR   pszGuidDB,        // guid (database id) in string format
    ULONGLONG ullSdbTimeStamp,  // 1ABFCA7ADC99FC timestamp
    BOOL      bLayer            // true is layer
    )
{
    LONG  lRes;
    WCHAR szRegPath[MAX_PATH];
    WCHAR szDBName[MAX_PATH];
    INT   nch;
    BOOL  bReturn = FALSE;
    HKEY  hKey    = NULL;
    DWORD dwValues;
    WCHAR szOldInstallName[MAX_PATH];

    wcsncpy(szDBName, pszGuidDB, MAX_PATH);
    szDBName[MAX_PATH - 1] = 0;

    wcsncat(szDBName, L".sdb", MAX_PATH);
    szDBName[MAX_PATH - 1] = 0;

    pszGuidDB = szDBName;
    
    if (g_bWin2K) {
        RemoveW2KData(szEntryName, pszGuidDB);
    }

    nch = _snwprintf(szRegPath,
                     sizeof(szRegPath)/sizeof(szRegPath[0]),
                     (bLayer ? L"%s\\Layers\\%s": L"%s\\%s"),
                     APPCOMPAT_KEY_PATH_CUSTOM_W,
                     szEntryName);
    if (nch < 0) {
        // error
        vPrintError(IDS_BUFFER_TOO_SMALL);
        goto Out;
    }

    lRes = RegOpenKeyExW(HKEY_LOCAL_MACHINE,
                         szRegPath,
                         0,
                         KEY_ALL_ACCESS|GetWow64Flag(),
                         &hKey);

    //
    // if we fail to open a key on uninstall, keep going, so
    // hopefully we can get as much uninstalled as possible.
    //
    if (lRes != ERROR_SUCCESS) {
        if (lRes == ERROR_ACCESS_DENIED) {
            vPrintError(IDS_NEED_UNINSTALL_PERMISSION);
            goto HandleError;
        } else {
            //
            // DO NOT report an error - this key might have been cleaned up during the
            // previous path, such as when identical exe names appear in the same db
            // for instance, two setup.exe's -- the first pass will clean up the key,
            // second path will fail to open them right here
            //
            // vPrintError(IDS_CANT_OPEN_REG_KEY, szRegPath);
            goto Out;
        }
    }

    lRes = RegDeleteValueW(hKey, pszGuidDB);
    if (lRes != ERROR_SUCCESS) {
        if (lRes == ERROR_ACCESS_DENIED) {
            vPrintError(IDS_NEED_UNINSTALL_PERMISSION);
            goto HandleError; // fatal error
        } else {
            //
            // bugbug - pszSdbInstallName
            //
            if (lRes == ERROR_FILE_NOT_FOUND) {
                WCHAR wszOldFormat[MAX_PATH];
                
                //
                // aha, value's not there, try old format
                //
                wcscpy(wszOldFormat, pszGuidDB);
                wcscat(wszOldFormat, L".sdb");
                lRes = RegDeleteValueW(hKey, wszOldFormat);
            }

            if (lRes != ERROR_SUCCESS) {
                vPrintError(IDS_CANT_DELETE_REG_VALUE, pszGuidDB, szRegPath);
            }
        }
    }

    //
    // figure out if we should delete the key, if there aren't any more values left
    //
    lRes = RegQueryInfoKey(hKey,
                           NULL,
                           NULL,
                           NULL,
                           NULL,
                           NULL,
                           NULL,
                           &dwValues,
                           NULL,
                           NULL,
                           NULL,
                           NULL);
    if (dwValues == 0) {
        RegCloseKey(hKey);
        hKey = NULL;

        nch = _snwprintf(szRegPath,
                         sizeof(szRegPath)/sizeof(szRegPath[0]),
                         (bLayer ? L"%s\\Layers": L"%s"),
                         APPCOMPAT_KEY_PATH_CUSTOM_W);
        if (nch < 0) {
            // error
            vPrintError(IDS_BUFFER_TOO_SMALL);
            goto Out;
        }

        lRes = RegOpenKeyExW(HKEY_LOCAL_MACHINE, szRegPath, 0, KEY_WRITE|GetWow64Flag(), &hKey);

        if (lRes != ERROR_SUCCESS) {
            vPrintError(IDS_CANT_OPEN_REG_KEY, szRegPath);
            goto Out;
        }


        lRes = LocalRegDeleteKeyW(hKey, szEntryName);

        if (lRes != ERROR_SUCCESS) {
            vPrintError(IDS_CANT_DELETE_REG_KEY, szEntryName, szRegPath);
        }
    }

Out:
    bReturn = TRUE;

HandleError:
    if (hKey != NULL) {
        RegCloseKey(hKey);
    }

    return bReturn;

    UNREFERENCED_PARAMETER(ullSdbTimeStamp);

}

/*++

    GetTimeStampByGuid

    This function recovers installed database timestamp. 
    If the value for the database timestamp (DatabaseInstallTimeStamp) does not exist - 
    it is created using the last write time on the key associated with a particular installed 
    database

    [out] pTimeStamp - receives the timestamp of a database
    [in]  pGuidDB    - guid id of a database

    returns TRUE if successful
    
--*/

BOOL
GetTimeStampByGuid(
    PULONGLONG pTimeStamp,
    GUID*      pGuidDB
    )
{
    NTSTATUS Status;
    WCHAR    szKeyPath[MAX_PATH];
    UNICODE_STRING ustrGuid = { 0 };
    LONG     lResult;
    HKEY     hKey = NULL;
    BOOL     bSuccess = FALSE;
    DWORD    dwType;
    DWORD    dwBufferSize;

    Status = RtlStringFromGUID(*pGuidDB, &ustrGuid);
    if (!NT_SUCCESS(Status)) {
        // no way to tell what's up with this guid, perhaps out of memory --
        // or we're
        return FALSE;
    }

    //
    // construct the key
    //
    wcscpy (szKeyPath, APPCOMPAT_KEY_PATH_INSTALLEDSDB_W);
    wcscat (szKeyPath, L"\\");
    wcsncat(szKeyPath, ustrGuid.Buffer, ustrGuid.Length / sizeof(WCHAR));

    lResult = RegOpenKeyExW(HKEY_LOCAL_MACHINE,
                            szKeyPath,
                            0,
                            KEY_READ|GetWow64Flag(),
                            &hKey);

    //
    // query for value with timestamp
    //
    if (lResult != ERROR_SUCCESS) {
       //
       // oops -- can't open the key -- error condition
       //
       goto cleanup;
    }

    dwBufferSize = sizeof(*pTimeStamp);
    lResult = RegQueryValueExW(hKey,
                               L"DatabaseInstallTimeStamp",
                               NULL,
                               &dwType,
                               (LPBYTE)pTimeStamp,
                               &dwBufferSize);
    
    if (lResult != ERROR_SUCCESS || dwType != REG_BINARY) {
        //
        // we can try exhaustive search using values at this point
        // there (apparently) is no install timestamp
        //
        if (lResult == ERROR_FILE_NOT_FOUND) {
            
            FILETIME       ftTimeStamp;
            ULARGE_INTEGER liTimeStamp;


            lResult = RegQueryInfoKeyW(hKey, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL,
                                       NULL, NULL, &ftTimeStamp);

            if (lResult == STATUS_SUCCESS) {
                liTimeStamp.LowPart  = ftTimeStamp.dwLowDateTime;
                liTimeStamp.HighPart = ftTimeStamp.dwHighDateTime;

                *pTimeStamp = liTimeStamp.QuadPart;
            }
        } else if (lResult == ERROR_SUCCESS && dwType != REG_BINARY) {
            lResult = ERROR_INVALID_DATA;
        }

        if (lResult != ERROR_SUCCESS) {
            goto cleanup;
        }
    }

    //
    // success
    //
    bSuccess = TRUE;

cleanup:

    if (ustrGuid.Buffer != NULL) {
        RtlFreeUnicodeString(&ustrGuid);
    }

    if (hKey != NULL) {
        RegCloseKey(hKey);
    }

    return bSuccess;
}

NTSTATUS
SDBAPI
FindCharInUnicodeString(
    ULONG            Flags,
    PCUNICODE_STRING StringToSearch,
    PCUNICODE_STRING CharSet,
    USHORT*          NonInclusivePrefixLength
    )
{
    LPCWSTR pch;

    //
    // implement only the case when we move backward
    //
    if (Flags != RTL_FIND_CHAR_IN_UNICODE_STRING_START_AT_END) {
        return STATUS_NOT_IMPLEMENTED;
    }

    pch = StringToSearch->Buffer + StringToSearch->Length / sizeof(WCHAR);
    
    while (pch >= StringToSearch->Buffer) {

        if (_tcschr(CharSet->Buffer, *pch)) {
            //
            // got the char
            //
            if (NonInclusivePrefixLength) {
                *NonInclusivePrefixLength = (USHORT)(pch - StringToSearch->Buffer) * sizeof(WCHAR);
            }
            
            return STATUS_SUCCESS;
        }

        pch--;
    }

    //
    // We haven't found it. Return failure.
    //
    return STATUS_NOT_FOUND;
}

//
// Database list entry
// Used to represent a particular installed database
//

typedef struct tagSDBLISTENTRY {
    LIST_ENTRY ListEntry;         // link list stuff
    
    ULONGLONG  ullTimeStamp;      // database install timestamp
    GUID       guidDB;            // database guid
    WCHAR      szTimeStamp[32];   // time stamp in string form
    WCHAR      szGuidDB[64];      // guid in string form
    WCHAR      szDatabasePath[1]; // database path - we store only the name
} SDBLISTENTRY, *PSDBLISTENTRY;

/*++
    AddSdbListEntry
    
    Adds a particular database to the list of installed sdbs (maintained internally)
    parses database path to retrieve database name
        
    [in out] pHeadList       - pointer to the associated list head for the installed sdbs
    [in]     guidDB          - database guid
    [in]     TimeStamp       - database time stamp
    [in]     pszDatabasePath - final database path

    returns true if success
--*/

BOOL
AddSdbListEntry(
    PLIST_ENTRY pHeadList,
    GUID&       guidDB,
    ULONGLONG&  TimeStamp,
    LPCWSTR     pszDatabasePath
    )
{
    //
    // out of database path, recover the database name
    //
    UNICODE_STRING  ustrPath = { 0 };
    USHORT          uPrefix;
    UNICODE_STRING  ustrPathSep = RTL_CONSTANT_STRING(L"\\/");
    NTSTATUS        Status;
    UNICODE_STRING  ustrGUID = { 0 };

    if (pszDatabasePath != NULL) {
        RtlInitUnicodeString(&ustrPath, pszDatabasePath);

        Status = FindCharInUnicodeString(RTL_FIND_CHAR_IN_UNICODE_STRING_START_AT_END,
                                         &ustrPath,
                                         &ustrPathSep,
                                         &uPrefix);
        
        if (NT_SUCCESS(Status) && (uPrefix + sizeof(WCHAR)) < ustrPath.Length) {

            //
            // uPrefix is number of character preceding the one we found not including it
            //
            ustrPath.Buffer        += uPrefix / sizeof(WCHAR) + 1;
            ustrPath.Length        -= (uPrefix + sizeof(WCHAR));
            ustrPath.MaximumLength -= (uPrefix + sizeof(WCHAR));
        }

        //
        // at this point ustrPath has just the filename -- this is what we shall use
        //
    }

    PBYTE Buffer = new BYTE[sizeof(SDBLISTENTRY) + ustrPath.Length];

    if (Buffer == NULL) {
        vLogMessage("[AddSdbListEntry] Failed to allocate 0x%lx bytes\n",
                    sizeof(SDBLISTENTRY) + ustrPath.Length);
        return FALSE;
    }

    PSDBLISTENTRY pSdbEntry = (PSDBLISTENTRY)Buffer;

    pSdbEntry->guidDB = guidDB;
    pSdbEntry->ullTimeStamp = TimeStamp;

    Status = RtlStringFromGUID(guidDB, &ustrGUID);
    
    if (!NT_SUCCESS(Status)) {
        //
        // we can't convert guid to string? memory allocation failure
        //
        vLogMessage("[AddSdbListEntry] Failed to convert guid to string Status 0x%lx\n",
                    Status);
        delete[] Buffer;
        return FALSE;
    }
    
    RtlCopyMemory(&pSdbEntry->szGuidDB[0], &ustrGUID.Buffer[0], ustrGUID.Length);
    pSdbEntry->szGuidDB[ustrGUID.Length/sizeof(WCHAR)] = L'\0';
    RtlFreeUnicodeString(&ustrGUID);

    wsprintfW(pSdbEntry->szTimeStamp, L"%.16I64X", TimeStamp);

    RtlCopyMemory(&pSdbEntry->szDatabasePath[0], &ustrPath.Buffer[0], ustrPath.Length);
    pSdbEntry->szDatabasePath[ustrPath.Length / sizeof(WCHAR)] = L'\0';

    InsertHeadList(pHeadList, &pSdbEntry->ListEntry);

    return TRUE;
}

//
// only pGuidDB OR pwszGuid is allowed
//

/*++
    FindSdbListEntry

    Finds and returns an sdb list entry given a guid (in string or binary form)
    Whenever possible pwszGuid is used (if it's supplied). If pwszGuid happens to be 
    an arbitrary filename -- it is assumed that it's the name of an installed sdb file
    as registered. 
    
    [in]  pHeadList      - list of the installed sdbs
    [in]  pwszGuid       - guid or guid.sdb 
    [out] ppSdbListEntry - if found, this receives a pointer to sdb list entry
    [in]  pGuidDB        - guid in binary form

    returns true if matching database has been located in the list    
--*/

BOOL
FindSdbListEntry(
    PLIST_ENTRY    pHeadList,
    LPCWSTR        pwszGuid, // guid, possibly with trailing '.sdb'
    PSDBLISTENTRY* ppSdbListEntry,
    GUID*          pGuidDB   // guid
    )
{
    UNICODE_STRING  ustrDot = RTL_CONSTANT_STRING(L".");
    UNICODE_STRING  ustrPath;
    USHORT          uPrefix;
    NTSTATUS        Status;
    PLIST_ENTRY     pEntry;
    PSDBLISTENTRY   pSdbEntry;
    GUID            guidDB;
    BOOL            bGuidSearch = TRUE;
    BOOL            bFound = FALSE;
    LPCWSTR         pch;

    if (pGuidDB == NULL) {

        RtlInitUnicodeString(&ustrPath, pwszGuid);

        Status = FindCharInUnicodeString(RTL_FIND_CHAR_IN_UNICODE_STRING_START_AT_END,
                                         &ustrPath,
                                         &ustrDot,
                                         &uPrefix);
        if (NT_SUCCESS(Status)) {

            //
            // uPrefix is number of character preceding the one we found not including it
            //
            ustrPath.Length = uPrefix;
        }

        //
        // convert to guid, but check first
        //
        pch = pwszGuid + wcsspn(pwszGuid, L" \t");
        if (*pch != L'{') { // not a guid, why convert ?
            bGuidSearch = FALSE;
        } else {

            Status = RtlGUIDFromString(&ustrPath, &guidDB);
            if (!NT_SUCCESS(Status)) {
                //
                // failed, so use database path instead
                //
                bGuidSearch = FALSE;
            }
        }
    } else {
        guidDB = *pGuidDB;  // guid search only
    }


    pEntry = pHeadList->Flink;
    
    while (pEntry != pHeadList && !bFound) {

        //
        // convert entry by subtracting the offset of the list entry
        //
        pSdbEntry = (PSDBLISTENTRY)((PBYTE)pEntry - OFFSETOF(SDBLISTENTRY, ListEntry));

        //
        // compare db guids or paths
        //
        if (bGuidSearch) {
            bFound = RtlEqualMemory(&pSdbEntry->guidDB, &guidDB, sizeof(GUID));
        } else {
            bFound = !_wcsicmp(pSdbEntry->szDatabasePath, pwszGuid);
        }

        pEntry = pEntry->Flink;
    }

    //
    // we have found an entry ? return it -- note that pEntry would have advanced while pSdbEntry
    // still points to the entry we have found
    //
    if (bFound) {
        *ppSdbListEntry = pSdbEntry;
    }

    return bFound;
}

/*++
    CleanupSdbList

    Performs cleanup for the installed sdb list
    
    returns nothing
--*/

VOID
CleanupSdbList(
    PLIST_ENTRY pSdbListHead
    )
{
    PLIST_ENTRY   pEntry;
    PSDBLISTENTRY pSdbEntry;
    PBYTE         Buffer;

    pEntry = pSdbListHead->Flink;
    if (pEntry == NULL) {
        return;
    }

    while (pEntry != pSdbListHead) {
        pSdbEntry = (PSDBLISTENTRY)((PBYTE)pEntry - OFFSETOF(SDBLISTENTRY, ListEntry));
        pEntry = pEntry->Flink;

        Buffer = (PBYTE)pSdbEntry;
        delete[] Buffer;
    }

}

/*++
    ConvertInstalledSdbsToNewFormat

    Converts installed sdbs to new format, which involves storing (or verifying) the
    timestamp for each installed sdb file. This function also builds a list of sdbs
    used elsewhere

    [in]     hKey         - a key handle for hklm/..../InstalledSdb
    [in out] pSdbListHead - list head for the installed sdbs

    returns true if successful

--*/

BOOL
ConvertInstalledSdbsToNewFormat(
    HKEY        hKey,           // hklm/.../InstalledSdb
    PLIST_ENTRY pSdbListHead    // we fill this list with our sdbs for later
    )
{
    DWORD           dwIndex = 0;
    WCHAR           szSubKeyName[MAX_PATH];
    PWCHAR          pwszKeyName;
    DWORD           dwBufferSize;
    FILETIME        ftLastWriteTime;
    HKEY            hKeyEntry = NULL;
    LONG            lResult;
    ULARGE_INTEGER  liTimeStamp;
    UNICODE_STRING  ustrGuid;
    GUID            guidDB;
    NTSTATUS        Status;
    WCHAR           szDatabasePath[MAX_PATH];
    PWCHAR          pszDatabasePath;
    DWORD           dwType;
    BOOL            bSuccess = TRUE;

    while (TRUE) {

        dwBufferSize = sizeof(szSubKeyName)/sizeof(szSubKeyName[0]);
        
        lResult = RegEnumKeyExW(hKey,
                                dwIndex,
                                szSubKeyName,
                                &dwBufferSize,
                                NULL, NULL, NULL,
                                &ftLastWriteTime);
        ++dwIndex;

        if (lResult != ERROR_SUCCESS) {
            //
            // done if no more keys, else some sort of error
            // bugbug
            //
            if (lResult == ERROR_NO_MORE_ITEMS) {
                //
                // we are done, clean
                //
                break;
            }

            //
            // this is unexpected
            //
            vLogMessage("[ConvertInstalledSdbsToNewFormat] RegEnumKeyExW for index 0x%lx returned unexpected error 0x%lx\n",
                        dwIndex, lResult);

            break;
        }

        RtlInitUnicodeString(&ustrGuid, szSubKeyName);
        Status = RtlGUIDFromString(&ustrGuid, &guidDB);
        
        if (!NT_SUCCESS(Status)) {
            //
            // BUGBUG - failed to convert the guid (subkey name!)
            // extraneous entry, log warning
            //
            vLogMessage("[ConvertInstalledSdbsToNewFormat] Failed to convert string to guid for \"%ls\" status 0x%lx\n",
                        szSubKeyName, Status);
            continue;
        }

        //
        // for this db entry we have to set the timestamp
        //
        lResult = RegOpenKeyExW(hKey,
                                szSubKeyName,
                                0,
                                KEY_READ|KEY_WRITE|GetWow64Flag(),
                                &hKeyEntry);
        
        if (lResult != ERROR_SUCCESS) {
            //
            // bad error ?
            // BUGBUG
            vLogMessage("[ConvertInstalledSdbsToNewFormat] Failed to open subkey \"%ls\" error 0x%lx\n",
                        szSubKeyName, lResult);
            continue;
        }

        //
        // now check the value
        //

        dwBufferSize = sizeof(liTimeStamp.QuadPart);
        lResult = RegQueryValueExW(hKeyEntry,
                                   L"DatabaseInstallTimeStamp",
                                   NULL,
                                   &dwType,
                                   (PBYTE)&liTimeStamp.QuadPart,
                                   &dwBufferSize);

        if (lResult != ERROR_SUCCESS || dwType != REG_BINARY) {

            //
            // we may either have this value already -- if not, set it up now
            //
            liTimeStamp.LowPart  = ftLastWriteTime.dwLowDateTime;
            liTimeStamp.HighPart = ftLastWriteTime.dwHighDateTime;

            vLogMessage("[Info] Database \"%ls\" receives timestamp \"%.16I64X\"\n",
                        szSubKeyName, liTimeStamp.QuadPart);

            lResult = RegSetValueExW(hKeyEntry,
                                     L"DatabaseInstallTimeStamp",
                                     0,
                                     REG_BINARY,
                                     (PBYTE)&liTimeStamp.QuadPart,
                                     sizeof(liTimeStamp.QuadPart));
            if (lResult != ERROR_SUCCESS) {
                //
                // error, ignore for now
                //
                vLogMessage("[ConvertInstalledSdbsToNewFormat] Failed to set timestamp value for database \"%ls\" value \"%.16I64X\" error 0x%lx\n",
                            szSubKeyName, liTimeStamp.QuadPart, lResult);
            }
        }

        //
        // at this point we have :
        // sdb guid (in szSubKeyName)
        // time stamp in liTimeStamp
        //

        //
        // query also database path
        //
        pszDatabasePath = &szDatabasePath[0];
        dwBufferSize = sizeof(szDatabasePath);
        
        lResult = RegQueryValueExW(hKeyEntry,
                                   L"DatabasePath",
                                   NULL,
                                   &dwType,
                                   (PBYTE)pszDatabasePath,
                                   &dwBufferSize);
        
        if (lResult != ERROR_SUCCESS || dwType != REG_SZ) {
            //
            // no database path
            // warn basically corrupt database path
            //
            vLogMessage("[ConvertInstalledSdbsToNewFormat] Failed to query database path for \"%s\" error 0x%lx\n", szSubKeyName, lResult);
            pszDatabasePath = NULL;
        }

        //
        // optional check: we can check here whether the sdb file does exist
        //

        //
        // add this sdb to our cache
        //

        if (!AddSdbListEntry(pSdbListHead, guidDB, liTimeStamp.QuadPart, pszDatabasePath)) {

            //
            // failed to add list entry - we cannot continue
            //
            bSuccess = FALSE;
            break;
        }


        RegCloseKey(hKeyEntry);
        hKeyEntry = NULL;

    }


    if (hKeyEntry != NULL) {
        RegCloseKey(hKeyEntry);
    }

    //
    // we are done converting entries -- and we have also collected cache of sdb info
    //

    return bSuccess;

}

//
// this stucture is used to cache values associated with any particular entry (exe)
//

typedef struct tagSDBVALUEENTRY {
    LIST_ENTRY ListEntry;    // link
    PSDBLISTENTRY pSdbEntry; // this entry belongs to this database 
    WCHAR szValueName[1];    // value name as we got it from registry
} SDBVALUEENTRY, *PSDBVALUEENTRY;


/*++

    AddValueEntry

    Adds an new link list element to the list of values 

    [in out] pValueListHead - link list of values
    [in]     pSdbEntry      - pointer to a cached entry from sdb list 
    [in]     pwszValueName  - value name as we got it from the db (something like {guid} or {guid}.sdb)

    returns true if successful
    
--*/

BOOL
AddValueEntry(
    PLIST_ENTRY   pValueListHead,
    PSDBLISTENTRY pSdbEntry,
    LPCWSTR       pwszValueName
    )
{
    PSDBVALUEENTRY pValueEntry;
    PBYTE          Buffer;
    DWORD          dwSize;

    dwSize = sizeof(SDBVALUEENTRY) + wcslen(pwszValueName) * sizeof(WCHAR);
    
    Buffer = new BYTE[dwSize];

    if (Buffer == NULL) {
        //
        // out of memory
        //
        vLogMessage("[AddValueEntry] Failed to allocate buffer for %ls 0x%lx bytes\n",
                    pwszValueName, dwSize);

        return FALSE;
    }

    pValueEntry = (PSDBVALUEENTRY)Buffer;

    pValueEntry->pSdbEntry = pSdbEntry;
    wcscpy(pValueEntry->szValueName, pwszValueName);

    InsertHeadList(pValueListHead, &pValueEntry->ListEntry);

    return TRUE;
}

/*++
    WriteEntryValue

    Writes value for a particular entry (exe or layer name), deletes old value associated with 
    this particular database for this exe (or layer)

    [in] hKey            - handle for an entry (for instance 
                           hklm/Software/Microsoft/Windows NT/CurrentVersion/AppcompatFlags/Custom/Notepad.exe)
    [in] pValueEntry     - pointer to a value entry element from the value list
    [in] bWriteNewFormat - whether we are asked to write new or old format

    returns true if successful

--*/


BOOL
WriteEntryValue(
    HKEY           hKey,
    PSDBVALUEENTRY pValueEntry,
    BOOL           bWriteNewFormat  // if true -- write new format else old format
    )
{
    LONG    lResult;
    BOOL    bSuccess = FALSE;
    LPCWSTR pValueName;

    if (bWriteNewFormat) {
        
        pValueName = pValueEntry->pSdbEntry->szGuidDB;
        
        lResult = RegSetValueExW(hKey,
                                 pValueName,
                                 0,
                                 REG_QWORD,
                                 (PBYTE)&pValueEntry->pSdbEntry->ullTimeStamp,
                                 sizeof(pValueEntry->pSdbEntry->ullTimeStamp));
        if (lResult != ERROR_SUCCESS) {

            //
            // we can't do this entry ?
            //
            vLogMessage("[WriteEntryValue] Failed to write qword value \"%ls\"=\"%.16I64X\" error 0x%lx\n",
                        pValueEntry->pSdbEntry->szGuidDB, pValueEntry->pSdbEntry->ullTimeStamp, lResult);

            goto cleanup;
        }

        //
        // nuke old entry
        //
    } else {
        //
        // old style format please
        //
        pValueName = pValueEntry->pSdbEntry->szDatabasePath;
        
        lResult = RegSetValueExW(hKey,
                                 pValueName,
                                 0,
                                 REG_SZ,
                                 (PBYTE)L"",
                                 sizeof(WCHAR));
        
        if (lResult != ERROR_SUCCESS) {

            //
            // trouble -- error
            //
            vLogMessage("[WriteEntryValue] Failed to write string value \"%ls\" error 0x%lx\n",
                        pValueEntry->pSdbEntry->szDatabasePath, lResult);
            goto cleanup;
        }
    }

    //
    // if we are here -- success, check to see if we can delete the old value
    // 

    if (_wcsicmp(pValueEntry->szValueName, pValueName) != 0) {
        lResult = RegDeleteValueW(hKey, pValueEntry->szValueName);
        if (lResult != ERROR_SUCCESS) {
            vLogMessage("[WriteEntryValue] Failed to delete value \"%ls\" error 0x%lx\n",
                        pValueEntry->szValueName, lResult);
        }
    }

    bSuccess = TRUE;

cleanup:

    return bSuccess;
}

/*++

    ConvertEntryToNewFormat    

    Converts a particular entry (layer or exe)

    [in] hKeyParent    - key handle for a parent key (for instance 
                         hklm/Software/Microsoft/Windows NT/CurrentVersion/AppcompatFlags/Custom when 
                         pwszEntryName == "Notepad.exe" or 
                         hklm/Software/Microsoft/Windows NT/CurrentVersion/AppcompatFlags/Custom/Layers when
                         pwszEntryName == "RunLayer"
    [in] pwszEntryName - Either exe name or layer name
    [in] pSdbListHead  - cached list of installed databases
    [in] bNewFormat    - whether to use new or old format

    returns true if successful

--*/

BOOL
ConvertEntryToNewFormat(
    HKEY        hKeyParent,
    LPCWSTR     pwszEntryName,
    PLIST_ENTRY pSdbListHead,
    BOOL        bConvertToNewFormat // true if converting to new format, false if reverting
    )
{
    LONG            lResult;
    DWORD           dwValues;
    DWORD           dwMaxValueNameLen;
    DWORD           dwMaxValueLen;
    DWORD           dwType;
    DWORD           dwValueNameSize;
    DWORD           dwValueSize;
    LPWSTR          pwszValueName = NULL;
    LPBYTE          pValue = NULL;
    PSDBLISTENTRY   pSdbEntry;
    DWORD           dwIndex;
    LIST_ENTRY      ValueList = { 0 };
    PSDBVALUEENTRY  pValueEntry;
    PLIST_ENTRY     pValueList;
    PBYTE           Buffer;
    BOOL            bSuccess = FALSE;
    HKEY            hKey = NULL;
    
    //
    // loop through values, for each value - find sdb and write out new entry
    // then delete old entry
    //
    lResult = RegOpenKeyExW(hKeyParent,
                            pwszEntryName,
                            0,
                            KEY_READ|KEY_WRITE|GetWow64Flag(),
                            &hKey);
    
    if (lResult != ERROR_SUCCESS) {
        vLogMessage("[ConvertEntryToNewFormat] Failed to open key \"%ls\" error 0x%lx\n",
                    pwszEntryName, lResult);
        goto cleanup;
    }

    lResult = RegQueryInfoKeyW(hKey,
                               NULL, NULL, // class/class buffer
                               NULL,       // reserved
                               NULL, NULL, // subkeys/max subkey length
                               NULL,       // max class len
                               &dwValues,  // value count
                               &dwMaxValueNameLen,
                               &dwMaxValueLen,
                               NULL, NULL);

    if (lResult != ERROR_SUCCESS) {
        //
        // failed to query the key, very bad
        // bugbug
        vLogMessage("[ConvertEntryToNewFormat] Failed to query key information \"%ls\" error 0x%lx\n",
                    pwszEntryName, lResult);
        goto cleanup;
    }

    //
    // allocate buffers
    //
    pwszValueName = new WCHAR[dwMaxValueNameLen + 1];
    pValue = new BYTE[dwMaxValueLen];
    
    if (pValue == NULL || pwszValueName == NULL) {
        //
        // bugbug
        //
        vLogMessage("[ConvertEntryToNewFormat] Failed to allocate memory buffer entry \"%ls\" (0x%lx, 0x%lx)\n",
                    pwszEntryName, dwMaxValueNameLen, dwMaxValueLen);
        goto cleanup;
    }

    InitializeListHead(&ValueList);

    //
    // we have dwValues -- the count of values
    //
    for (dwIndex = 0; dwIndex < dwValues; ++dwIndex) {

        dwValueNameSize = dwMaxValueNameLen + 1;
        dwValueSize = dwMaxValueLen;

        lResult = RegEnumValueW(hKey,
                                dwIndex,
                                pwszValueName,
                                &dwValueNameSize,
                                NULL,
                                &dwType,
                                (PBYTE)pValue,
                                &dwValueSize);
        //
        // check if we are successful
        //
        if (lResult != ERROR_SUCCESS) {

            if (lResult == ERROR_NO_MORE_ITEMS) {
                //
                // oops -- we ran out of values!!! Unexpected, but ok
                //
                vLogMessage("[ConvertEntryToNewFormat] RegEnumValue unexpectedly reports no more items for \"%ls\" index 0x%lx\n",
                            pwszEntryName, dwIndex);
                break;
            }

            //
            // log error and continue
            //
            vLogMessage("[ConvertEntryToNewFormat] RegEnumValue failed for \"%ls\" index 0x%lx error 0x%lx\n",
                        pwszEntryName, dwIndex, lResult);
            continue;

        }

        if (bConvertToNewFormat) {

            if (dwType != REG_SZ) {
                //
                // bad entry for sure -- this could be a new entry
                // log warning
                //
                if (dwType == REG_QWORD || (dwType == REG_BINARY && dwValueSize == sizeof(ULONGLONG))) {
                    //
                    // new style entry ? 
                    //
                    if (wcsrchr(pwszValueName, L'.') == NULL && 
                        *pwszValueName == L'{' && 
                        *(pwszValueName + wcslen(pwszValueName) - 1) == L'}') {
                        
                        vLogMessage("[Info] Entry \"%ls\" value \"%ls\" already in new format.\n",
                                    pwszEntryName, pwszValueName);
                        continue;
                    } 
                }
                
                // 
                // very likely - some entry we do not understand
                //
            
                vLogMessage("[ConvertEntryToNewFormat] Bad value type (0x%lx) for entry \"%ls\" value \"%ls\" index 0x%lx\n",
                            dwType, pwszEntryName, pwszValueName, dwIndex);
                                            
                continue;
            }

            //
            // search by pwszValueName (which happens to be the GUID.sdb)
            // this may be any kind of a string -- not nec. guid
            //
            if (!FindSdbListEntry(pSdbListHead, pwszValueName, &pSdbEntry, NULL)) {
                //
                // error - sdb not found!
                //
                vLogMessage("[ConvertEntryToNewFormat] Failed to find database \"%ls\" for entry \"%ls\" index 0x%lx\n",
                            pwszValueName, pwszEntryName, dwIndex);
                continue;
            }

        } else {

            //
            // check the type first, if this is a new style entry - this will be bin
            //

            if (dwType == REG_SZ &&
                wcsrchr(pwszValueName, L'.') != NULL && 
                *(LPCWSTR)pValue == L'\0') {
                
                vLogMessage("[Info] Entry \"%ls\" value \"%ls\" is already in required (old) format.\n",
                            pwszEntryName, pwszValueName);
                continue;
            }
            
            if (dwType != REG_QWORD &&
                (dwType != REG_BINARY || dwValueSize < sizeof(ULONGLONG))) {
                //
                // error -- we don't know what this entry is, go to the next one
                // print warning actually
                //
                vLogMessage("[ConvertEntryToNewFormat] Bad value type (0x%lx) or size (0x%lx) for entry \"%ls\" value \"%ls\" index 0x%lx\n",
                            dwType, dwValueSize, pwszEntryName, pwszValueName, dwIndex);
                continue;
            }

            if (!FindSdbListEntry(pSdbListHead, pwszValueName, &pSdbEntry, NULL)) {

                //
                // we're in trouble -- an entry has no registered database
                //
                vLogMessage("[ConvertEntryToNewFormat] Failed to find database for value \"%ls\" for entry \"%ls\" index 0x%lx\n",
                            pwszValueName, pwszEntryName, dwIndex);
                continue;
            }
        }

        //
        // we have found entry and we're ready to write it out, queue it up
        //
        if (!AddValueEntry(&ValueList, pSdbEntry, pwszValueName)) {

            //
            // bugbug can't add value entry
            //
            vLogMessage("[ConvertEntryToNewFormat] Failed to add value \"%ls\" for entry \"%ls\" index 0x%lx\n",
                        pwszValueName, pwszEntryName, dwIndex);
            goto cleanup;
        }
    }

    //
    // we have gone through all the values, write loop
    //
    bSuccess = TRUE;

    pValueList = ValueList.Flink;
    
    while (pValueList != &ValueList) {

        pValueEntry = (PSDBVALUEENTRY)((PBYTE)pValueList - OFFSETOF(SDBVALUEENTRY, ListEntry));

        //
        // we can point to the next entry now
        //

        if (!WriteEntryValue(hKey, pValueEntry, bConvertToNewFormat)) {

            //
            // error, can't convert entry
            // continue though so that we cleanout the list
            vLogMessage("[ConvertEntryToNewFormat] Failed to write value for entry \"%ls\"\n",
                        pwszEntryName);
        }

        pValueList = pValueList->Flink;
    }

cleanup:

    if (ValueList.Flink) {
        pValueList = ValueList.Flink;
        while (pValueList != &ValueList) {
            Buffer = (PBYTE)pValueList - OFFSETOF(SDBVALUEENTRY, ListEntry);
            pValueList = pValueList->Flink;

            delete[] Buffer;
        }
    }

    if (hKey != NULL) {
        RegCloseKey(hKey);
    }

    if (pwszValueName != NULL) {
        delete[] pwszValueName;
    }

    if (pValue != NULL) {
        delete[] pValue;
    }

    return bSuccess;

}


/*++
    ConvertFormat

    This function handles format conversions

    [in] bConvertToNewFormat - true if conversion old->new, false otherwise

    returns true if success
    
--*/


BOOL
ConvertFormat(
    BOOL bConvertToNewFormat
    )
{
    LIST_ENTRY  SdbList = { 0 }; // installed sdbs cache
    HKEY        hKey;
    LONG        lResult;
    DWORD       dwIndex;
    WCHAR       szSubKeyName[MAX_PATH];
    DWORD       dwBufferSize;
    WCHAR       szKeyPath[MAX_PATH];
    BOOL        bSuccess = FALSE;

    //
    // first convert installed sdbs
    // open installed sdb key
    //
    lResult = RegOpenKeyExW(HKEY_LOCAL_MACHINE,
                            APPCOMPAT_KEY_PATH_INSTALLEDSDB_W, // path to InstalledSDB
                            0,
                            KEY_READ|KEY_WRITE|GetWow64Flag(),
                            &hKey);
    
    if (lResult != ERROR_SUCCESS) {

        //
        // perhaps no dbs are installed ?
        //
        if (lResult == ERROR_FILE_NOT_FOUND) {
            //
            // no installed sdbs -- no problem
            //
            vLogMessage("[ConvertFormat] No Installed sdbs found\n");
            return TRUE;
        }

        //
        // some sort of error has occured
        //
        vLogMessage("[ConvertFormat] Failed to open key \"%ls\" Error 0x%lx\n",
                    APPCOMPAT_KEY_PATH_INSTALLEDSDB_W, lResult);
        return FALSE;
    }

    //
    // note that ConvertInstalledSdbsToNewFormat works properly for both install and uninstall cases
    //
    InitializeListHead(&SdbList);
    
    if (!ConvertInstalledSdbsToNewFormat(hKey, &SdbList)) {
        goto cleanup;
    }

    // done with Installed sdbs
    RegCloseKey(hKey);
    hKey = NULL;

    //
    // next up is entry conversion -- first enum exes, then layers
    //
    lResult = RegOpenKeyExW(HKEY_LOCAL_MACHINE,
                            APPCOMPAT_KEY_PATH_CUSTOM_W,
                            0,
                            KEY_READ|KEY_WRITE|GetWow64Flag(),
                            &hKey);
    
    if (lResult != ERROR_SUCCESS) {
        //
        // what is this?
        //
        if (lResult == ERROR_FILE_NOT_FOUND && !IsListEmpty(&SdbList)) {
            vLogMessage("[ConvertFormat] Failed to open \"%ls\" - check consistency\n",
                        APPCOMPAT_KEY_PATH_CUSTOM_W);
        } else {
            vLogMessage("[ConvertFormat] Failed to open \"%ls\" error 0x%lx\n",
                        APPCOMPAT_KEY_PATH_CUSTOM_W, lResult);
        }

        goto cleanup;
    }

    dwIndex = 0;
    
    while (TRUE) {

        dwBufferSize = sizeof(szSubKeyName)/sizeof(szSubKeyName[0]);

        lResult = RegEnumKeyExW(hKey,
                                dwIndex,
                                szSubKeyName,
                                &dwBufferSize,
                                NULL, NULL, NULL,
                                NULL);
        ++dwIndex;

        if (lResult != ERROR_SUCCESS) {

            if (lResult == ERROR_NO_MORE_ITEMS) {
                break;
            }

            //
            // some sort of error, log and continue
            //
            vLogMessage("[ConvertFormat] RegEnumKey (entries) returned error for index 0x%lx error 0x%lx\n",
                        dwIndex, lResult);
            break;
        }

        //
        // skip layers for now
        //
        if (!_wcsicmp(szSubKeyName, L"Layers")) {
            continue;
        }

        // for each of these -- call fixup function

        if (!ConvertEntryToNewFormat(hKey, szSubKeyName, &SdbList, bConvertToNewFormat)) {
            vLogMessage("[ConvertFormat] Failed to convert entry \"%ls\"\n", szSubKeyName);
        }
    }

    RegCloseKey(hKey);
    hKey = NULL;

    //
    // next up - layers
    //
    wcscpy(szKeyPath, APPCOMPAT_KEY_PATH_CUSTOM_W);
    wcscat(szKeyPath, L"\\Layers");

    //
    // open and enum layers
    //
    lResult = RegOpenKeyExW(HKEY_LOCAL_MACHINE,
                            szKeyPath,
                            0,
                            KEY_READ|KEY_WRITE|GetWow64Flag(),
                            &hKey);
    
    if (lResult != ERROR_SUCCESS) {
        // maybe dead ?
        if (lResult == ERROR_FILE_NOT_FOUND) {
            //
            // it's ok, maybe we have none of those ?
            //
            vLogMessage("[ConvertFormat] No layers found\n");
            goto ConvertComplete;
        }

        vLogMessage("[ConvertFormat] Failed to open \"%ls\" error 0x%lx\n", szKeyPath, lResult);
        goto cleanup;
    }

    dwIndex = 0;
    
    while (TRUE) {

        dwBufferSize = sizeof(szSubKeyName)/sizeof(szSubKeyName[0]);

        lResult = RegEnumKeyExW(hKey,
                                dwIndex,
                                szSubKeyName,
                                &dwBufferSize,
                                NULL, NULL, NULL,
                                NULL);
        ++dwIndex;

        if (lResult != ERROR_SUCCESS) {

            // check if this was the last entry
            if (lResult == ERROR_NO_MORE_ITEMS) {
                // clean break
                break;
            }

            // some sort of error, log and continue
            vLogMessage("[ConvertFormat] RegEnumKey (layers) returned error for index 0x%lx error 0x%lx\n",
                        dwIndex, lResult);
            break;
        }

        // for each of these -- call fixup function

        if (!ConvertEntryToNewFormat(hKey, szSubKeyName, &SdbList, bConvertToNewFormat)) {
            vLogMessage("[ConvertFormat] Failed to convert entry \"%ls\"\n", szSubKeyName);
        }
    }

    RegCloseKey(hKey);
    hKey = NULL;

ConvertComplete:

    bSuccess = TRUE;

cleanup:
    if (hKey != NULL) {
        RegCloseKey(hKey);
    }
    //
    // free SdbList
    //
    CleanupSdbList(&SdbList);

    return bSuccess;
}

BOOL
ProcessMSIPackages(
    PDB          pdb,
    TAGID        tiDatabase,
    LPCWSTR      pszGuidDB,
    ULONGLONG    ullSdbTimeStamp,
    INSTALL_MODE eMode)
{
    TAGID tiMsiPackage;
    TAGID tiMsiPackageID;
    GUID* pGuidID;
    WCHAR szRegPath[MAX_PATH];
    BOOL  bReturn = TRUE;
    WCHAR wszGuid[64];
    
    UNICODE_STRING ustrGuid = { 0 };

    tiMsiPackage = SdbFindFirstTag(pdb, tiDatabase, TAG_MSI_PACKAGE);
    
    while (tiMsiPackage && bReturn) {
        //
        // we have a package, extract/find TAG_MSI_PACKAGE_ID
        //
        tiMsiPackageID = SdbFindFirstTag(pdb, tiMsiPackage, TAG_MSI_PACKAGE_ID);
        if (!tiMsiPackageID) {
            vPrintError(IDS_MISSING_PACKAGE_ID);
            if (eMode == MODE_CLEANUP) {
                goto NextPackage;
            } else {
                bReturn = FALSE;
                break;
            }
        }

        pGuidID = (GUID*)SdbGetBinaryTagData(pdb, tiMsiPackageID);
        if (pGuidID == NULL) {
            vPrintError(IDS_MISSING_PACKAGE_ID);
            if (eMode == MODE_CLEANUP) {
                goto NextPackage;
            } else {
                bReturn = FALSE;
                break;
            }
        }


        if (!NT_SUCCESS(RtlStringFromGUID(*pGuidID, &ustrGuid))) {
            vPrintError(IDS_GUID_BAD_FORMAT);
            bReturn = FALSE;
            break;
        }

        RtlCopyMemory(wszGuid, ustrGuid.Buffer, ustrGuid.Length);
        wszGuid[ustrGuid.Length / sizeof(WCHAR)] = TEXT('\0');

        if (eMode == MODE_INSTALL) {
            bReturn = InstallSdbEntry(wszGuid, pszGuidDB, 0, 0, ullSdbTimeStamp, FALSE);
        } else {
            bReturn = UninstallSdbEntry(wszGuid, pszGuidDB, ullSdbTimeStamp, FALSE);
        }

        RtlFreeUnicodeString(&ustrGuid);

NextPackage:

        tiMsiPackage = SdbFindNextTag(pdb, tiDatabase, tiMsiPackage);
    }

    return bReturn;
}


#define MAX_FRIENDLY_NAME_LEN 256

BOOL
bHandleInstall(
    WCHAR*       wszSdbPath,
    INSTALL_MODE eMode,
    WCHAR*       wszSdbInstallPath
    )
{
    PDB      pdb = NULL;
    int      i;
    WCHAR    wszSdbName[MAX_PATH];
    WCHAR    wszSdbInstallName[MAX_PATH];
    HKEY     hKey = NULL;
    LONG     lRes;
    TAGID    tiDatabase, tiExe, tiLayer;
    TAGID    tiDBName = TAGID_NULL;
    WCHAR*   pszDBName = NULL;
    WCHAR    wszFriendlyName[MAX_FRIENDLY_NAME_LEN];
    WCHAR*   wszTemp;
    GUID     guidDB;
    NTSTATUS Status;
    FILETIME SystemTime;
    BOOL     bRet = TRUE;
    
    UNICODE_STRING ustrGUID;
    ULARGE_INTEGER TimeStamp = { 0 };

    //
    // determine the timestamp (for the install case)
    //
    if (eMode == MODE_INSTALL) {
        GetSystemTimeAsFileTime(&SystemTime);
        TimeStamp.LowPart  = SystemTime.dwLowDateTime;
        TimeStamp.HighPart = SystemTime.dwHighDateTime;
    }

    assert(wszSdbPath && wszSdbInstallPath);
    if (!wszSdbPath || !wszSdbInstallPath) {
        bRet = FALSE;
        goto quickOut;
    }

    ZeroMemory(wszFriendlyName, sizeof(wszFriendlyName));

    //
    // get the full path from the file name
    //
    wszTemp = wszGetFileFromPath(wszSdbPath);
    
    if (!wszTemp) {
        vPrintMessage(IDS_UNABLE_TO_GET_FILE);
        bRet = FALSE;
        goto quickOut;
    }
    
    wcscpy(wszSdbName, wszTemp);

    if (wcscmp(wszSdbName, L"sysmain.sdb") == 0) {
        vPrintError(IDS_CANT_INSTALL_SYS);
        bRet = FALSE;
        goto quickOut;
    }

    if (GetFileAttributesW(wszSdbPath) != -1 && bIsAlreadyInstalled(wszSdbPath)) {
        if (eMode == MODE_INSTALL) {
            //
            // they asked us to install, it's installed, so we're done
            //
            vPrintMessage(IDS_ALREADY_INSTALLED, wszSdbPath);
            goto quickOut;
        }
    } else {
        if (eMode == MODE_UNINSTALL) {
            //
            // they asked us to uninstall, it's not installed, so we're done
            //
            vPrintMessage(IDS_NOT_INSTALLED, wszSdbPath);
            goto quickOut;
        }
    }

    if (eMode == MODE_INSTALL) {
        //
        // find out what file name we're going to use for installing
        //
        if (!bFindInstallName(wszSdbPath, wszSdbInstallPath)) {
            bRet = FALSE;
            goto quickOut;
        }

    } else if (eMode == MODE_CLEANUP) {
        //
        // we're cleaning up a bad install, so we need to get the install name from the
        // install path
        //
        wszTemp = wszGetFileFromPath(wszSdbInstallPath);
        if (!wszTemp) {
            vPrintMessage(IDS_UNABLE_TO_GET_FILE);
            bRet = FALSE;
            goto quickOut;
        }

    } else {
        //
        // we're uninstalling, so the install name is the given name
        // and the install path is the given path
        //
        wcscpy(wszSdbInstallPath, wszSdbPath);
    }

    //
    // try to get the guid for later
    //
    if (!bGetGuid(wszSdbPath, &guidDB)) {
        bRet = FALSE;
        goto out;
    }

    //
    // check whether the guid is coopted from one of the known databases
    //
    if (IsKnownDatabaseGUID(&guidDB)) {
        vPrintError(IDS_CANT_INSTALL_SYS);
        bRet = FALSE;
        goto quickOut;
    }        


    //
    // in all cases, install name is the db GUID
    //
    Status = RtlStringFromGUID(guidDB, &ustrGUID);
    if (!NT_SUCCESS(Status)) {
        bRet = FALSE;
        goto out;
    }
    RtlCopyMemory(wszSdbInstallName, ustrGUID.Buffer, ustrGUID.Length);
    wszSdbInstallName[ustrGUID.Length/sizeof(WCHAR)] = L'\0';
    RtlFreeUnicodeString(&ustrGUID);

    //
    // if we're installing, make sure the root tags are in place
    //
    if (eMode == MODE_INSTALL) {
        lRes = RegCreateKeyExW(HKEY_LOCAL_MACHINE,
                               APPCOMPAT_KEY_PATH_W,
                               0,
                               NULL,
                               0,
                               KEY_ALL_ACCESS|GetWow64Flag(),
                               NULL,
                               &hKey,
                               NULL);

        if (lRes != ERROR_SUCCESS) {
            if (lRes == ERROR_ACCESS_DENIED) {
                vPrintError(IDS_NEED_INSTALL_PERMISSION);
            } else {
                vPrintError(IDS_CANT_CREATE_REG_KEY, APPCOMPAT_KEY_PATH_W);
            }
            bRet = FALSE;
            goto out;
        }

        RegCloseKey(hKey);
        hKey = NULL;

        lRes = RegCreateKeyExW(HKEY_LOCAL_MACHINE,
                               APPCOMPAT_KEY_PATH_CUSTOM_W,
                               0,
                               NULL,
                               0,
                               KEY_ALL_ACCESS|GetWow64Flag(),
                               NULL,
                               &hKey,
                               NULL);

        if (lRes != ERROR_SUCCESS) {
            vPrintError(IDS_CANT_CREATE_REG_KEY, APPCOMPAT_KEY_PATH_CUSTOM_W);
            bRet = FALSE;
            goto out;
        }

        RegCloseKey(hKey);
        hKey = NULL;
    }

    // Open the DB.
    pdb = SdbOpenDatabase(wszSdbPath, DOS_PATH);

    if (pdb == NULL) {
        vPrintError(IDS_UNABLE_TO_OPEN_FILE, wszSdbPath);
        bRet = FALSE;
        goto out;
    }

    tiDatabase = SdbFindFirstTag(pdb, TAGID_ROOT, TAG_DATABASE);
    if (!tiDatabase) {
        vPrintError(IDS_NO_DB_TAG, wszSdbPath);
        bRet = FALSE;
        goto out;
    }

    //
    // get the friendly name of the database
    //
    tiDBName = SdbFindFirstTag(pdb, tiDatabase, TAG_NAME);
    if (tiDBName) {
        pszDBName = SdbGetStringTagPtr(pdb, tiDBName);
    }

    //
    // if we don't find a friendly name, use the SDB file name
    //
    if (pszDBName) {
        wcsncpy(wszFriendlyName, pszDBName, MAX_FRIENDLY_NAME_LEN);
        wszFriendlyName[MAX_FRIENDLY_NAME_LEN - 1] = 0;
    } else {
        wcsncpy(wszFriendlyName, wszSdbName, MAX_FRIENDLY_NAME_LEN);
        wszFriendlyName[MAX_FRIENDLY_NAME_LEN - 1] = 0;
    }

    tiExe = SdbFindFirstTag(pdb, tiDatabase, TAG_EXE);
    while (tiExe) {
        WCHAR szRegPath[MAX_PATH];
        TAGID tiName, tiAction;
        WCHAR *szName;

        tiName = SdbFindFirstTag(pdb, tiExe, TAG_NAME);
        if (!tiName) {
            vPrintError(IDS_NO_EXE_NAME);
            bRet = FALSE;
            if (eMode == MODE_CLEANUP) {
                goto nextExe;
            } else {
                goto quickOut;
            }
        }
        szName = SdbGetStringTagPtr(pdb, tiName);
        if (!szName) {
            vPrintError(IDS_NO_EXE_NAME_PTR);
            bRet = FALSE;
            if (eMode == MODE_CLEANUP) {
                goto nextExe;
            } else {
                goto quickOut;
            }
        }

        //
        // See if this EXE has an ACTION node. Currently only EXEs shimmed with the LUA
        // shims have ACTION nodes.
        //
        tiAction = SdbFindFirstTag(pdb, tiExe, TAG_ACTION);
        
        if (eMode == MODE_INSTALL) {

            if (!InstallSdbEntry(szName, wszSdbInstallName, pdb, tiAction, TimeStamp.QuadPart, FALSE)) {
                bRet = FALSE;
                goto out;
            }

        } else {

            if (!UninstallSdbEntry(szName, wszSdbInstallName, TimeStamp.QuadPart, FALSE)) {
                goto quickOut;
            }
        }

nextExe:

        tiExe = SdbFindNextTag(pdb, tiDatabase, tiExe);
    }

    //
    // Loop through the published layers
    //
    tiLayer = SdbFindFirstTag(pdb, tiDatabase, TAG_LAYER);
    
    while (tiLayer) {
        WCHAR  szRegPath[MAX_PATH];
        TAGID  tiName;
        WCHAR* szName;

        tiName = SdbFindFirstTag(pdb, tiLayer, TAG_NAME);
        if (!tiName) {
            vPrintError(IDS_NO_EXE_NAME);
            bRet = FALSE;
            if (eMode == MODE_CLEANUP) {
                goto nextLayer;
            } else {
                goto quickOut;
            }
        }
        szName = SdbGetStringTagPtr(pdb, tiName);
        if (!szName) {
            vPrintError(IDS_NO_EXE_NAME_PTR);
            bRet = FALSE;
            if (eMode == MODE_CLEANUP) {
                goto nextLayer;
            } else {
                goto quickOut;
            }
        }

        if (eMode == MODE_INSTALL) {

            if (!InstallSdbEntry(szName, wszSdbInstallName, 0, 0, TimeStamp.QuadPart, TRUE)) {
                bRet = FALSE;
                goto out;
            }

        } else {

            if (!UninstallSdbEntry(szName, wszSdbInstallName, TimeStamp.QuadPart, TRUE)) {
                goto quickOut;
            }
        }

nextLayer:

        tiLayer = SdbFindNextTag(pdb, tiDatabase, tiLayer);
    }

    if (!ProcessMSIPackages(pdb, tiDatabase, wszSdbInstallName, TimeStamp.QuadPart, eMode)) {
        bRet = FALSE;
        goto quickOut;
    }

    if (pdb) {
        SdbCloseDatabase(pdb);
        pdb = NULL;
    }

    //
    // now that we've handled the registry keys, copy the file
    //
    if (eMode == MODE_INSTALL) {
        //
        // ensure the directory exists
        //
        CreateDirectoryW(g_wszCustom, NULL);
        if (!CopyFileW(wszSdbPath, wszSdbInstallPath, TRUE)) {
            vPrintError(IDS_CANT_COPY_FILE, wszSdbInstallPath);
            bRet = FALSE;
            goto out;
        }
    } else {
        //
        // ensure that we don't fail because of read-only files
        //
        SetFileAttributesW(wszSdbInstallPath, FILE_ATTRIBUTE_NORMAL);
        if (!DeleteFileW(wszSdbInstallPath)) {
            vPrintError(IDS_CANT_DELETE_FILE, wszSdbInstallPath);
            bRet = FALSE;
        }
    }


    //
    // set up or delete the uninstall registry keys
    //
    if (eMode == MODE_INSTALL) {
        WCHAR wszSDBInstPath[MAX_PATH];
        WCHAR wszUninstallPath[MAX_PATH];
        WCHAR wszUninstallString[MAX_PATH];

        //
        // goofball hack required because of crazy redirection strategy on IA64
        //
        wszSDBInstPath[0] = 0;
        GetSystemWindowsDirectoryW(wszSDBInstPath, MAX_PATH);
        wcscat(wszSDBInstPath, L"\\SysWow64\\sdbinst.exe");
        if (GetFileAttributesW(wszSDBInstPath) == -1) {
            //
            // there's no SysWow64 directory, so we'll just use system32
            //

            wszSDBInstPath[0] = 0;
            GetSystemWindowsDirectoryW(wszSDBInstPath, MAX_PATH);
            wcscat(wszSDBInstPath, L"\\system32\\sdbinst.exe");
        }

        wcscpy(wszUninstallPath, UNINSTALL_KEY_PATH);
        wcscat(wszUninstallPath, wszSdbInstallName);
        wcscat(wszUninstallPath, L".sdb");

        lRes = RegCreateKeyExW(HKEY_LOCAL_MACHINE,
                               wszUninstallPath,
                               0,
                               NULL,
                               REG_OPTION_NON_VOLATILE,
                               KEY_ALL_ACCESS|GetWow64Flag(),
                               NULL,
                               &hKey,
                               NULL);
        
        if (lRes != ERROR_SUCCESS) {
            vPrintError(IDS_CANT_CREATE_REG_KEY, wszUninstallPath);
            bRet = FALSE;
            goto out;
        }

        lRes = RegSetValueExW(hKey,
                              L"DisplayName",
                              0,
                              REG_SZ,
                              (PBYTE)wszFriendlyName,
                              (wcslen(wszFriendlyName) + 1) * sizeof(WCHAR));

        if (lRes != ERROR_SUCCESS) {
            vPrintError(IDS_CANT_CREATE_VALUE, wszUninstallPath);
            bRet = FALSE;
            goto out;
        }

        swprintf(wszUninstallString, L"%s -u \"%s\"", wszSDBInstPath, wszSdbInstallPath);

        lRes = RegSetValueExW(hKey, L"UninstallString", 0, REG_SZ,
                              (PBYTE)wszUninstallString, (wcslen(wszUninstallString) + 1) * sizeof(WCHAR));

        if (lRes != ERROR_SUCCESS) {
            vPrintError(IDS_CANT_CREATE_VALUE, wszUninstallPath);
            bRet = FALSE;
            goto out;
        }

        RegCloseKey(hKey);
        hKey = NULL;
    } else {

        WCHAR wszUninstallPath[MAX_PATH];

        lRes = RegOpenKeyExW(HKEY_LOCAL_MACHINE, UNINSTALL_KEY_PATH, 0, KEY_ALL_ACCESS|GetWow64Flag(), &hKey);

        if (lRes != ERROR_SUCCESS) {
            vPrintError(IDS_CANT_OPEN_REG_KEY, UNINSTALL_KEY_PATH);
            bRet = FALSE;
            goto out;
        }

        //
        // create sdb path name
        //
        wcscpy(wszUninstallPath, wszSdbInstallName);
        wcscat(wszUninstallPath, L".sdb");

        lRes = LocalRegDeleteKeyW(hKey, wszUninstallPath);

        if (lRes != ERROR_SUCCESS) {
            vPrintError(IDS_CANT_DELETE_REG_KEY, wszSdbInstallName, UNINSTALL_KEY_PATH);
        }

        RegCloseKey(hKey);
        hKey = NULL;
    }

    //
    // register or unregister the DB
    //
    if (eMode == MODE_INSTALL) {
        if (!SdbRegisterDatabaseEx(wszSdbInstallPath, SDB_DATABASE_SHIM, &TimeStamp.QuadPart)) {
            vPrintError(IDS_CANT_REGISTER_DB, wszFriendlyName);
            bRet = FALSE;
            goto out;
        }
    } else {
        if (!SdbUnregisterDatabase(&guidDB)) {
            vPrintError(IDS_CANT_UNREGISTER_DB, wszFriendlyName);
        }
    }

    if (eMode == MODE_INSTALL) {
        vPrintMessage(IDS_INSTALL_COMPLETE, wszFriendlyName);
    } else {
        vPrintMessage(IDS_UNINSTALL_COMPLETE, wszFriendlyName);
    }

out:

    //
    // always silently delete the file on uninstall, whether we failed to remove the
    // registry entries or not.
    //
    if (eMode != MODE_INSTALL) {
        //
        // need to make sure the pdb is closed before deleting it.
        //
        if (pdb) {
            SdbCloseDatabase(pdb);
            pdb = NULL;
        }
        //
        // ensure that we don't fail because of read-only files
        //
        SetFileAttributesW(wszSdbInstallPath, FILE_ATTRIBUTE_NORMAL);
        DeleteFileW(wszSdbInstallPath);
    }

quickOut:

    //
    // these cleanup steps are not strictly necessary, as they'll be cleaned up
    // on exit anyway. But what the heck.
    //
    if (pdb) {
        SdbCloseDatabase(pdb);
        pdb = NULL;
    }
    if (hKey) {
        RegCloseKey(hKey);
        hKey = NULL;
    }

    return bRet;
}


extern "C" int APIENTRY
wWinMain(
    HINSTANCE hInstance,
    HINSTANCE hPrevInstance,
    LPWSTR    lpCmdLine,
    int       nCmdShow
    )
{
    int         i;
    int         nReturn = 0;
    WCHAR       wszSdbName[MAX_PATH];
    WCHAR       wszSdbPath[MAX_PATH];
    WCHAR       wszSdbInstallPath[MAX_PATH];
    WCHAR       wszOldSdbPath[MAX_PATH];
    TAGID       tiDBName = TAGID_NULL;
    WCHAR*      pszDBName = NULL;
    WCHAR       wszFriendlyName[256];
    WCHAR       wszGuid[100];
    
    OSVERSIONINFO osvi;

    LPWSTR       szCommandLine;
    LPWSTR*      argv;
    int          argc;
    INSTALL_MODE eMode;

    g_hInst = hInstance;

    //
    // init custom directory
    //
    g_wszCustom[0] = 0;
    GetSystemWindowsDirectoryW(g_wszCustom, MAX_PATH);
#if defined(_WIN64)    
    wcscat(g_wszCustom, L"\\AppPatch\\Custom\\IA64\\");
#else
    wcscat(g_wszCustom, L"\\AppPatch\\Custom\\");
#endif // _WIN64

    RtlZeroMemory(&osvi, sizeof(OSVERSIONINFO));
    osvi.dwOSVersionInfoSize = sizeof(OSVERSIONINFO);

    GetVersionEx(&osvi);

    if (osvi.dwMajorVersion == 5 && osvi.dwMinorVersion == 0) {
        g_bWin2K = TRUE;
    }

    //
    // Note that this memory isn't freed because it will automatically
    // be freed on exit anyway, and there are a lot of exit cases from this application
    //
    szCommandLine = GetCommandLineW();
    argv = CommandLineToArgvW(szCommandLine, &argc);

    if (!argv) {
        vPrintError(IDS_CANT_GET_ARGS);
        return 1;
    }

    if (argc < 2) {
        vPrintHelp(argv[0]);
        return 0;
    }

    g_bQuiet = FALSE;
    eMode = MODE_INSTALL;
    wszSdbName[0] = 0;
    wszGuid[0] = 0;
    wszFriendlyName[0] = 0;

    for (i = 1; i < argc; ++i) {
        if (argv[i][0] == L'-' || argv[i][0] == L'/') {
            switch (tolower(argv[i][1])) {
            
            case L'?':
                vPrintHelp(argv[0]);
                return 0;
                break;

            case L'c':
                //
                // convert entries to new format
                //
                eMode = MODE_CONVERT_FORMAT_NEW;
                break;

            case L'g':
                i++;
                if (i >= argc) {
                    vPrintError(IDS_NEED_ARG, argv[i-1]);
                    vPrintHelp(argv[0]);
                    return 1;
                }
                eMode = MODE_UNINSTALL;
                wcscpy(wszGuid, argv[i]);
                break;

            case L'n':
                i++;
                if (i >= argc) {
                    vPrintError(IDS_NEED_ARG, argv[i-1]);
                    vPrintHelp(argv[0]);
                    return 1;
                }
                eMode = MODE_UNINSTALL;
                wcscpy(wszFriendlyName, argv[i]);
                break;

            case L'p':
                g_bAllowPatches = TRUE;
                break;

            case L'r':
                //
                // revert to old format
                //
                eMode = MODE_CONVERT_FORMAT_OLD;
                break;

            case L'q':
                g_bQuiet = TRUE;
                break;

            case L'u':
                eMode = MODE_UNINSTALL;
                break;

            default:
                vPrintError(IDS_INVALID_SWITCH, argv[i]);
                vPrintHelp(argv[0]);
                return 1;
            }
        } else {
            if (wszSdbName[0]) {
                vPrintError(IDS_TOO_MANY_ARGS);
                vPrintHelp(argv[0]);
                return 1;
            }
            wcscpy(wszSdbName, argv[i]);
        }
    }

    //
    // check to make sure the user is an administrator
    //
    if (!bCanRun()) {
        if (eMode == MODE_INSTALL) {
            vPrintError(IDS_NEED_INSTALL_PERMISSION);
        } else {
            vPrintError(IDS_NEED_UNINSTALL_PERMISSION);
        }
        return 1;
    }

    //
    // check if we are running in a special 'setup' mode (converting or reverting the entries)
    //
    if (eMode == MODE_CONVERT_FORMAT_NEW || eMode == MODE_CONVERT_FORMAT_OLD) {
        OpenLogFile();
        if (!ConvertFormat(eMode == MODE_CONVERT_FORMAT_NEW)) {
            nReturn = 1;
        }
        CloseLogFile();
        return nReturn;
    }

    if (eMode == MODE_INSTALL && !wszSdbName[0]) {
        vPrintError(IDS_MUST_SPECIFY_SDB);
        vPrintHelp(argv[0]);
        return 1;
    }
    if (eMode == MODE_UNINSTALL && !wszSdbName[0] && !wszGuid[0] && !wszFriendlyName[0]) {
        vPrintError(IDS_MUST_SPECIFY_SDB);
        vPrintHelp(argv[0]);
        return 1;
    }

    if (wszSdbName[0]) {
        if (wszSdbName[1] == L':' || wszSdbName[1] == L'\\') {
            //
            // this is a full path name, so just copy it
            //
            wcscpy(wszSdbPath, wszSdbName);
        } else {
            DWORD dwRet;

            //
            // this is a relative path name, so get the full one
            //
            if (!_wfullpath(wszSdbPath, wszSdbName, MAX_PATH)) {
                vPrintError(IDS_CANT_GET_FULL_PATH);
                return 1;
            }
        }
    }

    //
    // First, get the real file name from other params, if necessary
    //
    if (eMode == MODE_UNINSTALL) {
        if (wszGuid[0]) {
            DWORD dwLen = wcslen(wszGuid);

            if (dwLen != 38 || wszGuid[0] != L'{' || wszGuid[dwLen - 1] != L'}' ||
                wszGuid[9] != L'-' || wszGuid[14] != L'-' || wszGuid[19] != L'-' ||
                wszGuid[24] != L'-') {
                vPrintError(IDS_GUID_BAD_FORMAT);
                return 1;
            }
            wcscpy(wszSdbName, wszGuid);
            wcscat(wszSdbName, L".sdb");

            wcscpy(wszSdbPath, g_wszCustom);
            wcscat(wszSdbPath, wszSdbName);
        } else if (wszFriendlyName[0]) {
            if (!bFriendlyNameToFile(wszFriendlyName, wszSdbName, wszSdbPath)) {
                vPrintError(IDS_NO_FRIENDLY_NAME, wszFriendlyName);
                return 1;
            }
        } else {
            if (!bIsAlreadyInstalled(wszSdbPath)) {
                WCHAR wszSdbPathTemp[MAX_PATH];

                //
                // they're not giving us an installed file, so get the GUID and convert to a file
                //
                if (!bFindInstallName(wszSdbPath, wszSdbPathTemp)) {
                    return 1;
                }
                wcscpy(wszSdbName, wszSdbPathTemp); // name and path are the same
                wcscpy(wszSdbPath, wszSdbPathTemp);
            }
        }
    }

    if (eMode == MODE_INSTALL &&
        GetFileAttributesW(wszSdbPath) != -1 &&
        bIsAlreadyInstalled(wszSdbPath)) {
        
        //
        // they asked us to install, it's installed, so we're done
        //
        vPrintMessage(IDS_ALREADY_INSTALLED, wszSdbPath);
        goto quickOut;
    }

    if (eMode == MODE_UNINSTALL && GetFileAttributesW(wszSdbPath) == -1) {
        //
        // they asked us to uninstall, it's not installed, so we're done
        //
        vPrintMessage(IDS_NOT_INSTALLED, wszSdbName);
        goto quickOut;
    }

    if (eMode == MODE_INSTALL && DatabaseContainsPatch(wszSdbPath) && !g_bAllowPatches) {

        //
        // we can't install because the SDB contains a patch and the user hasn't authorized it.
        //
        // djm - can't use new text in XP SP1, so we'll print a generic error
        //
        //vPrintMessage(IDS_NO_PATCHES_ALLOWED);
        vPrintMessage(IDS_APP_ERROR_TITLE);
        goto quickOut;
    }

    if (eMode == MODE_INSTALL && bOldSdbInstalled(wszSdbPath, wszOldSdbPath)) {
        //
        // we should ask if we're going to uninstall the old one,
        // unless we're in quiet mode.
        //
        int nRet;
        WCHAR wszCaption[1024];
        WCHAR wszText[1024];

        if (g_bQuiet) {
            nRet = IDYES;
        } else {
            if (!LoadStringW(g_hInst, IDS_APP_TITLE, wszCaption, 1024)) {
                return 1;
            }
            if (!LoadStringW(g_hInst, IDS_FOUND_SAME_ID, wszText, 1024)) {
                return 1;
            }

            nRet = MessageBoxW(NULL,
                               wszText,
                               wszCaption,
                               MB_YESNO | MB_ICONQUESTION);
        }
        
        if (nRet == IDNO) {
            return 0;
        } else if (nRet == IDYES) {
            if (!bHandleInstall(wszOldSdbPath, MODE_UNINSTALL, wszSdbInstallPath)) {
                vPrintError(IDS_FAILED_UNINSTALL);
                return 1;
            }
        }
    }

    wszSdbInstallPath[0] = 0;

    if (!bHandleInstall(wszSdbPath, eMode, wszSdbInstallPath)) {
        if (eMode == MODE_INSTALL) {
            //
            // we need to clean up; the install failed.
            //
            g_bQuiet = TRUE;
            bHandleInstall(wszSdbPath, MODE_CLEANUP, wszSdbInstallPath);
        }
        nReturn = 1;
    }

    //
    // no matter what happens, flush the cache
    //
    vFlushCache();

quickOut:

    return nReturn;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\appcompat\tools\shimviewer\misc.cpp ===
/*++

  Copyright (c) 2001 Microsoft Corporation

  Module Name:

    Misc.cpp

  Abstract:

    Implements misc. functionality

  Notes:

    Unicode only

  History:

    05/04/2001  rparsons    Created

--*/

#include "precomp.h"

extern APPINFO g_ai;

/*++

  Routine Description:

    Retrieves or sets position info
    in the registry

  Arguments:

    fSave   -   If true, indicates we're saving data
    *lppt   -   A POINT structure that contains/receives our data

  Return Value:

    TRUE on success, FALSE otherwise

--*/
void
GetSavePositionInfo(
    IN     BOOL  fSave,
    IN OUT POINT *lppt
    )
{
    
    HKEY    hKey;
    DWORD   cbSize = 0, dwDisposition = 0;
    LONG    lRetVal = 0;
    char    szKeyName[] = "DlgCoordinates";
    
    //
    // Initialize our coordinates in case there's no data there
    //
    if (!fSave) {
        lppt->x = lppt->y = 0;
    }

    //
    // Open the registry key (or create it if the first time being used)
    //
    lRetVal = RegCreateKeyEx(HKEY_CURRENT_USER,
                             L"Software\\Microsoft\\ShimViewer",
                             0,
                             0,
                             REG_OPTION_NON_VOLATILE,
                             KEY_QUERY_VALUE | KEY_SET_VALUE,
                             0,
                             &hKey,
                             &dwDisposition);
    
    if (ERROR_SUCCESS != lRetVal) {
        return;
    }

    //
    // Save or retrieve our coordinates
    //
    if (fSave) {

        RegSetValueEx(hKey,
                      L"DlgCoordinates",
                      0,
                      REG_BINARY,
                      (PBYTE)lppt,
                      sizeof(*lppt));
    
    } else {

        cbSize = sizeof(*lppt);
        RegQueryValueEx(hKey,
                        L"DlgCoordinates",
                        0,
                        0,
                        (PBYTE)lppt,
                        &cbSize);
    }

    RegCloseKey(hKey);

    return;
}

/*++

  Routine Description:

    Retrieves or sets setting info.
    in the registry

  Arguments:

    fSave   -   If true, indicates we're saving data
    

  Return Value:

    TRUE on success, FALSE otherwise

--*/
void
GetSaveSettings(
    IN BOOL fSave
    )
{
    HKEY    hKey;
    LONG    lRetVal = 0;
    DWORD   dwOnTop = 0, dwMinimize = 0, dwMonitor = 1;
    DWORD   dwDisposition = 0, cbSize = 0;

    //
    // Open the registry key (or create it if the first time being used)
    //
    lRetVal = RegCreateKeyEx(HKEY_CURRENT_USER,
                             L"Software\\Microsoft\\ShimViewer",
                             0,
                             0,
                             REG_OPTION_NON_VOLATILE,
                             KEY_ALL_ACCESS,
                             0,
                             &hKey,
                             &dwDisposition);
    
    if (ERROR_SUCCESS != lRetVal) {
        return;
    }

    if (fSave) {

        if (g_ai.fOnTop) {
            dwOnTop |= 1;
        }

        if (g_ai.fMinimize) {
            dwMinimize |= 1;
        }

        if (g_ai.fMonitor) {
            dwMonitor |= 1;
        }

        lRetVal = RegSetValueEx(hKey,
                      L"AlwaysOnTop",
                      0,
                      REG_DWORD,
                      (LPBYTE)&dwOnTop,
                      sizeof(DWORD));

        RegSetValueEx(hKey,
                      L"StartMinimize",
                      0,
                      REG_DWORD,
                      (LPBYTE)&dwMinimize,
                      sizeof(DWORD));

        RegSetValueEx(hKey,
                      L"MonitorMessages",
                      0,
                      REG_DWORD,
                      (LPBYTE)&dwMonitor,
                      sizeof(DWORD));

        
    } else {

        cbSize = sizeof(DWORD);
        RegQueryValueEx(hKey,
                        L"AlwaysOnTop",
                        0,
                        0,
                        (PBYTE)&dwOnTop,
                        &cbSize);

        cbSize = sizeof(DWORD);
        RegQueryValueEx(hKey,
                        L"StartMinimize",
                        0,
                        0,
                        (PBYTE)&dwMinimize,
                        &cbSize);

        cbSize = sizeof(DWORD);
        lRetVal = RegQueryValueEx(hKey,
                                  L"MonitorMessages",
                                  0,
                                  0,
                                  (PBYTE)&dwMonitor,
                                  &cbSize);

        if (dwOnTop) {
            g_ai.fOnTop = TRUE;
        }

        if (dwMinimize) {
            g_ai.fMinimize = TRUE;
        }

        if ((dwMonitor) || (ERROR_SUCCESS != lRetVal)) {
            g_ai.fMonitor = TRUE;
        }

    }

    RegCloseKey(hKey);
    
    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\appcompat\tools\shimviewer\pipe.cpp ===
/*++

  Copyright (c) 2001 Microsoft Corporation

  Module Name:

    Pipe.cpp

  Abstract:

    Implements code that creates and maintains
    the named pipe server

  Notes:

    Unicode only

  History:

    05/04/2001  rparsons    Created

--*/

#include "precomp.h"

extern APPINFO g_ai;

/*++

  Routine Description:

    Creates a pipe and waits for a client connection
    to occur

  Arguments:

    *pVoid      -       Not used

  Return Value:

    TRUE on success, FALSE otherwise

--*/
UINT
CreatePipeAndWait(
    IN VOID* pVoid
    )
{
    HANDLE hPipe, hThread;
    BOOL   fConnected = FALSE;
    
    while (g_ai.fMonitor) {
        
        //
        // Create the named pipe
        //
        hPipe = CreateNamedPipe(PIPE_NAME,                // pipe name 
                                PIPE_ACCESS_INBOUND,      // read access 
                                PIPE_TYPE_MESSAGE |       // message type pipe 
                                PIPE_READMODE_MESSAGE |   // message-read mode 
                                PIPE_WAIT,                // blocking mode 
                                PIPE_UNLIMITED_INSTANCES, // max. instances  
                                0,                        // output buffer size 
                                2048,                     // input buffer size 
                                0,                        // client time-out 
                                NULL);                    // no security attribute 

        if (INVALID_HANDLE_VALUE == hPipe) {
            return -1;
        }

        //
        // Wait for clients to connect
        //
        fConnected = ConnectNamedPipe(hPipe, NULL) ? TRUE : (GetLastError() == ERROR_PIPE_CONNECTED);

        if (fConnected && g_ai.fMonitor) {
            
            hThread = (HANDLE) _beginthreadex(NULL,
                                              0,
                                              &InstanceThread,
                                              (LPVOID)hPipe,
                                              0,
                                              &g_ai.uInstThreadId);
            
            if (INVALID_HANDLE_VALUE == hThread) {
                return -1;
            } else {
                CloseHandle(hThread);
            }
        
        } else {
            CloseHandle(hPipe);
        }
    }

    return 0;
}

/*++

  Routine Description:

    Creates a thread that is responsible
    for starting the named pipe server

  Arguments:

    None

  Return Value:

    TRUE on success, FALSE otherwise

--*/
BOOL
CreateReceiveThread(
    IN VOID
    )
{
    HANDLE  hThread;    

    hThread = (HANDLE) _beginthreadex(NULL, 0, &CreatePipeAndWait, NULL, 0, &g_ai.uThreadId);
    CloseHandle(hThread);

    return TRUE;
}

/*++

  Routine Description:

    Thread callback responsible for
    receiving data from the client

  Arguments:

    *pVoid      -   A handle to the pipe

  Return Value:

    TRUE on success, FALSE otherwise

--*/
UINT
InstanceThread(
    IN VOID *pVoid
    )
{
    HANDLE              hPipe;
    BOOL                fSuccess = TRUE;
    DWORD               cbBytesRead = 0;
    WCHAR               wszBuffer[2048];
    WCHAR               *p;
    int                 nCount = 0;

    // Get the pipe handle
    hPipe = (HANDLE)pVoid;

    while (TRUE) {
                
        fSuccess = ReadFile(hPipe,
                            wszBuffer,
                            2048,
                            &cbBytesRead,
                            NULL);

        if (!fSuccess || cbBytesRead == 0) 
            break;

        // Ensure that the data is NULL terminated
        wszBuffer[cbBytesRead / sizeof(WCHAR)] = 0;

        // See if this is a new process notification
        p = wcsstr(wszBuffer, L"process");

        if (p) {

            // We got a new process notification.
            // See if any items are already in the list
            nCount = ListView_GetItemCount(g_ai.hWndList);                                                

            if (nCount) {
                AddListViewItem(L"");
            }
        }
        
        // Add the item to the list box in a normal fashion
        AddListViewItem(wszBuffer);
    }

    // Flush the pipe to allow the client to read the pipe's contents 
    // before disconnecting. Then disconnect the pipe, and close the 
    // handle to this pipe instance
    FlushFileBuffers(hPipe); 
    DisconnectNamedPipe(hPipe); 
    CloseHandle(hPipe);
    
    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\appcompat\tools\shimviewer\listview.cpp ===
/*++

  Copyright (c) 2001 Microsoft Corporation

  Module Name:

    Listview.cpp

  Abstract:

    Manages the list view

  Notes:

    Unicode only

  History:

    05/04/2001  rparsons    Created

--*/

#include "precomp.h"

extern APPINFO g_ai;

/*++

  Routine Description:

    Initializes the list view column

  Arguments:

    None

  Return Value:

    -1 on failure

--*/
int
InitListViewColumn(
    VOID
    )
{
    LVCOLUMN    lvc;

    lvc.mask        =   LVCF_TEXT | LVCF_WIDTH | LVCF_SUBITEM;
    lvc.iSubItem    =   0;
    lvc.pszText     =   (LPWSTR) L"Messages";
    lvc.cx          =   555;    

    return (ListView_InsertColumn(g_ai.hWndList, 1, &lvc));    
}

/*++

  Routine Description:

    Adds an item to the list view

  Arguments:

    lpwText     -       Text that belongs to the item

  Return Value:

    -1 on failure

--*/
int
AddListViewItem(
    IN LPWSTR lpwItemText
    )
{
    LVITEM  lvi;

    lvi.iItem       =   ListView_GetItemCount(g_ai.hWndList);
    lvi.mask        =   LVIF_TEXT;
    lvi.iSubItem    =   0;
    lvi.pszText     =   lpwItemText;

    ListView_InsertItem(g_ai.hWndList, &lvi);

    ListView_EnsureVisible(g_ai.hWndList, lvi.iItem, FALSE);

    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\appcompat\tools\shimviewer\precomp.h ===
/*++

  Copyright (c) 2001 Microsoft Corporation

  Module Name:

    Precomp.h

  Abstract:

    Contains constants, function prototypes,
    structures, etc. used throughout the
    application

  Notes:

    Unicode only

  History:

    05/04/2001  rparsons    Created

--*/
#ifndef UNICODE
#define  UNICODE
#endif

#ifndef _X86_
#define _X86_
#endif

#ifndef  _UNICODE
#define  _UNICODE
#endif

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <process.h>
#include <string.h>
#include <commctrl.h>
#include <shellapi.h>
#include "resource.h"

#define     APP_NAME        L"ShimViewer"
#define     APP_CLASS       L"SHIMVIEW"
#define     WRITTEN_BY      L"Written by rparsons"
//#define     PIPE_NAME       L"\\Device\\NamedPipe\\ShimViewer"
#define     PIPE_NAME       L"\\\\.\\pipe\\ShimViewer" 

#define     ICON_NOTIFY     10101
#define     WM_NOTIFYICON   (WM_APP+100)

typedef struct _APPINFO {
        HWND        hMainDlg;           // main dialog handle
        HWND        hWndList;           // list view handle
        HINSTANCE   hInstance;          // main instance handle
        BOOL        fOnTop;             // flag for window position
        BOOL        fMinimize;          // flag for window placement
        BOOL        fMonitor;           // flag for monitoring messages
        UINT        uThreadId;          // receive thread identifier
        UINT        uInstThreadId;      // instance thread identifier
} APPINFO, *PAPPINFO, *LPAPPINFO;

LRESULT
CALLBACK
MainWndProc(
    IN HWND   hWnd,
    IN UINT   uMsg,
    IN WPARAM wParam,
    IN LPARAM lParam
    );

BOOL 
AddIconToTray(
    IN HWND hWnd,
    IN HICON hIcon,
    IN LPCWSTR lpwTip
    );

BOOL
RemoveFromTray(
    IN HWND hWnd
    );

BOOL 
DisplayMenu(
    IN HWND hWnd
    );

DWORD
pCreateNamedPipe(
    IN  PCWSTR pwPipeName,
    OUT HANDLE *phPipe
    );

BOOL
CreateReceiveThread(
    IN VOID
    );

UINT
InstanceThread(
    IN VOID *pVoid
    );

UINT
CreatePipeAndWait(
    IN VOID *pVoid
    );

void
GetSavePositionInfo(
    IN     BOOL  fSave,
    IN OUT POINT *lppt
    );

void
GetSaveSettings(
    IN BOOL fSave
    );

int
InitListViewColumn(
    VOID
    );

int
AddListViewItem(
    IN LPWSTR lpwItemText
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\appcompat\tools\shimviewer\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by shimview.rc
//
#define IDS_NO_CLASS                    1
#define IDS_NO_MAIN_DLG                 2
#define IDS_CREATE_FAILED               3
#define IDD_MAIN                        101
#define IDR_MENU                        102
#define IDI_APPICON                     102
#define IDM_MENU                        102
#define IDM_POPUP                       104
#define IDC_LIST                        1000
#define IDM_MONITOR                     40001
#define IDM_EXIT                        40002
#define IDM_ABOUT                       40003
#define IDM_ON_TOP                      40004
#define IDM_RESTORE                     40005
#define IDM_START_SMALL                 40006
#define IDM_CLEAR                       40007

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        104
#define _APS_NEXT_COMMAND_VALUE         40008
#define _APS_NEXT_CONTROL_VALUE         1005
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\appcompat\tools\shimviewer\main.cpp ===
/*++

  Copyright (c) 2001 Microsoft Corporation

  Module Name:

    Main.cpp

  Abstract:

    Implements the entry point and message
    pump for the application

  Notes:

    Unicode only

  History:

    05/04/2001  rparsons    Created

--*/

#include "precomp.h"

// Disable warning about possible loss of data
#pragma warning (disable : 4244)  

APPINFO g_ai;

/*++

  Routine Description:

    Application entry point

  Arguments:

    hInstance        -    App instance handle
    hPrevInstance    -    Always NULL
    lpCmdLine        -    Pointer to the command line
    nCmdShow         -    Window show flag

  Return Value:

    The wParam of the message or 0 on failure

--*/
int
CALLBACK
WinMain(
    IN HINSTANCE hInstance,
    IN HINSTANCE hPrevInstance,
    IN LPSTR     lpCmdLine,
    IN int       nCmdShow
    )
{      
    MSG                     msg;
    WNDCLASS                wndclass;
    WCHAR                   wszError[MAX_PATH];
    RECT                    rcDesktop;
    RECT                    rcDialog;
    INITCOMMONCONTROLSEX    icex;
    POINT                   pt;
    HANDLE                  hMutex;
            
    UNREFERENCED_PARAMETER(lpCmdLine);
    UNREFERENCED_PARAMETER(hPrevInstance);

    g_ai.hInstance = hInstance;

    //
    // Make sure we're the only instance running
    //
    hMutex = CreateMutex(NULL, FALSE, L"ShimViewer");

    if (ERROR_ALREADY_EXISTS == GetLastError()) {
        return 0;
    }

    wndclass.style          = CS_HREDRAW | CS_VREDRAW;
    wndclass.lpfnWndProc    = (WNDPROC) MainWndProc;
    wndclass.cbClsExtra     = 0;
    wndclass.cbWndExtra     = DLGWINDOWEXTRA;
    wndclass.hInstance      = hInstance;
    wndclass.hIcon          = NULL;
    wndclass.hCursor        = LoadCursor(NULL, IDC_ARROW);
    wndclass.hbrBackground  = (HBRUSH) (COLOR_BTNFACE+1);
    wndclass.lpszMenuName   = NULL;
    wndclass.lpszClassName  = APP_CLASS;

    if (!RegisterClass(&wndclass))
    {
        LoadString(hInstance, IDS_NO_CLASS, wszError, sizeof(wszError));
        MessageBox(NULL, wszError, APP_NAME, MB_OK | MB_ICONERROR);
        return 0;
    }

    //
    // Set up the common controls
    // 
    icex.dwSize     =   sizeof(INITCOMMONCONTROLSEX);
    icex.dwICC      =   ICC_LISTVIEW_CLASSES;

    if (!InitCommonControlsEx(&icex)) {
        InitCommonControls();
    }

    //
    // Get application settings from the registry, if there are any
    //
    GetSaveSettings(FALSE);

    g_ai.hMainDlg = CreateDialog(hInstance, (LPCTSTR) IDD_MAIN,
                              NULL, (DLGPROC)MainWndProc);

    if (!g_ai.hMainDlg)
    {
        LoadString(hInstance, IDS_NO_MAIN_DLG, wszError, sizeof(wszError));
        MessageBox(NULL, wszError, APP_NAME, MB_OK | MB_ICONERROR);
        return 0;
    }

    //
    // Get the window position info from the registry, if it's there
    //
    GetSavePositionInfo(FALSE, &pt);

    //
    // Get the coords of the desktop window and place the dialog
    //
    GetWindowRect(GetDesktopWindow(), &rcDesktop);
    GetWindowRect(g_ai.hMainDlg, &rcDialog);

    double nWidth = rcDialog.right - rcDialog.left;
    double nHeight = rcDialog.bottom - rcDialog.top;

    //
    // If nothing was stored in the registry, use default settings
    //
    if (pt.x != 0) {
        
        //
        // If the flag is set, make the window topmost
        //
        SetWindowPos(g_ai.hMainDlg,
                     g_ai.fOnTop ? HWND_TOPMOST : HWND_NOTOPMOST,
                     pt.x, pt.y, 0, 0,
                     SWP_NOSIZE | SWP_SHOWWINDOW);
    
    } else {

        //
        // If the flag is set, make the window topmost
        //
        SetWindowPos(g_ai.hMainDlg,
                     g_ai.fOnTop ? HWND_TOPMOST : HWND_NOTOPMOST,
                     (rcDesktop.right  / 1.05) - (nWidth  / 1.05),
                     (rcDesktop.bottom / 1.05) - (nHeight / 1.05),
                     0, 0,
                     SWP_NOSIZE | SWP_SHOWWINDOW);
    }

    //
    // If the flag is set, make the window minimized
    //
    ShowWindow(g_ai.hMainDlg,
               g_ai.fMinimize ? SW_MINIMIZE : SW_SHOWNORMAL);
    
    while (GetMessage(&msg, (HWND) NULL, 0, 0)) {
        if (!IsDialogMessage(g_ai.hMainDlg, &msg)) {
            TranslateMessage(&msg);
            DispatchMessage(&msg);
        }
    }
    
    return msg.wParam;
}

/*++

  Routine Description:

    Runs the message loop for the app

  Arguments:

    hWnd        -    Handle to the window
    uMsg        -    Windows message
    wParam      -    Additional message info
    lParam      -    Additional message info

  Return Value:

    TRUE if handled, FALSE otherwise

--*/
LRESULT
CALLBACK
MainWndProc(
    IN HWND   hWnd,
    IN UINT   uMsg,
    IN WPARAM wParam,
    IN LPARAM lParam
    )
{
    switch (uMsg) { 

        case WM_INITDIALOG:
        {
            WCHAR   wszError[MAX_PATH];
            
            //
            // Get the handle to the listview and do some init stuff
            //
            g_ai.hWndList = GetDlgItem(hWnd, IDC_LIST);
            InitListViewColumn();

            //
            // Set up our icon, initialize the menu items, and create the thread
            //
            SendMessage(hWnd,
                        WM_SETICON,
                        TRUE,
                        (LPARAM)LoadIcon(g_ai.hInstance, MAKEINTRESOURCE(IDI_APPICON)));            

            CheckMenuItem(GetMenu(hWnd),
                          IDM_ON_TOP,
                          g_ai.fOnTop ? MF_CHECKED : MF_UNCHECKED);

            CheckMenuItem(GetMenu(hWnd),
                          IDM_START_SMALL,
                          g_ai.fMinimize ? MF_CHECKED : MF_UNCHECKED);

            CheckMenuItem(GetMenu(hWnd),
                          IDM_MONITOR,
                          g_ai.fMonitor ? MF_CHECKED : MF_UNCHECKED);

            if (!CreateReceiveThread())
            {
                LoadString(g_ai.hInstance, IDS_CREATE_FAILED, wszError, MAX_PATH);
                MessageBox(hWnd, wszError, APP_NAME, MB_OK | MB_ICONERROR);
                g_ai.fMonitor = FALSE;
            
            } else {
                SetPriorityClass(GetCurrentProcess(), ABOVE_NORMAL_PRIORITY_CLASS);
            }
        
            break;
        }

        case WM_CLOSE:
        {
            RECT    rc;

            GetWindowRect(hWnd, &rc);
            GetSavePositionInfo(TRUE, (LPPOINT)&rc);
            GetSaveSettings(TRUE);
            RemoveFromTray(hWnd);
            EndDialog(hWnd, 0);
            PostQuitMessage(0);
            break;
        }

        case WM_SIZE:
        
            if (SIZE_MINIMIZED == wParam) {

                ShowWindow(hWnd, SW_HIDE);
                
                AddIconToTray(hWnd,
                             (HICON) LoadImage(g_ai.hInstance,
                             MAKEINTRESOURCE(IDI_APPICON),
                             IMAGE_ICON, 16, 16, 0),
                             APP_NAME);
                return TRUE;
            }

            MoveWindow(g_ai.hWndList, 0, 0, LOWORD(lParam), HIWORD(lParam), TRUE);

            break;
        
        case WM_NOTIFYICON:
    
            switch (lParam) {
        
                case WM_RBUTTONUP:
                    DisplayMenu(hWnd);
                    break;
            
                case WM_LBUTTONDBLCLK:
                    RemoveFromTray(hWnd);
                    ShowWindow(hWnd, SW_SHOWNORMAL);
                    break;
            }
            break;

        case WM_COMMAND:

            switch (LOWORD(wParam)) {
            
                case IDM_EXIT:
                    PostMessage(hWnd, WM_CLOSE, 0, 0);
                    break;

                case IDM_RESTORE:
                    ShowWindow(hWnd, SW_SHOWNORMAL);
                    SetWindowPos(hWnd, g_ai.fOnTop ? HWND_TOPMOST : HWND_NOTOPMOST,
                                 0,0,0,0, SWP_NOSIZE | SWP_NOMOVE);
                    RemoveFromTray(hWnd);
                    break;

                case IDM_ABOUT:
                    ShellAbout(hWnd, APP_NAME, WRITTEN_BY, LoadIcon(g_ai.hInstance, MAKEINTRESOURCE(IDI_APPICON)));
                    break;

                case IDM_MONITOR:
                    CheckMenuItem(GetMenu(hWnd),
                                  IDM_MONITOR,
                                  g_ai.fMonitor ? MF_UNCHECKED : MF_CHECKED);
                    g_ai.fMonitor = g_ai.fMonitor ? FALSE : TRUE;
                    if (g_ai.fMonitor) {
                        CreateReceiveThread();
                    }
                    break;

                case IDM_ON_TOP:
                    CheckMenuItem(GetMenu(hWnd),
                                  IDM_ON_TOP,
                                  g_ai.fOnTop ? MF_UNCHECKED : MF_CHECKED);
                    SetWindowPos(hWnd, g_ai.fOnTop ? HWND_NOTOPMOST : HWND_TOPMOST,
                                 0,0,0,0, SWP_NOSIZE | SWP_NOMOVE);
                    g_ai.fOnTop = g_ai.fOnTop ? FALSE : TRUE;
                    break;

                case IDM_START_SMALL:
                    CheckMenuItem(GetMenu(hWnd),
                                  IDM_START_SMALL,
                                  g_ai.fMinimize ? MF_UNCHECKED : MF_CHECKED);
                    g_ai.fMinimize = g_ai.fMinimize ? FALSE : TRUE;
                    break;

                case IDM_CLEAR:
                    ListView_DeleteAllItems(g_ai.hWndList);
                    break;

                default:
                    break;
            }
    }

    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\appcompat\tools\shimviewer\tray.cpp ===
/*++

  Copyright (c) 2001 Microsoft Corporation

  Module Name:

    Tray.cpp

  Abstract:

    Implements systray functionality

  Notes:

    Unicode only

  History:

    05/04/2001  rparsons    Created

--*/

#include "precomp.h"

/*++

  Routine Description:

    Adds the specified icon to the system tray

  Arguments:

    hWnd    -   Parent window handle
    hIcon   -   Icon hanle to add to the tray
    lpwTip  -   Tooltip to associate with the icon

  Return Value:

    TRUE on success, FALSE otherwise

--*/
BOOL 
AddIconToTray(
    IN HWND hWnd,
    IN HICON hIcon,
    IN LPCWSTR lpwTip
    )
{
    NOTIFYICONDATA  pnid;
    BOOL            fReturn = FALSE;

    pnid.cbSize             =    sizeof(NOTIFYICONDATA); 
    pnid.hWnd               =    hWnd; 
    pnid.uID                =    ICON_NOTIFY; 
    pnid.uFlags             =    NIF_ICON | NIF_MESSAGE | NIF_TIP; 
    pnid.uCallbackMessage   =    WM_NOTIFYICON; 
    pnid.hIcon              =    hIcon;
    
    if (lpwTip) {
        wcsncpy(pnid.szTip, lpwTip, wcslen(lpwTip)*sizeof(WCHAR));    
    } else {
        pnid.szTip[0]       =   '\0';
    }
    
    fReturn = Shell_NotifyIcon(NIM_ADD, &pnid);
    
    if (hIcon) {
        DestroyIcon(hIcon);
    }

    return (fReturn ? TRUE : FALSE);
}

/*++

  Routine Description:

    Removes the specified icon from the system tray

  Arguments:

    hWnd    -   Parent window handle    

  Return Value:

    TRUE on success, FALSE otherwise

--*/
BOOL
RemoveFromTray(
    IN HWND hWnd
    )
{
    NOTIFYICONDATA  pnid;
    BOOL            fReturn = FALSE;

    pnid.cbSize     =    sizeof(NOTIFYICONDATA); 
    pnid.hWnd       =    hWnd; 
    pnid.uID        =    ICON_NOTIFY; 
    
    fReturn = Shell_NotifyIcon(NIM_DELETE, &pnid);

    return (fReturn);
}

/*++

  Routine Description:

    Displays a popup menu for the tray icon.

  Arguments:

    hWnd    -   Main window handle    

  Return Value:

    TRUE on success, FALSE otherwise.

--*/
BOOL 
DisplayMenu(
    IN HWND hWnd
    )
{
    MENUITEMINFO mii;
    HMENU hMenu = NULL, hPopupMenu = NULL;    
    POINT pt;
    BOOL fReturn = FALSE;    
    
    hMenu = CreatePopupMenu();

    if (hMenu) {

        mii.cbSize          =   sizeof(MENUITEMINFO);
        mii.fMask           =   MIIM_DATA | MIIM_ID | MIIM_TYPE | MIIM_STATE;
        mii.fType           =   MFT_STRING;                            
        mii.wID             =   IDM_RESTORE;
        mii.hSubMenu        =   NULL;                                
        mii.hbmpChecked     =   NULL;                                
        mii.hbmpUnchecked   =   NULL;                                
        mii.dwItemData      =   0L;
        mii.dwTypeData      =   L"&Restore";
        mii.cch             =   14;
        mii.fState          =   MFS_ENABLED;

        InsertMenuItem(hMenu, 0, TRUE, &mii);

        mii.cbSize          =   sizeof(MENUITEMINFO);  
        mii.fMask           =   MIIM_TYPE; 
        mii.fType           =   MFT_SEPARATOR; 
        mii.hSubMenu        =   NULL; 
        mii.hbmpChecked     =   NULL; 
        mii.hbmpUnchecked   =   NULL; 
        mii.dwItemData      =   0L;
        
        InsertMenuItem(hMenu, 1, TRUE, &mii);

        mii.cbSize           =  sizeof(MENUITEMINFO);
        mii.fMask            =  MIIM_DATA | MIIM_ID | MIIM_TYPE | MIIM_STATE;
        mii.fType            =  MFT_STRING;                            
        mii.wID              =  IDM_EXIT;
        mii.hSubMenu         =  NULL;                                
        mii.hbmpChecked      =  NULL;                                
        mii.hbmpUnchecked    =  NULL;                                
        mii.dwItemData       =  0L;
        mii.dwTypeData       =  L"E&xit";
        mii.cch              =  10;
        mii.fState           =  MFS_ENABLED;

        InsertMenuItem(hMenu, 2, TRUE, &mii);

        // Get the coordinates of the cursor
        GetCursorPos(&pt);        

        // Show the popup menu - the menu is left aligned and
        // we're tracking the left button or right button
        fReturn = TrackPopupMenuEx(hMenu, TPM_CENTERALIGN | TPM_RIGHTBUTTON,
                                   pt.x, pt.y, hWnd, NULL);
    }

    if (hMenu) {
        DestroyMenu(hMenu);
    }

    return (fReturn);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\appcompat\tools\smvtest\common\common.h ===
/*++

Copyright (c) 2000-2001  Microsoft Corporation

Module Name:

    Common.h

Abstract:

    This file has common stuff among SMVTest, SMVDDLL and SMVSDLL.

Author:

    Diaa Fathalla (DiaaF)   11-Dec-2000

Revision History:

--*/

#ifndef _COMMON_H_
#define _COMMON_H_

#include "..\excluded\excluded.h"
LPCTSTR SHIM_TEST = TEXT("123");

extern "C" BOOL TestResults(LPCTSTR szTestStr)
{
	TCHAR  szTemp[MAX_PATH];
	LPTSTR szReturn;
	
	szReturn = NOT_HOOKEDGetCommandLine();
	_tcscpy(szTemp, szReturn);
	_tcscat(szTemp, SHIM_TEST);

	if (_tcscmp(szTemp,szTestStr) == 0)
		return TRUE;

	return FALSE;
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\appcompat\tools\smvtest\common\afxres.h ===
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) 1992-1998 Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#ifndef __AFXRES_H__
#define __AFXRES_H__

#ifdef RC_INVOKED
#ifndef _INC_WINDOWS
#define _INC_WINDOWS
	#include "winres.h"           // extract from windows header
#endif
#endif

#ifdef _AFX_MINREBUILD
#pragma component(minrebuild, off)
#endif

#ifdef APSTUDIO_INVOKED
#define APSTUDIO_HIDDEN_SYMBOLS
#endif

/////////////////////////////////////////////////////////////////////////////
// MFC resource types (see Technical note TN024 for implementation details)

#ifndef RC_INVOKED
#define RT_DLGINIT  MAKEINTRESOURCE(240)
#define RT_TOOLBAR  MAKEINTRESOURCE(241)
#endif

/////////////////////////////////////////////////////////////////////////////

#ifdef APSTUDIO_INVOKED
#undef APSTUDIO_HIDDEN_SYMBOLS
#endif

/////////////////////////////////////////////////////////////////////////////
// General style bits etc

// ControlBar styles
#define CBRS_ALIGN_LEFT     0x1000L
#define CBRS_ALIGN_TOP      0x2000L
#define CBRS_ALIGN_RIGHT    0x4000L
#define CBRS_ALIGN_BOTTOM   0x8000L
#define CBRS_ALIGN_ANY      0xF000L

#define CBRS_BORDER_LEFT    0x0100L
#define CBRS_BORDER_TOP     0x0200L
#define CBRS_BORDER_RIGHT   0x0400L
#define CBRS_BORDER_BOTTOM  0x0800L
#define CBRS_BORDER_ANY     0x0F00L

#define CBRS_TOOLTIPS       0x0010L
#define CBRS_FLYBY          0x0020L
#define CBRS_FLOAT_MULTI    0x0040L
#define CBRS_BORDER_3D      0x0080L
#define CBRS_HIDE_INPLACE   0x0008L
#define CBRS_SIZE_DYNAMIC   0x0004L
#define CBRS_SIZE_FIXED     0x0002L
#define CBRS_FLOATING       0x0001L

#define CBRS_GRIPPER        0x00400000L

#define CBRS_ORIENT_HORZ    (CBRS_ALIGN_TOP|CBRS_ALIGN_BOTTOM)
#define CBRS_ORIENT_VERT    (CBRS_ALIGN_LEFT|CBRS_ALIGN_RIGHT)
#define CBRS_ORIENT_ANY     (CBRS_ORIENT_HORZ|CBRS_ORIENT_VERT)

#define CBRS_ALL            0x0040FFFFL

// the CBRS_ style is made up of an alignment style and a draw border style
//  the alignment styles are mutually exclusive
//  the draw border styles may be combined
#define CBRS_NOALIGN        0x00000000L
#define CBRS_LEFT           (CBRS_ALIGN_LEFT|CBRS_BORDER_RIGHT)
#define CBRS_TOP            (CBRS_ALIGN_TOP|CBRS_BORDER_BOTTOM)
#define CBRS_RIGHT          (CBRS_ALIGN_RIGHT|CBRS_BORDER_LEFT)
#define CBRS_BOTTOM         (CBRS_ALIGN_BOTTOM|CBRS_BORDER_TOP)

/////////////////////////////////////////////////////////////////////////////
// Standard window components

// Mode indicators in status bar - these are routed like commands
#define ID_INDICATOR_EXT                0xE700  // extended selection indicator
#define ID_INDICATOR_CAPS               0xE701  // cap lock indicator
#define ID_INDICATOR_NUM                0xE702  // num lock indicator
#define ID_INDICATOR_SCRL               0xE703  // scroll lock indicator
#define ID_INDICATOR_OVR                0xE704  // overtype mode indicator
#define ID_INDICATOR_REC                0xE705  // record mode indicator
#define ID_INDICATOR_KANA               0xE706  // kana lock indicator

#define ID_SEPARATOR                    0   // special separator value

#ifndef RC_INVOKED  // code only
// Standard control bars (IDW = window ID)
#define AFX_IDW_CONTROLBAR_FIRST        0xE800
#define AFX_IDW_CONTROLBAR_LAST         0xE8FF

#define AFX_IDW_TOOLBAR                 0xE800  // main Toolbar for window
#define AFX_IDW_STATUS_BAR              0xE801  // Status bar window
#define AFX_IDW_PREVIEW_BAR             0xE802  // PrintPreview Dialog Bar
#define AFX_IDW_RESIZE_BAR              0xE803  // OLE in-place resize bar
#define AFX_IDW_REBAR                   0xE804  // COMCTL32 "rebar" Bar
#define AFX_IDW_DIALOGBAR               0xE805  // CDialogBar

// Note: If your application supports docking toolbars, you should
//  not use the following IDs for your own toolbars.  The IDs chosen
//  are at the top of the first 32 such that the bars will be hidden
//  while in print preview mode, and are not likely to conflict with
//  IDs your application may have used succesfully in the past.

#define AFX_IDW_DOCKBAR_TOP             0xE81B
#define AFX_IDW_DOCKBAR_LEFT            0xE81C
#define AFX_IDW_DOCKBAR_RIGHT           0xE81D
#define AFX_IDW_DOCKBAR_BOTTOM          0xE81E
#define AFX_IDW_DOCKBAR_FLOAT           0xE81F

// Macro for mapping standard control bars to bitmask (limit of 32)
#define AFX_CONTROLBAR_MASK(nIDC)   (1L << (nIDC - AFX_IDW_CONTROLBAR_FIRST))

// parts of Main Frame
#define AFX_IDW_PANE_FIRST              0xE900  // first pane (256 max)
#define AFX_IDW_PANE_LAST               0xE9ff
#define AFX_IDW_HSCROLL_FIRST           0xEA00  // first Horz scrollbar (16 max)
#define AFX_IDW_VSCROLL_FIRST           0xEA10  // first Vert scrollbar (16 max)

#define AFX_IDW_SIZE_BOX                0xEA20  // size box for splitters
#define AFX_IDW_PANE_SAVE               0xEA21  // to shift AFX_IDW_PANE_FIRST
#endif //!RC_INVOKED

#ifndef APSTUDIO_INVOKED

// common style for form views
#define AFX_WS_DEFAULT_VIEW             (WS_CHILD | WS_VISIBLE | WS_BORDER)

#endif //!APSTUDIO_INVOKED

/////////////////////////////////////////////////////////////////////////////
// Standard app configurable strings

// for application title (defaults to EXE name or name in constructor)
#define AFX_IDS_APP_TITLE               0xE000
// idle message bar line
#define AFX_IDS_IDLEMESSAGE             0xE001
// message bar line when in shift-F1 help mode
#define AFX_IDS_HELPMODEMESSAGE         0xE002
// document title when editing OLE embedding
#define AFX_IDS_APP_TITLE_EMBEDDING     0xE003
// company name
#define AFX_IDS_COMPANY_NAME            0xE004
// object name when server is inplace
#define AFX_IDS_OBJ_TITLE_INPLACE       0xE005

/////////////////////////////////////////////////////////////////////////////
// Standard Commands

// File commands
#define ID_FILE_NEW                     0xE100
#define ID_FILE_OPEN                    0xE101
#define ID_FILE_CLOSE                   0xE102
#define ID_FILE_SAVE                    0xE103
#define ID_FILE_SAVE_AS                 0xE104
#define ID_FILE_PAGE_SETUP              0xE105
#define ID_FILE_PRINT_SETUP             0xE106
#define ID_FILE_PRINT                   0xE107
#define ID_FILE_PRINT_DIRECT            0xE108
#define ID_FILE_PRINT_PREVIEW           0xE109
#define ID_FILE_UPDATE                  0xE10A
#define ID_FILE_SAVE_COPY_AS            0xE10B
#define ID_FILE_SEND_MAIL               0xE10C

#define ID_FILE_MRU_FIRST               0xE110
#define ID_FILE_MRU_FILE1               0xE110          // range - 16 max
#define ID_FILE_MRU_FILE2               0xE111
#define ID_FILE_MRU_FILE3               0xE112
#define ID_FILE_MRU_FILE4               0xE113
#define ID_FILE_MRU_FILE5               0xE114
#define ID_FILE_MRU_FILE6               0xE115
#define ID_FILE_MRU_FILE7               0xE116
#define ID_FILE_MRU_FILE8               0xE117
#define ID_FILE_MRU_FILE9               0xE118
#define ID_FILE_MRU_FILE10              0xE119
#define ID_FILE_MRU_FILE11              0xE11A
#define ID_FILE_MRU_FILE12              0xE11B
#define ID_FILE_MRU_FILE13              0xE11C
#define ID_FILE_MRU_FILE14              0xE11D
#define ID_FILE_MRU_FILE15              0xE11E
#define ID_FILE_MRU_FILE16              0xE11F
#define ID_FILE_MRU_LAST                0xE11F

// Edit commands
#define ID_EDIT_CLEAR                   0xE120
#define ID_EDIT_CLEAR_ALL               0xE121
#define ID_EDIT_COPY                    0xE122
#define ID_EDIT_CUT                     0xE123
#define ID_EDIT_FIND                    0xE124
#define ID_EDIT_PASTE                   0xE125
#define ID_EDIT_PASTE_LINK              0xE126
#define ID_EDIT_PASTE_SPECIAL           0xE127
#define ID_EDIT_REPEAT                  0xE128
#define ID_EDIT_REPLACE                 0xE129
#define ID_EDIT_SELECT_ALL              0xE12A
#define ID_EDIT_UNDO                    0xE12B
#define ID_EDIT_REDO                    0xE12C

// Window commands
#define ID_WINDOW_NEW                   0xE130
#define ID_WINDOW_ARRANGE               0xE131
#define ID_WINDOW_CASCADE               0xE132
#define ID_WINDOW_TILE_HORZ             0xE133
#define ID_WINDOW_TILE_VERT             0xE134
#define ID_WINDOW_SPLIT                 0xE135
#ifndef RC_INVOKED      // code only
#define AFX_IDM_WINDOW_FIRST            0xE130
#define AFX_IDM_WINDOW_LAST             0xE13F
#define AFX_IDM_FIRST_MDICHILD          0xFF00  // window list starts here
#endif //!RC_INVOKED

// Help and App commands
#define ID_APP_ABOUT                    0xE140
#define ID_APP_EXIT                     0xE141
#define ID_HELP_INDEX                   0xE142
#define ID_HELP_FINDER                  0xE143
#define ID_HELP_USING                   0xE144
#define ID_CONTEXT_HELP                 0xE145      // shift-F1
// special commands for processing help
#define ID_HELP                         0xE146      // first attempt for F1
#define ID_DEFAULT_HELP                 0xE147      // last attempt

// Misc
#define ID_NEXT_PANE                    0xE150
#define ID_PREV_PANE                    0xE151

// Format
#define ID_FORMAT_FONT                  0xE160

// OLE commands
#define ID_OLE_INSERT_NEW               0xE200
#define ID_OLE_EDIT_LINKS               0xE201
#define ID_OLE_EDIT_CONVERT             0xE202
#define ID_OLE_EDIT_CHANGE_ICON         0xE203
#define ID_OLE_EDIT_PROPERTIES          0xE204
#define ID_OLE_VERB_FIRST               0xE210     // range - 16 max
#ifndef RC_INVOKED      // code only
#define ID_OLE_VERB_LAST                0xE21F
#endif //!RC_INVOKED

// for print preview dialog bar
#define AFX_ID_PREVIEW_CLOSE            0xE300
#define AFX_ID_PREVIEW_NUMPAGE          0xE301      // One/Two Page button
#define AFX_ID_PREVIEW_NEXT             0xE302
#define AFX_ID_PREVIEW_PREV             0xE303
#define AFX_ID_PREVIEW_PRINT            0xE304
#define AFX_ID_PREVIEW_ZOOMIN           0xE305
#define AFX_ID_PREVIEW_ZOOMOUT          0xE306

// View commands (same number used as IDW used for control bar)
#define ID_VIEW_TOOLBAR                 0xE800
#define ID_VIEW_STATUS_BAR              0xE801
#define ID_VIEW_REBAR                   0xE804
#define ID_VIEW_AUTOARRANGE         0xE805
	// E810 -> E81F must be kept in order for RANGE macros
#define ID_VIEW_SMALLICON               0xE810
#define ID_VIEW_LARGEICON               0xE811
#define ID_VIEW_LIST                   0xE812
#define ID_VIEW_DETAILS                 0xE813
#define ID_VIEW_LINEUP                  0xE814
#define ID_VIEW_BYNAME                  0xE815
#define AFX_ID_VIEW_MINIMUM              ID_VIEW_SMALLICON
#define AFX_ID_VIEW_MAXIMUM              ID_VIEW_BYNAME
	// E800 -> E8FF reserved for other control bar commands

// RecordForm commands
#define ID_RECORD_FIRST                 0xE900
#define ID_RECORD_LAST                  0xE901
#define ID_RECORD_NEXT                  0xE902
#define ID_RECORD_PREV                  0xE903

/////////////////////////////////////////////////////////////////////////////
// Standard control IDs

#ifdef IDC_STATIC
#undef IDC_STATIC
#endif
#define IDC_STATIC              (-1)     // all static controls

/////////////////////////////////////////////////////////////////////////////
// Standard string error/warnings

#ifndef RC_INVOKED      // code only
#define AFX_IDS_SCFIRST                 0xEF00
#endif //!RC_INVOKED

#define AFX_IDS_SCSIZE                  0xEF00
#define AFX_IDS_SCMOVE                  0xEF01
#define AFX_IDS_SCMINIMIZE              0xEF02
#define AFX_IDS_SCMAXIMIZE              0xEF03
#define AFX_IDS_SCNEXTWINDOW            0xEF04
#define AFX_IDS_SCPREVWINDOW            0xEF05
#define AFX_IDS_SCCLOSE                 0xEF06
#define AFX_IDS_SCRESTORE               0xEF12
#define AFX_IDS_SCTASKLIST              0xEF13

#define AFX_IDS_MDICHILD                0xEF1F

#define AFX_IDS_DESKACCESSORY           0xEFDA

// General strings
#define AFX_IDS_OPENFILE                0xF000
#define AFX_IDS_SAVEFILE                0xF001
#define AFX_IDS_ALLFILTER               0xF002
#define AFX_IDS_UNTITLED                0xF003
#define AFX_IDS_SAVEFILECOPY            0xF004
#define AFX_IDS_PREVIEW_CLOSE           0xF005
#define AFX_IDS_UNNAMED_FILE            0xF006
#define AFX_IDS_HIDE                    0xF011

// MFC Standard Exception Error messages
#define AFX_IDP_NO_ERROR_AVAILABLE      0xF020
#define AFX_IDS_NOT_SUPPORTED_EXCEPTION 0xF021
#define AFX_IDS_RESOURCE_EXCEPTION      0xF022
#define AFX_IDS_MEMORY_EXCEPTION        0xF023
#define AFX_IDS_USER_EXCEPTION          0xF024

// Printing and print preview strings
#define AFX_IDS_PRINTONPORT             0xF040
#define AFX_IDS_ONEPAGE                 0xF041
#define AFX_IDS_TWOPAGE                 0xF042
#define AFX_IDS_PRINTPAGENUM            0xF043
#define AFX_IDS_PREVIEWPAGEDESC         0xF044
#define AFX_IDS_PRINTDEFAULTEXT         0xF045
#define AFX_IDS_PRINTDEFAULT            0xF046
#define AFX_IDS_PRINTFILTER             0xF047
#define AFX_IDS_PRINTCAPTION            0xF048
#define AFX_IDS_PRINTTOFILE             0xF049


// OLE strings
#define AFX_IDS_OBJECT_MENUITEM         0xF080
#define AFX_IDS_EDIT_VERB               0xF081
#define AFX_IDS_ACTIVATE_VERB           0xF082
#define AFX_IDS_CHANGE_LINK             0xF083
#define AFX_IDS_AUTO                    0xF084
#define AFX_IDS_MANUAL                  0xF085
#define AFX_IDS_FROZEN                  0xF086
#define AFX_IDS_ALL_FILES               0xF087
// dynamically changing menu items
#define AFX_IDS_SAVE_MENU               0xF088
#define AFX_IDS_UPDATE_MENU             0xF089
#define AFX_IDS_SAVE_AS_MENU            0xF08A
#define AFX_IDS_SAVE_COPY_AS_MENU       0xF08B
#define AFX_IDS_EXIT_MENU               0xF08C
#define AFX_IDS_UPDATING_ITEMS          0xF08D
// COlePasteSpecialDialog defines
#define AFX_IDS_METAFILE_FORMAT         0xF08E
#define AFX_IDS_DIB_FORMAT              0xF08F
#define AFX_IDS_BITMAP_FORMAT           0xF090
#define AFX_IDS_LINKSOURCE_FORMAT       0xF091
#define AFX_IDS_EMBED_FORMAT            0xF092
// other OLE utility strings
#define AFX_IDS_PASTELINKEDTYPE         0xF094
#define AFX_IDS_UNKNOWNTYPE             0xF095
#define AFX_IDS_RTF_FORMAT              0xF096
#define AFX_IDS_TEXT_FORMAT             0xF097
// OLE datatype format error strings
#define AFX_IDS_INVALID_CURRENCY        0xF098
#define AFX_IDS_INVALID_DATETIME        0xF099
#define AFX_IDS_INVALID_DATETIMESPAN    0xF09A

// General error / prompt strings
#define AFX_IDP_INVALID_FILENAME        0xF100
#define AFX_IDP_FAILED_TO_OPEN_DOC      0xF101
#define AFX_IDP_FAILED_TO_SAVE_DOC      0xF102
#define AFX_IDP_ASK_TO_SAVE             0xF103
#define AFX_IDP_FAILED_TO_CREATE_DOC    0xF104
#define AFX_IDP_FILE_TOO_LARGE          0xF105
#define AFX_IDP_FAILED_TO_START_PRINT   0xF106
#define AFX_IDP_FAILED_TO_LAUNCH_HELP   0xF107
#define AFX_IDP_INTERNAL_FAILURE        0xF108      // general failure
#define AFX_IDP_COMMAND_FAILURE         0xF109      // command failure
#define AFX_IDP_FAILED_MEMORY_ALLOC     0xF10A
#define AFX_IDP_UNREG_DONE              0xF10B
#define AFX_IDP_UNREG_FAILURE           0xF10C
#define AFX_IDP_DLL_LOAD_FAILED         0xF10D
#define AFX_IDP_DLL_BAD_VERSION         0xF10E

// DDV parse errors
#define AFX_IDP_PARSE_INT               0xF110
#define AFX_IDP_PARSE_REAL              0xF111
#define AFX_IDP_PARSE_INT_RANGE         0xF112
#define AFX_IDP_PARSE_REAL_RANGE        0xF113
#define AFX_IDP_PARSE_STRING_SIZE       0xF114
#define AFX_IDP_PARSE_RADIO_BUTTON      0xF115
#define AFX_IDP_PARSE_BYTE              0xF116
#define AFX_IDP_PARSE_UINT              0xF117
#define AFX_IDP_PARSE_DATETIME          0xF118
#define AFX_IDP_PARSE_CURRENCY          0xF119

// CFile/CArchive error strings for user failure
#define AFX_IDP_FAILED_INVALID_FORMAT   0xF120
#define AFX_IDP_FAILED_INVALID_PATH     0xF121
#define AFX_IDP_FAILED_DISK_FULL        0xF122
#define AFX_IDP_FAILED_ACCESS_READ      0xF123
#define AFX_IDP_FAILED_ACCESS_WRITE     0xF124
#define AFX_IDP_FAILED_IO_ERROR_READ    0xF125
#define AFX_IDP_FAILED_IO_ERROR_WRITE   0xF126

// OLE errors / prompt strings
#define AFX_IDP_STATIC_OBJECT           0xF180
#define AFX_IDP_FAILED_TO_CONNECT       0xF181
#define AFX_IDP_SERVER_BUSY             0xF182
#define AFX_IDP_BAD_VERB                0xF183
#define AFX_IDS_NOT_DOCOBJECT                0xF184
#define AFX_IDP_FAILED_TO_NOTIFY        0xF185
#define AFX_IDP_FAILED_TO_LAUNCH        0xF186
#define AFX_IDP_ASK_TO_UPDATE           0xF187
#define AFX_IDP_FAILED_TO_UPDATE        0xF188
#define AFX_IDP_FAILED_TO_REGISTER      0xF189
#define AFX_IDP_FAILED_TO_AUTO_REGISTER 0xF18A
#define AFX_IDP_FAILED_TO_CONVERT       0xF18B
#define AFX_IDP_GET_NOT_SUPPORTED       0xF18C
#define AFX_IDP_SET_NOT_SUPPORTED       0xF18D
#define AFX_IDP_ASK_TO_DISCARD          0xF18E
#define AFX_IDP_FAILED_TO_CREATE        0xF18F

// MAPI errors / prompt strings
#define AFX_IDP_FAILED_MAPI_LOAD        0xF190
#define AFX_IDP_INVALID_MAPI_DLL        0xF191
#define AFX_IDP_FAILED_MAPI_SEND        0xF192

#define AFX_IDP_FILE_NONE               0xF1A0
#define AFX_IDP_FILE_GENERIC            0xF1A1
#define AFX_IDP_FILE_NOT_FOUND          0xF1A2
#define AFX_IDP_FILE_BAD_PATH           0xF1A3
#define AFX_IDP_FILE_TOO_MANY_OPEN      0xF1A4
#define AFX_IDP_FILE_ACCESS_DENIED      0xF1A5
#define AFX_IDP_FILE_INVALID_FILE       0xF1A6
#define AFX_IDP_FILE_REMOVE_CURRENT     0xF1A7
#define AFX_IDP_FILE_DIR_FULL           0xF1A8
#define AFX_IDP_FILE_BAD_SEEK           0xF1A9
#define AFX_IDP_FILE_HARD_IO            0xF1AA
#define AFX_IDP_FILE_SHARING            0xF1AB
#define AFX_IDP_FILE_LOCKING            0xF1AC
#define AFX_IDP_FILE_DISKFULL           0xF1AD
#define AFX_IDP_FILE_EOF                0xF1AE

#define AFX_IDP_ARCH_NONE               0xF1B0
#define AFX_IDP_ARCH_GENERIC            0xF1B1
#define AFX_IDP_ARCH_READONLY           0xF1B2
#define AFX_IDP_ARCH_ENDOFFILE          0xF1B3
#define AFX_IDP_ARCH_WRITEONLY          0xF1B4
#define AFX_IDP_ARCH_BADINDEX           0xF1B5
#define AFX_IDP_ARCH_BADCLASS           0xF1B6
#define AFX_IDP_ARCH_BADSCHEMA          0xF1B7

#define AFX_IDS_OCC_SCALEUNITS_PIXELS   0xF1C0

// 0xf200-0xf20f reserved

// font names and point sizes
#define AFX_IDS_STATUS_FONT             0xF230
#define AFX_IDS_TOOLTIP_FONT            0xF231
#define AFX_IDS_UNICODE_FONT            0xF232
#define AFX_IDS_MINI_FONT               0xF233

// ODBC Database errors / prompt strings
#ifndef RC_INVOKED      // code only
#define AFX_IDP_SQL_FIRST                       0xF280
#endif //!RC_INVOKED
#define AFX_IDP_SQL_CONNECT_FAIL                0xF281
#define AFX_IDP_SQL_RECORDSET_FORWARD_ONLY      0xF282
#define AFX_IDP_SQL_EMPTY_COLUMN_LIST           0xF283
#define AFX_IDP_SQL_FIELD_SCHEMA_MISMATCH       0xF284
#define AFX_IDP_SQL_ILLEGAL_MODE                0xF285
#define AFX_IDP_SQL_MULTIPLE_ROWS_AFFECTED      0xF286
#define AFX_IDP_SQL_NO_CURRENT_RECORD           0xF287
#define AFX_IDP_SQL_NO_ROWS_AFFECTED            0xF288
#define AFX_IDP_SQL_RECORDSET_READONLY          0xF289
#define AFX_IDP_SQL_SQL_NO_TOTAL                0xF28A
#define AFX_IDP_SQL_ODBC_LOAD_FAILED            0xF28B
#define AFX_IDP_SQL_DYNASET_NOT_SUPPORTED       0xF28C
#define AFX_IDP_SQL_SNAPSHOT_NOT_SUPPORTED      0xF28D
#define AFX_IDP_SQL_API_CONFORMANCE             0xF28E
#define AFX_IDP_SQL_SQL_CONFORMANCE             0xF28F
#define AFX_IDP_SQL_NO_DATA_FOUND               0xF290
#define AFX_IDP_SQL_ROW_UPDATE_NOT_SUPPORTED    0xF291
#define AFX_IDP_SQL_ODBC_V2_REQUIRED            0xF292
#define AFX_IDP_SQL_NO_POSITIONED_UPDATES       0xF293
#define AFX_IDP_SQL_LOCK_MODE_NOT_SUPPORTED     0xF294
#define AFX_IDP_SQL_DATA_TRUNCATED              0xF295
#define AFX_IDP_SQL_ROW_FETCH                   0xF296
#define AFX_IDP_SQL_INCORRECT_ODBC              0xF297
#define AFX_IDP_SQL_UPDATE_DELETE_FAILED        0xF298
#define AFX_IDP_SQL_DYNAMIC_CURSOR_NOT_SUPPORTED    0xF299
#define AFX_IDP_SQL_FIELD_NOT_FOUND             0xF29A
#define AFX_IDP_SQL_BOOKMARKS_NOT_SUPPORTED     0xF29B
#define AFX_IDP_SQL_BOOKMARKS_NOT_ENABLED       0xF29C

// ODBC Database strings
#define AFX_IDS_DELETED                         0xF29D

// DAO Database errors / prompt strings
#ifndef RC_INVOKED      // code only
#define AFX_IDP_DAO_FIRST                       0xF2B0
#endif //!RC_INVOKED
#define AFX_IDP_DAO_ENGINE_INITIALIZATION       0xF2B0
#define AFX_IDP_DAO_DFX_BIND                    0xF2B1
#define AFX_IDP_DAO_OBJECT_NOT_OPEN             0xF2B2

// ICDAORecordset::GetRows Errors
//  These are not placed in DAO Errors collection
//  and must be handled directly by MFC.
#define AFX_IDP_DAO_ROWTOOSHORT                 0xF2B3
#define AFX_IDP_DAO_BADBINDINFO                 0xF2B4
#define AFX_IDP_DAO_COLUMNUNAVAILABLE           0xF2B5

/////////////////////////////////////////////////////////////////////////////
// Strings for ISAPI support

#define AFX_IDS_HTTP_TITLE              0xF2D1
#define AFX_IDS_HTTP_NO_TEXT            0xF2D2
#define AFX_IDS_HTTP_BAD_REQUEST        0xF2D3
#define AFX_IDS_HTTP_AUTH_REQUIRED      0xF2D4
#define AFX_IDS_HTTP_FORBIDDEN          0xF2D5
#define AFX_IDS_HTTP_NOT_FOUND          0xF2D6
#define AFX_IDS_HTTP_SERVER_ERROR       0xF2D7
#define AFX_IDS_HTTP_NOT_IMPLEMENTED    0xF2D8

/////////////////////////////////////////////////////////////////////////////
// AFX implementation - control IDs (AFX_IDC)

// Parts of dialogs
#define AFX_IDC_LISTBOX                 100
#define AFX_IDC_CHANGE                  101

// for print dialog
#define AFX_IDC_PRINT_DOCNAME           201
#define AFX_IDC_PRINT_PRINTERNAME       202
#define AFX_IDC_PRINT_PORTNAME          203
#define AFX_IDC_PRINT_PAGENUM           204

// Property Sheet control id's (determined with Spy++)
#define ID_APPLY_NOW                    0x3021
#define ID_WIZBACK                      0x3023
#define ID_WIZNEXT                      0x3024
#define ID_WIZFINISH                    0x3025
#define AFX_IDC_TAB_CONTROL             0x3020

/////////////////////////////////////////////////////////////////////////////
// IDRs for standard components

#ifndef RC_INVOKED  // code only
// These are really COMMDLG dialogs, so there usually isn't a resource
// for them, but these IDs are used as help IDs.
#define AFX_IDD_FILEOPEN                28676
#define AFX_IDD_FILESAVE                28677
#define AFX_IDD_FONT                    28678
#define AFX_IDD_COLOR                   28679
#define AFX_IDD_PRINT                   28680
#define AFX_IDD_PRINTSETUP              28681
#define AFX_IDD_FIND                    28682
#define AFX_IDD_REPLACE                 28683
#endif //!RC_INVOKED

// Standard dialogs app should leave alone (0x7801->)
#define AFX_IDD_NEWTYPEDLG              30721
#define AFX_IDD_PRINTDLG                30722
#define AFX_IDD_PREVIEW_TOOLBAR         30723

// Dialogs defined for OLE2UI library
#define AFX_IDD_INSERTOBJECT            30724
#define AFX_IDD_CHANGEICON              30725
#define AFX_IDD_CONVERT                 30726
#define AFX_IDD_PASTESPECIAL            30727
#define AFX_IDD_EDITLINKS               30728
#define AFX_IDD_FILEBROWSE              30729
#define AFX_IDD_BUSY                    30730

#define AFX_IDD_OBJECTPROPERTIES        30732
#define AFX_IDD_CHANGESOURCE            30733

// Standard cursors (0x7901->)
	// AFX_IDC = Cursor resources
#define AFX_IDC_CONTEXTHELP             30977       // context sensitive help
#define AFX_IDC_MAGNIFY                 30978       // print preview zoom
#define AFX_IDC_SMALLARROWS             30979       // splitter
#define AFX_IDC_HSPLITBAR               30980       // splitter
#define AFX_IDC_VSPLITBAR               30981       // splitter
#define AFX_IDC_NODROPCRSR              30982       // No Drop Cursor
#define AFX_IDC_TRACKNWSE               30983       // tracker
#define AFX_IDC_TRACKNESW               30984       // tracker
#define AFX_IDC_TRACKNS                 30985       // tracker
#define AFX_IDC_TRACKWE                 30986       // tracker
#define AFX_IDC_TRACK4WAY               30987       // tracker
#define AFX_IDC_MOVE4WAY                30988       // resize bar (server only)

// Mini frame window bitmap ID
#define AFX_IDB_MINIFRAME_MENU          30994

// CheckListBox checks bitmap ID
#define AFX_IDB_CHECKLISTBOX_NT         30995
#define AFX_IDB_CHECKLISTBOX_95         30996

// AFX standard accelerator resources
#define AFX_IDR_PREVIEW_ACCEL           30997

// AFX standard ICON IDs (for MFC V1 apps) (0x7A01->)
#define AFX_IDI_STD_MDIFRAME            31233
#define AFX_IDI_STD_FRAME               31234

/////////////////////////////////////////////////////////////////////////////
// AFX OLE control implementation - control IDs (AFX_IDC)

// Font property page
#define AFX_IDC_FONTPROP                1000
#define AFX_IDC_FONTNAMES               1001
#define AFX_IDC_FONTSTYLES              1002
#define AFX_IDC_FONTSIZES               1003
#define AFX_IDC_STRIKEOUT               1004
#define AFX_IDC_UNDERLINE               1005
#define AFX_IDC_SAMPLEBOX               1006

// Color property page
#define AFX_IDC_COLOR_BLACK             1100
#define AFX_IDC_COLOR_WHITE             1101
#define AFX_IDC_COLOR_RED               1102
#define AFX_IDC_COLOR_GREEN             1103
#define AFX_IDC_COLOR_BLUE              1104
#define AFX_IDC_COLOR_YELLOW            1105
#define AFX_IDC_COLOR_MAGENTA           1106
#define AFX_IDC_COLOR_CYAN              1107
#define AFX_IDC_COLOR_GRAY              1108
#define AFX_IDC_COLOR_LIGHTGRAY         1109
#define AFX_IDC_COLOR_DARKRED           1110
#define AFX_IDC_COLOR_DARKGREEN         1111
#define AFX_IDC_COLOR_DARKBLUE          1112
#define AFX_IDC_COLOR_LIGHTBROWN        1113
#define AFX_IDC_COLOR_DARKMAGENTA       1114
#define AFX_IDC_COLOR_DARKCYAN          1115
#define AFX_IDC_COLORPROP               1116
#define AFX_IDC_SYSTEMCOLORS            1117

// Picture porperty page
#define AFX_IDC_PROPNAME                1201
#define AFX_IDC_PICTURE                 1202
#define AFX_IDC_BROWSE                  1203
#define AFX_IDC_CLEAR                   1204

/////////////////////////////////////////////////////////////////////////////
// IDRs for OLE control standard components

// Standard propery page dialogs app should leave alone (0x7E01->)
#define AFX_IDD_PROPPAGE_COLOR         32257
#define AFX_IDD_PROPPAGE_FONT          32258
#define AFX_IDD_PROPPAGE_PICTURE       32259

#define AFX_IDB_TRUETYPE               32384

/////////////////////////////////////////////////////////////////////////////
// Standard OLE control strings

// OLE Control page strings
#define AFX_IDS_PROPPAGE_UNKNOWN        0xFE01
#define AFX_IDS_COLOR_DESKTOP           0xFE04
#define AFX_IDS_COLOR_APPWORKSPACE      0xFE05
#define AFX_IDS_COLOR_WNDBACKGND        0xFE06
#define AFX_IDS_COLOR_WNDTEXT           0xFE07
#define AFX_IDS_COLOR_MENUBAR           0xFE08
#define AFX_IDS_COLOR_MENUTEXT          0xFE09
#define AFX_IDS_COLOR_ACTIVEBAR         0xFE0A
#define AFX_IDS_COLOR_INACTIVEBAR       0xFE0B
#define AFX_IDS_COLOR_ACTIVETEXT        0xFE0C
#define AFX_IDS_COLOR_INACTIVETEXT      0xFE0D
#define AFX_IDS_COLOR_ACTIVEBORDER      0xFE0E
#define AFX_IDS_COLOR_INACTIVEBORDER    0xFE0F
#define AFX_IDS_COLOR_WNDFRAME          0xFE10
#define AFX_IDS_COLOR_SCROLLBARS        0xFE11
#define AFX_IDS_COLOR_BTNFACE           0xFE12
#define AFX_IDS_COLOR_BTNSHADOW         0xFE13
#define AFX_IDS_COLOR_BTNTEXT           0xFE14
#define AFX_IDS_COLOR_BTNHIGHLIGHT      0xFE15
#define AFX_IDS_COLOR_DISABLEDTEXT      0xFE16
#define AFX_IDS_COLOR_HIGHLIGHT         0xFE17
#define AFX_IDS_COLOR_HIGHLIGHTTEXT     0xFE18
#define AFX_IDS_REGULAR                 0xFE19
#define AFX_IDS_BOLD                    0xFE1A
#define AFX_IDS_ITALIC                  0xFE1B
#define AFX_IDS_BOLDITALIC              0xFE1C
#define AFX_IDS_SAMPLETEXT              0xFE1D
#define AFX_IDS_DISPLAYSTRING_FONT      0xFE1E
#define AFX_IDS_DISPLAYSTRING_COLOR     0xFE1F
#define AFX_IDS_DISPLAYSTRING_PICTURE   0xFE20
#define AFX_IDS_PICTUREFILTER           0xFE21
#define AFX_IDS_PICTYPE_UNKNOWN         0xFE22
#define AFX_IDS_PICTYPE_NONE            0xFE23
#define AFX_IDS_PICTYPE_BITMAP          0xFE24
#define AFX_IDS_PICTYPE_METAFILE        0xFE25
#define AFX_IDS_PICTYPE_ICON            0xFE26
#define AFX_IDS_COLOR_PPG               0xFE28
#define AFX_IDS_COLOR_PPG_CAPTION       0xFE29
#define AFX_IDS_FONT_PPG                0xFE2A
#define AFX_IDS_FONT_PPG_CAPTION        0xFE2B
#define AFX_IDS_PICTURE_PPG             0xFE2C
#define AFX_IDS_PICTURE_PPG_CAPTION     0xFE2D
#define AFX_IDS_PICTUREBROWSETITLE      0xFE30
#define AFX_IDS_BORDERSTYLE_0           0xFE31
#define AFX_IDS_BORDERSTYLE_1           0xFE32

// OLE Control verb names
#define AFX_IDS_VERB_EDIT               0xFE40
#define AFX_IDS_VERB_PROPERTIES         0xFE41

// OLE Control internal error messages
#define AFX_IDP_PICTURECANTOPEN         0xFE83
#define AFX_IDP_PICTURECANTLOAD         0xFE84
#define AFX_IDP_PICTURETOOLARGE         0xFE85
#define AFX_IDP_PICTUREREADFAILED       0xFE86

// Standard OLE Control error strings
#define AFX_IDP_E_ILLEGALFUNCTIONCALL       0xFEA0
#define AFX_IDP_E_OVERFLOW                  0xFEA1
#define AFX_IDP_E_OUTOFMEMORY               0xFEA2
#define AFX_IDP_E_DIVISIONBYZERO            0xFEA3
#define AFX_IDP_E_OUTOFSTRINGSPACE          0xFEA4
#define AFX_IDP_E_OUTOFSTACKSPACE           0xFEA5
#define AFX_IDP_E_BADFILENAMEORNUMBER       0xFEA6
#define AFX_IDP_E_FILENOTFOUND              0xFEA7
#define AFX_IDP_E_BADFILEMODE               0xFEA8
#define AFX_IDP_E_FILEALREADYOPEN           0xFEA9
#define AFX_IDP_E_DEVICEIOERROR             0xFEAA
#define AFX_IDP_E_FILEALREADYEXISTS         0xFEAB
#define AFX_IDP_E_BADRECORDLENGTH           0xFEAC
#define AFX_IDP_E_DISKFULL                  0xFEAD
#define AFX_IDP_E_BADRECORDNUMBER           0xFEAE
#define AFX_IDP_E_BADFILENAME               0xFEAF
#define AFX_IDP_E_TOOMANYFILES              0xFEB0
#define AFX_IDP_E_DEVICEUNAVAILABLE         0xFEB1
#define AFX_IDP_E_PERMISSIONDENIED          0xFEB2
#define AFX_IDP_E_DISKNOTREADY              0xFEB3
#define AFX_IDP_E_PATHFILEACCESSERROR       0xFEB4
#define AFX_IDP_E_PATHNOTFOUND              0xFEB5
#define AFX_IDP_E_INVALIDPATTERNSTRING      0xFEB6
#define AFX_IDP_E_INVALIDUSEOFNULL          0xFEB7
#define AFX_IDP_E_INVALIDFILEFORMAT         0xFEB8
#define AFX_IDP_E_INVALIDPROPERTYVALUE      0xFEB9
#define AFX_IDP_E_INVALIDPROPERTYARRAYINDEX 0xFEBA
#define AFX_IDP_E_SETNOTSUPPORTEDATRUNTIME  0xFEBB
#define AFX_IDP_E_SETNOTSUPPORTED           0xFEBC
#define AFX_IDP_E_NEEDPROPERTYARRAYINDEX    0xFEBD
#define AFX_IDP_E_SETNOTPERMITTED           0xFEBE
#define AFX_IDP_E_GETNOTSUPPORTEDATRUNTIME  0xFEBF
#define AFX_IDP_E_GETNOTSUPPORTED           0xFEC0
#define AFX_IDP_E_PROPERTYNOTFOUND          0xFEC1
#define AFX_IDP_E_INVALIDCLIPBOARDFORMAT    0xFEC2
#define AFX_IDP_E_INVALIDPICTURE            0xFEC3
#define AFX_IDP_E_PRINTERERROR              0xFEC4
#define AFX_IDP_E_CANTSAVEFILETOTEMP        0xFEC5
#define AFX_IDP_E_SEARCHTEXTNOTFOUND        0xFEC6
#define AFX_IDP_E_REPLACEMENTSTOOLONG       0xFEC7

/////////////////////////////////////////////////////////////////////////////

#ifdef _AFX_MINREBUILD
#pragma component(minrebuild, on)
#endif

#endif //__AFXRES_H__

/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\appcompat\tools\smvtest\excluded\excluded.cpp ===
/*++

Copyright (c) 2000-2001  Microsoft Corporation

Module Name:

    Excluded.cpp

Abstract:

    This DLL is being excluded from the applied shim to GetCommandLine() API.
	It's the second DLL to be loaded after Log.dll and it has the code to 
	initialize the log file and copy the shim dlls to the AppPatch folder. It
	also uninitializes the log file and deletes the dll files.

Author:

    Diaa Fathalla (DiaaF)   27-Nov-2000

Revision History:

--*/

#include "stdafx.h"
#include "Excluded.h"

BOOL APIENTRY DllMain( HANDLE hModule, 
                       DWORD  ul_reason_for_call, 
                       LPVOID lpReserved
					 )
{
    return TRUE;
}

/*++

	It returns GetCommandLine result with no shims applied to it.

--*/

EXCLUDED_API LPTSTR NOT_HOOKEDGetCommandLine(void)
{
	return GetCommandLine();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\appcompat\tools\smvtest\excluded\stdafx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
//	Excluded.pch will be the pre-compiled header
//	stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\appcompat\tools\smvtest\excluded\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by Excluded.rc
//

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        101
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1000
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\appcompat\tools\smvtest\log\stdafx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
//	Log.pch will be the pre-compiled header
//	stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"

// TODO: reference any additional headers you need in STDAFX.H
// and not in this file
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\appcompat\tools\smvtest\log\log.cpp ===
/*++

Copyright (c) 2000-2001  Microsoft Corporation

Module Name:

    Log.cpp

Abstract:

    This DLL handles the logging for the SMVTest.

Author:

    Diaa Fathalla (DiaaF)   27-Nov-2000

Revision History:

--*/

#include "stdafx.h"
#include "Log.h"
#include "memory.h"

BOOL APIENTRY DllMain( HANDLE hModule, 
                       DWORD  ul_reason_for_call, 
                       LPVOID lpReserved
					 )
{
    switch (ul_reason_for_call)
	{
		case DLL_PROCESS_ATTACH:
		case DLL_THREAD_ATTACH:
		case DLL_THREAD_DETACH:
		case DLL_PROCESS_DETACH:
			break;
    }
    return TRUE;
}

//
// Constructor of a class that is being exported.
//

CLog::CLog()
{ 
	m_iProcessor			= 0;
	m_iOperatingSys			= 0;
	m_iNTProductType		= 0;	
	m_sMachineName			= new TCHAR[MAX_COMPUTERNAME_LENGTH + 1];
	m_sBuildNumber			= new TCHAR[NORMAL_SIZE];
	m_sCSDVersion			= new TCHAR[NORMAL_SIZE];
	m_sProcessor			= new TCHAR[NORMAL_SIZE];
	ZeroMemory(m_sMachineName,MAX_COMPUTERNAME_LENGTH + 1);
	ZeroMemory(m_sBuildNumber, NORMAL_SIZE);
	ZeroMemory(m_sCSDVersion, NORMAL_SIZE);
	ZeroMemory(m_sProcessor, NORMAL_SIZE);
}

//
// Destructor of a class that is being exported.
//

CLog::~CLog()
{
	if (m_sMachineName)
		delete m_sMachineName;

	if (m_sBuildNumber)
		delete m_sBuildNumber;

	if (m_sCSDVersion)
		delete m_sCSDVersion;

	if (m_sProcessor)
		delete m_sProcessor;

}

//
// InitLogfile
//

BOOL LOG_API CLog::InitLogfile(LPCTSTR szLogfile, LPCTSTR szLogfileFolder)
{
	if (!s_bFirstTime)
		s_bFirstTime = TRUE;
	else
		return SUCCESS;

	LPTSTR	szBuffer;		
	LPTSTR	szLogfilePath	= new TCHAR[MAX_PATH];
	LPTSTR  szTempPath		= new TCHAR[MAX_PATH];

	//Set Global path for the global
	SetLogfile(szLogfile);
	SetLogfileFolder(szLogfileFolder);
	_tcscpy(m_sLogfile, szLogfile);
	_tcscpy(m_sLogfileFolder, szLogfileFolder);

	GetWindowsDirectory(szLogfilePath, MAX_PATH);
	_tcscat(szLogfilePath, TEXT("\\"));
	_tcscat(szLogfilePath, m_sLogfileFolder);

	//Get local computer info
	GetLocalComputerInfo();

	//Make sure TestLogs folder exists
	WIN32_FIND_DATA  pFindFileData;
	_tcscpy(szTempPath, szLogfilePath);
	_tcscat(szTempPath, TEXT("\\*.*"));
	HANDLE hFileHndl = FindFirstFile(szTempPath, &pFindFileData);

	if(hFileHndl != INVALID_HANDLE_VALUE)
		FindClose(hFileHndl);
	else
		CreateDirectory(szLogfilePath,NULL);

	//DeleteAllLogFiles();

	szTempPath = _tcscat(_tcscat(_tcscpy(szTempPath,szLogfilePath),TEXT("\\")),m_sLogfile);
    hFileHndl = CreateFile(szTempPath, GENERIC_WRITE, 0, NULL, CREATE_ALWAYS, 
							FILE_ATTRIBUTE_NORMAL | FILE_FLAG_SEQUENTIAL_SCAN, NULL); 

	delete szLogfilePath;
	delete szTempPath;

	if(hFileHndl == NULL)
	{
		return FAILURE;
	}
	else
	{
		//Log file not found so create new one
		DWORD dwWritten = NULL;
		szBuffer = LogInitHeader();
		WriteFile(hFileHndl, (LPTSTR) szBuffer, _tcslen(szBuffer), &dwWritten, NULL);
		CloseHandle(hFileHndl);

		delete szBuffer;
		if (dwWritten == NULL)
			return FAILURE;
	}
	return SUCCESS;
}

//
// InitLogfileInfo
//

BOOL LOG_API CLog::InitLogfileInfo(LPCTSTR szLogfile, LPCTSTR szLogfileFolder)
{
	if (!s_bFirstTime)
		s_bFirstTime = TRUE;
	else
		return SUCCESS;

	LPTSTR	szLogfilePath	= new TCHAR[MAX_PATH];
	LPTSTR  szTempPath		= new TCHAR[MAX_PATH];
	
	//Set Global path for the global
	SetLogfile(szLogfile);
	SetLogfileFolder(szLogfileFolder);
	_tcscpy(m_sLogfile, szLogfile);
	_tcscpy(m_sLogfileFolder, szLogfileFolder);

	GetWindowsDirectory(szLogfilePath, MAX_PATH);
	_tcscat(szLogfilePath, TEXT("\\"));
	_tcscat(szLogfilePath, m_sLogfileFolder);

	//Get local computer info
	GetLocalComputerInfo();

	//Make sure TestLogs folder exists
	WIN32_FIND_DATA  pFindFileData;
	szTempPath = _tcscat(_tcscat(_tcscpy(szTempPath,szLogfilePath),TEXT("\\")),m_sLogfile);
	HANDLE hFileHndl = FindFirstFile(szTempPath, &pFindFileData);

	if(hFileHndl != INVALID_HANDLE_VALUE)
		FindClose(hFileHndl);
	else
	{
		CreateDirectory(szLogfilePath,NULL);
 		hFileHndl = CreateFile(szTempPath, GENERIC_WRITE, 0, NULL, CREATE_ALWAYS, 
							FILE_ATTRIBUTE_NORMAL | FILE_FLAG_SEQUENTIAL_SCAN, NULL); 
	}
	delete szLogfilePath;
	delete szTempPath;
	
	return SUCCESS;
}

//
// EndLogfile
//

BOOL CLog::EndLogfile()
{
	if (s_bFirstTime)
		s_bFirstTime = FALSE;
	else
		return SUCCESS;

	LPCTSTR szShortLine	= TEXT("------------------------------------------------------------");
	LPCTSTR szLEnd		= TEXT("-----------------------------------");
	LPCTSTR szLogtext	= TEXT("SMV         : Shim Automation Verifier"); 
	LPTSTR  szLine		= new TCHAR[_tcslen(szShortLine) + _tcslen(szLEnd) + 1]; 	

	LPTSTR	szLogfilePath	= new TCHAR[MAX_PATH];
	GetWindowsDirectory(szLogfilePath, MAX_PATH);
	_tcscat(szLogfilePath, TEXT("\\"));
	_tcscat(szLogfilePath, m_sLogfileFolder);
	_tcscat(szLogfilePath, TEXT("\\"));
	_tcscat(szLogfilePath, m_sLogfile);

	LPTSTR szBuffer = LogCompTail();

    HANDLE hFileHndl = CreateFile(szLogfilePath, GENERIC_WRITE, 0, NULL, OPEN_ALWAYS, 
						  FILE_ATTRIBUTE_NORMAL | FILE_FLAG_SEQUENTIAL_SCAN, NULL); 

	SetFilePointer(hFileHndl, NULL, NULL, FILE_END);

	DWORD dwWritten = NULL;
	WriteFile(hFileHndl, (LPSTR)szBuffer, _tcslen(szBuffer), &dwWritten, NULL);
	WriteFile(hFileHndl, (LPSTR)szBuffer, _tcslen(szBuffer), &dwWritten, NULL);
	CloseHandle(hFileHndl);
		
	delete szBuffer;
	delete szLine;
	delete szLogfilePath;

	if (m_sLogfile)
		delete m_sLogfile;

	if (m_sLogfileFolder)
		delete m_sLogfileFolder;

	return SUCCESS;
}

//
// DeleteAllLogFiles
//

void CLog::DeleteAllLogFiles()
{
	LPTSTR szLogfileFolder	= new TCHAR[MAX_PATH];
	_tcscpy(szLogfileFolder,m_sLogfileFolder);
	
	LPTSTR szSearchForFiles = new TCHAR[MAX_PATH];
	_tcscpy(szSearchForFiles, szLogfileFolder);
	_tcscat(szSearchForFiles, TEXT("\\*.*"));

	LPTSTR szLogfilePath	= new TCHAR[MAX_PATH];
	_tcscpy(szLogfilePath, szLogfileFolder);
	_tcscat(szLogfilePath, TEXT("\\"));
	_tcscat(szLogfilePath, m_sLogfile);

	WIN32_FIND_DATA pFindFileData;
	HANDLE			hFileToDelete;
	BOOL			bFoundNextFile = FALSE;
	DWORD			dwFindNextFileLastErr = 0;
	DWORD			fErr = 0;

	hFileToDelete = FindFirstFile(szSearchForFiles, &pFindFileData);
	if(hFileToDelete != INVALID_HANDLE_VALUE)
	{
		do
		{
			if(FindNextFile(hFileToDelete, &pFindFileData))
			{
				if(pFindFileData.dwFileAttributes != FILE_ATTRIBUTE_DIRECTORY)
					//Do not delete the SMV log file
					if(strcmp(m_sLogfile,pFindFileData.cFileName) != 0) 
 					{
						LPTSTR szTemp = new TCHAR[MAX_PATH];
						_tcscpy(szTemp, m_sLogfileFolder);
						_tcscat(szTemp, TEXT("\\"));
						_tcscat(szTemp, pFindFileData.cFileName);
						DeleteFile(szTemp);
						delete szTemp;
					}
			}
			dwFindNextFileLastErr = GetLastError();
		}
		while (dwFindNextFileLastErr != ERROR_NO_MORE_FILES);
		FindClose(hFileToDelete);
	}
	delete szLogfileFolder;
	delete szSearchForFiles;
	delete szLogfilePath;
}

//
// LogResults
//

BOOL CLog::LogResults(BOOL bPassed, LPCTSTR szText)
{
	if (!s_bFirstTime)
		return FAILURE;   //initLogFile is not initialized

	LPTSTR	szLogfileFolder	= new TCHAR[MAX_PATH];
	_tcscpy(szLogfileFolder, m_sLogfileFolder);

	LPTSTR szLogfilePath	= new TCHAR[MAX_PATH];
	GetWindowsDirectory(szLogfilePath, MAX_PATH);
	szLogfilePath = _tcscat(szLogfilePath, TEXT("\\"));
	szLogfilePath = _tcscat(_tcscat(_tcscat(szLogfilePath,m_sLogfileFolder), TEXT("\\")), m_sLogfile);

	LPCTSTR   szTab		= TEXT("\t");		
	LPCTSTR   szSpace	= TEXT("\r\n");
	LPCTSTR   szPassed	= TEXT("PASSED\t:");
	LPCTSTR	  szFailed	= TEXT("FAILED\t:");
	LPTSTR    szBuffer	= new TCHAR[NORMAL_SIZE + _tcslen(szText)];
	_tcscpy(szBuffer, szTab);

	IncNumberOfTests();
	if (bPassed)
		szBuffer = _tcscat(_tcscat(szBuffer, szPassed), szText);
	else
	{
		IncNumberOfFailures();
		szBuffer = _tcscat(_tcscat(_tcscat(szBuffer, szFailed), szText), szSpace);
	}
	
	szBuffer = _tcscat(szBuffer, szSpace);
	
    HANDLE hFileHndl = CreateFile(szLogfilePath, GENERIC_WRITE, 0, NULL, OPEN_ALWAYS, 
								  FILE_ATTRIBUTE_NORMAL | FILE_FLAG_SEQUENTIAL_SCAN, NULL); 

	SetFilePointer(hFileHndl, NULL, NULL, FILE_END);

	delete szLogfileFolder;
	delete szLogfilePath;

	if(hFileHndl == NULL)
	{
		delete szBuffer;
		return FAILURE;
	}
	else
	{
		DWORD dwWritten = NULL;
		WriteFile(hFileHndl, (LPSTR)szBuffer, _tcslen(szBuffer), &dwWritten, NULL);
		CloseHandle(hFileHndl);
		
		delete szBuffer;
		if (dwWritten == NULL)
			return FAILURE;
	}

	return SUCCESS;
}

//
// LogInitHeader
//

LPTSTR CLog::LogInitHeader()
{
	LPTSTR  szBuffer	= new TCHAR[NORMAL_SIZE*10];
	LPCTSTR szTab		= TEXT("\t");
	LPCTSTR szSpace		= TEXT("\r\n");
	LPCTSTR szShortLine	= TEXT("------------------------------------------------------------");
	LPCTSTR szLEnd		= TEXT("-----------------------------------");
	LPCTSTR szLogtext	= TEXT("SMV-TEST    : Shim Automation Verifier TEST"); 
	LPTSTR  szLine		= new TCHAR[_tcslen(szShortLine) + _tcslen(szLEnd) + 1]; 	
	szLine = _tcscat(_tcscpy(szLine,szShortLine),szLEnd);
		
	LPTSTR szVersion	= new TCHAR[NORMAL_SIZE*3];
	_tcscpy(szVersion, m_sBuildNumber);
	
	LPTSTR szMachineName = new TCHAR[NORMAL_SIZE*2];
	_tcscpy(szMachineName,TEXT("Machine Name:"));
	szMachineName = _tcscat(_tcscat(_tcscat(szMachineName, szTab), szTab), m_sMachineName);

	if (m_sCSDVersion != NULL)
		szVersion = _tcscat(_tcscat(_tcscat(szVersion, TEXT(" (")), m_sCSDVersion), _TEXT(")"));
	
	LPTSTR szBuildNumber = new TCHAR[NORMAL_SIZE*3];
	_tcscpy(szBuildNumber, _T("Build #     :"));
	szBuildNumber = _tcscat(_tcscat(_tcscat(szBuildNumber, szTab), szTab), szVersion);

	szBuffer = _tcscat(_tcscpy(szBuffer, szLine), szSpace);
	szBuffer = _tcscat(_tcscat(_tcscat(szBuffer, szTab), szLogtext), szSpace);
	szBuffer = _tcscat(_tcscat(_tcscat(szBuffer, szLine), szSpace), szSpace);
	szBuffer = _tcscat(_tcscat(_tcscat(szBuffer, szTab), szMachineName), szSpace);
	szBuffer = _tcscat(_tcscat(_tcscat(szBuffer, szTab), szBuildNumber), szSpace);

	//SYSTEMTIME InitLogTime;
	//GetSystemTime(&InitLogTime);

	szBuffer = _tcscat(_tcscat(szBuffer, szLine), szSpace);
	szBuffer = _tcscat(_tcscat(szBuffer, szLine), szSpace);

	delete szLine;
	delete szVersion;
	delete szMachineName;
	delete szBuildNumber;

	return szBuffer;
}

//
// LogCompTail
//

LPTSTR CLog::LogCompTail()
{
	LPTSTR  szTemp		  = new TCHAR[NORMAL_SIZE * 10];
	LPTSTR	szLogfilePath = new TCHAR[MAX_PATH];
	szLogfilePath = _tcscat(_tcscat(_tcscpy(szLogfilePath,m_sLogfileFolder), TEXT("\\")), m_sLogfile);
	
	LPCTSTR szSpace		= TEXT("\r\n");
	LPCTSTR szTab		= TEXT("\t");		
	LPCTSTR szShortLine	= TEXT("------------------------------------------------------------");
	LPCTSTR szLEnd		= TEXT("-----------------------------------");
	LPCTSTR szLogtext	= TEXT("Shim Mechanism Verifier"); 
	LPTSTR  szLine		= new TCHAR[_tcslen(szShortLine) + _tcslen(szLEnd) + 1]; 	
	szLine = _tcscat(_tcscpy(szLine,szShortLine),szLEnd);
	
	//CTime tmEnd = m_pScript->m_tmScriptEndTime;
	//CTime tmStart = m_pScript->m_tmScriptStartTime;
	//CString sDate1 = tmStart.Format("%A, %B %d, %Y\t%I:%M:%S%p");
	//CString sDate2 = tmEnd.Format("%A, %B %d, %Y\t%I:%M:%S%p");

	//sTemp += sTab + _T("Script Start Time :") + sTab + sDate1 + sSpace;
	//sTemp += sTab + _T("Script Finish Time:") + sTab + sDate2 + sSpace;
	szTemp = _tcscat(_tcscpy(szTemp,szLine), szSpace);
	szTemp = _tcscat(_tcscat(szTemp,szLine), szSpace);

	delete szLogfilePath;
	delete szLine;
	return szTemp;
}

//
// DoesLogfileExist: Checks if ShimTest.log exists on the local machine.
//

BOOL CLog::DoesLogfileExist()
{
	LPTSTR szPath = new TCHAR[MAX_PATH]; 
	_tcscat(szPath,m_sLogfileFolder);
	_tcscat(szPath,TEXT("\\"));
	_tcscat(szPath,m_sLogfile);

	WIN32_FIND_DATA  pFindFileData;
	
	HANDLE hFileHndl = FindFirstFile(szPath, &pFindFileData);

	if(hFileHndl != INVALID_HANDLE_VALUE)
	{
		FindClose(hFileHndl);
		delete szPath;
		return TRUE;
	}

	delete szPath;
	return FALSE;
}

//
// GetLocalComputerInfo()
//

void CLog::GetLocalComputerInfo()
{

	OSVERSIONINFO	OSVer;
	SYSTEM_INFO		SysInf;
	DWORD			dwNameSize = MAX_COMPUTERNAME_LENGTH + 1;
	TCHAR			sMachineName[MAX_COMPUTERNAME_LENGTH + 1];

	// Get machine name and language of system
	GetComputerName(sMachineName, &dwNameSize);
	_tcscpy(m_sMachineName, TEXT(sMachineName));

	//Get OS and build #
	OSVer.dwOSVersionInfoSize	= sizeof(OSVer);
	GetVersionEx(&OSVer);
	m_iOperatingSys	= OSVer.dwPlatformId;
	wsprintf(m_sBuildNumber, TEXT("%d"), OSVer.dwBuildNumber);
	if (OSVer.szCSDVersion[0] != NULL)
		m_sCSDVersion	= TEXT(OSVer.szCSDVersion);
	
	//Get processor type, and workstation or server
	GetSystemInfo(&SysInf);
	m_iProcessor	= SysInf.wProcessorArchitecture;

	switch(m_iProcessor)
	{
	case 0:	_tcscpy(m_sProcessor,TEXT("x86"));		break;
	case 2: _tcscpy(m_sProcessor,TEXT("Alpha"));	break;
	default: _tcscpy(m_sProcessor, TEXT("Unknown Processor Architcture"));	break;
	}
}

//
// SetLogfile
//
void CLog::SetLogfile(LPCTSTR szLogfile)
{
	m_sLogfile = new TCHAR[MAX_PATH];
	_tcscpy(m_sLogfile,szLogfile);
}

//
// SetLogfileFolder
//
void CLog::SetLogfileFolder(LPCTSTR szLogfileFolder)
{
	m_sLogfileFolder = new TCHAR[MAX_PATH];
	_tcscpy(m_sLogfileFolder,szLogfileFolder);
}

//
// IncNumberOfTests
//
void CLog::IncNumberOfTests()
{
	s_NumberOfTests++;
}

//
// IncNumberOfFailures
//
void CLog::IncNumberOfFailures()
{
	s_NumberOfFailures++;
}

//
// NumberOfTests
//
int CLog::NumberOfTests()
{
	return s_NumberOfTests;
}

//
// NumberOfFailures
//
int CLog::NumberOfFailures()
{
	return s_NumberOfFailures;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\appcompat\tools\smvtest\excluded\excluded.h ===
/*++

Copyright (c) 2000-2001  Microsoft Corporation

Module Name:

    Excluded.h

Abstract:

    This DLL is being excluded from the applied shim to GetCommandLine() API.

Author:

    Diaa Fathalla (DiaaF)   27-Nov-2000

Revision History:

--*/

#ifndef _EXCLUDED_H_
#define	_EXCLUDED_H_

#ifdef EXCLUDED_EXPORTS
#define EXCLUDED_API extern "C" __declspec(dllexport)
#else
#define EXCLUDED_API extern "C" __declspec(dllimport)
#endif

//
// Functions Prototypes
//
BOOL Initialize();
BOOL Uninitialize();

//
// Exported Functions
//
EXCLUDED_API LPTSTR NOT_HOOKEDGetCommandLine(void);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\appcompat\tools\smvtest\excluded\stdafx.h ===
// stdafx.h : include file for standard system include files,
//  or project specific include files that are used frequently, but
//  are changed infrequently
//

#if !defined(AFX_STDAFX_H__E740021B_45DD_46AD_8648_429C97CB8CED__INCLUDED_)
#define AFX_STDAFX_H__E740021B_45DD_46AD_8648_429C97CB8CED__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

// Insert your headers here
//#define WIN32_LEAN_AND_MEAN		// Exclude rarely-used stuff from Windows headers

#include <windows.h>
#include <TCHAR.h>
#include "..\Log\Log.h"

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__E740021B_45DD_46AD_8648_429C97CB8CED__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\appcompat\tools\smvtest\log\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by Log.rc
//

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        101
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1000
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\appcompat\tools\smvtest\log\stdafx.h ===
// stdafx.h : include file for standard system include files,
//  or project specific include files that are used frequently, but
//      are changed infrequently
//

#if !defined(AFX_STDAFX_H__654A637A_45A4_4651_AA9F_8421ECDB5F8D__INCLUDED_)
#define AFX_STDAFX_H__654A637A_45A4_4651_AA9F_8421ECDB5F8D__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000


// Insert your headers here
#ifndef	WIN32_LEAN_AND_MEAN
#define WIN32_LEAN_AND_MEAN		// Exclude rarely-used stuff from Windows headers
#endif

#include <windows.h>
#include <TCHAR.h>

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__654A637A_45A4_4651_AA9F_8421ECDB5F8D__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\appcompat\tools\smvtest\log\log.h ===
/*++

Copyright (c) 2000-2001  Microsoft Corporation

Module Name:

    Log.h

Abstract:

    This DLL handles the logging for the SMVTest.

Author:

    Diaa Fathalla (DiaaF)   27-Nov-2000

Revision History:

--*/

// The following ifdef block is the standard way of creating macros which make exporting 
// from a DLL simpler. All files within this DLL are compiled with the LOG_EXPORTS
// symbol defined on the command line. this symbol should not be defined on any project
// that uses this DLL. This way any other project whose source files include this file see 
// LOG_API functions as being imported from a DLL, wheras this DLL sees symbols
// defined with this macro as being exported.

#ifndef _LOG_H_
#define _LOG_H_

#ifdef LOG_EXPORTS
#define LOG_API __declspec(dllexport)
#else
#define LOG_API __declspec(dllimport)
#endif

#define SUCCESS		0
#define FAILURE		1
#define NORMAL_SIZE 128*sizeof(TCHAR)

// This class is exported from the Log.dll
class LOG_API CLog {
private: 
	void SetLogfile(LPCTSTR szLogfile);
	void SetLogfileFolder(LPCTSTR szLogfileFolder);
	
	static LPTSTR m_sLogfile;
	static LPTSTR m_sLogfileFolder;
	
	static int s_NumberOfTests;
	static int s_NumberOfFailures;

	static BOOL s_bFirstTime;

	void IncNumberOfTests();
	void IncNumberOfFailures();
	int NumberOfTests();
	int NumberOfFailures();

protected: 
	LPTSTR	m_sMachineName;
	LPTSTR  m_sCSDVersion;
	LPTSTR  m_sBuildNumber;
	LPTSTR	m_sProcessor;
	int		m_iProcessor;
	int		m_iOperatingSys;
	int		m_iNTProductType;
	BOOL	m_bLogFile;
	
protected:
	void	DeleteAllLogFiles();


public:
	//Logging file routines
	//--------------------------------------
	CLog(void);
	~CLog();
	BOOL	InitLogfile(LPCTSTR szLogfile = TEXT("ShimTest.Log"),
					    LPCTSTR szLogfileFolder = TEXT("TestLogs"));
	BOOL	InitLogfileInfo(LPCTSTR szLogfile = TEXT("ShimTest.Log"),
					    LPCTSTR szLogfileFolder = TEXT("TestLogs"));
	BOOL	EndLogfile();
	BOOL    LogResults(BOOL bPassed, LPCTSTR szText);
	BOOL    DoesLogfileExist();
	BOOL    VerifyFileExists(LPTSTR sPath);
	LPTSTR  LogInitHeader();
	LPTSTR  LogCompTail();
	void    GetLocalComputerInfo();
	//--------------------------------------

};

//Using my own new and delete operators because of the MSVCRT dependency
void * __cdecl operator new(size_t size)
{
    return HeapAlloc(GetProcessHeap(), 0, size);
}

void __cdecl operator delete(void* memory)
{
    if (memory != NULL) {
        HeapFree(GetProcessHeap(), 0, memory);
    }
}

//explicitly exporting static members because they implicitly linked.
#ifdef LOG_EXPORTS
	LOG_API int CLog::s_NumberOfTests;
	LOG_API int CLog::s_NumberOfFailures;
	LOG_API LPTSTR CLog::m_sLogfile;
	LOG_API LPTSTR CLog::m_sLogfileFolder;
	LOG_API BOOL   CLog::s_bFirstTime;
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\appcompat\tools\smvtest\shims\shimmechanismverificationtest13\precomp.h ===
#ifndef _GPSHIMS_PRECOMP_H_
#define _GPSHIMS_PRECOMP_H_

#include "ShimHookEx.h"


#endif // _GPSHIMS_PRECOMP_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\appcompat\tools\smvtest\shims\shimmechanismverificationtest13\main.cpp ===
/*++

 Copyright (c) 2000 Microsoft Corporation

 Module Name:

    Main.cpp

 Abstract:


 Notes:

 History:

    11/30/2000 diaaf Created

--*/

#include "precomp.h"
#include "ShimHookMacroEx.h"

DECLARE_SHIM(ShimMechanismVerificationTest1)
DECLARE_SHIM(ShimMechanismVerificationTest3)

VOID MULTISHIM_NOTIFY_FUNCTION()(DWORD fdwReason)
{
    if (fdwReason == DLL_PROCESS_ATTACH) {
        DPF("ShimMechanismVerificationTest", eDbgLevelSpew,
			"ShimMechanismVerificationTest multishim initialized.");
    } else {
        DPF("ShimMechanismVerificationTest", eDbgLevelSpew,
			"ShimMechanismVerificationTest multishim uninitialized.");
    }
}

MULTISHIM_BEGIN()
    MULTISHIM_ENTRY(ShimMechanismVerificationTest1)
    MULTISHIM_ENTRY(ShimMechanismVerificationTest3)    
    
    CALL_MULTISHIM_NOTIFY_FUNCTION()
MULTISHIM_END()
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\appcompat\tools\smvtest\shims\shimmechanismverificationtest13\shimmechanismverificationtest1.cpp ===
/*++

 Copyright (c) 2000 Microsoft Corporation

 Module Name:

   ShimMechanismVerificationTest1.cpp

 Abstract:

   This DLL serves as a test for the shim michanism.

 Notes:
 

 History:

   11/13/2000 diaaf  Created
   11/27/2000 diaaf  modified to support the new macros.
   04/02/2001 diaaf  modified to support the new macros.

--*/

#include "precomp.h"

IMPLEMENT_SHIM_BEGIN(ShimMechanismVerificationTest1)
#include "ShimHookMacroEx.h"

//
// Add APIs that you wish to hook to this macro construction.
//
APIHOOK_ENUM_BEGIN
    APIHOOK_ENUM_ENTRY(GetCommandLineA) 
    APIHOOK_ENUM_ENTRY(GetCommandLineW) 
APIHOOK_ENUM_END

//
// Global Variables
//
CHAR *gszCommandLineA1;
WCHAR *gwcsCommandLineW1;

/*++

 This stub function intercepts all calls to GetCommandLineA
 and appends "1" to the returned string.

--*/

LPSTR APIHOOK(GetCommandLineA)()
{
    CHAR  szAppendValue[] = "1";
	LPSTR szReturnValue;

    DPF("ShimMechanismVerificationTest1", eDbgLevelInfo,
		"GetCommandLineA called.\n");
    
	szReturnValue = ORIGINAL_API(GetCommandLineA)();

	gszCommandLineA1 = (CHAR*)LocalAlloc(LPTR, strlen(szReturnValue)
									  + strlen(szAppendValue) + sizeof(CHAR));
	
	strcpy(gszCommandLineA1, szReturnValue);
	strcat(gszCommandLineA1, szAppendValue);

    LOG("ShimMechanismVerificationTest1", eDbgLevelWarning,
        "GetCommandLineA is returning \"%S\".", gszCommandLineA1);

    return gszCommandLineA1;
}

/*++

 This stub function intercepts all calls to GetCommandLineW
 and appends "1" to the returned string.

--*/

LPWSTR APIHOOK(GetCommandLineW)()
{
    WCHAR   wszAppendValue[] = L"1";
	LPWSTR  wszReturnValue;

    DPF("ShimMechanismVerificationTest1", eDbgLevelInfo,
		"GetCommandLineW called.\n");
    
	wszReturnValue = ORIGINAL_API(GetCommandLineW)();

	gwcsCommandLineW1 = (WCHAR*)LocalAlloc(LPTR, wcslen(wszReturnValue)
							  + wcslen(wszAppendValue) + sizeof(WCHAR));
	
	wcscpy(gwcsCommandLineW1, wszReturnValue);
	wcscat(gwcsCommandLineW1, wszAppendValue);

    LOG("ShimMechanismVerificationTest1", eDbgLevelWarning,
        "GetCommandLineW is returning \"%S\".", gwcsCommandLineW1);

    return gwcsCommandLineW1;
}

/*++

 Handle DLL_PROCESS_ATTACH and DLL_PROCESS_DETACH in your notify function
 to do initialization and uninitialization.
 
--*/
BOOL
NOTIFY_FUNCTION(
    DWORD fdwReason
    )
{
    if (fdwReason == DLL_PROCESS_ATTACH) {
        gszCommandLineA1 = NULL;
        gwcsCommandLineW1 = NULL;
        DPF("ShimMechanismVerificationTest1", eDbgLevelInfo,
			"ShimMechanismVerificationTest1 initialized.");
    } else {
        if (gszCommandLineA1)
        {
            LocalFree(gszCommandLineA1);
            gszCommandLineA1 = NULL;
        }
        
        if (gwcsCommandLineW1)
        {
            LocalFree(gwcsCommandLineW1);
            gwcsCommandLineW1 = NULL;
        }
        DPF("ShimMechanismVerificationTest1", eDbgLevelInfo, 
			"ShimMechanismVerificationTest1 uninitialized.");
    }
	return TRUE;
}

/*++

 Register hooked functions

--*/

HOOK_BEGIN

    CALL_NOTIFY_FUNCTION

    APIHOOK_ENTRY(KERNEL32.DLL, GetCommandLineA)
    APIHOOK_ENTRY(KERNEL32.DLL, GetCommandLineW)

HOOK_END

IMPLEMENT_SHIM_END
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\appcompat\tools\smvtest\shims\shimmechanismverificationtest1\shimmechanismverificationtest1.cpp ===
/*++

 Copyright (c) 2000 Microsoft Corporation

 Module Name:

   ShimMechanismVerificationTest1.cpp

 Abstract:

   This DLL serves as a test for the shim michanism.

 Notes:
 

 History:

   11/13/2000 diaaf  Created
   11/27/2000 diaaf  modified to support the new macros.

--*/

#include "ShimHookEx.h"

DECLARE_SHIM_VERSION2_STANDALONE(ShimMechanismVerificationTest1)

//
// Add APIs that you wish to hook to this macro construction.
//
APIHOOK_ENUM_BEGIN(ShimMechanismVerificationTest1)
    APIHOOK_ENUM_ENTRY(ShimMechanismVerificationTest1, GetCommandLineA) 
    APIHOOK_ENUM_ENTRY(ShimMechanismVerificationTest1, GetCommandLineW) 
APIHOOK_ENUM_END(ShimMechanismVerificationTest1)

//
// Global Variables
//
CHAR *gszCommandLineA;
WCHAR *gwcsCommandLineW;

/*++

 This stub function intercepts all calls to GetCommandLineA
 and appends "1" to the returned string.

--*/

LPSTR APIHOOK(ShimMechanismVerificationTest1,GetCommandLineA)()
{
    CHAR  szAppendValue[] = "1";
	LPSTR szReturnValue;

    DPF("ShimMechanismVerificationTest1", eDbgLevelInfo,
		"GetCommandLineA called.\n");
    
	szReturnValue = ORIGINAL_API(ShimMechanismVerificationTest1,
								 GetCommandLineA)();

	gszCommandLineA = (CHAR*)LocalAlloc(LPTR, strlen(szReturnValue)
									  + strlen(szAppendValue) + sizeof(CHAR));
	
	strcpy(gszCommandLineA, szReturnValue);
	strcat(gszCommandLineA, szAppendValue);

    LOG("ShimMechanismVerificationTest1", eDbgLevelWarning,
        "GetCommandLineA is returning \"%S\".", gszCommandLineA);

    return gszCommandLineA;
}

/*++

 This stub function intercepts all calls to GetCommandLineW
 and appends "1" to the returned string.

--*/

LPWSTR APIHOOK(ShimMechanismVerificationTest1,GetCommandLineW)()
{
    WCHAR   wszAppendValue[] = L"1";
	LPWSTR  wszReturnValue;

    DPF("ShimMechanismVerificationTest1", eDbgLevelInfo,
		"GetCommandLineW called.\n");
    
	wszReturnValue = ORIGINAL_API(ShimMechanismVerificationTest1,
								 GetCommandLineW)();

	gwcsCommandLineW = (WCHAR*)LocalAlloc(LPTR, wcslen(wszReturnValue)
							  + wcslen(wszAppendValue) + sizeof(WCHAR));
	
	wcscpy(gwcsCommandLineW, wszReturnValue);
	wcscat(gwcsCommandLineW, wszAppendValue);

    LOG("ShimMechanismVerificationTest1", eDbgLevelWarning,
        "GetCommandLineW is returning \"%S\".", gwcsCommandLineW);

    return gwcsCommandLineW;
}

/*++

 Handle DLL_PROCESS_ATTACH and DLL_PROCESS_DETACH in your notify function
 to do initialization and uninitialization.
 
--*/
VOID
NOTIFY_FUNCTION(ShimMechanismVerificationTest1)(
    DWORD fdwReason)
{
    if (fdwReason == DLL_PROCESS_ATTACH) {
        gszCommandLineA = NULL;
        gwcsCommandLineW = NULL;
        DPF("ShimMechanismVerificationTest1", eDbgLevelInfo,
			"ShimMechanismVerificationTest1 initialized.");
    } else {
        if (gszCommandLineA)
        {
            LocalFree(gszCommandLineA);
            gszCommandLineA = NULL;
        }
        
        if (gwcsCommandLineW)
        {
            LocalFree(gwcsCommandLineW);
            gwcsCommandLineW = NULL;
        }
        DPF("ShimMechanismVerificationTest1", eDbgLevelInfo, 
			"ShimMechanismVerificationTest1 uninitialized.");
    }
}

/*++

 Register hooked functions

--*/

HOOK_BEGIN(ShimMechanismVerificationTest1)

    APIHOOK_ENTRY(ShimMechanismVerificationTest1, KERNEL32.DLL, GetCommandLineA)
    APIHOOK_ENTRY(ShimMechanismVerificationTest1, KERNEL32.DLL, GetCommandLineW)

    DECLARE_NOTIFY_FUNCTION(ShimMechanismVerificationTest1)

HOOK_END(ShimMechanismVerificationTest1)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\appcompat\tools\smvtest\shims\shimmechanismverificationtest2\precomp.h ===
#ifndef _GPSHIMS_PRECOMP_H_
#define _GPSHIMS_PRECOMP_H_

#include "ShimHookEx.h"


#endif // _GPSHIMS_PRECOMP_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\appcompat\tools\smvtest\shims\shimmechanismverificationtest13\shimmechanismverificationtest3.cpp ===
/*++

 Copyright (c) 2000 Microsoft Corporation

 Module Name:

   ShimMechanismVerificationTest3.cpp

 Abstract:

   This DLL serves as a test for the shim michanism.

 Notes:
 

 History:

   11/13/2000 diaaf  Created
   11/27/2000 diaaf  modified to support the new macros.
   04/02/2001 diaaf  modified to support the new macros.

--*/

#include "precomp.h"

IMPLEMENT_SHIM_BEGIN(ShimMechanismVerificationTest3)
#include "ShimHookMacroEx.h"

//
// Add APIs that you wish to hook to this macro construction.
//
APIHOOK_ENUM_BEGIN
    APIHOOK_ENUM_ENTRY(GetCommandLineA) 
    APIHOOK_ENUM_ENTRY(GetCommandLineW) 
APIHOOK_ENUM_END

//
// Global Variables
//
CHAR *gszCommandLineA3;
WCHAR *gwcsCommandLineW3;

/*++

 This stub function intercepts all calls to GetCommandLineA
 and appends "1" to the returned string.

--*/

LPSTR APIHOOK(GetCommandLineA)()
{
    CHAR  szAppendValue[] = "3";
	LPSTR szReturnValue;

    DPF("ShimMechanismVerificationTest3", eDbgLevelInfo,
		"GetCommandLineA called.\n");
    
	szReturnValue = ORIGINAL_API(GetCommandLineA)();

	gszCommandLineA3 = (CHAR*)LocalAlloc(LPTR, strlen(szReturnValue)
									  + strlen(szAppendValue) + sizeof(CHAR));
	
	strcpy(gszCommandLineA3, szReturnValue);
	strcat(gszCommandLineA3, szAppendValue);

    LOG("ShimMechanismVerificationTest3", eDbgLevelWarning,
        "GetCommandLineA is returning \"%S\".", gszCommandLineA3);

    return gszCommandLineA3;
}

/*++

 This stub function intercepts all calls to GetCommandLineW
 and appends "1" to the returned string.

--*/

LPWSTR APIHOOK(GetCommandLineW)()
{
    WCHAR   wszAppendValue[] = L"3";
	LPWSTR  wszReturnValue;

    DPF("ShimMechanismVerificationTest3", eDbgLevelInfo,
		"GetCommandLineW called.\n");
    
	wszReturnValue = ORIGINAL_API(GetCommandLineW)();

	gwcsCommandLineW3 = (WCHAR*)LocalAlloc(LPTR, wcslen(wszReturnValue)
							  + wcslen(wszAppendValue) + sizeof(WCHAR));
	
	wcscpy(gwcsCommandLineW3, wszReturnValue);
	wcscat(gwcsCommandLineW3, wszAppendValue);

    LOG("ShimMechanismVerificationTest3", eDbgLevelWarning,
        "GetCommandLineW is returning \"%S\".", gwcsCommandLineW3);

    return gwcsCommandLineW3;
}

/*++

 Handle DLL_PROCESS_ATTACH and DLL_PROCESS_DETACH in your notify function
 to do initialization and uninitialization.
 
--*/
BOOL
NOTIFY_FUNCTION(
    DWORD fdwReason
    )
{
    if (fdwReason == DLL_PROCESS_ATTACH) {
        gszCommandLineA3 = NULL;
        gwcsCommandLineW3 = NULL;
        DPF("ShimMechanismVerificationTest3", eDbgLevelInfo,
			"ShimMechanismVerificationTest3 initialized.");
    } else {
        if (gszCommandLineA3)
        {
            LocalFree(gszCommandLineA3);
            gszCommandLineA3 = NULL;
        }
        
        if (gwcsCommandLineW3)
        {
            LocalFree(gwcsCommandLineW3);
            gwcsCommandLineW3 = NULL;
        }
        DPF("ShimMechanismVerificationTest3", eDbgLevelInfo, 
			"ShimMechanismVerificationTest3 uninitialized.");
    }
	return TRUE;
}

/*++

 Register hooked functions

--*/

HOOK_BEGIN

    CALL_NOTIFY_FUNCTION

    APIHOOK_ENTRY(KERNEL32.DLL, GetCommandLineA)
    APIHOOK_ENTRY(KERNEL32.DLL, GetCommandLineW)

HOOK_END

IMPLEMENT_SHIM_END
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\appcompat\tools\smvtest\shims\shimmechanismverificationtest2\shimmechanismverificationtest2.cpp ===
/*++

 Copyright (c) 2000 Microsoft Corporation

 Module Name:

   ShimMechanismVerificationTest2.cpp

 Abstract:

   This DLL serves as a test for the shim michanism.

 Notes:
 

 History:

   11/13/2000 diaaf  Created
   11/27/2000 diaaf  modified to support the new macros.
   04/03/2001 diaaf  modified to support the new macros.

--*/

#include "precomp.h"
#include "ShimHookEx.h"

IMPLEMENT_SHIM_STANDALONE(ShimMechanismVerificationTest2)
#include "ShimHookMacroEx.h"

//
// Add APIs that you wish to hook to this macro construction.
//
APIHOOK_ENUM_BEGIN
    APIHOOK_ENUM_ENTRY(GetCommandLineA) 
    APIHOOK_ENUM_ENTRY(GetCommandLineW) 
APIHOOK_ENUM_END

//
// Global Variables
//
CHAR *gszCommandLineA;
WCHAR *gwcsCommandLineW;

/*++

 This stub function intercepts all calls to GetCommandLineA
 and appends "1" to the returned string.

--*/

LPSTR APIHOOK(GetCommandLineA)()
{
    CHAR  szAppendValue[] = "2";
	LPSTR szReturnValue;

    DPF("ShimMechanismVerificationTest2", eDbgLevelInfo,
		"GetCommandLineA called.\n");
    
	szReturnValue = ORIGINAL_API(GetCommandLineA)();

	gszCommandLineA = (CHAR*)LocalAlloc(LPTR, strlen(szReturnValue)
									  + strlen(szAppendValue) + sizeof(CHAR));
	
	strcpy(gszCommandLineA, szReturnValue);
	strcat(gszCommandLineA, szAppendValue);

    LOG("ShimMechanismVerificationTest2", eDbgLevelWarning,
        "GetCommandLineA is returning \"%S\".", gszCommandLineA);

    return gszCommandLineA;
}

/*++

 This stub function intercepts all calls to GetCommandLineW
 and appends "1" to the returned string.

--*/

LPWSTR APIHOOK(GetCommandLineW)()
{
    WCHAR   wszAppendValue[] = L"2";
	LPWSTR  wszReturnValue;

    DPF("ShimMechanismVerificationTest2", eDbgLevelInfo,
		"GetCommandLineW called.\n");
    
	wszReturnValue = ORIGINAL_API(GetCommandLineW)();

	gwcsCommandLineW = (WCHAR*)LocalAlloc(LPTR, wcslen(wszReturnValue)
							  + wcslen(wszAppendValue) + sizeof(WCHAR));
	
	wcscpy(gwcsCommandLineW, wszReturnValue);
	wcscat(gwcsCommandLineW, wszAppendValue);

    LOG("ShimMechanismVerificationTest2", eDbgLevelWarning,
        "GetCommandLineW is returning \"%S\".", gwcsCommandLineW);

    return gwcsCommandLineW;
}

/*++

 Handle DLL_PROCESS_ATTACH and DLL_PROCESS_DETACH in your notify function
 to do initialization and uninitialization.
 
--*/
BOOL
NOTIFY_FUNCTION(
    DWORD fdwReason
    )
{
    if (fdwReason == DLL_PROCESS_ATTACH) {
        gszCommandLineA = NULL;
        gwcsCommandLineW = NULL;
        DPF("ShimMechanismVerificationTest2", eDbgLevelInfo,
			"ShimMechanismVerificationTest2 initialized.");
    } else {
        if (gszCommandLineA)
        {
            LocalFree(gszCommandLineA);
            gszCommandLineA = NULL;
        }
        
        if (gwcsCommandLineW)
        {
            LocalFree(gwcsCommandLineW);
            gwcsCommandLineW = NULL;
        }
        DPF("ShimMechanismVerificationTest2", eDbgLevelInfo, 
			"ShimMechanismVerificationTest2 uninitialized.");
    }
	return TRUE;
}

/*++

 Register hooked functions

--*/

HOOK_BEGIN

    CALL_NOTIFY_FUNCTION

    APIHOOK_ENTRY(KERNEL32.DLL, GetCommandLineA)
    APIHOOK_ENTRY(KERNEL32.DLL, GetCommandLineW)

HOOK_END

IMPLEMENT_SHIM_END
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\appcompat\tools\smvtest\smvddll\stdafx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
//	SMVDDLL.pch will be the pre-compiled header
//	stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\appcompat\tools\smvtest\smvddll\smvddll.cpp ===
/*++

Copyright (c) 2000-2001  Microsoft Corporation

Module Name:

    Excluded.cpp

Abstract:

    This DLL is explicitly linked to the SMVEXE.

Author:

    Diaa Fathalla (DiaaF)   27-Nov-2000

Revision History:

--*/

#include "stdafx.h"
#include "..\Common\Common.h"

BOOL APIENTRY DllMain( HANDLE hModule, 
                       DWORD  ul_reason_for_call, 
                       LPVOID lpReserved
					 )
{
    if (ul_reason_for_call == DLL_PROCESS_ATTACH)
    {
		CLog Log;
		LPTSTR szTestStr = GetCommandLine();
		Log.LogResults(TestResults(szTestStr),"Calling GetCommandLine from DLL_PROCESS_ATTACH in explicitly linked dll (SMVDDLL.DLL).");
    } 
    return TRUE;
}


EXPORT BOOL WINAPI DDLLTestGetCommandLine()
{
	CLog Log;
	LPTSTR szTestStr = GetCommandLine();
	Log.LogResults(TestResults(szTestStr),"Calling GetCommandLine from an exported function in explicitly linked dll (SMVDDLL.DLL).");
	return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\appcompat\tools\smvtest\smvddll\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by SMVDDLL.rc
//

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        101
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1000
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\appcompat\tools\smvtest\smvddll\stdafx.h ===
// stdafx.h : include file for standard system include files,
//  or project specific include files that are used frequently, but
//      are changed infrequently
//

#if !defined(AFX_STDAFX_H__2F533D5B_39C0_49B3_974B_034363C31C29__INCLUDED_)
#define AFX_STDAFX_H__2F533D5B_39C0_49B3_974B_034363C31C29__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000


// Insert your headers here
//#define WIN32_LEAN_AND_MEAN		// Exclude rarely-used stuff from Windows headers

#include <windows.h>
#include <TCHAR.h>
#include "SMVDDLL.h"
#include "..\Excluded\Excluded.h"
#include "..\Log\Log.h"

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__2F533D5B_39C0_49B3_974B_034363C31C29__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\appcompat\tools\smvtest\smvdrv\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by SMVDrv.rc
//
#define ID_SHOW_LOG                     3
#define IDI_SMV                         101
#define IDD_SMVDRV                      102
#define IDRUN                           1000

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        103
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1001
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\appcompat\tools\smvtest\smvddll\smvddll.h ===
/*++

Copyright (c) 2000-2001  Microsoft Corporation

Module Name:

    Excluded.cpp

Abstract:

    This DLL is being excluded from the applied shim to GetCommandLine() API.

Author:

    Diaa Fathalla (DiaaF)   27-Nov-2000

Revision History:

--*/

#ifndef _SMVDDLL_H_
#define _SMVDDLL_H_

#ifdef __cplusplus
#define EXPORT extern "C" __declspec (dllexport)
#else
#define EXPORT __declspec (dllexport)
#endif

EXPORT BOOL WINAPI DDLLTestGetCommandLine();

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\appcompat\tools\smvtest\shims\shimmechanismverificationtest3\shimmechanismverificationtest3.cpp ===
/*++

 Copyright (c) 2000 Microsoft Corporation

 Module Name:

   ShimMechanismVerificationTest3.cpp

 Abstract:

   This DLL serves as a test for the shim michanism.

 Notes:
 

 History:

   11/13/2000 diaaf  Created
   11/27/2000 diaaf  modified to support the new macros.

--*/

#include "ShimHookEx.h"

DECLARE_SHIM_VERSION2_STANDALONE(ShimMechanismVerificationTest3)

//
// Add APIs that you wish to hook to this macro construction.
//
APIHOOK_ENUM_BEGIN(ShimMechanismVerificationTest3)
    APIHOOK_ENUM_ENTRY(ShimMechanismVerificationTest3, GetCommandLineA) 
    APIHOOK_ENUM_ENTRY(ShimMechanismVerificationTest3, GetCommandLineW) 
APIHOOK_ENUM_END(ShimMechanismVerificationTest3)

//
// Global Variables
//
CHAR *gszCommandLineA;
WCHAR *gwcsCommandLineW;

/*++

 This stub function intercepts all calls to GetCommandLineA
 and appends "1" to the returned string.

--*/

LPSTR APIHOOK(ShimMechanismVerificationTest3,GetCommandLineA)()
{
    CHAR  szAppendValue[] = "3";
	LPSTR szReturnValue;

    DPF("ShimMechanismVerificationTest3", eDbgLevelInfo,
		"GetCommandLineA called.\n");
    
	szReturnValue = ORIGINAL_API(ShimMechanismVerificationTest3,
								 GetCommandLineA)();

	gszCommandLineA = (CHAR*)LocalAlloc(LPTR, strlen(szReturnValue)
									  + strlen(szAppendValue) + sizeof(CHAR));
	
	strcpy(gszCommandLineA, szReturnValue);
	strcat(gszCommandLineA, szAppendValue);

    LOG("ShimMechanismVerificationTest3", eDbgLevelWarning,
        "GetCommandLineA is returning \"%S\".", gszCommandLineA);

    return gszCommandLineA;
}

/*++

 This stub function intercepts all calls to GetCommandLineW
 and appends "1" to the returned string.

--*/

LPWSTR APIHOOK(ShimMechanismVerificationTest3,GetCommandLineW)()
{
    WCHAR   wszAppendValue[] = L"3";
	LPWSTR  wszReturnValue;

    DPF("ShimMechanismVerificationTest3", eDbgLevelInfo,
		"GetCommandLineW called.\n");
    
	wszReturnValue = ORIGINAL_API(ShimMechanismVerificationTest3,
								 GetCommandLineW)();

	gwcsCommandLineW = (WCHAR*)LocalAlloc(LPTR, wcslen(wszReturnValue)
							  + wcslen(wszAppendValue) + sizeof(WCHAR));
	
	wcscpy(gwcsCommandLineW, wszReturnValue);
	wcscat(gwcsCommandLineW, wszAppendValue);

    LOG("ShimMechanismVerificationTest3", eDbgLevelWarning,
        "GetCommandLineW is returning \"%S\".", gwcsCommandLineW);

    return gwcsCommandLineW;
}

/*++

 Handle DLL_PROCESS_ATTACH and DLL_PROCESS_DETACH in your notify function
 to do initialization and uninitialization.
 
--*/
VOID
NOTIFY_FUNCTION(ShimMechanismVerificationTest3)(
    DWORD fdwReason)
{
    if (fdwReason == DLL_PROCESS_ATTACH) {
        gszCommandLineA = NULL;
        gwcsCommandLineW = NULL;
        DPF("ShimMechanismVerificationTest3", eDbgLevelInfo,
			"ShimMechanismVerificationTest3 initialized.");
    } else {
        if (gszCommandLineA)
        {
            LocalFree(gszCommandLineA);
            gszCommandLineA = NULL;
        }
        
        if (gwcsCommandLineW)
        {
            LocalFree(gwcsCommandLineW);
            gwcsCommandLineW = NULL;
        }
        DPF("ShimMechanismVerificationTest3", eDbgLevelInfo, 
			"ShimMechanismVerificationTest3 uninitialized.");
    }
}

/*++

 Register hooked functions

--*/

HOOK_BEGIN(ShimMechanismVerificationTest3)

    APIHOOK_ENTRY(ShimMechanismVerificationTest3, KERNEL32.DLL, GetCommandLineA)
    APIHOOK_ENTRY(ShimMechanismVerificationTest3, KERNEL32.DLL, GetCommandLineW)

    DECLARE_NOTIFY_FUNCTION(ShimMechanismVerificationTest3)

HOOK_END(ShimMechanismVerificationTest3)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\appcompat\tools\smvtest\smvdrv\smvdrv.cpp ===
/*++

Copyright (c) 2000-2001  Microsoft Corporation

Module Name:

    SMVDrv.cpp

Abstract:

    This executable works as a driver for the SMVTest.exe.

Author:

    Diaa Fathalla (DiaaF)   10-Dec-2000
    
Revision History:
	DiaaF	18-Apr-2001		Adding GUI interface

--*/

#include "stdafx.h"
#include "resource.h"

/*
 *	Global Variables
 */
HINSTANCE	g_hInstance;

BOOL CallSMVTest()
{
	CLog Log;
	DWORD dwSignalled = 0;
	DWORD dwExitCode  = 0;
	HANDLE hEventObjects[1];
    PROCESS_INFORMATION  ProcessID;
    STARTUPINFO sui = { sizeof(STARTUPINFO),
						0,
						NULL,
						NULL,
						NULL,
						0,
						0,
						0,
						0,
						0,
						0,
						0,
						0,
						0,
						0 };

	TCHAR sz_CommandLine[MAX_PATH];
	
	GetCurrentDirectory(MAX_PATH, sz_CommandLine);
	_tcscat(sz_CommandLine, TEXT("\\SMVTest.exe"));
	

	//Start running SMVTest 
	if(!::CreateProcess (NULL, 
						sz_CommandLine,
						NULL,
						NULL,
						FALSE,
						NORMAL_PRIORITY_CLASS | CREATE_SUSPENDED, 
						NULL,
						NULL,
						&sui,
						&ProcessID))
	{
		Log.LogResults(FALSE, TEXT("Can't create process for SMVTest.exe"));
		return FALSE;
	}
	 
	//Set the Event to the current Process
	hEventObjects[0] = ProcessID.hThread;

	ResumeThread(ProcessID.hThread);

	dwSignalled = !WAIT_OBJECT_0;
	do
	{
		dwSignalled = WaitForSingleObject(hEventObjects[0],0);
	}	
	//Wait for the 'First' event which is the only one available.
	while (dwSignalled != WAIT_OBJECT_0); 

	GetExitCodeProcess(ProcessID.hProcess, &dwExitCode);

	//Close the thread/process handles
	CloseHandle(ProcessID.hProcess);
	CloseHandle(ProcessID.hThread);

	if(dwExitCode != 0)
		Log.LogResults(FALSE, TEXT("SMVTest.exe returned failure."));

	return TRUE;
}

/*++

	It initializes the project's log file and copy the shim dlls 
	to the AppPatch folder.

--*/

BOOL Initialize()
{
	CLog Log;
	TCHAR szAppPatchFolder[MAX_PATH];
	TCHAR szShimCurrentDir[MAX_PATH];
	TCHAR sz_SMVTSTSrcPath[MAX_PATH];
	TCHAR sz_SMVTST2SrcPath[MAX_PATH];
	TCHAR sz_SMVTSTDstPath[MAX_PATH];
	TCHAR sz_SMVTST2DstPath[MAX_PATH];
	
	Log.InitLogfile();
		
	GetWindowsDirectory(szAppPatchFolder, MAX_PATH);
	_tcscat(szAppPatchFolder, TEXT("\\AppPatch"));
	_tcscpy(sz_SMVTSTDstPath, szAppPatchFolder);
	_tcscpy(sz_SMVTST2DstPath, szAppPatchFolder);

	GetCurrentDirectory(MAX_PATH, szShimCurrentDir);
	_tcscat(szShimCurrentDir, TEXT("\\TestShims"));
	_tcscpy(sz_SMVTSTSrcPath, szShimCurrentDir);
	_tcscpy(sz_SMVTST2SrcPath, szShimCurrentDir);

	_tcscat(sz_SMVTSTSrcPath, TEXT("\\_SMVTST.DLL"));
	_tcscat(sz_SMVTST2SrcPath, TEXT("\\_SMVTST2.DLL"));
	_tcscat(sz_SMVTSTDstPath, TEXT("\\_SMVTST.DLL"));
	_tcscat(sz_SMVTST2DstPath, TEXT("\\_SMVTST2.DLL"));

	//Copy the _SMVTST and _SMVTST2 to the AppPatch folder.
	CopyFile(sz_SMVTSTSrcPath, sz_SMVTSTDstPath, FALSE);
	CopyFile(sz_SMVTST2SrcPath, sz_SMVTST2DstPath, FALSE);

	return TRUE;
}

/*++

	It uninitializes the project's log file and delete the shim dlls 
	from the AppPatch folder.

--*/

BOOL Uninitialize()
{
	CLog Log;
	TCHAR szAppPatchFolder[MAX_PATH];
	TCHAR sz_SMVTSTDstPath[MAX_PATH];
	TCHAR sz_SMVTST2DstPath[MAX_PATH];
	
	GetWindowsDirectory(szAppPatchFolder, MAX_PATH);
	_tcscat(szAppPatchFolder, TEXT("\\AppPatch"));
	_tcscpy(sz_SMVTSTDstPath, szAppPatchFolder);
	_tcscpy(sz_SMVTST2DstPath, szAppPatchFolder);

	_tcscat(sz_SMVTSTDstPath, TEXT("\\_SMVTST.DLL"));
	_tcscat(sz_SMVTST2DstPath, TEXT("\\_SMVTST2.DLL"));
	
	//Delete the shim DLLs from the AppPatch Folder
	DeleteFile(sz_SMVTSTDstPath);
	DeleteFile(sz_SMVTST2DstPath);

	Log.EndLogfile();
	
	return TRUE;
}

/*++

	SetEnvironmentVariables: Sets necessary Environment Variables.

--*/

BOOL SetEnvironmentVariables()
{
	TCHAR	sz_Buffer[] = _T("9");
	DWORD	dwReturnValue;
	HKEY	hKey= NULL;
	long	lRet= 0;
	TCHAR	sz_SubKey[] = _T("SYSTEM\\CurrentControlSet\\Control\\Session Manager\\Environment");
	CLog Log;

	lRet = RegOpenKeyEx(HKEY_LOCAL_MACHINE, sz_SubKey, 0, KEY_WRITE, &hKey);
	if(lRet == ERROR_SUCCESS)
	{
		lRet = RegSetValueEx(hKey,_T("SHIM_DEBUG_LEVEL"), 0, REG_SZ, 
							(LPBYTE) sz_Buffer, sizeof(sz_Buffer));

		if(lRet == ERROR_SUCCESS)
			SendMessageTimeout(HWND_BROADCAST, WM_SETTINGCHANGE, 0,(LPARAM) _T("Environment"),
							   SMTO_ABORTIFHUNG, 5000, &dwReturnValue);
		else
			Log.LogResults(FALSE,TEXT("Can't set the environment variable SHIM_DEBUG_LEVEL"));
						
		RegCloseKey(hKey);
	}

	return TRUE;
}

BOOL CALLBACK
SMVDrvDlgProc(
	HWND	hDlg,
	UINT	uMsg,
	WPARAM	wParam,
	LPARAM	lParam)
/*++
	SMVDrvDlgProc

	Description:	The dialog proc of SMVDrv.
--*/
{
	switch (uMsg) {
	case WM_INITDIALOG:
		SetClassLong(hDlg, GCL_HICON, (LONG) LoadIcon(g_hInstance,MAKEINTRESOURCE(IDI_SMV)));
		//g_bGoodApp = FALSE;
		//CheckRadioButton(hDlg, IDC_OPTION_GOOD, IDC_OPTION_BAD, IDC_OPTION_BAD);
		SetEnvironmentVariables();
		break;
	case WM_COMMAND:
		switch (LOWORD (wParam))
		{
		case IDCANCEL:
			EndDialog(hDlg, TRUE);
			return TRUE;
		case IDRUN:
			Initialize();
			CallSMVTest();
			Uninitialize();
			break;
		//case IDC_OPTION_GOOD:
		//case IDC_OPTION_BAD:
		//	CheckRadioButton(hDlg, IDC_OPTION_GOOD, IDC_OPTION_BAD, LOWORD(wParam));
		//	g_bGoodApp = !g_bGoodApp;
		//	return TRUE;
		}
	default:
		return FALSE;
	}

	return FALSE;
}


int APIENTRY WinMain(HINSTANCE hInstance,
                     HINSTANCE hPrevInstance,
                     LPSTR     lpCmdLine,
                     int       nCmdShow)
/*++

	It initializes the project's log file and copy the shim dlls 
	to the AppPatch folder.

--*/
{
	switch(*lpCmdLine)
	{
		//
		// Check for the command line options
		//
	case '/':
	case '-':
		switch(*(lpCmdLine+1))
		{
		//Quite Mode
		case 'q':
		case 'Q':
			Initialize();
			SetEnvironmentVariables();
			CallSMVTest();
			Uninitialize();
			break;
		}
		break;
	default:
		//
		// If no command line options, launch dialog.
		//
		g_hInstance = hInstance;
		DialogBox(hInstance,
				  MAKEINTRESOURCE(IDD_SMVDRV),
				  GetDesktopWindow(),
				  SMVDrvDlgProc);		
	}

	return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\appcompat\tools\smvtest\smvdrv\smvdrv.h ===
/*++

Copyright (c) 2000-2001  Microsoft Corporation

Module Name:

    SMVDrv.h

Abstract:

    This DLL is being excluded from the applied shim to GetCommandLine() API.

Author:

    Diaa Fathalla (DiaaF)   10-Dec-2000

Revision History:

--*/

#ifndef _SMVDRV_H_
#define _SMVDRV_H_

BOOL Initialize();
BOOL Uninitialize();
BOOL CallSMVTest();
BOOL SetEnvironmentVariables();

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\appcompat\tools\smvtest\smvdrv\stdafx.h ===
// stdafx.h : include file for standard system include files,
//  or project specific include files that are used frequently, but
//      are changed infrequently
//

#if !defined(AFX_STDAFX_H__A9DB83DB_A9FD_11D0_BFD1_444553540000__INCLUDED_)
#define AFX_STDAFX_H__A9DB83DB_A9FD_11D0_BFD1_444553540000__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

//#define WIN32_LEAN_AND_MEAN		// Exclude rarely-used stuff from Windows headers

#include <windows.h>
#include <TCHAR.h>
#include "SMVDrv.h"
#include "..\Log\Log.h"

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__A9DB83DB_A9FD_11D0_BFD1_444553540000__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\appcompat\tools\smvtest\smvdrv\stdafx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
//	SMVDrv.pch will be the pre-compiled header
//	stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\appcompat\tools\smvtest\smvsdll\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by SMVSDLL.rc
//

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        101
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1000
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\appcompat\tools\smvtest\smvsdll\smvsdll.h ===
/*++

Copyright (c) 2000-2001  Microsoft Corporation

Module Name:

    Excluded.cpp

Abstract:

    This DLL is implicitly linked with SMVTest.exe.

Author:

    Diaa Fathalla (DiaaF)   27-Nov-2000

Revision History:

--*/

#ifndef _SMVSDLL_H_
#define _SMVSDLL_H_

#ifdef __cplusplus
#define EXPORT extern "C" __declspec (dllexport)
#else
#define EXPORT __declspec (dllexport)
#endif

EXPORT BOOL WINAPI SDLLTestGetCommandLine();

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\appcompat\tools\smvtest\smvsdll\smvsdll.cpp ===
/*++

Copyright (c) 2000-2001  Microsoft Corporation

Module Name:

    Excluded.cpp

Abstract:

    This DLL is being excluded from the applied shim to GetCommandLine() API.

Author:

    Diaa Fathalla (DiaaF)   27-Nov-2000

Revision History:

--*/

#include "stdafx.h"
#include "..\common\common.h"

BOOL APIENTRY DllMain( HANDLE hModule, 
                       DWORD  ul_reason_for_call, 
                       LPVOID lpReserved
					 )
{
    if (ul_reason_for_call == DLL_PROCESS_ATTACH)
    {
		CLog Log;
		Log.InitLogfileInfo();
		LPTSTR szTestStr = GetCommandLine();
		Log.LogResults(TestResults(szTestStr),TEXT("Calling GetCommandLine from DLL_PROCESS_ATTACH in implicitly linked dll (SMVSDLL.DLL)."));
    } 

    return TRUE;
}

EXPORT BOOL WINAPI SDLLTestGetCommandLine()
{
	CLog Log;
	LPTSTR szTestStr = GetCommandLine();
	Log.LogResults(TestResults(szTestStr),TEXT("Calling GetCommandLine from an exported function in implicitly linked dll (SMVSDLL.DLL)."));

	return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\appcompat\tools\smvtest\smvtest\stdafx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
//	SMVTest.pch will be the pre-compiled header
//	stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\appcompat\tools\smvtest\smvtest\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by SMVTest.rc
//

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        101
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1000
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\appcompat\tools\smvtest\smvsdll\stdafx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
//	SMVSDLL.pch will be the pre-compiled header
//	stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\appcompat\tools\smvtest\smvsdll\stdafx.h ===
// stdafx.h : include file for standard system include files,
//  or project specific include files that are used frequently, but
//  are changed infrequently
//

#if !defined(AFX_STDAFX_H__9C7A24C3_919D_4420_A492_C77E155B0D69__INCLUDED_)
#define AFX_STDAFX_H__9C7A24C3_919D_4420_A492_C77E155B0D69__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000


// Insert your headers here
#ifndef WIN32_LEAN_AND_MEAN
#define WIN32_LEAN_AND_MEAN		// Exclude rarely-used stuff from Windows headers
#endif

#include <windows.h>
#include <TCHAR.h>
#include "SMVSDLL.h"
#include "..\Excluded\Excluded.h"
#include "..\Log\Log.h"

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__9C7A24C3_919D_4420_A492_C77E155B0D69__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\appcompat\tools\smvtest\smvtest\smvtest.cpp ===
/*++

Copyright (c) 2000-2001  Microsoft Corporation

Module Name:

    Excluded.cpp

Abstract:

	SMVTest.cpp : Defines the entry point for the console application.
	SMV: Shim Mechainsm Verifier


Author:

    Diaa Fathalla (DiaaF)   27-Nov-2000

Revision History:

--*/

#include "stdafx.h"
#include "..\Common\Common.h"

void TestEXEGetCommandLine();
void TestSDLLGetCommandLine();
void TestDDLLGetCommandLine();

int
__cdecl
main(int argc, char* argv[])
{
	//Test the Explicitly linked DLL
	TestSDLLGetCommandLine();

	//Test the Implicitly linked DLL
	TestDDLLGetCommandLine();

	//Do the local test.
	TestEXEGetCommandLine();

	return 0;
}

void TestEXEGetCommandLine()
{
	CLog Log;
	LPTSTR szTestStr = GetCommandLine();
	Log.LogResults(TestResults(szTestStr),TEXT("Calling GetCommandLine from an executable (SMVTest.exe)."));
	return;
}

void TestSDLLGetCommandLine()
{
	SDLLTestGetCommandLine();
	return;
}

void TestDDLLGetCommandLine()
{
	HINSTANCE	hLibrary;
	PFNTEST		pfnDDLLGetCommandLine;
		
	if ((hLibrary = LoadLibrary(TEXT("SMVDDLL.DLL"))) == NULL)
	{
		CLog Log;
		Log.LogResults(FALSE,TEXT("Can't load SMVDDLL.DLL."));
		return;
	}
	pfnDDLLGetCommandLine = (PFNTEST) GetProcAddress(hLibrary, TEXT("DDLLTestGetCommandLine"));
	if (pfnDDLLGetCommandLine == NULL)
	{
		if (hLibrary)
			FreeLibrary(hLibrary);
		CLog Log;
		Log.LogResults(FALSE,TEXT("Can't find DDLLTestGetCommandLine in SMVDDLL."));
		return;
	}

	(pfnDDLLGetCommandLine)();

	if (hLibrary)
		FreeLibrary(hLibrary);

	return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\appcompat\tools\smvtest\smvtest\smvtest.h ===
/*++

Copyright (c) 2000-2001  Microsoft Corporation

Module Name:

    Excluded.cpp

Abstract:

    This DLL is being excluded from the applied shim to GetCommandLine() API.

Author:

    Diaa Fathalla (DiaaF)   27-Nov-2000

Revision History:

--*/

#ifndef _SMVTEST_H_
#define _SMVTEST_H_

typedef BOOL (WINAPI* PFNTEST) ();

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\appcompat\tools\smvtest\smvtest\stdafx.h ===
// stdafx.h : include file for standard system include files,
//  or project specific include files that are used frequently, but
//  are changed infrequently
//

#if !defined(AFX_STDAFX_H__C0DC9B3F_57F9_444F_89BD_C7A4AAE2B10F__INCLUDED_)
#define AFX_STDAFX_H__C0DC9B3F_57F9_444F_89BD_C7A4AAE2B10F__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#include <windows.h>
#include <TCHAR.h>
#include "SMVTest.h"
#include "..\Log\Log.h"
#include "..\Excluded\Excluded.h"
#include "..\SMVSDLL\SMVSDLL.h"

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__C0DC9B3F_57F9_444F_89BD_C7A4AAE2B10F__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\appcompat\tools\xmlwiz\stdafx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
//	AppEntryWizard.pch will be the pre-compiled header
//	stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"

// TODO: reference any additional headers you need in STDAFX.H
// and not in this file
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\appcompat\tools\xmlwiz\xmlwiz.h ===
#if !defined(AFX_APPENTRYWIZARD_H__7B9BB236_EB63_4854_B8CA_C80EE17CFB37__INCLUDED_)
#define AFX_APPENTRYWIZARD_H__7B9BB236_EB63_4854_B8CA_C80EE17CFB37__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#include "xmlwizres.h"


#endif // !defined(AFX_APPENTRYWIZARD_H__7B9BB236_EB63_4854_B8CA_C80EE17CFB37__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\appcompat\tools\xmlwiz\verread.h ===
//+--------------------------------------------------------------------------
//
// Microsoft Windows
// Copyright (C) Microsoft Corporation, 2000
//
// File:        verread.h
//
// Contents:    headers for reading version info for app matching
//
// History:     24-Feb-00   dmunsil         created
//
//---------------------------------------------------------------------------


typedef struct _VERSION_DATA {
    PVOID               pBuffer;
    DWORD               dwBufferSize;
    VS_FIXEDFILEINFO    *pFixedInfo;
} VERSION_DATA, *PVERSION_DATA;

BOOL bInitVersionData(TCHAR *szPath, PVERSION_DATA pVersionData);
TCHAR *szGetVersionString(PVERSION_DATA pVersionData, TCHAR *szString);
ULONGLONG qwGetBinFileVer(PVERSION_DATA pVersionData);
ULONGLONG qwGetBinProdVer(PVERSION_DATA pVersionData);
void vReleaseVersionData(PVERSION_DATA pVersionData);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\appcompat\tools\xmlwiz\stdafx.h ===
// stdafx.h : include file for standard system include files,
//  or project specific include files that are used frequently, but
//      are changed infrequently
//

#if !defined(AFX_STDAFX_H__A9DB83DB_A9FD_11D0_BFD1_444553540000__INCLUDED_)
#define AFX_STDAFX_H__A9DB83DB_A9FD_11D0_BFD1_444553540000__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

//#define WIN32_LEAN_AND_MEAN		// Exclude rarely-used stuff from Windows headers


// Windows Header Files:
#include <windows.h>

// C RunTime Header Files
#include <stdlib.h>
#include <malloc.h>
#include <memory.h>
#include <tchar.h>

// Local Header Files

// TODO: reference additional headers your program requires here

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__A9DB83DB_A9FD_11D0_BFD1_444553540000__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\appcompat\tools\xmlwiz\verread.cpp ===
//+--------------------------------------------------------------------------
//
// Microsoft Windows
// Copyright (C) Microsoft Corporation, 2000
//
// File:        verread.cpp
//
// Contents:    code for reading version info for app matching
//
// History:     24-Feb-00   dmunsil         created
//
//---------------------------------------------------------------------------


#include "stdafx.h"
#include "stdio.h"
#include "assert.h"
#include "verread.h"

BOOL bInitVersionData(TCHAR *szPath, PVERSION_DATA pVersionData)
{
    UINT unSize = 0;
    DWORD dwNull = 0;

    assert(szPath && pVersionData);

    ZeroMemory(pVersionData, sizeof(VERSION_DATA));

    pVersionData->dwBufferSize = GetFileVersionInfoSize(szPath, &dwNull);
    if (!pVersionData->dwBufferSize) {
        goto err;
    }

    pVersionData->pBuffer = new BYTE[pVersionData->dwBufferSize];
    if (!pVersionData->pBuffer) {
        goto err;
    }

    if (!GetFileVersionInfo(szPath, 0, pVersionData->dwBufferSize, pVersionData->pBuffer)) {
        goto err;
    }

    if (!VerQueryValue(pVersionData->pBuffer, TEXT("\\"), (PVOID*)&pVersionData->pFixedInfo, &unSize)) {
        goto err;
    }

    return TRUE;

err:

    if (pVersionData->pBuffer) {
        delete [] pVersionData->pBuffer;
        ZeroMemory(pVersionData, sizeof(VERSION_DATA));
    }

    return FALSE;
}

/*--

  Search order is:

  - Language neutral, Unicode (0x000004B0)
  - Language neutral, Windows-multilingual (0x000004e4)
  - US English, Unicode (0x040904B0)
  - US English, Windows-multilingual (0x040904E4)

  If none of those exist, it's not likely we're going to get good
  matching info from what does exist.

--*/

TCHAR *szGetVersionString(PVERSION_DATA pVersionData, TCHAR *szString)
{
    TCHAR szTemp[100] = "";
    TCHAR *szReturn = NULL;
    static DWORD adwLangs[] = {0x000004B0, 0x000004E4, 0x040904B0, 0x040904E4, 0};
    int i;

    assert(pVersionData && szString);

    for (i = 0; adwLangs[i]; ++i) {
        UINT unLen;

        _stprintf(szTemp, TEXT("\\StringFileInfo\\%08X\\%s"), adwLangs[i], szString);
        if (VerQueryValue(pVersionData->pBuffer, szTemp, (PVOID*)&szReturn, &unLen)) {
            goto out;
        }
    }
out:

    return szReturn;
}

ULONGLONG qwGetBinFileVer(PVERSION_DATA pVersionData)
{
    LARGE_INTEGER liReturn;

    assert(pVersionData);

    liReturn.LowPart = pVersionData->pFixedInfo->dwFileVersionLS;
    liReturn.HighPart = pVersionData->pFixedInfo->dwFileVersionMS;

    return liReturn.QuadPart;
}

ULONGLONG qwGetBinProdVer(PVERSION_DATA pVersionData)
{
    LARGE_INTEGER liReturn;

    assert(pVersionData);

    liReturn.LowPart = pVersionData->pFixedInfo->dwProductVersionLS;
    liReturn.HighPart = pVersionData->pFixedInfo->dwProductVersionMS;

    return liReturn.QuadPart;
}

void vReleaseVersionData(PVERSION_DATA pVersionData)
{
    assert(pVersionData);

    if (pVersionData->pBuffer) {
        delete [] pVersionData->pBuffer;
        ZeroMemory(pVersionData, sizeof(VERSION_DATA));
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\appcompat\windowsupdate\installer\cqueue.cpp ===
/*++

  Copyright (c) 2000 Microsoft Corporation

  Module Name:

    CQueue.cpp

  Abstract:

    The implementation of the C++
    Queue class.

  Notes:

    Unicode only.
    
  History:

    10/10/2000      a-fwills    Created

--*/

#include "CQueue.h"


/*++

  Routine Description:

    CQNode c'tor

  Arguments:

    lpwszString(in): Null-delimited string assigned to CQNode on 
        creation, which takes place when CQueue Enqueues a string.
    
  Return Value:


--*/
CQNode::CQNode(
    LPWSTR lpwszString
    ) 
{
    int nLen = wcslen(lpwszString);

    LPWSTR lpwAlloc;

    // Will be null if HeapAlloc fails. This will result in 
    // FALSE return value when trying to Enqueue strings in CQueue.
    m_lpwszString = 0;
    m_pNext = 0;

    if(!(lpwAlloc = (LPWSTR)HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, 
        sizeof(WCHAR)*(nLen+1))))
        return;

    m_lpwszString = lpwAlloc;

    wcscpy(m_lpwszString, lpwszString);
}

/*++

  Routine Description:

    CQNode d'tor

  Arguments:

    None.
    
  Return Value:
  
    None.

--*/
CQNode::~CQNode(
    )
{
    if(m_lpwszString)
        HeapFree(GetProcessHeap(), 0, m_lpwszString);
}

/*++

  Routine Description:

    CQNode copy c'tor

  Arguments:

    lpwString(out): Null delimited buffer to contain string 
        enqueued contained by CQNode.
    nMaxLen(in): Maximum length available in buffer lpwString 
        for copy of CQNode string. String returned will be 
        null-delimited.
    
  Return Value:
    TRUE: CQNode successfully allocated storage for a string 
        on creation (is non-null), and was able to return a 
        string of zero lenght to nMaxLen length.
    FALSE: CQNode does not contain a valid storage space for 
        a string to return.
--*/
BOOL CQNode::Copy(
    LPWSTR lpwString,
    int nMaxLen
    )
{
    if(!m_lpwszString)
        return FALSE;

    wcsncpy(lpwString, m_lpwszString, nMaxLen);
    *(lpwString+nMaxLen) = 0;

    return TRUE;
}

/*++

  Routine Description:

    CQueue c'tor

  Arguments:

    None.
    
  Return Value:

--*/
CQueue::CQueue(
    )
{
    m_cSize = 0;
    m_pHead = m_pTail = 0;
}

/*++

  Routine Description:

    CQeue d'tor

  Arguments:

    None.
    
  Return Value:


--*/
CQueue::~CQueue(
    ) 
{
    CQNode *pQNode;

    while(m_pHead) {
        pQNode = m_pHead;
        m_pHead = m_pHead->m_pNext;
        delete pQNode;
        }
}

/*++

  Routine Description:

    Removes a string from the queue.

  Arguments:

    lpwString(out): buffer to contain null-delimited string 
        being dequeued.
    nMaxLen(in): maximum length available for string in buffer.
    
  Return Value:
    TRUE: Queue is not empty and string was successfully 
        returned in buffer lpwString.
    FALSE: Queue was empty. No string was returned in buffer.

--*/
BOOL CQueue::Dequeue(
    LPWSTR lpwString,
    int    nMaxLen,
    BOOL   fPersist
    )
{
    CQNode *pQNode;

    if (fPersist) {
        pQNode = m_pHead;
        pQNode->Copy(lpwString, nMaxLen);
    
    } else {

        if(!m_pHead)
            return FALSE;

        pQNode = m_pHead;
        m_pHead = m_pHead->m_pNext;
        if(!m_pHead)
            m_pTail = 0;

        pQNode->Copy(lpwString, nMaxLen);

        delete pQNode;

        m_cSize--;
    }    

    return TRUE;
}

/*++

  Routine Description:

    Adds a string to the queue.

  Arguments:

    lpwszString(in): null-delimited string to enqueue.
    
  Return Value:


--*/
BOOL CQueue::Enqueue(
    LPWSTR lpwszString
    ) 
{
    CQNode *pNode = new CQNode(lpwszString), *pTail;

    pTail = pNode;
    if(m_pTail)
        m_pTail->m_pNext = pTail;
    m_pTail = pTail;

    if(!m_pHead)
        m_pHead = m_pTail;

    m_cSize++;

    return true;
}

/*++

  Routine Description:

    Retrives the length of the queue.

  Arguments:

    None.
    
  Return Value:
    The length of the current string at the head of the queue.
    Will return -1 if no strings are enqueued.

--*/
int CQueue::GetLength(
    ) 
{
    if(!m_pHead)
        return -1;

    return m_pHead->GetLength();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\appcompat\tools\xmlwiz\xmlwizres.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by xmlwiz.rc
//
#define IDC_MYICON                      2
#define IDD_APPENTRYWIZARD_DIALOG       102
#define IDD_ABOUTBOX                    103
#define IDS_APP_TITLE                   103
#define IDM_ABOUT                       104
#define IDD_MAIN                        104
#define IDM_EXIT                        105
#define IDS_HELLO                       106
#define IDI_APPENTRYWIZARD              107
#define IDI_SMALL                       108
#define IDC_APPENTRYWIZARD              109
#define IDR_MAINFRAME                   128
#define IDR_ACCELERATOR1                130
#define IDD_DLL_LIST                    131
#define IDC_EDIT1                       1000
#define IDC_BTN_SET_EXE                 1002
#define IDC_BTN_ADD_MATCH               1003
#define IDC_BUTTON3                     1004
#define IDC_BTN_ADD_DLL                 1004
#define IDC_BUTTON4                     1005
#define IDC_BUTTON5                     1006
#define IDC_BTN_WRITE_SYSTEST           1006
#define IDC_BUTTON6                     1007
#define IDC_BUTTON7                     1008
#define IDC_BTN_COPY                    1009
#define IDC_DLL_LIST                    1010
#define IDA_SELECT_ALL                  32772
#define IDC_STATIC                      -1

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NO_MFC                     1
#define _APS_NEXT_RESOURCE_VALUE        132
#define _APS_NEXT_COMMAND_VALUE         32773
#define _APS_NEXT_CONTROL_VALUE         1011
#define _APS_NEXT_SYMED_VALUE           110
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\appcompat\windowsupdate\installer\cqueue.h ===
/*++

  Copyright (c) 2000 Microsoft Corporation

  Module Name:

    CQueue.h

  Abstract:

    Class definition and constants
    for the C++ queue class.

  Notes:

    Unicode only.
    
  History:

    10/10/2000      a-fwills    Created

--*/

#ifndef __CQueue_h__
#define __CQueue_h__

#include <windows.h>
#include <string.h>

class CQNode {
    
    private:
        LPWSTR    m_lpwszString;
    
    public:
        CQNode    *m_pNext;

    public:
        CQNode(LPWSTR lpwString);
        ~CQNode();
        Copy(LPWSTR lpwString, int nMaxLen);
        int GetLength() { return wcslen(m_lpwszString); }
    };

class CQueue {

    private:
        int     m_cSize;
        CQNode  *m_pHead,
                *m_pTail;

    public:
        CQueue();
        ~CQueue();
        BOOL Enqueue(LPWSTR lpwszString);
        BOOL Dequeue(LPWSTR lpwString, int nMaxLen, BOOL fPersist);
        int GetLength(); // Length of string at head of queue.
        int GetSize() { return m_cSize; } // Size of queue.
    };

#endif __CQueue_h__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\appcompat\tools\xmlwiz\xmlwiz.cpp ===
//+--------------------------------------------------------------------------
//
// Microsoft Windows
// Copyright (C) Microsoft Corporation, 2000
//
// File:        xmlwiz.cpp
//
// Contents:    code for generating app matching XML
//
// History:    ~12-Jan-00   dmunsil         created
//              18-Feb-00   dmunsil         ver 0.8 -- added changing '&' to "&amp"
//
//---------------------------------------------------------------------------


#include "stdafx.h"
#include "commdlg.h"
#include "stdio.h"
#include "assert.h"
#include "xmlwizres.h"
#include "verread.h"

extern "C" {
#include "shimdb.h"
}

#undef _GATHER_TIME

#define MAX_LINE_LEN 500
#define MAX_NUM_LINES 100
#define MAX_TEXT_BUF 32768
#define MAX_WORKING_BUFFER_SIZE 65536

// Types

typedef struct _MATCH_INFO {
    DWORD           dwSize;
    DWORD           dwChecksum;
    char            szTime[20];
    LARGE_INTEGER   liBinFileVersion;
    LARGE_INTEGER   liBinProdVersion;
    char            szProductName[50];
} MATCH_INFO, *PMATCH_INFO;

// Global Variables:
HINSTANCE g_hInst;                              // current instance
HWND g_hMainDlg;

char g_szExeName[260];
char g_szExeFullPath[1000];
char g_szParentExeName[260];
char g_szParentExeFullPath[1000];

char g_szEditText[MAX_TEXT_BUF];
char g_aszEditLines[MAX_NUM_LINES][MAX_LINE_LEN];
UINT g_unEditLines;

char g_szAppIndent[] = "    "; // 4 spaces
char g_szExeIndent[] = "        "; // 8 spaces
char g_szMatchIndent[] = "            "; // 12 spaces

char g_szMatchAttributeIndent[] = "                           "; // 27 spaces
char g_szExeAttributeIndent[] = "             "; // 13 spaces
BOOL g_bSelectedParentExe = FALSE;

DWORD g_dwSystemDlls = 0;

HFONT g_hFont;

// Foward declarations of functions included in this code module:
ATOM                MyRegisterClass(HINSTANCE hInstance);
BOOL                InitInstance(HINSTANCE, int);
LRESULT CALLBACK    DlgMain(HWND, UINT, WPARAM, LPARAM);
LRESULT CALLBACK    DlgDlls(HWND, UINT, WPARAM, LPARAM);
void GetExeNames(HWND hDlg);
void GetMatchFile(HWND hDlg);
void UnpackEditLines(HWND hDlg);
void PackEditLines(HWND hDlg);
void DeleteLines(UINT unBegin, UINT unLen);
void InsertLine(UINT unLine, char *szLine);
void InsertExeLines(UINT unLine);
BOOL bFindLine(char *szSearch, UINT *punLine);
BOOL bFindLineFrom(char *szSearch, UINT unStart, UINT *punLine);
void InitEditLines(void);
void GetMatchInfo(char *szFile, PMATCH_INFO pMatch);
DWORD GetFileChecksum(HANDLE handle);
char *szGetRelativePath(char *pExeFile, char *pMatchFile);
BOOL bSameDrive(char *szPath1, char *szPath2);
void MySelectAll(HWND hDlg);

void vEnumerateSystemDlls(HWND hDlg);
void vAddSelectedDlls(HWND hDlg);
void vWriteSysTest(void);

char *szConvertSpecialChars(char *szString);


int APIENTRY WinMain(HINSTANCE hInstance,
                     HINSTANCE hPrevInstance,
                     LPSTR     lpCmdLine,
                     int       nCmdShow)
{
    MSG msg;
    HACCEL hAccel;

    // Perform application initialization:
    if (!InitInstance (hInstance, nCmdShow)) 
    {
        return FALSE;
    }

    hAccel = LoadAccelerators(hInstance, MAKEINTRESOURCE(IDR_ACCELERATOR1));

    if (hAccel == NULL)
    {
        return FALSE;
    }

    g_hMainDlg = CreateDialog(hInstance, (LPCTSTR)IDD_MAIN, NULL, (DLGPROC)DlgMain);

    // Main message loop:
    while (GetMessage(&msg, NULL, 0, 0)) 
    {
        if (!TranslateAccelerator(g_hMainDlg, hAccel, &msg)) {
            TranslateMessage(&msg);
            DispatchMessage(&msg);
        }
    }



    return msg.wParam;
}



//
//   FUNCTION: InitInstance(HANDLE, int)
//
//   PURPOSE: Saves instance handle and creates main window
//
//   COMMENTS:
//
//        In this function, we save the instance handle in a global variable and
//        create and display the main program window.
//
BOOL InitInstance(HINSTANCE hInstance, int nCmdShow)
{
   //HWND hWnd;

   g_hInst = hInstance; // Store instance handle in our global variable
   g_szExeName[0] = '\0';
   g_szExeFullPath[0] = '\0';
   g_szParentExeName[0] = '\0';
   g_szParentExeFullPath[0] = '\0';
   InitEditLines();

   return TRUE;
}


// Message handler for DLL dialog.
LRESULT CALLBACK DlgDlls(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam)
{
    switch (message)
    {
    case WM_INITDIALOG:
        vEnumerateSystemDlls(hDlg);
        return TRUE;
        break;

    case WM_COMMAND:
        switch LOWORD(wParam) {

        case IDOK:
            vAddSelectedDlls(hDlg);
            // falls through

        case IDCANCEL:

            EndDialog(hDlg, LOWORD(wParam));
            return TRUE;
            break;
        }
    }
    return FALSE;
}

// Message handler for main dialog.
LRESULT CALLBACK DlgMain(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam)
{
    HDC hDC;

    switch (message)
    {
    case WM_INITDIALOG:
        if (!g_szExeName[0]) {
            HWND hBtn;

            hBtn = GetDlgItem(hDlg, IDC_BTN_ADD_MATCH);
            EnableWindow(hBtn, FALSE);
            hBtn = GetDlgItem(hDlg, IDC_BTN_ADD_DLL);
            EnableWindow(hBtn, FALSE);
        }

        // set the edit window to fixed-width font
        hDC = GetDC(hDlg);
        if (hDC) {
            g_hFont = CreateFont(
                -MulDiv(9, GetDeviceCaps(hDC, LOGPIXELSY), 72), // 9-pt font
                0,
                0,
                0,
                FW_REGULAR,
                FALSE,
                FALSE,
                FALSE,
                ANSI_CHARSET,
                OUT_DEFAULT_PRECIS,
                CLIP_DEFAULT_PRECIS,
                ANTIALIASED_QUALITY,
                FIXED_PITCH | FF_MODERN,
                NULL);
            if (g_hFont) {
                HWND hEdit = GetDlgItem(hDlg, IDC_EDIT1);
                SendMessage(hEdit, WM_SETFONT, (WPARAM)g_hFont, TRUE);
            }
            ReleaseDC(hDlg, hDC);
        }

        return TRUE;
        break;

    case WM_COMMAND:
        switch LOWORD(wParam) {
        case IDA_SELECT_ALL:
            MySelectAll(hDlg);
            break;

        case IDC_BTN_SET_EXE:
            GetExeNames(hDlg);
            break;

        case IDC_BTN_ADD_MATCH:
            GetMatchFile(hDlg);
            break;

        case IDC_BTN_ADD_DLL:
            DialogBox(g_hInst, (LPCTSTR)IDD_DLL_LIST, hDlg, (DLGPROC)DlgDlls);
            break;

        case IDC_BTN_WRITE_SYSTEST:
            vWriteSysTest();
            break;

        case IDOK:
        case IDCANCEL:
            EndDialog(hDlg, LOWORD(wParam));
            PostQuitMessage(0);
            DeleteObject(g_hFont);
            return TRUE;
            break;
        }
    }
    return FALSE;
}

void GetMatchFile(HWND hDlg)
{
    OPENFILENAME ofn;
    MATCH_INFO MatchInfo;
    char szMatchFile[1000];
    char szInitialPath[1000];
    char szFileTitle[260];

    char szDrive[_MAX_DRIVE];
    char szDir[_MAX_DIR];
    UINT unLine;
    char szTemp[MAX_LINE_LEN];
    char szTime[MAX_LINE_LEN];
    char szProdVer[MAX_LINE_LEN];
    char szFileVer[MAX_LINE_LEN];
    char szProdName[MAX_LINE_LEN];
    char *szMatch;

    szMatchFile[0] = '\0';
    szFileTitle[0] = '\0';
    szInitialPath[0] = '\0';
    if (g_szParentExeFullPath[0]) {
        _splitpath(g_szParentExeFullPath, szDrive, szDir, NULL, NULL);
        strcpy(szInitialPath, szDrive);
        strcat(szInitialPath, szDir);
    }

    ZeroMemory(&ofn, sizeof(OPENFILENAME));
    ofn.lStructSize = sizeof(OPENFILENAME);
    ofn.hwndOwner = hDlg;
    ofn.lpstrFile = szMatchFile;
    ofn.nMaxFile = sizeof(szMatchFile);
    ofn.lpstrFilter = "All\0*.*\0Exe\0*.EXE\0";
    ofn.nFilterIndex = 1;
    ofn.lpstrFileTitle = szFileTitle;
    ofn.nMaxFileTitle = sizeof(szFileTitle);
    ofn.lpstrInitialDir = szInitialPath;
    ofn.lpstrTitle = "Select Matching File";
    ofn.Flags = OFN_PATHMUSTEXIST | OFN_FILEMUSTEXIST | OFN_NODEREFERENCELINKS;

    // get the matching file name 
    if (GetOpenFileName(&ofn) == FALSE) {
        goto err1;
    }

    // get the lines out of the edit dialog
    UnpackEditLines(hDlg);

    // check if we need to get an parent exe
    if (!bSameDrive(szMatchFile, g_szParentExeFullPath) && !g_bSelectedParentExe) {
        char szParentFile[1000];

        // get the parent exe
        szParentFile[0] = '\0';
        szInitialPath[0] = '\0';
        if (szMatchFile[0]) {
            _splitpath(szMatchFile, szDrive, szDir, NULL, NULL);
            strcpy(szInitialPath, szDrive);
            strcat(szInitialPath, szDir);
        }

        // most of ofn is already filled-in
        ofn.lpstrTitle = "Select Parent Exe";
        ofn.lpstrFile = szParentFile;
        ofn.nMaxFile = sizeof(szParentFile);

        if (GetOpenFileName(&ofn) == TRUE) {
            strcpy(g_szParentExeName, szFileTitle);
            strcpy(g_szParentExeFullPath, szParentFile);
            g_bSelectedParentExe = TRUE;

            // delete any previous parent exe comments
            while (bFindLine("<!-- Parent exe", &unLine)) {
                DeleteLines(unLine, 1);
            }

            // reconstruct the EXE if necessary
            if (!bFindLine("<EXE", &unLine)) {
                // insert it right after <APP> or at the beginning
                if (bFindLine("<APP", &unLine)) {
                    unLine += 1;
                } else {
                    unLine = 0;
                }

                InsertExeLines(unLine);
            }

            // if the parent exe is different, insert a comment
            if (strcmp(g_szExeFullPath, g_szParentExeFullPath) != 0) {
                char *szPathWithoutDrive = g_szParentExeFullPath + 2;

                if (bSameDrive(g_szExeFullPath, g_szParentExeFullPath)) {
                    sprintf(szTemp, "%s<!-- Parent exe \"%s\" on same drive.-->", g_szMatchIndent, szPathWithoutDrive);
                } else {
                    sprintf(szTemp, "%s<!-- Parent exe \"%s\" on different drive.-->", g_szMatchIndent, szPathWithoutDrive);
                }

                if (bFindLine("<EXE", &unLine)) {
                    if (bFindLineFrom(">", unLine, &unLine)) {
                        InsertLine(unLine + 1, szTemp);
                    }
                }
            }
        } 
    }


    // check the drive letters to see which drive the match file is on
    // then calculate a relative path to the matching file
    if (bSameDrive(szMatchFile, g_szParentExeFullPath)) {

        szMatch = szGetRelativePath(g_szParentExeFullPath, szMatchFile);

    } else if (bSameDrive(szMatchFile, g_szExeFullPath)) {

        szMatch = szGetRelativePath(g_szExeFullPath, szMatchFile);

    } else {

        MessageBox(hDlg, "Match file is not on same drive as either EXE or Parent EXE. "
            "Can't generate relative path.", "Error", MB_ICONEXCLAMATION);
        goto err2;
    }

    // reconstruct the EXE if necessary
    if (!bFindLine("<EXE", &unLine)) {
        // insert it right after <APP> or at the beginning
        if (!bFindLine("<APP", &unLine)) {
            unLine = 0;
        } else {
            unLine += 1;
        }

        InsertExeLines(unLine);
    }

    // find the </EXE> line and insert if necessary
    if (!bFindLine("</EXE>", &unLine)) {
        if (!bFindLine("</APP>", &unLine)) {
            unLine = g_unEditLines + 1;
        }
        sprintf(szTemp, "%s</EXE>", g_szExeIndent);
        InsertLine(unLine, szTemp);
    }

    GetMatchInfo(szMatchFile, &MatchInfo);

    // now insert the line right before </EXE>
#ifdef _SPLIT_LINES
    sprintf(szTemp, "%s<MATCHING_FILE NAME=\"%s\"", 
        g_szMatchIndent, 
        szMatch
        );
    InsertLine(unLine++, szTemp);

    sprintf(szTemp, "%sSIZE=\"%u\"", 
        g_szMatchAttributeIndent, 
        MatchInfo.dwSize
        );
    InsertLine(unLine++, szTemp);

    sprintf(szTemp, "%sCHECKSUM=\"0x%8.8X\"", 
        g_szMatchAttributeIndent, 
        MatchInfo.dwChecksum
        );
    InsertLine(unLine++, szTemp);

    sprintf(szTemp, "%sTIME=\"%s\"", 
        g_szMatchAttributeIndent, 
        MatchInfo.szTime
        );
    InsertLine(unLine++, szTemp);

    sprintf(szTemp, "%s/>", 
        g_szMatchIndent
        );
    InsertLine(unLine++, szTemp);
#else
    if (MatchInfo.szTime[0] != 0) {
        sprintf(szTime, " TIME=\"%s\"", MatchInfo.szTime);
    } else {
        szTime[0] = 0;
    }

    if (MatchInfo.liBinFileVersion.QuadPart) {
        sprintf(szFileVer, " BIN_FILE_VERSION=\"%d.%d.%d.%d\"", 
            HIWORD(MatchInfo.liBinFileVersion.HighPart),
            LOWORD(MatchInfo.liBinFileVersion.HighPart),
            HIWORD(MatchInfo.liBinFileVersion.LowPart),
            LOWORD(MatchInfo.liBinFileVersion.LowPart));
    } else {
        szFileVer[0] = 0;
    }

    if (MatchInfo.liBinProdVersion.QuadPart) {
        sprintf(szProdVer, " BIN_PRODUCT_VERSION=\"%d.%d.%d.%d\"", 
            HIWORD(MatchInfo.liBinProdVersion.HighPart),
            LOWORD(MatchInfo.liBinProdVersion.HighPart),
            HIWORD(MatchInfo.liBinProdVersion.LowPart),
            LOWORD(MatchInfo.liBinProdVersion.LowPart));
    } else {
        szProdVer[0] = 0;
    }

    if (MatchInfo.szProductName[0]) {
        sprintf(szProdName, " PRODUCT_NAME=\"%s\"", MatchInfo.szProductName);
    } else {
        szProdName[0] = 0;
    }

    sprintf(szTemp, "%s<MATCHING_FILE NAME=\"%s\" SIZE=\"%u\" CHECKSUM=\"0x%8.8X\"%s%s%s%s/>", 
        g_szMatchIndent, 
        szMatch,
        MatchInfo.dwSize,
        MatchInfo.dwChecksum,
        szTime,
        szFileVer,
        szProdVer,
        szProdName
        );
    InsertLine(unLine, szTemp);
#endif


err2:
    // put them back into the dialog
    PackEditLines(hDlg);
err1:
    return;
}

void GetExeNames(HWND hDlg)
{
    OPENFILENAME ofn;
    char szFile[1000];
    char szFileTitle[260];
    HWND hBtn;
    char szTemp[MAX_LINE_LEN];

    szFile[0] = '\0';
    szFileTitle[0] = '\0';

    ZeroMemory(&ofn, sizeof(OPENFILENAME));
    ofn.lStructSize = sizeof(OPENFILENAME);
    ofn.hwndOwner = hDlg;
    ofn.lpstrFile = szFile;
    ofn.nMaxFile = sizeof(szFile);
    ofn.lpstrFilter = "All\0*.*\0Exe\0*.EXE\0";
    ofn.nFilterIndex = 1;
    ofn.lpstrFileTitle = szFileTitle;
    ofn.nMaxFileTitle = sizeof(szFileTitle);
    ofn.lpstrInitialDir = NULL;
    ofn.lpstrTitle = "Select Exe to Shim";
    ofn.Flags = OFN_PATHMUSTEXIST | OFN_FILEMUSTEXIST | OFN_NODEREFERENCELINKS;

    // get the main exe name 
    if (GetOpenFileName(&ofn) == FALSE) {
        return;
    }

    strcpy(g_szExeName, szFileTitle);
    strcpy(g_szExeFullPath, szFile);

    // the parent exe defaults to the same as the EXE
    strcpy(g_szParentExeName, szFileTitle);
    strcpy(g_szParentExeFullPath, szFile);
    g_bSelectedParentExe = FALSE;

    // construct our new dialog text
    InitEditLines();
    sprintf(szTemp, "%s<APP NAME=\"\" VENDOR=\"\">", g_szAppIndent); 
    InsertLine(0, szTemp);

    InsertExeLines(1);

    sprintf(szTemp, "%s</EXE>", g_szExeIndent);
    InsertLine(999, szTemp);

    sprintf(szTemp, "%s</APP>", g_szAppIndent); 
    InsertLine(999, szTemp);

    // stick it in the dialog box
    PackEditLines(hDlg);

    hBtn = GetDlgItem(hDlg, IDC_BTN_ADD_MATCH);
    EnableWindow(hBtn, TRUE);
    hBtn = GetDlgItem(hDlg, IDC_BTN_ADD_DLL);
    EnableWindow(hBtn, TRUE);
}

#define SECS_IN_DAY 86400
#define HUNDRED_NSECS_IN_SEC 10000000

void GetMatchInfo(char *szFile, PMATCH_INFO pMatch)
{
    HANDLE hFile;
    FILETIME ft;
    SYSTEMTIME st;

    ZeroMemory(pMatch, sizeof(MATCH_INFO));

    hFile = CreateFile(
        szFile,
        GENERIC_READ,
        FILE_SHARE_READ,
        NULL,
        OPEN_EXISTING,
        FILE_ATTRIBUTE_NORMAL,
        NULL);

    if (hFile != INVALID_HANDLE_VALUE ) {
        DWORD dwAttributes;

        pMatch->dwSize = GetFileSize(hFile, NULL);

        pMatch->dwChecksum = GetFileChecksum(hFile);

        pMatch->szTime[0] = 0;

#ifdef _GATHER_TIME
        // only get the time if the file is not read only, and the date is
        // not within 2 days of today
        dwAttributes = GetFileAttributes(szFile);
        if (dwAttributes != -1 && (dwAttributes & FILE_ATTRIBUTE_READONLY)) {
            SYSTEMTIME stMachine;
            FILETIME ftMachine;
            DWORD dwDayFile;
            DWORD dwDayMachine;
            LARGE_INTEGER liFile;
            LARGE_INTEGER liMachine;
            LARGE_INTEGER liDifference;

            GetFileTime(hFile, &ft, NULL, NULL);
            FileTimeToSystemTime(&ft, &st);

            GetSystemTime(&stMachine);
            SystemTimeToFileTime(&stMachine, &ftMachine);

            liFile.LowPart = ft.dwLowDateTime;
            liFile.HighPart = ft.dwHighDateTime;
            liMachine.LowPart = ftMachine.dwLowDateTime;
            liMachine.HighPart = ftMachine.dwHighDateTime;
            liDifference.QuadPart = liMachine.QuadPart - liFile.QuadPart;

            // this goofy math is because I can't specify more than a 32-bit
            // value as a constant in this compiler
            if ((liDifference.QuadPart / HUNDRED_NSECS_IN_SEC) > SECS_IN_DAY * 2) {
            
                sprintf(pMatch->szTime, "%2.2d/%2.2d/%4.4d %2.2d:%2.2d:%2.2d", 
                    st.wMonth,
                    st.wDay,
                    st.wYear,
                    st.wHour,
                    st.wMinute,
                    st.wSecond);
            }
        }
#endif

        CloseHandle(hFile);

        // now get resource info
        VERSION_DATA VersionData;

        if (bInitVersionData(szFile, &VersionData)) {
            char *szProductName = NULL;

            pMatch->liBinFileVersion.QuadPart = qwGetBinFileVer(&VersionData);
            pMatch->liBinProdVersion.QuadPart = qwGetBinProdVer(&VersionData);

#if 0
            szProductName = szGetVersionString(&VersionData, "ProductName");
            if (szProductName) {
                int nLen;

                nLen = sizeof(pMatch->szProductName) - 1;

                strncpy(pMatch->szProductName, szProductName, nLen);
                pMatch->szProductName[nLen] = 0;
            }
#endif

            vReleaseVersionData(&VersionData);
        }
    } else {
        MessageBox(NULL, "Can't open match file for READ. Matching info inaccurate.", 
            "Error", MB_ICONEXCLAMATION);
        pMatch->dwSize = 0;
        pMatch->dwChecksum = 0xDEADBEEF;
        pMatch->szTime[0] = 0;
    }
}


void InitEditLines(void)
{
    g_unEditLines = 0;
}

void UnpackEditLines(HWND hDlg)
{
    char *szTemp, *szBegin;

    GetDlgItemText(hDlg, IDC_EDIT1, g_szEditText, MAX_TEXT_BUF - 1);

    szBegin = g_szEditText;

    g_unEditLines = 0;
    if (!szBegin[0]) {
        return;
    }

    while (szTemp = strstr(szBegin, "\r\n")) {
        // temporarily terminate the string and copy
        *szTemp = '\0';
        strcpy(g_aszEditLines[g_unEditLines], szBegin);
        g_unEditLines++;

        // back to normal
        *szTemp = '\r';

        szBegin = szTemp + 2;
    }

    // copy in the final line, if any
    if (szBegin[0]) {
        strcpy(g_aszEditLines[g_unEditLines], szBegin);
        g_unEditLines++;
    }
}

void PackEditLines(HWND hDlg)
{
    UINT i;
    char *szTemp = g_szEditText;
    HWND hEdit = GetDlgItem(hDlg, IDC_EDIT1);

    for (i = 0; i < g_unEditLines; ++i) {
        int nLen = strlen(g_aszEditLines[i]);

        memcpy(szTemp, g_aszEditLines[i], nLen);
        szTemp += nLen;
        memcpy(szTemp, "\r\n", 2 * sizeof(char));
        szTemp += 2;
    }

    *szTemp = '\0';

    SetDlgItemText(hDlg, IDC_EDIT1, g_szEditText);

    SendMessage(hEdit, EM_SETSEL, 0, -1); // select everything

    SetFocus(hEdit);

}

void MySelectAll(HWND hDlg)
{
    HWND hEdit = GetDlgItem(hDlg, IDC_EDIT1);

    SendMessage(hEdit, EM_SETSEL, 0, -1); // select everything

    SetFocus(hEdit);
}

void DeleteLines(UINT unBegin, UINT unLen)
{
    UINT unEnd = unBegin + unLen;

    if (unBegin > g_unEditLines) {
        return;
    }
    if (unEnd > g_unEditLines) {
        unEnd = g_unEditLines;
    }

    while (unEnd < g_unEditLines) {
        strcpy(g_aszEditLines[unBegin++], g_aszEditLines[unEnd++]);
    }

    g_unEditLines -= unLen;
}

void InsertLine(UINT unLine, char *szLine)
{
    UINT unTemp;

    if (unLine > g_unEditLines) {
        unLine = g_unEditLines;
    }

    unTemp = g_unEditLines;

    while (unTemp != unLine) {
        strcpy(g_aszEditLines[unTemp], g_aszEditLines[unTemp - 1]);
        unTemp--;
    }

    strcpy(g_aszEditLines[unLine], szConvertSpecialChars(szLine));

    g_unEditLines++;
}

void InsertExeLines(UINT unLine)
{
    char szTemp[MAX_LINE_LEN];
    MATCH_INFO MatchInfo;
    char szTime[MAX_LINE_LEN];
    char szProdVer[MAX_LINE_LEN];
    char szFileVer[MAX_LINE_LEN];

    GetMatchInfo(g_szExeFullPath, &MatchInfo);

#ifdef _SPLIT_LINES
    sprintf(szTemp, "%s<EXE NAME=\"%s\"", 
        g_szExeIndent, 
        g_szExeName
        );
    InsertLine(unLine++, szTemp);

    sprintf(szTemp, "%sSIZE=\"%u\"", 
        g_szExeAttributeIndent, 
        MatchInfo.dwSize
        );
    InsertLine(unLine++, szTemp);

    sprintf(szTemp, "%sCHECKSUM=\"0x%8.8X\"", 
        g_szExeAttributeIndent, 
        MatchInfo.dwChecksum
        );
    InsertLine(unLine++, szTemp);

    if (MatchInfo.szTime[0] != 0) {
        sprintf(szTemp, "%sTIME=\"%s\"", 
            g_szExeAttributeIndent, 
            MatchInfo.szTime
            );
        InsertLine(unLine++, szTemp);
    }

    sprintf(szTemp, "%s>", 
        g_szExeIndent
        );
    InsertLine(unLine++, szTemp);
#else
    if (MatchInfo.szTime[0] != 0) {
        sprintf(szTime, " TIME=\"%s\"", MatchInfo.szTime);
    } else {
        szTime[0] = 0;
    }

    if (MatchInfo.liBinFileVersion.QuadPart) {
        sprintf(szFileVer, " BIN_FILE_VERSION=\"%d.%d.%d.%d\"", 
            HIWORD(MatchInfo.liBinFileVersion.HighPart),
            LOWORD(MatchInfo.liBinFileVersion.HighPart),
            HIWORD(MatchInfo.liBinFileVersion.LowPart),
            LOWORD(MatchInfo.liBinFileVersion.LowPart));
    } else {
        szFileVer[0] = 0;
    }

    if (MatchInfo.liBinProdVersion.QuadPart) {
        sprintf(szProdVer, " BIN_PRODUCT_VERSION=\"%d.%d.%d.%d\"", 
            HIWORD(MatchInfo.liBinProdVersion.HighPart),
            LOWORD(MatchInfo.liBinProdVersion.HighPart),
            HIWORD(MatchInfo.liBinProdVersion.LowPart),
            LOWORD(MatchInfo.liBinProdVersion.LowPart));
    } else {
        szProdVer[0] = 0;
    }

    sprintf(szTemp, "%s<EXE NAME=\"%s\" SIZE=\"%u\" CHECKSUM=\"0x%8.8X\"%s%s%s>", 
        g_szExeIndent, 
        g_szExeName,
        MatchInfo.dwSize,
        MatchInfo.dwChecksum,
        szTime,
        szFileVer,
        szProdVer
        );
    InsertLine(unLine, szTemp);
#endif
}

BOOL bFindLine(char *szSearch, UINT *punLine)
{
    UINT i;

    for (i = 0; i < g_unEditLines; ++i) {
        if (g_aszEditLines[i][0] && strstr(g_aszEditLines[i], szSearch)) {
            *punLine = i;
            return TRUE;
        }
    }

    return FALSE;
}

BOOL bFindLineFrom(char *szSearch, UINT unStart, UINT *punLine)
{
    UINT i;

    for (i = unStart; i < g_unEditLines; ++i) {
        if (g_aszEditLines[i][0] && strstr(g_aszEditLines[i], szSearch)) {
            *punLine = i;
            return TRUE;
        }
    }

    return FALSE;
}

char *szGetRelativePath(char *pExeFile, char *pMatchFile)
{
    int  iLenp = 0;
    int  iLenq = 0;
    //int  index = 0;
    BOOL bCommonBegin = FALSE; // do the two paths have a common beginning
    char *p    = NULL;
    char *q    = NULL;

    // BUGBUG -- if you call this function twice in a row
    // without copying the result, the second call will overwrite
    // the first -- consider changing to a passed-in string
    //
    static char result[MAX_PATH] = { '\0' };

    char *resultIdx = result;

    p = strchr(pExeFile, '\\');
    q = strchr(pMatchFile, '\\');

    while( p && q )
    {
        iLenp = p - pExeFile;
        iLenq = q - pMatchFile;

        if ( iLenp != iLenq )
            break;

        if ( !(_strnicmp(pExeFile, pMatchFile, iLenp) == 0) )
            break;

        bCommonBegin = TRUE;
        pExeFile = p + 1;
        pMatchFile = q + 1;

        p = strchr(pExeFile, '\\');
        q = strchr(pMatchFile, '\\');
    }

    if (bCommonBegin)
    {
        while( p )
        {
            strcpy(resultIdx, "..\\");
            resultIdx = resultIdx + 3;
            pExeFile  = p + 1;
            p = strchr(pExeFile, '\\');
        }

        strcpy(resultIdx, pMatchFile);

        return result;
    }

    // the two paths don't have a common beginning,
    // and there is no relative path

    return NULL;
}

BOOL bSameDrive(char *szPath1, char *szPath2)
{
    char szDrive1[256];
    char szDrive2[256];
    char *szTemp1, *szTemp2;

    BOOL bReturn = FALSE;

    assert(szPath1 && szPath1[0] && szPath2 && szPath2[0]);

    if (szPath1[1] != szPath2[1]) {
        // if the 2nd characters don't match, then one
        // is a DOS style path and the other is UNC,
        // and we're definitely not on the same drive
        goto out;
    }

    if (szPath1[1] == ':') {
        // these are both DOS-style paths

        if (szPath1[0] == szPath2[0]) {
            // if the first characters match, it's the same drive
            bReturn = TRUE;
        }
        goto out;
    }

    // now we're sure we have two UNC-style paths

    // skip past the "\\"
    szTemp1 = szPath1 + 2; 
    szTemp2 = szPath2 + 2;

    // skip to the next '\'
    szTemp1 = strchr(szTemp1, '\\');
    szTemp2 = strchr(szTemp2, '\\');

    // if we didn't find another backslash, bail
    if (!szTemp1 || !szTemp2) {
        goto out;
    }

    // skip to the next '\' again
    szTemp1++;
    szTemp2++;
    szTemp1 = strchr(szTemp1, '\\');
    szTemp2 = strchr(szTemp2, '\\');

    // if we didn't find another backslash, bail
    if (!szTemp1 || !szTemp2) {
        goto out;
    }

    // are they different sizes?
    if (szTemp1 - szPath1 != szTemp2 - szPath2) {
        goto out;
    }

    // they're the same size, are they the same string?
    if (memcmp(szPath1, szPath2, szTemp1-szPath1) == 0) {
        bReturn = TRUE;
    }

out:
    return bReturn;
}

#define CHECKSUM_SIZE 4096
#define CHECKSUM_OFFSET 512
#define CHECKSUM_BUFFER (CHECKSUM_SIZE+CHECKSUM_OFFSET)

DWORD GetFileChecksum(HANDLE handle)
{
    PBYTE pBuffer;
    DWORD dwCheckSum;
    DWORD dwBytesRead;
    DWORD dwReadSize;

    dwCheckSum = 0;

    dwReadSize = GetFileSize(handle, 
                         NULL);

    if ( dwReadSize > CHECKSUM_BUFFER ) {
        dwReadSize = CHECKSUM_BUFFER;
    }

    pBuffer = new BYTE[dwReadSize];
    if ( !pBuffer ) {
        dwCheckSum = 0xDEADBEEF;
        goto err1;
    }

    SetFilePointer(handle, 
                   0L, 
                   NULL, 
                   FILE_BEGIN);


    ZeroMemory(pBuffer, dwReadSize);

    //
    // We can get away with this since if the read fails then the check sum will also fail.
    //
    if ( !ReadFile(handle, (PBYTE)pBuffer, dwReadSize, &dwBytesRead, NULL) ) {
        dwCheckSum = 0xDEADBEEF;
        goto err2;
    }

    {
        INT    i,size     = CHECKSUM_SIZE;
        DWORD  startAddr  = CHECKSUM_OFFSET;
        PBYTE  pTemp = pBuffer;

        if (dwBytesRead < (ULONG)size) {
            //
            // File size is less than 4096. We set the start address to 0 and set the size for the checksum
            // to the actual file size.
            //
            startAddr = 0;
            size = dwBytesRead;
        } else if (startAddr + size > dwBytesRead) {
            //
            // File size is too small. We set the start address so that size of checksum can be 4096 bytes
            //
            startAddr = dwBytesRead - size;
        }

        if (size < 4) {
            //
            // we need at least 4 bytes to be able to do something here.
            //
            dwCheckSum = 0;
            goto err2;
        }

        // start at the offset
        pTemp = pTemp + startAddr;

        // walk through adding in DWORDs and rotating the result to guard against
        // transposition
        for (i = 0; i < (size - 3); i += 4) {
            dwCheckSum += *((PDWORD) (pTemp + i));
            dwCheckSum = _rotr (dwCheckSum, 1);
        }
    }

err2:
    delete [] pBuffer;

err1:
    return dwCheckSum;
}

void vWriteSysTest(void)
{
    char szHeader[] = "<?xml version=\"1.0\"?>\r\n<DATABASE>\r\n";
    char szTrailer[] = "\r\n</DATABASE>\r\n";
    char szCommand[_MAX_PATH * 3];
    char szSDBPath[_MAX_PATH];
    char szXMLPath[_MAX_PATH];
    char szLOGPath[_MAX_PATH];
    DWORD dwBytesWritten = 0;
    BOOL bRet;
    PROCESS_INFORMATION ProcInfo;

    STARTUPINFO si;

    GetDlgItemText(g_hMainDlg, IDC_EDIT1, g_szEditText, MAX_TEXT_BUF - 1);

    ExpandEnvironmentStrings("%windir%\\AppPatch\\systest.xml", szXMLPath, _MAX_PATH);
    ExpandEnvironmentStrings("%windir%\\AppPatch\\systest.sdb", szSDBPath, _MAX_PATH);
    ExpandEnvironmentStrings("%windir%\\AppPatch\\systest.log", szLOGPath, _MAX_PATH);

    HANDLE hFile = CreateFile(
        szXMLPath, 
        GENERIC_WRITE,
        0,
        NULL,
        CREATE_ALWAYS,
        FILE_ATTRIBUTE_NORMAL,
        NULL);

    if (hFile == INVALID_HANDLE_VALUE) {
        goto out;
    }

    if (!WriteFile(hFile, szHeader, sizeof(szHeader) - 1, &dwBytesWritten, NULL)) {
        goto out;
    }

    if (!WriteFile(hFile, g_szEditText, strlen(g_szEditText), &dwBytesWritten, NULL)) {
        goto out;
    }

    if (!WriteFile(hFile, szTrailer, sizeof(szTrailer) - 1, &dwBytesWritten, NULL)) {
        goto out;
    }

    CloseHandle(hFile);
    hFile = INVALID_HANDLE_VALUE;

    // Set up the start up info struct.
    ZeroMemory(&si,sizeof(STARTUPINFO));
    si.cb = sizeof(STARTUPINFO);

    ZeroMemory(&ProcInfo, sizeof(PROCESS_INFORMATION));

    sprintf(szCommand, "cmd /c shimdbc fix \"%s\" \"%s\" > \"%s\"", szXMLPath, szSDBPath, szLOGPath);
    bRet = CreateProcess(NULL,
        szCommand,
        NULL,
        NULL,
        FALSE,
        CREATE_NO_WINDOW,
        NULL,
        NULL,
        &si,
        &ProcInfo);
    if (!bRet) {
        MessageBox(g_hMainDlg, "Couldn't launch shimdbc to generate systest.sdb. Check systest.log for more.", "Error", MB_ICONEXCLAMATION);
        goto out;
    }

    if (WaitForSingleObject(ProcInfo.hProcess, 10000) == WAIT_OBJECT_0) {

        // wait a bit to ensure everything is all done, and the .SDB file is done closing.
        Sleep(100);

        // Set up the start up info struct.
        ZeroMemory(&si,sizeof(STARTUPINFO));
        si.cb = sizeof(STARTUPINFO);

        ZeroMemory(&ProcInfo, sizeof(PROCESS_INFORMATION));

        // pop open notepad to see the log
        sprintf(szCommand, "notepad \"%s\"", szLOGPath);
        bRet = CreateProcess(NULL,
            szCommand,
            NULL,
            NULL,
            FALSE,
            0,
            NULL,
            NULL,
            &si,
            &ProcInfo);
    }


out:
    if (hFile != INVALID_HANDLE_VALUE) {
        CloseHandle(hFile);
    }
}
    
void vEnumerateSystemDlls(HWND hDlg)
{
    PDB pdb = NULL;
    WCHAR wszPath[_MAX_PATH];
    HWND hList;
    TAGID tiDatabase;
    TAGID tiLibrary;
    TAGID tiDll;

    hList = GetDlgItem(hDlg, IDC_DLL_LIST);
    if (!hList) {
        goto out;
    }

    g_dwSystemDlls = 0;

    ExpandEnvironmentStringsW(L"%windir%\\AppPatch\\sysmain.sdb", wszPath, _MAX_PATH);

    pdb = SdbOpenDatabase(wszPath, DOS_PATH);
    if (!pdb) {
        goto out;
    }

    tiDatabase = SdbFindFirstTag(pdb, TAGID_ROOT, TAG_DATABASE);
    if (!tiDatabase) {
        goto out;
    }

    tiLibrary = SdbFindFirstTag(pdb, tiDatabase, TAG_LIBRARY);
    if (!tiLibrary) {
        goto out;
    }

    tiDll = SdbFindFirstTag(pdb, tiLibrary, TAG_SHIM);
    while (tiDll) {
        TAGID tiName;
        WCHAR wszName[_MAX_PATH];

        wszName[0] = 0;
        tiName = SdbFindFirstTag(pdb, tiDll, TAG_NAME);
        if (tiName) {
            
            SdbReadStringTag(pdb, tiName, wszName, _MAX_PATH * sizeof(WCHAR));
        }
        if (wszName[0]) {
            char szName[_MAX_PATH];

            sprintf(szName, "%S", wszName);
            SendMessage(hList, LB_ADDSTRING, 0, (LPARAM)szName);
            g_dwSystemDlls++;
        }

        tiDll = SdbFindNextTag(pdb, tiLibrary, tiDll);
    }

out:
    if (pdb) {
        SdbCloseDatabase(pdb);
    }
}

void vAddSelectedDlls(HWND hDlg)
{
    HWND hList;
    DWORD *pdwItems = new DWORD[g_dwSystemDlls];
    DWORD dwItems = 0;
    DWORD i;
    UINT unLine;
    char szTemp[MAX_LINE_LEN];

    if (!pdwItems) {
        goto out;
    }

    hList = GetDlgItem(hDlg, IDC_DLL_LIST);
    if (!hList) {
        goto out;
    }

    UnpackEditLines(g_hMainDlg);

    // find the </EXE> line and insert if necessary
    if (!bFindLine("</EXE>", &unLine)) {
        if (!bFindLine("</APP>", &unLine)) {
            unLine = g_unEditLines + 1;
        }
        sprintf(szTemp, "%s</EXE>", g_szExeIndent);
        InsertLine(unLine, szTemp);
    }

    
    dwItems = SendMessage(hList, LB_GETSELITEMS, g_dwSystemDlls, (LPARAM)pdwItems);
    for (i = 0; i < dwItems; ++i) {
        char szName[_MAX_PATH];

        szName[0] = 0;
        SendMessage(hList, LB_GETTEXT, pdwItems[i], (LPARAM)szName);

        if (szName[0]) {
            sprintf(szTemp, "%s<DLL NAME=\"%s\"/>", g_szMatchIndent, szName);
            InsertLine(unLine, szTemp);
        }
    }

    PackEditLines(g_hMainDlg);

out:
    return;
}

/*
    Does an in-place expansion of special characters for XML into the equivalents.

    Specifically, converts '&' to '&amp'.

*/

char *szConvertSpecialChars(char *szString)
{
    char *szPtr;
    char *szEnd;

    assert(szString);

    szPtr = szString;
    szEnd = szString;
    while (*szEnd) {
        szEnd++;
    }

    szEnd++; // now points one past end

    //
    // now go looking for ampersands
    //
    while (*szPtr) {
        if (*szPtr == '&') {
            memmove(szPtr + 3, szPtr, szEnd-szPtr);
            memcpy(szPtr, "&amp", 4);
            szPtr += 3;
            szEnd += 3;
        }
        szPtr++;
    }

    return szString;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\appcompat\windowsupdate\installer\enumdir.h ===
/*++

  Copyright (c) 2001 Microsoft Corporation

  Module Name:

    Enumdir.h

  Abstract:

    Class definition for the directory
    enumeration class.

  Notes:

    Unicode only right now.

  History:

    02/21/2001  rparsons    Created

--*/

#include <windows.h>
#include <windowsx.h>
#include <stdio.h>
#include <stdlib.h>
#include <errno.h>
#include <ctype.h>
#include <string.h>
#include <io.h>
#include <fcntl.h>
#include <malloc.h>
#include <sys\types.h>
#include <sys\stat.h>

//
// Determine if an argument is present by testing a value of NULL
//

#define ARGUMENT_IS_PRESENT( ArgumentPointer )    (\
    (LPSTR)(ArgumentPointer) != (LPSTR)(NULL) )

//
// Useful rounding macros that the rounding amount is always a
// power of two.
//

#define ROUND_DOWN( Size, Amount ) ((DWORD)(Size) & ~((Amount) - 1))
#define ROUND_UP( Size, Amount ) (((DWORD)(Size) + ((Amount) - 1)) & ~((Amount) - 1))

//
// Directory enumeration and file notification definitions.
//

typedef
BOOL (*PDIRECTORY_ENUMERATE_ROUTINE)(
    LPCWSTR lpwPath,
    PWIN32_FIND_DATA pFindFileData,
    PVOID pEnumerateParameter
    );

//
// Data structures private to the EnumerateDirectoryTree function.
//

typedef struct _ENUMERATE_DIRECTORY_STACK {
    LPWSTR PathEnd;
    HANDLE FindHandle;
} ENUMERATE_DIRECTORY_STACK, *PENUMERATE_DIRECTORY_STACK;

#define MAX_DEPTH 256

typedef struct _ENUMERATE_DIRECTORY_STATE {
    DWORD Depth;
    ENUMERATE_DIRECTORY_STACK Stack[ MAX_DEPTH ];
    WCHAR Path[ MAX_PATH ];
} ENUMERATE_DIRECTORY_STATE, *PENUMERATE_DIRECTORY_STATE;

//
// Virtual Buffer data structure
//

typedef struct _VIRTUAL_BUFFER {
    LPVOID Base;
    ULONG PageSize;
    LPVOID CommitLimit;
    LPVOID ReserveLimit;
} VIRTUAL_BUFFER, *PVIRTUAL_BUFFER;

class CEnumDir {


public:

    BOOL EnumerateDirectoryTree(IN LPCWSTR DirectoryPath,
                                IN PDIRECTORY_ENUMERATE_ROUTINE EnumerateRoutine,
                                IN BOOL fEnumSubDirs,
                                IN PVOID EnumerateParameter);

private:

    BOOL CreateVirtualBuffer(OUT PVIRTUAL_BUFFER Buffer,
                             IN DWORD CommitSize,
                             IN DWORD ReserveSize OPTIONAL);

    BOOL ExtendVirtualBuffer(IN PVIRTUAL_BUFFER Buffer,
                             IN LPVOID Address);

    BOOL TrimVirtualBuffer(IN PVIRTUAL_BUFFER Buffer);

    BOOL FreeVirtualBuffer(IN PVIRTUAL_BUFFER Buffer);

    int VirtualBufferExceptionFilter(IN DWORD ExceptionCode,
                                     IN PEXCEPTION_POINTERS ExceptionInfo,
                                     IN OUT PVIRTUAL_BUFFER Buffer);
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\appcompat\windowsupdate\installer\enumdir.cpp ===
/*++

  Copyright (c) 2001 Microsoft Corporation

  Module Name:

    Enumdir.cpp

  Abstract:

    Public functions exposed by the directory
    enumeration class.

  Notes:

    Unicode only right now.

  History:

    02/21/2001  rparsons    Created

--*/

#include "enumdir.h"

/*++

Routine Description:

    This function walks a directory tree, depth first, calling the
    passed enumeration routine for each directory and file found
    in the tree.  The enumeration routine is passed the full path
    of the file, the directory information associated with the file
    and an enumeration parameter that is uninterpreted by this
    function.

Arguments:

    DirectoryPath - Absolute or relative path to the directory that
        will is the root of the tree to enumerate.

    EnumerateRoutine - Pointer to an enumeration routine to call
        for each file and directory found.
        
    fEnumSubDirs    -   Indicates if we should enumerate
                        subdirectories.

    EnumerateParameter - Uninterpreted 32-bit value that is passed
        to the EnumerationRoutine each time it is called.

Return Value:

    TRUE if operation was successful.  Otherwise returns FALSE and
    extended error information is available from GetLastError()

--*/
BOOL
CEnumDir::EnumerateDirectoryTree(
    IN LPCWSTR DirectoryPath,
    IN PDIRECTORY_ENUMERATE_ROUTINE EnumerateRoutine,
    IN BOOL fEnumSubDirs,
    IN PVOID EnumerateParameter
    )
{
    BOOL                        fResult;
    VIRTUAL_BUFFER              Buffer;
    PENUMERATE_DIRECTORY_STATE  State;
    PENUMERATE_DIRECTORY_STACK  Stack;
    WIN32_FIND_DATA             FindFileData;

    //
    // Create a virtual buffer with an initial committed size of
    // our directory state buffer, and a maximum reserved size of
    // the longest possible full path based on the maximum depth
    // we handle and the maximum length of each path component.
    //
    if (!this->CreateVirtualBuffer(&Buffer,
                                   sizeof(ENUMERATE_DIRECTORY_STATE),
                                   sizeof(ENUMERATE_DIRECTORY_STATE) +
                                   MAX_DEPTH * MAX_PATH)) {
        return FALSE;
    }

    //
    // This buffer will be used to maintain a stack of directory
    // search handles, as well as accumulate the full path string
    // as we descend the directory tree.
    //
    State = (PENUMERATE_DIRECTORY_STATE)Buffer.Base;
    State->Depth = 0;
    Stack = &State->Stack[0];

    //
    // Enter a try ... finally block so we can insure that we clean
    // up after ourselves on exit.
    //
    __try {
        
        //
        // First translate the passed in DirectoryPath into a fully
        // qualified path.  This path will be the initial value in
        // our path buffer.  The initial allocation of the path buffer
        // is big enough for this initial request, so does not need
        // to be guarded by a try ... except clause.
        //
        if (GetFullPathName(DirectoryPath, MAX_PATH, State->Path, &Stack->PathEnd)) {
            
            //
            // Now enter a try ... except block that will be used to
            // manage the commitment of space in the path buffer as
            // we append subdirectory names and file names to it.
            // Using the virtual buffer allows us to handle full
            // path names up to 16KB in length, with an initial
            // allocation of 4KB.
            //
            __try {
                
                //
                // Walk the directory tree.  The outer loop is executed
                // once for each directory in the tree.
                //
                while (TRUE) {

startDirectorySearch:
                    
                    //
                    // Find the end of the current path, and make sure
                    // there is a trailing path separator.
                    //
                    Stack->PathEnd = wcschr( State->Path, '\0' );
                    if (Stack->PathEnd > State->Path && Stack->PathEnd[ -1 ] != '\\') {
                        *(Stack->PathEnd)++ = '\\';
                        }

                    //
                    // Now append the wild card specification that will
                    // let us enumerate all the entries in this directory.
                    // Call FindFirstFile to find the first entry in the
                    // directory.
                    //
                    wcscpy( Stack->PathEnd, L"*.*" );
                    Stack->FindHandle = FindFirstFile( State->Path,
                                                       &FindFileData
                                                     );
                    if (Stack->FindHandle != INVALID_HANDLE_VALUE) {
                        
                        //
                        // Entry found.  Now loop through the entire
                        // directory processing each entry found,
                        // including the first one.
                        //
                        do {
                            
                            //
                            // Ignore bogus pseudo-directories that are
                            // returned by some file systems (e.g. FAT).
                            //
                            if (FindFileData.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY &&
                                (!wcscmp(FindFileData.cFileName, L".")  ||
                                 !wcscmp(FindFileData.cFileName, L"..") ||
                                 !wcscmp(FindFileData.cFileName, L"System Volume Information" ) ||
                                 !wcscmp(FindFileData.cFileName,  L"Recycler"))
                               )
                                {
                                continue;
                                }

                            //
                            // Copy the file name portion from the current
                            // directory entry to the last component in the
                            // path buffer.
                            //
                            wcscpy( Stack->PathEnd, FindFileData.cFileName);

                            //
                            // Call the supplied enumeration routine with the
                            // full path we have built up in the path buffer,
                            // the directory information for this directory
                            // entry and the supplied enumeration parameter.
                            //
                            (*EnumerateRoutine)(State->Path, &FindFileData, EnumerateParameter);

                            //
                            // If this is entry is a subdirectory, then it is
                            // time to recurse.  Do this by incrementing the
                            // stack pointer and depth and jumping to the top
                            // of the outer loop to process current contents
                            // of the path buffer as a fully qualified name of
                            // a directory.
                            //
                            if (FindFileData.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY && fEnumSubDirs) {
                                Stack++;
                                State->Depth++;
                                goto startDirectorySearch;
restartDirectorySearch:         ;
                                }

                            //
                            // Here to find the next entry in the current directory.
                            //
                            }

                        while (FindNextFile( Stack->FindHandle, &FindFileData));

                        //
                        // No more entries in the current directory, so close
                        // the search handle and fall into the code that will
                        // pop our stack of directory seacrh handles.
                        //

                        FindClose(Stack->FindHandle);
                        }

                    //
                    // Here when done with a directory.  See if we are pushed
                    // inside another directory.  If not, then we are done
                    // enumerating the whole tree, so break out of the loop.
                    //
                    if (!State->Depth) {
                        fResult = TRUE;
                        break;
                        }

                    //
                    // We were pushed within another directory search,
                    // so pop the stack to restore its search handle
                    // and path buffer position and resume the search
                    // within that directory.
                    //
                    State->Depth--;
                    --Stack;
                    goto restartDirectorySearch;
                    }
                }

            //
            // Any of the code that appends to the path buffer within
            // the above try ... except clause can cause an access
            // violation if the path buffer becomes longer than its
            // current committed size.  This exception filter
            // will dynamically commit additional pages as needed
            // and resume execution.
            //
            _except( this->VirtualBufferExceptionFilter(GetExceptionCode(),
                                                  GetExceptionInformation(),
                                                  &Buffer)) {
                
                //
                // We will get here if the exception filter was unable to
                // commit the memory.
                //
                fResult = FALSE;
                }
            
            } else {
            
            //
            // Initial GetFullPathName failed, so return a failure.
            //
            fResult = FALSE;
            }
        }
    
        __finally {
        
        //
        // Here on our way out of the outer try ... finally block.
        // Make sure all our search handles have been closed and then
        // free the virtual buffer.  The only way this code is not
        // executed is if code within the try ... finally block
        // called ExitThread or ExitProcess, or an external thread
        // or process terminated this thread or process.
        //
        // In the case of process death, this is not a problem, because
        // process terminate closes all open handles attached to the process
        // and frees all private virtual memory that is part of the address
        // space of the process.
        //
        // In the case ot thread death, the code below is not executed if
        // the thread terminates via ExitThread in the context of the
        // try .. finally or if an external thread, either in this process
        // or another process called TerminateThread on this thread.
        //
        while (State->Depth--) {
            --Stack;
            FindClose(Stack->FindHandle);
            }

        this->FreeVirtualBuffer(&Buffer);
    }

    return fResult;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\appcompat\windowsupdate\installer\enumfn.cpp ===
/*++

  Copyright (c) 2001 Microsoft Corporation

  Module Name:

    Enumfn.cpp

  Abstract:

    Private functions used by the directory
    enumeration class.

  Notes:

    Unicode only right now.    

  History:

    02/22/2001  rparsons    Created

--*/

#include "enumdir.h"

/*++

Routine Description:

    This function is called to create a virtual buffer.  A virtual
    buffer is a contiguous range of virtual memory, where some initial
    prefix portion of the memory is committed and the remainder is only
    reserved virtual address space.  A routine is provided to extend the
    size of the committed region incrementally or to trim the size of
    the committed region back to some specified amount.

Arguments:

    Buffer - Pointer to the virtual buffer control structure that is
        filled in by this function.

    CommitSize - Size of the initial committed portion of the buffer.
        May be zero.

    ReserveSize - Amount of virtual address space to reserve for the
        buffer.  May be zero, in which case amount reserved is the
        committed size plus one, rounded up to the next 64KB boundary.

Return Value:

    TRUE if operation was successful.  Otherwise returns FALSE and
    extended error information is available from GetLastError()

--*/
BOOL
CEnumDir::CreateVirtualBuffer(
    OUT PVIRTUAL_BUFFER Buffer,
    IN DWORD CommitSize,
    IN DWORD ReserveSize OPTIONAL
    )
{
    SYSTEM_INFO SystemInformation;

    //
    // Query the page size from the system for rounding
    // our memory allocations.
    // 
    GetSystemInfo(&SystemInformation);
    Buffer->PageSize = SystemInformation.dwPageSize;

    //
    // If the reserve size was not specified, default it by
    // rounding up the initial committed size to a 64KB
    // boundary.  This is because the Win32 Virtual Memory
    // API calls always allocate virtual address space on
    // 64KB boundaries, so we might well have it available
    // for commitment.
    //
    if (!ARGUMENT_IS_PRESENT(ReserveSize)) {
        ReserveSize = ROUND_UP(CommitSize + 1, 0x10000);
    }

    //
    // Attempt to reserve the address space.
    //
    Buffer->Base = VirtualAlloc(NULL,
                                ReserveSize,
                                MEM_RESERVE,
                                PAGE_READWRITE);
    
    if (Buffer->Base == NULL) {
        //
        // Unable to reserve address space, return failure.
        //
        return FALSE;
    }

    //
    // Attempt to commit some initial portion of the reserved region.
    //
    //
    CommitSize = ROUND_UP(CommitSize, Buffer->PageSize);
    
    if (CommitSize == 0 ||
        VirtualAlloc(Buffer->Base,
                     CommitSize,
                     MEM_COMMIT,
                     PAGE_READWRITE) != NULL) {
        //
        // Either the size of the committed region was zero or the
        // commitment succeeded.  In either case calculate the
        // address of the first byte after the committed region
        // and the address of the first byte after the reserved
        // region and return successs.
        //
        Buffer->CommitLimit = (LPVOID)
            ((char *)Buffer->Base + CommitSize);

        Buffer->ReserveLimit = (LPVOID)
            ((char *)Buffer->Base + ReserveSize);

        return TRUE;
    }

    //
    // If unable to commit the memory, release the virtual address
    // range allocated above and return failure.
    //
    VirtualFree(Buffer->Base, 0, MEM_RELEASE);

    return FALSE;
}

/*++

Routine Description:

    This function is called to extend the committed portion of a virtual
    buffer.

Arguments:

    Buffer - Pointer to the virtual buffer control structure.

    Address - Byte at this address is committed, along with all memory
        from the beginning of the buffer to this address.  If the
        address is already within the committed portion of the virtual
        buffer, then this routine does nothing.  If outside the reserved
        portion of the virtual buffer, then this routine returns an
        error.

        Otherwise enough pages are committed so that the memory from the
        base of the buffer to the passed address is a contiguous region
        of committed memory.


Return Value:

    TRUE if operation was successful.  Otherwise returns FALSE and
    extended error information is available from GetLastError()

--*/
BOOL
CEnumDir::ExtendVirtualBuffer(
    IN PVIRTUAL_BUFFER Buffer,
    IN LPVOID Address
    )
{
    DWORD NewCommitSize;
    LPVOID NewCommitLimit;

    //
    // See if address is within the buffer.
    //
    if (Address >= Buffer->Base && Address < Buffer->ReserveLimit) {
        
        //
        // See if the address is within the committed portion of
        // the buffer.  If so return success immediately.
        // 
        if (Address < Buffer->CommitLimit) {
            return TRUE;
        }

        //
        // Address is within the reserved portion.  Determine how many
        // bytes are between the address and the end of the committed
        // portion of the buffer.  Round this size to a multiple of
        // the page size and this is the amount we will attempt to
        // commit.
        //
        NewCommitSize =
            ((DWORD)ROUND_UP((DWORD)Address + 1, Buffer->PageSize) -
             (DWORD)Buffer->CommitLimit);

        //
        // Attempt to commit the memory.
        //
        NewCommitLimit = VirtualAlloc(Buffer->CommitLimit,
                                      NewCommitSize,
                                      MEM_COMMIT,
                                      PAGE_READWRITE);
        if (NewCommitLimit != NULL) {
            
            //
            // Successful, so update the upper limit of the committed
            // region of the buffer and return success.
            //
            Buffer->CommitLimit = (LPVOID)
                ((DWORD)NewCommitLimit + NewCommitSize);

            return TRUE;
            }
        }

    //
    // Address is outside of the buffer, return failure.
    //
    return FALSE;
}

/*++

Routine Description:

    This function is called to decommit any memory that has been
    committed for this virtual buffer.

Arguments:

    Buffer - Pointer to the virtual buffer control structure.

Return Value:

    TRUE if operation was successful.  Otherwise returns FALSE and
    extended error information is available from GetLastError()

--*/
BOOL
CEnumDir::TrimVirtualBuffer(
    IN PVIRTUAL_BUFFER Buffer
    )
{
    Buffer->CommitLimit = Buffer->Base;
    return VirtualFree(Buffer->Base, 0, MEM_DECOMMIT);
}

/*++

Routine Description:

    This function is called to free all the memory that is associated
    with this virtual buffer.

Arguments:

    Buffer - Pointer to the virtual buffer control structure.

Return Value:

    TRUE if operation was successful.  Otherwise returns FALSE and
    extended error information is available from GetLastError()

--*/
BOOL
CEnumDir::FreeVirtualBuffer(
    IN PVIRTUAL_BUFFER Buffer
    )
{
    //
    // Decommit and release all virtual memory associated with
    // this virtual buffer.
    //

    return VirtualFree(Buffer->Base, 0, MEM_RELEASE);
}

/*++

Routine Description:

    This function is an exception filter that handles exceptions that
    referenced uncommitted but reserved memory contained in the passed
    virtual buffer.  It this filter routine is able to commit the
    additional pages needed to allow the memory reference to succeed,
    then it will re-execute the faulting instruction.  If it is unable
    to commit the pages, it will execute the callers exception handler.

    If the exception is not an access violation or is an access
    violation but does not reference memory contained in the reserved
    portion of the virtual buffer, then this filter passes the exception
    on up the exception chain.

Arguments:

    ExceptionCode - Reason for the exception.

    ExceptionInfo - Information about the exception and the context
        that it occurred in.

    Buffer - Points to a virtual buffer control structure that defines
        the reserved memory region that is to be committed whenever an
        attempt is made to access it.

Return Value:

    Exception disposition code that tells the exception dispatcher what
    to do with this exception.  One of three values is returned:

        EXCEPTION_EXECUTE_HANDLER - execute the exception handler
            associated with the exception clause that called this filter
            procedure.

        EXCEPTION_CONTINUE_SEARCH - Continue searching for an exception
            handler to handle this exception.

        EXCEPTION_CONTINUE_EXECUTION - Dismiss this exception and return
            control to the instruction that caused the exception.

--*/
int
CEnumDir::VirtualBufferExceptionFilter(
    IN DWORD ExceptionCode,
    IN PEXCEPTION_POINTERS ExceptionInfo,
    IN OUT PVIRTUAL_BUFFER Buffer
    )
{
    LPVOID FaultingAddress;

    //
    // If this is an access violation touching memory within
    // our reserved buffer, but outside of the committed portion
    // of the buffer, then we are going to take this exception.
    //
    if (ExceptionCode == STATUS_ACCESS_VIOLATION) {
        
        //
        // Get the virtual address that caused the access violation
        // from the exception record.  Determine if the address
        // references memory within the reserved but uncommitted
        // portion of the virtual buffer.
        //
        FaultingAddress = (LPVOID)ExceptionInfo->ExceptionRecord->ExceptionInformation[ 1 ];
        if (FaultingAddress >= Buffer->CommitLimit &&
            FaultingAddress <= Buffer->ReserveLimit
           ) {
            
            //
            // This is our exception.  Try to extend the buffer
            // to including the faulting address.
            //
            if (ExtendVirtualBuffer(Buffer, FaultingAddress)) {
                
                //
                // Buffer successfully extended, so re-execute the
                // faulting instruction.
                //
                return EXCEPTION_CONTINUE_EXECUTION;
            
            } else {
                
                //
                // Unable to extend the buffer.  Stop searching
                // for exception handlers and execute the caller's
                // handler.
                //
                return EXCEPTION_EXECUTE_HANDLER;
            }
        }
    }

    //
    // Not an exception we care about, so pass it up the chain.
    //
    return EXCEPTION_CONTINUE_SEARCH;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\appcompat\windowsupdate\installer\eventlog.cpp ===
/*++

  Copyright (c) 2001 Microsoft Corporation

  Module Name:

    Eventlog.cpp

  Abstract:

    Implementation of the event log API
    wrapper class.

  Notes:

    Unicode only.   
    
  History:

    03/02/2001      rparsons    Created

--*/

#include "eventlog.h"

/*++

  Routine Description:

    Adds the specified event source to the registry

  Arguments:

    lpwSourceFile   -   The path & name of the file that
                        contains the event log strings
    lpwSourceName   -   The name of the event log source
    dwLogType       -   The log that the source should be
                        added to

  Return Value:

    TRUE if the source was added successfully, FALSE otherwise

--*/
BOOL 
CEventLog::CreateEventSource(
    IN LPCWSTR lpwSourceFile,
    IN LPCWSTR lpwSourceName,
    IN DWORD   dwLogType
    )
{
    HKEY    hLogKey = NULL;
    DWORD   dwTypes = 7L;
    DWORD   cCount = 0L;
    BOOL    fResult = FALSE;
    WCHAR   wszRegPath[MAX_PATH] = L"";

    __try {

        //
        // Determine the log type - application, system, 
        // or security - and build the path in the registry
        //
        switch (dwLogType) {
        
        case dwApplication:

            wsprintf(wszRegPath, L"%s\\%s", APP_LOG_REG_PATH, lpwSourceName);

            break;

        case dwSystem:

            wsprintf(wszRegPath, L"%s\\%s", SYS_LOG_REG_PATH, lpwSourceName);

            break;

        case dwSecurity:

            wsprintf(wszRegPath, L"%s\\%s", SEC_LOG_REG_PATH, lpwSourceName);

            break;
        }
    
        //
        // Open the source key - if it doesn't exist,
        // it will be created
        //
        if (RegCreateKeyEx(HKEY_LOCAL_MACHINE,
                           wszRegPath,
                           0,
                           NULL,
                           REG_OPTION_NON_VOLATILE,
                           KEY_SET_VALUE,
                           NULL,
                           &hLogKey,
                           0) != ERROR_SUCCESS) __leave;

        //
        // Write the path to our message file
        //
        if (RegSetValueEx(hLogKey,
                          L"EventMessageFile",
                          0L,
                          REG_SZ,
                          (LPBYTE) lpwSourceFile,
                          (wcslen(lpwSourceFile)+1)
                          *sizeof(WCHAR)) != ERROR_SUCCESS) __leave;

        //
        // Write the number of event types supported
        //
        if (RegSetValueEx(hLogKey,
                          L"TypesSupported",
                          0L,
                          REG_DWORD,
                          (LPBYTE) &dwTypes,
                          sizeof(DWORD)) != ERROR_SUCCESS) __leave;

    
        //
        // Write the number of event categories supported
        //
        if (RegSetValueEx(hLogKey,
                          L"CategoryCount",
                          0L,
                          REG_DWORD,
                          (LPBYTE) &cCount,
                          sizeof(DWORD)) != ERROR_SUCCESS) __leave;

        fResult = TRUE;
        
    } // try

    __finally {

        if (hLogKey) {
            RegCloseKey(hLogKey);
        }
    
    } // finally

    return (fResult);
}

/*++

  Routine Description:

    Logs an event to the event log

  Arguments:

    lpwSourceName       -   Name of the source in the registry
    lpwUNCServerName    -   UNC server name or NULL for local
    wType               -   Type of event to report
    dwEventID           -   Event identifier
    wNumStrings         -   Number of insertion strings contained
                            in lpwStrings array
    *lpwStrings         -   Array of insertion strings. Can be NULL
                            if no strings are being used

  Return Value:

    None

--*/
BOOL
CEventLog::LogEvent(
    IN LPCWSTR lpwSourceName,
    IN LPCWSTR lpwUNCServerName,
    IN WORD    wType,
    IN DWORD   dwEventID,
    IN WORD    wNumStrings,
    IN LPCWSTR *lpwStrings OPTIONAL
    )
{
    HANDLE  hES = NULL;
    LPVOID  lpMsgBuf = NULL;
    BOOL    fResult = FALSE;

    __try {
    
        //
        // Obtain a handle to our event source
        //
        hES = RegisterEventSource(lpwUNCServerName, lpwSourceName);

        if (NULL == hES) {
            __leave;
        }

        if (wNumStrings) {

            //
            // Report the event with insertion strings
            //
            fResult = ReportEvent(hES,
                                  wType,
                                  0,
                                  dwEventID,
                                  NULL,
                                  wNumStrings,
                                  0,
                                  lpwStrings,
                                  0);
        } else {

            //
            // Report the event with no strings
            //
            fResult = ReportEvent(hES,
                                  wType,
                                  0,
                                  dwEventID,
                                  NULL,
                                  0,
                                  0L,
                                  NULL,
                                  0);
        }

    } // try

    __finally {

        if (hES) {

            DeregisterEventSource(hES);
        }
    
    } // finally
    
    return (fResult);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\appcompat\windowsupdate\installer\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by wuinst.rc
//
#define IDS_FORMAT_MESSAGE_FAILED       1
#define IDS_NEWER_VERSION               2
#define IDS_INSTALL_PROMPT              3
#define IDS_UNINSTALL_PROMPT            4
#define IDS_REBOOT_NEEDED               5
#define IDS_MB_TITLE                    6
#define IDS_APP_NAME_WIN2K              7
#define IDS_APP_NAME_XP                 8
#define IDS_EL_SOURCE_NAME              9
#define IDS_CRITICAL_ERROR              10
#define IDS_SYSRESTORE_INST_LABEL       11
#define IDS_SYSRESTORE_UNINST_LABEL     12

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        101
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1000
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\appcompat\windowsupdate\installer\registry.h ===
/*++

  Copyright (c) 2001 Microsoft Corporation

  Module Name:

    Registry.h

  Abstract:

    Class definition for the registry
    API wrapper class.

  Notes:

    Unicode only.   
    
  History:

    01/29/2001      rparsons      Created
    03/02/2001      rparsons      Major overhaul

--*/
#include <windows.h>

#define REG_FORCE_RESTORE           (0x00000008L)

class CRegistry {

public:

    HKEY CreateKey(IN HKEY    hKey,
                   IN LPCWSTR lpwSubKey,
                   IN REGSAM  samDesired);

    BOOL CloseKey(IN HKEY hKey);

    LPWSTR GetString(IN HKEY    hKey,
                     IN LPCWSTR lpwSubKey,
                     IN LPCWSTR lpwValueName,
                     IN BOOL    fPredefined);

    BOOL GetDword(IN HKEY    hKey,
                  IN LPCWSTR lpwSubKey,
                  IN LPCWSTR lpwValueName,
                  IN LPDWORD lpdwData,
                  IN BOOL    fPredefined);

    BOOL SetString(IN HKEY    hKey,
                   IN LPCWSTR lpwSubKey,
                   IN LPCWSTR lpwValueName,
                   IN LPWSTR  lpwData,
                   IN BOOL    fPredefined);

    BOOL SetDword(IN HKEY    hKey,
                  IN LPCWSTR lpwSubKey,
                  IN LPCWSTR lpwValueName,
                  IN DWORD   dwData,
                  IN BOOL    fPredefined);

    BOOL DeleteRegistryString(IN HKEY    hKey,
                              IN LPCWSTR lpwSubKey,
                              IN LPCWSTR lpwValueName,
                              IN BOOL    fPredefined);

    BOOL DeleteRegistryKey(IN HKEY    hKey,
                           IN LPCWSTR lpwKey,
                           IN LPCWSTR lpwSubKeyName,
                           IN BOOL    fPredefined,
                           IN BOOL    fFlush);

    BOOL IsRegistryKeyPresent(IN HKEY    hKey,
                              IN LPCWSTR lpwSubKey);

    void Free(IN LPVOID lpMem);

    BOOL AddStringToMultiSz(IN HKEY    hKey,
                            IN LPCWSTR lpwSubKey,
                            IN LPCWSTR lpwValueName,
                            IN LPCWSTR lpwEntry,
                            IN BOOL    fPredefined);

    BOOL RemoveStringFromMultiSz(IN HKEY    hKey,
                                 IN LPCWSTR lpwSubKey,
                                 IN LPCWSTR lpwValueName,
                                 IN LPCWSTR lpwEntry,
                                 IN BOOL    fPredefined);

    BOOL RestoreKey(IN HKEY    hKey,
                    IN LPCWSTR lpwSubKey,
                    IN LPCWSTR lpwFileName,
                    IN BOOL    fGrantPrivs);

    BOOL BackupRegistryKey(IN HKEY    hKey,
                           IN LPCWSTR lpwSubKey,
                           IN LPCWSTR lpwFileName,
                           IN BOOL    fGrantPrivs);
         

private:

    DWORD GetStringSize(IN  HKEY    hKey,
                        IN  LPCWSTR lpwValueName,
                        OUT LPDWORD lpType OPTIONAL);

    LPVOID Malloc(IN SIZE_T dwBytes);

    HKEY OpenKey(IN HKEY    hKey,
                 IN LPCWSTR lpwSubKey,
                 IN REGSAM  samDesired);

    int ListStoreLen(IN LPWSTR lpwList);

    BOOL ModifyTokenPrivilege(IN LPCWSTR lpwPrivilege,
                              IN BOOL    fEnable);
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\appcompat\windowsupdate\installer\makefile.inc ===
wumsg.rc: msg00001.bin

wumsg.h msg00001.bin: wumsg.mc
    mc -v -h .\ wumsg.mc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\appcompat\windowsupdate\installer\eventlog.h ===
/*++

  Copyright (c) 2001 Microsoft Corporation

  Module Name:

    Eventlog.h

  Abstract:

    Class definition for the event log
    API wrapper class.

  Notes:

    Unicode only.   
    
  History:

    03/02/2001      rparsons    Created

--*/
#include <windows.h>

#define dwApplication   ((DWORD)0)
#define dwSystem        ((DWORD)1)
#define dwSecurity      ((DWORD)2)

#define APP_LOG_REG_PATH    L"SYSTEM\\CurrentControlSet\\Services\\EventLog\\Application"
#define SYS_LOG_REG_PATH    L"SYSTEM\\CurrentControlSet\\Services\\EventLog\\System"
#define SEC_LOG_REG_PATH    L"SYSTEM\\CurrentControlSet\\Services\\EventLog\\Security"

class CEventLog {

public:

    BOOL CreateEventSource(IN LPCWSTR lpwSourceFile,
                           IN LPCWSTR lpwSourceName,
                           IN DWORD   dwLogType);

    BOOL LogEvent(IN LPCWSTR lpwSourceName,
                  IN LPCWSTR lpwUNCServerName,
                  IN WORD    wType,
                  IN DWORD   dwEventID,
                  IN WORD    wNumStrings,
                  IN LPCWSTR *lpwStrings);
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\appcompat\windowsupdate\installer\registry.cpp ===
/*++

  Copyright (c) 2001 Microsoft Corporation

  Module Name:

    Registry.cpp

  Abstract:

    Implementation of the registry
    wrapper class.

  Notes:

    Unicode only.   
    
  History:

    01/29/2001      rparsons    Created
    03/02/2001      rparsons    Major overhaul

--*/

#include "registry.h"

/*++

  Routine Description:

    Allocates memory from the heap

  Arguments:

    dwBytes         -       Number of bytes to allocate
                            This value will be multiplied
                            by the size of a WCHAR

  Return Value:

    A pointer to a block of memory

--*/
LPVOID
CRegistry::Malloc(
    IN SIZE_T dwBytes
    )
{
    LPVOID  lpReturn = NULL;

    lpReturn = HeapAlloc(GetProcessHeap(),
                         HEAP_ZERO_MEMORY,
                         dwBytes*sizeof(WCHAR));

    return (lpReturn);
}

/*++

  Routine Description:

    Frees memory from the heap

  Arguments:

    lpMem           -       Pointer to a block of memory to free                           

  Return Value:

    None

--*/
void
CRegistry::Free(
    IN LPVOID lpMem
    )
{
    if (NULL != lpMem) {
        HeapFree(GetProcessHeap(), 0, lpMem);
    }

    return;
}

/*++

  Routine Description:

    Creates the specified key or opens it if it
    already exists

  Arguments:

    hKey        -       Handle to a predefined key
    lpwSubKey   -       Path to the sub key to open
    samDesired  -       The desired access rights

  Return Value:

    A handle to the key on success, NULL otherwise

--*/
HKEY
CRegistry::CreateKey(
    IN HKEY    hKey,
    IN LPCWSTR lpwSubKey,
    IN REGSAM  samDesired
    )
{
    HKEY    hReturnKey = NULL;

    if (!hKey || !lpwSubKey || !samDesired) {
        return NULL;
    }

    RegCreateKeyEx(hKey,
                   lpwSubKey,
                   0,
                   NULL,
                   REG_OPTION_NON_VOLATILE,
                   samDesired,
                   NULL,
                   &hReturnKey,
                   0);

    return (hReturnKey);
}

/*++

  Routine Description:

    Opens the specified key

  Arguments:

    hKey        -       Handle to a predefined key
    lpwSubKey   -       Path to the sub key to open
    samDesired  -       The desired access rights

  Return Value:

    A handle to the key on success, NULL otherwise

--*/
HKEY
CRegistry::OpenKey(
    IN HKEY    hKey,
    IN LPCWSTR lpwSubKey,
    IN REGSAM  samDesired
    )
{
    HKEY    hReturnKey = NULL;

    if (!hKey || !lpwSubKey || !samDesired) {
        return NULL;
    }

    RegOpenKeyEx(hKey,
                 lpwSubKey,
                 0,
                 samDesired,
                 &hReturnKey);
    
    return (hReturnKey);
}

/*++

  Routine Description:

    Closes the specified key handle

  Arguments:

    hKey    -   Handle of the key to close

  Return Value:

    TRUE on success, FALSE otherwise

--*/
BOOL
CRegistry::CloseKey(
    IN HKEY hKey
    )
{
    LONG    lResult = 0;

    lResult = RegCloseKey(hKey);

    return (lResult == ERROR_SUCCESS ? TRUE : FALSE);
}

/*++

  Routine Description:

    Gets a size for a specified value name

  Arguments:

    hKey            -       Open key handle (not predefined)
    lpwValueName    -       Name of data value
    lpType          -       Receives the type of data

  Return Value:

    Number of bytes the value occupies

--*/
DWORD
CRegistry::GetStringSize(
    IN  HKEY    hKey,
    IN  LPCWSTR lpwValueName,
    OUT LPDWORD lpType OPTIONAL
    )
{
    DWORD cbSize = 0;

    if (!hKey || !lpwValueName) {
        return 0;
    }

    RegQueryValueEx(hKey,
                    lpwValueName,
                    0,
                    lpType,
                    NULL,
                    &cbSize);

    return (cbSize);
}

/*++

  Routine Description:

    Retrieves a string value from the registry

  Arguments:

    hKey            -       Predefined or open key handle
    lpwSubKey       -       Path to the subkey
    lpwValueName    -       Name of data value
    fPredefined     -       Flag to indicate if a predefined
                            key handle was passed

  Return Value:

    The requested value data on success, NULL otherwise

--*/
LPWSTR 
CRegistry::GetString(
    IN HKEY    hKey, 
    IN LPCWSTR lpwSubKey, 
    IN LPCWSTR lpwValueName,
    IN BOOL    fPredefined
    )
{
    DWORD       cbSize = 0;
    BOOL        fResult = FALSE;
    LONG        lResult = 0;
    LPWSTR      lpwReturn = NULL;
    HKEY        hLocalKey = NULL;

    if (!hKey || !lpwValueName) {
        return NULL;
    }

    __try {

        hLocalKey = hKey;

        if (fPredefined) {

            //
            // We'll need to open the key for them
            //
            hLocalKey = this->OpenKey(hKey, lpwSubKey, KEY_QUERY_VALUE);

            if (NULL == hLocalKey) {
                __leave;
            }
        }

        //
        // Get the required string size and allocate
        // memory for the actual call
        //
        cbSize = this->GetStringSize(hLocalKey, lpwValueName, NULL);

        if (0 == cbSize) {
            __leave;
        }

        lpwReturn = (LPWSTR) this->Malloc(cbSize*sizeof(WCHAR));

        if (NULL == lpwReturn) {
            __leave;
        }

        //
        // Make the actual call to get the data
        //
        lResult = RegQueryValueEx(hLocalKey,
                                  lpwValueName,
                                  0,
                                  NULL, 
                                  (LPBYTE) lpwReturn,
                                  &cbSize);

        if (ERROR_SUCCESS != lResult) {
            __leave;
        }

        fResult = TRUE;

    } // try

    __finally {

        if (hLocalKey) {
            RegCloseKey(hLocalKey);
        }
    }
    
    return (fResult ? lpwReturn : NULL);
}

/*++

  Routine Description:

    Retrieves a DWORD value from the registry

  Arguments:

    hKey            -       Predefined or open key handle
    lpwSubKey       -       Path to the subkey
    lpwValueName    -       Name of data value
    lpdwData        -       Pointer to store the value
    fPredefined     -       Flag to indicate if a predefined
                            key handle was passed

  Return Value:

    TRUE on success, FALSE otherwise.

--*/
BOOL
CRegistry::GetDword(
    IN HKEY    hKey,
    IN LPCWSTR lpwSubKey,
    IN LPCWSTR lpwValueName,
    IN LPDWORD lpdwData,
    IN BOOL    fPredefined
    )
{
    DWORD       cbSize = MAX_PATH;
    BOOL        fResult = FALSE;
    LONG        lResult = 0;
    HKEY        hLocalKey = NULL;

    if (!hKey || !lpwValueName || !lpdwData) {
        return FALSE;
    }

    __try {

        hLocalKey = hKey;

        if (fPredefined) {

            //
            // We'll need to open the key for them
            //
            hLocalKey = this->OpenKey(hKey, lpwSubKey, KEY_QUERY_VALUE);

            if (NULL == hLocalKey) {
                __leave;
            }
        }

        //
        // Make the call to get the data
        //
        lResult = RegQueryValueEx(hLocalKey,
                                  lpwValueName,
                                  0,
                                  NULL,
                                  (LPBYTE) lpdwData,
                                  &cbSize);

        if (ERROR_SUCCESS != lResult) {
            __leave;
        }

        fResult = TRUE;

    } // try

    __finally {

        if (hLocalKey) {
            RegCloseKey(hLocalKey);
        }

    } //finally
    
    return (fResult);
}

/*++

  Routine Description:

    Sets a DWORD value in the registry

  Arguments:

    hKey            -       Predefined or open key handle
    lpwSubKey       -       Path to the subkey
    lpwValueName    -       Name of data value
    dwData          -       Value to store
    fPredefined     -       Flag to indicate if a predefined
                            key handle was passed

  Return Value:

    TRUE on success, FALSE otherwise

--*/
BOOL
CRegistry::SetDword(
    IN HKEY    hKey,
    IN LPCWSTR lpwSubKey,
    IN LPCWSTR lpwValueName,
    IN DWORD   dwData,
    IN BOOL    fPredefined
    )
{   
    LONG        lResult = 0;
    BOOL        fResult = FALSE;
    HKEY        hLocalKey = NULL;

    if (!hKey || !lpwValueName) {
        return FALSE;
    }

    __try {

        hLocalKey = hKey;

        if (fPredefined) {

            //
            // We'll need to open the key for them
            //
            hLocalKey = this->OpenKey(hKey, lpwSubKey, KEY_SET_VALUE);

            if (NULL == hLocalKey) {
                __leave;
            }
        }

        //
        // Make the call to set the data
        //
        lResult = RegSetValueEx(hLocalKey,
                                lpwValueName,
                                0,
                                REG_DWORD,
                                (LPBYTE) &dwData,
                                sizeof(DWORD));

        if (ERROR_SUCCESS != lResult) {
            __leave;
        }

        fResult = TRUE;
    
    } // try

    __finally {

        if (hLocalKey) {
            RegCloseKey(hLocalKey);
        }
    
    } // finally
    
    return (fResult);
}

/*++

  Routine Description:

    Sets a string value in the registry

  Arguments:

    hKey            -       Predefined or open key handle
    lpwSubKey       -       Path to the subkey
    lpwValueName    -       Name of data value
    lpwData         -       Value to store
    fPredefined     -       Flag to indicate if a predefined
                            key handle was passed

  Return Value:

    TRUE on success, FALSE otherwise.

--*/
BOOL 
CRegistry::SetString(
    IN HKEY    hKey,
    IN LPCWSTR lpwSubKey,
    IN LPCWSTR lpwValueName,
    IN LPWSTR  lpwData,
    IN BOOL    fPredefined
    )
{
    HKEY        hLocalKey = NULL;
    BOOL        fResult = FALSE;
    LONG        lResult = 0;

    if (!hKey || !lpwValueName) {
        return FALSE;
    }

    __try {

        hLocalKey = hKey;

        if (fPredefined) {

            //
            // We'll need to open the key for them
            //
            hLocalKey = this->OpenKey(hKey, lpwSubKey, KEY_SET_VALUE);

            if (NULL == hLocalKey) {
                __leave;
            }
        }
    
        lResult = RegSetValueEx(hLocalKey,
                                lpwValueName,
                                0,
                                REG_SZ,
                                (LPBYTE) lpwData,
                                (wcslen(lpwData)+1)*sizeof(WCHAR));

        if (ERROR_SUCCESS != lResult) {
            __leave;
        }

        fResult = TRUE;
        
    } // try

    __finally {

        if (hLocalKey) {
            RegCloseKey(hLocalKey);
        }
    
    } // finally

    return (fResult);
}

/*++

  Routine Description:

    Deletes the specified value from the registry

  Arguments:

    hKey            -   Predefined or open key handle
    lpwSubKey       -   Path to the subkey
    lpwValueName    -   Name of the value to delete
    fPredefined     -   Flag to indicate if a predefined
                        key handle was passed

  Return Value:

    TRUE on success, FALSE otherwise.

--*/
BOOL 
CRegistry::DeleteRegistryString(
    IN HKEY    hKey,
    IN LPCWSTR lpwSubKey,
    IN LPCWSTR lpwValueName,
    IN BOOL    fPredefined
    )
{
    HKEY        hLocalKey = NULL;
    BOOL        fResult = FALSE;
    LONG        lResult = 0;

    if (!hKey || !lpwValueName) {
        return FALSE;
    }

    __try {

        hLocalKey = hKey;

        if (fPredefined) {

            //
            // We'll need to open the key for them
            //
            hLocalKey = this->OpenKey(hKey, lpwSubKey, KEY_WRITE);

            if (NULL == hLocalKey) {
                __leave;
            }
        }
    
        //
        // Delete the value
        //
        lResult = RegDeleteValue(hLocalKey,
                                 lpwValueName);

        if (ERROR_SUCCESS != lResult) {
            __leave;
        }

        fResult = TRUE;
    
    } // try

    __finally {

        if (hLocalKey) {
            RegCloseKey(hLocalKey);
        }
    
    } // finally

    return (fResult);
}

/*++

  Routine Description:

    Deletes the specified key from the registry
    (At this time, subkeys are not allowed)

  Arguments:

    hKey            -   Predefined or open key handle
    lpwSubKey       -   Path to the subkey
    lpwSubKeyName   -   Name of the subkey
    fPredefined     -   Flag to indicate if a predefined
                        key handle was passed
    fFlush          -   Flag to indicate if we should flush the key

  Return Value:

    TRUE on success, FALSE otherwise.

--*/
BOOL 
CRegistry::DeleteRegistryKey(
    IN HKEY    hKey,
    IN LPCWSTR lpwKey,
    IN LPCWSTR lpwSubKeyName,
    IN BOOL    fPredefined,
    IN BOOL    fFlush
    )
{
    HKEY        hLocalKey = NULL;
    BOOL        fResult = FALSE;
    LONG        lResult = 0;

    if (!hKey) {
        return FALSE;
    }

    __try {

        hLocalKey = hKey;

        if (fPredefined) {

            //
            // We'll need to open the key for them
            //
            hLocalKey = this->OpenKey(hKey, lpwKey, KEY_WRITE);

            if (NULL == hLocalKey) {
                __leave;
            }
        }
    
        //
        // Delete the value
        //
        lResult = RegDeleteKey(hLocalKey,
                               lpwSubKeyName);

        if (ERROR_SUCCESS != lResult) {
            __leave;
        }

        if (fFlush) {
            RegFlushKey(hLocalKey);
        }

        fResult = TRUE;
    
    } // try

    __finally {

        if (hLocalKey) {
            RegCloseKey(hLocalKey);
        }
    
    } // finally

    return (fResult);
}

/*++

  Routine Description:

    Adds a string to a REG_MULTI_SZ key

  Arguments:

    hKey            -       Predefined or open key handle
    lpwSubKey       -       Path to the subkey
    lpwValueName    -       Name of the value
    lpwEntry        -       Name of entry to add
    fPredefined     -       Flag to indicate if a predefined
                            key handle was passed

  Return Value:

    TRUE on success, FALSE otherwise

--*/
BOOL
CRegistry::AddStringToMultiSz(
    IN HKEY    hKey,
    IN LPCWSTR lpwSubKey,
    IN LPCWSTR lpwValueName,
    IN LPCWSTR lpwEntry,
    IN BOOL    fPredefined
    )
{
    int         nLen = 0;
    HKEY        hLocalKey = NULL;
    DWORD       cbSize = 0, dwType = 0;
    LPWSTR      lpwNew = NULL, lpwData = NULL;
    BOOL        fResult = FALSE;
    LONG        lResult = 0;

    if (!hKey || !lpwEntry) {
        return FALSE;
    }

    __try {

        hLocalKey = hKey;

        if (fPredefined) {

            //
            // We'll need to open the key for them
            //
            hLocalKey = this->OpenKey(hKey,
                                      lpwSubKey,
                                      KEY_QUERY_VALUE | KEY_WRITE);
    
            if (NULL == hLocalKey) {
                __leave;
            }
        }

        //
        // Get the required string size and allocate
        // memory for the actual call
        //
        cbSize = this->GetStringSize(hLocalKey, lpwValueName, &dwType);
    
        if ((0 == cbSize) || (dwType != REG_MULTI_SZ)) {
            __leave;
        }
    
        lpwData = (LPWSTR) this->Malloc(cbSize * sizeof(WCHAR));
    
        if (NULL == lpwData) {
            __leave;
        }
    
        //
        // Get the actual data
        //
        lResult = RegQueryValueEx(hLocalKey,
                                  lpwValueName,
                                  0,
                                  0,
                                  (LPBYTE) lpwData,
                                  &cbSize);

        if (ERROR_SUCCESS != lResult) {
            __leave;
        }

    
        lpwNew = lpwData;

        while (*lpwNew) {

            nLen = wcslen(lpwNew);

            //
            // Move to the next string
            //
            lpwNew += nLen + 1;

            //
            // At end of list of strings, append here
            //
            if (!*lpwNew) {

                wcscpy(lpwNew, lpwEntry);
                lpwNew += wcslen(lpwEntry) + 1;
                *lpwNew = 0;
                nLen = this->ListStoreLen(lpwData);

                lResult = RegSetValueEx(hLocalKey,
                                        lpwValueName,
                                        0,
                                        REG_MULTI_SZ,
                                        (const BYTE*) lpwData,
                                        nLen);

                if (lResult != ERROR_SUCCESS) {
                    __leave;
                
                } else {
                    fResult = TRUE;
                }

            break;
            
            }
        }

    } // try

    __finally {

        if (lpwData) {
            this->Free(lpwData);
        }

        if (hLocalKey) {
            RegCloseKey(hKey);
        }
    
    } // finally
    
    return (fResult);
}

/*++

  Routine Description:

    Removes a string from a REG_MULTI_SZ key

  Arguments:

    
    hKey            -       Predefined or open key handle
    lpwSubKey       -       Path to the subkey
    lpwValueName    -       Name of the value
    lpwEntry        -       Name of entry to remove
    fPredefined     -       Flag to indicate if a predefined
                            key handle was passed

  Return Value:

    TRUE on success, FALSE otherwise

--*/
BOOL
CRegistry::RemoveStringFromMultiSz(
    IN HKEY    hKey,
    IN LPCWSTR lpwSubKey,
    IN LPCWSTR lpwValueName,
    IN LPCWSTR lpwEntry,
    IN BOOL    fPredefined
    )
{
    LPBYTE      lpBuf = NULL;
    HKEY        hLocalKey = NULL;
    WCHAR       *pFirst = NULL;
    WCHAR       *pSecond = NULL;
    DWORD       dwType = 0, cbSize = 0;
    DWORD       dwNameLen = 0, dwNameOffset = 0, dwSize = 0;
    BOOL        fResult = FALSE;
    LONG        lResult = 0;

    if (!hKey || !lpwEntry) {
        return FALSE;
    }

    __try {

        hLocalKey = hKey;
        
        if (fPredefined) {

            //
            // We'll need to open the key for them
            //
            hLocalKey = this->OpenKey(hKey,
                                      lpwSubKey,
                                      KEY_QUERY_VALUE | KEY_WRITE);
    
            if (NULL == hLocalKey) {
                __leave;
            }
        }

        //
        // Get the required string size and allocate
        // memory for the actual call
        //
        cbSize = this->GetStringSize(hLocalKey, lpwValueName, &dwType);
    
        if ((0 == cbSize) || (dwType != REG_MULTI_SZ)) {
            __leave;
        }
    
        lpBuf = (LPBYTE) this->Malloc(cbSize * sizeof(WCHAR));
    
        if (NULL == lpBuf) {
            __leave;
        }
    
        //
        // Get the actual data
        //
        lResult = RegQueryValueEx(hLocalKey,
                                  lpwValueName,
                                  0,
                                  0,
                                  (LPBYTE) lpBuf,
                                  &cbSize);

        if (ERROR_SUCCESS != lResult) {
            __leave;
        }
    
        //
        // Attempt to find the string we're looking for
        //
        for (pFirst = (WCHAR*) lpBuf; *pFirst; pFirst += dwNameLen) {

            dwNameLen = wcslen(pFirst) + 1; // Length of name plus NULL
            dwNameOffset += dwNameLen;
    
            //
            // Check for a match
            //
            if (_wcsicmp(pFirst, lpwEntry) == 0) {

                dwSize = wcslen(pFirst) + 1;    // Length of name
                pSecond = (WCHAR*) pFirst + dwSize;
    
                while(*pSecond) 
                    while(*pSecond)
                        *pFirst++ = *pSecond++;
                    *pFirst++ = *pSecond++;
                
                *pFirst = '\0';
    
                //
                // Found a match - update the key
                //
                lResult = RegSetValueEx(hLocalKey,
                                        lpwValueName,
                                        0,
                                        REG_MULTI_SZ,
                                        (const BYTE*) lpBuf,
                                        cbSize -
                                        (dwSize*sizeof(WCHAR)));

                if (lResult != ERROR_SUCCESS) {
                    __leave;
                
                } else {
                    fResult = TRUE;
                }
    
                break;                
            }            
        }

    } // try

    __finally {

        if (lpBuf) {
            this->Free(lpBuf);
        }

        if (hLocalKey) {
            RegCloseKey(hLocalKey);
        }
    
    } // finally

    return (fResult);
}

/*++

  Routine Description:

    Determines if the specified subkey is present

  Arguments:
  
    hKey            -       Predefined or open key handle
    lpwSubKey       -       Path to the subkey
    
  Return Value:

    TRUE if it's present, FALSE otherwise.

--*/
BOOL
CRegistry::IsRegistryKeyPresent(
    IN HKEY    hKey,
    IN LPCWSTR lpwSubKey
    )
{
    BOOL        fResult = FALSE;
    HKEY        hLocalKey = NULL;

    if (!hKey || !lpwSubKey) {
        return FALSE;
    }

    __try {

        hLocalKey = hKey;

        //
        // Check for the presence of the key
        //
        hLocalKey = this->OpenKey(hKey,
                                  lpwSubKey,
                                  KEY_QUERY_VALUE);

        if (NULL == hLocalKey) {
            __leave;
        
        } else {
            fResult = TRUE;
        }        
   

    } // try
    
    __finally {
    
        if (hLocalKey)
            RegCloseKey(hLocalKey);
    
    } // finally

    return (fResult);
}

/*++

  Routine Description:

    Restores the specified registry key

  Arguments:
  
    hKey            -       Predefined or open key handle
    lpwSubKey       -       Path to the subkey
    lpwFileName     -       Path & name of the file to restore
    fGrantPrivs     -       Flag to indicate if we should grant
                            privileges to the user
    
  Return Value:

    TRUE on success, FALSE otherwise

--*/
BOOL 
CRegistry::RestoreKey(
    IN HKEY    hKey,
    IN LPCWSTR lpwSubKey,
    IN LPCWSTR lpwFileName,
    IN BOOL    fGrantPrivs
    )
{
    BOOL    fResult = FALSE;
    HKEY    hLocalKey = NULL;
    LONG    lResult = 0;

    if (!hKey || !lpwSubKey || !lpwFileName) {
        return FALSE;
    }

    __try {

        //
        // If necessary, grant privileges for the restore
        //
        if (fGrantPrivs) {
            this->ModifyTokenPrivilege(L"SeRestorePrivilege", TRUE);
        }
    
        lResult = RegCreateKeyEx(hKey,
                                 lpwSubKey,
                                 0,
                                 NULL,
                                 0,
                                 KEY_ALL_ACCESS,
                                 NULL,
                                 &hLocalKey,
                                 0);

        if (ERROR_SUCCESS != lResult) {
            __leave;
        }

        //
        // Restore the key from the specified file
        //
        lResult = RegRestoreKey(hLocalKey,
                                lpwFileName,
                                REG_FORCE_RESTORE);

        if (ERROR_SUCCESS != lResult) {
            __leave;
        }

        RegFlushKey(hLocalKey);

        fResult = TRUE;

    } // try

    __finally {

        if (hLocalKey) {
            RegCloseKey(hLocalKey);
        }

        if (fGrantPrivs) {
            this->ModifyTokenPrivilege(L"SeRestorePrivilege", FALSE);
        }
    
    } // finally

    return (fResult);
}

/*++

  Routine Description:

    Makes a backup of the specified registry key

  Arguments:
  
    hKey            -       Predefined or open key handle
    lpwSubKey       -       Path to the subkey
    lpwFileName     -       Path & name of the file to restore
    fGrantPrivs     -       Flag to indicate if we should grant
                            privileges to the user
    
  Return Value:

    TRUE on success, FALSE otherwise

--*/
BOOL 
CRegistry::BackupRegistryKey(
    IN HKEY    hKey,
    IN LPCWSTR lpwSubKey,
    IN LPCWSTR lpwFileName,
    IN BOOL    fGrantPrivs
    )
{
    BOOL    fResult = FALSE;
    HKEY    hLocalKey = NULL;
    DWORD   dwDisposition = 0;
    DWORD   dwLastError = 0;
    LONG    lResult = 0;

    if (!hKey || !lpwSubKey || !lpwFileName) {
        return FALSE;
    }

    __try {

        if (fGrantPrivs) {
            ModifyTokenPrivilege(L"SeBackupPrivilege", TRUE);
        }

        lResult = RegCreateKeyEx(hKey,
                                 lpwSubKey,
                                 0,
                                 NULL,
                                 REG_OPTION_BACKUP_RESTORE,
                                 KEY_QUERY_VALUE,             // this argument is ignored
                                 NULL,
                                 &hLocalKey,
                                 &dwDisposition);

        if (ERROR_SUCCESS != lResult) {
            __leave;
        }
        
        //
        // Verify that we didn't create a new key
        // 
        if (REG_CREATED_NEW_KEY == dwDisposition) {
            __leave;
        }
        
        //
        // Save the key to the file
        //
        lResult = RegSaveKey(hLocalKey,
                             lpwFileName,
                             NULL);

        if (ERROR_SUCCESS != lResult) {
            __leave;
        
        } else {
            fResult = TRUE;
        }

    } // try
     
    __finally {
    
        if (hLocalKey) {
            RegCloseKey(hLocalKey);
        }

        if (fGrantPrivs) {
            this->ModifyTokenPrivilege(L"SeBackupPrivilege", FALSE);
        }
    
    } // finally
    
    return (fResult);
}

/*++

  Routine Description:

    Helper function that calculates the size of MULTI_SZ string.

  Arguments:

    lpwList     -       MULTI_SZ string.

  Return Value:

    Size of the string.

--*/
int
CRegistry::ListStoreLen(
    IN LPWSTR lpwList
    )
{
    int nStoreLen = 2, nLen = 0;

    if (NULL == lpwList) {
        return 0;
    }

    while (*lpwList) {

        nLen = wcslen(lpwList) + 1;
        nStoreLen += nLen * 2;
        lpwList += nLen;
    }

    return (nStoreLen);
}

/*++

  Routine Description:

    Enables or disables a specified privilege

  Arguments:

    lpwPrivilege    -   The name of the privilege
    
    fEnable         -   A flag to indicate if the
                        privilege should be enabled
    
  Return Value:

    TRUE on success, FALSE otherwise

--*/
BOOL 
CRegistry::ModifyTokenPrivilege(
    IN LPCWSTR lpwPrivilege,
    IN BOOL    fEnable
    )
{
    HANDLE           hToken = NULL;
    LUID             luid;
    BOOL             fResult = FALSE;
    TOKEN_PRIVILEGES tp;

    if (NULL == lpwPrivilege) {
        return FALSE;
    }

    __try {
    
        //
        // Get a handle to the access token associated with the current process
        //
        OpenProcessToken(GetCurrentProcess(), 
                         TOKEN_ADJUST_PRIVILEGES | TOKEN_QUERY, 
                         &hToken);
    
        if (NULL == hToken) {
            __leave;
        }
        
        //
        // Obtain a LUID for the specified privilege
        //
        if (!LookupPrivilegeValue(NULL, lpwPrivilege, &luid)) {
            __leave;
        }
        
        tp.PrivilegeCount           = 1;
        tp.Privileges[0].Luid       = luid;
        tp.Privileges[0].Attributes = fEnable ? SE_PRIVILEGE_ENABLED : 0;
    
        //
        // Modify the access token
        //
        if (!AdjustTokenPrivileges(hToken,
                                   FALSE,
                                   &tp,
                                   sizeof(TOKEN_PRIVILEGES),
                                   NULL,
                                   NULL)) {
            __leave;
        }
        
        fResult = TRUE;
    
    } // try

    __finally {

        if (hToken) {
            CloseHandle(hToken);
        }
    
    } // finally

    return (fResult);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\appcompat\windowsupdate\installer\systemrestore.cpp ===
/*++

  Copyright (c) 2001 Microsoft Corporation

  Module Name:

    SystemRestore.cpp

  Abstract:

    Implements a function to set/clear
    a system restore point.

  Notes:

    Unicode only.

  History:

    04/09/2001      markder    Created
    
--*/

#include "precomp.h"
#include "srrestoreptapi.h"

extern SETUP_INFO g_si;

STATEMGRSTATUS g_SMgrStatus = { NULL };
RESTOREPOINTINFO g_RestPtInfo = { NULL };

BOOL SystemRestorePointStart(BOOL bInstall)
{
   ZeroMemory(&g_SMgrStatus, sizeof(STATEMGRSTATUS));
   ZeroMemory(&g_RestPtInfo, sizeof(RESTOREPOINTINFO));

   // Initialize the RESTOREPOINTINFO structure
   g_RestPtInfo.dwEventType = BEGIN_SYSTEM_CHANGE;

   // Notify the system that changes are about to be made.
   // An application is to be installed/uninstalled.
   g_RestPtInfo.dwRestorePtType = bInstall ? APPLICATION_INSTALL : APPLICATION_UNINSTALL;

   // Set  g_RestPtInfo.llSequenceNumber.
   g_RestPtInfo.llSequenceNumber = 0;

   // String to be displayed by System Restore for this restore point. 
   if (0 == LoadString(g_si.hInstance,
      bInstall ? IDS_SYSRESTORE_INST_LABEL : IDS_SYSRESTORE_UNINST_LABEL, 
      g_RestPtInfo.szDescription, MAX_DESC))
   {
      printf("Couldn't get friendly name for restore point.\n");
      return FALSE;
   }

   // Notify the system that changes are to be made and that
   // the beginning of the restore point should be marked. 
   if(!SRSetRestorePoint(&g_RestPtInfo, &g_SMgrStatus)) 
   {
      printf("Couldn't set the beginning of the restore point.\n");
      return FALSE;
   }

   return TRUE;
}

BOOL SystemRestorePointEnd()
{
   if (g_SMgrStatus.llSequenceNumber == 0)
   {
       return TRUE;
   }

   // Initialize the RESTOREPOINTINFO structure to notify the 
   // system that the operation is finished.
    g_RestPtInfo.dwEventType = END_SYSTEM_CHANGE;

   // End the system change by returning the sequence number 
   // received from the first call to SRSetRestorePoint.
    g_RestPtInfo.llSequenceNumber = g_SMgrStatus.llSequenceNumber;

   // Notify the system that the operation is done and that this
   // is the end of the restore point.
   if(!SRSetRestorePoint(&g_RestPtInfo, &g_SMgrStatus)) 
   {
      printf("Couldn't set the end of the restore point.\n");
      return FALSE;
   }

   ZeroMemory(&g_SMgrStatus, sizeof(STATEMGRSTATUS));

   return TRUE;
}

BOOL SystemRestorePointCancel()
{
    if (g_SMgrStatus.llSequenceNumber == 0)
    {
        return TRUE;
    }

    // Restore Point Spec to cancel the previous restore point.
     g_RestPtInfo.dwEventType=END_SYSTEM_CHANGE;
     g_RestPtInfo.dwRestorePtType=CANCELLED_OPERATION;
     g_RestPtInfo.llSequenceNumber=g_SMgrStatus.llSequenceNumber; 

    // Canceling the previous restore point
    if (!SRSetRestorePoint(&g_RestPtInfo, &g_SMgrStatus)) 
    {
        printf("Couldn't cancel restore point.\n");
        return FALSE;
    }

    printf("Restore point canceled. Restore point data:\n");
    printf("Sequence Number=%lld\n",g_SMgrStatus.llSequenceNumber);
    printf("Status=%u\n",g_SMgrStatus.nStatus);

    ZeroMemory(&g_SMgrStatus, sizeof(STATEMGRSTATUS));

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\appcompat\windowsupdate\installer\systemrestore.h ===
/*++

  Copyright (c) 2001 Microsoft Corporation

  Module Name:

    SystemRestore.h

  Abstract:

    Implements a function to set/clear
    a system restore point.

  Notes:

    Unicode only.

  History:

    04/09/2001      markder    Created
    
--*/

BOOL SystemRestorePointStart(BOOL bInstall);
BOOL SystemRestorePointEnd();
BOOL SystemRestorePointCancel();
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\appcompat\windowsupdate\installer\precomp.h ===
/*++

  Copyright (c) 2001 Microsoft Corporation

  Module Name:

    Precomp.h

  Abstract:

    Precompiled header file. Contains constants,
    function prototypes, macros, and structures used
    throughout the app.

  Notes:

    Unicode only.

  History:

    03/02/2001      rparsons    Created
    
--*/

#ifndef _X86_
#define _X86_
#endif

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>

#include <windows.h>
#include <imagehlp.h>
#include <shlwapi.h>
#include <aclapi.h>
#include <shellapi.h>
#include <setupapi.h>

extern "C" {
#include <spapip.h>
#include <sfcapip.h>
}

#include <stdio.h>
#include <stdarg.h>
#include <mscat.h>

#include "resource.h"
#include "eventlog.h"
#include "registry.h"
#include "enumdir.h"
#include "cqueue.h"
#include "wumsg.h"

#define ACCESS_READ  1
#define ACCESS_WRITE 2

#define ERROR    0
#define WARNING  1
#define TRACE    2

#define MAX_QUEUE_SIZE          MAX_PATH*2

#define INF_FILE_NAMEW          L"wuinst.inf"
#define INF_FILE_NAMEA          "wuinst.inf"

#define UNINST_INF_FILE_NAMEW   L"wuuninst.inf"
#define UNINST_INF_FILE_NAMEA   "wuuninst.inf"

#define INF_MASTER_SECTIONS     "Sections"

//
// Section names for install INF
//
#define INF_CAT_SECTION_NAME    "CatalogsToInstall"
#define INF_BACKUP_FILES        "Backup.Files"
#define INF_BACKUP_REGISTRY     "Backup.Registry"
#define INF_COPY_FILES          "Copy.Files"
#define INF_REGISTRATIONS       "Registrations"
#define INF_ADD_REGISTRY        "Add.Registry.Keys"
#define INF_VERSION_INFO        "Registry.Data"

//
// Section names for uninstall INF
//
#define INF_RESTORE_FILES       "Restore.Files"
#define INF_RESTORE_REGISTRY    "Restore.Registry.Keys"
#define INF_RESTORE_REGISTRYW   L"Restore.Registry.Keys"
#define INF_UNREGISTRATIONS     "UnRegistrations"
#define INF_UNREGISTRATIONSW    L"UnRegistrations"

//
// Common to both
//
#define INF_PROCESSES_TO_RUN    "ProcessesToRun"
#define INF_DELETE_REGISTRY     "Delete.Registry.Keys"
#define INF_DELETE_REGISTRYW    L"Delete.Registry.Keys"
#define INF_EXCLUDE             "Exclusions"

#define dwBackupFiles           ((DWORD)0x0001)
#define dwBackupRegistry        ((DWORD)0x0002)
#define dwDeleteRegistry        ((DWORD)0x0003)
#define dwCopyFiles             ((DWORD)0x0004)
#define dwRegistrations         ((DWORD)0x0005)
#define dwExclusionsInstall     ((DWORD)0x0006)
#define dwExclusionsUninstall   ((DWORD)0x0007)
#define dwRestoreFiles          ((DWORD)0x0008)
#define dwRestoreRegistry       ((DWORD)0x0009)
#define dwUnRegistrations       ((DWORD)0x0010)
#define dwAddRegistry           ((DWORD)0x0011) 

#define REG_DISPLAY_NAME        L"DisplayName"
#define REG_UNINSTALL_STRING    L"UninstallString"
#define UNINSTALL_SWITCH        L"-u"
#define REG_PROT_RENAMES        L"AllowProtectedRenames"
#define REG_ACTIVE_SETUP        L"SOFTWARE\\Microsoft\\Active Setup\\Installed Components"
#define REG_UNINSTALL           L"SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Uninstall"
#define REG_WINFP_PATH          L"SOFTWARE\\Policies\\Microsoft\\Windows NT\\Windows File Protection"
#define REG_WINLOGON_PATH       L"SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\Winlogon"
#define REG_INSTALL_SOURCES     L"SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Setup"
#define REG_SESSION_MANAGER     L"System\\CurrentControlSet\\Control\\Session Manager"

#define LOAD_STRING_FAILED      L"Unable to load a string from the module."

#define MALLOC(s) HeapAlloc(GetProcessHeap(),HEAP_ZERO_MEMORY,(s))
#define REALLOC(s,b) HeapReAlloc(GetProcessHeap(),HEAP_ZERO_MEMORY,(s),(b))
#define FREE(b)   HeapFree(GetProcessHeap(),0,(b))

//
// Structures
//
typedef struct _tagSETUPINFO {
    HINSTANCE           hInstance;
    HINF                hInf;
    UINT                nErrorLevel;
    BOOL                fInstall;
    BOOL                fQuiet;
    BOOL                fForceInstall;
    BOOL                fNoReboot;
    BOOL                fNoUninstall;
    BOOL                fEventSourceCreated;
    BOOL                fNeedToAdjustACL;
    BOOL                fOnWin2K;
    BOOL                fCanUninstall;
    BOOL                fSourceDirAdded;
    BOOL                fUpdateDllCache;
    WCHAR               wszDebugOut[2048];
    LPWSTR              lpwUninstallINFPath;
    LPWSTR              lpwInstallINFPath;
    LPWSTR              lpwExtractPath;
    LPWSTR              lpwMessageBoxTitle;
    LPWSTR              lpwPrettyAppName;
    LPWSTR              lpwInstallDirectory;
    LPWSTR              lpwUninstallDirectory;
    LPWSTR              lpwWindowsDirectory;
    LPWSTR              lpwSystem32Directory;
    LPWSTR              lpwEventLogSourceName;
    DWORD               dwRequiredFreeSpaceNoUninstall;
    DWORD               dwRequiredFreeSpaceWithUninstall;
    DWORDLONG           dwlUpdateVersion;
    CQueue              BackupFileQueue;
    CQueue              BackupRegistryQueue;
    CQueue              CopyFileQueue;
    CQueue              DeleteRegistryQueue;
    CQueue              RegistrationQueue;
    CQueue              ExclusionQueue;
    CQueue              RestoreRegistryQueue;
    CQueue              RestoreFileQueue;
    CQueue              AddRegistryQueue;
} SETUP_INFO, *LPSETUP_INFO;

//
// Functions contained in wumain.cpp
//
BOOL DoInstallation();
BOOL DoUninstallation();

//
// Functions contained in wuinst.cpp
//
int InstallCheckVersion();
BOOL InstallBackupFiles();
BOOL InstallCopyFiles();
BOOL InstallWriteUninstallKey();
BOOL InstallRunINFProcesses();
BOOL InstallGetSectionsFromINF();
BOOL InstallBackupRegistryKeys();
BOOL InstallRegistryData();

BOOL InstallCatalogFiles(
    IN HINF    hInf,
    IN LPCWSTR lpwSourcePath
    );

BOOL
InstallWFPFile(
    IN LPCWSTR lpwSourceFileName,
    IN LPCWSTR lpwDestFileName,
    IN LPCWSTR lpwDestFileNamePath,
    IN BOOL    fUpdateDllCache
    );

BOOL
InstallPrepareDirectory(
    IN LPWSTR lpwDirectoryPath,
    IN DWORD  dwAttributes
    );

//
// Functions contained in wufns.cpp
//
BOOL CommonDeleteRegistryKeys();
BOOL CommonEnableProtectedRenames();

BOOL CommonRegisterServers(
    IN BOOL fRegister
    );

BOOL
CommonRemoveDirectoryAndFiles(
    IN LPCWSTR lpwDirectoryPath,
    IN PVOID   pEnumerateParameter,
    IN BOOL    fRemoveDirectory,
    IN BOOL    fRemoveSubDirs
    );

LPWSTR
GetNextToken(
    IN LPWSTR lpwSourceString,
    IN LPCWSTR lpwSeparator
    );

BOOL 
ForceMove(
    IN LPCWSTR lpwSourceFileName,
    IN LPCWSTR lpwDestFileName
    );

BOOL
ForceDelete(
    IN LPCWSTR lpwFileName
    );

BOOL 
ForceCopy(
    IN LPCWSTR lpwSourceFileName,
    IN LPCWSTR lpwDestFileName
    );

BOOL
IsFileProtected(
    IN LPCWSTR lpwFileName
    );

DWORD
pInstallCatalogFile(
    IN LPCWSTR lpwCatalogFullPath,
    IN LPCWSTR lpwNewBaseName
    );

BOOL
GetVersionInfoFromImage(
    IN LPCWSTR     lpwFileName,
    OUT PDWORDLONG pdwVersion
    );

LPWSTR
CopyTempFile(
    IN LPCWSTR lpwSrcFileName,
    IN LPCWSTR lpwDestDir
    );

BOOL
ParseCommandLine();

BOOL
IsAnotherInstanceRunning(
    IN LPCWSTR lpwInstanceName
    );

BOOL
AdjustDirectoryPerms(
    IN LPWSTR lpwDirPath
    );

BOOL
DeleteOneFile(
    IN LPCWSTR          lpwPath,
    IN PWIN32_FIND_DATA pFindFileData,
    IN PVOID            pEnumerateParameter
    );

BOOL
MirrorDirectoryPerms(
    IN LPWSTR lpwSourceDir,
    IN LPWSTR lpwDestDir
    );

DWORD 
GetCatVersion(
    IN LPWSTR lpwCatName
    );

LPWSTR 
GetCurWorkingDirectory();

int 
IsUserAnAdministrator();

void
pUnicodeToAnsi(
    IN     LPCWSTR lpwUnicodeString,
    IN OUT LPSTR   lpAnsiString,
    IN     int     nLen
    );

void
pAnsiToUnicode(
    IN     LPCSTR lpAnsiString,
    IN OUT LPWSTR lpwUnicodeString,
    IN     int    nLen
    );

#if DBG
    void _cdecl Print(
        IN UINT   uLevel,
        IN LPWSTR lpwFmt,
        IN ...
        );
#else
    #define Print
#endif

BOOL
WUInitialize();

void
WUCleanup();

DWORDLONG
GetDiskSpaceFreeOnNTDrive();

BOOL 
DisplayErrMsg(
    IN HWND   hWnd,
    IN DWORD  dwMessageId, 
    IN LPWSTR lpwMessageArray
    );

BOOL
GetInfValue(
    IN  HINF    hInf,
    IN  LPCSTR  lpSectionName,
    IN  LPCSTR  lpKeyName,
    OUT PDWORD  pdwValue
    );

BOOL
VersionStringToNumber(
    IN LPCWSTR        lpwVersionString,
    IN OUT DWORDLONG *lpVersionNumber
    );

BOOL
LaunchProcessAndWait(
    IN  LPCWSTR lpwCommandLine,
    OUT PDWORD  pdwReturnCode
    );

BOOL 
ModifyTokenPrivilege(
    IN LPCWSTR lpwPrivilege,
    IN BOOL    fEnable
    );

BOOL 
ShutdownSystem(
    IN BOOL fForceClose,
    IN BOOL fReboot
    );

BOOL SaveEntryToINF(
    IN LPCWSTR lpwSectionName,
    IN LPCWSTR lpwKeyName,
    IN LPCWSTR lpwEntryName,
    IN LPCWSTR lpwFileName
    );

//
// Functions contained in wulog.cpp
//
void
LogWUEvent(
    IN WORD    wType,
    IN DWORD   dwEventID,
    IN WORD    wNumStrings,
    IN LPCWSTR *lpwStrings
    );

BOOL 
LogEventDisplayError(
    IN WORD  wType,
    IN DWORD dwEventID,
    IN BOOL  fDisplayErr,
    IN BOOL  fCritical
    );

//
// Functions contained in wuuninst.cpp
//

BOOL UninstallGetSectionsFromINF();
BOOL UninstallRestoreRegistryKeys();
BOOL UninstallRemoveFiles();
BOOL UninstallRestoreFiles();
void UninstallCustomWorker();

void
UninstallDeleteSubKey(
    IN LPCWSTR lpwKey,
    IN LPCWSTR lpwSubKey
    );

BOOL
UninstallWFPFile(
    IN LPCWSTR lpwSourceFileName,
    IN LPCWSTR lpwDestFileName,
    IN LPCWSTR lpwDestFileNamePath,
    IN BOOL    fUpdateDllCache
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\core.inc ===
C_DEFINES=$(C_DEFINES)           \
          -DGENERIC_INPUT        \
          -DSUBPIXEL_MOUSE       \
          -DHUNGAPP_GHOSTING     \
          -DIMM_PER_LOGON        \
          -DAUTORUN_CURSOR       \
          -DMOUSE_IP             \
          -DGI_SINK              \
          -DMESSAGE_PUMP_HOOK    \
          -DBUG365290            \
          -DCUAS_ENABLE
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\appcompat\windowsupdate\installer\wuinst.cpp ===
/*++

  Copyright (c) 2001 Microsoft Corporation

  Module Name:

    Duinst.cpp

  Abstract:

    Contains the main installation code
    used by the app.

  Notes:

    Unicode only.

  History:

    03/02/2001      rparsons    Created
    
--*/

#include "precomp.h"

extern SETUP_INFO g_si;

/*++

  Routine Description:

    Determines if a newer version of our package
    exists on the target

  Arguments:

    None

  Return Value:

    TRUE if the installation should take place
    FALSE if the installation should not take place
    -1 on failure

--*/
int
InstallCheckVersion()
{
    BOOL        fReturn = FALSE;
    CRegistry   creg;
    DWORDLONG   dwlPackageVersion = 0;
    DWORDLONG   dwlInstalledVersion = 0;
    char        szActiveSetupKey[MAX_PATH] = "";
    char        szBuffer[MAX_PATH*3] = "";
    WCHAR       wszActiveSetupKey[MAX_PATH] = L"";
    WCHAR       wszPackageVersion[MAX_PATH] = L"";
    LPWSTR      lpwInstalledVersion = NULL;

    //
    // Get the registry key path from the INF
    //
    fReturn = SetupGetLineTextA(NULL,
                                g_si.hInf,
                                "Strings",
                                "ActiveSetupKey",
                                szActiveSetupKey,
                                sizeof(szActiveSetupKey),
                                NULL);

    if (!fReturn) {
        return -1;
    }

    pAnsiToUnicode(szActiveSetupKey, wszActiveSetupKey, MAX_PATH);

    //
    // Determine if a package is already installed 
    //
    fReturn = creg.IsRegistryKeyPresent(HKEY_LOCAL_MACHINE,
                                        wszActiveSetupKey);

    if (!fReturn) {
        return TRUE;
    }

    //
    // A package is installed - determine the version
    //
    lpwInstalledVersion = creg.GetString(HKEY_LOCAL_MACHINE,
                                         wszActiveSetupKey,
                                         L"Version",
                                         TRUE);

    if (NULL == lpwInstalledVersion) {
        return -1;
    }

    //
    // Convert the installed version string to a number
    //
    VersionStringToNumber(lpwInstalledVersion, &dwlInstalledVersion);

    creg.Free(lpwInstalledVersion);

    //
    // Now scan the INF AddReg data to determine if a newer version
    // is present with our package
    //
    if (0 != dwlInstalledVersion) {
        
        INFCONTEXT  InfContext;
        BOOL        fRetVal = FALSE;

        fRetVal = SetupFindFirstLineA(g_si.hInf,
                                      INF_VERSION_INFO,
                                      NULL,
                                      &InfContext);

        while (fRetVal) {
            
            if ((SetupGetStringFieldA(&InfContext,
                                      1, 
                                      szBuffer, sizeof(szBuffer),
                                      NULL) == FALSE) ||
                (_stricmp(szBuffer, "HKLM") != 0 )) {

                goto NextLine;
                
            }

            if ((SetupGetStringFieldA(&InfContext,
                                      2,
                                      szBuffer,
                                      sizeof(szBuffer),
                                      NULL) == FALSE) ||
                (_stricmp(szBuffer, szActiveSetupKey) != 0 )) {

                goto NextLine;
                
            }

            if ((SetupGetStringFieldA(&InfContext,
                                      3,
                                      szBuffer,
                                      sizeof(szBuffer),
                                      NULL) == TRUE) &&
                (_stricmp(szBuffer, "Version") == 0 )) {

                break;
            }

NextLine:
            
            fRetVal = SetupFindNextLine(&InfContext, &InfContext);
        }

        if (fRetVal) {

            if (SetupGetStringFieldA(&InfContext,
                                     5,
                                     szBuffer,
                                     sizeof(szBuffer),
                                     NULL) == TRUE) {

                pAnsiToUnicode(szBuffer, wszPackageVersion, MAX_PATH);                
                VersionStringToNumber(wszPackageVersion, &dwlPackageVersion);
                g_si.dwlUpdateVersion = dwlPackageVersion;
            }
        }        

        //
        // Compare the versions
        //
        if (dwlPackageVersion >= dwlInstalledVersion) {
            return TRUE;    // Package has newer than what's installed
        }
    }

    return FALSE;
}

/*++

  Routine Description:

    Installs catalog files, if there are any to install

  Arguments:

    hInf            -   Handle to the INF containing catalog names
    lpwSourcePath   -   The path where the file is currently located

  Return Value:

    TRUE on success, FALSE otherwise

--*/
BOOL
InstallCatalogFiles(
    IN HINF    hInf,
    IN LPCWSTR lpwSourcePath
    )
{
    DWORD       dwTargetCatVersion = 0;
    DWORD       dwSourceCatVersion = 0;
    DWORD       dwError = 0;
    BOOL        fReturn = FALSE;
    char        szCatFileName[MAX_PATH] = "";
    WCHAR       wszCatFileName[MAX_PATH] = L"";
    WCHAR       wszTargetCat[MAX_PATH] = L"";
    char        szSourceCat[MAX_PATH] = "";
    WCHAR       wszSourceCat[MAX_PATH] = L"";
    char        szTempCat[MAX_PATH] = "";
    WCHAR       wszTempCat[MAX_PATH] = L"";
    INFCONTEXT  InfContext;

    WCHAR       wszCatRoot[] = L"CatRoot\\{F750E6C3-38EE-11D1-85E5-00C04FC295EE}";

    //
    // Loop through all the lines in the CatalogsToInstall section,
    // verifying and installing each one
    //
    fReturn = SetupFindFirstLineA(hInf, INF_CAT_SECTION_NAME, NULL, &InfContext) &&
              SetupGetLineTextA(&InfContext, NULL, NULL, NULL, 
                               szCatFileName, MAX_PATH, NULL);
    
    while (fReturn) {

        pAnsiToUnicode(szCatFileName, wszCatFileName, MAX_PATH);

        //
        // Get paths to src and dest, compare versions,
        // and do the copy if necessary
        //
        wsprintf(wszSourceCat, L"%s\\%s", g_si.lpwExtractPath, wszCatFileName);
        
        wsprintf(wszTargetCat, L"%s\\%s\\%s", g_si.lpwSystem32Directory,
                 wszCatRoot, wszCatFileName);

        wsprintf(wszTempCat, L"%s\\%s", g_si.lpwWindowsDirectory,
                 wszCatFileName);

        dwTargetCatVersion = GetCatVersion(wszTargetCat);
        dwSourceCatVersion = GetCatVersion(wszSourceCat);

        if (dwTargetCatVersion > dwSourceCatVersion) {

            // If the SP?.CAT on the target is greater than ours
            // don't install ours
            Print(TRACE, L"[InstallCatalogFiles] Not installing older catalog\n");
            return TRUE;
        }

        pUnicodeToAnsi(wszSourceCat, szSourceCat, MAX_PATH);
        pUnicodeToAnsi(wszTempCat, szTempCat, MAX_PATH);

        //
        // Put the CAT file in the Windows directory
        //
        dwError = SetupDecompressOrCopyFileA(szSourceCat,
                                             szTempCat,
                                             NULL);
        
        if (NO_ERROR == dwError) {
                
            //
            // Perform the installation using the approriate function
            //
            dwError = pInstallCatalogFile(wszTempCat, wszCatFileName);

            if (NO_ERROR != dwError) {
                
                Print(ERROR,
                      L"[InstallCatalogFiles] Failed to install catalog %s\n",
                      wszTempCat);
                return FALSE;
            }
        }
        
        DeleteFile(wszTempCat);       // clean up copied-over file
        
        fReturn = SetupFindNextLine(&InfContext, &InfContext) &&
                  SetupGetLineTextA(&InfContext, NULL, NULL, NULL,
                                    szCatFileName, MAX_PATH, NULL);
    }
    
    return TRUE;
}

/*++

  Routine Description:

    Creates the uninstall key in the registry

  Arguments:

    None
    
  Return Value:

    TRUE on success, FALSE otherwise

--*/
BOOL
InstallWriteUninstallKey()
{
    BOOL        fReturn = FALS