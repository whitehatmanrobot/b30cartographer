ctivationAgentInfo_GetActivationAgents(This,prgSidList)	\
    (This)->lpVtbl -> GetActivationAgents(This,prgSidList)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IActivationAgentInfo_AddActivationAgent_Proxy( 
    IActivationAgentInfo * This,
    /* [in] */ PSIDLIST pSidList);


void __RPC_STUB IActivationAgentInfo_AddActivationAgent_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActivationAgentInfo_GetActivationAgentCount_Proxy( 
    IActivationAgentInfo * This,
    /* [out] */ ULONG *pulCount);


void __RPC_STUB IActivationAgentInfo_GetActivationAgentCount_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActivationAgentInfo_GetActivationAgents_Proxy( 
    IActivationAgentInfo * This,
    /* [out] */ PSIDLIST **prgSidList);


void __RPC_STUB IActivationAgentInfo_GetActivationAgents_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IActivationAgentInfo_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_activate_0125 */
/* [local] */ 

typedef /* [public][public][public][public][public][public] */ 
enum __MIDL___MIDL_itf_activate_0125_0001
    {	ST_SERVER	= 1,
	ST_OLDSURROGATE	= ST_SERVER + 1,
	ST_COMPLUSAPP	= ST_OLDSURROGATE + 1,
	ST_SERVICE	= ST_COMPLUSAPP + 1
    } 	ServerType;

typedef /* [public][public][public][public][public][public] */ 
enum __MIDL___MIDL_itf_activate_0125_0002
    {	SIT_RUNAS_SPECIFIC_USER	= 1,
	SIT_RUNAS_INTERACTIVE	= SIT_RUNAS_SPECIFIC_USER + 1
    } 	ServerIDType;

typedef /* [public] */ 
enum __MIDL___MIDL_itf_activate_0125_0003
    {	SPIF_COMPLUS	= 1,
	SPIF_SUSPENDED	= 2,
	SPIF_RETIRED	= 4,
	SPIF_READY	= 8,
	SPIF_PAUSED	= 16
    } 	SCMProcessInfoFlags;

typedef /* [public][public][public][public] */ struct __MIDL___MIDL_itf_activate_0125_0004
    {
    ULONG ulNumClasses;
    GUID *pCLSIDs;
    DWORD pidProcess;
    HANDLE hProcess;
    HANDLE hImpersonationToken;
    WCHAR *pwszWinstaDesktop;
    DWORD dwState;
    GUID AppId;
    ServerType ServerType;
    ServerIDType ServerID;
    FILETIME ftCreated;
    } 	SCMProcessInfo;

typedef struct __MIDL___MIDL_itf_activate_0125_0004 *PSCMProcessInfo;



extern RPC_IF_HANDLE __MIDL_itf_activate_0125_ClientIfHandle;
extern RPC_IF_HANDLE __MIDL_itf_activate_0125_ServerIfHandle;

#ifndef __IEnumSCMProcessInfo_INTERFACE_DEFINED__
#define __IEnumSCMProcessInfo_INTERFACE_DEFINED__

/* interface IEnumSCMProcessInfo */
/* [unique][uuid][object][local] */ 


EXTERN_C const IID IID_IEnumSCMProcessInfo;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("8bbbd026-de4d-46b7-8a90-72c66eb64ad6")
    IEnumSCMProcessInfo : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Next( 
            /* [in] */ ULONG cElems,
            /* [length_is][size_is][out] */ SCMProcessInfo **ppSCMProcessInfo,
            /* [out] */ ULONG *pcFetched) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Skip( 
            /* [in] */ ULONG cElems) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Reset( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Clone( 
            /* [out] */ IEnumSCMProcessInfo **ppESPI) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IEnumSCMProcessInfoVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IEnumSCMProcessInfo * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IEnumSCMProcessInfo * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IEnumSCMProcessInfo * This);
        
        HRESULT ( STDMETHODCALLTYPE *Next )( 
            IEnumSCMProcessInfo * This,
            /* [in] */ ULONG cElems,
            /* [length_is][size_is][out] */ SCMProcessInfo **ppSCMProcessInfo,
            /* [out] */ ULONG *pcFetched);
        
        HRESULT ( STDMETHODCALLTYPE *Skip )( 
            IEnumSCMProcessInfo * This,
            /* [in] */ ULONG cElems);
        
        HRESULT ( STDMETHODCALLTYPE *Reset )( 
            IEnumSCMProcessInfo * This);
        
        HRESULT ( STDMETHODCALLTYPE *Clone )( 
            IEnumSCMProcessInfo * This,
            /* [out] */ IEnumSCMProcessInfo **ppESPI);
        
        END_INTERFACE
    } IEnumSCMProcessInfoVtbl;

    interface IEnumSCMProcessInfo
    {
        CONST_VTBL struct IEnumSCMProcessInfoVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IEnumSCMProcessInfo_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IEnumSCMProcessInfo_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IEnumSCMProcessInfo_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IEnumSCMProcessInfo_Next(This,cElems,ppSCMProcessInfo,pcFetched)	\
    (This)->lpVtbl -> Next(This,cElems,ppSCMProcessInfo,pcFetched)

#define IEnumSCMProcessInfo_Skip(This,cElems)	\
    (This)->lpVtbl -> Skip(This,cElems)

#define IEnumSCMProcessInfo_Reset(This)	\
    (This)->lpVtbl -> Reset(This)

#define IEnumSCMProcessInfo_Clone(This,ppESPI)	\
    (This)->lpVtbl -> Clone(This,ppESPI)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IEnumSCMProcessInfo_Next_Proxy( 
    IEnumSCMProcessInfo * This,
    /* [in] */ ULONG cElems,
    /* [length_is][size_is][out] */ SCMProcessInfo **ppSCMProcessInfo,
    /* [out] */ ULONG *pcFetched);


void __RPC_STUB IEnumSCMProcessInfo_Next_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumSCMProcessInfo_Skip_Proxy( 
    IEnumSCMProcessInfo * This,
    /* [in] */ ULONG cElems);


void __RPC_STUB IEnumSCMProcessInfo_Skip_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumSCMProcessInfo_Reset_Proxy( 
    IEnumSCMProcessInfo * This);


void __RPC_STUB IEnumSCMProcessInfo_Reset_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumSCMProcessInfo_Clone_Proxy( 
    IEnumSCMProcessInfo * This,
    /* [out] */ IEnumSCMProcessInfo **ppESPI);


void __RPC_STUB IEnumSCMProcessInfo_Clone_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IEnumSCMProcessInfo_INTERFACE_DEFINED__ */


#ifndef __ISCMProcessControl_INTERFACE_DEFINED__
#define __ISCMProcessControl_INTERFACE_DEFINED__

/* interface ISCMProcessControl */
/* [unique][uuid][object][local] */ 


EXTERN_C const IID IID_ISCMProcessControl;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("7629798c-f1e6-4ef0-b521-dc466fded209")
    ISCMProcessControl : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE FindApplication( 
            /* [in] */ REFGUID rappid,
            /* [out] */ IEnumSCMProcessInfo **ppESPI) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE FindClass( 
            /* [in] */ REFCLSID rclsid,
            /* [out] */ IEnumSCMProcessInfo **ppESPI) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE FindProcess( 
            /* [in] */ DWORD pid,
            /* [out] */ SCMProcessInfo **pSCMProcessInfo) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SuspendApplication( 
            /* [in] */ REFGUID rappid) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SuspendClass( 
            /* [in] */ REFCLSID rclsid) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SuspendProcess( 
            /* [in] */ DWORD ppid) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ResumeApplication( 
            /* [in] */ REFGUID rappid) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ResumeClass( 
            /* [in] */ REFCLSID rclsid) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ResumeProcess( 
            /* [in] */ DWORD pid) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE RetireApplication( 
            /* [in] */ REFGUID rappid) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE RetireClass( 
            /* [in] */ REFCLSID rclsid) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE RetireProcess( 
            /* [in] */ DWORD pid) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE FreeSCMProcessInfo( 
            SCMProcessInfo **ppSCMProcessInfo) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ISCMProcessControlVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ISCMProcessControl * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ISCMProcessControl * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ISCMProcessControl * This);
        
        HRESULT ( STDMETHODCALLTYPE *FindApplication )( 
            ISCMProcessControl * This,
            /* [in] */ REFGUID rappid,
            /* [out] */ IEnumSCMProcessInfo **ppESPI);
        
        HRESULT ( STDMETHODCALLTYPE *FindClass )( 
            ISCMProcessControl * This,
            /* [in] */ REFCLSID rclsid,
            /* [out] */ IEnumSCMProcessInfo **ppESPI);
        
        HRESULT ( STDMETHODCALLTYPE *FindProcess )( 
            ISCMProcessControl * This,
            /* [in] */ DWORD pid,
            /* [out] */ SCMProcessInfo **pSCMProcessInfo);
        
        HRESULT ( STDMETHODCALLTYPE *SuspendApplication )( 
            ISCMProcessControl * This,
            /* [in] */ REFGUID rappid);
        
        HRESULT ( STDMETHODCALLTYPE *SuspendClass )( 
            ISCMProcessControl * This,
            /* [in] */ REFCLSID rclsid);
        
        HRESULT ( STDMETHODCALLTYPE *SuspendProcess )( 
            ISCMProcessControl * This,
            /* [in] */ DWORD ppid);
        
        HRESULT ( STDMETHODCALLTYPE *ResumeApplication )( 
            ISCMProcessControl * This,
            /* [in] */ REFGUID rappid);
        
        HRESULT ( STDMETHODCALLTYPE *ResumeClass )( 
            ISCMProcessControl * This,
            /* [in] */ REFCLSID rclsid);
        
        HRESULT ( STDMETHODCALLTYPE *ResumeProcess )( 
            ISCMProcessControl * This,
            /* [in] */ DWORD pid);
        
        HRESULT ( STDMETHODCALLTYPE *RetireApplication )( 
            ISCMProcessControl * This,
            /* [in] */ REFGUID rappid);
        
        HRESULT ( STDMETHODCALLTYPE *RetireClass )( 
            ISCMProcessControl * This,
            /* [in] */ REFCLSID rclsid);
        
        HRESULT ( STDMETHODCALLTYPE *RetireProcess )( 
            ISCMProcessControl * This,
            /* [in] */ DWORD pid);
        
        HRESULT ( STDMETHODCALLTYPE *FreeSCMProcessInfo )( 
            ISCMProcessControl * This,
            SCMProcessInfo **ppSCMProcessInfo);
        
        END_INTERFACE
    } ISCMProcessControlVtbl;

    interface ISCMProcessControl
    {
        CONST_VTBL struct ISCMProcessControlVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ISCMProcessControl_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ISCMProcessControl_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ISCMProcessControl_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ISCMProcessControl_FindApplication(This,rappid,ppESPI)	\
    (This)->lpVtbl -> FindApplication(This,rappid,ppESPI)

#define ISCMProcessControl_FindClass(This,rclsid,ppESPI)	\
    (This)->lpVtbl -> FindClass(This,rclsid,ppESPI)

#define ISCMProcessControl_FindProcess(This,pid,pSCMProcessInfo)	\
    (This)->lpVtbl -> FindProcess(This,pid,pSCMProcessInfo)

#define ISCMProcessControl_SuspendApplication(This,rappid)	\
    (This)->lpVtbl -> SuspendApplication(This,rappid)

#define ISCMProcessControl_SuspendClass(This,rclsid)	\
    (This)->lpVtbl -> SuspendClass(This,rclsid)

#define ISCMProcessControl_SuspendProcess(This,ppid)	\
    (This)->lpVtbl -> SuspendProcess(This,ppid)

#define ISCMProcessControl_ResumeApplication(This,rappid)	\
    (This)->lpVtbl -> ResumeApplication(This,rappid)

#define ISCMProcessControl_ResumeClass(This,rclsid)	\
    (This)->lpVtbl -> ResumeClass(This,rclsid)

#define ISCMProcessControl_ResumeProcess(This,pid)	\
    (This)->lpVtbl -> ResumeProcess(This,pid)

#define ISCMProcessControl_RetireApplication(This,rappid)	\
    (This)->lpVtbl -> RetireApplication(This,rappid)

#define ISCMProcessControl_RetireClass(This,rclsid)	\
    (This)->lpVtbl -> RetireClass(This,rclsid)

#define ISCMProcessControl_RetireProcess(This,pid)	\
    (This)->lpVtbl -> RetireProcess(This,pid)

#define ISCMProcessControl_FreeSCMProcessInfo(This,ppSCMProcessInfo)	\
    (This)->lpVtbl -> FreeSCMProcessInfo(This,ppSCMProcessInfo)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE ISCMProcessControl_FindApplication_Proxy( 
    ISCMProcessControl * This,
    /* [in] */ REFGUID rappid,
    /* [out] */ IEnumSCMProcessInfo **ppESPI);


void __RPC_STUB ISCMProcessControl_FindApplication_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ISCMProcessControl_FindClass_Proxy( 
    ISCMProcessControl * This,
    /* [in] */ REFCLSID rclsid,
    /* [out] */ IEnumSCMProcessInfo **ppESPI);


void __RPC_STUB ISCMProcessControl_FindClass_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ISCMProcessControl_FindProcess_Proxy( 
    ISCMProcessControl * This,
    /* [in] */ DWORD pid,
    /* [out] */ SCMProcessInfo **pSCMProcessInfo);


void __RPC_STUB ISCMProcessControl_FindProcess_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ISCMProcessControl_SuspendApplication_Proxy( 
    ISCMProcessControl * This,
    /* [in] */ REFGUID rappid);


void __RPC_STUB ISCMProcessControl_SuspendApplication_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ISCMProcessControl_SuspendClass_Proxy( 
    ISCMProcessControl * This,
    /* [in] */ REFCLSID rclsid);


void __RPC_STUB ISCMProcessControl_SuspendClass_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ISCMProcessControl_SuspendProcess_Proxy( 
    ISCMProcessControl * This,
    /* [in] */ DWORD ppid);


void __RPC_STUB ISCMProcessControl_SuspendProcess_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ISCMProcessControl_ResumeApplication_Proxy( 
    ISCMProcessControl * This,
    /* [in] */ REFGUID rappid);


void __RPC_STUB ISCMProcessControl_ResumeApplication_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ISCMProcessControl_ResumeClass_Proxy( 
    ISCMProcessControl * This,
    /* [in] */ REFCLSID rclsid);


void __RPC_STUB ISCMProcessControl_ResumeClass_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ISCMProcessControl_ResumeProcess_Proxy( 
    ISCMProcessControl * This,
    /* [in] */ DWORD pid);


void __RPC_STUB ISCMProcessControl_ResumeProcess_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ISCMProcessControl_RetireApplication_Proxy( 
    ISCMProcessControl * This,
    /* [in] */ REFGUID rappid);


void __RPC_STUB ISCMProcessControl_RetireApplication_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ISCMProcessControl_RetireClass_Proxy( 
    ISCMProcessControl * This,
    /* [in] */ REFCLSID rclsid);


void __RPC_STUB ISCMProcessControl_RetireClass_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ISCMProcessControl_RetireProcess_Proxy( 
    ISCMProcessControl * This,
    /* [in] */ DWORD pid);


void __RPC_STUB ISCMProcessControl_RetireProcess_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ISCMProcessControl_FreeSCMProcessInfo_Proxy( 
    ISCMProcessControl * This,
    SCMProcessInfo **ppSCMProcessInfo);


void __RPC_STUB ISCMProcessControl_FreeSCMProcessInfo_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ISCMProcessControl_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_activate_0127 */
/* [local] */ 


EXTERN_C const CLSID CLSID_RPCSSInfo;


////////////////////////////////////////////////////////////////////////
//
// API for accessing SCM's objects (exported from rpcss.dll)
//
typedef HRESULT (__stdcall *PFNGETRPCSSINFO)(REFCLSID, REFIID, void**);
//
////////////////////////////////////////////////////////////////////////



extern RPC_IF_HANDLE __MIDL_itf_activate_0127_ClientIfHandle;
extern RPC_IF_HANDLE __MIDL_itf_activate_0127_ServerIfHandle;

/* Additional Prototypes for ALL interfaces */

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\public\internal\base\inc\_qsort.h ===
/***
*qsort.c - quicksort algorithm; qsort() library function for sorting arrays
*
*       Copyright (c) 1985-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*       To implement the qsort() routine for sorting arrays.
*
*Revision History:
*       06-22-84  RN    author
*       03-25-85  RN    added pre-check for elements already in order to
*                       eliminate worst-case behavior.
*       05-18-86  TC    changed to recurse on the smallest piece to avoid
*                       piece. unneccesary stack usage, and to iterate on
*                       largest
*       01-09-87  BCM   fixed huge-array case where (num-1) * wid computation
*                       was overflowing (large/compact models only)
*       06-13-89  PHG   made more efficient, many more comments, removed
*                       recursion
*       10-30-89  JCR   Added _cdecl to prototypes
*       03-15-90  GJF   Replaced _cdecl with _CALLTYPE1 and added #include
*                       <cruntime.h>. Also, fixed the copyright.
*       04-05-90  GJF   Made shortsort() and swap() _CALLTYPE4. Also, added
*                       #include <search.h>.
*       10-04-90  GJF   New-style function declarators.
*       12-28-90  SRW   Added _CRUISER_ conditional around check_stack pragmas
*       01-24-91  SRW   Added missing close comment in swap procedure
*       11-19-91  GJF   Do the swap one character at a time to avoid alignment
*                       woes.
*       04-06-93  SKS   Replace _CRTAPI* with __cdecl
*       09-06-94  CFW   Remove Cruiser support.
*       02-27-98  RKP   Add 64 bit support.
*       01-04-99  GJF   Changes for 64-bit size_t.
*       05-10-00  PML   Performance improvements - middle-of-3 pivot choice,
*                       widen middle range equal to pivot, don't swap pivot to
*                       beginning (vs7#99674).
*       08-08-00  PML   Avoid calling comp(p,p), since some existing code
*                       doesn't expect that (vs7#123134).
*
*******************************************************************************/

#include <stdlib.h>
#include <search.h>
#ifdef NEW_QSORT_NAME
#define qsort NEW_QSORT_NAME
#endif

/* Always compile this module for speed, not size */
#pragma optimize("t", on)

/* prototypes for local routines */
static void __cdecl shortsort(char *lo, char *hi, size_t width,
                int (__cdecl *comp)(const void *, const void *));
static void __cdecl swap(char *p, char *q, size_t width);

/* this parameter defines the cutoff between using quick sort and
   insertion sort for arrays; arrays with lengths shorter or equal to the
   below value use insertion sort */

#define CUTOFF 8            /* testing shows that this is good value */

/***
*qsort(base, num, wid, comp) - quicksort function for sorting arrays
*
*Purpose:
*       quicksort the array of elements
*       side effects:  sorts in place
*       maximum array size is number of elements times size of elements,
*       but is limited by the virtual address space of the processor
*
*Entry:
*       char *base = pointer to base of array
*       size_t num  = number of elements in the array
*       size_t width = width in bytes of each array element
*       int (*comp)() = pointer to function returning analog of strcmp for
*               strings, but supplied by user for comparing the array elements.
*               it accepts 2 pointers to elements and returns neg if 1<2, 0 if
*               1=2, pos if 1>2.
*
*Exit:
*       returns void
*
*Exceptions:
*
*******************************************************************************/

/* sort the array between lo and hi (inclusive) */

#define STKSIZ (8*sizeof(void*) - 2)

void __cdecl qsort (
    void *base,
    size_t num,
    size_t width,
    int (__cdecl *comp)(const void *, const void *)
    )
{
    /* Note: the number of stack entries required is no more than
       1 + log2(num), so 30 is sufficient for any array */
    char *lo, *hi;              /* ends of sub-array currently sorting */
    char *mid;                  /* points to middle of subarray */
    char *loguy, *higuy;        /* traveling pointers for partition step */
    size_t size;                /* size of the sub-array */
    char *lostk[STKSIZ], *histk[STKSIZ];
    int stkptr;                 /* stack for saving sub-array to be processed */

    if (num < 2 || width == 0)
        return;                 /* nothing to do */

    stkptr = 0;                 /* initialize stack */

    lo = (char *)base;
    hi = (char *)base + width * (num-1);        /* initialize limits */

    /* this entry point is for pseudo-recursion calling: setting
       lo and hi and jumping to here is like recursion, but stkptr is
       preserved, locals aren't, so we preserve stuff on the stack */
recurse:

    size = (hi - lo) / width + 1;        /* number of el's to sort */

    /* below a certain size, it is faster to use a O(n^2) sorting method */
    if (size <= CUTOFF) {
        shortsort(lo, hi, width, comp);
    }
    else {
        /* First we pick a partitioning element.  The efficiency of the
           algorithm demands that we find one that is approximately the median
           of the values, but also that we select one fast.  We choose the
           median of the first, middle, and last elements, to avoid bad
           performance in the face of already sorted data, or data that is made
           up of multiple sorted runs appended together.  Testing shows that a
           median-of-three algorithm provides better performance than simply
           picking the middle element for the latter case. */

        mid = lo + (size / 2) * width;      /* find middle element */

        /* Sort the first, middle, last elements into order */
        if (comp(lo, mid) > 0) {
            swap(lo, mid, width);
        }
        if (comp(lo, hi) > 0) {
            swap(lo, hi, width);
        }
        if (comp(mid, hi) > 0) {
            swap(mid, hi, width);
        }

        /* We now wish to partition the array into three pieces, one consisting
           of elements <= partition element, one of elements equal to the
           partition element, and one of elements > than it.  This is done
           below; comments indicate conditions established at every step. */

        loguy = lo;
        higuy = hi;

        /* Note that higuy decreases and loguy increases on every iteration,
           so loop must terminate. */
        for (;;) {
            /* lo <= loguy < hi, lo < higuy <= hi,
               A[i] <= A[mid] for lo <= i <= loguy,
               A[i] > A[mid] for higuy <= i < hi,
               A[hi] >= A[mid] */

            /* The doubled loop is to avoid calling comp(mid,mid), since some
               existing comparison funcs don't work when passed the same
               value for both pointers. */

            if (mid > loguy) {
                do  {
                    loguy += width;
                } while (loguy < mid && comp(loguy, mid) <= 0);
            }
            if (mid <= loguy) {
                do  {
                    loguy += width;
                } while (loguy <= hi && comp(loguy, mid) <= 0);
            }

            /* lo < loguy <= hi+1, A[i] <= A[mid] for lo <= i < loguy,
               either loguy > hi or A[loguy] > A[mid] */

            do  {
                higuy -= width;
            } while (higuy > mid && comp(higuy, mid) > 0);

            /* lo <= higuy < hi, A[i] > A[mid] for higuy < i < hi,
               either higuy == lo or A[higuy] <= A[mid] */

            if (higuy < loguy)
                break;

            /* if loguy > hi or higuy == lo, then we would have exited, so
               A[loguy] > A[mid], A[higuy] <= A[mid],
               loguy <= hi, higuy > lo */

            swap(loguy, higuy, width);

            /* If the partition element was moved, follow it.  Only need
               to check for mid == higuy, since before the swap,
               A[loguy] > A[mid] implies loguy != mid. */

            if (mid == higuy)
                mid = loguy;

            /* A[loguy] <= A[mid], A[higuy] > A[mid]; so condition at top
               of loop is re-established */
        }

        /*     A[i] <= A[mid] for lo <= i < loguy,
               A[i] > A[mid] for higuy < i < hi,
               A[hi] >= A[mid]
               higuy < loguy
           implying:
               higuy == loguy-1
               or higuy == hi - 1, loguy == hi + 1, A[hi] == A[mid] */

        /* Find adjacent elements equal to the partition element.  The
           doubled loop is to avoid calling comp(mid,mid), since some
           existing comparison funcs don't work when passed the same value
           for both pointers. */

        higuy += width;
        if (mid < higuy) {
            do  {
                higuy -= width;
            } while (higuy > mid && comp(higuy, mid) == 0);
        }
        if (mid >= higuy) {
            do  {
                higuy -= width;
            } while (higuy > lo && comp(higuy, mid) == 0);
        }

        /* OK, now we have the following:
              higuy < loguy
              lo <= higuy <= hi
              A[i]  <= A[mid] for lo <= i <= higuy
              A[i]  == A[mid] for higuy < i < loguy
              A[i]  >  A[mid] for loguy <= i < hi
              A[hi] >= A[mid] */

        /* We've finished the partition, now we want to sort the subarrays
           [lo, higuy] and [loguy, hi].
           We do the smaller one first to minimize stack usage.
           We only sort arrays of length 2 or more.*/

        if ( higuy - lo >= hi - loguy ) {
            if (lo < higuy) {
                lostk[stkptr] = lo;
                histk[stkptr] = higuy;
                ++stkptr;
            }                           /* save big recursion for later */

            if (loguy < hi) {
                lo = loguy;
                goto recurse;           /* do small recursion */
            }
        }
        else {
            if (loguy < hi) {
                lostk[stkptr] = loguy;
                histk[stkptr] = hi;
                ++stkptr;               /* save big recursion for later */
            }

            if (lo < higuy) {
                hi = higuy;
                goto recurse;           /* do small recursion */
            }
        }
    }

    /* We have sorted the array, except for any pending sorts on the stack.
       Check if there are any, and do them. */

    --stkptr;
    if (stkptr >= 0) {
        lo = lostk[stkptr];
        hi = histk[stkptr];
        goto recurse;           /* pop subarray from stack */
    }
    else
        return;                 /* all subarrays done */
}


/***
*shortsort(hi, lo, width, comp) - insertion sort for sorting short arrays
*
*Purpose:
*       sorts the sub-array of elements between lo and hi (inclusive)
*       side effects:  sorts in place
*       assumes that lo < hi
*
*Entry:
*       char *lo = pointer to low element to sort
*       char *hi = pointer to high element to sort
*       size_t width = width in bytes of each array element
*       int (*comp)() = pointer to function returning analog of strcmp for
*               strings, but supplied by user for comparing the array elements.
*               it accepts 2 pointers to elements and returns neg if 1<2, 0 if
*               1=2, pos if 1>2.
*
*Exit:
*       returns void
*
*Exceptions:
*
*******************************************************************************/

static void __cdecl shortsort (
    char *lo,
    char *hi,
    size_t width,
    int (__cdecl *comp)(const void *, const void *)
    )
{
    char *p, *max;

    /* Note: in assertions below, i and j are alway inside original bound of
       array to sort. */

    while (hi > lo) {
        /* A[i] <= A[j] for i <= j, j > hi */
        max = lo;
        for (p = lo+width; p <= hi; p += width) {
            /* A[i] <= A[max] for lo <= i < p */
            if (comp(p, max) > 0) {
                max = p;
            }
            /* A[i] <= A[max] for lo <= i <= p */
        }

        /* A[i] <= A[max] for lo <= i <= hi */

        swap(max, hi, width);

        /* A[i] <= A[hi] for i <= hi, so A[i] <= A[j] for i <= j, j >= hi */

        hi -= width;

        /* A[i] <= A[j] for i <= j, j > hi, loop top condition established */
    }
    /* A[i] <= A[j] for i <= j, j > lo, which implies A[i] <= A[j] for i < j,
       so array is sorted */
}


/***
*swap(a, b, width) - swap two elements
*
*Purpose:
*       swaps the two array elements of size width
*
*Entry:
*       char *a, *b = pointer to two elements to swap
*       size_t width = width in bytes of each array element
*
*Exit:
*       returns void
*
*Exceptions:
*
*******************************************************************************/

static void __cdecl swap (
    char *a,
    char *b,
    size_t width
    )
{
    char tmp;

    if ( a != b )
        /* Do the swap one character at a time to avoid potential alignment
           problems. */
        while ( width-- ) {
            tmp = *a;
            *a++ = *b;
            *b++ = tmp;
        }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\public\internal\base\inc\zlib.h ===
/* zlib.h -- interface of the 'zlib' general purpose compression library
  version 1.1.4, March 11th, 2002

  Copyright (C) 1995-2002 Jean-loup Gailly and Mark Adler

  This software is provided 'as-is', without any express or implied
  warranty.  In no event will the authors be held liable for any damages
  arising from the use of this software.

  Permission is granted to anyone to use this software for any purpose,
  including commercial applications, and to alter it and redistribute it
  freely, subject to the following restrictions:

  1. The origin of this software must not be misrepresented; you must not
     claim that you wrote the original software. If you use this software
     in a product, an acknowledgment in the product documentation would be
     appreciated but is not required.
  2. Altered source versions must be plainly marked as such, and must not be
     misrepresented as being the original software.
  3. This notice may not be removed or altered from any source distribution.

  Jean-loup Gailly        Mark Adler
  jloup@gzip.org          madler@alumni.caltech.edu


  The data format used by the zlib library is described by RFCs (Request for
  Comments) 1950 to 1952 in the files ftp://ds.internic.net/rfc/rfc1950.txt
  (zlib format), rfc1951.txt (deflate format) and rfc1952.txt (gzip format).
*/

#ifndef _ZLIB_H
#define _ZLIB_H

#include "zconf.h"

#ifdef __cplusplus
extern "C" {
#endif

#define ZLIB_VERSION "1.1.4"

/* 
     The 'zlib' compression library provides in-memory compression and
  decompression functions, including integrity checks of the uncompressed
  data.  This version of the library supports only one compression method
  (deflation) but other algorithms will be added later and will have the same
  stream interface.

     Compression can be done in a single step if the buffers are large
  enough (for example if an input file is mmap'ed), or can be done by
  repeated calls of the compression function.  In the latter case, the
  application must provide more input and/or consume the output
  (providing more output space) before each call.

     The library also supports reading and writing files in gzip (.gz) format
  with an interface similar to that of stdio.

     The library does not install any signal handler. The decoder checks
  the consistency of the compressed data, so the library should never
  crash even in case of corrupted input.
*/

typedef voidpf (*alloc_func) OF((voidpf opaque, uInt items, uInt size));
typedef void   (*free_func)  OF((voidpf opaque, voidpf address));

struct internal_state;

typedef struct z_stream_s {
    Bytef    *next_in;  /* next input byte */
    uInt     avail_in;  /* number of bytes available at next_in */
    uLong    total_in;  /* total nb of input bytes read so far */

    Bytef    *next_out; /* next output byte should be put there */
    uInt     avail_out; /* remaining free space at next_out */
    uLong    total_out; /* total nb of bytes output so far */

    char     *msg;      /* last error message, NULL if no error */
    struct internal_state FAR *state; /* not visible by applications */

    alloc_func zalloc;  /* used to allocate the internal state */
    free_func  zfree;   /* used to free the internal state */
    voidpf     opaque;  /* private data object passed to zalloc and zfree */

    int     data_type;  /* best guess about the data type: ascii or binary */
    uLong   adler;      /* adler32 value of the uncompressed data */
    uLong   reserved;   /* reserved for future use */
} z_stream;

typedef z_stream FAR *z_streamp;

/*
   The application must update next_in and avail_in when avail_in has
   dropped to zero. It must update next_out and avail_out when avail_out
   has dropped to zero. The application must initialize zalloc, zfree and
   opaque before calling the init function. All other fields are set by the
   compression library and must not be updated by the application.

   The opaque value provided by the application will be passed as the first
   parameter for calls of zalloc and zfree. This can be useful for custom
   memory management. The compression library attaches no meaning to the
   opaque value.

   zalloc must return Z_NULL if there is not enough memory for the object.
   If zlib is used in a multi-threaded application, zalloc and zfree must be
   thread safe.

   On 16-bit systems, the functions zalloc and zfree must be able to allocate
   exactly 65536 bytes, but will not be required to allocate more than this
   if the symbol MAXSEG_64K is defined (see zconf.h). WARNING: On MSDOS,
   pointers returned by zalloc for objects of exactly 65536 bytes *must*
   have their offset normalized to zero. The default allocation function
   provided by this library ensures this (see zutil.c). To reduce memory
   requirements and avoid any allocation of 64K objects, at the expense of
   compression ratio, compile the library with -DMAX_WBITS=14 (see zconf.h).

   The fields total_in and total_out can be used for statistics or
   progress reports. After compression, total_in holds the total size of
   the uncompressed data and may be saved for use in the decompressor
   (particularly if the decompressor wants to decompress everything in
   a single step).
*/

                        /* constants */

#define Z_NO_FLUSH      0
#define Z_PARTIAL_FLUSH 1 /* will be removed, use Z_SYNC_FLUSH instead */
#define Z_SYNC_FLUSH    2
#define Z_FULL_FLUSH    3
#define Z_FINISH        4
/* Allowed flush values; see deflate() below for details */

#define Z_OK            0
#define Z_STREAM_END    1
#define Z_NEED_DICT     2
#define Z_ERRNO        (-1)
#define Z_STREAM_ERROR (-2)
#define Z_DATA_ERROR   (-3)
#define Z_MEM_ERROR    (-4)
#define Z_BUF_ERROR    (-5)
#define Z_VERSION_ERROR (-6)
/* Return codes for the compression/decompression functions. Negative
 * values are errors, positive values are used for special but normal events.
 */

#define Z_NO_COMPRESSION         0
#define Z_BEST_SPEED             1
#define Z_BEST_COMPRESSION       9
#define Z_DEFAULT_COMPRESSION  (-1)
/* compression levels */

#define Z_FILTERED            1
#define Z_HUFFMAN_ONLY        2
#define Z_DEFAULT_STRATEGY    0
/* compression strategy; see deflateInit2() below for details */

#define Z_BINARY   0
#define Z_ASCII    1
#define Z_UNKNOWN  2
/* Possible values of the data_type field */

#define Z_DEFLATED   8
/* The deflate compression method (the only one supported in this version) */

#define Z_NULL  0  /* for initializing zalloc, zfree, opaque */

#define zlib_version zlibVersion()
/* for compatibility with versions < 1.0.2 */

                        /* basic functions */

ZEXTERN const char * ZEXPORT zlibVersion OF((void));
/* The application can compare zlibVersion and ZLIB_VERSION for consistency.
   If the first character differs, the library code actually used is
   not compatible with the zlib.h header file used by the application.
   This check is automatically made by deflateInit and inflateInit.
 */

/* 
ZEXTERN int ZEXPORT deflateInit OF((z_streamp strm, int level));

     Initializes the internal stream state for compression. The fields
   zalloc, zfree and opaque must be initialized before by the caller.
   If zalloc and zfree are set to Z_NULL, deflateInit updates them to
   use default allocation functions.

     The compression level must be Z_DEFAULT_COMPRESSION, or between 0 and 9:
   1 gives best speed, 9 gives best compression, 0 gives no compression at
   all (the input data is simply copied a block at a time).
   Z_DEFAULT_COMPRESSION requests a default compromise between speed and
   compression (currently equivalent to level 6).

     deflateInit returns Z_OK if success, Z_MEM_ERROR if there was not
   enough memory, Z_STREAM_ERROR if level is not a valid compression level,
   Z_VERSION_ERROR if the zlib library version (zlib_version) is incompatible
   with the version assumed by the caller (ZLIB_VERSION).
   msg is set to null if there is no error message.  deflateInit does not
   perform any compression: this will be done by deflate().
*/


ZEXTERN int ZEXPORT deflate OF((z_streamp strm, int flush));
/*
    deflate compresses as much data as possible, and stops when the input
  buffer becomes empty or the output buffer becomes full. It may introduce some
  output latency (reading input without producing any output) except when
  forced to flush.

    The detailed semantics are as follows. deflate performs one or both of the
  following actions:

  - Compress more input starting at next_in and update next_in and avail_in
    accordingly. If not all input can be processed (because there is not
    enough room in the output buffer), next_in and avail_in are updated and
    processing will resume at this point for the next call of deflate().

  - Provide more output starting at next_out and update next_out and avail_out
    accordingly. This action is forced if the parameter flush is non zero.
    Forcing flush frequently degrades the compression ratio, so this parameter
    should be set only when necessary (in interactive applications).
    Some output may be provided even if flush is not set.

  Before the call of deflate(), the application should ensure that at least
  one of the actions is possible, by providing more input and/or consuming
  more output, and updating avail_in or avail_out accordingly; avail_out
  should never be zero before the call. The application can consume the
  compressed output when it wants, for example when the output buffer is full
  (avail_out == 0), or after each call of deflate(). If deflate returns Z_OK
  and with zero avail_out, it must be called again after making room in the
  output buffer because there might be more output pending.

    If the parameter flush is set to Z_SYNC_FLUSH, all pending output is
  flushed to the output buffer and the output is aligned on a byte boundary, so
  that the decompressor can get all input data available so far. (In particular
  avail_in is zero after the call if enough output space has been provided
  before the call.)  Flushing may degrade compression for some compression
  algorithms and so it should be used only when necessary.

    If flush is set to Z_FULL_FLUSH, all output is flushed as with
  Z_SYNC_FLUSH, and the compression state is reset so that decompression can
  restart from this point if previous compressed data has been damaged or if
  random access is desired. Using Z_FULL_FLUSH too often can seriously degrade
  the compression.

    If deflate returns with avail_out == 0, this function must be called again
  with the same value of the flush parameter and more output space (updated
  avail_out), until the flush is complete (deflate returns with non-zero
  avail_out).

    If the parameter flush is set to Z_FINISH, pending input is processed,
  pending output is flushed and deflate returns with Z_STREAM_END if there
  was enough output space; if deflate returns with Z_OK, this function must be
  called again with Z_FINISH and more output space (updated avail_out) but no
  more input data, until it returns with Z_STREAM_END or an error. After
  deflate has returned Z_STREAM_END, the only possible operations on the
  stream are deflateReset or deflateEnd.
  
    Z_FINISH can be used immediately after deflateInit if all the compression
  is to be done in a single step. In this case, avail_out must be at least
  0.1% larger than avail_in plus 12 bytes.  If deflate does not return
  Z_STREAM_END, then it must be called again as described above.

    deflate() sets strm->adler to the adler32 checksum of all input read
  so far (that is, total_in bytes).

    deflate() may update data_type if it can make a good guess about
  the input data type (Z_ASCII or Z_BINARY). In doubt, the data is considered
  binary. This field is only for information purposes and does not affect
  the compression algorithm in any manner.

    deflate() returns Z_OK if some progress has been made (more input
  processed or more output produced), Z_STREAM_END if all input has been
  consumed and all output has been produced (only when flush is set to
  Z_FINISH), Z_STREAM_ERROR if the stream state was inconsistent (for example
  if next_in or next_out was NULL), Z_BUF_ERROR if no progress is possible
  (for example avail_in or avail_out was zero).
*/


ZEXTERN int ZEXPORT deflateEnd OF((z_streamp strm));
/*
     All dynamically allocated data structures for this stream are freed.
   This function discards any unprocessed input and does not flush any
   pending output.

     deflateEnd returns Z_OK if success, Z_STREAM_ERROR if the
   stream state was inconsistent, Z_DATA_ERROR if the stream was freed
   prematurely (some input or output was discarded). In the error case,
   msg may be set but then points to a static string (which must not be
   deallocated).
*/


/* 
ZEXTERN int ZEXPORT inflateInit OF((z_streamp strm));

     Initializes the internal stream state for decompression. The fields
   next_in, avail_in, zalloc, zfree and opaque must be initialized before by
   the caller. If next_in is not Z_NULL and avail_in is large enough (the exact
   value depends on the compression method), inflateInit determines the
   compression method from the zlib header and allocates all data structures
   accordingly; otherwise the allocation will be deferred to the first call of
   inflate.  If zalloc and zfree are set to Z_NULL, inflateInit updates them to
   use default allocation functions.

     inflateInit returns Z_OK if success, Z_MEM_ERROR if there was not enough
   memory, Z_VERSION_ERROR if the zlib library version is incompatible with the
   version assumed by the caller.  msg is set to null if there is no error
   message. inflateInit does not perform any decompression apart from reading
   the zlib header if present: this will be done by inflate().  (So next_in and
   avail_in may be modified, but next_out and avail_out are unchanged.)
*/


ZEXTERN int ZEXPORT inflate OF((z_streamp strm, int flush));
/*
    inflate decompresses as much data as possible, and stops when the input
  buffer becomes empty or the output buffer becomes full. It may some
  introduce some output latency (reading input without producing any output)
  except when forced to flush.

  The detailed semantics are as follows. inflate performs one or both of the
  following actions:

  - Decompress more input starting at next_in and update next_in and avail_in
    accordingly. If not all input can be processed (because there is not
    enough room in the output buffer), next_in is updated and processing
    will resume at this point for the next call of inflate().

  - Provide more output starting at next_out and update next_out and avail_out
    accordingly.  inflate() provides as much output as possible, until there
    is no more input data or no more space in the output buffer (see below
    about the flush parameter).

  Before the call of inflate(), the application should ensure that at least
  one of the actions is possible, by providing more input and/or consuming
  more output, and updating the next_* and avail_* values accordingly.
  The application can consume the uncompressed output when it wants, for
  example when the output buffer is full (avail_out == 0), or after each
  call of inflate(). If inflate returns Z_OK and with zero avail_out, it
  must be called again after making room in the output buffer because there
  might be more output pending.

    If the parameter flush is set to Z_SYNC_FLUSH, inflate flushes as much
  output as possible to the output buffer. The flushing behavior of inflate is
  not specified for values of the flush parameter other than Z_SYNC_FLUSH
  and Z_FINISH, but the current implementation actually flushes as much output
  as possible anyway.

    inflate() should normally be called until it returns Z_STREAM_END or an
  error. However if all decompression is to be performed in a single step
  (a single call of inflate), the parameter flush should be set to
  Z_FINISH. In this case all pending input is processed and all pending
  output is flushed; avail_out must be large enough to hold all the
  uncompressed data. (The size of the uncompressed data may have been saved
  by the compressor for this purpose.) The next operation on this stream must
  be inflateEnd to deallocate the decompression state. The use of Z_FINISH
  is never required, but can be used to inform inflate that a faster routine
  may be used for the single inflate() call.

     If a preset dictionary is needed at this point (see inflateSetDictionary
  below), inflate sets strm-adler to the adler32 checksum of the
  dictionary chosen by the compressor and returns Z_NEED_DICT; otherwise 
  it sets strm->adler to the adler32 checksum of all output produced
  so far (that is, total_out bytes) and returns Z_OK, Z_STREAM_END or
  an error code as described below. At the end of the stream, inflate()
  checks that its computed adler32 checksum is equal to that saved by the
  compressor and returns Z_STREAM_END only if the checksum is correct.

    inflate() returns Z_OK if some progress has been made (more input processed
  or more output produced), Z_STREAM_END if the end of the compressed data has
  been reached and all uncompressed output has been produced, Z_NEED_DICT if a
  preset dictionary is needed at this point, Z_DATA_ERROR if the input data was
  corrupted (input stream not conforming to the zlib format or incorrect
  adler32 checksum), Z_STREAM_ERROR if the stream structure was inconsistent
  (for example if next_in or next_out was NULL), Z_MEM_ERROR if there was not
  enough memory, Z_BUF_ERROR if no progress is possible or if there was not
  enough room in the output buffer when Z_FINISH is used. In the Z_DATA_ERROR
  case, the application may then call inflateSync to look for a good
  compression block.
*/


ZEXTERN int ZEXPORT inflateEnd OF((z_streamp strm));
/*
     All dynamically allocated data structures for this stream are freed.
   This function discards any unprocessed input and does not flush any
   pending output.

     inflateEnd returns Z_OK if success, Z_STREAM_ERROR if the stream state
   was inconsistent. In the error case, msg may be set but then points to a
   static string (which must not be deallocated).
*/

                        /* Advanced functions */

/*
    The following functions are needed only in some special applications.
*/

/*   
ZEXTERN int ZEXPORT deflateInit2 OF((z_streamp strm,
                                     int  level,
                                     int  method,
                                     int  windowBits,
                                     int  memLevel,
                                     int  strategy));

     This is another version of deflateInit with more compression options. The
   fields next_in, zalloc, zfree and opaque must be initialized before by
   the caller.

     The method parameter is the compression method. It must be Z_DEFLATED in
   this version of the library.

     The windowBits parameter is the base two logarithm of the window size
   (the size of the history buffer).  It should be in the range 8..15 for this
   version of the library. Larger values of this parameter result in better
   compression at the expense of memory usage. The default value is 15 if
   deflateInit is used instead.

     The memLevel parameter specifies how much memory should be allocated
   for the internal compression state. memLevel=1 uses minimum memory but
   is slow and reduces compression ratio; memLevel=9 uses maximum memory
   for optimal speed. The default value is 8. See zconf.h for total memory
   usage as a function of windowBits and memLevel.

     The strategy parameter is used to tune the compression algorithm. Use the
   value Z_DEFAULT_STRATEGY for normal data, Z_FILTERED for data produced by a
   filter (or predictor), or Z_HUFFMAN_ONLY to force Huffman encoding only (no
   string match).  Filtered data consists mostly of small values with a
   somewhat random distribution. In this case, the compression algorithm is
   tuned to compress them better. The effect of Z_FILTERED is to force more
   Huffman coding and less string matching; it is somewhat intermediate
   between Z_DEFAULT and Z_HUFFMAN_ONLY. The strategy parameter only affects
   the compression ratio but not the correctness of the compressed output even
   if it is not set appropriately.

      deflateInit2 returns Z_OK if success, Z_MEM_ERROR if there was not enough
   memory, Z_STREAM_ERROR if a parameter is invalid (such as an invalid
   method). msg is set to null if there is no error message.  deflateInit2 does
   not perform any compression: this will be done by deflate().
*/
                            
ZEXTERN int ZEXPORT deflateSetDictionary OF((z_streamp strm,
                                             const Bytef *dictionary,
                                             uInt  dictLength));
/*
     Initializes the compression dictionary from the given byte sequence
   without producing any compressed output. This function must be called
   immediately after deflateInit, deflateInit2 or deflateReset, before any
   call of deflate. The compressor and decompressor must use exactly the same
   dictionary (see inflateSetDictionary).

     The dictionary should consist of strings (byte sequences) that are likely
   to be encountered later in the data to be compressed, with the most commonly
   used strings preferably put towards the end of the dictionary. Using a
   dictionary is most useful when the data to be compressed is short and can be
   predicted with good accuracy; the data can then be compressed better than
   with the default empty dictionary.

     Depending on the size of the compression data structures selected by
   deflateInit or deflateInit2, a part of the dictionary may in effect be
   discarded, for example if the dictionary is larger than the window size in
   deflate or deflate2. Thus the strings most likely to be useful should be
   put at the end of the dictionary, not at the front.

     Upon return of this function, strm->adler is set to the Adler32 value
   of the dictionary; the decompressor may later use this value to determine
   which dictionary has been used by the compressor. (The Adler32 value
   applies to the whole dictionary even if only a subset of the dictionary is
   actually used by the compressor.)

     deflateSetDictionary returns Z_OK if success, or Z_STREAM_ERROR if a
   parameter is invalid (such as NULL dictionary) or the stream state is
   inconsistent (for example if deflate has already been called for this stream
   or if the compression method is bsort). deflateSetDictionary does not
   perform any compression: this will be done by deflate().
*/

ZEXTERN int ZEXPORT deflateCopy OF((z_streamp dest,
                                    z_streamp source));
/*
     Sets the destination stream as a complete copy of the source stream.

     This function can be useful when several compression strategies will be
   tried, for example when there are several ways of pre-processing the input
   data with a filter. The streams that will be discarded should then be freed
   by calling deflateEnd.  Note that deflateCopy duplicates the internal
   compression state which can be quite large, so this strategy is slow and
   can consume lots of memory.

     deflateCopy returns Z_OK if success, Z_MEM_ERROR if there was not
   enough memory, Z_STREAM_ERROR if the source stream state was inconsistent
   (such as zalloc being NULL). msg is left unchanged in both source and
   destination.
*/

ZEXTERN int ZEXPORT deflateReset OF((z_streamp strm));
/*
     This function is equivalent to deflateEnd followed by deflateInit,
   but does not free and reallocate all the internal compression state.
   The stream will keep the same compression level and any other attributes
   that may have been set by deflateInit2.

      deflateReset returns Z_OK if success, or Z_STREAM_ERROR if the source
   stream state was inconsistent (such as zalloc or state being NULL).
*/

ZEXTERN int ZEXPORT deflateParams OF((z_streamp strm,
				      int level,
				      int strategy));
/*
     Dynamically update the compression level and compression strategy.  The
   interpretation of level and strategy is as in deflateInit2.  This can be
   used to switch between compression and straight copy of the input data, or
   to switch to a different kind of input data requiring a different
   strategy. If the compression level is changed, the input available so far
   is compressed with the old level (and may be flushed); the new level will
   take effect only at the next call of deflate().

     Before the call of deflateParams, the stream state must be set as for
   a call of deflate(), since the currently available input may have to
   be compressed and flushed. In particular, strm->avail_out must be non-zero.

     deflateParams returns Z_OK if success, Z_STREAM_ERROR if the source
   stream state was inconsistent or if a parameter was invalid, Z_BUF_ERROR
   if strm->avail_out was zero.
*/

/*   
ZEXTERN int ZEXPORT inflateInit2 OF((z_streamp strm,
                                     int  windowBits));

     This is another version of inflateInit with an extra parameter. The
   fields next_in, avail_in, zalloc, zfree and opaque must be initialized
   before by the caller.

     The windowBits parameter is the base two logarithm of the maximum window
   size (the size of the history buffer).  It should be in the range 8..15 for
   this version of the library. The default value is 15 if inflateInit is used
   instead. If a compressed stream with a larger window size is given as
   input, inflate() will return with the error code Z_DATA_ERROR instead of
   trying to allocate a larger window.

      inflateInit2 returns Z_OK if success, Z_MEM_ERROR if there was not enough
   memory, Z_STREAM_ERROR if a parameter is invalid (such as a negative
   memLevel). msg is set to null if there is no error message.  inflateInit2
   does not perform any decompression apart from reading the zlib header if
   present: this will be done by inflate(). (So next_in and avail_in may be
   modified, but next_out and avail_out are unchanged.)
*/

ZEXTERN int ZEXPORT inflateSetDictionary OF((z_streamp strm,
                                             const Bytef *dictionary,
                                             uInt  dictLength));
/*
     Initializes the decompression dictionary from the given uncompressed byte
   sequence. This function must be called immediately after a call of inflate
   if this call returned Z_NEED_DICT. The dictionary chosen by the compressor
   can be determined from the Adler32 value returned by this call of
   inflate. The compressor and decompressor must use exactly the same
   dictionary (see deflateSetDictionary).

     inflateSetDictionary returns Z_OK if success, Z_STREAM_ERROR if a
   parameter is invalid (such as NULL dictionary) or the stream state is
   inconsistent, Z_DATA_ERROR if the given dictionary doesn't match the
   expected one (incorrect Adler32 value). inflateSetDictionary does not
   perform any decompression: this will be done by subsequent calls of
   inflate().
*/

ZEXTERN int ZEXPORT inflateSync OF((z_streamp strm));
/* 
    Skips invalid compressed data until a full flush point (see above the
  description of deflate with Z_FULL_FLUSH) can be found, or until all
  available input is skipped. No output is provided.

    inflateSync returns Z_OK if a full flush point has been found, Z_BUF_ERROR
  if no more input was provided, Z_DATA_ERROR if no flush point has been found,
  or Z_STREAM_ERROR if the stream structure was inconsistent. In the success
  case, the application may save the current current value of total_in which
  indicates where valid compressed data was found. In the error case, the
  application may repeatedly call inflateSync, providing more input each time,
  until success or end of the input data.
*/

ZEXTERN int ZEXPORT inflateReset OF((z_streamp strm));
/*
     This function is equivalent to inflateEnd followed by inflateInit,
   but does not free and reallocate all the internal decompression state.
   The stream will keep attributes that may have been set by inflateInit2.

      inflateReset returns Z_OK if success, or Z_STREAM_ERROR if the source
   stream state was inconsistent (such as zalloc or state being NULL).
*/


                        /* utility functions */

/*
     The following utility functions are implemented on top of the
   basic stream-oriented functions. To simplify the interface, some
   default options are assumed (compression level and memory usage,
   standard memory allocation functions). The source code of these
   utility functions can easily be modified if you need special options.
*/

ZEXTERN int ZEXPORT compress OF((Bytef *dest,   uLongf *destLen,
                                 const Bytef *source, uLong sourceLen));
/*
     Compresses the source buffer into the destination buffer.  sourceLen is
   the byte length of the source buffer. Upon entry, destLen is the total
   size of the destination buffer, which must be at least 0.1% larger than
   sourceLen plus 12 bytes. Upon exit, destLen is the actual size of the
   compressed buffer.
     This function can be used to compress a whole file at once if the
   input file is mmap'ed.
     compress returns Z_OK if success, Z_MEM_ERROR if there was not
   enough memory, Z_BUF_ERROR if there was not enough room in the output
   buffer.
*/

ZEXTERN int ZEXPORT compress2 OF((Bytef *dest,   uLongf *destLen,
                                  const Bytef *source, uLong sourceLen,
                                  int level));
/*
     Compresses the source buffer into the destination buffer. The level
   parameter has the same meaning as in deflateInit.  sourceLen is the byte
   length of the source buffer. Upon entry, destLen is the total size of the
   destination buffer, which must be at least 0.1% larger than sourceLen plus
   12 bytes. Upon exit, destLen is the actual size of the compressed buffer.

     compress2 returns Z_OK if success, Z_MEM_ERROR if there was not enough
   memory, Z_BUF_ERROR if there was not enough room in the output buffer,
   Z_STREAM_ERROR if the level parameter is invalid.
*/

ZEXTERN int ZEXPORT uncompress OF((Bytef *dest,   uLongf *destLen,
                                   const Bytef *source, uLong sourceLen));
/*
     Decompresses the source buffer into the destination buffer.  sourceLen is
   the byte length of the source buffer. Upon entry, destLen is the total
   size of the destination buffer, which must be large enough to hold the
   entire uncompressed data. (The size of the uncompressed data must have
   been saved previously by the compressor and transmitted to the decompressor
   by some mechanism outside the scope of this compression library.)
   Upon exit, destLen is the actual size of the compressed buffer.
     This function can be used to decompress a whole file at once if the
   input file is mmap'ed.

     uncompress returns Z_OK if success, Z_MEM_ERROR if there was not
   enough memory, Z_BUF_ERROR if there was not enough room in the output
   buffer, or Z_DATA_ERROR if the input data was corrupted.
*/


typedef voidp gzFile;

ZEXTERN gzFile ZEXPORT gzopen  OF((const char *path, const char *mode));
/*
     Opens a gzip (.gz) file for reading or writing. The mode parameter
   is as in fopen ("rb" or "wb") but can also include a compression level
   ("wb9") or a strategy: 'f' for filtered data as in "wb6f", 'h' for
   Huffman only compression as in "wb1h". (See the description
   of deflateInit2 for more information about the strategy parameter.)

     gzopen can be used to read a file which is not in gzip format; in this
   case gzread will directly read from the file without decompression.

     gzopen returns NULL if the file could not be opened or if there was
   insufficient memory to allocate the (de)compression state; errno
   can be checked to distinguish the two cases (if errno is zero, the
   zlib error is Z_MEM_ERROR).  */

ZEXTERN gzFile ZEXPORT gzdopen  OF((int fd, const char *mode));
/*
     gzdopen() associates a gzFile with the file descriptor fd.  File
   descriptors are obtained from calls like open, dup, creat, pipe or
   fileno (in the file has been previously opened with fopen).
   The mode parameter is as in gzopen.
     The next call of gzclose on the returned gzFile will also close the
   file descriptor fd, just like fclose(fdopen(fd), mode) closes the file
   descriptor fd. If you want to keep fd open, use gzdopen(dup(fd), mode).
     gzdopen returns NULL if there was insufficient memory to allocate
   the (de)compression state.
*/

ZEXTERN int ZEXPORT gzsetparams OF((gzFile file, int level, int strategy));
/*
     Dynamically update the compression level or strategy. See the description
   of deflateInit2 for the meaning of these parameters.
     gzsetparams returns Z_OK if success, or Z_STREAM_ERROR if the file was not
   opened for writing.
*/

ZEXTERN int ZEXPORT    gzread  OF((gzFile file, voidp buf, unsigned len));
/*
     Reads the given number of uncompressed bytes from the compressed file.
   If the input file was not in gzip format, gzread copies the given number
   of bytes into the buffer.
     gzread returns the number of uncompressed bytes actually read (0 for
   end of file, -1 for error). */

ZEXTERN int ZEXPORT    gzwrite OF((gzFile file, 
				   const voidp buf, unsigned len));
/*
     Writes the given number of uncompressed bytes into the compressed file.
   gzwrite returns the number of uncompressed bytes actually written
   (0 in case of error).
*/

ZEXTERN int ZEXPORTVA   gzprintf OF((gzFile file, const char *format, ...));
/*
     Converts, formats, and writes the args to the compressed file under
   control of the format string, as in fprintf. gzprintf returns the number of
   uncompressed bytes actually written (0 in case of error).
*/

ZEXTERN int ZEXPORT gzputs OF((gzFile file, const char *s));
/*
      Writes the given null-terminated string to the compressed file, excluding
   the terminating null character.
      gzputs returns the number of characters written, or -1 in case of error.
*/

ZEXTERN char * ZEXPORT gzgets OF((gzFile file, char *buf, int len));
/*
      Reads bytes from the compressed file until len-1 characters are read, or
   a newline character is read and transferred to buf, or an end-of-file
   condition is encountered.  The string is then terminated with a null
   character.
      gzgets returns buf, or Z_NULL in case of error.
*/

ZEXTERN int ZEXPORT    gzputc OF((gzFile file, int c));
/*
      Writes c, converted to an unsigned char, into the compressed file.
   gzputc returns the value that was written, or -1 in case of error.
*/

ZEXTERN int ZEXPORT    gzgetc OF((gzFile file));
/*
      Reads one byte from the compressed file. gzgetc returns this byte
   or -1 in case of end of file or error.
*/

ZEXTERN int ZEXPORT    gzflush OF((gzFile file, int flush));
/*
     Flushes all pending output into the compressed file. The parameter
   flush is as in the deflate() function. The return value is the zlib
   error number (see function gzerror below). gzflush returns Z_OK if
   the flush parameter is Z_FINISH and all output could be flushed.
     gzflush should be called only when strictly necessary because it can
   degrade compression.
*/

ZEXTERN z_off_t ZEXPORT    gzseek OF((gzFile file,
				      z_off_t offset, int whence));
/* 
      Sets the starting position for the next gzread or gzwrite on the
   given compressed file. The offset represents a number of bytes in the
   uncompressed data stream. The whence parameter is defined as in lseek(2);
   the value SEEK_END is not supported.
     If the file is opened for reading, this function is emulated but can be
   extremely slow. If the file is opened for writing, only forward seeks are
   supported; gzseek then compresses a sequence of zeroes up to the new
   starting position.

      gzseek returns the resulting offset location as measured in bytes from
   the beginning of the uncompressed stream, or -1 in case of error, in
   particular if the file is opened for writing and the new starting position
   would be before the current position.
*/

ZEXTERN int ZEXPORT    gzrewind OF((gzFile file));
/*
     Rewinds the given file. This function is supported only for reading.

   gzrewind(file) is equivalent to (int)gzseek(file, 0L, SEEK_SET)
*/

ZEXTERN z_off_t ZEXPORT    gztell OF((gzFile file));
/*
     Returns the starting position for the next gzread or gzwrite on the
   given compressed file. This position represents a number of bytes in the
   uncompressed data stream.

   gztell(file) is equivalent to gzseek(file, 0L, SEEK_CUR)
*/

ZEXTERN int ZEXPORT gzeof OF((gzFile file));
/*
     Returns 1 when EOF has previously been detected reading the given
   input stream, otherwise zero.
*/

ZEXTERN int ZEXPORT    gzclose OF((gzFile file));
/*
     Flushes all pending output if necessary, closes the compressed file
   and deallocates all the (de)compression state. The return value is the zlib
   error number (see function gzerror below).
*/

ZEXTERN const char * ZEXPORT gzerror OF((gzFile file, int *errnum));
/*
     Returns the error message for the last error which occurred on the
   given compressed file. errnum is set to zlib error number. If an
   error occurred in the file system and not in the compression library,
   errnum is set to Z_ERRNO and the application may consult errno
   to get the exact error code.
*/

                        /* checksum functions */

/*
     These functions are not related to compression but are exported
   anyway because they might be useful in applications using the
   compression library.
*/

ZEXTERN uLong ZEXPORT adler32 OF((uLong adler, const Bytef *buf, uInt len));

/*
     Update a running Adler-32 checksum with the bytes buf[0..len-1] and
   return the updated checksum. If buf is NULL, this function returns
   the required initial value for the checksum.
   An Adler-32 checksum is almost as reliable as a CRC32 but can be computed
   much faster. Usage example:

     uLong adler = adler32(0L, Z_NULL, 0);

     while (read_buffer(buffer, length) != EOF) {
       adler = adler32(adler, buffer, length);
     }
     if (adler != original_adler) error();
*/

ZEXTERN uLong ZEXPORT crc32   OF((uLong crc, const Bytef *buf, uInt len));
/*
     Update a running crc with the bytes buf[0..len-1] and return the updated
   crc. If buf is NULL, this function returns the required initial value
   for the crc. Pre- and post-conditioning (one's complement) is performed
   within this function so it shouldn't be done by the application.
   Usage example:

     uLong crc = crc32(0L, Z_NULL, 0);

     while (read_buffer(buffer, length) != EOF) {
       crc = crc32(crc, buffer, length);
     }
     if (crc != original_crc) error();
*/


                        /* various hacks, don't look :) */

/* deflateInit and inflateInit are macros to allow checking the zlib version
 * and the compiler's view of z_stream:
 */
ZEXTERN int ZEXPORT deflateInit_ OF((z_streamp strm, int level,
                                     const char *version, int stream_size));
ZEXTERN int ZEXPORT inflateInit_ OF((z_streamp strm,
                                     const char *version, int stream_size));
ZEXTERN int ZEXPORT deflateInit2_ OF((z_streamp strm, int  level, int  method,
                                      int windowBits, int memLevel,
                                      int strategy, const char *version,
                                      int stream_size));
ZEXTERN int ZEXPORT inflateInit2_ OF((z_streamp strm, int  windowBits,
                                      const char *version, int stream_size));
#define deflateInit(strm, level) \
        deflateInit_((strm), (level),       ZLIB_VERSION, sizeof(z_stream))
#define inflateInit(strm) \
        inflateInit_((strm),                ZLIB_VERSION, sizeof(z_stream))
#define deflateInit2(strm, level, method, windowBits, memLevel, strategy) \
        deflateInit2_((strm),(level),(method),(windowBits),(memLevel),\
                      (strategy),           ZLIB_VERSION, sizeof(z_stream))
#define inflateInit2(strm, windowBits) \
        inflateInit2_((strm), (windowBits), ZLIB_VERSION, sizeof(z_stream))


#if !defined(_Z_UTIL_H) && !defined(NO_DUMMY_DECL)
    struct internal_state {int dummy;}; /* hack for buggy compilers */
#endif

ZEXTERN const char   * ZEXPORT zError           OF((int err));
ZEXTERN int            ZEXPORT inflateSyncPoint OF((z_streamp z));
ZEXTERN const uLongf * ZEXPORT get_crc_table    OF((void));

#ifdef __cplusplus
}
#endif

#endif /* _ZLIB_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\public\internal\base\inc\zwapi.h ===
NTSYSAPI
NTSTATUS
NTAPI
ZwDelayExecution (
    IN BOOLEAN Alertable,
    IN PLARGE_INTEGER DelayInterval
    );
NTSYSAPI
NTSTATUS
NTAPI
ZwQuerySystemEnvironmentValue (
    IN PUNICODE_STRING VariableName,
    OUT PWSTR VariableValue,
    IN USHORT ValueLength,
    OUT PUSHORT ReturnLength OPTIONAL
    );
NTSYSAPI
NTSTATUS
NTAPI
ZwSetSystemEnvironmentValue (
    IN PUNICODE_STRING VariableName,
    IN PUNICODE_STRING VariableValue
    );
NTSYSAPI
NTSTATUS
NTAPI
ZwQuerySystemEnvironmentValueEx (
    IN PUNICODE_STRING VariableName,
    IN LPGUID VendorGuid,
    OUT PVOID Value,
    IN OUT PULONG ValueLength,
    OUT PULONG Attributes OPTIONAL
    );
NTSYSAPI
NTSTATUS
NTAPI
ZwSetSystemEnvironmentValueEx (
    IN PUNICODE_STRING VariableName,
    IN LPGUID VendorGuid,
    IN PVOID Value,
    IN ULONG ValueLength,
    IN ULONG Attributes
    );
NTSYSAPI
NTSTATUS
NTAPI
ZwEnumerateSystemEnvironmentValuesEx (
    IN ULONG InformationClass,
    OUT PVOID Buffer,
    IN OUT PULONG BufferLength
    );
NTSYSAPI
NTSTATUS
NTAPI
ZwAddBootEntry (
    IN PBOOT_ENTRY BootEntry,
    OUT PULONG Id OPTIONAL
    );
NTSYSAPI
NTSTATUS
NTAPI
ZwDeleteBootEntry (
    IN ULONG Id
    );
NTSYSAPI
NTSTATUS
NTAPI
ZwModifyBootEntry (
    IN PBOOT_ENTRY BootEntry
    );
NTSYSAPI
NTSTATUS
NTAPI
ZwEnumerateBootEntries (
    OUT PVOID Buffer,
    IN OUT PULONG BufferLength
    );
NTSYSAPI
NTSTATUS
NTAPI
ZwQueryBootEntryOrder (
    OUT PULONG Ids,
    IN OUT PULONG Count
    );
NTSYSAPI
NTSTATUS
NTAPI
ZwSetBootEntryOrder (
    IN PULONG Ids,
    IN ULONG Count
    );
NTSYSAPI
NTSTATUS
NTAPI
ZwQueryBootOptions (
    OUT PBOOT_OPTIONS BootOptions,
    IN OUT PULONG BootOptionsLength
    );
NTSYSAPI
NTSTATUS
NTAPI
ZwSetBootOptions (
    IN PBOOT_OPTIONS BootOptions,
    IN ULONG FieldsToChange
    );
NTSYSAPI
NTSTATUS
NTAPI
ZwTranslateFilePath (
    IN PFILE_PATH InputFilePath,
    IN ULONG OutputType,
    OUT PFILE_PATH OutputFilePath,
    IN OUT PULONG OutputFilePathLength
    );
NTSYSAPI
NTSTATUS
NTAPI
ZwClearEvent (
    IN HANDLE EventHandle
    );
NTSYSAPI
NTSTATUS
NTAPI
ZwCreateEvent (
    OUT PHANDLE EventHandle,
    IN ACCESS_MASK DesiredAccess,
    IN POBJECT_ATTRIBUTES ObjectAttributes OPTIONAL,
    IN EVENT_TYPE EventType,
    IN BOOLEAN InitialState
    );
NTSYSAPI
NTSTATUS
NTAPI
ZwOpenEvent (
    OUT PHANDLE EventHandle,
    IN ACCESS_MASK DesiredAccess,
    IN POBJECT_ATTRIBUTES ObjectAttributes
    );
NTSYSAPI
NTSTATUS
NTAPI
ZwPulseEvent (
    IN HANDLE EventHandle,
    OUT PLONG PreviousState OPTIONAL
    );
NTSYSAPI
NTSTATUS
NTAPI
ZwQueryEvent (
    IN HANDLE EventHandle,
    IN EVENT_INFORMATION_CLASS EventInformationClass,
    OUT PVOID EventInformation,
    IN ULONG EventInformationLength,
    OUT PULONG ReturnLength OPTIONAL
    );
NTSYSAPI
NTSTATUS
NTAPI
ZwResetEvent (
    IN HANDLE EventHandle,
    OUT PLONG PreviousState OPTIONAL
    );
NTSYSAPI
NTSTATUS
NTAPI
ZwSetEvent (
    IN HANDLE EventHandle,
    OUT PLONG PreviousState OPTIONAL
    );
NTSYSAPI
NTSTATUS
NTAPI
ZwSetEventBoostPriority (
    IN HANDLE EventHandle
    );
NTSYSAPI
NTSTATUS
NTAPI
ZwCreateEventPair (
    OUT PHANDLE EventPairHandle,
    IN ACCESS_MASK DesiredAccess,
    IN POBJECT_ATTRIBUTES ObjectAttributes OPTIONAL
    );
NTSYSAPI
NTSTATUS
NTAPI
ZwOpenEventPair(
    OUT PHANDLE EventPairHandle,
    IN ACCESS_MASK DesiredAccess,
    IN POBJECT_ATTRIBUTES ObjectAttributes
    );
NTSYSAPI
NTSTATUS
NTAPI
ZwWaitLowEventPair(
    IN HANDLE EventPairHandle
    );
NTSYSAPI
NTSTATUS
NTAPI
ZwWaitHighEventPair(
    IN HANDLE EventPairHandle
    );
NTSYSAPI
NTSTATUS
NTAPI
ZwSetLowWaitHighEventPair(
    IN HANDLE EventPairHandle
    );
NTSYSAPI
NTSTATUS
NTAPI
ZwSetHighWaitLowEventPair(
    IN HANDLE EventPairHandle
    );
NTSYSAPI
NTSTATUS
NTAPI
ZwSetLowEventPair(
    IN HANDLE EventPairHandle
    );
NTSYSAPI
NTSTATUS
NTAPI
ZwSetHighEventPair(
    IN HANDLE EventPairHandle
    );
NTSYSAPI
NTSTATUS
NTAPI
ZwCreateMutant (
    OUT PHANDLE MutantHandle,
    IN ACCESS_MASK DesiredAccess,
    IN POBJECT_ATTRIBUTES ObjectAttributes OPTIONAL,
    IN BOOLEAN InitialOwner
    );
NTSYSAPI
NTSTATUS
NTAPI
ZwOpenMutant (
    OUT PHANDLE MutantHandle,
    IN ACCESS_MASK DesiredAccess,
    IN POBJECT_ATTRIBUTES ObjectAttributes
    );
NTSYSAPI
NTSTATUS
NTAPI
ZwQueryMutant (
    IN HANDLE MutantHandle,
    IN MUTANT_INFORMATION_CLASS MutantInformationClass,
    OUT PVOID MutantInformation,
    IN ULONG MutantInformationLength,
    OUT PULONG ReturnLength OPTIONAL
    );
NTSYSAPI
NTSTATUS
NTAPI
ZwReleaseMutant (
    IN HANDLE MutantHandle,
    OUT PLONG PreviousCount OPTIONAL
    );
NTSYSAPI
NTSTATUS
NTAPI
ZwCreateSemaphore (
    OUT PHANDLE SemaphoreHandle,
    IN ACCESS_MASK DesiredAccess,
    IN POBJECT_ATTRIBUTES ObjectAttributes OPTIONAL,
    IN LONG InitialCount,
    IN LONG MaximumCount
    );
NTSYSAPI
NTSTATUS
NTAPI
ZwOpenSemaphore(
    OUT PHANDLE SemaphoreHandle,
    IN ACCESS_MASK DesiredAccess,
    IN POBJECT_ATTRIBUTES ObjectAttributes
    );
NTSYSAPI
NTSTATUS
NTAPI
ZwQuerySemaphore (
    IN HANDLE SemaphoreHandle,
    IN SEMAPHORE_INFORMATION_CLASS SemaphoreInformationClass,
    OUT PVOID SemaphoreInformation,
    IN ULONG SemaphoreInformationLength,
    OUT PULONG ReturnLength OPTIONAL
    );
NTSYSAPI
NTSTATUS
NTAPI
ZwReleaseSemaphore(
    IN HANDLE SemaphoreHandle,
    IN LONG ReleaseCount,
    OUT PLONG PreviousCount OPTIONAL
    );
NTSYSAPI
NTSTATUS
NTAPI
ZwCreateTimer (
    OUT PHANDLE TimerHandle,
    IN ACCESS_MASK DesiredAccess,
    IN POBJECT_ATTRIBUTES ObjectAttributes OPTIONAL,
    IN TIMER_TYPE TimerType
    );
NTSYSAPI
NTSTATUS
NTAPI
ZwOpenTimer (
    OUT PHANDLE TimerHandle,
    IN ACCESS_MASK DesiredAccess,
    IN POBJECT_ATTRIBUTES ObjectAttributes
    );
NTSYSAPI
NTSTATUS
NTAPI
ZwCancelTimer (
    IN HANDLE TimerHandle,
    OUT PBOOLEAN CurrentState OPTIONAL
    );
NTSYSAPI
NTSTATUS
NTAPI
ZwQueryTimer (
    IN HANDLE TimerHandle,
    IN TIMER_INFORMATION_CLASS TimerInformationClass,
    OUT PVOID TimerInformation,
    IN ULONG TimerInformationLength,
    OUT PULONG ReturnLength OPTIONAL
    );
NTSYSAPI
NTSTATUS
NTAPI
ZwSetTimer (
    IN HANDLE TimerHandle,
    IN PLARGE_INTEGER DueTime,
    IN PTIMER_APC_ROUTINE TimerApcRoutine OPTIONAL,
    IN PVOID TimerContext OPTIONAL,
    IN BOOLEAN ResumeTimer,
    IN LONG Period OPTIONAL,
    OUT PBOOLEAN PreviousState OPTIONAL
    );
NTSYSAPI
NTSTATUS
NTAPI
ZwQuerySystemTime (
    OUT PLARGE_INTEGER SystemTime
    );
NTSYSAPI
NTSTATUS
NTAPI
ZwSetSystemTime (
    IN PLARGE_INTEGER SystemTime,
    OUT PLARGE_INTEGER PreviousTime OPTIONAL
    );
NTSYSAPI
NTSTATUS
NTAPI
ZwQueryTimerResolution (
    OUT PULONG MaximumTime,
    OUT PULONG MinimumTime,
    OUT PULONG CurrentTime
    );
NTSYSAPI
NTSTATUS
NTAPI
ZwSetTimerResolution (
    IN ULONG DesiredTime,
    IN BOOLEAN SetResolution,
    OUT PULONG ActualTime
    );
NTSYSAPI
NTSTATUS
NTAPI
ZwAllocateLocallyUniqueId(
    OUT PLUID Luid
    );
NTSYSAPI
NTSTATUS
NTAPI
ZwSetUuidSeed (
    IN PCHAR Seed
    );
NTSYSAPI
NTSTATUS
NTAPI
ZwAllocateUuids(
    OUT PULARGE_INTEGER Time,
    OUT PULONG Range,
    OUT PULONG Sequence,
    OUT PCHAR Seed
    );
NTSYSAPI
NTSTATUS
NTAPI
ZwCreateProfile (
    OUT PHANDLE ProfileHandle,
    IN HANDLE Process OPTIONAL,
    IN PVOID ProfileBase,
    IN SIZE_T ProfileSize,
    IN ULONG BucketSize,
    IN PULONG Buffer,
    IN ULONG BufferSize,
    IN KPROFILE_SOURCE ProfileSource,
    IN KAFFINITY Affinity
    );
NTSYSAPI
NTSTATUS
NTAPI
ZwStartProfile (
    IN HANDLE ProfileHandle
    );
NTSYSAPI
NTSTATUS
NTAPI
ZwStopProfile (
    IN HANDLE ProfileHandle
    );
NTSYSAPI
NTSTATUS
NTAPI
ZwSetIntervalProfile (
    IN ULONG Interval,
    IN KPROFILE_SOURCE Source
    );
NTSYSAPI
NTSTATUS
NTAPI
ZwQueryIntervalProfile (
    IN KPROFILE_SOURCE ProfileSource,
    OUT PULONG Interval
    );
NTSYSAPI
NTSTATUS
NTAPI
ZwQueryPerformanceCounter (
    OUT PLARGE_INTEGER PerformanceCounter,
    OUT PLARGE_INTEGER PerformanceFrequency OPTIONAL
    );
NTSYSAPI
NTSTATUS
NTAPI
ZwCreateKeyedEvent (
    OUT PHANDLE KeyedEventHandle,
    IN ACCESS_MASK DesiredAccess,
    IN POBJECT_ATTRIBUTES ObjectAttributes OPTIONAL,
    IN ULONG Flags
    );
NTSYSAPI
NTSTATUS
NTAPI
ZwOpenKeyedEvent (
    OUT PHANDLE KeyedEventHandle,
    IN ACCESS_MASK DesiredAccess,
    IN POBJECT_ATTRIBUTES ObjectAttributes
    );
NTSYSAPI
NTSTATUS
NTAPI
ZwReleaseKeyedEvent (
    IN HANDLE KeyedEventHandle,
    IN PVOID KeyValue,
    IN BOOLEAN Alertable,
    IN PLARGE_INTEGER Timeout OPTIONAL
    );
NTSYSAPI
NTSTATUS
NTAPI
ZwWaitForKeyedEvent (
    IN HANDLE KeyedEventHandle,
    IN PVOID KeyValue,
    IN BOOLEAN Alertable,
    IN PLARGE_INTEGER Timeout OPTIONAL
    );
NTSYSAPI
NTSTATUS
NTAPI
ZwQuerySystemInformation (
    IN SYSTEM_INFORMATION_CLASS SystemInformationClass,
    OUT PVOID SystemInformation,
    IN ULONG SystemInformationLength,
    OUT PULONG ReturnLength OPTIONAL
    );
NTSYSAPI
NTSTATUS
NTAPI
ZwSetSystemInformation (
    IN SYSTEM_INFORMATION_CLASS SystemInformationClass,
    IN PVOID SystemInformation,
    IN ULONG SystemInformationLength
    );
NTSYSAPI
NTSTATUS
NTAPI
ZwSystemDebugControl (
    IN SYSDBG_COMMAND Command,
    IN PVOID InputBuffer,
    IN ULONG InputBufferLength,
    OUT PVOID OutputBuffer,
    IN ULONG OutputBufferLength,
    OUT PULONG ReturnLength
    );
NTSYSAPI
NTSTATUS
NTAPI
ZwRaiseHardError(
    IN NTSTATUS ErrorStatus,
    IN ULONG NumberOfParameters,
    IN ULONG UnicodeStringParameterMask,
    IN PULONG_PTR Parameters,
    IN ULONG ValidResponseOptions,
    OUT PULONG Response
    );
NTSYSAPI
NTSTATUS
NTAPI
ZwQueryDefaultLocale(
    IN BOOLEAN UserProfile,
    OUT PLCID DefaultLocaleId
    );
NTSYSAPI
NTSTATUS
NTAPI
ZwSetDefaultLocale(
    IN BOOLEAN UserProfile,
    IN LCID DefaultLocaleId
    );
NTSYSAPI
NTSTATUS
NTAPI
ZwQueryInstallUILanguage(
    OUT LANGID *InstallUILanguageId
    );
NTSYSAPI
NTSTATUS
NTAPI
ZwQueryDefaultUILanguage(
    OUT LANGID *DefaultUILanguageId
    );
NTSYSAPI
NTSTATUS
NTAPI
ZwSetDefaultUILanguage(
    IN LANGID DefaultUILanguageId
    );
NTSYSAPI
NTSTATUS
NTAPI
ZwSetDefaultHardErrorPort(
    IN HANDLE DefaultHardErrorPort
    );
NTSYSAPI
NTSTATUS
NTAPI
ZwShutdownSystem(
    IN SHUTDOWN_ACTION Action
    );
NTSYSAPI
NTSTATUS
NTAPI
ZwDisplayString(
    IN PUNICODE_STRING String
    );
NTSYSAPI
NTSTATUS
NTAPI
ZwAddAtom(
    IN PWSTR AtomName OPTIONAL,
    IN ULONG Length OPTIONAL,
    OUT PRTL_ATOM Atom OPTIONAL
    );
NTSYSAPI
NTSTATUS
NTAPI
ZwFindAtom(
    IN PWSTR AtomName,
    IN ULONG Length,
    OUT PRTL_ATOM Atom OPTIONAL
    );
NTSYSAPI
NTSTATUS
NTAPI
ZwDeleteAtom(
    IN RTL_ATOM Atom
    );
NTSYSAPI
NTSTATUS
NTAPI
ZwQueryInformationAtom(
    IN RTL_ATOM Atom,
    IN ATOM_INFORMATION_CLASS AtomInformationClass,
    OUT PVOID AtomInformation,
    IN ULONG AtomInformationLength,
    OUT PULONG ReturnLength OPTIONAL
    );
NTSYSAPI
NTSTATUS
NTAPI
ZwCancelIoFile(
    IN HANDLE FileHandle,
    OUT PIO_STATUS_BLOCK IoStatusBlock
    );
NTSYSAPI
NTSTATUS
NTAPI
ZwCreateNamedPipeFile(
     OUT PHANDLE FileHandle,
     IN ULONG DesiredAccess,
     IN POBJECT_ATTRIBUTES ObjectAttributes,
     OUT PIO_STATUS_BLOCK IoStatusBlock,
     IN ULONG ShareAccess,
     IN ULONG CreateDisposition,
     IN ULONG CreateOptions,
     IN ULONG NamedPipeType,
     IN ULONG ReadMode,
     IN ULONG CompletionMode,
     IN ULONG MaximumInstances,
     IN ULONG InboundQuota,
     IN ULONG OutboundQuota,
     IN PLARGE_INTEGER DefaultTimeout OPTIONAL
     );
NTSYSAPI
NTSTATUS
NTAPI
ZwCreateMailslotFile(
     OUT PHANDLE FileHandle,
     IN ULONG DesiredAccess,
     IN POBJECT_ATTRIBUTES ObjectAttributes,
     OUT PIO_STATUS_BLOCK IoStatusBlock,
     ULONG CreateOptions,
     IN ULONG MailslotQuota,
     IN ULONG MaximumMessageSize,
     IN PLARGE_INTEGER ReadTimeout
     );
NTSYSAPI
NTSTATUS
NTAPI
ZwDeleteFile(
    IN POBJECT_ATTRIBUTES ObjectAttributes
    );
NTSYSAPI
NTSTATUS
NTAPI
ZwFlushBuffersFile(
    IN HANDLE FileHandle,
    OUT PIO_STATUS_BLOCK IoStatusBlock
    );
NTSYSAPI
NTSTATUS
NTAPI
ZwNotifyChangeDirectoryFile(
    IN HANDLE FileHandle,
    IN HANDLE Event OPTIONAL,
    IN PIO_APC_ROUTINE ApcRoutine OPTIONAL,
    IN PVOID ApcContext OPTIONAL,
    OUT PIO_STATUS_BLOCK IoStatusBlock,
    OUT PVOID Buffer,
    IN ULONG Length,
    IN ULONG CompletionFilter,
    IN BOOLEAN WatchTree
    );
NTSYSAPI
NTSTATUS
NTAPI
ZwQueryAttributesFile(
    IN POBJECT_ATTRIBUTES ObjectAttributes,
    OUT PFILE_BASIC_INFORMATION FileInformation
    );
NTSYSAPI
NTSTATUS
NTAPI
ZwQueryFullAttributesFile(
    IN POBJECT_ATTRIBUTES ObjectAttributes,
    OUT PFILE_NETWORK_OPEN_INFORMATION FileInformation
    );
NTSYSAPI
NTSTATUS
NTAPI
ZwQueryEaFile(
    IN HANDLE FileHandle,
    OUT PIO_STATUS_BLOCK IoStatusBlock,
    OUT PVOID Buffer,
    IN ULONG Length,
    IN BOOLEAN ReturnSingleEntry,
    IN PVOID EaList OPTIONAL,
    IN ULONG EaListLength,
    IN PULONG EaIndex OPTIONAL,
    IN BOOLEAN RestartScan
    );
NTSYSAPI
NTSTATUS
NTAPI
ZwCreateFile(
    OUT PHANDLE FileHandle,
    IN ACCESS_MASK DesiredAccess,
    IN POBJECT_ATTRIBUTES ObjectAttributes,
    OUT PIO_STATUS_BLOCK IoStatusBlock,
    IN PLARGE_INTEGER AllocationSize OPTIONAL,
    IN ULONG FileAttributes,
    IN ULONG ShareAccess,
    IN ULONG CreateDisposition,
    IN ULONG CreateOptions,
    IN PVOID EaBuffer OPTIONAL,
    IN ULONG EaLength
    );
NTSYSAPI
NTSTATUS
NTAPI
ZwDeviceIoControlFile(
    IN HANDLE FileHandle,
    IN HANDLE Event OPTIONAL,
    IN PIO_APC_ROUTINE ApcRoutine OPTIONAL,
    IN PVOID ApcContext OPTIONAL,
    OUT PIO_STATUS_BLOCK IoStatusBlock,
    IN ULONG IoControlCode,
    IN PVOID InputBuffer OPTIONAL,
    IN ULONG InputBufferLength,
    OUT PVOID OutputBuffer OPTIONAL,
    IN ULONG OutputBufferLength
    );
NTSYSAPI
NTSTATUS
NTAPI
ZwFsControlFile(
    IN HANDLE FileHandle,
    IN HANDLE Event OPTIONAL,
    IN PIO_APC_ROUTINE ApcRoutine OPTIONAL,
    IN PVOID ApcContext OPTIONAL,
    OUT PIO_STATUS_BLOCK IoStatusBlock,
    IN ULONG FsControlCode,
    IN PVOID InputBuffer OPTIONAL,
    IN ULONG InputBufferLength,
    OUT PVOID OutputBuffer OPTIONAL,
    IN ULONG OutputBufferLength
    );
NTSYSAPI
NTSTATUS
NTAPI
ZwLockFile(
    IN HANDLE FileHandle,
    IN HANDLE Event OPTIONAL,
    IN PIO_APC_ROUTINE ApcRoutine OPTIONAL,
    IN PVOID ApcContext OPTIONAL,
    OUT PIO_STATUS_BLOCK IoStatusBlock,
    IN PLARGE_INTEGER ByteOffset,
    IN PLARGE_INTEGER Length,
    IN ULONG Key,
    IN BOOLEAN FailImmediately,
    IN BOOLEAN ExclusiveLock
    );
NTSYSAPI
NTSTATUS
NTAPI
ZwOpenFile(
    OUT PHANDLE FileHandle,
    IN ACCESS_MASK DesiredAccess,
    IN POBJECT_ATTRIBUTES ObjectAttributes,
    OUT PIO_STATUS_BLOCK IoStatusBlock,
    IN ULONG ShareAccess,
    IN ULONG OpenOptions
    );
NTSYSAPI
NTSTATUS
NTAPI
ZwQueryDirectoryFile(
    IN HANDLE FileHandle,
    IN HANDLE Event OPTIONAL,
    IN PIO_APC_ROUTINE ApcRoutine OPTIONAL,
    IN PVOID ApcContext OPTIONAL,
    OUT PIO_STATUS_BLOCK IoStatusBlock,
    OUT PVOID FileInformation,
    IN ULONG Length,
    IN FILE_INFORMATION_CLASS FileInformationClass,
    IN BOOLEAN ReturnSingleEntry,
    IN PUNICODE_STRING FileName OPTIONAL,
    IN BOOLEAN RestartScan
    );
NTSYSAPI
NTSTATUS
NTAPI
ZwQueryInformationFile(
    IN HANDLE FileHandle,
    OUT PIO_STATUS_BLOCK IoStatusBlock,
    OUT PVOID FileInformation,
    IN ULONG Length,
    IN FILE_INFORMATION_CLASS FileInformationClass
    );
NTSYSAPI
NTSTATUS
NTAPI
ZwQueryQuotaInformationFile(
    IN HANDLE FileHandle,
    OUT PIO_STATUS_BLOCK IoStatusBlock,
    OUT PVOID Buffer,
    IN ULONG Length,
    IN BOOLEAN ReturnSingleEntry,
    IN PVOID SidList OPTIONAL,
    IN ULONG SidListLength,
    IN PSID StartSid OPTIONAL,
    IN BOOLEAN RestartScan
    );
NTSYSAPI
NTSTATUS
NTAPI
ZwQueryVolumeInformationFile(
    IN HANDLE FileHandle,
    OUT PIO_STATUS_BLOCK IoStatusBlock,
    OUT PVOID FsInformation,
    IN ULONG Length,
    IN FS_INFORMATION_CLASS FsInformationClass
    );
NTSYSAPI
NTSTATUS
NTAPI
ZwReadFile(
    IN HANDLE FileHandle,
    IN HANDLE Event OPTIONAL,
    IN PIO_APC_ROUTINE ApcRoutine OPTIONAL,
    IN PVOID ApcContext OPTIONAL,
    OUT PIO_STATUS_BLOCK IoStatusBlock,
    OUT PVOID Buffer,
    IN ULONG Length,
    IN PLARGE_INTEGER ByteOffset OPTIONAL,
    IN PULONG Key OPTIONAL
    );
NTSYSAPI
NTSTATUS
NTAPI
ZwSetInformationFile(
    IN HANDLE FileHandle,
    OUT PIO_STATUS_BLOCK IoStatusBlock,
    IN PVOID FileInformation,
    IN ULONG Length,
    IN FILE_INFORMATION_CLASS FileInformationClass
    );
NTSYSAPI
NTSTATUS
NTAPI
ZwSetQuotaInformationFile(
    IN HANDLE FileHandle,
    OUT PIO_STATUS_BLOCK IoStatusBlock,
    IN PVOID Buffer,
    IN ULONG Length
    );
NTSYSAPI
NTSTATUS
NTAPI
ZwSetVolumeInformationFile(
    IN HANDLE FileHandle,
    OUT PIO_STATUS_BLOCK IoStatusBlock,
    IN PVOID FsInformation,
    IN ULONG Length,
    IN FS_INFORMATION_CLASS FsInformationClass
    );
NTSYSAPI
NTSTATUS
NTAPI
ZwWriteFile(
    IN HANDLE FileHandle,
    IN HANDLE Event OPTIONAL,
    IN PIO_APC_ROUTINE ApcRoutine OPTIONAL,
    IN PVOID ApcContext OPTIONAL,
    OUT PIO_STATUS_BLOCK IoStatusBlock,
    IN PVOID Buffer,
    IN ULONG Length,
    IN PLARGE_INTEGER ByteOffset OPTIONAL,
    IN PULONG Key OPTIONAL
    );
NTSYSAPI
NTSTATUS
NTAPI
ZwUnlockFile(
    IN HANDLE FileHandle,
    OUT PIO_STATUS_BLOCK IoStatusBlock,
    IN PLARGE_INTEGER ByteOffset,
    IN PLARGE_INTEGER Length,
    IN ULONG Key
    );
NTSYSAPI
NTSTATUS
NTAPI
ZwReadFile64(
    IN HANDLE FileHandle,
    IN HANDLE Event OPTIONAL,
    IN PIO_APC_ROUTINE ApcRoutine OPTIONAL,
    IN PVOID ApcContext OPTIONAL,
    OUT PIO_STATUS_BLOCK IoStatusBlock,
    OUT PVOID64 *Buffer,
    IN ULONG Length,
    IN PLARGE_INTEGER ByteOffset OPTIONAL,
    IN PULONG Key OPTIONAL
    );
NTSYSAPI
NTSTATUS
NTAPI
ZwReadFileScatter(
    IN HANDLE FileHandle,
    IN HANDLE Event OPTIONAL,
    IN PIO_APC_ROUTINE ApcRoutine OPTIONAL,
    IN PVOID ApcContext OPTIONAL,
    OUT PIO_STATUS_BLOCK IoStatusBlock,
    IN PFILE_SEGMENT_ELEMENT SegmentArray,
    IN ULONG Length,
    IN PLARGE_INTEGER ByteOffset OPTIONAL,
    IN PULONG Key OPTIONAL
    );
NTSYSAPI
NTSTATUS
NTAPI
ZwSetEaFile(
    IN HANDLE FileHandle,
    OUT PIO_STATUS_BLOCK IoStatusBlock,
    IN PVOID Buffer,
    IN ULONG Length
    );
NTSYSAPI
NTSTATUS
NTAPI
ZwWriteFile64(
    IN HANDLE FileHandle,
    IN HANDLE Event OPTIONAL,
    IN PIO_APC_ROUTINE ApcRoutine OPTIONAL,
    IN PVOID ApcContext OPTIONAL,
    OUT PIO_STATUS_BLOCK IoStatusBlock,
    IN PVOID64 *Buffer,
    IN ULONG Length,
    IN PLARGE_INTEGER ByteOffset OPTIONAL,
    IN PULONG Key OPTIONAL
    );
NTSYSAPI
NTSTATUS
NTAPI
ZwWriteFileGather(
    IN HANDLE FileHandle,
    IN HANDLE Event OPTIONAL,
    IN PIO_APC_ROUTINE ApcRoutine OPTIONAL,
    IN PVOID ApcContext OPTIONAL,
    OUT PIO_STATUS_BLOCK IoStatusBlock,
    IN PFILE_SEGMENT_ELEMENT SegmentArray,
    IN ULONG Length,
    IN PLARGE_INTEGER ByteOffset OPTIONAL,
    IN PULONG Key OPTIONAL
    );
NTSYSAPI
NTSTATUS
NTAPI
ZwLoadDriver(
    IN PUNICODE_STRING DriverServiceName
    );
NTSYSAPI
NTSTATUS
NTAPI
ZwUnloadDriver(
    IN PUNICODE_STRING DriverServiceName
    );
NTSYSAPI
NTSTATUS
NTAPI
ZwCreateIoCompletion (
    OUT PHANDLE IoCompletionHandle,
    IN ACCESS_MASK DesiredAccess,
    IN POBJECT_ATTRIBUTES ObjectAttributes OPTIONAL,
    IN ULONG Count OPTIONAL
    );
NTSYSAPI
NTSTATUS
NTAPI
ZwOpenIoCompletion (
    OUT PHANDLE IoCompletionHandle,
    IN ACCESS_MASK DesiredAccess,
    IN POBJECT_ATTRIBUTES ObjectAttributes
    );
NTSYSAPI
NTSTATUS
NTAPI
ZwQueryIoCompletion (
    IN HANDLE IoCompletionHandle,
    IN IO_COMPLETION_INFORMATION_CLASS IoCompletionInformationClass,
    OUT PVOID IoCompletionInformation,
    IN ULONG IoCompletionInformationLength,
    OUT PULONG ReturnLength OPTIONAL
    );
NTSYSAPI
NTSTATUS
NTAPI
ZwSetIoCompletion (
    IN HANDLE IoCompletionHandle,
    IN PVOID KeyContext,
    IN PVOID ApcContext,
    IN NTSTATUS IoStatus,
    IN ULONG_PTR IoStatusInformation
    );
NTSYSAPI
NTSTATUS
NTAPI
ZwRemoveIoCompletion (
    IN HANDLE IoCompletionHandle,
    OUT PVOID *KeyContext,
    OUT PVOID *ApcContext,
    OUT PIO_STATUS_BLOCK IoStatusBlock,
    IN PLARGE_INTEGER Timeout
    );
NTSYSAPI
NTSTATUS
NTAPI
ZwCallbackReturn (
    IN PVOID OutputBuffer OPTIONAL,
    IN ULONG OutputLength,
    IN NTSTATUS Status
    );
NTSYSAPI
NTSTATUS
NTAPI
ZwQueryDebugFilterState (
    IN ULONG ComponentId,
    IN ULONG Level
    );
NTSYSAPI
NTSTATUS
NTAPI
ZwSetDebugFilterState (
    IN ULONG ComponentId,
    IN ULONG Level,
    IN BOOLEAN State
    );
NTSYSAPI
NTSTATUS
NTAPI
ZwW32Call (
    IN ULONG ApiNumber,
    IN PVOID InputBuffer,
    IN ULONG InputLength,
    OUT PVOID *OutputBuffer,
    OUT PULONG OutputLength
    );
NTSYSAPI
NTSTATUS
NTAPI
ZwYieldExecution (
    VOID
    );
NTSYSAPI
NTSTATUS
NTAPI
ZwCreatePort(
    OUT PHANDLE PortHandle,
    IN POBJECT_ATTRIBUTES ObjectAttributes,
    IN ULONG MaxConnectionInfoLength,
    IN ULONG MaxMessageLength,
    IN ULONG MaxPoolUsage
    );
NTSYSAPI
NTSTATUS
NTAPI
ZwCreateWaitablePort(
    OUT PHANDLE PortHandle,
    IN POBJECT_ATTRIBUTES ObjectAttributes,
    IN ULONG MaxConnectionInfoLength,
    IN ULONG MaxMessageLength,
    IN ULONG MaxPoolUsage
    );
NTSYSAPI
NTSTATUS
NTAPI
ZwConnectPort(
    OUT PHANDLE PortHandle,
    IN PUNICODE_STRING PortName,
    IN PSECURITY_QUALITY_OF_SERVICE SecurityQos,
    IN OUT PPORT_VIEW ClientView OPTIONAL,
    IN OUT PREMOTE_PORT_VIEW ServerView OPTIONAL,
    OUT PULONG MaxMessageLength OPTIONAL,
    IN OUT PVOID ConnectionInformation OPTIONAL,
    IN OUT PULONG ConnectionInformationLength OPTIONAL
    );
NTSYSAPI
NTSTATUS
NTAPI
ZwSecureConnectPort(
    OUT PHANDLE PortHandle,
    IN PUNICODE_STRING PortName,
    IN PSECURITY_QUALITY_OF_SERVICE SecurityQos,
    IN OUT PPORT_VIEW ClientView OPTIONAL,
    IN PSID RequiredServerSid,
    IN OUT PREMOTE_PORT_VIEW ServerView OPTIONAL,
    OUT PULONG MaxMessageLength OPTIONAL,
    IN OUT PVOID ConnectionInformation OPTIONAL,
    IN OUT PULONG ConnectionInformationLength OPTIONAL
    );
NTSYSAPI
NTSTATUS
NTAPI
ZwListenPort(
    IN HANDLE PortHandle,
    OUT PPORT_MESSAGE ConnectionRequest
    );
NTSYSAPI
NTSTATUS
NTAPI
ZwAcceptConnectPort(
    OUT PHANDLE PortHandle,
    IN PVOID PortContext,
    IN PPORT_MESSAGE ConnectionRequest,
    IN BOOLEAN AcceptConnection,
    IN OUT PPORT_VIEW ServerView OPTIONAL,
    OUT PREMOTE_PORT_VIEW ClientView OPTIONAL
    );
NTSYSAPI
NTSTATUS
NTAPI
ZwCompleteConnectPort(
    IN HANDLE PortHandle
    );
NTSYSAPI
NTSTATUS
NTAPI
ZwRequestPort(
    IN HANDLE PortHandle,
    IN PPORT_MESSAGE RequestMessage
    );
NTSYSAPI
NTSTATUS
NTAPI
ZwRequestWaitReplyPort(
    IN HANDLE PortHandle,
    IN PPORT_MESSAGE RequestMessage,
    OUT PPORT_MESSAGE ReplyMessage
    );
NTSYSAPI
NTSTATUS
NTAPI
ZwReplyPort(
    IN HANDLE PortHandle,
    IN PPORT_MESSAGE ReplyMessage
    );
NTSYSAPI
NTSTATUS
NTAPI
ZwReplyWaitReplyPort(
    IN HANDLE PortHandle,
    IN OUT PPORT_MESSAGE ReplyMessage
    );
NTSYSAPI
NTSTATUS
NTAPI
ZwReplyWaitReceivePort(
    IN HANDLE PortHandle,
    OUT PVOID *PortContext OPTIONAL,
    IN PPORT_MESSAGE ReplyMessage OPTIONAL,
    OUT PPORT_MESSAGE ReceiveMessage
    );
NTSYSAPI
NTSTATUS
NTAPI
ZwReplyWaitReceivePortEx(
    IN HANDLE PortHandle,
    OUT PVOID *PortContext OPTIONAL,
    IN PPORT_MESSAGE ReplyMessage OPTIONAL,
    OUT PPORT_MESSAGE ReceiveMessage,
    IN PLARGE_INTEGER Timeout OPTIONAL
    );
NTSYSAPI
NTSTATUS
NTAPI
ZwImpersonateClientOfPort(
    IN HANDLE PortHandle,
    IN PPORT_MESSAGE Message
    );
NTSYSAPI
NTSTATUS
NTAPI
ZwReadRequestData(
    IN HANDLE PortHandle,
    IN PPORT_MESSAGE Message,
    IN ULONG DataEntryIndex,
    OUT PVOID Buffer,
    IN SIZE_T BufferSize,
    OUT PSIZE_T NumberOfBytesRead OPTIONAL
    );
NTSYSAPI
NTSTATUS
NTAPI
ZwWriteRequestData(
    IN HANDLE PortHandle,
    IN PPORT_MESSAGE Message,
    IN ULONG DataEntryIndex,
    IN PVOID Buffer,
    IN SIZE_T BufferSize,
    OUT PSIZE_T NumberOfBytesWritten OPTIONAL
    );
NTSYSAPI
NTSTATUS
NTAPI
ZwQueryInformationPort(
    IN HANDLE PortHandle,
    IN PORT_INFORMATION_CLASS PortInformationClass,
    OUT PVOID PortInformation,
    IN ULONG Length,
    OUT PULONG ReturnLength OPTIONAL
    );
NTSYSAPI
NTSTATUS
NTAPI
ZwCreateSection (
    OUT PHANDLE SectionHandle,
    IN ACCESS_MASK DesiredAccess,
    IN POBJECT_ATTRIBUTES ObjectAttributes OPTIONAL,
    IN PLARGE_INTEGER MaximumSize OPTIONAL,
    IN ULONG SectionPageProtection,
    IN ULONG AllocationAttributes,
    IN HANDLE FileHandle OPTIONAL
    );
NTSYSAPI
NTSTATUS
NTAPI
ZwOpenSection(
    OUT PHANDLE SectionHandle,
    IN ACCESS_MASK DesiredAccess,
    IN POBJECT_ATTRIBUTES ObjectAttributes
    );
NTSYSAPI
NTSTATUS
NTAPI
ZwMapViewOfSection(
    IN HANDLE SectionHandle,
    IN HANDLE ProcessHandle,
    IN OUT PVOID *BaseAddress,
    IN ULONG_PTR ZeroBits,
    IN SIZE_T CommitSize,
    IN OUT PLARGE_INTEGER SectionOffset OPTIONAL,
    IN OUT PSIZE_T ViewSize,
    IN SECTION_INHERIT InheritDisposition,
    IN ULONG AllocationType,
    IN ULONG Protect
    );
NTSYSAPI
NTSTATUS
NTAPI
ZwUnmapViewOfSection(
    IN HANDLE ProcessHandle,
    IN PVOID BaseAddress
    );
NTSYSAPI
NTSTATUS
NTAPI
ZwExtendSection(
    IN HANDLE SectionHandle,
    IN OUT PLARGE_INTEGER NewSectionSize
    );
NTSYSAPI
NTSTATUS
NTAPI
ZwAreMappedFilesTheSame (
    IN PVOID File1MappedAsAnImage,
    IN PVOID File2MappedAsFile
    );
NTSYSAPI
NTSTATUS
NTAPI
ZwAllocateVirtualMemory(
    IN HANDLE ProcessHandle,
    IN OUT PVOID *BaseAddress,
    IN ULONG_PTR ZeroBits,
    IN OUT PSIZE_T RegionSize,
    IN ULONG AllocationType,
    IN ULONG Protect
    );
NTSYSAPI
NTSTATUS
NTAPI
ZwFreeVirtualMemory(
    IN HANDLE ProcessHandle,
    IN OUT PVOID *BaseAddress,
    IN OUT PSIZE_T RegionSize,
    IN ULONG FreeType
    );
NTSYSAPI
NTSTATUS
NTAPI
ZwReadVirtualMemory(
    IN HANDLE ProcessHandle,
    IN PVOID BaseAddress,
    OUT PVOID Buffer,
    IN SIZE_T BufferSize,
    OUT PSIZE_T NumberOfBytesRead OPTIONAL
    );
NTSYSAPI
NTSTATUS
NTAPI
ZwWriteVirtualMemory(
    IN HANDLE ProcessHandle,
    OUT PVOID BaseAddress,
    IN CONST VOID *Buffer,
    IN SIZE_T BufferSize,
    OUT PSIZE_T NumberOfBytesWritten OPTIONAL
    );
NTSYSAPI
NTSTATUS
NTAPI
ZwFlushVirtualMemory(
    IN HANDLE ProcessHandle,
    IN OUT PVOID *BaseAddress,
    IN OUT PSIZE_T RegionSize,
    OUT PIO_STATUS_BLOCK IoStatus
    );
NTSYSAPI
NTSTATUS
NTAPI
ZwLockVirtualMemory(
    IN HANDLE ProcessHandle,
    IN OUT PVOID *BaseAddress,
    IN OUT PSIZE_T RegionSize,
    IN ULONG MapType
    );
NTSYSAPI
NTSTATUS
NTAPI
ZwUnlockVirtualMemory(
    IN HANDLE ProcessHandle,
    IN OUT PVOID *BaseAddress,
    IN OUT PSIZE_T RegionSize,
    IN ULONG MapType
    );
NTSYSAPI
NTSTATUS
NTAPI
ZwProtectVirtualMemory(
    IN HANDLE ProcessHandle,
    IN OUT PVOID *BaseAddress,
    IN OUT PSIZE_T RegionSize,
    IN ULONG NewProtect,
    OUT PULONG OldProtect
    );
NTSYSAPI
NTSTATUS
NTAPI
ZwQueryVirtualMemory(
    IN HANDLE ProcessHandle,
    IN PVOID BaseAddress,
    IN MEMORY_INFORMATION_CLASS MemoryInformationClass,
    OUT PVOID MemoryInformation,
    IN SIZE_T MemoryInformationLength,
    OUT PSIZE_T ReturnLength OPTIONAL
    );
NTSYSAPI
NTSTATUS
NTAPI
ZwQuerySection(
    IN HANDLE SectionHandle,
    IN SECTION_INFORMATION_CLASS SectionInformationClass,
    OUT PVOID SectionInformation,
    IN SIZE_T SectionInformationLength,
    OUT PSIZE_T ReturnLength OPTIONAL
    );
NTSYSAPI
NTSTATUS
NTAPI
ZwMapUserPhysicalPages(
    IN PVOID VirtualAddress,
    IN OUT ULONG_PTR NumberOfPages,
    IN OUT PULONG_PTR UserPfnArray OPTIONAL
    );
NTSYSAPI
NTSTATUS
NTAPI
ZwMapUserPhysicalPagesScatter(
    IN PVOID *VirtualAddresses,
    IN OUT ULONG_PTR NumberOfPages,
    IN OUT PULONG_PTR UserPfnArray OPTIONAL
    );
NTSYSAPI
NTSTATUS
NTAPI
ZwAllocateUserPhysicalPages(
    IN HANDLE ProcessHandle,
    IN OUT PULONG_PTR NumberOfPages,
    OUT PULONG_PTR UserPfnArray
    );
NTSYSAPI
NTSTATUS
NTAPI
ZwFreeUserPhysicalPages(
    IN HANDLE ProcessHandle,
    IN OUT PULONG_PTR NumberOfPages,
    IN PULONG_PTR UserPfnArray
    );
NTSYSAPI
NTSTATUS
NTAPI
ZwGetWriteWatch (
    IN HANDLE ProcessHandle,
    IN ULONG Flags,
    IN PVOID BaseAddress,
    IN SIZE_T RegionSize,
    IN OUT PVOID *UserAddressArray,
    IN OUT PULONG_PTR EntriesInUserAddressArray,
    OUT PULONG Granularity
    );
NTSYSAPI
NTSTATUS
NTAPI
ZwResetWriteWatch (
    IN HANDLE ProcessHandle,
    IN PVOID BaseAddress,
    IN SIZE_T RegionSize
    );
NTSYSAPI
NTSTATUS
NTAPI
ZwCreatePagingFile (
    IN PUNICODE_STRING PageFileName,
    IN PLARGE_INTEGER MinimumSize,
    IN PLARGE_INTEGER MaximumSize,
    IN ULONG Priority OPTIONAL
    );
NTSYSAPI
NTSTATUS
NTAPI
ZwFlushInstructionCache (
    IN HANDLE ProcessHandle,
    IN PVOID BaseAddress OPTIONAL,
    IN SIZE_T Length
    );
NTSYSAPI
NTSTATUS
NTAPI
ZwFlushWriteBuffer (
    VOID
    );
NTSYSAPI
NTSTATUS
NTAPI
ZwQueryObject(
    IN HANDLE Handle,
    IN OBJECT_INFORMATION_CLASS ObjectInformationClass,
    OUT PVOID ObjectInformation,
    IN ULONG Length,
    OUT PULONG ReturnLength OPTIONAL
    );
NTSYSAPI
NTSTATUS
NTAPI
ZwSetInformationObject(
    IN HANDLE Handle,
    IN OBJECT_INFORMATION_CLASS ObjectInformationClass,
    IN PVOID ObjectInformation,
    IN ULONG ObjectInformationLength
    );
NTSYSAPI
NTSTATUS
NTAPI
ZwDuplicateObject(
    IN HANDLE SourceProcessHandle,
    IN HANDLE SourceHandle,
    IN HANDLE TargetProcessHandle OPTIONAL,
    OUT PHANDLE TargetHandle OPTIONAL,
    IN ACCESS_MASK DesiredAccess,
    IN ULONG HandleAttributes,
    IN ULONG Options
    );
NTSYSAPI
NTSTATUS
NTAPI
ZwMakeTemporaryObject(
    IN HANDLE Handle
    );
NTSYSAPI
NTSTATUS
NTAPI
ZwMakePermanentObject(
    IN HANDLE Handle
    );
NTSYSAPI
NTSTATUS
NTAPI
ZwSignalAndWaitForSingleObject(
    IN HANDLE SignalHandle,
    IN HANDLE WaitHandle,
    IN BOOLEAN Alertable,
    IN PLARGE_INTEGER Timeout OPTIONAL
    );
NTSYSAPI
NTSTATUS
NTAPI
ZwWaitForSingleObject(
    IN HANDLE Handle,
    IN BOOLEAN Alertable,
    IN PLARGE_INTEGER Timeout OPTIONAL
    );
NTSYSAPI
NTSTATUS
NTAPI
ZwWaitForMultipleObjects(
    IN ULONG Count,
    IN HANDLE Handles[],
    IN WAIT_TYPE WaitType,
    IN BOOLEAN Alertable,
    IN PLARGE_INTEGER Timeout OPTIONAL
    );
NTSYSAPI
NTSTATUS
NTAPI
ZwSetSecurityObject(
    IN HANDLE Handle,
    IN SECURITY_INFORMATION SecurityInformation,
    IN PSECURITY_DESCRIPTOR SecurityDescriptor
    );
NTSYSAPI
NTSTATUS
NTAPI
ZwQuerySecurityObject(
    IN HANDLE Handle,
    IN SECURITY_INFORMATION SecurityInformation,
    OUT PSECURITY_DESCRIPTOR SecurityDescriptor,
    IN ULONG Length,
    OUT PULONG LengthNeeded
    );
NTSYSAPI
NTSTATUS
NTAPI
ZwClose(
    IN HANDLE Handle
    );
NTSYSAPI
NTSTATUS
NTAPI
ZwCreateDirectoryObject(
    OUT PHANDLE DirectoryHandle,
    IN ACCESS_MASK DesiredAccess,
    IN POBJECT_ATTRIBUTES ObjectAttributes
    );
NTSYSAPI
NTSTATUS
NTAPI
ZwOpenDirectoryObject(
    OUT PHANDLE DirectoryHandle,
    IN ACCESS_MASK DesiredAccess,
    IN POBJECT_ATTRIBUTES ObjectAttributes
    );
NTSYSAPI
NTSTATUS
NTAPI
ZwQueryDirectoryObject(
    IN HANDLE DirectoryHandle,
    OUT PVOID Buffer,
    IN ULONG Length,
    IN BOOLEAN ReturnSingleEntry,
    IN BOOLEAN RestartScan,
    IN OUT PULONG Context,
    OUT PULONG ReturnLength OPTIONAL
    );
NTSYSAPI
NTSTATUS
NTAPI
ZwCreateSymbolicLinkObject(
    OUT PHANDLE LinkHandle,
    IN ACCESS_MASK DesiredAccess,
    IN POBJECT_ATTRIBUTES ObjectAttributes,
    IN PUNICODE_STRING LinkTarget
    );
NTSYSAPI
NTSTATUS
NTAPI
ZwOpenSymbolicLinkObject(
    OUT PHANDLE LinkHandle,
    IN ACCESS_MASK DesiredAccess,
    IN POBJECT_ATTRIBUTES ObjectAttributes
    );
NTSYSAPI
NTSTATUS
NTAPI
ZwQuerySymbolicLinkObject(
    IN HANDLE LinkHandle,
    IN OUT PUNICODE_STRING LinkTarget,
    OUT PULONG ReturnedLength OPTIONAL
    );
NTSYSAPI
NTSTATUS
NTAPI
ZwGetPlugPlayEvent(
    IN  HANDLE EventHandle,
    IN  PVOID Context OPTIONAL,
    OUT PPLUGPLAY_EVENT_BLOCK EventBlock,
    IN  ULONG EventBufferLength
    );
NTSYSAPI
NTSTATUS
NTAPI
ZwPlugPlayControl(
    IN     PLUGPLAY_CONTROL_CLASS PnPControlClass,
    IN OUT PVOID PnPControlData,
    IN     ULONG PnPControlDataLength
    );
NTSYSAPI
NTSTATUS
NTAPI
ZwPowerInformation(
    IN POWER_INFORMATION_LEVEL InformationLevel,
    IN PVOID InputBuffer OPTIONAL,
    IN ULONG InputBufferLength,
    OUT PVOID OutputBuffer OPTIONAL,
    IN ULONG OutputBufferLength
    );
NTSYSAPI
NTSTATUS
NTAPI
ZwSetThreadExecutionState(
    IN EXECUTION_STATE esFlags,               // ES_xxx flags
    OUT EXECUTION_STATE *PreviousFlags
    );
NTSYSAPI
NTSTATUS
NTAPI
ZwRequestWakeupLatency(
    IN LATENCY_TIME latency
    );
NTSYSAPI
NTSTATUS
NTAPI
ZwInitiatePowerAction(
    IN POWER_ACTION SystemAction,
    IN SYSTEM_POWER_STATE MinSystemState,
    IN ULONG Flags,                 // POWER_ACTION_xxx flags
    IN BOOLEAN Asynchronous
    );
NTSYSAPI
NTSTATUS
NTAPI
ZwSetSystemPowerState(
    IN POWER_ACTION SystemAction,
    IN SYSTEM_POWER_STATE MinSystemState,
    IN ULONG Flags                  // POWER_ACTION_xxx flags
    );
NTSYSAPI
NTSTATUS
NTAPI
ZwGetDevicePowerState(
    IN HANDLE Device,
    OUT DEVICE_POWER_STATE *State
    );
NTSYSAPI
NTSTATUS
NTAPI
ZwCancelDeviceWakeupRequest(
    IN HANDLE Device
    );
NTSYSAPI
NTSTATUS
NTAPI
ZwRequestDeviceWakeup(
    IN HANDLE Device
    );
NTSYSAPI
NTSTATUS
NTAPI
ZwCreateProcess(
    OUT PHANDLE ProcessHandle,
    IN ACCESS_MASK DesiredAccess,
    IN POBJECT_ATTRIBUTES ObjectAttributes OPTIONAL,
    IN HANDLE ParentProcess,
    IN BOOLEAN InheritObjectTable,
    IN HANDLE SectionHandle OPTIONAL,
    IN HANDLE DebugPort OPTIONAL,
    IN HANDLE ExceptionPort OPTIONAL
    );
NTSYSAPI
NTSTATUS
NTAPI
ZwCreateProcessEx(
    OUT PHANDLE ProcessHandle,
    IN ACCESS_MASK DesiredAccess,
    IN POBJECT_ATTRIBUTES ObjectAttributes OPTIONAL,
    IN HANDLE ParentProcess,
    IN ULONG Flags,
    IN HANDLE SectionHandle OPTIONAL,
    IN HANDLE DebugPort OPTIONAL,
    IN HANDLE ExceptionPort OPTIONAL,
    IN ULONG JobMemberLevel
    );
NTSYSAPI
NTSTATUS
NTAPI
ZwOpenProcess (
    OUT PHANDLE ProcessHandle,
    IN ACCESS_MASK DesiredAccess,
    IN POBJECT_ATTRIBUTES ObjectAttributes,
    IN PCLIENT_ID ClientId OPTIONAL
    );
NTSYSAPI
NTSTATUS
NTAPI
ZwTerminateProcess(
    IN HANDLE ProcessHandle OPTIONAL,
    IN NTSTATUS ExitStatus
    );
NTSYSAPI
NTSTATUS
NTAPI
ZwQueryInformationProcess(
    IN HANDLE ProcessHandle,
    IN PROCESSINFOCLASS ProcessInformationClass,
    OUT PVOID ProcessInformation,
    IN ULONG ProcessInformationLength,
    OUT PULONG ReturnLength OPTIONAL
    );
NTSYSAPI
NTSTATUS
NTAPI
ZwQueryPortInformationProcess(
    VOID
    );
NTSYSAPI
NTSTATUS
NTAPI
ZwSetInformationProcess(
    IN HANDLE ProcessHandle,
    IN PROCESSINFOCLASS ProcessInformationClass,
    IN PVOID ProcessInformation,
    IN ULONG ProcessInformationLength
    );
NTSYSAPI
NTSTATUS
NTAPI
ZwCreateThread(
    OUT PHANDLE ThreadHandle,
    IN ACCESS_MASK DesiredAccess,
    IN POBJECT_ATTRIBUTES ObjectAttributes OPTIONAL,
    IN HANDLE ProcessHandle,
    OUT PCLIENT_ID ClientId,
    IN PCONTEXT ThreadContext,
    IN PINITIAL_TEB InitialTeb,
    IN BOOLEAN CreateSuspended
    );
NTSYSAPI
NTSTATUS
NTAPI
ZwOpenThread (
    OUT PHANDLE ThreadHandle,
    IN ACCESS_MASK DesiredAccess,
    IN POBJECT_ATTRIBUTES ObjectAttributes,
    IN PCLIENT_ID ClientId OPTIONAL
    );
NTSYSAPI
NTSTATUS
NTAPI
ZwTerminateThread(
    IN HANDLE ThreadHandle OPTIONAL,
    IN NTSTATUS ExitStatus
    );
NTSYSAPI
NTSTATUS
NTAPI
ZwSuspendThread(
    IN HANDLE ThreadHandle,
    OUT PULONG PreviousSuspendCount OPTIONAL
    );
NTSYSAPI
NTSTATUS
NTAPI
ZwResumeThread(
    IN HANDLE ThreadHandle,
    OUT PULONG PreviousSuspendCount OPTIONAL
    );
NTSYSAPI
NTSTATUS
NTAPI
ZwSuspendProcess (
    IN HANDLE ProcessHandle
    );
NTSYSAPI
NTSTATUS
NTAPI
ZwResumeProcess (
    IN HANDLE ProcessHandle
    );
NTSYSAPI
NTSTATUS
NTAPI
ZwGetContextThread(
    IN HANDLE ThreadHandle,
    IN OUT PCONTEXT ThreadContext
    );
NTSYSAPI
NTSTATUS
NTAPI
ZwSetContextThread(
    IN HANDLE ThreadHandle,
    IN PCONTEXT ThreadContext
    );
NTSYSAPI
NTSTATUS
NTAPI
ZwQueryInformationThread(
    IN HANDLE ThreadHandle,
    IN THREADINFOCLASS ThreadInformationClass,
    OUT PVOID ThreadInformation,
    IN ULONG ThreadInformationLength,
    OUT PULONG ReturnLength OPTIONAL
    );
NTSYSAPI
NTSTATUS
NTAPI
ZwSetInformationThread(
    IN HANDLE ThreadHandle,
    IN THREADINFOCLASS ThreadInformationClass,
    IN PVOID ThreadInformation,
    IN ULONG ThreadInformationLength
    );
NTSYSAPI
NTSTATUS
NTAPI
ZwAlertThread(
    IN HANDLE ThreadHandle
    );
NTSYSAPI
NTSTATUS
NTAPI
ZwAlertResumeThread(
    IN HANDLE ThreadHandle,
    OUT PULONG PreviousSuspendCount OPTIONAL
    );
NTSYSAPI
NTSTATUS
NTAPI
ZwImpersonateThread(
    IN HANDLE ServerThreadHandle,
    IN HANDLE ClientThreadHandle,
    IN PSECURITY_QUALITY_OF_SERVICE SecurityQos
    );
NTSYSAPI
NTSTATUS
NTAPI
ZwTestAlert(
    VOID
    );
NTSYSAPI
NTSTATUS
NTAPI
ZwRegisterThreadTerminatePort(
    IN HANDLE PortHandle
    );
NTSYSAPI
NTSTATUS
NTAPI
ZwSetLdtEntries(
    IN ULONG Selector0,
    IN ULONG Entry0Low,
    IN ULONG Entry0Hi,
    IN ULONG Selector1,
    IN ULONG Entry1Low,
    IN ULONG Entry1High
    );
NTSYSAPI
NTSTATUS
NTAPI
ZwQueueApcThread(
    IN HANDLE ThreadHandle,
    IN PPS_APC_ROUTINE ApcRoutine,
    IN PVOID ApcArgument1,
    IN PVOID ApcArgument2,
    IN PVOID ApcArgument3
    );
NTSYSAPI
NTSTATUS
NTAPI
ZwCreateJobObject (
    OUT PHANDLE JobHandle,
    IN ACCESS_MASK DesiredAccess,
    IN POBJECT_ATTRIBUTES ObjectAttributes OPTIONAL
    );
NTSYSAPI
NTSTATUS
NTAPI
ZwOpenJobObject(
    OUT PHANDLE JobHandle,
    IN ACCESS_MASK DesiredAccess,
    IN POBJECT_ATTRIBUTES ObjectAttributes
    );
NTSYSAPI
NTSTATUS
NTAPI
ZwAssignProcessToJobObject(
    IN HANDLE JobHandle,
    IN HANDLE ProcessHandle
    );
NTSYSAPI
NTSTATUS
NTAPI
ZwTerminateJobObject(
    IN HANDLE JobHandle,
    IN NTSTATUS ExitStatus
    );
NTSYSAPI
NTSTATUS
NTAPI
ZwIsProcessInJob (
    IN HANDLE ProcessHandle,
    IN HANDLE JobHandle
    );
NTSYSAPI
NTSTATUS
NTAPI
ZwCreateJobSet (
    IN ULONG NumJob,
    IN PJOB_SET_ARRAY UserJobSet,
    IN ULONG Flags);
NTSYSAPI
NTSTATUS
NTAPI
ZwQueryInformationJobObject(
    IN HANDLE JobHandle,
    IN JOBOBJECTINFOCLASS JobObjectInformationClass,
    OUT PVOID JobObjectInformation,
    IN ULONG JobObjectInformationLength,
    OUT PULONG ReturnLength OPTIONAL
    );
NTSYSAPI
NTSTATUS
NTAPI
ZwSetInformationJobObject(
    IN HANDLE JobHandle,
    IN JOBOBJECTINFOCLASS JobObjectInformationClass,
    IN PVOID JobObjectInformation,
    IN ULONG JobObjectInformationLength
    );
NTSYSAPI
NTSTATUS
NTAPI
ZwCreateKey(
    OUT PHANDLE KeyHandle,
    IN ACCESS_MASK DesiredAccess,
    IN POBJECT_ATTRIBUTES ObjectAttributes,
    IN ULONG TitleIndex,
    IN PUNICODE_STRING Class OPTIONAL,
    IN ULONG CreateOptions,
    OUT PULONG Disposition OPTIONAL
    );
NTSYSAPI
NTSTATUS
NTAPI
ZwDeleteKey(
    IN HANDLE KeyHandle
    );
NTSYSAPI
NTSTATUS
NTAPI
ZwDeleteValueKey(
    IN HANDLE KeyHandle,
    IN PUNICODE_STRING ValueName
    );
NTSYSAPI
NTSTATUS
NTAPI
ZwEnumerateKey(
    IN HANDLE KeyHandle,
    IN ULONG Index,
    IN KEY_INFORMATION_CLASS KeyInformationClass,
    OUT PVOID KeyInformation,
    IN ULONG Length,
    OUT PULONG ResultLength
    );
NTSYSAPI
NTSTATUS
NTAPI
ZwEnumerateValueKey(
    IN HANDLE KeyHandle,
    IN ULONG Index,
    IN KEY_VALUE_INFORMATION_CLASS KeyValueInformationClass,
    OUT PVOID KeyValueInformation,
    IN ULONG Length,
    OUT PULONG ResultLength
    );
NTSYSAPI
NTSTATUS
NTAPI
ZwFlushKey(
    IN HANDLE KeyHandle
    );
NTSYSAPI
NTSTATUS
NTAPI
ZwInitializeRegistry(
    IN USHORT BootCondition
    );
NTSYSAPI
NTSTATUS
NTAPI
ZwNotifyChangeKey(
    IN HANDLE KeyHandle,
    IN HANDLE Event OPTIONAL,
    IN PIO_APC_ROUTINE ApcRoutine OPTIONAL,
    IN PVOID ApcContext OPTIONAL,
    OUT PIO_STATUS_BLOCK IoStatusBlock,
    IN ULONG CompletionFilter,
    IN BOOLEAN WatchTree,
    OUT PVOID Buffer,
    IN ULONG BufferSize,
    IN BOOLEAN Asynchronous
    );
NTSYSAPI
NTSTATUS
NTAPI
ZwNotifyChangeMultipleKeys(
    IN HANDLE MasterKeyHandle,  		
    IN ULONG Count,
    IN OBJECT_ATTRIBUTES SlaveObjects[],
    IN HANDLE Event OPTIONAL,
    IN PIO_APC_ROUTINE ApcRoutine OPTIONAL,
    IN PVOID ApcContext OPTIONAL,
    OUT PIO_STATUS_BLOCK IoStatusBlock,
    IN ULONG CompletionFilter,
    IN BOOLEAN WatchTree,
    OUT PVOID Buffer,
    IN ULONG BufferSize,
    IN BOOLEAN Asynchronous
    );
NTSYSAPI
NTSTATUS
NTAPI
ZwLoadKey(
    IN POBJECT_ATTRIBUTES TargetKey,
    IN POBJECT_ATTRIBUTES SourceFile
    );
NTSYSAPI
NTSTATUS
NTAPI
ZwLoadKey2(
    IN POBJECT_ATTRIBUTES TargetKey,
    IN POBJECT_ATTRIBUTES SourceFile,
    IN ULONG Flags
    );
NTSYSAPI
NTSTATUS
NTAPI
ZwOpenKey(
    OUT PHANDLE KeyHandle,
    IN ACCESS_MASK DesiredAccess,
    IN POBJECT_ATTRIBUTES ObjectAttributes
    );
NTSYSAPI
NTSTATUS
NTAPI
ZwQueryKey(
    IN HANDLE KeyHandle,
    IN KEY_INFORMATION_CLASS KeyInformationClass,
    OUT PVOID KeyInformation,
    IN ULONG Length,
    OUT PULONG ResultLength
    );
NTSYSAPI
NTSTATUS
NTAPI
ZwQueryValueKey(
    IN HANDLE KeyHandle,
    IN PUNICODE_STRING ValueName,
    IN KEY_VALUE_INFORMATION_CLASS KeyValueInformationClass,
    OUT PVOID KeyValueInformation,
    IN ULONG Length,
    OUT PULONG ResultLength
    );
NTSYSAPI
NTSTATUS
NTAPI
ZwQueryMultipleValueKey(
    IN HANDLE KeyHandle,
    IN OUT PKEY_VALUE_ENTRY ValueEntries,
    IN ULONG EntryCount,
    OUT PVOID ValueBuffer,
    IN OUT PULONG BufferLength,
    OUT OPTIONAL PULONG RequiredBufferLength
    );
NTSYSAPI
NTSTATUS
NTAPI
ZwReplaceKey(
    IN POBJECT_ATTRIBUTES NewFile,
    IN HANDLE             TargetHandle,
    IN POBJECT_ATTRIBUTES OldFile
    );
NTSYSAPI
NTSTATUS
NTAPI
ZwRenameKey(
    IN HANDLE           KeyHandle,
    IN PUNICODE_STRING  NewName
    );
NTSYSAPI
NTSTATUS
NTAPI
ZwCompactKeys(
    IN ULONG Count,
    IN HANDLE KeyArray[]
            );
NTSYSAPI
NTSTATUS
NTAPI
ZwCompressKey(
    IN HANDLE Key
            );
NTSYSAPI
NTSTATUS
NTAPI
ZwRestoreKey(
    IN HANDLE KeyHandle,
    IN HANDLE FileHandle,
    IN ULONG  Flags
    );
NTSYSAPI
NTSTATUS
NTAPI
ZwSaveKey(
    IN HANDLE KeyHandle,
    IN HANDLE FileHandle
    );
NTSYSAPI
NTSTATUS
NTAPI
ZwSaveKeyEx(
    IN HANDLE KeyHandle,
    IN HANDLE FileHandle,
    IN ULONG  Format
    );
NTSYSAPI
NTSTATUS
NTAPI
ZwSaveMergedKeys(
    IN HANDLE HighPrecedenceKeyHandle,
    IN HANDLE LowPrecedenceKeyHandle,
    IN HANDLE FileHandle
    );
NTSYSAPI
NTSTATUS
NTAPI
ZwSetValueKey(
    IN HANDLE KeyHandle,
    IN PUNICODE_STRING ValueName,
    IN ULONG TitleIndex OPTIONAL,
    IN ULONG Type,
    IN PVOID Data,
    IN ULONG DataSize
    );
NTSYSAPI
NTSTATUS
NTAPI
ZwUnloadKey(
    IN POBJECT_ATTRIBUTES TargetKey
    );
NTSYSAPI
NTSTATUS
NTAPI
ZwUnloadKeyEx(
    IN POBJECT_ATTRIBUTES TargetKey,
    IN HANDLE Event OPTIONAL
    );
NTSYSAPI
NTSTATUS
NTAPI
ZwSetInformationKey(
    IN HANDLE KeyHandle,
    IN KEY_SET_INFORMATION_CLASS KeySetInformationClass,
    IN PVOID KeySetInformation,
    IN ULONG KeySetInformationLength
    );
NTSYSAPI
NTSTATUS
NTAPI
ZwQueryOpenSubKeys(
    IN POBJECT_ATTRIBUTES TargetKey,
    OUT PULONG  HandleCount
    );
NTSYSAPI
NTSTATUS
NTAPI
ZwLockRegistryKey(
    IN HANDLE           KeyHandle
    );
NTSYSAPI
NTSTATUS
NTAPI
ZwLockProductActivationKeys(
    ULONG   *pPrivateVer,
    ULONG   *pIsSafeMode
    );
NTSYSAPI
NTSTATUS
NTAPI
ZwAccessCheck (
    IN PSECURITY_DESCRIPTOR SecurityDescriptor,
    IN HANDLE ClientToken,
    IN ACCESS_MASK DesiredAccess,
    IN PGENERIC_MAPPING GenericMapping,
    OUT PPRIVILEGE_SET PrivilegeSet,
    IN OUT PULONG PrivilegeSetLength,
    OUT PACCESS_MASK GrantedAccess,
    OUT PNTSTATUS AccessStatus
    );
NTSYSAPI
NTSTATUS
NTAPI
ZwAccessCheckByType (
    IN PSECURITY_DESCRIPTOR SecurityDescriptor,
    IN PSID PrincipalSelfSid,
    IN HANDLE ClientToken,
    IN ACCESS_MASK DesiredAccess,
    IN POBJECT_TYPE_LIST ObjectTypeList,
    IN ULONG ObjectTypeListLength,
    IN PGENERIC_MAPPING GenericMapping,
    OUT PPRIVILEGE_SET PrivilegeSet,
    IN OUT PULONG PrivilegeSetLength,
    OUT PACCESS_MASK GrantedAccess,
    OUT PNTSTATUS AccessStatus
    );
NTSYSAPI
NTSTATUS
NTAPI
ZwAccessCheckByTypeResultList (
    IN PSECURITY_DESCRIPTOR SecurityDescriptor,
    IN PSID PrincipalSelfSid,
    IN HANDLE ClientToken,
    IN ACCESS_MASK DesiredAccess,
    IN POBJECT_TYPE_LIST ObjectTypeList,
    IN ULONG ObjectTypeListLength,
    IN PGENERIC_MAPPING GenericMapping,
    OUT PPRIVILEGE_SET PrivilegeSet,
    IN OUT PULONG PrivilegeSetLength,
    OUT PACCESS_MASK GrantedAccess,
    OUT PNTSTATUS AccessStatus
    );
NTSYSAPI
NTSTATUS
NTAPI
ZwCreateToken(
    OUT PHANDLE TokenHandle,
    IN ACCESS_MASK DesiredAccess,
    IN POBJECT_ATTRIBUTES ObjectAttributes OPTIONAL,
    IN TOKEN_TYPE TokenType,
    IN PLUID AuthenticationId,
    IN PLARGE_INTEGER ExpirationTime,
    IN PTOKEN_USER User,
    IN PTOKEN_GROUPS Groups,
    IN PTOKEN_PRIVILEGES Privileges,
    IN PTOKEN_OWNER Owner OPTIONAL,
    IN PTOKEN_PRIMARY_GROUP PrimaryGroup,
    IN PTOKEN_DEFAULT_DACL DefaultDacl OPTIONAL,
    IN PTOKEN_SOURCE TokenSource
    );
NTSYSAPI
NTSTATUS
NTAPI
ZwCompareTokens(
    IN HANDLE FirstTokenHandle,
    IN HANDLE SecondTokenHandle,
    OUT PBOOLEAN Equal
    );
NTSYSAPI
NTSTATUS
NTAPI
ZwOpenThreadToken(
    IN HANDLE ThreadHandle,
    IN ACCESS_MASK DesiredAccess,
    IN BOOLEAN OpenAsSelf,
    OUT PHANDLE TokenHandle
    );
NTSYSAPI
NTSTATUS
NTAPI
ZwOpenThreadTokenEx(
    IN HANDLE ThreadHandle,
    IN ACCESS_MASK DesiredAccess,
    IN BOOLEAN OpenAsSelf,
    IN ULONG HandleAttributes,
    OUT PHANDLE TokenHandle
    );
NTSYSAPI
NTSTATUS
NTAPI
ZwOpenProcessToken(
    IN HANDLE ProcessHandle,
    IN ACCESS_MASK DesiredAccess,
    OUT PHANDLE TokenHandle
    );
NTSYSAPI
NTSTATUS
NTAPI
ZwOpenProcessTokenEx(
    IN HANDLE ProcessHandle,
    IN ACCESS_MASK DesiredAccess,
    IN ULONG HandleAttributes,
    OUT PHANDLE TokenHandle
    );
NTSYSAPI
NTSTATUS
NTAPI
ZwOpenJobObjectToken(
    IN HANDLE JobHandle,
    IN ACCESS_MASK DesiredAccess,
    OUT PHANDLE TokenHandle
    );
NTSYSAPI
NTSTATUS
NTAPI
ZwDuplicateToken(
    IN HANDLE ExistingTokenHandle,
    IN ACCESS_MASK DesiredAccess,
    IN POBJECT_ATTRIBUTES ObjectAttributes,
    IN BOOLEAN EffectiveOnly,
    IN TOKEN_TYPE TokenType,
    OUT PHANDLE NewTokenHandle
    );
NTSYSAPI
NTSTATUS
NTAPI
ZwFilterToken (
    IN HANDLE ExistingTokenHandle,
    IN ULONG Flags,
    IN PTOKEN_GROUPS SidsToDisable OPTIONAL,
    IN PTOKEN_PRIVILEGES PrivilegesToDelete OPTIONAL,
    IN PTOKEN_GROUPS RestrictedSids OPTIONAL,
    OUT PHANDLE NewTokenHandle
    );
NTSYSAPI
NTSTATUS
NTAPI
ZwImpersonateAnonymousToken(
    IN HANDLE ThreadHandle
    );
NTSYSAPI
NTSTATUS
NTAPI
ZwQueryInformationToken (
    IN HANDLE TokenHandle,
    IN TOKEN_INFORMATION_CLASS TokenInformationClass,
    OUT PVOID TokenInformation,
    IN ULONG TokenInformationLength,
    OUT PULONG ReturnLength
    );
NTSYSAPI
NTSTATUS
NTAPI
ZwSetInformationToken (
    IN HANDLE TokenHandle,
    IN TOKEN_INFORMATION_CLASS TokenInformationClass,
    IN PVOID TokenInformation,
    IN ULONG TokenInformationLength
    );
NTSYSAPI
NTSTATUS
NTAPI
ZwAdjustPrivilegesToken (
    IN HANDLE TokenHandle,
    IN BOOLEAN DisableAllPrivileges,
    IN PTOKEN_PRIVILEGES NewState OPTIONAL,
    IN ULONG BufferLength OPTIONAL,
    OUT PTOKEN_PRIVILEGES PreviousState OPTIONAL,
    OUT PULONG ReturnLength
    );
NTSYSAPI
NTSTATUS
NTAPI
ZwAdjustGroupsToken (
    IN HANDLE TokenHandle,
    IN BOOLEAN ResetToDefault,
    IN PTOKEN_GROUPS NewState OPTIONAL,
    IN ULONG BufferLength OPTIONAL,
    OUT PTOKEN_GROUPS PreviousState OPTIONAL,
    OUT PULONG ReturnLength
    );
NTSYSAPI
NTSTATUS
NTAPI
ZwPrivilegeCheck (
    IN HANDLE ClientToken,
    IN OUT PPRIVILEGE_SET RequiredPrivileges,
    OUT PBOOLEAN Result
    );
NTSYSAPI
NTSTATUS
NTAPI
ZwAccessCheckAndAuditAlarm (
    IN PUNICODE_STRING SubsystemName,
    IN PVOID HandleId,
    IN PUNICODE_STRING ObjectTypeName,
    IN PUNICODE_STRING ObjectName,
    IN PSECURITY_DESCRIPTOR SecurityDescriptor,
    IN ACCESS_MASK DesiredAccess,
    IN PGENERIC_MAPPING GenericMapping,
    IN BOOLEAN ObjectCreation,
    OUT PACCESS_MASK GrantedAccess,
    OUT PNTSTATUS AccessStatus,
    OUT PBOOLEAN GenerateOnClose
    );
NTSYSAPI
NTSTATUS
NTAPI
ZwAccessCheckByTypeAndAuditAlarm (
    IN PUNICODE_STRING SubsystemName,
    IN PVOID HandleId,
    IN PUNICODE_STRING ObjectTypeName,
    IN PUNICODE_STRING ObjectName,
    IN PSECURITY_DESCRIPTOR SecurityDescriptor,
    IN PSID PrincipalSelfSid,
    IN ACCESS_MASK DesiredAccess,
    IN AUDIT_EVENT_TYPE AuditType,
    IN ULONG Flags,
    IN POBJECT_TYPE_LIST ObjectTypeList OPTIONAL,
    IN ULONG ObjectTypeListLength,
    IN PGENERIC_MAPPING GenericMapping,
    IN BOOLEAN ObjectCreation,
    OUT PACCESS_MASK GrantedAccess,
    OUT PNTSTATUS AccessStatus,
    OUT PBOOLEAN GenerateOnClose
    );
NTSYSAPI
NTSTATUS
NTAPI
ZwAccessCheckByTypeResultListAndAuditAlarm (
    IN PUNICODE_STRING SubsystemName,
    IN PVOID HandleId,
    IN PUNICODE_STRING ObjectTypeName,
    IN PUNICODE_STRING ObjectName,
    IN PSECURITY_DESCRIPTOR SecurityDescriptor,
    IN PSID PrincipalSelfSid,
    IN ACCESS_MASK DesiredAccess,
    IN AUDIT_EVENT_TYPE AuditType,
    IN ULONG Flags,
    IN POBJECT_TYPE_LIST ObjectTypeList OPTIONAL,
    IN ULONG ObjectTypeListLength,
    IN PGENERIC_MAPPING GenericMapping,
    IN BOOLEAN ObjectCreation,
    OUT PACCESS_MASK GrantedAccess,
    OUT PNTSTATUS AccessStatus,
    OUT PBOOLEAN GenerateOnClose
    );
NTSYSAPI
NTSTATUS
NTAPI
ZwAccessCheckByTypeResultListAndAuditAlarmByHandle (
    IN PUNICODE_STRING SubsystemName,
    IN PVOID HandleId,
    IN HANDLE ClientToken,
    IN PUNICODE_STRING ObjectTypeName,
    IN PUNICODE_STRING ObjectName,
    IN PSECURITY_DESCRIPTOR SecurityDescriptor,
    IN PSID PrincipalSelfSid,
    IN ACCESS_MASK DesiredAccess,
    IN AUDIT_EVENT_TYPE AuditType,
    IN ULONG Flags,
    IN POBJECT_TYPE_LIST ObjectTypeList OPTIONAL,
    IN ULONG ObjectTypeListLength,
    IN PGENERIC_MAPPING GenericMapping,
    IN BOOLEAN ObjectCreation,
    OUT PACCESS_MASK GrantedAccess,
    OUT PNTSTATUS AccessStatus,
    OUT PBOOLEAN GenerateOnClose
    );
NTSYSAPI
NTSTATUS
NTAPI
ZwOpenObjectAuditAlarm (
    IN PUNICODE_STRING SubsystemName,
    IN PVOID HandleId OPTIONAL,
    IN PUNICODE_STRING ObjectTypeName,
    IN PUNICODE_STRING ObjectName,
    IN PSECURITY_DESCRIPTOR SecurityDescriptor OPTIONAL,
    IN HANDLE ClientToken,
    IN ACCESS_MASK DesiredAccess,
    IN ACCESS_MASK GrantedAccess,
    IN PPRIVILEGE_SET Privileges OPTIONAL,
    IN BOOLEAN ObjectCreation,
    IN BOOLEAN AccessGranted,
    OUT PBOOLEAN GenerateOnClose
    );
NTSYSAPI
NTSTATUS
NTAPI
ZwPrivilegeObjectAuditAlarm (
    IN PUNICODE_STRING SubsystemName,
    IN PVOID HandleId,
    IN HANDLE ClientToken,
    IN ACCESS_MASK DesiredAccess,
    IN PPRIVILEGE_SET Privileges,
    IN BOOLEAN AccessGranted
    );
NTSYSAPI
NTSTATUS
NTAPI
ZwCloseObjectAuditAlarm (
    IN PUNICODE_STRING SubsystemName,
    IN PVOID HandleId,
    IN BOOLEAN GenerateOnClose
    );
NTSYSAPI
NTSTATUS
NTAPI
ZwDeleteObjectAuditAlarm (
    IN PUNICODE_STRING SubsystemName,
    IN PVOID HandleId,
    IN BOOLEAN GenerateOnClose
    );
NTSYSAPI
NTSTATUS
NTAPI
ZwPrivilegedServiceAuditAlarm (
    IN PUNICODE_STRING SubsystemName,
    IN PUNICODE_STRING ServiceName,
    IN HANDLE ClientToken,
    IN PPRIVILEGE_SET Privileges,
    IN BOOLEAN AccessGranted
    );
NTSYSAPI
NTSTATUS
NTAPI
ZwTraceEvent(
    IN HANDLE TraceHandle,
    IN ULONG  Flags,
    IN ULONG  FieldSize,
    IN PVOID  Fields
    );
NTSYSAPI
NTSTATUS
NTAPI
ZwContinue (
    IN PCONTEXT ContextRecord,
    IN BOOLEAN TestAlert
    );
NTSYSAPI
NTSTATUS
NTAPI
ZwRaiseException (
    IN PEXCEPTION_RECORD ExceptionRecord,
    IN PCONTEXT ContextRecord,
    IN BOOLEAN FirstChance
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\public\internal\com\inc\contxt.h ===
#pragma warning( disable: 4049 )  /* more than 64k source lines */

/* this ALWAYS GENERATED file contains the definitions for the interfaces */


 /* File created by MIDL compiler version 6.00.0347 */
/* Compiler settings for contxt.idl:
    Oicf, W1, Zp8, env=Win32 (32b run)
    protocol : dce , ms_ext, c_ext, oldnames, robust
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )


/* verify that the <rpcndr.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCNDR_H_VERSION__
#define __REQUIRED_RPCNDR_H_VERSION__ 475
#endif

#include "rpc.h"
#include "rpcndr.h"

#ifndef __RPCNDR_H_VERSION__
#error this stub requires an updated version of <rpcndr.h>
#endif // __RPCNDR_H_VERSION__

#ifndef COM_NO_WINDOWS_H
#include "windows.h"
#include "ole2.h"
#endif /*COM_NO_WINDOWS_H*/

#ifndef __contxt_h__
#define __contxt_h__

#if defined(_MSC_VER) && (_MSC_VER >= 1020)
#pragma once
#endif

/* Forward Declarations */ 

#ifndef __IEnumContextProps_FWD_DEFINED__
#define __IEnumContextProps_FWD_DEFINED__
typedef interface IEnumContextProps IEnumContextProps;
#endif 	/* __IEnumContextProps_FWD_DEFINED__ */


#ifndef __IContext_FWD_DEFINED__
#define __IContext_FWD_DEFINED__
typedef interface IContext IContext;
#endif 	/* __IContext_FWD_DEFINED__ */


#ifndef __IContextMarshaler_FWD_DEFINED__
#define __IContextMarshaler_FWD_DEFINED__
typedef interface IContextMarshaler IContextMarshaler;
#endif 	/* __IContextMarshaler_FWD_DEFINED__ */


#ifndef __IObjContext_FWD_DEFINED__
#define __IObjContext_FWD_DEFINED__
typedef interface IObjContext IObjContext;
#endif 	/* __IObjContext_FWD_DEFINED__ */


#ifndef __IGetContextId_FWD_DEFINED__
#define __IGetContextId_FWD_DEFINED__
typedef interface IGetContextId IGetContextId;
#endif 	/* __IGetContextId_FWD_DEFINED__ */


#ifndef __IAggregator_FWD_DEFINED__
#define __IAggregator_FWD_DEFINED__
typedef interface IAggregator IAggregator;
#endif 	/* __IAggregator_FWD_DEFINED__ */


#ifndef __ICall_FWD_DEFINED__
#define __ICall_FWD_DEFINED__
typedef interface ICall ICall;
#endif 	/* __ICall_FWD_DEFINED__ */


#ifndef __IRpcCall_FWD_DEFINED__
#define __IRpcCall_FWD_DEFINED__
typedef interface IRpcCall IRpcCall;
#endif 	/* __IRpcCall_FWD_DEFINED__ */


#ifndef __ICallInfo_FWD_DEFINED__
#define __ICallInfo_FWD_DEFINED__
typedef interface ICallInfo ICallInfo;
#endif 	/* __ICallInfo_FWD_DEFINED__ */


#ifndef __IPolicy_FWD_DEFINED__
#define __IPolicy_FWD_DEFINED__
typedef interface IPolicy IPolicy;
#endif 	/* __IPolicy_FWD_DEFINED__ */


#ifndef __IPolicyAsync_FWD_DEFINED__
#define __IPolicyAsync_FWD_DEFINED__
typedef interface IPolicyAsync IPolicyAsync;
#endif 	/* __IPolicyAsync_FWD_DEFINED__ */


#ifndef __IPolicySet_FWD_DEFINED__
#define __IPolicySet_FWD_DEFINED__
typedef interface IPolicySet IPolicySet;
#endif 	/* __IPolicySet_FWD_DEFINED__ */


#ifndef __IComObjIdentity_FWD_DEFINED__
#define __IComObjIdentity_FWD_DEFINED__
typedef interface IComObjIdentity IComObjIdentity;
#endif 	/* __IComObjIdentity_FWD_DEFINED__ */


#ifndef __IPolicyMaker_FWD_DEFINED__
#define __IPolicyMaker_FWD_DEFINED__
typedef interface IPolicyMaker IPolicyMaker;
#endif 	/* __IPolicyMaker_FWD_DEFINED__ */


#ifndef __IExceptionNotification_FWD_DEFINED__
#define __IExceptionNotification_FWD_DEFINED__
typedef interface IExceptionNotification IExceptionNotification;
#endif 	/* __IExceptionNotification_FWD_DEFINED__ */


#ifndef __IAbandonmentNotification_FWD_DEFINED__
#define __IAbandonmentNotification_FWD_DEFINED__
typedef interface IAbandonmentNotification IAbandonmentNotification;
#endif 	/* __IAbandonmentNotification_FWD_DEFINED__ */


#ifndef __IMarshalEnvoy_FWD_DEFINED__
#define __IMarshalEnvoy_FWD_DEFINED__
typedef interface IMarshalEnvoy IMarshalEnvoy;
#endif 	/* __IMarshalEnvoy_FWD_DEFINED__ */


#ifndef __IWrapperInfo_FWD_DEFINED__
#define __IWrapperInfo_FWD_DEFINED__
typedef interface IWrapperInfo IWrapperInfo;
#endif 	/* __IWrapperInfo_FWD_DEFINED__ */


#ifndef __IComDispatchInfo_FWD_DEFINED__
#define __IComDispatchInfo_FWD_DEFINED__
typedef interface IComDispatchInfo IComDispatchInfo;
#endif 	/* __IComDispatchInfo_FWD_DEFINED__ */


/* header files for imported files */
#include "wtypes.h"
#include "objidl.h"

#ifdef __cplusplus
extern "C"{
#endif 

void * __RPC_USER MIDL_user_allocate(size_t);
void __RPC_USER MIDL_user_free( void * ); 

/* interface __MIDL_itf_contxt_0000 */
/* [local] */ 

//+-----------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1997.
//
//------------------------------------------------------------------

enum tagCONTEXTEVENT
    {	CONTEXTEVENT_NONE	= 0,
	CONTEXTEVENT_CALL	= 0x1,
	CONTEXTEVENT_ENTER	= 0x2,
	CONTEXTEVENT_LEAVE	= 0x4,
	CONTEXTEVENT_RETURN	= 0x8,
	CONTEXTEVENT_CALLFILLBUFFER	= 0x10,
	CONTEXTEVENT_ENTERWITHBUFFER	= 0x20,
	CONTEXTEVENT_LEAVEFILLBUFFER	= 0x40,
	CONTEXTEVENT_RETURNWITHBUFFER	= 0x80,
	CONTEXTEVENT_BEGINCALL	= 0x100,
	CONTEXTEVENT_BEGINENTER	= 0x200,
	CONTEXTEVENT_BEGINLEAVE	= 0x400,
	CONTEXTEVENT_BEGINRETURN	= 0x800,
	CONTEXTEVENT_FINISHCALL	= 0x1000,
	CONTEXTEVENT_FINISHENTER	= 0x2000,
	CONTEXTEVENT_FINISHLEAVE	= 0x4000,
	CONTEXTEVENT_FINISHRETURN	= 0x8000,
	CONTEXTEVENT_BEGINCALLFILLBUFFER	= 0x10000,
	CONTEXTEVENT_BEGINENTERWITHBUFFER	= 0x20000,
	CONTEXTEVENT_FINISHLEAVEFILLBUFFER	= 0x40000,
	CONTEXTEVENT_FINISHRETURNWITHBUFFER	= 0x80000,
	CONTEXTEVENT_LEAVEEXCEPTION	= 0x100000,
	CONTEXTEVENT_LEAVEEXCEPTIONFILLBUFFER	= 0x200000,
	CONTEXTEVENT_RETURNEXCEPTION	= 0x400000,
	CONTEXTEVENT_RETURNEXCEPTIONWITHBUFFER	= 0x800000,
	CONTEXTEVENT_ADDREFPOLICY	= 0x10000000,
	CONTEXTEVENT_RELEASEPOLICY	= 0x20000000
    } ;
typedef DWORD ContextEvent;


enum tagCPFLAGS
    {	CPFLAG_NONE	= 0,
	CPFLAG_PROPAGATE	= 0x1,
	CPFLAG_EXPOSE	= 0x2,
	CPFLAG_ENVOY	= 0x4,
	CPFLAG_MONITORSTUB	= 0x8,
	CPFLAG_MONITORPROXY	= 0x10,
	CPFLAG_DONTCOMPARE	= 0x20
    } ;
typedef DWORD CPFLAGS;

typedef struct tagContextProperty
    {
    GUID policyId;
    CPFLAGS flags;
    /* [unique] */ IUnknown *pUnk;
    } 	ContextProperty;



extern RPC_IF_HANDLE __MIDL_itf_contxt_0000_ClientIfHandle;
extern RPC_IF_HANDLE __MIDL_itf_contxt_0000_ServerIfHandle;

#ifndef __IEnumContextProps_INTERFACE_DEFINED__
#define __IEnumContextProps_INTERFACE_DEFINED__

/* interface IEnumContextProps */
/* [unique][uuid][object] */ 

typedef /* [unique] */ IEnumContextProps *LPENUMCONTEXTPROPS;


EXTERN_C const IID IID_IEnumContextProps;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("000001c1-0000-0000-C000-000000000046")
    IEnumContextProps : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Next( 
            /* [in] */ ULONG celt,
            /* [length_is][size_is][out] */ ContextProperty *pContextProperties,
            /* [out] */ ULONG *pceltFetched) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Skip( 
            /* [in] */ ULONG celt) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Reset( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Clone( 
            /* [out] */ IEnumContextProps **ppEnumContextProps) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Count( 
            /* [out] */ ULONG *pcelt) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IEnumContextPropsVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IEnumContextProps * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IEnumContextProps * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IEnumContextProps * This);
        
        HRESULT ( STDMETHODCALLTYPE *Next )( 
            IEnumContextProps * This,
            /* [in] */ ULONG celt,
            /* [length_is][size_is][out] */ ContextProperty *pContextProperties,
            /* [out] */ ULONG *pceltFetched);
        
        HRESULT ( STDMETHODCALLTYPE *Skip )( 
            IEnumContextProps * This,
            /* [in] */ ULONG celt);
        
        HRESULT ( STDMETHODCALLTYPE *Reset )( 
            IEnumContextProps * This);
        
        HRESULT ( STDMETHODCALLTYPE *Clone )( 
            IEnumContextProps * This,
            /* [out] */ IEnumContextProps **ppEnumContextProps);
        
        HRESULT ( STDMETHODCALLTYPE *Count )( 
            IEnumContextProps * This,
            /* [out] */ ULONG *pcelt);
        
        END_INTERFACE
    } IEnumContextPropsVtbl;

    interface IEnumContextProps
    {
        CONST_VTBL struct IEnumContextPropsVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IEnumContextProps_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IEnumContextProps_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IEnumContextProps_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IEnumContextProps_Next(This,celt,pContextProperties,pceltFetched)	\
    (This)->lpVtbl -> Next(This,celt,pContextProperties,pceltFetched)

#define IEnumContextProps_Skip(This,celt)	\
    (This)->lpVtbl -> Skip(This,celt)

#define IEnumContextProps_Reset(This)	\
    (This)->lpVtbl -> Reset(This)

#define IEnumContextProps_Clone(This,ppEnumContextProps)	\
    (This)->lpVtbl -> Clone(This,ppEnumContextProps)

#define IEnumContextProps_Count(This,pcelt)	\
    (This)->lpVtbl -> Count(This,pcelt)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IEnumContextProps_Next_Proxy( 
    IEnumContextProps * This,
    /* [in] */ ULONG celt,
    /* [length_is][size_is][out] */ ContextProperty *pContextProperties,
    /* [out] */ ULONG *pceltFetched);


void __RPC_STUB IEnumContextProps_Next_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumContextProps_Skip_Proxy( 
    IEnumContextProps * This,
    /* [in] */ ULONG celt);


void __RPC_STUB IEnumContextProps_Skip_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumContextProps_Reset_Proxy( 
    IEnumContextProps * This);


void __RPC_STUB IEnumContextProps_Reset_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumContextProps_Clone_Proxy( 
    IEnumContextProps * This,
    /* [out] */ IEnumContextProps **ppEnumContextProps);


void __RPC_STUB IEnumContextProps_Clone_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumContextProps_Count_Proxy( 
    IEnumContextProps * This,
    /* [out] */ ULONG *pcelt);


void __RPC_STUB IEnumContextProps_Count_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IEnumContextProps_INTERFACE_DEFINED__ */


#ifndef __IContext_INTERFACE_DEFINED__
#define __IContext_INTERFACE_DEFINED__

/* interface IContext */
/* [unique][uuid][object][local] */ 


EXTERN_C const IID IID_IContext;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("000001c0-0000-0000-C000-000000000046")
    IContext : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE SetProperty( 
            /* [in] */ REFGUID rpolicyId,
            /* [in] */ CPFLAGS flags,
            /* [in] */ IUnknown *pUnk) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE RemoveProperty( 
            /* [in] */ REFGUID rPolicyId) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetProperty( 
            /* [in] */ REFGUID rGuid,
            /* [out] */ CPFLAGS *pFlags,
            /* [out] */ IUnknown **ppUnk) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE EnumContextProps( 
            /* [out] */ IEnumContextProps **ppEnumContextProps) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IContextVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IContext * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IContext * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IContext * This);
        
        HRESULT ( STDMETHODCALLTYPE *SetProperty )( 
            IContext * This,
            /* [in] */ REFGUID rpolicyId,
            /* [in] */ CPFLAGS flags,
            /* [in] */ IUnknown *pUnk);
        
        HRESULT ( STDMETHODCALLTYPE *RemoveProperty )( 
            IContext * This,
            /* [in] */ REFGUID rPolicyId);
        
        HRESULT ( STDMETHODCALLTYPE *GetProperty )( 
            IContext * This,
            /* [in] */ REFGUID rGuid,
            /* [out] */ CPFLAGS *pFlags,
            /* [out] */ IUnknown **ppUnk);
        
        HRESULT ( STDMETHODCALLTYPE *EnumContextProps )( 
            IContext * This,
            /* [out] */ IEnumContextProps **ppEnumContextProps);
        
        END_INTERFACE
    } IContextVtbl;

    interface IContext
    {
        CONST_VTBL struct IContextVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IContext_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IContext_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IContext_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IContext_SetProperty(This,rpolicyId,flags,pUnk)	\
    (This)->lpVtbl -> SetProperty(This,rpolicyId,flags,pUnk)

#define IContext_RemoveProperty(This,rPolicyId)	\
    (This)->lpVtbl -> RemoveProperty(This,rPolicyId)

#define IContext_GetProperty(This,rGuid,pFlags,ppUnk)	\
    (This)->lpVtbl -> GetProperty(This,rGuid,pFlags,ppUnk)

#define IContext_EnumContextProps(This,ppEnumContextProps)	\
    (This)->lpVtbl -> EnumContextProps(This,ppEnumContextProps)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IContext_SetProperty_Proxy( 
    IContext * This,
    /* [in] */ REFGUID rpolicyId,
    /* [in] */ CPFLAGS flags,
    /* [in] */ IUnknown *pUnk);


void __RPC_STUB IContext_SetProperty_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IContext_RemoveProperty_Proxy( 
    IContext * This,
    /* [in] */ REFGUID rPolicyId);


void __RPC_STUB IContext_RemoveProperty_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IContext_GetProperty_Proxy( 
    IContext * This,
    /* [in] */ REFGUID rGuid,
    /* [out] */ CPFLAGS *pFlags,
    /* [out] */ IUnknown **ppUnk);


void __RPC_STUB IContext_GetProperty_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IContext_EnumContextProps_Proxy( 
    IContext * This,
    /* [out] */ IEnumContextProps **ppEnumContextProps);


void __RPC_STUB IContext_EnumContextProps_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IContext_INTERFACE_DEFINED__ */


#ifndef __IContextMarshaler_INTERFACE_DEFINED__
#define __IContextMarshaler_INTERFACE_DEFINED__

/* interface IContextMarshaler */
/* [uuid][object][local] */ 

typedef /* [unique] */ IContextMarshaler *LPCTXMARSHALER;


EXTERN_C const IID IID_IContextMarshaler;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("000001D8-0000-0000-C000-000000000046")
    IContextMarshaler : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetMarshalSizeMax( 
            /* [in] */ REFIID riid,
            /* [unique][in] */ void *pv,
            /* [in] */ DWORD dwDestContext,
            /* [unique][in] */ void *pvDestContext,
            /* [in] */ DWORD mshlflags,
            /* [out] */ DWORD *pSize) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE MarshalInterface( 
            /* [unique][in] */ IStream *pStm,
            /* [in] */ REFIID riid,
            /* [unique][in] */ void *pv,
            /* [in] */ DWORD dwDestContext,
            /* [unique][in] */ void *pvDestContext,
            /* [in] */ DWORD mshlflags) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IContextMarshalerVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IContextMarshaler * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IContextMarshaler * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IContextMarshaler * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetMarshalSizeMax )( 
            IContextMarshaler * This,
            /* [in] */ REFIID riid,
            /* [unique][in] */ void *pv,
            /* [in] */ DWORD dwDestContext,
            /* [unique][in] */ void *pvDestContext,
            /* [in] */ DWORD mshlflags,
            /* [out] */ DWORD *pSize);
        
        HRESULT ( STDMETHODCALLTYPE *MarshalInterface )( 
            IContextMarshaler * This,
            /* [unique][in] */ IStream *pStm,
            /* [in] */ REFIID riid,
            /* [unique][in] */ void *pv,
            /* [in] */ DWORD dwDestContext,
            /* [unique][in] */ void *pvDestContext,
            /* [in] */ DWORD mshlflags);
        
        END_INTERFACE
    } IContextMarshalerVtbl;

    interface IContextMarshaler
    {
        CONST_VTBL struct IContextMarshalerVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IContextMarshaler_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IContextMarshaler_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IContextMarshaler_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IContextMarshaler_GetMarshalSizeMax(This,riid,pv,dwDestContext,pvDestContext,mshlflags,pSize)	\
    (This)->lpVtbl -> GetMarshalSizeMax(This,riid,pv,dwDestContext,pvDestContext,mshlflags,pSize)

#define IContextMarshaler_MarshalInterface(This,pStm,riid,pv,dwDestContext,pvDestContext,mshlflags)	\
    (This)->lpVtbl -> MarshalInterface(This,pStm,riid,pv,dwDestContext,pvDestContext,mshlflags)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IContextMarshaler_GetMarshalSizeMax_Proxy( 
    IContextMarshaler * This,
    /* [in] */ REFIID riid,
    /* [unique][in] */ void *pv,
    /* [in] */ DWORD dwDestContext,
    /* [unique][in] */ void *pvDestContext,
    /* [in] */ DWORD mshlflags,
    /* [out] */ DWORD *pSize);


void __RPC_STUB IContextMarshaler_GetMarshalSizeMax_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IContextMarshaler_MarshalInterface_Proxy( 
    IContextMarshaler * This,
    /* [unique][in] */ IStream *pStm,
    /* [in] */ REFIID riid,
    /* [unique][in] */ void *pv,
    /* [in] */ DWORD dwDestContext,
    /* [unique][in] */ void *pvDestContext,
    /* [in] */ DWORD mshlflags);


void __RPC_STUB IContextMarshaler_MarshalInterface_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IContextMarshaler_INTERFACE_DEFINED__ */


#ifndef __IObjContext_INTERFACE_DEFINED__
#define __IObjContext_INTERFACE_DEFINED__

/* interface IObjContext */
/* [unique][uuid][object][local] */ 

typedef /* [ref] */ HRESULT ( __stdcall *PFNCTXCALLBACK )( 
    void *pParam);


EXTERN_C const IID IID_IObjContext;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("000001c6-0000-0000-C000-000000000046")
    IObjContext : public IContext
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Freeze( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE DoCallback( 
            /* [in] */ PFNCTXCALLBACK pfnCallback,
            /* [in] */ void *pParam,
            /* [in] */ REFIID riid,
            /* [in] */ unsigned int iMethod) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetContextMarshaler( 
            /* [in] */ IContextMarshaler *pICM) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetContextMarshaler( 
            /* [out] */ IContextMarshaler **pICM) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetContextFlags( 
            /* [in] */ DWORD dwFlags) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ClearContextFlags( 
            /* [in] */ DWORD dwFlags) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetContextFlags( 
            /* [out] */ DWORD *pdwFlags) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IObjContextVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IObjContext * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IObjContext * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IObjContext * This);
        
        HRESULT ( STDMETHODCALLTYPE *SetProperty )( 
            IObjContext * This,
            /* [in] */ REFGUID rpolicyId,
            /* [in] */ CPFLAGS flags,
            /* [in] */ IUnknown *pUnk);
        
        HRESULT ( STDMETHODCALLTYPE *RemoveProperty )( 
            IObjContext * This,
            /* [in] */ REFGUID rPolicyId);
        
        HRESULT ( STDMETHODCALLTYPE *GetProperty )( 
            IObjContext * This,
            /* [in] */ REFGUID rGuid,
            /* [out] */ CPFLAGS *pFlags,
            /* [out] */ IUnknown **ppUnk);
        
        HRESULT ( STDMETHODCALLTYPE *EnumContextProps )( 
            IObjContext * This,
            /* [out] */ IEnumContextProps **ppEnumContextProps);
        
        HRESULT ( STDMETHODCALLTYPE *Freeze )( 
            IObjContext * This);
        
        HRESULT ( STDMETHODCALLTYPE *DoCallback )( 
            IObjContext * This,
            /* [in] */ PFNCTXCALLBACK pfnCallback,
            /* [in] */ void *pParam,
            /* [in] */ REFIID riid,
            /* [in] */ unsigned int iMethod);
        
        HRESULT ( STDMETHODCALLTYPE *SetContextMarshaler )( 
            IObjContext * This,
            /* [in] */ IContextMarshaler *pICM);
        
        HRESULT ( STDMETHODCALLTYPE *GetContextMarshaler )( 
            IObjContext * This,
            /* [out] */ IContextMarshaler **pICM);
        
        HRESULT ( STDMETHODCALLTYPE *SetContextFlags )( 
            IObjContext * This,
            /* [in] */ DWORD dwFlags);
        
        HRESULT ( STDMETHODCALLTYPE *ClearContextFlags )( 
            IObjContext * This,
            /* [in] */ DWORD dwFlags);
        
        HRESULT ( STDMETHODCALLTYPE *GetContextFlags )( 
            IObjContext * This,
            /* [out] */ DWORD *pdwFlags);
        
        END_INTERFACE
    } IObjContextVtbl;

    interface IObjContext
    {
        CONST_VTBL struct IObjContextVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IObjContext_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IObjContext_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IObjContext_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IObjContext_SetProperty(This,rpolicyId,flags,pUnk)	\
    (This)->lpVtbl -> SetProperty(This,rpolicyId,flags,pUnk)

#define IObjContext_RemoveProperty(This,rPolicyId)	\
    (This)->lpVtbl -> RemoveProperty(This,rPolicyId)

#define IObjContext_GetProperty(This,rGuid,pFlags,ppUnk)	\
    (This)->lpVtbl -> GetProperty(This,rGuid,pFlags,ppUnk)

#define IObjContext_EnumContextProps(This,ppEnumContextProps)	\
    (This)->lpVtbl -> EnumContextProps(This,ppEnumContextProps)


#define IObjContext_Freeze(This)	\
    (This)->lpVtbl -> Freeze(This)

#define IObjContext_DoCallback(This,pfnCallback,pParam,riid,iMethod)	\
    (This)->lpVtbl -> DoCallback(This,pfnCallback,pParam,riid,iMethod)

#define IObjContext_SetContextMarshaler(This,pICM)	\
    (This)->lpVtbl -> SetContextMarshaler(This,pICM)

#define IObjContext_GetContextMarshaler(This,pICM)	\
    (This)->lpVtbl -> GetContextMarshaler(This,pICM)

#define IObjContext_SetContextFlags(This,dwFlags)	\
    (This)->lpVtbl -> SetContextFlags(This,dwFlags)

#define IObjContext_ClearContextFlags(This,dwFlags)	\
    (This)->lpVtbl -> ClearContextFlags(This,dwFlags)

#define IObjContext_GetContextFlags(This,pdwFlags)	\
    (This)->lpVtbl -> GetContextFlags(This,pdwFlags)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IObjContext_Freeze_Proxy( 
    IObjContext * This);


void __RPC_STUB IObjContext_Freeze_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IObjContext_DoCallback_Proxy( 
    IObjContext * This,
    /* [in] */ PFNCTXCALLBACK pfnCallback,
    /* [in] */ void *pParam,
    /* [in] */ REFIID riid,
    /* [in] */ unsigned int iMethod);


void __RPC_STUB IObjContext_DoCallback_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IObjContext_SetContextMarshaler_Proxy( 
    IObjContext * This,
    /* [in] */ IContextMarshaler *pICM);


void __RPC_STUB IObjContext_SetContextMarshaler_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IObjContext_GetContextMarshaler_Proxy( 
    IObjContext * This,
    /* [out] */ IContextMarshaler **pICM);


void __RPC_STUB IObjContext_GetContextMarshaler_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IObjContext_SetContextFlags_Proxy( 
    IObjContext * This,
    /* [in] */ DWORD dwFlags);


void __RPC_STUB IObjContext_SetContextFlags_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IObjContext_ClearContextFlags_Proxy( 
    IObjContext * This,
    /* [in] */ DWORD dwFlags);


void __RPC_STUB IObjContext_ClearContextFlags_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IObjContext_GetContextFlags_Proxy( 
    IObjContext * This,
    /* [out] */ DWORD *pdwFlags);


void __RPC_STUB IObjContext_GetContextFlags_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IObjContext_INTERFACE_DEFINED__ */


#ifndef __IGetContextId_INTERFACE_DEFINED__
#define __IGetContextId_INTERFACE_DEFINED__

/* interface IGetContextId */
/* [unique][uuid][object][local] */ 


EXTERN_C const IID IID_IGetContextId;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("000001dd-0000-0000-C000-000000000046")
    IGetContextId : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetContextId( 
            /* [out] */ GUID *pguidCtxtId) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IGetContextIdVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IGetContextId * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IGetContextId * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IGetContextId * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetContextId )( 
            IGetContextId * This,
            /* [out] */ GUID *pguidCtxtId);
        
        END_INTERFACE
    } IGetContextIdVtbl;

    interface IGetContextId
    {
        CONST_VTBL struct IGetContextIdVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IGetContextId_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IGetContextId_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IGetContextId_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IGetContextId_GetContextId(This,pguidCtxtId)	\
    (This)->lpVtbl -> GetContextId(This,pguidCtxtId)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IGetContextId_GetContextId_Proxy( 
    IGetContextId * This,
    /* [out] */ GUID *pguidCtxtId);


void __RPC_STUB IGetContextId_GetContextId_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IGetContextId_INTERFACE_DEFINED__ */


#ifndef __IAggregator_INTERFACE_DEFINED__
#define __IAggregator_INTERFACE_DEFINED__

/* interface IAggregator */
/* [unique][uuid][object][local] */ 

typedef /* [unique] */ IAggregator *IAGGREGATOR;


EXTERN_C const IID IID_IAggregator;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("000001d8-0000-0000-C000-000000000046")
    IAggregator : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Aggregate( 
            /* [in] */ IUnknown *pInnerUnk) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IAggregatorVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IAggregator * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IAggregator * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IAggregator * This);
        
        HRESULT ( STDMETHODCALLTYPE *Aggregate )( 
            IAggregator * This,
            /* [in] */ IUnknown *pInnerUnk);
        
        END_INTERFACE
    } IAggregatorVtbl;

    interface IAggregator
    {
        CONST_VTBL struct IAggregatorVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IAggregator_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IAggregator_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IAggregator_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IAggregator_Aggregate(This,pInnerUnk)	\
    (This)->lpVtbl -> Aggregate(This,pInnerUnk)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IAggregator_Aggregate_Proxy( 
    IAggregator * This,
    /* [in] */ IUnknown *pInnerUnk);


void __RPC_STUB IAggregator_Aggregate_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IAggregator_INTERFACE_DEFINED__ */


#ifndef __ICall_INTERFACE_DEFINED__
#define __ICall_INTERFACE_DEFINED__

/* interface ICall */
/* [unique][uuid][object][local] */ 

typedef /* [unique] */ ICall *LPCALL;


EXTERN_C const IID IID_ICall;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("000001d6-0000-0000-C000-000000000046")
    ICall : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetCallInfo( 
            /* [out] */ const void **ppIdentity,
            /* [out] */ IID *piid,
            /* [out] */ DWORD *pdwMethod,
            /* [out] */ HRESULT *phr) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Nullify( 
            /* [in] */ HRESULT hr) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetServerHR( 
            /* [out] */ HRESULT *phr) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ICallVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ICall * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ICall * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ICall * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetCallInfo )( 
            ICall * This,
            /* [out] */ const void **ppIdentity,
            /* [out] */ IID *piid,
            /* [out] */ DWORD *pdwMethod,
            /* [out] */ HRESULT *phr);
        
        HRESULT ( STDMETHODCALLTYPE *Nullify )( 
            ICall * This,
            /* [in] */ HRESULT hr);
        
        HRESULT ( STDMETHODCALLTYPE *GetServerHR )( 
            ICall * This,
            /* [out] */ HRESULT *phr);
        
        END_INTERFACE
    } ICallVtbl;

    interface ICall
    {
        CONST_VTBL struct ICallVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ICall_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ICall_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ICall_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ICall_GetCallInfo(This,ppIdentity,piid,pdwMethod,phr)	\
    (This)->lpVtbl -> GetCallInfo(This,ppIdentity,piid,pdwMethod,phr)

#define ICall_Nullify(This,hr)	\
    (This)->lpVtbl -> Nullify(This,hr)

#define ICall_GetServerHR(This,phr)	\
    (This)->lpVtbl -> GetServerHR(This,phr)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE ICall_GetCallInfo_Proxy( 
    ICall * This,
    /* [out] */ const void **ppIdentity,
    /* [out] */ IID *piid,
    /* [out] */ DWORD *pdwMethod,
    /* [out] */ HRESULT *phr);


void __RPC_STUB ICall_GetCallInfo_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICall_Nullify_Proxy( 
    ICall * This,
    /* [in] */ HRESULT hr);


void __RPC_STUB ICall_Nullify_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICall_GetServerHR_Proxy( 
    ICall * This,
    /* [out] */ HRESULT *phr);


void __RPC_STUB ICall_GetServerHR_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ICall_INTERFACE_DEFINED__ */


#ifndef __IRpcCall_INTERFACE_DEFINED__
#define __IRpcCall_INTERFACE_DEFINED__

/* interface IRpcCall */
/* [unique][uuid][object][local] */ 

typedef /* [unique] */ IRpcCall *LPRPCCALL;


EXTERN_C const IID IID_IRpcCall;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("000001c5-0000-0000-C000-000000000046")
    IRpcCall : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetRpcOleMessage( 
            /* [out] */ RPCOLEMESSAGE **ppMessage) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IRpcCallVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IRpcCall * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IRpcCall * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IRpcCall * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetRpcOleMessage )( 
            IRpcCall * This,
            /* [out] */ RPCOLEMESSAGE **ppMessage);
        
        END_INTERFACE
    } IRpcCallVtbl;

    interface IRpcCall
    {
        CONST_VTBL struct IRpcCallVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IRpcCall_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IRpcCall_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IRpcCall_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IRpcCall_GetRpcOleMessage(This,ppMessage)	\
    (This)->lpVtbl -> GetRpcOleMessage(This,ppMessage)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IRpcCall_GetRpcOleMessage_Proxy( 
    IRpcCall * This,
    /* [out] */ RPCOLEMESSAGE **ppMessage);


void __RPC_STUB IRpcCall_GetRpcOleMessage_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IRpcCall_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_contxt_0098 */
/* [local] */ 

typedef 
enum _CALLSOURCE
    {	CALLSOURCE_CROSSAPT	= 0,
	CALLSOURCE_CROSSCTX	= 1
    } 	CALLSOURCE;



extern RPC_IF_HANDLE __MIDL_itf_contxt_0098_ClientIfHandle;
extern RPC_IF_HANDLE __MIDL_itf_contxt_0098_ServerIfHandle;

#ifndef __ICallInfo_INTERFACE_DEFINED__
#define __ICallInfo_INTERFACE_DEFINED__

/* interface ICallInfo */
/* [unique][uuid][object][local] */ 


EXTERN_C const IID IID_ICallInfo;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("000001dc-0000-0000-C000-000000000046")
    ICallInfo : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetCallSource( 
            /* [out] */ CALLSOURCE *pCallSource) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ICallInfoVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ICallInfo * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ICallInfo * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ICallInfo * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetCallSource )( 
            ICallInfo * This,
            /* [out] */ CALLSOURCE *pCallSource);
        
        END_INTERFACE
    } ICallInfoVtbl;

    interface ICallInfo
    {
        CONST_VTBL struct ICallInfoVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ICallInfo_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ICallInfo_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ICallInfo_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ICallInfo_GetCallSource(This,pCallSource)	\
    (This)->lpVtbl -> GetCallSource(This,pCallSource)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE ICallInfo_GetCallSource_Proxy( 
    ICallInfo * This,
    /* [out] */ CALLSOURCE *pCallSource);


void __RPC_STUB ICallInfo_GetCallSource_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ICallInfo_INTERFACE_DEFINED__ */


#ifndef __IPolicy_INTERFACE_DEFINED__
#define __IPolicy_INTERFACE_DEFINED__

/* interface IPolicy */
/* [unique][uuid][object][local] */ 


EXTERN_C const IID IID_IPolicy;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("000001c2-0000-0000-C000-000000000046")
    IPolicy : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Call( 
            /* [in] */ ICall *pCall) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Enter( 
            /* [in] */ ICall *pCall) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Leave( 
            /* [in] */ ICall *pCall) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Return( 
            /* [in] */ ICall *pCall) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CallGetSize( 
            /* [in] */ ICall *pCall,
            /* [out] */ ULONG *pcb) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CallFillBuffer( 
            /* [in] */ ICall *pCall,
            /* [in] */ void *pvBuf,
            /* [out] */ ULONG *pcb) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE EnterWithBuffer( 
            /* [in] */ ICall *pCall,
            /* [in] */ void *pvBuf,
            /* [in] */ ULONG cb) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE LeaveGetSize( 
            /* [in] */ ICall *pCall,
            /* [out] */ ULONG *pcb) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE LeaveFillBuffer( 
            /* [in] */ ICall *pCall,
            /* [in] */ void *pvBuf,
            /* [out] */ ULONG *pcb) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ReturnWithBuffer( 
            /* [in] */ ICall *pCall,
            /* [in] */ void *pvBuf,
            /* [in] */ ULONG cb) = 0;
        
        virtual ULONG STDMETHODCALLTYPE AddRefPolicy( void) = 0;
        
        virtual ULONG STDMETHODCALLTYPE ReleasePolicy( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IPolicyVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IPolicy * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IPolicy * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IPolicy * This);
        
        HRESULT ( STDMETHODCALLTYPE *Call )( 
            IPolicy * This,
            /* [in] */ ICall *pCall);
        
        HRESULT ( STDMETHODCALLTYPE *Enter )( 
            IPolicy * This,
            /* [in] */ ICall *pCall);
        
        HRESULT ( STDMETHODCALLTYPE *Leave )( 
            IPolicy * This,
            /* [in] */ ICall *pCall);
        
        HRESULT ( STDMETHODCALLTYPE *Return )( 
            IPolicy * This,
            /* [in] */ ICall *pCall);
        
        HRESULT ( STDMETHODCALLTYPE *CallGetSize )( 
            IPolicy * This,
            /* [in] */ ICall *pCall,
            /* [out] */ ULONG *pcb);
        
        HRESULT ( STDMETHODCALLTYPE *CallFillBuffer )( 
            IPolicy * This,
            /* [in] */ ICall *pCall,
            /* [in] */ void *pvBuf,
            /* [out] */ ULONG *pcb);
        
        HRESULT ( STDMETHODCALLTYPE *EnterWithBuffer )( 
            IPolicy * This,
            /* [in] */ ICall *pCall,
            /* [in] */ void *pvBuf,
            /* [in] */ ULONG cb);
        
        HRESULT ( STDMETHODCALLTYPE *LeaveGetSize )( 
            IPolicy * This,
            /* [in] */ ICall *pCall,
            /* [out] */ ULONG *pcb);
        
        HRESULT ( STDMETHODCALLTYPE *LeaveFillBuffer )( 
            IPolicy * This,
            /* [in] */ ICall *pCall,
            /* [in] */ void *pvBuf,
            /* [out] */ ULONG *pcb);
        
        HRESULT ( STDMETHODCALLTYPE *ReturnWithBuffer )( 
            IPolicy * This,
            /* [in] */ ICall *pCall,
            /* [in] */ void *pvBuf,
            /* [in] */ ULONG cb);
        
        ULONG ( STDMETHODCALLTYPE *AddRefPolicy )( 
            IPolicy * This);
        
        ULONG ( STDMETHODCALLTYPE *ReleasePolicy )( 
            IPolicy * This);
        
        END_INTERFACE
    } IPolicyVtbl;

    interface IPolicy
    {
        CONST_VTBL struct IPolicyVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IPolicy_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IPolicy_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IPolicy_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IPolicy_Call(This,pCall)	\
    (This)->lpVtbl -> Call(This,pCall)

#define IPolicy_Enter(This,pCall)	\
    (This)->lpVtbl -> Enter(This,pCall)

#define IPolicy_Leave(This,pCall)	\
    (This)->lpVtbl -> Leave(This,pCall)

#define IPolicy_Return(This,pCall)	\
    (This)->lpVtbl -> Return(This,pCall)

#define IPolicy_CallGetSize(This,pCall,pcb)	\
    (This)->lpVtbl -> CallGetSize(This,pCall,pcb)

#define IPolicy_CallFillBuffer(This,pCall,pvBuf,pcb)	\
    (This)->lpVtbl -> CallFillBuffer(This,pCall,pvBuf,pcb)

#define IPolicy_EnterWithBuffer(This,pCall,pvBuf,cb)	\
    (This)->lpVtbl -> EnterWithBuffer(This,pCall,pvBuf,cb)

#define IPolicy_LeaveGetSize(This,pCall,pcb)	\
    (This)->lpVtbl -> LeaveGetSize(This,pCall,pcb)

#define IPolicy_LeaveFillBuffer(This,pCall,pvBuf,pcb)	\
    (This)->lpVtbl -> LeaveFillBuffer(This,pCall,pvBuf,pcb)

#define IPolicy_ReturnWithBuffer(This,pCall,pvBuf,cb)	\
    (This)->lpVtbl -> ReturnWithBuffer(This,pCall,pvBuf,cb)

#define IPolicy_AddRefPolicy(This)	\
    (This)->lpVtbl -> AddRefPolicy(This)

#define IPolicy_ReleasePolicy(This)	\
    (This)->lpVtbl -> ReleasePolicy(This)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IPolicy_Call_Proxy( 
    IPolicy * This,
    /* [in] */ ICall *pCall);


void __RPC_STUB IPolicy_Call_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IPolicy_Enter_Proxy( 
    IPolicy * This,
    /* [in] */ ICall *pCall);


void __RPC_STUB IPolicy_Enter_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IPolicy_Leave_Proxy( 
    IPolicy * This,
    /* [in] */ ICall *pCall);


void __RPC_STUB IPolicy_Leave_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IPolicy_Return_Proxy( 
    IPolicy * This,
    /* [in] */ ICall *pCall);


void __RPC_STUB IPolicy_Return_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IPolicy_CallGetSize_Proxy( 
    IPolicy * This,
    /* [in] */ ICall *pCall,
    /* [out] */ ULONG *pcb);


void __RPC_STUB IPolicy_CallGetSize_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IPolicy_CallFillBuffer_Proxy( 
    IPolicy * This,
    /* [in] */ ICall *pCall,
    /* [in] */ void *pvBuf,
    /* [out] */ ULONG *pcb);


void __RPC_STUB IPolicy_CallFillBuffer_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IPolicy_EnterWithBuffer_Proxy( 
    IPolicy * This,
    /* [in] */ ICall *pCall,
    /* [in] */ void *pvBuf,
    /* [in] */ ULONG cb);


void __RPC_STUB IPolicy_EnterWithBuffer_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IPolicy_LeaveGetSize_Proxy( 
    IPolicy * This,
    /* [in] */ ICall *pCall,
    /* [out] */ ULONG *pcb);


void __RPC_STUB IPolicy_LeaveGetSize_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IPolicy_LeaveFillBuffer_Proxy( 
    IPolicy * This,
    /* [in] */ ICall *pCall,
    /* [in] */ void *pvBuf,
    /* [out] */ ULONG *pcb);


void __RPC_STUB IPolicy_LeaveFillBuffer_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IPolicy_ReturnWithBuffer_Proxy( 
    IPolicy * This,
    /* [in] */ ICall *pCall,
    /* [in] */ void *pvBuf,
    /* [in] */ ULONG cb);


void __RPC_STUB IPolicy_ReturnWithBuffer_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


ULONG STDMETHODCALLTYPE IPolicy_AddRefPolicy_Proxy( 
    IPolicy * This);


void __RPC_STUB IPolicy_AddRefPolicy_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


ULONG STDMETHODCALLTYPE IPolicy_ReleasePolicy_Proxy( 
    IPolicy * This);


void __RPC_STUB IPolicy_ReleasePolicy_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IPolicy_INTERFACE_DEFINED__ */


#ifndef __IPolicyAsync_INTERFACE_DEFINED__
#define __IPolicyAsync_INTERFACE_DEFINED__

/* interface IPolicyAsync */
/* [unique][uuid][object][local] */ 


EXTERN_C const IID IID_IPolicyAsync;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("000001cd-0000-0000-C000-000000000046")
    IPolicyAsync : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE BeginCallGetSize( 
            /* [in] */ ICall *pCall,
            /* [out] */ ULONG *pcb) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE BeginCall( 
            /* [in] */ ICall *pCall) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE BeginCallFillBuffer( 
            /* [in] */ ICall *pCall,
            /* [in] */ void *pvBuf,
            /* [out] */ ULONG *pcb) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE BeginEnter( 
            /* [in] */ ICall *pCall) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE BeginEnterWithBuffer( 
            /* [in] */ ICall *pCall,
            /* [in] */ void *pvBuf,
            /* [in] */ ULONG cb) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE BeginLeave( 
            /* [in] */ ICall *pCall) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE BeginReturn( 
            /* [in] */ ICall *pCall) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE FinishCall( 
            /* [in] */ ICall *pCall) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE FinishEnter( 
            /* [in] */ ICall *pCall) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE FinishLeaveGetSize( 
            /* [in] */ ICall *pCall,
            /* [out] */ ULONG *pcb) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE FinishLeave( 
            /* [in] */ ICall *pCall) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE FinishLeaveFillBuffer( 
            /* [in] */ ICall *pCall,
            /* [in] */ void *pvBuf,
            /* [out] */ ULONG *pcb) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE FinishReturn( 
            /* [in] */ ICall *pCall) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE FinishReturnWithBuffer( 
            /* [in] */ ICall *pCall,
            /* [in] */ void *pvBuf,
            /* [in] */ ULONG cb) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IPolicyAsyncVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IPolicyAsync * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IPolicyAsync * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IPolicyAsync * This);
        
        HRESULT ( STDMETHODCALLTYPE *BeginCallGetSize )( 
            IPolicyAsync * This,
            /* [in] */ ICall *pCall,
            /* [out] */ ULONG *pcb);
        
        HRESULT ( STDMETHODCALLTYPE *BeginCall )( 
            IPolicyAsync * This,
            /* [in] */ ICall *pCall);
        
        HRESULT ( STDMETHODCALLTYPE *BeginCallFillBuffer )( 
            IPolicyAsync * This,
            /* [in] */ ICall *pCall,
            /* [in] */ void *pvBuf,
            /* [out] */ ULONG *pcb);
        
        HRESULT ( STDMETHODCALLTYPE *BeginEnter )( 
            IPolicyAsync * This,
            /* [in] */ ICall *pCall);
        
        HRESULT ( STDMETHODCALLTYPE *BeginEnterWithBuffer )( 
            IPolicyAsync * This,
            /* [in] */ ICall *pCall,
            /* [in] */ void *pvBuf,
            /* [in] */ ULONG cb);
        
        HRESULT ( STDMETHODCALLTYPE *BeginLeave )( 
            IPolicyAsync * This,
            /* [in] */ ICall *pCall);
        
        HRESULT ( STDMETHODCALLTYPE *BeginReturn )( 
            IPolicyAsync * This,
            /* [in] */ ICall *pCall);
        
        HRESULT ( STDMETHODCALLTYPE *FinishCall )( 
            IPolicyAsync * This,
            /* [in] */ ICall *pCall);
        
        HRESULT ( STDMETHODCALLTYPE *FinishEnter )( 
            IPolicyAsync * This,
            /* [in] */ ICall *pCall);
        
        HRESULT ( STDMETHODCALLTYPE *FinishLeaveGetSize )( 
            IPolicyAsync * This,
            /* [in] */ ICall *pCall,
            /* [out] */ ULONG *pcb);
        
        HRESULT ( STDMETHODCALLTYPE *FinishLeave )( 
            IPolicyAsync * This,
            /* [in] */ ICall *pCall);
        
        HRESULT ( STDMETHODCALLTYPE *FinishLeaveFillBuffer )( 
            IPolicyAsync * This,
            /* [in] */ ICall *pCall,
            /* [in] */ void *pvBuf,
            /* [out] */ ULONG *pcb);
        
        HRESULT ( STDMETHODCALLTYPE *FinishReturn )( 
            IPolicyAsync * This,
            /* [in] */ ICall *pCall);
        
        HRESULT ( STDMETHODCALLTYPE *FinishReturnWithBuffer )( 
            IPolicyAsync * This,
            /* [in] */ ICall *pCall,
            /* [in] */ void *pvBuf,
            /* [in] */ ULONG cb);
        
        END_INTERFACE
    } IPolicyAsyncVtbl;

    interface IPolicyAsync
    {
        CONST_VTBL struct IPolicyAsyncVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IPolicyAsync_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IPolicyAsync_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IPolicyAsync_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IPolicyAsync_BeginCallGetSize(This,pCall,pcb)	\
    (This)->lpVtbl -> BeginCallGetSize(This,pCall,pcb)

#define IPolicyAsync_BeginCall(This,pCall)	\
    (This)->lpVtbl -> BeginCall(This,pCall)

#define IPolicyAsync_BeginCallFillBuffer(This,pCall,pvBuf,pcb)	\
    (This)->lpVtbl -> BeginCallFillBuffer(This,pCall,pvBuf,pcb)

#define IPolicyAsync_BeginEnter(This,pCall)	\
    (This)->lpVtbl -> BeginEnter(This,pCall)

#define IPolicyAsync_BeginEnterWithBuffer(This,pCall,pvBuf,cb)	\
    (This)->lpVtbl -> BeginEnterWithBuffer(This,pCall,pvBuf,cb)

#define IPolicyAsync_BeginLeave(This,pCall)	\
    (This)->lpVtbl -> BeginLeave(This,pCall)

#define IPolicyAsync_BeginReturn(This,pCall)	\
    (This)->lpVtbl -> BeginReturn(This,pCall)

#define IPolicyAsync_FinishCall(This,pCall)	\
    (This)->lpVtbl -> FinishCall(This,pCall)

#define IPolicyAsync_FinishEnter(This,pCall)	\
    (This)->lpVtbl -> FinishEnter(This,pCall)

#define IPolicyAsync_FinishLeaveGetSize(This,pCall,pcb)	\
    (This)->lpVtbl -> FinishLeaveGetSize(This,pCall,pcb)

#define IPolicyAsync_FinishLeave(This,pCall)	\
    (This)->lpVtbl -> FinishLeave(This,pCall)

#define IPolicyAsync_FinishLeaveFillBuffer(This,pCall,pvBuf,pcb)	\
    (This)->lpVtbl -> FinishLeaveFillBuffer(This,pCall,pvBuf,pcb)

#define IPolicyAsync_FinishReturn(This,pCall)	\
    (This)->lpVtbl -> FinishReturn(This,pCall)

#define IPolicyAsync_FinishReturnWithBuffer(This,pCall,pvBuf,cb)	\
    (This)->lpVtbl -> FinishReturnWithBuffer(This,pCall,pvBuf,cb)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IPolicyAsync_BeginCallGetSize_Proxy( 
    IPolicyAsync * This,
    /* [in] */ ICall *pCall,
    /* [out] */ ULONG *pcb);


void __RPC_STUB IPolicyAsync_BeginCallGetSize_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IPolicyAsync_BeginCall_Proxy( 
    IPolicyAsync * This,
    /* [in] */ ICall *pCall);


void __RPC_STUB IPolicyAsync_BeginCall_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IPolicyAsync_BeginCallFillBuffer_Proxy( 
    IPolicyAsync * This,
    /* [in] */ ICall *pCall,
    /* [in] */ void *pvBuf,
    /* [out] */ ULONG *pcb);


void __RPC_STUB IPolicyAsync_BeginCallFillBuffer_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IPolicyAsync_BeginEnter_Proxy( 
    IPolicyAsync * This,
    /* [in] */ ICall *pCall);


void __RPC_STUB IPolicyAsync_BeginEnter_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IPolicyAsync_BeginEnterWithBuffer_Proxy( 
    IPolicyAsync * This,
    /* [in] */ ICall *pCall,
    /* [in] */ void *pvBuf,
    /* [in] */ ULONG cb);


void __RPC_STUB IPolicyAsync_BeginEnterWithBuffer_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IPolicyAsync_BeginLeave_Proxy( 
    IPolicyAsync * This,
    /* [in] */ ICall *pCall);


void __RPC_STUB IPolicyAsync_BeginLeave_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IPolicyAsync_BeginReturn_Proxy( 
    IPolicyAsync * This,
    /* [in] */ ICall *pCall);


void __RPC_STUB IPolicyAsync_BeginReturn_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IPolicyAsync_FinishCall_Proxy( 
    IPolicyAsync * This,
    /* [in] */ ICall *pCall);


void __RPC_STUB IPolicyAsync_FinishCall_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IPolicyAsync_FinishEnter_Proxy( 
    IPolicyAsync * This,
    /* [in] */ ICall *pCall);


void __RPC_STUB IPolicyAsync_FinishEnter_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IPolicyAsync_FinishLeaveGetSize_Proxy( 
    IPolicyAsync * This,
    /* [in] */ ICall *pCall,
    /* [out] */ ULONG *pcb);


void __RPC_STUB IPolicyAsync_FinishLeaveGetSize_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IPolicyAsync_FinishLeave_Proxy( 
    IPolicyAsync * This,
    /* [in] */ ICall *pCall);


void __RPC_STUB IPolicyAsync_FinishLeave_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IPolicyAsync_FinishLeaveFillBuffer_Proxy( 
    IPolicyAsync * This,
    /* [in] */ ICall *pCall,
    /* [in] */ void *pvBuf,
    /* [out] */ ULONG *pcb);


void __RPC_STUB IPolicyAsync_FinishLeaveFillBuffer_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IPolicyAsync_FinishReturn_Proxy( 
    IPolicyAsync * This,
    /* [in] */ ICall *pCall);


void __RPC_STUB IPolicyAsync_FinishReturn_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IPolicyAsync_FinishReturnWithBuffer_Proxy( 
    IPolicyAsync * This,
    /* [in] */ ICall *pCall,
    /* [in] */ void *pvBuf,
    /* [in] */ ULONG cb);


void __RPC_STUB IPolicyAsync_FinishReturnWithBuffer_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IPolicyAsync_INTERFACE_DEFINED__ */


#ifndef __IPolicySet_INTERFACE_DEFINED__
#define __IPolicySet_INTERFACE_DEFINED__

/* interface IPolicySet */
/* [unique][uuid][object][local] */ 


EXTERN_C const IID IID_IPolicySet;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("000001c3-0000-0000-C000-000000000046")
    IPolicySet : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE AddPolicy( 
            /* [in] */ ContextEvent ctxEvent,
            /* [in] */ REFGUID rguid,
            /* [in] */ IPolicy *pPolicy) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IPolicySetVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IPolicySet * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IPolicySet * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IPolicySet * This);
        
        HRESULT ( STDMETHODCALLTYPE *AddPolicy )( 
            IPolicySet * This,
            /* [in] */ ContextEvent ctxEvent,
            /* [in] */ REFGUID rguid,
            /* [in] */ IPolicy *pPolicy);
        
        END_INTERFACE
    } IPolicySetVtbl;

    interface IPolicySet
    {
        CONST_VTBL struct IPolicySetVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IPolicySet_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IPolicySet_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IPolicySet_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IPolicySet_AddPolicy(This,ctxEvent,rguid,pPolicy)	\
    (This)->lpVtbl -> AddPolicy(This,ctxEvent,rguid,pPolicy)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IPolicySet_AddPolicy_Proxy( 
    IPolicySet * This,
    /* [in] */ ContextEvent ctxEvent,
    /* [in] */ REFGUID rguid,
    /* [in] */ IPolicy *pPolicy);


void __RPC_STUB IPolicySet_AddPolicy_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IPolicySet_INTERFACE_DEFINED__ */


#ifndef __IComObjIdentity_INTERFACE_DEFINED__
#define __IComObjIdentity_INTERFACE_DEFINED__

/* interface IComObjIdentity */
/* [unique][uuid][object][local] */ 


EXTERN_C const IID IID_IComObjIdentity;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("000001d7-0000-0000-C000-000000000046")
    IComObjIdentity : public IUnknown
    {
    public:
        virtual BOOL STDMETHODCALLTYPE IsServer( void) = 0;
        
        virtual BOOL STDMETHODCALLTYPE IsDeactivated( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetIdentity( 
            /* [out] */ IUnknown **ppUnk) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IComObjIdentityVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IComObjIdentity * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IComObjIdentity * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IComObjIdentity * This);
        
        BOOL ( STDMETHODCALLTYPE *IsServer )( 
            IComObjIdentity * This);
        
        BOOL ( STDMETHODCALLTYPE *IsDeactivated )( 
            IComObjIdentity * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetIdentity )( 
            IComObjIdentity * This,
            /* [out] */ IUnknown **ppUnk);
        
        END_INTERFACE
    } IComObjIdentityVtbl;

    interface IComObjIdentity
    {
        CONST_VTBL struct IComObjIdentityVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IComObjIdentity_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IComObjIdentity_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IComObjIdentity_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IComObjIdentity_IsServer(This)	\
    (This)->lpVtbl -> IsServer(This)

#define IComObjIdentity_IsDeactivated(This)	\
    (This)->lpVtbl -> IsDeactivated(This)

#define IComObjIdentity_GetIdentity(This,ppUnk)	\
    (This)->lpVtbl -> GetIdentity(This,ppUnk)

#endif /* COBJMACROS */


#endif 	/* C style interface */



BOOL STDMETHODCALLTYPE IComObjIdentity_IsServer_Proxy( 
    IComObjIdentity * This);


void __RPC_STUB IComObjIdentity_IsServer_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


BOOL STDMETHODCALLTYPE IComObjIdentity_IsDeactivated_Proxy( 
    IComObjIdentity * This);


void __RPC_STUB IComObjIdentity_IsDeactivated_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IComObjIdentity_GetIdentity_Proxy( 
    IComObjIdentity * This,
    /* [out] */ IUnknown **ppUnk);


void __RPC_STUB IComObjIdentity_GetIdentity_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IComObjIdentity_INTERFACE_DEFINED__ */


#ifndef __IPolicyMaker_INTERFACE_DEFINED__
#define __IPolicyMaker_INTERFACE_DEFINED__

/* interface IPolicyMaker */
/* [unique][uuid][object][local] */ 


EXTERN_C const IID IID_IPolicyMaker;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("000001c4-0000-0000-C000-000000000046")
    IPolicyMaker : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE AddClientPoliciesToSet( 
            /* [in] */ IPolicySet *pPS,
            /* [in] */ IContext *pClientContext,
            /* [in] */ IContext *pServerContext) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE AddEnvoyPoliciesToSet( 
            /* [in] */ IPolicySet *pPS,
            /* [in] */ IContext *pClientContext,
            /* [in] */ IContext *pServerContext) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE AddServerPoliciesToSet( 
            /* [in] */ IPolicySet *pPS,
            /* [in] */ IContext *pClientContext,
            /* [in] */ IContext *pServerContext) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Freeze( 
            /* [in] */ IObjContext *pObjContext) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CreateStub( 
            /* [in] */ IComObjIdentity *pID) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE DestroyStub( 
            /* [in] */ IComObjIdentity *pID) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CreateProxy( 
            /* [in] */ IComObjIdentity *pID) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE DestroyProxy( 
            /* [in] */ IComObjIdentity *pID) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IPolicyMakerVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IPolicyMaker * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IPolicyMaker * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IPolicyMaker * This);
        
        HRESULT ( STDMETHODCALLTYPE *AddClientPoliciesToSet )( 
            IPolicyMaker * This,
            /* [in] */ IPolicySet *pPS,
            /* [in] */ IContext *pClientContext,
            /* [in] */ IContext *pServerContext);
        
        HRESULT ( STDMETHODCALLTYPE *AddEnvoyPoliciesToSet )( 
            IPolicyMaker * This,
            /* [in] */ IPolicySet *pPS,
            /* [in] */ IContext *pClientContext,
            /* [in] */ IContext *pServerContext);
        
        HRESULT ( STDMETHODCALLTYPE *AddServerPoliciesToSet )( 
            IPolicyMaker * This,
            /* [in] */ IPolicySet *pPS,
            /* [in] */ IContext *pClientContext,
            /* [in] */ IContext *pServerContext);
        
        HRESULT ( STDMETHODCALLTYPE *Freeze )( 
            IPolicyMaker * This,
            /* [in] */ IObjContext *pObjContext);
        
        HRESULT ( STDMETHODCALLTYPE *CreateStub )( 
            IPolicyMaker * This,
            /* [in] */ IComObjIdentity *pID);
        
        HRESULT ( STDMETHODCALLTYPE *DestroyStub )( 
            IPolicyMaker * This,
            /* [in] */ IComObjIdentity *pID);
        
        HRESULT ( STDMETHODCALLTYPE *CreateProxy )( 
            IPolicyMaker * This,
            /* [in] */ IComObjIdentity *pID);
        
        HRESULT ( STDMETHODCALLTYPE *DestroyProxy )( 
            IPolicyMaker * This,
            /* [in] */ IComObjIdentity *pID);
        
        END_INTERFACE
    } IPolicyMakerVtbl;

    interface IPolicyMaker
    {
        CONST_VTBL struct IPolicyMakerVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IPolicyMaker_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IPolicyMaker_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IPolicyMaker_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IPolicyMaker_AddClientPoliciesToSet(This,pPS,pClientContext,pServerContext)	\
    (This)->lpVtbl -> AddClientPoliciesToSet(This,pPS,pClientContext,pServerContext)

#define IPolicyMaker_AddEnvoyPoliciesToSet(This,pPS,pClientContext,pServerContext)	\
    (This)->lpVtbl -> AddEnvoyPoliciesToSet(This,pPS,pClientContext,pServerContext)

#define IPolicyMaker_AddServerPoliciesToSet(This,pPS,pClientContext,pServerContext)	\
    (This)->lpVtbl -> AddServerPoliciesToSet(This,pPS,pClientContext,pServerContext)

#define IPolicyMaker_Freeze(This,pObjContext)	\
    (This)->lpVtbl -> Freeze(This,pObjContext)

#define IPolicyMaker_CreateStub(This,pID)	\
    (This)->lpVtbl -> CreateStub(This,pID)

#define IPolicyMaker_DestroyStub(This,pID)	\
    (This)->lpVtbl -> DestroyStub(This,pID)

#define IPolicyMaker_CreateProxy(This,pID)	\
    (This)->lpVtbl -> CreateProxy(This,pID)

#define IPolicyMaker_DestroyProxy(This,pID)	\
    (This)->lpVtbl -> DestroyProxy(This,pID)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IPolicyMaker_AddClientPoliciesToSet_Proxy( 
    IPolicyMaker * This,
    /* [in] */ IPolicySet *pPS,
    /* [in] */ IContext *pClientContext,
    /* [in] */ IContext *pServerContext);


void __RPC_STUB IPolicyMaker_AddClientPoliciesToSet_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IPolicyMaker_AddEnvoyPoliciesToSet_Proxy( 
    IPolicyMaker * This,
    /* [in] */ IPolicySet *pPS,
    /* [in] */ IContext *pClientContext,
    /* [in] */ IContext *pServerContext);


void __RPC_STUB IPolicyMaker_AddEnvoyPoliciesToSet_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IPolicyMaker_AddServerPoliciesToSet_Proxy( 
    IPolicyMaker * This,
    /* [in] */ IPolicySet *pPS,
    /* [in] */ IContext *pClientContext,
    /* [in] */ IContext *pServerContext);


void __RPC_STUB IPolicyMaker_AddServerPoliciesToSet_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IPolicyMaker_Freeze_Proxy( 
    IPolicyMaker * This,
    /* [in] */ IObjContext *pObjContext);


void __RPC_STUB IPolicyMaker_Freeze_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IPolicyMaker_CreateStub_Proxy( 
    IPolicyMaker * This,
    /* [in] */ IComObjIdentity *pID);


void __RPC_STUB IPolicyMaker_CreateStub_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IPolicyMaker_DestroyStub_Proxy( 
    IPolicyMaker * This,
    /* [in] */ IComObjIdentity *pID);


void __RPC_STUB IPolicyMaker_DestroyStub_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IPolicyMaker_CreateProxy_Proxy( 
    IPolicyMaker * This,
    /* [in] */ IComObjIdentity *pID);


void __RPC_STUB IPolicyMaker_CreateProxy_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IPolicyMaker_DestroyProxy_Proxy( 
    IPolicyMaker * This,
    /* [in] */ IComObjIdentity *pID);


void __RPC_STUB IPolicyMaker_DestroyProxy_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IPolicyMaker_INTERFACE_DEFINED__ */


#ifndef __IExceptionNotification_INTERFACE_DEFINED__
#define __IExceptionNotification_INTERFACE_DEFINED__

/* interface IExceptionNotification */
/* [unique][uuid][object][local] */ 


EXTERN_C const IID IID_IExceptionNotification;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("000001db-0000-0000-C000-000000000046")
    IExceptionNotification : public IUnknown
    {
    public:
        virtual void STDMETHODCALLTYPE ServerException( 
            /* [in] */ void *pExcepPtrs) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IExceptionNotificationVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IExceptionNotification * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IExceptionNotification * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IExceptionNotification * This);
        
        void ( STDMETHODCALLTYPE *ServerException )( 
            IExceptionNotification * This,
            /* [in] */ void *pExcepPtrs);
        
        END_INTERFACE
    } IExceptionNotificationVtbl;

    interface IExceptionNotification
    {
        CONST_VTBL struct IExceptionNotificationVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IExceptionNotification_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IExceptionNotification_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IExceptionNotification_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IExceptionNotification_ServerException(This,pExcepPtrs)	\
    (This)->lpVtbl -> ServerException(This,pExcepPtrs)

#endif /* COBJMACROS */


#endif 	/* C style interface */



void STDMETHODCALLTYPE IExceptionNotification_ServerException_Proxy( 
    IExceptionNotification * This,
    /* [in] */ void *pExcepPtrs);


void __RPC_STUB IExceptionNotification_ServerException_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IExceptionNotification_INTERFACE_DEFINED__ */


#ifndef __IAbandonmentNotification_INTERFACE_DEFINED__
#define __IAbandonmentNotification_INTERFACE_DEFINED__

/* interface IAbandonmentNotification */
/* [unique][uuid][object][local] */ 


EXTERN_C const IID IID_IAbandonmentNotification;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("000001de-0000-0000-C000-000000000046")
    IAbandonmentNotification : public IUnknown
    {
    public:
        virtual void STDMETHODCALLTYPE Abandoned( 
            IObjContext *pObjContext) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IAbandonmentNotificationVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IAbandonmentNotification * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IAbandonmentNotification * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IAbandonmentNotification * This);
        
        void ( STDMETHODCALLTYPE *Abandoned )( 
            IAbandonmentNotification * This,
            IObjContext *pObjContext);
        
        END_INTERFACE
    } IAbandonmentNotificationVtbl;

    interface IAbandonmentNotification
    {
        CONST_VTBL struct IAbandonmentNotificationVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IAbandonmentNotification_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IAbandonmentNotification_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IAbandonmentNotification_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IAbandonmentNotification_Abandoned(This,pObjContext)	\
    (This)->lpVtbl -> Abandoned(This,pObjContext)

#endif /* COBJMACROS */


#endif 	/* C style interface */



void STDMETHODCALLTYPE IAbandonmentNotification_Abandoned_Proxy( 
    IAbandonmentNotification * This,
    IObjContext *pObjContext);


void __RPC_STUB IAbandonmentNotification_Abandoned_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IAbandonmentNotification_INTERFACE_DEFINED__ */


#ifndef __IMarshalEnvoy_INTERFACE_DEFINED__
#define __IMarshalEnvoy_INTERFACE_DEFINED__

/* interface IMarshalEnvoy */
/* [unique][uuid][object][local] */ 


EXTERN_C const IID IID_IMarshalEnvoy;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("000001c8-0000-0000-C000-000000000046")
    IMarshalEnvoy : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetEnvoyUnmarshalClass( 
            /* [in] */ DWORD dwDestContext,
            /* [out] */ CLSID *pClsid) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetEnvoySizeMax( 
            /* [in] */ DWORD dwDestContext,
            /* [out] */ DWORD *pcb) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE MarshalEnvoy( 
            /* [in] */ IStream *pStream,
            /* [in] */ DWORD dwDestContext) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE UnmarshalEnvoy( 
            /* [in] */ IStream *pStream,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppunk) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IMarshalEnvoyVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IMarshalEnvoy * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IMarshalEnvoy * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IMarshalEnvoy * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetEnvoyUnmarshalClass )( 
            IMarshalEnvoy * This,
            /* [in] */ DWORD dwDestContext,
            /* [out] */ CLSID *pClsid);
        
        HRESULT ( STDMETHODCALLTYPE *GetEnvoySizeMax )( 
            IMarshalEnvoy * This,
            /* [in] */ DWORD dwDestContext,
            /* [out] */ DWORD *pcb);
        
        HRESULT ( STDMETHODCALLTYPE *MarshalEnvoy )( 
            IMarshalEnvoy * This,
            /* [in] */ IStream *pStream,
            /* [in] */ DWORD dwDestContext);
        
        HRESULT ( STDMETHODCALLTYPE *UnmarshalEnvoy )( 
            IMarshalEnvoy * This,
            /* [in] */ IStream *pStream,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppunk);
        
        END_INTERFACE
    } IMarshalEnvoyVtbl;

    interface IMarshalEnvoy
    {
        CONST_VTBL struct IMarshalEnvoyVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IMarshalEnvoy_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IMarshalEnvoy_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IMarshalEnvoy_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IMarshalEnvoy_GetEnvoyUnmarshalClass(This,dwDestContext,pClsid)	\
    (This)->lpVtbl -> GetEnvoyUnmarshalClass(This,dwDestContext,pClsid)

#define IMarshalEnvoy_GetEnvoySizeMax(This,dwDestContext,pcb)	\
    (This)->lpVtbl -> GetEnvoySizeMax(This,dwDestContext,pcb)

#define IMarshalEnvoy_MarshalEnvoy(This,pStream,dwDestContext)	\
    (This)->lpVtbl -> MarshalEnvoy(This,pStream,dwDestContext)

#define IMarshalEnvoy_UnmarshalEnvoy(This,pStream,riid,ppunk)	\
    (This)->lpVtbl -> UnmarshalEnvoy(This,pStream,riid,ppunk)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IMarshalEnvoy_GetEnvoyUnmarshalClass_Proxy( 
    IMarshalEnvoy * This,
    /* [in] */ DWORD dwDestContext,
    /* [out] */ CLSID *pClsid);


void __RPC_STUB IMarshalEnvoy_GetEnvoyUnmarshalClass_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMarshalEnvoy_GetEnvoySizeMax_Proxy( 
    IMarshalEnvoy * This,
    /* [in] */ DWORD dwDestContext,
    /* [out] */ DWORD *pcb);


void __RPC_STUB IMarshalEnvoy_GetEnvoySizeMax_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMarshalEnvoy_MarshalEnvoy_Proxy( 
    IMarshalEnvoy * This,
    /* [in] */ IStream *pStream,
    /* [in] */ DWORD dwDestContext);


void __RPC_STUB IMarshalEnvoy_MarshalEnvoy_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMarshalEnvoy_UnmarshalEnvoy_Proxy( 
    IMarshalEnvoy * This,
    /* [in] */ IStream *pStream,
    /* [in] */ REFIID riid,
    /* [iid_is][out] */ void **ppunk);


void __RPC_STUB IMarshalEnvoy_UnmarshalEnvoy_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IMarshalEnvoy_INTERFACE_DEFINED__ */


#ifndef __IWrapperInfo_INTERFACE_DEFINED__
#define __IWrapperInfo_INTERFACE_DEFINED__

/* interface IWrapperInfo */
/* [unique][uuid][object][local] */ 


EXTERN_C const IID IID_IWrapperInfo;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("5052f924-7ab8-11d3-b93f-00c04f990176")
    IWrapperInfo : public IUnknown
    {
    public:
        virtual void STDMETHODCALLTYPE SetMapping( 
            void *pv) = 0;
        
        virtual void *STDMETHODCALLTYPE GetMapping( void) = 0;
        
        virtual IObjContext *STDMETHODCALLTYPE GetServerObjectContext( void) = 0;
        
        virtual IUnknown *STDMETHODCALLTYPE GetServerObject( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWrapperInfoVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IWrapperInfo * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IWrapperInfo * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IWrapperInfo * This);
        
        void ( STDMETHODCALLTYPE *SetMapping )( 
            IWrapperInfo * This,
            void *pv);
        
        void *( STDMETHODCALLTYPE *GetMapping )( 
            IWrapperInfo * This);
        
        IObjContext *( STDMETHODCALLTYPE *GetServerObjectContext )( 
            IWrapperInfo * This);
        
        IUnknown *( STDMETHODCALLTYPE *GetServerObject )( 
            IWrapperInfo * This);
        
        END_INTERFACE
    } IWrapperInfoVtbl;

    interface IWrapperInfo
    {
        CONST_VTBL struct IWrapperInfoVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWrapperInfo_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IWrapperInfo_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IWrapperInfo_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IWrapperInfo_SetMapping(This,pv)	\
    (This)->lpVtbl -> SetMapping(This,pv)

#define IWrapperInfo_GetMapping(This)	\
    (This)->lpVtbl -> GetMapping(This)

#define IWrapperInfo_GetServerObjectContext(This)	\
    (This)->lpVtbl -> GetServerObjectContext(This)

#define IWrapperInfo_GetServerObject(This)	\
    (This)->lpVtbl -> GetServerObject(This)

#endif /* COBJMACROS */


#endif 	/* C style interface */



void STDMETHODCALLTYPE IWrapperInfo_SetMapping_Proxy( 
    IWrapperInfo * This,
    void *pv);


void __RPC_STUB IWrapperInfo_SetMapping_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


void *STDMETHODCALLTYPE IWrapperInfo_GetMapping_Proxy( 
    IWrapperInfo * This);


void __RPC_STUB IWrapperInfo_GetMapping_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


IObjContext *STDMETHODCALLTYPE IWrapperInfo_GetServerObjectContext_Proxy( 
    IWrapperInfo * This);


void __RPC_STUB IWrapperInfo_GetServerObjectContext_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


IUnknown *STDMETHODCALLTYPE IWrapperInfo_GetServerObject_Proxy( 
    IWrapperInfo * This);


void __RPC_STUB IWrapperInfo_GetServerObject_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IWrapperInfo_INTERFACE_DEFINED__ */


#ifndef __IComDispatchInfo_INTERFACE_DEFINED__
#define __IComDispatchInfo_INTERFACE_DEFINED__

/* interface IComDispatchInfo */
/* [unique][uuid][object][local] */ 


EXTERN_C const IID IID_IComDispatchInfo;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("000001d9-0000-0000-C000-000000000046")
    IComDispatchInfo : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE EnableComInits( 
            /* [out] */ void **ppvCookie) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE DisableComInits( 
            /* [in] */ void *pvCookie) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IComDispatchInfoVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IComDispatchInfo * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IComDispatchInfo * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IComDispatchInfo * This);
        
        HRESULT ( STDMETHODCALLTYPE *EnableComInits )( 
            IComDispatchInfo * This,
            /* [out] */ void **ppvCookie);
        
        HRESULT ( STDMETHODCALLTYPE *DisableComInits )( 
            IComDispatchInfo * This,
            /* [in] */ void *pvCookie);
        
        END_INTERFACE
    } IComDispatchInfoVtbl;

    interface IComDispatchInfo
    {
        CONST_VTBL struct IComDispatchInfoVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IComDispatchInfo_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IComDispatchInfo_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IComDispatchInfo_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IComDispatchInfo_EnableComInits(This,ppvCookie)	\
    (This)->lpVtbl -> EnableComInits(This,ppvCookie)

#define IComDispatchInfo_DisableComInits(This,pvCookie)	\
    (This)->lpVtbl -> DisableComInits(This,pvCookie)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IComDispatchInfo_EnableComInits_Proxy( 
    IComDispatchInfo * This,
    /* [out] */ void **ppvCookie);


void __RPC_STUB IComDispatchInfo_EnableComInits_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IComDispatchInfo_DisableComInits_Proxy( 
    IComDispatchInfo * This,
    /* [in] */ void *pvCookie);


void __RPC_STUB IComDispatchInfo_DisableComInits_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IComDispatchInfo_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_contxt_0109 */
/* [local] */ 

typedef DWORD HActivator;

STDAPI CoCreateObjectInContext(IUnknown *pUnk, IObjContext *pObjectCtx, REFIID riid, void **ppv);
STDAPI CoGetApartmentID(APTTYPE dAptType, HActivator* pAptID);
STDAPI CoDeactivateObject(IUnknown *pUnk, IUnknown **ppCookie);
STDAPI CoReactivateObject(IUnknown *pUnk, IUnknown *pCookie);
#define MSHLFLAGS_NO_IEC      0x8  // don't use IExternalConnextion
#define MSHLFLAGS_NO_IMARSHAL 0x10 // don't use IMarshal
#define CONTEXTFLAGS_FROZEN         0x01 // Frozen context
#define CONTEXTFLAGS_ALLOWUNAUTH    0x02 // Allow unauthenticated calls
#define CONTEXTFLAGS_ENVOYCONTEXT   0x04 // Envoy context
#define CONTEXTFLAGS_DEFAULTCONTEXT 0x08 // Default context
#define CONTEXTFLAGS_STATICCONTEXT  0x10 // Static context
#define CONTEXTFLAGS_INPROPTABLE    0x20 // Is in property table
#define CONTEXTFLAGS_INDESTRUCTOR   0x40 // Is in destructor
#define CONTEXTFLAGS_URTPROPPRESENT 0x80 // URT property added


extern RPC_IF_HANDLE __MIDL_itf_contxt_0109_ClientIfHandle;
extern RPC_IF_HANDLE __MIDL_itf_contxt_0109_ServerIfHandle;

/* Additional Prototypes for ALL interfaces */

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\public\internal\com\inc\cor.h ===
/*****************************************************************************
 **                                                                         **
 ** Cor.h - general header for the Runtime.                                 **
 **                                                                         **
 ** Copyright (c) Microsoft Corporation. All rights reserved.               **
 **                                                                         **
 *****************************************************************************/


#ifndef _COR_H_
#define _COR_H_
#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#ifdef __cplusplus
extern "C" {
#endif

//*****************************************************************************
// Required includes
#include <ole2.h>                       // Definitions of OLE types.    
//*****************************************************************************

#ifndef DECLSPEC_SELECT_ANY
#define DECLSPEC_SELECT_ANY __declspec(selectany)
#endif // DECLSPEC_SELECT_ANY

// {BED7F4EA-1A96-11d2-8F08-00A0C9A6186D}
extern const GUID DECLSPEC_SELECT_ANY LIBID_ComPlusRuntime = 
{ 0xbed7f4ea, 0x1a96, 0x11d2, { 0x8f, 0x8, 0x0, 0xa0, 0xc9, 0xa6, 0x18, 0x6d } };

// {90883F05-3D28-11D2-8F17-00A0C9A6186D}
extern const GUID DECLSPEC_SELECT_ANY GUID_ExportedFromComPlus = 
{ 0x90883f05, 0x3d28, 0x11d2, { 0x8f, 0x17, 0x0, 0xa0, 0xc9, 0xa6, 0x18, 0x6d } };

// {0F21F359-AB84-41e8-9A78-36D110E6D2F9}
extern const GUID DECLSPEC_SELECT_ANY GUID_ManagedName = 
{ 0xf21f359, 0xab84, 0x41e8, { 0x9a, 0x78, 0x36, 0xd1, 0x10, 0xe6, 0xd2, 0xf9 } };


// CLSID_CorMetaDataDispenserRuntime: {1EC2DE53-75CC-11d2-9775-00A0C9B4D50C}
//  Dispenser coclass for version 1.5 and 2.0 meta data.  To get the "latest" bind  
//  to CLSID_MetaDataDispenser. 
extern const GUID DECLSPEC_SELECT_ANY CLSID_CorMetaDataDispenserRuntime = 
{ 0x1ec2de53, 0x75cc, 0x11d2, { 0x97, 0x75, 0x0, 0xa0, 0xc9, 0xb4, 0xd5, 0xc } };


// CLSID_CorMetaDataRuntime: {005023CA-72B1-11D3-9FC4-00C04F79A0A3}
//  For COM+ 2.0 Meta Data, managed program meta data.  
extern const GUID DECLSPEC_SELECT_ANY CLSID_CorMetaDataRuntime = 
{ 0x005023ca, 0x72b1, 0x11d3, { 0x9f, 0xc4, 0x0, 0xc0, 0x4f, 0x79, 0xa0, 0xa3 } };


// {90883F06-3D28-11D2-8F17-00A0C9A6186D}
extern const GUID DECLSPEC_SELECT_ANY GUID_ImportedToComPlus = 
{ 0x90883f06, 0x3d28, 0x11d2, { 0x8f, 0x17, 0x0, 0xa0, 0xc9, 0xa6, 0x18, 0x6d } };
extern const char DECLSPEC_SELECT_ANY szGUID_ImportedToComPlus[] = "{90883F06-3D28-11D2-8F17-00A0C9A6186D}";
extern const WCHAR DECLSPEC_SELECT_ANY wzGUID_ImportedToComPlus[] = L"{90883F06-3D28-11D2-8F17-00A0C9A6186D}";

// {30FE7BE8-D7D9-11D2-9F80-00C04F79A0A3}
extern const GUID DECLSPEC_SELECT_ANY MetaDataCheckDuplicatesFor =
{ 0x30fe7be8, 0xd7d9, 0x11d2, { 0x9f, 0x80, 0x0, 0xc0, 0x4f, 0x79, 0xa0, 0xa3 } };

// {DE3856F8-D7D9-11D2-9F80-00C04F79A0A3}
extern const GUID DECLSPEC_SELECT_ANY MetaDataRefToDefCheck =
{ 0xde3856f8, 0xd7d9, 0x11d2, { 0x9f, 0x80, 0x0, 0xc0, 0x4f, 0x79, 0xa0, 0xa3 } };

// {E5D71A4C-D7DA-11D2-9F80-00C04F79A0A3}
extern const GUID DECLSPEC_SELECT_ANY MetaDataNotificationForTokenMovement = 
{ 0xe5d71a4c, 0xd7da, 0x11d2, { 0x9f, 0x80, 0x0, 0xc0, 0x4f, 0x79, 0xa0, 0xa3 } };


// {2eee315c-d7db-11d2-9f80-00c04f79a0a3}
extern const GUID DECLSPEC_SELECT_ANY MetaDataSetUpdate = 
{ 0x2eee315c, 0xd7db, 0x11d2, { 0x9f, 0x80, 0x0, 0xc0, 0x4f, 0x79, 0xa0, 0xa3 } };

#define MetaDataSetENC MetaDataSetUpdate

// Use this guid in SetOption to indicate if the import enumerator should skip over 
// delete items or not. The default is yes.
//
// {79700F36-4AAC-11d3-84C3-009027868CB1}
extern const GUID DECLSPEC_SELECT_ANY MetaDataImportOption = 
{ 0x79700f36, 0x4aac, 0x11d3, { 0x84, 0xc3, 0x0, 0x90, 0x27, 0x86, 0x8c, 0xb1 } };


// Use this guid in the SetOption if compiler wants to have MetaData API to take reader/writer lock
// {F7559806-F266-42ea-8C63-0ADB45E8B234}
extern const GUID DECLSPEC_SELECT_ANY MetaDataThreadSafetyOptions = 
{ 0xf7559806, 0xf266, 0x42ea, { 0x8c, 0x63, 0xa, 0xdb, 0x45, 0xe8, 0xb2, 0x34 } };


// Use this guid in the SetOption if compiler wants error when some tokens are emitted out of order
// {1547872D-DC03-11d2-9420-0000F8083460}
extern const GUID DECLSPEC_SELECT_ANY MetaDataErrorIfEmitOutOfOrder = 
{ 0x1547872d, 0xdc03, 0x11d2, { 0x94, 0x20, 0x0, 0x0, 0xf8, 0x8, 0x34, 0x60 } };


// Use this guid in the SetOption to indicate if the tlbimporter should generate the
// TCE adapters for COM connection point containers.
// {DCC9DE90-4151-11d3-88D6-00902754C43A}
extern const GUID DECLSPEC_SELECT_ANY MetaDataGenerateTCEAdapters = 
{ 0xdcc9de90, 0x4151, 0x11d3, { 0x88, 0xd6, 0x0, 0x90, 0x27, 0x54, 0xc4, 0x3a } };


// Use this guid in the SetOption to specifiy a non-default namespace for typelib import.
// {F17FF889-5A63-11d3-9FF2-00C04FF7431A}
extern const GUID DECLSPEC_SELECT_ANY MetaDataTypeLibImportNamespace = 
{ 0xf17ff889, 0x5a63, 0x11d3, { 0x9f, 0xf2, 0x0, 0xc0, 0x4f, 0xf7, 0x43, 0x1a } };


interface IMetaDataImport;
interface IMetaDataAssemblyEmit;
interface IMetaDataAssemblyImport;
interface IMetaDataEmit;
interface ICeeGen;


//*****************************************************************************
//*****************************************************************************
//
// D L L   P U B L I C   E N T R Y    P O I N T   D E C L A R A T I O N S   
//
//*****************************************************************************
//*****************************************************************************

#ifdef UNDER_CE
BOOL STDMETHODCALLTYPE _CorDllMain(HINSTANCE hInst,
                                   DWORD dwReason,  
                                   LPVOID lpReserved,   
                                   LPVOID pDllBase, 
                                   DWORD dwRva14,   
                                   DWORD dwSize14); 

__int32 STDMETHODCALLTYPE _CorExeMain(HINSTANCE hInst,
                                      HINSTANCE hPrevInst,  
                                      LPWSTR lpCmdLine, 
                                      int nCmdShow, 
                                      LPVOID pExeBase,  
                                      DWORD dwRva14,    
                                      DWORD dwSize14);  

#else //!UNDER_CE
BOOL STDMETHODCALLTYPE _CorDllMain(HINSTANCE hInst, DWORD dwReason, LPVOID lpReserved);
__int32 STDMETHODCALLTYPE _CorExeMain();
__int32 STDMETHODCALLTYPE _CorExeMain2( // Executable exit code.
    PBYTE   pUnmappedPE,                // -> memory mapped code
    DWORD   cUnmappedPE,                // Size of memory mapped code
    LPWSTR  pImageNameIn,               // -> Executable Name
    LPWSTR  pLoadersFileName,           // -> Loaders Name
    LPWSTR  pCmdLine);                  // -> Command Line

STDAPI _CorValidateImage(PVOID *ImageBase, LPCWSTR FileName);
STDAPI_(VOID) _CorImageUnloading(PVOID ImageBase);

#endif // UNDER_CE
__int32 STDMETHODCALLTYPE _CorClassMain(LPWSTR entryClassName);

STDAPI          CoInitializeEE(DWORD fFlags);   
STDAPI_(void)   CoUninitializeEE(BOOL fFlags);  

//
// CoInitializeCor flags.
//
typedef enum tagCOINITCOR
{
    COINITCOR_DEFAULT       = 0x0           // Default initialization mode. 
} COINITICOR;

//
// CoInitializeEE flags.
//
typedef enum tagCOINITEE
{
    COINITEE_DEFAULT        = 0x0,          // Default initialization mode. 
    COINITEE_DLL            = 0x1           // Initialization mode for loading DLL. 
} COINITIEE;

//
// CoInitializeEE flags.
//
typedef enum tagCOUNINITEE
{
    COUNINITEE_DEFAULT      = 0x0,          // Default uninitialization mode.   
    COUNINITEE_DLL          = 0x1           // Uninitialization mode for unloading DLL. 
} COUNINITIEE;

//*****************************************************************************
//*****************************************************************************
//
// I L   &   F I L E   F O R M A T   D E C L A R A T I O N S    
//
//*****************************************************************************
//*****************************************************************************


// The following definitions will get moved into <windows.h> by RTM but are
// kept here for the Alpha's and Beta's.
#ifndef _WINDOWS_UDPATES_
#include <corhdr.h>
#endif // <windows.h> updates

//*****************************************************************************
//*****************************************************************************
//
// D L L   P U B L I C   E N T R Y    P O I N T   D E C L A R A T I O N S
//
//*****************************************************************************
//*****************************************************************************

STDAPI          CoInitializeCor(DWORD fFlags);
STDAPI_(void)   CoUninitializeCor(void);

typedef void (* TDestructorCallback)(EXCEPTION_RECORD*);
STDAPI_(void) AddDestructorCallback(int code, TDestructorCallback callback);


#include <pshpack1.h>

#include <poppack.h>

//
//*****************************************************************************
//*****************************************************************************

// CLSID_Cor: {bee00000-ee77-11d0-a015-00c04fbbb884}
extern const GUID DECLSPEC_SELECT_ANY CLSID_Cor = 
{ 0xbee00010, 0xee77, 0x11d0, {0xa0, 0x15, 0x00, 0xc0, 0x4f, 0xbb, 0xb8, 0x84 } };

// CLSID_CorMetaDataDispenser: {E5CB7A31-7512-11d2-89CE-0080C792E5D8}
//  This is the "Master Dispenser", always guaranteed to be the most recent
//  dispenser on the machine.
extern const GUID DECLSPEC_SELECT_ANY CLSID_CorMetaDataDispenser = 
{ 0xe5cb7a31, 0x7512, 0x11d2, { 0x89, 0xce, 0x0, 0x80, 0xc7, 0x92, 0xe5, 0xd8 } };


// CLSID_CorMetaDataDispenserReg: {435755FF-7397-11d2-9771-00A0C9B4D50C}
//  Dispenser coclass for version 1.0 meta data.  To get the "latest" bind
//  to CLSID_CorMetaDataDispenser.
extern const GUID DECLSPEC_SELECT_ANY CLSID_CorMetaDataDispenserReg = 
{ 0x435755ff, 0x7397, 0x11d2, { 0x97, 0x71, 0x0, 0xa0, 0xc9, 0xb4, 0xd5, 0xc } };


// CLSID_CorMetaDataReg: {87F3A1F5-7397-11d2-9771-00A0C9B4D50C}
// For COM+ 1.0 Meta Data, Data Driven Registration
extern const GUID DECLSPEC_SELECT_ANY CLSID_CorMetaDataReg = 
{ 0x87f3a1f5, 0x7397, 0x11d2, { 0x97, 0x71, 0x0, 0xa0, 0xc9, 0xb4, 0xd5, 0xc } };

// IID_IMetaDataInternal {02D601BB-C5B9-11d1-93F9-0000F8083460}
extern const GUID DECLSPEC_SELECT_ANY IID_IMetaDataInternal = 
{ 0x2d601bb, 0xc5b9, 0x11d1, {0x93, 0xf9, 0x0, 0x0, 0xf8, 0x8, 0x34, 0x60 } };

interface IMetaDataDispenser;

//-------------------------------------
//--- IMetaDataError
//-------------------------------------
//---
// {B81FF171-20F3-11d2-8DCC-00A0C9B09C19}
extern const GUID DECLSPEC_SELECT_ANY IID_IMetaDataError =
{ 0xb81ff171, 0x20f3, 0x11d2, { 0x8d, 0xcc, 0x0, 0xa0, 0xc9, 0xb0, 0x9c, 0x19 } };

//---
#undef  INTERFACE
#define INTERFACE IMetaDataError
DECLARE_INTERFACE_(IMetaDataError, IUnknown)
{
    STDMETHOD(OnError)(HRESULT hrError, mdToken token) PURE;
};

//-------------------------------------
//--- IMapToken
//-------------------------------------
//---
// IID_IMapToken: {06A3EA8B-0225-11d1-BF72-00C04FC31E12}
extern const GUID DECLSPEC_SELECT_ANY IID_IMapToken = 
{ 0x6a3ea8b, 0x225, 0x11d1, {0xbf, 0x72, 0x0, 0xc0, 0x4f, 0xc3, 0x1e, 0x12 } };
//---
#undef  INTERFACE
#define INTERFACE IMapToken
DECLARE_INTERFACE_(IMapToken, IUnknown)
{
    STDMETHOD(Map)(mdToken tkImp, mdToken tkEmit) PURE;
};

//-------------------------------------
//--- IMetaDataDispenser
//-------------------------------------
//---
// {B81FF171-20F3-11d2-8DCC-00A0C9B09C19}
extern const GUID DECLSPEC_SELECT_ANY IID_IMetaDataDispenser =
{ 0x809c652e, 0x7396, 0x11d2, { 0x97, 0x71, 0x0, 0xa0, 0xc9, 0xb4, 0xd5, 0xc } };
#undef  INTERFACE
#define INTERFACE IMetaDataDispenser
DECLARE_INTERFACE_(IMetaDataDispenser, IUnknown)
{
    STDMETHOD(DefineScope)(                 // Return code.
        REFCLSID    rclsid,                 // [in] What version to create.
        DWORD       dwCreateFlags,          // [in] Flags on the create.
        REFIID      riid,                   // [in] The interface desired.
        IUnknown    **ppIUnk) PURE;         // [out] Return interface on success.

    STDMETHOD(OpenScope)(                   // Return code.
        LPCWSTR     szScope,                // [in] The scope to open.
        DWORD       dwOpenFlags,            // [in] Open mode flags.
        REFIID      riid,                   // [in] The interface desired.
        IUnknown    **ppIUnk) PURE;         // [out] Return interface on success.

    STDMETHOD(OpenScopeOnMemory)(           // Return code.
        LPCVOID     pData,                  // [in] Location of scope data.
        ULONG       cbData,                 // [in] Size of the data pointed to by pData.
        DWORD       dwOpenFlags,            // [in] Open mode flags.
        REFIID      riid,                   // [in] The interface desired.
        IUnknown    **ppIUnk) PURE;         // [out] Return interface on success.
};

//-------------------------------------
//--- IMetaDataEmit
//-------------------------------------

// {671ED8EF-4531-4c0c-8F84-5C618F8DF000}
extern const GUID DECLSPEC_SELECT_ANY IID_IMetaDataEmit =
{ 0x671ed8ef, 0x4531, 0x4c0c, { 0x8f, 0x84, 0x5c, 0x61, 0x8f, 0x8d, 0xf0, 0x0 } };

//---
#undef  INTERFACE   
#define INTERFACE IMetaDataEmit
DECLARE_INTERFACE_(IMetaDataEmit, IUnknown)
{
    STDMETHOD(SetModuleProps)(              // S_OK or error.
        LPCWSTR     szName) PURE;           // [IN] If not NULL, the GUID to set.

    STDMETHOD(Save)(                        // S_OK or error.
        LPCWSTR     szFile,                 // [IN] The filename to save to.
        DWORD       dwSaveFlags) PURE;      // [IN] Flags for the save.

    STDMETHOD(SaveToStream)(                // S_OK or error.
        IStream     *pIStream,              // [IN] A writable stream to save to.
        DWORD       dwSaveFlags) PURE;      // [IN] Flags for the save.

    STDMETHOD(GetSaveSize)(                 // S_OK or error.
        CorSaveSize fSave,                  // [IN] cssAccurate or cssQuick.
        DWORD       *pdwSaveSize) PURE;     // [OUT] Put the size here.

    STDMETHOD(DefineTypeDef)(               // S_OK or error.
        LPCWSTR     szTypeDef,              // [IN] Name of TypeDef
        CLASSVERSION *pVer,                 // [IN] Optional version
        DWORD       dwTypeDefFlags,         // [IN] CustomValue flags
        mdToken     tkExtends,              // [IN] extends this TypeDef or typeref 
        mdToken     rtkImplements[],        // [IN] Implements interfaces
        mdTypeDef   *ptd) PURE;             // [OUT] Put TypeDef token here

    STDMETHOD(DefineNestedType)(            // S_OK or error.
        LPCWSTR     szTypeDef,              // [IN] Name of TypeDef
        CLASSVERSION *pVer,                 // [IN] Optional version
        DWORD       dwTypeDefFlags,         // [IN] CustomValue flags
        mdToken     tkExtends,              // [IN] extends this TypeDef or typeref 
        mdToken     rtkImplements[],        // [IN] Implements interfaces
        mdTypeDef   tdEncloser,             // [IN] TypeDef token of the enclosing type.
        mdTypeDef   *ptd) PURE;             // [OUT] Put TypeDef token here

    STDMETHOD(SetHandler)(                  // S_OK.
        IUnknown    *pUnk) PURE;            // [IN] The new error handler.

    STDMETHOD(DefineMethod)(                // S_OK or error. 
        mdTypeDef   td,                     // Parent TypeDef   
        LPCWSTR     szName,                 // Name of member   
        DWORD       dwMethodFlags,          // Member attributes    
        PCCOR_SIGNATURE pvSigBlob,          // [IN] point to a blob value of COM+ signature 
        ULONG       cbSigBlob,              // [IN] count of bytes in the signature blob    
        ULONG       ulCodeRVA,  
        DWORD       dwImplFlags,    
        mdMethodDef *pmd) PURE;             // Put member token here     

    STDMETHOD(DefineMethodImpl)(            // S_OK or error.   
        mdTypeDef   td,                     // [IN] The class implementing the method   
        mdToken     tkBody,                 // [IN] Method body - MethodDef or MethodRef
        mdToken     tkDecl) PURE;           // [IN] Method declaration - MethodDef or MethodRef

    STDMETHOD(DefineTypeRefByName)(         // S_OK or error.   
        mdToken     tkResolutionScope,      // [IN] ModuleRef, AssemblyRef or TypeRef.
        LPCWSTR     szName,                 // [IN] Name of the TypeRef.
        mdTypeRef   *ptr) PURE;             // [OUT] Put TypeRef token here.    

    STDMETHOD(DefineImportType)(            // S_OK or error.   
        IMetaDataAssemblyImport *pAssemImport,  // [IN] Assemby containing the TypeDef.
        const void  *pbHashValue,           // [IN] Hash Blob for Assembly.
        ULONG       cbHashValue,            // [IN] Count of bytes.
        mdExecutionLocation tkExec,         // [IN] Execution location for AssemblyRef.
        IMetaDataImport *pImport,           // [IN] Scope containing the TypeDef.   
        mdTypeDef   tdImport,               // [IN] The imported TypeDef.   
        IMetaDataAssemblyEmit *pAssemEmit,  // [IN] Assembly into which the TypeDef is imported.
        mdTypeRef   *ptr) PURE;             // [OUT] Put TypeRef token here.

    STDMETHOD(DefineMemberRef)(             // S_OK or error    
        mdToken     tkImport,               // [IN] ClassRef or ClassDef importing a member.    
        LPCWSTR     szName,                 // [IN] member's name   
        PCCOR_SIGNATURE pvSigBlob,          // [IN] point to a blob value of COM+ signature 
        ULONG       cbSigBlob,              // [IN] count of bytes in the signature blob    
        mdMemberRef *pmr) PURE;             // [OUT] memberref token    

    STDMETHOD(DefineImportMember)(        // S_OK or error.   
        IMetaDataAssemblyImport *pAssemImport,  // [IN] Assemby containing the Member.
        const void  *pbHashValue,           // [IN] Hash Blob for Assembly.
        ULONG       cbHashValue,            // [IN] Count of bytes.
        mdExecutionLocation tkExec,         // [IN] Execution location for AssemblyRef.
        IMetaDataImport *pImport,           // [IN] Import scope, with member.  
        mdToken     mbMember,               // [IN] Member in import scope.   
        IMetaDataAssemblyEmit *pAssemEmit,  // [IN] Assembly into which the Member is imported.
        mdToken     tkParent,               // [IN] Classref or classdef in emit scope.    
        mdMemberRef *pmr) PURE;             // [OUT] Put member ref here.   

    STDMETHOD(DefineEvent) (    
        mdTypeDef   td,                     // [IN] the class/interface on which the event is being defined 
        LPCWSTR     szEvent,                // [IN] Name of the event   
        DWORD       dwEventFlags,           // [IN] CorEventAttr    
        mdToken     tkEventType,            // [IN] a reference (mdTypeRef or mdTypeRef) to the Event class 
        mdMethodDef mdAddOn,                // [IN] required add method 
        mdMethodDef mdRemoveOn,             // [IN] required remove method  
        mdMethodDef mdFire,                 // [IN] optional fire method    
        mdMethodDef rmdOtherMethods[],      // [IN] optional array of other methods associate with the event    
        mdEvent     *pmdEvent) PURE;        // [OUT] output event token 

    STDMETHOD(SetClassLayout) (   
        mdTypeDef   td,                     // [IN] typedef 
        DWORD       dwPackSize,             // [IN] packing size specified as 1, 2, 4, 8, or 16 
        COR_FIELD_OFFSET rFieldOffsets[],   // [IN] array of layout specification   
        ULONG       ulClassSize) PURE;      // [IN] size of the class   

    STDMETHOD(DeleteClassLayout) (
        mdTypeDef   td) PURE;               // [IN] typedef whose layout is to be deleted.

    STDMETHOD(SetFieldMarshal) (    
        mdToken     tk,                     // [IN] given a fieldDef or paramDef token  
        PCCOR_SIGNATURE pvNativeType,       // [IN] native type specification   
        ULONG       cbNativeType) PURE;     // [IN] count of bytes of pvNativeType  

    STDMETHOD(DeleteFieldMarshal) (
        mdToken     tk) PURE;               // [IN] given a fieldDef or paramDef token

    STDMETHOD(DefinePermissionSet) (    
        mdToken     tk,                     // [IN] the object to be decorated. 
        DWORD       dwAction,               // [IN] CorDeclSecurity.    
        void const  *pvPermission,          // [IN] permission blob.    
        ULONG       cbPermission,           // [IN] count of bytes of pvPermission. 
        mdPermission *ppm) PURE;            // [OUT] returned permission token. 

    STDMETHOD(SetRVA)(                      // S_OK or error.   
        mdMethodDef md,                     // [IN] Method for which to set offset  
        ULONG       ulRVA) PURE;            // [IN] The offset    

    STDMETHOD(GetTokenFromSig)(             // S_OK or error.   
        PCCOR_SIGNATURE pvSig,              // [IN] Signature to define.    
        ULONG       cbSig,                  // [IN] Size of signature data. 
        mdSignature *pmsig) PURE;           // [OUT] returned signature token.  

    STDMETHOD(DefineModuleRef)(             // S_OK or error.   
        LPCWSTR     szName,                 // [IN] DLL name    
        mdModuleRef *pmur) PURE;            // [OUT] returned   

    // @todo:  This should go away once everyone starts using SetMemberRefProps.
    STDMETHOD(SetParent)(                   // S_OK or error.   
        mdMemberRef mr,                     // [IN] Token for the ref to be fixed up.   
        mdToken     tk) PURE;               // [IN] The ref parent. 

    STDMETHOD(GetTokenFromTypeSpec)(        // S_OK or error.   
        PCCOR_SIGNATURE pvSig,              // [IN] TypeSpec Signature to define.  
        ULONG       cbSig,                  // [IN] Size of signature data. 
        mdTypeSpec *ptypespec) PURE;        // [OUT] returned TypeSpec token.  

    STDMETHOD(SaveToMemory)(                // S_OK or error.
        void        *pbData,                // [OUT] Location to write data.
        ULONG       cbData) PURE;           // [IN] Max size of data buffer.

    STDMETHOD(SetSymbolBindingPath)(        // S_OK or error.
        REFGUID     FormatID,               // [IN] Symbol data format ID.
        LPCWSTR     szSymbolDataPath) PURE; // [IN] URL for the symbols of this module.

    STDMETHOD(DefineUserString)(            // Return code.
        LPCWSTR szString,                   // [IN] User literal string.
        ULONG       cchString,              // [IN] Length of string.
        mdString    *pstk) PURE;            // [OUT] String token.

    STDMETHOD(DeleteToken)(                 // Return code.
        mdToken     tkObj) PURE;            // [IN] The token to be deleted

    STDMETHOD(SetMethodProps)(              // S_OK or error.
        mdMethodDef md,                     // [IN] The MethodDef.
        DWORD       dwMethodFlags,          // [IN] Method attributes.
        ULONG       ulCodeRVA,              // [IN] Code RVA.
        DWORD       dwImplFlags) PURE;      // [IN] Impl flags.

    STDMETHOD(SetTypeDefProps)(             // S_OK or error.
        mdTypeDef   td,                     // [IN] The TypeDef.
        CLASSVERSION *pVer,                 // [IN] Class version.
        DWORD       dwTypeDefFlags,         // [IN] TypeDef flags.
        mdToken     tkExtends,              // [IN] Base TypeDef or TypeRef.
        mdToken     rtkImplements[]) PURE;  // [IN] Implemented interfaces.

    STDMETHOD(SetEventProps)(               // S_OK or error.
        mdEvent     ev,                     // [IN] The event token.
        DWORD       dwEventFlags,           // [IN] CorEventAttr.
        mdToken     tkEventType,            // [IN] A reference (mdTypeRef or mdTypeRef) to the Event class.
        mdMethodDef mdAddOn,                // [IN] Add method.
        mdMethodDef mdRemoveOn,             // [IN] Remove method.
        mdMethodDef mdFire,                 // [IN] Fire method.
        mdMethodDef rmdOtherMethods[]) PURE;// [IN] Array of other methods associate with the event.

    STDMETHOD(SetPermissionSetProps)(       // S_OK or error.
        mdToken     tk,                     // [IN] The object to be decorated.
        DWORD       dwAction,               // [IN] CorDeclSecurity.
        void const  *pvPermission,          // [IN] Permission blob.
        ULONG       cbPermission,           // [IN] Count of bytes of pvPermission.
        mdPermission *ppm) PURE;            // [OUT] Permission token.

    STDMETHOD(DefinePinvokeMap)(            // Return code.
        mdToken     tk,                     // [IN] FieldDef or MethodDef.
        DWORD       dwMappingFlags,         // [IN] Flags used for mapping.
        LPCWSTR     szImportName,           // [IN] Import name.
        mdModuleRef mrImportDLL) PURE;      // [IN] ModuleRef token for the target DLL.

    STDMETHOD(SetPinvokeMap)(               // Return code.
        mdToken     tk,                     // [IN] FieldDef or MethodDef.
        DWORD       dwMappingFlags,         // [IN] Flags used for mapping.
        LPCWSTR     szImportName,           // [IN] Import name.
        mdModuleRef mrImportDLL) PURE;      // [IN] ModuleRef token for the target DLL.

    STDMETHOD(DeletePinvokeMap)(            // Return code.
        mdToken     tk) PURE;               // [IN] FieldDef or MethodDef.

    // New CustomAttribute functions.
    STDMETHOD(DefineCustomAttribute)(       // Return code.
        mdToken     tkObj,                  // [IN] The object to put the value on.
        mdToken     tkType,                 // [IN] Type of the CustomValue (TypeRef/TypeDef).
        void const  *pCustomValue,          // [IN] The custom value data.
        ULONG       cbCustomValue,          // [IN] The custom value data length.
        mdCustomValue *pcv) PURE;           // [OUT] The custom value token value on return.

    STDMETHOD(SetCustomAttributeValue)(     // Return code.
        mdCustomValue pcv,                  // [IN] The custom value token whose value to replace.
        void const  *pCustomValue,          // [IN] The custom value data.
        ULONG       cbCustomValue) PURE;    // [IN] The custom value data length.

    STDMETHOD(DefineField)(                 // S_OK or error. 
        mdTypeDef   td,                     // Parent TypeDef   
        LPCWSTR     szName,                 // Name of member   
        DWORD       dwFieldFlags,           // Member attributes    
        PCCOR_SIGNATURE pvSigBlob,          // [IN] point to a blob value of COM+ signature 
        ULONG       cbSigBlob,              // [IN] count of bytes in the signature blob    
        DWORD       dwCPlusTypeFlag,        // [IN] flag for value type. selected ELEMENT_TYPE_*    
        void const  *pValue,                // [IN] constant value  
        ULONG       cchValue,               // [IN] size of constant value (string, in wide chars).
        mdFieldDef  *pmd) PURE;             // [OUT] Put member token here    

    STDMETHOD(DefineProperty)( 
        mdTypeDef   td,                     // [IN] the class/interface on which the property is being defined  
        LPCWSTR     szProperty,             // [IN] Name of the property    
        DWORD       dwPropFlags,            // [IN] CorPropertyAttr 
        PCCOR_SIGNATURE pvSig,              // [IN] the required type signature 
        ULONG       cbSig,                  // [IN] the size of the type signature blob 
        DWORD       dwCPlusTypeFlag,        // [IN] flag for value type. selected ELEMENT_TYPE_*    
        void const  *pValue,                // [IN] constant value  
        ULONG       cchValue,               // [IN] size of constant value (string, in wide chars).
        mdMethodDef mdSetter,               // [IN] optional setter of the property 
        mdMethodDef mdGetter,               // [IN] optional getter of the property 
        mdMethodDef rmdOtherMethods[],      // [IN] an optional array of other methods  
        mdFieldDef  fdBackingField,         // [IN] optional field   
        mdProperty  *pmdProp) PURE;         // [OUT] output property token  

    STDMETHOD(DefineParam)(
        mdMethodDef md,                     // [IN] Owning method   
        ULONG       ulParamSeq,             // [IN] Which param 
        LPCWSTR     szName,                 // [IN] Optional param name 
        DWORD       dwParamFlags,           // [IN] Optional param flags    
        DWORD       dwCPlusTypeFlag,        // [IN] flag for value type. selected ELEMENT_TYPE_*    
        void const  *pValue,                // [IN] constant value  
        ULONG       cchValue,               // [IN] size of constant value (string, in wide chars).
        mdParamDef  *ppd) PURE;             // [OUT] Put param token here   

    STDMETHOD(SetFieldProps)(               // S_OK or error.
        mdFieldDef  fd,                     // [IN] The FieldDef.
        DWORD       dwFieldFlags,           // [IN] Field attributes.
        DWORD       dwCPlusTypeFlag,        // [IN] Flag for the value type, selected ELEMENT_TYPE_*
        void const  *pValue,                // [IN] Constant value.
        ULONG       cchValue) PURE;         // [IN] size of constant value (string, in wide chars).

    STDMETHOD(SetPropertyProps)(            // S_OK or error.
        mdProperty  pr,                     // [IN] Property token.
        DWORD       dwPropFlags,            // [IN] CorPropertyAttr.
        DWORD       dwCPlusTypeFlag,        // [IN] Flag for value type, selected ELEMENT_TYPE_*
        void const  *pValue,                // [IN] Constant value.
        ULONG       cchValue,               // [IN] size of constant value (string, in wide chars).
        mdMethodDef mdSetter,               // [IN] Setter of the property.
        mdMethodDef mdGetter,               // [IN] Getter of the property.
        mdMethodDef rmdOtherMethods[],      // [IN] Array of other methods.
        mdFieldDef  fdBackingField) PURE;   // [IN] Backing field.

    STDMETHOD(SetParamProps)(             // Return code.
        mdParamDef  pd,                     // [IN] Param token.   
        LPCWSTR     szName,                 // [IN] Param name.
        DWORD       dwParamFlags,           // [IN] Param flags.
        DWORD       dwCPlusTypeFlag,        // [IN] Flag for value type. selected ELEMENT_TYPE_*.
        void const  *pValue,                // [OUT] Constant value.
        ULONG       cchValue) PURE;         // [IN] size of constant value (string, in wide chars).

    // Specialized CustomAttribute for security.
    STDMETHOD(DefineSecurityAttribute)(     // Return code.
        mdToken     tkObj,                  // [IN] The object to put the value on.
        mdMemberRef tkCtor,                 // [IN] The security attribute constructor.
        void const  *pCustomValue,          // [IN] The custom value data.
        ULONG       cbCustomValue) PURE;    // [IN] The custom value data length.

    STDMETHOD(DefineSecurityAttributeSet)(  // Return code.
        mdToken     tkObj,                  // [IN] Class or method requiring security attributes.
        COR_SECATTR rSecAttrs[],            // [IN] Array of security attribute descriptions.
        ULONG       cSecAttrs,              // [IN] Count of elements in above array.
        ULONG       *pulErrorAttr) PURE;    // [OUT] On error, index of attribute causing problem.

    STDMETHOD(ApplyEditAndContinue)(        // S_OK or error.
        IUnknown    *pImport) PURE;     // [IN] Metadata from the delta PE.

    STDMETHOD(TranslateSigWithScope)(
        IMetaDataAssemblyImport *pAssemImport, // [IN] importing assembly interface
        const void  *pbHashValue,           // [IN] Hash Blob for Assembly.
        ULONG       cbHashValue,            // [IN] Count of bytes.
        mdExecutionLocation tkExec,         // [IN] Execution location for AssemblyRef.
        IMetaDataImport *import,            // [IN] importing interface
        PCCOR_SIGNATURE pbSigBlob,          // [IN] signature in the importing scope
        ULONG       cbSigBlob,              // [IN] count of bytes of signature
        IMetaDataAssemblyEmit *pAssemEmit,  // [IN] emit assembly interface
        IMetaDataEmit *emit,                // [IN] emit interface
        PCOR_SIGNATURE pvTranslatedSig,     // [OUT] buffer to hold translated signature
        ULONG       cbTranslatedSigMax,
        ULONG       *pcbTranslatedSig) PURE;// [OUT] count of bytes in the translated signature

    STDMETHOD(SetMethodImplFlags)(          // [IN] S_OK or error.  
        mdMethodDef md,                     // [IN] Method for which to set ImplFlags 
        DWORD       dwImplFlags) PURE;  

    STDMETHOD(SetFieldRVA)(                 // [IN] S_OK or error.  
        mdFieldDef  fd,                     // [IN] Field for which to set offset  
        ULONG       ulRVA) PURE;            // [IN] The offset  

    STDMETHOD(MergeEx)(                     // S_OK or error.
        IMetaDataImport *pImport,           // [IN] The scope to be merged.
        IMapToken   *pHostMapToken,         // [IN] Host IMapToken interface to receive token remap notification
        IUnknown    *pHandler) PURE;        // [IN] An object to receive to receive error notification.

    STDMETHOD(MergeEndEx)() PURE;           // S_OK or error.

// Methods placed at end for easier removal from vtable.    
    STDMETHOD(Merge)(                       // S_OK or error.
        IMetaDataImport *pImport,           // [IN] The scope to be merged.
        IMapToken   *pIMap) PURE;           // [IN] An object to receive token remap notices.

    STDMETHOD(MergeEnd)() PURE;             // S_OK or error.

};      // IMetaDataEmit


//-------------------------------------
//--- IMetaDataImport
//-------------------------------------

// {D7666763-C171-42cc-B947-0EDFA17F3B59}
extern const GUID DECLSPEC_SELECT_ANY IID_IMetaDataImport = 
{ 0xd7666763, 0xc171, 0x42cc, { 0xb9, 0x47, 0xe, 0xdf, 0xa1, 0x7f, 0x3b, 0x59 } };

//---
#undef  INTERFACE   
#define INTERFACE IMetaDataImport
DECLARE_INTERFACE_(IMetaDataImport, IUnknown)
{
    STDMETHOD_(void, CloseEnum)(HCORENUM hEnum) PURE;
    STDMETHOD(CountEnum)(HCORENUM hEnum, ULONG *pulCount) PURE;
    STDMETHOD(ResetEnum)(HCORENUM hEnum, ULONG ulPos) PURE;
    STDMETHOD(EnumTypeDefs)(HCORENUM *phEnum, mdTypeDef rTypeDefs[],
                            ULONG cMax, ULONG *pcTypeDefs) PURE;
    STDMETHOD(EnumInterfaceImpls)(HCORENUM *phEnum, mdTypeDef td,
                            mdInterfaceImpl rImpls[], ULONG cMax,
                            ULONG* pcImpls) PURE;
    STDMETHOD(EnumTypeRefs)(HCORENUM *phEnum, mdTypeRef rTypeRefs[],
                            ULONG cMax, ULONG* pcTypeRefs) PURE;

    STDMETHOD(FindTypeDefByName)(           // S_OK or error.
        LPCWSTR     szTypeDef,              // [IN] Name of the Type.
        mdToken     tkEnclosingClass,       // [IN] TypeDef/TypeRef for Enclosing class.
        mdTypeDef   *ptd) PURE;             // [OUT] Put the TypeDef token here.

    STDMETHOD(GetScopeProps)(               // S_OK or error.
        LPWSTR      szName,                 // [OUT] Put the name here.
        ULONG       cchName,                // [IN] Size of name buffer in wide chars.
        ULONG       *pchName,               // [OUT] Put size of name (wide chars) here.
        GUID        *pmvid) PURE;           // [OUT, OPTIONAL] Put MVID here.

    STDMETHOD(GetModuleFromScope)(          // S_OK.
        mdModule    *pmd) PURE;             // [OUT] Put mdModule token here.

    STDMETHOD(GetTypeDefProps)(             // S_OK or error.
        mdTypeDef   td,                     // [IN] TypeDef token for inquiry.
        LPWSTR      szTypeDef,              // [OUT] Put name here.
        ULONG       cchTypeDef,             // [IN] size of name buffer in wide chars.
        ULONG       *pchTypeDef,            // [OUT] put size of name (wide chars) here.
        CLASSVERSION *pver,                 // [OUT] Put version here.
        DWORD       *pdwTypeDefFlags,       // [OUT] Put flags here.
        mdToken     *ptkExtends) PURE;      // [OUT] Put base class TypeDef/TypeRef here.

    STDMETHOD(GetInterfaceImplProps)(       // S_OK or error.
        mdInterfaceImpl iiImpl,             // [IN] InterfaceImpl token.
        mdTypeDef   *pClass,                // [OUT] Put implementing class token here.
        mdToken     *ptkIface) PURE;        // [OUT] Put implemented interface token here.              

    STDMETHOD(GetTypeRefProps)(             // S_OK or error.
        mdTypeRef   tr,                     // [IN] TypeRef token.
        mdToken     *ptkResolutionScope,    // [OUT] Resolution scope, ModuleRef or AssemblyRef.
        LPWSTR      szName,                 // [OUT] Name of the TypeRef.
        ULONG       cchName,                // [IN] Size of buffer.
        ULONG       *pchName) PURE;         // [OUT] Size of Name.

    STDMETHOD(ResolveTypeRef)(mdTypeRef tr, REFIID riid, IUnknown **ppIScope, mdTypeDef *ptd) PURE;

    STDMETHOD(EnumMembers)(                 // S_OK, S_FALSE, or error. 
        HCORENUM    *phEnum,                // [IN|OUT] Pointer to the enum.    
        mdTypeDef   cl,                     // [IN] TypeDef to scope the enumeration.   
        mdToken     rMembers[],             // [OUT] Put MemberDefs here.   
        ULONG       cMax,                   // [IN] Max MemberDefs to put.  
        ULONG       *pcTokens) PURE;        // [OUT] Put # put here.    

    STDMETHOD(EnumMembersWithName)(         // S_OK, S_FALSE, or error.             
        HCORENUM    *phEnum,                // [IN|OUT] Pointer to the enum.                
        mdTypeDef   cl,                     // [IN] TypeDef to scope the enumeration.   
        LPCWSTR     szName,                 // [IN] Limit results to those with this name.              
        mdToken     rMembers[],             // [OUT] Put MemberDefs here.                   
        ULONG       cMax,                   // [IN] Max MemberDefs to put.              
        ULONG       *pcTokens) PURE;        // [OUT] Put # put here.    

    STDMETHOD(EnumMethods)(                 // S_OK, S_FALSE, or error. 
        HCORENUM    *phEnum,                // [IN|OUT] Pointer to the enum.    
        mdTypeDef   cl,                     // [IN] TypeDef to scope the enumeration.   
        mdMethodDef rMethods[],             // [OUT] Put MethodDefs here.   
        ULONG       cMax,                   // [IN] Max MethodDefs to put.  
        ULONG       *pcTokens) PURE;        // [OUT] Put # put here.    

    STDMETHOD(EnumMethodsWithName)(         // S_OK, S_FALSE, or error.             
        HCORENUM    *phEnum,                // [IN|OUT] Pointer to the enum.                
        mdTypeDef   cl,                     // [IN] TypeDef to scope the enumeration.   
        LPCWSTR     szName,                 // [IN] Limit results to those with this name.              
        mdMethodDef rMethods[],             // [OU] Put MethodDefs here.    
        ULONG       cMax,                   // [IN] Max MethodDefs to put.              
        ULONG       *pcTokens) PURE;        // [OUT] Put # put here.    

    STDMETHOD(EnumFields)(                 // S_OK, S_FALSE, or error.  
        HCORENUM    *phEnum,                // [IN|OUT] Pointer to the enum.    
        mdTypeDef   cl,                     // [IN] TypeDef to scope the enumeration.   
        mdFieldDef  rFields[],              // [OUT] Put FieldDefs here.    
        ULONG       cMax,                   // [IN] Max FieldDefs to put.   
        ULONG       *pcTokens) PURE;        // [OUT] Put # put here.    

    STDMETHOD(EnumFieldsWithName)(         // S_OK, S_FALSE, or error.              
        HCORENUM    *phEnum,                // [IN|OUT] Pointer to the enum.                
        mdTypeDef   cl,                     // [IN] TypeDef to scope the enumeration.   
        LPCWSTR     szName,                 // [IN] Limit results to those with this name.              
        mdFieldDef  rFields[],              // [OUT] Put MemberDefs here.                   
        ULONG       cMax,                   // [IN] Max MemberDefs to put.              
        ULONG       *pcTokens) PURE;        // [OUT] Put # put here.    


    STDMETHOD(EnumParams)(                  // S_OK, S_FALSE, or error. 
        HCORENUM    *phEnum,                // [IN|OUT] Pointer to the enum.    
        mdMethodDef mb,                     // [IN] MethodDef to scope the enumeration. 
        mdParamDef  rParams[],              // [OUT] Put ParamDefs here.    
        ULONG       cMax,                   // [IN] Max ParamDefs to put.   
        ULONG       *pcTokens) PURE;        // [OUT] Put # put here.    

    STDMETHOD(EnumMemberRefs)(              // S_OK, S_FALSE, or error. 
        HCORENUM    *phEnum,                // [IN|OUT] Pointer to the enum.    
        mdToken     tkParent,               // [IN] Parent token to scope the enumeration.  
        mdMemberRef rMemberRefs[],          // [OUT] Put MemberRefs here.   
        ULONG       cMax,                   // [IN] Max MemberRefs to put.  
        ULONG       *pcTokens) PURE;        // [OUT] Put # put here.    

    STDMETHOD(EnumMethodImpls)(             // S_OK, S_FALSE, or error  
        HCORENUM    *phEnum,                // [IN|OUT] Pointer to the enum.    
        mdTypeDef   td,                     // [IN] TypeDef to scope the enumeration.   
        mdToken     rMethodBody[],          // [OUT] Put Method Body tokens here.   
        mdToken     rMethodDecl[],          // [OUT] Put Method Declaration tokens here.
        ULONG       cMax,                   // [IN] Max tokens to put.  
        ULONG       *pcTokens) PURE;        // [OUT] Put # put here.    

    STDMETHOD(EnumPermissionSets)(          // S_OK, S_FALSE, or error. 
        HCORENUM    *phEnum,                // [IN|OUT] Pointer to the enum.    
        mdToken     tk,                     // [IN] if !NIL, token to scope the enumeration.    
        DWORD       dwActions,              // [IN] if !0, return only these actions.   
        mdPermission rPermission[],         // [OUT] Put Permissions here.  
        ULONG       cMax,                   // [IN] Max Permissions to put. 
        ULONG       *pcTokens) PURE;        // [OUT] Put # put here.    

    STDMETHOD(FindMember)(  
        mdTypeDef   td,                     // [IN] given typedef   
        LPCWSTR     szName,                 // [IN] member name 
        PCCOR_SIGNATURE pvSigBlob,          // [IN] point to a blob value of COM+ signature 
        ULONG       cbSigBlob,              // [IN] count of bytes in the signature blob    
        mdToken     *pmb) PURE;             // [OUT] matching memberdef 

    STDMETHOD(FindMethod)(  
        mdTypeDef   td,                     // [IN] given typedef   
        LPCWSTR     szName,                 // [IN] member name 
        PCCOR_SIGNATURE pvSigBlob,          // [IN] point to a blob value of COM+ signature 
        ULONG       cbSigBlob,              // [IN] count of bytes in the signature blob    
        mdMethodDef *pmb) PURE;             // [OUT] matching memberdef 

    STDMETHOD(FindField)(   
        mdTypeDef   td,                     // [IN] given typedef   
        LPCWSTR     szName,                 // [IN] member name 
        PCCOR_SIGNATURE pvSigBlob,          // [IN] point to a blob value of COM+ signature 
        ULONG       cbSigBlob,              // [IN] count of bytes in the signature blob    
        mdFieldDef  *pmb) PURE;             // [OUT] matching memberdef 

    STDMETHOD(FindMemberRef)(   
        mdTypeRef   td,                     // [IN] given typeRef   
        LPCWSTR     szName,                 // [IN] member name 
        PCCOR_SIGNATURE pvSigBlob,          // [IN] point to a blob value of COM+ signature 
        ULONG       cbSigBlob,              // [IN] count of bytes in the signature blob    
        mdMemberRef *pmr) PURE;             // [OUT] matching memberref 

    STDMETHOD (GetMethodProps)( 
        mdMethodDef mb,                     // The method for which to get props.   
        mdTypeDef   *pClass,                // Put method's class here. 
        LPWSTR      szMethod,               // Put method's name here.  
        ULONG       cchMethod,              // Size of szMethod buffer in wide chars.   
        ULONG       *pchMethod,             // Put actual size here 
        DWORD       *pdwAttr,               // Put flags here.  
        PCCOR_SIGNATURE *ppvSigBlob,        // [OUT] point to the blob value of meta data   
        ULONG       *pcbSigBlob,            // [OUT] actual size of signature blob  
        ULONG       *pulCodeRVA,            // [OUT] codeRVA    
        DWORD       *pdwImplFlags) PURE;    // [OUT] Impl. Flags    

    STDMETHOD(GetMemberRefProps)(           // S_OK or error.   
        mdMemberRef mr,                     // [IN] given memberref 
        mdToken     *ptk,                   // [OUT] Put classref or classdef here. 
        LPWSTR      szMember,               // [OUT] buffer to fill for member's name   
        ULONG       cchMember,              // [IN] the count of char of szMember   
        ULONG       *pchMember,             // [OUT] actual count of char in member name    
        PCCOR_SIGNATURE *ppvSigBlob,        // [OUT] point to meta data blob value  
        ULONG       *pbSig) PURE;           // [OUT] actual size of signature blob  

    STDMETHOD(EnumProperties)(              // S_OK, S_FALSE, or error. 
        HCORENUM    *phEnum,                // [IN|OUT] Pointer to the enum.    
        mdTypeDef   td,                     // [IN] TypeDef to scope the enumeration.   
        mdProperty  rProperties[],          // [OUT] Put Properties here.   
        ULONG       cMax,                   // [IN] Max properties to put.  
        ULONG       *pcProperties) PURE;    // [OUT] Put # put here.    

    STDMETHOD(EnumEvents)(                  // S_OK, S_FALSE, or error. 
        HCORENUM    *phEnum,                // [IN|OUT] Pointer to the enum.    
        mdTypeDef   td,                     // [IN] TypeDef to scope the enumeration.   
        mdEvent     rEvents[],              // [OUT] Put events here.   
        ULONG       cMax,                   // [IN] Max events to put.  
        ULONG       *pcEvents) PURE;        // [OUT] Put # put here.    

    STDMETHOD(GetEventProps)(               // S_OK, S_FALSE, or error. 
        mdEvent     ev,                     // [IN] event token 
        mdTypeDef   *pClass,                // [OUT] typedef containing the event declarion.    
        LPCWSTR     szEvent,                // [OUT] Event name 
        ULONG       cchEvent,               // [IN] the count of wchar of szEvent   
        ULONG       *pchEvent,              // [OUT] actual count of wchar for event's name 
        DWORD       *pdwEventFlags,         // [OUT] Event flags.   
        mdToken     *ptkEventType,          // [OUT] EventType class    
        mdMethodDef *pmdAddOn,              // [OUT] AddOn method of the event  
        mdMethodDef *pmdRemoveOn,           // [OUT] RemoveOn method of the event   
        mdMethodDef *pmdFire,               // [OUT] Fire method of the event   
        mdMethodDef rmdOtherMethod[],       // [OUT] other method of the event  
        ULONG       cMax,                   // [IN] size of rmdOtherMethod  
        ULONG       *pcOtherMethod) PURE;   // [OUT] total number of other method of this event 

    STDMETHOD(EnumMethodSemantics)(         // S_OK, S_FALSE, or error. 
        HCORENUM    *phEnum,                // [IN|OUT] Pointer to the enum.    
        mdMethodDef mb,                     // [IN] MethodDef to scope the enumeration. 
        mdToken     rEventProp[],           // [OUT] Put Event/Property here.   
        ULONG       cMax,                   // [IN] Max properties to put.  
        ULONG       *pcEventProp) PURE;     // [OUT] Put # put here.    

    STDMETHOD(GetMethodSemantics)(          // S_OK, S_FALSE, or error. 
        mdMethodDef mb,                     // [IN] method token    
        mdToken     tkEventProp,            // [IN] event/property token.   
        DWORD       *pdwSemanticsFlags) PURE; // [OUT] the role flags for the method/propevent pair 

    STDMETHOD(GetClassLayout) ( 
        mdTypeDef   td,                     // [IN] give typedef    
        DWORD       *pdwPackSize,           // [OUT] 1, 2, 4, 8, or 16  
        COR_FIELD_OFFSET rFieldOffset[],    // [OUT] field offset array 
        ULONG       cMax,                   // [IN] size of the array   
        ULONG       *pcFieldOffset,         // [OUT] needed array size  
        ULONG       *pulClassSize) PURE;        // [OUT] the size of the class  

    STDMETHOD(GetFieldMarshal) (    
        mdToken     tk,                     // [IN] given a field's memberdef   
        PCCOR_SIGNATURE *ppvNativeType,     // [OUT] native type of this field  
        ULONG       *pcbNativeType) PURE;   // [OUT] the count of bytes of *ppvNativeType   

    STDMETHOD(GetRVA)(                      // S_OK or error.   
        mdToken     tk,                     // Member for which to set offset   
        ULONG       *pulCodeRVA,            // The offset   
        DWORD       *pdwImplFlags) PURE;    // the implementation flags 

    STDMETHOD(GetPermissionSetProps) (  
        mdPermission pm,                    // [IN] the permission token.   
        DWORD       *pdwAction,             // [OUT] CorDeclSecurity.   
        void const  **ppvPermission,        // [OUT] permission blob.   
        ULONG       *pcbPermission) PURE;   // [OUT] count of bytes of pvPermission.    

    STDMETHOD(GetSigFromToken)(             // S_OK or error.   
        mdSignature mdSig,                  // [IN] Signature token.    
        PCCOR_SIGNATURE *ppvSig,            // [OUT] return pointer to token.   
        ULONG       *pcbSig) PURE;          // [OUT] return size of signature.  

    STDMETHOD(GetModuleRefProps)(           // S_OK or error.   
        mdModuleRef mur,                    // [IN] moduleref token.    
        LPWSTR      szName,                 // [OUT] buffer to fill with the moduleref name.    
        ULONG       cchName,                // [IN] size of szName in wide characters.  
        ULONG       *pchName) PURE;         // [OUT] actual count of characters in the name.    

    STDMETHOD(EnumModuleRefs)(              // S_OK or error.   
        HCORENUM    *phEnum,                // [IN|OUT] pointer to the enum.    
        mdModuleRef rModuleRefs[],          // [OUT] put modulerefs here.   
        ULONG       cmax,                   // [IN] max memberrefs to put.  
        ULONG       *pcModuleRefs) PURE;    // [OUT] put # put here.    

    STDMETHOD(GetTypeSpecFromToken)(        // S_OK or error.   
        mdTypeSpec typespec,                // [IN] TypeSpec token.    
        PCCOR_SIGNATURE *ppvSig,            // [OUT] return pointer to TypeSpec signature  
        ULONG       *pcbSig) PURE;          // [OUT] return size of signature.  

    STDMETHOD(GetNameFromToken)(            // S_OK or error.
        mdToken     tk,                     // [IN] Token to get name from.  Must have a name.
        MDUTF8CSTR  *pszUtf8NamePtr) PURE;  // [OUT] Return pointer to UTF8 name in heap.

    STDMETHOD(GetSymbolBindingPath)(        // S_OK or error.
        GUID        *pFormatID,             // [OUT] Symbol data format ID.
        LPWSTR      szSymbolDataPath,       // [OUT] Path of symbols.
        ULONG       cchSymbolDataPath,      // [IN] Max characters for output buffer.
        ULONG       *pcbSymbolDataPath) PURE;// [OUT] Number of chars in actual name.

    STDMETHOD(EnumUnresolvedMethods)(       // S_OK, S_FALSE, or error. 
        HCORENUM    *phEnum,                // [IN|OUT] Pointer to the enum.    
        mdToken     rMethods[],             // [OUT] Put MemberDefs here.   
        ULONG       cMax,                   // [IN] Max MemberDefs to put.  
        ULONG       *pcTokens) PURE;        // [OUT] Put # put here.    

    STDMETHOD(GetUserString)(               // S_OK or error.
        mdString    stk,                    // [IN] String token.
        LPWSTR      szString,               // [OUT] Copy of string.
        ULONG       cchString,              // [IN] Max chars of room in szString.
        ULONG       *pchString) PURE;       // [OUT] How many chars in actual string.

    STDMETHOD(GetPinvokeMap)(               // S_OK or error.
        mdToken     tk,                     // [IN] FieldDef or MethodDef.
        DWORD       *pdwMappingFlags,       // [OUT] Flags used for mapping.
        LPWSTR      szImportName,           // [OUT] Import name.
        ULONG       cchImportName,          // [IN] Size of the name buffer.
        ULONG       *pchImportName,         // [OUT] Actual number of characters stored.
        mdModuleRef *pmrImportDLL) PURE;    // [OUT] ModuleRef token for the target DLL.

    STDMETHOD(EnumSignatures)(              // S_OK or error.
        HCORENUM    *phEnum,                // [IN|OUT] pointer to the enum.    
        mdSignature rSignatures[],          // [OUT] put signatures here.   
        ULONG       cmax,                   // [IN] max signatures to put.  
        ULONG       *pcSignatures) PURE;    // [OUT] put # put here.

    STDMETHOD(EnumTypeSpecs)(               // S_OK or error.
        HCORENUM    *phEnum,                // [IN|OUT] pointer to the enum.    
        mdTypeSpec  rTypeSpecs[],           // [OUT] put TypeSpecs here.   
        ULONG       cmax,                   // [IN] max TypeSpecs to put.  
        ULONG       *pcTypeSpecs) PURE;     // [OUT] put # put here.

    STDMETHOD(EnumUserStrings)(             // S_OK or error.
        HCORENUM    *phEnum,                // [IN/OUT] pointer to the enum.
        mdString    rStrings[],             // [OUT] put Strings here.
        ULONG       cmax,                   // [IN] max Strings to put.
        ULONG       *pcStrings) PURE;       // [OUT] put # put here.

    STDMETHOD(GetParamForMethodIndex)(      // S_OK or error.
        mdMethodDef md,                     // [IN] Method token.
        ULONG       ulParamSeq,             // [IN] Parameter sequence.
        mdParamDef  *ppd) PURE;             // [IN] Put Param token here.

    // New Custom Value functions.
    STDMETHOD(EnumCustomAttributes)(        // S_OK or error.
        HCORENUM    *phEnum,                // [IN, OUT] COR enumerator.
        mdToken     tk,                     // [IN] Token to scope the enumeration, 0 for all.
        mdToken     tkType,                 // [IN] Type of interest, 0 for all.
        mdCustomValue rCustomValues[],      // [OUT] Put custom attribute tokens here.
        ULONG       cMax,                   // [IN] Size of rCustomValues.
        ULONG       *pcCustomValues) PURE;  // [OUT, OPTIONAL] Put count of token values here.

    STDMETHOD(GetCustomAttributeProps)(     // S_OK or error.
        mdCustomValue cv,                   // [IN] CustomAttribute token.
        mdToken     *ptkObj,                // [OUT, OPTIONAL] Put object token here.
        mdToken     *ptkType,               // [OUT, OPTIONAL] Put AttrType token here.
        void const  **ppBlob,               // [OUT, OPTIONAL] Put pointer to data here.
        ULONG       *pcbSize) PURE;         // [OUT, OPTIONAL] Put size of date here.

    STDMETHOD(FindTypeRef)(   
        mdToken     tkResolutionScope,      // [IN] ModuleRef, AssemblyRef or TypeRef.
        LPCWSTR     szName,                 // [IN] TypeRef Name.
        mdTypeRef   *ptr) PURE;             // [OUT] matching TypeRef.

    STDMETHOD(GetMemberProps)(  
        mdToken     mb,                     // The member for which to get props.   
        mdTypeDef   *pClass,                // Put member's class here. 
        LPWSTR      szMember,               // Put member's name here.  
        ULONG       cchMember,              // Size of szMember buffer in wide chars.   
        ULONG       *pchMember,             // Put actual size here 
        DWORD       *pdwAttr,               // Put flags here.  
        PCCOR_SIGNATURE *ppvSigBlob,        // [OUT] point to the blob value of meta data   
        ULONG       *pcbSigBlob,            // [OUT] actual size of signature blob  
        ULONG       *pulCodeRVA,            // [OUT] codeRVA    
        DWORD       *pdwImplFlags,          // [OUT] Impl. Flags    
        DWORD       *pdwCPlusTypeFlag,      // [OUT] flag for value type. selected ELEMENT_TYPE_*   
        void const  **ppValue,              // [OUT] constant value 
        ULONG       *pcbValue) PURE;        // [OUT] size of constant value

    STDMETHOD(GetFieldProps)(  
        mdFieldDef  mb,                     // The field for which to get props.    
        mdTypeDef   *pClass,                // Put field's class here.  
        LPWSTR      szField,                // Put field's name here.   
        ULONG       cchField,               // Size of szField buffer in wide chars.    
        ULONG       *pchField,              // Put actual size here 
        DWORD       *pdwAttr,               // Put flags here.  
        PCCOR_SIGNATURE *ppvSigBlob,        // [OUT] point to the blob value of meta data   
        ULONG       *pcbSigBlob,            // [OUT] actual size of signature blob  
        DWORD       *pdwCPlusTypeFlag,      // [OUT] flag for value type. selected ELEMENT_TYPE_*   
        void const  **ppValue,              // [OUT] constant value 
        ULONG       *pcbValue) PURE;        // [OUT] size of constant value

    STDMETHOD(GetPropertyProps)(            // S_OK, S_FALSE, or error. 
        mdProperty  prop,                   // [IN] property token  
        mdTypeDef   *pClass,                // [OUT] typedef containing the property declarion. 
        LPCWSTR     szProperty,             // [OUT] Property name  
        ULONG       cchProperty,            // [IN] the count of wchar of szProperty    
        ULONG       *pchProperty,           // [OUT] actual count of wchar for property name    
        DWORD       *pdwPropFlags,          // [OUT] property flags.    
        PCCOR_SIGNATURE *ppvSig,            // [OUT] property type. pointing to meta data internal blob 
        ULONG       *pbSig,                 // [OUT] count of bytes in *ppvSig  
        DWORD       *pdwCPlusTypeFlag,      // [OUT] flag for value type. selected ELEMENT_TYPE_*   
        void const  **ppDefaultValue,       // [OUT] constant value 
        ULONG       *pcbDefaultValue,       // [OUT] size of constant value
        mdMethodDef *pmdSetter,             // [OUT] setter method of the property  
        mdMethodDef *pmdGetter,             // [OUT] getter method of the property  
        mdMethodDef rmdOtherMethod[],       // [OUT] other method of the property   
        ULONG       cMax,                   // [IN] size of rmdOtherMethod  
        ULONG       *pcOtherMethod,         // [OUT] total number of other method of this property  
        mdFieldDef  *pmdBackingField) PURE;  // [OUT] backing field 

    STDMETHOD(GetParamProps)(               // S_OK or error.
        mdParamDef  tk,                     // [IN]The Parameter.
        mdMethodDef *pmd,                   // [OUT] Parent Method token.
        ULONG       *pulSequence,           // [OUT] Parameter sequence.
        LPWSTR      szName,                 // [OUT] Put name here.
        ULONG       cchName,                // [OUT] Size of name buffer.
        ULONG       *pchName,               // [OUT] Put actual size of name here.
        DWORD       *pdwAttr,               // [OUT] Put flags here.
        DWORD       *pdwCPlusTypeFlag,      // [OUT] Flag for value type. selected ELEMENT_TYPE_*.
        void const  **ppValue,              // [OUT] Constant value.
        ULONG       *pcbValue) PURE;        //[OUT] size of constant value

    STDMETHOD(GetCustomAttributeByName)(    // S_OK or error.
        mdToken     tkObj,                  // [IN] Object with Custom Attribute.
        LPCWSTR     szName,                 // [IN] Name of desired Custom Attribute.
        const void  **ppData,               // [OUT] Put pointer to data here.
        ULONG       *pcbData) PURE;         // [OUT] Put size of data here.

    STDMETHOD_(BOOL, IsValidToken)(         // True or False.
        mdToken     tk) PURE;               // [IN] Given token.

    STDMETHOD(GetNestedClassProps)(         // S_OK or error.
        mdTypeDef   tdNestedClass,          // [IN] NestedClass token.
        mdTypeDef   *ptdEnclosingClass) PURE; // [OUT] EnclosingClass token.

    STDMETHOD(GetNativeCallConvFromSig)(    // S_OK or error.
        void const  *pvSig,                 // [IN] Pointer to signature.
        ULONG       cbSig,                  // [IN] Count of signature bytes.
        ULONG       *pCallConv) PURE;       // [OUT] Put calling conv here (see CorPinvokemap).                                                                                        

};      // IMetaDataImport


//-------------------------------------
//--- IMetaDataFilter
//-------------------------------------

// {D0E80DD1-12D4-11d3-B39D-00C04FF81795}
extern const GUID DECLSPEC_SELECT_ANY IID_IMetaDataFilter = 
{0xd0e80dd1, 0x12d4, 0x11d3, {0xb3, 0x9d, 0x0, 0xc0, 0x4f, 0xf8, 0x17, 0x95} };

//---
#undef  INTERFACE   
#define INTERFACE IMetaDataFilter
DECLARE_INTERFACE_(IMetaDataFilter, IUnknown)
{
    STDMETHOD(UnmarkAll)() PURE;
    STDMETHOD(MarkToken)(mdToken tk) PURE;
    STDMETHOD(IsTokenMarked)(mdToken tk, BOOL *pIsMarked) PURE;
};



//-------------------------------------
//--- IHostFilter
//-------------------------------------

// {D0E80DD3-12D4-11d3-B39D-00C04FF81795}
extern const GUID DECLSPEC_SELECT_ANY IID_IHostFilter = 
{0xd0e80dd3, 0x12d4, 0x11d3, {0xb3, 0x9d, 0x0, 0xc0, 0x4f, 0xf8, 0x17, 0x95} };

//---
#undef  INTERFACE   
#define INTERFACE IHostFilter
DECLARE_INTERFACE_(IHostFilter, IUnknown)
{
    STDMETHOD(MarkToken)(mdToken tk) PURE;
};


//-------------------------------------
//--- IMetaDataCFC
//-------------------------------------

// Obsolete Interface ID.  Respond to QI, but assert.

// {BB779E43-0D36-11d3-8C4E-00C04FF7431A}
extern const GUID DECLSPEC_SELECT_ANY IID_IMetaDataCFC = 
{ 0xbb779e43, 0xd36, 0x11d3, { 0x8c, 0x4e, 0x0, 0xc0, 0x4f, 0xf7, 0x43, 0x1a } };


//---
#undef  INTERFACE   
#define INTERFACE IMetaDataCFC
DECLARE_INTERFACE_(IMetaDataCFC, IUnknown)
{
    // obsolete:
    STDMETHOD(GetMethodCode)(               // return hresult   
        mdMethodDef  mb,                    // [IN] Member definition   
        void         **ppBytes,             // [OUT] Pointer to bytes goes here 
        ULONG        *piSize) PURE;         // [IN] Size of code    

    STDMETHOD(GetMaxIndex)( 
        USHORT      *index) PURE;           // [OUT] Put max constantpool index here    

    STDMETHOD(GetTokenFromIndex)(   
        USHORT      index,                  // [IN] Index into ConstantPool 
        mdCPToken   *pcp) PURE;             // [OUT] Put ConstantPool token here    

    STDMETHOD(GetTokenValue)(   
        mdCPToken   cp,                     // [IN] ConstantPool token  
        VARIANT     *pValue) PURE;          // [OUT] Put token value here   
};


//--------------------------------------
//--- IMetaDataConverter
//--------------------------------------
// {D9DEBD79-2992-11d3-8BC1-0000F8083A57}
extern const GUID DECLSPEC_SELECT_ANY IID_IMetaDataConverter = 
{ 0xd9debd79, 0x2992, 0x11d3, { 0x8b, 0xc1, 0x0, 0x0, 0xf8, 0x8, 0x3a, 0x57 } };


//---
#undef  INTERFACE   
#define INTERFACE IMetaDataConverter
DECLARE_INTERFACE_(IMetaDataConverter, IUnknown)
{
    STDMETHOD(GetMetaDataFromTypeInfo)(
        ITypeInfo* pITI,                    // [in] Type info
        IMetaDataImport** ppMDI) PURE;      // [out] return IMetaDataImport on success

    STDMETHOD(GetMetaDataFromTypeLib)(
        ITypeLib* pITL,                     // [in] Type library
        IMetaDataImport** ppMDI) PURE;      // [out] return IMetaDataImport on success

    STDMETHOD(GetTypeLibFromMetaData)(
        BSTR strModule,                     // [in] Module name
        BSTR strTlbName,                    // [in] Type library name
        ITypeLib** ppITL) PURE;             // [out] return ITypeLib on success
};


//*****************************************************************************
// Assembly Declarations
//*****************************************************************************

typedef struct
{
    DWORD       dwOSPlatformId;         // Operating system platform.
    DWORD       dwOSMajorVersion;       // OS Major version.
    DWORD       dwOSMinorVersion;       // OS Minor version.
} OSINFO;


typedef struct
{
    USHORT      usMajorVersion;         // Major Version.   
    USHORT      usMinorVersion;         // Minor Version.
    USHORT      usRevisionNumber;       // Revision Number.
    USHORT      usBuildNumber;          // Build Number.
    LPWSTR      szLocale;               // Locale.
    ULONG       cbLocale;               // [IN/OUT] Size of the buffer in wide chars/Actual size.
    DWORD       *rProcessor;            // Processor ID array.
    ULONG       ulProcessor;            // [IN/OUT] Size of the Processor ID array/Actual # of entries filled in.
    OSINFO      *rOS;                   // OSINFO array.
    ULONG       ulOS;                   // [IN/OUT]Size of the OSINFO array/Actual # of entries filled in.
    LPWSTR      szConfiguration;        // Configuration.
    ULONG       cbConfiguration;        // [IN/OUT]Size of the configuration buffer in wide chars/Actual size of configuration.
} ASSEMBLYMETADATA;


// {D9B7F7D6-0976-4360-8A70-9B6685290A40}
extern const GUID DECLSPEC_SELECT_ANY IID_IMetaDataAssemblyEmit = 
{ 0xd9b7f7d6, 0x0976, 0x4360, { 0x8a, 0x70, 0x9b, 0x66, 0x85, 0x29, 0x0a, 0x40} };


//---
#undef  INTERFACE   
#define INTERFACE IMetaDataAssemblyEmit
DECLARE_INTERFACE_(IMetaDataAssemblyEmit, IUnknown)
{
    STDMETHOD(DefineAssembly)(              // S_OK or error.
        const void  *pbOriginator,          // [IN] Originator of the assembly.
        ULONG       cbOriginator,           // [IN] Count of bytes in the Originator blob.
        ULONG       ulHashAlgId,            // [IN] Hash algorithm used to hash the files.
        LPCWSTR     szName,                 // [IN] Name of the assembly.
        const ASSEMBLYMETADATA *pMetaData,  // [IN] Assembly MetaData.
        LPCWSTR     szTitle,                // [IN] Title of the assembly.
        LPCWSTR     szDescription,          // [IN] Description.
        LPCWSTR     szDefaultAlias,         // [IN] Default alias for the Assembly.
        DWORD       dwAssemblyFlags,        // [IN] Flags.
        mdAssembly  *pma) PURE;             // [OUT] Returned Assembly token.

    STDMETHOD(DefineAssemblyRef)(           // S_OK or error.
        const void  *pbOriginator,          // [IN] Originator of the assembly.
        ULONG       cbOriginator,           // [IN] Count of bytes in the Originator blob.
        LPCWSTR     szName,                 // [IN] Name of the assembly being referenced.
        const ASSEMBLYMETADATA *pMetaData,  // [IN] Assembly MetaData.
        const void  *pbHashValue,           // [IN] Hash Blob.
        ULONG       cbHashValue,            // [IN] Count of bytes in the Hash Blob.
        mdExecutionLocation tkExecutionLocation, // [IN] The token for Execution Location.
        DWORD       dwAssemblyRefFlags,     // [IN] Token for Execution Location.
        mdAssemblyRef *pmdar) PURE;         // [OUT] Returned AssemblyRef token.

    STDMETHOD(DefineFile)(                  // S_OK or error.
        LPCWSTR     szName,                 // [IN] Name of the file.
        const void  *pbHashValue,           // [IN] Hash Blob.
        ULONG       cbHashValue,            // [IN] Count of bytes in the Hash Blob.
        DWORD       dwFileFlags,            // [IN] Flags.
        mdFile      *pmdf) PURE;            // [OUT] Returned File token.

    STDMETHOD(DefineComType)(               // S_OK or error.
        LPCWSTR     szName,                 // [IN] Name of the Com Type.
        LPCWSTR     szDescription,          // [IN] Description,
        mdToken     tkImplementation,       // [IN] mdFile or mdAssemblyRef or mdComType
        mdTypeDef   tkTypeDef,              // [IN] TypeDef token within the file.
        mdExecutionLocation tkExecutionLocation, // [IN] The token for Execution Location.
        DWORD       dwComTypeFlags,         // [IN] Flags.
        mdComType   *pmdct) PURE;           // [OUT] Returned ComType token.

    STDMETHOD(DefineManifestResource)(      // S_OK or error.
        LPCWSTR     szName,                 // [IN] Name of the resource.
        LPCWSTR     szDescription,          // [IN] Description.
        mdToken     tkImplementation,       // [IN] mdFile or mdAssemblyRef that provides the resource.
        DWORD       dwOffset,               // [IN] Offset to the beginning of the resource within the file.
        LPCWSTR     szMIMEType,             // [IN] MIMEType of the resource.
        LPCWSTR     szLocale,               // [IN] Locale of the resource.
        DWORD       dwResourceFlags,        // [IN] Flags.
        mdManifestResource  *pmdmr) PURE;   // [OUT] Returned ManifestResource token.

    STDMETHOD(DefineExecutionLocation)(     // S_OK or error.
        LPCWSTR     szName,                 // [IN] Name of the Execution Location.
        LPCWSTR     szDescription,          // [IN] Description.
        LPCWSTR     szLocation,             // [IN] Location.
        DWORD       dwExecutionLocationFlags, // [IN] Flags.
        mdExecutionLocation *pmdel) PURE;   // [OUT] Returned Execution Location token.

    STDMETHOD(SetAssemblyRefProps)(         // S_OK or error.
        mdAssemblyRef ar,                   // [IN] AssemblyRefToken.
        const void  *pbOriginator,          // [IN] Originator of the assembly.
        ULONG       cbOriginator,           // [IN] Count of bytes in the Originator blob.
        LPCWSTR     szName,                 // [IN] Name of the assembly being referenced.
        const ASSEMBLYMETADATA *pMetaData,  // [IN] Assembly MetaData.
        const void  *pbHashValue,           // [IN] Hash Blob.
        ULONG       cbHashValue,            // [IN] Count of bytes in the Hash Blob.
        mdExecutionLocation tkExecutionLocation, // [IN] The token for Execution Location.
        DWORD       dwAssemblyRefFlags) PURE; // [IN] Token for Execution Location.

    STDMETHOD(SetFileProps)(                // S_OK or error.
        mdFile      file,                   // [IN] File token.
        const void  *pbHashValue,           // [IN] Hash Blob.
        ULONG       cbHashValue,            // [IN] Count of bytes in the Hash Blob.
        DWORD       dwFileFlags) PURE;      // [IN] Flags.

    STDMETHOD(SetComTypeProps)(             // S_OK or error.
        mdComType   ct,                     // [IN] ComType token.
        LPCWSTR     szDescription,          // [IN] Description,
        mdToken     tkImplementation,       // [IN] mdFile or mdAssemblyRef or mdComType.
        mdTypeDef   tkTypeDef,              // [IN] TypeDef token within the file.
        mdExecutionLocation tkExecutionLocation, // [IN] The token for Execution Location.
        DWORD       dwComTypeFlags) PURE;   // [IN] Flags.

    STDMETHOD(SetManifestResourceProps)(    // S_OK or error.
        mdManifestResource  mr,             // [IN] ManifestResource token.
        LPCWSTR     szDescription,          // [IN] Description.
        mdToken     tkImplementation,       // [IN] mdFile or mdAssemblyRef that provides the resource.
        DWORD       dwOffset,               // [IN] Offset to the beginning of the resource within the file.
        LPCWSTR     szMIMEType,             // [IN] MIMEType of the resource.
        LPCWSTR     szLocale,               // [IN] Locale of the resource.
        DWORD       dwResourceFlags) PURE;  // [IN] Flags.

};  // IMetaDataAssemblyEmit


// {b2f161d2-3d07-413d-8752-689dc0744085}
extern const GUID DECLSPEC_SELECT_ANY IID_IMetaDataAssemblyImport = 
{ 0xb2f161d2, 0x3d07, 0x413d, { 0x87, 0x52, 0x68, 0x9d, 0xc0, 0x74, 0x40, 0x85} };

//---
#undef  INTERFACE   
#define INTERFACE IMetaDataAssemblyImport
DECLARE_INTERFACE_(IMetaDataAssemblyImport, IUnknown)
{
    STDMETHOD(GetAssemblyProps)(            // S_OK or error.
        mdAssembly  mda,                    // [IN] The Assembly for which to get the properties.
        const void  **ppbOriginator,        // [OUT] Pointer to the Originator blob.
        ULONG       *pcbOriginator,         // [OUT] Count of bytes in the Originator Blob.
        ULONG       *pulHashAlgId,          // [OUT] Hash Algorithm.
        LPWSTR      szName,                 // [OUT] Buffer to fill with name.
        ULONG       cchName,                // [IN] Size of buffer in wide chars.
        ULONG       *pchName,               // [OUT] Actual # of wide chars in name.
        ASSEMBLYMETADATA *pMetaData,        // [OUT] Assembly MetaData.
        LPWSTR      szTitle,                // [OUT] Title of the Assembly.
        ULONG       cchTitle,               // [IN] Size of buffer in wide chars.
        ULONG       *pchTitle,              // [OUT] Actual # of wide chars.
        LPWSTR      szDescription,          // [OUT] Description for the Assembly.
        ULONG       cchDescription,         // [IN] Size of buffer in wide chars.
        ULONG       *pchDescription,        // [OUT] Acutal # of wide chars in buffer.
        LPWSTR      szDefaultAlias,         // [OUT] Default alias for the Assembly.
        ULONG       cchDefaultAlias,        // [IN] Size of buffer in wide chars.
        ULONG       *pchDefaultAlias,       // [OUT] Acutal # of wide chars in buffer.
        DWORD       *pdwAssemblyFlags) PURE;    // [OUT] Flags.

    STDMETHOD(GetAssemblyRefProps)(         // S_OK or error.
        mdAssemblyRef mdar,                 // [IN] The AssemblyRef for which to get the properties.
        const void  **ppbOriginator,        // [OUT] Pointer to the Originator blob.
        ULONG       *pcbOriginator,         // [OUT] Count of bytes in the Originator Blob.
        LPWSTR      szName,                 // [OUT] Buffer to fill with name.
        ULONG       cchName,                // [IN] Size of buffer in wide chars.
        ULONG       *pchName,               // [OUT] Actual # of wide chars in name.
        ASSEMBLYMETADATA *pMetaData,        // [OUT] Assembly MetaData.
        const void  **ppbHashValue,         // [OUT] Hash blob.
        ULONG       *pcbHashValue,          // [OUT] Count of bytes in the hash blob.
        mdExecutionLocation *ptkExecutionLocation,  // [OUT] Token for Execution Location.
        DWORD       *pdwAssemblyRefFlags) PURE; // [OUT] Flags.

    STDMETHOD(GetFileProps)(                // S_OK or error.
        mdFile      mdf,                    // [IN] The File for which to get the properties.
        LPWSTR      szName,                 // [OUT] Buffer to fill with name.
        ULONG       cchName,                // [IN] Size of buffer in wide chars.
        ULONG       *pchName,               // [OUT] Actual # of wide chars in name.
        const void  **ppbHashValue,         // [OUT] Pointer to the Hash Value Blob.
        ULONG       *pcbHashValue,          // [OUT] Count of bytes in the Hash Value Blob.
        DWORD       *pdwFileFlags) PURE;    // [OUT] Flags.

    STDMETHOD(GetComTypeProps)(             // S_OK or error.
        mdComType   mdct,                   // [IN] The ComType for which to get the properties.
        LPWSTR      szName,                 // [OUT] Buffer to fill with name.
        ULONG       cchName,                // [IN] Size of buffer in wide chars.
        ULONG       *pchName,               // [OUT] Actual # of wide chars in name.
        LPWSTR      szDescription,          // [OUT] Buffer to fill with description.
        ULONG       cchDescription,         // [IN] Size of buffer in wide chars.
        ULONG       *pchDescription,        // [OUT] Actual # of wide chars in description.
        mdToken     *ptkImplementation,     // [OUT] mdFile or mdAssemblyRef or mdComType.
        mdTypeDef   *ptkTypeDef,            // [OUT] TypeDef token within the file.
        mdExecutionLocation *ptkExecutionLocation,  // [OUT] The token for Execution Location.
        DWORD       *pdwComTypeFlags) PURE; // [OUT] Flags.

    STDMETHOD(GetManifestResourceProps)(    // S_OK or error.
        mdManifestResource  mdmr,           // [IN] The ManifestResource for which to get the properties.
        LPWSTR      szName,                 // [OUT] Buffer to fill with name.
        ULONG       cchName,                // [IN] Size of buffer in wide chars.
        ULONG       *pchName,               // [OUT] Actual # of wide chars in name.
        LPWSTR      szDescription,          // [OUT] Buffer to fill with description.
        ULONG       cchDescription,         // [IN] Size of buffer in wide chars.
        ULONG       *pchDescription,        // [OUT] Actual # of wide chars in description.
        mdToken     *ptkImplementation,     // [OUT] mdFile or mdAssemblyRef that provides the ManifestResource.
        DWORD       *pdwOffset,             // [OUT] Offset to the beginning of the resource within the file.
        LPWSTR      szMIMEType,             // [OUT] Buffer to fill with MIMEType.
        ULONG       cchMIMEType,            // [IN] Size of buffer in wide chars.
        ULONG       *pchMIMEType,           // [OUT] Actual # of wide chars in name.
        LPWSTR      szLocale,               // [OUT] Buffer to fill with Locale.
        ULONG       cchLocale,              // [IN] Size of buffer in wide chars.
        ULONG       *pchLocale,             // [OUT] Actual # of wide chars in Locale.
        DWORD       *pdwResourceFlags) PURE;// [OUT] Flags.

    STDMETHOD(GetExecutionLocationProps)(   // S_OK or error.
        mdExecutionLocation mdel,           // [IN] The Execution Location for which to get the properties.
        LPWSTR      szName,                 // [OUT] Buffer to fill with name.
        ULONG       cchName,                // [IN] Size of buffer in wide chars.
        ULONG       *pchName,               // [OUT] Actual # of wide chars in name.
        LPWSTR      szDescription,          // [OUT] Buffer to fill with description.
        ULONG       cchDescription,         // [IN] Size of buffer in wide chars.
        ULONG       *pchDescription,        // [OUT] Actual # of wide chars in description.
        LPWSTR      szLocation,             // [OUT] Buffer to fill with Location.
        ULONG       cchLocation,            // [IN] Size of buffer in wide chars.
        ULONG       *pchLocation,           // [OUT] Buffer to fill with Location.
        DWORD       *pdwExecutionLocationFlags) PURE;   // [OUT] Flags.

    STDMETHOD(EnumAssemblyRefs)(            // S_OK or error
        HCORENUM    *phEnum,                // [IN|OUT] Pointer to the enum.
        mdAssemblyRef rAssemblyRefs[],      // [OUT] Put AssemblyRefs here.
        ULONG       cMax,                   // [IN] Max AssemblyRefs to put.
        ULONG       *pcTokens) PURE;        // [OUT] Put # put here.

    STDMETHOD(EnumFiles)(                   // S_OK or error
        HCORENUM    *phEnum,                // [IN|OUT] Pointer to the enum.
        mdFile      rFiles[],               // [OUT] Put Files here.
        ULONG       cMax,                   // [IN] Max Files to put.
        ULONG       *pcTokens) PURE;        // [OUT] Put # put here.

    STDMETHOD(EnumComTypes)(                // S_OK or error
        HCORENUM    *phEnum,                // [IN|OUT] Pointer to the enum.
        mdComType   rComTypes[],            // [OUT] Put ComTypes here.
        ULONG       cMax,                   // [IN] Max ComTypes to put.
        ULONG       *pcTokens) PURE;        // [OUT] Put # put here.

    STDMETHOD(EnumManifestResources)(       // S_OK or error
        HCORENUM    *phEnum,                // [IN|OUT] Pointer to the enum.
        mdManifestResource  rManifestResources[],   // [OUT] Put ManifestResources here.
        ULONG       cMax,                   // [IN] Max Resources to put.
        ULONG       *pcTokens) PURE;        // [OUT] Put # put here.

    STDMETHOD(EnumExecutionLocations)(      // S_OK or error
        HCORENUM    *phEnum,                // [IN|OUT] Pointer to the enum.
        mdExecutionLocation rExecutionLocations[],  // [OUT] Put ExecutionLocations here.
        ULONG       cMax,                   // [IN] Max ExecutionLocations to put.
        ULONG       *pcTokens) PURE;        // [OUT] Put # put here.

    STDMETHOD(GetAssemblyFromScope)(        // S_OK or error
        mdAssembly  *ptkAssembly) PURE;     // [OUT] Put token here.

    STDMETHOD(FindComTypeByName)(           // S_OK or error
        LPCWSTR     szName,                 // [IN] Name of the ComType.
        mdToken     mdtComType,             // [IN] ComType for the enclosing class.
        mdComType   *ptkComType) PURE;      // [OUT] Put the ComType token here.

    STDMETHOD(FindManifestResourceByName)(  // S_OK or error
        LPCWSTR     szName,                 // [IN] Name of the ManifestResource.
        mdManifestResource *ptkManifestResource) PURE;  // [OUT] Put the ManifestResource token here.

    STDMETHOD_(void, CloseEnum)(
        HCORENUM hEnum) PURE;               // Enum to be closed.

    STDMETHOD(FindAssembliesByName)(        // S_OK or error
        LPCWSTR  szAppBase,                 // [IN] optional - can be NULL
        LPCWSTR  szPrivateBin,              // [IN] optional - can be NULL
        LPCWSTR  szGlobalBin,               // [IN] optional - can be NULL
        LPCWSTR  szAssemblyName,            // [IN] required - this is the assembly you are requesting
        IUnknown *ppIUnk[],                 // [OUT] put IMetaDataAssemblyImport pointers here
        ULONG    cMax,                      // [IN] The max number to put
        ULONG    *pcAssemblies) PURE;       // [OUT] The number of assemblies returned.
};  // IMetaDataAssemblyImport

//*****************************************************************************
// End Assembly Declarations
//*****************************************************************************

//*****************************************************************************
// MetaData Validator Declarations
//*****************************************************************************

// Specifies the type of the module, PE file vs. .obj file.
typedef enum
{
    ValidatorModuleTypeInvalid      = 0x0,
    ValidatorModuleTypeMin          = 0x00000001,
    ValidatorModuleTypePE           = 0x00000001,
    ValidatorModuleTypeObj          = 0x00000002,
    ValidatorModuleTypeEnc          = 0x00000003,
    ValidatorModuleTypeIncr         = 0x00000004,
    ValidatorModuleTypeMax          = 0x00000004,
} CorValidatorModuleType;


// {4709C9C6-81FF-11D3-9FC7-00C04F79A0A3}
extern const GUID DECLSPEC_SELECT_ANY IID_IMetaDataValidate = 
{ 0x4709c9c6, 0x81ff, 0x11d3, { 0x9f, 0xc7, 0x0, 0xc0, 0x4f, 0x79, 0xa0, 0xa3} };

//---
#undef  INTERFACE   
#define INTERFACE IMetaDataValidate
DECLARE_INTERFACE_(IMetaDataValidate, IUnknown)
{
    STDMETHOD(ValidatorInit)(               // S_OK or error.
        DWORD       dwModuleType,           // [IN] Specifies the type of the module.
        IUnknown    *pUnk) PURE;            // [IN] Validation error handler.

    STDMETHOD(ValidateMetaData)(            // S_OK or error.
        ) PURE;
};  // IMetaDataValidate

//*****************************************************************************
// End MetaData Validator Declarations
//*****************************************************************************

//*****************************************************************************
// IMetaDataDispenserEx declarations.
//*****************************************************************************

// {31BCFCE2-DAFB-11D2-9F81-00C04F79A0A3}
extern const GUID DECLSPEC_SELECT_ANY IID_IMetaDataDispenserEx =
{ 0x31bcfce2, 0xdafb, 0x11d2, { 0x9f, 0x81, 0x0, 0xc0, 0x4f, 0x79, 0xa0, 0xa3 } };

#undef  INTERFACE
#define INTERFACE IMetaDataDispenserEx
DECLARE_INTERFACE_(IMetaDataDispenserEx, IMetaDataDispenser)
{
    STDMETHOD(SetOption)(                   // Return code.
        REFGUID     optionid,               // [in] GUID for the option to be set.
        const VARIANT *value) PURE;         // [in] Value to which the option is to be set.

    STDMETHOD(GetOption)(                   // Return code.
        REFGUID     optionid,               // [in] GUID for the option to be set.
        VARIANT *pvalue) PURE;              // [out] Value to which the option is currently set.

    STDMETHOD(OpenScopeOnITypeInfo)(        // Return code.
        ITypeInfo   *pITI,                  // [in] ITypeInfo to open.
        DWORD       dwOpenFlags,            // [in] Open mode flags.
        REFIID      riid,                   // [in] The interface desired.
        IUnknown    **ppIUnk) PURE;         // [out] Return interface on success.

    STDMETHOD(GetCORSystemDirectory)(       // Return code.
         LPWSTR      szBuffer,              // [out] Buffer for the directory name
         DWORD       cchBuffer,             // [in] Size of the buffer
         DWORD*      pchBuffer) PURE;       // [OUT] Number of characters returned

    STDMETHOD(FindAssembly)(                // S_OK or error
        LPCWSTR  szAppBase,                 // [IN] optional - can be NULL
        LPCWSTR  szPrivateBin,              // [IN] optional - can be NULL
        LPCWSTR  szGlobalBin,               // [IN] optional - can be NULL
        LPCWSTR  szAssemblyName,            // [IN] required - this is the assembly you are requesting
        LPCWSTR  szName,                    // [OUT] buffer - to hold name 
        ULONG    cchName,                   // [IN] the name buffer's size
        ULONG    *pcName) PURE;             // [OUT] the number of characters returend in the buffer

    STDMETHOD(FindAssemblyModule)(          // S_OK or error
        LPCWSTR  szAppBase,                 // [IN] optional - can be NULL
        LPCWSTR  szPrivateBin,              // [IN] optional - can be NULL
        LPCWSTR  szGlobalBin,               // [IN] optional - can be NULL
        LPCWSTR  szAssemblyName,            // [IN] required - this is the assembly you are requesting
        LPCWSTR  szModuleName,              // [IN] required - the name of the module
        LPWSTR   szName,                    // [OUT] buffer - to hold name 
        ULONG    cchName,                   // [IN]  the name buffer's size
        ULONG    *pcName) PURE;             // [OUT] the number of characters returend in the buffer

};

//*****************************************************************************
//*****************************************************************************
//
// Registration declarations.  Will be replace by Services' Registration
//  implementation. 
//
//*****************************************************************************
//*****************************************************************************
// Various flags for use in installing a module or a composite
typedef enum 
{
    regNoCopy = 0x00000001,         // Don't copy files into destination    
    regConfig = 0x00000002,         // Is a configuration   
    regHasRefs = 0x00000004         // Has class references 
} CorRegFlags;

typedef GUID CVID;

typedef struct {
    short Major;    
    short Minor;    
    short Sub;  
    short Build;    
} CVStruct;


//*****************************************************************************
//*****************************************************************************
//
// CeeGen interfaces for generating in-memory COM+ files
//
//*****************************************************************************
//*****************************************************************************

typedef void *HCEESECTION;

typedef enum  {
    sdNone =        0,
    sdReadOnly =    IMAGE_SCN_MEM_READ | IMAGE_SCN_CNT_INITIALIZED_DATA,
    sdReadWrite =   sdReadOnly | IMAGE_SCN_MEM_WRITE,
    sdExecute =     IMAGE_SCN_MEM_READ | IMAGE_SCN_CNT_CODE | IMAGE_SCN_MEM_EXECUTE
} CeeSectionAttr;

//
// Relocation types.
//

typedef enum  {
    // generate only a section-relative reloc, nothing into .reloc section
    srRelocAbsolute,
    // generate a .reloc for the top 16-bits of a 32 bit number
    srRelocHigh,
    // generate a .reloc for the bottom 16-bits of a 32 bit number
    srRelocLow,
    // generate a .reloc for a 32 bit number
    srRelocHighLow,
    // generate a .reloc for the top 16-bits of a 32 bit number, where the
    // bottom 16 bits are included in the next word in the .reloc table
    srRelocHighAdj,

    // generate a token map relocation, nothing into .reloc section 
    srRelocMapToken,

    // relative address fixup
    srRelocRelative,

    // Generate only a section-relative reloc, nothing into .reloc
    // section.  This reloc is relative to the file position of the
    // section, not the section's virtual address.
    srRelocFilePos,

    // pre-fixup contents of memory are ptr rather than a section offset
    srRelocPtr = 0x8000,
    // legal enums which include the Ptr flag
    srRelocAbsolutePtr = srRelocAbsolute + srRelocPtr,
    srRelocHighLowPtr = srRelocHighLow + srRelocPtr,
    srRelocRelativePtr = srRelocRelative + srRelocPtr,


/*
    // these are for compatibility and should not be used by new code

    // address should be added to the .reloc section
    srRelocNone = srRelocHighLow,
    // address should be not go into .reloc section
    srRelocRVA = srRelocAbsolute
*/
} CeeSectionRelocType;

typedef union  {
    USHORT highAdj;
} CeeSectionRelocExtra;

//-------------------------------------
//--- ICeeGen
//-------------------------------------
// {7ED1BDFF-8E36-11d2-9C56-00A0C9B7CC45}
extern const GUID DECLSPEC_SELECT_ANY IID_ICeeGen = 
{ 0x7ed1bdff, 0x8e36, 0x11d2, { 0x9c, 0x56, 0x0, 0xa0, 0xc9, 0xb7, 0xcc, 0x45 } };

DECLARE_INTERFACE_(ICeeGen, IUnknown)
{
    STDMETHOD (EmitString) (    
        LPWSTR lpString,                    // [IN] String to emit  
        ULONG *RVA) PURE;                   // [OUT] RVA for string emitted string  

    STDMETHOD (GetString) (     
        ULONG RVA,                          // [IN] RVA for string to return    
        LPWSTR *lpString) PURE;             // [OUT] Returned string    

    STDMETHOD (AllocateMethodBuffer) (  
        ULONG cchBuffer,                    // [IN] Length of buffer to create  
        UCHAR **lpBuffer,                   // [OUT] Returned buffer    
        ULONG *RVA) PURE;                   // [OUT] RVA for method 

    STDMETHOD (GetMethodBuffer) (   
        ULONG RVA,                          // [IN] RVA for method to return    
        UCHAR **lpBuffer) PURE;             // [OUT] Returned buffer    

    STDMETHOD (GetIMapTokenIface) (     
        IUnknown **pIMapToken) PURE;    

    STDMETHOD (GenerateCeeFile) () PURE;

    STDMETHOD (GetIlSection) (
        HCEESECTION *section) PURE; 

    STDMETHOD (GetStringSection) (
        HCEESECTION *section) PURE; 

    STDMETHOD (AddSectionReloc) (
        HCEESECTION section,    
        ULONG offset,   
        HCEESECTION relativeTo,     
        CeeSectionRelocType relocType) PURE;    

    // use these only if you have special section requirements not handled  
    // by other APIs    
    STDMETHOD (GetSectionCreate) (
        const char *name,   
        DWORD flags,    
        HCEESECTION *section) PURE; 

    STDMETHOD (GetSectionDataLen) (
        HCEESECTION section,    
        ULONG *dataLen) PURE;   

    STDMETHOD (GetSectionBlock) (
        HCEESECTION section,    
        ULONG len,  
        ULONG align=1,  
        void **ppBytes=0) PURE; 

    STDMETHOD (TruncateSection) (
        HCEESECTION section,    
        ULONG len) PURE;  

    STDMETHOD (GenerateCeeMemoryImage) (
        void **ppImage) PURE;

    STDMETHOD (ComputePointer) (   
        HCEESECTION section,    
        ULONG RVA,                          // [IN] RVA for method to return    
        UCHAR **lpBuffer) PURE;             // [OUT] Returned buffer    

};

//*****************************************************************************
//*****************************************************************************
//
// End of CeeGen declarations.
//
//*****************************************************************************

//*****************************************************************************
//*****************************************************************************
//
// CorModule interfaces for generating in-memory modules
//
//*****************************************************************************
//*****************************************************************************

typedef enum {
    CORMODULE_MATCH             =   0x00,   // find an existing module that matches interfaces supported    
    CORMODULE_NEW               =   0x01,   // always create a new module and interfaces    
} ICorModuleInitializeFlags;

//-------------------------------------
//--- ICorModule
//-------------------------------------
// {2629F8E1-95E5-11d2-9C56-00A0C9B7CC45}
extern const GUID DECLSPEC_SELECT_ANY IID_ICorModule = 
{ 0x2629f8e1, 0x95e5, 0x11d2, { 0x9c, 0x56, 0x0, 0xa0, 0xc9, 0xb7, 0xcc, 0x45 } };
DECLARE_INTERFACE_(ICorModule, IUnknown)
{
    STDMETHOD (Initialize) (    
        DWORD flags,                        // [IN] flags to control emitter returned   
        REFIID riidCeeGen,                  // [IN] type of cee generator to initialize with    
        REFIID riidEmitter) PURE;           // [IN] type of emitter to initialize with  
    
    STDMETHOD (GetCeeGen) ( 
        ICeeGen **pCeeGen) PURE;            // [OUT] cee generator  

    STDMETHOD (GetMetaDataEmit) (   
        IMetaDataEmit **pEmitter) PURE;     // [OUT] emitter    
};

//*****************************************************************************
//*****************************************************************************
//
// End of CorModule declarations.
//
//*****************************************************************************

//**********************************************************************
//**********************************************************************
//--- IMetaDataTables
//-------------------------------------
// {CE43C120-E856-11d2-8C21-00C04FF7431A}
extern const GUID DECLSPEC_SELECT_ANY IID_IMetaDataTables = 
{ 0xce43c120, 0xe856, 0x11d2, { 0x8c, 0x21, 0x0, 0xc0, 0x4f, 0xf7, 0x43, 0x1a } };

DECLARE_INTERFACE_(IMetaDataTables, IUnknown)
{
    STDMETHOD (GetStringHeapSize) (    
        ULONG   *pcbStrings) PURE;          // [OUT] Size of the string heap.

    STDMETHOD (GetBlobHeapSize) (    
        ULONG   *pcbBlobs) PURE;            // [OUT] Size of the Blob heap.

    STDMETHOD (GetGuidHeapSize) (    
        ULONG   *pcbGuids) PURE;            // [OUT] Size of the Guid heap.

    STDMETHOD (GetUserStringHeapSize) (  
        ULONG   *pcbBlobs) PURE;            // [OUT] Size of the User String heap.

    STDMETHOD (GetNumTables) (    
        ULONG   *pcTables) PURE;            // [OUT] Count of tables.

    STDMETHOD (GetTableIndex) (   
        ULONG   token,                      // [IN] Token for which to get table index.
        ULONG   *pixTbl) PURE;              // [OUT] Put table index here.

    STDMETHOD (GetTableInfo) (    
        ULONG   ixTbl,                      // [IN] Which table.
        ULONG   *pcbRow,                    // [OUT] Size of a row, bytes.
        ULONG   *pcRows,                    // [OUT] Number of rows.
        ULONG   *pcCols,                    // [OUT] Number of columns in each row.
        ULONG   *piKey,                     // [OUT] Key column, or -1 if none.
        const char **ppName) PURE;          // [OUT] Name of the table.

    STDMETHOD (GetColumnInfo) (   
        ULONG   ixTbl,                      // [IN] Which Table
        ULONG   ixCol,                      // [IN] Which Column in the table
        ULONG   *poCol,                     // [OUT] Offset of the column in the row.
        ULONG   *pcbCol,                    // [OUT] Size of a column, bytes.
        ULONG   *pType,                     // [OUT] Type of the column.
        const char **ppName) PURE;          // [OUT] Name of the Column.

    STDMETHOD (GetCodedTokenInfo) (   
        ULONG   ixCdTkn,                    // [IN] Which kind of coded token.
        ULONG   *pcTokens,                  // [OUT] Count of tokens.
        ULONG   **ppTokens,                 // [OUT] List of tokens.
        const char **ppName) PURE;          // [OUT] Name of the CodedToken.

    STDMETHOD (GetRow) (      
        ULONG   ixTbl,                      // [IN] Which table.
        ULONG   rid,                        // [IN] Which row.
        void    **ppRow) PURE;              // [OUT] Put pointer to row here.

    STDMETHOD (GetColumn) (   
        ULONG   ixTbl,                      // [IN] Which table.
        ULONG   ixCol,                      // [IN] Which column.
        ULONG   rid,                        // [IN] Which row.
        ULONG   *pVal) PURE;                // [OUT] Put the column contents here.

    STDMETHOD (GetString) (   
        ULONG   ixString,                   // [IN] Value from a string column.
        const char **ppString) PURE;        // [OUT] Put a pointer to the string here.

    STDMETHOD (GetBlob) (     
        ULONG   ixBlob,                     // [IN] Value from a blob column.
        ULONG   *pcbData,                   // [OUT] Put size of the blob here.
        const void **ppData) PURE;          // [OUT] Put a pointer to the blob here.

    STDMETHOD (GetGuid) (     
        ULONG   ixGuid,                     // [IN] Value from a guid column.
        const GUID **ppGUID) PURE;          // [OUT] Put a pointer to the GUID here.

    STDMETHOD (GetUserString) (   
        ULONG   ixUserString,               // [IN] Value from a UserString column.
        ULONG   *pcbData,                   // [OUT] Put size of the UserString here.
        const void **ppData) PURE;          // [OUT] Put a pointer to the UserString here.

};
//**********************************************************************
// End of IMetaDataTables.
//**********************************************************************
//**********************************************************************

//**********************************************************************
//
// Predefined CustomValue and structures for these custom value
//
//**********************************************************************

//
// Native Link method custom value definitions. This is for N-direct support.
//

#define COR_NATIVE_LINK_CUSTOM_VALUE        L"COMPLUS_NativeLink"   
#define COR_NATIVE_LINK_CUSTOM_VALUE_ANSI   "COMPLUS_NativeLink"    

// count of chars for COR_NATIVE_LINK_CUSTOM_VALUE(_ANSI)
#define COR_NATIVE_LINK_CUSTOM_VALUE_CC     18  

#include <pshpack1.h>
typedef struct 
{
    BYTE        m_linkType;       // see CorNativeLinkType below    
    BYTE        m_flags;          // see CorNativeLinkFlags below   
    mdMemberRef m_entryPoint;     // member ref token giving entry point, format is lib:entrypoint  
} COR_NATIVE_LINK;
#include <poppack.h>

typedef enum 
{
    nltNone     = 1,    // none of the keywords are specified   
    nltAnsi     = 2,    // ansi keyword specified   
    nltUnicode  = 3,    // unicode keyword specified    
    nltAuto     = 4,    // auto keyword specified   
    nltOle      = 5,    // ole keyword specified    
} CorNativeLinkType;

typedef enum 
{
    nlfNone         = 0x00,     // no flags 
    nlfLastError    = 0x01,     // setLastError keyword specified   
    nlfNoMangle     = 0x02,     // nomangle keyword specified
} CorNativeLinkFlags;


#define COR_DUAL_CUSTOM_VALUE L"IsDual"
#define COR_DUAL_CUSTOM_VALUE_ANSI "IsDual"

#define COR_DISPATCH_CUSTOM_VALUE L"DISPID"
#define COR_DISPATCH_CUSTOM_VALUE_ANSI "DISPID"

//
// Security custom value definitions (these are all deprecated).
//

#define COR_PERM_REQUEST_REQD_CUSTOM_VALUE L"SecPermReq_Reqd"
#define COR_PERM_REQUEST_REQD_CUSTOM_VALUE_ANSI "SecPermReq_Reqd"

#define COR_PERM_REQUEST_OPT_CUSTOM_VALUE L"SecPermReq_Opt"
#define COR_PERM_REQUEST_OPT_CUSTOM_VALUE_ANSI "SecPermReq_Opt"

#define COR_PERM_REQUEST_REFUSE_CUSTOM_VALUE L"SecPermReq_Refuse"
#define COR_PERM_REQUEST_REFUSE_CUSTOM_VALUE_ANSI "SecPermReq_Refuse"

//
// Base class for security custom attributes.
//

#define COR_BASE_SECURITY_ATTRIBUTE_CLASS L"System.Security.Permissions.SecurityAttribute"
#define COR_BASE_SECURITY_ATTRIBUTE_CLASS_ANSI "System.Security.Permissions.SecurityAttribute"

//
// Name of custom attribute used to indicate that per-call security checks should
// be disabled for P/Invoke calls.
//

#define COR_SUPPRESS_UNMANAGED_CODE_CHECK_ATTRIBUTE L"System.Security.SuppressUnmanagedCodeSecurityAttribute"
#define COR_SUPPRESS_UNMANAGED_CODE_CHECK_ATTRIBUTE_ANSI "System.Security.SuppressUnmanagedCodeSecurityAttribute"

//
// Name of custom attribute tagged on module to indicate it contains
// unverifiable code.
//

#define COR_UNVER_CODE_ATTRIBUTE L"System.Security.UnverifiableCodeAttribute"
#define COR_UNVER_CODE_ATTRIBUTE_ANSI "System.Security.UnverifiableCodeAttribute"

//
// Name of custom attribute indicating that a method requires a security object
// slot on the caller's stack.
//

#define COR_REQUIRES_SECOBJ_ATTRIBUTE L"System.Security.DynamicSecurityMethodAttribute"
#define COR_REQUIRES_SECOBJ_ATTRIBUTE_ANSI "System.Security.DynamicSecurityMethodAttribute"

#define COR_COMPILERSERVICE_DISCARDABLEATTRIBUTE L"System.Runtime.CompilerServices.DiscardableAttribute"
#define COR_COMPILERSERVICE_DISCARDABLEATTRIBUTE_ASNI "System.Runtime.CompilerServices.DiscardableAttribute"


#ifdef __cplusplus
}

//*****************************************************************************
//*****************************************************************************
//
// C O M +   s i g n a t u r e   s u p p o r t  
//
//*****************************************************************************
//*****************************************************************************

#ifndef FORCEINLINE
 #if defined( UNDER_CE ) || _MSC_VER < 1200
   #define FORCEINLINE inline
 #else
   #define FORCEINLINE __forceinline
 #endif
#endif

// return true if it is a primitive type, i.e. only need to store CorElementType
FORCEINLINE int CorIsPrimitiveType(CorElementType elementtype)
{
    return (elementtype < ELEMENT_TYPE_PTR);    
}


// Return true if element type is a modifier, i.e. ELEMENT_TYPE_MODIFIER bits are 
// turned on. For now, it is checking for ELEMENT_TYPE_PTR and ELEMENT_TYPE_BYREF
// as well. This will be removed when we turn on ELEMENT_TYPE_MODIFIER bits for 
// these two enum members.
//
FORCEINLINE int CorIsModifierElementType(CorElementType elementtype)
{
    if (elementtype == ELEMENT_TYPE_PTR || elementtype == ELEMENT_TYPE_BYREF || elementtype == ELEMENT_TYPE_COPYCTOR)   
        return 1;   
    return  (elementtype & ELEMENT_TYPE_MODIFIER);  
}

// Given a compress byte (*pData), return the size of the uncompressed data.
inline ULONG CorSigUncompressedDataSize(
    PCCOR_SIGNATURE pData)
{
    if ((*pData & 0x80) == 0)
        return 1;
    else if ((*pData & 0xC0) == 0x80)
        return 2;
    else
        return 4;
}

/////////////////////////////////////////////////////////////////////////////////////////////
//
// Given a compressed integer(*pData), expand the compressed int to *pDataOut.
// Return value is the number of bytes that the integer occupies in the compressed format
// It is caller's responsibility to ensure pDataOut has at least 4 bytes to be written to.
//
// This function returns -1 if pass in with an incorrectly compressed data, such as
// (*pBytes & 0xE0) == 0XE0.
/////////////////////////////////////////////////////////////////////////////////////////////
//@future: BIGENDIAN work here.
inline ULONG CorSigUncompressBigData(
    PCCOR_SIGNATURE &pData)             // [IN,OUT] compressed data 
{
    ULONG res;  

    // 1 byte data is handled in CorSigUncompressData   
//  _ASSERTE(*pData & 0x80);    

    // Medium.  
    if ((*pData & 0xC0) == 0x80)  // 10?? ????  
    {   
        res = 0;    
        ((BYTE *) &res)[1] = *pData++ & 0x3f;   
        ((BYTE *) &res)[0] = *pData++;  
    }   
    else // 110? ???? @todo: Should this be 11?? ????   
    {   
        ((BYTE *) &res)[3] = *pData++ & 0x1f;   
        ((BYTE *) &res)[2] = *pData++;  
        ((BYTE *) &res)[1] = *pData++;  
        ((BYTE *) &res)[0] = *pData++;  
    }   
    return res; 
}
FORCEINLINE ULONG CorSigUncompressData(
    PCCOR_SIGNATURE &pData)             // [IN,OUT] compressed data 
{
    // Handle smallest data inline. 
    if ((*pData & 0x80) == 0x00)        // 0??? ????    
        return *pData++;    
    return CorSigUncompressBigData(pData);  
}
//@todo: remove this
inline ULONG CorSigUncompressData(      // return number of bytes of that compressed data occupied in pData 
    PCCOR_SIGNATURE pData,              // [IN] compressed data 
    ULONG       *pDataOut)              // [OUT] the expanded *pData    
{   
    ULONG       cb = -1;    
    BYTE const  *pBytes = reinterpret_cast<BYTE const*>(pData); 

    // Smallest.    
    if ((*pBytes & 0x80) == 0x00)       // 0??? ????    
    {   
        *pDataOut = *pBytes;    
        cb = 1; 
    }   
    // Medium.  
    else if ((*pBytes & 0xC0) == 0x80)  // 10?? ????    
    {   
        *pDataOut = ((*pBytes & 0x3f) << 8 | *(pBytes+1));  
        cb = 2; 
    }   
    else if ((*pBytes & 0xE0) == 0xC0)      // 110? ????    
    {   
        *pDataOut = ((*pBytes & 0x1f) << 24 | *(pBytes+1) << 16 | *(pBytes+2) << 8 | *(pBytes+3));  
        cb = 4; 
    }   
    return cb;  

}

const static mdToken g_tkCorEncodeToken[4] ={mdtTypeDef, mdtTypeRef, mdtTypeSpec, mdtBaseType};

// uncompress a token
inline mdToken CorSigUncompressToken(   // return the token.    
    PCCOR_SIGNATURE &pData)             // [IN,OUT] compressed data 
{
    mdToken     tk; 
    mdToken     tkType; 

    tk = CorSigUncompressData(pData);   
    tkType = g_tkCorEncodeToken[tk & 0x3];  
    tk = TokenFromRid(tk >> 2, tkType); 
    return tk;  
}

//@todo: remove
inline ULONG CorSigUncompressToken(     // return number of bytes of that compressed data occupied in pData 
    PCCOR_SIGNATURE pData,              // [IN] compressed data 
    mdToken     *pToken)                // [OUT] the expanded *pData    
{
    ULONG       cb; 
    mdToken     tk; 
    mdToken     tkType; 

    cb = CorSigUncompressData(pData, (ULONG *)&tk); 
    tkType = g_tkCorEncodeToken[tk & 0x3];  
    tk = TokenFromRid(tk >> 2, tkType); 
    *pToken = tk;   
    return cb;  
}

FORCEINLINE ULONG CorSigUncompressCallingConv(
    PCCOR_SIGNATURE &pData)             // [IN,OUT] compressed data 
{
    return *pData++;    
}

enum {
    SIGN_MASK_ONEBYTE  = 0xffffffc0,        // Mask the same size as the missing bits.  
    SIGN_MASK_TWOBYTE  = 0xffffe000,        // Mask the same size as the missing bits.  
    SIGN_MASK_FOURBYTE = 0xf0000000,        // Mask the same size as the missing bits.  
};

// uncompress a signed integer
inline ULONG CorSigUncompressSignedInt( // return number of bytes of that compressed data occupied in pData
    PCCOR_SIGNATURE pData,              // [IN] compressed data 
    int         *pInt)                  // [OUT] the expanded *pInt 
{
    ULONG       cb; 
    ULONG       ulSigned;   
    ULONG       iData;  

    cb = CorSigUncompressData(pData, &iData);   
    if (cb == -1) return cb;    
    ulSigned = iData & 0x1; 
    iData = iData >> 1; 
    if (ulSigned)   
    {   
        if (cb == 1)    
        {   
            iData |= SIGN_MASK_ONEBYTE; 
        }   
        else if (cb == 2)   
        {   
            iData |= SIGN_MASK_TWOBYTE; 
        }   
        else    
        {   
            iData |= SIGN_MASK_FOURBYTE;    
        }   
    }   
    *pInt = iData;  
    return cb;  
}


// uncompress encoded element type
FORCEINLINE CorElementType CorSigUncompressElementType(//Element type
    PCCOR_SIGNATURE &pData)             // [IN,OUT] compressed data 
{
    return (CorElementType)*pData++;    
}
//@todo: remove
inline ULONG CorSigUncompressElementType(// return number of bytes of that compressed data occupied in pData
    PCCOR_SIGNATURE pData,              // [IN] compressed data 
    CorElementType *pElementType)       // [OUT] the expanded *pData    
{   
    *pElementType = (CorElementType)(*pData & 0x7f);    
    return 1;   
}


/////////////////////////////////////////////////////////////////////////////////////////////
//
// Given an uncompressed unsigned integer (iLen), Store it to pDataOut in a compressed format.
// Return value is the number of bytes that the integer occupies in the compressed format.
// It is caller's responsibilityt to ensure *pDataOut has at least 4 bytes to write to.
//
// Note that this function returns -1 if iLen is too big to be compressed. We currently can
// only represent to 0x1FFFFFFF.
//
/////////////////////////////////////////////////////////////////////////////////////////////
inline ULONG CorSigCompressData(        // return number of bytes that compressed form of iLen will take    
    ULONG       iLen,                   // [IN] given uncompressed data 
    void        *pDataOut)              // [OUT] buffer where iLen will be compressed and stored.   
{   
    BYTE        *pBytes = reinterpret_cast<BYTE *>(pDataOut);   

    if (iLen <= 0x7F)   
    {   
        *pBytes = BYTE(iLen);    
        return 1;   
    }   

    if (iLen <= 0x3FFF) 
    {   
        *pBytes     = BYTE((iLen >> 8) | 0x80);   
        *(pBytes+1) = BYTE(iLen);  
        return 2;   
    }   

    if (iLen <= 0x1FFFFFFF) 
    {   
        *pBytes     = BYTE((iLen >> 24) | 0xC0);  
        *(pBytes+1) = BYTE(iLen >> 16);  
        *(pBytes+2) = BYTE(iLen >> 8);  
        *(pBytes+3) = BYTE(iLen);  
        return 4;   
    }   
    return -1;  

}

// compress a token
// The least significant bit of the first compress byte will indicate the token type.
//
inline ULONG CorSigCompressToken(       // return number of bytes that compressed form of iLen will take    
    mdToken     tk,                     // [IN] given token 
    void        *pDataOut)              // [OUT] buffer where iLen will be compressed and stored.   
{
    RID         rid = RidFromToken(tk); 
    ULONG32     ulTyp = TypeFromToken(tk);  

    if (rid > 0x3FFFFFF)    
        // token is too big to be compressed    
        return -1;  

    rid = (rid << 2);   

    // TypeDef is encoded with low bits 00  
    // TypeRef is encoded with low bits 01  
    // TypeSpec is encoded with low bits 10    
    // BaseType is encoded with low bit 11
    //
    if (ulTyp == g_tkCorEncodeToken[1]) 
    {   
        // make the last two bits 01    
        rid |= 0x1; 
    }   
    else if (ulTyp == g_tkCorEncodeToken[2])    
    {   
        // make last two bits 0 
        rid |= 0x2; 
    }   
    else if (ulTyp == g_tkCorEncodeToken[3])
    {
        rid |= 0x3;
    }
    return CorSigCompressData((ULONG)rid, pDataOut);   
}

// compress a signed integer
// The least significant bit of the first compress byte will be the signed bit.
//
inline ULONG CorSigCompressSignedInt(   // return number of bytes that compressed form of iData will take   
    int         iData,                  // [IN] given integer   
    void        *pDataOut)              // [OUT] buffer where iLen will be compressed and stored.   
{
    ULONG       isSigned = 0;   

    if (iData < 0)  
        isSigned = 0x1; 

    if ((iData & SIGN_MASK_ONEBYTE) == 0 || (iData & SIGN_MASK_ONEBYTE) == SIGN_MASK_ONEBYTE)   
    {   
        iData &= ~SIGN_MASK_ONEBYTE;    
    }   
    else if ((iData & SIGN_MASK_TWOBYTE) == 0 || (iData & SIGN_MASK_TWOBYTE) == SIGN_MASK_TWOBYTE)  
    {   
        iData &= ~SIGN_MASK_TWOBYTE;    
    }   

    else if ((iData & SIGN_MASK_FOURBYTE) == 0 || (iData & SIGN_MASK_FOURBYTE) == SIGN_MASK_FOURBYTE)   
    {   
        iData &= ~SIGN_MASK_FOURBYTE;   
    }   
    else    
    {   
        // out of compressable range    
        return -1;  
    }   
    iData = iData << 1 | isSigned;  
    return CorSigCompressData(iData, pDataOut); 
}



// uncompress encoded element type
inline ULONG CorSigCompressElementType(// return number of bytes of that compressed data occupied in pData
    CorElementType et,                 // [OUT] the expanded *pData 
    void        *pData)                // [IN] compressed data  
{   
    BYTE        *pBytes = (BYTE *)(pData);  

    *pBytes = BYTE(et);   
    return 1;   

}

#endif  // __cplusplus

#endif // _COR_H_
// EOF =======================================================================
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\public\internal\com\inc\catalog.h ===
#pragma warning( disable: 4049 )  /* more than 64k source lines */

/* this ALWAYS GENERATED file contains the definitions for the interfaces */


 /* File created by MIDL compiler version 6.00.0347 */
/* Compiler settings for catalog.idl:
    Oicf, W1, Zp8, env=Win32 (32b run)
    protocol : dce , ms_ext, c_ext, oldnames, robust
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )


/* verify that the <rpcndr.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCNDR_H_VERSION__
#define __REQUIRED_RPCNDR_H_VERSION__ 475
#endif

#include "rpc.h"
#include "rpcndr.h"

#ifndef __RPCNDR_H_VERSION__
#error this stub requires an updated version of <rpcndr.h>
#endif // __RPCNDR_H_VERSION__

#ifndef COM_NO_WINDOWS_H
#include "windows.h"
#include "ole2.h"
#endif /*COM_NO_WINDOWS_H*/

#ifndef __catalog_h__
#define __catalog_h__

#if defined(_MSC_VER) && (_MSC_VER >= 1020)
#pragma once
#endif

/* Forward Declarations */ 

#ifndef __IComCatalog_FWD_DEFINED__
#define __IComCatalog_FWD_DEFINED__
typedef interface IComCatalog IComCatalog;
#endif 	/* __IComCatalog_FWD_DEFINED__ */


#ifndef __IComCatalog2_FWD_DEFINED__
#define __IComCatalog2_FWD_DEFINED__
typedef interface IComCatalog2 IComCatalog2;
#endif 	/* __IComCatalog2_FWD_DEFINED__ */


#ifndef __IComCatalogSCM_FWD_DEFINED__
#define __IComCatalogSCM_FWD_DEFINED__
typedef interface IComCatalogSCM IComCatalogSCM;
#endif 	/* __IComCatalogSCM_FWD_DEFINED__ */


#ifndef __IComClassInfo_FWD_DEFINED__
#define __IComClassInfo_FWD_DEFINED__
typedef interface IComClassInfo IComClassInfo;
#endif 	/* __IComClassInfo_FWD_DEFINED__ */


#ifndef __IComClassInfo2_FWD_DEFINED__
#define __IComClassInfo2_FWD_DEFINED__
typedef interface IComClassInfo2 IComClassInfo2;
#endif 	/* __IComClassInfo2_FWD_DEFINED__ */


#ifndef __IClassClassicInfo_FWD_DEFINED__
#define __IClassClassicInfo_FWD_DEFINED__
typedef interface IClassClassicInfo IClassClassicInfo;
#endif 	/* __IClassClassicInfo_FWD_DEFINED__ */


#ifndef __IComServices_FWD_DEFINED__
#define __IComServices_FWD_DEFINED__
typedef interface IComServices IComServices;
#endif 	/* __IComServices_FWD_DEFINED__ */


#ifndef __IComServices2_FWD_DEFINED__
#define __IComServices2_FWD_DEFINED__
typedef interface IComServices2 IComServices2;
#endif 	/* __IComServices2_FWD_DEFINED__ */


#ifndef __IComProcessInfo_FWD_DEFINED__
#define __IComProcessInfo_FWD_DEFINED__
typedef interface IComProcessInfo IComProcessInfo;
#endif 	/* __IComProcessInfo_FWD_DEFINED__ */


#ifndef __IComProcessInfo2_FWD_DEFINED__
#define __IComProcessInfo2_FWD_DEFINED__
typedef interface IComProcessInfo2 IComProcessInfo2;
#endif 	/* __IComProcessInfo2_FWD_DEFINED__ */


#ifndef __IResourceGates_FWD_DEFINED__
#define __IResourceGates_FWD_DEFINED__
typedef interface IResourceGates IResourceGates;
#endif 	/* __IResourceGates_FWD_DEFINED__ */


#ifndef __IProcessServerInfo_FWD_DEFINED__
#define __IProcessServerInfo_FWD_DEFINED__
typedef interface IProcessServerInfo IProcessServerInfo;
#endif 	/* __IProcessServerInfo_FWD_DEFINED__ */


#ifndef __IInterfaceInfo_FWD_DEFINED__
#define __IInterfaceInfo_FWD_DEFINED__
typedef interface IInterfaceInfo IInterfaceInfo;
#endif 	/* __IInterfaceInfo_FWD_DEFINED__ */


/* header files for imported files */
#include "activate.h"
#include "partitions.h"

#ifdef __cplusplus
extern "C"{
#endif 

void * __RPC_USER MIDL_user_allocate(size_t);
void __RPC_USER MIDL_user_free( void * ); 

#ifndef __IComCatalog_INTERFACE_DEFINED__
#define __IComCatalog_INTERFACE_DEFINED__

/* interface IComCatalog */
/* [uuid][unique][local][object] */ 


EXTERN_C const IID IID_IComCatalog;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("000001E0-0000-0000-C000-000000000046")
    IComCatalog : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetClassInfo( 
            /* [in] */ REFGUID guidConfiguredClsid,
            /* [in] */ REFIID riid,
            /* [out] */ void **ppv) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetApplicationInfo( 
            /* [in] */ REFGUID guidApplId,
            /* [in] */ REFIID riid,
            /* [out] */ void **ppv) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetProcessInfo( 
            /* [in] */ REFGUID guidProcess,
            /* [in] */ REFIID riid,
            /* [out] */ void **ppv) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetServerGroupInfo( 
            /* [in] */ REFGUID guidServerGroup,
            /* [in] */ REFIID riid,
            /* [out] */ void **ppv) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetRetQueueInfo( 
            /* [string][in] */ WCHAR *wszFormatName,
            /* [in] */ REFIID riid,
            /* [out] */ void **ppv) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetApplicationInfoForExe( 
            /* [string][in] */ WCHAR *pwszExeName,
            /* [in] */ REFIID riid,
            /* [out] */ void **ppv) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetTypeLibrary( 
            /* [in] */ REFGUID guidTypeLib,
            /* [in] */ REFIID riid,
            /* [out] */ void **ppv) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetInterfaceInfo( 
            /* [in] */ REFIID iidInterface,
            /* [in] */ REFIID riid,
            /* [out] */ void **ppv) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE FlushCache( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetClassInfoFromProgId( 
            /* [in] */ WCHAR *pwszProgID,
            /* [in] */ REFIID riid,
            /* [out] */ void **ppv) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IComCatalogVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IComCatalog * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IComCatalog * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IComCatalog * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetClassInfo )( 
            IComCatalog * This,
            /* [in] */ REFGUID guidConfiguredClsid,
            /* [in] */ REFIID riid,
            /* [out] */ void **ppv);
        
        HRESULT ( STDMETHODCALLTYPE *GetApplicationInfo )( 
            IComCatalog * This,
            /* [in] */ REFGUID guidApplId,
            /* [in] */ REFIID riid,
            /* [out] */ void **ppv);
        
        HRESULT ( STDMETHODCALLTYPE *GetProcessInfo )( 
            IComCatalog * This,
            /* [in] */ REFGUID guidProcess,
            /* [in] */ REFIID riid,
            /* [out] */ void **ppv);
        
        HRESULT ( STDMETHODCALLTYPE *GetServerGroupInfo )( 
            IComCatalog * This,
            /* [in] */ REFGUID guidServerGroup,
            /* [in] */ REFIID riid,
            /* [out] */ void **ppv);
        
        HRESULT ( STDMETHODCALLTYPE *GetRetQueueInfo )( 
            IComCatalog * This,
            /* [string][in] */ WCHAR *wszFormatName,
            /* [in] */ REFIID riid,
            /* [out] */ void **ppv);
        
        HRESULT ( STDMETHODCALLTYPE *GetApplicationInfoForExe )( 
            IComCatalog * This,
            /* [string][in] */ WCHAR *pwszExeName,
            /* [in] */ REFIID riid,
            /* [out] */ void **ppv);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeLibrary )( 
            IComCatalog * This,
            /* [in] */ REFGUID guidTypeLib,
            /* [in] */ REFIID riid,
            /* [out] */ void **ppv);
        
        HRESULT ( STDMETHODCALLTYPE *GetInterfaceInfo )( 
            IComCatalog * This,
            /* [in] */ REFIID iidInterface,
            /* [in] */ REFIID riid,
            /* [out] */ void **ppv);
        
        HRESULT ( STDMETHODCALLTYPE *FlushCache )( 
            IComCatalog * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetClassInfoFromProgId )( 
            IComCatalog * This,
            /* [in] */ WCHAR *pwszProgID,
            /* [in] */ REFIID riid,
            /* [out] */ void **ppv);
        
        END_INTERFACE
    } IComCatalogVtbl;

    interface IComCatalog
    {
        CONST_VTBL struct IComCatalogVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IComCatalog_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IComCatalog_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IComCatalog_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IComCatalog_GetClassInfo(This,guidConfiguredClsid,riid,ppv)	\
    (This)->lpVtbl -> GetClassInfo(This,guidConfiguredClsid,riid,ppv)

#define IComCatalog_GetApplicationInfo(This,guidApplId,riid,ppv)	\
    (This)->lpVtbl -> GetApplicationInfo(This,guidApplId,riid,ppv)

#define IComCatalog_GetProcessInfo(This,guidProcess,riid,ppv)	\
    (This)->lpVtbl -> GetProcessInfo(This,guidProcess,riid,ppv)

#define IComCatalog_GetServerGroupInfo(This,guidServerGroup,riid,ppv)	\
    (This)->lpVtbl -> GetServerGroupInfo(This,guidServerGroup,riid,ppv)

#define IComCatalog_GetRetQueueInfo(This,wszFormatName,riid,ppv)	\
    (This)->lpVtbl -> GetRetQueueInfo(This,wszFormatName,riid,ppv)

#define IComCatalog_GetApplicationInfoForExe(This,pwszExeName,riid,ppv)	\
    (This)->lpVtbl -> GetApplicationInfoForExe(This,pwszExeName,riid,ppv)

#define IComCatalog_GetTypeLibrary(This,guidTypeLib,riid,ppv)	\
    (This)->lpVtbl -> GetTypeLibrary(This,guidTypeLib,riid,ppv)

#define IComCatalog_GetInterfaceInfo(This,iidInterface,riid,ppv)	\
    (This)->lpVtbl -> GetInterfaceInfo(This,iidInterface,riid,ppv)

#define IComCatalog_FlushCache(This)	\
    (This)->lpVtbl -> FlushCache(This)

#define IComCatalog_GetClassInfoFromProgId(This,pwszProgID,riid,ppv)	\
    (This)->lpVtbl -> GetClassInfoFromProgId(This,pwszProgID,riid,ppv)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IComCatalog_GetClassInfo_Proxy( 
    IComCatalog * This,
    /* [in] */ REFGUID guidConfiguredClsid,
    /* [in] */ REFIID riid,
    /* [out] */ void **ppv);


void __RPC_STUB IComCatalog_GetClassInfo_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IComCatalog_GetApplicationInfo_Proxy( 
    IComCatalog * This,
    /* [in] */ REFGUID guidApplId,
    /* [in] */ REFIID riid,
    /* [out] */ void **ppv);


void __RPC_STUB IComCatalog_GetApplicationInfo_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IComCatalog_GetProcessInfo_Proxy( 
    IComCatalog * This,
    /* [in] */ REFGUID guidProcess,
    /* [in] */ REFIID riid,
    /* [out] */ void **ppv);


void __RPC_STUB IComCatalog_GetProcessInfo_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IComCatalog_GetServerGroupInfo_Proxy( 
    IComCatalog * This,
    /* [in] */ REFGUID guidServerGroup,
    /* [in] */ REFIID riid,
    /* [out] */ void **ppv);


void __RPC_STUB IComCatalog_GetServerGroupInfo_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IComCatalog_GetRetQueueInfo_Proxy( 
    IComCatalog * This,
    /* [string][in] */ WCHAR *wszFormatName,
    /* [in] */ REFIID riid,
    /* [out] */ void **ppv);


void __RPC_STUB IComCatalog_GetRetQueueInfo_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IComCatalog_GetApplicationInfoForExe_Proxy( 
    IComCatalog * This,
    /* [string][in] */ WCHAR *pwszExeName,
    /* [in] */ REFIID riid,
    /* [out] */ void **ppv);


void __RPC_STUB IComCatalog_GetApplicationInfoForExe_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IComCatalog_GetTypeLibrary_Proxy( 
    IComCatalog * This,
    /* [in] */ REFGUID guidTypeLib,
    /* [in] */ REFIID riid,
    /* [out] */ void **ppv);


void __RPC_STUB IComCatalog_GetTypeLibrary_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IComCatalog_GetInterfaceInfo_Proxy( 
    IComCatalog * This,
    /* [in] */ REFIID iidInterface,
    /* [in] */ REFIID riid,
    /* [out] */ void **ppv);


void __RPC_STUB IComCatalog_GetInterfaceInfo_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IComCatalog_FlushCache_Proxy( 
    IComCatalog * This);


void __RPC_STUB IComCatalog_FlushCache_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IComCatalog_GetClassInfoFromProgId_Proxy( 
    IComCatalog * This,
    /* [in] */ WCHAR *pwszProgID,
    /* [in] */ REFIID riid,
    /* [out] */ void **ppv);


void __RPC_STUB IComCatalog_GetClassInfoFromProgId_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IComCatalog_INTERFACE_DEFINED__ */


#ifndef __IComCatalog2_INTERFACE_DEFINED__
#define __IComCatalog2_INTERFACE_DEFINED__

/* interface IComCatalog2 */
/* [uuid][unique][local][object] */ 


EXTERN_C const IID IID_IComCatalog2;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("000001FA-0000-0000-C000-000000000046")
    IComCatalog2 : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetClassInfoByPartition( 
            /* [in] */ REFGUID guidConfiguredClsid,
            /* [in] */ REFGUID guidPartitionId,
            /* [in] */ REFIID riid,
            /* [out] */ void **ppv) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetClassInfoByApplication( 
            /* [in] */ REFGUID guidConfiguredClsid,
            /* [in] */ REFGUID guidPartitionId,
            /* [in] */ REFGUID guidApplId,
            /* [in] */ REFIID riid,
            /* [out] */ void **ppv) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetNativeRegistryCatalog( 
            /* [in] */ REFIID riid,
            /* [out] */ void **ppv) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetNonNativeRegistryCatalog( 
            /* [in] */ REFIID riid,
            /* [out] */ void **ppv) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IComCatalog2Vtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IComCatalog2 * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IComCatalog2 * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IComCatalog2 * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetClassInfoByPartition )( 
            IComCatalog2 * This,
            /* [in] */ REFGUID guidConfiguredClsid,
            /* [in] */ REFGUID guidPartitionId,
            /* [in] */ REFIID riid,
            /* [out] */ void **ppv);
        
        HRESULT ( STDMETHODCALLTYPE *GetClassInfoByApplication )( 
            IComCatalog2 * This,
            /* [in] */ REFGUID guidConfiguredClsid,
            /* [in] */ REFGUID guidPartitionId,
            /* [in] */ REFGUID guidApplId,
            /* [in] */ REFIID riid,
            /* [out] */ void **ppv);
        
        HRESULT ( STDMETHODCALLTYPE *GetNativeRegistryCatalog )( 
            IComCatalog2 * This,
            /* [in] */ REFIID riid,
            /* [out] */ void **ppv);
        
        HRESULT ( STDMETHODCALLTYPE *GetNonNativeRegistryCatalog )( 
            IComCatalog2 * This,
            /* [in] */ REFIID riid,
            /* [out] */ void **ppv);
        
        END_INTERFACE
    } IComCatalog2Vtbl;

    interface IComCatalog2
    {
        CONST_VTBL struct IComCatalog2Vtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IComCatalog2_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IComCatalog2_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IComCatalog2_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IComCatalog2_GetClassInfoByPartition(This,guidConfiguredClsid,guidPartitionId,riid,ppv)	\
    (This)->lpVtbl -> GetClassInfoByPartition(This,guidConfiguredClsid,guidPartitionId,riid,ppv)

#define IComCatalog2_GetClassInfoByApplication(This,guidConfiguredClsid,guidPartitionId,guidApplId,riid,ppv)	\
    (This)->lpVtbl -> GetClassInfoByApplication(This,guidConfiguredClsid,guidPartitionId,guidApplId,riid,ppv)

#define IComCatalog2_GetNativeRegistryCatalog(This,riid,ppv)	\
    (This)->lpVtbl -> GetNativeRegistryCatalog(This,riid,ppv)

#define IComCatalog2_GetNonNativeRegistryCatalog(This,riid,ppv)	\
    (This)->lpVtbl -> GetNonNativeRegistryCatalog(This,riid,ppv)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IComCatalog2_GetClassInfoByPartition_Proxy( 
    IComCatalog2 * This,
    /* [in] */ REFGUID guidConfiguredClsid,
    /* [in] */ REFGUID guidPartitionId,
    /* [in] */ REFIID riid,
    /* [out] */ void **ppv);


void __RPC_STUB IComCatalog2_GetClassInfoByPartition_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IComCatalog2_GetClassInfoByApplication_Proxy( 
    IComCatalog2 * This,
    /* [in] */ REFGUID guidConfiguredClsid,
    /* [in] */ REFGUID guidPartitionId,
    /* [in] */ REFGUID guidApplId,
    /* [in] */ REFIID riid,
    /* [out] */ void **ppv);


void __RPC_STUB IComCatalog2_GetClassInfoByApplication_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IComCatalog2_GetNativeRegistryCatalog_Proxy( 
    IComCatalog2 * This,
    /* [in] */ REFIID riid,
    /* [out] */ void **ppv);


void __RPC_STUB IComCatalog2_GetNativeRegistryCatalog_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IComCatalog2_GetNonNativeRegistryCatalog_Proxy( 
    IComCatalog2 * This,
    /* [in] */ REFIID riid,
    /* [out] */ void **ppv);


void __RPC_STUB IComCatalog2_GetNonNativeRegistryCatalog_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IComCatalog2_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_catalog_0141 */
/* [local] */ 

/* These constants are used in the SCM catalog interfaces */
#define CAT_REG64_ONLY  (0x10000000)
#define CAT_REG32_ONLY  (0x20000000)
#define CAT_REG_MASK    (0x30000000)


extern RPC_IF_HANDLE __MIDL_itf_catalog_0141_ClientIfHandle;
extern RPC_IF_HANDLE __MIDL_itf_catalog_0141_ServerIfHandle;

#ifndef __IComCatalogSCM_INTERFACE_DEFINED__
#define __IComCatalogSCM_INTERFACE_DEFINED__

/* interface IComCatalogSCM */
/* [uuid][unique][local][object] */ 


EXTERN_C const IID IID_IComCatalogSCM;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("000001FD-0000-0000-C000-000000000046")
    IComCatalogSCM : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetClassInfo( 
            /* [in] */ DWORD flags,
            /* [in] */ IUserToken *pToken,
            /* [in] */ REFGUID guidConfiguredClsid,
            /* [in] */ REFIID riid,
            /* [out] */ void **ppv) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetApplicationInfo( 
            /* [in] */ IUserToken *pToken,
            /* [in] */ REFGUID guidApplId,
            /* [in] */ REFIID riid,
            /* [out] */ void **ppv) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetProcessInfo( 
            /* [in] */ DWORD flags,
            /* [in] */ IUserToken *pToken,
            /* [in] */ REFGUID guidProcess,
            /* [in] */ REFIID riid,
            /* [out] */ void **ppv) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetServerGroupInfo( 
            /* [in] */ IUserToken *pToken,
            /* [in] */ REFGUID guidServerGroup,
            /* [in] */ REFIID riid,
            /* [out] */ void **ppv) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetRetQueueInfo( 
            /* [in] */ IUserToken *pToken,
            /* [string][in] */ WCHAR *wszFormatName,
            /* [in] */ REFIID riid,
            /* [out] */ void **ppv) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetApplicationInfoForExe( 
            /* [in] */ IUserToken *pToken,
            /* [string][in] */ WCHAR *pwszExeName,
            /* [in] */ REFIID riid,
            /* [out] */ void **ppv) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetTypeLibrary( 
            /* [in] */ IUserToken *pToken,
            /* [in] */ REFGUID guidTypeLib,
            /* [in] */ REFIID riid,
            /* [out] */ void **ppv) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetInterfaceInfo( 
            /* [in] */ IUserToken *pToken,
            /* [in] */ REFIID iidInterface,
            /* [in] */ REFIID riid,
            /* [out] */ void **ppv) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE FlushCache( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetClassInfoFromProgId( 
            /* [in] */ IUserToken *pToken,
            /* [in] */ WCHAR *pwszProgID,
            /* [in] */ REFIID riid,
            /* [out] */ void **ppv) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE FlushIdleEntries( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IComCatalogSCMVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IComCatalogSCM * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IComCatalogSCM * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IComCatalogSCM * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetClassInfo )( 
            IComCatalogSCM * This,
            /* [in] */ DWORD flags,
            /* [in] */ IUserToken *pToken,
            /* [in] */ REFGUID guidConfiguredClsid,
            /* [in] */ REFIID riid,
            /* [out] */ void **ppv);
        
        HRESULT ( STDMETHODCALLTYPE *GetApplicationInfo )( 
            IComCatalogSCM * This,
            /* [in] */ IUserToken *pToken,
            /* [in] */ REFGUID guidApplId,
            /* [in] */ REFIID riid,
            /* [out] */ void **ppv);
        
        HRESULT ( STDMETHODCALLTYPE *GetProcessInfo )( 
            IComCatalogSCM * This,
            /* [in] */ DWORD flags,
            /* [in] */ IUserToken *pToken,
            /* [in] */ REFGUID guidProcess,
            /* [in] */ REFIID riid,
            /* [out] */ void **ppv);
        
        HRESULT ( STDMETHODCALLTYPE *GetServerGroupInfo )( 
            IComCatalogSCM * This,
            /* [in] */ IUserToken *pToken,
            /* [in] */ REFGUID guidServerGroup,
            /* [in] */ REFIID riid,
            /* [out] */ void **ppv);
        
        HRESULT ( STDMETHODCALLTYPE *GetRetQueueInfo )( 
            IComCatalogSCM * This,
            /* [in] */ IUserToken *pToken,
            /* [string][in] */ WCHAR *wszFormatName,
            /* [in] */ REFIID riid,
            /* [out] */ void **ppv);
        
        HRESULT ( STDMETHODCALLTYPE *GetApplicationInfoForExe )( 
            IComCatalogSCM * This,
            /* [in] */ IUserToken *pToken,
            /* [string][in] */ WCHAR *pwszExeName,
            /* [in] */ REFIID riid,
            /* [out] */ void **ppv);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeLibrary )( 
            IComCatalogSCM * This,
            /* [in] */ IUserToken *pToken,
            /* [in] */ REFGUID guidTypeLib,
            /* [in] */ REFIID riid,
            /* [out] */ void **ppv);
        
        HRESULT ( STDMETHODCALLTYPE *GetInterfaceInfo )( 
            IComCatalogSCM * This,
            /* [in] */ IUserToken *pToken,
            /* [in] */ REFIID iidInterface,
            /* [in] */ REFIID riid,
            /* [out] */ void **ppv);
        
        HRESULT ( STDMETHODCALLTYPE *FlushCache )( 
            IComCatalogSCM * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetClassInfoFromProgId )( 
            IComCatalogSCM * This,
            /* [in] */ IUserToken *pToken,
            /* [in] */ WCHAR *pwszProgID,
            /* [in] */ REFIID riid,
            /* [out] */ void **ppv);
        
        HRESULT ( STDMETHODCALLTYPE *FlushIdleEntries )( 
            IComCatalogSCM * This);
        
        END_INTERFACE
    } IComCatalogSCMVtbl;

    interface IComCatalogSCM
    {
        CONST_VTBL struct IComCatalogSCMVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IComCatalogSCM_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IComCatalogSCM_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IComCatalogSCM_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IComCatalogSCM_GetClassInfo(This,flags,pToken,guidConfiguredClsid,riid,ppv)	\
    (This)->lpVtbl -> GetClassInfo(This,flags,pToken,guidConfiguredClsid,riid,ppv)

#define IComCatalogSCM_GetApplicationInfo(This,pToken,guidApplId,riid,ppv)	\
    (This)->lpVtbl -> GetApplicationInfo(This,pToken,guidApplId,riid,ppv)

#define IComCatalogSCM_GetProcessInfo(This,flags,pToken,guidProcess,riid,ppv)	\
    (This)->lpVtbl -> GetProcessInfo(This,flags,pToken,guidProcess,riid,ppv)

#define IComCatalogSCM_GetServerGroupInfo(This,pToken,guidServerGroup,riid,ppv)	\
    (This)->lpVtbl -> GetServerGroupInfo(This,pToken,guidServerGroup,riid,ppv)

#define IComCatalogSCM_GetRetQueueInfo(This,pToken,wszFormatName,riid,ppv)	\
    (This)->lpVtbl -> GetRetQueueInfo(This,pToken,wszFormatName,riid,ppv)

#define IComCatalogSCM_GetApplicationInfoForExe(This,pToken,pwszExeName,riid,ppv)	\
    (This)->lpVtbl -> GetApplicationInfoForExe(This,pToken,pwszExeName,riid,ppv)

#define IComCatalogSCM_GetTypeLibrary(This,pToken,guidTypeLib,riid,ppv)	\
    (This)->lpVtbl -> GetTypeLibrary(This,pToken,guidTypeLib,riid,ppv)

#define IComCatalogSCM_GetInterfaceInfo(This,pToken,iidInterface,riid,ppv)	\
    (This)->lpVtbl -> GetInterfaceInfo(This,pToken,iidInterface,riid,ppv)

#define IComCatalogSCM_FlushCache(This)	\
    (This)->lpVtbl -> FlushCache(This)

#define IComCatalogSCM_GetClassInfoFromProgId(This,pToken,pwszProgID,riid,ppv)	\
    (This)->lpVtbl -> GetClassInfoFromProgId(This,pToken,pwszProgID,riid,ppv)

#define IComCatalogSCM_FlushIdleEntries(This)	\
    (This)->lpVtbl -> FlushIdleEntries(This)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IComCatalogSCM_GetClassInfo_Proxy( 
    IComCatalogSCM * This,
    /* [in] */ DWORD flags,
    /* [in] */ IUserToken *pToken,
    /* [in] */ REFGUID guidConfiguredClsid,
    /* [in] */ REFIID riid,
    /* [out] */ void **ppv);


void __RPC_STUB IComCatalogSCM_GetClassInfo_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IComCatalogSCM_GetApplicationInfo_Proxy( 
    IComCatalogSCM * This,
    /* [in] */ IUserToken *pToken,
    /* [in] */ REFGUID guidApplId,
    /* [in] */ REFIID riid,
    /* [out] */ void **ppv);


void __RPC_STUB IComCatalogSCM_GetApplicationInfo_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IComCatalogSCM_GetProcessInfo_Proxy( 
    IComCatalogSCM * This,
    /* [in] */ DWORD flags,
    /* [in] */ IUserToken *pToken,
    /* [in] */ REFGUID guidProcess,
    /* [in] */ REFIID riid,
    /* [out] */ void **ppv);


void __RPC_STUB IComCatalogSCM_GetProcessInfo_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IComCatalogSCM_GetServerGroupInfo_Proxy( 
    IComCatalogSCM * This,
    /* [in] */ IUserToken *pToken,
    /* [in] */ REFGUID guidServerGroup,
    /* [in] */ REFIID riid,
    /* [out] */ void **ppv);


void __RPC_STUB IComCatalogSCM_GetServerGroupInfo_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IComCatalogSCM_GetRetQueueInfo_Proxy( 
    IComCatalogSCM * This,
    /* [in] */ IUserToken *pToken,
    /* [string][in] */ WCHAR *wszFormatName,
    /* [in] */ REFIID riid,
    /* [out] */ void **ppv);


void __RPC_STUB IComCatalogSCM_GetRetQueueInfo_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IComCatalogSCM_GetApplicationInfoForExe_Proxy( 
    IComCatalogSCM * This,
    /* [in] */ IUserToken *pToken,
    /* [string][in] */ WCHAR *pwszExeName,
    /* [in] */ REFIID riid,
    /* [out] */ void **ppv);


void __RPC_STUB IComCatalogSCM_GetApplicationInfoForExe_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IComCatalogSCM_GetTypeLibrary_Proxy( 
    IComCatalogSCM * This,
    /* [in] */ IUserToken *pToken,
    /* [in] */ REFGUID guidTypeLib,
    /* [in] */ REFIID riid,
    /* [out] */ void **ppv);


void __RPC_STUB IComCatalogSCM_GetTypeLibrary_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IComCatalogSCM_GetInterfaceInfo_Proxy( 
    IComCatalogSCM * This,
    /* [in] */ IUserToken *pToken,
    /* [in] */ REFIID iidInterface,
    /* [in] */ REFIID riid,
    /* [out] */ void **ppv);


void __RPC_STUB IComCatalogSCM_GetInterfaceInfo_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IComCatalogSCM_FlushCache_Proxy( 
    IComCatalogSCM * This);


void __RPC_STUB IComCatalogSCM_FlushCache_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IComCatalogSCM_GetClassInfoFromProgId_Proxy( 
    IComCatalogSCM * This,
    /* [in] */ IUserToken *pToken,
    /* [in] */ WCHAR *pwszProgID,
    /* [in] */ REFIID riid,
    /* [out] */ void **ppv);


void __RPC_STUB IComCatalogSCM_GetClassInfoFromProgId_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IComCatalogSCM_FlushIdleEntries_Proxy( 
    IComCatalogSCM * This);


void __RPC_STUB IComCatalogSCM_FlushIdleEntries_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IComCatalogSCM_INTERFACE_DEFINED__ */


#ifndef __IComClassInfo_INTERFACE_DEFINED__
#define __IComClassInfo_INTERFACE_DEFINED__

/* interface IComClassInfo */
/* [uuid][unique][local][object] */ 


EXTERN_C const IID IID_IComClassInfo;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("000001E1-0000-0000-C000-000000000046")
    IComClassInfo : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetConfiguredClsid( 
            /* [out] */ GUID **ppguidClsid) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetProgId( 
            /* [out] */ WCHAR **pwszProgid) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetClassName( 
            /* [out] */ WCHAR **pwszClassName) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetApplication( 
            /* [in] */ REFIID riid,
            /* [out] */ void **ppv) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetClassContext( 
            /* [in] */ CLSCTX clsctxFilter,
            /* [out] */ CLSCTX *pclsctx) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetCustomActivatorCount( 
            /* [in] */ ACTIVATION_STAGE activationStage,
            /* [out] */ unsigned long *pulCount) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetCustomActivatorClsids( 
            /* [in] */ ACTIVATION_STAGE activationStage,
            /* [out] */ GUID **prgguidClsid) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetCustomActivators( 
            /* [in] */ ACTIVATION_STAGE activationStage,
            /* [out] */ ISystemActivator ***prgpActivator) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetTypeInfo( 
            /* [in] */ REFIID riid,
            /* [out] */ void **ppv) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE IsComPlusConfiguredClass( 
            /* [out] */ BOOL *pfComPlusConfiguredClass) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE MustRunInClientContext( 
            /* [out] */ BOOL *pbMustRunInClientContext) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetVersionNumber( 
            /* [out] */ DWORD *pdwVersionMS,
            /* [out] */ DWORD *pdwVersionLS) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Lock( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Unlock( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IComClassInfoVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IComClassInfo * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IComClassInfo * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IComClassInfo * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetConfiguredClsid )( 
            IComClassInfo * This,
            /* [out] */ GUID **ppguidClsid);
        
        HRESULT ( STDMETHODCALLTYPE *GetProgId )( 
            IComClassInfo * This,
            /* [out] */ WCHAR **pwszProgid);
        
        HRESULT ( STDMETHODCALLTYPE *GetClassName )( 
            IComClassInfo * This,
            /* [out] */ WCHAR **pwszClassName);
        
        HRESULT ( STDMETHODCALLTYPE *GetApplication )( 
            IComClassInfo * This,
            /* [in] */ REFIID riid,
            /* [out] */ void **ppv);
        
        HRESULT ( STDMETHODCALLTYPE *GetClassContext )( 
            IComClassInfo * This,
            /* [in] */ CLSCTX clsctxFilter,
            /* [out] */ CLSCTX *pclsctx);
        
        HRESULT ( STDMETHODCALLTYPE *GetCustomActivatorCount )( 
            IComClassInfo * This,
            /* [in] */ ACTIVATION_STAGE activationStage,
            /* [out] */ unsigned long *pulCount);
        
        HRESULT ( STDMETHODCALLTYPE *GetCustomActivatorClsids )( 
            IComClassInfo * This,
            /* [in] */ ACTIVATION_STAGE activationStage,
            /* [out] */ GUID **prgguidClsid);
        
        HRESULT ( STDMETHODCALLTYPE *GetCustomActivators )( 
            IComClassInfo * This,
            /* [in] */ ACTIVATION_STAGE activationStage,
            /* [out] */ ISystemActivator ***prgpActivator);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IComClassInfo * This,
            /* [in] */ REFIID riid,
            /* [out] */ void **ppv);
        
        HRESULT ( STDMETHODCALLTYPE *IsComPlusConfiguredClass )( 
            IComClassInfo * This,
            /* [out] */ BOOL *pfComPlusConfiguredClass);
        
        HRESULT ( STDMETHODCALLTYPE *MustRunInClientContext )( 
            IComClassInfo * This,
            /* [out] */ BOOL *pbMustRunInClientContext);
        
        HRESULT ( STDMETHODCALLTYPE *GetVersionNumber )( 
            IComClassInfo * This,
            /* [out] */ DWORD *pdwVersionMS,
            /* [out] */ DWORD *pdwVersionLS);
        
        HRESULT ( STDMETHODCALLTYPE *Lock )( 
            IComClassInfo * This);
        
        HRESULT ( STDMETHODCALLTYPE *Unlock )( 
            IComClassInfo * This);
        
        END_INTERFACE
    } IComClassInfoVtbl;

    interface IComClassInfo
    {
        CONST_VTBL struct IComClassInfoVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IComClassInfo_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IComClassInfo_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IComClassInfo_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IComClassInfo_GetConfiguredClsid(This,ppguidClsid)	\
    (This)->lpVtbl -> GetConfiguredClsid(This,ppguidClsid)

#define IComClassInfo_GetProgId(This,pwszProgid)	\
    (This)->lpVtbl -> GetProgId(This,pwszProgid)

#define IComClassInfo_GetClassName(This,pwszClassName)	\
    (This)->lpVtbl -> GetClassName(This,pwszClassName)

#define IComClassInfo_GetApplication(This,riid,ppv)	\
    (This)->lpVtbl -> GetApplication(This,riid,ppv)

#define IComClassInfo_GetClassContext(This,clsctxFilter,pclsctx)	\
    (This)->lpVtbl -> GetClassContext(This,clsctxFilter,pclsctx)

#define IComClassInfo_GetCustomActivatorCount(This,activationStage,pulCount)	\
    (This)->lpVtbl -> GetCustomActivatorCount(This,activationStage,pulCount)

#define IComClassInfo_GetCustomActivatorClsids(This,activationStage,prgguidClsid)	\
    (This)->lpVtbl -> GetCustomActivatorClsids(This,activationStage,prgguidClsid)

#define IComClassInfo_GetCustomActivators(This,activationStage,prgpActivator)	\
    (This)->lpVtbl -> GetCustomActivators(This,activationStage,prgpActivator)

#define IComClassInfo_GetTypeInfo(This,riid,ppv)	\
    (This)->lpVtbl -> GetTypeInfo(This,riid,ppv)

#define IComClassInfo_IsComPlusConfiguredClass(This,pfComPlusConfiguredClass)	\
    (This)->lpVtbl -> IsComPlusConfiguredClass(This,pfComPlusConfiguredClass)

#define IComClassInfo_MustRunInClientContext(This,pbMustRunInClientContext)	\
    (This)->lpVtbl -> MustRunInClientContext(This,pbMustRunInClientContext)

#define IComClassInfo_GetVersionNumber(This,pdwVersionMS,pdwVersionLS)	\
    (This)->lpVtbl -> GetVersionNumber(This,pdwVersionMS,pdwVersionLS)

#define IComClassInfo_Lock(This)	\
    (This)->lpVtbl -> Lock(This)

#define IComClassInfo_Unlock(This)	\
    (This)->lpVtbl -> Unlock(This)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IComClassInfo_GetConfiguredClsid_Proxy( 
    IComClassInfo * This,
    /* [out] */ GUID **ppguidClsid);


void __RPC_STUB IComClassInfo_GetConfiguredClsid_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IComClassInfo_GetProgId_Proxy( 
    IComClassInfo * This,
    /* [out] */ WCHAR **pwszProgid);


void __RPC_STUB IComClassInfo_GetProgId_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IComClassInfo_GetClassName_Proxy( 
    IComClassInfo * This,
    /* [out] */ WCHAR **pwszClassName);


void __RPC_STUB IComClassInfo_GetClassName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IComClassInfo_GetApplication_Proxy( 
    IComClassInfo * This,
    /* [in] */ REFIID riid,
    /* [out] */ void **ppv);


void __RPC_STUB IComClassInfo_GetApplication_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IComClassInfo_GetClassContext_Proxy( 
    IComClassInfo * This,
    /* [in] */ CLSCTX clsctxFilter,
    /* [out] */ CLSCTX *pclsctx);


void __RPC_STUB IComClassInfo_GetClassContext_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IComClassInfo_GetCustomActivatorCount_Proxy( 
    IComClassInfo * This,
    /* [in] */ ACTIVATION_STAGE activationStage,
    /* [out] */ unsigned long *pulCount);


void __RPC_STUB IComClassInfo_GetCustomActivatorCount_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IComClassInfo_GetCustomActivatorClsids_Proxy( 
    IComClassInfo * This,
    /* [in] */ ACTIVATION_STAGE activationStage,
    /* [out] */ GUID **prgguidClsid);


void __RPC_STUB IComClassInfo_GetCustomActivatorClsids_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IComClassInfo_GetCustomActivators_Proxy( 
    IComClassInfo * This,
    /* [in] */ ACTIVATION_STAGE activationStage,
    /* [out] */ ISystemActivator ***prgpActivator);


void __RPC_STUB IComClassInfo_GetCustomActivators_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IComClassInfo_GetTypeInfo_Proxy( 
    IComClassInfo * This,
    /* [in] */ REFIID riid,
    /* [out] */ void **ppv);


void __RPC_STUB IComClassInfo_GetTypeInfo_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IComClassInfo_IsComPlusConfiguredClass_Proxy( 
    IComClassInfo * This,
    /* [out] */ BOOL *pfComPlusConfiguredClass);


void __RPC_STUB IComClassInfo_IsComPlusConfiguredClass_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IComClassInfo_MustRunInClientContext_Proxy( 
    IComClassInfo * This,
    /* [out] */ BOOL *pbMustRunInClientContext);


void __RPC_STUB IComClassInfo_MustRunInClientContext_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IComClassInfo_GetVersionNumber_Proxy( 
    IComClassInfo * This,
    /* [out] */ DWORD *pdwVersionMS,
    /* [out] */ DWORD *pdwVersionLS);


void __RPC_STUB IComClassInfo_GetVersionNumber_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IComClassInfo_Lock_Proxy( 
    IComClassInfo * This);


void __RPC_STUB IComClassInfo_Lock_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IComClassInfo_Unlock_Proxy( 
    IComClassInfo * This);


void __RPC_STUB IComClassInfo_Unlock_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IComClassInfo_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_catalog_0143 */
/* [local] */ 

typedef struct tagSOAP_ACTIVATION_INFO
    {
    BOOL bSoapActivated;
    LONG lMode;
    BSTR bstrVRoot;
    BSTR bstrMailTo;
    BSTR bstrAssemblyName;
    BSTR bstrTypeName;
    BSTR bstrBaseUrl;
    } 	SOAP_ACTIVATION_INFO;



extern RPC_IF_HANDLE __MIDL_itf_catalog_0143_ClientIfHandle;
extern RPC_IF_HANDLE __MIDL_itf_catalog_0143_ServerIfHandle;

#ifndef __IComClassInfo2_INTERFACE_DEFINED__
#define __IComClassInfo2_INTERFACE_DEFINED__

/* interface IComClassInfo2 */
/* [uuid][unique][local][object] */ 


EXTERN_C const IID IID_IComClassInfo2;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("000001E4-0000-0000-C000-000000000046")
    IComClassInfo2 : public IComClassInfo
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE IsEnabled( 
            /* [out] */ BOOL *bEnabled) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetInternalClsid( 
            /* [out] */ GUID **ppguidInternalClsid) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetApplicationPartitionId( 
            /* [out] */ GUID **ppguidAppPartitionId) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE MustRunInDefaultContext( 
            /* [out] */ BOOL *pbMustRunInDefaultContext) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE IsPrivateComponent( 
            /* [out] */ BOOL *pbIsPrivateComponent) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE VBDebugInProgress( 
            /* [out] */ BOOL *pbVBDebugInProgress) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetSoapInfo( 
            /* [out] */ SOAP_ACTIVATION_INFO *psoapActInfo) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IComClassInfo2Vtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IComClassInfo2 * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IComClassInfo2 * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IComClassInfo2 * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetConfiguredClsid )( 
            IComClassInfo2 * This,
            /* [out] */ GUID **ppguidClsid);
        
        HRESULT ( STDMETHODCALLTYPE *GetProgId )( 
            IComClassInfo2 * This,
            /* [out] */ WCHAR **pwszProgid);
        
        HRESULT ( STDMETHODCALLTYPE *GetClassName )( 
            IComClassInfo2 * This,
            /* [out] */ WCHAR **pwszClassName);
        
        HRESULT ( STDMETHODCALLTYPE *GetApplication )( 
            IComClassInfo2 * This,
            /* [in] */ REFIID riid,
            /* [out] */ void **ppv);
        
        HRESULT ( STDMETHODCALLTYPE *GetClassContext )( 
            IComClassInfo2 * This,
            /* [in] */ CLSCTX clsctxFilter,
            /* [out] */ CLSCTX *pclsctx);
        
        HRESULT ( STDMETHODCALLTYPE *GetCustomActivatorCount )( 
            IComClassInfo2 * This,
            /* [in] */ ACTIVATION_STAGE activationStage,
            /* [out] */ unsigned long *pulCount);
        
        HRESULT ( STDMETHODCALLTYPE *GetCustomActivatorClsids )( 
            IComClassInfo2 * This,
            /* [in] */ ACTIVATION_STAGE activationStage,
            /* [out] */ GUID **prgguidClsid);
        
        HRESULT ( STDMETHODCALLTYPE *GetCustomActivators )( 
            IComClassInfo2 * This,
            /* [in] */ ACTIVATION_STAGE activationStage,
            /* [out] */ ISystemActivator ***prgpActivator);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IComClassInfo2 * This,
            /* [in] */ REFIID riid,
            /* [out] */ void **ppv);
        
        HRESULT ( STDMETHODCALLTYPE *IsComPlusConfiguredClass )( 
            IComClassInfo2 * This,
            /* [out] */ BOOL *pfComPlusConfiguredClass);
        
        HRESULT ( STDMETHODCALLTYPE *MustRunInClientContext )( 
            IComClassInfo2 * This,
            /* [out] */ BOOL *pbMustRunInClientContext);
        
        HRESULT ( STDMETHODCALLTYPE *GetVersionNumber )( 
            IComClassInfo2 * This,
            /* [out] */ DWORD *pdwVersionMS,
            /* [out] */ DWORD *pdwVersionLS);
        
        HRESULT ( STDMETHODCALLTYPE *Lock )( 
            IComClassInfo2 * This);
        
        HRESULT ( STDMETHODCALLTYPE *Unlock )( 
            IComClassInfo2 * This);
        
        HRESULT ( STDMETHODCALLTYPE *IsEnabled )( 
            IComClassInfo2 * This,
            /* [out] */ BOOL *bEnabled);
        
        HRESULT ( STDMETHODCALLTYPE *GetInternalClsid )( 
            IComClassInfo2 * This,
            /* [out] */ GUID **ppguidInternalClsid);
        
        HRESULT ( STDMETHODCALLTYPE *GetApplicationPartitionId )( 
            IComClassInfo2 * This,
            /* [out] */ GUID **ppguidAppPartitionId);
        
        HRESULT ( STDMETHODCALLTYPE *MustRunInDefaultContext )( 
            IComClassInfo2 * This,
            /* [out] */ BOOL *pbMustRunInDefaultContext);
        
        HRESULT ( STDMETHODCALLTYPE *IsPrivateComponent )( 
            IComClassInfo2 * This,
            /* [out] */ BOOL *pbIsPrivateComponent);
        
        HRESULT ( STDMETHODCALLTYPE *VBDebugInProgress )( 
            IComClassInfo2 * This,
            /* [out] */ BOOL *pbVBDebugInProgress);
        
        HRESULT ( STDMETHODCALLTYPE *GetSoapInfo )( 
            IComClassInfo2 * This,
            /* [out] */ SOAP_ACTIVATION_INFO *psoapActInfo);
        
        END_INTERFACE
    } IComClassInfo2Vtbl;

    interface IComClassInfo2
    {
        CONST_VTBL struct IComClassInfo2Vtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IComClassInfo2_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IComClassInfo2_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IComClassInfo2_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IComClassInfo2_GetConfiguredClsid(This,ppguidClsid)	\
    (This)->lpVtbl -> GetConfiguredClsid(This,ppguidClsid)

#define IComClassInfo2_GetProgId(This,pwszProgid)	\
    (This)->lpVtbl -> GetProgId(This,pwszProgid)

#define IComClassInfo2_GetClassName(This,pwszClassName)	\
    (This)->lpVtbl -> GetClassName(This,pwszClassName)

#define IComClassInfo2_GetApplication(This,riid,ppv)	\
    (This)->lpVtbl -> GetApplication(This,riid,ppv)

#define IComClassInfo2_GetClassContext(This,clsctxFilter,pclsctx)	\
    (This)->lpVtbl -> GetClassContext(This,clsctxFilter,pclsctx)

#define IComClassInfo2_GetCustomActivatorCount(This,activationStage,pulCount)	\
    (This)->lpVtbl -> GetCustomActivatorCount(This,activationStage,pulCount)

#define IComClassInfo2_GetCustomActivatorClsids(This,activationStage,prgguidClsid)	\
    (This)->lpVtbl -> GetCustomActivatorClsids(This,activationStage,prgguidClsid)

#define IComClassInfo2_GetCustomActivators(This,activationStage,prgpActivator)	\
    (This)->lpVtbl -> GetCustomActivators(This,activationStage,prgpActivator)

#define IComClassInfo2_GetTypeInfo(This,riid,ppv)	\
    (This)->lpVtbl -> GetTypeInfo(This,riid,ppv)

#define IComClassInfo2_IsComPlusConfiguredClass(This,pfComPlusConfiguredClass)	\
    (This)->lpVtbl -> IsComPlusConfiguredClass(This,pfComPlusConfiguredClass)

#define IComClassInfo2_MustRunInClientContext(This,pbMustRunInClientContext)	\
    (This)->lpVtbl -> MustRunInClientContext(This,pbMustRunInClientContext)

#define IComClassInfo2_GetVersionNumber(This,pdwVersionMS,pdwVersionLS)	\
    (This)->lpVtbl -> GetVersionNumber(This,pdwVersionMS,pdwVersionLS)

#define IComClassInfo2_Lock(This)	\
    (This)->lpVtbl -> Lock(This)

#define IComClassInfo2_Unlock(This)	\
    (This)->lpVtbl -> Unlock(This)


#define IComClassInfo2_IsEnabled(This,bEnabled)	\
    (This)->lpVtbl -> IsEnabled(This,bEnabled)

#define IComClassInfo2_GetInternalClsid(This,ppguidInternalClsid)	\
    (This)->lpVtbl -> GetInternalClsid(This,ppguidInternalClsid)

#define IComClassInfo2_GetApplicationPartitionId(This,ppguidAppPartitionId)	\
    (This)->lpVtbl -> GetApplicationPartitionId(This,ppguidAppPartitionId)

#define IComClassInfo2_MustRunInDefaultContext(This,pbMustRunInDefaultContext)	\
    (This)->lpVtbl -> MustRunInDefaultContext(This,pbMustRunInDefaultContext)

#define IComClassInfo2_IsPrivateComponent(This,pbIsPrivateComponent)	\
    (This)->lpVtbl -> IsPrivateComponent(This,pbIsPrivateComponent)

#define IComClassInfo2_VBDebugInProgress(This,pbVBDebugInProgress)	\
    (This)->lpVtbl -> VBDebugInProgress(This,pbVBDebugInProgress)

#define IComClassInfo2_GetSoapInfo(This,psoapActInfo)	\
    (This)->lpVtbl -> GetSoapInfo(This,psoapActInfo)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IComClassInfo2_IsEnabled_Proxy( 
    IComClassInfo2 * This,
    /* [out] */ BOOL *bEnabled);


void __RPC_STUB IComClassInfo2_IsEnabled_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IComClassInfo2_GetInternalClsid_Proxy( 
    IComClassInfo2 * This,
    /* [out] */ GUID **ppguidInternalClsid);


void __RPC_STUB IComClassInfo2_GetInternalClsid_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IComClassInfo2_GetApplicationPartitionId_Proxy( 
    IComClassInfo2 * This,
    /* [out] */ GUID **ppguidAppPartitionId);


void __RPC_STUB IComClassInfo2_GetApplicationPartitionId_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IComClassInfo2_MustRunInDefaultContext_Proxy( 
    IComClassInfo2 * This,
    /* [out] */ BOOL *pbMustRunInDefaultContext);


void __RPC_STUB IComClassInfo2_MustRunInDefaultContext_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IComClassInfo2_IsPrivateComponent_Proxy( 
    IComClassInfo2 * This,
    /* [out] */ BOOL *pbIsPrivateComponent);


void __RPC_STUB IComClassInfo2_IsPrivateComponent_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IComClassInfo2_VBDebugInProgress_Proxy( 
    IComClassInfo2 * This,
    /* [out] */ BOOL *pbVBDebugInProgress);


void __RPC_STUB IComClassInfo2_VBDebugInProgress_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IComClassInfo2_GetSoapInfo_Proxy( 
    IComClassInfo2 * This,
    /* [out] */ SOAP_ACTIVATION_INFO *psoapActInfo);


void __RPC_STUB IComClassInfo2_GetSoapInfo_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IComClassInfo2_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_catalog_0144 */
/* [local] */ 

typedef 
enum tagThreadingModel
    {	ApartmentThreaded	= 0,
	FreeThreaded	= ApartmentThreaded + 1,
	SingleThreaded	= FreeThreaded + 1,
	BothThreaded	= SingleThreaded + 1,
	NeutralThreaded	= BothThreaded + 1
    } 	ThreadingModel;

typedef 
enum tagLocalServerType
    {	LocalServerType16	= 0,
	LocalServerType32	= LocalServerType16 + 1
    } 	LocalServerType;



extern RPC_IF_HANDLE __MIDL_itf_catalog_0144_ClientIfHandle;
extern RPC_IF_HANDLE __MIDL_itf_catalog_0144_ServerIfHandle;

#ifndef __IClassClassicInfo_INTERFACE_DEFINED__
#define __IClassClassicInfo_INTERFACE_DEFINED__

/* interface IClassClassicInfo */
/* [uuid][unique][local][object] */ 


EXTERN_C const IID IID_IClassClassicInfo;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("000001E2-0000-0000-C000-000000000046")
    IClassClassicInfo : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetThreadingModel( 
            /* [out] */ ThreadingModel *pthreadmodel) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetModulePath( 
            /* [in] */ CLSCTX clsctx,
            /* [string][out] */ WCHAR **pwszDllName) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetImplementedClsid( 
            /* [out] */ GUID **ppguidClsid) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetProcess( 
            /* [in] */ REFIID riid,
            /* [out] */ void **ppv) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetRemoteServerName( 
            /* [out] */ WCHAR **pwszServerName) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetLocalServerType( 
            /* [out] */ LocalServerType *pType) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetSurrogateCommandLine( 
            /* [out] */ WCHAR **pwszSurrogateCommandLine) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IClassClassicInfoVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IClassClassicInfo * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IClassClassicInfo * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IClassClassicInfo * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetThreadingModel )( 
            IClassClassicInfo * This,
            /* [out] */ ThreadingModel *pthreadmodel);
        
        HRESULT ( STDMETHODCALLTYPE *GetModulePath )( 
            IClassClassicInfo * This,
            /* [in] */ CLSCTX clsctx,
            /* [string][out] */ WCHAR **pwszDllName);
        
        HRESULT ( STDMETHODCALLTYPE *GetImplementedClsid )( 
            IClassClassicInfo * This,
            /* [out] */ GUID **ppguidClsid);
        
        HRESULT ( STDMETHODCALLTYPE *GetProcess )( 
            IClassClassicInfo * This,
            /* [in] */ REFIID riid,
            /* [out] */ void **ppv);
        
        HRESULT ( STDMETHODCALLTYPE *GetRemoteServerName )( 
            IClassClassicInfo * This,
            /* [out] */ WCHAR **pwszServerName);
        
        HRESULT ( STDMETHODCALLTYPE *GetLocalServerType )( 
            IClassClassicInfo * This,
            /* [out] */ LocalServerType *pType);
        
        HRESULT ( STDMETHODCALLTYPE *GetSurrogateCommandLine )( 
            IClassClassicInfo * This,
            /* [out] */ WCHAR **pwszSurrogateCommandLine);
        
        END_INTERFACE
    } IClassClassicInfoVtbl;

    interface IClassClassicInfo
    {
        CONST_VTBL struct IClassClassicInfoVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IClassClassicInfo_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IClassClassicInfo_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IClassClassicInfo_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IClassClassicInfo_GetThreadingModel(This,pthreadmodel)	\
    (This)->lpVtbl -> GetThreadingModel(This,pthreadmodel)

#define IClassClassicInfo_GetModulePath(This,clsctx,pwszDllName)	\
    (This)->lpVtbl -> GetModulePath(This,clsctx,pwszDllName)

#define IClassClassicInfo_GetImplementedClsid(This,ppguidClsid)	\
    (This)->lpVtbl -> GetImplementedClsid(This,ppguidClsid)

#define IClassClassicInfo_GetProcess(This,riid,ppv)	\
    (This)->lpVtbl -> GetProcess(This,riid,ppv)

#define IClassClassicInfo_GetRemoteServerName(This,pwszServerName)	\
    (This)->lpVtbl -> GetRemoteServerName(This,pwszServerName)

#define IClassClassicInfo_GetLocalServerType(This,pType)	\
    (This)->lpVtbl -> GetLocalServerType(This,pType)

#define IClassClassicInfo_GetSurrogateCommandLine(This,pwszSurrogateCommandLine)	\
    (This)->lpVtbl -> GetSurrogateCommandLine(This,pwszSurrogateCommandLine)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IClassClassicInfo_GetThreadingModel_Proxy( 
    IClassClassicInfo * This,
    /* [out] */ ThreadingModel *pthreadmodel);


void __RPC_STUB IClassClassicInfo_GetThreadingModel_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IClassClassicInfo_GetModulePath_Proxy( 
    IClassClassicInfo * This,
    /* [in] */ CLSCTX clsctx,
    /* [string][out] */ WCHAR **pwszDllName);


void __RPC_STUB IClassClassicInfo_GetModulePath_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IClassClassicInfo_GetImplementedClsid_Proxy( 
    IClassClassicInfo * This,
    /* [out] */ GUID **ppguidClsid);


void __RPC_STUB IClassClassicInfo_GetImplementedClsid_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IClassClassicInfo_GetProcess_Proxy( 
    IClassClassicInfo * This,
    /* [in] */ REFIID riid,
    /* [out] */ void **ppv);


void __RPC_STUB IClassClassicInfo_GetProcess_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IClassClassicInfo_GetRemoteServerName_Proxy( 
    IClassClassicInfo * This,
    /* [out] */ WCHAR **pwszServerName);


void __RPC_STUB IClassClassicInfo_GetRemoteServerName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IClassClassicInfo_GetLocalServerType_Proxy( 
    IClassClassicInfo * This,
    /* [out] */ LocalServerType *pType);


void __RPC_STUB IClassClassicInfo_GetLocalServerType_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IClassClassicInfo_GetSurrogateCommandLine_Proxy( 
    IClassClassicInfo * This,
    /* [out] */ WCHAR **pwszSurrogateCommandLine);


void __RPC_STUB IClassClassicInfo_GetSurrogateCommandLine_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IClassClassicInfo_INTERFACE_DEFINED__ */


#ifndef __IComServices_INTERFACE_DEFINED__
#define __IComServices_INTERFACE_DEFINED__

/* interface IComServices */
/* [uuid][unique][local][object] */ 


EXTERN_C const IID IID_IComServices;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("000001F5-0000-0000-C000-000000000046")
    IComServices : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetServicesCount( 
            /* [out] */ ULONG *pulCount) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetServicesClsids( 
            /* [out] */ GUID **pprgguidClsid) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IComServicesVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IComServices * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IComServices * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IComServices * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetServicesCount )( 
            IComServices * This,
            /* [out] */ ULONG *pulCount);
        
        HRESULT ( STDMETHODCALLTYPE *GetServicesClsids )( 
            IComServices * This,
            /* [out] */ GUID **pprgguidClsid);
        
        END_INTERFACE
    } IComServicesVtbl;

    interface IComServices
    {
        CONST_VTBL struct IComServicesVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IComServices_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IComServices_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IComServices_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IComServices_GetServicesCount(This,pulCount)	\
    (This)->lpVtbl -> GetServicesCount(This,pulCount)

#define IComServices_GetServicesClsids(This,pprgguidClsid)	\
    (This)->lpVtbl -> GetServicesClsids(This,pprgguidClsid)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IComServices_GetServicesCount_Proxy( 
    IComServices * This,
    /* [out] */ ULONG *pulCount);


void __RPC_STUB IComServices_GetServicesCount_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IComServices_GetServicesClsids_Proxy( 
    IComServices * This,
    /* [out] */ GUID **pprgguidClsid);


void __RPC_STUB IComServices_GetServicesClsids_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IComServices_INTERFACE_DEFINED__ */


#ifndef __IComServices2_INTERFACE_DEFINED__
#define __IComServices2_INTERFACE_DEFINED__

/* interface IComServices2 */
/* [uuid][unique][local][object] */ 


EXTERN_C const IID IID_IComServices2;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("61a7d610-42eb-43d2-a55f-1904d3294daa")
    IComServices2 : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetInitializerCount( 
            /* [out] */ ULONG *pulCount) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetInitializerClsids( 
            /* [out] */ GUID **pprgguidClsid) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IComServices2Vtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IComServices2 * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IComServices2 * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IComServices2 * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetInitializerCount )( 
            IComServices2 * This,
            /* [out] */ ULONG *pulCount);
        
        HRESULT ( STDMETHODCALLTYPE *GetInitializerClsids )( 
            IComServices2 * This,
            /* [out] */ GUID **pprgguidClsid);
        
        END_INTERFACE
    } IComServices2Vtbl;

    interface IComServices2
    {
        CONST_VTBL struct IComServices2Vtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IComServices2_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IComServices2_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IComServices2_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IComServices2_GetInitializerCount(This,pulCount)	\
    (This)->lpVtbl -> GetInitializerCount(This,pulCount)

#define IComServices2_GetInitializerClsids(This,pprgguidClsid)	\
    (This)->lpVtbl -> GetInitializerClsids(This,pprgguidClsid)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IComServices2_GetInitializerCount_Proxy( 
    IComServices2 * This,
    /* [out] */ ULONG *pulCount);


void __RPC_STUB IComServices2_GetInitializerCount_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IComServices2_GetInitializerClsids_Proxy( 
    IComServices2 * This,
    /* [out] */ GUID **pprgguidClsid);


void __RPC_STUB IComServices2_GetInitializerClsids_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IComServices2_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_catalog_0147 */
/* [local] */ 

typedef 
enum tagProcessType
    {	ProcessTypeNormal	= 0,
	ProcessTypeService	= ProcessTypeNormal + 1,
	ProcessTypeComPlus	= ProcessTypeService + 1,
	ProcessTypeLegacySurrogate	= ProcessTypeComPlus + 1,
	ProcessTypeComPlusService	= ProcessTypeLegacySurrogate + 1
    } 	ProcessType;

typedef 
enum tagRunAsType
    {	RunAsSpecifiedUser	= 0,
	RunAsInteractiveUser	= RunAsSpecifiedUser + 1,
	RunAsLaunchingUser	= RunAsInteractiveUser + 1
    } 	RunAsType;


enum DCOM_ENDPOINT_FLAGS
    {	fUseInternetPorts	= 0x1
    } ;
typedef struct tagDCOM_ENDPOINT
    {
    WCHAR *wszProtSeq;
    WCHAR *wszPorts;
    DWORD dwFlags;
    } 	DCOM_ENDPOINT;



extern RPC_IF_HANDLE __MIDL_itf_catalog_0147_ClientIfHandle;
extern RPC_IF_HANDLE __MIDL_itf_catalog_0147_ServerIfHandle;

#ifndef __IComProcessInfo_INTERFACE_DEFINED__
#define __IComProcessInfo_INTERFACE_DEFINED__

/* interface IComProcessInfo */
/* [uuid][unique][local][object] */ 


EXTERN_C const IID IID_IComProcessInfo;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("000001ED-0000-0000-C000-000000000046")
    IComProcessInfo : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetProcessId( 
            /* [out] */ GUID **ppguidProcessId) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetProcessName( 
            /* [out] */ WCHAR **pwszProcessName) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetProcessType( 
            /* [out] */ ProcessType *pType) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetSurrogatePath( 
            /* [out] */ WCHAR **pwszSurrogatePath) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetServiceName( 
            /* [out] */ WCHAR **pwszServiceName) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetServiceParameters( 
            /* [out] */ WCHAR **pwszServiceParameters) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetActivateAtStorage( 
            /* [out] */ BOOL *pfActivateAtStorage) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetRunAsType( 
            /* [out] */ RunAsType *pRunAsType) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetRunAsUser( 
            /* [out] */ WCHAR **pwszUserName) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetLaunchPermission( 
            /* [out] */ void **ppsdLaunch,
            /* [out] */ DWORD *pdwDescriptorLength) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetAccessPermission( 
            /* [out] */ void **ppsdAccess,
            /* [out] */ DWORD *pdwDescriptorLength) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetAuthenticationLevel( 
            /* [out] */ DWORD *pdwAuthnLevel) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetImpersonationLevel( 
            /* [out] */ DWORD *pdwImpLevel) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetAuthenticationCapabilities( 
            /* [out] */ DWORD *pdwAuthenticationCapabilities) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetEndpoints( 
            /* [out] */ DWORD *pdwNumEndpoints,
            /* [size_is][size_is][out] */ DCOM_ENDPOINT **ppEndPoints) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetRemoteServerName( 
            /* [out] */ WCHAR **pwszServerName) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SendsProcessEvents( 
            /* [out] */ BOOL *pbSendsEvents) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IComProcessInfoVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IComProcessInfo * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IComProcessInfo * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IComProcessInfo * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetProcessId )( 
            IComProcessInfo * This,
            /* [out] */ GUID **ppguidProcessId);
        
        HRESULT ( STDMETHODCALLTYPE *GetProcessName )( 
            IComProcessInfo * This,
            /* [out] */ WCHAR **pwszProcessName);
        
        HRESULT ( STDMETHODCALLTYPE *GetProcessType )( 
            IComProcessInfo * This,
            /* [out] */ ProcessType *pType);
        
        HRESULT ( STDMETHODCALLTYPE *GetSurrogatePath )( 
            IComProcessInfo * This,
            /* [out] */ WCHAR **pwszSurrogatePath);
        
        HRESULT ( STDMETHODCALLTYPE *GetServiceName )( 
            IComProcessInfo * This,
            /* [out] */ WCHAR **pwszServiceName);
        
        HRESULT ( STDMETHODCALLTYPE *GetServiceParameters )( 
            IComProcessInfo * This,
            /* [out] */ WCHAR **pwszServiceParameters);
        
        HRESULT ( STDMETHODCALLTYPE *GetActivateAtStorage )( 
            IComProcessInfo * This,
            /* [out] */ BOOL *pfActivateAtStorage);
        
        HRESULT ( STDMETHODCALLTYPE *GetRunAsType )( 
            IComProcessInfo * This,
            /* [out] */ RunAsType *pRunAsType);
        
        HRESULT ( STDMETHODCALLTYPE *GetRunAsUser )( 
            IComProcessInfo * This,
            /* [out] */ WCHAR **pwszUserName);
        
        HRESULT ( STDMETHODCALLTYPE *GetLaunchPermission )( 
            IComProcessInfo * This,
            /* [out] */ void **ppsdLaunch,
            /* [out] */ DWORD *pdwDescriptorLength);
        
        HRESULT ( STDMETHODCALLTYPE *GetAccessPermission )( 
            IComProcessInfo * This,
            /* [out] */ void **ppsdAccess,
            /* [out] */ DWORD *pdwDescriptorLength);
        
        HRESULT ( STDMETHODCALLTYPE *GetAuthenticationLevel )( 
            IComProcessInfo * This,
            /* [out] */ DWORD *pdwAuthnLevel);
        
        HRESULT ( STDMETHODCALLTYPE *GetImpersonationLevel )( 
            IComProcessInfo * This,
            /* [out] */ DWORD *pdwImpLevel);
        
        HRESULT ( STDMETHODCALLTYPE *GetAuthenticationCapabilities )( 
            IComProcessInfo * This,
            /* [out] */ DWORD *pdwAuthenticationCapabilities);
        
        HRESULT ( STDMETHODCALLTYPE *GetEndpoints )( 
            IComProcessInfo * This,
            /* [out] */ DWORD *pdwNumEndpoints,
            /* [size_is][size_is][out] */ DCOM_ENDPOINT **ppEndPoints);
        
        HRESULT ( STDMETHODCALLTYPE *GetRemoteServerName )( 
            IComProcessInfo * This,
            /* [out] */ WCHAR **pwszServerName);
        
        HRESULT ( STDMETHODCALLTYPE *SendsProcessEvents )( 
            IComProcessInfo * This,
            /* [out] */ BOOL *pbSendsEvents);
        
        END_INTERFACE
    } IComProcessInfoVtbl;

    interface IComProcessInfo
    {
        CONST_VTBL struct IComProcessInfoVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IComProcessInfo_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IComProcessInfo_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IComProcessInfo_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IComProcessInfo_GetProcessId(This,ppguidProcessId)	\
    (This)->lpVtbl -> GetProcessId(This,ppguidProcessId)

#define IComProcessInfo_GetProcessName(This,pwszProcessName)	\
    (This)->lpVtbl -> GetProcessName(This,pwszProcessName)

#define IComProcessInfo_GetProcessType(This,pType)	\
    (This)->lpVtbl -> GetProcessType(This,pType)

#define IComProcessInfo_GetSurrogatePath(This,pwszSurrogatePath)	\
    (This)->lpVtbl -> GetSurrogatePath(This,pwszSurrogatePath)

#define IComProcessInfo_GetServiceName(This,pwszServiceName)	\
    (This)->lpVtbl -> GetServiceName(This,pwszServiceName)

#define IComProcessInfo_GetServiceParameters(This,pwszServiceParameters)	\
    (This)->lpVtbl -> GetServiceParameters(This,pwszServiceParameters)

#define IComProcessInfo_GetActivateAtStorage(This,pfActivateAtStorage)	\
    (This)->lpVtbl -> GetActivateAtStorage(This,pfActivateAtStorage)

#define IComProcessInfo_GetRunAsType(This,pRunAsType)	\
    (This)->lpVtbl -> GetRunAsType(This,pRunAsType)

#define IComProcessInfo_GetRunAsUser(This,pwszUserName)	\
    (This)->lpVtbl -> GetRunAsUser(This,pwszUserName)

#define IComProcessInfo_GetLaunchPermission(This,ppsdLaunch,pdwDescriptorLength)	\
    (This)->lpVtbl -> GetLaunchPermission(This,ppsdLaunch,pdwDescriptorLength)

#define IComProcessInfo_GetAccessPermission(This,ppsdAccess,pdwDescriptorLength)	\
    (This)->lpVtbl -> GetAccessPermission(This,ppsdAccess,pdwDescriptorLength)

#define IComProcessInfo_GetAuthenticationLevel(This,pdwAuthnLevel)	\
    (This)->lpVtbl -> GetAuthenticationLevel(This,pdwAuthnLevel)

#define IComProcessInfo_GetImpersonationLevel(This,pdwImpLevel)	\
    (This)->lpVtbl -> GetImpersonationLevel(This,pdwImpLevel)

#define IComProcessInfo_GetAuthenticationCapabilities(This,pdwAuthenticationCapabilities)	\
    (This)->lpVtbl -> GetAuthenticationCapabilities(This,pdwAuthenticationCapabilities)

#define IComProcessInfo_GetEndpoints(This,pdwNumEndpoints,ppEndPoints)	\
    (This)->lpVtbl -> GetEndpoints(This,pdwNumEndpoints,ppEndPoints)

#define IComProcessInfo_GetRemoteServerName(This,pwszServerName)	\
    (This)->lpVtbl -> GetRemoteServerName(This,pwszServerName)

#define IComProcessInfo_SendsProcessEvents(This,pbSendsEvents)	\
    (This)->lpVtbl -> SendsProcessEvents(This,pbSendsEvents)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IComProcessInfo_GetProcessId_Proxy( 
    IComProcessInfo * This,
    /* [out] */ GUID **ppguidProcessId);


void __RPC_STUB IComProcessInfo_GetProcessId_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IComProcessInfo_GetProcessName_Proxy( 
    IComProcessInfo * This,
    /* [out] */ WCHAR **pwszProcessName);


void __RPC_STUB IComProcessInfo_GetProcessName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IComProcessInfo_GetProcessType_Proxy( 
    IComProcessInfo * This,
    /* [out] */ ProcessType *pType);


void __RPC_STUB IComProcessInfo_GetProcessType_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IComProcessInfo_GetSurrogatePath_Proxy( 
    IComProcessInfo * This,
    /* [out] */ WCHAR **pwszSurrogatePath);


void __RPC_STUB IComProcessInfo_GetSurrogatePath_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IComProcessInfo_GetServiceName_Proxy( 
    IComProcessInfo * This,
    /* [out] */ WCHAR **pwszServiceName);


void __RPC_STUB IComProcessInfo_GetServiceName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IComProcessInfo_GetServiceParameters_Proxy( 
    IComProcessInfo * This,
    /* [out] */ WCHAR **pwszServiceParameters);


void __RPC_STUB IComProcessInfo_GetServiceParameters_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IComProcessInfo_GetActivateAtStorage_Proxy( 
    IComProcessInfo * This,
    /* [out] */ BOOL *pfActivateAtStorage);


void __RPC_STUB IComProcessInfo_GetActivateAtStorage_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IComProcessInfo_GetRunAsType_Proxy( 
    IComProcessInfo * This,
    /* [out] */ RunAsType *pRunAsType);


void __RPC_STUB IComProcessInfo_GetRunAsType_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IComProcessInfo_GetRunAsUser_Proxy( 
    IComProcessInfo * This,
    /* [out] */ WCHAR **pwszUserName);


void __RPC_STUB IComProcessInfo_GetRunAsUser_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IComProcessInfo_GetLaunchPermission_Proxy( 
    IComProcessInfo * This,
    /* [out] */ void **ppsdLaunch,
    /* [out] */ DWORD *pdwDescriptorLength);


void __RPC_STUB IComProcessInfo_GetLaunchPermission_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IComProcessInfo_GetAccessPermission_Proxy( 
    IComProcessInfo * This,
    /* [out] */ void **ppsdAccess,
    /* [out] */ DWORD *pdwDescriptorLength);


void __RPC_STUB IComProcessInfo_GetAccessPermission_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IComProcessInfo_GetAuthenticationLevel_Proxy( 
    IComProcessInfo * This,
    /* [out] */ DWORD *pdwAuthnLevel);


void __RPC_STUB IComProcessInfo_GetAuthenticationLevel_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IComProcessInfo_GetImpersonationLevel_Proxy( 
    IComProcessInfo * This,
    /* [out] */ DWORD *pdwImpLevel);


void __RPC_STUB IComProcessInfo_GetImpersonationLevel_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IComProcessInfo_GetAuthenticationCapabilities_Proxy( 
    IComProcessInfo * This,
    /* [out] */ DWORD *pdwAuthenticationCapabilities);


void __RPC_STUB IComProcessInfo_GetAuthenticationCapabilities_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IComProcessInfo_GetEndpoints_Proxy( 
    IComProcessInfo * This,
    /* [out] */ DWORD *pdwNumEndpoints,
    /* [size_is][size_is][out] */ DCOM_ENDPOINT **ppEndPoints);


void __RPC_STUB IComProcessInfo_GetEndpoints_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IComProcessInfo_GetRemoteServerName_Proxy( 
    IComProcessInfo * This,
    /* [out] */ WCHAR **pwszServerName);


void __RPC_STUB IComProcessInfo_GetRemoteServerName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IComProcessInfo_SendsProcessEvents_Proxy( 
    IComProcessInfo * This,
    /* [out] */ BOOL *pbSendsEvents);


void __RPC_STUB IComProcessInfo_SendsProcessEvents_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IComProcessInfo_INTERFACE_DEFINED__ */


#ifndef __IComProcessInfo2_INTERFACE_DEFINED__
#define __IComProcessInfo2_INTERFACE_DEFINED__

/* interface IComProcessInfo2 */
/* [uuid][unique][local][object] */ 


EXTERN_C const IID IID_IComProcessInfo2;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("6acfc1bf-3882-45b1-96a3-ab948a267d38")
    IComProcessInfo2 : public IComProcessInfo
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetManifestLocation( 
            /* [out] */ WCHAR **wszManifestLocation) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetSaferTrustLevel( 
            /* [out] */ DWORD *pdwSaferTrustLevel) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IComProcessInfo2Vtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IComProcessInfo2 * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IComProcessInfo2 * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IComProcessInfo2 * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetProcessId )( 
            IComProcessInfo2 * This,
            /* [out] */ GUID **ppguidProcessId);
        
        HRESULT ( STDMETHODCALLTYPE *GetProcessName )( 
            IComProcessInfo2 * This,
            /* [out] */ WCHAR **pwszProcessName);
        
        HRESULT ( STDMETHODCALLTYPE *GetProcessType )( 
            IComProcessInfo2 * This,
            /* [out] */ ProcessType *pType);
        
        HRESULT ( STDMETHODCALLTYPE *GetSurrogatePath )( 
            IComProcessInfo2 * This,
            /* [out] */ WCHAR **pwszSurrogatePath);
        
        HRESULT ( STDMETHODCALLTYPE *GetServiceName )( 
            IComProcessInfo2 * This,
            /* [out] */ WCHAR **pwszServiceName);
        
        HRESULT ( STDMETHODCALLTYPE *GetServiceParameters )( 
            IComProcessInfo2 * This,
            /* [out] */ WCHAR **pwszServiceParameters);
        
        HRESULT ( STDMETHODCALLTYPE *GetActivateAtStorage )( 
            IComProcessInfo2 * This,
            /* [out] */ BOOL *pfActivateAtStorage);
        
        HRESULT ( STDMETHODCALLTYPE *GetRunAsType )( 
            IComProcessInfo2 * This,
            /* [out] */ RunAsType *pRunAsType);
        
        HRESULT ( STDMETHODCALLTYPE *GetRunAsUser )( 
            IComProcessInfo2 * This,
            /* [out] */ WCHAR **pwszUserName);
        
        HRESULT ( STDMETHODCALLTYPE *GetLaunchPermission )( 
            IComProcessInfo2 * This,
            /* [out] */ void **ppsdLaunch,
            /* [out] */ DWORD *pdwDescriptorLength);
        
        HRESULT ( STDMETHODCALLTYPE *GetAccessPermission )( 
            IComProcessInfo2 * This,
            /* [out] */ void **ppsdAccess,
            /* [out] */ DWORD *pdwDescriptorLength);
        
        HRESULT ( STDMETHODCALLTYPE *GetAuthenticationLevel )( 
            IComProcessInfo2 * This,
            /* [out] */ DWORD *pdwAuthnLevel);
        
        HRESULT ( STDMETHODCALLTYPE *GetImpersonationLevel )( 
            IComProcessInfo2 * This,
            /* [out] */ DWORD *pdwImpLevel);
        
        HRESULT ( STDMETHODCALLTYPE *GetAuthenticationCapabilities )( 
            IComProcessInfo2 * This,
            /* [out] */ DWORD *pdwAuthenticationCapabilities);
        
        HRESULT ( STDMETHODCALLTYPE *GetEndpoints )( 
            IComProcessInfo2 * This,
            /* [out] */ DWORD *pdwNumEndpoints,
            /* [size_is][size_is][out] */ DCOM_ENDPOINT **ppEndPoints);
        
        HRESULT ( STDMETHODCALLTYPE *GetRemoteServerName )( 
            IComProcessInfo2 * This,
            /* [out] */ WCHAR **pwszServerName);
        
        HRESULT ( STDMETHODCALLTYPE *SendsProcessEvents )( 
            IComProcessInfo2 * This,
            /* [out] */ BOOL *pbSendsEvents);
        
        HRESULT ( STDMETHODCALLTYPE *GetManifestLocation )( 
            IComProcessInfo2 * This,
            /* [out] */ WCHAR **wszManifestLocation);
        
        HRESULT ( STDMETHODCALLTYPE *GetSaferTrustLevel )( 
            IComProcessInfo2 * This,
            /* [out] */ DWORD *pdwSaferTrustLevel);
        
        END_INTERFACE
    } IComProcessInfo2Vtbl;

    interface IComProcessInfo2
    {
        CONST_VTBL struct IComProcessInfo2Vtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IComProcessInfo2_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IComProcessInfo2_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IComProcessInfo2_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IComProcessInfo2_GetProcessId(This,ppguidProcessId)	\
    (This)->lpVtbl -> GetProcessId(This,ppguidProcessId)

#define IComProcessInfo2_GetProcessName(This,pwszProcessName)	\
    (This)->lpVtbl -> GetProcessName(This,pwszProcessName)

#define IComProcessInfo2_GetProcessType(This,pType)	\
    (This)->lpVtbl -> GetProcessType(This,pType)

#define IComProcessInfo2_GetSurrogatePath(This,pwszSurrogatePath)	\
    (This)->lpVtbl -> GetSurrogatePath(This,pwszSurrogatePath)

#define IComProcessInfo2_GetServiceName(This,pwszServiceName)	\
    (This)->lpVtbl -> GetServiceName(This,pwszServiceName)

#define IComProcessInfo2_GetServiceParameters(This,pwszServiceParameters)	\
    (This)->lpVtbl -> GetServiceParameters(This,pwszServiceParameters)

#define IComProcessInfo2_GetActivateAtStorage(This,pfActivateAtStorage)	\
    (This)->lpVtbl -> GetActivateAtStorage(This,pfActivateAtStorage)

#define IComProcessInfo2_GetRunAsType(This,pRunAsType)	\
    (This)->lpVtbl -> GetRunAsType(This,pRunAsType)

#define IComProcessInfo2_GetRunAsUser(This,pwszUserName)	\
    (This)->lpVtbl -> GetRunAsUser(This,pwszUserName)

#define IComProcessInfo2_GetLaunchPermission(This,ppsdLaunch,pdwDescriptorLength)	\
    (This)->lpVtbl -> GetLaunchPermission(This,ppsdLaunch,pdwDescriptorLength)

#define IComProcessInfo2_GetAccessPermission(This,ppsdAccess,pdwDescriptorLength)	\
    (This)->lpVtbl -> GetAccessPermission(This,ppsdAccess,pdwDescriptorLength)

#define IComProcessInfo2_GetAuthenticationLevel(This,pdwAuthnLevel)	\
    (This)->lpVtbl -> GetAuthenticationLevel(This,pdwAuthnLevel)

#define IComProcessInfo2_GetImpersonationLevel(This,pdwImpLevel)	\
    (This)->lpVtbl -> GetImpersonationLevel(This,pdwImpLevel)

#define IComProcessInfo2_GetAuthenticationCapabilities(This,pdwAuthenticationCapabilities)	\
    (This)->lpVtbl -> GetAuthenticationCapabilities(This,pdwAuthenticationCapabilities)

#define IComProcessInfo2_GetEndpoints(This,pdwNumEndpoints,ppEndPoints)	\
    (This)->lpVtbl -> GetEndpoints(This,pdwNumEndpoints,ppEndPoints)

#define IComProcessInfo2_GetRemoteServerName(This,pwszServerName)	\
    (This)->lpVtbl -> GetRemoteServerName(This,pwszServerName)

#define IComProcessInfo2_SendsProcessEvents(This,pbSendsEvents)	\
    (This)->lpVtbl -> SendsProcessEvents(This,pbSendsEvents)


#define IComProcessInfo2_GetManifestLocation(This,wszManifestLocation)	\
    (This)->lpVtbl -> GetManifestLocation(This,wszManifestLocation)

#define IComProcessInfo2_GetSaferTrustLevel(This,pdwSaferTrustLevel)	\
    (This)->lpVtbl -> GetSaferTrustLevel(This,pdwSaferTrustLevel)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IComProcessInfo2_GetManifestLocation_Proxy( 
    IComProcessInfo2 * This,
    /* [out] */ WCHAR **wszManifestLocation);


void __RPC_STUB IComProcessInfo2_GetManifestLocation_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IComProcessInfo2_GetSaferTrustLevel_Proxy( 
    IComProcessInfo2 * This,
    /* [out] */ DWORD *pdwSaferTrustLevel);


void __RPC_STUB IComProcessInfo2_GetSaferTrustLevel_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IComProcessInfo2_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_catalog_0149 */
/* [local] */ 

typedef 
enum tagResourceGateId
    {	CreateProcessMemoryGate	= 0,
	CreateObjectMemoryGate	= CreateProcessMemoryGate + 1
    } 	ResourceGateId;



extern RPC_IF_HANDLE __MIDL_itf_catalog_0149_ClientIfHandle;
extern RPC_IF_HANDLE __MIDL_itf_catalog_0149_ServerIfHandle;

#ifndef __IResourceGates_INTERFACE_DEFINED__
#define __IResourceGates_INTERFACE_DEFINED__

/* interface IResourceGates */
/* [uuid][unique][local][object] */ 


EXTERN_C const IID IID_IResourceGates;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("7a0ddd93-7198-4e15-bbd7-427c77b6907a")
    IResourceGates : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Test( 
            /* [in] */ ResourceGateId id,
            /* [out] */ BOOL *pbResult) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IResourceGatesVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IResourceGates * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IResourceGates * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IResourceGates * This);
        
        HRESULT ( STDMETHODCALLTYPE *Test )( 
            IResourceGates * This,
            /* [in] */ ResourceGateId id,
            /* [out] */ BOOL *pbResult);
        
        END_INTERFACE
    } IResourceGatesVtbl;

    interface IResourceGates
    {
        CONST_VTBL struct IResourceGatesVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IResourceGates_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IResourceGates_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IResourceGates_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IResourceGates_Test(This,id,pbResult)	\
    (This)->lpVtbl -> Test(This,id,pbResult)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IResourceGates_Test_Proxy( 
    IResourceGates * This,
    /* [in] */ ResourceGateId id,
    /* [out] */ BOOL *pbResult);


void __RPC_STUB IResourceGates_Test_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IResourceGates_INTERFACE_DEFINED__ */


#ifndef __IProcessServerInfo_INTERFACE_DEFINED__
#define __IProcessServerInfo_INTERFACE_DEFINED__

/* interface IProcessServerInfo */
/* [uuid][unique][local][object] */ 


EXTERN_C const IID IID_IProcessServerInfo;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("000001EE-0000-0000-C000-000000000046")
    IProcessServerInfo : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetShutdownIdleTime( 
            /* [out] */ unsigned long *pulTime) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetCrmLogFileName( 
            /* [out] */ WCHAR **pwszFileName) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE EnumApplications( 
            /* [out] */ IEnumUnknown **ppEnum) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE EnumRetQueues( 
            /* [out] */ IEnumUnknown **ppEnum) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IProcessServerInfoVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IProcessServerInfo * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IProcessServerInfo * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IProcessServerInfo * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetShutdownIdleTime )( 
            IProcessServerInfo * This,
            /* [out] */ unsigned long *pulTime);
        
        HRESULT ( STDMETHODCALLTYPE *GetCrmLogFileName )( 
            IProcessServerInfo * This,
            /* [out] */ WCHAR **pwszFileName);
        
        HRESULT ( STDMETHODCALLTYPE *EnumApplications )( 
            IProcessServerInfo * This,
            /* [out] */ IEnumUnknown **ppEnum);
        
        HRESULT ( STDMETHODCALLTYPE *EnumRetQueues )( 
            IProcessServerInfo * This,
            /* [out] */ IEnumUnknown **ppEnum);
        
        END_INTERFACE
    } IProcessServerInfoVtbl;

    interface IProcessServerInfo
    {
        CONST_VTBL struct IProcessServerInfoVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IProcessServerInfo_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IProcessServerInfo_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IProcessServerInfo_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IProcessServerInfo_GetShutdownIdleTime(This,pulTime)	\
    (This)->lpVtbl -> GetShutdownIdleTime(This,pulTime)

#define IProcessServerInfo_GetCrmLogFileName(This,pwszFileName)	\
    (This)->lpVtbl -> GetCrmLogFileName(This,pwszFileName)

#define IProcessServerInfo_EnumApplications(This,ppEnum)	\
    (This)->lpVtbl -> EnumApplications(This,ppEnum)

#define IProcessServerInfo_EnumRetQueues(This,ppEnum)	\
    (This)->lpVtbl -> EnumRetQueues(This,ppEnum)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IProcessServerInfo_GetShutdownIdleTime_Proxy( 
    IProcessServerInfo * This,
    /* [out] */ unsigned long *pulTime);


void __RPC_STUB IProcessServerInfo_GetShutdownIdleTime_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IProcessServerInfo_GetCrmLogFileName_Proxy( 
    IProcessServerInfo * This,
    /* [out] */ WCHAR **pwszFileName);


void __RPC_STUB IProcessServerInfo_GetCrmLogFileName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IProcessServerInfo_EnumApplications_Proxy( 
    IProcessServerInfo * This,
    /* [out] */ IEnumUnknown **ppEnum);


void __RPC_STUB IProcessServerInfo_EnumApplications_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IProcessServerInfo_EnumRetQueues_Proxy( 
    IProcessServerInfo * This,
    /* [out] */ IEnumUnknown **ppEnum);


void __RPC_STUB IProcessServerInfo_EnumRetQueues_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IProcessServerInfo_INTERFACE_DEFINED__ */


#ifndef __IInterfaceInfo_INTERFACE_DEFINED__
#define __IInterfaceInfo_INTERFACE_DEFINED__

/* interface IInterfaceInfo */
/* [uuid][unique][local][object] */ 


EXTERN_C const IID IID_IInterfaceInfo;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("000001F7-0000-0000-C000-000000000046")
    IInterfaceInfo : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetProxyStubCLSID( 
            /* [out] */ GUID **psclsid,
            /* [out] */ BOOL *pfIs16BitPS) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetTypeLibrary( 
            /* [out] */ GUID **pLibID,
            /* [out] */ unsigned short *psVersionMajor,
            /* [out] */ unsigned short *psVersionMinor) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetSyncIID( 
            /* [out] */ GUID **syncriid) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetAsyncIID( 
            /* [out] */ GUID **asyncriid) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetTypeInfo( 
            /* [in] */ REFIID riid,
            /* [out] */ void **ppv) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IInterfaceInfoVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IInterfaceInfo * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IInterfaceInfo * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IInterfaceInfo * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetProxyStubCLSID )( 
            IInterfaceInfo * This,
            /* [out] */ GUID **psclsid,
            /* [out] */ BOOL *pfIs16BitPS);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeLibrary )( 
            IInterfaceInfo * This,
            /* [out] */ GUID **pLibID,
            /* [out] */ unsigned short *psVersionMajor,
            /* [out] */ unsigned short *psVersionMinor);
        
        HRESULT ( STDMETHODCALLTYPE *GetSyncIID )( 
            IInterfaceInfo * This,
            /* [out] */ GUID **syncriid);
        
        HRESULT ( STDMETHODCALLTYPE *GetAsyncIID )( 
            IInterfaceInfo * This,
            /* [out] */ GUID **asyncriid);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IInterfaceInfo * This,
            /* [in] */ REFIID riid,
            /* [out] */ void **ppv);
        
        END_INTERFACE
    } IInterfaceInfoVtbl;

    interface IInterfaceInfo
    {
        CONST_VTBL struct IInterfaceInfoVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IInterfaceInfo_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IInterfaceInfo_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IInterfaceInfo_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IInterfaceInfo_GetProxyStubCLSID(This,psclsid,pfIs16BitPS)	\
    (This)->lpVtbl -> GetProxyStubCLSID(This,psclsid,pfIs16BitPS)

#define IInterfaceInfo_GetTypeLibrary(This,pLibID,psVersionMajor,psVersionMinor)	\
    (This)->lpVtbl -> GetTypeLibrary(This,pLibID,psVersionMajor,psVersionMinor)

#define IInterfaceInfo_GetSyncIID(This,syncriid)	\
    (This)->lpVtbl -> GetSyncIID(This,syncriid)

#define IInterfaceInfo_GetAsyncIID(This,asyncriid)	\
    (This)->lpVtbl -> GetAsyncIID(This,asyncriid)

#define IInterfaceInfo_GetTypeInfo(This,riid,ppv)	\
    (This)->lpVtbl -> GetTypeInfo(This,riid,ppv)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IInterfaceInfo_GetProxyStubCLSID_Proxy( 
    IInterfaceInfo * This,
    /* [out] */ GUID **psclsid,
    /* [out] */ BOOL *pfIs16BitPS);


void __RPC_STUB IInterfaceInfo_GetProxyStubCLSID_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IInterfaceInfo_GetTypeLibrary_Proxy( 
    IInterfaceInfo * This,
    /* [out] */ GUID **pLibID,
    /* [out] */ unsigned short *psVersionMajor,
    /* [out] */ unsigned short *psVersionMinor);


void __RPC_STUB IInterfaceInfo_GetTypeLibrary_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IInterfaceInfo_GetSyncIID_Proxy( 
    IInterfaceInfo * This,
    /* [out] */ GUID **syncriid);


void __RPC_STUB IInterfaceInfo_GetSyncIID_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IInterfaceInfo_GetAsyncIID_Proxy( 
    IInterfaceInfo * This,
    /* [out] */ GUID **asyncriid);


void __RPC_STUB IInterfaceInfo_GetAsyncIID_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IInterfaceInfo_GetTypeInfo_Proxy( 
    IInterfaceInfo * This,
    /* [in] */ REFIID riid,
    /* [out] */ void **ppv);


void __RPC_STUB IInterfaceInfo_GetTypeInfo_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IInterfaceInfo_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_catalog_0152 */
/* [local] */ 

typedef HRESULT __stdcall FN_GetCatalogObject (REFIID riid, void **ppv );
extern  HRESULT __stdcall    GetCatalogObject (REFIID riid, void **ppv );


extern RPC_IF_HANDLE __MIDL_itf_catalog_0152_ClientIfHandle;
extern RPC_IF_HANDLE __MIDL_itf_catalog_0152_ServerIfHandle;

/* Additional Prototypes for ALL interfaces */

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\public\internal\com\inc\iface.h ===
#pragma warning( disable: 4049 )  /* more than 64k source lines */

/* this ALWAYS GENERATED file contains the definitions for the interfaces */


 /* File created by MIDL compiler version 6.00.0347 */
/* Compiler settings for iface.idl:
    Oicf, W1, Zp8, env=Win32 (32b run)
    protocol : dce , ms_ext, c_ext, oldnames, robust
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )


/* verify that the <rpcndr.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCNDR_H_VERSION__
#define __REQUIRED_RPCNDR_H_VERSION__ 475
#endif

#include "rpc.h"
#include "rpcndr.h"

#ifndef __RPCNDR_H_VERSION__
#error this stub requires an updated version of <rpcndr.h>
#endif // __RPCNDR_H_VERSION__


#ifndef __iface_h__
#define __iface_h__

#if defined(_MSC_VER) && (_MSC_VER >= 1020)
#pragma once
#endif

/* Forward Declarations */ 

/* header files for imported files */
#include "wtypes.h"
#include "obase.h"

#ifdef __cplusplus
extern "C"{
#endif 

void * __RPC_USER MIDL_user_allocate(size_t);
void __RPC_USER MIDL_user_free( void * ); 

#ifndef __XmitDefs_INTERFACE_DEFINED__
#define __XmitDefs_INTERFACE_DEFINED__

/* interface XmitDefs */
/* [auto_handle][unique][version][uuid] */ 

#define	ORPCF_INPUT_SYNC	( ORPCF_RESERVED1 )

#define	ORPCF_ASYNC	( ORPCF_RESERVED2 )

#define	ORPCF_DYNAMIC_CLOAKING	( ORPCF_RESERVED3 )

#define	ORPCF_REJECTED	( ORPCF_RESERVED1 )

#define	ORPCF_RETRY_LATER	( ORPCF_RESERVED2 )

typedef /* [public] */ struct __MIDL_XmitDefs_0001
    {
    DWORD dwFlags;
    DWORD dwClientThread;
    } 	LOCALTHIS;

typedef 
enum tagLOCALFLAG
    {	LOCALF_NONE	= 0,
	LOCALF_NONNDR	= 0x800
    } 	LOCALFLAG;

typedef 
enum tagCALLCATEGORY
    {	CALLCAT_NOCALL	= 0,
	CALLCAT_SYNCHRONOUS	= 1,
	CALLCAT_ASYNC	= 2,
	CALLCAT_INPUTSYNC	= 3,
	CALLCAT_INTERNALSYNC	= 4,
	CALLCAT_INTERNALINPUTSYNC	= 5,
	CALLCAT_SCMCALL	= 6
    } 	CALLCATEGORY;

typedef struct tagInterfaceData
    {
    ULONG ulCntData;
    /* [length_is] */ BYTE abData[ 1024 ];
    } 	InterfaceData;

typedef /* [unique] */ InterfaceData *PInterfaceData;

#define IFD_SIZE(pIFD) (sizeof(InterfaceData) + pIFD->ulCntData - 1024)


extern RPC_IF_HANDLE XmitDefs_ClientIfHandle;
extern RPC_IF_HANDLE XmitDefs_ServerIfHandle;
#endif /* __XmitDefs_INTERFACE_DEFINED__ */

/* Additional Prototypes for ALL interfaces */

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\public\internal\com\inc\corhdr.h ===
/*****************************************************************************
 **                                                                         **
 ** CorHdr.h - contains definitions for the Runtime structures,             **
 **            needed to work with metadata.                                **
 **                                                                         **
 ** Copyright (c) Microsoft Corporation. All rights reserved.               **
 **                                                                         **
 *****************************************************************************/


#ifndef __CORHDR_H__
#define __CORHDR_H__


#pragma warning(disable:4200) // nonstandard extension used : zero-sized array in struct/union.
typedef ULONG32 mdScope;                // Why is this still needed?
typedef ULONG32 mdToken;                // Generic token


// Token  definitions


typedef mdToken mdModule;               // Module token (roughly, a scope)
typedef mdToken mdTypeRef;              // TypeRef reference (this or other scope)
typedef mdToken mdTypeDef;              // TypeDef in this scope
typedef mdToken mdFieldDef;             // Field in this scope  
typedef mdToken mdMethodDef;            // Method in this scope 
typedef mdToken mdParamDef;             // param token  
typedef mdToken mdInterfaceImpl;        // interface implementation token

typedef mdToken mdMemberRef;            // MemberRef (this or other scope)  
typedef mdToken mdCustomAttribute;      // attribute token
typedef mdCustomAttribute mdCustomValue;// attribute token
typedef mdToken mdPermission;           // DeclSecurity 

typedef mdToken mdSignature;            // Signature object 
typedef mdToken mdEvent;                // event token  
typedef mdToken mdProperty;             // property token   

typedef mdToken mdModuleRef;            // Module reference (for the imported modules)  

// Assembly tokens.
typedef mdToken mdAssembly;             // Assembly token.
typedef mdToken mdAssemblyRef;          // AssemblyRef token.
typedef mdToken mdFile;                 // File token.
typedef mdToken mdComType;              // ComType token.
typedef mdToken mdManifestResource;     // ManifestResource token.
typedef mdToken mdLocalizedResource;    // LocalizedManifestResource token.
typedef mdToken mdExecutionLocation;    // Execution location token.

typedef mdToken mdTypeSpec;             // TypeSpec object 

// Debugger support tokens - deprecated.
typedef mdToken mdSourceFile;           // source file token    
typedef mdToken mdLocalVarScope;        // local variable scope token   
typedef mdToken mdLocalVar;             // local variable token 

// Application string.
typedef mdToken mdString;               // User literal string token.

typedef mdToken mdCPToken;              // constantpool token   

#ifndef MACROS_NOT_SUPPORTED
typedef unsigned long RID;              //@todo: this goes away with 9/29 integration when complib is nuked.
#else
typedef unsigned RID;
#endif


typedef enum ReplacesGeneralNumericDefines
{
// Directory entry macro for COM+ data.
#ifndef IMAGE_DIRECTORY_ENTRY_COMHEADER
    IMAGE_DIRECTORY_ENTRY_COMHEADER     =14,
#endif // IMAGE_DIRECTORY_ENTRY_COMHEADER

    _NEW_FLAGS_IMPLEMENTED              =1,
    __NEW_FLAGS_IMPLEMENTED             =1,
} ReplacesGeneralNumericDefines;


// The most recent version.

#define COR_CTOR_METHOD_NAME        ".ctor"
#define COR_CTOR_METHOD_NAME_W      L".ctor"
#define COR_CCTOR_METHOD_NAME       ".cctor"
#define COR_CCTOR_METHOD_NAME_W     L".cctor"

// The predefined name for deleting a typeDef,MethodDef, FieldDef, Property and Event
#define COR_DELETED_NAME_A          "_Deleted"
#define COR_DELETED_NAME_W          L"_Deleted"
#define COR_VTABLEGAP_NAME_A        "_VtblGap"
#define COR_VTABLEGAP_NAME_W        L"_VtblGap"

// We intentionally use strncmp so that we will ignore any suffix 
#define IsDeletedName(strName)      (strncmp(strName, COR_DELETED_NAME_A, COR_DELETED_NAME_LENGTH) == 0)
#define IsVtblGapName(strName)      (strncmp(strName, COR_VTABLEGAP_NAME_A, COR_VTABLEGAP_NAME_LENGTH) == 0)

// TypeDef/ComType attr bits, used by DefineTypeDef.
typedef enum CorTypeAttr
{
    // Use this mask to retrieve the type visibility information.
    tdVisibilityMask        =   0x00000007,
    tdNotPublic             =   0x00000000,     // Class is not public scope.
    tdPublic                =   0x00000001,     // Class is public scope.
    tdNestedPublic          =   0x00000002,     // Class is nested with public visibility.
    tdNestedPrivate         =   0x00000003,     // Class is nested with private visibility.
    tdNestedFamily          =   0x00000004,     // Class is nested with family visibility.
    tdNestedAssembly        =   0x00000005,     // Class is nested with assembly visibility.
    tdNestedFamANDAssem     =   0x00000006,     // Class is nested with family and assembly visibility.
    tdNestedFamORAssem      =   0x00000007,     // Class is nested with family or assembly visibility.

    // Use this mask to retrieve class layout information
    tdLayoutMask            =   0x00000018,
    tdAutoLayout            =   0x00000000,     // Class fields are auto-laid out
    tdLayoutSequential      =   0x00000008,     // Class fields are laid out sequentially
    tdExplicitLayout        =   0x00000010,     // Layout is supplied explicitly
    // end layout mask

    // Use this mask to retrieve class semantics information.
    tdClassSemanticsMask    =   0x00000060,
    tdClass                 =   0x00000000,     // Type is a class.
    tdInterface             =   0x00000020,     // Type is an interface.
    tdValueType             =   0x00000040,     // Type is a managed value type.
    tdUnmanagedValueType    =   0x00000060,     // DEPRECATED Don't use TODO; remove on next breaking change
    tdNotInGCHeapValueType  =   0x00000060,     // It is a value type that can not live in the GC heap.
    // end semantics mask

    // Special semantics in addition to class semantics.
    tdAbstract              =   0x00000080,     // Class is abstract
    tdSealed                =   0x00000100,     // Class is concrete and may not be extended
    tdEnum                  =   0x00000200,     // Class is an enum; static final values only
    tdSpecialName           =   0x00000400,     // Class name is special.  Name describes how.

    // Implementation attributes.
    tdImport                =   0x00001000,     // Class / interface is imported
    tdSerializable          =   0x00002000,     // The class is Serializable.

    // Use tdStringFormatMask to retrieve string information for native interop
    tdStringFormatMask      =   0x00030000,     
    tdAnsiClass             =   0x00000000,     // LPTSTR is interpreted as ANSI in this class
    tdUnicodeClass          =   0x00010000,     // LPTSTR is interpreted as UNICODE
    tdAutoClass             =   0x00020000,     // LPTSTR is interpreted automatically
    // end string format mask

    tdLateInit              =   0x00080000,     // Initialize the class lazily.

    // Flags reserved for runtime use.
    tdReservedMask          =   0x00040800,
    tdRTSpecialName         =   0x00000800,     // Runtime should check name encoding.
    tdHasSecurity           =   0x00040000,     // Class has security associate with it.
} CorTypeAttr;


// Macros for accessing the members of the CorTypeAttr.
#define IsTdNotPublic(x)                    (((x) & tdVisibilityMask) == tdNotPublic)
#define IsTdPublic(x)                       (((x) & tdVisibilityMask) == tdPublic)
#define IsTdNestedPublic(x)                 (((x) & tdVisibilityMask) == tdNestedPublic)
#define IsTdNestedPrivate(x)                (((x) & tdVisibilityMask) == tdNestedPrivate)
#define IsTdNestedFamily(x)                 (((x) & tdVisibilityMask) == tdNestedFamily)
#define IsTdNestedAssembly(x)               (((x) & tdVisibilityMask) == tdNestedAssembly)
#define IsTdNestedFamANDAssem(x)            (((x) & tdVisibilityMask) == tdNestedFamANDAssem)
#define IsTdNestedFamORAssem(x)             (((x) & tdVisibilityMask) == tdNestedFamORAssem)
#define IsTdNested(x)                       (((x) & tdVisibilityMask) >= tdNestedPublic)

#define IsTdAutoLayout(x)                   (((x) & tdLayoutMask) == tdAutoLayout)
#define IsTdLayoutSequential(x)             (((x) & tdLayoutMask) == tdLayoutSequential)
#define IsTdExplicitLayout(x)               (((x) & tdLayoutMask) == tdExplicitLayout)

#define IsTdClass(x)                        (((x) & tdClassSemanticsMask) == tdClass)
#define IsTdInterface(x)                    (((x) & tdClassSemanticsMask) == tdInterface)
#define IsTdUnmanagedValueType(x)           IsTdNotInGCHeapValueType(x)  		// DEPRECATED: TODO remove on next breaking change
#define IsTdNotInGCHeapValueType(x)         (((x) & tdClassSemanticsMask) == tdNotInGCHeapValueType)
#define IsTdValueType(x)                    ((x) & tdValueType)  // This can be either tdManagedValueType or tdNotInGCHeapValueType

#define IsTdAbstract(x)                     ((x) & tdAbstract)
#define IsTdSealed(x)                       ((x) & tdSealed)
#define IsTdEnum(x)                         ((x) & tdEnum)
#define IsTdSpecialName(x)                  ((x) & tdSpecialName)

#define IsTdImport(x)                       ((x) & tdImport)
#define IsTdSerializable(x)                 ((x) & tdSerializable)

#define IsTdAnsiClass(x)                    (((x) & tdStringFormatMask) == tdAnsiClass)
#define IsTdUnicodeClass(x)                 (((x) & tdStringFormatMask) == tdUnicodeClass)
#define IsTdAutoClass(x)                    (((x) & tdStringFormatMask) == tdAutoClass)

#define IsTdLateInit(x)                     ((x) &tdLateInit)

#define IsTdRTSpecialName(x)                ((x) & tdRTSpecialName)
#define IsTdHasSecurity(x)                  ((x) & tdHasSecurity)

// MethodDef attr bits, Used by DefineMethod.
typedef enum CorMethodAttr
{
    // member access mask - Use this mask to retrieve accessibility information.
    mdMemberAccessMask          =   0x0007,
    mdPrivateScope              =   0x0000,     // Member not referenceable.
    mdPrivate                   =   0x0001,     // Accessible only by the parent type.  
    mdFamANDAssem               =   0x0002,     // Accessible by sub-types only in this Assembly.
    mdAssem                     =   0x0003,     // Accessibly by anyone in the Assembly.
    mdFamily                    =   0x0004,     // Accessible only by type and sub-types.    
    mdFamORAssem                =   0x0005,     // Accessibly by sub-types anywhere, plus anyone in assembly.
    mdPublic                    =   0x0006,     // Accessibly by anyone who has visibility to this scope.    
    // end member access mask

    // method contract attributes.
    mdStatic                    =   0x0010,     // Defined on type, else per instance.
    mdFinal                     =   0x0020,     // Method may not be overridden.
    mdVirtual                   =   0x0040,     // Method virtual.
    mdHideBySig                 =   0x0080,     // Method hides by name+sig, else just by name.

    // vtable layout mask - Use this mask to retrieve vtable attributes.
    mdVtableLayoutMask          =   0x0100,
    mdReuseSlot                 =   0x0000,     // The default.
    mdNewSlot                   =   0x0100,     // Method always gets a new slot in the vtable.
    // end vtable layout mask

    // method implementation attributes.
    mdAbstract                  =   0x0400,     // Method does not provide an implementation.
    mdSpecialName               =   0x0800,     // Method is special.  Name describes how.
    
    // interop attributes
    mdPinvokeImpl               =   0x2000,     // Implementation is forwarded through pinvoke.
    mdUnmanagedExport           =   0x0008,     // Managed method exported via thunk to unmanaged code.

    // Reserved flags for runtime use only.
    mdReservedMask              =   0xd000,
    mdRTSpecialName             =   0x1000,     // Runtime should check name encoding.
    mdHasSecurity               =   0x4000,     // Method has security associate with it.
    mdRequireSecObject          =   0x8000,     // Method calls another method containing security code.

} CorMethodAttr;

// Macros for accessing the members of CorMethodAttr.
#define IsMdPrivateScope(x)                 (((x) & mdMemberAccessMask) == mdPrivateScope)
#define IsMdPrivate(x)                      (((x) & mdMemberAccessMask) == mdPrivate)
#define IsMdFamANDAssem(x)                  (((x) & mdMemberAccessMask) == mdFamANDAssem)
#define IsMdAssem(x)                        (((x) & mdMemberAccessMask) == mdAssem)
#define IsMdFamily(x)                       (((x) & mdMemberAccessMask) == mdFamily)
#define IsMdFamORAssem(x)                   (((x) & mdMemberAccessMask) == mdFamORAssem)
#define IsMdPublic(x)                       (((x) & mdMemberAccessMask) == mdPublic)

#define IsMdStatic(x)                       ((x) & mdStatic)
#define IsMdFinal(x)                        ((x) & mdFinal)
#define IsMdVirtual(x)                      ((x) & mdVirtual)
#define IsMdHideBySig(x)                    ((x) & mdHideBySig)

#define IsMdReuseSlot(x)                    (((x) & mdVtableLayoutMask) == mdReuseSlot)
#define IsMdNewSlot(x)                      (((x) & mdVtableLayoutMask) == mdNewSlot)

#define IsMdAbstract(x)                     ((x) & mdAbstract)
#define IsMdSpecialName(x)                  ((x) & mdSpecialName)

#define IsMdPinvokeImpl(x)                  ((x) & mdPinvokeImpl)
#define IsMdUnmanagedExport(x)              ((x) & mdUnmanagedExport)

#define IsMdRTSpecialName(x)                ((x) & mdRTSpecialName)
#define IsMdInstanceInitializer(x, str)     (((x) & mdRTSpecialName) && !strcmp((str), COR_CTOR_METHOD_NAME))
#define IsMdInstanceInitializerW(x, str)    (((x) & mdRTSpecialName) && !wcscmp((str), COR_CTOR_METHOD_NAME_W))
#define IsMdClassConstructor(x, str)        (((x) & mdRTSpecialName) && !strcmp((str), COR_CCTOR_METHOD_NAME))
#define IsMdClassConstructorW(x, str)       (((x) & mdRTSpecialName) && !wcscmp((str), COR_CCTOR_METHOD_NAME_W))
#define IsMdHasSecurity(x)                  ((x) & mdHasSecurity)
#define IsMdRequireSecObject(x)             ((x) & mdRequireSecObject)

// FieldDef attr bits, used by DefineField.
typedef enum CorFieldAttr
{
    // member access mask - Use this mask to retrieve accessibility information.
    fdFieldAccessMask           =   0x0007,
    fdPrivateScope              =   0x0000,     // Member not referenceable.
    fdPrivate                   =   0x0001,     // Accessible only by the parent type.  
    fdFamANDAssem               =   0x0002,     // Accessible by sub-types only in this Assembly.
    fdAssembly                  =   0x0003,     // Accessibly by anyone in the Assembly.
    fdFamily                    =   0x0004,     // Accessible only by type and sub-types.    
    fdFamORAssem                =   0x0005,     // Accessibly by sub-types anywhere, plus anyone in assembly.
    fdPublic                    =   0x0006,     // Accessibly by anyone who has visibility to this scope.    
    // end member access mask

    // field contract attributes.
    fdStatic                    =   0x0010,     // Defined on type, else per instance.
    fdInitOnly                  =   0x0020,     // Field may only be initialized, not written to after init.
    fdLiteral                   =   0x0040,     // Value is compile time constant.
    fdNotSerialized             =   0x0080,     // Field does not have to be serialized when type is remoted.

    fdSpecialName               =   0x0200,     // field is special.  Name describes how.
    
    // interop attributes
    fdPinvokeImpl               =   0x2000,     // Implementation is forwarded through pinvoke.

    // Reserved flags for runtime use only.
    fdReservedMask              =   0xd500,
    fdRTSpecialName             =   0x0400,     // Runtime(metadata internal APIs) should check name encoding.
    fdHasFieldMarshal           =   0x1000,     // Field has marshalling information.
    fdHasSecurity               =   0x4000,     // Field has a security associate.
    fdHasDefault                =   0x8000,     // Field has default.
    fdHasFieldRVA               =   0x0100,     // Field has RVA.
} CorFieldAttr;

// Macros for accessing the members of CorFieldAttr.
#define IsFdPrivateScope(x)                 (((x) & fdFieldAccessMask) == fdPrivateScope)
#define IsFdPrivate(x)                      (((x) & fdFieldAccessMask) == fdPrivate)
#define IsFdFamANDAssem(x)                  (((x) & fdFieldAccessMask) == fdFamANDAssem)
#define IsFdAssembly(x)                     (((x) & fdFieldAccessMask) == fdAssembly)
#define IsFdFamily(x)                       (((x) & fdFieldAccessMask) == fdFamily)
#define IsFdFamORAssem(x)                   (((x) & fdFieldAccessMask) == fdFamORAssem)
#define IsFdPublic(x)                       (((x) & fdFieldAccessMask) == fdPublic)

#define IsFdStatic(x)                       ((x) & fdStatic)
#define IsFdInitOnly(x)                     ((x) & fdInitOnly)
#define IsFdLiteral(x)                      ((x) & fdLiteral)
#define IsFdNotSerialized(x)                ((x) & fdNotSerialized)

#define IsFdPinvokeImpl(x)                  ((x) & fdPinvokeImpl)
#define IsFdSpecialName(x)                  ((x) & fdSpecialName)
#define IsFdHasFieldRVA(x)                  ((x) & fdHasFieldRVA)

#define IsFdRTSpecialName(x)                ((x) & fdRTSpecialName)
#define IsFdHasFieldMarshal(x)              ((x) & fdHasFieldMarshal)
#define IsFdHasSecurity(x)                  ((x) & fdHasSecurity)
#define IsFdHasDefault(x)                   ((x) & fdHasDefault)
#define IsFdHasFieldRVA(x)                  ((x) & fdHasFieldRVA)

// Param attr bits, used by DefineParam. 
typedef enum CorParamAttr
{
    pdIn                        =   0x0001,     // Param is [In]    
    pdOut                       =   0x0002,     // Param is [out]   
    pdLcid                      =   0x0004,     // Param is [lcid]  
    pdRetval                    =   0x0008,     // Param is [Retval]    
    pdOptional                  =   0x0010,     // Param is optional    

    // Reserved flags for Runtime use only.
    pdReservedMask              =   0xf000,
    pdHasDefault                =   0x1000,     // Param has default value.
    pdHasFieldMarshal           =   0x2000,     // Param has FieldMarshal.
    pdReserved3                 =   0x4000,     // reserved bit
    pdReserved4                 =   0x8000      // reserved bit 
} CorParamAttr;

// Macros for accessing the members of CorParamAttr.
#define IsPdIn(x)                           ((x) & pdIn)
#define IsPdOut(x)                          ((x) & pdOut)
#define IsPdLcid(x)                         ((x) & pdLcid)
#define IsPdRetval(x)                       ((x) & pdRetval)
#define IsPdOptional(x)                     ((x) & pdOptional)

#define IsPdHasDefault(x)                   ((x) & pdHasDefault)
#define IsPdHasFieldMarshal(x)              ((x) & pdHasFieldMarshal)


// Property attr bits, used by DefineProperty.
typedef enum CorPropertyAttr
{
    prSpecialName           =   0x0200,     // property is special.  Name describes how.

    // Reserved flags for Runtime use only.
    prReservedMask          =   0xf400,
    prRTSpecialName         =   0x0400,     // Runtime(metadata internal APIs) should check name encoding.
    prHasDefault            =   0x1000,     // Property has default 
    prReserved2             =   0x2000,     // reserved bit
    prReserved3             =   0x4000,     // reserved bit 
    prReserved4             =   0x8000      // reserved bit 
} CorPropertyAttr;

// Macros for accessing the members of CorPropertyAttr.
#define IsPrSpecialName(x)                  ((x) & prSpecialName)

#define IsPrRTSpecialName(x)                ((x) & prRTSpecialName)
#define IsPrHasDefault(x)                   ((x) & prHasDefault)

// Event attr bits, used by DefineEvent.
typedef enum CorEventAttr
{
    evSpecialName           =   0x0200,     // event is special.  Name describes how.

    // Reserved flags for Runtime use only.
    evReservedMask          =   0x0400,
    evRTSpecialName         =   0x0400,     // Runtime(metadata internal APIs) should check name encoding.
} CorEventAttr;

// Macros for accessing the members of CorEventAttr.
#define IsEvSpecialName(x)                  ((x) & evSpecialName)

#define IsEvRTSpecialName(x)                ((x) & evRTSpecialName)


// MethodSemantic attr bits, used by DefineProperty, DefineEvent.
typedef enum CorMethodSemanticsAttr
{
    msSetter    =   0x0001,     // Setter for property  
    msGetter    =   0x0002,     // Getter for property  
    msOther     =   0x0004,     // other method for property or event   
    msAddOn     =   0x0008,     // AddOn method for event   
    msRemoveOn  =   0x0010,     // RemoveOn method for event    
    msFire      =   0x0020,     // Fire method for event    
} CorMethodSemanticsAttr;

// Macros for accessing the members of CorMethodSemanticsAttr.
#define IsMsSetter(x)                       ((x) & msSetter)
#define IsMsGetter(x)                       ((x) & msGetter)
#define IsMsOther(x)                        ((x) & msOther)
#define IsMsAddOn(x)                        ((x) & msAddOn)
#define IsMsRemoveOn(x)                     ((x) & msRemoveOn)
#define IsMsFire(x)                         ((x) & msFire)


// DeclSecurity attr bits, used by DefinePermissionSet.
typedef enum CorDeclSecurity
{
    dclActionMask       =   0x000f,     // Mask allows growth of enum.
    dclActionNil        =   0x0000, 
    dclRequest          =   0x0001,     //  
    dclDemand           =   0x0002,     //  
    dclAssert           =   0x0003,     //  
    dclDeny             =   0x0004,     //  
    dclPermitOnly       =   0x0005,     //  
    dclLinktimeCheck    =   0x0006,     //  
    dclInheritanceCheck =   0x0007,     //  
    dclRequestMinimum   =   0x0008,     //
    dclRequestOptional  =   0x0009,     //
    dclRequestRefuse    =   0x000a,     //
    dclPrejitGrant      =   0x000b,     // Persisted grant set at prejit time
    dclPrejitDenied     =   0x000c,     // Persisted denied set at prejit time
    dclNonCasDemand     =   0x000d,     //
    dclNonCasLinkDemand =   0x000e,
    dclNonCasInheritance=   0x000f,
    dclMaximumValue     =   0x000f,     // Maximum legal value  
} CorDeclSecurity;

// Macros for accessing the members of CorDeclSecurity.
#define IsDclActionNil(x)                   (((x) & dclActionMask) == dclActionNil)
#define IsDclRequest(x)                     (((x) & dclActionMask) == dclRequest)
#define IsDclDemand(x)                      (((x) & dclActionMask) == dclDemand)
#define IsDclAssert(x)                      (((x) & dclActionMask) == dclAssert)
#define IsDclDeny(x)                        (((x) & dclActionMask) == dclDeny)
#define IsDclPermitOnly(x)                  (((x) & dclActionMask) == dclPermit)
#define IsDclLinktimeCheck(x)               (((x) & dclActionMask) == dclLinktimeCheck)
#define IsDclInheritanceCheck(x)            (((x) & dclActionMask) == dclInheritanceCheck)
#define IsDclMaximumValue(x)                (((x) & dclActionMask) == dclMaximumValue)


// MethodImpl attr bits, used by DefineMethodImpl.
typedef enum CorMethodImpl
{
    // code impl mask
    miCodeTypeMask      =   0x0003,   // Flags about code type.   
    miIL                =   0x0000,   // Method impl is IL.   
    miNative            =   0x0001,   // Method impl is native.     
    miOPTIL             =   0x0002,   // Method impl is OPTIL 
    miRuntime           =   0x0003,   // Method impl is provided by the runtime.
    // end code impl mask

    // managed mask
    miManagedMask       =   0x0004,   // Flags specifying whether the code is managed or unmanaged.
    miUnmanaged         =   0x0004,   // Method impl is unmanaged, otherwise managed.
    miManaged           =   0x0000,   // Method impl is managed.
    // end managed mask

    // implementation info and interop
    miForwardRef        =   0x0010,   // Indicates method is defined; used primarily in merge scenarios.
    miOLE               =   0x0080,   // Indicates method sig is mangled to return HRESULT, with retval as param 

    miInternalCall      =   0x1000,   // Reserved for internal use.

    miSynchronized      =   0x0020,   // Method is single threaded through the body.
    miNoInlining        =   0x0008,   // Method may not be inlined.                                      
    miMaxMethodImplVal  =   0xffff,   // Range check value    
} CorMethodImpl; 

// Macros for accesing the members of CorMethodImpl.
#define IsMiIL(x)                           (((x) & miCodeTypeMask) == miIL)
#define IsMiNative(x)                       (((x) & miCodeTypeMask) == miNative)
#define IsMiOPTIL(x)                        (((x) & miCodeTypeMask) == miOPTIL)
#define IsMiRuntime(x)                      (((x) & miCodeTypeMask) == miRuntime)

#define IsMiUnmanaged(x)                    (((x) & miManagedMask) == miUnmanaged)
#define IsMiManaged(x)                      (((x) & miManagedMask) == miManaged)

#define IsMiForwardRef(x)                   ((x) & miForwardRef)
#define IsMiOLE(x)                          ((x) & miOLE)

#define IsMiInternalCall(x)                 ((x) & miInternalCall)

#define IsMiSynchronized(x)                 ((x) & miSynchronized)
#define IsMiNoInlining(x)                   ((x) & miNoInlining)


// PinvokeMap attr bits, used by DefinePinvokeMap.
typedef enum  CorPinvokeMap
{ 
    pmNoMangle          = 0x0001,   // Pinvoke is to use the member name as specified.

    // Use this mask to retrieve the CharSet information.
    pmCharSetMask       = 0x0006,
    pmCharSetNotSpec    = 0x0000,
    pmCharSetAnsi       = 0x0002, 
    pmCharSetUnicode    = 0x0004,
    pmCharSetAuto       = 0x0006,

    pmPinvokeOLE        = 0x0020,   // Heuristic: pinvoke will return hresult, with return value becoming the retval param. Not relevant for fields. 
    pmSupportsLastError = 0x0040,   // Information about target function. Not relevant for fields.

    // None of the calling convention flags is relevant for fields.
    pmCallConvMask      = 0x0700,
    pmCallConvWinapi    = 0x0100,   // Pinvoke will use native callconv appropriate to target windows platform.
    pmCallConvCdecl     = 0x0200,
    pmCallConvStdcall   = 0x0300,
    pmCallConvThiscall  = 0x0400,   // In M9, pinvoke will raise exception.
    pmCallConvFastcall  = 0x0500,
} CorPinvokeMap;

// Macros for accessing the members of CorPinvokeMap
#define IsPmNoMangle(x)                     ((x) & pmNoMangle)

#define IsPmCharSetNotSpec(x)               (((x) & pmCharSetMask) == pmCharSetNotSpec)
#define IsPmCharSetAnsi(x)                  (((x) & pmCharSetMask) == pmCharSetAnsi)
#define IsPmCharSetUnicode(x)               (((x) & pmCharSetMask) == pmCharSetUnicode)
#define IsPmCharSetAuto(x)                  (((x) & pmCharSetMask) == pmCharSetAuto)

#define IsPmPinvokeOLE(x)                   ((x) & pmPinvokeOLE)
#define IsPmSupportsLastError(x)            ((x) & pmSupportsLastError)

#define IsPmCallConvWinapi(x)               (((x) & pmCallConvMask) == pmCallConvWinapi)
#define IsPmCallConvCdecl(x)                (((x) & pmCallConvMask) == pmCallConvCdecl)
#define IsPmCallConvStdcall(x)              (((x) & pmCallConvMask) == pmCallConvStdcall)
#define IsPmCallConvThiscall(x)             (((x) & pmCallConvMask) == pmCallConvThiscall)
#define IsPmCallConvFastcall(x)             (((x) & pmCallConvMask) == pmCallConvFastcall)


// Assembly attr bits, used by DefineAssembly.
typedef enum CorAssemblyFlags
{
    afImplicitComTypes      =   0x0001,     // ComType definitions are implicit within the files.
    afImplicitResources     =   0x0002,     // Resource definitions are implicit within the files.

    afCompatibilityMask     =   0x0070,
    afSideBySideCompatible  =   0x0000,      // The assembly is side by side compatible.
    afNonSideBySideAppDomain=   0x0010,     // The assembly cannot execute with other versions if
                                            // they are executing in the same application domain.
    afNonSideBySideProcess  =   0x0020,     // The assembly cannot execute with other versions if
                                            // they are executing in the same process.
    afNonSideBySideMachine  =   0x0030,     // The assembly cannot execute with other versions if
                                            // they are executing on the same machine.
} CorAssemblyFlags;

// Macros for accessing the members of CorAssemblyFlags.
#define IsAfImplicitComTypes(x)             ((x) & afImplicitComTypes)
#define IsAfImplicitResources(x)            ((x) & afImplicitResources)
#define IsAfSideBySideCompatible(x)         (((x) & afCompatibilityMask) == afSideBySideCompatible)
#define IsAfNonSideBySideAppDomain(x)       (((x) & afCompatibilityMask) == afNonSideBySideAppDomain)
#define IsAfNonSideBySideProcess(x)         (((x) & afCompatibilityMask) == afNonSideBySideProcess)
#define IsAfNonSideBySideMachine(x)         (((x) & afCompatibilityMask) == afNonSideBySideMachine)


// AssemblyRef attr bits, used by DefineAssemblyRef.
typedef enum CorAssemblyRefFlags
{
    arFullOriginator        =   0x0001,     // The assembly ref holds the full (unhashed) originator.
} CorAssemblyRefFlags;

// Macros for accessing the members of CorAssemblyRefFlags.
#define IsArFullOriginator(x)               ((x) & arFullOriginator)


// ManifestResource attr bits, used by DefineManifestResource.
typedef enum CorManifestResourceFlags
{
    mrVisibilityMask        =   0x0007,
    mrPublic                =   0x0001,     // The Resource is exported from the Assembly.
    mrPrivate               =   0x0002,     // The Resource is private to the Assembly.
} CorManifestResourceFlags;

// Macros for accessing the members of CorManifestResourceFlags.
#define IsMrPublic(x)                       (((x) & mrVisibilityMask) == mrPublic)
#define IsMrPrivate(x)                      (((x) & mrVisibilityMask) == mrPrivate)


// File attr bits, used by DefineFile.
typedef enum CorFileFlags
{
    ffContainsMetaData      =   0x0000,     // This is not a resource file
    ffContainsNoMetaData    =   0x0001,     // This is a resource file or other non-metadata-containing file
    ffWriteable             =   0x0002,     // The file is writeable post-build.
} CorFileFlags;

// Macros for accessing the members of CorFileFlags.
#define IsFfContainsMetaData(x)             (!((x) & ffContainsNoMetaData))
#define IsFfContainsNoMetaData(x)           ((x) & ffContainsNoMetaData)
#define IsFfWriteable(x)                    ((x) & ffWriteable)


// structures and enums moved from COR.H
typedef unsigned __int8 COR_SIGNATURE;

typedef COR_SIGNATURE* PCOR_SIGNATURE;      // pointer to a cor sig.  Not void* so that 
                                            // the bytes can be incremented easily  
typedef const COR_SIGNATURE* PCCOR_SIGNATURE;


typedef const char * MDUTF8CSTR;
typedef char * MDUTF8STR;

//*****************************************************************************
//
// Element type for Cor signature
//
//*****************************************************************************

typedef enum CorElementType
{
    ELEMENT_TYPE_END            = 0x0,  
    ELEMENT_TYPE_VOID           = 0x1,  
    ELEMENT_TYPE_BOOLEAN        = 0x2,  
    ELEMENT_TYPE_CHAR           = 0x3,  
    ELEMENT_TYPE_I1             = 0x4,  
    ELEMENT_TYPE_U1             = 0x5, 
    ELEMENT_TYPE_I2             = 0x6,  
    ELEMENT_TYPE_U2             = 0x7,  
    ELEMENT_TYPE_I4             = 0x8,  
    ELEMENT_TYPE_U4             = 0x9,  
    ELEMENT_TYPE_I8             = 0xa,  
    ELEMENT_TYPE_U8             = 0xb,  
    ELEMENT_TYPE_R4             = 0xc,  
    ELEMENT_TYPE_R8             = 0xd,  
    ELEMENT_TYPE_STRING         = 0xe,  

    // every type above PTR will be simple type 
    ELEMENT_TYPE_PTR            = 0xf,      // PTR <type>   
    ELEMENT_TYPE_BYREF          = 0x10,     // BYREF <type> 

    // Please use ELEMENT_TYPE_VALUETYPE. ELEMENT_TYPE_VALUECLASS is deprecated.
    ELEMENT_TYPE_VALUETYPE      = 0x11,     // VALUETYPE <class Token> 
    ELEMENT_TYPE_VALUECLASS     = ELEMENT_TYPE_VALUETYPE, 
    ELEMENT_TYPE_CLASS          = 0x12,     // CLASS <class Token>  

    ELEMENT_TYPE_UNUSED1        = 0x13,
    ELEMENT_TYPE_ARRAY          = 0x14,     // MDARRAY <type> <rank> <bcount> <bound1> ... <lbcount> <lb1> ...  

    ELEMENT_TYPE_COPYCTOR       = 0x15,     // COPYCTOR <type>      // copy construct the argument
    ELEMENT_TYPE_TYPEDBYREF     = 0x16,     // This is a simple type.   

    ELEMENT_TYPE_VALUEARRAY     = 0x17,     // VALUEARRAY <type> <bound>    
    ELEMENT_TYPE_I              = 0x18,     // native integer size  
    ELEMENT_TYPE_U              = 0x19,     // native unsigned integer size 
    ELEMENT_TYPE_R              = 0x1A,     // native real size 
    ELEMENT_TYPE_FNPTR          = 0x1B,     // FNPTR <complete sig for the function including calling convention>
    ELEMENT_TYPE_OBJECT         = 0x1C,     // Shortcut for System.Object
    ELEMENT_TYPE_SZARRAY        = 0x1D,     // Shortcut for single dimension zero lower bound array
                                            // SZARRAY <type>
    ELEMENT_TYPE_GENERICARRAY   = 0x1E,     // Array with unknown rank
                                            // GZARRAY <type>

    // This is only for binding
    ELEMENT_TYPE_CMOD_REQD      = 0x1F,     // required C modifier : E_T_CMOD_REQD <mdTypeRef/mdTypeDef>
    ELEMENT_TYPE_CMOD_OPT       = 0x20,     // optional C modifier : E_T_CMOD_OPT <mdTypeRef/mdTypeDef>

    // Note that this is the max of base type excluding modifiers   
    ELEMENT_TYPE_MAX            = 0x21,     // first invalid element type   

    // These are experimental for internal use only
    ELEMENT_TYPE_VAR            = ELEMENT_TYPE_MAX + 1,     // a type variable VAR <U1> 
    ELEMENT_TYPE_NAME           = ELEMENT_TYPE_MAX + 2,     // class by name NAME <count> <chars>
                                                            // should remove after 9/27/99

    ELEMENT_TYPE_MODIFIER       = 0x40, 
    ELEMENT_TYPE_SENTINEL       = 0x01 | ELEMENT_TYPE_MODIFIER, // sentinel for varargs
    ELEMENT_TYPE_PINNED         = 0x05 | ELEMENT_TYPE_MODIFIER,

} CorElementType;


//*****************************************************************************
//
// Serialization types for Custom attribute support
//
//*****************************************************************************

typedef enum CorSerializationType
{
    SERIALIZATION_TYPE_BOOLEAN      = ELEMENT_TYPE_BOOLEAN,
    SERIALIZATION_TYPE_CHAR         = ELEMENT_TYPE_CHAR,
    SERIALIZATION_TYPE_I1           = ELEMENT_TYPE_I1, 
    SERIALIZATION_TYPE_U1           = ELEMENT_TYPE_U1, 
    SERIALIZATION_TYPE_I2           = ELEMENT_TYPE_I2,  
    SERIALIZATION_TYPE_U2           = ELEMENT_TYPE_U2,  
    SERIALIZATION_TYPE_I4           = ELEMENT_TYPE_I4,  
    SERIALIZATION_TYPE_U4           = ELEMENT_TYPE_U4,  
    SERIALIZATION_TYPE_I8           = ELEMENT_TYPE_I8, 
    SERIALIZATION_TYPE_U8           = ELEMENT_TYPE_U8,  
    SERIALIZATION_TYPE_R4           = ELEMENT_TYPE_R4,  
    SERIALIZATION_TYPE_R8           = ELEMENT_TYPE_R8,  
    SERIALIZATION_TYPE_STRING       = ELEMENT_TYPE_STRING, 
    SERIALIZATION_TYPE_SZARRAY      = ELEMENT_TYPE_SZARRAY, // Shortcut for single dimension zero lower bound array 
    SERIALIZATION_TYPE_TYPE         = 0x50,
    SERIALIZATION_TYPE_VARIANT      = 0x51,
    SERIALIZATION_TYPE_FIELD        = 0x53,
    SERIALIZATION_TYPE_PROPERTY     = 0x54,
    SERIALIZATION_TYPE_ENUM         = 0x55    
} CorSerializationType;

//
// Calling convention flags.
//


typedef enum CorCallingConvention
{
    IMAGE_CEE_CS_CALLCONV_DEFAULT   = 0x0,  

    IMAGE_CEE_CS_CALLCONV_VARARG    = 0x5,  
    IMAGE_CEE_CS_CALLCONV_FIELD     = 0x6,  
    IMAGE_CEE_CS_CALLCONV_LOCAL_SIG = 0x7,
    IMAGE_CEE_CS_CALLCONV_PROPERTY  = 0x8,
    IMAGE_CEE_CS_CALLCONV_UNMGD     = 0x9,
    IMAGE_CEE_CS_CALLCONV_MAX       = 0x10,  // first invalid calling convention    


        // The high bits of the calling convention convey additional info   
    IMAGE_CEE_CS_CALLCONV_MASK      = 0x0f,  // Calling convention is bottom 4 bits 
    IMAGE_CEE_CS_CALLCONV_HASTHIS   = 0x20,  // Top bit indicates a 'this' parameter    
    IMAGE_CEE_CS_CALLCONV_EXPLICITTHIS = 0x40,  // This parameter is explicitly in the signature
} CorCallingConvention;


typedef enum CorUnmanagedCallingConvention
{
    IMAGE_CEE_UNMANAGED_CALLCONV_C         = 0x1,  
    IMAGE_CEE_UNMANAGED_CALLCONV_STDCALL   = 0x2,  
    IMAGE_CEE_UNMANAGED_CALLCONV_THISCALL  = 0x3,  
    IMAGE_CEE_UNMANAGED_CALLCONV_FASTCALL  = 0x4,  

    IMAGE_CEE_CS_CALLCONV_C         = IMAGE_CEE_UNMANAGED_CALLCONV_C,  
    IMAGE_CEE_CS_CALLCONV_STDCALL   = IMAGE_CEE_UNMANAGED_CALLCONV_STDCALL,  
    IMAGE_CEE_CS_CALLCONV_THISCALL  = IMAGE_CEE_UNMANAGED_CALLCONV_THISCALL,  
    IMAGE_CEE_CS_CALLCONV_FASTCALL  = IMAGE_CEE_UNMANAGED_CALLCONV_FASTCALL,  

} CorUnmanagedCallingConvention;


typedef enum CorArgType
{
    IMAGE_CEE_CS_END        = 0x0,
    IMAGE_CEE_CS_VOID       = 0x1,
    IMAGE_CEE_CS_I4         = 0x2,
    IMAGE_CEE_CS_I8         = 0x3,
    IMAGE_CEE_CS_R4         = 0x4,
    IMAGE_CEE_CS_R8         = 0x5,
    IMAGE_CEE_CS_PTR        = 0x6,
    IMAGE_CEE_CS_OBJECT     = 0x7,
    IMAGE_CEE_CS_STRUCT4    = 0x8,
    IMAGE_CEE_CS_STRUCT32   = 0x9,
    IMAGE_CEE_CS_BYVALUE    = 0xA,
} CorArgType;


//*****************************************************************************
//
// Native type for N-Direct
//
//*****************************************************************************

typedef enum CorNativeType
{
    NATIVE_TYPE_END         = 0x0,    //DEPRECATED
    NATIVE_TYPE_VOID        = 0x1,    //DEPRECATED
    NATIVE_TYPE_BOOLEAN     = 0x2,    // (4 byte boolean value: TRUE = non-zero, FALSE = 0)
    NATIVE_TYPE_I1          = 0x3,  
    NATIVE_TYPE_U1          = 0x4,  
    NATIVE_TYPE_I2          = 0x5,  
    NATIVE_TYPE_U2          = 0x6,  
    NATIVE_TYPE_I4          = 0x7,  
    NATIVE_TYPE_U4          = 0x8,  
    NATIVE_TYPE_I8          = 0x9,  
    NATIVE_TYPE_U8          = 0xa,  
    NATIVE_TYPE_R4          = 0xb,  
    NATIVE_TYPE_R8          = 0xc,  
    NATIVE_TYPE_SYSCHAR     = 0xd,    //DEPRECATED 
    NATIVE_TYPE_VARIANT     = 0xe,    //DEPRECATED
    NATIVE_TYPE_CURRENCY    = 0xf,    //DEPRECATED
    NATIVE_TYPE_PTR         = 0x10,   //DEPRECATED  

    NATIVE_TYPE_DECIMAL     = 0x11,   //DEPRECATED
    NATIVE_TYPE_DATE        = 0x12,   //DEPRECATED
    NATIVE_TYPE_BSTR        = 0x13, 
    NATIVE_TYPE_LPSTR       = 0x14, 
    NATIVE_TYPE_LPWSTR      = 0x15, 
    NATIVE_TYPE_LPTSTR      = 0x16, 
    NATIVE_TYPE_FIXEDSYSSTRING  = 0x17, 
    NATIVE_TYPE_OBJECTREF   = 0x18,   //DEPRECATED
    NATIVE_TYPE_IUNKNOWN    = 0x19,
    NATIVE_TYPE_IDISPATCH   = 0x1a,
    NATIVE_TYPE_STRUCT      = 0x1b, 
    NATIVE_TYPE_INTF        = 0x1c, 
    NATIVE_TYPE_SAFEARRAY   = 0x1d, 
    NATIVE_TYPE_FIXEDARRAY  = 0x1e, 
    NATIVE_TYPE_INT         = 0x1f, 
    NATIVE_TYPE_UINT        = 0x20, 

    //@todo: sync up the spec   
    NATIVE_TYPE_NESTEDSTRUCT  = 0x21, //DEPRECATED (use NATIVE_TYPE_STRUCT)   

    NATIVE_TYPE_BYVALSTR    = 0x22,
                              
    NATIVE_TYPE_ANSIBSTR    = 0x23,

    NATIVE_TYPE_TBSTR       = 0x24, // select BSTR or ANSIBSTR depending on platform


    NATIVE_TYPE_VARIANTBOOL = 0x25, // (2-byte boolean value: TRUE = -1, FALSE = 0)
    NATIVE_TYPE_FUNC        = 0x26,
    NATIVE_TYPE_LPVOID      = 0x27, // blind pointer (no deep marshaling)

    NATIVE_TYPE_ASANY       = 0x28,
    NATIVE_TYPE_R           = 0x29, // agnostic floating point

    NATIVE_TYPE_ARRAY       = 0x2a,
    NATIVE_TYPE_LPSTRUCT    = 0x2b,

    NATIVE_TYPE_CUSTOMMARSHALER = 0x2c,  // Custom marshaler native type. This must be followed 
                                         // by a string of the following format:
                                         // "Native type name/0Custom marshaler type name/0Optional cookie/0"
                                         // Or
                                         // "{Native type GUID}/0Custom marshaler type name/0Optional cookie/0"

    NATIVE_TYPE_ERROR       = 0x2d, // This native type coupled with ELEMENT_TYPE_I4 will map to VT_HRESULT

    NATIVE_TYPE_MAX         = 0x50, // first invalid element type   
} CorNativeType;


enum 
{
    DESCR_GROUP_METHODDEF = 0,          // DESCR group for MethodDefs   
    DESCR_GROUP_METHODIMPL,             // DESCR group for MethodImpls  
};

/***********************************************************************************/
// a COR_ILMETHOD_SECT is a generic container for attributes that are private
// to a particular method.  The COR_ILMETHOD structure points to one of these
// (see GetSect()).  COR_ILMETHOD_SECT can decode the Kind of attribute (but not
// its internal data layout, and can skip past the current attibute to find the
// Next one.   The overhead for COR_ILMETHOD_SECT is a minimum of 2 bytes.  

typedef enum CorILMethodSect                             // codes that identify attributes   
{
    CorILMethod_Sect_Reserved    = 0,   
    CorILMethod_Sect_EHTable     = 1,   
    CorILMethod_Sect_OptILTable  = 2,   

    CorILMethod_Sect_KindMask    = 0x3F,        // The mask for decoding the type code  
    CorILMethod_Sect_FatFormat   = 0x40,        // fat format   
    CorILMethod_Sect_MoreSects   = 0x80,        // there is another attribute after this one    
} CorILMethodSect;

/************************************/
/* NOTE this structure must be DWORD aligned!! */

typedef struct IMAGE_COR_ILMETHOD_SECT_SMALL 
{
    BYTE Kind;  
    BYTE DataSize;  
} IMAGE_COR_ILMETHOD_SECT_SMALL;



/************************************/
/* NOTE this structure must be DWORD aligned!! */
typedef struct IMAGE_COR_ILMETHOD_SECT_FAT 
{
    unsigned Kind : 8;  
    unsigned DataSize : 24; 
} IMAGE_COR_ILMETHOD_SECT_FAT;



/***********************************************************************************/
/* If COR_ILMETHOD_SECT_HEADER::Kind() = CorILMethod_Sect_EHTable then the attribute
   is a list of exception handling clauses.  There are two formats, fat or small
*/
typedef enum CorExceptionFlag                       // defintitions for the Flags field below (for both big and small)  
{
    COR_ILEXCEPTION_CLAUSE_NONE,                    // This is a typed handler
    COR_ILEXCEPTION_CLAUSE_OFFSETLEN = 0x0000,      // Deprecated
    COR_ILEXCEPTION_CLAUSE_DEPRECATED = 0x0000,     // Deprecated
    COR_ILEXCEPTION_CLAUSE_FILTER  = 0x0001,        // If this bit is on, then this EH entry is for a filter    
    COR_ILEXCEPTION_CLAUSE_FINALLY = 0x0002,        // This clause is a finally clause  
    COR_ILEXCEPTION_CLAUSE_FAULT = 0x0004,          // Fault clause (finally that is called on exception only)
} CorExceptionFlag;

/***********************************/
// NOTE !!! NOTE 
// This structure should line up with EE_ILEXCEPTION_CLAUSE,
// otherwise you'll have to adjust code in Excep.cpp, re: EHRangeTree 
// NOTE !!! NOTE

typedef struct IMAGE_COR_ILMETHOD_SECT_EH_CLAUSE_FAT
{
    CorExceptionFlag    Flags;  
    DWORD               TryOffset;    
    DWORD               TryLength;      // relative to start of try block
    DWORD               HandlerOffset;
    DWORD               HandlerLength;  // relative to start of handler
    union {
        DWORD           ClassToken;     // use for type-based exception handlers    
        DWORD           FilterOffset;   // use for filter-based exception handlers (COR_ILEXCEPTION_FILTER is set)  
    };
} IMAGE_COR_ILMETHOD_SECT_EH_CLAUSE_FAT;

typedef struct IMAGE_COR_ILMETHOD_SECT_EH_FAT
{
    IMAGE_COR_ILMETHOD_SECT_FAT   SectFat;
    IMAGE_COR_ILMETHOD_SECT_EH_CLAUSE_FAT Clauses[1];     // actually variable size   
} IMAGE_COR_ILMETHOD_SECT_EH_FAT;

/***********************************/
typedef struct IMAGE_COR_ILMETHOD_SECT_EH_CLAUSE_SMALL
{
#ifdef _WIN64
    unsigned            Flags         : 16;
#else // !_WIN64
    CorExceptionFlag    Flags         : 16;
#endif
    unsigned            TryOffset     : 16; 
    unsigned            TryLength     : 8;  // relative to start of try block
    unsigned            HandlerOffset : 16;
    unsigned            HandlerLength : 8;  // relative to start of handler
    union {
        DWORD       ClassToken;
        DWORD       FilterOffset; 
    };
} IMAGE_COR_ILMETHOD_SECT_EH_CLAUSE_SMALL;

/***********************************/
typedef struct IMAGE_COR_ILMETHOD_SECT_EH_SMALL
{
    IMAGE_COR_ILMETHOD_SECT_SMALL SectSmall;
    WORD Reserved;
    IMAGE_COR_ILMETHOD_SECT_EH_CLAUSE_SMALL Clauses[1];   // actually variable size   
} IMAGE_COR_ILMETHOD_SECT_EH_SMALL;



typedef union IMAGE_COR_ILMETHOD_SECT_EH
{
    IMAGE_COR_ILMETHOD_SECT_EH_SMALL Small;   
    IMAGE_COR_ILMETHOD_SECT_EH_FAT Fat;   
} IMAGE_COR_ILMETHOD_SECT_EH;


/***********************************************************************************/
typedef enum CorILMethodFlags
{ 
    CorILMethod_InitLocals      = 0x0010,           // call default constructor on all local vars   
    CorILMethod_MoreSects       = 0x0008,           // there is another attribute after this one    

    CorILMethod_CompressedIL    = 0x0040,           // FIX Remove this and do it on a per Module basis  

        // Indicates the format for the COR_ILMETHOD header 
    CorILMethod_FormatShift     = 3,    
    CorILMethod_FormatMask      = ((1 << CorILMethod_FormatShift) - 1), 
    CorILMethod_TinyFormat      = 0x0002,         // use this code if the code size is even 
    CorILMethod_SmallFormat     = 0x0000,           
    CorILMethod_FatFormat       = 0x0003,   
    CorILMethod_TinyFormat1     = 0x0006,         // use this code if the code size is odd  
} CorILMethodFlags;

/***************************************************************************/
/* Used when the method is tiny (< 64 bytes), and there are no local vars */
typedef struct IMAGE_COR_ILMETHOD_TINY
{
    BYTE Flags_CodeSize;    
} IMAGE_COR_ILMETHOD_TINY;

/************************************/
// This strucuture is the 'fat' layout, where no compression is attempted. 
// Note that this structure can be added on at the end, thus making it extensible
typedef struct IMAGE_COR_ILMETHOD_FAT
{
    unsigned Flags    : 12;     // Flags    
    unsigned Size     :  4;     // size in DWords of this structure (currently 3)   
    unsigned MaxStack : 16;     // maximum number of items (I4, I, I8, obj ...), on the operand stack   
    DWORD   CodeSize;           // size of the code 
    mdSignature   LocalVarSigTok;     // token that indicates the signature of the local vars (0 means none)  
} IMAGE_COR_ILMETHOD_FAT;

typedef union IMAGE_COR_ILMETHOD
{
    IMAGE_COR_ILMETHOD_TINY       Tiny;   
    IMAGE_COR_ILMETHOD_FAT        Fat;    
} IMAGE_COR_ILMETHOD;

//
// Native method descriptor.
//

typedef struct IMAGE_COR_NATIVE_DESCRIPTOR
{
    DWORD       GCInfo; 
    DWORD       EHInfo; 
} IMAGE_COR_NATIVE_DESCRIPTOR;

//@Todo:  this structure is obsoleted by the pdata version right behind it.
// This needs to get deleted as soon as VC/COR are sync'd up.
typedef struct COR_IPMAP_ENTRY
{
    ULONG MethodRVA;    
    ULONG MIHRVA;   
} COR_IPMAP_ENTRY;

typedef struct IMAGE_COR_X86_RUNTIME_FUNCTION_ENTRY 
{
    ULONG       BeginAddress;           // RVA of start of function
    ULONG       EndAddress;             // RVA of end of function
    ULONG       MIH;                    // Associated MIH
} IMAGE_COR_X86_RUNTIME_FUNCTION_ENTRY;

typedef struct IMAGE_COR_MIH_ENTRY
{
    ULONG   EHRVA;  
    ULONG   MethodRVA;  
    mdToken Token;  
    BYTE    Flags;  
    BYTE    CodeManager;    
    BYTE    MIHData[0]; 
} IMAGE_COR_MIH_ENTRY;

//*****************************************************************************
// Non VOS v-table entries.  Define an array of these pointed to by 
// IMAGE_COR20_HEADER.VTableFixups.  Each entry describes a contiguous array of
// v-table slots.  The slots start out initialized to the meta data token value
// for the method they need to call.  At image load time, the COM+ Loader will
// turn each entry into a pointer to machine code for the CPU and can be
// called directly.
//*****************************************************************************

typedef struct IMAGE_COR_VTABLEFIXUP
{
    ULONG       RVA;                    // Offset of v-table array in image.    
    USHORT      Count;                  // How many entries at location.    
    USHORT      Type;                   // COR_VTABLE_xxx type of entries.  
} IMAGE_COR_VTABLEFIXUP;





//*****************************************************************************
//*****************************************************************************
//
// M E T A - D A T A    D E C L A R A T I O N S 
//
//*****************************************************************************
//*****************************************************************************

//*****************************************************************************
//
// Enums for SetOption API.
//
//*****************************************************************************

// flags for MetaDataCheckDuplicatesFor
typedef enum CorCheckDuplicatesFor
{
    MDDupAll                = 0xffffffff,
    MDDupENC                = MDDupAll,
    MDNoDupChecks           = 0x00000000,
    MDDupTypeDef            = 0x00000001,
    MDDupInterfaceImpl      = 0x00000002,
    MDDupMethodDef          = 0x00000004,
    MDDupTypeRef            = 0x00000008,
    MDDupMemberRef          = 0x00000010,
    MDDupCustomValue        = 0x00000020,
    MDDupCustomAttribute    = 0x00000020,   // Alias for custom value.
    MDDupParamDef           = 0x00000040,
    MDDupPermission         = 0x00000080,
    MDDupProperty           = 0x00000100,
    MDDupEvent              = 0x00000200,
    MDDupFieldDef           = 0x00000400,
    MDDupSignature          = 0x00000800,
    MDDupModuleRef          = 0x00001000,
    MDDupTypeSpec           = 0x00002000,
    MDDupImplMap            = 0x00004000,
    MDDupAssemblyRef        = 0x00008000,
    MDDupFile               = 0x00010000,
    MDDupComType            = 0x00020000,
    MDDupManifestResource   = 0x00040000,
    MDDupExecutionLocation  = 0x00080000,
    // gap for debug junk
    MDDupAssembly           = 0x10000000,

    // @todo: These will go away once the MetaData debug tables are gone.
    MDDupSourceFile         = 0x01000000,
    MDDupBlock              = 0x02000000,
    MDDupLocalVarScope      = 0x04000000,
    MDDupLocalVar           = 0x08000000,

    // This is the default behavior on metadata. It will check duplicates for TypeRef, MemberRef, Signature, and TypeSpec
    MDDupDefault = MDNoDupChecks | MDDupTypeRef | MDDupMemberRef | MDDupSignature | MDDupTypeSpec,
} CorCheckDuplicatesFor;

// flags for MetaDataRefToDefCheck
typedef enum CorRefToDefCheck
{
    // default behavior is to always perform TypeRef to TypeDef and MemberRef to MethodDef/FieldDef optimization
    MDRefToDefDefault       = 0x00000003,
    MDRefToDefAll           = 0xffffffff,
    MDRefToDefNone          = 0x00000000,
    MDTypeRefToDef          = 0x00000001,
    MDMemberRefToDef        = 0x00000002
} CorRefToDefCheck;


// MetaDataNotificationForTokenMovement
typedef enum CorNotificationForTokenMovement
{
    // default behavior is to notify TypeRef, MethodDef, MemberRef, and FieldDef token remaps
    MDNotifyDefault         = 0x0000000f,
    MDNotifyAll             = 0xffffffff,
    MDNotifyNone            = 0x00000000,
    MDNotifyMethodDef       = 0x00000001,
    MDNotifyMemberRef       = 0x00000002,
    MDNotifyFieldDef        = 0x00000004,
    MDNotifyTypeRef         = 0x00000008,

    MDNotifyTypeDef         = 0x00000010,
    MDNotifyParamDef        = 0x00000020,
    MDNotifyInterfaceImpl   = 0x00000040,
    MDNotifyProperty        = 0x00000080,
    MDNotifyEvent           = 0x00000100,
    MDNotifySignature       = 0x00000200,
    MDNotifyTypeSpec        = 0x00000400,
    MDNotifyCustomValue     = 0x00000800,
    MDNotifyCustomAttribute = 0x00001000,   // Alias for custom value
    MDNotifySecurityValue   = 0x00002000,
    MDNotifyPermission      = 0x00004000,
    MDNotifyModuleRef       = 0x00008000,
    
    MDNotifyNameSpace       = 0x00010000,
    MDNotifyDebugTokens     = 0x00800000,   // This covers all Debug tokens, bits are expensive :-)

    MDNotifyAssemblyRef     = 0x01000000,
    MDNotifyFile            = 0x02000000,
    MDNotifyComType         = 0x04000000,
    MDNotifyResource        = 0x08000000,
    MDNotifyExecutionLocation = 0x10000000,
} CorNotificationForTokenMovement;


typedef enum CorSetENC
{
    MDSetENCOn              = 0x00000001,   // Deprecated name.
    MDSetENCOff             = 0x00000002,   // Deprecated name.

    MDUpdateENC             = 0x00000001,   // ENC mode.  Tokens don't move; can be updated.
    MDUpdateFull            = 0x00000002,   // "Normal" update mode.
    MDUpdateExtension       = 0x00000003,   // Extension mode.  Tokens don't move, adds only.
    MDUpdateIncremental     = 0x00000004,   // Incremental compilation
    MDUpdateMask            = 0x00000007,

    MDUpdateDelta           = 0x00000008,   // If ENC on, save only deltas.

} CorSetENC;


// flags used in SetOption when pair with MetaDataErrorIfEmitOutOfOrder guid
typedef enum CorErrorIfEmitOutOfOrder
{
    MDErrorOutOfOrderDefault = 0x00000000,  // default not to generate any error
    MDErrorOutOfOrderNone   = 0x00000000,   // do not generate error for out of order emit
    MDErrorOutOfOrderAll    = 0xffffffff,   // generate out of order emit for method, field, param, property, and event
    MDMethodOutOfOrder      = 0x00000001,   // generate error when methods are emitted out of order
    MDFieldOutOfOrder       = 0x00000002,   // generate error when fields are emitted out of order
    MDParamOutOfOrder       = 0x00000004,   // generate error when params are emitted out of order
    MDPropertyOutOfOrder    = 0x00000008,   // generate error when properties are emitted out of order
    MDEventOutOfOrder       = 0x00000010,   // generate error when events are emitted out of order
} CorErrorIfEmitOutOfOrder;


// flags used in SetOption when pair with MetaDataImportOption guid
typedef enum CorImportOptions
{
    MDImportOptionDefault       = 0x00000000,   // default to skip over deleted records
    MDImportOptionAll           = 0xFFFFFFFF,   // Enumerate everything
    MDImportOptionAllTypeDefs   = 0x00000001,   // all of the typedefs including the deleted typedef
    MDImportOptionAllMethodDefs = 0x00000002,   // all of the methoddefs including the deleted ones
    MDImportOptionAllFieldDefs  = 0x00000004,   // all of the fielddefs including the deleted ones
    MDImportOptionAllProperties = 0x00000008,   // all of the properties including the deleted ones
    MDImportOptionAllEvents     = 0x00000010,   // all of the events including the deleted ones
    MDImportOptionAllCustomValues = 0x00000020, // all of the customvalues including the deleted ones
    MDImportOptionAllCustomAttributes = 0x00000020, // all of the customvalues including the deleted ones
    MDImportOptionAllComTypes   = 0x00000040,   // all of the ComTypes including the deleted ones

} CorImportOptions;


// flags for MetaDataThreadSafetyOptions
typedef enum CorThreadSafetyOptions
{
    // default behavior is to have thread safety turn off. This means that MetaData APIs will not take reader/writer
    // lock. Clients is responsible to make sure the properly thread synchornization when using MetaData APIs.
    MDThreadSafetyDefault   = 0x00000000,
    MDThreadSafetyOff       = 0x00000000,
    MDThreadSafetyOn        = 0x00000001,
} CorThreadSafetyOptions;


// 
// struct used to retrieve field offset
// used by GetClassLayout and SetClassLayout
//
typedef struct COR_FIELD_OFFSET
{
    mdFieldDef  ridOfField; 
    ULONG       ulOffset;   
} COR_FIELD_OFFSET;

typedef struct IMAGE_COR_FIXUPENTRY
{
    ULONG ulRVA;    
    ULONG Count;    
} IMAGE_COR_FIXUPENTRY;


//
// Token tags.
//
typedef enum CorTokenType
{
    mdtModule               = 0x00000000,       //          
    mdtTypeRef              = 0x01000000,       //          
    mdtTypeDef              = 0x02000000,       //          
    mdtFieldDef             = 0x04000000,       //           
    mdtMethodDef            = 0x06000000,       //       
    mdtParamDef             = 0x08000000,       //           
    mdtInterfaceImpl        = 0x09000000,       //  
    mdtMemberRef            = 0x0a000000,       //       
    mdtCustomAttribute      = 0x0c000000,       //      
    mdtCustomValue          = mdtCustomAttribute,       //      
    mdtPermission           = 0x0e000000,       //       
    mdtSignature            = 0x11000000,       //       
    mdtEvent                = 0x14000000,       //           
    mdtProperty             = 0x17000000,       //           
    mdtModuleRef            = 0x1a000000,       //       
    mdtTypeSpec             = 0x1b000000,       //           
    mdtAssembly             = 0x20000000,       //
    mdtAssemblyRef          = 0x23000000,       //
    mdtFile                 = 0x26000000,       //
    mdtComType              = 0x27000000,       //
    mdtManifestResource     = 0x28000000,       //
    mdtExecutionLocation    = 0x29000000,       //

    mdtSourceFile           = 0x2a000000,       //       
    mdtLocalVarScope        = 0x2c000000,       //   
    mdtLocalVar             = 0x2d000000,       //           

    mdtString               = 0x70000000,       //          
    mdtName                 = 0x71000000,       //
    mdtBaseType             = 0x72000000,       // Leave this on the high end value. This does not correspond to metadata table
} CorTokenType;

//
// Build / decompose tokens.
//
#define RidToToken(rid,tktype) ((rid) |= (tktype))
#define TokenFromRid(rid,tktype) ((rid) | (tktype))
#define RidFromToken(tk) ((RID) ((tk) & 0x00ffffff))
#define TypeFromToken(tk) ((ULONG32)((tk) & 0xff000000))
#define IsNilToken(tk) ((RidFromToken(tk)) == 0)

//
// Nil tokens
//
#define mdTokenNil                  ((mdToken)0)
#define mdModuleNil                 ((mdModule)mdtModule)               
#define mdTypeRefNil                ((mdTypeRef)mdtTypeRef)             
#define mdTypeDefNil                ((mdTypeDef)mdtTypeDef)             
#define mdFieldDefNil               ((mdFieldDef)mdtFieldDef)           
#define mdMethodDefNil              ((mdMethodDef)mdtMethodDef)         
#define mdParamDefNil               ((mdParamDef)mdtParamDef)           
#define mdInterfaceImplNil          ((mdInterfaceImpl)mdtInterfaceImpl)     
#define mdMemberRefNil              ((mdMemberRef)mdtMemberRef)         
#define mdCustomAttributeNil        ((mdCustomValue)mdtCustomAttribute)         
#define mdCustomValueNil            ((mdCustomAttribute)mdtCustomAttribute)         
#define mdPermissionNil             ((mdPermission)mdtPermission)           
#define mdSignatureNil              ((mdSignature)mdtSignature)         
#define mdEventNil                  ((mdEvent)mdtEvent)             
#define mdPropertyNil               ((mdProperty)mdtProperty)           
#define mdModuleRefNil              ((mdModuleRef)mdtModuleRef)         
#define mdTypeSpecNil               ((mdTypeSpec)mdtTypeSpec)           
#define mdAssemblyNil               ((mdAssembly)mdtAssembly)
#define mdAssemblyRefNil            ((mdAssemblyRef)mdtAssemblyRef)
#define mdFileNil                   ((mdFile)mdtFile)
#define mdComTypeNil                ((mdComType)mdtComType)
#define mdManifestResourceNil       ((mdManifestResource)mdtManifestResource)
#define mdExecutionLocationNil      ((mdExecutionLocation)mdtExecutionLocation)

#define mdSourceFileNil             ((mdSourceFile)mdtSourceFile)           
#define mdLocalVarScopeNil          ((mdLocalVarScope)mdtLocalVarScope)     
#define mdLocalVarNil               ((mdLocalVar)mdtLocalVar)           

#define mdStringNil                 ((mdString)mdtString)               

//
// Open bits.
//
typedef enum CorOpenFlags
{
    ofRead      =   0x00000000,     // Open scope for read
    ofWrite     =   0x00000001,     // Open scope for write.
    ofCopyMemory =  0x00000002,     // Open scope with memory. Ask metadata to maintain its own copy of memory.
    ofCacheImage =  0x00000004,     // EE maps but does not do relocations or verify image
    ofNoTypeLib =   0x00000080,     // Don't OpenScope on a typelib.
} CorOpenFlags;


typedef enum CorBaseType    // TokenFromRid(X,Y) replaced with (X | Y)
{
    mdtBaseType_BOOLEAN        = ( ELEMENT_TYPE_BOOLEAN | mdtBaseType ),  
    mdtBaseType_CHAR           = ( ELEMENT_TYPE_CHAR    | mdtBaseType ),
    mdtBaseType_I1             = ( ELEMENT_TYPE_I1      | mdtBaseType ), 
    mdtBaseType_U1             = ( ELEMENT_TYPE_U1      | mdtBaseType ),
    mdtBaseType_I2             = ( ELEMENT_TYPE_I2      | mdtBaseType ),  
    mdtBaseType_U2             = ( ELEMENT_TYPE_U2      | mdtBaseType ),  
    mdtBaseType_I4             = ( ELEMENT_TYPE_I4      | mdtBaseType ),  
    mdtBaseType_U4             = ( ELEMENT_TYPE_U4      | mdtBaseType ),  
    mdtBaseType_I8             = ( ELEMENT_TYPE_I8      | mdtBaseType ),  
    mdtBaseType_U8             = ( ELEMENT_TYPE_U8      | mdtBaseType ),  
    mdtBaseType_R4             = ( ELEMENT_TYPE_R4      | mdtBaseType ),  
    mdtBaseType_R8             = ( ELEMENT_TYPE_R8      | mdtBaseType ),  
    mdtBaseType_STRING         = ( ELEMENT_TYPE_STRING  | mdtBaseType ),
    mdtBaseType_I              = ( ELEMENT_TYPE_I       | mdtBaseType ),    
    mdtBaseType_U              = ( ELEMENT_TYPE_U       | mdtBaseType ),    
    mdtBaseType_R              = ( ELEMENT_TYPE_R       | mdtBaseType ),    
} CorBaseType;


typedef CorTypeAttr CorRegTypeAttr;

//
// Opaque type for an enumeration handle.
//
typedef void *HCORENUM;


// Note that this must be kept in sync with System.AttributeTargets.
typedef enum CorAttributeTargets
{
    catAssembly      = 0x0001,
    catModule        = 0x0002,
    catClass         = 0x0004,
    catStruct        = 0x0008,
    catEnum          = 0x0010,
    catConstructor   = 0x0020,
    catMethod        = 0x0040,
    catProperty      = 0x0080,
    catField         = 0x0100,
    catEvent         = 0x0200,
    catInterface     = 0x0400,
    catParameter     = 0x0800,
    catDelegate      = 0x1000,

    catAll           = catAssembly | catModule | catClass | catStruct | catEnum | catConstructor | 
                    catMethod | catProperty | catField | catEvent | catInterface | catParameter | catDelegate,
    catClassMembers  = catClass | catStruct | catEnum | catConstructor | catMethod | catProperty | catField | catEvent | catDelegate | catInterface,
    
} CorAttributeTargets;

//
// Some well-known custom attributes 
//
#ifndef MACROS_NOT_SUPPORTED

 #ifndef IMAGE_CEE_CS_CALLCONV_DEFAULT_HASTHIS
  #define IMAGE_CEE_CS_CALLCONV_DEFAULT_HASTHIS (IMAGE_CEE_CS_CALLCONV_DEFAULT | IMAGE_CEE_CS_CALLCONV_HASTHIS)
 #endif

#define INTEROP_DISPID_TYPE_W                   L"System.Runtime.InteropServices.DispIdAttribute"
#define INTEROP_DISPID_TYPE                     "System.Runtime.InteropServices.DispIdAttribute"
#define INTEROP_DISPID_SIG                      {IMAGE_CEE_CS_CALLCONV_DEFAULT_HASTHIS, 1, ELEMENT_TYPE_VOID, ELEMENT_TYPE_I4}

#define INTEROP_INTERFACETYPE_TYPE_W            L"System.Runtime.InteropServices.InterfaceTypeAttribute"
#define INTEROP_INTERFACETYPE_TYPE              "System.Runtime.InteropServices.InterfaceTypeAttribute"
#define INTEROP_INTERFACETYPE_SIG               {IMAGE_CEE_CS_CALLCONV_DEFAULT_HASTHIS, 1, ELEMENT_TYPE_VOID, ELEMENT_TYPE_I2}

#define INTEROP_HASDEFAULTIFACE_TYPE_W          L"System.Runtime.InteropServices.HasDefaultInterfaceAttribute"
#define INTEROP_HASDEFAULTIFACE_TYPE            "System.Runtime.InteropServices.HasDefaultInterfaceAttribute"
#define INTEROP_HASDEFAULTIFACE_SIG             {IMAGE_CEE_CS_CALLCONV_DEFAULT_HASTHIS, 0, ELEMENT_TYPE_VOID}

#define INTEROP_COMVISIBLE_TYPE_W               L"System.Runtime.InteropServices.ComVisibleAttribute"
#define INTEROP_COMVISIBLE_TYPE                 "System.Runtime.InteropServices.ComVisibleAttribute"
#define INTEROP_COMVISIBLE_SIG                  {IMAGE_CEE_CS_CALLCONV_DEFAULT_HASTHIS, 0, ELEMENT_TYPE_BOOLEAN}

#define INTEROP_NOCOMREGISTRATION_TYPE_W        L"System.Runtime.InteropServices.NoComRegistrationAttribute"
#define INTEROP_NOCOMREGISTRATION_TYPE          "System.Runtime.InteropServices.NoComRegistrationAttribute"
#define INTEROP_NOCOMREGISTRATION_SIG           {IMAGE_CEE_CS_CALLCONV_DEFAULT_HASTHIS, 0, ELEMENT_TYPE_VOID}

#define INTEROP_COMREGISTERFUNCTION_TYPE_W      L"System.Runtime.InteropServices.ComRegisterFunctionAttribute"
#define INTEROP_COMREGISTERFUNCTION_TYPE        "System.Runtime.InteropServices.ComRegisterFunctionAttribute"
#define INTEROP_COMREGISTERFUNCTION_SIG         {IMAGE_CEE_CS_CALLCONV_DEFAULT_HASTHIS, 0, ELEMENT_TYPE_VOID}
#define INTEROP_COMUNREGISTERFUNCTION_TYPE_W    L"System.Runtime.InteropServices.ComUnregisterFunctionAttribute"
#define INTEROP_COMUNREGISTERFUNCTION_TYPE      "System.Runtime.InteropServices.ComUnregisterFunctionAttribute"
#define INTEROP_COMUNREGISTERFUNCTION_SIG       {IMAGE_CEE_CS_CALLCONV_DEFAULT_HASTHIS, 0, ELEMENT_TYPE_VOID}

#define INTEROP_IMPORTEDFROMTYPELIB_TYPE_W      L"System.Runtime.InteropServices.ImportedFromTypeLibAttribute"
#define INTEROP_IMPORTEDFROMTYPELIB_TYPE        "System.Runtime.InteropServices.ImportedFromTypeLibAttribute"
#define INTEROP_IMPORTEDFROMTYPELIB_SIG         {IMAGE_CEE_CS_CALLCONV_DEFAULT_HASTHIS, 1, ELEMENT_TYPE_VOID, ELEMENT_TYPE_STRING}

#define INTEROP_NOIDISPATCH_TYPE_W              L"System.Runtime.InteropServices.NoIDispatchAttribute"
#define INTEROP_NOIDISPATCH_TYPE                "System.Runtime.InteropServices.NoIDispatchAttribute"
#define INTEROP_NOIDISPATCH_SIG                 {IMAGE_CEE_CS_CALLCONV_DEFAULT_HASTHIS, 0, ELEMENT_TYPE_VOID}

#define INTEROP_IDISPATCHIMPL_TYPE_W            L"System.Runtime.InteropServices.IDispatchImplAttribute"
#define INTEROP_IDISPATCHIMPL_TYPE              "System.Runtime.InteropServices.IDispatchImplAttribute"
#define INTEROP_IDISPATCHIMPL_SIG               {IMAGE_CEE_CS_CALLCONV_DEFAULT_HASTHIS, 1, ELEMENT_TYPE_VOID, ELEMENT_TYPE_I2}

#define INTEROP_COMSOURCEINTERFACES_TYPE_W      L"System.Runtime.InteropServices.ComSourceInterfacesAttribute"
#define INTEROP_COMSOURCEINTERFACES_TYPE        "System.Runtime.InteropServices.ComSourceInterfacesAttribute"
#define INTEROP_COMSOURCEINTERFACES_SIG         {IMAGE_CEE_CS_CALLCONV_DEFAULT_HASTHIS, 1, ELEMENT_TYPE_VOID, ELEMENT_TYPE_STRING}

#define INTEROP_COMCONVERSIONLOSS_TYPE_W        L"System.Runtime.InteropServices.ComConversionLossAttribute"
#define INTEROP_COMCONVERSIONLOSS_TYPE          "System.Runtime.InteropServices.ComConversionLossAttribute"
#define INTEROP_COMCONVERSIONLOSS_SIG           {IMAGE_CEE_CS_CALLCONV_DEFAULT_HASTHIS, 0, ELEMENT_TYPE_VOID}

//@todo: remove this definition, also from BCL
#define INTEROP_GLOBALOBJECT_TYPE_W             L"System.Runtime.InteropServices.GlobalObjectAttribute"
#define INTEROP_GLOBALOBJECT_TYPE               "System.Runtime.InteropServices.GlobalObjectAttribute"
#define INTEROP_GLOBALOBJECT_SIG                {IMAGE_CEE_CS_CALLCONV_DEFAULT_HASTHIS, 0, ELEMENT_TYPE_VOID}

//@todo: remove this definition, also from BCL
#define INTEROP_PREDECLARED_TYPE_W              L"System.Runtime.InteropServices.PredeclaredAttribute"
#define INTEROP_PREDECLARED_TYPE                "System.Runtime.InteropServices.PredeclaredAttribute"
#define INTEROP_PREDECLARED_SIG                 {IMAGE_CEE_CS_CALLCONV_DEFAULT_HASTHIS, 0, ELEMENT_TYPE_VOID}

#define INTEROP_TYPELIBTYPE_TYPE_W              L"System.Runtime.InteropServices.TypeLibTypeAttribute"
#define INTEROP_TYPELIBTYPE_TYPE                "System.Runtime.InteropServices.TypeLibTypeAttribute"
#define INTEROP_TYPELIBTYPE_SIG                 {IMAGE_CEE_CS_CALLCONV_DEFAULT_HASTHIS, 1, ELEMENT_TYPE_VOID, ELEMENT_TYPE_I2}

#define INTEROP_TYPELIBFUNC_TYPE_W              L"System.Runtime.InteropServices.TypeLibFuncAttribute"
#define INTEROP_TYPELIBFUNC_TYPE                "System.Runtime.InteropServices.TypeLibFuncAttribute"
#define INTEROP_TYPELIBFUNC_SIG                 {IMAGE_CEE_CS_CALLCONV_DEFAULT_HASTHIS, 1, ELEMENT_TYPE_VOID, ELEMENT_TYPE_I2}

#define INTEROP_TYPELIBVAR_TYPE_W               L"System.Runtime.InteropServices.TypeLibVarAttribute"
#define INTEROP_TYPELIBVAR_TYPE                 "System.Runtime.InteropServices.TypeLibVarAttribute"
#define INTEROP_TYPELIBVAR_SIG                  {IMAGE_CEE_CS_CALLCONV_DEFAULT_HASTHIS, 1, ELEMENT_TYPE_VOID, ELEMENT_TYPE_I2}

#define INTEROP_MARSHALAS_TYPE_W                L"System.Runtime.InteropServices.MarshalAsAttribute"
#define INTEROP_MARSHALAS_TYPE                  "System.Runtime.InteropServices.MarshalAsAttribute"
#define INTEROP_MARSHALAS_SIG                   {IMAGE_CEE_CS_CALLCONV_DEFAULT_HASTHIS, 1, ELEMENT_TYPE_VOID, ELEMENT_TYPE_I2}

#define INTEROP_COMIMPORT_TYPE_W                L"System.Runtime.InteropServices.ComImportAttribute"
#define INTEROP_COMIMPORT_TYPE                  "System.Runtime.InteropServices.ComImportAttribute"
#define INTEROP_COMIMPORT_SIG                   {IMAGE_CEE_CS_CALLCONV_DEFAULT_HASTHIS, 0, ELEMENT_TYPE_VOID}

#define INTEROP_GUID_TYPE_W                     L"System.Runtime.InteropServices.GuidAttribute"
#define INTEROP_GUID_TYPE                       "System.Runtime.InteropServices.GuidAttribute"
#define INTEROP_GUID_SIG                        {IMAGE_CEE_CS_CALLCONV_DEFAULT_HASTHIS, 1, ELEMENT_TYPE_VOID, ELEMENT_TYPE_STRING}

#define INTEROP_DEFAULTMEMBER_TYPE_W            L"System.Reflection.DefaultMemberAttribute"
#define INTEROP_DEFAULTMEMBER_TYPE              "System.Reflection.DefaultMemberAttribute"
#define INTEROP_DEFAULTMEMBER_SIG               {IMAGE_CEE_CS_CALLCONV_DEFAULT_HASTHIS, 1, ELEMENT_TYPE_VOID, ELEMENT_TYPE_STRING}

#define INTEROP_COMEMULATE_TYPE_W               L"System.Runtime.InteropServices.ComEmulateAttribute"
#define INTEROP_COMEMULATE_TYPE                 "System.Runtime.InteropServices.ComEmulateAttribute"
#define INTEROP_COMEMULATE_SIG                  {IMAGE_CEE_CS_CALLCONV_DEFAULT_HASTHIS, 1, ELEMENT_TYPE_VOID, ELEMENT_TYPE_STRING}

#define INTEROP_EXPOSEHRESULT_TYPE_W            L"System.Runtime.InteropServices.ExposeHResultAttribute"
#define INTEROP_EXPOSEHRESULT_TYPE              "System.Runtime.InteropServices.ExposeHResultAttribute"
#define INTEROP_EXPOSEHRESULT_SIG               {IMAGE_CEE_CS_CALLCONV_DEFAULT_HASTHIS, 0, ELEMENT_TYPE_BOOLEAN}

#define INTEROP_PRESERVESIG_TYPE_W              L"System.Runtime.InteropServices.PreserveSigAttribure"
#define INTEROP_PRESERVESIG_TYPE                "System.Runtime.InteropServices.PreserveSigAttribure"
#define INTEROP_PRESERVESIG_SIG                 {IMAGE_CEE_CS_CALLCONV_DEFAULT_HASTHIS, 0, ELEMENT_TYPE_BOOLEAN}

#define INTEROP_IN_TYPE_W                       L"System.Runtime.InteropServices.InAttribute"
#define INTEROP_IN_TYPE                         "System.Runtime.InteropServices.InAttribute"
#define INTEROP_IN_SIG                          {IMAGE_CEE_CS_CALLCONV_DEFAULT_HASTHIS, 0, ELEMENT_TYPE_VOID}

#define INTEROP_OUT_TYPE_W                      L"System.Runtime.InteropServices.OutAttribute"
#define INTEROP_OUT_TYPE                        "System.Runtime.InteropServices.OutAttribute"
#define INTEROP_OUT_SIG                         {IMAGE_CEE_CS_CALLCONV_DEFAULT_HASTHIS, 0, ELEMENT_TYPE_VOID}

#define INTEROP_COMALIASNAME_TYPE_W             L"System.Runtime.InteropServices.ComAliasNameAttribute"
#define INTEROP_COMALIASNAME_TYPE               "System.Runtime.InteropServices.ComAliasNameAttribute"
#define INTEROP_COMALIASNAME_SIG                {IMAGE_CEE_CS_CALLCONV_DEFAULT_HASTHIS, 1, ELEMENT_TYPE_VOID, ELEMENT_TYPE_STRING}

#define INTEROP_PARAMARRAY_TYPE_W               L"System.ParamArrayAttribute"
#define INTEROP_PARAMARRAY_TYPE                 "System.ParamArrayAttribute"
#define INTEROP_PARAMARRAY_SIG                  {IMAGE_CEE_CS_CALLCONV_DEFAULT_HASTHIS, 0, ELEMENT_TYPE_VOID}

#define DEFAULTDOMAIN_STA_TYPE_W                L"System.STAThreadAttribute"                                
#define DEFAULTDOMAIN_STA_TYPE                   "System.STAThreadAttribute"                                 
#define DEFAULTDOMAIN_STA_SIG                   {IMAGE_CEE_CS_CALLCONV_DEFAULT_HASTHIS, 0, ELEMENT_TYPE_VOID}

#define DEFAULTDOMAIN_MTA_TYPE_W                L"System.MTAThreadAttribute"                                
#define DEFAULTDOMAIN_MTA_TYPE                   "System.MTAThreadAttribute"                                 
#define DEFAULTDOMAIN_MTA_SIG                   {IMAGE_CEE_CS_CALLCONV_DEFAULT_HASTHIS, 0, ELEMENT_TYPE_VOID}

#define DEFAULTDOMAIN_LOADEROPTIMIZATION_TYPE_W L"System.LoaderOptimizationAttribute"
#define DEFAULTDOMAIN_LOADEROPTIMIZATION_TYPE    "System.LoaderOptimizationAttribute"
      
#define DEFAULTDOMAIN_LOADEROPTIMIZATION_SIG    {IMAGE_CEE_CS_CALLCONV_DEFAULT_HASTHIS, 1, ELEMENT_TYPE_VOID, ELEMENT_TYPE_I1}

#define CMOD_CALLCONV_NAMESPACE                 "System.Runtime.InteropServices"
#define CMOD_CALLCONV_NAME_CDECL                "CallConvCdecl"
#define CMOD_CALLCONV_NAME_STDCALL              "CallConvStdcall"
#define CMOD_CALLCONV_NAME_THISCALL             "CallConvThiscall"
#define CMOD_CALLCONV_NAME_FASTCALL             "CallConvFastcall"

#endif // MACROS_NOT_SUPPORTED

//
// GetSaveSize accuracy
//
#ifndef _CORSAVESIZE_DEFINED_
#define _CORSAVESIZE_DEFINED_
typedef enum CorSaveSize
{
    cssAccurate             = 0x0000,               // Find exact save size, accurate but slower.
    cssQuick                = 0x0001,               // Estimate save size, may pad estimate, but faster.
    cssDiscardTransientCAs  = 0x0002,               // remove all of the CAs of discardable types
} CorSaveSize;
#endif

typedef unsigned __int64 CLASSVERSION;

#define COR_IS_METHOD_MANAGED_IL(flags)         ((flags & 0xf) == (miIL | miManaged))   
#define COR_IS_METHOD_MANAGED_OPTIL(flags)      ((flags & 0xf) == (miOPTIL | miManaged))    
#define COR_IS_METHOD_MANAGED_NATIVE(flags)     ((flags & 0xf) == (miNative | miManaged))   
#define COR_IS_METHOD_UNMANAGED_NATIVE(flags)   ((flags & 0xf) == (miNative | miUnmanaged)) 
#define COR_IS_METHOD_IAT(flags)                (flags & miIAT) 


//
// Opaque types for security properties and values.
//
typedef void  *  PSECURITY_PROPS ;
typedef void  *  PSECURITY_VALUE ;
typedef void ** PPSECURITY_PROPS ;
typedef void ** PPSECURITY_VALUE ;

//-------------------------------------
//--- Security data structures
//-------------------------------------

// Descriptor for a single security custom attribute.
typedef struct COR_SECATTR {
    mdMemberRef     tkCtor;         // Ref to constructor of security attribute.
    const void      *pCustomValue;  // Blob describing ctor args and field/property values.
    ULONG           cbCustomValue;  // Length of the above blob.
} COR_SECATTR;

#endif // __CORHDR_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\public\internal\com\inc\isltrack.h ===
#ifndef _ISLTRACK_H_
#define _ISLTRACK_H_

#if defined(ENABLE_TRACK)

//===========================================================================
//
// Interface: IShellLinkTracker
//
//  The IShellLinkTracker interface is used to access the ShellLink's
// CTracker object.  For example, Monikers call this interface to set
// the creation flags in the CTracker.
//
//
// [Member functions]
//
//    Initialize
//          This function is called to set the Creation Flags on
//          a ShellLinkTracker object
//
//          Parameters: [DWORD] dwCreationFlags
//
//    GetTrackFlags
//          This function is used to get the creation flags (known externally
//          as "track flags").
//  
//          Parameters: [DWORD *] pdwTrackFlags
//
//    Resolve
//          This function resolves the shell link, searching for the
//          link if necessary.
//
//          Parameters: [HWND] hwnd
//                          -   The window of the caller (can be GetDesktopWindow()).
//                      [DWORD] fFlags
//                          -   Flags to control the Resolve, from the SLR_ enumeration.
//                      [DWORD] dwRestricted
//                          -   Track Flags to be OR-ed with the ShellLink object's
//                              internal Track Flags (a.k.a. Creation Flags).
//                      [DWORD] dwTickCountDeadline
//                          -   The maximum amount of time, in milliseconds, for
//                              which a search should execute (if a search is necessary).
//                      
//
//===========================================================================

#undef  INTERFACE
#define INTERFACE   IShellLinkTracker

DECLARE_INTERFACE_(IShellLinkTracker, IUnknown)
{
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID * ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;


    // *** IShellLinkTracker methods ***
    STDMETHOD(Initialize)(THIS_
                          DWORD dwTrackFlags) PURE;
    STDMETHOD(GetTrackFlags)(THIS_
                             DWORD * pdwTrackFlags) PURE;
    STDMETHOD(Resolve)(THIS_
                       HWND        hwnd,
                       DWORD       fFlags,
                       DWORD       dwRestriction,
                       DWORD       dwTickCountDeadline,
                       DWORD       dwReserved ) PURE;


};


typedef IShellLinkTracker * LPSHELLLINKTRACKER;

DEFINE_GUID(IID_IShellLinkTracker, 0x5E35D200L, 0xF3BB, 0x11CE, 0x9B, 0xDB, 0x00, 0xAA, 0x00, 0x4C, 0xD0, 0x1A);

#endif  // _CAIRO_
#endif  // _ISLTRACK_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\public\internal\com\inc\ntrpcp.h ===
/*++

Copyright (c) 1990,91  Microsoft Corporation

Module Name:

    ntrpcp.h

Abstract:

    This file contains prototypes for commonly used RPC functionality.
    This includes: bind/unbind functions, MIDL user alloc/free functions,
    and server start/stop functions.

Author:

    Dan Lafferty danl 06-Feb-1991

Environment:

    User Mode - Win32

Revision History:

    06-Feb-1991     danl
        Created

    26-Apr-1991 JohnRo
        Added IN and OUT keywords to MIDL functions.  Commented-out
        (nonstandard) identifier on endif.  Deleted tabs.

    03-July-1991    JimK
        Commonly used aspects copied from LM specific file.

--*/
#ifndef _NTRPCP_
#define _NTRPCP_

#include <nt.h>
#include <ntrtl.h>          // needed for nturtl.h
#include <nturtl.h>
#include <windows.h>        // win32 typedefs
#include <rpc.h>

#ifdef __cplusplus
extern "C" {
#endif

//
// DEFINES
//



//
// Function Prototypes - routines called by MIDL-generated code:
//

void *
MIDL_user_allocate(
    IN size_t NumBytes
    );

void
MIDL_user_free(
    IN void *MemPointer
    );

//
// Function Prototypes - routines to go along with the above, but aren't
// needed by MIDL or any other non-network software.
//

void *
MIDL_user_reallocate(
    IN void * OldPointer OPTIONAL,
    IN size_t NewByteCount
    );

unsigned long
MIDL_user_size(
    IN void * Pointer
    );

//
// client side functions
//


NTSTATUS
RpcpBindRpc(
    IN  LPWSTR               servername,
    IN  LPWSTR               servicename,
    IN  LPWSTR               networkoptions,
    OUT RPC_BINDING_HANDLE   * pBindingHandle
    );

NTSTATUS
RpcpUnbindRpc(
    IN  RPC_BINDING_HANDLE BindingHandle
    );



//
// server side functions
//

DWORD
RpcpInitRpcServer(
    VOID
    );

NTSTATUS
RpcpAddInterface(
    IN  LPWSTR              InterfaceName,
    IN  RPC_IF_HANDLE       InterfaceSpecification
    );

NTSTATUS
RpcpStartRpcServer(
    IN  LPWSTR              InterfaceName,
    IN  RPC_IF_HANDLE       InterfaceSpecification
    );

NTSTATUS
RpcpDeleteInterface(
    IN  RPC_IF_HANDLE      InterfaceSpecification
    );

NTSTATUS
RpcpStopRpcServer(
    IN  RPC_IF_HANDLE      InterfaceSpecification
    );

NTSTATUS
RpcpStopRpcServerEx(
    IN  RPC_IF_HANDLE      InterfaceSpecification
    );

#ifdef __cplusplus
}
#endif

#endif // _NTRPCP_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\public\internal\com\inc\olechar.h ===
//+======================================================
//
//  File:       olechar.h
//
//  Purpose:    Provide wrappers for string-related
//              functions so that the Ansi or Unicode function
//              is called, whichever is appropriate for the
//              current OLECHAR definition.
//
//              This file is similar to "tchar.h", except
//              that it covers OLECHARs rather than TCHARs.
//
//+======================================================


#ifndef _OLECHAR_H_
#define _OLECHAR_H_

//#include <objbase.h>

#ifdef OLE2ANSI

#   ifdef _MAC
#       define ocslen      strlen
#       define ocscpy      strcpy
#       define ocscmp      strcmp
#       define ocscat      strcat
#       define ocschr      strchr
#       define soprintf    sprintf
#       define oprintf     printf
#       define ocsnicmp    _strnicmp
#   else
#       define ocslen      lstrlenA
#       define ocscpy      lstrcpyA
#       define ocscmp      lpstrcmpA
#       define ocscat      lpstrcatA
#       define ocschr      strchr
#       define soprintf    sprintf
#       define oprintf     printf
#       define ocsnicmp    _strnicmp
#   endif

    // "Unsigned Long to OLESTR"
#   define ULTOO(value,string,radix)  _ultoa( (value), (string), (radix) )

#else // !OLE2ANSI

#   ifdef IPROPERTY_DLL
#       define ocslen      lstrlenW
#       define ocscpy      wcscpy
#       define ocscmp      wcscmp
#       define ocscat      wcscat
#       define ocschr      wcschr
#       define ocsnicmp    _wcsnicmp
#       define soprintf    swprintf
#       define oprintf     wprintf
#       define ocsnicmp    _wcsnicmp
#       define ocsstr      wcsstr
#   else
#       define ocslen      lstrlenW
#       define ocscpy      lstrcpyW
#       define ocscmp      lstrcmpW
#       define ocscat      lstrcatW
#       define ocschr      wcschr
#       define ocsnicmp    _wcsnicmp
#       define soprintf    swprintf
#       define oprintf     wprintf
#       define ocsnicmp    _wcsnicmp
#       define ocsstr      wcsstr
#   endif

    // "Unsigned Long to OLESTR"
#   define ULTOO(value,string,radix)  _ultow( (value), (string), (radix) )

#endif // !OLE2ANSI

#endif // !_OLECHAR_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\public\internal\com\inc\sensapip.h ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved.

Module Name:

    sensapip.h

Abstract:

    This header file is used by components external to System Event
    Notification Service (SENS). These components will call SENS to
    notify it of events related to themselves.

Author:

    Gopal Parupudi    <GopalP>

[Notes:]

    optional-notes

Revision History:

    GopalP          11/4/1997         Start.

--*/


#ifndef __SENSAPIP_H__
#define __SENSAPIP_H__

#if _MSC_VER > 1000
#pragma once
#endif

//
// Includes
//


#if !defined(__midl)
#include <netcon.h>
#else
import "netcon.idl";
#endif // __midl

#ifdef __cplusplus
extern "C" {
#endif

//
// Constants
//

#define SENS_NOTIFY_RAS_STARTED                 0x00000001
#define SENS_NOTIFY_RAS_STOPPED                 0x00000002
#define SENS_NOTIFY_RAS_CONNECT                 0x00000004
#define SENS_NOTIFY_RAS_DISCONNECT              0x00000008
#define SENS_NOTIFY_RAS_DISCONNECT_PENDING      0x00000010
#define SENS_NOTIFY_LAN_CONNECT                 0x00000020
#define SENS_NOTIFY_LAN_DISCONNECT              0x00000040

#define SENS_NOTIFY_WINLOGON_LOGON              0x00001000
#define SENS_NOTIFY_WINLOGON_LOGOFF             0x00002000
#define SENS_NOTIFY_WINLOGON_STARTUP            0x00004000
#define SENS_NOTIFY_WINLOGON_STARTSHELL         0x00008000
#define SENS_NOTIFY_WINLOGON_SHUTDOWN           0x00010000
#define SENS_NOTIFY_WINLOGON_LOCK               0x00020000
#define SENS_NOTIFY_WINLOGON_UNLOCK             0x00040000
#define SENS_NOTIFY_WINLOGON_STARTSCREENSAVER   0x00080000
#define SENS_NOTIFY_WINLOGON_STOPSCREENSAVER    0x00100000
#define SENS_NOTIFY_WINLOGON_POSTSHELL          0x00200000
#define SENS_NOTIFY_WINLOGON_SESSION_DISCONNECT 0x00400000
#define SENS_NOTIFY_WINLOGON_SESSION_RECONNECT  0x00800000

//
// Typedefs
//

typedef DWORD SENS_HRASCONN;

typedef struct _WINLOGON_INFO
{
    ULONG Size;
    ULONG Flags;
    LPWSTR UserName;
    LPWSTR Domain;
    LPWSTR WindowStation;
    DWORD hToken;   // Originally HANDLE
    DWORD hDesktop; // Originally HDESK
    DWORD dwSessionId;
} WINLOGON_INFO, *PWINLOGON_INFO;

typedef struct _SENS_NOTIFY_WINLOGON
{
    DWORD eType;
    WINLOGON_INFO Info;
} SENS_NOTIFY_WINLOGON, *PSENS_NOTIFY_WINLOGON;

typedef struct _SENS_NOTIFY_RAS
{
    DWORD eType;
    SENS_HRASCONN hConnection;
} SENS_NOTIFY_RAS, *PSENS_NOTIFY_RAS;

typedef struct _SENS_NOTIFY_NETCON
{
    DWORD eType;
    INetConnection *pINetConnection;
} SENS_NOTIFY_NETCON, *PSENS_NOTIFY_NETCON;

typedef struct _SENS_NOTIFY_NETCON_P // _P stands for Private
{
    DWORD eType;
#ifdef MIDL_PASS
    [string]
#endif // MIDL_PASS
    LPWSTR Name;
    NETCON_STATUS Status;
    NETCON_MEDIATYPE Type;
} SENS_NOTIFY_NETCON_P, *PSENS_NOTIFY_NETCON_P;

//
// Function prototypes
//

#if !defined(__midl)

DWORD APIENTRY
SensNotifyWinlogonEvent(
    PSENS_NOTIFY_WINLOGON pEvent
    );

DWORD APIENTRY
SensNotifyRasEvent(
    PSENS_NOTIFY_RAS pEvent
    );

DWORD APIENTRY
SensNotifyNetconEvent(
    PSENS_NOTIFY_NETCON pEvent
    );

#endif // !defined(__midl)


#ifdef __cplusplus
}
#endif

#endif // __SENSAPIP_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\public\internal\com\inc\trkstub.h ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved.

Module Name:



Abstract:

   Prototypes for the RPC stubs that services uses to 
   call over to trkwks, now that it is in svchost.


Author:



Revisions:


--*/


extern "C" {
NTSTATUS
WINAPI
StartTrkWksServiceStubs( 
     PSVCS_START_RPC_SERVER RpcpStartRpcServer,
     LPTSTR SvcsRpcPipeName
    );

NTSTATUS
WINAPI
StopTrkWksServiceStubs( 
    PSVCS_STOP_RPC_SERVER RpcpStopRpcServer
    );
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\public\internal\com\inc\syncrasp.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (c) Microsoft Corporation. All rights reserved.
//
//  File:       SyncRasp.h
//
//  Contents:   Private Exports used by Ras and SyncMgr for 
//		doing Pending Disconnect
//
//
//  Classes:    
//
//  Notes:      
//
//  History:    09-Jan-98   rogerg      Created.
//
//--------------------------------------------------------------------------


#ifndef _SYNCMGRRAS_
#define _SYNCMGRRAS_

LRESULT CALLBACK  SyncMgrRasProc(UINT uMsg,WPARAM wParam, LPARAM lParam);  

// structures used in messages

typedef struct _tagSYNCMGRQUERYSHOWSYNCUI
{
    /* [in]  */ DWORD cbSize;
    /* [in]  */ GUID GuidConnection;
    /* [in]  */ LPCWSTR pszConnectionName;
    /* [out] */ BOOL fShowCheckBox;
    /* [out] */ UINT nCheckState;  // values taken from the BST_ #defines
} SYNCMGRQUERYSHOWSYNCUI;

typedef struct _tagSYNCMGRSYNCDISCONNECT
{
    /* [in] */ DWORD cbSize;
    /* [in] */ GUID  GuidConnection;
    /* [in] */ LPCWSTR pszConnectionName;
 } SYNCMGRSYNCDISCONNECT;

// Messages to SyncMgrRasProc
#define SYNCMGRRASPROC_QUERYSHOWSYNCUI 	WM_USER + 1

// wParam = 0
// lParam = Pointer to SYNCMGRQUERYSHOWSYNCUI

#define SYNCMGRRASPROC_SYNCDISCONNECT        	WM_USER + 2

// wParam = 0
// lParam = Pointer to SYNCMGRSYNCDISCONNECT

#endif // _SYNCMGRRAS_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\public\internal\com\inc\privact.h ===
#pragma warning( disable: 4049 )  /* more than 64k source lines */

/* this ALWAYS GENERATED file contains the definitions for the interfaces */


 /* File created by MIDL compiler version 6.00.0347 */
/* Compiler settings for privact.idl:
    Oicf, W1, Zp8, env=Win32 (32b run)
    protocol : dce , ms_ext, c_ext, oldnames, robust
    error checks: allocation ref bounds_check enum stub_data , no_format_optimization
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )


/* verify that the <rpcndr.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCNDR_H_VERSION__
#define __REQUIRED_RPCNDR_H_VERSION__ 475
#endif

#include "rpc.h"
#include "rpcndr.h"

#ifndef __RPCNDR_H_VERSION__
#error this stub requires an updated version of <rpcndr.h>
#endif // __RPCNDR_H_VERSION__

#ifndef COM_NO_WINDOWS_H
#include "windows.h"
#include "ole2.h"
#endif /*COM_NO_WINDOWS_H*/

#ifndef __privact_h__
#define __privact_h__

#if defined(_MSC_VER) && (_MSC_VER >= 1020)
#pragma once
#endif

/* Forward Declarations */ 

#ifndef __IScmRequestInfo_FWD_DEFINED__
#define __IScmRequestInfo_FWD_DEFINED__
typedef interface IScmRequestInfo IScmRequestInfo;
#endif 	/* __IScmRequestInfo_FWD_DEFINED__ */


#ifndef __IScmReplyInfo_FWD_DEFINED__
#define __IScmReplyInfo_FWD_DEFINED__
typedef interface IScmReplyInfo IScmReplyInfo;
#endif 	/* __IScmReplyInfo_FWD_DEFINED__ */


#ifndef __IInstantiationInfo_FWD_DEFINED__
#define __IInstantiationInfo_FWD_DEFINED__
typedef interface IInstantiationInfo IInstantiationInfo;
#endif 	/* __IInstantiationInfo_FWD_DEFINED__ */


#ifndef __ILegacyInfo_FWD_DEFINED__
#define __ILegacyInfo_FWD_DEFINED__
typedef interface ILegacyInfo ILegacyInfo;
#endif 	/* __ILegacyInfo_FWD_DEFINED__ */


#ifndef __IInstanceInfo_FWD_DEFINED__
#define __IInstanceInfo_FWD_DEFINED__
typedef interface IInstanceInfo IInstanceInfo;
#endif 	/* __IInstanceInfo_FWD_DEFINED__ */


#ifndef __IPrivActivationContextInfo_FWD_DEFINED__
#define __IPrivActivationContextInfo_FWD_DEFINED__
typedef interface IPrivActivationContextInfo IPrivActivationContextInfo;
#endif 	/* __IPrivActivationContextInfo_FWD_DEFINED__ */


#ifndef __IActivationProperties_FWD_DEFINED__
#define __IActivationProperties_FWD_DEFINED__
typedef interface IActivationProperties IActivationProperties;
#endif 	/* __IActivationProperties_FWD_DEFINED__ */


#ifndef __IPrivActivationPropertiesOut_FWD_DEFINED__
#define __IPrivActivationPropertiesOut_FWD_DEFINED__
typedef interface IPrivActivationPropertiesOut IPrivActivationPropertiesOut;
#endif 	/* __IPrivActivationPropertiesOut_FWD_DEFINED__ */


#ifndef __IPrivActivationPropertiesIn_FWD_DEFINED__
#define __IPrivActivationPropertiesIn_FWD_DEFINED__
typedef interface IPrivActivationPropertiesIn IPrivActivationPropertiesIn;
#endif 	/* __IPrivActivationPropertiesIn_FWD_DEFINED__ */


#ifndef __IMarshalOptions_FWD_DEFINED__
#define __IMarshalOptions_FWD_DEFINED__
typedef interface IMarshalOptions IMarshalOptions;
#endif 	/* __IMarshalOptions_FWD_DEFINED__ */


/* header files for imported files */
#include "obase.h"
#include "objidl.h"
#include "activate.h"

#ifdef __cplusplus
extern "C"{
#endif 

void * __RPC_USER MIDL_user_allocate(size_t);
void __RPC_USER MIDL_user_free( void * ); 

/* interface __MIDL_itf_privact_0000 */
/* [local] */ 

typedef struct _PRIV_SCM_INFO
    {
    long Apartment;
    /* [string] */ WCHAR *pwszWinstaDesktop;
    ULONG64 ProcessSignature;
    /* [size_is] */ WCHAR *pEnvBlock;
    DWORD EnvBlockLength;
    } 	PRIV_SCM_INFO;

typedef struct _PRIV_RESOLVER_INFO
    {
    OXID OxidServer;
    DUALSTRINGARRAY *pServerORBindings;
    OXID_INFO OxidInfo;
    MID LocalMidOfRemote;
    DWORD DllServerModel;
    /* [string] */ WCHAR *pwszDllServer;
    BOOL FoundInROT;
    } 	PRIV_RESOLVER_INFO;

typedef struct _REMOTE_REQUEST_SCM_INFO
    {
    DWORD ClientImpLevel;
    unsigned short cRequestedProtseqs;
    /* [size_is] */ unsigned short *pRequestedProtseqs;
    } 	REMOTE_REQUEST_SCM_INFO;

typedef struct _REMOTE_REPLY_SCM_INFO
    {
    OXID Oxid;
    DUALSTRINGARRAY *pdsaOxidBindings;
    IPID ipidRemUnknown;
    DWORD authnHint;
    COMVERSION serverVersion;
    } 	REMOTE_REPLY_SCM_INFO;



extern RPC_IF_HANDLE __MIDL_itf_privact_0000_ClientIfHandle;
extern RPC_IF_HANDLE __MIDL_itf_privact_0000_ServerIfHandle;

#ifndef __IScmRequestInfo_INTERFACE_DEFINED__
#define __IScmRequestInfo_INTERFACE_DEFINED__

/* interface IScmRequestInfo */
/* [unique][uuid][local][object] */ 


EXTERN_C const IID IID_IScmRequestInfo;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("000001AA-0000-0000-C000-000000000046")
    IScmRequestInfo : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE SetScmInfo( 
            /* [in] */ PRIV_SCM_INFO *pScmInfo) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetScmInfo( 
            /* [out] */ PRIV_SCM_INFO **ppScmInfo) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetRemoteRequestInfo( 
            /* [in] */ REMOTE_REQUEST_SCM_INFO *pRemoteReq) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetRemoteRequestInfo( 
            /* [out] */ REMOTE_REQUEST_SCM_INFO **ppRemoteReq) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IScmRequestInfoVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IScmRequestInfo * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IScmRequestInfo * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IScmRequestInfo * This);
        
        HRESULT ( STDMETHODCALLTYPE *SetScmInfo )( 
            IScmRequestInfo * This,
            /* [in] */ PRIV_SCM_INFO *pScmInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetScmInfo )( 
            IScmRequestInfo * This,
            /* [out] */ PRIV_SCM_INFO **ppScmInfo);
        
        HRESULT ( STDMETHODCALLTYPE *SetRemoteRequestInfo )( 
            IScmRequestInfo * This,
            /* [in] */ REMOTE_REQUEST_SCM_INFO *pRemoteReq);
        
        HRESULT ( STDMETHODCALLTYPE *GetRemoteRequestInfo )( 
            IScmRequestInfo * This,
            /* [out] */ REMOTE_REQUEST_SCM_INFO **ppRemoteReq);
        
        END_INTERFACE
    } IScmRequestInfoVtbl;

    interface IScmRequestInfo
    {
        CONST_VTBL struct IScmRequestInfoVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IScmRequestInfo_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IScmRequestInfo_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IScmRequestInfo_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IScmRequestInfo_SetScmInfo(This,pScmInfo)	\
    (This)->lpVtbl -> SetScmInfo(This,pScmInfo)

#define IScmRequestInfo_GetScmInfo(This,ppScmInfo)	\
    (This)->lpVtbl -> GetScmInfo(This,ppScmInfo)

#define IScmRequestInfo_SetRemoteRequestInfo(This,pRemoteReq)	\
    (This)->lpVtbl -> SetRemoteRequestInfo(This,pRemoteReq)

#define IScmRequestInfo_GetRemoteRequestInfo(This,ppRemoteReq)	\
    (This)->lpVtbl -> GetRemoteRequestInfo(This,ppRemoteReq)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IScmRequestInfo_SetScmInfo_Proxy( 
    IScmRequestInfo * This,
    /* [in] */ PRIV_SCM_INFO *pScmInfo);


void __RPC_STUB IScmRequestInfo_SetScmInfo_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IScmRequestInfo_GetScmInfo_Proxy( 
    IScmRequestInfo * This,
    /* [out] */ PRIV_SCM_INFO **ppScmInfo);


void __RPC_STUB IScmRequestInfo_GetScmInfo_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IScmRequestInfo_SetRemoteRequestInfo_Proxy( 
    IScmRequestInfo * This,
    /* [in] */ REMOTE_REQUEST_SCM_INFO *pRemoteReq);


void __RPC_STUB IScmRequestInfo_SetRemoteRequestInfo_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IScmRequestInfo_GetRemoteRequestInfo_Proxy( 
    IScmRequestInfo * This,
    /* [out] */ REMOTE_REQUEST_SCM_INFO **ppRemoteReq);


void __RPC_STUB IScmRequestInfo_GetRemoteRequestInfo_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IScmRequestInfo_INTERFACE_DEFINED__ */


#ifndef __IScmReplyInfo_INTERFACE_DEFINED__
#define __IScmReplyInfo_INTERFACE_DEFINED__

/* interface IScmReplyInfo */
/* [unique][uuid][local][object] */ 


EXTERN_C const IID IID_IScmReplyInfo;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("000001B6-0000-0000-C000-000000000046")
    IScmReplyInfo : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE SetResolverInfo( 
            /* [in] */ PRIV_RESOLVER_INFO *pResolverInfo) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetResolverInfo( 
            /* [out] */ PRIV_RESOLVER_INFO **ppResolverInfo) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetRemoteReplyInfo( 
            /* [in] */ REMOTE_REPLY_SCM_INFO *pRemoteReply) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetRemoteReplyInfo( 
            /* [out] */ REMOTE_REPLY_SCM_INFO **ppRemoteReply) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IScmReplyInfoVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IScmReplyInfo * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IScmReplyInfo * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IScmReplyInfo * This);
        
        HRESULT ( STDMETHODCALLTYPE *SetResolverInfo )( 
            IScmReplyInfo * This,
            /* [in] */ PRIV_RESOLVER_INFO *pResolverInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetResolverInfo )( 
            IScmReplyInfo * This,
            /* [out] */ PRIV_RESOLVER_INFO **ppResolverInfo);
        
        HRESULT ( STDMETHODCALLTYPE *SetRemoteReplyInfo )( 
            IScmReplyInfo * This,
            /* [in] */ REMOTE_REPLY_SCM_INFO *pRemoteReply);
        
        HRESULT ( STDMETHODCALLTYPE *GetRemoteReplyInfo )( 
            IScmReplyInfo * This,
            /* [out] */ REMOTE_REPLY_SCM_INFO **ppRemoteReply);
        
        END_INTERFACE
    } IScmReplyInfoVtbl;

    interface IScmReplyInfo
    {
        CONST_VTBL struct IScmReplyInfoVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IScmReplyInfo_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IScmReplyInfo_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IScmReplyInfo_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IScmReplyInfo_SetResolverInfo(This,pResolverInfo)	\
    (This)->lpVtbl -> SetResolverInfo(This,pResolverInfo)

#define IScmReplyInfo_GetResolverInfo(This,ppResolverInfo)	\
    (This)->lpVtbl -> GetResolverInfo(This,ppResolverInfo)

#define IScmReplyInfo_SetRemoteReplyInfo(This,pRemoteReply)	\
    (This)->lpVtbl -> SetRemoteReplyInfo(This,pRemoteReply)

#define IScmReplyInfo_GetRemoteReplyInfo(This,ppRemoteReply)	\
    (This)->lpVtbl -> GetRemoteReplyInfo(This,ppRemoteReply)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IScmReplyInfo_SetResolverInfo_Proxy( 
    IScmReplyInfo * This,
    /* [in] */ PRIV_RESOLVER_INFO *pResolverInfo);


void __RPC_STUB IScmReplyInfo_SetResolverInfo_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IScmReplyInfo_GetResolverInfo_Proxy( 
    IScmReplyInfo * This,
    /* [out] */ PRIV_RESOLVER_INFO **ppResolverInfo);


void __RPC_STUB IScmReplyInfo_GetResolverInfo_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IScmReplyInfo_SetRemoteReplyInfo_Proxy( 
    IScmReplyInfo * This,
    /* [in] */ REMOTE_REPLY_SCM_INFO *pRemoteReply);


void __RPC_STUB IScmReplyInfo_SetRemoteReplyInfo_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IScmReplyInfo_GetRemoteReplyInfo_Proxy( 
    IScmReplyInfo * This,
    /* [out] */ REMOTE_REPLY_SCM_INFO **ppRemoteReply);


void __RPC_STUB IScmReplyInfo_GetRemoteReplyInfo_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IScmReplyInfo_INTERFACE_DEFINED__ */


#ifndef __IInstantiationInfo_INTERFACE_DEFINED__
#define __IInstantiationInfo_INTERFACE_DEFINED__

/* interface IInstantiationInfo */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IInstantiationInfo;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("000001AB-0000-0000-C000-000000000046")
    IInstantiationInfo : public IUnknown
    {
    public:
    };
    
#else 	/* C style interface */

    typedef struct IInstantiationInfoVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IInstantiationInfo * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IInstantiationInfo * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IInstantiationInfo * This);
        
        END_INTERFACE
    } IInstantiationInfoVtbl;

    interface IInstantiationInfo
    {
        CONST_VTBL struct IInstantiationInfoVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IInstantiationInfo_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IInstantiationInfo_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IInstantiationInfo_Release(This)	\
    (This)->lpVtbl -> Release(This)


#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IInstantiationInfo_INTERFACE_DEFINED__ */


#ifndef __ILegacyInfo_INTERFACE_DEFINED__
#define __ILegacyInfo_INTERFACE_DEFINED__

/* interface ILegacyInfo */
/* [unique][uuid][local][object] */ 


EXTERN_C const IID IID_ILegacyInfo;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("000001AC-0000-0000-C000-000000000046")
    ILegacyInfo : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE SetCOSERVERINFO( 
            /* [in] */ COSERVERINFO *pServerInfo) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetCOSERVERINFO( 
            /* [out] */ COSERVERINFO **ppServerInfo) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ILegacyInfoVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ILegacyInfo * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ILegacyInfo * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ILegacyInfo * This);
        
        HRESULT ( STDMETHODCALLTYPE *SetCOSERVERINFO )( 
            ILegacyInfo * This,
            /* [in] */ COSERVERINFO *pServerInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetCOSERVERINFO )( 
            ILegacyInfo * This,
            /* [out] */ COSERVERINFO **ppServerInfo);
        
        END_INTERFACE
    } ILegacyInfoVtbl;

    interface ILegacyInfo
    {
        CONST_VTBL struct ILegacyInfoVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ILegacyInfo_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ILegacyInfo_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ILegacyInfo_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ILegacyInfo_SetCOSERVERINFO(This,pServerInfo)	\
    (This)->lpVtbl -> SetCOSERVERINFO(This,pServerInfo)

#define ILegacyInfo_GetCOSERVERINFO(This,ppServerInfo)	\
    (This)->lpVtbl -> GetCOSERVERINFO(This,ppServerInfo)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE ILegacyInfo_SetCOSERVERINFO_Proxy( 
    ILegacyInfo * This,
    /* [in] */ COSERVERINFO *pServerInfo);


void __RPC_STUB ILegacyInfo_SetCOSERVERINFO_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ILegacyInfo_GetCOSERVERINFO_Proxy( 
    ILegacyInfo * This,
    /* [out] */ COSERVERINFO **ppServerInfo);


void __RPC_STUB ILegacyInfo_GetCOSERVERINFO_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ILegacyInfo_INTERFACE_DEFINED__ */


#ifndef __IInstanceInfo_INTERFACE_DEFINED__
#define __IInstanceInfo_INTERFACE_DEFINED__

/* interface IInstanceInfo */
/* [unique][uuid][local][object] */ 


EXTERN_C const IID IID_IInstanceInfo;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("000001AD-0000-0000-C000-000000000046")
    IInstanceInfo : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE SetStorage( 
            /* [unique][in] */ IStorage *pStg) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetStorage( 
            /* [out] */ IStorage **ppStg) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetStorageIFD( 
            /* [in] */ MInterfacePointer *pStgIFD) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetStorageIFD( 
            /* [out] */ MInterfacePointer **ppStgIFD) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetFile( 
            /* [unique][string][in] */ WCHAR *pwszFileName,
            /* [in] */ DWORD dwMode) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetFile( 
            /* [string][out] */ WCHAR **ppwszFileName,
            /* [out] */ DWORD *pdwMode) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetIfdROT( 
            MInterfacePointer *pIfdROT) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetIfdROT( 
            MInterfacePointer **ppIfdROT) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IInstanceInfoVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IInstanceInfo * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IInstanceInfo * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IInstanceInfo * This);
        
        HRESULT ( STDMETHODCALLTYPE *SetStorage )( 
            IInstanceInfo * This,
            /* [unique][in] */ IStorage *pStg);
        
        HRESULT ( STDMETHODCALLTYPE *GetStorage )( 
            IInstanceInfo * This,
            /* [out] */ IStorage **ppStg);
        
        HRESULT ( STDMETHODCALLTYPE *SetStorageIFD )( 
            IInstanceInfo * This,
            /* [in] */ MInterfacePointer *pStgIFD);
        
        HRESULT ( STDMETHODCALLTYPE *GetStorageIFD )( 
            IInstanceInfo * This,
            /* [out] */ MInterfacePointer **ppStgIFD);
        
        HRESULT ( STDMETHODCALLTYPE *SetFile )( 
            IInstanceInfo * This,
            /* [unique][string][in] */ WCHAR *pwszFileName,
            /* [in] */ DWORD dwMode);
        
        HRESULT ( STDMETHODCALLTYPE *GetFile )( 
            IInstanceInfo * This,
            /* [string][out] */ WCHAR **ppwszFileName,
            /* [out] */ DWORD *pdwMode);
        
        HRESULT ( STDMETHODCALLTYPE *SetIfdROT )( 
            IInstanceInfo * This,
            MInterfacePointer *pIfdROT);
        
        HRESULT ( STDMETHODCALLTYPE *GetIfdROT )( 
            IInstanceInfo * This,
            MInterfacePointer **ppIfdROT);
        
        END_INTERFACE
    } IInstanceInfoVtbl;

    interface IInstanceInfo
    {
        CONST_VTBL struct IInstanceInfoVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IInstanceInfo_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IInstanceInfo_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IInstanceInfo_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IInstanceInfo_SetStorage(This,pStg)	\
    (This)->lpVtbl -> SetStorage(This,pStg)

#define IInstanceInfo_GetStorage(This,ppStg)	\
    (This)->lpVtbl -> GetStorage(This,ppStg)

#define IInstanceInfo_SetStorageIFD(This,pStgIFD)	\
    (This)->lpVtbl -> SetStorageIFD(This,pStgIFD)

#define IInstanceInfo_GetStorageIFD(This,ppStgIFD)	\
    (This)->lpVtbl -> GetStorageIFD(This,ppStgIFD)

#define IInstanceInfo_SetFile(This,pwszFileName,dwMode)	\
    (This)->lpVtbl -> SetFile(This,pwszFileName,dwMode)

#define IInstanceInfo_GetFile(This,ppwszFileName,pdwMode)	\
    (This)->lpVtbl -> GetFile(This,ppwszFileName,pdwMode)

#define IInstanceInfo_SetIfdROT(This,pIfdROT)	\
    (This)->lpVtbl -> SetIfdROT(This,pIfdROT)

#define IInstanceInfo_GetIfdROT(This,ppIfdROT)	\
    (This)->lpVtbl -> GetIfdROT(This,ppIfdROT)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IInstanceInfo_SetStorage_Proxy( 
    IInstanceInfo * This,
    /* [unique][in] */ IStorage *pStg);


void __RPC_STUB IInstanceInfo_SetStorage_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IInstanceInfo_GetStorage_Proxy( 
    IInstanceInfo * This,
    /* [out] */ IStorage **ppStg);


void __RPC_STUB IInstanceInfo_GetStorage_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IInstanceInfo_SetStorageIFD_Proxy( 
    IInstanceInfo * This,
    /* [in] */ MInterfacePointer *pStgIFD);


void __RPC_STUB IInstanceInfo_SetStorageIFD_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IInstanceInfo_GetStorageIFD_Proxy( 
    IInstanceInfo * This,
    /* [out] */ MInterfacePointer **ppStgIFD);


void __RPC_STUB IInstanceInfo_GetStorageIFD_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IInstanceInfo_SetFile_Proxy( 
    IInstanceInfo * This,
    /* [unique][string][in] */ WCHAR *pwszFileName,
    /* [in] */ DWORD dwMode);


void __RPC_STUB IInstanceInfo_SetFile_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IInstanceInfo_GetFile_Proxy( 
    IInstanceInfo * This,
    /* [string][out] */ WCHAR **ppwszFileName,
    /* [out] */ DWORD *pdwMode);


void __RPC_STUB IInstanceInfo_GetFile_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IInstanceInfo_SetIfdROT_Proxy( 
    IInstanceInfo * This,
    MInterfacePointer *pIfdROT);


void __RPC_STUB IInstanceInfo_SetIfdROT_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IInstanceInfo_GetIfdROT_Proxy( 
    IInstanceInfo * This,
    MInterfacePointer **ppIfdROT);


void __RPC_STUB IInstanceInfo_GetIfdROT_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IInstanceInfo_INTERFACE_DEFINED__ */


#ifndef __IPrivActivationContextInfo_INTERFACE_DEFINED__
#define __IPrivActivationContextInfo_INTERFACE_DEFINED__

/* interface IPrivActivationContextInfo */
/* [unique][uuid][local][object] */ 


EXTERN_C const IID IID_IPrivActivationContextInfo;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("000001AE-0000-0000-C000-000000000046")
    IPrivActivationContextInfo : public IActivationContextInfo
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE SetClientContext( 
            /* [in] */ IContext *pClientContext) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetPrototypeContext( 
            /* [in] */ IContext *pContext) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE PrototypeExists( 
            /* [out] */ BOOL *pBExists) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IPrivActivationContextInfoVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IPrivActivationContextInfo * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IPrivActivationContextInfo * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IPrivActivationContextInfo * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetClientContext )( 
            IPrivActivationContextInfo * This,
            /* [out] */ IContext **ppClientContext);
        
        HRESULT ( STDMETHODCALLTYPE *GetPrototypeContext )( 
            IPrivActivationContextInfo * This,
            /* [out] */ IContext **ppContext);
        
        HRESULT ( STDMETHODCALLTYPE *IsClientContextOK )( 
            IPrivActivationContextInfo * This,
            /* [out] */ BOOL *fYes);
        
        HRESULT ( STDMETHODCALLTYPE *SetClientContextNotOK )( 
            IPrivActivationContextInfo * This);
        
        HRESULT ( STDMETHODCALLTYPE *SetClientContext )( 
            IPrivActivationContextInfo * This,
            /* [in] */ IContext *pClientContext);
        
        HRESULT ( STDMETHODCALLTYPE *SetPrototypeContext )( 
            IPrivActivationContextInfo * This,
            /* [in] */ IContext *pContext);
        
        HRESULT ( STDMETHODCALLTYPE *PrototypeExists )( 
            IPrivActivationContextInfo * This,
            /* [out] */ BOOL *pBExists);
        
        END_INTERFACE
    } IPrivActivationContextInfoVtbl;

    interface IPrivActivationContextInfo
    {
        CONST_VTBL struct IPrivActivationContextInfoVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IPrivActivationContextInfo_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IPrivActivationContextInfo_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IPrivActivationContextInfo_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IPrivActivationContextInfo_GetClientContext(This,ppClientContext)	\
    (This)->lpVtbl -> GetClientContext(This,ppClientContext)

#define IPrivActivationContextInfo_GetPrototypeContext(This,ppContext)	\
    (This)->lpVtbl -> GetPrototypeContext(This,ppContext)

#define IPrivActivationContextInfo_IsClientContextOK(This,fYes)	\
    (This)->lpVtbl -> IsClientContextOK(This,fYes)

#define IPrivActivationContextInfo_SetClientContextNotOK(This)	\
    (This)->lpVtbl -> SetClientContextNotOK(This)


#define IPrivActivationContextInfo_SetClientContext(This,pClientContext)	\
    (This)->lpVtbl -> SetClientContext(This,pClientContext)

#define IPrivActivationContextInfo_SetPrototypeContext(This,pContext)	\
    (This)->lpVtbl -> SetPrototypeContext(This,pContext)

#define IPrivActivationContextInfo_PrototypeExists(This,pBExists)	\
    (This)->lpVtbl -> PrototypeExists(This,pBExists)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IPrivActivationContextInfo_SetClientContext_Proxy( 
    IPrivActivationContextInfo * This,
    /* [in] */ IContext *pClientContext);


void __RPC_STUB IPrivActivationContextInfo_SetClientContext_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IPrivActivationContextInfo_SetPrototypeContext_Proxy( 
    IPrivActivationContextInfo * This,
    /* [in] */ IContext *pContext);


void __RPC_STUB IPrivActivationContextInfo_SetPrototypeContext_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IPrivActivationContextInfo_PrototypeExists_Proxy( 
    IPrivActivationContextInfo * This,
    /* [out] */ BOOL *pBExists);


void __RPC_STUB IPrivActivationContextInfo_PrototypeExists_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IPrivActivationContextInfo_INTERFACE_DEFINED__ */


#ifndef __IActivationProperties_INTERFACE_DEFINED__
#define __IActivationProperties_INTERFACE_DEFINED__

/* interface IActivationProperties */
/* [unique][uuid][local][object] */ 


EXTERN_C const IID IID_IActivationProperties;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("000001AF-0000-0000-C000-000000000046")
    IActivationProperties : public IMarshal2
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE SetDestCtx( 
            /* [in] */ DWORD dwDestCtx) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetMarshalFlags( 
            /* [in] */ DWORD dwMarshalFlags) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetLocalBlob( 
            /* [in] */ void *blob) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetLocalBlob( 
            /* [out] */ void **blob) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IActivationPropertiesVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IActivationProperties * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IActivationProperties * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IActivationProperties * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetUnmarshalClass )( 
            IActivationProperties * This,
            /* [in] */ REFIID riid,
            /* [unique][in] */ void *pv,
            /* [in] */ DWORD dwDestContext,
            /* [unique][in] */ void *pvDestContext,
            /* [in] */ DWORD mshlflags,
            /* [out] */ CLSID *pCid);
        
        HRESULT ( STDMETHODCALLTYPE *GetMarshalSizeMax )( 
            IActivationProperties * This,
            /* [in] */ REFIID riid,
            /* [unique][in] */ void *pv,
            /* [in] */ DWORD dwDestContext,
            /* [unique][in] */ void *pvDestContext,
            /* [in] */ DWORD mshlflags,
            /* [out] */ DWORD *pSize);
        
        HRESULT ( STDMETHODCALLTYPE *MarshalInterface )( 
            IActivationProperties * This,
            /* [unique][in] */ IStream *pStm,
            /* [in] */ REFIID riid,
            /* [unique][in] */ void *pv,
            /* [in] */ DWORD dwDestContext,
            /* [unique][in] */ void *pvDestContext,
            /* [in] */ DWORD mshlflags);
        
        HRESULT ( STDMETHODCALLTYPE *UnmarshalInterface )( 
            IActivationProperties * This,
            /* [unique][in] */ IStream *pStm,
            /* [in] */ REFIID riid,
            /* [out] */ void **ppv);
        
        HRESULT ( STDMETHODCALLTYPE *ReleaseMarshalData )( 
            IActivationProperties * This,
            /* [unique][in] */ IStream *pStm);
        
        HRESULT ( STDMETHODCALLTYPE *DisconnectObject )( 
            IActivationProperties * This,
            /* [in] */ DWORD dwReserved);
        
        HRESULT ( STDMETHODCALLTYPE *SetDestCtx )( 
            IActivationProperties * This,
            /* [in] */ DWORD dwDestCtx);
        
        HRESULT ( STDMETHODCALLTYPE *SetMarshalFlags )( 
            IActivationProperties * This,
            /* [in] */ DWORD dwMarshalFlags);
        
        HRESULT ( STDMETHODCALLTYPE *SetLocalBlob )( 
            IActivationProperties * This,
            /* [in] */ void *blob);
        
        HRESULT ( STDMETHODCALLTYPE *GetLocalBlob )( 
            IActivationProperties * This,
            /* [out] */ void **blob);
        
        END_INTERFACE
    } IActivationPropertiesVtbl;

    interface IActivationProperties
    {
        CONST_VTBL struct IActivationPropertiesVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IActivationProperties_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IActivationProperties_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IActivationProperties_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IActivationProperties_GetUnmarshalClass(This,riid,pv,dwDestContext,pvDestContext,mshlflags,pCid)	\
    (This)->lpVtbl -> GetUnmarshalClass(This,riid,pv,dwDestContext,pvDestContext,mshlflags,pCid)

#define IActivationProperties_GetMarshalSizeMax(This,riid,pv,dwDestContext,pvDestContext,mshlflags,pSize)	\
    (This)->lpVtbl -> GetMarshalSizeMax(This,riid,pv,dwDestContext,pvDestContext,mshlflags,pSize)

#define IActivationProperties_MarshalInterface(This,pStm,riid,pv,dwDestContext,pvDestContext,mshlflags)	\
    (This)->lpVtbl -> MarshalInterface(This,pStm,riid,pv,dwDestContext,pvDestContext,mshlflags)

#define IActivationProperties_UnmarshalInterface(This,pStm,riid,ppv)	\
    (This)->lpVtbl -> UnmarshalInterface(This,pStm,riid,ppv)

#define IActivationProperties_ReleaseMarshalData(This,pStm)	\
    (This)->lpVtbl -> ReleaseMarshalData(This,pStm)

#define IActivationProperties_DisconnectObject(This,dwReserved)	\
    (This)->lpVtbl -> DisconnectObject(This,dwReserved)



#define IActivationProperties_SetDestCtx(This,dwDestCtx)	\
    (This)->lpVtbl -> SetDestCtx(This,dwDestCtx)

#define IActivationProperties_SetMarshalFlags(This,dwMarshalFlags)	\
    (This)->lpVtbl -> SetMarshalFlags(This,dwMarshalFlags)

#define IActivationProperties_SetLocalBlob(This,blob)	\
    (This)->lpVtbl -> SetLocalBlob(This,blob)

#define IActivationProperties_GetLocalBlob(This,blob)	\
    (This)->lpVtbl -> GetLocalBlob(This,blob)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IActivationProperties_SetDestCtx_Proxy( 
    IActivationProperties * This,
    /* [in] */ DWORD dwDestCtx);


void __RPC_STUB IActivationProperties_SetDestCtx_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActivationProperties_SetMarshalFlags_Proxy( 
    IActivationProperties * This,
    /* [in] */ DWORD dwMarshalFlags);


void __RPC_STUB IActivationProperties_SetMarshalFlags_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActivationProperties_SetLocalBlob_Proxy( 
    IActivationProperties * This,
    /* [in] */ void *blob);


void __RPC_STUB IActivationProperties_SetLocalBlob_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActivationProperties_GetLocalBlob_Proxy( 
    IActivationProperties * This,
    /* [out] */ void **blob);


void __RPC_STUB IActivationProperties_GetLocalBlob_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IActivationProperties_INTERFACE_DEFINED__ */


#ifndef __IPrivActivationPropertiesOut_INTERFACE_DEFINED__
#define __IPrivActivationPropertiesOut_INTERFACE_DEFINED__

/* interface IPrivActivationPropertiesOut */
/* [unique][uuid][local][object] */ 


EXTERN_C const IID IID_IPrivActivationPropertiesOut;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("000001B0-0000-0000-C000-000000000046")
    IPrivActivationPropertiesOut : public IActivationPropertiesOut
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE SetObjectInterfaces( 
            /* [in] */ DWORD cIfs,
            /* [in] */ IID *pIID,
            /* [in] */ IUnknown *pUnk) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetMarshalledResults( 
            /* [in] */ DWORD cIfs,
            /* [in] */ IID *pIID,
            /* [in] */ HRESULT *pHr,
            /* [in] */ MInterfacePointer **pIntfData) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetMarshalledResults( 
            /* [out] */ DWORD *pcIfs,
            /* [out] */ IID **pIID,
            /* [out] */ HRESULT **pHr,
            /* [out] */ MInterfacePointer ***pIntfData) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IPrivActivationPropertiesOutVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IPrivActivationPropertiesOut * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IPrivActivationPropertiesOut * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IPrivActivationPropertiesOut * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetActivationID )( 
            IPrivActivationPropertiesOut * This,
            /* [out] */ GUID *pActivationID);
        
        HRESULT ( STDMETHODCALLTYPE *GetObjectInterface )( 
            IPrivActivationPropertiesOut * This,
            /* [in] */ REFIID riid,
            /* [in] */ DWORD actvflags,
            /* [iid_is][out] */ void **ppv);
        
        HRESULT ( STDMETHODCALLTYPE *GetObjectInterfaces )( 
            IPrivActivationPropertiesOut * This,
            /* [in] */ DWORD cIfs,
            /* [in] */ DWORD actvflags,
            /* [size_is][in] */ MULTI_QI *multiQi);
        
        HRESULT ( STDMETHODCALLTYPE *RemoveRequestedIIDs )( 
            IPrivActivationPropertiesOut * This,
            /* [in] */ DWORD cIfs,
            /* [size_is][in] */ IID *rgIID);
        
        HRESULT ( STDMETHODCALLTYPE *SetObjectInterfaces )( 
            IPrivActivationPropertiesOut * This,
            /* [in] */ DWORD cIfs,
            /* [in] */ IID *pIID,
            /* [in] */ IUnknown *pUnk);
        
        HRESULT ( STDMETHODCALLTYPE *SetMarshalledResults )( 
            IPrivActivationPropertiesOut * This,
            /* [in] */ DWORD cIfs,
            /* [in] */ IID *pIID,
            /* [in] */ HRESULT *pHr,
            /* [in] */ MInterfacePointer **pIntfData);
        
        HRESULT ( STDMETHODCALLTYPE *GetMarshalledResults )( 
            IPrivActivationPropertiesOut * This,
            /* [out] */ DWORD *pcIfs,
            /* [out] */ IID **pIID,
            /* [out] */ HRESULT **pHr,
            /* [out] */ MInterfacePointer ***pIntfData);
        
        END_INTERFACE
    } IPrivActivationPropertiesOutVtbl;

    interface IPrivActivationPropertiesOut
    {
        CONST_VTBL struct IPrivActivationPropertiesOutVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IPrivActivationPropertiesOut_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IPrivActivationPropertiesOut_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IPrivActivationPropertiesOut_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IPrivActivationPropertiesOut_GetActivationID(This,pActivationID)	\
    (This)->lpVtbl -> GetActivationID(This,pActivationID)

#define IPrivActivationPropertiesOut_GetObjectInterface(This,riid,actvflags,ppv)	\
    (This)->lpVtbl -> GetObjectInterface(This,riid,actvflags,ppv)

#define IPrivActivationPropertiesOut_GetObjectInterfaces(This,cIfs,actvflags,multiQi)	\
    (This)->lpVtbl -> GetObjectInterfaces(This,cIfs,actvflags,multiQi)

#define IPrivActivationPropertiesOut_RemoveRequestedIIDs(This,cIfs,rgIID)	\
    (This)->lpVtbl -> RemoveRequestedIIDs(This,cIfs,rgIID)


#define IPrivActivationPropertiesOut_SetObjectInterfaces(This,cIfs,pIID,pUnk)	\
    (This)->lpVtbl -> SetObjectInterfaces(This,cIfs,pIID,pUnk)

#define IPrivActivationPropertiesOut_SetMarshalledResults(This,cIfs,pIID,pHr,pIntfData)	\
    (This)->lpVtbl -> SetMarshalledResults(This,cIfs,pIID,pHr,pIntfData)

#define IPrivActivationPropertiesOut_GetMarshalledResults(This,pcIfs,pIID,pHr,pIntfData)	\
    (This)->lpVtbl -> GetMarshalledResults(This,pcIfs,pIID,pHr,pIntfData)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IPrivActivationPropertiesOut_SetObjectInterfaces_Proxy( 
    IPrivActivationPropertiesOut * This,
    /* [in] */ DWORD cIfs,
    /* [in] */ IID *pIID,
    /* [in] */ IUnknown *pUnk);


void __RPC_STUB IPrivActivationPropertiesOut_SetObjectInterfaces_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IPrivActivationPropertiesOut_SetMarshalledResults_Proxy( 
    IPrivActivationPropertiesOut * This,
    /* [in] */ DWORD cIfs,
    /* [in] */ IID *pIID,
    /* [in] */ HRESULT *pHr,
    /* [in] */ MInterfacePointer **pIntfData);


void __RPC_STUB IPrivActivationPropertiesOut_SetMarshalledResults_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IPrivActivationPropertiesOut_GetMarshalledResults_Proxy( 
    IPrivActivationPropertiesOut * This,
    /* [out] */ DWORD *pcIfs,
    /* [out] */ IID **pIID,
    /* [out] */ HRESULT **pHr,
    /* [out] */ MInterfacePointer ***pIntfData);


void __RPC_STUB IPrivActivationPropertiesOut_GetMarshalledResults_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IPrivActivationPropertiesOut_INTERFACE_DEFINED__ */


#ifndef __IPrivActivationPropertiesIn_INTERFACE_DEFINED__
#define __IPrivActivationPropertiesIn_INTERFACE_DEFINED__

/* interface IPrivActivationPropertiesIn */
/* [unique][uuid][local][object] */ 


EXTERN_C const IID IID_IPrivActivationPropertiesIn;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("000001B5-0000-0000-C000-000000000046")
    IPrivActivationPropertiesIn : public IActivationPropertiesIn
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE PrivGetReturnActivationProperties( 
            /* [out] */ IPrivActivationPropertiesOut **ppActOut) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetCOMVersion( 
            /* [out] */ COMVERSION *pVersion) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetClsid( 
            /* [out] */ CLSID *pClsid) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetClientToken( 
            /* [out] */ HANDLE *pHandle) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetDestCtx( 
            /* [out] */ DWORD *pdwDestCtx) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IPrivActivationPropertiesInVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IPrivActivationPropertiesIn * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IPrivActivationPropertiesIn * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IPrivActivationPropertiesIn * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetActivationID )( 
            IPrivActivationPropertiesIn * This,
            /* [out] */ GUID *pActivationID);
        
        HRESULT ( STDMETHODCALLTYPE *GetClassInfo )( 
            IPrivActivationPropertiesIn * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppv);
        
        HRESULT ( STDMETHODCALLTYPE *GetClsctx )( 
            IPrivActivationPropertiesIn * This,
            /* [out] */ DWORD *pclsctx);
        
        HRESULT ( STDMETHODCALLTYPE *GetActivationFlags )( 
            IPrivActivationPropertiesIn * This,
            /* [out] */ DWORD *pactvflags);
        
        HRESULT ( STDMETHODCALLTYPE *AddRequestedIIDs )( 
            IPrivActivationPropertiesIn * This,
            /* [in] */ DWORD cIfs,
            /* [size_is][in] */ IID *rgIID);
        
        HRESULT ( STDMETHODCALLTYPE *GetRequestedIIDs )( 
            IPrivActivationPropertiesIn * This,
            /* [out] */ ULONG *pulCount,
            /* [out] */ IID **prgIID);
        
        HRESULT ( STDMETHODCALLTYPE *DelegateGetClassObject )( 
            IPrivActivationPropertiesIn * This,
            /* [out] */ IActivationPropertiesOut **pActPropsOut);
        
        HRESULT ( STDMETHODCALLTYPE *DelegateCreateInstance )( 
            IPrivActivationPropertiesIn * This,
            /* [in] */ IUnknown *pUnkOuter,
            /* [out] */ IActivationPropertiesOut **pActPropsOut);
        
        HRESULT ( STDMETHODCALLTYPE *DelegateCIAndGetCF )( 
            IPrivActivationPropertiesIn * This,
            /* [in] */ IUnknown *pUnkOuter,
            /* [out] */ IActivationPropertiesOut **pActPropsOut,
            /* [out] */ IClassFactory **ppCf);
        
        HRESULT ( STDMETHODCALLTYPE *GetReturnActivationProperties )( 
            IPrivActivationPropertiesIn * This,
            /* [in] */ IUnknown *pUnk,
            /* [out] */ IActivationPropertiesOut **ppActOut);
        
        HRESULT ( STDMETHODCALLTYPE *PrivGetReturnActivationProperties )( 
            IPrivActivationPropertiesIn * This,
            /* [out] */ IPrivActivationPropertiesOut **ppActOut);
        
        HRESULT ( STDMETHODCALLTYPE *GetCOMVersion )( 
            IPrivActivationPropertiesIn * This,
            /* [out] */ COMVERSION *pVersion);
        
        HRESULT ( STDMETHODCALLTYPE *GetClsid )( 
            IPrivActivationPropertiesIn * This,
            /* [out] */ CLSID *pClsid);
        
        HRESULT ( STDMETHODCALLTYPE *GetClientToken )( 
            IPrivActivationPropertiesIn * This,
            /* [out] */ HANDLE *pHandle);
        
        HRESULT ( STDMETHODCALLTYPE *GetDestCtx )( 
            IPrivActivationPropertiesIn * This,
            /* [out] */ DWORD *pdwDestCtx);
        
        END_INTERFACE
    } IPrivActivationPropertiesInVtbl;

    interface IPrivActivationPropertiesIn
    {
        CONST_VTBL struct IPrivActivationPropertiesInVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IPrivActivationPropertiesIn_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IPrivActivationPropertiesIn_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IPrivActivationPropertiesIn_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IPrivActivationPropertiesIn_GetActivationID(This,pActivationID)	\
    (This)->lpVtbl -> GetActivationID(This,pActivationID)

#define IPrivActivationPropertiesIn_GetClassInfo(This,riid,ppv)	\
    (This)->lpVtbl -> GetClassInfo(This,riid,ppv)

#define IPrivActivationPropertiesIn_GetClsctx(This,pclsctx)	\
    (This)->lpVtbl -> GetClsctx(This,pclsctx)

#define IPrivActivationPropertiesIn_GetActivationFlags(This,pactvflags)	\
    (This)->lpVtbl -> GetActivationFlags(This,pactvflags)

#define IPrivActivationPropertiesIn_AddRequestedIIDs(This,cIfs,rgIID)	\
    (This)->lpVtbl -> AddRequestedIIDs(This,cIfs,rgIID)

#define IPrivActivationPropertiesIn_GetRequestedIIDs(This,pulCount,prgIID)	\
    (This)->lpVtbl -> GetRequestedIIDs(This,pulCount,prgIID)

#define IPrivActivationPropertiesIn_DelegateGetClassObject(This,pActPropsOut)	\
    (This)->lpVtbl -> DelegateGetClassObject(This,pActPropsOut)

#define IPrivActivationPropertiesIn_DelegateCreateInstance(This,pUnkOuter,pActPropsOut)	\
    (This)->lpVtbl -> DelegateCreateInstance(This,pUnkOuter,pActPropsOut)

#define IPrivActivationPropertiesIn_DelegateCIAndGetCF(This,pUnkOuter,pActPropsOut,ppCf)	\
    (This)->lpVtbl -> DelegateCIAndGetCF(This,pUnkOuter,pActPropsOut,ppCf)

#define IPrivActivationPropertiesIn_GetReturnActivationProperties(This,pUnk,ppActOut)	\
    (This)->lpVtbl -> GetReturnActivationProperties(This,pUnk,ppActOut)


#define IPrivActivationPropertiesIn_PrivGetReturnActivationProperties(This,ppActOut)	\
    (This)->lpVtbl -> PrivGetReturnActivationProperties(This,ppActOut)

#define IPrivActivationPropertiesIn_GetCOMVersion(This,pVersion)	\
    (This)->lpVtbl -> GetCOMVersion(This,pVersion)

#define IPrivActivationPropertiesIn_GetClsid(This,pClsid)	\
    (This)->lpVtbl -> GetClsid(This,pClsid)

#define IPrivActivationPropertiesIn_GetClientToken(This,pHandle)	\
    (This)->lpVtbl -> GetClientToken(This,pHandle)

#define IPrivActivationPropertiesIn_GetDestCtx(This,pdwDestCtx)	\
    (This)->lpVtbl -> GetDestCtx(This,pdwDestCtx)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IPrivActivationPropertiesIn_PrivGetReturnActivationProperties_Proxy( 
    IPrivActivationPropertiesIn * This,
    /* [out] */ IPrivActivationPropertiesOut **ppActOut);


void __RPC_STUB IPrivActivationPropertiesIn_PrivGetReturnActivationProperties_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IPrivActivationPropertiesIn_GetCOMVersion_Proxy( 
    IPrivActivationPropertiesIn * This,
    /* [out] */ COMVERSION *pVersion);


void __RPC_STUB IPrivActivationPropertiesIn_GetCOMVersion_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IPrivActivationPropertiesIn_GetClsid_Proxy( 
    IPrivActivationPropertiesIn * This,
    /* [out] */ CLSID *pClsid);


void __RPC_STUB IPrivActivationPropertiesIn_GetClsid_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IPrivActivationPropertiesIn_GetClientToken_Proxy( 
    IPrivActivationPropertiesIn * This,
    /* [out] */ HANDLE *pHandle);


void __RPC_STUB IPrivActivationPropertiesIn_GetClientToken_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IPrivActivationPropertiesIn_GetDestCtx_Proxy( 
    IPrivActivationPropertiesIn * This,
    /* [out] */ DWORD *pdwDestCtx);


void __RPC_STUB IPrivActivationPropertiesIn_GetDestCtx_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IPrivActivationPropertiesIn_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_privact_0140 */
/* [local] */ 

typedef /* [public] */ 
enum __MIDL___MIDL_itf_privact_0140_0001
    {	MARSHOPT_NO_OID_REGISTER	= 1
    } 	MARSHAL_OPTIONS;



extern RPC_IF_HANDLE __MIDL_itf_privact_0140_ClientIfHandle;
extern RPC_IF_HANDLE __MIDL_itf_privact_0140_ServerIfHandle;

#ifndef __IMarshalOptions_INTERFACE_DEFINED__
#define __IMarshalOptions_INTERFACE_DEFINED__

/* interface IMarshalOptions */
/* [object][local][uuid] */ 


EXTERN_C const IID IID_IMarshalOptions;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("4c1e39e1-e3e3-4296-aa86-ec938d896e92")
    IMarshalOptions : public IUnknown
    {
    public:
        virtual void STDMETHODCALLTYPE GetStubMarshalFlags( 
            /* [out] */ DWORD *pdwFlags) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IMarshalOptionsVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IMarshalOptions * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IMarshalOptions * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IMarshalOptions * This);
        
        void ( STDMETHODCALLTYPE *GetStubMarshalFlags )( 
            IMarshalOptions * This,
            /* [out] */ DWORD *pdwFlags);
        
        END_INTERFACE
    } IMarshalOptionsVtbl;

    interface IMarshalOptions
    {
        CONST_VTBL struct IMarshalOptionsVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IMarshalOptions_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IMarshalOptions_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IMarshalOptions_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IMarshalOptions_GetStubMarshalFlags(This,pdwFlags)	\
    (This)->lpVtbl -> GetStubMarshalFlags(This,pdwFlags)

#endif /* COBJMACROS */


#endif 	/* C style interface */



void STDMETHODCALLTYPE IMarshalOptions_GetStubMarshalFlags_Proxy( 
    IMarshalOptions * This,
    /* [out] */ DWORD *pdwFlags);


void __RPC_STUB IMarshalOptions_GetStubMarshalFlags_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IMarshalOptions_INTERFACE_DEFINED__ */


/* Additional Prototypes for ALL interfaces */

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\public\internal\com\inc\partitions.h ===
#pragma warning( disable: 4049 )  /* more than 64k source lines */

/* this ALWAYS GENERATED file contains the definitions for the interfaces */


 /* File created by MIDL compiler version 6.00.0347 */
/* Compiler settings for partitions.idl:
    Oicf, W1, Zp8, env=Win32 (32b run)
    protocol : dce , ms_ext, c_ext, oldnames, robust
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )


/* verify that the <rpcndr.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCNDR_H_VERSION__
#define __REQUIRED_RPCNDR_H_VERSION__ 475
#endif

#include "rpc.h"
#include "rpcndr.h"

#ifndef __RPCNDR_H_VERSION__
#error this stub requires an updated version of <rpcndr.h>
#endif // __RPCNDR_H_VERSION__

#ifndef COM_NO_WINDOWS_H
#include "windows.h"
#include "ole2.h"
#endif /*COM_NO_WINDOWS_H*/

#ifndef __partitions_h__
#define __partitions_h__

#if defined(_MSC_VER) && (_MSC_VER >= 1020)
#pragma once
#endif

/* Forward Declarations */ 

#ifndef __IUserToken_FWD_DEFINED__
#define __IUserToken_FWD_DEFINED__
typedef interface IUserToken IUserToken;
#endif 	/* __IUserToken_FWD_DEFINED__ */


#ifndef __IPartitionProperty_FWD_DEFINED__
#define __IPartitionProperty_FWD_DEFINED__
typedef interface IPartitionProperty IPartitionProperty;
#endif 	/* __IPartitionProperty_FWD_DEFINED__ */


#ifndef __IPartitionLookup_FWD_DEFINED__
#define __IPartitionLookup_FWD_DEFINED__
typedef interface IPartitionLookup IPartitionLookup;
#endif 	/* __IPartitionLookup_FWD_DEFINED__ */


#ifndef __IReplaceClassInfo_FWD_DEFINED__
#define __IReplaceClassInfo_FWD_DEFINED__
typedef interface IReplaceClassInfo IReplaceClassInfo;
#endif 	/* __IReplaceClassInfo_FWD_DEFINED__ */


#ifndef __IGetCatalogObject_FWD_DEFINED__
#define __IGetCatalogObject_FWD_DEFINED__
typedef interface IGetCatalogObject IGetCatalogObject;
#endif 	/* __IGetCatalogObject_FWD_DEFINED__ */


#ifndef __IComCatalogInternal_FWD_DEFINED__
#define __IComCatalogInternal_FWD_DEFINED__
typedef interface IComCatalogInternal IComCatalogInternal;
#endif 	/* __IComCatalogInternal_FWD_DEFINED__ */


#ifndef __IComCatalog2Internal_FWD_DEFINED__
#define __IComCatalog2Internal_FWD_DEFINED__
typedef interface IComCatalog2Internal IComCatalog2Internal;
#endif 	/* __IComCatalog2Internal_FWD_DEFINED__ */


#ifndef __IComCatalogLocation_FWD_DEFINED__
#define __IComCatalogLocation_FWD_DEFINED__
typedef interface IComCatalogLocation IComCatalogLocation;
#endif 	/* __IComCatalogLocation_FWD_DEFINED__ */


#ifndef __ICacheControl_FWD_DEFINED__
#define __ICacheControl_FWD_DEFINED__
typedef interface ICacheControl ICacheControl;
#endif 	/* __ICacheControl_FWD_DEFINED__ */


/* header files for imported files */
#include "objidl.h"

#ifdef __cplusplus
extern "C"{
#endif 

void * __RPC_USER MIDL_user_allocate(size_t);
void __RPC_USER MIDL_user_free( void * ); 

#ifndef __IUserToken_INTERFACE_DEFINED__
#define __IUserToken_INTERFACE_DEFINED__

/* interface IUserToken */
/* [uuid][unique][local][object] */ 


EXTERN_C const IID IID_IUserToken;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("000001FC-0000-0000-C000-000000000046")
    IUserToken : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetUserClassesRootKey( 
            /* [out] */ HKEY *phKey) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ReleaseUserClassesRootKey( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetUserSid( 
            /* [out] */ BYTE **ppSid,
            /* [out] */ USHORT *pcbSid) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IUserTokenVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IUserToken * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IUserToken * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IUserToken * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetUserClassesRootKey )( 
            IUserToken * This,
            /* [out] */ HKEY *phKey);
        
        HRESULT ( STDMETHODCALLTYPE *ReleaseUserClassesRootKey )( 
            IUserToken * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetUserSid )( 
            IUserToken * This,
            /* [out] */ BYTE **ppSid,
            /* [out] */ USHORT *pcbSid);
        
        END_INTERFACE
    } IUserTokenVtbl;

    interface IUserToken
    {
        CONST_VTBL struct IUserTokenVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IUserToken_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IUserToken_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IUserToken_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IUserToken_GetUserClassesRootKey(This,phKey)	\
    (This)->lpVtbl -> GetUserClassesRootKey(This,phKey)

#define IUserToken_ReleaseUserClassesRootKey(This)	\
    (This)->lpVtbl -> ReleaseUserClassesRootKey(This)

#define IUserToken_GetUserSid(This,ppSid,pcbSid)	\
    (This)->lpVtbl -> GetUserSid(This,ppSid,pcbSid)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IUserToken_GetUserClassesRootKey_Proxy( 
    IUserToken * This,
    /* [out] */ HKEY *phKey);


void __RPC_STUB IUserToken_GetUserClassesRootKey_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IUserToken_ReleaseUserClassesRootKey_Proxy( 
    IUserToken * This);


void __RPC_STUB IUserToken_ReleaseUserClassesRootKey_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IUserToken_GetUserSid_Proxy( 
    IUserToken * This,
    /* [out] */ BYTE **ppSid,
    /* [out] */ USHORT *pcbSid);


void __RPC_STUB IUserToken_GetUserSid_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IUserToken_INTERFACE_DEFINED__ */


#ifndef __IPartitionProperty_INTERFACE_DEFINED__
#define __IPartitionProperty_INTERFACE_DEFINED__

/* interface IPartitionProperty */
/* [uuid][unique][local][object] */ 


EXTERN_C const IID IID_IPartitionProperty;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("000001F2-0000-0000-C000-000000000046")
    IPartitionProperty : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetPartitionID( 
            /* [out] */ GUID *pGuid) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetPartitionID( 
            /* [in] */ GUID *pGuid) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IPartitionPropertyVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IPartitionProperty * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IPartitionProperty * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IPartitionProperty * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetPartitionID )( 
            IPartitionProperty * This,
            /* [out] */ GUID *pGuid);
        
        HRESULT ( STDMETHODCALLTYPE *SetPartitionID )( 
            IPartitionProperty * This,
            /* [in] */ GUID *pGuid);
        
        END_INTERFACE
    } IPartitionPropertyVtbl;

    interface IPartitionProperty
    {
        CONST_VTBL struct IPartitionPropertyVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IPartitionProperty_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IPartitionProperty_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IPartitionProperty_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IPartitionProperty_GetPartitionID(This,pGuid)	\
    (This)->lpVtbl -> GetPartitionID(This,pGuid)

#define IPartitionProperty_SetPartitionID(This,pGuid)	\
    (This)->lpVtbl -> SetPartitionID(This,pGuid)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IPartitionProperty_GetPartitionID_Proxy( 
    IPartitionProperty * This,
    /* [out] */ GUID *pGuid);


void __RPC_STUB IPartitionProperty_GetPartitionID_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IPartitionProperty_SetPartitionID_Proxy( 
    IPartitionProperty * This,
    /* [in] */ GUID *pGuid);


void __RPC_STUB IPartitionProperty_SetPartitionID_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IPartitionProperty_INTERFACE_DEFINED__ */


#ifndef __IPartitionLookup_INTERFACE_DEFINED__
#define __IPartitionLookup_INTERFACE_DEFINED__

/* interface IPartitionLookup */
/* [uuid][unique][local][object] */ 


EXTERN_C const IID IID_IPartitionLookup;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("000001F8-0000-0000-C000-000000000046")
    IPartitionLookup : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetDefaultPartitionForUser( 
            /* [out] */ IPartitionProperty **ppPartitionProperty) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE IsPartitionValidForUser( 
            /* [in] */ GUID *pguidPartitionId,
            /* [out] */ BOOL *pfIsPartitionValid) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetDefaultPartitionForUserByToken( 
            /* [in] */ IUserToken *pUserToken,
            /* [out] */ IPartitionProperty **ppPartitionProperty) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE IsPartitionValidForUserByToken( 
            /* [in] */ IUserToken *pUserToken,
            /* [in] */ GUID *pguidPartitionId,
            /* [out] */ BOOL *pfIsPartitionValid) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE IsLocalStoreEnabled( 
            /* [out] */ BOOL *pfEnabled) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE IsDSLookupEnabled( 
            /* [out] */ BOOL *pfEnabled) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IPartitionLookupVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IPartitionLookup * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IPartitionLookup * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IPartitionLookup * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetDefaultPartitionForUser )( 
            IPartitionLookup * This,
            /* [out] */ IPartitionProperty **ppPartitionProperty);
        
        HRESULT ( STDMETHODCALLTYPE *IsPartitionValidForUser )( 
            IPartitionLookup * This,
            /* [in] */ GUID *pguidPartitionId,
            /* [out] */ BOOL *pfIsPartitionValid);
        
        HRESULT ( STDMETHODCALLTYPE *GetDefaultPartitionForUserByToken )( 
            IPartitionLookup * This,
            /* [in] */ IUserToken *pUserToken,
            /* [out] */ IPartitionProperty **ppPartitionProperty);
        
        HRESULT ( STDMETHODCALLTYPE *IsPartitionValidForUserByToken )( 
            IPartitionLookup * This,
            /* [in] */ IUserToken *pUserToken,
            /* [in] */ GUID *pguidPartitionId,
            /* [out] */ BOOL *pfIsPartitionValid);
        
        HRESULT ( STDMETHODCALLTYPE *IsLocalStoreEnabled )( 
            IPartitionLookup * This,
            /* [out] */ BOOL *pfEnabled);
        
        HRESULT ( STDMETHODCALLTYPE *IsDSLookupEnabled )( 
            IPartitionLookup * This,
            /* [out] */ BOOL *pfEnabled);
        
        END_INTERFACE
    } IPartitionLookupVtbl;

    interface IPartitionLookup
    {
        CONST_VTBL struct IPartitionLookupVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IPartitionLookup_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IPartitionLookup_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IPartitionLookup_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IPartitionLookup_GetDefaultPartitionForUser(This,ppPartitionProperty)	\
    (This)->lpVtbl -> GetDefaultPartitionForUser(This,ppPartitionProperty)

#define IPartitionLookup_IsPartitionValidForUser(This,pguidPartitionId,pfIsPartitionValid)	\
    (This)->lpVtbl -> IsPartitionValidForUser(This,pguidPartitionId,pfIsPartitionValid)

#define IPartitionLookup_GetDefaultPartitionForUserByToken(This,pUserToken,ppPartitionProperty)	\
    (This)->lpVtbl -> GetDefaultPartitionForUserByToken(This,pUserToken,ppPartitionProperty)

#define IPartitionLookup_IsPartitionValidForUserByToken(This,pUserToken,pguidPartitionId,pfIsPartitionValid)	\
    (This)->lpVtbl -> IsPartitionValidForUserByToken(This,pUserToken,pguidPartitionId,pfIsPartitionValid)

#define IPartitionLookup_IsLocalStoreEnabled(This,pfEnabled)	\
    (This)->lpVtbl -> IsLocalStoreEnabled(This,pfEnabled)

#define IPartitionLookup_IsDSLookupEnabled(This,pfEnabled)	\
    (This)->lpVtbl -> IsDSLookupEnabled(This,pfEnabled)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IPartitionLookup_GetDefaultPartitionForUser_Proxy( 
    IPartitionLookup * This,
    /* [out] */ IPartitionProperty **ppPartitionProperty);


void __RPC_STUB IPartitionLookup_GetDefaultPartitionForUser_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IPartitionLookup_IsPartitionValidForUser_Proxy( 
    IPartitionLookup * This,
    /* [in] */ GUID *pguidPartitionId,
    /* [out] */ BOOL *pfIsPartitionValid);


void __RPC_STUB IPartitionLookup_IsPartitionValidForUser_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IPartitionLookup_GetDefaultPartitionForUserByToken_Proxy( 
    IPartitionLookup * This,
    /* [in] */ IUserToken *pUserToken,
    /* [out] */ IPartitionProperty **ppPartitionProperty);


void __RPC_STUB IPartitionLookup_GetDefaultPartitionForUserByToken_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IPartitionLookup_IsPartitionValidForUserByToken_Proxy( 
    IPartitionLookup * This,
    /* [in] */ IUserToken *pUserToken,
    /* [in] */ GUID *pguidPartitionId,
    /* [out] */ BOOL *pfIsPartitionValid);


void __RPC_STUB IPartitionLookup_IsPartitionValidForUserByToken_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IPartitionLookup_IsLocalStoreEnabled_Proxy( 
    IPartitionLookup * This,
    /* [out] */ BOOL *pfEnabled);


void __RPC_STUB IPartitionLookup_IsLocalStoreEnabled_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IPartitionLookup_IsDSLookupEnabled_Proxy( 
    IPartitionLookup * This,
    /* [out] */ BOOL *pfEnabled);


void __RPC_STUB IPartitionLookup_IsDSLookupEnabled_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IPartitionLookup_INTERFACE_DEFINED__ */


#ifndef __IReplaceClassInfo_INTERFACE_DEFINED__
#define __IReplaceClassInfo_INTERFACE_DEFINED__

/* interface IReplaceClassInfo */
/* [uuid][unique][local][object] */ 


EXTERN_C const IID IID_IReplaceClassInfo;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("000001FB-0000-0000-C000-000000000046")
    IReplaceClassInfo : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetClassInfo( 
            /* [in] */ REFGUID guidConfiguredClsid,
            /* [in] */ REFIID riid,
            /* [out] */ void **ppv) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IReplaceClassInfoVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IReplaceClassInfo * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IReplaceClassInfo * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IReplaceClassInfo * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetClassInfo )( 
            IReplaceClassInfo * This,
            /* [in] */ REFGUID guidConfiguredClsid,
            /* [in] */ REFIID riid,
            /* [out] */ void **ppv);
        
        END_INTERFACE
    } IReplaceClassInfoVtbl;

    interface IReplaceClassInfo
    {
        CONST_VTBL struct IReplaceClassInfoVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IReplaceClassInfo_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IReplaceClassInfo_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IReplaceClassInfo_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IReplaceClassInfo_GetClassInfo(This,guidConfiguredClsid,riid,ppv)	\
    (This)->lpVtbl -> GetClassInfo(This,guidConfiguredClsid,riid,ppv)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IReplaceClassInfo_GetClassInfo_Proxy( 
    IReplaceClassInfo * This,
    /* [in] */ REFGUID guidConfiguredClsid,
    /* [in] */ REFIID riid,
    /* [out] */ void **ppv);


void __RPC_STUB IReplaceClassInfo_GetClassInfo_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IReplaceClassInfo_INTERFACE_DEFINED__ */


#ifndef __IGetCatalogObject_INTERFACE_DEFINED__
#define __IGetCatalogObject_INTERFACE_DEFINED__

/* interface IGetCatalogObject */
/* [uuid][unique][local][object] */ 


EXTERN_C const IID IID_IGetCatalogObject;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("000001FE-0000-0000-C000-000000000046")
    IGetCatalogObject : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetCatalogObject( 
            /* [in] */ REFIID riid,
            /* [out] */ void **ppv) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IGetCatalogObjectVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IGetCatalogObject * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IGetCatalogObject * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IGetCatalogObject * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetCatalogObject )( 
            IGetCatalogObject * This,
            /* [in] */ REFIID riid,
            /* [out] */ void **ppv);
        
        END_INTERFACE
    } IGetCatalogObjectVtbl;

    interface IGetCatalogObject
    {
        CONST_VTBL struct IGetCatalogObjectVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IGetCatalogObject_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IGetCatalogObject_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IGetCatalogObject_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IGetCatalogObject_GetCatalogObject(This,riid,ppv)	\
    (This)->lpVtbl -> GetCatalogObject(This,riid,ppv)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IGetCatalogObject_GetCatalogObject_Proxy( 
    IGetCatalogObject * This,
    /* [in] */ REFIID riid,
    /* [out] */ void **ppv);


void __RPC_STUB IGetCatalogObject_GetCatalogObject_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IGetCatalogObject_INTERFACE_DEFINED__ */


#ifndef __IComCatalogInternal_INTERFACE_DEFINED__
#define __IComCatalogInternal_INTERFACE_DEFINED__

/* interface IComCatalogInternal */
/* [uuid][unique][local][object] */ 


EXTERN_C const IID IID_IComCatalogInternal;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("a6304910-4115-11d2-8133-0060089f5fed")
    IComCatalogInternal : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetClassInfo( 
            /* [in] */ IUserToken *pUserToken,
            /* [in] */ REFGUID guidConfiguredClsid,
            /* [in] */ REFIID riid,
            /* [out] */ void **ppv,
            /* [in] */ void *pvReserved) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetApplicationInfo( 
            /* [in] */ IUserToken *pUserToken,
            /* [in] */ REFGUID guidApplId,
            /* [in] */ REFIID riid,
            /* [out] */ void **ppv,
            /* [in] */ void *pvReserved) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetProcessInfo( 
            /* [in] */ IUserToken *pUserToken,
            /* [in] */ REFGUID guidProcess,
            /* [in] */ REFIID riid,
            /* [out] */ void **ppv,
            /* [in] */ void *pvReserved) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetServerGroupInfo( 
            /* [in] */ IUserToken *pUserToken,
            /* [in] */ REFGUID guidServerGroup,
            /* [in] */ REFIID riid,
            /* [out] */ void **ppv,
            /* [in] */ void *pvReserved) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetRetQueueInfo( 
            /* [in] */ IUserToken *pUserToken,
            /* [string][in] */ WCHAR *wszFormatName,
            /* [in] */ REFIID riid,
            /* [out] */ void **ppv,
            /* [in] */ void *pvReserved) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetApplicationInfoForExe( 
            /* [in] */ IUserToken *pUserToken,
            /* [string][in] */ WCHAR *pwszExeName,
            /* [in] */ REFIID riid,
            /* [out] */ void **ppv,
            /* [in] */ void *pvReserved) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetTypeLibrary( 
            /* [in] */ IUserToken *pUserToken,
            /* [in] */ REFGUID guidTypeLib,
            /* [in] */ REFIID riid,
            /* [out] */ void **ppv,
            /* [in] */ void *pvReserved) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetInterfaceInfo( 
            /* [in] */ IUserToken *pUserToken,
            /* [in] */ REFIID iidInterface,
            /* [in] */ REFIID riid,
            /* [out] */ void **ppv,
            /* [in] */ void *pComCatalog) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE FlushCache( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetClassInfoFromProgId( 
            /* [in] */ IUserToken *pUserToken,
            /* [in] */ WCHAR *pwszProgID,
            /* [in] */ REFIID riid,
            /* [out] */ void **ppv,
            /* [in] */ void *pComCatalog) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IComCatalogInternalVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IComCatalogInternal * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IComCatalogInternal * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IComCatalogInternal * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetClassInfo )( 
            IComCatalogInternal * This,
            /* [in] */ IUserToken *pUserToken,
            /* [in] */ REFGUID guidConfiguredClsid,
            /* [in] */ REFIID riid,
            /* [out] */ void **ppv,
            /* [in] */ void *pvReserved);
        
        HRESULT ( STDMETHODCALLTYPE *GetApplicationInfo )( 
            IComCatalogInternal * This,
            /* [in] */ IUserToken *pUserToken,
            /* [in] */ REFGUID guidApplId,
            /* [in] */ REFIID riid,
            /* [out] */ void **ppv,
            /* [in] */ void *pvReserved);
        
        HRESULT ( STDMETHODCALLTYPE *GetProcessInfo )( 
            IComCatalogInternal * This,
            /* [in] */ IUserToken *pUserToken,
            /* [in] */ REFGUID guidProcess,
            /* [in] */ REFIID riid,
            /* [out] */ void **ppv,
            /* [in] */ void *pvReserved);
        
        HRESULT ( STDMETHODCALLTYPE *GetServerGroupInfo )( 
            IComCatalogInternal * This,
            /* [in] */ IUserToken *pUserToken,
            /* [in] */ REFGUID guidServerGroup,
            /* [in] */ REFIID riid,
            /* [out] */ void **ppv,
            /* [in] */ void *pvReserved);
        
        HRESULT ( STDMETHODCALLTYPE *GetRetQueueInfo )( 
            IComCatalogInternal * This,
            /* [in] */ IUserToken *pUserToken,
            /* [string][in] */ WCHAR *wszFormatName,
            /* [in] */ REFIID riid,
            /* [out] */ void **ppv,
            /* [in] */ void *pvReserved);
        
        HRESULT ( STDMETHODCALLTYPE *GetApplicationInfoForExe )( 
            IComCatalogInternal * This,
            /* [in] */ IUserToken *pUserToken,
            /* [string][in] */ WCHAR *pwszExeName,
            /* [in] */ REFIID riid,
            /* [out] */ void **ppv,
            /* [in] */ void *pvReserved);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeLibrary )( 
            IComCatalogInternal * This,
            /* [in] */ IUserToken *pUserToken,
            /* [in] */ REFGUID guidTypeLib,
            /* [in] */ REFIID riid,
            /* [out] */ void **ppv,
            /* [in] */ void *pvReserved);
        
        HRESULT ( STDMETHODCALLTYPE *GetInterfaceInfo )( 
            IComCatalogInternal * This,
            /* [in] */ IUserToken *pUserToken,
            /* [in] */ REFIID iidInterface,
            /* [in] */ REFIID riid,
            /* [out] */ void **ppv,
            /* [in] */ void *pComCatalog);
        
        HRESULT ( STDMETHODCALLTYPE *FlushCache )( 
            IComCatalogInternal * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetClassInfoFromProgId )( 
            IComCatalogInternal * This,
            /* [in] */ IUserToken *pUserToken,
            /* [in] */ WCHAR *pwszProgID,
            /* [in] */ REFIID riid,
            /* [out] */ void **ppv,
            /* [in] */ void *pComCatalog);
        
        END_INTERFACE
    } IComCatalogInternalVtbl;

    interface IComCatalogInternal
    {
        CONST_VTBL struct IComCatalogInternalVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IComCatalogInternal_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IComCatalogInternal_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IComCatalogInternal_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IComCatalogInternal_GetClassInfo(This,pUserToken,guidConfiguredClsid,riid,ppv,pvReserved)	\
    (This)->lpVtbl -> GetClassInfo(This,pUserToken,guidConfiguredClsid,riid,ppv,pvReserved)

#define IComCatalogInternal_GetApplicationInfo(This,pUserToken,guidApplId,riid,ppv,pvReserved)	\
    (This)->lpVtbl -> GetApplicationInfo(This,pUserToken,guidApplId,riid,ppv,pvReserved)

#define IComCatalogInternal_GetProcessInfo(This,pUserToken,guidProcess,riid,ppv,pvReserved)	\
    (This)->lpVtbl -> GetProcessInfo(This,pUserToken,guidProcess,riid,ppv,pvReserved)

#define IComCatalogInternal_GetServerGroupInfo(This,pUserToken,guidServerGroup,riid,ppv,pvReserved)	\
    (This)->lpVtbl -> GetServerGroupInfo(This,pUserToken,guidServerGroup,riid,ppv,pvReserved)

#define IComCatalogInternal_GetRetQueueInfo(This,pUserToken,wszFormatName,riid,ppv,pvReserved)	\
    (This)->lpVtbl -> GetRetQueueInfo(This,pUserToken,wszFormatName,riid,ppv,pvReserved)

#define IComCatalogInternal_GetApplicationInfoForExe(This,pUserToken,pwszExeName,riid,ppv,pvReserved)	\
    (This)->lpVtbl -> GetApplicationInfoForExe(This,pUserToken,pwszExeName,riid,ppv,pvReserved)

#define IComCatalogInternal_GetTypeLibrary(This,pUserToken,guidTypeLib,riid,ppv,pvReserved)	\
    (This)->lpVtbl -> GetTypeLibrary(This,pUserToken,guidTypeLib,riid,ppv,pvReserved)

#define IComCatalogInternal_GetInterfaceInfo(This,pUserToken,iidInterface,riid,ppv,pComCatalog)	\
    (This)->lpVtbl -> GetInterfaceInfo(This,pUserToken,iidInterface,riid,ppv,pComCatalog)

#define IComCatalogInternal_FlushCache(This)	\
    (This)->lpVtbl -> FlushCache(This)

#define IComCatalogInternal_GetClassInfoFromProgId(This,pUserToken,pwszProgID,riid,ppv,pComCatalog)	\
    (This)->lpVtbl -> GetClassInfoFromProgId(This,pUserToken,pwszProgID,riid,ppv,pComCatalog)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IComCatalogInternal_GetClassInfo_Proxy( 
    IComCatalogInternal * This,
    /* [in] */ IUserToken *pUserToken,
    /* [in] */ REFGUID guidConfiguredClsid,
    /* [in] */ REFIID riid,
    /* [out] */ void **ppv,
    /* [in] */ void *pvReserved);


void __RPC_STUB IComCatalogInternal_GetClassInfo_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IComCatalogInternal_GetApplicationInfo_Proxy( 
    IComCatalogInternal * This,
    /* [in] */ IUserToken *pUserToken,
    /* [in] */ REFGUID guidApplId,
    /* [in] */ REFIID riid,
    /* [out] */ void **ppv,
    /* [in] */ void *pvReserved);


void __RPC_STUB IComCatalogInternal_GetApplicationInfo_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IComCatalogInternal_GetProcessInfo_Proxy( 
    IComCatalogInternal * This,
    /* [in] */ IUserToken *pUserToken,
    /* [in] */ REFGUID guidProcess,
    /* [in] */ REFIID riid,
    /* [out] */ void **ppv,
    /* [in] */ void *pvReserved);


void __RPC_STUB IComCatalogInternal_GetProcessInfo_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IComCatalogInternal_GetServerGroupInfo_Proxy( 
    IComCatalogInternal * This,
    /* [in] */ IUserToken *pUserToken,
    /* [in] */ REFGUID guidServerGroup,
    /* [in] */ REFIID riid,
    /* [out] */ void **ppv,
    /* [in] */ void *pvReserved);


void __RPC_STUB IComCatalogInternal_GetServerGroupInfo_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IComCatalogInternal_GetRetQueueInfo_Proxy( 
    IComCatalogInternal * This,
    /* [in] */ IUserToken *pUserToken,
    /* [string][in] */ WCHAR *wszFormatName,
    /* [in] */ REFIID riid,
    /* [out] */ void **ppv,
    /* [in] */ void *pvReserved);


void __RPC_STUB IComCatalogInternal_GetRetQueueInfo_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IComCatalogInternal_GetApplicationInfoForExe_Proxy( 
    IComCatalogInternal * This,
    /* [in] */ IUserToken *pUserToken,
    /* [string][in] */ WCHAR *pwszExeName,
    /* [in] */ REFIID riid,
    /* [out] */ void **ppv,
    /* [in] */ void *pvReserved);


void __RPC_STUB IComCatalogInternal_GetApplicationInfoForExe_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IComCatalogInternal_GetTypeLibrary_Proxy( 
    IComCatalogInternal * This,
    /* [in] */ IUserToken *pUserToken,
    /* [in] */ REFGUID guidTypeLib,
    /* [in] */ REFIID riid,
    /* [out] */ void **ppv,
    /* [in] */ void *pvReserved);


void __RPC_STUB IComCatalogInternal_GetTypeLibrary_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IComCatalogInternal_GetInterfaceInfo_Proxy( 
    IComCatalogInternal * This,
    /* [in] */ IUserToken *pUserToken,
    /* [in] */ REFIID iidInterface,
    /* [in] */ REFIID riid,
    /* [out] */ void **ppv,
    /* [in] */ void *pComCatalog);


void __RPC_STUB IComCatalogInternal_GetInterfaceInfo_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IComCatalogInternal_FlushCache_Proxy( 
    IComCatalogInternal * This);


void __RPC_STUB IComCatalogInternal_FlushCache_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IComCatalogInternal_GetClassInfoFromProgId_Proxy( 
    IComCatalogInternal * This,
    /* [in] */ IUserToken *pUserToken,
    /* [in] */ WCHAR *pwszProgID,
    /* [in] */ REFIID riid,
    /* [out] */ void **ppv,
    /* [in] */ void *pComCatalog);


void __RPC_STUB IComCatalogInternal_GetClassInfoFromProgId_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IComCatalogInternal_INTERFACE_DEFINED__ */


#ifndef __IComCatalog2Internal_INTERFACE_DEFINED__
#define __IComCatalog2Internal_INTERFACE_DEFINED__

/* interface IComCatalog2Internal */
/* [uuid][unique][local][object] */ 


EXTERN_C const IID IID_IComCatalog2Internal;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("3310dab4-edc0-4ce9-8a9c-8fea2980fd89")
    IComCatalog2Internal : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetClassInfoByPartition( 
            /* [in] */ IUserToken *pUserToken,
            /* [in] */ REFGUID guidConfiguredClsid,
            /* [in] */ REFGUID guidPartitionId,
            /* [in] */ REFIID riid,
            /* [out] */ void **ppv,
            /* [in] */ void *pComCatalog) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetClassInfoByApplication( 
            /* [in] */ IUserToken *pUserToken,
            /* [in] */ REFGUID guidConfiguredClsid,
            /* [in] */ REFGUID guidPartitionId,
            /* [in] */ REFGUID guidApplId,
            /* [in] */ REFIID riid,
            /* [out] */ void **ppv,
            /* [in] */ void *pComCatalog) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IComCatalog2InternalVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IComCatalog2Internal * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IComCatalog2Internal * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IComCatalog2Internal * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetClassInfoByPartition )( 
            IComCatalog2Internal * This,
            /* [in] */ IUserToken *pUserToken,
            /* [in] */ REFGUID guidConfiguredClsid,
            /* [in] */ REFGUID guidPartitionId,
            /* [in] */ REFIID riid,
            /* [out] */ void **ppv,
            /* [in] */ void *pComCatalog);
        
        HRESULT ( STDMETHODCALLTYPE *GetClassInfoByApplication )( 
            IComCatalog2Internal * This,
            /* [in] */ IUserToken *pUserToken,
            /* [in] */ REFGUID guidConfiguredClsid,
            /* [in] */ REFGUID guidPartitionId,
            /* [in] */ REFGUID guidApplId,
            /* [in] */ REFIID riid,
            /* [out] */ void **ppv,
            /* [in] */ void *pComCatalog);
        
        END_INTERFACE
    } IComCatalog2InternalVtbl;

    interface IComCatalog2Internal
    {
        CONST_VTBL struct IComCatalog2InternalVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IComCatalog2Internal_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IComCatalog2Internal_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IComCatalog2Internal_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IComCatalog2Internal_GetClassInfoByPartition(This,pUserToken,guidConfiguredClsid,guidPartitionId,riid,ppv,pComCatalog)	\
    (This)->lpVtbl -> GetClassInfoByPartition(This,pUserToken,guidConfiguredClsid,guidPartitionId,riid,ppv,pComCatalog)

#define IComCatalog2Internal_GetClassInfoByApplication(This,pUserToken,guidConfiguredClsid,guidPartitionId,guidApplId,riid,ppv,pComCatalog)	\
    (This)->lpVtbl -> GetClassInfoByApplication(This,pUserToken,guidConfiguredClsid,guidPartitionId,guidApplId,riid,ppv,pComCatalog)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IComCatalog2Internal_GetClassInfoByPartition_Proxy( 
    IComCatalog2Internal * This,
    /* [in] */ IUserToken *pUserToken,
    /* [in] */ REFGUID guidConfiguredClsid,
    /* [in] */ REFGUID guidPartitionId,
    /* [in] */ REFIID riid,
    /* [out] */ void **ppv,
    /* [in] */ void *pComCatalog);


void __RPC_STUB IComCatalog2Internal_GetClassInfoByPartition_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IComCatalog2Internal_GetClassInfoByApplication_Proxy( 
    IComCatalog2Internal * This,
    /* [in] */ IUserToken *pUserToken,
    /* [in] */ REFGUID guidConfiguredClsid,
    /* [in] */ REFGUID guidPartitionId,
    /* [in] */ REFGUID guidApplId,
    /* [in] */ REFIID riid,
    /* [out] */ void **ppv,
    /* [in] */ void *pComCatalog);


void __RPC_STUB IComCatalog2Internal_GetClassInfoByApplication_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IComCatalog2Internal_INTERFACE_DEFINED__ */


#ifndef __IComCatalogLocation_INTERFACE_DEFINED__
#define __IComCatalogLocation_INTERFACE_DEFINED__

/* interface IComCatalogLocation */
/* [uuid][unique][local][object] */ 


EXTERN_C const IID IID_IComCatalogLocation;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("fae51051-9887-47f2-af44-7392bf90039b")
    IComCatalogLocation : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE SetCatalogLocation( 
            /* [in] */ BOOL bInSCM) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetCatalogLocation( 
            /* [out] */ BOOL *pbInSCM) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IComCatalogLocationVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IComCatalogLocation * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IComCatalogLocation * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IComCatalogLocation * This);
        
        HRESULT ( STDMETHODCALLTYPE *SetCatalogLocation )( 
            IComCatalogLocation * This,
            /* [in] */ BOOL bInSCM);
        
        HRESULT ( STDMETHODCALLTYPE *GetCatalogLocation )( 
            IComCatalogLocation * This,
            /* [out] */ BOOL *pbInSCM);
        
        END_INTERFACE
    } IComCatalogLocationVtbl;

    interface IComCatalogLocation
    {
        CONST_VTBL struct IComCatalogLocationVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IComCatalogLocation_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IComCatalogLocation_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IComCatalogLocation_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IComCatalogLocation_SetCatalogLocation(This,bInSCM)	\
    (This)->lpVtbl -> SetCatalogLocation(This,bInSCM)

#define IComCatalogLocation_GetCatalogLocation(This,pbInSCM)	\
    (This)->lpVtbl -> GetCatalogLocation(This,pbInSCM)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IComCatalogLocation_SetCatalogLocation_Proxy( 
    IComCatalogLocation * This,
    /* [in] */ BOOL bInSCM);


void __RPC_STUB IComCatalogLocation_SetCatalogLocation_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IComCatalogLocation_GetCatalogLocation_Proxy( 
    IComCatalogLocation * This,
    /* [out] */ BOOL *pbInSCM);


void __RPC_STUB IComCatalogLocation_GetCatalogLocation_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IComCatalogLocation_INTERFACE_DEFINED__ */


#ifndef __ICacheControl_INTERFACE_DEFINED__
#define __ICacheControl_INTERFACE_DEFINED__

/* interface ICacheControl */
/* [uuid][unique][local][object] */ 


EXTERN_C const IID IID_ICacheControl;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("59a47420-0094-11d2-bbf7-0060089f5fed")
    ICacheControl : public IUnknown
    {
    public:
        virtual ULONG STDMETHODCALLTYPE CacheAddRef( void) = 0;
        
        virtual ULONG STDMETHODCALLTYPE CacheRelease( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ICacheControlVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ICacheControl * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ICacheControl * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ICacheControl * This);
        
        ULONG ( STDMETHODCALLTYPE *CacheAddRef )( 
            ICacheControl * This);
        
        ULONG ( STDMETHODCALLTYPE *CacheRelease )( 
            ICacheControl * This);
        
        END_INTERFACE
    } ICacheControlVtbl;

    interface ICacheControl
    {
        CONST_VTBL struct ICacheControlVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ICacheControl_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ICacheControl_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ICacheControl_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ICacheControl_CacheAddRef(This)	\
    (This)->lpVtbl -> CacheAddRef(This)

#define ICacheControl_CacheRelease(This)	\
    (This)->lpVtbl -> CacheRelease(This)

#endif /* COBJMACROS */


#endif 	/* C style interface */



ULONG STDMETHODCALLTYPE ICacheControl_CacheAddRef_Proxy( 
    ICacheControl * This);


void __RPC_STUB ICacheControl_CacheAddRef_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


ULONG STDMETHODCALLTYPE ICacheControl_CacheRelease_Proxy( 
    ICacheControl * This);


void __RPC_STUB ICacheControl_CacheRelease_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ICacheControl_INTERFACE_DEFINED__ */


/* Additional Prototypes for ALL interfaces */

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\public\internal\com\inc\trksvr_c.c ===
#pragma warning( disable: 4049 )  /* more than 64k source lines */

/* this ALWAYS GENERATED file contains the RPC client stubs */


 /* File created by MIDL compiler version 6.00.0347 */
/* Compiler settings for trksvr.idl:
    Oicf, W1, Zp8, env=Win32 (32b run)
    protocol : dce , ms_ext, c_ext, robust
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )

#if !defined(_M_IA64) && !defined(_M_AMD64)
#include <string.h>

#include "trksvr.h"

#define TYPE_FORMAT_STRING_SIZE   563                               
#define PROC_FORMAT_STRING_SIZE   77                                
#define TRANSMIT_AS_TABLE_SIZE    0            
#define WIRE_MARSHAL_TABLE_SIZE   0            

typedef struct _MIDL_TYPE_FORMAT_STRING
    {
    short          Pad;
    unsigned char  Format[ TYPE_FORMAT_STRING_SIZE ];
    } MIDL_TYPE_FORMAT_STRING;

typedef struct _MIDL_PROC_FORMAT_STRING
    {
    short          Pad;
    unsigned char  Format[ PROC_FORMAT_STRING_SIZE ];
    } MIDL_PROC_FORMAT_STRING;


static RPC_SYNTAX_IDENTIFIER  _RpcTransferSyntax = 
{{0x8A885D04,0x1CEB,0x11C9,{0x9F,0xE8,0x08,0x00,0x2B,0x10,0x48,0x60}},{2,0}};


extern const MIDL_TYPE_FORMAT_STRING __MIDL_TypeFormatString;
extern const MIDL_PROC_FORMAT_STRING __MIDL_ProcFormatString;

#define GENERIC_BINDING_TABLE_SIZE   0            


/* Standard interface: __MIDL_itf_trksvr_0000, ver. 0.0,
   GUID={0x00000000,0x0000,0x0000,{0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00}} */


/* Standard interface: trksvr, ver. 1.0,
   GUID={0x4da1c422,0x943d,0x11d1,{0xac,0xae,0x00,0xc0,0x4f,0xc2,0xaa,0x3f}} */


extern const MIDL_SERVER_INFO trksvr_ServerInfo;
handle_t notused;


extern RPC_DISPATCH_TABLE trksvr_v1_0_DispatchTable;

static const RPC_CLIENT_INTERFACE trksvr___RpcClientInterface =
    {
    sizeof(RPC_CLIENT_INTERFACE),
    {{0x4da1c422,0x943d,0x11d1,{0xac,0xae,0x00,0xc0,0x4f,0xc2,0xaa,0x3f}},{1,0}},
    {{0x8A885D04,0x1CEB,0x11C9,{0x9F,0xE8,0x08,0x00,0x2B,0x10,0x48,0x60}},{2,0}},
    &trksvr_v1_0_DispatchTable,
    0,
    0,
    0,
    &trksvr_ServerInfo,
    0x04000000
    };
RPC_IF_HANDLE trksvr_v1_0_c_ifspec = (RPC_IF_HANDLE)& trksvr___RpcClientInterface;

extern const MIDL_STUB_DESC trksvr_StubDesc;

static RPC_BINDING_HANDLE trksvr__MIDL_AutoBindHandle;


HRESULT LnkSvrMessage( 
    /* [in] */ handle_t IDL_handle,
    /* [out][in] */ TRKSVR_MESSAGE_UNION *pMsg)
{

    CLIENT_CALL_RETURN _RetVal;

    _RetVal = NdrClientCall2(
                  ( PMIDL_STUB_DESC  )&trksvr_StubDesc,
                  (PFORMAT_STRING) &__MIDL_ProcFormatString.Format[0],
                  ( unsigned char * )&IDL_handle);
    return ( HRESULT  )_RetVal.Simple;
    
}


#if !defined(__RPC_WIN32__)
#error  Invalid build platform for this stub.
#endif

#if !(TARGET_IS_NT50_OR_LATER)
#error You need a Windows 2000 or later to run this stub because it uses these features:
#error   /robust command line switch.
#error However, your C/C++ compilation flags indicate you intend to run this app on earlier systems.
#error This app will die there with the RPC_X_WRONG_STUB_VERSION error.
#endif


static const MIDL_PROC_FORMAT_STRING __MIDL_ProcFormatString =
    {
        0,
        {

	/* Procedure LnkSvrMessage */

			0x0,		/* 0 */
			0x48,		/* Old Flags:  */
/*  2 */	NdrFcLong( 0x0 ),	/* 0 */
/*  6 */	NdrFcShort( 0x0 ),	/* 0 */
/*  8 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 10 */	0x32,		/* FC_BIND_PRIMITIVE */
			0x0,		/* 0 */
/* 12 */	NdrFcShort( 0x0 ),	/* x86 Stack size/offset = 0 */
/* 14 */	NdrFcShort( 0x0 ),	/* 0 */
/* 16 */	NdrFcShort( 0x8 ),	/* 8 */
/* 18 */	0x47,		/* Oi2 Flags:  srv must size, clt must size, has return, has ext, */
			0x2,		/* 2 */
/* 20 */	0x8,		/* 8 */
			0x7,		/* Ext Flags:  new corr desc, clt corr check, srv corr check, */
/* 22 */	NdrFcShort( 0xb ),	/* 11 */
/* 24 */	NdrFcShort( 0xb ),	/* 11 */
/* 26 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter IDL_handle */

/* 28 */	NdrFcShort( 0x11b ),	/* Flags:  must size, must free, in, out, simple ref, */
/* 30 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 32 */	NdrFcShort( 0x21e ),	/* Type Offset=542 */

	/* Parameter pMsg */

/* 34 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 36 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 38 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure LnkSvrMessageCallback */


	/* Return value */

/* 40 */	0x34,		/* FC_CALLBACK_HANDLE */
			0x48,		/* Old Flags:  */
/* 42 */	NdrFcLong( 0x0 ),	/* 0 */
/* 46 */	NdrFcShort( 0x0 ),	/* 0 */
/* 48 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 50 */	NdrFcShort( 0x0 ),	/* 0 */
/* 52 */	NdrFcShort( 0x8 ),	/* 8 */
/* 54 */	0x47,		/* Oi2 Flags:  srv must size, clt must size, has return, has ext, */
			0x2,		/* 2 */
/* 56 */	0x8,		/* 8 */
			0x7,		/* Ext Flags:  new corr desc, clt corr check, srv corr check, */
/* 58 */	NdrFcShort( 0xb ),	/* 11 */
/* 60 */	NdrFcShort( 0xb ),	/* 11 */
/* 62 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter pMsg */

/* 64 */	NdrFcShort( 0x11b ),	/* Flags:  must size, must free, in, out, simple ref, */
/* 66 */	NdrFcShort( 0x0 ),	/* x86 Stack size/offset = 0 */
/* 68 */	NdrFcShort( 0x21e ),	/* Type Offset=542 */

	/* Return value */

/* 70 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 72 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 74 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

			0x0
        }
    };

static const MIDL_TYPE_FORMAT_STRING __MIDL_TypeFormatString =
    {
        0,
        {
			NdrFcShort( 0x0 ),	/* 0 */
/*  2 */	
			0x11, 0x0,	/* FC_RP */
/*  4 */	NdrFcShort( 0x21a ),	/* Offset= 538 (542) */
/*  6 */	
			0x2b,		/* FC_NON_ENCAPSULATED_UNION */
			0x8,		/* FC_LONG */
/*  8 */	0x8,		/* Corr desc: FC_LONG */
			0x0,		/*  */
/* 10 */	NdrFcShort( 0xfff8 ),	/* -8 */
/* 12 */	NdrFcShort( 0x1 ),	/* Corr flags:  early, */
/* 14 */	NdrFcShort( 0x2 ),	/* Offset= 2 (16) */
/* 16 */	NdrFcShort( 0xc8 ),	/* 200 */
/* 18 */	NdrFcShort( 0x9 ),	/* 9 */
/* 20 */	NdrFcLong( 0x0 ),	/* 0 */
/* 24 */	NdrFcShort( 0x88 ),	/* Offset= 136 (160) */
/* 26 */	NdrFcLong( 0x1 ),	/* 1 */
/* 30 */	NdrFcShort( 0xb6 ),	/* Offset= 182 (212) */
/* 32 */	NdrFcLong( 0x2 ),	/* 2 */
/* 36 */	NdrFcShort( 0xf8 ),	/* Offset= 248 (284) */
/* 38 */	NdrFcLong( 0x3 ),	/* 3 */
/* 42 */	NdrFcShort( 0x160 ),	/* Offset= 352 (394) */
/* 44 */	NdrFcLong( 0x4 ),	/* 4 */
/* 48 */	NdrFcShort( 0xec ),	/* Offset= 236 (284) */
/* 50 */	NdrFcLong( 0x5 ),	/* 5 */
/* 54 */	NdrFcShort( 0x170 ),	/* Offset= 368 (422) */
/* 56 */	NdrFcLong( 0x6 ),	/* 6 */
/* 60 */	NdrFcShort( 0x1ce ),	/* Offset= 462 (522) */
/* 62 */	NdrFcLong( 0x7 ),	/* 7 */
/* 66 */	NdrFcShort( 0x104 ),	/* Offset= 260 (326) */
/* 68 */	NdrFcLong( 0x8 ),	/* 8 */
/* 72 */	NdrFcShort( 0x8008 ),	/* Simple arm type: FC_LONG */
/* 74 */	NdrFcShort( 0xffffffff ),	/* Offset= -1 (73) */
/* 76 */	
			0x1d,		/* FC_SMFARRAY */
			0x1,		/* 1 */
/* 78 */	NdrFcShort( 0x202 ),	/* 514 */
/* 80 */	0x5,		/* FC_WCHAR */
			0x5b,		/* FC_END */
/* 82 */	
			0x1d,		/* FC_SMFARRAY */
			0x0,		/* 0 */
/* 84 */	NdrFcShort( 0x8 ),	/* 8 */
/* 86 */	0x1,		/* FC_BYTE */
			0x5b,		/* FC_END */
/* 88 */	
			0x15,		/* FC_STRUCT */
			0x3,		/* 3 */
/* 90 */	NdrFcShort( 0x10 ),	/* 16 */
/* 92 */	0x8,		/* FC_LONG */
			0x6,		/* FC_SHORT */
/* 94 */	0x6,		/* FC_SHORT */
			0x4c,		/* FC_EMBEDDED_COMPLEX */
/* 96 */	0x0,		/* 0 */
			NdrFcShort( 0xfffffff1 ),	/* Offset= -15 (82) */
			0x5b,		/* FC_END */
/* 100 */	
			0x15,		/* FC_STRUCT */
			0x3,		/* 3 */
/* 102 */	NdrFcShort( 0x10 ),	/* 16 */
/* 104 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 106 */	NdrFcShort( 0xffffffee ),	/* Offset= -18 (88) */
/* 108 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 110 */	
			0x15,		/* FC_STRUCT */
			0x3,		/* 3 */
/* 112 */	NdrFcShort( 0x20 ),	/* 32 */
/* 114 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 116 */	NdrFcShort( 0xfffffff0 ),	/* Offset= -16 (100) */
/* 118 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 120 */	NdrFcShort( 0xffffffec ),	/* Offset= -20 (100) */
/* 122 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 124 */	
			0x15,		/* FC_STRUCT */
			0x3,		/* 3 */
/* 126 */	NdrFcShort( 0x248 ),	/* 584 */
/* 128 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 130 */	NdrFcShort( 0xffffffca ),	/* Offset= -54 (76) */
/* 132 */	0x3e,		/* FC_STRUCTPAD2 */
			0x4c,		/* FC_EMBEDDED_COMPLEX */
/* 134 */	0x0,		/* 0 */
			NdrFcShort( 0xffffffe7 ),	/* Offset= -25 (110) */
			0x4c,		/* FC_EMBEDDED_COMPLEX */
/* 138 */	0x0,		/* 0 */
			NdrFcShort( 0xffffffe3 ),	/* Offset= -29 (110) */
			0x8,		/* FC_LONG */
/* 142 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 144 */	
			0x1b,		/* FC_CARRAY */
			0x3,		/* 3 */
/* 146 */	NdrFcShort( 0x248 ),	/* 584 */
/* 148 */	0x19,		/* Corr desc:  field pointer, FC_ULONG */
			0x0,		/*  */
/* 150 */	NdrFcShort( 0x0 ),	/* 0 */
/* 152 */	NdrFcShort( 0x1 ),	/* Corr flags:  early, */
/* 154 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 156 */	NdrFcShort( 0xffffffe0 ),	/* Offset= -32 (124) */
/* 158 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 160 */	
			0x16,		/* FC_PSTRUCT */
			0x3,		/* 3 */
/* 162 */	NdrFcShort( 0x8 ),	/* 8 */
/* 164 */	
			0x4b,		/* FC_PP */
			0x5c,		/* FC_PAD */
/* 166 */	
			0x46,		/* FC_NO_REPEAT */
			0x5c,		/* FC_PAD */
/* 168 */	NdrFcShort( 0x4 ),	/* 4 */
/* 170 */	NdrFcShort( 0x4 ),	/* 4 */
/* 172 */	0x12, 0x0,	/* FC_UP */
/* 174 */	NdrFcShort( 0xffffffe2 ),	/* Offset= -30 (144) */
/* 176 */	
			0x5b,		/* FC_END */

			0x8,		/* FC_LONG */
/* 178 */	0x8,		/* FC_LONG */
			0x5b,		/* FC_END */
/* 180 */	
			0x1b,		/* FC_CARRAY */
			0x3,		/* 3 */
/* 182 */	NdrFcShort( 0x10 ),	/* 16 */
/* 184 */	0x19,		/* Corr desc:  field pointer, FC_ULONG */
			0x0,		/*  */
/* 186 */	NdrFcShort( 0x0 ),	/* 0 */
/* 188 */	NdrFcShort( 0x1 ),	/* Corr flags:  early, */
/* 190 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 192 */	NdrFcShort( 0xffffffa4 ),	/* Offset= -92 (100) */
/* 194 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 196 */	
			0x1b,		/* FC_CARRAY */
			0x3,		/* 3 */
/* 198 */	NdrFcShort( 0x20 ),	/* 32 */
/* 200 */	0x19,		/* Corr desc:  field pointer, FC_ULONG */
			0x0,		/*  */
/* 202 */	NdrFcShort( 0x0 ),	/* 0 */
/* 204 */	NdrFcShort( 0x1 ),	/* Corr flags:  early, */
/* 206 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 208 */	NdrFcShort( 0xffffff9e ),	/* Offset= -98 (110) */
/* 210 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 212 */	
			0x16,		/* FC_PSTRUCT */
			0x3,		/* 3 */
/* 214 */	NdrFcShort( 0x20 ),	/* 32 */
/* 216 */	
			0x4b,		/* FC_PP */
			0x5c,		/* FC_PAD */
/* 218 */	
			0x46,		/* FC_NO_REPEAT */
			0x5c,		/* FC_PAD */
/* 220 */	NdrFcShort( 0x10 ),	/* 16 */
/* 222 */	NdrFcShort( 0x10 ),	/* 16 */
/* 224 */	0x12, 0x0,	/* FC_UP */
/* 226 */	NdrFcShort( 0xffffff82 ),	/* Offset= -126 (100) */
/* 228 */	
			0x46,		/* FC_NO_REPEAT */
			0x5c,		/* FC_PAD */
/* 230 */	NdrFcShort( 0x14 ),	/* 20 */
/* 232 */	NdrFcShort( 0x14 ),	/* 20 */
/* 234 */	0x12, 0x0,	/* FC_UP */
/* 236 */	NdrFcShort( 0xffffffc8 ),	/* Offset= -56 (180) */
/* 238 */	
			0x46,		/* FC_NO_REPEAT */
			0x5c,		/* FC_PAD */
/* 240 */	NdrFcShort( 0x18 ),	/* 24 */
/* 242 */	NdrFcShort( 0x18 ),	/* 24 */
/* 244 */	0x12, 0x0,	/* FC_UP */
/* 246 */	NdrFcShort( 0xffffffce ),	/* Offset= -50 (196) */
/* 248 */	
			0x46,		/* FC_NO_REPEAT */
			0x5c,		/* FC_PAD */
/* 250 */	NdrFcShort( 0x1c ),	/* 28 */
/* 252 */	NdrFcShort( 0x1c ),	/* 28 */
/* 254 */	0x12, 0x0,	/* FC_UP */
/* 256 */	NdrFcShort( 0xffffffc4 ),	/* Offset= -60 (196) */
/* 258 */	
			0x5b,		/* FC_END */

			0x8,		/* FC_LONG */
/* 260 */	0x8,		/* FC_LONG */
			0x8,		/* FC_LONG */
/* 262 */	0x8,		/* FC_LONG */
			0x8,		/* FC_LONG */
/* 264 */	0x8,		/* FC_LONG */
			0x8,		/* FC_LONG */
/* 266 */	0x8,		/* FC_LONG */
			0x5b,		/* FC_END */
/* 268 */	
			0x1b,		/* FC_CARRAY */
			0x3,		/* 3 */
/* 270 */	NdrFcShort( 0x10 ),	/* 16 */
/* 272 */	0x19,		/* Corr desc:  field pointer, FC_ULONG */
			0x0,		/*  */
/* 274 */	NdrFcShort( 0x8 ),	/* 8 */
/* 276 */	NdrFcShort( 0x1 ),	/* Corr flags:  early, */
/* 278 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 280 */	NdrFcShort( 0xffffff4c ),	/* Offset= -180 (100) */
/* 282 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 284 */	
			0x16,		/* FC_PSTRUCT */
			0x3,		/* 3 */
/* 286 */	NdrFcShort( 0x10 ),	/* 16 */
/* 288 */	
			0x4b,		/* FC_PP */
			0x5c,		/* FC_PAD */
/* 290 */	
			0x46,		/* FC_NO_REPEAT */
			0x5c,		/* FC_PAD */
/* 292 */	NdrFcShort( 0x4 ),	/* 4 */
/* 294 */	NdrFcShort( 0x4 ),	/* 4 */
/* 296 */	0x12, 0x0,	/* FC_UP */
/* 298 */	NdrFcShort( 0xffffff9a ),	/* Offset= -102 (196) */
/* 300 */	
			0x46,		/* FC_NO_REPEAT */
			0x5c,		/* FC_PAD */
/* 302 */	NdrFcShort( 0xc ),	/* 12 */
/* 304 */	NdrFcShort( 0xc ),	/* 12 */
/* 306 */	0x12, 0x0,	/* FC_UP */
/* 308 */	NdrFcShort( 0xffffffd8 ),	/* Offset= -40 (268) */
/* 310 */	
			0x5b,		/* FC_END */

			0x8,		/* FC_LONG */
/* 312 */	0x8,		/* FC_LONG */
			0x8,		/* FC_LONG */
/* 314 */	0x8,		/* FC_LONG */
			0x5b,		/* FC_END */
/* 316 */	
			0x15,		/* FC_STRUCT */
			0x0,		/* 0 */
/* 318 */	NdrFcShort( 0x8 ),	/* 8 */
/* 320 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 322 */	NdrFcShort( 0xffffff10 ),	/* Offset= -240 (82) */
/* 324 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 326 */	
			0x15,		/* FC_STRUCT */
			0x3,		/* 3 */
/* 328 */	NdrFcShort( 0x8 ),	/* 8 */
/* 330 */	0x8,		/* FC_LONG */
			0x8,		/* FC_LONG */
/* 332 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 334 */	
			0x1d,		/* FC_SMFARRAY */
			0x0,		/* 0 */
/* 336 */	NdrFcShort( 0x10 ),	/* 16 */
/* 338 */	0x2,		/* FC_CHAR */
			0x5b,		/* FC_END */
/* 340 */	
			0x15,		/* FC_STRUCT */
			0x0,		/* 0 */
/* 342 */	NdrFcShort( 0x10 ),	/* 16 */
/* 344 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 346 */	NdrFcShort( 0xfffffff4 ),	/* Offset= -12 (334) */
/* 348 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 350 */	
			0x15,		/* FC_STRUCT */
			0x3,		/* 3 */
/* 352 */	NdrFcShort( 0x44 ),	/* 68 */
/* 354 */	0x8,		/* FC_LONG */
			0xe,		/* FC_ENUM32 */
/* 356 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 358 */	NdrFcShort( 0xfffffefe ),	/* Offset= -258 (100) */
/* 360 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 362 */	NdrFcShort( 0xffffffd2 ),	/* Offset= -46 (316) */
/* 364 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 366 */	NdrFcShort( 0xffffffce ),	/* Offset= -50 (316) */
/* 368 */	0x8,		/* FC_LONG */
			0x4c,		/* FC_EMBEDDED_COMPLEX */
/* 370 */	0x0,		/* 0 */
			NdrFcShort( 0xffffffd3 ),	/* Offset= -45 (326) */
			0x4c,		/* FC_EMBEDDED_COMPLEX */
/* 374 */	0x0,		/* 0 */
			NdrFcShort( 0xffffffdd ),	/* Offset= -35 (340) */
			0x5b,		/* FC_END */
/* 378 */	
			0x1b,		/* FC_CARRAY */
			0x3,		/* 3 */
/* 380 */	NdrFcShort( 0x44 ),	/* 68 */
/* 382 */	0x19,		/* Corr desc:  field pointer, FC_ULONG */
			0x0,		/*  */
/* 384 */	NdrFcShort( 0x0 ),	/* 0 */
/* 386 */	NdrFcShort( 0x1 ),	/* Corr flags:  early, */
/* 388 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 390 */	NdrFcShort( 0xffffffd8 ),	/* Offset= -40 (350) */
/* 392 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 394 */	
			0x16,		/* FC_PSTRUCT */
			0x3,		/* 3 */
/* 396 */	NdrFcShort( 0x8 ),	/* 8 */
/* 398 */	
			0x4b,		/* FC_PP */
			0x5c,		/* FC_PAD */
/* 400 */	
			0x46,		/* FC_NO_REPEAT */
			0x5c,		/* FC_PAD */
/* 402 */	NdrFcShort( 0x4 ),	/* 4 */
/* 404 */	NdrFcShort( 0x4 ),	/* 4 */
/* 406 */	0x12, 0x0,	/* FC_UP */
/* 408 */	NdrFcShort( 0xffffffe2 ),	/* Offset= -30 (378) */
/* 410 */	
			0x5b,		/* FC_END */

			0x8,		/* FC_LONG */
/* 412 */	0x8,		/* FC_LONG */
			0x5b,		/* FC_END */
/* 414 */	
			0x15,		/* FC_STRUCT */
			0x3,		/* 3 */
/* 416 */	NdrFcShort( 0xc ),	/* 12 */
/* 418 */	0x8,		/* FC_LONG */
			0x8,		/* FC_LONG */
/* 420 */	0x8,		/* FC_LONG */
			0x5b,		/* FC_END */
/* 422 */	
			0x15,		/* FC_STRUCT */
			0x3,		/* 3 */
/* 424 */	NdrFcShort( 0xc8 ),	/* 200 */
/* 426 */	0x8,		/* FC_LONG */
			0x8,		/* FC_LONG */
/* 428 */	0x8,		/* FC_LONG */
			0x8,		/* FC_LONG */
/* 430 */	0x8,		/* FC_LONG */
			0x8,		/* FC_LONG */
/* 432 */	0x8,		/* FC_LONG */
			0x8,		/* FC_LONG */
/* 434 */	0x8,		/* FC_LONG */
			0x8,		/* FC_LONG */
/* 436 */	0x8,		/* FC_LONG */
			0x8,		/* FC_LONG */
/* 438 */	0x8,		/* FC_LONG */
			0x8,		/* FC_LONG */
/* 440 */	0x8,		/* FC_LONG */
			0x8,		/* FC_LONG */
/* 442 */	0x8,		/* FC_LONG */
			0x8,		/* FC_LONG */
/* 444 */	0x8,		/* FC_LONG */
			0x8,		/* FC_LONG */
/* 446 */	0x8,		/* FC_LONG */
			0x8,		/* FC_LONG */
/* 448 */	0x8,		/* FC_LONG */
			0x8,		/* FC_LONG */
/* 450 */	0x8,		/* FC_LONG */
			0x8,		/* FC_LONG */
/* 452 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 454 */	NdrFcShort( 0xffffff80 ),	/* Offset= -128 (326) */
/* 456 */	0x8,		/* FC_LONG */
			0x8,		/* FC_LONG */
/* 458 */	0x8,		/* FC_LONG */
			0x8,		/* FC_LONG */
/* 460 */	0x8,		/* FC_LONG */
			0x4c,		/* FC_EMBEDDED_COMPLEX */
/* 462 */	0x0,		/* 0 */
			NdrFcShort( 0xffffff77 ),	/* Offset= -137 (326) */
			0x8,		/* FC_LONG */
/* 466 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 468 */	NdrFcShort( 0xffffff72 ),	/* Offset= -142 (326) */
/* 470 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 472 */	NdrFcShort( 0xffffff6e ),	/* Offset= -146 (326) */
/* 474 */	0x8,		/* FC_LONG */
			0x8,		/* FC_LONG */
/* 476 */	0x8,		/* FC_LONG */
			0x8,		/* FC_LONG */
/* 478 */	0x8,		/* FC_LONG */
			0x6,		/* FC_SHORT */
/* 480 */	0x6,		/* FC_SHORT */
			0x6,		/* FC_SHORT */
/* 482 */	0x6,		/* FC_SHORT */
			0x4c,		/* FC_EMBEDDED_COMPLEX */
/* 484 */	0x0,		/* 0 */
			NdrFcShort( 0xffffffb9 ),	/* Offset= -71 (414) */
			0x5b,		/* FC_END */
/* 488 */	
			0x15,		/* FC_STRUCT */
			0x3,		/* 3 */
/* 490 */	NdrFcShort( 0x54 ),	/* 84 */
/* 492 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 494 */	NdrFcShort( 0xfffffe80 ),	/* Offset= -384 (110) */
/* 496 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 498 */	NdrFcShort( 0xfffffe7c ),	/* Offset= -388 (110) */
/* 500 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 502 */	NdrFcShort( 0xffffff5e ),	/* Offset= -162 (340) */
/* 504 */	0x8,		/* FC_LONG */
			0x5b,		/* FC_END */
/* 506 */	
			0x1b,		/* FC_CARRAY */
			0x3,		/* 3 */
/* 508 */	NdrFcShort( 0x54 ),	/* 84 */
/* 510 */	0x19,		/* Corr desc:  field pointer, FC_ULONG */
			0x0,		/*  */
/* 512 */	NdrFcShort( 0x0 ),	/* 0 */
/* 514 */	NdrFcShort( 0x1 ),	/* Corr flags:  early, */
/* 516 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 518 */	NdrFcShort( 0xffffffe2 ),	/* Offset= -30 (488) */
/* 520 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 522 */	
			0x16,		/* FC_PSTRUCT */
			0x3,		/* 3 */
/* 524 */	NdrFcShort( 0x8 ),	/* 8 */
/* 526 */	
			0x4b,		/* FC_PP */
			0x5c,		/* FC_PAD */
/* 528 */	
			0x46,		/* FC_NO_REPEAT */
			0x5c,		/* FC_PAD */
/* 530 */	NdrFcShort( 0x4 ),	/* 4 */
/* 532 */	NdrFcShort( 0x4 ),	/* 4 */
/* 534 */	0x12, 0x0,	/* FC_UP */
/* 536 */	NdrFcShort( 0xffffffe2 ),	/* Offset= -30 (506) */
/* 538 */	
			0x5b,		/* FC_END */

			0x8,		/* FC_LONG */
/* 540 */	0x8,		/* FC_LONG */
			0x5b,		/* FC_END */
/* 542 */	
			0x1a,		/* FC_BOGUS_STRUCT */
			0x3,		/* 3 */
/* 544 */	NdrFcShort( 0xd4 ),	/* 212 */
/* 546 */	NdrFcShort( 0x0 ),	/* 0 */
/* 548 */	NdrFcShort( 0xa ),	/* Offset= 10 (558) */
/* 550 */	0xe,		/* FC_ENUM32 */
			0xe,		/* FC_ENUM32 */
/* 552 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 554 */	NdrFcShort( 0xfffffddc ),	/* Offset= -548 (6) */
/* 556 */	0x36,		/* FC_POINTER */
			0x5b,		/* FC_END */
/* 558 */	
			0x12, 0x8,	/* FC_UP [simple_pointer] */
/* 560 */	
			0x25,		/* FC_C_WSTRING */
			0x5c,		/* FC_PAD */

			0x0
        }
    };

static const unsigned short trksvr_FormatStringOffsetTable[] =
    {
    0,
    };


static const unsigned short _callbacktrksvr_FormatStringOffsetTable[] =
    {
    40
    };


static const MIDL_STUB_DESC trksvr_StubDesc = 
    {
    (void *)& trksvr___RpcClientInterface,
    MIDL_user_allocate,
    MIDL_user_free,
    &notused,
    0,
    0,
    0,
    0,
    __MIDL_TypeFormatString.Format,
    1, /* -error bounds_check flag */
    0x50002, /* Ndr library version */
    0,
    0x600015b, /* MIDL Version 6.0.347 */
    0,
    0,
    0,  /* notify & notify_flag routine table */
    0x1, /* MIDL flag */
    0, /* cs routines */
    0,   /* proxy/server info */
    0   /* Reserved5 */
    };

static RPC_DISPATCH_FUNCTION trksvr_table[] =
    {
    NdrServerCall2,
    0
    };
RPC_DISPATCH_TABLE trksvr_v1_0_DispatchTable = 
    {
    1,
    trksvr_table
    };

static const SERVER_ROUTINE trksvr_ServerRoutineTable[] = 
    {
    (SERVER_ROUTINE)StubLnkSvrMessageCallback
    };

static const MIDL_SERVER_INFO trksvr_ServerInfo = 
    {
    &trksvr_StubDesc,
    trksvr_ServerRoutineTable,
    __MIDL_ProcFormatString.Format,
    _callbacktrksvr_FormatStringOffsetTable,
    0,
    0,
    0,
    0};


#endif /* !defined(_M_IA64) && !defined(_M_AMD64)*/


#pragma warning( disable: 4049 )  /* more than 64k source lines */

/* this ALWAYS GENERATED file contains the RPC client stubs */


 /* File created by MIDL compiler version 6.00.0347 */
/* Compiler settings for trksvr.idl:
    Oicf, W1, Zp8, env=Win64 (32b run,appending)
    protocol : dce , ms_ext, c_ext, robust
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )

#if defined(_M_IA64) || defined(_M_AMD64)
#include <string.h>

#include "trksvr.h"

#define TYPE_FORMAT_STRING_SIZE   545                               
#define PROC_FORMAT_STRING_SIZE   81                                
#define TRANSMIT_AS_TABLE_SIZE    0            
#define WIRE_MARSHAL_TABLE_SIZE   0            

typedef struct _MIDL_TYPE_FORMAT_STRING
    {
    short          Pad;
    unsigned char  Format[ TYPE_FORMAT_STRING_SIZE ];
    } MIDL_TYPE_FORMAT_STRING;

typedef struct _MIDL_PROC_FORMAT_STRING
    {
    short          Pad;
    unsigned char  Format[ PROC_FORMAT_STRING_SIZE ];
    } MIDL_PROC_FORMAT_STRING;


static RPC_SYNTAX_IDENTIFIER  _RpcTransferSyntax = 
{{0x8A885D04,0x1CEB,0x11C9,{0x9F,0xE8,0x08,0x00,0x2B,0x10,0x48,0x60}},{2,0}};


extern const MIDL_TYPE_FORMAT_STRING __MIDL_TypeFormatString;
extern const MIDL_PROC_FORMAT_STRING __MIDL_ProcFormatString;

#define GENERIC_BINDING_TABLE_SIZE   0            


/* Standard interface: __MIDL_itf_trksvr_0000, ver. 0.0,
   GUID={0x00000000,0x0000,0x0000,{0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00}} */


/* Standard interface: trksvr, ver. 1.0,
   GUID={0x4da1c422,0x943d,0x11d1,{0xac,0xae,0x00,0xc0,0x4f,0xc2,0xaa,0x3f}} */


extern const MIDL_SERVER_INFO trksvr_ServerInfo;
handle_t notused;


extern RPC_DISPATCH_TABLE trksvr_v1_0_DispatchTable;

static const RPC_CLIENT_INTERFACE trksvr___RpcClientInterface =
    {
    sizeof(RPC_CLIENT_INTERFACE),
    {{0x4da1c422,0x943d,0x11d1,{0xac,0xae,0x00,0xc0,0x4f,0xc2,0xaa,0x3f}},{1,0}},
    {{0x8A885D04,0x1CEB,0x11C9,{0x9F,0xE8,0x08,0x00,0x2B,0x10,0x48,0x60}},{2,0}},
    &trksvr_v1_0_DispatchTable,
    0,
    0,
    0,
    &trksvr_ServerInfo,
    0x04000000
    };
RPC_IF_HANDLE trksvr_v1_0_c_ifspec = (RPC_IF_HANDLE)& trksvr___RpcClientInterface;

extern const MIDL_STUB_DESC trksvr_StubDesc;

static RPC_BINDING_HANDLE trksvr__MIDL_AutoBindHandle;


HRESULT LnkSvrMessage( 
    /* [in] */ handle_t IDL_handle,
    /* [out][in] */ TRKSVR_MESSAGE_UNION *pMsg)
{

    CLIENT_CALL_RETURN _RetVal;

    _RetVal = NdrClientCall2(
                  ( PMIDL_STUB_DESC  )&trksvr_StubDesc,
                  (PFORMAT_STRING) &__MIDL_ProcFormatString.Format[0],
                  IDL_handle,
                  pMsg);
    return ( HRESULT  )_RetVal.Simple;
    
}


#if !defined(__RPC_WIN64__)
#error  Invalid build platform for this stub.
#endif

static const MIDL_PROC_FORMAT_STRING __MIDL_ProcFormatString =
    {
        0,
        {

	/* Procedure LnkSvrMessage */

			0x0,		/* 0 */
			0x48,		/* Old Flags:  */
/*  2 */	NdrFcLong( 0x0 ),	/* 0 */
/*  6 */	NdrFcShort( 0x0 ),	/* 0 */
/*  8 */	NdrFcShort( 0x18 ),	/* ia64 Stack size/offset = 24 */
/* 10 */	0x32,		/* FC_BIND_PRIMITIVE */
			0x0,		/* 0 */
/* 12 */	NdrFcShort( 0x0 ),	/* ia64 Stack size/offset = 0 */
/* 14 */	NdrFcShort( 0x0 ),	/* 0 */
/* 16 */	NdrFcShort( 0x8 ),	/* 8 */
/* 18 */	0x47,		/* Oi2 Flags:  srv must size, clt must size, has return, has ext, */
			0x2,		/* 2 */
/* 20 */	0xa,		/* 10 */
			0x7,		/* Ext Flags:  new corr desc, clt corr check, srv corr check, */
/* 22 */	NdrFcShort( 0xb ),	/* 11 */
/* 24 */	NdrFcShort( 0xb ),	/* 11 */
/* 26 */	NdrFcShort( 0x0 ),	/* 0 */
/* 28 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter IDL_handle */

/* 30 */	NdrFcShort( 0x11b ),	/* Flags:  must size, must free, in, out, simple ref, */
/* 32 */	NdrFcShort( 0x8 ),	/* ia64 Stack size/offset = 8 */
/* 34 */	NdrFcShort( 0x20c ),	/* Type Offset=524 */

	/* Parameter pMsg */

/* 36 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 38 */	NdrFcShort( 0x10 ),	/* ia64 Stack size/offset = 16 */
/* 40 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure LnkSvrMessageCallback */


	/* Return value */

/* 42 */	0x34,		/* FC_CALLBACK_HANDLE */
			0x48,		/* Old Flags:  */
/* 44 */	NdrFcLong( 0x0 ),	/* 0 */
/* 48 */	NdrFcShort( 0x0 ),	/* 0 */
/* 50 */	NdrFcShort( 0x10 ),	/* ia64 Stack size/offset = 16 */
/* 52 */	NdrFcShort( 0x0 ),	/* 0 */
/* 54 */	NdrFcShort( 0x8 ),	/* 8 */
/* 56 */	0x47,		/* Oi2 Flags:  srv must size, clt must size, has return, has ext, */
			0x2,		/* 2 */
/* 58 */	0xa,		/* 10 */
			0x7,		/* Ext Flags:  new corr desc, clt corr check, srv corr check, */
/* 60 */	NdrFcShort( 0xb ),	/* 11 */
/* 62 */	NdrFcShort( 0xb ),	/* 11 */
/* 64 */	NdrFcShort( 0x0 ),	/* 0 */
/* 66 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter pMsg */

/* 68 */	NdrFcShort( 0x11b ),	/* Flags:  must size, must free, in, out, simple ref, */
/* 70 */	NdrFcShort( 0x0 ),	/* ia64 Stack size/offset = 0 */
/* 72 */	NdrFcShort( 0x20c ),	/* Type Offset=524 */

	/* Return value */

/* 74 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 76 */	NdrFcShort( 0x8 ),	/* ia64 Stack size/offset = 8 */
/* 78 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

			0x0
        }
    };

static const MIDL_TYPE_FORMAT_STRING __MIDL_TypeFormatString =
    {
        0,
        {
			NdrFcShort( 0x0 ),	/* 0 */
/*  2 */	
			0x11, 0x0,	/* FC_RP */
/*  4 */	NdrFcShort( 0x208 ),	/* Offset= 520 (524) */
/*  6 */	
			0x2b,		/* FC_NON_ENCAPSULATED_UNION */
			0x8,		/* FC_LONG */
/*  8 */	0x8,		/* Corr desc: FC_LONG */
			0x0,		/*  */
/* 10 */	NdrFcShort( 0xfff8 ),	/* -8 */
/* 12 */	NdrFcShort( 0x1 ),	/* Corr flags:  early, */
/* 14 */	NdrFcShort( 0x2 ),	/* Offset= 2 (16) */
/* 16 */	NdrFcShort( 0xc8 ),	/* 200 */
/* 18 */	NdrFcShort( 0x9 ),	/* 9 */
/* 20 */	NdrFcLong( 0x0 ),	/* 0 */
/* 24 */	NdrFcShort( 0x88 ),	/* Offset= 136 (160) */
/* 26 */	NdrFcLong( 0x1 ),	/* 1 */
/* 30 */	NdrFcShort( 0xb2 ),	/* Offset= 178 (208) */
/* 32 */	NdrFcLong( 0x2 ),	/* 2 */
/* 36 */	NdrFcShort( 0xde ),	/* Offset= 222 (258) */
/* 38 */	NdrFcLong( 0x3 ),	/* 3 */
/* 42 */	NdrFcShort( 0x13e ),	/* Offset= 318 (360) */
/* 44 */	NdrFcLong( 0x4 ),	/* 4 */
/* 48 */	NdrFcShort( 0x148 ),	/* Offset= 328 (376) */
/* 50 */	NdrFcLong( 0x5 ),	/* 5 */
/* 54 */	NdrFcShort( 0x162 ),	/* Offset= 354 (408) */
/* 56 */	NdrFcLong( 0x6 ),	/* 6 */
/* 60 */	NdrFcShort( 0x1c0 ),	/* Offset= 448 (508) */
/* 62 */	NdrFcLong( 0x7 ),	/* 7 */
/* 66 */	NdrFcShort( 0xe2 ),	/* Offset= 226 (292) */
/* 68 */	NdrFcLong( 0x8 ),	/* 8 */
/* 72 */	NdrFcShort( 0x8008 ),	/* Simple arm type: FC_LONG */
/* 74 */	NdrFcShort( 0xffffffff ),	/* Offset= -1 (73) */
/* 76 */	
			0x1d,		/* FC_SMFARRAY */
			0x1,		/* 1 */
/* 78 */	NdrFcShort( 0x202 ),	/* 514 */
/* 80 */	0x5,		/* FC_WCHAR */
			0x5b,		/* FC_END */
/* 82 */	
			0x1d,		/* FC_SMFARRAY */
			0x0,		/* 0 */
/* 84 */	NdrFcShort( 0x8 ),	/* 8 */
/* 86 */	0x1,		/* FC_BYTE */
			0x5b,		/* FC_END */
/* 88 */	
			0x15,		/* FC_STRUCT */
			0x3,		/* 3 */
/* 90 */	NdrFcShort( 0x10 ),	/* 16 */
/* 92 */	0x8,		/* FC_LONG */
			0x6,		/* FC_SHORT */
/* 94 */	0x6,		/* FC_SHORT */
			0x4c,		/* FC_EMBEDDED_COMPLEX */
/* 96 */	0x0,		/* 0 */
			NdrFcShort( 0xfffffff1 ),	/* Offset= -15 (82) */
			0x5b,		/* FC_END */
/* 100 */	
			0x15,		/* FC_STRUCT */
			0x3,		/* 3 */
/* 102 */	NdrFcShort( 0x10 ),	/* 16 */
/* 104 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 106 */	NdrFcShort( 0xffffffee ),	/* Offset= -18 (88) */
/* 108 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 110 */	
			0x15,		/* FC_STRUCT */
			0x3,		/* 3 */
/* 112 */	NdrFcShort( 0x20 ),	/* 32 */
/* 114 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 116 */	NdrFcShort( 0xfffffff0 ),	/* Offset= -16 (100) */
/* 118 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 120 */	NdrFcShort( 0xffffffec ),	/* Offset= -20 (100) */
/* 122 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 124 */	
			0x15,		/* FC_STRUCT */
			0x3,		/* 3 */
/* 126 */	NdrFcShort( 0x248 ),	/* 584 */
/* 128 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 130 */	NdrFcShort( 0xffffffca ),	/* Offset= -54 (76) */
/* 132 */	0x3e,		/* FC_STRUCTPAD2 */
			0x4c,		/* FC_EMBEDDED_COMPLEX */
/* 134 */	0x0,		/* 0 */
			NdrFcShort( 0xffffffe7 ),	/* Offset= -25 (110) */
			0x4c,		/* FC_EMBEDDED_COMPLEX */
/* 138 */	0x0,		/* 0 */
			NdrFcShort( 0xffffffe3 ),	/* Offset= -29 (110) */
			0x8,		/* FC_LONG */
/* 142 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 144 */	
			0x1b,		/* FC_CARRAY */
			0x3,		/* 3 */
/* 146 */	NdrFcShort( 0x248 ),	/* 584 */
/* 148 */	0x19,		/* Corr desc:  field pointer, FC_ULONG */
			0x0,		/*  */
/* 150 */	NdrFcShort( 0x0 ),	/* 0 */
/* 152 */	NdrFcShort( 0x1 ),	/* Corr flags:  early, */
/* 154 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 156 */	NdrFcShort( 0xffffffe0 ),	/* Offset= -32 (124) */
/* 158 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 160 */	
			0x1a,		/* FC_BOGUS_STRUCT */
			0x3,		/* 3 */
/* 162 */	NdrFcShort( 0x10 ),	/* 16 */
/* 164 */	NdrFcShort( 0x0 ),	/* 0 */
/* 166 */	NdrFcShort( 0x6 ),	/* Offset= 6 (172) */
/* 168 */	0x8,		/* FC_LONG */
			0x40,		/* FC_STRUCTPAD4 */
/* 170 */	0x36,		/* FC_POINTER */
			0x5b,		/* FC_END */
/* 172 */	
			0x12, 0x0,	/* FC_UP */
/* 174 */	NdrFcShort( 0xffffffe2 ),	/* Offset= -30 (144) */
/* 176 */	
			0x1b,		/* FC_CARRAY */
			0x3,		/* 3 */
/* 178 */	NdrFcShort( 0x10 ),	/* 16 */
/* 180 */	0x19,		/* Corr desc:  field pointer, FC_ULONG */
			0x0,		/*  */
/* 182 */	NdrFcShort( 0x0 ),	/* 0 */
/* 184 */	NdrFcShort( 0x1 ),	/* Corr flags:  early, */
/* 186 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 188 */	NdrFcShort( 0xffffffa8 ),	/* Offset= -88 (100) */
/* 190 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 192 */	
			0x1b,		/* FC_CARRAY */
			0x3,		/* 3 */
/* 194 */	NdrFcShort( 0x20 ),	/* 32 */
/* 196 */	0x19,		/* Corr desc:  field pointer, FC_ULONG */
			0x0,		/*  */
/* 198 */	NdrFcShort( 0x0 ),	/* 0 */
/* 200 */	NdrFcShort( 0x1 ),	/* Corr flags:  early, */
/* 202 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 204 */	NdrFcShort( 0xffffffa2 ),	/* Offset= -94 (110) */
/* 206 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 208 */	
			0x1a,		/* FC_BOGUS_STRUCT */
			0x3,		/* 3 */
/* 210 */	NdrFcShort( 0x30 ),	/* 48 */
/* 212 */	NdrFcShort( 0x0 ),	/* 0 */
/* 214 */	NdrFcShort( 0xc ),	/* Offset= 12 (226) */
/* 216 */	0x8,		/* FC_LONG */
			0x8,		/* FC_LONG */
/* 218 */	0x8,		/* FC_LONG */
			0x8,		/* FC_LONG */
/* 220 */	0x36,		/* FC_POINTER */
			0x36,		/* FC_POINTER */
/* 222 */	0x36,		/* FC_POINTER */
			0x36,		/* FC_POINTER */
/* 224 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 226 */	
			0x12, 0x0,	/* FC_UP */
/* 228 */	NdrFcShort( 0xffffff80 ),	/* Offset= -128 (100) */
/* 230 */	
			0x12, 0x0,	/* FC_UP */
/* 232 */	NdrFcShort( 0xffffffc8 ),	/* Offset= -56 (176) */
/* 234 */	
			0x12, 0x0,	/* FC_UP */
/* 236 */	NdrFcShort( 0xffffffd4 ),	/* Offset= -44 (192) */
/* 238 */	
			0x12, 0x0,	/* FC_UP */
/* 240 */	NdrFcShort( 0xffffffd0 ),	/* Offset= -48 (192) */
/* 242 */	
			0x1b,		/* FC_CARRAY */
			0x3,		/* 3 */
/* 244 */	NdrFcShort( 0x10 ),	/* 16 */
/* 246 */	0x19,		/* Corr desc:  field pointer, FC_ULONG */
			0x0,		/*  */
/* 248 */	NdrFcShort( 0x10 ),	/* 16 */
/* 250 */	NdrFcShort( 0x1 ),	/* Corr flags:  early, */
/* 252 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 254 */	NdrFcShort( 0xffffff66 ),	/* Offset= -154 (100) */
/* 256 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 258 */	
			0x1a,		/* FC_BOGUS_STRUCT */
			0x3,		/* 3 */
/* 260 */	NdrFcShort( 0x20 ),	/* 32 */
/* 262 */	NdrFcShort( 0x0 ),	/* 0 */
/* 264 */	NdrFcShort( 0xa ),	/* Offset= 10 (274) */
/* 266 */	0x8,		/* FC_LONG */
			0x40,		/* FC_STRUCTPAD4 */
/* 268 */	0x36,		/* FC_POINTER */
			0x8,		/* FC_LONG */
/* 270 */	0x40,		/* FC_STRUCTPAD4 */
			0x36,		/* FC_POINTER */
/* 272 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 274 */	
			0x12, 0x0,	/* FC_UP */
/* 276 */	NdrFcShort( 0xffffffac ),	/* Offset= -84 (192) */
/* 278 */	
			0x12, 0x0,	/* FC_UP */
/* 280 */	NdrFcShort( 0xffffffda ),	/* Offset= -38 (242) */
/* 282 */	
			0x15,		/* FC_STRUCT */
			0x0,		/* 0 */
/* 284 */	NdrFcShort( 0x8 ),	/* 8 */
/* 286 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 288 */	NdrFcShort( 0xffffff32 ),	/* Offset= -206 (82) */
/* 290 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 292 */	
			0x15,		/* FC_STRUCT */
			0x3,		/* 3 */
/* 294 */	NdrFcShort( 0x8 ),	/* 8 */
/* 296 */	0x8,		/* FC_LONG */
			0x8,		/* FC_LONG */
/* 298 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 300 */	
			0x1d,		/* FC_SMFARRAY */
			0x0,		/* 0 */
/* 302 */	NdrFcShort( 0x10 ),	/* 16 */
/* 304 */	0x2,		/* FC_CHAR */
			0x5b,		/* FC_END */
/* 306 */	
			0x15,		/* FC_STRUCT */
			0x0,		/* 0 */
/* 308 */	NdrFcShort( 0x10 ),	/* 16 */
/* 310 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 312 */	NdrFcShort( 0xfffffff4 ),	/* Offset= -12 (300) */
/* 314 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 316 */	
			0x15,		/* FC_STRUCT */
			0x3,		/* 3 */
/* 318 */	NdrFcShort( 0x44 ),	/* 68 */
/* 320 */	0x8,		/* FC_LONG */
			0xe,		/* FC_ENUM32 */
/* 322 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 324 */	NdrFcShort( 0xffffff20 ),	/* Offset= -224 (100) */
/* 326 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 328 */	NdrFcShort( 0xffffffd2 ),	/* Offset= -46 (282) */
/* 330 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 332 */	NdrFcShort( 0xffffffce ),	/* Offset= -50 (282) */
/* 334 */	0x8,		/* FC_LONG */
			0x4c,		/* FC_EMBEDDED_COMPLEX */
/* 336 */	0x0,		/* 0 */
			NdrFcShort( 0xffffffd3 ),	/* Offset= -45 (292) */
			0x4c,		/* FC_EMBEDDED_COMPLEX */
/* 340 */	0x0,		/* 0 */
			NdrFcShort( 0xffffffdd ),	/* Offset= -35 (306) */
			0x5b,		/* FC_END */
/* 344 */	
			0x1b,		/* FC_CARRAY */
			0x3,		/* 3 */
/* 346 */	NdrFcShort( 0x44 ),	/* 68 */
/* 348 */	0x19,		/* Corr desc:  field pointer, FC_ULONG */
			0x0,		/*  */
/* 350 */	NdrFcShort( 0x0 ),	/* 0 */
/* 352 */	NdrFcShort( 0x1 ),	/* Corr flags:  early, */
/* 354 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 356 */	NdrFcShort( 0xffffffd8 ),	/* Offset= -40 (316) */
/* 358 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 360 */	
			0x1a,		/* FC_BOGUS_STRUCT */
			0x3,		/* 3 */
/* 362 */	NdrFcShort( 0x10 ),	/* 16 */
/* 364 */	NdrFcShort( 0x0 ),	/* 0 */
/* 366 */	NdrFcShort( 0x6 ),	/* Offset= 6 (372) */
/* 368 */	0x8,		/* FC_LONG */
			0x40,		/* FC_STRUCTPAD4 */
/* 370 */	0x36,		/* FC_POINTER */
			0x5b,		/* FC_END */
/* 372 */	
			0x12, 0x0,	/* FC_UP */
/* 374 */	NdrFcShort( 0xffffffe2 ),	/* Offset= -30 (344) */
/* 376 */	
			0x1a,		/* FC_BOGUS_STRUCT */
			0x3,		/* 3 */
/* 378 */	NdrFcShort( 0x20 ),	/* 32 */
/* 380 */	NdrFcShort( 0x0 ),	/* 0 */
/* 382 */	NdrFcShort( 0xa ),	/* Offset= 10 (392) */
/* 384 */	0x8,		/* FC_LONG */
			0x40,		/* FC_STRUCTPAD4 */
/* 386 */	0x36,		/* FC_POINTER */
			0x8,		/* FC_LONG */
/* 388 */	0x40,		/* FC_STRUCTPAD4 */
			0x36,		/* FC_POINTER */
/* 390 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 392 */	
			0x12, 0x0,	/* FC_UP */
/* 394 */	NdrFcShort( 0xffffff36 ),	/* Offset= -202 (192) */
/* 396 */	
			0x12, 0x0,	/* FC_UP */
/* 398 */	NdrFcShort( 0xffffff64 ),	/* Offset= -156 (242) */
/* 400 */	
			0x15,		/* FC_STRUCT */
			0x3,		/* 3 */
/* 402 */	NdrFcShort( 0xc ),	/* 12 */
/* 404 */	0x8,		/* FC_LONG */
			0x8,		/* FC_LONG */
/* 406 */	0x8,		/* FC_LONG */
			0x5b,		/* FC_END */
/* 408 */	
			0x15,		/* FC_STRUCT */
			0x3,		/* 3 */
/* 410 */	NdrFcShort( 0xc8 ),	/* 200 */
/* 412 */	0x8,		/* FC_LONG */
			0x8,		/* FC_LONG */
/* 414 */	0x8,		/* FC_LONG */
			0x8,		/* FC_LONG */
/* 416 */	0x8,		/* FC_LONG */
			0x8,		/* FC_LONG */
/* 418 */	0x8,		/* FC_LONG */
			0x8,		/* FC_LONG */
/* 420 */	0x8,		/* FC_LONG */
			0x8,		/* FC_LONG */
/* 422 */	0x8,		/* FC_LONG */
			0x8,		/* FC_LONG */
/* 424 */	0x8,		/* FC_LONG */
			0x8,		/* FC_LONG */
/* 426 */	0x8,		/* FC_LONG */
			0x8,		/* FC_LONG */
/* 428 */	0x8,		/* FC_LONG */
			0x8,		/* FC_LONG */
/* 430 */	0x8,		/* FC_LONG */
			0x8,		/* FC_LONG */
/* 432 */	0x8,		/* FC_LONG */
			0x8,		/* FC_LONG */
/* 434 */	0x8,		/* FC_LONG */
			0x8,		/* FC_LONG */
/* 436 */	0x8,		/* FC_LONG */
			0x8,		/* FC_LONG */
/* 438 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 440 */	NdrFcShort( 0xffffff6c ),	/* Offset= -148 (292) */
/* 442 */	0x8,		/* FC_LONG */
			0x8,		/* FC_LONG */
/* 444 */	0x8,		/* FC_LONG */
			0x8,		/* FC_LONG */
/* 446 */	0x8,		/* FC_LONG */
			0x4c,		/* FC_EMBEDDED_COMPLEX */
/* 448 */	0x0,		/* 0 */
			NdrFcShort( 0xffffff63 ),	/* Offset= -157 (292) */
			0x8,		/* FC_LONG */
/* 452 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 454 */	NdrFcShort( 0xffffff5e ),	/* Offset= -162 (292) */
/* 456 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 458 */	NdrFcShort( 0xffffff5a ),	/* Offset= -166 (292) */
/* 460 */	0x8,		/* FC_LONG */
			0x8,		/* FC_LONG */
/* 462 */	0x8,		/* FC_LONG */
			0x8,		/* FC_LONG */
/* 464 */	0x8,		/* FC_LONG */
			0x6,		/* FC_SHORT */
/* 466 */	0x6,		/* FC_SHORT */
			0x6,		/* FC_SHORT */
/* 468 */	0x6,		/* FC_SHORT */
			0x4c,		/* FC_EMBEDDED_COMPLEX */
/* 470 */	0x0,		/* 0 */
			NdrFcShort( 0xffffffb9 ),	/* Offset= -71 (400) */
			0x5b,		/* FC_END */
/* 474 */	
			0x15,		/* FC_STRUCT */
			0x3,		/* 3 */
/* 476 */	NdrFcShort( 0x54 ),	/* 84 */
/* 478 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 480 */	NdrFcShort( 0xfffffe8e ),	/* Offset= -370 (110) */
/* 482 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 484 */	NdrFcShort( 0xfffffe8a ),	/* Offset= -374 (110) */
/* 486 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 488 */	NdrFcShort( 0xffffff4a ),	/* Offset= -182 (306) */
/* 490 */	0x8,		/* FC_LONG */
			0x5b,		/* FC_END */
/* 492 */	
			0x1b,		/* FC_CARRAY */
			0x3,		/* 3 */
/* 494 */	NdrFcShort( 0x54 ),	/* 84 */
/* 496 */	0x19,		/* Corr desc:  field pointer, FC_ULONG */
			0x0,		/*  */
/* 498 */	NdrFcShort( 0x0 ),	/* 0 */
/* 500 */	NdrFcShort( 0x1 ),	/* Corr flags:  early, */
/* 502 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 504 */	NdrFcShort( 0xffffffe2 ),	/* Offset= -30 (474) */
/* 506 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 508 */	
			0x1a,		/* FC_BOGUS_STRUCT */
			0x3,		/* 3 */
/* 510 */	NdrFcShort( 0x10 ),	/* 16 */
/* 512 */	NdrFcShort( 0x0 ),	/* 0 */
/* 514 */	NdrFcShort( 0x6 ),	/* Offset= 6 (520) */
/* 516 */	0x8,		/* FC_LONG */
			0x40,		/* FC_STRUCTPAD4 */
/* 518 */	0x36,		/* FC_POINTER */
			0x5b,		/* FC_END */
/* 520 */	
			0x12, 0x0,	/* FC_UP */
/* 522 */	NdrFcShort( 0xffffffe2 ),	/* Offset= -30 (492) */
/* 524 */	
			0x1a,		/* FC_BOGUS_STRUCT */
			0x3,		/* 3 */
/* 526 */	NdrFcShort( 0xd8 ),	/* 216 */
/* 528 */	NdrFcShort( 0x0 ),	/* 0 */
/* 530 */	NdrFcShort( 0xa ),	/* Offset= 10 (540) */
/* 532 */	0xe,		/* FC_ENUM32 */
			0xe,		/* FC_ENUM32 */
/* 534 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 536 */	NdrFcShort( 0xfffffdee ),	/* Offset= -530 (6) */
/* 538 */	0x36,		/* FC_POINTER */
			0x5b,		/* FC_END */
/* 540 */	
			0x12, 0x8,	/* FC_UP [simple_pointer] */
/* 542 */	
			0x25,		/* FC_C_WSTRING */
			0x5c,		/* FC_PAD */

			0x0
        }
    };

static const unsigned short trksvr_FormatStringOffsetTable[] =
    {
    0,
    };


static const unsigned short _callbacktrksvr_FormatStringOffsetTable[] =
    {
    42
    };


static const MIDL_STUB_DESC trksvr_StubDesc = 
    {
    (void *)& trksvr___RpcClientInterface,
    MIDL_user_allocate,
    MIDL_user_free,
    &notused,
    0,
    0,
    0,
    0,
    __MIDL_TypeFormatString.Format,
    1, /* -error bounds_check flag */
    0x50002, /* Ndr library version */
    0,
    0x600015b, /* MIDL Version 6.0.347 */
    0,
    0,
    0,  /* notify & notify_flag routine table */
    0x1, /* MIDL flag */
    0, /* cs routines */
    0,   /* proxy/server info */
    0   /* Reserved5 */
    };

static RPC_DISPATCH_FUNCTION trksvr_table[] =
    {
    NdrServerCall2,
    0
    };
RPC_DISPATCH_TABLE trksvr_v1_0_DispatchTable = 
    {
    1,
    trksvr_table
    };

static const SERVER_ROUTINE trksvr_ServerRoutineTable[] = 
    {
    (SERVER_ROUTINE)StubLnkSvrMessageCallback
    };

static const MIDL_SERVER_INFO trksvr_ServerInfo = 
    {
    &trksvr_StubDesc,
    trksvr_ServerRoutineTable,
    __MIDL_ProcFormatString.Format,
    _callbacktrksvr_FormatStringOffsetTable,
    0,
    0,
    0,
    0};


#endif /* defined(_M_IA64) || defined(_M_AMD64)*/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\public\internal\com\inc\trkwks_c.c ===
#pragma warning( disable: 4049 )  /* more than 64k source lines */

/* this ALWAYS GENERATED file contains the RPC client stubs */


 /* File created by MIDL compiler version 6.00.0347 */
/* Compiler settings for trkwks.idl:
    Oicf, W1, Zp8, env=Win32 (32b run)
    protocol : dce , ms_ext, c_ext, robust
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )

#if !defined(_M_IA64) && !defined(_M_AMD64)
#include <string.h>

#include "trkwks.h"

#define TYPE_FORMAT_STRING_SIZE   745                               
#define PROC_FORMAT_STRING_SIZE   701                               
#define TRANSMIT_AS_TABLE_SIZE    0            
#define WIRE_MARSHAL_TABLE_SIZE   0            

typedef struct _MIDL_TYPE_FORMAT_STRING
    {
    short          Pad;
    unsigned char  Format[ TYPE_FORMAT_STRING_SIZE ];
    } MIDL_TYPE_FORMAT_STRING;

typedef struct _MIDL_PROC_FORMAT_STRING
    {
    short          Pad;
    unsigned char  Format[ PROC_FORMAT_STRING_SIZE ];
    } MIDL_PROC_FORMAT_STRING;


static RPC_SYNTAX_IDENTIFIER  _RpcTransferSyntax = 
{{0x8A885D04,0x1CEB,0x11C9,{0x9F,0xE8,0x08,0x00,0x2B,0x10,0x48,0x60}},{2,0}};


extern const MIDL_TYPE_FORMAT_STRING __MIDL_TypeFormatString;
extern const MIDL_PROC_FORMAT_STRING __MIDL_ProcFormatString;

#define GENERIC_BINDING_TABLE_SIZE   0            


/* Standard interface: __MIDL_itf_trkwks_0000, ver. 0.0,
   GUID={0x00000000,0x0000,0x0000,{0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00}} */


/* Standard interface: trkwks, ver. 1.2,
   GUID={0x300f3532,0x38cc,0x11d0,{0xa3,0xf0,0x00,0x20,0xaf,0x6b,0x0a,0xdd}} */



static const RPC_CLIENT_INTERFACE trkwks___RpcClientInterface =
    {
    sizeof(RPC_CLIENT_INTERFACE),
    {{0x300f3532,0x38cc,0x11d0,{0xa3,0xf0,0x00,0x20,0xaf,0x6b,0x0a,0xdd}},{1,2}},
    {{0x8A885D04,0x1CEB,0x11C9,{0x9F,0xE8,0x08,0x00,0x2B,0x10,0x48,0x60}},{2,0}},
    0,
    0,
    0,
    0,
    0,
    0x00000001
    };
RPC_IF_HANDLE trkwks_v1_2_c_ifspec = (RPC_IF_HANDLE)& trkwks___RpcClientInterface;

extern const MIDL_STUB_DESC trkwks_StubDesc;

static RPC_BINDING_HANDLE trkwks__MIDL_AutoBindHandle;


HRESULT old_LnkMendLink( 
    /* [in] */ handle_t IDL_handle,
    /* [in] */ FILETIME ftLimit,
    /* [in] */ ULONG Restrictions,
    /* [in] */ const CDomainRelativeObjId *pdroidBirth,
    /* [in] */ const CDomainRelativeObjId *pdroidLast,
    /* [out] */ CDomainRelativeObjId *pdroidCurrent,
    /* [string][out] */ WCHAR wsz[ 261 ])
{

    CLIENT_CALL_RETURN _RetVal;

    _RetVal = NdrClientCall2(
                  ( PMIDL_STUB_DESC  )&trkwks_StubDesc,
                  (PFORMAT_STRING) &__MIDL_ProcFormatString.Format[0],
                  ( unsigned char * )&IDL_handle);
    return ( HRESULT  )_RetVal.Simple;
    
}


HRESULT old_LnkSearchMachine( 
    /* [in] */ handle_t IDL_handle,
    /* [in] */ ULONG Restrictions,
    /* [in] */ const CDomainRelativeObjId *pdroidLast,
    /* [out] */ CDomainRelativeObjId *pdroidReferral,
    /* [string][out] */ TCHAR tsz[ 261 ])
{

    CLIENT_CALL_RETURN _RetVal;

    _RetVal = NdrClientCall2(
                  ( PMIDL_STUB_DESC  )&trkwks_StubDesc,
                  (PFORMAT_STRING) &__MIDL_ProcFormatString.Format[70],
                  ( unsigned char * )&IDL_handle);
    return ( HRESULT  )_RetVal.Simple;
    
}


HRESULT old_LnkCallSvrMessage( 
    /* [in] */ handle_t IDL_handle,
    /* [out][in] */ TRKSVR_MESSAGE_UNION_OLD *pMsg)
{

    CLIENT_CALL_RETURN _RetVal;

    _RetVal = NdrClientCall2(
                  ( PMIDL_STUB_DESC  )&trkwks_StubDesc,
                  (PFORMAT_STRING) &__MIDL_ProcFormatString.Format[128],
                  ( unsigned char * )&IDL_handle);
    return ( HRESULT  )_RetVal.Simple;
    
}


HRESULT LnkSetVolumeId( 
    /* [in] */ handle_t IDL_handle,
    ULONG volumeIndex,
    const CVolumeId VolId)
{

    CLIENT_CALL_RETURN _RetVal;

    _RetVal = NdrClientCall2(
                  ( PMIDL_STUB_DESC  )&trkwks_StubDesc,
                  (PFORMAT_STRING) &__MIDL_ProcFormatString.Format[168],
                  ( unsigned char * )&IDL_handle);
    return ( HRESULT  )_RetVal.Simple;
    
}


HRESULT LnkRestartDcSynchronization( 
    /* [in] */ handle_t IDL_handle)
{

    CLIENT_CALL_RETURN _RetVal;

    _RetVal = NdrClientCall2(
                  ( PMIDL_STUB_DESC  )&trkwks_StubDesc,
                  (PFORMAT_STRING) &__MIDL_ProcFormatString.Format[214],
                  ( unsigned char * )&IDL_handle);
    return ( HRESULT  )_RetVal.Simple;
    
}


HRESULT GetVolumeTrackingInformation( 
    /* [in] */ handle_t IDL_handle,
    /* [in] */ CVolumeId volid,
    /* [in] */ TrkInfoScope scope,
    /* [out] */ TRK_VOLUME_TRACKING_INFORMATION_PIPE pipeVolInfo)
{

    CLIENT_CALL_RETURN _RetVal;

    _RetVal = NdrClientCall2(
                  ( PMIDL_STUB_DESC  )&trkwks_StubDesc,
                  (PFORMAT_STRING) &__MIDL_ProcFormatString.Format[248],
                  ( unsigned char * )&IDL_handle);
    return ( HRESULT  )_RetVal.Simple;
    
}


HRESULT GetFileTrackingInformation( 
    /* [in] */ handle_t IDL_handle,
    /* [in] */ CDomainRelativeObjId droidCurrent,
    /* [in] */ TrkInfoScope scope,
    /* [out] */ TRK_FILE_TRACKING_INFORMATION_PIPE pipeFileInfo)
{

    CLIENT_CALL_RETURN _RetVal;

    _RetVal = NdrClientCall2(
                  ( PMIDL_STUB_DESC  )&trkwks_StubDesc,
                  (PFORMAT_STRING) &__MIDL_ProcFormatString.Format[300],
                  ( unsigned char * )&IDL_handle);
    return ( HRESULT  )_RetVal.Simple;
    
}


HRESULT TriggerVolumeClaims( 
    /* [in] */ handle_t IDL_handle,
    /* [in] */ ULONG cVolumes,
    /* [size_is][in] */ const CVolumeId *rgvolid)
{

    CLIENT_CALL_RETURN _RetVal;

    _RetVal = NdrClientCall2(
                  ( PMIDL_STUB_DESC  )&trkwks_StubDesc,
                  (PFORMAT_STRING) &__MIDL_ProcFormatString.Format[352],
                  ( unsigned char * )&IDL_handle);
    return ( HRESULT  )_RetVal.Simple;
    
}


HRESULT LnkOnRestore( 
    /* [in] */ handle_t IDL_handle)
{

    CLIENT_CALL_RETURN _RetVal;

    _RetVal = NdrClientCall2(
                  ( PMIDL_STUB_DESC  )&trkwks_StubDesc,
                  (PFORMAT_STRING) &__MIDL_ProcFormatString.Format[398],
                  ( unsigned char * )&IDL_handle);
    return ( HRESULT  )_RetVal.Simple;
    
}


/* [async] */ void  LnkMendLink( 
    /* [in] */ PRPC_ASYNC_STATE LnkMendLink_AsyncHandle,
    /* [in] */ handle_t IDL_handle,
    /* [in] */ FILETIME ftLimit,
    /* [in] */ DWORD Restrictions,
    /* [in] */ const CDomainRelativeObjId *pdroidBirth,
    /* [in] */ const CDomainRelativeObjId *pdroidLast,
    /* [in] */ const CMachineId *pmcidLast,
    /* [out] */ CDomainRelativeObjId *pdroidCurrent,
    /* [out] */ CMachineId *pmcidCurrent,
    /* [out][in] */ ULONG *pcbPath,
    /* [string][size_is][out] */ WCHAR *pwszPath)
{

    NdrAsyncClientCall(
                      ( PMIDL_STUB_DESC  )&trkwks_StubDesc,
                      (PFORMAT_STRING) &__MIDL_ProcFormatString.Format[432],
                      ( unsigned char * )&LnkMendLink_AsyncHandle);
    
}


HRESULT old2_LnkSearchMachine( 
    /* [in] */ handle_t IDL_handle,
    /* [in] */ DWORD Restrictions,
    /* [in] */ const CDomainRelativeObjId *pdroidLast,
    /* [out] */ CDomainRelativeObjId *pdroidNext,
    /* [out] */ CMachineId *pmcidNext,
    /* [string][max_is][out] */ TCHAR *ptszPath)
{

    CLIENT_CALL_RETURN _RetVal;

    _RetVal = NdrClientCall2(
                  ( PMIDL_STUB_DESC  )&trkwks_StubDesc,
                  (PFORMAT_STRING) &__MIDL_ProcFormatString.Format[520],
                  ( unsigned char * )&IDL_handle);
    return ( HRESULT  )_RetVal.Simple;
    
}


HRESULT LnkCallSvrMessage( 
    /* [in] */ handle_t IDL_handle,
    /* [out][in] */ TRKSVR_MESSAGE_UNION *pMsg)
{

    CLIENT_CALL_RETURN _RetVal;

    _RetVal = NdrClientCall2(
                  ( PMIDL_STUB_DESC  )&trkwks_StubDesc,
                  (PFORMAT_STRING) &__MIDL_ProcFormatString.Format[584],
                  ( unsigned char * )&IDL_handle);
    return ( HRESULT  )_RetVal.Simple;
    
}


HRESULT LnkSearchMachine( 
    /* [in] */ handle_t IDL_handle,
    /* [in] */ DWORD Restrictions,
    /* [in] */ const CDomainRelativeObjId *pdroidBirthLast,
    /* [in] */ const CDomainRelativeObjId *pdroidLast,
    /* [out] */ CDomainRelativeObjId *pdroidBirthNext,
    /* [out] */ CDomainRelativeObjId *pdroidNext,
    /* [out] */ CMachineId *pmcidNext,
    /* [string][max_is][out] */ TCHAR *ptszPath)
{

    CLIENT_CALL_RETURN _RetVal;

    _RetVal = NdrClientCall2(
                  ( PMIDL_STUB_DESC  )&trkwks_StubDesc,
                  (PFORMAT_STRING) &__MIDL_ProcFormatString.Format[624],
                  ( unsigned char * )&IDL_handle);
    return ( HRESULT  )_RetVal.Simple;
    
}


#if !defined(__RPC_WIN32__)
#error  Invalid build platform for this stub.
#endif

#if !(TARGET_IS_NT50_OR_LATER)
#error You need a Windows 2000 or later to run this stub because it uses these features:
#error   [async] attribute, /robust command line switch.
#error However, your C/C++ compilation flags indicate you intend to run this app on earlier systems.
#error This app will die there with the RPC_X_WRONG_STUB_VERSION error.
#endif


static const MIDL_PROC_FORMAT_STRING __MIDL_ProcFormatString =
    {
        0,
        {

	/* Procedure old_LnkMendLink */

			0x0,		/* 0 */
			0x48,		/* Old Flags:  */
/*  2 */	NdrFcLong( 0x0 ),	/* 0 */
/*  6 */	NdrFcShort( 0x0 ),	/* 0 */
/*  8 */	NdrFcShort( 0x24 ),	/* x86 Stack size/offset = 36 */
/* 10 */	0x32,		/* FC_BIND_PRIMITIVE */
			0x0,		/* 0 */
/* 12 */	NdrFcShort( 0x0 ),	/* x86 Stack size/offset = 0 */
/* 14 */	NdrFcShort( 0x168 ),	/* 360 */
/* 16 */	NdrFcShort( 0xac ),	/* 172 */
/* 18 */	0x45,		/* Oi2 Flags:  srv must size, has return, has ext, */
			0x7,		/* 7 */
/* 20 */	0x8,		/* 8 */
			0x1,		/* Ext Flags:  new corr desc, */
/* 22 */	NdrFcShort( 0x0 ),	/* 0 */
/* 24 */	NdrFcShort( 0x0 ),	/* 0 */
/* 26 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter IDL_handle */

/* 28 */	NdrFcShort( 0x8a ),	/* Flags:  must free, in, by val, */
/* 30 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 32 */	NdrFcShort( 0x2 ),	/* Type Offset=2 */

	/* Parameter ftLimit */

/* 34 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 36 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 38 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter Restrictions */

/* 40 */	NdrFcShort( 0x10a ),	/* Flags:  must free, in, simple ref, */
/* 42 */	NdrFcShort( 0x10 ),	/* x86 Stack size/offset = 16 */
/* 44 */	NdrFcShort( 0x2a ),	/* Type Offset=42 */

	/* Parameter pdroidBirth */

/* 46 */	NdrFcShort( 0x10a ),	/* Flags:  must free, in, simple ref, */
/* 48 */	NdrFcShort( 0x14 ),	/* x86 Stack size/offset = 20 */
/* 50 */	NdrFcShort( 0x2a ),	/* Type Offset=42 */

	/* Parameter pdroidLast */

/* 52 */	NdrFcShort( 0x8112 ),	/* Flags:  must free, out, simple ref, srv alloc size=32 */
/* 54 */	NdrFcShort( 0x18 ),	/* x86 Stack size/offset = 24 */
/* 56 */	NdrFcShort( 0x2a ),	/* Type Offset=42 */

	/* Parameter pdroidCurrent */

/* 58 */	NdrFcShort( 0x13 ),	/* Flags:  must size, must free, out, */
/* 60 */	NdrFcShort( 0x1c ),	/* x86 Stack size/offset = 28 */
/* 62 */	NdrFcShort( 0x3c ),	/* Type Offset=60 */

	/* Parameter wsz */

/* 64 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 66 */	NdrFcShort( 0x20 ),	/* x86 Stack size/offset = 32 */
/* 68 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure old_LnkSearchMachine */


	/* Return value */

/* 70 */	0x0,		/* 0 */
			0x48,		/* Old Flags:  */
/* 72 */	NdrFcLong( 0x0 ),	/* 0 */
/* 76 */	NdrFcShort( 0x1 ),	/* 1 */
/* 78 */	NdrFcShort( 0x18 ),	/* x86 Stack size/offset = 24 */
/* 80 */	0x32,		/* FC_BIND_PRIMITIVE */
			0x0,		/* 0 */
/* 82 */	NdrFcShort( 0x0 ),	/* x86 Stack size/offset = 0 */
/* 84 */	NdrFcShort( 0xac ),	/* 172 */
/* 86 */	NdrFcShort( 0xac ),	/* 172 */
/* 88 */	0x45,		/* Oi2 Flags:  srv must size, has return, has ext, */
			0x5,		/* 5 */
/* 90 */	0x8,		/* 8 */
			0x1,		/* Ext Flags:  new corr desc, */
/* 92 */	NdrFcShort( 0x0 ),	/* 0 */
/* 94 */	NdrFcShort( 0x0 ),	/* 0 */
/* 96 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter IDL_handle */

/* 98 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 100 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 102 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter Restrictions */

/* 104 */	NdrFcShort( 0x10a ),	/* Flags:  must free, in, simple ref, */
/* 106 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 108 */	NdrFcShort( 0x2a ),	/* Type Offset=42 */

	/* Parameter pdroidLast */

/* 110 */	NdrFcShort( 0x8112 ),	/* Flags:  must free, out, simple ref, srv alloc size=32 */
/* 112 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 114 */	NdrFcShort( 0x2a ),	/* Type Offset=42 */

	/* Parameter pdroidReferral */

/* 116 */	NdrFcShort( 0x13 ),	/* Flags:  must size, must free, out, */
/* 118 */	NdrFcShort( 0x10 ),	/* x86 Stack size/offset = 16 */
/* 120 */	NdrFcShort( 0x3c ),	/* Type Offset=60 */

	/* Parameter tsz */

/* 122 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 124 */	NdrFcShort( 0x14 ),	/* x86 Stack size/offset = 20 */
/* 126 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure old_LnkCallSvrMessage */


	/* Return value */

/* 128 */	0x0,		/* 0 */
			0x48,		/* Old Flags:  */
/* 130 */	NdrFcLong( 0x0 ),	/* 0 */
/* 134 */	NdrFcShort( 0x2 ),	/* 2 */
/* 136 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 138 */	0x32,		/* FC_BIND_PRIMITIVE */
			0x0,		/* 0 */
/* 140 */	NdrFcShort( 0x0 ),	/* x86 Stack size/offset = 0 */
/* 142 */	NdrFcShort( 0x0 ),	/* 0 */
/* 144 */	NdrFcShort( 0x8 ),	/* 8 */
/* 146 */	0x47,		/* Oi2 Flags:  srv must size, clt must size, has return, has ext, */
			0x2,		/* 2 */
/* 148 */	0x8,		/* 8 */
			0x7,		/* Ext Flags:  new corr desc, clt corr check, srv corr check, */
/* 150 */	NdrFcShort( 0xb ),	/* 11 */
/* 152 */	NdrFcShort( 0xb ),	/* 11 */
/* 154 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter IDL_handle */

/* 156 */	NdrFcShort( 0x11b ),	/* Flags:  must size, must free, in, out, simple ref, */
/* 158 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 160 */	NdrFcShort( 0x1ce ),	/* Type Offset=462 */

	/* Parameter pMsg */

/* 162 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 164 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 166 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure LnkSetVolumeId */


	/* Return value */

/* 168 */	0x0,		/* 0 */
			0x48,		/* Old Flags:  */
/* 170 */	NdrFcLong( 0x0 ),	/* 0 */
/* 174 */	NdrFcShort( 0x3 ),	/* 3 */
/* 176 */	NdrFcShort( 0x1c ),	/* x86 Stack size/offset = 28 */
/* 178 */	0x32,		/* FC_BIND_PRIMITIVE */
			0x0,		/* 0 */
/* 180 */	NdrFcShort( 0x0 ),	/* x86 Stack size/offset = 0 */
/* 182 */	NdrFcShort( 0x48 ),	/* 72 */
/* 184 */	NdrFcShort( 0x8 ),	/* 8 */
/* 186 */	0x44,		/* Oi2 Flags:  has return, has ext, */
			0x3,		/* 3 */
/* 188 */	0x8,		/* 8 */
			0x1,		/* Ext Flags:  new corr desc, */
/* 190 */	NdrFcShort( 0x0 ),	/* 0 */
/* 192 */	NdrFcShort( 0x0 ),	/* 0 */
/* 194 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter IDL_handle */

/* 196 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 198 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 200 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter volumeIndex */

/* 202 */	NdrFcShort( 0x8a ),	/* Flags:  must free, in, by val, */
/* 204 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 206 */	NdrFcShort( 0x20 ),	/* Type Offset=32 */

	/* Parameter VolId */

/* 208 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 210 */	NdrFcShort( 0x18 ),	/* x86 Stack size/offset = 24 */
/* 212 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure LnkRestartDcSynchronization */


	/* Return value */

/* 214 */	0x0,		/* 0 */
			0x48,		/* Old Flags:  */
/* 216 */	NdrFcLong( 0x0 ),	/* 0 */
/* 220 */	NdrFcShort( 0x4 ),	/* 4 */
/* 222 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 224 */	0x32,		/* FC_BIND_PRIMITIVE */
			0x0,		/* 0 */
/* 226 */	NdrFcShort( 0x0 ),	/* x86 Stack size/offset = 0 */
/* 228 */	NdrFcShort( 0x0 ),	/* 0 */
/* 230 */	NdrFcShort( 0x8 ),	/* 8 */
/* 232 */	0x44,		/* Oi2 Flags:  has return, has ext, */
			0x1,		/* 1 */
/* 234 */	0x8,		/* 8 */
			0x1,		/* Ext Flags:  new corr desc, */
/* 236 */	NdrFcShort( 0x0 ),	/* 0 */
/* 238 */	NdrFcShort( 0x0 ),	/* 0 */
/* 240 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter IDL_handle */

/* 242 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 244 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 246 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure GetVolumeTrackingInformation */


	/* Return value */

/* 248 */	0x0,		/* 0 */
			0x48,		/* Old Flags:  */
/* 250 */	NdrFcLong( 0x0 ),	/* 0 */
/* 254 */	NdrFcShort( 0x5 ),	/* 5 */
/* 256 */	NdrFcShort( 0x2c ),	/* x86 Stack size/offset = 44 */
/* 258 */	0x32,		/* FC_BIND_PRIMITIVE */
			0x0,		/* 0 */
/* 260 */	NdrFcShort( 0x0 ),	/* x86 Stack size/offset = 0 */
/* 262 */	NdrFcShort( 0x48 ),	/* 72 */
/* 264 */	NdrFcShort( 0x8 ),	/* 8 */
/* 266 */	0x4c,		/* Oi2 Flags:  has return, has pipes, has ext, */
			0x4,		/* 4 */
/* 268 */	0x8,		/* 8 */
			0x1,		/* Ext Flags:  new corr desc, */
/* 270 */	NdrFcShort( 0x0 ),	/* 0 */
/* 272 */	NdrFcShort( 0x0 ),	/* 0 */
/* 274 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter IDL_handle */

/* 276 */	NdrFcShort( 0x8a ),	/* Flags:  must free, in, by val, */
/* 278 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 280 */	NdrFcShort( 0x20 ),	/* Type Offset=32 */

	/* Parameter volid */

/* 282 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 284 */	NdrFcShort( 0x14 ),	/* x86 Stack size/offset = 20 */
/* 286 */	0xe,		/* FC_ENUM32 */
			0x0,		/* 0 */

	/* Parameter scope */

/* 288 */	NdrFcShort( 0x14 ),	/* Flags:  pipe, out, */
/* 290 */	NdrFcShort( 0x18 ),	/* x86 Stack size/offset = 24 */
/* 292 */	NdrFcShort( 0x1ec ),	/* Type Offset=492 */

	/* Parameter pipeVolInfo */

/* 294 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 296 */	NdrFcShort( 0x28 ),	/* x86 Stack size/offset = 40 */
/* 298 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure GetFileTrackingInformation */


	/* Return value */

/* 300 */	0x0,		/* 0 */
			0x48,		/* Old Flags:  */
/* 302 */	NdrFcLong( 0x0 ),	/* 0 */
/* 306 */	NdrFcShort( 0x6 ),	/* 6 */
/* 308 */	NdrFcShort( 0x3c ),	/* x86 Stack size/offset = 60 */
/* 310 */	0x32,		/* FC_BIND_PRIMITIVE */
			0x0,		/* 0 */
/* 312 */	NdrFcShort( 0x0 ),	/* x86 Stack size/offset = 0 */
/* 314 */	NdrFcShort( 0x98 ),	/* 152 */
/* 316 */	NdrFcShort( 0x8 ),	/* 8 */
/* 318 */	0x4c,		/* Oi2 Flags:  has return, has pipes, has ext, */
			0x4,		/* 4 */
/* 320 */	0x8,		/* 8 */
			0x1,		/* Ext Flags:  new corr desc, */
/* 322 */	NdrFcShort( 0x0 ),	/* 0 */
/* 324 */	NdrFcShort( 0x0 ),	/* 0 */
/* 326 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter IDL_handle */

/* 328 */	NdrFcShort( 0x8a ),	/* Flags:  must free, in, by val, */
/* 330 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 332 */	NdrFcShort( 0x2a ),	/* Type Offset=42 */

	/* Parameter droidCurrent */

/* 334 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 336 */	NdrFcShort( 0x24 ),	/* x86 Stack size/offset = 36 */
/* 338 */	0xe,		/* FC_ENUM32 */
			0x0,		/* 0 */

	/* Parameter scope */

/* 340 */	NdrFcShort( 0x14 ),	/* Flags:  pipe, out, */
/* 342 */	NdrFcShort( 0x28 ),	/* x86 Stack size/offset = 40 */
/* 344 */	NdrFcShort( 0x1f4 ),	/* Type Offset=500 */

	/* Parameter pipeFileInfo */

/* 346 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 348 */	NdrFcShort( 0x38 ),	/* x86 Stack size/offset = 56 */
/* 350 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure TriggerVolumeClaims */


	/* Return value */

/* 352 */	0x0,		/* 0 */
			0x48,		/* Old Flags:  */
/* 354 */	NdrFcLong( 0x0 ),	/* 0 */
/* 358 */	NdrFcShort( 0x7 ),	/* 7 */
/* 360 */	NdrFcShort( 0x10 ),	/* x86 Stack size/offset = 16 */
/* 362 */	0x32,		/* FC_BIND_PRIMITIVE */
			0x0,		/* 0 */
/* 364 */	NdrFcShort( 0x0 ),	/* x86 Stack size/offset = 0 */
/* 366 */	NdrFcShort( 0x8 ),	/* 8 */
/* 368 */	NdrFcShort( 0x8 ),	/* 8 */
/* 370 */	0x46,		/* Oi2 Flags:  clt must size, has return, has ext, */
			0x3,		/* 3 */
/* 372 */	0x8,		/* 8 */
			0x5,		/* Ext Flags:  new corr desc, srv corr check, */
/* 374 */	NdrFcShort( 0x0 ),	/* 0 */
/* 376 */	NdrFcShort( 0x1 ),	/* 1 */
/* 378 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter IDL_handle */

/* 380 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 382 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 384 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter cVolumes */

/* 386 */	NdrFcShort( 0x10b ),	/* Flags:  must size, must free, in, simple ref, */
/* 388 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 390 */	NdrFcShort( 0x200 ),	/* Type Offset=512 */

	/* Parameter rgvolid */

/* 392 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 394 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 396 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure LnkOnRestore */


	/* Return value */

/* 398 */	0x0,		/* 0 */
			0x48,		/* Old Flags:  */
/* 400 */	NdrFcLong( 0x0 ),	/* 0 */
/* 404 */	NdrFcShort( 0x8 ),	/* 8 */
/* 406 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 408 */	0x32,		/* FC_BIND_PRIMITIVE */
			0x0,		/* 0 */
/* 410 */	NdrFcShort( 0x0 ),	/* x86 Stack size/offset = 0 */
/* 412 */	NdrFcShort( 0x0 ),	/* 0 */
/* 414 */	NdrFcShort( 0x8 ),	/* 8 */
/* 416 */	0x44,		/* Oi2 Flags:  has return, has ext, */
			0x1,		/* 1 */
/* 418 */	0x8,		/* 8 */
			0x1,		/* Ext Flags:  new corr desc, */
/* 420 */	NdrFcShort( 0x0 ),	/* 0 */
/* 422 */	NdrFcShort( 0x0 ),	/* 0 */
/* 424 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter IDL_handle */

/* 426 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 428 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 430 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure LnkMendLink */


	/* Return value */

/* 432 */	0x0,		/* 0 */
			0x48,		/* Old Flags:  */
/* 434 */	NdrFcLong( 0x0 ),	/* 0 */
/* 438 */	NdrFcShort( 0x9 ),	/* 9 */
/* 440 */	NdrFcShort( 0x34 ),	/* x86 Stack size/offset = 52 */
/* 442 */	0x32,		/* FC_BIND_PRIMITIVE */
			0x0,		/* 0 */
/* 444 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 446 */	NdrFcShort( 0x1c8 ),	/* 456 */
/* 448 */	NdrFcShort( 0x10c ),	/* 268 */
/* 450 */	0xc5,		/* Oi2 Flags:  srv must size, has return, has ext, has async handle */
			0xa,		/* 10 */
/* 452 */	0x8,		/* 8 */
			0x3,		/* Ext Flags:  new corr desc, clt corr check, */
/* 454 */	NdrFcShort( 0x1 ),	/* 1 */
/* 456 */	NdrFcShort( 0x0 ),	/* 0 */
/* 458 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter IDL_handle */

/* 460 */	NdrFcShort( 0x8a ),	/* Flags:  must free, in, by val, */
/* 462 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 464 */	NdrFcShort( 0x2 ),	/* Type Offset=2 */

	/* Parameter ftLimit */

/* 466 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 468 */	NdrFcShort( 0x10 ),	/* x86 Stack size/offset = 16 */
/* 470 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter Restrictions */

/* 472 */	NdrFcShort( 0x10a ),	/* Flags:  must free, in, simple ref, */
/* 474 */	NdrFcShort( 0x14 ),	/* x86 Stack size/offset = 20 */
/* 476 */	NdrFcShort( 0x2a ),	/* Type Offset=42 */

	/* Parameter pdroidBirth */

/* 478 */	NdrFcShort( 0x10a ),	/* Flags:  must free, in, simple ref, */
/* 480 */	NdrFcShort( 0x18 ),	/* x86 Stack size/offset = 24 */
/* 482 */	NdrFcShort( 0x2a ),	/* Type Offset=42 */

	/* Parameter pdroidLast */

/* 484 */	NdrFcShort( 0x10a ),	/* Flags:  must free, in, simple ref, */
/* 486 */	NdrFcShort( 0x1c ),	/* x86 Stack size/offset = 28 */
/* 488 */	NdrFcShort( 0x14e ),	/* Type Offset=334 */

	/* Parameter pmcidLast */

/* 490 */	NdrFcShort( 0x8112 ),	/* Flags:  must free, out, simple ref, srv alloc size=32 */
/* 492 */	NdrFcShort( 0x20 ),	/* x86 Stack size/offset = 32 */
/* 494 */	NdrFcShort( 0x2a ),	/* Type Offset=42 */

	/* Parameter pdroidCurrent */

/* 496 */	NdrFcShort( 0x4112 ),	/* Flags:  must free, out, simple ref, srv alloc size=16 */
/* 498 */	NdrFcShort( 0x24 ),	/* x86 Stack size/offset = 36 */
/* 500 */	NdrFcShort( 0x14e ),	/* Type Offset=334 */

	/* Parameter pmcidCurrent */

/* 502 */	NdrFcShort( 0x158 ),	/* Flags:  in, out, base type, simple ref, */
/* 504 */	NdrFcShort( 0x28 ),	/* x86 Stack size/offset = 40 */
/* 506 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter pcbPath */

/* 508 */	NdrFcShort( 0x113 ),	/* Flags:  must size, must free, out, simple ref, */
/* 510 */	NdrFcShort( 0x2c ),	/* x86 Stack size/offset = 44 */
/* 512 */	NdrFcShort( 0x220 ),	/* Type Offset=544 */

	/* Parameter pwszPath */

/* 514 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 516 */	NdrFcShort( 0x30 ),	/* x86 Stack size/offset = 48 */
/* 518 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure old2_LnkSearchMachine */


	/* Return value */

/* 520 */	0x0,		/* 0 */
			0x48,		/* Old Flags:  */
/* 522 */	NdrFcLong( 0x0 ),	/* 0 */
/* 526 */	NdrFcShort( 0xa ),	/* 10 */
/* 528 */	NdrFcShort( 0x1c ),	/* x86 Stack size/offset = 28 */
/* 530 */	0x32,		/* FC_BIND_PRIMITIVE */
			0x0,		/* 0 */
/* 532 */	NdrFcShort( 0x0 ),	/* x86 Stack size/offset = 0 */
/* 534 */	NdrFcShort( 0xac ),	/* 172 */
/* 536 */	NdrFcShort( 0xf0 ),	/* 240 */
/* 538 */	0x45,		/* Oi2 Flags:  srv must size, has return, has ext, */
			0x6,		/* 6 */
/* 540 */	0x8,		/* 8 */
			0x3,		/* Ext Flags:  new corr desc, clt corr check, */
/* 542 */	NdrFcShort( 0x1 ),	/* 1 */
/* 544 */	NdrFcShort( 0x0 ),	/* 0 */
/* 546 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter IDL_handle */

/* 548 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 550 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 552 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter Restrictions */

/* 554 */	NdrFcShort( 0x10a ),	/* Flags:  must free, in, simple ref, */
/* 556 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 558 */	NdrFcShort( 0x2a ),	/* Type Offset=42 */

	/* Parameter pdroidLast */

/* 560 */	NdrFcShort( 0x8112 ),	/* Flags:  must free, out, simple ref, srv alloc size=32 */
/* 562 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 564 */	NdrFcShort( 0x2a ),	/* Type Offset=42 */

	/* Parameter pdroidNext */

/* 566 */	NdrFcShort( 0x4112 ),	/* Flags:  must free, out, simple ref, srv alloc size=16 */
/* 568 */	NdrFcShort( 0x10 ),	/* x86 Stack size/offset = 16 */
/* 570 */	NdrFcShort( 0x14e ),	/* Type Offset=334 */

	/* Parameter pmcidNext */

/* 572 */	NdrFcShort( 0x113 ),	/* Flags:  must size, must free, out, simple ref, */
/* 574 */	NdrFcShort( 0x14 ),	/* x86 Stack size/offset = 20 */
/* 576 */	NdrFcShort( 0x22c ),	/* Type Offset=556 */

	/* Parameter ptszPath */

/* 578 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 580 */	NdrFcShort( 0x18 ),	/* x86 Stack size/offset = 24 */
/* 582 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure LnkCallSvrMessage */


	/* Return value */

/* 584 */	0x0,		/* 0 */
			0x48,		/* Old Flags:  */
/* 586 */	NdrFcLong( 0x0 ),	/* 0 */
/* 590 */	NdrFcShort( 0xb ),	/* 11 */
/* 592 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 594 */	0x32,		/* FC_BIND_PRIMITIVE */
			0x0,		/* 0 */
/* 596 */	NdrFcShort( 0x0 ),	/* x86 Stack size/offset = 0 */
/* 598 */	NdrFcShort( 0x0 ),	/* 0 */
/* 600 */	NdrFcShort( 0x8 ),	/* 8 */
/* 602 */	0x47,		/* Oi2 Flags:  srv must size, clt must size, has return, has ext, */
			0x2,		/* 2 */
/* 604 */	0x8,		/* 8 */
			0x7,		/* Ext Flags:  new corr desc, clt corr check, srv corr check, */
/* 606 */	NdrFcShort( 0xb ),	/* 11 */
/* 608 */	NdrFcShort( 0xb ),	/* 11 */
/* 610 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter IDL_handle */

/* 612 */	NdrFcShort( 0x11b ),	/* Flags:  must size, must free, in, out, simple ref, */
/* 614 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 616 */	NdrFcShort( 0x2c8 ),	/* Type Offset=712 */

	/* Parameter pMsg */

/* 618 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 620 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 622 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure LnkSearchMachine */


	/* Return value */

/* 624 */	0x0,		/* 0 */
			0x48,		/* Old Flags:  */
/* 626 */	NdrFcLong( 0x0 ),	/* 0 */
/* 630 */	NdrFcShort( 0xc ),	/* 12 */
/* 632 */	NdrFcShort( 0x24 ),	/* x86 Stack size/offset = 36 */
/* 634 */	0x32,		/* FC_BIND_PRIMITIVE */
			0x0,		/* 0 */
/* 636 */	NdrFcShort( 0x0 ),	/* x86 Stack size/offset = 0 */
/* 638 */	NdrFcShort( 0x150 ),	/* 336 */
/* 640 */	NdrFcShort( 0x194 ),	/* 404 */
/* 642 */	0x45,		/* Oi2 Flags:  srv must size, has return, has ext, */
			0x8,		/* 8 */
/* 644 */	0x8,		/* 8 */
			0x3,		/* Ext Flags:  new corr desc, clt corr check, */
/* 646 */	NdrFcShort( 0x1 ),	/* 1 */
/* 648 */	NdrFcShort( 0x0 ),	/* 0 */
/* 650 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter IDL_handle */

/* 652 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 654 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 656 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter Restrictions */

/* 658 */	NdrFcShort( 0x10a ),	/* Flags:  must free, in, simple ref, */
/* 660 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 662 */	NdrFcShort( 0x2a ),	/* Type Offset=42 */

	/* Parameter pdroidBirthLast */

/* 664 */	NdrFcShort( 0x10a ),	/* Flags:  must free, in, simple ref, */
/* 666 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 668 */	NdrFcShort( 0x2a ),	/* Type Offset=42 */

	/* Parameter pdroidLast */

/* 670 */	NdrFcShort( 0x8112 ),	/* Flags:  must free, out, simple ref, srv alloc size=32 */
/* 672 */	NdrFcShort( 0x10 ),	/* x86 Stack size/offset = 16 */
/* 674 */	NdrFcShort( 0x2a ),	/* Type Offset=42 */

	/* Parameter pdroidBirthNext */

/* 676 */	NdrFcShort( 0x8112 ),	/* Flags:  must free, out, simple ref, srv alloc size=32 */
/* 678 */	NdrFcShort( 0x14 ),	/* x86 Stack size/offset = 20 */
/* 680 */	NdrFcShort( 0x2a ),	/* Type Offset=42 */

	/* Parameter pdroidNext */

/* 682 */	NdrFcShort( 0x4112 ),	/* Flags:  must free, out, simple ref, srv alloc size=16 */
/* 684 */	NdrFcShort( 0x18 ),	/* x86 Stack size/offset = 24 */
/* 686 */	NdrFcShort( 0x14e ),	/* Type Offset=334 */

	/* Parameter pmcidNext */

/* 688 */	NdrFcShort( 0x113 ),	/* Flags:  must size, must free, out, simple ref, */
/* 690 */	NdrFcShort( 0x1c ),	/* x86 Stack size/offset = 28 */
/* 692 */	NdrFcShort( 0x2e0 ),	/* Type Offset=736 */

	/* Parameter ptszPath */

/* 694 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 696 */	NdrFcShort( 0x20 ),	/* x86 Stack size/offset = 32 */
/* 698 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

			0x0
        }
    };

static const MIDL_TYPE_FORMAT_STRING __MIDL_TypeFormatString =
    {
        0,
        {
			NdrFcShort( 0x0 ),	/* 0 */
/*  2 */	
			0x15,		/* FC_STRUCT */
			0x3,		/* 3 */
/*  4 */	NdrFcShort( 0x8 ),	/* 8 */
/*  6 */	0x8,		/* FC_LONG */
			0x8,		/* FC_LONG */
/*  8 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 10 */	
			0x11, 0x0,	/* FC_RP */
/* 12 */	NdrFcShort( 0x1e ),	/* Offset= 30 (42) */
/* 14 */	
			0x1d,		/* FC_SMFARRAY */
			0x0,		/* 0 */
/* 16 */	NdrFcShort( 0x8 ),	/* 8 */
/* 18 */	0x1,		/* FC_BYTE */
			0x5b,		/* FC_END */
/* 20 */	
			0x15,		/* FC_STRUCT */
			0x3,		/* 3 */
/* 22 */	NdrFcShort( 0x10 ),	/* 16 */
/* 24 */	0x8,		/* FC_LONG */
			0x6,		/* FC_SHORT */
/* 26 */	0x6,		/* FC_SHORT */
			0x4c,		/* FC_EMBEDDED_COMPLEX */
/* 28 */	0x0,		/* 0 */
			NdrFcShort( 0xfffffff1 ),	/* Offset= -15 (14) */
			0x5b,		/* FC_END */
/* 32 */	
			0x15,		/* FC_STRUCT */
			0x3,		/* 3 */
/* 34 */	NdrFcShort( 0x10 ),	/* 16 */
/* 36 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 38 */	NdrFcShort( 0xffffffee ),	/* Offset= -18 (20) */
/* 40 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 42 */	
			0x15,		/* FC_STRUCT */
			0x3,		/* 3 */
/* 44 */	NdrFcShort( 0x20 ),	/* 32 */
/* 46 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 48 */	NdrFcShort( 0xfffffff0 ),	/* Offset= -16 (32) */
/* 50 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 52 */	NdrFcShort( 0xffffffec ),	/* Offset= -20 (32) */
/* 54 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 56 */	
			0x11, 0x4,	/* FC_RP [alloced_on_stack] */
/* 58 */	NdrFcShort( 0xfffffff0 ),	/* Offset= -16 (42) */
/* 60 */	
			0x29,		/* FC_WSTRING */
			0x5c,		/* FC_PAD */
/* 62 */	NdrFcShort( 0x105 ),	/* 261 */
/* 64 */	
			0x11, 0x0,	/* FC_RP */
/* 66 */	NdrFcShort( 0x18c ),	/* Offset= 396 (462) */
/* 68 */	
			0x2b,		/* FC_NON_ENCAPSULATED_UNION */
			0x8,		/* FC_LONG */
/* 70 */	0x8,		/* Corr desc: FC_LONG */
			0x0,		/*  */
/* 72 */	NdrFcShort( 0xfffc ),	/* -4 */
/* 74 */	NdrFcShort( 0x1 ),	/* Corr flags:  early, */
/* 76 */	NdrFcShort( 0x2 ),	/* Offset= 2 (78) */
/* 78 */	NdrFcShort( 0x20 ),	/* 32 */
/* 80 */	NdrFcShort( 0x6 ),	/* 6 */
/* 82 */	NdrFcLong( 0x0 ),	/* 0 */
/* 86 */	NdrFcShort( 0x4c ),	/* Offset= 76 (162) */
/* 88 */	NdrFcLong( 0x1 ),	/* 1 */
/* 92 */	NdrFcShort( 0x7a ),	/* Offset= 122 (214) */
/* 94 */	NdrFcLong( 0x2 ),	/* 2 */
/* 98 */	NdrFcShort( 0xbc ),	/* Offset= 188 (286) */
/* 100 */	NdrFcLong( 0x3 ),	/* 3 */
/* 104 */	NdrFcShort( 0x11c ),	/* Offset= 284 (388) */
/* 106 */	NdrFcLong( 0x4 ),	/* 4 */
/* 110 */	NdrFcShort( 0xb0 ),	/* Offset= 176 (286) */
/* 112 */	NdrFcLong( 0x6 ),	/* 6 */
/* 116 */	NdrFcShort( 0x146 ),	/* Offset= 326 (442) */
/* 118 */	NdrFcShort( 0xffffffff ),	/* Offset= -1 (117) */
/* 120 */	
			0x1d,		/* FC_SMFARRAY */
			0x1,		/* 1 */
/* 122 */	NdrFcShort( 0x202 ),	/* 514 */
/* 124 */	0x5,		/* FC_WCHAR */
			0x5b,		/* FC_END */
/* 126 */	
			0x15,		/* FC_STRUCT */
			0x3,		/* 3 */
/* 128 */	NdrFcShort( 0x248 ),	/* 584 */
/* 130 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 132 */	NdrFcShort( 0xfffffff4 ),	/* Offset= -12 (120) */
/* 134 */	0x3e,		/* FC_STRUCTPAD2 */
			0x4c,		/* FC_EMBEDDED_COMPLEX */
/* 136 */	0x0,		/* 0 */
			NdrFcShort( 0xffffffa1 ),	/* Offset= -95 (42) */
			0x4c,		/* FC_EMBEDDED_COMPLEX */
/* 140 */	0x0,		/* 0 */
			NdrFcShort( 0xffffff9d ),	/* Offset= -99 (42) */
			0x8,		/* FC_LONG */
/* 144 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 146 */	
			0x1b,		/* FC_CARRAY */
			0x3,		/* 3 */
/* 148 */	NdrFcShort( 0x248 ),	/* 584 */
/* 150 */	0x19,		/* Corr desc:  field pointer, FC_ULONG */
			0x0,		/*  */
/* 152 */	NdrFcShort( 0x0 ),	/* 0 */
/* 154 */	NdrFcShort( 0x1 ),	/* Corr flags:  early, */
/* 156 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 158 */	NdrFcShort( 0xffffffe0 ),	/* Offset= -32 (126) */
/* 160 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 162 */	
			0x16,		/* FC_PSTRUCT */
			0x3,		/* 3 */
/* 164 */	NdrFcShort( 0x8 ),	/* 8 */
/* 166 */	
			0x4b,		/* FC_PP */
			0x5c,		/* FC_PAD */
/* 168 */	
			0x46,		/* FC_NO_REPEAT */
			0x5c,		/* FC_PAD */
/* 170 */	NdrFcShort( 0x4 ),	/* 4 */
/* 172 */	NdrFcShort( 0x4 ),	/* 4 */
/* 174 */	0x12, 0x0,	/* FC_UP */
/* 176 */	NdrFcShort( 0xffffffe2 ),	/* Offset= -30 (146) */
/* 178 */	
			0x5b,		/* FC_END */

			0x8,		/* FC_LONG */
/* 180 */	0x8,		/* FC_LONG */
			0x5b,		/* FC_END */
/* 182 */	
			0x1b,		/* FC_CARRAY */
			0x3,		/* 3 */
/* 184 */	NdrFcShort( 0x10 ),	/* 16 */
/* 186 */	0x19,		/* Corr desc:  field pointer, FC_ULONG */
			0x0,		/*  */
/* 188 */	NdrFcShort( 0x0 ),	/* 0 */
/* 190 */	NdrFcShort( 0x1 ),	/* Corr flags:  early, */
/* 192 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 194 */	NdrFcShort( 0xffffff5e ),	/* Offset= -162 (32) */
/* 196 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 198 */	
			0x1b,		/* FC_CARRAY */
			0x3,		/* 3 */
/* 200 */	NdrFcShort( 0x20 ),	/* 32 */
/* 202 */	0x19,		/* Corr desc:  field pointer, FC_ULONG */
			0x0,		/*  */
/* 204 */	NdrFcShort( 0x0 ),	/* 0 */
/* 206 */	NdrFcShort( 0x1 ),	/* Corr flags:  early, */
/* 208 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 210 */	NdrFcShort( 0xffffff58 ),	/* Offset= -168 (42) */
/* 212 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 214 */	
			0x16,		/* FC_PSTRUCT */
			0x3,		/* 3 */
/* 216 */	NdrFcShort( 0x20 ),	/* 32 */
/* 218 */	
			0x4b,		/* FC_PP */
			0x5c,		/* FC_PAD */
/* 220 */	
			0x46,		/* FC_NO_REPEAT */
			0x5c,		/* FC_PAD */
/* 222 */	NdrFcShort( 0x10 ),	/* 16 */
/* 224 */	NdrFcShort( 0x10 ),	/* 16 */
/* 226 */	0x12, 0x0,	/* FC_UP */
/* 228 */	NdrFcShort( 0xffffff3c ),	/* Offset= -196 (32) */
/* 230 */	
			0x46,		/* FC_NO_REPEAT */
			0x5c,		/* FC_PAD */
/* 232 */	NdrFcShort( 0x14 ),	/* 20 */
/* 234 */	NdrFcShort( 0x14 ),	/* 20 */
/* 236 */	0x12, 0x0,	/* FC_UP */
/* 238 */	NdrFcShort( 0xffffffc8 ),	/* Offset= -56 (182) */
/* 240 */	
			0x46,		/* FC_NO_REPEAT */
			0x5c,		/* FC_PAD */
/* 242 */	NdrFcShort( 0x18 ),	/* 24 */
/* 244 */	NdrFcShort( 0x18 ),	/* 24 */
/* 246 */	0x12, 0x0,	/* FC_UP */
/* 248 */	NdrFcShort( 0xffffffce ),	/* Offset= -50 (198) */
/* 250 */	
			0x46,		/* FC_NO_REPEAT */
			0x5c,		/* FC_PAD */
/* 252 */	NdrFcShort( 0x1c ),	/* 28 */
/* 254 */	NdrFcShort( 0x1c ),	/* 28 */
/* 256 */	0x12, 0x0,	/* FC_UP */
/* 258 */	NdrFcShort( 0xffffffc4 ),	/* Offset= -60 (198) */
/* 260 */	
			0x5b,		/* FC_END */

			0x8,		/* FC_LONG */
/* 262 */	0x8,		/* FC_LONG */
			0x8,		/* FC_LONG */
/* 264 */	0x8,		/* FC_LONG */
			0x8,		/* FC_LONG */
/* 266 */	0x8,		/* FC_LONG */
			0x8,		/* FC_LONG */
/* 268 */	0x8,		/* FC_LONG */
			0x5b,		/* FC_END */
/* 270 */	
			0x1b,		/* FC_CARRAY */
			0x3,		/* 3 */
/* 272 */	NdrFcShort( 0x10 ),	/* 16 */
/* 274 */	0x19,		/* Corr desc:  field pointer, FC_ULONG */
			0x0,		/*  */
/* 276 */	NdrFcShort( 0x8 ),	/* 8 */
/* 278 */	NdrFcShort( 0x1 ),	/* Corr flags:  early, */
/* 280 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 282 */	NdrFcShort( 0xffffff06 ),	/* Offset= -250 (32) */
/* 284 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 286 */	
			0x16,		/* FC_PSTRUCT */
			0x3,		/* 3 */
/* 288 */	NdrFcShort( 0x10 ),	/* 16 */
/* 290 */	
			0x4b,		/* FC_PP */
			0x5c,		/* FC_PAD */
/* 292 */	
			0x46,		/* FC_NO_REPEAT */
			0x5c,		/* FC_PAD */
/* 294 */	NdrFcShort( 0x4 ),	/* 4 */
/* 296 */	NdrFcShort( 0x4 ),	/* 4 */
/* 298 */	0x12, 0x0,	/* FC_UP */
/* 300 */	NdrFcShort( 0xffffff9a ),	/* Offset= -102 (198) */
/* 302 */	
			0x46,		/* FC_NO_REPEAT */
			0x5c,		/* FC_PAD */
/* 304 */	NdrFcShort( 0xc ),	/* 12 */
/* 306 */	NdrFcShort( 0xc ),	/* 12 */
/* 308 */	0x12, 0x0,	/* FC_UP */
/* 310 */	NdrFcShort( 0xffffffd8 ),	/* Offset= -40 (270) */
/* 312 */	
			0x5b,		/* FC_END */

			0x8,		/* FC_LONG */
/* 314 */	0x8,		/* FC_LONG */
			0x8,		/* FC_LONG */
/* 316 */	0x8,		/* FC_LONG */
			0x5b,		/* FC_END */
/* 318 */	
			0x15,		/* FC_STRUCT */
			0x0,		/* 0 */
/* 320 */	NdrFcShort( 0x8 ),	/* 8 */
/* 322 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 324 */	NdrFcShort( 0xfffffeca ),	/* Offset= -310 (14) */
/* 326 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 328 */	
			0x1d,		/* FC_SMFARRAY */
			0x0,		/* 0 */
/* 330 */	NdrFcShort( 0x10 ),	/* 16 */
/* 332 */	0x2,		/* FC_CHAR */
			0x5b,		/* FC_END */
/* 334 */	
			0x15,		/* FC_STRUCT */
			0x0,		/* 0 */
/* 336 */	NdrFcShort( 0x10 ),	/* 16 */
/* 338 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 340 */	NdrFcShort( 0xfffffff4 ),	/* Offset= -12 (328) */
/* 342 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 344 */	
			0x15,		/* FC_STRUCT */
			0x3,		/* 3 */
/* 346 */	NdrFcShort( 0x44 ),	/* 68 */
/* 348 */	0x8,		/* FC_LONG */
			0xe,		/* FC_ENUM32 */
/* 350 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 352 */	NdrFcShort( 0xfffffec0 ),	/* Offset= -320 (32) */
/* 354 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 356 */	NdrFcShort( 0xffffffda ),	/* Offset= -38 (318) */
/* 358 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 360 */	NdrFcShort( 0xffffffd6 ),	/* Offset= -42 (318) */
/* 362 */	0x8,		/* FC_LONG */
			0x4c,		/* FC_EMBEDDED_COMPLEX */
/* 364 */	0x0,		/* 0 */
			NdrFcShort( 0xfffffe95 ),	/* Offset= -363 (2) */
			0x4c,		/* FC_EMBEDDED_COMPLEX */
/* 368 */	0x0,		/* 0 */
			NdrFcShort( 0xffffffdd ),	/* Offset= -35 (334) */
			0x5b,		/* FC_END */
/* 372 */	
			0x1b,		/* FC_CARRAY */
			0x3,		/* 3 */
/* 374 */	NdrFcShort( 0x44 ),	/* 68 */
/* 376 */	0x19,		/* Corr desc:  field pointer, FC_ULONG */
			0x0,		/*  */
/* 378 */	NdrFcShort( 0x0 ),	/* 0 */
/* 380 */	NdrFcShort( 0x1 ),	/* Corr flags:  early, */
/* 382 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 384 */	NdrFcShort( 0xffffffd8 ),	/* Offset= -40 (344) */
/* 386 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 388 */	
			0x16,		/* FC_PSTRUCT */
			0x3,		/* 3 */
/* 390 */	NdrFcShort( 0x8 ),	/* 8 */
/* 392 */	
			0x4b,		/* FC_PP */
			0x5c,		/* FC_PAD */
/* 394 */	
			0x46,		/* FC_NO_REPEAT */
			0x5c,		/* FC_PAD */
/* 396 */	NdrFcShort( 0x4 ),	/* 4 */
/* 398 */	NdrFcShort( 0x4 ),	/* 4 */
/* 400 */	0x12, 0x0,	/* FC_UP */
/* 402 */	NdrFcShort( 0xffffffe2 ),	/* Offset= -30 (372) */
/* 404 */	
			0x5b,		/* FC_END */

			0x8,		/* FC_LONG */
/* 406 */	0x8,		/* FC_LONG */
			0x5b,		/* FC_END */
/* 408 */	
			0x15,		/* FC_STRUCT */
			0x3,		/* 3 */
/* 410 */	NdrFcShort( 0x54 ),	/* 84 */
/* 412 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 414 */	NdrFcShort( 0xfffffe8c ),	/* Offset= -372 (42) */
/* 416 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 418 */	NdrFcShort( 0xfffffe88 ),	/* Offset= -376 (42) */
/* 420 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 422 */	NdrFcShort( 0xffffffa8 ),	/* Offset= -88 (334) */
/* 424 */	0x8,		/* FC_LONG */
			0x5b,		/* FC_END */
/* 426 */	
			0x1b,		/* FC_CARRAY */
			0x3,		/* 3 */
/* 428 */	NdrFcShort( 0x54 ),	/* 84 */
/* 430 */	0x19,		/* Corr desc:  field pointer, FC_ULONG */
			0x0,		/*  */
/* 432 */	NdrFcShort( 0x0 ),	/* 0 */
/* 434 */	NdrFcShort( 0x1 ),	/* Corr flags:  early, */
/* 436 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 438 */	NdrFcShort( 0xffffffe2 ),	/* Offset= -30 (408) */
/* 440 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 442 */	
			0x16,		/* FC_PSTRUCT */
			0x3,		/* 3 */
/* 444 */	NdrFcShort( 0x8 ),	/* 8 */
/* 446 */	
			0x4b,		/* FC_PP */
			0x5c,		/* FC_PAD */
/* 448 */	
			0x46,		/* FC_NO_REPEAT */
			0x5c,		/* FC_PAD */
/* 450 */	NdrFcShort( 0x4 ),	/* 4 */
/* 452 */	NdrFcShort( 0x4 ),	/* 4 */
/* 454 */	0x12, 0x0,	/* FC_UP */
/* 456 */	NdrFcShort( 0xffffffe2 ),	/* Offset= -30 (426) */
/* 458 */	
			0x5b,		/* FC_END */

			0x8,		/* FC_LONG */
/* 460 */	0x8,		/* FC_LONG */
			0x5b,		/* FC_END */
/* 462 */	
			0x1a,		/* FC_BOGUS_STRUCT */
			0x3,		/* 3 */
/* 464 */	NdrFcShort( 0x28 ),	/* 40 */
/* 466 */	NdrFcShort( 0x0 ),	/* 0 */
/* 468 */	NdrFcShort( 0xa ),	/* Offset= 10 (478) */
/* 470 */	0xe,		/* FC_ENUM32 */
			0x4c,		/* FC_EMBEDDED_COMPLEX */
/* 472 */	0x0,		/* 0 */
			NdrFcShort( 0xfffffe6b ),	/* Offset= -405 (68) */
			0x36,		/* FC_POINTER */
/* 476 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 478 */	
			0x12, 0x8,	/* FC_UP [simple_pointer] */
/* 480 */	
			0x25,		/* FC_C_WSTRING */
			0x5c,		/* FC_PAD */
/* 482 */	
			0x15,		/* FC_STRUCT */
			0x3,		/* 3 */
/* 484 */	NdrFcShort( 0x14 ),	/* 20 */
/* 486 */	0x8,		/* FC_LONG */
			0x4c,		/* FC_EMBEDDED_COMPLEX */
/* 488 */	0x0,		/* 0 */
			NdrFcShort( 0xfffffe37 ),	/* Offset= -457 (32) */
			0x5b,		/* FC_END */
/* 492 */	0xb5,		/* FC_PIPE */
			0x3,		/* 3 */
/* 494 */	NdrFcShort( 0xfffffff4 ),	/* Offset= -12 (482) */
/* 496 */	NdrFcShort( 0x14 ),	/* 20 */
/* 498 */	NdrFcShort( 0x14 ),	/* 20 */
/* 500 */	0xb5,		/* FC_PIPE */
			0x3,		/* 3 */
/* 502 */	NdrFcShort( 0xffffffa2 ),	/* Offset= -94 (408) */
/* 504 */	NdrFcShort( 0x54 ),	/* 84 */
/* 506 */	NdrFcShort( 0x54 ),	/* 84 */
/* 508 */	
			0x11, 0x0,	/* FC_RP */
/* 510 */	NdrFcShort( 0x2 ),	/* Offset= 2 (512) */
/* 512 */	
			0x1b,		/* FC_CARRAY */
			0x3,		/* 3 */
/* 514 */	NdrFcShort( 0x10 ),	/* 16 */
/* 516 */	0x29,		/* Corr desc:  parameter, FC_ULONG */
			0x0,		/*  */
/* 518 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 520 */	NdrFcShort( 0x1 ),	/* Corr flags:  early, */
/* 522 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 524 */	NdrFcShort( 0xfffffe14 ),	/* Offset= -492 (32) */
/* 526 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 528 */	
			0x11, 0x0,	/* FC_RP */
/* 530 */	NdrFcShort( 0xffffff3c ),	/* Offset= -196 (334) */
/* 532 */	
			0x11, 0x4,	/* FC_RP [alloced_on_stack] */
/* 534 */	NdrFcShort( 0xffffff38 ),	/* Offset= -200 (334) */
/* 536 */	
			0x11, 0x8,	/* FC_RP [simple_pointer] */
/* 538 */	0x8,		/* FC_LONG */
			0x5c,		/* FC_PAD */
/* 540 */	
			0x11, 0x0,	/* FC_RP */
/* 542 */	NdrFcShort( 0x2 ),	/* Offset= 2 (544) */
/* 544 */	
			0x25,		/* FC_C_WSTRING */
			0x44,		/* FC_STRING_SIZED */
/* 546 */	0x29,		/* Corr desc:  parameter, FC_ULONG */
			0x54,		/* FC_DEREFERENCE */
/* 548 */	NdrFcShort( 0x28 ),	/* x86 Stack size/offset = 40 */
/* 550 */	NdrFcShort( 0x1 ),	/* Corr flags:  early, */
/* 552 */	
			0x11, 0x0,	/* FC_RP */
/* 554 */	NdrFcShort( 0x2 ),	/* Offset= 2 (556) */
/* 556 */	
			0x25,		/* FC_C_WSTRING */
			0x44,		/* FC_STRING_SIZED */
/* 558 */	0x40,		/* Corr desc:  constant, val=262 */
			0x0,		/* 0 */
/* 560 */	NdrFcShort( 0x106 ),	/* 262 */
/* 562 */	NdrFcShort( 0x0 ),	/* Corr flags:  */
/* 564 */	
			0x11, 0x0,	/* FC_RP */
/* 566 */	NdrFcShort( 0x92 ),	/* Offset= 146 (712) */
/* 568 */	
			0x2b,		/* FC_NON_ENCAPSULATED_UNION */
			0x8,		/* FC_LONG */
/* 570 */	0x8,		/* Corr desc: FC_LONG */
			0x0,		/*  */
/* 572 */	NdrFcShort( 0xfff8 ),	/* -8 */
/* 574 */	NdrFcShort( 0x1 ),	/* Corr flags:  early, */
/* 576 */	NdrFcShort( 0x2 ),	/* Offset= 2 (578) */
/* 578 */	NdrFcShort( 0xc8 ),	/* 200 */
/* 580 */	NdrFcShort( 0x9 ),	/* 9 */
/* 582 */	NdrFcLong( 0x0 ),	/* 0 */
/* 586 */	NdrFcShort( 0xfffffe58 ),	/* Offset= -424 (162) */
/* 588 */	NdrFcLong( 0x1 ),	/* 1 */
/* 592 */	NdrFcShort( 0xfffffe86 ),	/* Offset= -378 (214) */
/* 594 */	NdrFcLong( 0x2 ),	/* 2 */
/* 598 */	NdrFcShort( 0xfffffec8 ),	/* Offset= -312 (286) */
/* 600 */	NdrFcLong( 0x3 ),	/* 3 */
/* 604 */	NdrFcShort( 0xffffff28 ),	/* Offset= -216 (388) */
/* 606 */	NdrFcLong( 0x4 ),	/* 4 */
/* 610 */	NdrFcShort( 0xfffffebc ),	/* Offset= -324 (286) */
/* 612 */	NdrFcLong( 0x5 ),	/* 5 */
/* 616 */	NdrFcShort( 0x1e ),	/* Offset= 30 (646) */
/* 618 */	NdrFcLong( 0x6 ),	/* 6 */
/* 622 */	NdrFcShort( 0xffffff4c ),	/* Offset= -180 (442) */
/* 624 */	NdrFcLong( 0x7 ),	/* 7 */
/* 628 */	NdrFcShort( 0xfffffd8e ),	/* Offset= -626 (2) */
/* 630 */	NdrFcLong( 0x8 ),	/* 8 */
/* 634 */	NdrFcShort( 0x8008 ),	/* Simple arm type: FC_LONG */
/* 636 */	NdrFcShort( 0xffffffff ),	/* Offset= -1 (635) */
/* 638 */	
			0x15,		/* FC_STRUCT */
			0x3,		/* 3 */
/* 640 */	NdrFcShort( 0xc ),	/* 12 */
/* 642 */	0x8,		/* FC_LONG */
			0x8,		/* FC_LONG */
/* 644 */	0x8,		/* FC_LONG */
			0x5b,		/* FC_END */
/* 646 */	
			0x15,		/* FC_STRUCT */
			0x3,		/* 3 */
/* 648 */	NdrFcShort( 0xc8 ),	/* 200 */
/* 650 */	0x8,		/* FC_LONG */
			0x8,		/* FC_LONG */
/* 652 */	0x8,		/* FC_LONG */
			0x8,		/* FC_LONG */
/* 654 */	0x8,		/* FC_LONG */
			0x8,		/* FC_LONG */
/* 656 */	0x8,		/* FC_LONG */
			0x8,		/* FC_LONG */
/* 658 */	0x8,		/* FC_LONG */
			0x8,		/* FC_LONG */
/* 660 */	0x8,		/* FC_LONG */
			0x8,		/* FC_LONG */
/* 662 */	0x8,		/* FC_LONG */
			0x8,		/* FC_LONG */
/* 664 */	0x8,		/* FC_LONG */
			0x8,		/* FC_LONG */
/* 666 */	0x8,		/* FC_LONG */
			0x8,		/* FC_LONG */
/* 668 */	0x8,		/* FC_LONG */
			0x8,		/* FC_LONG */
/* 670 */	0x8,		/* FC_LONG */
			0x8,		/* FC_LONG */
/* 672 */	0x8,		/* FC_LONG */
			0x8,		/* FC_LONG */
/* 674 */	0x8,		/* FC_LONG */
			0x8,		/* FC_LONG */
/* 676 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 678 */	NdrFcShort( 0xfffffd5c ),	/* Offset= -676 (2) */
/* 680 */	0x8,		/* FC_LONG */
			0x8,		/* FC_LONG */
/* 682 */	0x8,		/* FC_LONG */
			0x8,		/* FC_LONG */
/* 684 */	0x8,		/* FC_LONG */
			0x4c,		/* FC_EMBEDDED_COMPLEX */
/* 686 */	0x0,		/* 0 */
			NdrFcShort( 0xfffffd53 ),	/* Offset= -685 (2) */
			0x8,		/* FC_LONG */
/* 690 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 692 */	NdrFcShort( 0xfffffd4e ),	/* Offset= -690 (2) */
/* 694 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 696 */	NdrFcShort( 0xfffffd4a ),	/* Offset= -694 (2) */
/* 698 */	0x8,		/* FC_LONG */
			0x8,		/* FC_LONG */
/* 700 */	0x8,		/* FC_LONG */
			0x8,		/* FC_LONG */
/* 702 */	0x8,		/* FC_LONG */
			0x6,		/* FC_SHORT */
/* 704 */	0x6,		/* FC_SHORT */
			0x6,		/* FC_SHORT */
/* 706 */	0x6,		/* FC_SHORT */
			0x4c,		/* FC_EMBEDDED_COMPLEX */
/* 708 */	0x0,		/* 0 */
			NdrFcShort( 0xffffffb9 ),	/* Offset= -71 (638) */
			0x5b,		/* FC_END */
/* 712 */	
			0x1a,		/* FC_BOGUS_STRUCT */
			0x3,		/* 3 */
/* 714 */	NdrFcShort( 0xd4 ),	/* 212 */
/* 716 */	NdrFcShort( 0x0 ),	/* 0 */
/* 718 */	NdrFcShort( 0xa ),	/* Offset= 10 (728) */
/* 720 */	0xe,		/* FC_ENUM32 */
			0xe,		/* FC_ENUM32 */
/* 722 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 724 */	NdrFcShort( 0xffffff64 ),	/* Offset= -156 (568) */
/* 726 */	0x36,		/* FC_POINTER */
			0x5b,		/* FC_END */
/* 728 */	
			0x12, 0x8,	/* FC_UP [simple_pointer] */
/* 730 */	
			0x25,		/* FC_C_WSTRING */
			0x5c,		/* FC_PAD */
/* 732 */	
			0x11, 0x0,	/* FC_RP */
/* 734 */	NdrFcShort( 0x2 ),	/* Offset= 2 (736) */
/* 736 */	
			0x25,		/* FC_C_WSTRING */
			0x44,		/* FC_STRING_SIZED */
/* 738 */	0x40,		/* Corr desc:  constant, val=262 */
			0x0,		/* 0 */
/* 740 */	NdrFcShort( 0x106 ),	/* 262 */
/* 742 */	NdrFcShort( 0x0 ),	/* Corr flags:  */

			0x0
        }
    };

static const unsigned short trkwks_FormatStringOffsetTable[] =
    {
    0,
    70,
    128,
    168,
    214,
    248,
    300,
    352,
    398,
    432,
    520,
    584,
    624
    };


static const MIDL_STUB_DESC trkwks_StubDesc = 
    {
    (void *)& trkwks___RpcClientInterface,
    MIDL_user_allocate,
    MIDL_user_free,
    &trkwks__MIDL_AutoBindHandle,
    0,
    0,
    0,
    0,
    __MIDL_TypeFormatString.Format,
    1, /* -error bounds_check flag */
    0x50002, /* Ndr library version */
    0,
    0x600015b, /* MIDL Version 6.0.347 */
    0,
    0,
    0,  /* notify & notify_flag routine table */
    0x1, /* MIDL flag */
    0, /* cs routines */
    0,   /* proxy/server info */
    0   /* Reserved5 */
    };


#endif /* !defined(_M_IA64) && !defined(_M_AMD64)*/


#pragma warning( disable: 4049 )  /* more than 64k source lines */

/* this ALWAYS GENERATED file contains the RPC client stubs */


 /* File created by MIDL compiler version 6.00.0347 */
/* Compiler settings for trkwks.idl:
    Oicf, W1, Zp8, env=Win64 (32b run,appending)
    protocol : dce , ms_ext, c_ext, robust
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )

#if defined(_M_IA64) || defined(_M_AMD64)
#include <string.h>

#include "trkwks.h"

#define TYPE_FORMAT_STRING_SIZE   727                               
#define PROC_FORMAT_STRING_SIZE   727                               
#define TRANSMIT_AS_TABLE_SIZE    0            
#define WIRE_MARSHAL_TABLE_SIZE   0            

typedef struct _MIDL_TYPE_FORMAT_STRING
    {
    short          Pad;
    unsigned char  Format[ TYPE_FORMAT_STRING_SIZE ];
    } MIDL_TYPE_FORMAT_STRING;

typedef struct _MIDL_PROC_FORMAT_STRING
    {
    short          Pad;
    unsigned char  Format[ PROC_FORMAT_STRING_SIZE ];
    } MIDL_PROC_FORMAT_STRING;


static RPC_SYNTAX_IDENTIFIER  _RpcTransferSyntax = 
{{0x8A885D04,0x1CEB,0x11C9,{0x9F,0xE8,0x08,0x00,0x2B,0x10,0x48,0x60}},{2,0}};


extern const MIDL_TYPE_FORMAT_STRING __MIDL_TypeFormatString;
extern const MIDL_PROC_FORMAT_STRING __MIDL_ProcFormatString;

#define GENERIC_BINDING_TABLE_SIZE   0            


/* Standard interface: __MIDL_itf_trkwks_0000, ver. 0.0,
   GUID={0x00000000,0x0000,0x0000,{0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00}} */


/* Standard interface: trkwks, ver. 1.2,
   GUID={0x300f3532,0x38cc,0x11d0,{0xa3,0xf0,0x00,0x20,0xaf,0x6b,0x0a,0xdd}} */



static const RPC_CLIENT_INTERFACE trkwks___RpcClientInterface =
    {
    sizeof(RPC_CLIENT_INTERFACE),
    {{0x300f3532,0x38cc,0x11d0,{0xa3,0xf0,0x00,0x20,0xaf,0x6b,0x0a,0xdd}},{1,2}},
    {{0x8A885D04,0x1CEB,0x11C9,{0x9F,0xE8,0x08,0x00,0x2B,0x10,0x48,0x60}},{2,0}},
    0,
    0,
    0,
    0,
    0,
    0x00000001
    };
RPC_IF_HANDLE trkwks_v1_2_c_ifspec = (RPC_IF_HANDLE)& trkwks___RpcClientInterface;

extern const MIDL_STUB_DESC trkwks_StubDesc;

static RPC_BINDING_HANDLE trkwks__MIDL_AutoBindHandle;


HRESULT old_LnkMendLink( 
    /* [in] */ handle_t IDL_handle,
    /* [in] */ FILETIME ftLimit,
    /* [in] */ ULONG Restrictions,
    /* [in] */ const CDomainRelativeObjId *pdroidBirth,
    /* [in] */ const CDomainRelativeObjId *pdroidLast,
    /* [out] */ CDomainRelativeObjId *pdroidCurrent,
    /* [string][out] */ WCHAR wsz[ 261 ])
{

    CLIENT_CALL_RETURN _RetVal;

    _RetVal = NdrClientCall2(
                  ( PMIDL_STUB_DESC  )&trkwks_StubDesc,
                  (PFORMAT_STRING) &__MIDL_ProcFormatString.Format[0],
                  IDL_handle,
                  ftLimit,
                  Restrictions,
                  pdroidBirth,
                  pdroidLast,
                  pdroidCurrent,
                  wsz);
    return ( HRESULT  )_RetVal.Simple;
    
}


HRESULT old_LnkSearchMachine( 
    /* [in] */ handle_t IDL_handle,
    /* [in] */ ULONG Restrictions,
    /* [in] */ const CDomainRelativeObjId *pdroidLast,
    /* [out] */ CDomainRelativeObjId *pdroidReferral,
    /* [string][out] */ TCHAR tsz[ 261 ])
{

    CLIENT_CALL_RETURN _RetVal;

    _RetVal = NdrClientCall2(
                  ( PMIDL_STUB_DESC  )&trkwks_StubDesc,
                  (PFORMAT_STRING) &__MIDL_ProcFormatString.Format[72],
                  IDL_handle,
                  Restrictions,
                  pdroidLast,
                  pdroidReferral,
                  tsz);
    return ( HRESULT  )_RetVal.Simple;
    
}


HRESULT old_LnkCallSvrMessage( 
    /* [in] */ handle_t IDL_handle,
    /* [out][in] */ TRKSVR_MESSAGE_UNION_OLD *pMsg)
{

    CLIENT_CALL_RETURN _RetVal;

    _RetVal = NdrClientCall2(
                  ( PMIDL_STUB_DESC  )&trkwks_StubDesc,
                  (PFORMAT_STRING) &__MIDL_ProcFormatString.Format[132],
                  IDL_handle,
                  pMsg);
    return ( HRESULT  )_RetVal.Simple;
    
}


HRESULT LnkSetVolumeId( 
    /* [in] */ handle_t IDL_handle,
    ULONG volumeIndex,
    const CVolumeId VolId)
{

    CLIENT_CALL_RETURN _RetVal;

    _RetVal = NdrClientCall2(
                  ( PMIDL_STUB_DESC  )&trkwks_StubDesc,
                  (PFORMAT_STRING) &__MIDL_ProcFormatString.Format[174],
                  IDL_handle,
                  volumeIndex,
                  VolId);
    return ( HRESULT  )_RetVal.Simple;
    
}


HRESULT LnkRestartDcSynchronization( 
    /* [in] */ handle_t IDL_handle)
{

    CLIENT_CALL_RETURN _RetVal;

    _RetVal = NdrClientCall2(
                  ( PMIDL_STUB_DESC  )&trkwks_StubDesc,
                  (PFORMAT_STRING) &__MIDL_ProcFormatString.Format[222],
                  IDL_handle);
    return ( HRESULT  )_RetVal.Simple;
    
}


HRESULT GetVolumeTrackingInformation( 
    /* [in] */ handle_t IDL_handle,
    /* [in] */ CVolumeId volid,
    /* [in] */ TrkInfoScope scope,
    /* [out] */ TRK_VOLUME_TRACKING_INFORMATION_PIPE pipeVolInfo)
{

    CLIENT_CALL_RETURN _RetVal;

    _RetVal = NdrClientCall2(
                  ( PMIDL_STUB_DESC  )&trkwks_StubDesc,
                  (PFORMAT_STRING) &__MIDL_ProcFormatString.Format[258],
                  IDL_handle,
                  volid,
                  scope,
                  pipeVolInfo);
    return ( HRESULT  )_RetVal.Simple;
    
}


HRESULT GetFileTrackingInformation( 
    /* [in] */ handle_t IDL_handle,
    /* [in] */ CDomainRelativeObjId droidCurrent,
    /* [in] */ TrkInfoScope scope,
    /* [out] */ TRK_FILE_TRACKING_INFORMATION_PIPE pipeFileInfo)
{

    CLIENT_CALL_RETURN _RetVal;

    _RetVal = NdrClientCall2(
                  ( PMIDL_STUB_DESC  )&trkwks_StubDesc,
                  (PFORMAT_STRING) &__MIDL_ProcFormatString.Format[312],
                  IDL_handle,
                  droidCurrent,
                  scope,
                  pipeFileInfo);
    return ( HRESULT  )_RetVal.Simple;
    
}


HRESULT TriggerVolumeClaims( 
    /* [in] */ handle_t IDL_handle,
    /* [in] */ ULONG cVolumes,
    /* [size_is][in] */ const CVolumeId *rgvolid)
{

    CLIENT_CALL_RETURN _RetVal;

    _RetVal = NdrClientCall2(
                  ( PMIDL_STUB_DESC  )&trkwks_StubDesc,
                  (PFORMAT_STRING) &__MIDL_ProcFormatString.Format[366],
                  IDL_handle,
                  cVolumes,
                  rgvolid);
    return ( HRESULT  )_RetVal.Simple;
    
}


HRESULT LnkOnRestore( 
    /* [in] */ handle_t IDL_handle)
{

    CLIENT_CALL_RETURN _RetVal;

    _RetVal = NdrClientCall2(
                  ( PMIDL_STUB_DESC  )&trkwks_StubDesc,
                  (PFORMAT_STRING) &__MIDL_ProcFormatString.Format[414],
                  IDL_handle);
    return ( HRESULT  )_RetVal.Simple;
    
}


/* [async] */ void  LnkMendLink( 
    /* [in] */ PRPC_ASYNC_STATE LnkMendLink_AsyncHandle,
    /* [in] */ handle_t IDL_handle,
    /* [in] */ FILETIME ftLimit,
    /* [in] */ DWORD Restrictions,
    /* [in] */ const CDomainRelativeObjId *pdroidBirth,
    /* [in] */ const CDomainRelativeObjId *pdroidLast,
    /* [in] */ const CMachineId *pmcidLast,
    /* [out] */ CDomainRelativeObjId *pdroidCurrent,
    /* [out] */ CMachineId *pmcidCurrent,
    /* [out][in] */ ULONG *pcbPath,
    /* [string][size_is][out] */ WCHAR *pwszPath)
{

    NdrAsyncClientCall(
                      ( PMIDL_STUB_DESC  )&trkwks_StubDesc,
                      (PFORMAT_STRING) &__MIDL_ProcFormatString.Format[450],
                      LnkMendLink_AsyncHandle,
                      IDL_handle,
                      ftLimit,
                      Restrictions,
                      pdroidBirth,
                      pdroidLast,
                      pmcidLast,
                      pdroidCurrent,
                      pmcidCurrent,
                      pcbPath,
                      pwszPath);
    
}


HRESULT old2_LnkSearchMachine( 
    /* [in] */ handle_t IDL_handle,
    /* [in] */ DWORD Restrictions,
    /* [in] */ const CDomainRelativeObjId *pdroidLast,
    /* [out] */ CDomainRelativeObjId *pdroidNext,
    /* [out] */ CMachineId *pmcidNext,
    /* [string][max_is][out] */ TCHAR *ptszPath)
{

    CLIENT_CALL_RETURN _RetVal;

    _RetVal = NdrClientCall2(
                  ( PMIDL_STUB_DESC  )&trkwks_StubDesc,
                  (PFORMAT_STRING) &__MIDL_ProcFormatString.Format[540],
                  IDL_handle,
                  Restrictions,
                  pdroidLast,
                  pdroidNext,
                  pmcidNext,
                  ptszPath);
    return ( HRESULT  )_RetVal.Simple;
    
}


HRESULT LnkCallSvrMessage( 
    /* [in] */ handle_t IDL_handle,
    /* [out][in] */ TRKSVR_MESSAGE_UNION *pMsg)
{

    CLIENT_CALL_RETURN _RetVal;

    _RetVal = NdrClientCall2(
                  ( PMIDL_STUB_DESC  )&trkwks_StubDesc,
                  (PFORMAT_STRING) &__MIDL_ProcFormatString.Format[606],
                  IDL_handle,
                  pMsg);
    return ( HRESULT  )_RetVal.Simple;
    
}


HRESULT LnkSearchMachine( 
    /* [in] */ handle_t IDL_handle,
    /* [in] */ DWORD Restrictions,
    /* [in] */ const CDomainRelativeObjId *pdroidBirthLast,
    /* [in] */ const CDomainRelativeObjId *pdroidLast,
    /* [out] */ CDomainRelativeObjId *pdroidBirthNext,
    /* [out] */ CDomainRelativeObjId *pdroidNext,
    /* [out] */ CMachineId *pmcidNext,
    /* [string][max_is][out] */ TCHAR *ptszPath)
{

    CLIENT_CALL_RETURN _RetVal;

    _RetVal = NdrClientCall2(
                  ( PMIDL_STUB_DESC  )&trkwks_StubDesc,
                  (PFORMAT_STRING) &__MIDL_ProcFormatString.Format[648],
                  IDL_handle,
                  Restrictions,
                  pdroidBirthLast,
                  pdroidLast,
                  pdroidBirthNext,
                  pdroidNext,
                  pmcidNext,
                  ptszPath);
    return ( HRESULT  )_RetVal.Simple;
    
}


#if !defined(__RPC_WIN64__)
#error  Invalid build platform for this stub.
#endif

static const MIDL_PROC_FORMAT_STRING __MIDL_ProcFormatString =
    {
        0,
        {

	/* Procedure old_LnkMendLink */

			0x0,		/* 0 */
			0x48,		/* Old Flags:  */
/*  2 */	NdrFcLong( 0x0 ),	/* 0 */
/*  6 */	NdrFcShort( 0x0 ),	/* 0 */
/*  8 */	NdrFcShort( 0x40 ),	/* ia64 Stack size/offset = 64 */
/* 10 */	0x32,		/* FC_BIND_PRIMITIVE */
			0x0,		/* 0 */
/* 12 */	NdrFcShort( 0x0 ),	/* ia64 Stack size/offset = 0 */
/* 14 */	NdrFcShort( 0x168 ),	/* 360 */
/* 16 */	NdrFcShort( 0xac ),	/* 172 */
/* 18 */	0x45,		/* Oi2 Flags:  srv must size, has return, has ext, */
			0x7,		/* 7 */
/* 20 */	0xa,		/* 10 */
			0x1,		/* Ext Flags:  new corr desc, */
/* 22 */	NdrFcShort( 0x0 ),	/* 0 */
/* 24 */	NdrFcShort( 0x0 ),	/* 0 */
/* 26 */	NdrFcShort( 0x0 ),	/* 0 */
/* 28 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter IDL_handle */

/* 30 */	NdrFcShort( 0x8a ),	/* Flags:  must free, in, by val, */
/* 32 */	NdrFcShort( 0x8 ),	/* ia64 Stack size/offset = 8 */
/* 34 */	NdrFcShort( 0x2 ),	/* Type Offset=2 */

	/* Parameter ftLimit */

/* 36 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 38 */	NdrFcShort( 0x10 ),	/* ia64 Stack size/offset = 16 */
/* 40 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter Restrictions */

/* 42 */	NdrFcShort( 0x10a ),	/* Flags:  must free, in, simple ref, */
/* 44 */	NdrFcShort( 0x18 ),	/* ia64 Stack size/offset = 24 */
/* 46 */	NdrFcShort( 0x2a ),	/* Type Offset=42 */

	/* Parameter pdroidBirth */

/* 48 */	NdrFcShort( 0x10a ),	/* Flags:  must free, in, simple ref, */
/* 50 */	NdrFcShort( 0x20 ),	/* ia64 Stack size/offset = 32 */
/* 52 */	NdrFcShort( 0x2a ),	/* Type Offset=42 */

	/* Parameter pdroidLast */

/* 54 */	NdrFcShort( 0x8112 ),	/* Flags:  must free, out, simple ref, srv alloc size=32 */
/* 56 */	NdrFcShort( 0x28 ),	/* ia64 Stack size/offset = 40 */
/* 58 */	NdrFcShort( 0x2a ),	/* Type Offset=42 */

	/* Parameter pdroidCurrent */

/* 60 */	NdrFcShort( 0x13 ),	/* Flags:  must size, must free, out, */
/* 62 */	NdrFcShort( 0x30 ),	/* ia64 Stack size/offset = 48 */
/* 64 */	NdrFcShort( 0x3c ),	/* Type Offset=60 */

	/* Parameter wsz */

/* 66 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 68 */	NdrFcShort( 0x38 ),	/* ia64 Stack size/offset = 56 */
/* 70 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure old_LnkSearchMachine */


	/* Return value */

/* 72 */	0x0,		/* 0 */
			0x48,		/* Old Flags:  */
/* 74 */	NdrFcLong( 0x0 ),	/* 0 */
/* 78 */	NdrFcShort( 0x1 ),	/* 1 */
/* 80 */	NdrFcShort( 0x30 ),	/* ia64 Stack size/offset = 48 */
/* 82 */	0x32,		/* FC_BIND_PRIMITIVE */
			0x0,		/* 0 */
/* 84 */	NdrFcShort( 0x0 ),	/* ia64 Stack size/offset = 0 */
/* 86 */	NdrFcShort( 0xac ),	/* 172 */
/* 88 */	NdrFcShort( 0xac ),	/* 172 */
/* 90 */	0x45,		/* Oi2 Flags:  srv must size, has return, has ext, */
			0x5,		/* 5 */
/* 92 */	0xa,		/* 10 */
			0x1,		/* Ext Flags:  new corr desc, */
/* 94 */	NdrFcShort( 0x0 ),	/* 0 */
/* 96 */	NdrFcShort( 0x0 ),	/* 0 */
/* 98 */	NdrFcShort( 0x0 ),	/* 0 */
/* 100 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter IDL_handle */

/* 102 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 104 */	NdrFcShort( 0x8 ),	/* ia64 Stack size/offset = 8 */
/* 106 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter Restrictions */

/* 108 */	NdrFcShort( 0x10a ),	/* Flags:  must free, in, simple ref, */
/* 110 */	NdrFcShort( 0x10 ),	/* ia64 Stack size/offset = 16 */
/* 112 */	NdrFcShort( 0x2a ),	/* Type Offset=42 */

	/* Parameter pdroidLast */

/* 114 */	NdrFcShort( 0x8112 ),	/* Flags:  must free, out, simple ref, srv alloc size=32 */
/* 116 */	NdrFcShort( 0x18 ),	/* ia64 Stack size/offset = 24 */
/* 118 */	NdrFcShort( 0x2a ),	/* Type Offset=42 */

	/* Parameter pdroidReferral */

/* 120 */	NdrFcShort( 0x13 ),	/* Flags:  must size, must free, out, */
/* 122 */	NdrFcShort( 0x20 ),	/* ia64 Stack size/offset = 32 */
/* 124 */	NdrFcShort( 0x3c ),	/* Type Offset=60 */

	/* Parameter tsz */

/* 126 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 128 */	NdrFcShort( 0x28 ),	/* ia64 Stack size/offset = 40 */
/* 130 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure old_LnkCallSvrMessage */


	/* Return value */

/* 132 */	0x0,		/* 0 */
			0x48,		/* Old Flags:  */
/* 134 */	NdrFcLong( 0x0 ),	/* 0 */
/* 138 */	NdrFcShort( 0x2 ),	/* 2 */
/* 140 */	NdrFcShort( 0x18 ),	/* ia64 Stack size/offset = 24 */
/* 142 */	0x32,		/* FC_BIND_PRIMITIVE */
			0x0,		/* 0 */
/* 144 */	NdrFcShort( 0x0 ),	/* ia64 Stack size/offset = 0 */
/* 146 */	NdrFcShort( 0x0 ),	/* 0 */
/* 148 */	NdrFcShort( 0x8 ),	/* 8 */
/* 150 */	0x47,		/* Oi2 Flags:  srv must size, clt must size, has return, has ext, */
			0x2,		/* 2 */
/* 152 */	0xa,		/* 10 */
			0x7,		/* Ext Flags:  new corr desc, clt corr check, srv corr check, */
/* 154 */	NdrFcShort( 0xb ),	/* 11 */
/* 156 */	NdrFcShort( 0xb ),	/* 11 */
/* 158 */	NdrFcShort( 0x0 ),	/* 0 */
/* 160 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter IDL_handle */

/* 162 */	NdrFcShort( 0x11b ),	/* Flags:  must size, must free, in, out, simple ref, */
/* 164 */	NdrFcShort( 0x8 ),	/* ia64 Stack size/offset = 8 */
/* 166 */	NdrFcShort( 0x1bc ),	/* Type Offset=444 */

	/* Parameter pMsg */

/* 168 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 170 */	NdrFcShort( 0x10 ),	/* ia64 Stack size/offset = 16 */
/* 172 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure LnkSetVolumeId */


	/* Return value */

/* 174 */	0x0,		/* 0 */
			0x48,		/* Old Flags:  */
/* 176 */	NdrFcLong( 0x0 ),	/* 0 */
/* 180 */	NdrFcShort( 0x3 ),	/* 3 */
/* 182 */	NdrFcShort( 0x28 ),	/* ia64 Stack size/offset = 40 */
/* 184 */	0x32,		/* FC_BIND_PRIMITIVE */
			0x0,		/* 0 */
/* 186 */	NdrFcShort( 0x0 ),	/* ia64 Stack size/offset = 0 */
/* 188 */	NdrFcShort( 0x48 ),	/* 72 */
/* 190 */	NdrFcShort( 0x8 ),	/* 8 */
/* 192 */	0x44,		/* Oi2 Flags:  has return, has ext, */
			0x3,		/* 3 */
/* 194 */	0xa,		/* 10 */
			0x1,		/* Ext Flags:  new corr desc, */
/* 196 */	NdrFcShort( 0x0 ),	/* 0 */
/* 198 */	NdrFcShort( 0x0 ),	/* 0 */
/* 200 */	NdrFcShort( 0x0 ),	/* 0 */
/* 202 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter IDL_handle */

/* 204 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 206 */	NdrFcShort( 0x8 ),	/* ia64 Stack size/offset = 8 */
/* 208 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter volumeIndex */

/* 210 */	NdrFcShort( 0x8a ),	/* Flags:  must free, in, by val, */
/* 212 */	NdrFcShort( 0x10 ),	/* ia64 Stack size/offset = 16 */
/* 214 */	NdrFcShort( 0x20 ),	/* Type Offset=32 */

	/* Parameter VolId */

/* 216 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 218 */	NdrFcShort( 0x20 ),	/* ia64 Stack size/offset = 32 */
/* 220 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure LnkRestartDcSynchronization */


	/* Return value */

/* 222 */	0x0,		/* 0 */
			0x48,		/* Old Flags:  */
/* 224 */	NdrFcLong( 0x0 ),	/* 0 */
/* 228 */	NdrFcShort( 0x4 ),	/* 4 */
/* 230 */	NdrFcShort( 0x10 ),	/* ia64 Stack size/offset = 16 */
/* 232 */	0x32,		/* FC_BIND_PRIMITIVE */
			0x0,		/* 0 */
/* 234 */	NdrFcShort( 0x0 ),	/* ia64 Stack size/offset = 0 */
/* 236 */	NdrFcShort( 0x0 ),	/* 0 */
/* 238 */	NdrFcShort( 0x8 ),	/* 8 */
/* 240 */	0x44,		/* Oi2 Flags:  has return, has ext, */
			0x1,		/* 1 */
/* 242 */	0xa,		/* 10 */
			0x1,		/* Ext Flags:  new corr desc, */
/* 244 */	NdrFcShort( 0x0 ),	/* 0 */
/* 246 */	NdrFcShort( 0x0 ),	/* 0 */
/* 248 */	NdrFcShort( 0x0 ),	/* 0 */
/* 250 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter IDL_handle */

/* 252 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 254 */	NdrFcShort( 0x8 ),	/* ia64 Stack size/offset = 8 */
/* 256 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure GetVolumeTrackingInformation */


	/* Return value */

/* 258 */	0x0,		/* 0 */
			0x48,		/* Old Flags:  */
/* 260 */	NdrFcLong( 0x0 ),	/* 0 */
/* 264 */	NdrFcShort( 0x5 ),	/* 5 */
/* 266 */	NdrFcShort( 0x48 ),	/* ia64 Stack size/offset = 72 */
/* 268 */	0x32,		/* FC_BIND_PRIMITIVE */
			0x0,		/* 0 */
/* 270 */	NdrFcShort( 0x0 ),	/* ia64 Stack size/offset = 0 */
/* 272 */	NdrFcShort( 0x48 ),	/* 72 */
/* 274 */	NdrFcShort( 0x8 ),	/* 8 */
/* 276 */	0x4c,		/* Oi2 Flags:  has return, has pipes, has ext, */
			0x4,		/* 4 */
/* 278 */	0xa,		/* 10 */
			0x1,		/* Ext Flags:  new corr desc, */
/* 280 */	NdrFcShort( 0x0 ),	/* 0 */
/* 282 */	NdrFcShort( 0x0 ),	/* 0 */
/* 284 */	NdrFcShort( 0x0 ),	/* 0 */
/* 286 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter IDL_handle */

/* 288 */	NdrFcShort( 0x8a ),	/* Flags:  must free, in, by val, */
/* 290 */	NdrFcShort( 0x8 ),	/* ia64 Stack size/offset = 8 */
/* 292 */	NdrFcShort( 0x20 ),	/* Type Offset=32 */

	/* Parameter volid */

/* 294 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 296 */	NdrFcShort( 0x18 ),	/* ia64 Stack size/offset = 24 */
/* 298 */	0xe,		/* FC_ENUM32 */
			0x0,		/* 0 */

	/* Parameter scope */

/* 300 */	NdrFcShort( 0x14 ),	/* Flags:  pipe, out, */
/* 302 */	NdrFcShort( 0x20 ),	/* ia64 Stack size/offset = 32 */
/* 304 */	NdrFcShort( 0x1da ),	/* Type Offset=474 */

	/* Parameter pipeVolInfo */

/* 306 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 308 */	NdrFcShort( 0x40 ),	/* ia64 Stack size/offset = 64 */
/* 310 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure GetFileTrackingInformation */


	/* Return value */

/* 312 */	0x0,		/* 0 */
			0x48,		/* Old Flags:  */
/* 314 */	NdrFcLong( 0x0 ),	/* 0 */
/* 318 */	NdrFcShort( 0x6 ),	/* 6 */
/* 320 */	NdrFcShort( 0x58 ),	/* ia64 Stack size/offset = 88 */
/* 322 */	0x32,		/* FC_BIND_PRIMITIVE */
			0x0,		/* 0 */
/* 324 */	NdrFcShort( 0x0 ),	/* ia64 Stack size/offset = 0 */
/* 326 */	NdrFcShort( 0x98 ),	/* 152 */
/* 328 */	NdrFcShort( 0x8 ),	/* 8 */
/* 330 */	0x4c,		/* Oi2 Flags:  has return, has pipes, has ext, */
			0x4,		/* 4 */
/* 332 */	0xa,		/* 10 */
			0x1,		/* Ext Flags:  new corr desc, */
/* 334 */	NdrFcShort( 0x0 ),	/* 0 */
/* 336 */	NdrFcShort( 0x0 ),	/* 0 */
/* 338 */	NdrFcShort( 0x0 ),	/* 0 */
/* 340 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter IDL_handle */

/* 342 */	NdrFcShort( 0x8a ),	/* Flags:  must free, in, by val, */
/* 344 */	NdrFcShort( 0x8 ),	/* ia64 Stack size/offset = 8 */
/* 346 */	NdrFcShort( 0x2a ),	/* Type Offset=42 */

	/* Parameter droidCurrent */

/* 348 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 350 */	NdrFcShort( 0x28 ),	/* ia64 Stack size/offset = 40 */
/* 352 */	0xe,		/* FC_ENUM32 */
			0x0,		/* 0 */

	/* Parameter scope */

/* 354 */	NdrFcShort( 0x14 ),	/* Flags:  pipe, out, */
/* 356 */	NdrFcShort( 0x30 ),	/* ia64 Stack size/offset = 48 */
/* 358 */	NdrFcShort( 0x1e2 ),	/* Type Offset=482 */

	/* Parameter pipeFileInfo */

/* 360 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 362 */	NdrFcShort( 0x50 ),	/* ia64 Stack size/offset = 80 */
/* 364 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure TriggerVolumeClaims */


	/* Return value */

/* 366 */	0x0,		/* 0 */
			0x48,		/* Old Flags:  */
/* 368 */	NdrFcLong( 0x0 ),	/* 0 */
/* 372 */	NdrFcShort( 0x7 ),	/* 7 */
/* 374 */	NdrFcShort( 0x20 ),	/* ia64 Stack size/offset = 32 */
/* 376 */	0x32,		/* FC_BIND_PRIMITIVE */
			0x0,		/* 0 */
/* 378 */	NdrFcShort( 0x0 ),	/* ia64 Stack size/offset = 0 */
/* 380 */	NdrFcShort( 0x8 ),	/* 8 */
/* 382 */	NdrFcShort( 0x8 ),	/* 8 */
/* 384 */	0x46,		/* Oi2 Flags:  clt must size, has return, has ext, */
			0x3,		/* 3 */
/* 386 */	0xa,		/* 10 */
			0x5,		/* Ext Flags:  new corr desc, srv corr check, */
/* 388 */	NdrFcShort( 0x0 ),	/* 0 */
/* 390 */	NdrFcShort( 0x1 ),	/* 1 */
/* 392 */	NdrFcShort( 0x0 ),	/* 0 */
/* 394 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter IDL_handle */

/* 396 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 398 */	NdrFcShort( 0x8 ),	/* ia64 Stack size/offset = 8 */
/* 400 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter cVolumes */

/* 402 */	NdrFcShort( 0x10b ),	/* Flags:  must size, must free, in, simple ref, */
/* 404 */	NdrFcShort( 0x10 ),	/* ia64 Stack size/offset = 16 */
/* 406 */	NdrFcShort( 0x1ee ),	/* Type Offset=494 */

	/* Parameter rgvolid */

/* 408 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 410 */	NdrFcShort( 0x18 ),	/* ia64 Stack size/offset = 24 */
/* 412 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure LnkOnRestore */


	/* Return value */

/* 414 */	0x0,		/* 0 */
			0x48,		/* Old Flags:  */
/* 416 */	NdrFcLong( 0x0 ),	/* 0 */
/* 420 */	NdrFcShort( 0x8 ),	/* 8 */
/* 422 */	NdrFcShort( 0x10 ),	/* ia64 Stack size/offset = 16 */
/* 424 */	0x32,		/* FC_BIND_PRIMITIVE */
			0x0,		/* 0 */
/* 426 */	NdrFcShort( 0x0 ),	/* ia64 Stack size/offset = 0 */
/* 428 */	NdrFcShort( 0x0 ),	/* 0 */
/* 430 */	NdrFcShort( 0x8 ),	/* 8 */
/* 432 */	0x44,		/* Oi2 Flags:  has return, has ext, */
			0x1,		/* 1 */
/* 434 */	0xa,		/* 10 */
			0x1,		/* Ext Flags:  new corr desc, */
/* 436 */	NdrFcShort( 0x0 ),	/* 0 */
/* 438 */	NdrFcShort( 0x0 ),	/* 0 */
/* 440 */	NdrFcShort( 0x0 ),	/* 0 */
/* 442 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter IDL_handle */

/* 444 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 446 */	NdrFcShort( 0x8 ),	/* ia64 Stack size/offset = 8 */
/* 448 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure LnkMendLink */


	/* Return value */

/* 450 */	0x0,		/* 0 */
			0x48,		/* Old Flags:  */
/* 452 */	NdrFcLong( 0x0 ),	/* 0 */
/* 456 */	NdrFcShort( 0x9 ),	/* 9 */
/* 458 */	NdrFcShort( 0x60 ),	/* ia64 Stack size/offset = 96 */
/* 460 */	0x32,		/* FC_BIND_PRIMITIVE */
			0x0,		/* 0 */
/* 462 */	NdrFcShort( 0x8 ),	/* ia64 Stack size/offset = 8 */
/* 464 */	NdrFcShort( 0x1c8 ),	/* 456 */
/* 466 */	NdrFcShort( 0x10c ),	/* 268 */
/* 468 */	0xc5,		/* Oi2 Flags:  srv must size, has return, has ext, has async handle */
			0xa,		/* 10 */
/* 470 */	0xa,		/* 10 */
			0x3,		/* Ext Flags:  new corr desc, clt corr check, */
/* 472 */	NdrFcShort( 0x1 ),	/* 1 */
/* 474 */	NdrFcShort( 0x0 ),	/* 0 */
/* 476 */	NdrFcShort( 0x0 ),	/* 0 */
/* 478 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter IDL_handle */

/* 480 */	NdrFcShort( 0x8a ),	/* Flags:  must free, in, by val, */
/* 482 */	NdrFcShort( 0x10 ),	/* ia64 Stack size/offset = 16 */
/* 484 */	NdrFcShort( 0x2 ),	/* Type Offset=2 */

	/* Parameter ftLimit */

/* 486 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 488 */	NdrFcShort( 0x18 ),	/* ia64 Stack size/offset = 24 */
/* 490 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter Restrictions */

/* 492 */	NdrFcShort( 0x10a ),	/* Flags:  must free, in, simple ref, */
/* 494 */	NdrFcShort( 0x20 ),	/* ia64 Stack size/offset = 32 */
/* 496 */	NdrFcShort( 0x2a ),	/* Type Offset=42 */

	/* Parameter pdroidBirth */

/* 498 */	NdrFcShort( 0x10a ),	/* Flags:  must free, in, simple ref, */
/* 500 */	NdrFcShort( 0x28 ),	/* ia64 Stack size/offset = 40 */
/* 502 */	NdrFcShort( 0x2a ),	/* Type Offset=42 */

	/* Parameter pdroidLast */

/* 504 */	NdrFcShort( 0x10a ),	/* Flags:  must free, in, simple ref, */
/* 506 */	NdrFcShort( 0x30 ),	/* ia64 Stack size/offset = 48 */
/* 508 */	NdrFcShort( 0x12c ),	/* Type Offset=300 */

	/* Parameter pmcidLast */

/* 510 */	NdrFcShort( 0x8112 ),	/* Flags:  must free, out, simple ref, srv alloc size=32 */
/* 512 */	NdrFcShort( 0x38 ),	/* ia64 Stack size/offset = 56 */
/* 514 */	NdrFcShort( 0x2a ),	/* Type Offset=42 */

	/* Parameter pdroidCurrent */

/* 516 */	NdrFcShort( 0x4112 ),	/* Flags:  must free, out, simple ref, srv alloc size=16 */
/* 518 */	NdrFcShort( 0x40 ),	/* ia64 Stack size/offset = 64 */
/* 520 */	NdrFcShort( 0x12c ),	/* Type Offset=300 */

	/* Parameter pmcidCurrent */

/* 522 */	NdrFcShort( 0x158 ),	/* Flags:  in, out, base type, simple ref, */
/* 524 */	NdrFcShort( 0x48 ),	/* ia64 Stack size/offset = 72 */
/* 526 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter pcbPath */

/* 528 */	NdrFcShort( 0x113 ),	/* Flags:  must size, must free, out, simple ref, */
/* 530 */	NdrFcShort( 0x50 ),	/* ia64 Stack size/offset = 80 */
/* 532 */	NdrFcShort( 0x20e ),	/* Type Offset=526 */

	/* Parameter pwszPath */

/* 534 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 536 */	NdrFcShort( 0x58 ),	/* ia64 Stack size/offset = 88 */
/* 538 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure old2_LnkSearchMachine */


	/* Return value */

/* 540 */	0x0,		/* 0 */
			0x48,		/* Old Flags:  */
/* 542 */	NdrFcLong( 0x0 ),	/* 0 */
/* 546 */	NdrFcShort( 0xa ),	/* 10 */
/* 548 */	NdrFcShort( 0x38 ),	/* ia64 Stack size/offset = 56 */
/* 550 */	0x32,		/* FC_BIND_PRIMITIVE */
			0x0,		/* 0 */
/* 552 */	NdrFcShort( 0x0 ),	/* ia64 Stack size/offset = 0 */
/* 554 */	NdrFcShort( 0xac ),	/* 172 */
/* 556 */	NdrFcShort( 0xf0 ),	/* 240 */
/* 558 */	0x45,		/* Oi2 Flags:  srv must size, has return, has ext, */
			0x6,		/* 6 */
/* 560 */	0xa,		/* 10 */
			0x3,		/* Ext Flags:  new corr desc, clt corr check, */
/* 562 */	NdrFcShort( 0x1 ),	/* 1 */
/* 564 */	NdrFcShort( 0x0 ),	/* 0 */
/* 566 */	NdrFcShort( 0x0 ),	/* 0 */
/* 568 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter IDL_handle */

/* 570 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 572 */	NdrFcShort( 0x8 ),	/* ia64 Stack size/offset = 8 */
/* 574 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter Restrictions */

/* 576 */	NdrFcShort( 0x10a ),	/* Flags:  must free, in, simple ref, */
/* 578 */	NdrFcShort( 0x10 ),	/* ia64 Stack size/offset = 16 */
/* 580 */	NdrFcShort( 0x2a ),	/* Type Offset=42 */

	/* Parameter pdroidLast */

/* 582 */	NdrFcShort( 0x8112 ),	/* Flags:  must free, out, simple ref, srv alloc size=32 */
/* 584 */	NdrFcShort( 0x18 ),	/* ia64 Stack size/offset = 24 */
/* 586 */	NdrFcShort( 0x2a ),	/* Type Offset=42 */

	/* Parameter pdroidNext */

/* 588 */	NdrFcShort( 0x4112 ),	/* Flags:  must free, out, simple ref, srv alloc size=16 */
/* 590 */	NdrFcShort( 0x20 ),	/* ia64 Stack size/offset = 32 */
/* 592 */	NdrFcShort( 0x12c ),	/* Type Offset=300 */

	/* Parameter pmcidNext */

/* 594 */	NdrFcShort( 0x113 ),	/* Flags:  must size, must free, out, simple ref, */
/* 596 */	NdrFcShort( 0x28 ),	/* ia64 Stack size/offset = 40 */
/* 598 */	NdrFcShort( 0x21a ),	/* Type Offset=538 */

	/* Parameter ptszPath */

/* 600 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 602 */	NdrFcShort( 0x30 ),	/* ia64 Stack size/offset = 48 */
/* 604 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure LnkCallSvrMessage */


	/* Return value */

/* 606 */	0x0,		/* 0 */
			0x48,		/* Old Flags:  */
/* 608 */	NdrFcLong( 0x0 ),	/* 0 */
/* 612 */	NdrFcShort( 0xb ),	/* 11 */
/* 614 */	NdrFcShort( 0x18 ),	/* ia64 Stack size/offset = 24 */
/* 616 */	0x32,		/* FC_BIND_PRIMITIVE */
			0x0,		/* 0 */
/* 618 */	NdrFcShort( 0x0 ),	/* ia64 Stack size/offset = 0 */
/* 620 */	NdrFcShort( 0x0 ),	/* 0 */
/* 622 */	NdrFcShort( 0x8 ),	/* 8 */
/* 624 */	0x47,		/* Oi2 Flags:  srv must size, clt must size, has return, has ext, */
			0x2,		/* 2 */
/* 626 */	0xa,		/* 10 */
			0x7,		/* Ext Flags:  new corr desc, clt corr check, srv corr check, */
/* 628 */	NdrFcShort( 0xb ),	/* 11 */
/* 630 */	NdrFcShort( 0xb ),	/* 11 */
/* 632 */	NdrFcShort( 0x0 ),	/* 0 */
/* 634 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter IDL_handle */

/* 636 */	NdrFcShort( 0x11b ),	/* Flags:  must size, must free, in, out, simple ref, */
/* 638 */	NdrFcShort( 0x8 ),	/* ia64 Stack size/offset = 8 */
/* 640 */	NdrFcShort( 0x2b6 ),	/* Type Offset=694 */

	/* Parameter pMsg */

/* 642 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 644 */	NdrFcShort( 0x10 ),	/* ia64 Stack size/offset = 16 */
/* 646 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure LnkSearchMachine */


	/* Return value */

/* 648 */	0x0,		/* 0 */
			0x48,		/* Old Flags:  */
/* 650 */	NdrFcLong( 0x0 ),	/* 0 */
/* 654 */	NdrFcShort( 0xc ),	/* 12 */
/* 656 */	NdrFcShort( 0x48 ),	/* ia64 Stack size/offset = 72 */
/* 658 */	0x32,		/* FC_BIND_PRIMITIVE */
			0x0,		/* 0 */
/* 660 */	NdrFcShort( 0x0 ),	/* ia64 Stack size/offset = 0 */
/* 662 */	NdrFcShort( 0x150 ),	/* 336 */
/* 664 */	NdrFcShort( 0x194 ),	/* 404 */
/* 666 */	0x45,		/* Oi2 Flags:  srv must size, has return, has ext, */
			0x8,		/* 8 */
/* 668 */	0xa,		/* 10 */
			0x3,		/* Ext Flags:  new corr desc, clt corr check, */
/* 670 */	NdrFcShort( 0x1 ),	/* 1 */
/* 672 */	NdrFcShort( 0x0 ),	/* 0 */
/* 674 */	NdrFcShort( 0x0 ),	/* 0 */
/* 676 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter IDL_handle */

/* 678 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 680 */	NdrFcShort( 0x8 ),	/* ia64 Stack size/offset = 8 */
/* 682 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter Restrictions */

/* 684 */	NdrFcShort( 0x10a ),	/* Flags:  must free, in, simple ref, */
/* 686 */	NdrFcShort( 0x10 ),	/* ia64 Stack size/offset = 16 */
/* 688 */	NdrFcShort( 0x2a ),	/* Type Offset=42 */

	/* Parameter pdroidBirthLast */

/* 690 */	NdrFcShort( 0x10a ),	/* Flags:  must free, in, simple ref, */
/* 692 */	NdrFcShort( 0x18 ),	/* ia64 Stack size/offset = 24 */
/* 694 */	NdrFcShort( 0x2a ),	/* Type Offset=42 */

	/* Parameter pdroidLast */

/* 696 */	NdrFcShort( 0x8112 ),	/* Flags:  must free, out, simple ref, srv alloc size=32 */
/* 698 */	NdrFcShort( 0x20 ),	/* ia64 Stack size/offset = 32 */
/* 700 */	NdrFcShort( 0x2a ),	/* Type Offset=42 */

	/* Parameter pdroidBirthNext */

/* 702 */	NdrFcShort( 0x8112 ),	/* Flags:  must free, out, simple ref, srv alloc size=32 */
/* 704 */	NdrFcShort( 0x28 ),	/* ia64 Stack size/offset = 40 */
/* 706 */	NdrFcShort( 0x2a ),	/* Type Offset=42 */

	/* Parameter pdroidNext */

/* 708 */	NdrFcShort( 0x4112 ),	/* Flags:  must free, out, simple ref, srv alloc size=16 */
/* 710 */	NdrFcShort( 0x30 ),	/* ia64 Stack size/offset = 48 */
/* 712 */	NdrFcShort( 0x12c ),	/* Type Offset=300 */

	/* Parameter pmcidNext */

/* 714 */	NdrFcShort( 0x113 ),	/* Flags:  must size, must free, out, simple ref, */
/* 716 */	NdrFcShort( 0x38 ),	/* ia64 Stack size/offset = 56 */
/* 718 */	NdrFcShort( 0x2ce ),	/* Type Offset=718 */

	/* Parameter ptszPath */

/* 720 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 722 */	NdrFcShort( 0x40 ),	/* ia64 Stack size/offset = 64 */
/* 724 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

			0x0
        }
    };

static const MIDL_TYPE_FORMAT_STRING __MIDL_TypeFormatString =
    {
        0,
        {
			NdrFcShort( 0x0 ),	/* 0 */
/*  2 */	
			0x15,		/* FC_STRUCT */
			0x3,		/* 3 */
/*  4 */	NdrFcShort( 0x8 ),	/* 8 */
/*  6 */	0x8,		/* FC_LONG */
			0x8,		/* FC_LONG */
/*  8 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 10 */	
			0x11, 0x0,	/* FC_RP */
/* 12 */	NdrFcShort( 0x1e ),	/* Offset= 30 (42) */
/* 14 */	
			0x1d,		/* FC_SMFARRAY */
			0x0,		/* 0 */
/* 16 */	NdrFcShort( 0x8 ),	/* 8 */
/* 18 */	0x1,		/* FC_BYTE */
			0x5b,		/* FC_END */
/* 20 */	
			0x15,		/* FC_STRUCT */
			0x3,		/* 3 */
/* 22 */	NdrFcShort( 0x10 ),	/* 16 */
/* 24 */	0x8,		/* FC_LONG */
			0x6,		/* FC_SHORT */
/* 26 */	0x6,		/* FC_SHORT */
			0x4c,		/* FC_EMBEDDED_COMPLEX */
/* 28 */	0x0,		/* 0 */
			NdrFcShort( 0xfffffff1 ),	/* Offset= -15 (14) */
			0x5b,		/* FC_END */
/* 32 */	
			0x15,		/* FC_STRUCT */
			0x3,		/* 3 */
/* 34 */	NdrFcShort( 0x10 ),	/* 16 */
/* 36 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 38 */	NdrFcShort( 0xffffffee ),	/* Offset= -18 (20) */
/* 40 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 42 */	
			0x15,		/* FC_STRUCT */
			0x3,		/* 3 */
/* 44 */	NdrFcShort( 0x20 ),	/* 32 */
/* 46 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 48 */	NdrFcShort( 0xfffffff0 ),	/* Offset= -16 (32) */
/* 50 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 52 */	NdrFcShort( 0xffffffec ),	/* Offset= -20 (32) */
/* 54 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 56 */	
			0x11, 0x4,	/* FC_RP [alloced_on_stack] */
/* 58 */	NdrFcShort( 0xfffffff0 ),	/* Offset= -16 (42) */
/* 60 */	
			0x29,		/* FC_WSTRING */
			0x5c,		/* FC_PAD */
/* 62 */	NdrFcShort( 0x105 ),	/* 261 */
/* 64 */	
			0x11, 0x0,	/* FC_RP */
/* 66 */	NdrFcShort( 0x17a ),	/* Offset= 378 (444) */
/* 68 */	
			0x2b,		/* FC_NON_ENCAPSULATED_UNION */
			0x8,		/* FC_LONG */
/* 70 */	0x8,		/* Corr desc: FC_LONG */
			0x0,		/*  */
/* 72 */	NdrFcShort( 0xfff8 ),	/* -8 */
/* 74 */	NdrFcShort( 0x1 ),	/* Corr flags:  early, */
/* 76 */	NdrFcShort( 0x2 ),	/* Offset= 2 (78) */
/* 78 */	NdrFcShort( 0x30 ),	/* 48 */
/* 80 */	NdrFcShort( 0x6 ),	/* 6 */
/* 82 */	NdrFcLong( 0x0 ),	/* 0 */
/* 86 */	NdrFcShort( 0x4c ),	/* Offset= 76 (162) */
/* 88 */	NdrFcLong( 0x1 ),	/* 1 */
/* 92 */	NdrFcShort( 0x76 ),	/* Offset= 118 (210) */
/* 94 */	NdrFcLong( 0x2 ),	/* 2 */
/* 98 */	NdrFcShort( 0xa2 ),	/* Offset= 162 (260) */
/* 100 */	NdrFcLong( 0x3 ),	/* 3 */
/* 104 */	NdrFcShort( 0xfa ),	/* Offset= 250 (354) */
/* 106 */	NdrFcLong( 0x4 ),	/* 4 */
/* 110 */	NdrFcShort( 0x104 ),	/* Offset= 260 (370) */
/* 112 */	NdrFcLong( 0x6 ),	/* 6 */
/* 116 */	NdrFcShort( 0x138 ),	/* Offset= 312 (428) */
/* 118 */	NdrFcShort( 0xffffffff ),	/* Offset= -1 (117) */
/* 120 */	
			0x1d,		/* FC_SMFARRAY */
			0x1,		/* 1 */
/* 122 */	NdrFcShort( 0x202 ),	/* 514 */
/* 124 */	0x5,		/* FC_WCHAR */
			0x5b,		/* FC_END */
/* 126 */	
			0x15,		/* FC_STRUCT */
			0x3,		/* 3 */
/* 128 */	NdrFcShort( 0x248 ),	/* 584 */
/* 130 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 132 */	NdrFcShort( 0xfffffff4 ),	/* Offset= -12 (120) */
/* 134 */	0x3e,		/* FC_STRUCTPAD2 */
			0x4c,		/* FC_EMBEDDED_COMPLEX */
/* 136 */	0x0,		/* 0 */
			NdrFcShort( 0xffffffa1 ),	/* Offset= -95 (42) */
			0x4c,		/* FC_EMBEDDED_COMPLEX */
/* 140 */	0x0,		/* 0 */
			NdrFcShort( 0xffffff9d ),	/* Offset= -99 (42) */
			0x8,		/* FC_LONG */
/* 144 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 146 */	
			0x1b,		/* FC_CARRAY */
			0x3,		/* 3 */
/* 148 */	NdrFcShort( 0x248 ),	/* 584 */
/* 150 */	0x19,		/* Corr desc:  field pointer, FC_ULONG */
			0x0,		/*  */
/* 152 */	NdrFcShort( 0x0 ),	/* 0 */
/* 154 */	NdrFcShort( 0x1 ),	/* Corr flags:  early, */
/* 156 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 158 */	NdrFcShort( 0xffffffe0 ),	/* Offset= -32 (126) */
/* 160 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 162 */	
			0x1a,		/* FC_BOGUS_STRUCT */
			0x3,		/* 3 */
/* 164 */	NdrFcShort( 0x10 ),	/* 16 */
/* 166 */	NdrFcShort( 0x0 ),	/* 0 */
/* 168 */	NdrFcShort( 0x6 ),	/* Offset= 6 (174) */
/* 170 */	0x8,		/* FC_LONG */
			0x40,		/* FC_STRUCTPAD4 */
/* 172 */	0x36,		/* FC_POINTER */
			0x5b,		/* FC_END */
/* 174 */	
			0x12, 0x0,	/* FC_UP */
/* 176 */	NdrFcShort( 0xffffffe2 ),	/* Offset= -30 (146) */
/* 178 */	
			0x1b,		/* FC_CARRAY */
			0x3,		/* 3 */
/* 180 */	NdrFcShort( 0x10 ),	/* 16 */
/* 182 */	0x19,		/* Corr desc:  field pointer, FC_ULONG */
			0x0,		/*  */
/* 184 */	NdrFcShort( 0x0 ),	/* 0 */
/* 186 */	NdrFcShort( 0x1 ),	/* Corr flags:  early, */
/* 188 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 190 */	NdrFcShort( 0xffffff62 ),	/* Offset= -158 (32) */
/* 192 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 194 */	
			0x1b,		/* FC_CARRAY */
			0x3,		/* 3 */
/* 196 */	NdrFcShort( 0x20 ),	/* 32 */
/* 198 */	0x19,		/* Corr desc:  field pointer, FC_ULONG */
			0x0,		/*  */
/* 200 */	NdrFcShort( 0x0 ),	/* 0 */
/* 202 */	NdrFcShort( 0x1 ),	/* Corr flags:  early, */
/* 204 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 206 */	NdrFcShort( 0xffffff5c ),	/* Offset= -164 (42) */
/* 208 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 210 */	
			0x1a,		/* FC_BOGUS_STRUCT */
			0x3,		/* 3 */
/* 212 */	NdrFcShort( 0x30 ),	/* 48 */
/* 214 */	NdrFcShort( 0x0 ),	/* 0 */
/* 216 */	NdrFcShort( 0xc ),	/* Offset= 12 (228) */
/* 218 */	0x8,		/* FC_LONG */
			0x8,		/* FC_LONG */
/* 220 */	0x8,		/* FC_LONG */
			0x8,		/* FC_LONG */
/* 222 */	0x36,		/* FC_POINTER */
			0x36,		/* FC_POINTER */
/* 224 */	0x36,		/* FC_POINTER */
			0x36,		/* FC_POINTER */
/* 226 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 228 */	
			0x12, 0x0,	/* FC_UP */
/* 230 */	NdrFcShort( 0xffffff3a ),	/* Offset= -198 (32) */
/* 232 */	
			0x12, 0x0,	/* FC_UP */
/* 234 */	NdrFcShort( 0xffffffc8 ),	/* Offset= -56 (178) */
/* 236 */	
			0x12, 0x0,	/* FC_UP */
/* 238 */	NdrFcShort( 0xffffffd4 ),	/* Offset= -44 (194) */
/* 240 */	
			0x12, 0x0,	/* FC_UP */
/* 242 */	NdrFcShort( 0xffffffd0 ),	/* Offset= -48 (194) */
/* 244 */	
			0x1b,		/* FC_CARRAY */
			0x3,		/* 3 */
/* 246 */	NdrFcShort( 0x10 ),	/* 16 */
/* 248 */	0x19,		/* Corr desc:  field pointer, FC_ULONG */
			0x0,		/*  */
/* 250 */	NdrFcShort( 0x10 ),	/* 16 */
/* 252 */	NdrFcShort( 0x1 ),	/* Corr flags:  early, */
/* 254 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 256 */	NdrFcShort( 0xffffff20 ),	/* Offset= -224 (32) */
/* 258 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 260 */	
			0x1a,		/* FC_BOGUS_STRUCT */
			0x3,		/* 3 */
/* 262 */	NdrFcShort( 0x20 ),	/* 32 */
/* 264 */	NdrFcShort( 0x0 ),	/* 0 */
/* 266 */	NdrFcShort( 0xa ),	/* Offset= 10 (276) */
/* 268 */	0x8,		/* FC_LONG */
			0x40,		/* FC_STRUCTPAD4 */
/* 270 */	0x36,		/* FC_POINTER */
			0x8,		/* FC_LONG */
/* 272 */	0x40,		/* FC_STRUCTPAD4 */
			0x36,		/* FC_POINTER */
/* 274 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 276 */	
			0x12, 0x0,	/* FC_UP */
/* 278 */	NdrFcShort( 0xffffffac ),	/* Offset= -84 (194) */
/* 280 */	
			0x12, 0x0,	/* FC_UP */
/* 282 */	NdrFcShort( 0xffffffda ),	/* Offset= -38 (244) */
/* 284 */	
			0x15,		/* FC_STRUCT */
			0x0,		/* 0 */
/* 286 */	NdrFcShort( 0x8 ),	/* 8 */
/* 288 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 290 */	NdrFcShort( 0xfffffeec ),	/* Offset= -276 (14) */
/* 292 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 294 */	
			0x1d,		/* FC_SMFARRAY */
			0x0,		/* 0 */
/* 296 */	NdrFcShort( 0x10 ),	/* 16 */
/* 298 */	0x2,		/* FC_CHAR */
			0x5b,		/* FC_END */
/* 300 */	
			0x15,		/* FC_STRUCT */
			0x0,		/* 0 */
/* 302 */	NdrFcShort( 0x10 ),	/* 16 */
/* 304 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 306 */	NdrFcShort( 0xfffffff4 ),	/* Offset= -12 (294) */
/* 308 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 310 */	
			0x15,		/* FC_STRUCT */
			0x3,		/* 3 */
/* 312 */	NdrFcShort( 0x44 ),	/* 68 */
/* 314 */	0x8,		/* FC_LONG */
			0xe,		/* FC_ENUM32 */
/* 316 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 318 */	NdrFcShort( 0xfffffee2 ),	/* Offset= -286 (32) */
/* 320 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 322 */	NdrFcShort( 0xffffffda ),	/* Offset= -38 (284) */
/* 324 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 326 */	NdrFcShort( 0xffffffd6 ),	/* Offset= -42 (284) */
/* 328 */	0x8,		/* FC_LONG */
			0x4c,		/* FC_EMBEDDED_COMPLEX */
/* 330 */	0x0,		/* 0 */
			NdrFcShort( 0xfffffeb7 ),	/* Offset= -329 (2) */
			0x4c,		/* FC_EMBEDDED_COMPLEX */
/* 334 */	0x0,		/* 0 */
			NdrFcShort( 0xffffffdd ),	/* Offset= -35 (300) */
			0x5b,		/* FC_END */
/* 338 */	
			0x1b,		/* FC_CARRAY */
			0x3,		/* 3 */
/* 340 */	NdrFcShort( 0x44 ),	/* 68 */
/* 342 */	0x19,		/* Corr desc:  field pointer, FC_ULONG */
			0x0,		/*  */
/* 344 */	NdrFcShort( 0x0 ),	/* 0 */
/* 346 */	NdrFcShort( 0x1 ),	/* Corr flags:  early, */
/* 348 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 350 */	NdrFcShort( 0xffffffd8 ),	/* Offset= -40 (310) */
/* 352 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 354 */	
			0x1a,		/* FC_BOGUS_STRUCT */
			0x3,		/* 3 */
/* 356 */	NdrFcShort( 0x10 ),	/* 16 */
/* 358 */	NdrFcShort( 0x0 ),	/* 0 */
/* 360 */	NdrFcShort( 0x6 ),	/* Offset= 6 (366) */
/* 362 */	0x8,		/* FC_LONG */
			0x40,		/* FC_STRUCTPAD4 */
/* 364 */	0x36,		/* FC_POINTER */
			0x5b,		/* FC_END */
/* 366 */	
			0x12, 0x0,	/* FC_UP */
/* 368 */	NdrFcShort( 0xffffffe2 ),	/* Offset= -30 (338) */
/* 370 */	
			0x1a,		/* FC_BOGUS_STRUCT */
			0x3,		/* 3 */
/* 372 */	NdrFcShort( 0x20 ),	/* 32 */
/* 374 */	NdrFcShort( 0x0 ),	/* 0 */
/* 376 */	NdrFcShort( 0xa ),	/* Offset= 10 (386) */
/* 378 */	0x8,		/* FC_LONG */
			0x40,		/* FC_STRUCTPAD4 */
/* 380 */	0x36,		/* FC_POINTER */
			0x8,		/* FC_LONG */
/* 382 */	0x40,		/* FC_STRUCTPAD4 */
			0x36,		/* FC_POINTER */
/* 384 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 386 */	
			0x12, 0x0,	/* FC_UP */
/* 388 */	NdrFcShort( 0xffffff3e ),	/* Offset= -194 (194) */
/* 390 */	
			0x12, 0x0,	/* FC_UP */
/* 392 */	NdrFcShort( 0xffffff6c ),	/* Offset= -148 (244) */
/* 394 */	
			0x15,		/* FC_STRUCT */
			0x3,		/* 3 */
/* 396 */	NdrFcShort( 0x54 ),	/* 84 */
/* 398 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 400 */	NdrFcShort( 0xfffffe9a ),	/* Offset= -358 (42) */
/* 402 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 404 */	NdrFcShort( 0xfffffe96 ),	/* Offset= -362 (42) */
/* 406 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 408 */	NdrFcShort( 0xffffff94 ),	/* Offset= -108 (300) */
/* 410 */	0x8,		/* FC_LONG */
			0x5b,		/* FC_END */
/* 412 */	
			0x1b,		/* FC_CARRAY */
			0x3,		/* 3 */
/* 414 */	NdrFcShort( 0x54 ),	/* 84 */
/* 416 */	0x19,		/* Corr desc:  field pointer, FC_ULONG */
			0x0,		/*  */
/* 418 */	NdrFcShort( 0x0 ),	/* 0 */
/* 420 */	NdrFcShort( 0x1 ),	/* Corr flags:  early, */
/* 422 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 424 */	NdrFcShort( 0xffffffe2 ),	/* Offset= -30 (394) */
/* 426 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 428 */	
			0x1a,		/* FC_BOGUS_STRUCT */
			0x3,		/* 3 */
/* 430 */	NdrFcShort( 0x10 ),	/* 16 */
/* 432 */	NdrFcShort( 0x0 ),	/* 0 */
/* 434 */	NdrFcShort( 0x6 ),	/* Offset= 6 (440) */
/* 436 */	0x8,		/* FC_LONG */
			0x40,		/* FC_STRUCTPAD4 */
/* 438 */	0x36,		/* FC_POINTER */
			0x5b,		/* FC_END */
/* 440 */	
			0x12, 0x0,	/* FC_UP */
/* 442 */	NdrFcShort( 0xffffffe2 ),	/* Offset= -30 (412) */
/* 444 */	
			0x1a,		/* FC_BOGUS_STRUCT */
			0x3,		/* 3 */
/* 446 */	NdrFcShort( 0x40 ),	/* 64 */
/* 448 */	NdrFcShort( 0x0 ),	/* 0 */
/* 450 */	NdrFcShort( 0xa ),	/* Offset= 10 (460) */
/* 452 */	0xe,		/* FC_ENUM32 */
			0x40,		/* FC_STRUCTPAD4 */
/* 454 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 456 */	NdrFcShort( 0xfffffe7c ),	/* Offset= -388 (68) */
/* 458 */	0x36,		/* FC_POINTER */
			0x5b,		/* FC_END */
/* 460 */	
			0x12, 0x8,	/* FC_UP [simple_pointer] */
/* 462 */	
			0x25,		/* FC_C_WSTRING */
			0x5c,		/* FC_PAD */
/* 464 */	
			0x15,		/* FC_STRUCT */
			0x3,		/* 3 */
/* 466 */	NdrFcShort( 0x14 ),	/* 20 */
/* 468 */	0x8,		/* FC_LONG */
			0x4c,		/* FC_EMBEDDED_COMPLEX */
/* 470 */	0x0,		/* 0 */
			NdrFcShort( 0xfffffe49 ),	/* Offset= -439 (32) */
			0x5b,		/* FC_END */
/* 474 */	0xb5,		/* FC_PIPE */
			0x3,		/* 3 */
/* 476 */	NdrFcShort( 0xfffffff4 ),	/* Offset= -12 (464) */
/* 478 */	NdrFcShort( 0x14 ),	/* 20 */
/* 480 */	NdrFcShort( 0x14 ),	/* 20 */
/* 482 */	0xb5,		/* FC_PIPE */
			0x3,		/* 3 */
/* 484 */	NdrFcShort( 0xffffffa6 ),	/* Offset= -90 (394) */
/* 486 */	NdrFcShort( 0x54 ),	/* 84 */
/* 488 */	NdrFcShort( 0x54 ),	/* 84 */
/* 490 */	
			0x11, 0x0,	/* FC_RP */
/* 492 */	NdrFcShort( 0x2 ),	/* Offset= 2 (494) */
/* 494 */	
			0x1b,		/* FC_CARRAY */
			0x3,		/* 3 */
/* 496 */	NdrFcShort( 0x10 ),	/* 16 */
/* 498 */	0x29,		/* Corr desc:  parameter, FC_ULONG */
			0x0,		/*  */
/* 500 */	NdrFcShort( 0x8 ),	/* ia64 Stack size/offset = 8 */
/* 502 */	NdrFcShort( 0x1 ),	/* Corr flags:  early, */
/* 504 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 506 */	NdrFcShort( 0xfffffe26 ),	/* Offset= -474 (32) */
/* 508 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 510 */	
			0x11, 0x0,	/* FC_RP */
/* 512 */	NdrFcShort( 0xffffff2c ),	/* Offset= -212 (300) */
/* 514 */	
			0x11, 0x4,	/* FC_RP [alloced_on_stack] */
/* 516 */	NdrFcShort( 0xffffff28 ),	/* Offset= -216 (300) */
/* 518 */	
			0x11, 0x8,	/* FC_RP [simple_pointer] */
/* 520 */	0x8,		/* FC_LONG */
			0x5c,		/* FC_PAD */
/* 522 */	
			0x11, 0x0,	/* FC_RP */
/* 524 */	NdrFcShort( 0x2 ),	/* Offset= 2 (526) */
/* 526 */	
			0x25,		/* FC_C_WSTRING */
			0x44,		/* FC_STRING_SIZED */
/* 528 */	0x29,		/* Corr desc:  parameter, FC_ULONG */
			0x54,		/* FC_DEREFERENCE */
/* 530 */	NdrFcShort( 0x48 ),	/* ia64 Stack size/offset = 72 */
/* 532 */	NdrFcShort( 0x1 ),	/* Corr flags:  early, */
/* 534 */	
			0x11, 0x0,	/* FC_RP */
/* 536 */	NdrFcShort( 0x2 ),	/* Offset= 2 (538) */
/* 538 */	
			0x25,		/* FC_C_WSTRING */
			0x44,		/* FC_STRING_SIZED */
/* 540 */	0x40,		/* Corr desc:  constant, val=262 */
			0x0,		/* 0 */
/* 542 */	NdrFcShort( 0x106 ),	/* 262 */
/* 544 */	NdrFcShort( 0x0 ),	/* Corr flags:  */
/* 546 */	
			0x11, 0x0,	/* FC_RP */
/* 548 */	NdrFcShort( 0x92 ),	/* Offset= 146 (694) */
/* 550 */	
			0x2b,		/* FC_NON_ENCAPSULATED_UNION */
			0x8,		/* FC_LONG */
/* 552 */	0x8,		/* Corr desc: FC_LONG */
			0x0,		/*  */
/* 554 */	NdrFcShort( 0xfff8 ),	/* -8 */
/* 556 */	NdrFcShort( 0x1 ),	/* Corr flags:  early, */
/* 558 */	NdrFcShort( 0x2 ),	/* Offset= 2 (560) */
/* 560 */	NdrFcShort( 0xc8 ),	/* 200 */
/* 562 */	NdrFcShort( 0x9 ),	/* 9 */
/* 564 */	NdrFcLong( 0x0 ),	/* 0 */
/* 568 */	NdrFcShort( 0xfffffe6a ),	/* Offset= -406 (162) */
/* 570 */	NdrFcLong( 0x1 ),	/* 1 */
/* 574 */	NdrFcShort( 0xfffffe94 ),	/* Offset= -364 (210) */
/* 576 */	NdrFcLong( 0x2 ),	/* 2 */
/* 580 */	NdrFcShort( 0xfffffec0 ),	/* Offset= -320 (260) */
/* 582 */	NdrFcLong( 0x3 ),	/* 3 */
/* 586 */	NdrFcShort( 0xffffff18 ),	/* Offset= -232 (354) */
/* 588 */	NdrFcLong( 0x4 ),	/* 4 */
/* 592 */	NdrFcShort( 0xffffff22 ),	/* Offset= -222 (370) */
/* 594 */	NdrFcLong( 0x5 ),	/* 5 */
/* 598 */	NdrFcShort( 0x1e ),	/* Offset= 30 (628) */
/* 600 */	NdrFcLong( 0x6 ),	/* 6 */
/* 604 */	NdrFcShort( 0xffffff50 ),	/* Offset= -176 (428) */
/* 606 */	NdrFcLong( 0x7 ),	/* 7 */
/* 610 */	NdrFcShort( 0xfffffda0 ),	/* Offset= -608 (2) */
/* 612 */	NdrFcLong( 0x8 ),	/* 8 */
/* 616 */	NdrFcShort( 0x8008 ),	/* Simple arm type: FC_LONG */
/* 618 */	NdrFcShort( 0xffffffff ),	/* Offset= -1 (617) */
/* 620 */	
			0x15,		/* FC_STRUCT */
			0x3,		/* 3 */
/* 622 */	NdrFcShort( 0xc ),	/* 12 */
/* 624 */	0x8,		/* FC_LONG */
			0x8,		/* FC_LONG */
/* 626 */	0x8,		/* FC_LONG */
			0x5b,		/* FC_END */
/* 628 */	
			0x15,		/* FC_STRUCT */
			0x3,		/* 3 */
/* 630 */	NdrFcShort( 0xc8 ),	/* 200 */
/* 632 */	0x8,		/* FC_LONG */
			0x8,		/* FC_LONG */
/* 634 */	0x8,		/* FC_LONG */
			0x8,		/* FC_LONG */
/* 636 */	0x8,		/* FC_LONG */
			0x8,		/* FC_LONG */
/* 638 */	0x8,		/* FC_LONG */
			0x8,		/* FC_LONG */
/* 640 */	0x8,		/* FC_LONG */
			0x8,		/* FC_LONG */
/* 642 */	0x8,		/* FC_LONG */
			0x8,		/* FC_LONG */
/* 644 */	0x8,		/* FC_LONG */
			0x8,		/* FC_LONG */
/* 646 */	0x8,		/* FC_LONG */
			0x8,		/* FC_LONG */
/* 648 */	0x8,		/* FC_LONG */
			0x8,		/* FC_LONG */
/* 650 */	0x8,		/* FC_LONG */
			0x8,		/* FC_LONG */
/* 652 */	0x8,		/* FC_LONG */
			0x8,		/* FC_LONG */
/* 654 */	0x8,		/* FC_LONG */
			0x8,		/* FC_LONG */
/* 656 */	0x8,		/* FC_LONG */
			0x8,		/* FC_LONG */
/* 658 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 660 */	NdrFcShort( 0xfffffd6e ),	/* Offset= -658 (2) */
/* 662 */	0x8,		/* FC_LONG */
			0x8,		/* FC_LONG */
/* 664 */	0x8,		/* FC_LONG */
			0x8,		/* FC_LONG */
/* 666 */	0x8,		/* FC_LONG */
			0x4c,		/* FC_EMBEDDED_COMPLEX */
/* 668 */	0x0,		/* 0 */
			NdrFcShort( 0xfffffd65 ),	/* Offset= -667 (2) */
			0x8,		/* FC_LONG */
/* 672 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 674 */	NdrFcShort( 0xfffffd60 ),	/* Offset= -672 (2) */
/* 676 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 678 */	NdrFcShort( 0xfffffd5c ),	/* Offset= -676 (2) */
/* 680 */	0x8,		/* FC_LONG */
			0x8,		/* FC_LONG */
/* 682 */	0x8,		/* FC_LONG */
			0x8,		/* FC_LONG */
/* 684 */	0x8,		/* FC_LONG */
			0x6,		/* FC_SHORT */
/* 686 */	0x6,		/* FC_SHORT */
			0x6,		/* FC_SHORT */
/* 688 */	0x6,		/* FC_SHORT */
			0x4c,		/* FC_EMBEDDED_COMPLEX */
/* 690 */	0x0,		/* 0 */
			NdrFcShort( 0xffffffb9 ),	/* Offset= -71 (620) */
			0x5b,		/* FC_END */
/* 694 */	
			0x1a,		/* FC_BOGUS_STRUCT */
			0x3,		/* 3 */
/* 696 */	NdrFcShort( 0xd8 ),	/* 216 */
/* 698 */	NdrFcShort( 0x0 ),	/* 0 */
/* 700 */	NdrFcShort( 0xa ),	/* Offset= 10 (710) */
/* 702 */	0xe,		/* FC_ENUM32 */
			0xe,		/* FC_ENUM32 */
/* 704 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 706 */	NdrFcShort( 0xffffff64 ),	/* Offset= -156 (550) */
/* 708 */	0x36,		/* FC_POINTER */
			0x5b,		/* FC_END */
/* 710 */	
			0x12, 0x8,	/* FC_UP [simple_pointer] */
/* 712 */	
			0x25,		/* FC_C_WSTRING */
			0x5c,		/* FC_PAD */
/* 714 */	
			0x11, 0x0,	/* FC_RP */
/* 716 */	NdrFcShort( 0x2 ),	/* Offset= 2 (718) */
/* 718 */	
			0x25,		/* FC_C_WSTRING */
			0x44,		/* FC_STRING_SIZED */
/* 720 */	0x40,		/* Corr desc:  constant, val=262 */
			0x0,		/* 0 */
/* 722 */	NdrFcShort( 0x106 ),	/* 262 */
/* 724 */	NdrFcShort( 0x0 ),	/* Corr flags:  */

			0x0
        }
    };

static const unsigned short trkwks_FormatStringOffsetTable[] =
    {
    0,
    72,
    132,
    174,
    222,
    258,
    312,
    366,
    414,
    450,
    540,
    606,
    648
    };


static const MIDL_STUB_DESC trkwks_StubDesc = 
    {
    (void *)& trkwks___RpcClientInterface,
    MIDL_user_allocate,
    MIDL_user_free,
    &trkwks__MIDL_AutoBindHandle,
    0,
    0,
    0,
    0,
    __MIDL_TypeFormatString.Format,
    1, /* -error bounds_check flag */
    0x50002, /* Ndr library version */
    0,
    0x600015b, /* MIDL Version 6.0.347 */
    0,
    0,
    0,  /* notify & notify_flag routine table */
    0x1, /* MIDL flag */
    0, /* cs routines */
    0,   /* proxy/server info */
    0   /* Reserved5 */
    };


#endif /* defined(_M_IA64) || defined(_M_AMD64)*/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\public\internal\drivers\inc\agp.h ===
//
// Copyright (c) Microsoft Corporation. All rights reserved.
//


#ifndef __AGP_INCLUDED__
#define __AGP_INCLUDED__

DEFINE_GUID(GUID_AGP_INTERFACE, 0xd6c9df40, 0xa1a2, 0x11d1, 0x81, 0x15, 0x0, 0x20, 0xaf, 0xf7, 0x49, 0x1e);

#ifndef GUID_DEFS_ONLY

//
// Temporary Hack...
//

#ifndef IsEqualGUID
#ifdef __cplusplus
    inline int IsEqualGUID(REFGUID guid1, REFGUID guid2)
        {
            return !memcmp(&guid1, &guid2, sizeof(GUID));
        }
#else // !__cplusplus
    #define IsEqualGUID(guid1, guid2) \
        (!memcmp((guid1), (guid2), sizeof(GUID)))
#endif // !__cplusplus
#endif

#define AGP_INTERFACE_VERSION 1

typedef struct _AGP_INTERFACE
{
    USHORT           Size;
    USHORT           Version;
    PVOID            Context;
    PVOID            InterfaceReference;
    PVOID            InterfaceDereference;

    VIDEO_PORT_AGP_SERVICES AgpServices;

} AGP_INTERFACE, *PAGP_INTERFACE;

#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\public\internal\com\inc\unisrgt.h ===
#pragma warning( disable: 4049 )  /* more than 64k source lines */

/* this ALWAYS GENERATED file contains the definitions for the interfaces */


 /* File created by MIDL compiler version 6.00.0347 */
/* Compiler settings for unisrgt.idl:
    Oicf, W1, Zp8, env=Win32 (32b run)
    protocol : dce , ms_ext, c_ext, oldnames, robust
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )


/* verify that the <rpcndr.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCNDR_H_VERSION__
#define __REQUIRED_RPCNDR_H_VERSION__ 475
#endif

#include "rpc.h"
#include "rpcndr.h"

#ifndef __RPCNDR_H_VERSION__
#error this stub requires an updated version of <rpcndr.h>
#endif // __RPCNDR_H_VERSION__

#ifndef COM_NO_WINDOWS_H
#include "windows.h"
#include "ole2.h"
#endif /*COM_NO_WINDOWS_H*/

#ifndef __unisrgt_h__
#define __unisrgt_h__

#if defined(_MSC_VER) && (_MSC_VER >= 1020)
#pragma once
#endif

/* Forward Declarations */ 

#ifndef __IProcessLock_FWD_DEFINED__
#define __IProcessLock_FWD_DEFINED__
typedef interface IProcessLock IProcessLock;
#endif 	/* __IProcessLock_FWD_DEFINED__ */


#ifndef __ISurrogateService_FWD_DEFINED__
#define __ISurrogateService_FWD_DEFINED__
typedef interface ISurrogateService ISurrogateService;
#endif 	/* __ISurrogateService_FWD_DEFINED__ */


#ifndef __ISurrogateService2_FWD_DEFINED__
#define __ISurrogateService2_FWD_DEFINED__
typedef interface ISurrogateService2 ISurrogateService2;
#endif 	/* __ISurrogateService2_FWD_DEFINED__ */


#ifndef __IPAControl_FWD_DEFINED__
#define __IPAControl_FWD_DEFINED__
typedef interface IPAControl IPAControl;
#endif 	/* __IPAControl_FWD_DEFINED__ */


#ifndef __IServicesSink_FWD_DEFINED__
#define __IServicesSink_FWD_DEFINED__
typedef interface IServicesSink IServicesSink;
#endif 	/* __IServicesSink_FWD_DEFINED__ */


/* header files for imported files */
#include "wtypes.h"
#include "objidl.h"

#ifdef __cplusplus
extern "C"{
#endif 

void * __RPC_USER MIDL_user_allocate(size_t);
void __RPC_USER MIDL_user_free( void * ); 

/* interface __MIDL_itf_unisrgt_0000 */
/* [local] */ 

//+-----------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1998.
//
//------------------------------------------------------------------
typedef 
enum tagApplicationType
    {	ServerApplication	= 0,
	LibraryApplication	= ServerApplication + 1
    } 	ApplicationType;

typedef 
enum tagShutdownType
    {	IdleShutdown	= 0,
	ForcedShutdown	= IdleShutdown + 1
    } 	ShutdownType;



extern RPC_IF_HANDLE __MIDL_itf_unisrgt_0000_ClientIfHandle;
extern RPC_IF_HANDLE __MIDL_itf_unisrgt_0000_ServerIfHandle;

#ifndef __IProcessLock_INTERFACE_DEFINED__
#define __IProcessLock_INTERFACE_DEFINED__

/* interface IProcessLock */
/* [unique][uuid][local][object] */ 


EXTERN_C const IID IID_IProcessLock;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("000001d5-0000-0000-C000-000000000046")
    IProcessLock : public IUnknown
    {
    public:
        virtual ULONG STDMETHODCALLTYPE AddRefOnProcess( void) = 0;
        
        virtual ULONG STDMETHODCALLTYPE ReleaseRefOnProcess( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IProcessLockVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IProcessLock * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IProcessLock * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IProcessLock * This);
        
        ULONG ( STDMETHODCALLTYPE *AddRefOnProcess )( 
            IProcessLock * This);
        
        ULONG ( STDMETHODCALLTYPE *ReleaseRefOnProcess )( 
            IProcessLock * This);
        
        END_INTERFACE
    } IProcessLockVtbl;

    interface IProcessLock
    {
        CONST_VTBL struct IProcessLockVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IProcessLock_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IProcessLock_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IProcessLock_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IProcessLock_AddRefOnProcess(This)	\
    (This)->lpVtbl -> AddRefOnProcess(This)

#define IProcessLock_ReleaseRefOnProcess(This)	\
    (This)->lpVtbl -> ReleaseRefOnProcess(This)

#endif /* COBJMACROS */


#endif 	/* C style interface */



ULONG STDMETHODCALLTYPE IProcessLock_AddRefOnProcess_Proxy( 
    IProcessLock * This);


void __RPC_STUB IProcessLock_AddRefOnProcess_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


ULONG STDMETHODCALLTYPE IProcessLock_ReleaseRefOnProcess_Proxy( 
    IProcessLock * This);


void __RPC_STUB IProcessLock_ReleaseRefOnProcess_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IProcessLock_INTERFACE_DEFINED__ */


#ifndef __ISurrogateService_INTERFACE_DEFINED__
#define __ISurrogateService_INTERFACE_DEFINED__

/* interface ISurrogateService */
/* [unique][uuid][local][object] */ 


EXTERN_C const IID IID_ISurrogateService;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("000001d4-0000-0000-C000-000000000046")
    ISurrogateService : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Init( 
            /* [in] */ REFGUID rguidProcessID,
            /* [in] */ IProcessLock *pProcessLock,
            /* [out] */ BOOL *pfApplicationAware) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ApplicationLaunch( 
            /* [in] */ REFGUID rguidApplID,
            /* [in] */ ApplicationType appType) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ApplicationFree( 
            /* [in] */ REFGUID rguidApplID) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CatalogRefresh( 
            /* [in] */ ULONG ulReserved) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ProcessShutdown( 
            /* [in] */ ShutdownType shutdownType) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ISurrogateServiceVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ISurrogateService * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ISurrogateService * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ISurrogateService * This);
        
        HRESULT ( STDMETHODCALLTYPE *Init )( 
            ISurrogateService * This,
            /* [in] */ REFGUID rguidProcessID,
            /* [in] */ IProcessLock *pProcessLock,
            /* [out] */ BOOL *pfApplicationAware);
        
        HRESULT ( STDMETHODCALLTYPE *ApplicationLaunch )( 
            ISurrogateService * This,
            /* [in] */ REFGUID rguidApplID,
            /* [in] */ ApplicationType appType);
        
        HRESULT ( STDMETHODCALLTYPE *ApplicationFree )( 
            ISurrogateService * This,
            /* [in] */ REFGUID rguidApplID);
        
        HRESULT ( STDMETHODCALLTYPE *CatalogRefresh )( 
            ISurrogateService * This,
            /* [in] */ ULONG ulReserved);
        
        HRESULT ( STDMETHODCALLTYPE *ProcessShutdown )( 
            ISurrogateService * This,
            /* [in] */ ShutdownType shutdownType);
        
        END_INTERFACE
    } ISurrogateServiceVtbl;

    interface ISurrogateService
    {
        CONST_VTBL struct ISurrogateServiceVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ISurrogateService_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ISurrogateService_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ISurrogateService_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ISurrogateService_Init(This,rguidProcessID,pProcessLock,pfApplicationAware)	\
    (This)->lpVtbl -> Init(This,rguidProcessID,pProcessLock,pfApplicationAware)

#define ISurrogateService_ApplicationLaunch(This,rguidApplID,appType)	\
    (This)->lpVtbl -> ApplicationLaunch(This,rguidApplID,appType)

#define ISurrogateService_ApplicationFree(This,rguidApplID)	\
    (This)->lpVtbl -> ApplicationFree(This,rguidApplID)

#define ISurrogateService_CatalogRefresh(This,ulReserved)	\
    (This)->lpVtbl -> CatalogRefresh(This,ulReserved)

#define ISurrogateService_ProcessShutdown(This,shutdownType)	\
    (This)->lpVtbl -> ProcessShutdown(This,shutdownType)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE ISurrogateService_Init_Proxy( 
    ISurrogateService * This,
    /* [in] */ REFGUID rguidProcessID,
    /* [in] */ IProcessLock *pProcessLock,
    /* [out] */ BOOL *pfApplicationAware);


void __RPC_STUB ISurrogateService_Init_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ISurrogateService_ApplicationLaunch_Proxy( 
    ISurrogateService * This,
    /* [in] */ REFGUID rguidApplID,
    /* [in] */ ApplicationType appType);


void __RPC_STUB ISurrogateService_ApplicationLaunch_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ISurrogateService_ApplicationFree_Proxy( 
    ISurrogateService * This,
    /* [in] */ REFGUID rguidApplID);


void __RPC_STUB ISurrogateService_ApplicationFree_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ISurrogateService_CatalogRefresh_Proxy( 
    ISurrogateService * This,
    /* [in] */ ULONG ulReserved);


void __RPC_STUB ISurrogateService_CatalogRefresh_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ISurrogateService_ProcessShutdown_Proxy( 
    ISurrogateService * This,
    /* [in] */ ShutdownType shutdownType);


void __RPC_STUB ISurrogateService_ProcessShutdown_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ISurrogateService_INTERFACE_DEFINED__ */


#ifndef __ISurrogateService2_INTERFACE_DEFINED__
#define __ISurrogateService2_INTERFACE_DEFINED__

/* interface ISurrogateService2 */
/* [unique][uuid][local][object] */ 


EXTERN_C const IID IID_ISurrogateService2;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("000001da-0000-0000-C000-000000000046")
    ISurrogateService2 : public ISurrogateService
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE PauseProcess( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ResumeProcess( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ISurrogateService2Vtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ISurrogateService2 * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ISurrogateService2 * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ISurrogateService2 * This);
        
        HRESULT ( STDMETHODCALLTYPE *Init )( 
            ISurrogateService2 * This,
            /* [in] */ REFGUID rguidProcessID,
            /* [in] */ IProcessLock *pProcessLock,
            /* [out] */ BOOL *pfApplicationAware);
        
        HRESULT ( STDMETHODCALLTYPE *ApplicationLaunch )( 
            ISurrogateService2 * This,
            /* [in] */ REFGUID rguidApplID,
            /* [in] */ ApplicationType appType);
        
        HRESULT ( STDMETHODCALLTYPE *ApplicationFree )( 
            ISurrogateService2 * This,
            /* [in] */ REFGUID rguidApplID);
        
        HRESULT ( STDMETHODCALLTYPE *CatalogRefresh )( 
            ISurrogateService2 * This,
            /* [in] */ ULONG ulReserved);
        
        HRESULT ( STDMETHODCALLTYPE *ProcessShutdown )( 
            ISurrogateService2 * This,
            /* [in] */ ShutdownType shutdownType);
        
        HRESULT ( STDMETHODCALLTYPE *PauseProcess )( 
            ISurrogateService2 * This);
        
        HRESULT ( STDMETHODCALLTYPE *ResumeProcess )( 
            ISurrogateService2 * This);
        
        END_INTERFACE
    } ISurrogateService2Vtbl;

    interface ISurrogateService2
    {
        CONST_VTBL struct ISurrogateService2Vtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ISurrogateService2_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ISurrogateService2_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ISurrogateService2_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ISurrogateService2_Init(This,rguidProcessID,pProcessLock,pfApplicationAware)	\
    (This)->lpVtbl -> Init(This,rguidProcessID,pProcessLock,pfApplicationAware)

#define ISurrogateService2_ApplicationLaunch(This,rguidApplID,appType)	\
    (This)->lpVtbl -> ApplicationLaunch(This,rguidApplID,appType)

#define ISurrogateService2_ApplicationFree(This,rguidApplID)	\
    (This)->lpVtbl -> ApplicationFree(This,rguidApplID)

#define ISurrogateService2_CatalogRefresh(This,ulReserved)	\
    (This)->lpVtbl -> CatalogRefresh(This,ulReserved)

#define ISurrogateService2_ProcessShutdown(This,shutdownType)	\
    (This)->lpVtbl -> ProcessShutdown(This,shutdownType)


#define ISurrogateService2_PauseProcess(This)	\
    (This)->lpVtbl -> PauseProcess(This)

#define ISurrogateService2_ResumeProcess(This)	\
    (This)->lpVtbl -> ResumeProcess(This)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE ISurrogateService2_PauseProcess_Proxy( 
    ISurrogateService2 * This);


void __RPC_STUB ISurrogateService2_PauseProcess_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ISurrogateService2_ResumeProcess_Proxy( 
    ISurrogateService2 * This);


void __RPC_STUB ISurrogateService2_ResumeProcess_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ISurrogateService2_INTERFACE_DEFINED__ */


#ifndef __IPAControl_INTERFACE_DEFINED__
#define __IPAControl_INTERFACE_DEFINED__

/* interface IPAControl */
/* [unique][uuid][local][object] */ 


EXTERN_C const IID IID_IPAControl;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("000001d2-0000-0000-C000-000000000046")
    IPAControl : public IUnknown
    {
    public:
        virtual ULONG STDMETHODCALLTYPE AddRefOnProcess( void) = 0;
        
        virtual ULONG STDMETHODCALLTYPE ReleaseRefOnProcess( void) = 0;
        
        virtual void STDMETHODCALLTYPE PendingInit( void) = 0;
        
        virtual void STDMETHODCALLTYPE ServicesReady( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SuspendApplication( 
            /* [in] */ REFGUID rguidApplID) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE PendingApplication( 
            /* [in] */ REFGUID rguidApplID) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ResumeApplication( 
            /* [in] */ REFGUID rguidApplID) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SuspendAll( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ResumeAll( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ForcedShutdown( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetIdleTimeoutToZero( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IPAControlVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IPAControl * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IPAControl * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IPAControl * This);
        
        ULONG ( STDMETHODCALLTYPE *AddRefOnProcess )( 
            IPAControl * This);
        
        ULONG ( STDMETHODCALLTYPE *ReleaseRefOnProcess )( 
            IPAControl * This);
        
        void ( STDMETHODCALLTYPE *PendingInit )( 
            IPAControl * This);
        
        void ( STDMETHODCALLTYPE *ServicesReady )( 
            IPAControl * This);
        
        HRESULT ( STDMETHODCALLTYPE *SuspendApplication )( 
            IPAControl * This,
            /* [in] */ REFGUID rguidApplID);
        
        HRESULT ( STDMETHODCALLTYPE *PendingApplication )( 
            IPAControl * This,
            /* [in] */ REFGUID rguidApplID);
        
        HRESULT ( STDMETHODCALLTYPE *ResumeApplication )( 
            IPAControl * This,
            /* [in] */ REFGUID rguidApplID);
        
        HRESULT ( STDMETHODCALLTYPE *SuspendAll )( 
            IPAControl * This);
        
        HRESULT ( STDMETHODCALLTYPE *ResumeAll )( 
            IPAControl * This);
        
        HRESULT ( STDMETHODCALLTYPE *ForcedShutdown )( 
            IPAControl * This);
        
        HRESULT ( STDMETHODCALLTYPE *SetIdleTimeoutToZero )( 
            IPAControl * This);
        
        END_INTERFACE
    } IPAControlVtbl;

    interface IPAControl
    {
        CONST_VTBL struct IPAControlVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IPAControl_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IPAControl_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IPAControl_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IPAControl_AddRefOnProcess(This)	\
    (This)->lpVtbl -> AddRefOnProcess(This)

#define IPAControl_ReleaseRefOnProcess(This)	\
    (This)->lpVtbl -> ReleaseRefOnProcess(This)

#define IPAControl_PendingInit(This)	\
    (This)->lpVtbl -> PendingInit(This)

#define IPAControl_ServicesReady(This)	\
    (This)->lpVtbl -> ServicesReady(This)

#define IPAControl_SuspendApplication(This,rguidApplID)	\
    (This)->lpVtbl -> SuspendApplication(This,rguidApplID)

#define IPAControl_PendingApplication(This,rguidApplID)	\
    (This)->lpVtbl -> PendingApplication(This,rguidApplID)

#define IPAControl_ResumeApplication(This,rguidApplID)	\
    (This)->lpVtbl -> ResumeApplication(This,rguidApplID)

#define IPAControl_SuspendAll(This)	\
    (This)->lpVtbl -> SuspendAll(This)

#define IPAControl_ResumeAll(This)	\
    (This)->lpVtbl -> ResumeAll(This)

#define IPAControl_ForcedShutdown(This)	\
    (This)->lpVtbl -> ForcedShutdown(This)

#define IPAControl_SetIdleTimeoutToZero(This)	\
    (This)->lpVtbl -> SetIdleTimeoutToZero(This)

#endif /* COBJMACROS */


#endif 	/* C style interface */



ULONG STDMETHODCALLTYPE IPAControl_AddRefOnProcess_Proxy( 
    IPAControl * This);


void __RPC_STUB IPAControl_AddRefOnProcess_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


ULONG STDMETHODCALLTYPE IPAControl_ReleaseRefOnProcess_Proxy( 
    IPAControl * This);


void __RPC_STUB IPAControl_ReleaseRefOnProcess_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


void STDMETHODCALLTYPE IPAControl_PendingInit_Proxy( 
    IPAControl * This);


void __RPC_STUB IPAControl_PendingInit_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


void STDMETHODCALLTYPE IPAControl_ServicesReady_Proxy( 
    IPAControl * This);


void __RPC_STUB IPAControl_ServicesReady_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IPAControl_SuspendApplication_Proxy( 
    IPAControl * This,
    /* [in] */ REFGUID rguidApplID);


void __RPC_STUB IPAControl_SuspendApplication_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IPAControl_PendingApplication_Proxy( 
    IPAControl * This,
    /* [in] */ REFGUID rguidApplID);


void __RPC_STUB IPAControl_PendingApplication_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IPAControl_ResumeApplication_Proxy( 
    IPAControl * This,
    /* [in] */ REFGUID rguidApplID);


void __RPC_STUB IPAControl_ResumeApplication_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IPAControl_SuspendAll_Proxy( 
    IPAControl * This);


void __RPC_STUB IPAControl_SuspendAll_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IPAControl_ResumeAll_Proxy( 
    IPAControl * This);


void __RPC_STUB IPAControl_ResumeAll_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IPAControl_ForcedShutdown_Proxy( 
    IPAControl * This);


void __RPC_STUB IPAControl_ForcedShutdown_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IPAControl_SetIdleTimeoutToZero_Proxy( 
    IPAControl * This);


void __RPC_STUB IPAControl_SetIdleTimeoutToZero_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IPAControl_INTERFACE_DEFINED__ */


#ifndef __IServicesSink_INTERFACE_DEFINED__
#define __IServicesSink_INTERFACE_DEFINED__

/* interface IServicesSink */
/* [unique][uuid][local][object] */ 


EXTERN_C const IID IID_IServicesSink;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("000001d3-0000-0000-C000-000000000046")
    IServicesSink : public IUnknown
    {
    public:
        virtual void STDMETHODCALLTYPE ApplicationLaunch( 
            /* [in] */ REFGUID rguidApplID,
            /* [in] */ ApplicationType appType) = 0;
        
        virtual void STDMETHODCALLTYPE ApplicationFree( 
            /* [in] */ REFGUID rguidApplID) = 0;
        
        virtual void STDMETHODCALLTYPE ProcessFree( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE PauseApplication( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ResumeApplication( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IServicesSinkVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IServicesSink * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IServicesSink * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IServicesSink * This);
        
        void ( STDMETHODCALLTYPE *ApplicationLaunch )( 
            IServicesSink * This,
            /* [in] */ REFGUID rguidApplID,
            /* [in] */ ApplicationType appType);
        
        void ( STDMETHODCALLTYPE *ApplicationFree )( 
            IServicesSink * This,
            /* [in] */ REFGUID rguidApplID);
        
        void ( STDMETHODCALLTYPE *ProcessFree )( 
            IServicesSink * This);
        
        HRESULT ( STDMETHODCALLTYPE *PauseApplication )( 
            IServicesSink * This);
        
        HRESULT ( STDMETHODCALLTYPE *ResumeApplication )( 
            IServicesSink * This);
        
        END_INTERFACE
    } IServicesSinkVtbl;

    interface IServicesSink
    {
        CONST_VTBL struct IServicesSinkVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IServicesSink_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IServicesSink_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IServicesSink_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IServicesSink_ApplicationLaunch(This,rguidApplID,appType)	\
    (This)->lpVtbl -> ApplicationLaunch(This,rguidApplID,appType)

#define IServicesSink_ApplicationFree(This,rguidApplID)	\
    (This)->lpVtbl -> ApplicationFree(This,rguidApplID)

#define IServicesSink_ProcessFree(This)	\
    (This)->lpVtbl -> ProcessFree(This)

#define IServicesSink_PauseApplication(This)	\
    (This)->lpVtbl -> PauseApplication(This)

#define IServicesSink_ResumeApplication(This)	\
    (This)->lpVtbl -> ResumeApplication(This)

#endif /* COBJMACROS */


#endif 	/* C style interface */



void STDMETHODCALLTYPE IServicesSink_ApplicationLaunch_Proxy( 
    IServicesSink * This,
    /* [in] */ REFGUID rguidApplID,
    /* [in] */ ApplicationType appType);


void __RPC_STUB IServicesSink_ApplicationLaunch_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


void STDMETHODCALLTYPE IServicesSink_ApplicationFree_Proxy( 
    IServicesSink * This,
    /* [in] */ REFGUID rguidApplID);


void __RPC_STUB IServicesSink_ApplicationFree_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


void STDMETHODCALLTYPE IServicesSink_ProcessFree_Proxy( 
    IServicesSink * This);


void __RPC_STUB IServicesSink_ProcessFree_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IServicesSink_PauseApplication_Proxy( 
    IServicesSink * This);


void __RPC_STUB IServicesSink_PauseApplication_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IServicesSink_ResumeApplication_Proxy( 
    IServicesSink * This);


void __RPC_STUB IServicesSink_ResumeApplication_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IServicesSink_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_unisrgt_0095 */
/* [local] */ 

STDAPI CoRegisterSurrogateEx (REFGUID rguidProcessID,		
							  ISurrogate* pSrgt);			
STDAPI CoLoadServices (REFGUID rguidProcessID,				
					   IPAControl* pPAControl,				
					   REFIID riid, void **ppv );			
typedef HRESULT (STDAPICALLTYPE *FN_CoLoadServices)			
								(REFGUID rguidProcessID,	
								 IPAControl* pPAControl,	
								 REFIID riid, void **ppv );	


extern RPC_IF_HANDLE __MIDL_itf_unisrgt_0095_ClientIfHandle;
extern RPC_IF_HANDLE __MIDL_itf_unisrgt_0095_ServerIfHandle;

/* Additional Prototypes for ALL interfaces */

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\public\internal\com\inc\trkwks_s.c ===
#pragma warning( disable: 4049 )  /* more than 64k source lines */

/* this ALWAYS GENERATED file contains the RPC server stubs */


 /* File created by MIDL compiler version 6.00.0347 */
/* Compiler settings for trkwks.idl:
    Oicf, W1, Zp8, env=Win32 (32b run)
    protocol : dce , ms_ext, c_ext, robust
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )

#if !defined(_M_IA64) && !defined(_M_AMD64)
#include <string.h>
#include "trkwks.h"

#define TYPE_FORMAT_STRING_SIZE   745                               
#define PROC_FORMAT_STRING_SIZE   701                               
#define TRANSMIT_AS_TABLE_SIZE    0            
#define WIRE_MARSHAL_TABLE_SIZE   0            

typedef struct _MIDL_TYPE_FORMAT_STRING
    {
    short          Pad;
    unsigned char  Format[ TYPE_FORMAT_STRING_SIZE ];
    } MIDL_TYPE_FORMAT_STRING;

typedef struct _MIDL_PROC_FORMAT_STRING
    {
    short          Pad;
    unsigned char  Format[ PROC_FORMAT_STRING_SIZE ];
    } MIDL_PROC_FORMAT_STRING;


static RPC_SYNTAX_IDENTIFIER  _RpcTransferSyntax = 
{{0x8A885D04,0x1CEB,0x11C9,{0x9F,0xE8,0x08,0x00,0x2B,0x10,0x48,0x60}},{2,0}};

extern const MIDL_TYPE_FORMAT_STRING __MIDL_TypeFormatString;
extern const MIDL_PROC_FORMAT_STRING __MIDL_ProcFormatString;

/* Standard interface: __MIDL_itf_trkwks_0000, ver. 0.0,
   GUID={0x00000000,0x0000,0x0000,{0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00}} */


/* Standard interface: trkwks, ver. 1.2,
   GUID={0x300f3532,0x38cc,0x11d0,{0xa3,0xf0,0x00,0x20,0xaf,0x6b,0x0a,0xdd}} */


extern const MIDL_SERVER_INFO trkwks_ServerInfo;

extern RPC_DISPATCH_TABLE trkwks_v1_2_DispatchTable;

static const RPC_SERVER_INTERFACE trkwks___RpcServerInterface =
    {
    sizeof(RPC_SERVER_INTERFACE),
    {{0x300f3532,0x38cc,0x11d0,{0xa3,0xf0,0x00,0x20,0xaf,0x6b,0x0a,0xdd}},{1,2}},
    {{0x8A885D04,0x1CEB,0x11C9,{0x9F,0xE8,0x08,0x00,0x2B,0x10,0x48,0x60}},{2,0}},
    &trkwks_v1_2_DispatchTable,
    0,
    0,
    0,
    &trkwks_ServerInfo,
    0x04000001
    };
RPC_IF_HANDLE Stubtrkwks_v1_2_s_ifspec = (RPC_IF_HANDLE)& trkwks___RpcServerInterface;

extern const MIDL_STUB_DESC trkwks_StubDesc;


#if !defined(__RPC_WIN32__)
#error  Invalid build platform for this stub.
#endif

#if !(TARGET_IS_NT50_OR_LATER)
#error You need a Windows 2000 or later to run this stub because it uses these features:
#error   [async] attribute, /robust command line switch.
#error However, your C/C++ compilation flags indicate you intend to run this app on earlier systems.
#error This app will die there with the RPC_X_WRONG_STUB_VERSION error.
#endif


static const MIDL_PROC_FORMAT_STRING __MIDL_ProcFormatString =
    {
        0,
        {

	/* Procedure old_LnkMendLink */

			0x0,		/* 0 */
			0x48,		/* Old Flags:  */
/*  2 */	NdrFcLong( 0x0 ),	/* 0 */
/*  6 */	NdrFcShort( 0x0 ),	/* 0 */
/*  8 */	NdrFcShort( 0x24 ),	/* x86 Stack size/offset = 36 */
/* 10 */	0x32,		/* FC_BIND_PRIMITIVE */
			0x0,		/* 0 */
/* 12 */	NdrFcShort( 0x0 ),	/* x86 Stack size/offset = 0 */
/* 14 */	NdrFcShort( 0x168 ),	/* 360 */
/* 16 */	NdrFcShort( 0xac ),	/* 172 */
/* 18 */	0x45,		/* Oi2 Flags:  srv must size, has return, has ext, */
			0x7,		/* 7 */
/* 20 */	0x8,		/* 8 */
			0x1,		/* Ext Flags:  new corr desc, */
/* 22 */	NdrFcShort( 0x0 ),	/* 0 */
/* 24 */	NdrFcShort( 0x0 ),	/* 0 */
/* 26 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter IDL_handle */

/* 28 */	NdrFcShort( 0x8a ),	/* Flags:  must free, in, by val, */
/* 30 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 32 */	NdrFcShort( 0x2 ),	/* Type Offset=2 */

	/* Parameter ftLimit */

/* 34 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 36 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 38 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter Restrictions */

/* 40 */	NdrFcShort( 0x10a ),	/* Flags:  must free, in, simple ref, */
/* 42 */	NdrFcShort( 0x10 ),	/* x86 Stack size/offset = 16 */
/* 44 */	NdrFcShort( 0x2a ),	/* Type Offset=42 */

	/* Parameter pdroidBirth */

/* 46 */	NdrFcShort( 0x10a ),	/* Flags:  must free, in, simple ref, */
/* 48 */	NdrFcShort( 0x14 ),	/* x86 Stack size/offset = 20 */
/* 50 */	NdrFcShort( 0x2a ),	/* Type Offset=42 */

	/* Parameter pdroidLast */

/* 52 */	NdrFcShort( 0x8112 ),	/* Flags:  must free, out, simple ref, srv alloc size=32 */
/* 54 */	NdrFcShort( 0x18 ),	/* x86 Stack size/offset = 24 */
/* 56 */	NdrFcShort( 0x2a ),	/* Type Offset=42 */

	/* Parameter pdroidCurrent */

/* 58 */	NdrFcShort( 0x13 ),	/* Flags:  must size, must free, out, */
/* 60 */	NdrFcShort( 0x1c ),	/* x86 Stack size/offset = 28 */
/* 62 */	NdrFcShort( 0x3c ),	/* Type Offset=60 */

	/* Parameter wsz */

/* 64 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 66 */	NdrFcShort( 0x20 ),	/* x86 Stack size/offset = 32 */
/* 68 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure old_LnkSearchMachine */


	/* Return value */

/* 70 */	0x0,		/* 0 */
			0x48,		/* Old Flags:  */
/* 72 */	NdrFcLong( 0x0 ),	/* 0 */
/* 76 */	NdrFcShort( 0x1 ),	/* 1 */
/* 78 */	NdrFcShort( 0x18 ),	/* x86 Stack size/offset = 24 */
/* 80 */	0x32,		/* FC_BIND_PRIMITIVE */
			0x0,		/* 0 */
/* 82 */	NdrFcShort( 0x0 ),	/* x86 Stack size/offset = 0 */
/* 84 */	NdrFcShort( 0xac ),	/* 172 */
/* 86 */	NdrFcShort( 0xac ),	/* 172 */
/* 88 */	0x45,		/* Oi2 Flags:  srv must size, has return, has ext, */
			0x5,		/* 5 */
/* 90 */	0x8,		/* 8 */
			0x1,		/* Ext Flags:  new corr desc, */
/* 92 */	NdrFcShort( 0x0 ),	/* 0 */
/* 94 */	NdrFcShort( 0x0 ),	/* 0 */
/* 96 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter IDL_handle */

/* 98 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 100 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 102 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter Restrictions */

/* 104 */	NdrFcShort( 0x10a ),	/* Flags:  must free, in, simple ref, */
/* 106 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 108 */	NdrFcShort( 0x2a ),	/* Type Offset=42 */

	/* Parameter pdroidLast */

/* 110 */	NdrFcShort( 0x8112 ),	/* Flags:  must free, out, simple ref, srv alloc size=32 */
/* 112 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 114 */	NdrFcShort( 0x2a ),	/* Type Offset=42 */

	/* Parameter pdroidReferral */

/* 116 */	NdrFcShort( 0x13 ),	/* Flags:  must size, must free, out, */
/* 118 */	NdrFcShort( 0x10 ),	/* x86 Stack size/offset = 16 */
/* 120 */	NdrFcShort( 0x3c ),	/* Type Offset=60 */

	/* Parameter tsz */

/* 122 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 124 */	NdrFcShort( 0x14 ),	/* x86 Stack size/offset = 20 */
/* 126 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure old_LnkCallSvrMessage */


	/* Return value */

/* 128 */	0x0,		/* 0 */
			0x48,		/* Old Flags:  */
/* 130 */	NdrFcLong( 0x0 ),	/* 0 */
/* 134 */	NdrFcShort( 0x2 ),	/* 2 */
/* 136 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 138 */	0x32,		/* FC_BIND_PRIMITIVE */
			0x0,		/* 0 */
/* 140 */	NdrFcShort( 0x0 ),	/* x86 Stack size/offset = 0 */
/* 142 */	NdrFcShort( 0x0 ),	/* 0 */
/* 144 */	NdrFcShort( 0x8 ),	/* 8 */
/* 146 */	0x47,		/* Oi2 Flags:  srv must size, clt must size, has return, has ext, */
			0x2,		/* 2 */
/* 148 */	0x8,		/* 8 */
			0x7,		/* Ext Flags:  new corr desc, clt corr check, srv corr check, */
/* 150 */	NdrFcShort( 0xb ),	/* 11 */
/* 152 */	NdrFcShort( 0xb ),	/* 11 */
/* 154 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter IDL_handle */

/* 156 */	NdrFcShort( 0x11b ),	/* Flags:  must size, must free, in, out, simple ref, */
/* 158 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 160 */	NdrFcShort( 0x1ce ),	/* Type Offset=462 */

	/* Parameter pMsg */

/* 162 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 164 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 166 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure LnkSetVolumeId */


	/* Return value */

/* 168 */	0x0,		/* 0 */
			0x48,		/* Old Flags:  */
/* 170 */	NdrFcLong( 0x0 ),	/* 0 */
/* 174 */	NdrFcShort( 0x3 ),	/* 3 */
/* 176 */	NdrFcShort( 0x1c ),	/* x86 Stack size/offset = 28 */
/* 178 */	0x32,		/* FC_BIND_PRIMITIVE */
			0x0,		/* 0 */
/* 180 */	NdrFcShort( 0x0 ),	/* x86 Stack size/offset = 0 */
/* 182 */	NdrFcShort( 0x48 ),	/* 72 */
/* 184 */	NdrFcShort( 0x8 ),	/* 8 */
/* 186 */	0x44,		/* Oi2 Flags:  has return, has ext, */
			0x3,		/* 3 */
/* 188 */	0x8,		/* 8 */
			0x1,		/* Ext Flags:  new corr desc, */
/* 190 */	NdrFcShort( 0x0 ),	/* 0 */
/* 192 */	NdrFcShort( 0x0 ),	/* 0 */
/* 194 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter IDL_handle */

/* 196 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 198 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 200 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter volumeIndex */

/* 202 */	NdrFcShort( 0x8a ),	/* Flags:  must free, in, by val, */
/* 204 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 206 */	NdrFcShort( 0x20 ),	/* Type Offset=32 */

	/* Parameter VolId */

/* 208 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 210 */	NdrFcShort( 0x18 ),	/* x86 Stack size/offset = 24 */
/* 212 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure LnkRestartDcSynchronization */


	/* Return value */

/* 214 */	0x0,		/* 0 */
			0x48,		/* Old Flags:  */
/* 216 */	NdrFcLong( 0x0 ),	/* 0 */
/* 220 */	NdrFcShort( 0x4 ),	/* 4 */
/* 222 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 224 */	0x32,		/* FC_BIND_PRIMITIVE */
			0x0,		/* 0 */
/* 226 */	NdrFcShort( 0x0 ),	/* x86 Stack size/offset = 0 */
/* 228 */	NdrFcShort( 0x0 ),	/* 0 */
/* 230 */	NdrFcShort( 0x8 ),	/* 8 */
/* 232 */	0x44,		/* Oi2 Flags:  has return, has ext, */
			0x1,		/* 1 */
/* 234 */	0x8,		/* 8 */
			0x1,		/* Ext Flags:  new corr desc, */
/* 236 */	NdrFcShort( 0x0 ),	/* 0 */
/* 238 */	NdrFcShort( 0x0 ),	/* 0 */
/* 240 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter IDL_handle */

/* 242 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 244 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 246 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure GetVolumeTrackingInformation */


	/* Return value */

/* 248 */	0x0,		/* 0 */
			0x48,		/* Old Flags:  */
/* 250 */	NdrFcLong( 0x0 ),	/* 0 */
/* 254 */	NdrFcShort( 0x5 ),	/* 5 */
/* 256 */	NdrFcShort( 0x2c ),	/* x86 Stack size/offset = 44 */
/* 258 */	0x32,		/* FC_BIND_PRIMITIVE */
			0x0,		/* 0 */
/* 260 */	NdrFcShort( 0x0 ),	/* x86 Stack size/offset = 0 */
/* 262 */	NdrFcShort( 0x48 ),	/* 72 */
/* 264 */	NdrFcShort( 0x8 ),	/* 8 */
/* 266 */	0x4c,		/* Oi2 Flags:  has return, has pipes, has ext, */
			0x4,		/* 4 */
/* 268 */	0x8,		/* 8 */
			0x1,		/* Ext Flags:  new corr desc, */
/* 270 */	NdrFcShort( 0x0 ),	/* 0 */
/* 272 */	NdrFcShort( 0x0 ),	/* 0 */
/* 274 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter IDL_handle */

/* 276 */	NdrFcShort( 0x8a ),	/* Flags:  must free, in, by val, */
/* 278 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 280 */	NdrFcShort( 0x20 ),	/* Type Offset=32 */

	/* Parameter volid */

/* 282 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 284 */	NdrFcShort( 0x14 ),	/* x86 Stack size/offset = 20 */
/* 286 */	0xe,		/* FC_ENUM32 */
			0x0,		/* 0 */

	/* Parameter scope */

/* 288 */	NdrFcShort( 0x14 ),	/* Flags:  pipe, out, */
/* 290 */	NdrFcShort( 0x18 ),	/* x86 Stack size/offset = 24 */
/* 292 */	NdrFcShort( 0x1ec ),	/* Type Offset=492 */

	/* Parameter pipeVolInfo */

/* 294 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 296 */	NdrFcShort( 0x28 ),	/* x86 Stack size/offset = 40 */
/* 298 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure GetFileTrackingInformation */


	/* Return value */

/* 300 */	0x0,		/* 0 */
			0x48,		/* Old Flags:  */
/* 302 */	NdrFcLong( 0x0 ),	/* 0 */
/* 306 */	NdrFcShort( 0x6 ),	/* 6 */
/* 308 */	NdrFcShort( 0x3c ),	/* x86 Stack size/offset = 60 */
/* 310 */	0x32,		/* FC_BIND_PRIMITIVE */
			0x0,		/* 0 */
/* 312 */	NdrFcShort( 0x0 ),	/* x86 Stack size/offset = 0 */
/* 314 */	NdrFcShort( 0x98 ),	/* 152 */
/* 316 */	NdrFcShort( 0x8 ),	/* 8 */
/* 318 */	0x4c,		/* Oi2 Flags:  has return, has pipes, has ext, */
			0x4,		/* 4 */
/* 320 */	0x8,		/* 8 */
			0x1,		/* Ext Flags:  new corr desc, */
/* 322 */	NdrFcShort( 0x0 ),	/* 0 */
/* 324 */	NdrFcShort( 0x0 ),	/* 0 */
/* 326 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter IDL_handle */

/* 328 */	NdrFcShort( 0x8a ),	/* Flags:  must free, in, by val, */
/* 330 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 332 */	NdrFcShort( 0x2a ),	/* Type Offset=42 */

	/* Parameter droidCurrent */

/* 334 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 336 */	NdrFcShort( 0x24 ),	/* x86 Stack size/offset = 36 */
/* 338 */	0xe,		/* FC_ENUM32 */
			0x0,		/* 0 */

	/* Parameter scope */

/* 340 */	NdrFcShort( 0x14 ),	/* Flags:  pipe, out, */
/* 342 */	NdrFcShort( 0x28 ),	/* x86 Stack size/offset = 40 */
/* 344 */	NdrFcShort( 0x1f4 ),	/* Type Offset=500 */

	/* Parameter pipeFileInfo */

/* 346 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 348 */	NdrFcShort( 0x38 ),	/* x86 Stack size/offset = 56 */
/* 350 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure TriggerVolumeClaims */


	/* Return value */

/* 352 */	0x0,		/* 0 */
			0x48,		/* Old Flags:  */
/* 354 */	NdrFcLong( 0x0 ),	/* 0 */
/* 358 */	NdrFcShort( 0x7 ),	/* 7 */
/* 360 */	NdrFcShort( 0x10 ),	/* x86 Stack size/offset = 16 */
/* 362 */	0x32,		/* FC_BIND_PRIMITIVE */
			0x0,		/* 0 */
/* 364 */	NdrFcShort( 0x0 ),	/* x86 Stack size/offset = 0 */
/* 366 */	NdrFcShort( 0x8 ),	/* 8 */
/* 368 */	NdrFcShort( 0x8 ),	/* 8 */
/* 370 */	0x46,		/* Oi2 Flags:  clt must size, has return, has ext, */
			0x3,		/* 3 */
/* 372 */	0x8,		/* 8 */
			0x5,		/* Ext Flags:  new corr desc, srv corr check, */
/* 374 */	NdrFcShort( 0x0 ),	/* 0 */
/* 376 */	NdrFcShort( 0x1 ),	/* 1 */
/* 378 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter IDL_handle */

/* 380 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 382 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 384 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter cVolumes */

/* 386 */	NdrFcShort( 0x10b ),	/* Flags:  must size, must free, in, simple ref, */
/* 388 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 390 */	NdrFcShort( 0x200 ),	/* Type Offset=512 */

	/* Parameter rgvolid */

/* 392 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 394 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 396 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure LnkOnRestore */


	/* Return value */

/* 398 */	0x0,		/* 0 */
			0x48,		/* Old Flags:  */
/* 400 */	NdrFcLong( 0x0 ),	/* 0 */
/* 404 */	NdrFcShort( 0x8 ),	/* 8 */
/* 406 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 408 */	0x32,		/* FC_BIND_PRIMITIVE */
			0x0,		/* 0 */
/* 410 */	NdrFcShort( 0x0 ),	/* x86 Stack size/offset = 0 */
/* 412 */	NdrFcShort( 0x0 ),	/* 0 */
/* 414 */	NdrFcShort( 0x8 ),	/* 8 */
/* 416 */	0x44,		/* Oi2 Flags:  has return, has ext, */
			0x1,		/* 1 */
/* 418 */	0x8,		/* 8 */
			0x1,		/* Ext Flags:  new corr desc, */
/* 420 */	NdrFcShort( 0x0 ),	/* 0 */
/* 422 */	NdrFcShort( 0x0 ),	/* 0 */
/* 424 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter IDL_handle */

/* 426 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 428 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 430 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure LnkMendLink */


	/* Return value */

/* 432 */	0x0,		/* 0 */
			0x48,		/* Old Flags:  */
/* 434 */	NdrFcLong( 0x0 ),	/* 0 */
/* 438 */	NdrFcShort( 0x9 ),	/* 9 */
/* 440 */	NdrFcShort( 0x34 ),	/* x86 Stack size/offset = 52 */
/* 442 */	0x32,		/* FC_BIND_PRIMITIVE */
			0x0,		/* 0 */
/* 444 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 446 */	NdrFcShort( 0x1c8 ),	/* 456 */
/* 448 */	NdrFcShort( 0x10c ),	/* 268 */
/* 450 */	0xc5,		/* Oi2 Flags:  srv must size, has return, has ext, has async handle */
			0xa,		/* 10 */
/* 452 */	0x8,		/* 8 */
			0x3,		/* Ext Flags:  new corr desc, clt corr check, */
/* 454 */	NdrFcShort( 0x1 ),	/* 1 */
/* 456 */	NdrFcShort( 0x0 ),	/* 0 */
/* 458 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter IDL_handle */

/* 460 */	NdrFcShort( 0x8a ),	/* Flags:  must free, in, by val, */
/* 462 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 464 */	NdrFcShort( 0x2 ),	/* Type Offset=2 */

	/* Parameter ftLimit */

/* 466 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 468 */	NdrFcShort( 0x10 ),	/* x86 Stack size/offset = 16 */
/* 470 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter Restrictions */

/* 472 */	NdrFcShort( 0x10a ),	/* Flags:  must free, in, simple ref, */
/* 474 */	NdrFcShort( 0x14 ),	/* x86 Stack size/offset = 20 */
/* 476 */	NdrFcShort( 0x2a ),	/* Type Offset=42 */

	/* Parameter pdroidBirth */

/* 478 */	NdrFcShort( 0x10a ),	/* Flags:  must free, in, simple ref, */
/* 480 */	NdrFcShort( 0x18 ),	/* x86 Stack size/offset = 24 */
/* 482 */	NdrFcShort( 0x2a ),	/* Type Offset=42 */

	/* Parameter pdroidLast */

/* 484 */	NdrFcShort( 0x10a ),	/* Flags:  must free, in, simple ref, */
/* 486 */	NdrFcShort( 0x1c ),	/* x86 Stack size/offset = 28 */
/* 488 */	NdrFcShort( 0x14e ),	/* Type Offset=334 */

	/* Parameter pmcidLast */

/* 490 */	NdrFcShort( 0x8112 ),	/* Flags:  must free, out, simple ref, srv alloc size=32 */
/* 492 */	NdrFcShort( 0x20 ),	/* x86 Stack size/offset = 32 */
/* 494 */	NdrFcShort( 0x2a ),	/* Type Offset=42 */

	/* Parameter pdroidCurrent */

/* 496 */	NdrFcShort( 0x4112 ),	/* Flags:  must free, out, simple ref, srv alloc size=16 */
/* 498 */	NdrFcShort( 0x24 ),	/* x86 Stack size/offset = 36 */
/* 500 */	NdrFcShort( 0x14e ),	/* Type Offset=334 */

	/* Parameter pmcidCurrent */

/* 502 */	NdrFcShort( 0x158 ),	/* Flags:  in, out, base type, simple ref, */
/* 504 */	NdrFcShort( 0x28 ),	/* x86 Stack size/offset = 40 */
/* 506 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter pcbPath */

/* 508 */	NdrFcShort( 0x113 ),	/* Flags:  must size, must free, out, simple ref, */
/* 510 */	NdrFcShort( 0x2c ),	/* x86 Stack size/offset = 44 */
/* 512 */	NdrFcShort( 0x220 ),	/* Type Offset=544 */

	/* Parameter pwszPath */

/* 514 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 516 */	NdrFcShort( 0x30 ),	/* x86 Stack size/offset = 48 */
/* 518 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure old2_LnkSearchMachine */


	/* Return value */

/* 520 */	0x0,		/* 0 */
			0x48,		/* Old Flags:  */
/* 522 */	NdrFcLong( 0x0 ),	/* 0 */
/* 526 */	NdrFcShort( 0xa ),	/* 10 */
/* 528 */	NdrFcShort( 0x1c ),	/* x86 Stack size/offset = 28 */
/* 530 */	0x32,		/* FC_BIND_PRIMITIVE */
			0x0,		/* 0 */
/* 532 */	NdrFcShort( 0x0 ),	/* x86 Stack size/offset = 0 */
/* 534 */	NdrFcShort( 0xac ),	/* 172 */
/* 536 */	NdrFcShort( 0xf0 ),	/* 240 */
/* 538 */	0x45,		/* Oi2 Flags:  srv must size, has return, has ext, */
			0x6,		/* 6 */
/* 540 */	0x8,		/* 8 */
			0x3,		/* Ext Flags:  new corr desc, clt corr check, */
/* 542 */	NdrFcShort( 0x1 ),	/* 1 */
/* 544 */	NdrFcShort( 0x0 ),	/* 0 */
/* 546 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter IDL_handle */

/* 548 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 550 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 552 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter Restrictions */

/* 554 */	NdrFcShort( 0x10a ),	/* Flags:  must free, in, simple ref, */
/* 556 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 558 */	NdrFcShort( 0x2a ),	/* Type Offset=42 */

	/* Parameter pdroidLast */

/* 560 */	NdrFcShort( 0x8112 ),	/* Flags:  must free, out, simple ref, srv alloc size=32 */
/* 562 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 564 */	NdrFcShort( 0x2a ),	/* Type Offset=42 */

	/* Parameter pdroidNext */

/* 566 */	NdrFcShort( 0x4112 ),	/* Flags:  must free, out, simple ref, srv alloc size=16 */
/* 568 */	NdrFcShort( 0x10 ),	/* x86 Stack size/offset = 16 */
/* 570 */	NdrFcShort( 0x14e ),	/* Type Offset=334 */

	/* Parameter pmcidNext */

/* 572 */	NdrFcShort( 0x113 ),	/* Flags:  must size, must free, out, simple ref, */
/* 574 */	NdrFcShort( 0x14 ),	/* x86 Stack size/offset = 20 */
/* 576 */	NdrFcShort( 0x22c ),	/* Type Offset=556 */

	/* Parameter ptszPath */

/* 578 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 580 */	NdrFcShort( 0x18 ),	/* x86 Stack size/offset = 24 */
/* 582 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure LnkCallSvrMessage */


	/* Return value */

/* 584 */	0x0,		/* 0 */
			0x48,		/* Old Flags:  */
/* 586 */	NdrFcLong( 0x0 ),	/* 0 */
/* 590 */	NdrFcShort( 0xb ),	/* 11 */
/* 592 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 594 */	0x32,		/* FC_BIND_PRIMITIVE */
			0x0,		/* 0 */
/* 596 */	NdrFcShort( 0x0 ),	/* x86 Stack size/offset = 0 */
/* 598 */	NdrFcShort( 0x0 ),	/* 0 */
/* 600 */	NdrFcShort( 0x8 ),	/* 8 */
/* 602 */	0x47,		/* Oi2 Flags:  srv must size, clt must size, has return, has ext, */
			0x2,		/* 2 */
/* 604 */	0x8,		/* 8 */
			0x7,		/* Ext Flags:  new corr desc, clt corr check, srv corr check, */
/* 606 */	NdrFcShort( 0xb ),	/* 11 */
/* 608 */	NdrFcShort( 0xb ),	/* 11 */
/* 610 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter IDL_handle */

/* 612 */	NdrFcShort( 0x11b ),	/* Flags:  must size, must free, in, out, simple ref, */
/* 614 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 616 */	NdrFcShort( 0x2c8 ),	/* Type Offset=712 */

	/* Parameter pMsg */

/* 618 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 620 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 622 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure LnkSearchMachine */


	/* Return value */

/* 624 */	0x0,		/* 0 */
			0x48,		/* Old Flags:  */
/* 626 */	NdrFcLong( 0x0 ),	/* 0 */
/* 630 */	NdrFcShort( 0xc ),	/* 12 */
/* 632 */	NdrFcShort( 0x24 ),	/* x86 Stack size/offset = 36 */
/* 634 */	0x32,		/* FC_BIND_PRIMITIVE */
			0x0,		/* 0 */
/* 636 */	NdrFcShort( 0x0 ),	/* x86 Stack size/offset = 0 */
/* 638 */	NdrFcShort( 0x150 ),	/* 336 */
/* 640 */	NdrFcShort( 0x194 ),	/* 404 */
/* 642 */	0x45,		/* Oi2 Flags:  srv must size, has return, has ext, */
			0x8,		/* 8 */
/* 644 */	0x8,		/* 8 */
			0x3,		/* Ext Flags:  new corr desc, clt corr check, */
/* 646 */	NdrFcShort( 0x1 ),	/* 1 */
/* 648 */	NdrFcShort( 0x0 ),	/* 0 */
/* 650 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter IDL_handle */

/* 652 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 654 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 656 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter Restrictions */

/* 658 */	NdrFcShort( 0x10a ),	/* Flags:  must free, in, simple ref, */
/* 660 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 662 */	NdrFcShort( 0x2a ),	/* Type Offset=42 */

	/* Parameter pdroidBirthLast */

/* 664 */	NdrFcShort( 0x10a ),	/* Flags:  must free, in, simple ref, */
/* 666 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 668 */	NdrFcShort( 0x2a ),	/* Type Offset=42 */

	/* Parameter pdroidLast */

/* 670 */	NdrFcShort( 0x8112 ),	/* Flags:  must free, out, simple ref, srv alloc size=32 */
/* 672 */	NdrFcShort( 0x10 ),	/* x86 Stack size/offset = 16 */
/* 674 */	NdrFcShort( 0x2a ),	/* Type Offset=42 */

	/* Parameter pdroidBirthNext */

/* 676 */	NdrFcShort( 0x8112 ),	/* Flags:  must free, out, simple ref, srv alloc size=32 */
/* 678 */	NdrFcShort( 0x14 ),	/* x86 Stack size/offset = 20 */
/* 680 */	NdrFcShort( 0x2a ),	/* Type Offset=42 */

	/* Parameter pdroidNext */

/* 682 */	NdrFcShort( 0x4112 ),	/* Flags:  must free, out, simple ref, srv alloc size=16 */
/* 684 */	NdrFcShort( 0x18 ),	/* x86 Stack size/offset = 24 */
/* 686 */	NdrFcShort( 0x14e ),	/* Type Offset=334 */

	/* Parameter pmcidNext */

/* 688 */	NdrFcShort( 0x113 ),	/* Flags:  must size, must free, out, simple ref, */
/* 690 */	NdrFcShort( 0x1c ),	/* x86 Stack size/offset = 28 */
/* 692 */	NdrFcShort( 0x2e0 ),	/* Type Offset=736 */

	/* Parameter ptszPath */

/* 694 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 696 */	NdrFcShort( 0x20 ),	/* x86 Stack size/offset = 32 */
/* 698 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

			0x0
        }
    };

static const MIDL_TYPE_FORMAT_STRING __MIDL_TypeFormatString =
    {
        0,
        {
			NdrFcShort( 0x0 ),	/* 0 */
/*  2 */	
			0x15,		/* FC_STRUCT */
			0x3,		/* 3 */
/*  4 */	NdrFcShort( 0x8 ),	/* 8 */
/*  6 */	0x8,		/* FC_LONG */
			0x8,		/* FC_LONG */
/*  8 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 10 */	
			0x11, 0x0,	/* FC_RP */
/* 12 */	NdrFcShort( 0x1e ),	/* Offset= 30 (42) */
/* 14 */	
			0x1d,		/* FC_SMFARRAY */
			0x0,		/* 0 */
/* 16 */	NdrFcShort( 0x8 ),	/* 8 */
/* 18 */	0x1,		/* FC_BYTE */
			0x5b,		/* FC_END */
/* 20 */	
			0x15,		/* FC_STRUCT */
			0x3,		/* 3 */
/* 22 */	NdrFcShort( 0x10 ),	/* 16 */
/* 24 */	0x8,		/* FC_LONG */
			0x6,		/* FC_SHORT */
/* 26 */	0x6,		/* FC_SHORT */
			0x4c,		/* FC_EMBEDDED_COMPLEX */
/* 28 */	0x0,		/* 0 */
			NdrFcShort( 0xfffffff1 ),	/* Offset= -15 (14) */
			0x5b,		/* FC_END */
/* 32 */	
			0x15,		/* FC_STRUCT */
			0x3,		/* 3 */
/* 34 */	NdrFcShort( 0x10 ),	/* 16 */
/* 36 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 38 */	NdrFcShort( 0xffffffee ),	/* Offset= -18 (20) */
/* 40 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 42 */	
			0x15,		/* FC_STRUCT */
			0x3,		/* 3 */
/* 44 */	NdrFcShort( 0x20 ),	/* 32 */
/* 46 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 48 */	NdrFcShort( 0xfffffff0 ),	/* Offset= -16 (32) */
/* 50 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 52 */	NdrFcShort( 0xffffffec ),	/* Offset= -20 (32) */
/* 54 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 56 */	
			0x11, 0x4,	/* FC_RP [alloced_on_stack] */
/* 58 */	NdrFcShort( 0xfffffff0 ),	/* Offset= -16 (42) */
/* 60 */	
			0x29,		/* FC_WSTRING */
			0x5c,		/* FC_PAD */
/* 62 */	NdrFcShort( 0x105 ),	/* 261 */
/* 64 */	
			0x11, 0x0,	/* FC_RP */
/* 66 */	NdrFcShort( 0x18c ),	/* Offset= 396 (462) */
/* 68 */	
			0x2b,		/* FC_NON_ENCAPSULATED_UNION */
			0x8,		/* FC_LONG */
/* 70 */	0x8,		/* Corr desc: FC_LONG */
			0x0,		/*  */
/* 72 */	NdrFcShort( 0xfffc ),	/* -4 */
/* 74 */	NdrFcShort( 0x1 ),	/* Corr flags:  early, */
/* 76 */	NdrFcShort( 0x2 ),	/* Offset= 2 (78) */
/* 78 */	NdrFcShort( 0x20 ),	/* 32 */
/* 80 */	NdrFcShort( 0x6 ),	/* 6 */
/* 82 */	NdrFcLong( 0x0 ),	/* 0 */
/* 86 */	NdrFcShort( 0x4c ),	/* Offset= 76 (162) */
/* 88 */	NdrFcLong( 0x1 ),	/* 1 */
/* 92 */	NdrFcShort( 0x7a ),	/* Offset= 122 (214) */
/* 94 */	NdrFcLong( 0x2 ),	/* 2 */
/* 98 */	NdrFcShort( 0xbc ),	/* Offset= 188 (286) */
/* 100 */	NdrFcLong( 0x3 ),	/* 3 */
/* 104 */	NdrFcShort( 0x11c ),	/* Offset= 284 (388) */
/* 106 */	NdrFcLong( 0x4 ),	/* 4 */
/* 110 */	NdrFcShort( 0xb0 ),	/* Offset= 176 (286) */
/* 112 */	NdrFcLong( 0x6 ),	/* 6 */
/* 116 */	NdrFcShort( 0x146 ),	/* Offset= 326 (442) */
/* 118 */	NdrFcShort( 0xffffffff ),	/* Offset= -1 (117) */
/* 120 */	
			0x1d,		/* FC_SMFARRAY */
			0x1,		/* 1 */
/* 122 */	NdrFcShort( 0x202 ),	/* 514 */
/* 124 */	0x5,		/* FC_WCHAR */
			0x5b,		/* FC_END */
/* 126 */	
			0x15,		/* FC_STRUCT */
			0x3,		/* 3 */
/* 128 */	NdrFcShort( 0x248 ),	/* 584 */
/* 130 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 132 */	NdrFcShort( 0xfffffff4 ),	/* Offset= -12 (120) */
/* 134 */	0x3e,		/* FC_STRUCTPAD2 */
			0x4c,		/* FC_EMBEDDED_COMPLEX */
/* 136 */	0x0,		/* 0 */
			NdrFcShort( 0xffffffa1 ),	/* Offset= -95 (42) */
			0x4c,		/* FC_EMBEDDED_COMPLEX */
/* 140 */	0x0,		/* 0 */
			NdrFcShort( 0xffffff9d ),	/* Offset= -99 (42) */
			0x8,		/* FC_LONG */
/* 144 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 146 */	
			0x1b,		/* FC_CARRAY */
			0x3,		/* 3 */
/* 148 */	NdrFcShort( 0x248 ),	/* 584 */
/* 150 */	0x19,		/* Corr desc:  field pointer, FC_ULONG */
			0x0,		/*  */
/* 152 */	NdrFcShort( 0x0 ),	/* 0 */
/* 154 */	NdrFcShort( 0x1 ),	/* Corr flags:  early, */
/* 156 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 158 */	NdrFcShort( 0xffffffe0 ),	/* Offset= -32 (126) */
/* 160 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 162 */	
			0x16,		/* FC_PSTRUCT */
			0x3,		/* 3 */
/* 164 */	NdrFcShort( 0x8 ),	/* 8 */
/* 166 */	
			0x4b,		/* FC_PP */
			0x5c,		/* FC_PAD */
/* 168 */	
			0x46,		/* FC_NO_REPEAT */
			0x5c,		/* FC_PAD */
/* 170 */	NdrFcShort( 0x4 ),	/* 4 */
/* 172 */	NdrFcShort( 0x4 ),	/* 4 */
/* 174 */	0x12, 0x0,	/* FC_UP */
/* 176 */	NdrFcShort( 0xffffffe2 ),	/* Offset= -30 (146) */
/* 178 */	
			0x5b,		/* FC_END */

			0x8,		/* FC_LONG */
/* 180 */	0x8,		/* FC_LONG */
			0x5b,		/* FC_END */
/* 182 */	
			0x1b,		/* FC_CARRAY */
			0x3,		/* 3 */
/* 184 */	NdrFcShort( 0x10 ),	/* 16 */
/* 186 */	0x19,		/* Corr desc:  field pointer, FC_ULONG */
			0x0,		/*  */
/* 188 */	NdrFcShort( 0x0 ),	/* 0 */
/* 190 */	NdrFcShort( 0x1 ),	/* Corr flags:  early, */
/* 192 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 194 */	NdrFcShort( 0xffffff5e ),	/* Offset= -162 (32) */
/* 196 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 198 */	
			0x1b,		/* FC_CARRAY */
			0x3,		/* 3 */
/* 200 */	NdrFcShort( 0x20 ),	/* 32 */
/* 202 */	0x19,		/* Corr desc:  field pointer, FC_ULONG */
			0x0,		/*  */
/* 204 */	NdrFcShort( 0x0 ),	/* 0 */
/* 206 */	NdrFcShort( 0x1 ),	/* Corr flags:  early, */
/* 208 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 210 */	NdrFcShort( 0xffffff58 ),	/* Offset= -168 (42) */
/* 212 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 214 */	
			0x16,		/* FC_PSTRUCT */
			0x3,		/* 3 */
/* 216 */	NdrFcShort( 0x20 ),	/* 32 */
/* 218 */	
			0x4b,		/* FC_PP */
			0x5c,		/* FC_PAD */
/* 220 */	
			0x46,		/* FC_NO_REPEAT */
			0x5c,		/* FC_PAD */
/* 222 */	NdrFcShort( 0x10 ),	/* 16 */
/* 224 */	NdrFcShort( 0x10 ),	/* 16 */
/* 226 */	0x12, 0x0,	/* FC_UP */
/* 228 */	NdrFcShort( 0xffffff3c ),	/* Offset= -196 (32) */
/* 230 */	
			0x46,		/* FC_NO_REPEAT */
			0x5c,		/* FC_PAD */
/* 232 */	NdrFcShort( 0x14 ),	/* 20 */
/* 234 */	NdrFcShort( 0x14 ),	/* 20 */
/* 236 */	0x12, 0x0,	/* FC_UP */
/* 238 */	NdrFcShort( 0xffffffc8 ),	/* Offset= -56 (182) */
/* 240 */	
			0x46,		/* FC_NO_REPEAT */
			0x5c,		/* FC_PAD */
/* 242 */	NdrFcShort( 0x18 ),	/* 24 */
/* 244 */	NdrFcShort( 0x18 ),	/* 24 */
/* 246 */	0x12, 0x0,	/* FC_UP */
/* 248 */	NdrFcShort( 0xffffffce ),	/* Offset= -50 (198) */
/* 250 */	
			0x46,		/* FC_NO_REPEAT */
			0x5c,		/* FC_PAD */
/* 252 */	NdrFcShort( 0x1c ),	/* 28 */
/* 254 */	NdrFcShort( 0x1c ),	/* 28 */
/* 256 */	0x12, 0x0,	/* FC_UP */
/* 258 */	NdrFcShort( 0xffffffc4 ),	/* Offset= -60 (198) */
/* 260 */	
			0x5b,		/* FC_END */

			0x8,		/* FC_LONG */
/* 262 */	0x8,		/* FC_LONG */
			0x8,		/* FC_LONG */
/* 264 */	0x8,		/* FC_LONG */
			0x8,		/* FC_LONG */
/* 266 */	0x8,		/* FC_LONG */
			0x8,		/* FC_LONG */
/* 268 */	0x8,		/* FC_LONG */
			0x5b,		/* FC_END */
/* 270 */	
			0x1b,		/* FC_CARRAY */
			0x3,		/* 3 */
/* 272 */	NdrFcShort( 0x10 ),	/* 16 */
/* 274 */	0x19,		/* Corr desc:  field pointer, FC_ULONG */
			0x0,		/*  */
/* 276 */	NdrFcShort( 0x8 ),	/* 8 */
/* 278 */	NdrFcShort( 0x1 ),	/* Corr flags:  early, */
/* 280 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 282 */	NdrFcShort( 0xffffff06 ),	/* Offset= -250 (32) */
/* 284 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 286 */	
			0x16,		/* FC_PSTRUCT */
			0x3,		/* 3 */
/* 288 */	NdrFcShort( 0x10 ),	/* 16 */
/* 290 */	
			0x4b,		/* FC_PP */
			0x5c,		/* FC_PAD */
/* 292 */	
			0x46,		/* FC_NO_REPEAT */
			0x5c,		/* FC_PAD */
/* 294 */	NdrFcShort( 0x4 ),	/* 4 */
/* 296 */	NdrFcShort( 0x4 ),	/* 4 */
/* 298 */	0x12, 0x0,	/* FC_UP */
/* 300 */	NdrFcShort( 0xffffff9a ),	/* Offset= -102 (198) */
/* 302 */	
			0x46,		/* FC_NO_REPEAT */
			0x5c,		/* FC_PAD */
/* 304 */	NdrFcShort( 0xc ),	/* 12 */
/* 306 */	NdrFcShort( 0xc ),	/* 12 */
/* 308 */	0x12, 0x0,	/* FC_UP */
/* 310 */	NdrFcShort( 0xffffffd8 ),	/* Offset= -40 (270) */
/* 312 */	
			0x5b,		/* FC_END */

			0x8,		/* FC_LONG */
/* 314 */	0x8,		/* FC_LONG */
			0x8,		/* FC_LONG */
/* 316 */	0x8,		/* FC_LONG */
			0x5b,		/* FC_END */
/* 318 */	
			0x15,		/* FC_STRUCT */
			0x0,		/* 0 */
/* 320 */	NdrFcShort( 0x8 ),	/* 8 */
/* 322 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 324 */	NdrFcShort( 0xfffffeca ),	/* Offset= -310 (14) */
/* 326 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 328 */	
			0x1d,		/* FC_SMFARRAY */
			0x0,		/* 0 */
/* 330 */	NdrFcShort( 0x10 ),	/* 16 */
/* 332 */	0x2,		/* FC_CHAR */
			0x5b,		/* FC_END */
/* 334 */	
			0x15,		/* FC_STRUCT */
			0x0,		/* 0 */
/* 336 */	NdrFcShort( 0x10 ),	/* 16 */
/* 338 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 340 */	NdrFcShort( 0xfffffff4 ),	/* Offset= -12 (328) */
/* 342 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 344 */	
			0x15,		/* FC_STRUCT */
			0x3,		/* 3 */
/* 346 */	NdrFcShort( 0x44 ),	/* 68 */
/* 348 */	0x8,		/* FC_LONG */
			0xe,		/* FC_ENUM32 */
/* 350 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 352 */	NdrFcShort( 0xfffffec0 ),	/* Offset= -320 (32) */
/* 354 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 356 */	NdrFcShort( 0xffffffda ),	/* Offset= -38 (318) */
/* 358 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 360 */	NdrFcShort( 0xffffffd6 ),	/* Offset= -42 (318) */
/* 362 */	0x8,		/* FC_LONG */
			0x4c,		/* FC_EMBEDDED_COMPLEX */
/* 364 */	0x0,		/* 0 */
			NdrFcShort( 0xfffffe95 ),	/* Offset= -363 (2) */
			0x4c,		/* FC_EMBEDDED_COMPLEX */
/* 368 */	0x0,		/* 0 */
			NdrFcShort( 0xffffffdd ),	/* Offset= -35 (334) */
			0x5b,		/* FC_END */
/* 372 */	
			0x1b,		/* FC_CARRAY */
			0x3,		/* 3 */
/* 374 */	NdrFcShort( 0x44 ),	/* 68 */
/* 376 */	0x19,		/* Corr desc:  field pointer, FC_ULONG */
			0x0,		/*  */
/* 378 */	NdrFcShort( 0x0 ),	/* 0 */
/* 380 */	NdrFcShort( 0x1 ),	/* Corr flags:  early, */
/* 382 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 384 */	NdrFcShort( 0xffffffd8 ),	/* Offset= -40 (344) */
/* 386 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 388 */	
			0x16,		/* FC_PSTRUCT */
			0x3,		/* 3 */
/* 390 */	NdrFcShort( 0x8 ),	/* 8 */
/* 392 */	
			0x4b,		/* FC_PP */
			0x5c,		/* FC_PAD */
/* 394 */	
			0x46,		/* FC_NO_REPEAT */
			0x5c,		/* FC_PAD */
/* 396 */	NdrFcShort( 0x4 ),	/* 4 */
/* 398 */	NdrFcShort( 0x4 ),	/* 4 */
/* 400 */	0x12, 0x0,	/* FC_UP */
/* 402 */	NdrFcShort( 0xffffffe2 ),	/* Offset= -30 (372) */
/* 404 */	
			0x5b,		/* FC_END */

			0x8,		/* FC_LONG */
/* 406 */	0x8,		/* FC_LONG */
			0x5b,		/* FC_END */
/* 408 */	
			0x15,		/* FC_STRUCT */
			0x3,		/* 3 */
/* 410 */	NdrFcShort( 0x54 ),	/* 84 */
/* 412 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 414 */	NdrFcShort( 0xfffffe8c ),	/* Offset= -372 (42) */
/* 416 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 418 */	NdrFcShort( 0xfffffe88 ),	/* Offset= -376 (42) */
/* 420 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 422 */	NdrFcShort( 0xffffffa8 ),	/* Offset= -88 (334) */
/* 424 */	0x8,		/* FC_LONG */
			0x5b,		/* FC_END */
/* 426 */	
			0x1b,		/* FC_CARRAY */
			0x3,		/* 3 */
/* 428 */	NdrFcShort( 0x54 ),	/* 84 */
/* 430 */	0x19,		/* Corr desc:  field pointer, FC_ULONG */
			0x0,		/*  */
/* 432 */	NdrFcShort( 0x0 ),	/* 0 */
/* 434 */	NdrFcShort( 0x1 ),	/* Corr flags:  early, */
/* 436 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 438 */	NdrFcShort( 0xffffffe2 ),	/* Offset= -30 (408) */
/* 440 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 442 */	
			0x16,		/* FC_PSTRUCT */
			0x3,		/* 3 */
/* 444 */	NdrFcShort( 0x8 ),	/* 8 */
/* 446 */	
			0x4b,		/* FC_PP */
			0x5c,		/* FC_PAD */
/* 448 */	
			0x46,		/* FC_NO_REPEAT */
			0x5c,		/* FC_PAD */
/* 450 */	NdrFcShort( 0x4 ),	/* 4 */
/* 452 */	NdrFcShort( 0x4 ),	/* 4 */
/* 454 */	0x12, 0x0,	/* FC_UP */
/* 456 */	NdrFcShort( 0xffffffe2 ),	/* Offset= -30 (426) */
/* 458 */	
			0x5b,		/* FC_END */

			0x8,		/* FC_LONG */
/* 460 */	0x8,		/* FC_LONG */
			0x5b,		/* FC_END */
/* 462 */	
			0x1a,		/* FC_BOGUS_STRUCT */
			0x3,		/* 3 */
/* 464 */	NdrFcShort( 0x28 ),	/* 40 */
/* 466 */	NdrFcShort( 0x0 ),	/* 0 */
/* 468 */	NdrFcShort( 0xa ),	/* Offset= 10 (478) */
/* 470 */	0xe,		/* FC_ENUM32 */
			0x4c,		/* FC_EMBEDDED_COMPLEX */
/* 472 */	0x0,		/* 0 */
			NdrFcShort( 0xfffffe6b ),	/* Offset= -405 (68) */
			0x36,		/* FC_POINTER */
/* 476 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 478 */	
			0x12, 0x8,	/* FC_UP [simple_pointer] */
/* 480 */	
			0x25,		/* FC_C_WSTRING */
			0x5c,		/* FC_PAD */
/* 482 */	
			0x15,		/* FC_STRUCT */
			0x3,		/* 3 */
/* 484 */	NdrFcShort( 0x14 ),	/* 20 */
/* 486 */	0x8,		/* FC_LONG */
			0x4c,		/* FC_EMBEDDED_COMPLEX */
/* 488 */	0x0,		/* 0 */
			NdrFcShort( 0xfffffe37 ),	/* Offset= -457 (32) */
			0x5b,		/* FC_END */
/* 492 */	0xb5,		/* FC_PIPE */
			0x3,		/* 3 */
/* 494 */	NdrFcShort( 0xfffffff4 ),	/* Offset= -12 (482) */
/* 496 */	NdrFcShort( 0x14 ),	/* 20 */
/* 498 */	NdrFcShort( 0x14 ),	/* 20 */
/* 500 */	0xb5,		/* FC_PIPE */
			0x3,		/* 3 */
/* 502 */	NdrFcShort( 0xffffffa2 ),	/* Offset= -94 (408) */
/* 504 */	NdrFcShort( 0x54 ),	/* 84 */
/* 506 */	NdrFcShort( 0x54 ),	/* 84 */
/* 508 */	
			0x11, 0x0,	/* FC_RP */
/* 510 */	NdrFcShort( 0x2 ),	/* Offset= 2 (512) */
/* 512 */	
			0x1b,		/* FC_CARRAY */
			0x3,		/* 3 */
/* 514 */	NdrFcShort( 0x10 ),	/* 16 */
/* 516 */	0x29,		/* Corr desc:  parameter, FC_ULONG */
			0x0,		/*  */
/* 518 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 520 */	NdrFcShort( 0x1 ),	/* Corr flags:  early, */
/* 522 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 524 */	NdrFcShort( 0xfffffe14 ),	/* Offset= -492 (32) */
/* 526 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 528 */	
			0x11, 0x0,	/* FC_RP */
/* 530 */	NdrFcShort( 0xffffff3c ),	/* Offset= -196 (334) */
/* 532 */	
			0x11, 0x4,	/* FC_RP [alloced_on_stack] */
/* 534 */	NdrFcShort( 0xffffff38 ),	/* Offset= -200 (334) */
/* 536 */	
			0x11, 0x8,	/* FC_RP [simple_pointer] */
/* 538 */	0x8,		/* FC_LONG */
			0x5c,		/* FC_PAD */
/* 540 */	
			0x11, 0x0,	/* FC_RP */
/* 542 */	NdrFcShort( 0x2 ),	/* Offset= 2 (544) */
/* 544 */	
			0x25,		/* FC_C_WSTRING */
			0x44,		/* FC_STRING_SIZED */
/* 546 */	0x29,		/* Corr desc:  parameter, FC_ULONG */
			0x54,		/* FC_DEREFERENCE */
/* 548 */	NdrFcShort( 0x28 ),	/* x86 Stack size/offset = 40 */
/* 550 */	NdrFcShort( 0x1 ),	/* Corr flags:  early, */
/* 552 */	
			0x11, 0x0,	/* FC_RP */
/* 554 */	NdrFcShort( 0x2 ),	/* Offset= 2 (556) */
/* 556 */	
			0x25,		/* FC_C_WSTRING */
			0x44,		/* FC_STRING_SIZED */
/* 558 */	0x40,		/* Corr desc:  constant, val=262 */
			0x0,		/* 0 */
/* 560 */	NdrFcShort( 0x106 ),	/* 262 */
/* 562 */	NdrFcShort( 0x0 ),	/* Corr flags:  */
/* 564 */	
			0x11, 0x0,	/* FC_RP */
/* 566 */	NdrFcShort( 0x92 ),	/* Offset= 146 (712) */
/* 568 */	
			0x2b,		/* FC_NON_ENCAPSULATED_UNION */
			0x8,		/* FC_LONG */
/* 570 */	0x8,		/* Corr desc: FC_LONG */
			0x0,		/*  */
/* 572 */	NdrFcShort( 0xfff8 ),	/* -8 */
/* 574 */	NdrFcShort( 0x1 ),	/* Corr flags:  early, */
/* 576 */	NdrFcShort( 0x2 ),	/* Offset= 2 (578) */
/* 578 */	NdrFcShort( 0xc8 ),	/* 200 */
/* 580 */	NdrFcShort( 0x9 ),	/* 9 */
/* 582 */	NdrFcLong( 0x0 ),	/* 0 */
/* 586 */	NdrFcShort( 0xfffffe58 ),	/* Offset= -424 (162) */
/* 588 */	NdrFcLong( 0x1 ),	/* 1 */
/* 592 */	NdrFcShort( 0xfffffe86 ),	/* Offset= -378 (214) */
/* 594 */	NdrFcLong( 0x2 ),	/* 2 */
/* 598 */	NdrFcShort( 0xfffffec8 ),	/* Offset= -312 (286) */
/* 600 */	NdrFcLong( 0x3 ),	/* 3 */
/* 604 */	NdrFcShort( 0xffffff28 ),	/* Offset= -216 (388) */
/* 606 */	NdrFcLong( 0x4 ),	/* 4 */
/* 610 */	NdrFcShort( 0xfffffebc ),	/* Offset= -324 (286) */
/* 612 */	NdrFcLong( 0x5 ),	/* 5 */
/* 616 */	NdrFcShort( 0x1e ),	/* Offset= 30 (646) */
/* 618 */	NdrFcLong( 0x6 ),	/* 6 */
/* 622 */	NdrFcShort( 0xffffff4c ),	/* Offset= -180 (442) */
/* 624 */	NdrFcLong( 0x7 ),	/* 7 */
/* 628 */	NdrFcShort( 0xfffffd8e ),	/* Offset= -626 (2) */
/* 630 */	NdrFcLong( 0x8 ),	/* 8 */
/* 634 */	NdrFcShort( 0x8008 ),	/* Simple arm type: FC_LONG */
/* 636 */	NdrFcShort( 0xffffffff ),	/* Offset= -1 (635) */
/* 638 */	
			0x15,		/* FC_STRUCT */
			0x3,		/* 3 */
/* 640 */	NdrFcShort( 0xc ),	/* 12 */
/* 642 */	0x8,		/* FC_LONG */
			0x8,		/* FC_LONG */
/* 644 */	0x8,		/* FC_LONG */
			0x5b,		/* FC_END */
/* 646 */	
			0x15,		/* FC_STRUCT */
			0x3,		/* 3 */
/* 648 */	NdrFcShort( 0xc8 ),	/* 200 */
/* 650 */	0x8,		/* FC_LONG */
			0x8,		/* FC_LONG */
/* 652 */	0x8,		/* FC_LONG */
			0x8,		/* FC_LONG */
/* 654 */	0x8,		/* FC_LONG */
			0x8,		/* FC_LONG */
/* 656 */	0x8,		/* FC_LONG */
			0x8,		/* FC_LONG */
/* 658 */	0x8,		/* FC_LONG */
			0x8,		/* FC_LONG */
/* 660 */	0x8,		/* FC_LONG */
			0x8,		/* FC_LONG */
/* 662 */	0x8,		/* FC_LONG */
			0x8,		/* FC_LONG */
/* 664 */	0x8,		/* FC_LONG */
			0x8,		/* FC_LONG */
/* 666 */	0x8,		/* FC_LONG */
			0x8,		/* FC_LONG */
/* 668 */	0x8,		/* FC_LONG */
			0x8,		/* FC_LONG */
/* 670 */	0x8,		/* FC_LONG */
			0x8,		/* FC_LONG */
/* 672 */	0x8,		/* FC_LONG */
			0x8,		/* FC_LONG */
/* 674 */	0x8,		/* FC_LONG */
			0x8,		/* FC_LONG */
/* 676 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 678 */	NdrFcShort( 0xfffffd5c ),	/* Offset= -676 (2) */
/* 680 */	0x8,		/* FC_LONG */
			0x8,		/* FC_LONG */
/* 682 */	0x8,		/* FC_LONG */
			0x8,		/* FC_LONG */
/* 684 */	0x8,		/* FC_LONG */
			0x4c,		/* FC_EMBEDDED_COMPLEX */
/* 686 */	0x0,		/* 0 */
			NdrFcShort( 0xfffffd53 ),	/* Offset= -685 (2) */
			0x8,		/* FC_LONG */
/* 690 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 692 */	NdrFcShort( 0xfffffd4e ),	/* Offset= -690 (2) */
/* 694 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 696 */	NdrFcShort( 0xfffffd4a ),	/* Offset= -694 (2) */
/* 698 */	0x8,		/* FC_LONG */
			0x8,		/* FC_LONG */
/* 700 */	0x8,		/* FC_LONG */
			0x8,		/* FC_LONG */
/* 702 */	0x8,		/* FC_LONG */
			0x6,		/* FC_SHORT */
/* 704 */	0x6,		/* FC_SHORT */
			0x6,		/* FC_SHORT */
/* 706 */	0x6,		/* FC_SHORT */
			0x4c,		/* FC_EMBEDDED_COMPLEX */
/* 708 */	0x0,		/* 0 */
			NdrFcShort( 0xffffffb9 ),	/* Offset= -71 (638) */
			0x5b,		/* FC_END */
/* 712 */	
			0x1a,		/* FC_BOGUS_STRUCT */
			0x3,		/* 3 */
/* 714 */	NdrFcShort( 0xd4 ),	/* 212 */
/* 716 */	NdrFcShort( 0x0 ),	/* 0 */
/* 718 */	NdrFcShort( 0xa ),	/* Offset= 10 (728) */
/* 720 */	0xe,		/* FC_ENUM32 */
			0xe,		/* FC_ENUM32 */
/* 722 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 724 */	NdrFcShort( 0xffffff64 ),	/* Offset= -156 (568) */
/* 726 */	0x36,		/* FC_POINTER */
			0x5b,		/* FC_END */
/* 728 */	
			0x12, 0x8,	/* FC_UP [simple_pointer] */
/* 730 */	
			0x25,		/* FC_C_WSTRING */
			0x5c,		/* FC_PAD */
/* 732 */	
			0x11, 0x0,	/* FC_RP */
/* 734 */	NdrFcShort( 0x2 ),	/* Offset= 2 (736) */
/* 736 */	
			0x25,		/* FC_C_WSTRING */
			0x44,		/* FC_STRING_SIZED */
/* 738 */	0x40,		/* Corr desc:  constant, val=262 */
			0x0,		/* 0 */
/* 740 */	NdrFcShort( 0x106 ),	/* 262 */
/* 742 */	NdrFcShort( 0x0 ),	/* Corr flags:  */

			0x0
        }
    };

static const unsigned short trkwks_FormatStringOffsetTable[] =
    {
    0,
    70,
    128,
    168,
    214,
    248,
    300,
    352,
    398,
    432,
    520,
    584,
    624
    };


static const MIDL_STUB_DESC trkwks_StubDesc = 
    {
    (void *)& trkwks___RpcServerInterface,
    MIDL_user_allocate,
    MIDL_user_free,
    0,
    0,
    0,
    0,
    0,
    __MIDL_TypeFormatString.Format,
    1, /* -error bounds_check flag */
    0x50002, /* Ndr library version */
    0,
    0x600015b, /* MIDL Version 6.0.347 */
    0,
    0,
    0,  /* notify & notify_flag routine table */
    0x1, /* MIDL flag */
    0, /* cs routines */
    0,   /* proxy/server info */
    0   /* Reserved5 */
    };

static RPC_DISPATCH_FUNCTION trkwks_table[] =
    {
    NdrServerCall2,
    NdrServerCall2,
    NdrServerCall2,
    NdrServerCall2,
    NdrServerCall2,
    NdrServerCall2,
    NdrServerCall2,
    NdrServerCall2,
    NdrServerCall2,
    NdrAsyncServerCall,
    NdrServerCall2,
    NdrServerCall2,
    NdrServerCall2,
    0
    };
RPC_DISPATCH_TABLE trkwks_v1_2_DispatchTable = 
    {
    13,
    trkwks_table
    };

static const SERVER_ROUTINE trkwks_ServerRoutineTable[] = 
    {
    (SERVER_ROUTINE)Stubold_LnkMendLink,
    (SERVER_ROUTINE)Stubold_LnkSearchMachine,
    (SERVER_ROUTINE)Stubold_LnkCallSvrMessage,
    (SERVER_ROUTINE)StubLnkSetVolumeId,
    (SERVER_ROUTINE)StubLnkRestartDcSynchronization,
    (SERVER_ROUTINE)StubGetVolumeTrackingInformation,
    (SERVER_ROUTINE)StubGetFileTrackingInformation,
    (SERVER_ROUTINE)StubTriggerVolumeClaims,
    (SERVER_ROUTINE)StubLnkOnRestore,
    (SERVER_ROUTINE)StubLnkMendLink,
    (SERVER_ROUTINE)Stubold2_LnkSearchMachine,
    (SERVER_ROUTINE)StubLnkCallSvrMessage,
    (SERVER_ROUTINE)StubLnkSearchMachine
    };

static const MIDL_SERVER_INFO trkwks_ServerInfo = 
    {
    &trkwks_StubDesc,
    trkwks_ServerRoutineTable,
    __MIDL_ProcFormatString.Format,
    trkwks_FormatStringOffsetTable,
    0,
    0,
    0,
    0};


#endif /* !defined(_M_IA64) && !defined(_M_AMD64)*/


#pragma warning( disable: 4049 )  /* more than 64k source lines */

/* this ALWAYS GENERATED file contains the RPC server stubs */


 /* File created by MIDL compiler version 6.00.0347 */
/* Compiler settings for trkwks.idl:
    Oicf, W1, Zp8, env=Win64 (32b run,appending)
    protocol : dce , ms_ext, c_ext, robust
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )

#if defined(_M_IA64) || defined(_M_AMD64)
#include <string.h>
#include "trkwks.h"

#define TYPE_FORMAT_STRING_SIZE   727                               
#define PROC_FORMAT_STRING_SIZE   727                               
#define TRANSMIT_AS_TABLE_SIZE    0            
#define WIRE_MARSHAL_TABLE_SIZE   0            

typedef struct _MIDL_TYPE_FORMAT_STRING
    {
    short          Pad;
    unsigned char  Format[ TYPE_FORMAT_STRING_SIZE ];
    } MIDL_TYPE_FORMAT_STRING;

typedef struct _MIDL_PROC_FORMAT_STRING
    {
    short          Pad;
    unsigned char  Format[ PROC_FORMAT_STRING_SIZE ];
    } MIDL_PROC_FORMAT_STRING;


static RPC_SYNTAX_IDENTIFIER  _RpcTransferSyntax = 
{{0x8A885D04,0x1CEB,0x11C9,{0x9F,0xE8,0x08,0x00,0x2B,0x10,0x48,0x60}},{2,0}};

extern const MIDL_TYPE_FORMAT_STRING __MIDL_TypeFormatString;
extern const MIDL_PROC_FORMAT_STRING __MIDL_ProcFormatString;

/* Standard interface: __MIDL_itf_trkwks_0000, ver. 0.0,
   GUID={0x00000000,0x0000,0x0000,{0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00}} */


/* Standard interface: trkwks, ver. 1.2,
   GUID={0x300f3532,0x38cc,0x11d0,{0xa3,0xf0,0x00,0x20,0xaf,0x6b,0x0a,0xdd}} */


extern const MIDL_SERVER_INFO trkwks_ServerInfo;

extern RPC_DISPATCH_TABLE trkwks_v1_2_DispatchTable;

static const RPC_SERVER_INTERFACE trkwks___RpcServerInterface =
    {
    sizeof(RPC_SERVER_INTERFACE),
    {{0x300f3532,0x38cc,0x11d0,{0xa3,0xf0,0x00,0x20,0xaf,0x6b,0x0a,0xdd}},{1,2}},
    {{0x8A885D04,0x1CEB,0x11C9,{0x9F,0xE8,0x08,0x00,0x2B,0x10,0x48,0x60}},{2,0}},
    &trkwks_v1_2_DispatchTable,
    0,
    0,
    0,
    &trkwks_ServerInfo,
    0x04000001
    };
RPC_IF_HANDLE Stubtrkwks_v1_2_s_ifspec = (RPC_IF_HANDLE)& trkwks___RpcServerInterface;

extern const MIDL_STUB_DESC trkwks_StubDesc;


#if !defined(__RPC_WIN64__)
#error  Invalid build platform for this stub.
#endif

static const MIDL_PROC_FORMAT_STRING __MIDL_ProcFormatString =
    {
        0,
        {

	/* Procedure old_LnkMendLink */

			0x0,		/* 0 */
			0x48,		/* Old Flags:  */
/*  2 */	NdrFcLong( 0x0 ),	/* 0 */
/*  6 */	NdrFcShort( 0x0 ),	/* 0 */
/*  8 */	NdrFcShort( 0x40 ),	/* ia64 Stack size/offset = 64 */
/* 10 */	0x32,		/* FC_BIND_PRIMITIVE */
			0x0,		/* 0 */
/* 12 */	NdrFcShort( 0x0 ),	/* ia64 Stack size/offset = 0 */
/* 14 */	NdrFcShort( 0x168 ),	/* 360 */
/* 16 */	NdrFcShort( 0xac ),	/* 172 */
/* 18 */	0x45,		/* Oi2 Flags:  srv must size, has return, has ext, */
			0x7,		/* 7 */
/* 20 */	0xa,		/* 10 */
			0x1,		/* Ext Flags:  new corr desc, */
/* 22 */	NdrFcShort( 0x0 ),	/* 0 */
/* 24 */	NdrFcShort( 0x0 ),	/* 0 */
/* 26 */	NdrFcShort( 0x0 ),	/* 0 */
/* 28 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter IDL_handle */

/* 30 */	NdrFcShort( 0x8a ),	/* Flags:  must free, in, by val, */
/* 32 */	NdrFcShort( 0x8 ),	/* ia64 Stack size/offset = 8 */
/* 34 */	NdrFcShort( 0x2 ),	/* Type Offset=2 */

	/* Parameter ftLimit */

/* 36 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 38 */	NdrFcShort( 0x10 ),	/* ia64 Stack size/offset = 16 */
/* 40 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter Restrictions */

/* 42 */	NdrFcShort( 0x10a ),	/* Flags:  must free, in, simple ref, */
/* 44 */	NdrFcShort( 0x18 ),	/* ia64 Stack size/offset = 24 */
/* 46 */	NdrFcShort( 0x2a ),	/* Type Offset=42 */

	/* Parameter pdroidBirth */

/* 48 */	NdrFcShort( 0x10a ),	/* Flags:  must free, in, simple ref, */
/* 50 */	NdrFcShort( 0x20 ),	/* ia64 Stack size/offset = 32 */
/* 52 */	NdrFcShort( 0x2a ),	/* Type Offset=42 */

	/* Parameter pdroidLast */

/* 54 */	NdrFcShort( 0x8112 ),	/* Flags:  must free, out, simple ref, srv alloc size=32 */
/* 56 */	NdrFcShort( 0x28 ),	/* ia64 Stack size/offset = 40 */
/* 58 */	NdrFcShort( 0x2a ),	/* Type Offset=42 */

	/* Parameter pdroidCurrent */

/* 60 */	NdrFcShort( 0x13 ),	/* Flags:  must size, must free, out, */
/* 62 */	NdrFcShort( 0x30 ),	/* ia64 Stack size/offset = 48 */
/* 64 */	NdrFcShort( 0x3c ),	/* Type Offset=60 */

	/* Parameter wsz */

/* 66 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 68 */	NdrFcShort( 0x38 ),	/* ia64 Stack size/offset = 56 */
/* 70 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure old_LnkSearchMachine */


	/* Return value */

/* 72 */	0x0,		/* 0 */
			0x48,		/* Old Flags:  */
/* 74 */	NdrFcLong( 0x0 ),	/* 0 */
/* 78 */	NdrFcShort( 0x1 ),	/* 1 */
/* 80 */	NdrFcShort( 0x30 ),	/* ia64 Stack size/offset = 48 */
/* 82 */	0x32,		/* FC_BIND_PRIMITIVE */
			0x0,		/* 0 */
/* 84 */	NdrFcShort( 0x0 ),	/* ia64 Stack size/offset = 0 */
/* 86 */	NdrFcShort( 0xac ),	/* 172 */
/* 88 */	NdrFcShort( 0xac ),	/* 172 */
/* 90 */	0x45,		/* Oi2 Flags:  srv must size, has return, has ext, */
			0x5,		/* 5 */
/* 92 */	0xa,		/* 10 */
			0x1,		/* Ext Flags:  new corr desc, */
/* 94 */	NdrFcShort( 0x0 ),	/* 0 */
/* 96 */	NdrFcShort( 0x0 ),	/* 0 */
/* 98 */	NdrFcShort( 0x0 ),	/* 0 */
/* 100 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter IDL_handle */

/* 102 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 104 */	NdrFcShort( 0x8 ),	/* ia64 Stack size/offset = 8 */
/* 106 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter Restrictions */

/* 108 */	NdrFcShort( 0x10a ),	/* Flags:  must free, in, simple ref, */
/* 110 */	NdrFcShort( 0x10 ),	/* ia64 Stack size/offset = 16 */
/* 112 */	NdrFcShort( 0x2a ),	/* Type Offset=42 */

	/* Parameter pdroidLast */

/* 114 */	NdrFcShort( 0x8112 ),	/* Flags:  must free, out, simple ref, srv alloc size=32 */
/* 116 */	NdrFcShort( 0x18 ),	/* ia64 Stack size/offset = 24 */
/* 118 */	NdrFcShort( 0x2a ),	/* Type Offset=42 */

	/* Parameter pdroidReferral */

/* 120 */	NdrFcShort( 0x13 ),	/* Flags:  must size, must free, out, */
/* 122 */	NdrFcShort( 0x20 ),	/* ia64 Stack size/offset = 32 */
/* 124 */	NdrFcShort( 0x3c ),	/* Type Offset=60 */

	/* Parameter tsz */

/* 126 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 128 */	NdrFcShort( 0x28 ),	/* ia64 Stack size/offset = 40 */
/* 130 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure old_LnkCallSvrMessage */


	/* Return value */

/* 132 */	0x0,		/* 0 */
			0x48,		/* Old Flags:  */
/* 134 */	NdrFcLong( 0x0 ),	/* 0 */
/* 138 */	NdrFcShort( 0x2 ),	/* 2 */
/* 140 */	NdrFcShort( 0x18 ),	/* ia64 Stack size/offset = 24 */
/* 142 */	0x32,		/* FC_BIND_PRIMITIVE */
			0x0,		/* 0 */
/* 144 */	NdrFcShort( 0x0 ),	/* ia64 Stack size/offset = 0 */
/* 146 */	NdrFcShort( 0x0 ),	/* 0 */
/* 148 */	NdrFcShort( 0x8 ),	/* 8 */
/* 150 */	0x47,		/* Oi2 Flags:  srv must size, clt must size, has return, has ext, */
			0x2,		/* 2 */
/* 152 */	0xa,		/* 10 */
			0x7,		/* Ext Flags:  new corr desc, clt corr check, srv corr check, */
/* 154 */	NdrFcShort( 0xb ),	/* 11 */
/* 156 */	NdrFcShort( 0xb ),	/* 11 */
/* 158 */	NdrFcShort( 0x0 ),	/* 0 */
/* 160 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter IDL_handle */

/* 162 */	NdrFcShort( 0x11b ),	/* Flags:  must size, must free, in, out, simple ref, */
/* 164 */	NdrFcShort( 0x8 ),	/* ia64 Stack size/offset = 8 */
/* 166 */	NdrFcShort( 0x1bc ),	/* Type Offset=444 */

	/* Parameter pMsg */

/* 168 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 170 */	NdrFcShort( 0x10 ),	/* ia64 Stack size/offset = 16 */
/* 172 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure LnkSetVolumeId */


	/* Return value */

/* 174 */	0x0,		/* 0 */
			0x48,		/* Old Flags:  */
/* 176 */	NdrFcLong( 0x0 ),	/* 0 */
/* 180 */	NdrFcShort( 0x3 ),	/* 3 */
/* 182 */	NdrFcShort( 0x28 ),	/* ia64 Stack size/offset = 40 */
/* 184 */	0x32,		/* FC_BIND_PRIMITIVE */
			0x0,		/* 0 */
/* 186 */	NdrFcShort( 0x0 ),	/* ia64 Stack size/offset = 0 */
/* 188 */	NdrFcShort( 0x48 ),	/* 72 */
/* 190 */	NdrFcShort( 0x8 ),	/* 8 */
/* 192 */	0x44,		/* Oi2 Flags:  has return, has ext, */
			0x3,		/* 3 */
/* 194 */	0xa,		/* 10 */
			0x1,		/* Ext Flags:  new corr desc, */
/* 196 */	NdrFcShort( 0x0 ),	/* 0 */
/* 198 */	NdrFcShort( 0x0 ),	/* 0 */
/* 200 */	NdrFcShort( 0x0 ),	/* 0 */
/* 202 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter IDL_handle */

/* 204 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 206 */	NdrFcShort( 0x8 ),	/* ia64 Stack size/offset = 8 */
/* 208 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter volumeIndex */

/* 210 */	NdrFcShort( 0x8a ),	/* Flags:  must free, in, by val, */
/* 212 */	NdrFcShort( 0x10 ),	/* ia64 Stack size/offset = 16 */
/* 214 */	NdrFcShort( 0x20 ),	/* Type Offset=32 */

	/* Parameter VolId */

/* 216 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 218 */	NdrFcShort( 0x20 ),	/* ia64 Stack size/offset = 32 */
/* 220 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure LnkRestartDcSynchronization */


	/* Return value */

/* 222 */	0x0,		/* 0 */
			0x48,		/* Old Flags:  */
/* 224 */	NdrFcLong( 0x0 ),	/* 0 */
/* 228 */	NdrFcShort( 0x4 ),	/* 4 */
/* 230 */	NdrFcShort( 0x10 ),	/* ia64 Stack size/offset = 16 */
/* 232 */	0x32,		/* FC_BIND_PRIMITIVE */
			0x0,		/* 0 */
/* 234 */	NdrFcShort( 0x0 ),	/* ia64 Stack size/offset = 0 */
/* 236 */	NdrFcShort( 0x0 ),	/* 0 */
/* 238 */	NdrFcShort( 0x8 ),	/* 8 */
/* 240 */	0x44,		/* Oi2 Flags:  has return, has ext, */
			0x1,		/* 1 */
/* 242 */	0xa,		/* 10 */
			0x1,		/* Ext Flags:  new corr desc, */
/* 244 */	NdrFcShort( 0x0 ),	/* 0 */
/* 246 */	NdrFcShort( 0x0 ),	/* 0 */
/* 248 */	NdrFcShort( 0x0 ),	/* 0 */
/* 250 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter IDL_handle */

/* 252 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 254 */	NdrFcShort( 0x8 ),	/* ia64 Stack size/offset = 8 */
/* 256 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure GetVolumeTrackingInformation */


	/* Return value */

/* 258 */	0x0,		/* 0 */
			0x48,		/* Old Flags:  */
/* 260 */	NdrFcLong( 0x0 ),	/* 0 */
/* 264 */	NdrFcShort( 0x5 ),	/* 5 */
/* 266 */	NdrFcShort( 0x48 ),	/* ia64 Stack size/offset = 72 */
/* 268 */	0x32,		/* FC_BIND_PRIMITIVE */
			0x0,		/* 0 */
/* 270 */	NdrFcShort( 0x0 ),	/* ia64 Stack size/offset = 0 */
/* 272 */	NdrFcShort( 0x48 ),	/* 72 */
/* 274 */	NdrFcShort( 0x8 ),	/* 8 */
/* 276 */	0x4c,		/* Oi2 Flags:  has return, has pipes, has ext, */
			0x4,		/* 4 */
/* 278 */	0xa,		/* 10 */
			0x1,		/* Ext Flags:  new corr desc, */
/* 280 */	NdrFcShort( 0x0 ),	/* 0 */
/* 282 */	NdrFcShort( 0x0 ),	/* 0 */
/* 284 */	NdrFcShort( 0x0 ),	/* 0 */
/* 286 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter IDL_handle */

/* 288 */	NdrFcShort( 0x8a ),	/* Flags:  must free, in, by val, */
/* 290 */	NdrFcShort( 0x8 ),	/* ia64 Stack size/offset = 8 */
/* 292 */	NdrFcShort( 0x20 ),	/* Type Offset=32 */

	/* Parameter volid */

/* 294 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 296 */	NdrFcShort( 0x18 ),	/* ia64 Stack size/offset = 24 */
/* 298 */	0xe,		/* FC_ENUM32 */
			0x0,		/* 0 */

	/* Parameter scope */

/* 300 */	NdrFcShort( 0x14 ),	/* Flags:  pipe, out, */
/* 302 */	NdrFcShort( 0x20 ),	/* ia64 Stack size/offset = 32 */
/* 304 */	NdrFcShort( 0x1da ),	/* Type Offset=474 */

	/* Parameter pipeVolInfo */

/* 306 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 308 */	NdrFcShort( 0x40 ),	/* ia64 Stack size/offset = 64 */
/* 310 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure GetFileTrackingInformation */


	/* Return value */

/* 312 */	0x0,		/* 0 */
			0x48,		/* Old Flags:  */
/* 314 */	NdrFcLong( 0x0 ),	/* 0 */
/* 318 */	NdrFcShort( 0x6 ),	/* 6 */
/* 320 */	NdrFcShort( 0x58 ),	/* ia64 Stack size/offset = 88 */
/* 322 */	0x32,		/* FC_BIND_PRIMITIVE */
			0x0,		/* 0 */
/* 324 */	NdrFcShort( 0x0 ),	/* ia64 Stack size/offset = 0 */
/* 326 */	NdrFcShort( 0x98 ),	/* 152 */
/* 328 */	NdrFcShort( 0x8 ),	/* 8 */
/* 330 */	0x4c,		/* Oi2 Flags:  has return, has pipes, has ext, */
			0x4,		/* 4 */
/* 332 */	0xa,		/* 10 */
			0x1,		/* Ext Flags:  new corr desc, */
/* 334 */	NdrFcShort( 0x0 ),	/* 0 */
/* 336 */	NdrFcShort( 0x0 ),	/* 0 */
/* 338 */	NdrFcShort( 0x0 ),	/* 0 */
/* 340 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter IDL_handle */

/* 342 */	NdrFcShort( 0x8a ),	/* Flags:  must free, in, by val, */
/* 344 */	NdrFcShort( 0x8 ),	/* ia64 Stack size/offset = 8 */
/* 346 */	NdrFcShort( 0x2a ),	/* Type Offset=42 */

	/* Parameter droidCurrent */

/* 348 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 350 */	NdrFcShort( 0x28 ),	/* ia64 Stack size/offset = 40 */
/* 352 */	0xe,		/* FC_ENUM32 */
			0x0,		/* 0 */

	/* Parameter scope */

/* 354 */	NdrFcShort( 0x14 ),	/* Flags:  pipe, out, */
/* 356 */	NdrFcShort( 0x30 ),	/* ia64 Stack size/offset = 48 */
/* 358 */	NdrFcShort( 0x1e2 ),	/* Type Offset=482 */

	/* Parameter pipeFileInfo */

/* 360 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 362 */	NdrFcShort( 0x50 ),	/* ia64 Stack size/offset = 80 */
/* 364 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure TriggerVolumeClaims */


	/* Return value */

/* 366 */	0x0,		/* 0 */
			0x48,		/* Old Flags:  */
/* 368 */	NdrFcLong( 0x0 ),	/* 0 */
/* 372 */	NdrFcShort( 0x7 ),	/* 7 */
/* 374 */	NdrFcShort( 0x20 ),	/* ia64 Stack size/offset = 32 */
/* 376 */	0x32,		/* FC_BIND_PRIMITIVE */
			0x0,		/* 0 */
/* 378 */	NdrFcShort( 0x0 ),	/* ia64 Stack size/offset = 0 */
/* 380 */	NdrFcShort( 0x8 ),	/* 8 */
/* 382 */	NdrFcShort( 0x8 ),	/* 8 */
/* 384 */	0x46,		/* Oi2 Flags:  clt must size, has return, has ext, */
			0x3,		/* 3 */
/* 386 */	0xa,		/* 10 */
			0x5,		/* Ext Flags:  new corr desc, srv corr check, */
/* 388 */	NdrFcShort( 0x0 ),	/* 0 */
/* 390 */	NdrFcShort( 0x1 ),	/* 1 */
/* 392 */	NdrFcShort( 0x0 ),	/* 0 */
/* 394 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter IDL_handle */

/* 396 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 398 */	NdrFcShort( 0x8 ),	/* ia64 Stack size/offset = 8 */
/* 400 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter cVolumes */

/* 402 */	NdrFcShort( 0x10b ),	/* Flags:  must size, must free, in, simple ref, */
/* 404 */	NdrFcShort( 0x10 ),	/* ia64 Stack size/offset = 16 */
/* 406 */	NdrFcShort( 0x1ee ),	/* Type Offset=494 */

	/* Parameter rgvolid */

/* 408 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 410 */	NdrFcShort( 0x18 ),	/* ia64 Stack size/offset = 24 */
/* 412 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure LnkOnRestore */


	/* Return value */

/* 414 */	0x0,		/* 0 */
			0x48,		/* Old Flags:  */
/* 416 */	NdrFcLong( 0x0 ),	/* 0 */
/* 420 */	NdrFcShort( 0x8 ),	/* 8 */
/* 422 */	NdrFcShort( 0x10 ),	/* ia64 Stack size/offset = 16 */
/* 424 */	0x32,		/* FC_BIND_PRIMITIVE */
			0x0,		/* 0 */
/* 426 */	NdrFcShort( 0x0 ),	/* ia64 Stack size/offset = 0 */
/* 428 */	NdrFcShort( 0x0 ),	/* 0 */
/* 430 */	NdrFcShort( 0x8 ),	/* 8 */
/* 432 */	0x44,		/* Oi2 Flags:  has return, has ext, */
			0x1,		/* 1 */
/* 434 */	0xa,		/* 10 */
			0x1,		/* Ext Flags:  new corr desc, */
/* 436 */	NdrFcShort( 0x0 ),	/* 0 */
/* 438 */	NdrFcShort( 0x0 ),	/* 0 */
/* 440 */	NdrFcShort( 0x0 ),	/* 0 */
/* 442 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter IDL_handle */

/* 444 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 446 */	NdrFcShort( 0x8 ),	/* ia64 Stack size/offset = 8 */
/* 448 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure LnkMendLink */


	/* Return value */

/* 450 */	0x0,		/* 0 */
			0x48,		/* Old Flags:  */
/* 452 */	NdrFcLong( 0x0 ),	/* 0 */
/* 456 */	NdrFcShort( 0x9 ),	/* 9 */
/* 458 */	NdrFcShort( 0x60 ),	/* ia64 Stack size/offset = 96 */
/* 460 */	0x32,		/* FC_BIND_PRIMITIVE */
			0x0,		/* 0 */
/* 462 */	NdrFcShort( 0x8 ),	/* ia64 Stack size/offset = 8 */
/* 464 */	NdrFcShort( 0x1c8 ),	/* 456 */
/* 466 */	NdrFcShort( 0x10c ),	/* 268 */
/* 468 */	0xc5,		/* Oi2 Flags:  srv must size, has return, has ext, has async handle */
			0xa,		/* 10 */
/* 470 */	0xa,		/* 10 */
			0x3,		/* Ext Flags:  new corr desc, clt corr check, */
/* 472 */	NdrFcShort( 0x1 ),	/* 1 */
/* 474 */	NdrFcShort( 0x0 ),	/* 0 */
/* 476 */	NdrFcShort( 0x0 ),	/* 0 */
/* 478 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter IDL_handle */

/* 480 */	NdrFcShort( 0x8a ),	/* Flags:  must free, in, by val, */
/* 482 */	NdrFcShort( 0x10 ),	/* ia64 Stack size/offset = 16 */
/* 484 */	NdrFcShort( 0x2 ),	/* Type Offset=2 */

	/* Parameter ftLimit */

/* 486 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 488 */	NdrFcShort( 0x18 ),	/* ia64 Stack size/offset = 24 */
/* 490 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter Restrictions */

/* 492 */	NdrFcShort( 0x10a ),	/* Flags:  must free, in, simple ref, */
/* 494 */	NdrFcShort( 0x20 ),	/* ia64 Stack size/offset = 32 */
/* 496 */	NdrFcShort( 0x2a ),	/* Type Offset=42 */

	/* Parameter pdroidBirth */

/* 498 */	NdrFcShort( 0x10a ),	/* Flags:  must free, in, simple ref, */
/* 500 */	NdrFcShort( 0x28 ),	/* ia64 Stack size/offset = 40 */
/* 502 */	NdrFcShort( 0x2a ),	/* Type Offset=42 */

	/* Parameter pdroidLast */

/* 504 */	NdrFcShort( 0x10a ),	/* Flags:  must free, in, simple ref, */
/* 506 */	NdrFcShort( 0x30 ),	/* ia64 Stack size/offset = 48 */
/* 508 */	NdrFcShort( 0x12c ),	/* Type Offset=300 */

	/* Parameter pmcidLast */

/* 510 */	NdrFcShort( 0x8112 ),	/* Flags:  must free, out, simple ref, srv alloc size=32 */
/* 512 */	NdrFcShort( 0x38 ),	/* ia64 Stack size/offset = 56 */
/* 514 */	NdrFcShort( 0x2a ),	/* Type Offset=42 */

	/* Parameter pdroidCurrent */

/* 516 */	NdrFcShort( 0x4112 ),	/* Flags:  must free, out, simple ref, srv alloc size=16 */
/* 518 */	NdrFcShort( 0x40 ),	/* ia64 Stack size/offset = 64 */
/* 520 */	NdrFcShort( 0x12c ),	/* Type Offset=300 */

	/* Parameter pmcidCurrent */

/* 522 */	NdrFcShort( 0x158 ),	/* Flags:  in, out, base type, simple ref, */
/* 524 */	NdrFcShort( 0x48 ),	/* ia64 Stack size/offset = 72 */
/* 526 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter pcbPath */

/* 528 */	NdrFcShort( 0x113 ),	/* Flags:  must size, must free, out, simple ref, */
/* 530 */	NdrFcShort( 0x50 ),	/* ia64 Stack size/offset = 80 */
/* 532 */	NdrFcShort( 0x20e ),	/* Type Offset=526 */

	/* Parameter pwszPath */

/* 534 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 536 */	NdrFcShort( 0x58 ),	/* ia64 Stack size/offset = 88 */
/* 538 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure old2_LnkSearchMachine */


	/* Return value */

/* 540 */	0x0,		/* 0 */
			0x48,		/* Old Flags:  */
/* 542 */	NdrFcLong( 0x0 ),	/* 0 */
/* 546 */	NdrFcShort( 0xa ),	/* 10 */
/* 548 */	NdrFcShort( 0x38 ),	/* ia64 Stack size/offset = 56 */
/* 550 */	0x32,		/* FC_BIND_PRIMITIVE */
			0x0,		/* 0 */
/* 552 */	NdrFcShort( 0x0 ),	/* ia64 Stack size/offset = 0 */
/* 554 */	NdrFcShort( 0xac ),	/* 172 */
/* 556 */	NdrFcShort( 0xf0 ),	/* 240 */
/* 558 */	0x45,		/* Oi2 Flags:  srv must size, has return, has ext, */
			0x6,		/* 6 */
/* 560 */	0xa,		/* 10 */
			0x3,		/* Ext Flags:  new corr desc, clt corr check, */
/* 562 */	NdrFcShort( 0x1 ),	/* 1 */
/* 564 */	NdrFcShort( 0x0 ),	/* 0 */
/* 566 */	NdrFcShort( 0x0 ),	/* 0 */
/* 568 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter IDL_handle */

/* 570 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 572 */	NdrFcShort( 0x8 ),	/* ia64 Stack size/offset = 8 */
/* 574 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter Restrictions */

/* 576 */	NdrFcShort( 0x10a ),	/* Flags:  must free, in, simple ref, */
/* 578 */	NdrFcShort( 0x10 ),	/* ia64 Stack size/offset = 16 */
/* 580 */	NdrFcShort( 0x2a ),	/* Type Offset=42 */

	/* Parameter pdroidLast */

/* 582 */	NdrFcShort( 0x8112 ),	/* Flags:  must free, out, simple ref, srv alloc size=32 */
/* 584 */	NdrFcShort( 0x18 ),	/* ia64 Stack size/offset = 24 */
/* 586 */	NdrFcShort( 0x2a ),	/* Type Offset=42 */

	/* Parameter pdroidNext */

/* 588 */	NdrFcShort( 0x4112 ),	/* Flags:  must free, out, simple ref, srv alloc size=16 */
/* 590 */	NdrFcShort( 0x20 ),	/* ia64 Stack size/offset = 32 */
/* 592 */	NdrFcShort( 0x12c ),	/* Type Offset=300 */

	/* Parameter pmcidNext */

/* 594 */	NdrFcShort( 0x113 ),	/* Flags:  must size, must free, out, simple ref, */
/* 596 */	NdrFcShort( 0x28 ),	/* ia64 Stack size/offset = 40 */
/* 598 */	NdrFcShort( 0x21a ),	/* Type Offset=538 */

	/* Parameter ptszPath */

/* 600 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 602 */	NdrFcShort( 0x30 ),	/* ia64 Stack size/offset = 48 */
/* 604 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure LnkCallSvrMessage */


	/* Return value */

/* 606 */	0x0,		/* 0 */
			0x48,		/* Old Flags:  */
/* 608 */	NdrFcLong( 0x0 ),	/* 0 */
/* 612 */	NdrFcShort( 0xb ),	/* 11 */
/* 614 */	NdrFcShort( 0x18 ),	/* ia64 Stack size/offset = 24 */
/* 616 */	0x32,		/* FC_BIND_PRIMITIVE */
			0x0,		/* 0 */
/* 618 */	NdrFcShort( 0x0 ),	/* ia64 Stack size/offset = 0 */
/* 620 */	NdrFcShort( 0x0 ),	/* 0 */
/* 622 */	NdrFcShort( 0x8 ),	/* 8 */
/* 624 */	0x47,		/* Oi2 Flags:  srv must size, clt must size, has return, has ext, */
			0x2,		/* 2 */
/* 626 */	0xa,		/* 10 */
			0x7,		/* Ext Flags:  new corr desc, clt corr check, srv corr check, */
/* 628 */	NdrFcShort( 0xb ),	/* 11 */
/* 630 */	NdrFcShort( 0xb ),	/* 11 */
/* 632 */	NdrFcShort( 0x0 ),	/* 0 */
/* 634 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter IDL_handle */

/* 636 */	NdrFcShort( 0x11b ),	/* Flags:  must size, must free, in, out, simple ref, */
/* 638 */	NdrFcShort( 0x8 ),	/* ia64 Stack size/offset = 8 */
/* 640 */	NdrFcShort( 0x2b6 ),	/* Type Offset=694 */

	/* Parameter pMsg */

/* 642 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 644 */	NdrFcShort( 0x10 ),	/* ia64 Stack size/offset = 16 */
/* 646 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure LnkSearchMachine */


	/* Return value */

/* 648 */	0x0,		/* 0 */
			0x48,		/* Old Flags:  */
/* 650 */	NdrFcLong( 0x0 ),	/* 0 */
/* 654 */	NdrFcShort( 0xc ),	/* 12 */
/* 656 */	NdrFcShort( 0x48 ),	/* ia64 Stack size/offset = 72 */
/* 658 */	0x32,		/* FC_BIND_PRIMITIVE */
			0x0,		/* 0 */
/* 660 */	NdrFcShort( 0x0 ),	/* ia64 Stack size/offset = 0 */
/* 662 */	NdrFcShort( 0x150 ),	/* 336 */
/* 664 */	NdrFcShort( 0x194 ),	/* 404 */
/* 666 */	0x45,		/* Oi2 Flags:  srv must size, has return, has ext, */
			0x8,		/* 8 */
/* 668 */	0xa,		/* 10 */
			0x3,		/* Ext Flags:  new corr desc, clt corr check, */
/* 670 */	NdrFcShort( 0x1 ),	/* 1 */
/* 672 */	NdrFcShort( 0x0 ),	/* 0 */
/* 674 */	NdrFcShort( 0x0 ),	/* 0 */
/* 676 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter IDL_handle */

/* 678 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 680 */	NdrFcShort( 0x8 ),	/* ia64 Stack size/offset = 8 */
/* 682 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter Restrictions */

/* 684 */	NdrFcShort( 0x10a ),	/* Flags:  must free, in, simple ref, */
/* 686 */	NdrFcShort( 0x10 ),	/* ia64 Stack size/offset = 16 */
/* 688 */	NdrFcShort( 0x2a ),	/* Type Offset=42 */

	/* Parameter pdroidBirthLast */

/* 690 */	NdrFcShort( 0x10a ),	/* Flags:  must free, in, simple ref, */
/* 692 */	NdrFcShort( 0x18 ),	/* ia64 Stack size/offset = 24 */
/* 694 */	NdrFcShort( 0x2a ),	/* Type Offset=42 */

	/* Parameter pdroidLast */

/* 696 */	NdrFcShort( 0x8112 ),	/* Flags:  must free, out, simple ref, srv alloc size=32 */
/* 698 */	NdrFcShort( 0x20 ),	/* ia64 Stack size/offset = 32 */
/* 700 */	NdrFcShort( 0x2a ),	/* Type Offset=42 */

	/* Parameter pdroidBirthNext */

/* 702 */	NdrFcShort( 0x8112 ),	/* Flags:  must free, out, simple ref, srv alloc size=32 */
/* 704 */	NdrFcShort( 0x28 ),	/* ia64 Stack size/offset = 40 */
/* 706 */	NdrFcShort( 0x2a ),	/* Type Offset=42 */

	/* Parameter pdroidNext */

/* 708 */	NdrFcShort( 0x4112 ),	/* Flags:  must free, out, simple ref, srv alloc size=16 */
/* 710 */	NdrFcShort( 0x30 ),	/* ia64 Stack size/offset = 48 */
/* 712 */	NdrFcShort( 0x12c ),	/* Type Offset=300 */

	/* Parameter pmcidNext */

/* 714 */	NdrFcShort( 0x113 ),	/* Flags:  must size, must free, out, simple ref, */
/* 716 */	NdrFcShort( 0x38 ),	/* ia64 Stack size/offset = 56 */
/* 718 */	NdrFcShort( 0x2ce ),	/* Type Offset=718 */

	/* Parameter ptszPath */

/* 720 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 722 */	NdrFcShort( 0x40 ),	/* ia64 Stack size/offset = 64 */
/* 724 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

			0x0
        }
    };

static const MIDL_TYPE_FORMAT_STRING __MIDL_TypeFormatString =
    {
        0,
        {
			NdrFcShort( 0x0 ),	/* 0 */
/*  2 */	
			0x15,		/* FC_STRUCT */
			0x3,		/* 3 */
/*  4 */	NdrFcShort( 0x8 ),	/* 8 */
/*  6 */	0x8,		/* FC_LONG */
			0x8,		/* FC_LONG */
/*  8 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 10 */	
			0x11, 0x0,	/* FC_RP */
/* 12 */	NdrFcShort( 0x1e ),	/* Offset= 30 (42) */
/* 14 */	
			0x1d,		/* FC_SMFARRAY */
			0x0,		/* 0 */
/* 16 */	NdrFcShort( 0x8 ),	/* 8 */
/* 18 */	0x1,		/* FC_BYTE */
			0x5b,		/* FC_END */
/* 20 */	
			0x15,		/* FC_STRUCT */
			0x3,		/* 3 */
/* 22 */	NdrFcShort( 0x10 ),	/* 16 */
/* 24 */	0x8,		/* FC_LONG */
			0x6,		/* FC_SHORT */
/* 26 */	0x6,		/* FC_SHORT */
			0x4c,		/* FC_EMBEDDED_COMPLEX */
/* 28 */	0x0,		/* 0 */
			NdrFcShort( 0xfffffff1 ),	/* Offset= -15 (14) */
			0x5b,		/* FC_END */
/* 32 */	
			0x15,		/* FC_STRUCT */
			0x3,		/* 3 */
/* 34 */	NdrFcShort( 0x10 ),	/* 16 */
/* 36 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 38 */	NdrFcShort( 0xffffffee ),	/* Offset= -18 (20) */
/* 40 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 42 */	
			0x15,		/* FC_STRUCT */
			0x3,		/* 3 */
/* 44 */	NdrFcShort( 0x20 ),	/* 32 */
/* 46 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 48 */	NdrFcShort( 0xfffffff0 ),	/* Offset= -16 (32) */
/* 50 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 52 */	NdrFcShort( 0xffffffec ),	/* Offset= -20 (32) */
/* 54 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 56 */	
			0x11, 0x4,	/* FC_RP [alloced_on_stack] */
/* 58 */	NdrFcShort( 0xfffffff0 ),	/* Offset= -16 (42) */
/* 60 */	
			0x29,		/* FC_WSTRING */
			0x5c,		/* FC_PAD */
/* 62 */	NdrFcShort( 0x105 ),	/* 261 */
/* 64 */	
			0x11, 0x0,	/* FC_RP */
/* 66 */	NdrFcShort( 0x17a ),	/* Offset= 378 (444) */
/* 68 */	
			0x2b,		/* FC_NON_ENCAPSULATED_UNION */
			0x8,		/* FC_LONG */
/* 70 */	0x8,		/* Corr desc: FC_LONG */
			0x0,		/*  */
/* 72 */	NdrFcShort( 0xfff8 ),	/* -8 */
/* 74 */	NdrFcShort( 0x1 ),	/* Corr flags:  early, */
/* 76 */	NdrFcShort( 0x2 ),	/* Offset= 2 (78) */
/* 78 */	NdrFcShort( 0x30 ),	/* 48 */
/* 80 */	NdrFcShort( 0x6 ),	/* 6 */
/* 82 */	NdrFcLong( 0x0 ),	/* 0 */
/* 86 */	NdrFcShort( 0x4c ),	/* Offset= 76 (162) */
/* 88 */	NdrFcLong( 0x1 ),	/* 1 */
/* 92 */	NdrFcShort( 0x76 ),	/* Offset= 118 (210) */
/* 94 */	NdrFcLong( 0x2 ),	/* 2 */
/* 98 */	NdrFcShort( 0xa2 ),	/* Offset= 162 (260) */
/* 100 */	NdrFcLong( 0x3 ),	/* 3 */
/* 104 */	NdrFcShort( 0xfa ),	/* Offset= 250 (354) */
/* 106 */	NdrFcLong( 0x4 ),	/* 4 */
/* 110 */	NdrFcShort( 0x104 ),	/* Offset= 260 (370) */
/* 112 */	NdrFcLong( 0x6 ),	/* 6 */
/* 116 */	NdrFcShort( 0x138 ),	/* Offset= 312 (428) */
/* 118 */	NdrFcShort( 0xffffffff ),	/* Offset= -1 (117) */
/* 120 */	
			0x1d,		/* FC_SMFARRAY */
			0x1,		/* 1 */
/* 122 */	NdrFcShort( 0x202 ),	/* 514 */
/* 124 */	0x5,		/* FC_WCHAR */
			0x5b,		/* FC_END */
/* 126 */	
			0x15,		/* FC_STRUCT */
			0x3,		/* 3 */
/* 128 */	NdrFcShort( 0x248 ),	/* 584 */
/* 130 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 132 */	NdrFcShort( 0xfffffff4 ),	/* Offset= -12 (120) */
/* 134 */	0x3e,		/* FC_STRUCTPAD2 */
			0x4c,		/* FC_EMBEDDED_COMPLEX */
/* 136 */	0x0,		/* 0 */
			NdrFcShort( 0xffffffa1 ),	/* Offset= -95 (42) */
			0x4c,		/* FC_EMBEDDED_COMPLEX */
/* 140 */	0x0,		/* 0 */
			NdrFcShort( 0xffffff9d ),	/* Offset= -99 (42) */
			0x8,		/* FC_LONG */
/* 144 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 146 */	
			0x1b,		/* FC_CARRAY */
			0x3,		/* 3 */
/* 148 */	NdrFcShort( 0x248 ),	/* 584 */
/* 150 */	0x19,		/* Corr desc:  field pointer, FC_ULONG */
			0x0,		/*  */
/* 152 */	NdrFcShort( 0x0 ),	/* 0 */
/* 154 */	NdrFcShort( 0x1 ),	/* Corr flags:  early, */
/* 156 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 158 */	NdrFcShort( 0xffffffe0 ),	/* Offset= -32 (126) */
/* 160 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 162 */	
			0x1a,		/* FC_BOGUS_STRUCT */
			0x3,		/* 3 */
/* 164 */	NdrFcShort( 0x10 ),	/* 16 */
/* 166 */	NdrFcShort( 0x0 ),	/* 0 */
/* 168 */	NdrFcShort( 0x6 ),	/* Offset= 6 (174) */
/* 170 */	0x8,		/* FC_LONG */
			0x40,		/* FC_STRUCTPAD4 */
/* 172 */	0x36,		/* FC_POINTER */
			0x5b,		/* FC_END */
/* 174 */	
			0x12, 0x0,	/* FC_UP */
/* 176 */	NdrFcShort( 0xffffffe2 ),	/* Offset= -30 (146) */
/* 178 */	
			0x1b,		/* FC_CARRAY */
			0x3,		/* 3 */
/* 180 */	NdrFcShort( 0x10 ),	/* 16 */
/* 182 */	0x19,		/* Corr desc:  field pointer, FC_ULONG */
			0x0,		/*  */
/* 184 */	NdrFcShort( 0x0 ),	/* 0 */
/* 186 */	NdrFcShort( 0x1 ),	/* Corr flags:  early, */
/* 188 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 190 */	NdrFcShort( 0xffffff62 ),	/* Offset= -158 (32) */
/* 192 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 194 */	
			0x1b,		/* FC_CARRAY */
			0x3,		/* 3 */
/* 196 */	NdrFcShort( 0x20 ),	/* 32 */
/* 198 */	0x19,		/* Corr desc:  field pointer, FC_ULONG */
			0x0,		/*  */
/* 200 */	NdrFcShort( 0x0 ),	/* 0 */
/* 202 */	NdrFcShort( 0x1 ),	/* Corr flags:  early, */
/* 204 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 206 */	NdrFcShort( 0xffffff5c ),	/* Offset= -164 (42) */
/* 208 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 210 */	
			0x1a,		/* FC_BOGUS_STRUCT */
			0x3,		/* 3 */
/* 212 */	NdrFcShort( 0x30 ),	/* 48 */
/* 214 */	NdrFcShort( 0x0 ),	/* 0 */
/* 216 */	NdrFcShort( 0xc ),	/* Offset= 12 (228) */
/* 218 */	0x8,		/* FC_LONG */
			0x8,		/* FC_LONG */
/* 220 */	0x8,		/* FC_LONG */
			0x8,		/* FC_LONG */
/* 222 */	0x36,		/* FC_POINTER */
			0x36,		/* FC_POINTER */
/* 224 */	0x36,		/* FC_POINTER */
			0x36,		/* FC_POINTER */
/* 226 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 228 */	
			0x12, 0x0,	/* FC_UP */
/* 230 */	NdrFcShort( 0xffffff3a ),	/* Offset= -198 (32) */
/* 232 */	
			0x12, 0x0,	/* FC_UP */
/* 234 */	NdrFcShort( 0xffffffc8 ),	/* Offset= -56 (178) */
/* 236 */	
			0x12, 0x0,	/* FC_UP */
/* 238 */	NdrFcShort( 0xffffffd4 ),	/* Offset= -44 (194) */
/* 240 */	
			0x12, 0x0,	/* FC_UP */
/* 242 */	NdrFcShort( 0xffffffd0 ),	/* Offset= -48 (194) */
/* 244 */	
			0x1b,		/* FC_CARRAY */
			0x3,		/* 3 */
/* 246 */	NdrFcShort( 0x10 ),	/* 16 */
/* 248 */	0x19,		/* Corr desc:  field pointer, FC_ULONG */
			0x0,		/*  */
/* 250 */	NdrFcShort( 0x10 ),	/* 16 */
/* 252 */	NdrFcShort( 0x1 ),	/* Corr flags:  early, */
/* 254 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 256 */	NdrFcShort( 0xffffff20 ),	/* Offset= -224 (32) */
/* 258 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 260 */	
			0x1a,		/* FC_BOGUS_STRUCT */
			0x3,		/* 3 */
/* 262 */	NdrFcShort( 0x20 ),	/* 32 */
/* 264 */	NdrFcShort( 0x0 ),	/* 0 */
/* 266 */	NdrFcShort( 0xa ),	/* Offset= 10 (276) */
/* 268 */	0x8,		/* FC_LONG */
			0x40,		/* FC_STRUCTPAD4 */
/* 270 */	0x36,		/* FC_POINTER */
			0x8,		/* FC_LONG */
/* 272 */	0x40,		/* FC_STRUCTPAD4 */
			0x36,		/* FC_POINTER */
/* 274 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 276 */	
			0x12, 0x0,	/* FC_UP */
/* 278 */	NdrFcShort( 0xffffffac ),	/* Offset= -84 (194) */
/* 280 */	
			0x12, 0x0,	/* FC_UP */
/* 282 */	NdrFcShort( 0xffffffda ),	/* Offset= -38 (244) */
/* 284 */	
			0x15,		/* FC_STRUCT */
			0x0,		/* 0 */
/* 286 */	NdrFcShort( 0x8 ),	/* 8 */
/* 288 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 290 */	NdrFcShort( 0xfffffeec ),	/* Offset= -276 (14) */
/* 292 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 294 */	
			0x1d,		/* FC_SMFARRAY */
			0x0,		/* 0 */
/* 296 */	NdrFcShort( 0x10 ),	/* 16 */
/* 298 */	0x2,		/* FC_CHAR */
			0x5b,		/* FC_END */
/* 300 */	
			0x15,		/* FC_STRUCT */
			0x0,		/* 0 */
/* 302 */	NdrFcShort( 0x10 ),	/* 16 */
/* 304 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 306 */	NdrFcShort( 0xfffffff4 ),	/* Offset= -12 (294) */
/* 308 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 310 */	
			0x15,		/* FC_STRUCT */
			0x3,		/* 3 */
/* 312 */	NdrFcShort( 0x44 ),	/* 68 */
/* 314 */	0x8,		/* FC_LONG */
			0xe,		/* FC_ENUM32 */
/* 316 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 318 */	NdrFcShort( 0xfffffee2 ),	/* Offset= -286 (32) */
/* 320 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 322 */	NdrFcShort( 0xffffffda ),	/* Offset= -38 (284) */
/* 324 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 326 */	NdrFcShort( 0xffffffd6 ),	/* Offset= -42 (284) */
/* 328 */	0x8,		/* FC_LONG */
			0x4c,		/* FC_EMBEDDED_COMPLEX */
/* 330 */	0x0,		/* 0 */
			NdrFcShort( 0xfffffeb7 ),	/* Offset= -329 (2) */
			0x4c,		/* FC_EMBEDDED_COMPLEX */
/* 334 */	0x0,		/* 0 */
			NdrFcShort( 0xffffffdd ),	/* Offset= -35 (300) */
			0x5b,		/* FC_END */
/* 338 */	
			0x1b,		/* FC_CARRAY */
			0x3,		/* 3 */
/* 340 */	NdrFcShort( 0x44 ),	/* 68 */
/* 342 */	0x19,		/* Corr desc:  field pointer, FC_ULONG */
			0x0,		/*  */
/* 344 */	NdrFcShort( 0x0 ),	/* 0 */
/* 346 */	NdrFcShort( 0x1 ),	/* Corr flags:  early, */
/* 348 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 350 */	NdrFcShort( 0xffffffd8 ),	/* Offset= -40 (310) */
/* 352 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 354 */	
			0x1a,		/* FC_BOGUS_STRUCT */
			0x3,		/* 3 */
/* 356 */	NdrFcShort( 0x10 ),	/* 16 */
/* 358 */	NdrFcShort( 0x0 ),	/* 0 */
/* 360 */	NdrFcShort( 0x6 ),	/* Offset= 6 (366) */
/* 362 */	0x8,		/* FC_LONG */
			0x40,		/* FC_STRUCTPAD4 */
/* 364 */	0x36,		/* FC_POINTER */
			0x5b,		/* FC_END */
/* 366 */	
			0x12, 0x0,	/* FC_UP */
/* 368 */	NdrFcShort( 0xffffffe2 ),	/* Offset= -30 (338) */
/* 370 */	
			0x1a,		/* FC_BOGUS_STRUCT */
			0x3,		/* 3 */
/* 372 */	NdrFcShort( 0x20 ),	/* 32 */
/* 374 */	NdrFcShort( 0x0 ),	/* 0 */
/* 376 */	NdrFcShort( 0xa ),	/* Offset= 10 (386) */
/* 378 */	0x8,		/* FC_LONG */
			0x40,		/* FC_STRUCTPAD4 */
/* 380 */	0x36,		/* FC_POINTER */
			0x8,		/* FC_LONG */
/* 382 */	0x40,		/* FC_STRUCTPAD4 */
			0x36,		/* FC_POINTER */
/* 384 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 386 */	
			0x12, 0x0,	/* FC_UP */
/* 388 */	NdrFcShort( 0xffffff3e ),	/* Offset= -194 (194) */
/* 390 */	
			0x12, 0x0,	/* FC_UP */
/* 392 */	NdrFcShort( 0xffffff6c ),	/* Offset= -148 (244) */
/* 394 */	
			0x15,		/* FC_STRUCT */
			0x3,		/* 3 */
/* 396 */	NdrFcShort( 0x54 ),	/* 84 */
/* 398 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 400 */	NdrFcShort( 0xfffffe9a ),	/* Offset= -358 (42) */
/* 402 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 404 */	NdrFcShort( 0xfffffe96 ),	/* Offset= -362 (42) */
/* 406 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 408 */	NdrFcShort( 0xffffff94 ),	/* Offset= -108 (300) */
/* 410 */	0x8,		/* FC_LONG */
			0x5b,		/* FC_END */
/* 412 */	
			0x1b,		/* FC_CARRAY */
			0x3,		/* 3 */
/* 414 */	NdrFcShort( 0x54 ),	/* 84 */
/* 416 */	0x19,		/* Corr desc:  field pointer, FC_ULONG */
			0x0,		/*  */
/* 418 */	NdrFcShort( 0x0 ),	/* 0 */
/* 420 */	NdrFcShort( 0x1 ),	/* Corr flags:  early, */
/* 422 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 424 */	NdrFcShort( 0xffffffe2 ),	/* Offset= -30 (394) */
/* 426 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 428 */	
			0x1a,		/* FC_BOGUS_STRUCT */
			0x3,		/* 3 */
/* 430 */	NdrFcShort( 0x10 ),	/* 16 */
/* 432 */	NdrFcShort( 0x0 ),	/* 0 */
/* 434 */	NdrFcShort( 0x6 ),	/* Offset= 6 (440) */
/* 436 */	0x8,		/* FC_LONG */
			0x40,		/* FC_STRUCTPAD4 */
/* 438 */	0x36,		/* FC_POINTER */
			0x5b,		/* FC_END */
/* 440 */	
			0x12, 0x0,	/* FC_UP */
/* 442 */	NdrFcShort( 0xffffffe2 ),	/* Offset= -30 (412) */
/* 444 */	
			0x1a,		/* FC_BOGUS_STRUCT */
			0x3,		/* 3 */
/* 446 */	NdrFcShort( 0x40 ),	/* 64 */
/* 448 */	NdrFcShort( 0x0 ),	/* 0 */
/* 450 */	NdrFcShort( 0xa ),	/* Offset= 10 (460) */
/* 452 */	0xe,		/* FC_ENUM32 */
			0x40,		/* FC_STRUCTPAD4 */
/* 454 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 456 */	NdrFcShort( 0xfffffe7c ),	/* Offset= -388 (68) */
/* 458 */	0x36,		/* FC_POINTER */
			0x5b,		/* FC_END */
/* 460 */	
			0x12, 0x8,	/* FC_UP [simple_pointer] */
/* 462 */	
			0x25,		/* FC_C_WSTRING */
			0x5c,		/* FC_PAD */
/* 464 */	
			0x15,		/* FC_STRUCT */
			0x3,		/* 3 */
/* 466 */	NdrFcShort( 0x14 ),	/* 20 */
/* 468 */	0x8,		/* FC_LONG */
			0x4c,		/* FC_EMBEDDED_COMPLEX */
/* 470 */	0x0,		/* 0 */
			NdrFcShort( 0xfffffe49 ),	/* Offset= -439 (32) */
			0x5b,		/* FC_END */
/* 474 */	0xb5,		/* FC_PIPE */
			0x3,		/* 3 */
/* 476 */	NdrFcShort( 0xfffffff4 ),	/* Offset= -12 (464) */
/* 478 */	NdrFcShort( 0x14 ),	/* 20 */
/* 480 */	NdrFcShort( 0x14 ),	/* 20 */
/* 482 */	0xb5,		/* FC_PIPE */
			0x3,		/* 3 */
/* 484 */	NdrFcShort( 0xffffffa6 ),	/* Offset= -90 (394) */
/* 486 */	NdrFcShort( 0x54 ),	/* 84 */
/* 488 */	NdrFcShort( 0x54 ),	/* 84 */
/* 490 */	
			0x11, 0x0,	/* FC_RP */
/* 492 */	NdrFcShort( 0x2 ),	/* Offset= 2 (494) */
/* 494 */	
			0x1b,		/* FC_CARRAY */
			0x3,		/* 3 */
/* 496 */	NdrFcShort( 0x10 ),	/* 16 */
/* 498 */	0x29,		/* Corr desc:  parameter, FC_ULONG */
			0x0,		/*  */
/* 500 */	NdrFcShort( 0x8 ),	/* ia64 Stack size/offset = 8 */
/* 502 */	NdrFcShort( 0x1 ),	/* Corr flags:  early, */
/* 504 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 506 */	NdrFcShort( 0xfffffe26 ),	/* Offset= -474 (32) */
/* 508 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 510 */	
			0x11, 0x0,	/* FC_RP */
/* 512 */	NdrFcShort( 0xffffff2c ),	/* Offset= -212 (300) */
/* 514 */	
			0x11, 0x4,	/* FC_RP [alloced_on_stack] */
/* 516 */	NdrFcShort( 0xffffff28 ),	/* Offset= -216 (300) */
/* 518 */	
			0x11, 0x8,	/* FC_RP [simple_pointer] */
/* 520 */	0x8,		/* FC_LONG */
			0x5c,		/* FC_PAD */
/* 522 */	
			0x11, 0x0,	/* FC_RP */
/* 524 */	NdrFcShort( 0x2 ),	/* Offset= 2 (526) */
/* 526 */	
			0x25,		/* FC_C_WSTRING */
			0x44,		/* FC_STRING_SIZED */
/* 528 */	0x29,		/* Corr desc:  parameter, FC_ULONG */
			0x54,		/* FC_DEREFERENCE */
/* 530 */	NdrFcShort( 0x48 ),	/* ia64 Stack size/offset = 72 */
/* 532 */	NdrFcShort( 0x1 ),	/* Corr flags:  early, */
/* 534 */	
			0x11, 0x0,	/* FC_RP */
/* 536 */	NdrFcShort( 0x2 ),	/* Offset= 2 (538) */
/* 538 */	
			0x25,		/* FC_C_WSTRING */
			0x44,		/* FC_STRING_SIZED */
/* 540 */	0x40,		/* Corr desc:  constant, val=262 */
			0x0,		/* 0 */
/* 542 */	NdrFcShort( 0x106 ),	/* 262 */
/* 544 */	NdrFcShort( 0x0 ),	/* Corr flags:  */
/* 546 */	
			0x11, 0x0,	/* FC_RP */
/* 548 */	NdrFcShort( 0x92 ),	/* Offset= 146 (694) */
/* 550 */	
			0x2b,		/* FC_NON_ENCAPSULATED_UNION */
			0x8,		/* FC_LONG */
/* 552 */	0x8,		/* Corr desc: FC_LONG */
			0x0,		/*  */
/* 554 */	NdrFcShort( 0xfff8 ),	/* -8 */
/* 556 */	NdrFcShort( 0x1 ),	/* Corr flags:  early, */
/* 558 */	NdrFcShort( 0x2 ),	/* Offset= 2 (560) */
/* 560 */	NdrFcShort( 0xc8 ),	/* 200 */
/* 562 */	NdrFcShort( 0x9 ),	/* 9 */
/* 564 */	NdrFcLong( 0x0 ),	/* 0 */
/* 568 */	NdrFcShort( 0xfffffe6a ),	/* Offset= -406 (162) */
/* 570 */	NdrFcLong( 0x1 ),	/* 1 */
/* 574 */	NdrFcShort( 0xfffffe94 ),	/* Offset= -364 (210) */
/* 576 */	NdrFcLong( 0x2 ),	/* 2 */
/* 580 */	NdrFcShort( 0xfffffec0 ),	/* Offset= -320 (260) */
/* 582 */	NdrFcLong( 0x3 ),	/* 3 */
/* 586 */	NdrFcShort( 0xffffff18 ),	/* Offset= -232 (354) */
/* 588 */	NdrFcLong( 0x4 ),	/* 4 */
/* 592 */	NdrFcShort( 0xffffff22 ),	/* Offset= -222 (370) */
/* 594 */	NdrFcLong( 0x5 ),	/* 5 */
/* 598 */	NdrFcShort( 0x1e ),	/* Offset= 30 (628) */
/* 600 */	NdrFcLong( 0x6 ),	/* 6 */
/* 604 */	NdrFcShort( 0xffffff50 ),	/* Offset= -176 (428) */
/* 606 */	NdrFcLong( 0x7 ),	/* 7 */
/* 610 */	NdrFcShort( 0xfffffda0 ),	/* Offset= -608 (2) */
/* 612 */	NdrFcLong( 0x8 ),	/* 8 */
/* 616 */	NdrFcShort( 0x8008 ),	/* Simple arm type: FC_LONG */
/* 618 */	NdrFcShort( 0xffffffff ),	/* Offset= -1 (617) */
/* 620 */	
			0x15,		/* FC_STRUCT */
			0x3,		/* 3 */
/* 622 */	NdrFcShort( 0xc ),	/* 12 */
/* 624 */	0x8,		/* FC_LONG */
			0x8,		/* FC_LONG */
/* 626 */	0x8,		/* FC_LONG */
			0x5b,		/* FC_END */
/* 628 */	
			0x15,		/* FC_STRUCT */
			0x3,		/* 3 */
/* 630 */	NdrFcShort( 0xc8 ),	/* 200 */
/* 632 */	0x8,		/* FC_LONG */
			0x8,		/* FC_LONG */
/* 634 */	0x8,		/* FC_LONG */
			0x8,		/* FC_LONG */
/* 636 */	0x8,		/* FC_LONG */
			0x8,		/* FC_LONG */
/* 638 */	0x8,		/* FC_LONG */
			0x8,		/* FC_LONG */
/* 640 */	0x8,		/* FC_LONG */
			0x8,		/* FC_LONG */
/* 642 */	0x8,		/* FC_LONG */
			0x8,		/* FC_LONG */
/* 644 */	0x8,		/* FC_LONG */
			0x8,		/* FC_LONG */
/* 646 */	0x8,		/* FC_LONG */
			0x8,		/* FC_LONG */
/* 648 */	0x8,		/* FC_LONG */
			0x8,		/* FC_LONG */
/* 650 */	0x8,		/* FC_LONG */
			0x8,		/* FC_LONG */
/* 652 */	0x8,		/* FC_LONG */
			0x8,		/* FC_LONG */
/* 654 */	0x8,		/* FC_LONG */
			0x8,		/* FC_LONG */
/* 656 */	0x8,		/* FC_LONG */
			0x8,		/* FC_LONG */
/* 658 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 660 */	NdrFcShort( 0xfffffd6e ),	/* Offset= -658 (2) */
/* 662 */	0x8,		/* FC_LONG */
			0x8,		/* FC_LONG */
/* 664 */	0x8,		/* FC_LONG */
			0x8,		/* FC_LONG */
/* 666 */	0x8,		/* FC_LONG */
			0x4c,		/* FC_EMBEDDED_COMPLEX */
/* 668 */	0x0,		/* 0 */
			NdrFcShort( 0xfffffd65 ),	/* Offset= -667 (2) */
			0x8,		/* FC_LONG */
/* 672 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 674 */	NdrFcShort( 0xfffffd60 ),	/* Offset= -672 (2) */
/* 676 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 678 */	NdrFcShort( 0xfffffd5c ),	/* Offset= -676 (2) */
/* 680 */	0x8,		/* FC_LONG */
			0x8,		/* FC_LONG */
/* 682 */	0x8,		/* FC_LONG */
			0x8,		/* FC_LONG */
/* 684 */	0x8,		/* FC_LONG */
			0x6,		/* FC_SHORT */
/* 686 */	0x6,		/* FC_SHORT */
			0x6,		/* FC_SHORT */
/* 688 */	0x6,		/* FC_SHORT */
			0x4c,		/* FC_EMBEDDED_COMPLEX */
/* 690 */	0x0,		/* 0 */
			NdrFcShort( 0xffffffb9 ),	/* Offset= -71 (620) */
			0x5b,		/* FC_END */
/* 694 */	
			0x1a,		/* FC_BOGUS_STRUCT */
			0x3,		/* 3 */
/* 696 */	NdrFcShort( 0xd8 ),	/* 216 */
/* 698 */	NdrFcShort( 0x0 ),	/* 0 */
/* 700 */	NdrFcShort( 0xa ),	/* Offset= 10 (710) */
/* 702 */	0xe,		/* FC_ENUM32 */
			0xe,		/* FC_ENUM32 */
/* 704 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 706 */	NdrFcShort( 0xffffff64 ),	/* Offset= -156 (550) */
/* 708 */	0x36,		/* FC_POINTER */
			0x5b,		/* FC_END */
/* 710 */	
			0x12, 0x8,	/* FC_UP [simple_pointer] */
/* 712 */	
			0x25,		/* FC_C_WSTRING */
			0x5c,		/* FC_PAD */
/* 714 */	
			0x11, 0x0,	/* FC_RP */
/* 716 */	NdrFcShort( 0x2 ),	/* Offset= 2 (718) */
/* 718 */	
			0x25,		/* FC_C_WSTRING */
			0x44,		/* FC_STRING_SIZED */
/* 720 */	0x40,		/* Corr desc:  constant, val=262 */
			0x0,		/* 0 */
/* 722 */	NdrFcShort( 0x106 ),	/* 262 */
/* 724 */	NdrFcShort( 0x0 ),	/* Corr flags:  */

			0x0
        }
    };

static const unsigned short trkwks_FormatStringOffsetTable[] =
    {
    0,
    72,
    132,
    174,
    222,
    258,
    312,
    366,
    414,
    450,
    540,
    606,
    648
    };


static const MIDL_STUB_DESC trkwks_StubDesc = 
    {
    (void *)& trkwks___RpcServerInterface,
    MIDL_user_allocate,
    MIDL_user_free,
    0,
    0,
    0,
    0,
    0,
    __MIDL_TypeFormatString.Format,
    1, /* -error bounds_check flag */
    0x50002, /* Ndr library version */
    0,
    0x600015b, /* MIDL Version 6.0.347 */
    0,
    0,
    0,  /* notify & notify_flag routine table */
    0x1, /* MIDL flag */
    0, /* cs routines */
    0,   /* proxy/server info */
    0   /* Reserved5 */
    };

static RPC_DISPATCH_FUNCTION trkwks_table[] =
    {
    NdrServerCall2,
    NdrServerCall2,
    NdrServerCall2,
    NdrServerCall2,
    NdrServerCall2,
    NdrServerCall2,
    NdrServerCall2,
    NdrServerCall2,
    NdrServerCall2,
    NdrAsyncServerCall,
    NdrServerCall2,
    NdrServerCall2,
    NdrServerCall2,
    0
    };
RPC_DISPATCH_TABLE trkwks_v1_2_DispatchTable = 
    {
    13,
    trkwks_table
    };

static const SERVER_ROUTINE trkwks_ServerRoutineTable[] = 
    {
    (SERVER_ROUTINE)Stubold_LnkMendLink,
    (SERVER_ROUTINE)Stubold_LnkSearchMachine,
    (SERVER_ROUTINE)Stubold_LnkCallSvrMessage,
    (SERVER_ROUTINE)StubLnkSetVolumeId,
    (SERVER_ROUTINE)StubLnkRestartDcSynchronization,
    (SERVER_ROUTINE)StubGetVolumeTrackingInformation,
    (SERVER_ROUTINE)StubGetFileTrackingInformation,
    (SERVER_ROUTINE)StubTriggerVolumeClaims,
    (SERVER_ROUTINE)StubLnkOnRestore,
    (SERVER_ROUTINE)StubLnkMendLink,
    (SERVER_ROUTINE)Stubold2_LnkSearchMachine,
    (SERVER_ROUTINE)StubLnkCallSvrMessage,
    (SERVER_ROUTINE)StubLnkSearchMachine
    };

static const MIDL_SERVER_INFO trkwks_ServerInfo = 
    {
    &trkwks_StubDesc,
    trkwks_ServerRoutineTable,
    __MIDL_ProcFormatString.Format,
    trkwks_FormatStringOffsetTable,
    0,
    0,
    0,
    0};


#endif /* defined(_M_IA64) || defined(_M_AMD64)*/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\public\internal\drivers\inc\dx9xver.h ===
/*++
Copyright (c) Microsoft Corporation. All rights reserved.

Module Name:

    dx9xver.h

Abstract:

 This file define the version of binaries for DX win9x redistribution.
 It is intended to be included after ntverp.h to modify the file version.

 We define the version that's grater than millen OS version for ks ring0
 and ring3 components. dba might want to use this version too.


Author:


--*/
#undef VER_PRODUCTMAJORVERSION
#undef VER_PRODUCTMINORVERSION
#undef VER_PRODUCTBUILD

//
// make this greater than millennium release 2525 ?
//
#define VER_PRODUCTMAJORVERSION 4
#define VER_PRODUCTMINORVERSION 90
#define VER_PRODUCTBUILD 2526

//
// make the version
//
#undef VER_PRODUCTVERSION_STRING
#undef VER_PRODUCTVERSION
#define VER_PRODUCTVERSION_STRING   VER_PRODUCTVERSION_MAJORMINOR1(VER_PRODUCTMAJORVERSION, VER_PRODUCTMINORVERSION)

#define VER_PRODUCTVERSION          VER_PRODUCTMAJORVERSION,VER_PRODUCTMINORVERSION,VER_PRODUCTBUILD,VER_PRODUCTBUILD_QFE


//
// product name
//

#undef VER_PRODUCTNAME_STR
#define VER_PRODUCTNAME_STR "Microsoft(R) Windows(R) Operating System"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\public\internal\com\inc\trksvr_s.c ===
#pragma warning( disable: 4049 )  /* more than 64k source lines */

/* this ALWAYS GENERATED file contains the RPC server stubs */


 /* File created by MIDL compiler version 6.00.0347 */
/* Compiler settings for trksvr.idl:
    Oicf, W1, Zp8, env=Win32 (32b run)
    protocol : dce , ms_ext, c_ext, robust
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )

#if !defined(_M_IA64) && !defined(_M_AMD64)
#include <string.h>
#include "trksvr.h"

#define TYPE_FORMAT_STRING_SIZE   563                               
#define PROC_FORMAT_STRING_SIZE   77                                
#define TRANSMIT_AS_TABLE_SIZE    0            
#define WIRE_MARSHAL_TABLE_SIZE   0            

typedef struct _MIDL_TYPE_FORMAT_STRING
    {
    short          Pad;
    unsigned char  Format[ TYPE_FORMAT_STRING_SIZE ];
    } MIDL_TYPE_FORMAT_STRING;

typedef struct _MIDL_PROC_FORMAT_STRING
    {
    short          Pad;
    unsigned char  Format[ PROC_FORMAT_STRING_SIZE ];
    } MIDL_PROC_FORMAT_STRING;


static RPC_SYNTAX_IDENTIFIER  _RpcTransferSyntax = 
{{0x8A885D04,0x1CEB,0x11C9,{0x9F,0xE8,0x08,0x00,0x2B,0x10,0x48,0x60}},{2,0}};

extern const MIDL_TYPE_FORMAT_STRING __MIDL_TypeFormatString;
extern const MIDL_PROC_FORMAT_STRING __MIDL_ProcFormatString;

/* Standard interface: __MIDL_itf_trksvr_0000, ver. 0.0,
   GUID={0x00000000,0x0000,0x0000,{0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00}} */


/* Standard interface: trksvr, ver. 1.0,
   GUID={0x4da1c422,0x943d,0x11d1,{0xac,0xae,0x00,0xc0,0x4f,0xc2,0xaa,0x3f}} */


extern const MIDL_SERVER_INFO trksvr_ServerInfo;

extern RPC_DISPATCH_TABLE trksvr_v1_0_DispatchTable;

static const RPC_SERVER_INTERFACE trksvr___RpcServerInterface =
    {
    sizeof(RPC_SERVER_INTERFACE),
    {{0x4da1c422,0x943d,0x11d1,{0xac,0xae,0x00,0xc0,0x4f,0xc2,0xaa,0x3f}},{1,0}},
    {{0x8A885D04,0x1CEB,0x11C9,{0x9F,0xE8,0x08,0x00,0x2B,0x10,0x48,0x60}},{2,0}},
    &trksvr_v1_0_DispatchTable,
    0,
    0,
    0,
    &trksvr_ServerInfo,
    0x04000000
    };
RPC_IF_HANDLE Stubtrksvr_v1_0_s_ifspec = (RPC_IF_HANDLE)& trksvr___RpcServerInterface;

extern const MIDL_STUB_DESC trksvr_StubDesc;

 extern const MIDL_STUBLESS_PROXY_INFO trksvr_ProxyInfo;

/* [callback] */ HRESULT LnkSvrMessageCallback( 
    /* [out][in] */ TRKSVR_MESSAGE_UNION *pMsg)
{

    CLIENT_CALL_RETURN _RetVal;

    _RetVal = NdrClientCall2(
                  ( PMIDL_STUB_DESC  )&trksvr_StubDesc,
                  (PFORMAT_STRING) &__MIDL_ProcFormatString.Format[40],
                  ( unsigned char * )&pMsg);
    return ( HRESULT  )_RetVal.Simple;
    
}


#if !defined(__RPC_WIN32__)
#error  Invalid build platform for this stub.
#endif

#if !(TARGET_IS_NT50_OR_LATER)
#error You need a Windows 2000 or later to run this stub because it uses these features:
#error   /robust command line switch.
#error However, your C/C++ compilation flags indicate you intend to run this app on earlier systems.
#error This app will die there with the RPC_X_WRONG_STUB_VERSION error.
#endif


static const MIDL_PROC_FORMAT_STRING __MIDL_ProcFormatString =
    {
        0,
        {

	/* Procedure LnkSvrMessage */

			0x0,		/* 0 */
			0x48,		/* Old Flags:  */
/*  2 */	NdrFcLong( 0x0 ),	/* 0 */
/*  6 */	NdrFcShort( 0x0 ),	/* 0 */
/*  8 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 10 */	0x32,		/* FC_BIND_PRIMITIVE */
			0x0,		/* 0 */
/* 12 */	NdrFcShort( 0x0 ),	/* x86 Stack size/offset = 0 */
/* 14 */	NdrFcShort( 0x0 ),	/* 0 */
/* 16 */	NdrFcShort( 0x8 ),	/* 8 */
/* 18 */	0x47,		/* Oi2 Flags:  srv must size, clt must size, has return, has ext, */
			0x2,		/* 2 */
/* 20 */	0x8,		/* 8 */
			0x7,		/* Ext Flags:  new corr desc, clt corr check, srv corr check, */
/* 22 */	NdrFcShort( 0xb ),	/* 11 */
/* 24 */	NdrFcShort( 0xb ),	/* 11 */
/* 26 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter IDL_handle */

/* 28 */	NdrFcShort( 0x11b ),	/* Flags:  must size, must free, in, out, simple ref, */
/* 30 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 32 */	NdrFcShort( 0x21e ),	/* Type Offset=542 */

	/* Parameter pMsg */

/* 34 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 36 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 38 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure LnkSvrMessageCallback */


	/* Return value */

/* 40 */	0x34,		/* FC_CALLBACK_HANDLE */
			0x48,		/* Old Flags:  */
/* 42 */	NdrFcLong( 0x0 ),	/* 0 */
/* 46 */	NdrFcShort( 0x0 ),	/* 0 */
/* 48 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 50 */	NdrFcShort( 0x0 ),	/* 0 */
/* 52 */	NdrFcShort( 0x8 ),	/* 8 */
/* 54 */	0x47,		/* Oi2 Flags:  srv must size, clt must size, has return, has ext, */
			0x2,		/* 2 */
/* 56 */	0x8,		/* 8 */
			0x7,		/* Ext Flags:  new corr desc, clt corr check, srv corr check, */
/* 58 */	NdrFcShort( 0xb ),	/* 11 */
/* 60 */	NdrFcShort( 0xb ),	/* 11 */
/* 62 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter pMsg */

/* 64 */	NdrFcShort( 0x11b ),	/* Flags:  must size, must free, in, out, simple ref, */
/* 66 */	NdrFcShort( 0x0 ),	/* x86 Stack size/offset = 0 */
/* 68 */	NdrFcShort( 0x21e ),	/* Type Offset=542 */

	/* Return value */

/* 70 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 72 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 74 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

			0x0
        }
    };

static const MIDL_TYPE_FORMAT_STRING __MIDL_TypeFormatString =
    {
        0,
        {
			NdrFcShort( 0x0 ),	/* 0 */
/*  2 */	
			0x11, 0x0,	/* FC_RP */
/*  4 */	NdrFcShort( 0x21a ),	/* Offset= 538 (542) */
/*  6 */	
			0x2b,		/* FC_NON_ENCAPSULATED_UNION */
			0x8,		/* FC_LONG */
/*  8 */	0x8,		/* Corr desc: FC_LONG */
			0x0,		/*  */
/* 10 */	NdrFcShort( 0xfff8 ),	/* -8 */
/* 12 */	NdrFcShort( 0x1 ),	/* Corr flags:  early, */
/* 14 */	NdrFcShort( 0x2 ),	/* Offset= 2 (16) */
/* 16 */	NdrFcShort( 0xc8 ),	/* 200 */
/* 18 */	NdrFcShort( 0x9 ),	/* 9 */
/* 20 */	NdrFcLong( 0x0 ),	/* 0 */
/* 24 */	NdrFcShort( 0x88 ),	/* Offset= 136 (160) */
/* 26 */	NdrFcLong( 0x1 ),	/* 1 */
/* 30 */	NdrFcShort( 0xb6 ),	/* Offset= 182 (212) */
/* 32 */	NdrFcLong( 0x2 ),	/* 2 */
/* 36 */	NdrFcShort( 0xf8 ),	/* Offset= 248 (284) */
/* 38 */	NdrFcLong( 0x3 ),	/* 3 */
/* 42 */	NdrFcShort( 0x160 ),	/* Offset= 352 (394) */
/* 44 */	NdrFcLong( 0x4 ),	/* 4 */
/* 48 */	NdrFcShort( 0xec ),	/* Offset= 236 (284) */
/* 50 */	NdrFcLong( 0x5 ),	/* 5 */
/* 54 */	NdrFcShort( 0x170 ),	/* Offset= 368 (422) */
/* 56 */	NdrFcLong( 0x6 ),	/* 6 */
/* 60 */	NdrFcShort( 0x1ce ),	/* Offset= 462 (522) */
/* 62 */	NdrFcLong( 0x7 ),	/* 7 */
/* 66 */	NdrFcShort( 0x104 ),	/* Offset= 260 (326) */
/* 68 */	NdrFcLong( 0x8 ),	/* 8 */
/* 72 */	NdrFcShort( 0x8008 ),	/* Simple arm type: FC_LONG */
/* 74 */	NdrFcShort( 0xffffffff ),	/* Offset= -1 (73) */
/* 76 */	
			0x1d,		/* FC_SMFARRAY */
			0x1,		/* 1 */
/* 78 */	NdrFcShort( 0x202 ),	/* 514 */
/* 80 */	0x5,		/* FC_WCHAR */
			0x5b,		/* FC_END */
/* 82 */	
			0x1d,		/* FC_SMFARRAY */
			0x0,		/* 0 */
/* 84 */	NdrFcShort( 0x8 ),	/* 8 */
/* 86 */	0x1,		/* FC_BYTE */
			0x5b,		/* FC_END */
/* 88 */	
			0x15,		/* FC_STRUCT */
			0x3,		/* 3 */
/* 90 */	NdrFcShort( 0x10 ),	/* 16 */
/* 92 */	0x8,		/* FC_LONG */
			0x6,		/* FC_SHORT */
/* 94 */	0x6,		/* FC_SHORT */
			0x4c,		/* FC_EMBEDDED_COMPLEX */
/* 96 */	0x0,		/* 0 */
			NdrFcShort( 0xfffffff1 ),	/* Offset= -15 (82) */
			0x5b,		/* FC_END */
/* 100 */	
			0x15,		/* FC_STRUCT */
			0x3,		/* 3 */
/* 102 */	NdrFcShort( 0x10 ),	/* 16 */
/* 104 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 106 */	NdrFcShort( 0xffffffee ),	/* Offset= -18 (88) */
/* 108 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 110 */	
			0x15,		/* FC_STRUCT */
			0x3,		/* 3 */
/* 112 */	NdrFcShort( 0x20 ),	/* 32 */
/* 114 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 116 */	NdrFcShort( 0xfffffff0 ),	/* Offset= -16 (100) */
/* 118 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 120 */	NdrFcShort( 0xffffffec ),	/* Offset= -20 (100) */
/* 122 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 124 */	
			0x15,		/* FC_STRUCT */
			0x3,		/* 3 */
/* 126 */	NdrFcShort( 0x248 ),	/* 584 */
/* 128 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 130 */	NdrFcShort( 0xffffffca ),	/* Offset= -54 (76) */
/* 132 */	0x3e,		/* FC_STRUCTPAD2 */
			0x4c,		/* FC_EMBEDDED_COMPLEX */
/* 134 */	0x0,		/* 0 */
			NdrFcShort( 0xffffffe7 ),	/* Offset= -25 (110) */
			0x4c,		/* FC_EMBEDDED_COMPLEX */
/* 138 */	0x0,		/* 0 */
			NdrFcShort( 0xffffffe3 ),	/* Offset= -29 (110) */
			0x8,		/* FC_LONG */
/* 142 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 144 */	
			0x1b,		/* FC_CARRAY */
			0x3,		/* 3 */
/* 146 */	NdrFcShort( 0x248 ),	/* 584 */
/* 148 */	0x19,		/* Corr desc:  field pointer, FC_ULONG */
			0x0,		/*  */
/* 150 */	NdrFcShort( 0x0 ),	/* 0 */
/* 152 */	NdrFcShort( 0x1 ),	/* Corr flags:  early, */
/* 154 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 156 */	NdrFcShort( 0xffffffe0 ),	/* Offset= -32 (124) */
/* 158 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 160 */	
			0x16,		/* FC_PSTRUCT */
			0x3,		/* 3 */
/* 162 */	NdrFcShort( 0x8 ),	/* 8 */
/* 164 */	
			0x4b,		/* FC_PP */
			0x5c,		/* FC_PAD */
/* 166 */	
			0x46,		/* FC_NO_REPEAT */
			0x5c,		/* FC_PAD */
/* 168 */	NdrFcShort( 0x4 ),	/* 4 */
/* 170 */	NdrFcShort( 0x4 ),	/* 4 */
/* 172 */	0x12, 0x0,	/* FC_UP */
/* 174 */	NdrFcShort( 0xffffffe2 ),	/* Offset= -30 (144) */
/* 176 */	
			0x5b,		/* FC_END */

			0x8,		/* FC_LONG */
/* 178 */	0x8,		/* FC_LONG */
			0x5b,		/* FC_END */
/* 180 */	
			0x1b,		/* FC_CARRAY */
			0x3,		/* 3 */
/* 182 */	NdrFcShort( 0x10 ),	/* 16 */
/* 184 */	0x19,		/* Corr desc:  field pointer, FC_ULONG */
			0x0,		/*  */
/* 186 */	NdrFcShort( 0x0 ),	/* 0 */
/* 188 */	NdrFcShort( 0x1 ),	/* Corr flags:  early, */
/* 190 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 192 */	NdrFcShort( 0xffffffa4 ),	/* Offset= -92 (100) */
/* 194 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 196 */	
			0x1b,		/* FC_CARRAY */
			0x3,		/* 3 */
/* 198 */	NdrFcShort( 0x20 ),	/* 32 */
/* 200 */	0x19,		/* Corr desc:  field pointer, FC_ULONG */
			0x0,		/*  */
/* 202 */	NdrFcShort( 0x0 ),	/* 0 */
/* 204 */	NdrFcShort( 0x1 ),	/* Corr flags:  early, */
/* 206 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 208 */	NdrFcShort( 0xffffff9e ),	/* Offset= -98 (110) */
/* 210 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 212 */	
			0x16,		/* FC_PSTRUCT */
			0x3,		/* 3 */
/* 214 */	NdrFcShort( 0x20 ),	/* 32 */
/* 216 */	
			0x4b,		/* FC_PP */
			0x5c,		/* FC_PAD */
/* 218 */	
			0x46,		/* FC_NO_REPEAT */
			0x5c,		/* FC_PAD */
/* 220 */	NdrFcShort( 0x10 ),	/* 16 */
/* 222 */	NdrFcShort( 0x10 ),	/* 16 */
/* 224 */	0x12, 0x0,	/* FC_UP */
/* 226 */	NdrFcShort( 0xffffff82 ),	/* Offset= -126 (100) */
/* 228 */	
			0x46,		/* FC_NO_REPEAT */
			0x5c,		/* FC_PAD */
/* 230 */	NdrFcShort( 0x14 ),	/* 20 */
/* 232 */	NdrFcShort( 0x14 ),	/* 20 */
/* 234 */	0x12, 0x0,	/* FC_UP */
/* 236 */	NdrFcShort( 0xffffffc8 ),	/* Offset= -56 (180) */
/* 238 */	
			0x46,		/* FC_NO_REPEAT */
			0x5c,		/* FC_PAD */
/* 240 */	NdrFcShort( 0x18 ),	/* 24 */
/* 242 */	NdrFcShort( 0x18 ),	/* 24 */
/* 244 */	0x12, 0x0,	/* FC_UP */
/* 246 */	NdrFcShort( 0xffffffce ),	/* Offset= -50 (196) */
/* 248 */	
			0x46,		/* FC_NO_REPEAT */
			0x5c,		/* FC_PAD */
/* 250 */	NdrFcShort( 0x1c ),	/* 28 */
/* 252 */	NdrFcShort( 0x1c ),	/* 28 */
/* 254 */	0x12, 0x0,	/* FC_UP */
/* 256 */	NdrFcShort( 0xffffffc4 ),	/* Offset= -60 (196) */
/* 258 */	
			0x5b,		/* FC_END */

			0x8,		/* FC_LONG */
/* 260 */	0x8,		/* FC_LONG */
			0x8,		/* FC_LONG */
/* 262 */	0x8,		/* FC_LONG */
			0x8,		/* FC_LONG */
/* 264 */	0x8,		/* FC_LONG */
			0x8,		/* FC_LONG */
/* 266 */	0x8,		/* FC_LONG */
			0x5b,		/* FC_END */
/* 268 */	
			0x1b,		/* FC_CARRAY */
			0x3,		/* 3 */
/* 270 */	NdrFcShort( 0x10 ),	/* 16 */
/* 272 */	0x19,		/* Corr desc:  field pointer, FC_ULONG */
			0x0,		/*  */
/* 274 */	NdrFcShort( 0x8 ),	/* 8 */
/* 276 */	NdrFcShort( 0x1 ),	/* Corr flags:  early, */
/* 278 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 280 */	NdrFcShort( 0xffffff4c ),	/* Offset= -180 (100) */
/* 282 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 284 */	
			0x16,		/* FC_PSTRUCT */
			0x3,		/* 3 */
/* 286 */	NdrFcShort( 0x10 ),	/* 16 */
/* 288 */	
			0x4b,		/* FC_PP */
			0x5c,		/* FC_PAD */
/* 290 */	
			0x46,		/* FC_NO_REPEAT */
			0x5c,		/* FC_PAD */
/* 292 */	NdrFcShort( 0x4 ),	/* 4 */
/* 294 */	NdrFcShort( 0x4 ),	/* 4 */
/* 296 */	0x12, 0x0,	/* FC_UP */
/* 298 */	NdrFcShort( 0xffffff9a ),	/* Offset= -102 (196) */
/* 300 */	
			0x46,		/* FC_NO_REPEAT */
			0x5c,		/* FC_PAD */
/* 302 */	NdrFcShort( 0xc ),	/* 12 */
/* 304 */	NdrFcShort( 0xc ),	/* 12 */
/* 306 */	0x12, 0x0,	/* FC_UP */
/* 308 */	NdrFcShort( 0xffffffd8 ),	/* Offset= -40 (268) */
/* 310 */	
			0x5b,		/* FC_END */

			0x8,		/* FC_LONG */
/* 312 */	0x8,		/* FC_LONG */
			0x8,		/* FC_LONG */
/* 314 */	0x8,		/* FC_LONG */
			0x5b,		/* FC_END */
/* 316 */	
			0x15,		/* FC_STRUCT */
			0x0,		/* 0 */
/* 318 */	NdrFcShort( 0x8 ),	/* 8 */
/* 320 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 322 */	NdrFcShort( 0xffffff10 ),	/* Offset= -240 (82) */
/* 324 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 326 */	
			0x15,		/* FC_STRUCT */
			0x3,		/* 3 */
/* 328 */	NdrFcShort( 0x8 ),	/* 8 */
/* 330 */	0x8,		/* FC_LONG */
			0x8,		/* FC_LONG */
/* 332 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 334 */	
			0x1d,		/* FC_SMFARRAY */
			0x0,		/* 0 */
/* 336 */	NdrFcShort( 0x10 ),	/* 16 */
/* 338 */	0x2,		/* FC_CHAR */
			0x5b,		/* FC_END */
/* 340 */	
			0x15,		/* FC_STRUCT */
			0x0,		/* 0 */
/* 342 */	NdrFcShort( 0x10 ),	/* 16 */
/* 344 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 346 */	NdrFcShort( 0xfffffff4 ),	/* Offset= -12 (334) */
/* 348 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 350 */	
			0x15,		/* FC_STRUCT */
			0x3,		/* 3 */
/* 352 */	NdrFcShort( 0x44 ),	/* 68 */
/* 354 */	0x8,		/* FC_LONG */
			0xe,		/* FC_ENUM32 */
/* 356 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 358 */	NdrFcShort( 0xfffffefe ),	/* Offset= -258 (100) */
/* 360 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 362 */	NdrFcShort( 0xffffffd2 ),	/* Offset= -46 (316) */
/* 364 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 366 */	NdrFcShort( 0xffffffce ),	/* Offset= -50 (316) */
/* 368 */	0x8,		/* FC_LONG */
			0x4c,		/* FC_EMBEDDED_COMPLEX */
/* 370 */	0x0,		/* 0 */
			NdrFcShort( 0xffffffd3 ),	/* Offset= -45 (326) */
			0x4c,		/* FC_EMBEDDED_COMPLEX */
/* 374 */	0x0,		/* 0 */
			NdrFcShort( 0xffffffdd ),	/* Offset= -35 (340) */
			0x5b,		/* FC_END */
/* 378 */	
			0x1b,		/* FC_CARRAY */
			0x3,		/* 3 */
/* 380 */	NdrFcShort( 0x44 ),	/* 68 */
/* 382 */	0x19,		/* Corr desc:  field pointer, FC_ULONG */
			0x0,		/*  */
/* 384 */	NdrFcShort( 0x0 ),	/* 0 */
/* 386 */	NdrFcShort( 0x1 ),	/* Corr flags:  early, */
/* 388 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 390 */	NdrFcShort( 0xffffffd8 ),	/* Offset= -40 (350) */
/* 392 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 394 */	
			0x16,		/* FC_PSTRUCT */
			0x3,		/* 3 */
/* 396 */	NdrFcShort( 0x8 ),	/* 8 */
/* 398 */	
			0x4b,		/* FC_PP */
			0x5c,		/* FC_PAD */
/* 400 */	
			0x46,		/* FC_NO_REPEAT */
			0x5c,		/* FC_PAD */
/* 402 */	NdrFcShort( 0x4 ),	/* 4 */
/* 404 */	NdrFcShort( 0x4 ),	/* 4 */
/* 406 */	0x12, 0x0,	/* FC_UP */
/* 408 */	NdrFcShort( 0xffffffe2 ),	/* Offset= -30 (378) */
/* 410 */	
			0x5b,		/* FC_END */

			0x8,		/* FC_LONG */
/* 412 */	0x8,		/* FC_LONG */
			0x5b,		/* FC_END */
/* 414 */	
			0x15,		/* FC_STRUCT */
			0x3,		/* 3 */
/* 416 */	NdrFcShort( 0xc ),	/* 12 */
/* 418 */	0x8,		/* FC_LONG */
			0x8,		/* FC_LONG */
/* 420 */	0x8,		/* FC_LONG */
			0x5b,		/* FC_END */
/* 422 */	
			0x15,		/* FC_STRUCT */
			0x3,		/* 3 */
/* 424 */	NdrFcShort( 0xc8 ),	/* 200 */
/* 426 */	0x8,		/* FC_LONG */
			0x8,		/* FC_LONG */
/* 428 */	0x8,		/* FC_LONG */
			0x8,		/* FC_LONG */
/* 430 */	0x8,		/* FC_LONG */
			0x8,		/* FC_LONG */
/* 432 */	0x8,		/* FC_LONG */
			0x8,		/* FC_LONG */
/* 434 */	0x8,		/* FC_LONG */
			0x8,		/* FC_LONG */
/* 436 */	0x8,		/* FC_LONG */
			0x8,		/* FC_LONG */
/* 438 */	0x8,		/* FC_LONG */
			0x8,		/* FC_LONG */
/* 440 */	0x8,		/* FC_LONG */
			0x8,		/* FC_LONG */
/* 442 */	0x8,		/* FC_LONG */
			0x8,		/* FC_LONG */
/* 444 */	0x8,		/* FC_LONG */
			0x8,		/* FC_LONG */
/* 446 */	0x8,		/* FC_LONG */
			0x8,		/* FC_LONG */
/* 448 */	0x8,		/* FC_LONG */
			0x8,		/* FC_LONG */
/* 450 */	0x8,		/* FC_LONG */
			0x8,		/* FC_LONG */
/* 452 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 454 */	NdrFcShort( 0xffffff80 ),	/* Offset= -128 (326) */
/* 456 */	0x8,		/* FC_LONG */
			0x8,		/* FC_LONG */
/* 458 */	0x8,		/* FC_LONG */
			0x8,		/* FC_LONG */
/* 460 */	0x8,		/* FC_LONG */
			0x4c,		/* FC_EMBEDDED_COMPLEX */
/* 462 */	0x0,		/* 0 */
			NdrFcShort( 0xffffff77 ),	/* Offset= -137 (326) */
			0x8,		/* FC_LONG */
/* 466 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 468 */	NdrFcShort( 0xffffff72 ),	/* Offset= -142 (326) */
/* 470 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 472 */	NdrFcShort( 0xffffff6e ),	/* Offset= -146 (326) */
/* 474 */	0x8,		/* FC_LONG */
			0x8,		/* FC_LONG */
/* 476 */	0x8,		/* FC_LONG */
			0x8,		/* FC_LONG */
/* 478 */	0x8,		/* FC_LONG */
			0x6,		/* FC_SHORT */
/* 480 */	0x6,		/* FC_SHORT */
			0x6,		/* FC_SHORT */
/* 482 */	0x6,		/* FC_SHORT */
			0x4c,		/* FC_EMBEDDED_COMPLEX */
/* 484 */	0x0,		/* 0 */
			NdrFcShort( 0xffffffb9 ),	/* Offset= -71 (414) */
			0x5b,		/* FC_END */
/* 488 */	
			0x15,		/* FC_STRUCT */
			0x3,		/* 3 */
/* 490 */	NdrFcShort( 0x54 ),	/* 84 */
/* 492 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 494 */	NdrFcShort( 0xfffffe80 ),	/* Offset= -384 (110) */
/* 496 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 498 */	NdrFcShort( 0xfffffe7c ),	/* Offset= -388 (110) */
/* 500 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 502 */	NdrFcShort( 0xffffff5e ),	/* Offset= -162 (340) */
/* 504 */	0x8,		/* FC_LONG */
			0x5b,		/* FC_END */
/* 506 */	
			0x1b,		/* FC_CARRAY */
			0x3,		/* 3 */
/* 508 */	NdrFcShort( 0x54 ),	/* 84 */
/* 510 */	0x19,		/* Corr desc:  field pointer, FC_ULONG */
			0x0,		/*  */
/* 512 */	NdrFcShort( 0x0 ),	/* 0 */
/* 514 */	NdrFcShort( 0x1 ),	/* Corr flags:  early, */
/* 516 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 518 */	NdrFcShort( 0xffffffe2 ),	/* Offset= -30 (488) */
/* 520 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 522 */	
			0x16,		/* FC_PSTRUCT */
			0x3,		/* 3 */
/* 524 */	NdrFcShort( 0x8 ),	/* 8 */
/* 526 */	
			0x4b,		/* FC_PP */
			0x5c,		/* FC_PAD */
/* 528 */	
			0x46,		/* FC_NO_REPEAT */
			0x5c,		/* FC_PAD */
/* 530 */	NdrFcShort( 0x4 ),	/* 4 */
/* 532 */	NdrFcShort( 0x4 ),	/* 4 */
/* 534 */	0x12, 0x0,	/* FC_UP */
/* 536 */	NdrFcShort( 0xffffffe2 ),	/* Offset= -30 (506) */
/* 538 */	
			0x5b,		/* FC_END */

			0x8,		/* FC_LONG */
/* 540 */	0x8,		/* FC_LONG */
			0x5b,		/* FC_END */
/* 542 */	
			0x1a,		/* FC_BOGUS_STRUCT */
			0x3,		/* 3 */
/* 544 */	NdrFcShort( 0xd4 ),	/* 212 */
/* 546 */	NdrFcShort( 0x0 ),	/* 0 */
/* 548 */	NdrFcShort( 0xa ),	/* Offset= 10 (558) */
/* 550 */	0xe,		/* FC_ENUM32 */
			0xe,		/* FC_ENUM32 */
/* 552 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 554 */	NdrFcShort( 0xfffffddc ),	/* Offset= -548 (6) */
/* 556 */	0x36,		/* FC_POINTER */
			0x5b,		/* FC_END */
/* 558 */	
			0x12, 0x8,	/* FC_UP [simple_pointer] */
/* 560 */	
			0x25,		/* FC_C_WSTRING */
			0x5c,		/* FC_PAD */

			0x0
        }
    };

static const unsigned short trksvr_FormatStringOffsetTable[] =
    {
    0,
    };


static const unsigned short _callbacktrksvr_FormatStringOffsetTable[] =
    {
    40
    };


static const MIDL_STUB_DESC trksvr_StubDesc = 
    {
    (void *)& trksvr___RpcServerInterface,
    MIDL_user_allocate,
    MIDL_user_free,
    0,
    0,
    0,
    0,
    0,
    __MIDL_TypeFormatString.Format,
    1, /* -error bounds_check flag */
    0x50002, /* Ndr library version */
    0,
    0x600015b, /* MIDL Version 6.0.347 */
    0,
    0,
    0,  /* notify & notify_flag routine table */
    0x1, /* MIDL flag */
    0, /* cs routines */
    0,   /* proxy/server info */
    0   /* Reserved5 */
    };

static RPC_DISPATCH_FUNCTION trksvr_table[] =
    {
    NdrServerCall2,
    0
    };
RPC_DISPATCH_TABLE trksvr_v1_0_DispatchTable = 
    {
    1,
    trksvr_table
    };

static const SERVER_ROUTINE trksvr_ServerRoutineTable[] = 
    {
    (SERVER_ROUTINE)StubLnkSvrMessage,
    };

static const MIDL_SERVER_INFO trksvr_ServerInfo = 
    {
    &trksvr_StubDesc,
    trksvr_ServerRoutineTable,
    __MIDL_ProcFormatString.Format,
    trksvr_FormatStringOffsetTable,
    0,
    0,
    0,
    0};


#endif /* !defined(_M_IA64) && !defined(_M_AMD64)*/


#pragma warning( disable: 4049 )  /* more than 64k source lines */

/* this ALWAYS GENERATED file contains the RPC server stubs */


 /* File created by MIDL compiler version 6.00.0347 */
/* Compiler settings for trksvr.idl:
    Oicf, W1, Zp8, env=Win64 (32b run,appending)
    protocol : dce , ms_ext, c_ext, robust
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )

#if defined(_M_IA64) || defined(_M_AMD64)
#include <string.h>
#include "trksvr.h"

#define TYPE_FORMAT_STRING_SIZE   545                               
#define PROC_FORMAT_STRING_SIZE   81                                
#define TRANSMIT_AS_TABLE_SIZE    0            
#define WIRE_MARSHAL_TABLE_SIZE   0            

typedef struct _MIDL_TYPE_FORMAT_STRING
    {
    short          Pad;
    unsigned char  Format[ TYPE_FORMAT_STRING_SIZE ];
    } MIDL_TYPE_FORMAT_STRING;

typedef struct _MIDL_PROC_FORMAT_STRING
    {
    short          Pad;
    unsigned char  Format[ PROC_FORMAT_STRING_SIZE ];
    } MIDL_PROC_FORMAT_STRING;


static RPC_SYNTAX_IDENTIFIER  _RpcTransferSyntax = 
{{0x8A885D04,0x1CEB,0x11C9,{0x9F,0xE8,0x08,0x00,0x2B,0x10,0x48,0x60}},{2,0}};

extern const MIDL_TYPE_FORMAT_STRING __MIDL_TypeFormatString;
extern const MIDL_PROC_FORMAT_STRING __MIDL_ProcFormatString;

/* Standard interface: __MIDL_itf_trksvr_0000, ver. 0.0,
   GUID={0x00000000,0x0000,0x0000,{0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00}} */


/* Standard interface: trksvr, ver. 1.0,
   GUID={0x4da1c422,0x943d,0x11d1,{0xac,0xae,0x00,0xc0,0x4f,0xc2,0xaa,0x3f}} */


extern const MIDL_SERVER_INFO trksvr_ServerInfo;

extern RPC_DISPATCH_TABLE trksvr_v1_0_DispatchTable;

static const RPC_SERVER_INTERFACE trksvr___RpcServerInterface =
    {
    sizeof(RPC_SERVER_INTERFACE),
    {{0x4da1c422,0x943d,0x11d1,{0xac,0xae,0x00,0xc0,0x4f,0xc2,0xaa,0x3f}},{1,0}},
    {{0x8A885D04,0x1CEB,0x11C9,{0x9F,0xE8,0x08,0x00,0x2B,0x10,0x48,0x60}},{2,0}},
    &trksvr_v1_0_DispatchTable,
    0,
    0,
    0,
    &trksvr_ServerInfo,
    0x04000000
    };
RPC_IF_HANDLE Stubtrksvr_v1_0_s_ifspec = (RPC_IF_HANDLE)& trksvr___RpcServerInterface;

extern const MIDL_STUB_DESC trksvr_StubDesc;

 extern const MIDL_STUBLESS_PROXY_INFO trksvr_ProxyInfo;

/* [callback] */ HRESULT LnkSvrMessageCallback( 
    /* [out][in] */ TRKSVR_MESSAGE_UNION *pMsg)
{

    CLIENT_CALL_RETURN _RetVal;

    _RetVal = NdrClientCall2(
                  ( PMIDL_STUB_DESC  )&trksvr_StubDesc,
                  (PFORMAT_STRING) &__MIDL_ProcFormatString.Format[42],
                  pMsg);
    return ( HRESULT  )_RetVal.Simple;
    
}


#if !defined(__RPC_WIN64__)
#error  Invalid build platform for this stub.
#endif

static const MIDL_PROC_FORMAT_STRING __MIDL_ProcFormatString =
    {
        0,
        {

	/* Procedure LnkSvrMessage */

			0x0,		/* 0 */
			0x48,		/* Old Flags:  */
/*  2 */	NdrFcLong( 0x0 ),	/* 0 */
/*  6 */	NdrFcShort( 0x0 ),	/* 0 */
/*  8 */	NdrFcShort( 0x18 ),	/* ia64 Stack size/offset = 24 */
/* 10 */	0x32,		/* FC_BIND_PRIMITIVE */
			0x0,		/* 0 */
/* 12 */	NdrFcShort( 0x0 ),	/* ia64 Stack size/offset = 0 */
/* 14 */	NdrFcShort( 0x0 ),	/* 0 */
/* 16 */	NdrFcShort( 0x8 ),	/* 8 */
/* 18 */	0x47,		/* Oi2 Flags:  srv must size, clt must size, has return, has ext, */
			0x2,		/* 2 */
/* 20 */	0xa,		/* 10 */
			0x7,		/* Ext Flags:  new corr desc, clt corr check, srv corr check, */
/* 22 */	NdrFcShort( 0xb ),	/* 11 */
/* 24 */	NdrFcShort( 0xb ),	/* 11 */
/* 26 */	NdrFcShort( 0x0 ),	/* 0 */
/* 28 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter IDL_handle */

/* 30 */	NdrFcShort( 0x11b ),	/* Flags:  must size, must free, in, out, simple ref, */
/* 32 */	NdrFcShort( 0x8 ),	/* ia64 Stack size/offset = 8 */
/* 34 */	NdrFcShort( 0x20c ),	/* Type Offset=524 */

	/* Parameter pMsg */

/* 36 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 38 */	NdrFcShort( 0x10 ),	/* ia64 Stack size/offset = 16 */
/* 40 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure LnkSvrMessageCallback */


	/* Return value */

/* 42 */	0x34,		/* FC_CALLBACK_HANDLE */
			0x48,		/* Old Flags:  */
/* 44 */	NdrFcLong( 0x0 ),	/* 0 */
/* 48 */	NdrFcShort( 0x0 ),	/* 0 */
/* 50 */	NdrFcShort( 0x10 ),	/* ia64 Stack size/offset = 16 */
/* 52 */	NdrFcShort( 0x0 ),	/* 0 */
/* 54 */	NdrFcShort( 0x8 ),	/* 8 */
/* 56 */	0x47,		/* Oi2 Flags:  srv must size, clt must size, has return, has ext, */
			0x2,		/* 2 */
/* 58 */	0xa,		/* 10 */
			0x7,		/* Ext Flags:  new corr desc, clt corr check, srv corr check, */
/* 60 */	NdrFcShort( 0xb ),	/* 11 */
/* 62 */	NdrFcShort( 0xb ),	/* 11 */
/* 64 */	NdrFcShort( 0x0 ),	/* 0 */
/* 66 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter pMsg */

/* 68 */	NdrFcShort( 0x11b ),	/* Flags:  must size, must free, in, out, simple ref, */
/* 70 */	NdrFcShort( 0x0 ),	/* ia64 Stack size/offset = 0 */
/* 72 */	NdrFcShort( 0x20c ),	/* Type Offset=524 */

	/* Return value */

/* 74 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 76 */	NdrFcShort( 0x8 ),	/* ia64 Stack size/offset = 8 */
/* 78 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

			0x0
        }
    };

static const MIDL_TYPE_FORMAT_STRING __MIDL_TypeFormatString =
    {
        0,
        {
			NdrFcShort( 0x0 ),	/* 0 */
/*  2 */	
			0x11, 0x0,	/* FC_RP */
/*  4 */	NdrFcShort( 0x208 ),	/* Offset= 520 (524) */
/*  6 */	
			0x2b,		/* FC_NON_ENCAPSULATED_UNION */
			0x8,		/* FC_LONG */
/*  8 */	0x8,		/* Corr desc: FC_LONG */
			0x0,		/*  */
/* 10 */	NdrFcShort( 0xfff8 ),	/* -8 */
/* 12 */	NdrFcShort( 0x1 ),	/* Corr flags:  early, */
/* 14 */	NdrFcShort( 0x2 ),	/* Offset= 2 (16) */
/* 16 */	NdrFcShort( 0xc8 ),	/* 200 */
/* 18 */	NdrFcShort( 0x9 ),	/* 9 */
/* 20 */	NdrFcLong( 0x0 ),	/* 0 */
/* 24 */	NdrFcShort( 0x88 ),	/* Offset= 136 (160) */
/* 26 */	NdrFcLong( 0x1 ),	/* 1 */
/* 30 */	NdrFcShort( 0xb2 ),	/* Offset= 178 (208) */
/* 32 */	NdrFcLong( 0x2 ),	/* 2 */
/* 36 */	NdrFcShort( 0xde ),	/* Offset= 222 (258) */
/* 38 */	NdrFcLong( 0x3 ),	/* 3 */
/* 42 */	NdrFcShort( 0x13e ),	/* Offset= 318 (360) */
/* 44 */	NdrFcLong( 0x4 ),	/* 4 */
/* 48 */	NdrFcShort( 0x148 ),	/* Offset= 328 (376) */
/* 50 */	NdrFcLong( 0x5 ),	/* 5 */
/* 54 */	NdrFcShort( 0x162 ),	/* Offset= 354 (408) */
/* 56 */	NdrFcLong( 0x6 ),	/* 6 */
/* 60 */	NdrFcShort( 0x1c0 ),	/* Offset= 448 (508) */
/* 62 */	NdrFcLong( 0x7 ),	/* 7 */
/* 66 */	NdrFcShort( 0xe2 ),	/* Offset= 226 (292) */
/* 68 */	NdrFcLong( 0x8 ),	/* 8 */
/* 72 */	NdrFcShort( 0x8008 ),	/* Simple arm type: FC_LONG */
/* 74 */	NdrFcShort( 0xffffffff ),	/* Offset= -1 (73) */
/* 76 */	
			0x1d,		/* FC_SMFARRAY */
			0x1,		/* 1 */
/* 78 */	NdrFcShort( 0x202 ),	/* 514 */
/* 80 */	0x5,		/* FC_WCHAR */
			0x5b,		/* FC_END */
/* 82 */	
			0x1d,		/* FC_SMFARRAY */
			0x0,		/* 0 */
/* 84 */	NdrFcShort( 0x8 ),	/* 8 */
/* 86 */	0x1,		/* FC_BYTE */
			0x5b,		/* FC_END */
/* 88 */	
			0x15,		/* FC_STRUCT */
			0x3,		/* 3 */
/* 90 */	NdrFcShort( 0x10 ),	/* 16 */
/* 92 */	0x8,		/* FC_LONG */
			0x6,		/* FC_SHORT */
/* 94 */	0x6,		/* FC_SHORT */
			0x4c,		/* FC_EMBEDDED_COMPLEX */
/* 96 */	0x0,		/* 0 */
			NdrFcShort( 0xfffffff1 ),	/* Offset= -15 (82) */
			0x5b,		/* FC_END */
/* 100 */	
			0x15,		/* FC_STRUCT */
			0x3,		/* 3 */
/* 102 */	NdrFcShort( 0x10 ),	/* 16 */
/* 104 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 106 */	NdrFcShort( 0xffffffee ),	/* Offset= -18 (88) */
/* 108 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 110 */	
			0x15,		/* FC_STRUCT */
			0x3,		/* 3 */
/* 112 */	NdrFcShort( 0x20 ),	/* 32 */
/* 114 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 116 */	NdrFcShort( 0xfffffff0 ),	/* Offset= -16 (100) */
/* 118 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 120 */	NdrFcShort( 0xffffffec ),	/* Offset= -20 (100) */
/* 122 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 124 */	
			0x15,		/* FC_STRUCT */
			0x3,		/* 3 */
/* 126 */	NdrFcShort( 0x248 ),	/* 584 */
/* 128 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 130 */	NdrFcShort( 0xffffffca ),	/* Offset= -54 (76) */
/* 132 */	0x3e,		/* FC_STRUCTPAD2 */
			0x4c,		/* FC_EMBEDDED_COMPLEX */
/* 134 */	0x0,		/* 0 */
			NdrFcShort( 0xffffffe7 ),	/* Offset= -25 (110) */
			0x4c,		/* FC_EMBEDDED_COMPLEX */
/* 138 */	0x0,		/* 0 */
			NdrFcShort( 0xffffffe3 ),	/* Offset= -29 (110) */
			0x8,		/* FC_LONG */
/* 142 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 144 */	
			0x1b,		/* FC_CARRAY */
			0x3,		/* 3 */
/* 146 */	NdrFcShort( 0x248 ),	/* 584 */
/* 148 */	0x19,		/* Corr desc:  field pointer, FC_ULONG */
			0x0,		/*  */
/* 150 */	NdrFcShort( 0x0 ),	/* 0 */
/* 152 */	NdrFcShort( 0x1 ),	/* Corr flags:  early, */
/* 154 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 156 */	NdrFcShort( 0xffffffe0 ),	/* Offset= -32 (124) */
/* 158 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 160 */	
			0x1a,		/* FC_BOGUS_STRUCT */
			0x3,		/* 3 */
/* 162 */	NdrFcShort( 0x10 ),	/* 16 */
/* 164 */	NdrFcShort( 0x0 ),	/* 0 */
/* 166 */	NdrFcShort( 0x6 ),	/* Offset= 6 (172) */
/* 168 */	0x8,		/* FC_LONG */
			0x40,		/* FC_STRUCTPAD4 */
/* 170 */	0x36,		/* FC_POINTER */
			0x5b,		/* FC_END */
/* 172 */	
			0x12, 0x0,	/* FC_UP */
/* 174 */	NdrFcShort( 0xffffffe2 ),	/* Offset= -30 (144) */
/* 176 */	
			0x1b,		/* FC_CARRAY */
			0x3,		/* 3 */
/* 178 */	NdrFcShort( 0x10 ),	/* 16 */
/* 180 */	0x19,		/* Corr desc:  field pointer, FC_ULONG */
			0x0,		/*  */
/* 182 */	NdrFcShort( 0x0 ),	/* 0 */
/* 184 */	NdrFcShort( 0x1 ),	/* Corr flags:  early, */
/* 186 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 188 */	NdrFcShort( 0xffffffa8 ),	/* Offset= -88 (100) */
/* 190 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 192 */	
			0x1b,		/* FC_CARRAY */
			0x3,		/* 3 */
/* 194 */	NdrFcShort( 0x20 ),	/* 32 */
/* 196 */	0x19,		/* Corr desc:  field pointer, FC_ULONG */
			0x0,		/*  */
/* 198 */	NdrFcShort( 0x0 ),	/* 0 */
/* 200 */	NdrFcShort( 0x1 ),	/* Corr flags:  early, */
/* 202 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 204 */	NdrFcShort( 0xffffffa2 ),	/* Offset= -94 (110) */
/* 206 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 208 */	
			0x1a,		/* FC_BOGUS_STRUCT */
			0x3,		/* 3 */
/* 210 */	NdrFcShort( 0x30 ),	/* 48 */
/* 212 */	NdrFcShort( 0x0 ),	/* 0 */
/* 214 */	NdrFcShort( 0xc ),	/* Offset= 12 (226) */
/* 216 */	0x8,		/* FC_LONG */
			0x8,		/* FC_LONG */
/* 218 */	0x8,		/* FC_LONG */
			0x8,		/* FC_LONG */
/* 220 */	0x36,		/* FC_POINTER */
			0x36,		/* FC_POINTER */
/* 222 */	0x36,		/* FC_POINTER */
			0x36,		/* FC_POINTER */
/* 224 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 226 */	
			0x12, 0x0,	/* FC_UP */
/* 228 */	NdrFcShort( 0xffffff80 ),	/* Offset= -128 (100) */
/* 230 */	
			0x12, 0x0,	/* FC_UP */
/* 232 */	NdrFcShort( 0xffffffc8 ),	/* Offset= -56 (176) */
/* 234 */	
			0x12, 0x0,	/* FC_UP */
/* 236 */	NdrFcShort( 0xffffffd4 ),	/* Offset= -44 (192) */
/* 238 */	
			0x12, 0x0,	/* FC_UP */
/* 240 */	NdrFcShort( 0xffffffd0 ),	/* Offset= -48 (192) */
/* 242 */	
			0x1b,		/* FC_CARRAY */
			0x3,		/* 3 */
/* 244 */	NdrFcShort( 0x10 ),	/* 16 */
/* 246 */	0x19,		/* Corr desc:  field pointer, FC_ULONG */
			0x0,		/*  */
/* 248 */	NdrFcShort( 0x10 ),	/* 16 */
/* 250 */	NdrFcShort( 0x1 ),	/* Corr flags:  early, */
/* 252 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 254 */	NdrFcShort( 0xffffff66 ),	/* Offset= -154 (100) */
/* 256 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 258 */	
			0x1a,		/* FC_BOGUS_STRUCT */
			0x3,		/* 3 */
/* 260 */	NdrFcShort( 0x20 ),	/* 32 */
/* 262 */	NdrFcShort( 0x0 ),	/* 0 */
/* 264 */	NdrFcShort( 0xa ),	/* Offset= 10 (274) */
/* 266 */	0x8,		/* FC_LONG */
			0x40,		/* FC_STRUCTPAD4 */
/* 268 */	0x36,		/* FC_POINTER */
			0x8,		/* FC_LONG */
/* 270 */	0x40,		/* FC_STRUCTPAD4 */
			0x36,		/* FC_POINTER */
/* 272 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 274 */	
			0x12, 0x0,	/* FC_UP */
/* 276 */	NdrFcShort( 0xffffffac ),	/* Offset= -84 (192) */
/* 278 */	
			0x12, 0x0,	/* FC_UP */
/* 280 */	NdrFcShort( 0xffffffda ),	/* Offset= -38 (242) */
/* 282 */	
			0x15,		/* FC_STRUCT */
			0x0,		/* 0 */
/* 284 */	NdrFcShort( 0x8 ),	/* 8 */
/* 286 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 288 */	NdrFcShort( 0xffffff32 ),	/* Offset= -206 (82) */
/* 290 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 292 */	
			0x15,		/* FC_STRUCT */
			0x3,		/* 3 */
/* 294 */	NdrFcShort( 0x8 ),	/* 8 */
/* 296 */	0x8,		/* FC_LONG */
			0x8,		/* FC_LONG */
/* 298 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 300 */	
			0x1d,		/* FC_SMFARRAY */
			0x0,		/* 0 */
/* 302 */	NdrFcShort( 0x10 ),	/* 16 */
/* 304 */	0x2,		/* FC_CHAR */
			0x5b,		/* FC_END */
/* 306 */	
			0x15,		/* FC_STRUCT */
			0x0,		/* 0 */
/* 308 */	NdrFcShort( 0x10 ),	/* 16 */
/* 310 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 312 */	NdrFcShort( 0xfffffff4 ),	/* Offset= -12 (300) */
/* 314 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 316 */	
			0x15,		/* FC_STRUCT */
			0x3,		/* 3 */
/* 318 */	NdrFcShort( 0x44 ),	/* 68 */
/* 320 */	0x8,		/* FC_LONG */
			0xe,		/* FC_ENUM32 */
/* 322 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 324 */	NdrFcShort( 0xffffff20 ),	/* Offset= -224 (100) */
/* 326 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 328 */	NdrFcShort( 0xffffffd2 ),	/* Offset= -46 (282) */
/* 330 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 332 */	NdrFcShort( 0xffffffce ),	/* Offset= -50 (282) */
/* 334 */	0x8,		/* FC_LONG */
			0x4c,		/* FC_EMBEDDED_COMPLEX */
/* 336 */	0x0,		/* 0 */
			NdrFcShort( 0xffffffd3 ),	/* Offset= -45 (292) */
			0x4c,		/* FC_EMBEDDED_COMPLEX */
/* 340 */	0x0,		/* 0 */
			NdrFcShort( 0xffffffdd ),	/* Offset= -35 (306) */
			0x5b,		/* FC_END */
/* 344 */	
			0x1b,		/* FC_CARRAY */
			0x3,		/* 3 */
/* 346 */	NdrFcShort( 0x44 ),	/* 68 */
/* 348 */	0x19,		/* Corr desc:  field pointer, FC_ULONG */
			0x0,		/*  */
/* 350 */	NdrFcShort( 0x0 ),	/* 0 */
/* 352 */	NdrFcShort( 0x1 ),	/* Corr flags:  early, */
/* 354 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 356 */	NdrFcShort( 0xffffffd8 ),	/* Offset= -40 (316) */
/* 358 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 360 */	
			0x1a,		/* FC_BOGUS_STRUCT */
			0x3,		/* 3 */
/* 362 */	NdrFcShort( 0x10 ),	/* 16 */
/* 364 */	NdrFcShort( 0x0 ),	/* 0 */
/* 366 */	NdrFcShort( 0x6 ),	/* Offset= 6 (372) */
/* 368 */	0x8,		/* FC_LONG */
			0x40,		/* FC_STRUCTPAD4 */
/* 370 */	0x36,		/* FC_POINTER */
			0x5b,		/* FC_END */
/* 372 */	
			0x12, 0x0,	/* FC_UP */
/* 374 */	NdrFcShort( 0xffffffe2 ),	/* Offset= -30 (344) */
/* 376 */	
			0x1a,		/* FC_BOGUS_STRUCT */
			0x3,		/* 3 */
/* 378 */	NdrFcShort( 0x20 ),	/* 32 */
/* 380 */	NdrFcShort( 0x0 ),	/* 0 */
/* 382 */	NdrFcShort( 0xa ),	/* Offset= 10 (392) */
/* 384 */	0x8,		/* FC_LONG */
			0x40,		/* FC_STRUCTPAD4 */
/* 386 */	0x36,		/* FC_POINTER */
			0x8,		/* FC_LONG */
/* 388 */	0x40,		/* FC_STRUCTPAD4 */
			0x36,		/* FC_POINTER */
/* 390 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 392 */	
			0x12, 0x0,	/* FC_UP */
/* 394 */	NdrFcShort( 0xffffff36 ),	/* Offset= -202 (192) */
/* 396 */	
			0x12, 0x0,	/* FC_UP */
/* 398 */	NdrFcShort( 0xffffff64 ),	/* Offset= -156 (242) */
/* 400 */	
			0x15,		/* FC_STRUCT */
			0x3,		/* 3 */
/* 402 */	NdrFcShort( 0xc ),	/* 12 */
/* 404 */	0x8,		/* FC_LONG */
			0x8,		/* FC_LONG */
/* 406 */	0x8,		/* FC_LONG */
			0x5b,		/* FC_END */
/* 408 */	
			0x15,		/* FC_STRUCT */
			0x3,		/* 3 */
/* 410 */	NdrFcShort( 0xc8 ),	/* 200 */
/* 412 */	0x8,		/* FC_LONG */
			0x8,		/* FC_LONG */
/* 414 */	0x8,		/* FC_LONG */
			0x8,		/* FC_LONG */
/* 416 */	0x8,		/* FC_LONG */
			0x8,		/* FC_LONG */
/* 418 */	0x8,		/* FC_LONG */
			0x8,		/* FC_LONG */
/* 420 */	0x8,		/* FC_LONG */
			0x8,		/* FC_LONG */
/* 422 */	0x8,		/* FC_LONG */
			0x8,		/* FC_LONG */
/* 424 */	0x8,		/* FC_LONG */
			0x8,		/* FC_LONG */
/* 426 */	0x8,		/* FC_LONG */
			0x8,		/* FC_LONG */
/* 428 */	0x8,		/* FC_LONG */
			0x8,		/* FC_LONG */
/* 430 */	0x8,		/* FC_LONG */
			0x8,		/* FC_LONG */
/* 432 */	0x8,		/* FC_LONG */
			0x8,		/* FC_LONG */
/* 434 */	0x8,		/* FC_LONG */
			0x8,		/* FC_LONG */
/* 436 */	0x8,		/* FC_LONG */
			0x8,		/* FC_LONG */
/* 438 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 440 */	NdrFcShort( 0xffffff6c ),	/* Offset= -148 (292) */
/* 442 */	0x8,		/* FC_LONG */
			0x8,		/* FC_LONG */
/* 444 */	0x8,		/* FC_LONG */
			0x8,		/* FC_LONG */
/* 446 */	0x8,		/* FC_LONG */
			0x4c,		/* FC_EMBEDDED_COMPLEX */
/* 448 */	0x0,		/* 0 */
			NdrFcShort( 0xffffff63 ),	/* Offset= -157 (292) */
			0x8,		/* FC_LONG */
/* 452 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 454 */	NdrFcShort( 0xffffff5e ),	/* Offset= -162 (292) */
/* 456 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 458 */	NdrFcShort( 0xffffff5a ),	/* Offset= -166 (292) */
/* 460 */	0x8,		/* FC_LONG */
			0x8,		/* FC_LONG */
/* 462 */	0x8,		/* FC_LONG */
			0x8,		/* FC_LONG */
/* 464 */	0x8,		/* FC_LONG */
			0x6,		/* FC_SHORT */
/* 466 */	0x6,		/* FC_SHORT */
			0x6,		/* FC_SHORT */
/* 468 */	0x6,		/* FC_SHORT */
			0x4c,		/* FC_EMBEDDED_COMPLEX */
/* 470 */	0x0,		/* 0 */
			NdrFcShort( 0xffffffb9 ),	/* Offset= -71 (400) */
			0x5b,		/* FC_END */
/* 474 */	
			0x15,		/* FC_STRUCT */
			0x3,		/* 3 */
/* 476 */	NdrFcShort( 0x54 ),	/* 84 */
/* 478 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 480 */	NdrFcShort( 0xfffffe8e ),	/* Offset= -370 (110) */
/* 482 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 484 */	NdrFcShort( 0xfffffe8a ),	/* Offset= -374 (110) */
/* 486 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 488 */	NdrFcShort( 0xffffff4a ),	/* Offset= -182 (306) */
/* 490 */	0x8,		/* FC_LONG */
			0x5b,		/* FC_END */
/* 492 */	
			0x1b,		/* FC_CARRAY */
			0x3,		/* 3 */
/* 494 */	NdrFcShort( 0x54 ),	/* 84 */
/* 496 */	0x19,		/* Corr desc:  field pointer, FC_ULONG */
			0x0,		/*  */
/* 498 */	NdrFcShort( 0x0 ),	/* 0 */
/* 500 */	NdrFcShort( 0x1 ),	/* Corr flags:  early, */
/* 502 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 504 */	NdrFcShort( 0xffffffe2 ),	/* Offset= -30 (474) */
/* 506 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 508 */	
			0x1a,		/* FC_BOGUS_STRUCT */
			0x3,		/* 3 */
/* 510 */	NdrFcShort( 0x10 ),	/* 16 */
/* 512 */	NdrFcShort( 0x0 ),	/* 0 */
/* 514 */	NdrFcShort( 0x6 ),	/* Offset= 6 (520) */
/* 516 */	0x8,		/* FC_LONG */
			0x40,		/* FC_STRUCTPAD4 */
/* 518 */	0x36,		/* FC_POINTER */
			0x5b,		/* FC_END */
/* 520 */	
			0x12, 0x0,	/* FC_UP */
/* 522 */	NdrFcShort( 0xffffffe2 ),	/* Offset= -30 (492) */
/* 524 */	
			0x1a,		/* FC_BOGUS_STRUCT */
			0x3,		/* 3 */
/* 526 */	NdrFcShort( 0xd8 ),	/* 216 */
/* 528 */	NdrFcShort( 0x0 ),	/* 0 */
/* 530 */	NdrFcShort( 0xa ),	/* Offset= 10 (540) */
/* 532 */	0xe,		/* FC_ENUM32 */
			0xe,		/* FC_ENUM32 */
/* 534 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 536 */	NdrFcShort( 0xfffffdee ),	/* Offset= -530 (6) */
/* 538 */	0x36,		/* FC_POINTER */
			0x5b,		/* FC_END */
/* 540 */	
			0x12, 0x8,	/* FC_UP [simple_pointer] */
/* 542 */	
			0x25,		/* FC_C_WSTRING */
			0x5c,		/* FC_PAD */

			0x0
        }
    };

static const unsigned short trksvr_FormatStringOffsetTable[] =
    {
    0,
    };


static const unsigned short _callbacktrksvr_FormatStringOffsetTable[] =
    {
    42
    };


static const MIDL_STUB_DESC trksvr_StubDesc = 
    {
    (void *)& trksvr___RpcServerInterface,
    MIDL_user_allocate,
    MIDL_user_free,
    0,
    0,
    0,
    0,
    0,
    __MIDL_TypeFormatString.Format,
    1, /* -error bounds_check flag */
    0x50002, /* Ndr library version */
    0,
    0x600015b, /* MIDL Version 6.0.347 */
    0,
    0,
    0,  /* notify & notify_flag routine table */
    0x1, /* MIDL flag */
    0, /* cs routines */
    0,   /* proxy/server info */
    0   /* Reserved5 */
    };

static RPC_DISPATCH_FUNCTION trksvr_table[] =
    {
    NdrServerCall2,
    0
    };
RPC_DISPATCH_TABLE trksvr_v1_0_DispatchTable = 
    {
    1,
    trksvr_table
    };

static const SERVER_ROUTINE trksvr_ServerRoutineTable[] = 
    {
    (SERVER_ROUTINE)StubLnkSvrMessage,
    };

static const MIDL_SERVER_INFO trksvr_ServerInfo = 
    {
    &trksvr_StubDesc,
    trksvr_ServerRoutineTable,
    __MIDL_ProcFormatString.Format,
    trksvr_FormatStringOffsetTable,
    0,
    0,
    0,
    0};


#endif /* defined(_M_IA64) || defined(_M_AMD64)*/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\public\internal\drivers\inc\efsstruc.h ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved.

Module Name:

    efsstruc.h

Abstract:

    EFS (Encrypting File System) defines, data and function prototypes.

Author:

    Robert Reichel      (RobertRe)
    Robert Gu           (RobertG)

Environment:

Revision History:

--*/

#ifndef _EFSSTRUC_
#define _EFSSTRUC_

#ifdef __cplusplus
extern "C" {
#endif

#ifndef ALGIDDEF
#define ALGIDDEF
typedef unsigned int ALG_ID;
#endif

//
// Our OID.  Remove from here once it's in the real headers.
//

#ifndef szOID_EFS_CRYPTO
#define szOID_EFS_CRYPTO	"1.3.6.1.4.1.311.10.3.4"
#endif

#ifndef szOID_EFS_RECOVERY
#define szOID_EFS_RECOVERY      "1.3.6.1.4.1.311.10.3.4.1"
#endif


//
// Context flag
//

#define CONTEXT_FOR_EXPORT      0x00000000
#define CONTEXT_FOR_IMPORT      0x00000001
#define CONTEXT_INVALID         0x00000002
#define CONTEXT_OPEN_FOR_DIR    0x00008000

//
// Context ID
//
#define EFS_CONTEXT_ID  0x00000001

//
// Signature type
//
#define SIG_LENGTH              0x00000008
#define SIG_NO_MATCH            0x00000000
#define SIG_EFS_FILE            0x00000001
#define SIG_EFS_STREAM          0x00000002
#define SIG_EFS_DATA            0x00000003

//
// Export file format stream flag information
//

#define STREAM_NOT_ENCRYPTED    0x0001

#define EFS_EXP_FORMAT_CURRENT_VERSION  0x0100
#define EFS_SIGNATURE_LENGTH    4
#define EFS_STREAM_ID    0x1910

#define FSCTL_IMPORT_INPUT_LENGTH 4 * 1024
#define FSCTL_EXPORT_INPUT_LENGTH 128
#define FSCTL_OUTPUT_INITIAL_LENGTH    68 * 1024
#define FSCTL_OUTPUT_LESS_LENGTH       8 * 1024
#define FSCTL_OUTPUT_MIN_LENGTH        20 * 1024
#define FSCTL_OUTPUT_MISC_LENGTH       4 * 1024

//
// FSCTL data shared between server and driver
//

#define EFS_SET_ENCRYPT                 0
#define EFS_SET_ATTRIBUTE               1
#define EFS_DEL_ATTRIBUTE               2
#define EFS_GET_ATTRIBUTE               3
#define EFS_OVERWRITE_ATTRIBUTE         4
#define EFS_ENCRYPT_DONE                5
#define EFS_DECRYPT_BEGIN               6

//
// Mask for Set EFS Attribute
//

#define WRITE_EFS_ATTRIBUTE     0x00000001
#define SET_EFS_KEYBLOB         0x00000002

//
// Sub code of SET_ENCRYPT FSCTL
//

#define EFS_FSCTL_ON_DIR                0x80000000
#define EFS_ENCRYPT_FILE                0x00000001
#define EFS_DECRYPT_FILE                0x00000002
#define EFS_ENCRYPT_STREAM              0x00000003
#define EFS_DECRYPT_STREAM              0x00000004
#define EFS_DECRYPT_DIRFILE             0x80000002
#define EFS_ENCRYPT_DIRSTR              0x80000003
#define EFS_DECRYPT_DIRSTR              0x80000004


//
// EFS Version Information
//
// EFS_CURRENT_VERSION must always be the highest known revision
// level.  This value is placed in the EfsVersion field of the
// $EFS header.
//

#define EFS_VERSION_1                   (0x00000001)
#define EFS_VERSION_2                   (0x00000002)
#define EFS_CURRENT_VERSION             EFS_VERSION_2



///////////////////////////////////////////////////////////////////////////////
//                                                                            /
// EFS Data structures                                                        /
//                                                                            /
///////////////////////////////////////////////////////////////////////////////


/////////////////////////////////////////////////////////////////////
//                                                                  /
// EFS_KEY Structure                                                /
//                                                                  /
/////////////////////////////////////////////////////////////////////

typedef struct _EFS_KEY {

    //
    // The length in bytes of the appended key.
    //

    ULONG KeyLength;

    //
    // The number of bits of entropy in the key.
    // For example, an 8 byte key has 56 bits of
    // entropy.
    //

    ULONG Entropy;

    //
    // The algorithm used in conjunction with this key.
    //
    // Note: this is not the algorithm used to encrypt the
    // actual key data itself.
    //

    ALG_ID Algorithm;

    //
    // This structure must be a multiple of 8 in size,
    // including the KeyData at the end.
    //

    ULONG Pad;

    //
    // KeyData is appended to the end of the structure.
    //

    // UCHAR KeyData[1];

} EFS_KEY, *PEFS_KEY;

//
// Private macros to manipulate data structures
//

#define EFS_KEY_SIZE( pKey ) (sizeof( EFS_KEY ) + (pKey)->KeyLength)

#define EFS_KEY_DATA( Key )  (PUCHAR)(((PUCHAR)(Key)) + sizeof( EFS_KEY ))

#define OFFSET_TO_POINTER( FieldName, Base )  ((PCHAR)(Base) + (Base)->FieldName)

#define POINTER_TO_OFFSET( Pointer, Base ) (((PUCHAR)(Pointer)) - ((PUCHAR)(Base)))

//
// We're going to use MD5 to hash the EFS stream.  MD5 yields a 16 byte long hash.
//

#define MD5_HASH_SIZE   16

typedef struct _EFS_DATA_STREAM_HEADER {
    ULONG Length;
    ULONG State;
    ULONG EfsVersion;
    ULONG CryptoApiVersion;
    GUID  EfsId;
    UCHAR EfsHash[MD5_HASH_SIZE];
    UCHAR DrfIntegrity[MD5_HASH_SIZE];
    ULONG DataDecryptionField;          //Offset to DDF
    ULONG DataRecoveryField;            //Offset to DRF
    ULONG Reserved;
    ULONG Reserved2;
    ULONG Reserved3;
} EFS_DATA_STREAM_HEADER, *PEFS_DATA_STREAM_HEADER;



///////////////////////////////////////////////////////////////////////////////
//                                                                            /
// EFS_PUBLIC_KEY_INFO                                                        /
//                                                                            /
// This structure is used to contain all the information necessary to decrypt /
// the FEK.                                                                   /
//                                                                            /
///////////////////////////////////////////////////////////////////////////////


typedef struct _EFS_CERT_HASH_DATA {
    ULONG   pbHash;             // offset from start of structure
    ULONG   cbHash;             // count of bytes in hash
    ULONG   ContainerName;      // hint data, offset to LPWSTR
    ULONG   ProviderName;       // hint data, offset to LPWSTR
    ULONG   lpDisplayInformation; // offset to an LPWSTR
} EFS_CERT_HASH_DATA, *PEFS_CERT_HASH_DATA;

typedef struct _EFS_PUBLIC_KEY_INFO {

    //
    // The length of this entire structure, including string data
    // appended to the end.
    //

    ULONG Length;

    //
    // Sid of owner of the public key (regardless of format).
    // This field is to be treated as a hint only.
    //

    ULONG PossibleKeyOwner;

    //
    // Contains information describing how to interpret
    // the public key information
    //

    ULONG KeySourceTag;

    union {
        struct {

            //
            // The following fields contain offsets based at the
            // beginning of the structure.  Each offset is to
            // a NULL terminated WCHAR string.
            //

            ULONG ContainerName;
            ULONG ProviderName;

            //
            // The exported public key used to encrypt the FEK.
            // This field contains an offset from the beginning of the
            // structure.
            //

            ULONG PublicKeyBlob;

            //
            // Length of the PublicKeyBlob in bytes
            //

            ULONG PublicKeyBlobLength;

        } ContainerInfo;

        struct {

            ULONG CertificateLength;       // in bytes
            ULONG Certificate;             // offset from start of structure

        } CertificateInfo;

        struct {

            ULONG ThumbprintLength;        // in bytes
            ULONG CertHashData;            // offset from start of structure

        } CertificateThumbprint;
    };



} EFS_PUBLIC_KEY_INFO, *PEFS_PUBLIC_KEY_INFO;

//
// Possible KeyTag values
//

typedef enum _PUBLIC_KEY_SOURCE_TAG {
    EfsCryptoAPIContainer = 1,
    EfsCertificate,
    EfsCertificateThumbprint
} PUBLIC_KEY_SOURCE_TAG, *PPUBLIC_KEY_SOURCE_TAG;


///////////////////////////////////////////////////////////////////////////////
//                                                                            /
//  RECOVERY_KEY Data Structure                                               /
//                                                                            /
///////////////////////////////////////////////////////////////////////////////

//
// Current format of recovery data.
//

typedef struct _RECOVERY_KEY_1_1   {
        ULONG               TotalLength;
        EFS_PUBLIC_KEY_INFO PublicKeyInfo;
} RECOVERY_KEY_1_1, *PRECOVERY_KEY_1_1;



///////////////////////////////////////////////////////////////////////////////
//                                                                            /
// KEY_INTEGRITY_INFO                                                         /
//                                                                            /
// The KEY_INTEGRITY_INFO structure is used to verify that                    /
// the user's key has correctly decrypted the file's FEK.                     /
//                                                                            /
///////////////////////////////////////////////////////////////////////////////

typedef struct _KEY_INTEGRITY_INFO {

    //
    // The length of the entire structure, including the
    // variable length integrity information appended to
    // the end
    //

    ULONG Length;

    //
    // The algorithm used to hash the combined FEK and
    // public key
    //

    ALG_ID HashAlgorithm;

    //
    // The length of just the hash data.
    //

    ULONG HashDataLength;

    //
    // Integrity information goes here
    //

    // UCHAR Integrity Info[]
} KEY_INTEGRITY_INFO, *PKEY_INTEGRITY_INFO;

typedef struct _EFS_KEY_SALT {
    ULONG Length;   // total length of header plus data
    ULONG SaltType; // figure out what you want for this
    //
    // Put data here, so total length of the structure is
    // sizeof( EFS_KEY_SALT ) + length of your data
    //
} EFS_KEY_SALT, *PEFS_KEY_SALT;

//
// EFS Private DataStructures
//

typedef struct _ENCRYPTED_KEY {

    //
    // Total length of this structure and its data
    //

    ULONG Length;

    //
    // contains an offset from beginning of structure,
    // used to decrypt the EncryptedKey
    //

    ULONG PublicKeyInfo;

    //
    // Length in bytes of EncryptedFEK field
    //

    ULONG EncryptedFEKLength;

    //
    // offset from beginning of structure to encrypted
    // EFS_KEY containing the FEK
    //
    // Type is PUCHAR because data is encrypted.
    //

    ULONG EncryptedFEK;

    //
    // offset from beginning of structure to KEY_INTEGRITY_INFO
    //

    ULONG EfsKeySalt;

    //
    // FEK Data
    //
    // KEY_INTEGRITY_INFO Data
    //
    // PEFS_PUBLIC_KEY_INFO Data
    //

} ENCRYPTED_KEY, *PENCRYPTED_KEY;


//
// The Key Ring Structure.
//

typedef struct _ENCRYPTED_KEYS {
    ULONG           KeyCount;
    ENCRYPTED_KEY   EncryptedKey[1];
} ENCRYPTED_KEYS, *PENCRYPTED_KEYS;

typedef ENCRYPTED_KEYS      DDF, *PDDF;
typedef ENCRYPTED_KEYS      DRF, *PDRF;

typedef struct _EFS_STREAM_SIZE {
    ULONG       StreamFlag;
    LARGE_INTEGER   EOFSize;
    LARGE_INTEGER   AllocSize;
} EFS_STREAM_SIZE, *PEFS_STREAM_SIZE;

#define NEXT_ENCRYPTED_KEY( pEncryptedKey )  (PENCRYPTED_KEY)(((PBYTE)(pEncryptedKey)) + *((ULONG UNALIGNED *)&((PENCRYPTED_KEY)(pEncryptedKey))->Length))


//
// Import context
//

typedef struct IMPORT_CONTEXT{

    ULONG       ContextID; //To distinguish from other LSA context. Offset is fixed across LSA.
    ULONG       Flag;   // Indicate the type of context
    HANDLE      Handle; // File handle, used to create rest streams
    ULONG       Attribute;
    ULONG       CreateDisposition;
    ULONG       CreateOptions;
    ULONG       DesiredAccess;

} IMPORT_CONTEXT, *PIMPORT_CONTEXT;

//
// Export context
//

typedef struct EXPORT_CONTEXT{

    ULONG           ContextID; //To distinguish from other LSA context. Offset is fixed across LSA.
    ULONG           Flag;   // Indicate the type of context
    HANDLE          Handle; // File handle, used to open rest streams
    ULONG           NumberOfStreams;
    PHANDLE         StreamHandles;
    PUNICODE_STRING StreamNames;
    PFILE_STREAM_INFORMATION StreamInfoBase;

} EXPORT_CONTEXT, *PEXPORT_CONTEXT;

//
// EFS Export/Import RPC pipe status
//

typedef struct EFS_EXIM_STATE{
    PVOID   ExImCallback;
    PVOID   CallbackContext;
    char     *WorkBuf;
    ULONG   BufLength;
    ULONG  Status;
} EFS_EXIM_STATE, *PEFS_EXIM_STATE;

//
// Export file format
//

typedef struct EFSEXP_FILE_HEADER{

    ULONG  VersionID;   // Export file version
    WCHAR  FileSignature[EFS_SIGNATURE_LENGTH]; // Signature of the file
    ULONG  Reserved[2];
    //STREAM_DADA     Streams[0];  // An array of STREAM_BLOCK

} EFSEXP_FILE_HEADER, *PEFSEXP_FILE_HEADER;

typedef struct EFSEXP_STREAM_HEADER{

    ULONG    Length; // Redundant information. The length of this block not including DataBlocks but
                     // including itself; This field is to simplify the import routine.
    WCHAR    StreamSignature[EFS_SIGNATURE_LENGTH]; // Signature of the stream
    ULONG    Flag;  // Indicating if the stream is encrypted or not and etc.
    ULONG    Reserved[2];  // For future use
    ULONG    NameLength;   // Length of the stream name
    //WCHAR    StreamName[0];   // ID of the stream, Binary value can be used.
    //DATA_BLOCK   DataBlocks[0]; // Variable number of data block

} EFSEXP_STREAM_HEADER, *PEFSEXP_STREAM_HEADER;

typedef struct EFSEXP_DATA_HEADER{

    ULONG Length;      // Length of the block including this ULONG
    WCHAR DataSignature[EFS_SIGNATURE_LENGTH]; // Signature of the data
    ULONG Flag;          // For future use.
    // BYTE  DataBlock[N];  // N = Length - 2 * sizeof (ULONG) - 4 * sizeof (WCHAR)

} EFSEXP_DATA_HEADER, *PEFSEXP_DATA_HEADER;

//
//  TotalLength - total length of the RECOVERY_KEY Datastructure.
//
//  KeyName     - the storage stream will actually have the characters terminated by
//              a NULL character.
//  AlgorithmId - CryptAPI Algorithm ID - in V1 it is always RSA.
//
//  CSPName     - the storage stream will actually have the characters terminated by
//              a NULL character.
//  CSPType     - CryptAPI type of CSP.
//
//  PublicBlobLength - Length of the public blob that is importable in CryptoAPI in bytes.
//

//
//  Recovery Policy Data Structures
//

typedef struct _RECOVERY_POLICY_HEADER {
    USHORT      MajorRevision;
    USHORT      MinorRevision;
    ULONG       RecoveryKeyCount;
} RECOVERY_POLICY_HEADER, *PRECOVERY_POLICY_HEADER;

typedef struct _RECOVERY_POLICY_1_1    {
        RECOVERY_POLICY_HEADER  RecoveryPolicyHeader;
        RECOVERY_KEY_1_1        RecoveryKeyList[1];
}   RECOVERY_POLICY_1_1, *PRECOVERY_POLICY_1_1;

#define EFS_RECOVERY_POLICY_MAJOR_REVISION_1   (1)
#define EFS_RECOVERY_POLICY_MINOR_REVISION_0   (0)

#define EFS_RECOVERY_POLICY_MINOR_REVISION_1   (1)

//
//  Major/Minor Revision - revision number of policy information.
//
//  RecoveryKeyCount - number of recovery keys configured in this policy.
//
//  RecoveryKeyList - array of recovery keys.
//

//
// Session Key Structure
//

#define SESSION_KEY_SIZE    8
#define COMMON_FSCTL_HEADER_SIZE (7 * sizeof( ULONG ) + 2 * SESSION_KEY_SIZE)

typedef struct _EFS_INIT_DATAEXG {
    UCHAR Key[SESSION_KEY_SIZE];
    HANDLE LsaProcessID; // The reason we use HANDLE is for the sake of 64 bits
} EFS_INIT_DATAEXG, *PEFS_INIT_DATAEXG;


//
// Server API, callable from kernel mode
//

NTSTATUS
EfsGenerateKey(
      PEFS_KEY * Fek,
      PEFS_DATA_STREAM_HEADER * EfsStream,
      PEFS_DATA_STREAM_HEADER DirectoryEfsStream,
      ULONG DirectoryEfsStreamLength,
      PVOID * BufferBase,
      PULONG BufferLength
      );


NTSTATUS
GenerateDirEfs(
    PEFS_DATA_STREAM_HEADER DirectoryEfsStream,
    ULONG DirectoryEfsStreamLength,
    PEFS_DATA_STREAM_HEADER * NewEfs,
    PVOID * BufferBase,
    PULONG BufferLength
    );


#define EFS_OPEN_NORMAL  1
#define EFS_OPEN_RESTORE 2
#define EFS_OPEN_BACKUP  3

NTSTATUS
EfsDecryptFek(
    IN OUT PEFS_KEY * Fek,
    IN PEFS_DATA_STREAM_HEADER CurrentEfs,
    IN ULONG EfsStreamLength,
    IN ULONG OpenType,                      //Normal, Recovery or Backup
    OUT PEFS_DATA_STREAM_HEADER *NewEfs,     //In case the DDF, DRF are changed
    PVOID * BufferBase,
    PULONG BufferLength
    );

NTSTATUS
GenerateSessionKey(
    OUT EFS_INIT_DATAEXG * SessionKey
    );


//
// Private usermode server API
//

ULONG
EfsEncryptFileRPCClient(
    IN PUNICODE_STRING    FileName
    );

ULONG
EfsDecryptFileRPCClient(
    PUNICODE_STRING      FileName,
    ULONG   OpenFlag
    );

ULONG
EfsOpenFileRawRPCClient(
    IN  LPCWSTR    FileName,
    IN  ULONG   Flags,
    OUT PVOID * Context
    );

VOID
EfsCloseFileRawRPCClient(
    IN  PVOID   Context
    );

#ifdef __cplusplus
}
#endif

#endif // _EFSSTRUC_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\public\internal\drivers\inc\jetwriter.h ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved.

Module Name:

    ijetwriter.h

Abstract:

    Definition of CVssIJetWriter class

	Brian Berkowitz  [brianb]  3/17/2000

TBD:
	
	Add comments.

Revision History:

    Name        Date        Comments
    brianb      03/17/2000  Created
    mikejohn    04/03/2000  Added extra methods for OnIdentify()
    mikejohn    05/10/2000  Updated VS_FLUSH_TYPE to VSS_FLUSH_TYPE
    mikejohn	09/20/2000  176860: Added calling convention methods where missing

--*/

class CVssJetWriter;
class CVssIJetWriter;

class IVssCreateWriterMetadata;
class IVssWriterComponents;

typedef CVssJetWriter *PVSSJETWRITER;

// actual writer class
class CVssJetWriter
	{
	// Constructors and destructors
public:
	__declspec(dllexport)
	STDMETHODCALLTYPE CVssJetWriter() :
		m_pWriter(NULL)
		{
		}

	__declspec(dllexport)
	virtual STDMETHODCALLTYPE ~CVssJetWriter();

	__declspec(dllexport)
	HRESULT STDMETHODCALLTYPE Initialize(IN GUID idWriter,
					     IN LPCWSTR wszWriterName,
					     IN bool bSystemService,
					     IN bool bBootableSystemState,
					     IN LPCWSTR wszFilesToInclude,
					     IN LPCWSTR wszFilesToExclude);

	__declspec(dllexport)
	void STDMETHODCALLTYPE Uninitialize();


	// callback for identify event
	__declspec(dllexport)
	virtual bool STDMETHODCALLTYPE OnIdentify(IN IVssCreateWriterMetadata *pMetadata);

	// called at Prepare to backup
	__declspec(dllexport)
	virtual bool STDMETHODCALLTYPE OnPrepareBackupBegin(IN IVssWriterComponents *pIVssWriterComponents);

	__declspec(dllexport)
	virtual bool STDMETHODCALLTYPE OnPrepareBackupEnd(IN IVssWriterComponents *pIVssWriterComponents,
							  IN bool fJetPrepareSucceeded);


	// called at Prepare for snasphot
	__declspec(dllexport)
	virtual bool STDMETHODCALLTYPE OnPrepareSnapshotBegin();

	__declspec(dllexport)
	virtual bool STDMETHODCALLTYPE OnPrepareSnapshotEnd(IN bool fJetPrepareSucceeded);

	// called at freeze
	__declspec(dllexport)
	virtual bool STDMETHODCALLTYPE OnFreezeBegin();

	__declspec(dllexport)
	virtual bool STDMETHODCALLTYPE OnFreezeEnd(IN bool fJetFreezeSucceeded);

	// called at thaw
	__declspec(dllexport)
	virtual bool STDMETHODCALLTYPE OnThawBegin();

	__declspec(dllexport)
	virtual bool STDMETHODCALLTYPE OnThawEnd(IN bool fJetThawSucceeded);

	// called at OnPostSnapshot
	__declspec(dllexport)
	virtual bool STDMETHODCALLTYPE OnPostSnapshot(IN IVssWriterComponents *pIVssWriterComponents);

	// called when abort occurs
	__declspec(dllexport)
	virtual void STDMETHODCALLTYPE OnAbortBegin();

	__declspec(dllexport)
	virtual void STDMETHODCALLTYPE OnAbortEnd();

	// callback on backup complete event
	__declspec(dllexport)
	virtual bool STDMETHODCALLTYPE OnBackupCompleteBegin(IN IVssWriterComponents *pComponent);

	__declspec(dllexport)
	virtual bool STDMETHODCALLTYPE OnBackupCompleteEnd(IN IVssWriterComponents *pComponent,
							   IN bool fJetBackupCompleteSucceeded);

	// called when restore begins
	__declspec(dllexport)
	virtual bool STDMETHODCALLTYPE OnPreRestoreBegin(IN IVssWriterComponents *pIVssWriterComponents);

	__declspec(dllexport)
	virtual bool STDMETHODCALLTYPE OnPreRestoreEnd(IN IVssWriterComponents *pIVssWriterComponents,
						    IN bool fJetRestoreSucceeded);


	// called when restore begins
	__declspec(dllexport)
	virtual bool STDMETHODCALLTYPE OnPostRestoreBegin(IN IVssWriterComponents *pIVssWriterComponents);

	__declspec(dllexport)
	virtual bool STDMETHODCALLTYPE OnPostRestoreEnd(IN IVssWriterComponents *pIVssWriterComponents,
						    IN bool fJetRestoreSucceeded);



private:
	// internal writer object
	VOID *m_pWriter;

	// result of initialization
	HRESULT m_hrInitialized;

	// internal thread func function
	static DWORD InitializeThreadFunc(void *pv);
	};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\public\internal\drivers\inc\ksguid.c ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       ksguid.c
//
//--------------------------------------------------------------------------

#include <wdm.h>
#include <windef.h>
#define NOBITMAP
#include <ksguid.h>
#include <mmreg.h>

//
// Create a separate library for the SDK which does not separate the
// guids out from the .text section.
//
#ifdef DDK_KS
#ifdef ALLOC_DATA_PRAGMA
#pragma const_seg("PAGECONST")
#endif // ALLOC_PRAGMA
#endif // SDK_KS

// include swenum.h first so that a separate guid entry is made for the BUSID.
#include <swenum.h>
#include <ks.h>
#include <ksi.h>
#include <ksmedia.h>
#include <ksmediap.h>
#include <ksproxy.h>
// remove this, since basetyps.h defines it again.
#undef DEFINE_GUID
#include <unknown.h>
// set the version to less than 1100 so that guids are defined for the library.
#ifdef _MSC_VER
#undef _MSC_VER
#endif // _MSC_VER
#define _MSC_VER 0
#include <kcom.h>
#include <stdarg.h>

#ifdef ALLOC_DATA_PRAGMA
#pragma const_seg()
#endif // ALLOC_DATA_PRAGMA
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\public\internal\drivers\inc\ntddsnap.h ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved.

Module Name:

    ntddsnap.h

Abstract:

    This header file defines the public interface for the volume snapshot
    driver.

Author:

    Norbert P. Kusters  (norbertk)  30-July-1999

Notes:

Revision History:

    Adi Oltean          (aoltean)   08-May-2001 - Added Application Info GUID for Client accessible snapshots

--*/

#ifndef _NTDDSNAP_
#define _NTDDSNAP_

#define VOLSNAPCONTROLTYPE  ((ULONG) 'S') // ntifs

//
// The following IOCTLs are intended for proper volumes.
//

#define IOCTL_VOLSNAP_FLUSH_AND_HOLD_WRITES         CTL_CODE(VOLSNAPCONTROLTYPE, 0, METHOD_BUFFERED, FILE_READ_ACCESS | FILE_WRITE_ACCESS) // ntifs
#define IOCTL_VOLSNAP_RELEASE_WRITES                CTL_CODE(VOLSNAPCONTROLTYPE, 1, METHOD_BUFFERED, FILE_READ_ACCESS | FILE_WRITE_ACCESS)
#define IOCTL_VOLSNAP_PREPARE_FOR_SNAPSHOT          CTL_CODE(VOLSNAPCONTROLTYPE, 2, METHOD_BUFFERED, FILE_READ_ACCESS | FILE_WRITE_ACCESS)
#define IOCTL_VOLSNAP_ABORT_PREPARED_SNAPSHOT       CTL_CODE(VOLSNAPCONTROLTYPE, 3, METHOD_BUFFERED, FILE_READ_ACCESS | FILE_WRITE_ACCESS)
#define IOCTL_VOLSNAP_COMMIT_SNAPSHOT               CTL_CODE(VOLSNAPCONTROLTYPE, 4, METHOD_BUFFERED, FILE_READ_ACCESS | FILE_WRITE_ACCESS)
#define IOCTL_VOLSNAP_END_COMMIT_SNAPSHOT           CTL_CODE(VOLSNAPCONTROLTYPE, 5, METHOD_BUFFERED, FILE_READ_ACCESS | FILE_WRITE_ACCESS)
#define IOCTL_VOLSNAP_QUERY_NAMES_OF_SNAPSHOTS      CTL_CODE(VOLSNAPCONTROLTYPE, 6, METHOD_BUFFERED, FILE_READ_ACCESS)
#define IOCTL_VOLSNAP_CLEAR_DIFF_AREA               CTL_CODE(VOLSNAPCONTROLTYPE, 7, METHOD_BUFFERED, FILE_READ_ACCESS | FILE_WRITE_ACCESS)
#define IOCTL_VOLSNAP_ADD_VOLUME_TO_DIFF_AREA       CTL_CODE(VOLSNAPCONTROLTYPE, 8, METHOD_BUFFERED, FILE_READ_ACCESS | FILE_WRITE_ACCESS)
#define IOCTL_VOLSNAP_QUERY_DIFF_AREA               CTL_CODE(VOLSNAPCONTROLTYPE, 9, METHOD_BUFFERED, FILE_READ_ACCESS)
#define IOCTL_VOLSNAP_SET_MAX_DIFF_AREA_SIZE        CTL_CODE(VOLSNAPCONTROLTYPE, 10, METHOD_BUFFERED, FILE_READ_ACCESS | FILE_WRITE_ACCESS)
#define IOCTL_VOLSNAP_QUERY_DIFF_AREA_SIZES         CTL_CODE(VOLSNAPCONTROLTYPE, 11, METHOD_BUFFERED, FILE_READ_ACCESS)
#define IOCTL_VOLSNAP_DELETE_OLDEST_SNAPSHOT        CTL_CODE(VOLSNAPCONTROLTYPE, 12, METHOD_BUFFERED, FILE_READ_ACCESS | FILE_WRITE_ACCESS)
#define IOCTL_VOLSNAP_AUTO_CLEANUP                  CTL_CODE(VOLSNAPCONTROLTYPE, 13, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define IOCTL_VOLSNAP_DELETE_SNAPSHOT               CTL_CODE(VOLSNAPCONTROLTYPE, 14, METHOD_BUFFERED, FILE_READ_ACCESS | FILE_WRITE_ACCESS)

//
// The following IOCTLs are intended for volume snapshots.
//

#define IOCTL_VOLSNAP_QUERY_ORIGINAL_VOLUME_NAME    CTL_CODE(VOLSNAPCONTROLTYPE, 100, METHOD_BUFFERED, FILE_READ_ACCESS)
#define IOCTL_VOLSNAP_QUERY_CONFIG_INFO             CTL_CODE(VOLSNAPCONTROLTYPE, 101, METHOD_BUFFERED, FILE_READ_ACCESS)
#define IOCTL_VOLSNAP_SET_APPLICATION_INFO          CTL_CODE(VOLSNAPCONTROLTYPE, 102, METHOD_BUFFERED, FILE_READ_ACCESS | FILE_WRITE_ACCESS)
#define IOCTL_VOLSNAP_QUERY_APPLICATION_INFO        CTL_CODE(VOLSNAPCONTROLTYPE, 103, METHOD_BUFFERED, FILE_READ_ACCESS)

//
// Input buffer for IOCTL_VOLSNAP_FLUSH_AND_HOLD_WRITES.
//

typedef struct _VOLSNAP_FLUSH_AND_HOLD_INPUT {
    GUID    InstanceId;
    ULONG   NumberOfVolumesToFlush;
    USHORT  SecondsToHoldFileSystemsTimeout;    // 60 seconds recommended.
    USHORT  SecondsToHoldIrpsTimeout;           // 10 seconds recommended.
} VOLSNAP_FLUSH_AND_HOLD_INPUT, *PVOLSNAP_FLUSH_AND_HOLD_INPUT;

//
// Input buffer for IOCTL_VOLSNAP_PREPARE_FOR_SNAPSHOT.
//

#define VOLSNAP_ATTRIBUTE_PERSISTENT    (0x1)
#define VOLSNAP_ALL_ATTRIBUTES          (0x1)

typedef struct _VOLSNAP_PREPARE_INFO {
    ULONG       Attributes;
    ULONG       Reserved;                   // Must be 0.
    LONGLONG    InitialDiffAreaAllocation;  // 100 MB recommended.
} VOLSNAP_PREPARE_INFO, *PVOLSNAP_PREPARE_INFO;

//
// Output buffer for IOCTL_VOLSNAP_END_COMMIT_SNAPSHOT.
// Input buffer for IOCTL_VOLSNAP_ADD_VOLUME_TO_DIFF_AREA.
// Output buffer for IOCTL_VOLSNAP_QUERY_ORIGINAL_VOLUME_NAME.
// Input buffer for IOCTL_VOLSNAP_DELETE_SNAPSHOT.
//

typedef struct _VOLSNAP_NAME {
    USHORT  NameLength;
    WCHAR   Name[1];
} VOLSNAP_NAME, *PVOLSNAP_NAME;

//
// Input buffer for IOCTL_VOLSNAP_SET_DIFF_AREA.
// Output buffer for IOCTL_VOLSNAP_QUERY_NAMES_OF_SNAPSHOTS and
// IOCTL_VOLSNAP_QUERY_DIFF_AREA.
//

typedef struct _VOLSNAP_NAMES {
    ULONG   MultiSzLength;
    WCHAR   Names[1];
} VOLSNAP_NAMES, *PVOLSNAP_NAMES;

//
// Output buffer for IOCTL_VOLSNAP_QUERY_DIFF_AREA_SIZES.
// Input buffer for IOCTL_VOLSNAP_SET_MAX_DIFF_AREA_SIZE.
//

typedef struct _VOLSNAP_DIFF_AREA_SIZES {
    LONGLONG    UsedVolumeSpace;        // This value is ignored on a SET call.
    LONGLONG    AllocatedVolumeSpace;
    LONGLONG    MaximumVolumeSpace;     // A value of 0 indicates no maximum.
} VOLSNAP_DIFF_AREA_SIZES, *PVOLSNAP_DIFF_AREA_SIZES;

//
// Output buffer for IOCTL_VOLSNAP_QUERY_CONFIG_INFO.
//

typedef struct _VOLSNAP_CONFIG_INFO {
    ULONG           Attributes;
    ULONG           Reserved;
    LARGE_INTEGER   SnapshotCreationTime;
} VOLSNAP_CONFIG_INFO, *PVOLSNAP_CONFIG_INFO;

//
// Input buffer for IOCTL_VOLSNAP_END_COMMIT_SNAPSHOT.
// Input buffer for IOCTL_VOLSNAP_SET_APPLICATION_INFO.
// Output buffer for IOCTL_VOLSNAP_QUERY_APPLICATION_INFO.
//

typedef struct _VOLSNAP_APPLICATION_INFO {
    ULONG   InformationLength;
    UCHAR   Information[1];
    //
    // It is highly recommended that the first 16 bytes from the 
    // Application Info should be a unique GUID indentifying the 
    // unique structure layout of the subsequent Application Info.
    //
} VOLSNAP_APPLICATION_INFO, *PVOLSNAP_APPLICATION_INFO;


#ifdef DEFINE_GUID

//
// This GUID denotes the first 16 bytes from the Application 
// Info structure associated with Client accessible snapshots.  
//
// {E5DE7D45-49F2-40a4-817C-7DC82B72587F}
DEFINE_GUID(VOLSNAP_APPINFO_GUID_CLIENT_ACCESSIBLE, 
0xe5de7d45, 0x49f2, 0x40a4, 0x81, 0x7c, 0x7d, 0xc8, 0x2b, 0x72, 0x58, 0x7f);

#endif // DEFINE_GUID


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\public\internal\drivers\inc\ksmediap.h ===
/*++

Copyright (c) 2001 Microsoft Corporation. All rights reserved.

Module Name:

    ksmediap.h

Abstract:

    Private WDM multimedia definitions used only by Microsoft components.
    Moved here from ksmedia.h.  Some of these are obsolescent (e.g. ITD).

--*/

#ifndef _KSMEDIAP_H
#define _KSMEDIAP_H

#define CORE_AUDIO_BUFFER_DURATION_PATH L"\\Registry\\Machine\\System\\CurrentControlSet\\Services\\AudioSrv"
#define CORE_AUDIO_BUFFER_DURATION_VALUE L"CoreAudioBufferDuration"

#define DEFAULT_CORE_AUDIO_BUFFER_DURATION 10000    // duration in usec.
#define MAX_CORE_AUDIO_BUFFER_DURATION 20000
#define MIN_CORE_AUDIO_BUFFER_DURATION 1000

//===========================================================================
// Definitions intended for hardware acceleration of the HRTF 3D algorithm
//===========================================================================

#define KSDSOUND_BUFFER_CTRL_HRTF_3D        0x40000000

typedef struct {
    ULONG                   Size;           // This is the size of the struct in bytes
    ULONG                   Enabled;
    BOOL                    SwapChannels;
    BOOL                    ZeroAzimuth;
    BOOL                    CrossFadeOutput;
    ULONG                   FilterSize;     // This is the additional size of the filter coeff in bytes
} KSDS3D_HRTF_PARAMS_MSG, *PKSDS3D_HRTF_PARAMS_MSG;

// HRTF filter quality levels
typedef enum {
    FULL_FILTER,
    LIGHT_FILTER,
    KSDS3D_FILTER_QUALITY_COUNT
} KSDS3D_HRTF_FILTER_QUALITY;

typedef struct {
    ULONG                       Size;       // This is the size of the struct in bytes
    KSDS3D_HRTF_FILTER_QUALITY  Quality;
    FLOAT                       SampleRate;
    ULONG                       MaxFilterSize;
    ULONG                       FilterTransientMuteLength;
    ULONG                       FilterOverlapBufferLength;
    ULONG                       OutputOverlapBufferLength;
    ULONG                       Reserved;
} KSDS3D_HRTF_INIT_MSG, *PKSDS3D_HRTF_INIT_MSG;

// Coefficient formats
typedef enum {
    FLOAT_COEFF,
    SHORT_COEFF,
    KSDS3D_COEFF_COUNT
} KSDS3D_HRTF_COEFF_FORMAT;

// Filter methods
typedef enum {
    DIRECT_FORM,
    CASCADE_FORM,
    KSDS3D_FILTER_METHOD_COUNT
} KSDS3D_HRTF_FILTER_METHOD;

// Filter methods
typedef enum {
    DS3D_HRTF_VERSION_1
} KSDS3D_HRTF_FILTER_VERSION;

typedef struct {
    KSDS3D_HRTF_FILTER_METHOD    FilterMethod;
    KSDS3D_HRTF_COEFF_FORMAT     CoeffFormat;
    KSDS3D_HRTF_FILTER_VERSION   Version;
    ULONG                        Reserved;
} KSDS3D_HRTF_FILTER_FORMAT_MSG, *PKSDS3D_HRTF_FILTER_FORMAT_MSG;

#define STATIC_KSPROPSETID_Hrtf3d\
    0xb66decb0L, 0xa083, 0x11d0, 0x85, 0x1e, 0x00, 0xc0, 0x4f, 0xd9, 0xba, 0xf3
DEFINE_GUIDSTRUCT("b66decb0-a083-11d0-851e-00c04fd9baf3", KSPROPSETID_Hrtf3d);
#define KSPROPSETID_Hrtf3d DEFINE_GUIDNAMED(KSPROPSETID_Hrtf3d)

typedef enum {
    KSPROPERTY_HRTF3D_PARAMS = 0,
    KSPROPERTY_HRTF3D_INITIALIZE,
    KSPROPERTY_HRTF3D_FILTER_FORMAT
} KSPROPERTY_HRTF3D;


//===========================================================================
// Definitions related to the obsolete Interaural Time Delay 3D algorithm
//===========================================================================

// DirectSound3D FIR context
typedef struct {
    LONG                Channel;
    FLOAT               VolSmoothScale;
    FLOAT               TotalDryAttenuation;
    FLOAT               TotalWetAttenuation;
    LONG                SmoothFrequency;
    LONG                Delay;
} KSDS3D_ITD_PARAMS, *PKSDS3D_ITD_PARAMS;

typedef struct {
    ULONG                 Enabled;
    KSDS3D_ITD_PARAMS     LeftParams;
    KSDS3D_ITD_PARAMS     RightParams;
    ULONG                 Reserved;
} KSDS3D_ITD_PARAMS_MSG, *PKSDS3D_ITD_PARAMS_MSG;

#define STATIC_KSPROPSETID_Itd3d\
    0x6429f090L, 0x9fd9, 0x11d0, 0xa7, 0x5b, 0x00, 0xa0, 0xc9, 0x03, 0x65, 0xe3
DEFINE_GUIDSTRUCT("6429f090-9fd9-11d0-a75b-00a0c90365e3", KSPROPSETID_Itd3d);
#define KSPROPSETID_Itd3d DEFINE_GUIDNAMED(KSPROPSETID_Itd3d)

typedef enum {
    KSPROPERTY_ITD3D_PARAMS = 0
} KSPROPERTY_ITD3D;

#endif /* _KSMEDIAP_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\public\internal\drivers\inc\partmgrp.h ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved.

Module Name:

    partmgrp.h

Abstract:

    This file defines the public interfaces for the PARTMGR driver.

Author:

    norbertk

Revision History:

--*/

//
// Define IOCTL so that volume managers can get another crack at
// partitions that are unclaimed.
//

#define IOCTL_PARTMGR_CHECK_UNCLAIMED_PARTITIONS    CTL_CODE('p', 0, METHOD_BUFFERED, FILE_ANY_ACCESS)

//
// This IOCTL is for clusters to tell the volume managers for the
// given disk to stop using it.  You can undo this operation with
// IOCTL_PARTMGR_CHECK_UNCLAIMED_PARTITIONS.
//

#define IOCTL_PARTMGR_EJECT_VOLUME_MANAGERS         CTL_CODE('p', 1, METHOD_BUFFERED, FILE_READ_ACCESS | FILE_WRITE_ACCESS)

//
// This IOCTL usually just returns the MBR disk signature that is contained
// on the disk but may return a 'future' version of the disk signature during
// boot.  This separate call is needed so that if the signature on the boot
// disk is not unique or 0, that it still stays as the old value long enough
// for the system to find it from the loader block.
//

#define IOCTL_PARTMGR_QUERY_DISK_SIGNATURE          CTL_CODE('p', 2, METHOD_BUFFERED, FILE_READ_ACCESS)

//
// This structure is the return value for IOCTL_PARTMGR_QUERY_DISK_SIGNATURE.
//

typedef struct _PARTMGR_DISK_SIGNATURE {
    ULONG   Signature;
} PARTMGR_DISK_SIGNATURE, *PPARTMGR_DISK_SIGNATURE;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\public\internal\drivers\inc\ksdrmhlp.h ===
#ifndef _KS_DRM_HELP_H_
#define _KS_DRM_HELP_H_

#include <unknown.h>
#include <ks.h>
#include <ksmedia.h>
#include <drmk.h>

typedef
NTSTATUS
(*PFNKSHANDLERDRMSETCONTENTID)(
    IN PIRP                          irp,
    IN PKSP_DRMAUDIOSTREAM_CONTENTID pKsProperty,
    IN PKSDRMAUDIOSTREAM_CONTENTID   pvData
);

NTSTATUS KsPropertyHandleDrmSetContentId(
    IN PIRP Irp,
    IN PFNKSHANDLERDRMSETCONTENTID pDrmSetContentId);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\public\internal\drivers\inc\volprop.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (c) Microsoft Corporation. All rights reserved.
//
//  File:       volprop.h
//
//--------------------------------------------------------------------------

#ifndef VOLPROP_H
#define VOLPROP_H

#include <setupapi.h>

// PROPERTY_PAGE_DATA is used to communicated data between this property page
// provider and Logical Disk Management.
//
#define SIZE_LENGTH     100      // make them big enough to avoid 
#define ITEM_LENGTH     100      // localization problem
#define LABEL_LENGTH    100

typedef struct _VOLUME_DATA {
    TCHAR Size[SIZE_LENGTH];
    TCHAR Label[LABEL_LENGTH];   // ISSUE: what is the max size?
    TCHAR *MountName;
} VOLUME_DATA, *PVOLUME_DATA;

typedef struct _PROPERTY_PAGE_DATA {
    TCHAR DiskName[ITEM_LENGTH];   // ISSUE: what are the max sizes? e.g "CDROM 1000".
    TCHAR DiskStatus[ITEM_LENGTH]; //        "Unknown, Online, Offline, etc"
    TCHAR DiskType[ITEM_LENGTH];   //        "Basic, Dynamic"
    TCHAR DiskPartitionStyle[ITEM_LENGTH];
    TCHAR DiskCapacity[SIZE_LENGTH]; //        "1500 GB", "1500 MB"
    TCHAR DiskFreeSpace[SIZE_LENGTH]; 
    TCHAR DiskReservedSpace[SIZE_LENGTH];
    
    HANDLE ImageList;
    int    VolumeCount;
    VOLUME_DATA VolumeArray[1];

} PROPERTY_PAGE_DATA, *PPROPERTY_PAGE_DATA;

typedef struct _VOLUME_PAGE_DATA {
    HDEVINFO DeviceInfoSet;
    PSP_DEVINFO_DATA DeviceInfoData;
    BOOL  bIsLocalMachine;
    BOOL  bInvokedByDiskmgr;
    TCHAR MachineName[MAX_COMPUTERNAME_LENGTH+3];
    TCHAR DeviceInstanceId[MAX_DEVICE_ID_LEN];
    PPROPERTY_PAGE_DATA pPropertyPageData;

} VOLUME_PAGE_DATA, *PVOLUME_PAGE_DATA;

// IsRequestPending() is exported from dmdskmgr.dll
//
typedef BOOL (WINAPI *IS_REQUEST_PENDING)();

// GetPropertyPageData() is exported from dmdskmgr.dll.
//
typedef PPROPERTY_PAGE_DATA (WINAPI *GET_PROPERTY_PAGE_DATA)(
    TCHAR *MachineName,
    TCHAR  *DeviceInstanceId
    );

// LoadPropertyPageData() is exported from dmdskmgr.dll
//
typedef PPROPERTY_PAGE_DATA (WINAPI *LOAD_PROPERTY_PAGE_DATA)(
    TCHAR *MachineName,
    HDEVINFO DeviceInfoSet,
    PSP_DEVINFO_DATA DeviceInfoData
    );

INT_PTR
VolumeDialogProc(HWND hWnd,
                 UINT Message,
                 WPARAM wParam,
                 LPARAM lParam);
BOOL
VolumeDialogCallback(
    HWND HWnd,
    UINT Message,
    LPPROPSHEETPAGE Page
    );

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\public\internal\drivers\inc\oemtypes.h ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved.

Module Name:

    oemtypes.h

Abstract:

    This file defines the OEM partition types and provides a macro
    to recognize them.

Author:

    Cristian Teodorescu  (cristiat)  1-December-2000

Revision History:

--*/

#ifndef _OEMTYPES_H_
#define _OEMTYPES_H_

//
//  List of OEM partition types recognized by NT
//

#define PARTITION_EISA          0x12    // EISA partition
#define PARTITION_HIBERNATION   0x84	// Hibernation partition for laptops
#define PARTITION_DIAGNOSTIC    0xA0    // Diagnostic partition on some HP notebooks
#define PARTITION_DELL          0xDE	// Dell partition
#define PARTITION_IBM           0xFE    // IBM IML partition

//
// BOOLEAN
// IsOEMPartition(
//     IN ULONG PartitionType
//     )
//
// Routine Description:
//
//     This macro is used to determine if the given partition is an OEM
//     partition. We consider any special unrecognized partitions that 
//     are required for various machines to boot or work properly.
//
// Arguments:
//
//     PartitionType - Supplies the type of the partition being examined.
//
// Return Value:
//
//     The return value is TRUE if the partition type is an OEM partition,
//     otherwise FALSE is returned.
//

#define IsOEMPartition(PartitionType) (             \
    ((PartitionType) == PARTITION_EISA)         ||  \
    ((PartitionType) == PARTITION_HIBERNATION)  ||  \
    ((PartitionType) == PARTITION_DIAGNOSTIC)   ||  \
    ((PartitionType) == PARTITION_DELL)         ||  \
    ((PartitionType) == PARTITION_IBM))


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\public\internal\drivers\inc\rt.h ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved.


Module Name:

    rt.h

Abstract:

    This is the public include file for realtime executive (rt.sys) clients.

Author:

    Joseph Ballantyne

Environment:

    Kernel Mode

Revision History:

--*/




#ifdef __cplusplus
extern "C" {
#endif


// The following values can be ORed together and the result passed as the Flags argument
// to the RtCreateThread and RtAdjustCpuLoad routines.

#define CPUCYCLES		0x10000
#define INSTRUCTIONS	0x20000

#define USESFLOAT		0x00001
#define USESMMX			0x00002


// These should be used when calculating the desired period and duration to be
// passed to RtCreateThread and RtAdjustCpuLoad.

#define WEEK 604800000000000000I64
#define DAY   86400000000000000I64
#define HOUR   3600000000000000I64
#define MIN      60000000000000I64
#define SEC       1000000000000I64
#define MSEC         1000000000I64
#define USEC            1000000I64
#define NSEC               1000I64
#define PSEC                  1I64


#define X86 1


#define INTEL 1
#define AMD 2



typedef struct {
	ULONG ProcessorCount;	// Number of CPUs in the system.
	ULONG CpuArchitecture;	// Architecture of CPU, currently always X86==1
	ULONG CpuManufacturer;	// Manufacturer ID, Intel==1, AMD==2
	ULONG CpuFamily;		// CPU Family as reported by cpuid instruction.  0x0-0xf
	ULONG CpuModel;			// CPU Model as reported by cpuid instruction.  0x0-0xf
	ULONG CpuStepping;		// CPU Stepping as reported by cpuid instruction.  0x0-0xf
	ULONGLONG CpuFeatures;	// CPU features as reported by cpuid instruction.
	ULONGLONG CpuExtendedFeatures;	// AMD extended features.  (Not implemented.)  Always 0.
	ULONGLONG ProcessorID[2];		// Processor Unique ID.  If enabled.
	ULONG CpuCyclesPerMsec;			// Number of cpu cycles per MSEC.
	ULONG SystemBusCyclesPerMsec;	// Number of system bus cycles per MSEC.
	ULONG ReservedCpuPerMsec;		// Total cpu time reserved per ms by existing rt threads. (in picoseconds)
	ULONG UsedCpuPerMsec;			// Estimate of cpu time used per ms by existing rt threads. (in picoseconds)
	ULONG AvailableCpuPerMsec;		// Cpu time available per ms for allocation to new rt threads. (in picoseconds)
	} SystemInfo;



// The following realtime thread statistics are updated just before control is
// passed by the realtime executive to the realtime thread.  Everytime a realtime
// thread is being switched in, these statistics are updated before control is transfered.
// This means the statistics will change over time, but not while a realtime
// thread is running between thread switches.

#pragma pack(push,2)

typedef struct threadstats {
	ULONGLONG Period;		// Period as passed to RtCreateThread or latest RtAdjustCpuLoad call.
	ULONGLONG Duration;		// Duration from RtCreateThread or latest RtAdjustCpuLoad call.
	ULONG Flags;			// Flags from RtCreateThread or latest RtAdjustCpuLoad call.
	ULONG StackSize;		// StackSize from RtCreateThread call.
	ULONGLONG PeriodIndex;					// Number of periods since start of thread.
	ULONGLONG TimesliceIndex;				// Number of times thread has been switched to.
	ULONGLONG TimesliceIndexThisPeriod;		// Number of times thread switch to this period.
	ULONGLONG ThisPeriodStartTime;			// Starting time for current period.
	ULONGLONG ThisTimesliceStartTime;		// Starting time for current timeslice.
	ULONGLONG DurationRunThisPeriod;		// Total time run so far this period.
	ULONGLONG DurationRunLastPeriod;		// Total time run in the last period.
	} ThreadStats;

#pragma pack(pop)


typedef VOID (*RTTHREADPROC)(PVOID Context, ThreadStats *Statistics);



NTSTATUS
RtVersion (
	OUT PULONG Version
	);

// RtVersion will return the version number of the currently running
// realtime executive.

// If the realtime executive is running, this function returns
// STATUS_SUCCESS.  If for some reason the realtime executive
// cannot run on the current machine then STATUS_NOT_SUPPORTED
// is returned.

// Currently the realtime executive will only run on PII class or newer
// machines.

// If the pointer to the version number is non NULL, then the
// version information for the currently loaded realtime executive
// is returned.  The version information will be returned regardless
// of the NTSTATUS code returned by the function.

// The version number returned is in the format xx.xx.xx.xx where each
// xx is 1 byte of the ULONG and the ordering left to right is high
// order byte - > low order byte.  ie: 0x01020304 is version 1.2.3.4

// It IS acceptable to pass in a NULL version pointer.  In that case
// no version information is returned.

// If this function is called from a real time thread, then the version
// pointer MUST either be NULL, or it MUST point to a local variable on 
// that real time thread's stack.  Otherwise this function will return 
// STATUS_INVALID_PARAMETER.

// If this function is called from Windows, then the pointer must be
// valid for writing.  Otherwise it will return STATUS_INVALID_PARAMETER.

// This function may be called from any thread.  Windows or realtime.



BOOLEAN
RtThread (
    VOID
    );

// RtThread returns TRUE if called from within a realtime thread.  Otherwise
// it returns FALSE.



NTSTATUS
RtSystemInfo (
	ULONG Processor,
	SystemInfo *pSystemInfo
	);

// RtSystemInfo copies the pertinant processor and system information into the memory 
// pointed to by pSystemInfo.  If pSystemInfo is null or invalid, then RtSystemInfo 
// returns STATUS_INVALID_PARAMETER_2.  Otherwise RtSystemInfo will return STATUS_SUCCESS.

// For uniprocessor systems, the Processor number should be zero.  For N processor
// systems, the processor numbers range from 0 to N-1.  An invalid processor number
// will cause a STATUS_INVALID_PARAMETER_1 to be returned.



NTSTATUS
RtCreateThread (
	ULONGLONG Period,
	ULONGLONG Duration,
	ULONG Flags,
	ULONG StackSize,
	RTTHREADPROC RtThread,
	IN PVOID pRtThreadContext,
	OUT PHANDLE pRtThreadHandle
	);

// RtCreateThread is used to create a realtime thread.

// Period is the used to determine the frequency at which the realtime thread must be
// run.  The current minimum period that can be specified is 1ms.

// Duration is the amount of time within the period that the realtime thread will
// need to run.  Percentage CPU load can be calculated as 100*(Duration/Period) as long
// as Duration and Period are both specified in units of time.

// Flags
// This parameter is used to indicate specific requirements of the realtime thread
// being created.  Currently supported values for Flags are USESFLOAT and USESMMX.
// A realtime thread that can use floating point instructions must specify the
// USESFLOAT flag.  A realtime thread that can use MMX instructions must specify the
// USESMMX flag.

// StackSize is the size of the stack required by the realtime thread in 4k blocks.
// Currently StackSize must be between 1 and 8 inclusive.  RtCreateThread will fail
// with STATUS_UNSUCCESSFUL for any other values of StackSize.

// pRtThreadContext is a pointer to the context that should be passed to the thread.
// It may be NULL.  It is passed to the realtime thread as the Context parameter.

// pRtThreadHandle is a pointer to an RtThreadHandle that can be output from
// RtCreateThread.  pRtThreadHandle can be NULL, in which case no RtThreadHandle is
// returned.  Storage for the HANDLE RtThreadHandle must be allocated by the code
// that calls RtCreateThread.

// RtCreateThread may only be called from within a standard windows thread.  It MUST NOT
// be called from within a realtime thread.



NTSTATUS
RtDestroyThread (
	HANDLE RtThreadHandle
	);

// RtDestroyThread removes the realtime thread identified by RtThreadHandle from the
// list of running realtime threads, and releases all resources that were allocated when
// the thread was created.  RtThreadHandle must be a handle returned from RtCreateThread.

// RtDestroyThread may only be called from within a standard windows thread.  It MUST NOT
// be called from within a realtime thread.



NTSTATUS
RtAdjustCpuLoad (
	ULONGLONG Period,
	ULONGLONG Duration,
	ULONGLONG Phase,
	ULONG Flags
	);

// This function allows a realtime thread to adjust the amount of CPU that is allocated
// to it.  The Flags parameter must currently match that passed in at thread creation
// time, however, the Period and Duration may be different from the Period and Duration
// passed at thread create time.  If there is sufficient CPU to meet the new request,
// the function will return STATUS_SUCCESS and the Period and Duration in the thread's
// statistics will be updated to match the values passed in to this function.  If
// there is not enough CPU available to meet the request, this function will leave
// the Period and Duration recorded in Statistics unchanged and will return
// STATUS_INSUFFICIENT_RESOURCES.

// This function MUST be called from within a realtime thread.  A realtime thread can
// only change its OWN allocation.  It cannot change the allocation of any other
// realtime thread.



VOID
RtYield (
	ULONGLONG Mark,
	ULONGLONG Delta
	);

// RtYield will yield execution to other realtime threads in the system.

// It should be called whenever a realtime thread does not require further CPU resources.

// Parameters:
//  Mark
//		This is the reference time which will be subtracted from the current
//		realtime executive scheduler time.  Note that this time is ALWAYS
//		considered by the scheduler to be in the past.  Do NOT pass a time
//		which occurs in the future to this parameter.
//	Delta
//		This is the time that will be compared to the difference between the current
//		scheduler time and the mark.  The thread will yield execution until
//		the difference between the current scheduler time and the mark is greater 
//		than delta.

//		After a thread has called RtYield it will only be run when the following
//		code evaluates TRUE.  ( (RtTime() - Mark) >= Delta )  Until that occurs
//		the thread will NOT run.  Unless it is holding a spinlock required by
//		some other realtime thread - in which case it will run until it releases
//		the spinlock at which point it will again yield.



PVOID
RtAddLogEntry (
    ULONG Size
    );

// RtAddLogEntry reserves space for a new entry in the realtime logging buffer.
// It returns a pointer to the reserved space.  Note that if an unsupported Size
// is specified, or if there is no realtime logging buffer available on the
// system, this routine will return NULL.

// Parameters:
//  Size
//      This is the size in bytes of the chunk to reserve in the log.  It MUST be
//      an integral multiple of 16.



// The following standard WDM functions are also safe to call from within a real time 
// thread:  KeAcquireSpinLock and KeReleaseSpinLock.

// They have been modified to support realtime threads in the following ways:



// KeAcquireSpinLock

// KeAcquireSpinLock will now always attempt to take the spinlock regardless of whether it
// is running on a multiproc or uniproc machine.  If the spinlock is already acquired,
// then KeAcquireSpinLock will spin in a loop that calls RtYield(THISTIMESLICE) until
// the spinlock is released.

// It will then claim the spinlock.  This means that realtime threads that attempt to 
// acquire a held spinlock will BLOCK until the spinlock is free.  If you don't HAVE to use 
// spinlocks in your realtime threads, DON'T.

// Note that other realtime threads will continue to run as scheduled, but the thread
// waiting for the spinlock will continue yielding all its timeslices until the spinlock
// is released.

// If KeAcquireSpinLock is called from a realtime thread, then it will NOT attempt to
// change any irql levels.  This is important, since the current Windows IRQL level may
// be at higher than DISPATCH_LEVEL when this function is called.  Furthermore, the OldIrql
// returned by this function when it is called from a realtime thread is always 0xff - 
// which is an INVALID irql level.

// If you call KeAcquireSpinLock from a realtime thread you MUST call KeReleaseSpinLock
// for that spinlock from a realtime thread.

// Evenutally, KeAcquireSpinLock will be modified to do an RtDirectedYield to the realtime
// thread that is holding the spinlock.

// KeAcquireSpinLock may be called from within any thread.  Realtime or windows.



// KeReleaseSpinLock

// KeReleaseSpinLock now always attempts to release a held spinlock regardless of whether
// it is running on a multiproc or uniproc machine.

// If KeReleaseSpinLock is called from a realtime thread, then it will NOT change any irql
// levels.  It will also validate that it has been called with a new irql level of 0xff
// as would have been returned by the KeAcquireSpinLock call in the realtime thread to
// acquire the spinlock.

// At some point KeReleaseSpinLock may do an RtDirectedYield back to the realtime thread
// that yielded when it attempted to acquire the spinlock.

// KeReleaseSpinLock may be called from within any thread.  Realtime or windows.


#ifdef __cplusplus
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\public\internal\ds\inc\apperr.h ===
/*++ BUILD Version: 0001    // Increment this if a change has global effects 

Copyright (c) 1991  Microsoft Corporation

Module Name:

    apperr.h

Abstract:

    This file contains the number and text of application error
    messages.

Author:

    Dan Hinsley (danhi) 8-Jun-1991

Environment:

    User Mode - Win32
    Portable to any flat, 32-bit environment.  (Uses Win32 typedefs.)
    Requires ANSI C extensions: slash-slash comments.

--*/
#define APPERR_BASE     3500            /* APP errs start here */


/**INTERNAL_ONLY**/

/***********WARNING ****************
 *See the comment in netcon.h for  *
 *info on the allocation of errors *
 ************************************/

/**END_INTERNAL**/

/***
 *
 *      Messages terminating multiple commands
 *
 */

#define APE_Success             (APPERR_BASE + 0) /* @I
         *
         *The command completed successfully.
         */

#define APE_InvalidSwitch               (APPERR_BASE + 1)
        /*
         *You used an invalid option.
         */

#define APE_OS2Error                    (APPERR_BASE + 2) /* @I
         *
         *System error %1 has occurred.
         */

#define APE_NumArgs             (APPERR_BASE + 3)
        /*
         *The command contains an invalid number of arguments.
         */

#define APE_CmdComplWErrors (APPERR_BASE + 4) /* @I
         *
         *The command completed with one or more errors.
         */

#define APE_InvalidSwitchArg (APPERR_BASE + 5)
        /*
         *You used an option with an invalid value.
         */

#define APE_SwUnkSw (APPERR_BASE + 6 )
        /*
         *The option %1 is unknown.
         */

#define APE_SwAmbSw (APPERR_BASE + 7 )
        /*
         *Option %1 is ambiguous.
         */

/*
 * For additional general command line switch/argument related messages,
 * see section with APE_CmdArgXXX.
 */

/***  Use the following message only for real-mode (DOS) errors.
 ***  This error is here to allow real-mode Lan Manager to share
 ***  the message file.
 ***/

#define APE_ConflictingSwitches (APPERR_BASE + 10)
        /*
         *A command was used with conflicting switches.
         */

#define APE_SubpgmNotFound (APPERR_BASE + 11)
        /*
         *Could not find subprogram %1.
         */

#define APE_GEN_OldOSVersion (APPERR_BASE + 12)
	/*
	 *The software requires a newer version of the operating
	 *system.
	 */

#define APE_MoreData (APPERR_BASE + 13)
	/*
	 *More data is available than can be returned by Windows.
	 */

#define APE_MoreHelp (APPERR_BASE + 14 ) /* @I
         *
         *More help is available by typing NET HELPMSG %1.
         */

#define APE_LanmanNTOnly (APPERR_BASE + 15)
	/*
	 *This command can be used only on a Windows Domain Controller.
	 */

#define APE_WinNTOnly (APPERR_BASE + 16)
	/*
	 *This command cannot be used on a Windows Domain Controller.
	 */

/***
 *
 *      Starting, stopping, pausing, and continuing services
 *
 */

#define APE_StartStartedList (APPERR_BASE + 20 ) /* @I
         *
         *These Windows services are started:
         */

#define APE_StartNotStarted (APPERR_BASE + 21 ) /* @I
         *
         *The %1 service is not started.
         */

#define APE_StartPending (APPERR_BASE + 22 ) /* @I
         *
         *The %1 service is starting%0
         */

#define APE_StartFailed (APPERR_BASE + 23 )  /*  @I
         *
         *The %1 service could not be started.
         */

#define APE_StartSuccess (APPERR_BASE + 24 ) /* @I
         *
         *The %1 service was started successfully.
         */

#define APE_StopSrvRunning (APPERR_BASE + 25 ) /* @I
         *
         *Stopping the Workstation service also stops the Server service.
         */

#define APE_StopRdrOpenFiles (APPERR_BASE + 26 ) /* @I
         *
         *The workstation has open files.
         */

#define APE_StopPending (APPERR_BASE + 27 ) /* @I
         *
         *The %1 service is stopping%0
         */

#define APE_StopFailed (APPERR_BASE + 28 ) /* @I
         *
         *The %1 service could not be stopped.
         */

#define APE_StopSuccess (APPERR_BASE + 29 ) /* @I
         *
         *The %1 service was stopped successfully.
         */

#define APE_StopServiceList (APPERR_BASE + 30 ) /* @I
         *
         *The following services are dependent on the %1 service.
         *Stopping the %1 service will also stop these services.
         */

#define APE_ServiceStatePending         (APPERR_BASE + 33)
        /*
         *The service is starting or stopping.  Please try again later.
         */

#define APE_NoErrorReported (APPERR_BASE + 34) /* @I
         *
         *The service did not report an error.
         */

#define APE_ContpausDevErr (APPERR_BASE + 35 ) /* @I
         *
         *An error occurred controlling the device.
         */

#define APE_ContSuccess (APPERR_BASE + 36 ) /* @I
         *
         *The %1 service was continued successfully.
         */

#define APE_PausSuccess (APPERR_BASE + 37 ) /* @I
         *
         *The %1 service was paused successfully.
         */

#define APE_ContFailed (APPERR_BASE + 38 ) /* @I
         *
         *The %1 service failed to resume.
         */

#define APE_PausFailed (APPERR_BASE + 39 ) /* @I
         *
         *The %1 service failed to pause.
         */

#define APE_ContPending (APPERR_BASE + 40 ) /* @I
         *
         *The %1 service continue is pending%0
         */

#define APE_PausPending (APPERR_BASE + 41 ) /* @I
         *
         *The %1 service pause is pending%0
         */

#define APE_DevContSuccess (APPERR_BASE + 42 ) /* @I
         *
         *%1 was continued successfully.
         */

#define APE_DevPausSuccess (APPERR_BASE + 43 ) /* @I
         *
         *%1 was paused successfully.
         */

#define APE_StartPendingOther (APPERR_BASE + 44 ) /* @I
	*
	*The %1 service has been started by another process and is pending.%0
	*/

#define APE_ServiceSpecificError (APPERR_BASE + 47 ) /* @E
	*
	*A service specific error occurred: %1.
	*/



/***
 *
 *      Information messages
 *
 */

#define APE_SessionList (APPERR_BASE + 160 ) /* @I
         *
         *These workstations have sessions on this server:
         */

#define APE_SessionOpenList (APPERR_BASE + 161 ) /* @I
         *
         *These workstations have sessions with open files on this server:
         */

#define APE_NameIsFwd (APPERR_BASE + 166 ) /* @I
         *
         *The message alias is forwarded.
         */

#define APE_KillDevList (APPERR_BASE + 170 ) /* @I
         *
         *You have these remote connections:
         */

#define APE_KillCancel (APPERR_BASE + 171 ) /* @I
         *
         *Continuing will cancel the connections.
         */

#define APE_SessionOpenFiles (APPERR_BASE + 175 ) /* @I
         *
         *The session from %1 has open files.
         */

#define APE_ConnectionsAreRemembered (APPERR_BASE + 176 ) /* @I
         *
         *New connections will be remembered.
         */

#define APE_ConnectionsAreNotRemembered (APPERR_BASE + 177 ) /* @I
         *
         *New connections will not be remembered.
         */

#define APE_ProfileWriteError (APPERR_BASE + 178 ) /* @I
         *
         *An error occurred while saving your profile. The state of your remembered connections has not changed.
         */

#define APE_ProfileReadError (APPERR_BASE + 179 ) /* @I
         *
         *An error occurred while reading your profile. 
         */

#define APE_LoadError (APPERR_BASE + 180 ) /* @E
         *
         *An error occurred while restoring the connection to %1.
         */

#define APE_NothingRunning (APPERR_BASE + 182 ) /* @I
         *
         *No network services are started.
         */

#define APE_EmptyList (APPERR_BASE + 183 ) /* @I
         *
         *There are no entries in the list.
         */

#define APE_ShareOpens  (APPERR_BASE + 188) /* @I
         *
         *Users have open files on %1.  Continuing the operation will force the files closed.
         */

#define APE_WkstaSwitchesIgnored        (APPERR_BASE + 189) /* @I
         *
         *The Workstation service is already running. Windows will ignore command options for the workstation.
         */

#define APE_OpenHandles (APPERR_BASE + 191 ) /* @I
         *
         *There are open files and/or incomplete directory searches pending on the connection to %1.
         */

#define APE_RemotingToDC (APPERR_BASE + 193 ) /* @I
         *
         *The request will be processed at a domain controller for domain %1.
         */

#define APE_ShareSpooling (APPERR_BASE + 194 ) /* @E
         *
         *The shared queue cannot be deleted while a print job is being spooled to the queue.
         */

#define APE_DeviceIsRemembered (APPERR_BASE + 195 ) /* @E
         *
         *%1 has a remembered connection to %2.
         */



/***
 *
 *      Error messages
 *
 */

#define APE_HelpFileDoesNotExist            (APPERR_BASE + 210)
        /*
         *An error occurred while opening the Help file.
         */

#define APE_HelpFileEmpty                   (APPERR_BASE + 211)
        /*
         *The Help file is empty.
         */

#define APE_HelpFileError                   (APPERR_BASE + 212)
        /*
         *The Help file is corrupted.
         */

#define APE_DCNotFound          (APPERR_BASE + 213)
        /*
         *Could not find a domain controller for domain %1.
         */

#define APE_DownlevelReqPriv    (APPERR_BASE + 214)
        /*
         *This operation is privileged on systems with earlier
         *versions of the software.
         */

#define APE_UnknDevType         (APPERR_BASE + 216)
        /*
         *The device type is unknown.
         */

#define APE_LogFileCorrupt              (APPERR_BASE + 217)
        /*
         *The log file has been corrupted.
         */

#define APE_OnlyNetRunExes      (APPERR_BASE + 218)
        /*
         *Program filenames must end with .EXE.
         */

#define APE_ShareNotFound (APPERR_BASE + 219)
        /*
         *A matching share could not be found so nothing was deleted.
         */

#define APE_UserBadUPW (APPERR_BASE + 220)
        /*
         *A bad value is in the units-per-week field of the user record.
         */

#define APE_UseBadPass (APPERR_BASE + 221 )
        /*
         *The password is invalid for %1.
         */

#define APE_SendErrSending (APPERR_BASE + 222 )
        /*
         *An error occurred while sending a message to %1.
         */

#define APE_UseBadPassOrUser (APPERR_BASE + 223 )
        /*
         *The password or user name is invalid for %1.
         */

#define APE_ShareErrDeleting (APPERR_BASE + 225 )
        /*
         *An error occurred when the share was deleted.
         */

#define APE_LogoInvalidName (APPERR_BASE + 226 )
        /*
         *The user name is invalid.
         */

#define APE_UtilInvalidPass (APPERR_BASE + 227 )
        /*
         *The password is invalid.
         */

/*  Note.  The APE_UtilNomatch error message string is used in the
 *  WINNET project, where the string is hard coded.  Therefore, if
 *  This string changes, please do also update WINNET.RC in the
 *  WINNET project (..\..\WINNET\WINNET.RC).   Thank you.
 */
#define APE_UtilNomatch (APPERR_BASE + 228 )
        /*
         *The passwords do not match.
         */

#define APE_LoadAborted (APPERR_BASE + 229 ) /* @E
         *
         *Your persistent connections were not all restored.
         */

#define APE_PassInvalidCname (APPERR_BASE + 230 )
        /*
         *This is not a valid computer name or domain name.
         */


#define APE_NoDefaultPerms  (APPERR_BASE + 232)
        /*
         *Default permissions cannot be set for that resource.
         */


/*  Note.  The APE_NoGoodPass error message string is used in the
 *  WINNET project, where the string is hard coded.  Therefore, if
 *  This string changes, please do also update WINNET.RC in the
 *  WINNET project (..\..\WINNET\WINNET.RC).   Thank you.
 */
#define APE_NoGoodPass (APPERR_BASE + 234 )
        /*
         *A valid password was not entered.
         */

#define APE_NoGoodName (APPERR_BASE + 235 )
        /*
         *A valid name was not entered.
         */

#define APE_BadResource (APPERR_BASE + 236 ) /* @E
         *
         *The resource named cannot be shared.
         */

#define APE_BadPermsString (APPERR_BASE + 237 ) /* @E
         *
         *The permissions string contains invalid permissions.
         */

#define APE_InvalidDeviceType (APPERR_BASE + 238 ) /* @E
         *
         *You can only perform this operation on printers and communication devices.
         */

#define APE_BadUGName (APPERR_BASE + 242 ) /* @E
         *
         *%1 is an invalid user or group name.
         */

#define APE_BadAdminConfig      (APPERR_BASE+243)
        /*
         *The server is not configured for remote administration.
         */

#define APE_NoUsersOfSrv                    (APPERR_BASE + 252)
        /*
         *No users have sessions with this server.
         */

#define APE_UserNotInGroup                  (APPERR_BASE + 253)
        /*
         *User %1 is not a member of group %2.
         */

#define APE_UserAlreadyInGroup              (APPERR_BASE + 254)
        /*
         *User %1 is already a member of group %2.
         */

#define APE_NoSuchUser                      (APPERR_BASE + 255)
        /*
         *There is no such user: %1.
         */

#define APE_UtilInvalidResponse     (APPERR_BASE + 256) /* @I
         *
         *This is an invalid response.
         */

#define APE_NoGoodResponse                  (APPERR_BASE + 257)
        /*
         *No valid response was provided.
         */

#define APE_ShareNoMatch                    (APPERR_BASE + 258)
        /*
         *The destination list provided does not match the destination list of the printer queue.
         */

#define APE_PassChgDate                 (APPERR_BASE + 259)
        /*
         *Your password cannot be changed until %1.
         */

/***
 *  NET USER /TIMES format messages
 *
 */

#define APE_UnrecognizedDay                 (APPERR_BASE + 260)
        /*
         *%1 is not a recognized day of the week.
         */

#define APE_ReversedTimeRange               (APPERR_BASE + 261)
        /*
         *The time range specified ends before it starts.
         */

#define APE_UnrecognizedHour                (APPERR_BASE + 262)
        /*
         *%1 is not a recognized hour.
         */

#define APE_UnrecognizedMinutes             (APPERR_BASE + 263)
        /*
         *%1 is not a valid specification for minutes.
         */

#define APE_NonzeroMinutes                  (APPERR_BASE + 264)
        /*
         *Time supplied is not exactly on the hour.
         */

#define APE_MixedTimeFormat                 (APPERR_BASE + 265)
        /*
         *12 and 24 hour time formats may not be mixed.
         */

#define APE_NeitherAmNorPm                  (APPERR_BASE + 266)
        /*
         *%1 is not a valid 12-hour suffix.
         */

#define APE_BadDateFormat                       (APPERR_BASE + 267)
        /*
         *An illegal date format has been supplied.
         */

#define APE_BadDayRange                         (APPERR_BASE + 268)
        /*
         *An illegal day range has been supplied.
         */

#define APE_BadTimeRange                        (APPERR_BASE + 269)
        /*
         *An illegal time range has been supplied.
         */


/***
 * 	Other NET USER messages
 *
 */

#define APE_UserBadArgs                      (APPERR_BASE + 270)
        /*
         *Arguments to NET USER are invalid. Check the minimum password
         *length and/or arguments supplied.
         */

#define APE_UserBadEnablescript               (APPERR_BASE + 271)
        /*
         *The value for ENABLESCRIPT must be YES.
         */

#define APE_UserBadCountryCode                (APPERR_BASE + 273)
        /*
         *An illegal country code has been supplied.
         */

#define APE_UserFailAddToUsersAlias           (APPERR_BASE + 274)
        /*
         *The user was successfully created but could not be added
	 *to the USERS local group.
         */

/***
 *
 *      Misc new messages for NT
 *
 */
#define APE_BadUserContext                (APPERR_BASE + 275)
        /*
         *The user context supplied is invalid.
         */

#define APE_ErrorInDLL                    (APPERR_BASE + 276) 
	/*
         *The dynamic-link library %1 could not be loaded, or an error
         *occurred while trying to use it.
         */

#define APE_SendFileNotSupported          (APPERR_BASE + 277)
        /*
         *Sending files is no longer supported.
         */

#define APE_CannotShareSpecial            (APPERR_BASE + 278)
        /*
         *You may not specify paths for ADMIN$ and IPC$ shares.
         */

#define APE_AccountAlreadyInLocalGroup              (APPERR_BASE + 279)
        /*
         *User or group %1 is already a member of local group %2.
         */

#define APE_NoSuchAccount                      (APPERR_BASE + 280)
        /*
         *There is no such user or group: %1.
         */

#define APE_NoSuchComputerAccount               (APPERR_BASE + 281)
        /*
         *There is no such computer: %1.
         */

#define APE_ComputerAccountExists               (APPERR_BASE + 282)
        /*
         *The computer %1 already exists.
         */

#define APE_NoSuchRegAccount                      (APPERR_BASE + 283)
        /*
         *There is no such global user or group: %1.
         */

#define APE_BadCacheType                          (APPERR_BASE + 284)
    /*
     * Only disk shares can be marked as cacheable
     */

/*
 *  Used by NETLIB
 */
#define APE_UNKNOWN_MESSAGE              (APPERR_BASE + 290) 
        /*
         *The system could not find message: %1.
         */


/***
 *
 *      AT messages
 *
 */

#define APE_AT_INVALID_SCHED_DATE           (APPERR_BASE + 302)
        /*
         *This schedule date is invalid.
         */

#define APE_AT_WKSTAGETINFO_FAILURE         (APPERR_BASE + 303)
        /*
         *The LANMAN root directory is unavailable.
         */

#define APE_AT_SCHED_FILE_FAILURE           (APPERR_BASE + 304)
        /*
         *The SCHED.LOG file could not be opened.
         */

#define APE_AT_MEM_FAILURE                  (APPERR_BASE + 305)
        /*
         *The Server service has not been started.
         */

#define APE_AT_ID_NOT_FOUND                 (APPERR_BASE + 306)
        /*
         *The AT job ID does not exist.
         */

#define APE_AT_SCHED_CORRUPT                (APPERR_BASE + 307)
        /*
         *The AT schedule file is corrupted.
         */

#define APE_AT_DELETE_FAILURE               (APPERR_BASE + 308)
        /*
         *The delete failed due to a problem with the AT schedule file.
         */

#define APE_AT_COMMAND_TOO_LONG             (APPERR_BASE + 309)
        /*
         *The command line cannot exceed 259 characters.
         */

#define APE_AT_DISKFULL                     (APPERR_BASE + 310)
        /*
         *The AT schedule file could not be updated because the disk is full.
         */

#define APE_AT_INVALIDATED_AT_FILE          (APPERR_BASE + 312)
        /*
         *The AT schedule file is invalid.  Please delete the file and create a new one.
         */

#define APE_AT_SCHED_FILE_CLEARED           (APPERR_BASE + 313)
        /*
         *The AT schedule file was deleted.
         */

#define APE_AT_USAGE			    (APPERR_BASE + 314) /* @I
         *
         *The syntax of this command is:
         *
         *AT [id] [/DELETE]
         *AT time [/EVERY:date | /NEXT:date] command
         *
         *The AT command schedules a program command to run at a
         *later date and time on a server.  It also displays the
         *list of programs and commands scheduled to be run.
         *
	 *You can specify the date as M,T,W,Th,F,Sa,Su or 1-31
         *for the day of the month.
	 *
	 *You can specify the time in the 24 hour HH:MM format.
         */

#define APE_AT_SEM_BLOCKED	    	(APPERR_BASE + 315)
	/*
	 *The AT command has timed-out.
	 *Please try again later.
	 */

/***
 *
 *      NET ACCOUNTS error messages for NT
 *
 */
#define APE_MinGreaterThanMaxAge                (APPERR_BASE + 316)
        /*
         *The minimum password age for user accounts cannot be greater
         *than the maximum password age.
         */

#define APE_NotUASCompatible                    (APPERR_BASE + 317) 
	/*
         *You have specified a value that is incompatible
         *with servers with down-level software. Please specify a lower value.
         */

/* the following 2 messages have nothing to do with any ACC utility */
#define APE_BAD_COMPNAME                    (APPERR_BASE + 370)
        /*
         *%1 is not a valid computer name.
         */

#define APE_BAD_MSGID               (APPERR_BASE + 371)
        /*
         *%1 is not a valid Windows network message number.
         */

/*
 * Messenger message headers and ends.	These messages are also bound into
 * the messenger, in case the net.msg file is not available.
 */

#define APE_MSNGR_HDR			    (APPERR_BASE + 400)
    /*
     *Message from %1 to %2 on %3
     */

#define APE_MSNGR_GOODEND		    (APPERR_BASE + 401)
    /*
     *****
     */

#define APE_MSNGR_BADEND		    (APPERR_BASE + 402)
    /*
     ***** unexpected end of message ****
     */

/*
 * Messages for the net popup service / api.
 */


#define APE_POPUP_DISMISS		    (APPERR_BASE + 405)
    /* Press ESC to exit*/

#define APE_POPUP_MOREDATA		    (APPERR_BASE + 406)
    /*...*/



/***
 *
 *  NET TIME messages
 *
 */

#define APE_TIME_TimeDisp		(APPERR_BASE + 410)    /* @I
                *
                *Current time at %1 is %2
                */

#define APE_TIME_SetTime		(APPERR_BASE + 411)    /* @P
                *
                *The current local clock is %1
                *Do you want to set the local computer's time to match the
                *time at %2? %3: %0
                */

#define APE_TIME_RtsNotFound		(APPERR_BASE + 412)    /* @I
                *
                *Could not locate a time-server.
                */

#define APE_TIME_DcNotFound		(APPERR_BASE + 413)    /* @E
                *
                *Could not find the domain controller for domain %1.
                */

#define APE_TIME_TimeDispLocal		(APPERR_BASE + 414)    /* @I
                *
                *Local time (GMT%3) at %1 is %2
                */

/***
 *
 *  NET USE messages
 *
 */

#define APE_UseHomeDirNotDetermined	(APPERR_BASE + 415)    /* @E
                *
                *The user's home directory could not be determined.
                */

#define APE_UseHomeDirNotSet		(APPERR_BASE + 416)    /* @E
		*
		*The user's home directory has not been specified.
                */

#define APE_UseHomeDirNotUNC		(APPERR_BASE + 417)    /* @E
		*
		*The name specified for the user's home directory (%1) is not a universal naming convention (UNC) name.
                */

#define APE_UseHomeDirSuccess		(APPERR_BASE + 418)    /* @I
                *
                *Drive %1 is now connected to %2. Your home directory is %3\%4.
                */

#define APE_UseWildCardSuccess		(APPERR_BASE + 419)    /* @I
                *
                *Drive %1 is now connected to %2. 
                */

#define APE_UseWildCardNoneLeft		(APPERR_BASE + 420)    /* @E
                *
                *There are no available drive letters left.
                */

#define APE_CS_InvalidDomain		(APPERR_BASE + 432)	/* @E
                *
                *%1 is not a valid domain or workgroup name.
                */

/*
 *  More NET TIME messages
 */
#define APE_TIME_SNTP           (APPERR_BASE + 435) /* @I
        *
        *The current SNTP value is: %1
        */

#define APE_TIME_SNTP_DEFAULT   (APPERR_BASE + 436) /* @I
        *
        *This computer is not currently configured to use a specific SNTP server.
        */

#define APE_TIME_SNTP_AUTO      (APPERR_BASE + 437) /* @I
        *
        *This current autoconfigured SNTP value is: %1
        */


#define APE_CmdArgTooMany		(APPERR_BASE + 451)
		/*
		 * You specified too many values for the %1 option.
		 */

#define APE_CmdArgIllegal		(APPERR_BASE + 452)
		/*
		 * You entered an invalid value for the %1 option.
		 */

#define APE_CmdArgIncorrectSyntax	(APPERR_BASE + 453)
		/*
		 *The syntax is incorrect.
		 */

/*
 * NET PRINT and NET FILE errors
 */

#define APE_FILE_BadId                 		(APPERR_BASE + 460)
        /*
         *You specified an invalid file number.
         */

#define APE_PRINT_BadId                 	(APPERR_BASE + 461)
        /*
         *You specified an invalid print job number.
         */

/*
 * ALIAS related errors
 */

#define APE_UnknownAccount			(APPERR_BASE + 463)
	/*
	 *The user or group account specified cannot be found.
	 */

/*
 * FPNW related errors
 */

#define APE_CannotEnableNW			(APPERR_BASE + 465)
	/*
	 *The user was added but could not be enabled for File and Print
     *Services for NetWare.
	 */

#define APE_FPNWNotInstalled	    (APPERR_BASE + 466)
	/*
	 *File and Print Services for NetWare is not installed.
	 */

#define APE_CannotSetNW			    (APPERR_BASE + 467)
	/*
	 *Cannot set user properties for File and Print Services for NetWare.
	 */

#define APE_RandomPassword			    (APPERR_BASE + 468)
	/*
	 *Password for %1 is: %2
	 */

#define APE_NWCompat			    (APPERR_BASE + 469)
	/*
	 *NetWare compatible logon
	 */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\public\internal\drivers\inc\vscoordint.h ===
#pragma warning( disable: 4049 )  /* more than 64k source lines */

/* this ALWAYS GENERATED file contains the definitions for the interfaces */


 /* File created by MIDL compiler version 6.00.0347 */
/* Compiler settings for vscoordint.idl:
    Oicf, W1, Zp8, env=Win32 (32b run)
    protocol : dce , ms_ext, c_ext, robust
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )


/* verify that the <rpcndr.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCNDR_H_VERSION__
#define __REQUIRED_RPCNDR_H_VERSION__ 475
#endif

#include "rpc.h"
#include "rpcndr.h"

#ifndef __RPCNDR_H_VERSION__
#error this stub requires an updated version of <rpcndr.h>
#endif // __RPCNDR_H_VERSION__

#ifndef COM_NO_WINDOWS_H
#include "windows.h"
#include "ole2.h"
#endif /*COM_NO_WINDOWS_H*/

#ifndef __vscoordint_h__
#define __vscoordint_h__

#if defined(_MSC_VER) && (_MSC_VER >= 1020)
#pragma once
#endif

/* Forward Declarations */ 

#ifndef __IVssCoordinator_FWD_DEFINED__
#define __IVssCoordinator_FWD_DEFINED__
typedef interface IVssCoordinator IVssCoordinator;
#endif 	/* __IVssCoordinator_FWD_DEFINED__ */


#ifndef __IVssShim_FWD_DEFINED__
#define __IVssShim_FWD_DEFINED__
typedef interface IVssShim IVssShim;
#endif 	/* __IVssShim_FWD_DEFINED__ */


#ifndef __IVssAdmin_FWD_DEFINED__
#define __IVssAdmin_FWD_DEFINED__
typedef interface IVssAdmin IVssAdmin;
#endif 	/* __IVssAdmin_FWD_DEFINED__ */


#ifndef __VSSCoordinator_FWD_DEFINED__
#define __VSSCoordinator_FWD_DEFINED__

#ifdef __cplusplus
typedef class VSSCoordinator VSSCoordinator;
#else
typedef struct VSSCoordinator VSSCoordinator;
#endif /* __cplusplus */

#endif 	/* __VSSCoordinator_FWD_DEFINED__ */


/* header files for imported files */
#include "oaidl.h"
#include "ocidl.h"
#include "vss.h"

#ifdef __cplusplus
extern "C"{
#endif 

void * __RPC_USER MIDL_user_allocate(size_t);
void __RPC_USER MIDL_user_free( void * ); 

#ifndef __IVssCoordinator_INTERFACE_DEFINED__
#define __IVssCoordinator_INTERFACE_DEFINED__

/* interface IVssCoordinator */
/* [unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IVssCoordinator;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("93BA4344-AA56-403e-87F2-819650FEDACD")
    IVssCoordinator : public IUnknown
    {
    public:
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE SetContext( 
            /* [in] */ LONG lContext) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE StartSnapshotSet( 
            /* [out] */ VSS_ID *pSnapshotSetId) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE AddToSnapshotSet( 
            /* [in] */ VSS_PWSZ pwszVolumeName,
            /* [in] */ VSS_ID ProviderId,
            /* [out] */ VSS_ID *pSnapshotId) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE DoSnapshotSet( 
            /* [in] */ IDispatch *pWriterCallback,
            /* [out] */ IVssAsync **ppAsync) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetSnapshotProperties( 
            /* [in] */ VSS_ID SnapshotId,
            /* [out] */ VSS_SNAPSHOT_PROP *pProp) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE ExposeSnapshot( 
            /* [in] */ VSS_ID SnapshotId,
            /* [in] */ VSS_PWSZ wszPathFromRoot,
            /* [in] */ LONG lAttributes,
            /* [in] */ VSS_PWSZ wszExpose,
            /* [out] */ VSS_PWSZ *pwszExposed) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE RemountReadWrite( 
            /* [in] */ VSS_ID SnapshotId,
            /* [out] */ IVssAsync **ppAsync) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE ImportSnapshots( 
            /* [in] */ BSTR bstrXMLSnapshotSet,
            /* [out] */ IVssAsync **ppAsync) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE Query( 
            /* [in] */ VSS_ID QueriedObjectId,
            /* [in] */ VSS_OBJECT_TYPE eQueriedObjectType,
            /* [in] */ VSS_OBJECT_TYPE eReturnedObjectsType,
            /* [out] */ IVssEnumObject **ppEnum) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE DeleteSnapshots( 
            /* [in] */ VSS_ID SourceObjectId,
            /* [in] */ VSS_OBJECT_TYPE eSourceObjectType,
            /* [in] */ BOOL bForceDelete,
            /* [out] */ LONG *plDeletedSnapshots,
            /* [out] */ VSS_ID *pNondeletedSnapshotID) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE BreakSnapshotSet( 
            /* [in] */ VSS_ID SnapshotSetId) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE IsVolumeSupported( 
            /* [in] */ VSS_ID ProviderId,
            /* [in] */ VSS_PWSZ pwszVolumeName,
            /* [out] */ BOOL *pbSupportedByThisProvider) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE IsVolumeSnapshotted( 
            /* [in] */ VSS_ID ProviderId,
            /* [in] */ VSS_PWSZ pwszVolumeName,
            /* [out] */ BOOL *pbSnapshotsPresent,
            /* [out] */ LONG *plSnapshotCompatibility) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE SetWriterInstances( 
            /* [in] */ LONG lWriterInstanceIdCount,
            /* [size_is][unique][in] */ VSS_ID *rgWriterInstanceId) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IVssCoordinatorVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IVssCoordinator * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IVssCoordinator * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IVssCoordinator * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *SetContext )( 
            IVssCoordinator * This,
            /* [in] */ LONG lContext);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *StartSnapshotSet )( 
            IVssCoordinator * This,
            /* [out] */ VSS_ID *pSnapshotSetId);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *AddToSnapshotSet )( 
            IVssCoordinator * This,
            /* [in] */ VSS_PWSZ pwszVolumeName,
            /* [in] */ VSS_ID ProviderId,
            /* [out] */ VSS_ID *pSnapshotId);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *DoSnapshotSet )( 
            IVssCoordinator * This,
            /* [in] */ IDispatch *pWriterCallback,
            /* [out] */ IVssAsync **ppAsync);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *GetSnapshotProperties )( 
            IVssCoordinator * This,
            /* [in] */ VSS_ID SnapshotId,
            /* [out] */ VSS_SNAPSHOT_PROP *pProp);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *ExposeSnapshot )( 
            IVssCoordinator * This,
            /* [in] */ VSS_ID SnapshotId,
            /* [in] */ VSS_PWSZ wszPathFromRoot,
            /* [in] */ LONG lAttributes,
            /* [in] */ VSS_PWSZ wszExpose,
            /* [out] */ VSS_PWSZ *pwszExposed);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *RemountReadWrite )( 
            IVssCoordinator * This,
            /* [in] */ VSS_ID SnapshotId,
            /* [out] */ IVssAsync **ppAsync);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *ImportSnapshots )( 
            IVssCoordinator * This,
            /* [in] */ BSTR bstrXMLSnapshotSet,
            /* [out] */ IVssAsync **ppAsync);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *Query )( 
            IVssCoordinator * This,
            /* [in] */ VSS_ID QueriedObjectId,
            /* [in] */ VSS_OBJECT_TYPE eQueriedObjectType,
            /* [in] */ VSS_OBJECT_TYPE eReturnedObjectsType,
            /* [out] */ IVssEnumObject **ppEnum);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *DeleteSnapshots )( 
            IVssCoordinator * This,
            /* [in] */ VSS_ID SourceObjectId,
            /* [in] */ VSS_OBJECT_TYPE eSourceObjectType,
            /* [in] */ BOOL bForceDelete,
            /* [out] */ LONG *plDeletedSnapshots,
            /* [out] */ VSS_ID *pNondeletedSnapshotID);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *BreakSnapshotSet )( 
            IVssCoordinator * This,
            /* [in] */ VSS_ID SnapshotSetId);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *IsVolumeSupported )( 
            IVssCoordinator * This,
            /* [in] */ VSS_ID ProviderId,
            /* [in] */ VSS_PWSZ pwszVolumeName,
            /* [out] */ BOOL *pbSupportedByThisProvider);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *IsVolumeSnapshotted )( 
            IVssCoordinator * This,
            /* [in] */ VSS_ID ProviderId,
            /* [in] */ VSS_PWSZ pwszVolumeName,
            /* [out] */ BOOL *pbSnapshotsPresent,
            /* [out] */ LONG *plSnapshotCompatibility);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *SetWriterInstances )( 
            IVssCoordinator * This,
            /* [in] */ LONG lWriterInstanceIdCount,
            /* [size_is][unique][in] */ VSS_ID *rgWriterInstanceId);
        
        END_INTERFACE
    } IVssCoordinatorVtbl;

    interface IVssCoordinator
    {
        CONST_VTBL struct IVssCoordinatorVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IVssCoordinator_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IVssCoordinator_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IVssCoordinator_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IVssCoordinator_SetContext(This,lContext)	\
    (This)->lpVtbl -> SetContext(This,lContext)

#define IVssCoordinator_StartSnapshotSet(This,pSnapshotSetId)	\
    (This)->lpVtbl -> StartSnapshotSet(This,pSnapshotSetId)

#define IVssCoordinator_AddToSnapshotSet(This,pwszVolumeName,ProviderId,pSnapshotId)	\
    (This)->lpVtbl -> AddToSnapshotSet(This,pwszVolumeName,ProviderId,pSnapshotId)

#define IVssCoordinator_DoSnapshotSet(This,pWriterCallback,ppAsync)	\
    (This)->lpVtbl -> DoSnapshotSet(This,pWriterCallback,ppAsync)

#define IVssCoordinator_GetSnapshotProperties(This,SnapshotId,pProp)	\
    (This)->lpVtbl -> GetSnapshotProperties(This,SnapshotId,pProp)

#define IVssCoordinator_ExposeSnapshot(This,SnapshotId,wszPathFromRoot,lAttributes,wszExpose,pwszExposed)	\
    (This)->lpVtbl -> ExposeSnapshot(This,SnapshotId,wszPathFromRoot,lAttributes,wszExpose,pwszExposed)

#define IVssCoordinator_RemountReadWrite(This,SnapshotId,ppAsync)	\
    (This)->lpVtbl -> RemountReadWrite(This,SnapshotId,ppAsync)

#define IVssCoordinator_ImportSnapshots(This,bstrXMLSnapshotSet,ppAsync)	\
    (This)->lpVtbl -> ImportSnapshots(This,bstrXMLSnapshotSet,ppAsync)

#define IVssCoordinator_Query(This,QueriedObjectId,eQueriedObjectType,eReturnedObjectsType,ppEnum)	\
    (This)->lpVtbl -> Query(This,QueriedObjectId,eQueriedObjectType,eReturnedObjectsType,ppEnum)

#define IVssCoordinator_DeleteSnapshots(This,SourceObjectId,eSourceObjectType,bForceDelete,plDeletedSnapshots,pNondeletedSnapshotID)	\
    (This)->lpVtbl -> DeleteSnapshots(This,SourceObjectId,eSourceObjectType,bForceDelete,plDeletedSnapshots,pNondeletedSnapshotID)

#define IVssCoordinator_BreakSnapshotSet(This,SnapshotSetId)	\
    (This)->lpVtbl -> BreakSnapshotSet(This,SnapshotSetId)

#define IVssCoordinator_IsVolumeSupported(This,ProviderId,pwszVolumeName,pbSupportedByThisProvider)	\
    (This)->lpVtbl -> IsVolumeSupported(This,ProviderId,pwszVolumeName,pbSupportedByThisProvider)

#define IVssCoordinator_IsVolumeSnapshotted(This,ProviderId,pwszVolumeName,pbSnapshotsPresent,plSnapshotCompatibility)	\
    (This)->lpVtbl -> IsVolumeSnapshotted(This,ProviderId,pwszVolumeName,pbSnapshotsPresent,plSnapshotCompatibility)

#define IVssCoordinator_SetWriterInstances(This,lWriterInstanceIdCount,rgWriterInstanceId)	\
    (This)->lpVtbl -> SetWriterInstances(This,lWriterInstanceIdCount,rgWriterInstanceId)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring] */ HRESULT STDMETHODCALLTYPE IVssCoordinator_SetContext_Proxy( 
    IVssCoordinator * This,
    /* [in] */ LONG lContext);


void __RPC_STUB IVssCoordinator_SetContext_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IVssCoordinator_StartSnapshotSet_Proxy( 
    IVssCoordinator * This,
    /* [out] */ VSS_ID *pSnapshotSetId);


void __RPC_STUB IVssCoordinator_StartSnapshotSet_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IVssCoordinator_AddToSnapshotSet_Proxy( 
    IVssCoordinator * This,
    /* [in] */ VSS_PWSZ pwszVolumeName,
    /* [in] */ VSS_ID ProviderId,
    /* [out] */ VSS_ID *pSnapshotId);


void __RPC_STUB IVssCoordinator_AddToSnapshotSet_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IVssCoordinator_DoSnapshotSet_Proxy( 
    IVssCoordinator * This,
    /* [in] */ IDispatch *pWriterCallback,
    /* [out] */ IVssAsync **ppAsync);


void __RPC_STUB IVssCoordinator_DoSnapshotSet_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IVssCoordinator_GetSnapshotProperties_Proxy( 
    IVssCoordinator * This,
    /* [in] */ VSS_ID SnapshotId,
    /* [out] */ VSS_SNAPSHOT_PROP *pProp);


void __RPC_STUB IVssCoordinator_GetSnapshotProperties_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IVssCoordinator_ExposeSnapshot_Proxy( 
    IVssCoordinator * This,
    /* [in] */ VSS_ID SnapshotId,
    /* [in] */ VSS_PWSZ wszPathFromRoot,
    /* [in] */ LONG lAttributes,
    /* [in] */ VSS_PWSZ wszExpose,
    /* [out] */ VSS_PWSZ *pwszExposed);


void __RPC_STUB IVssCoordinator_ExposeSnapshot_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IVssCoordinator_RemountReadWrite_Proxy( 
    IVssCoordinator * This,
    /* [in] */ VSS_ID SnapshotId,
    /* [out] */ IVssAsync **ppAsync);


void __RPC_STUB IVssCoordinator_RemountReadWrite_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IVssCoordinator_ImportSnapshots_Proxy( 
    IVssCoordinator * This,
    /* [in] */ BSTR bstrXMLSnapshotSet,
    /* [out] */ IVssAsync **ppAsync);


void __RPC_STUB IVssCoordinator_ImportSnapshots_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IVssCoordinator_Query_Proxy( 
    IVssCoordinator * This,
    /* [in] */ VSS_ID QueriedObjectId,
    /* [in] */ VSS_OBJECT_TYPE eQueriedObjectType,
    /* [in] */ VSS_OBJECT_TYPE eReturnedObjectsType,
    /* [out] */ IVssEnumObject **ppEnum);


void __RPC_STUB IVssCoordinator_Query_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IVssCoordinator_DeleteSnapshots_Proxy( 
    IVssCoordinator * This,
    /* [in] */ VSS_ID SourceObjectId,
    /* [in] */ VSS_OBJECT_TYPE eSourceObjectType,
    /* [in] */ BOOL bForceDelete,
    /* [out] */ LONG *plDeletedSnapshots,
    /* [out] */ VSS_ID *pNondeletedSnapshotID);


void __RPC_STUB IVssCoordinator_DeleteSnapshots_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IVssCoordinator_BreakSnapshotSet_Proxy( 
    IVssCoordinator * This,
    /* [in] */ VSS_ID SnapshotSetId);


void __RPC_STUB IVssCoordinator_BreakSnapshotSet_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IVssCoordinator_IsVolumeSupported_Proxy( 
    IVssCoordinator * This,
    /* [in] */ VSS_ID ProviderId,
    /* [in] */ VSS_PWSZ pwszVolumeName,
    /* [out] */ BOOL *pbSupportedByThisProvider);


void __RPC_STUB IVssCoordinator_IsVolumeSupported_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IVssCoordinator_IsVolumeSnapshotted_Proxy( 
    IVssCoordinator * This,
    /* [in] */ VSS_ID ProviderId,
    /* [in] */ VSS_PWSZ pwszVolumeName,
    /* [out] */ BOOL *pbSnapshotsPresent,
    /* [out] */ LONG *plSnapshotCompatibility);


void __RPC_STUB IVssCoordinator_IsVolumeSnapshotted_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IVssCoordinator_SetWriterInstances_Proxy( 
    IVssCoordinator * This,
    /* [in] */ LONG lWriterInstanceIdCount,
    /* [size_is][unique][in] */ VSS_ID *rgWriterInstanceId);


void __RPC_STUB IVssCoordinator_SetWriterInstances_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IVssCoordinator_INTERFACE_DEFINED__ */


#ifndef __IVssShim_INTERFACE_DEFINED__
#define __IVssShim_INTERFACE_DEFINED__

/* interface IVssShim */
/* [unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IVssShim;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("D6222095-05C3-42f3-81D9-A4A0CEC05C26")
    IVssShim : public IUnknown
    {
    public:
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE SimulateSnapshotFreeze( 
            /* [in] */ VSS_ID guidSnapshotSetId,
            /* [in] */ ULONG ulOptionFlags,
            /* [in] */ ULONG ulVolumeCount,
            /* [size_is][size_is][unique][in] */ VSS_PWSZ *ppwszVolumeNamesArray,
            /* [out] */ IVssAsync **ppAsync) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE SimulateSnapshotThaw( 
            /* [in] */ VSS_ID guidSnapshotSetId) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE WaitForSubscribingCompletion( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IVssShimVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IVssShim * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IVssShim * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IVssShim * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *SimulateSnapshotFreeze )( 
            IVssShim * This,
            /* [in] */ VSS_ID guidSnapshotSetId,
            /* [in] */ ULONG ulOptionFlags,
            /* [in] */ ULONG ulVolumeCount,
            /* [size_is][size_is][unique][in] */ VSS_PWSZ *ppwszVolumeNamesArray,
            /* [out] */ IVssAsync **ppAsync);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *SimulateSnapshotThaw )( 
            IVssShim * This,
            /* [in] */ VSS_ID guidSnapshotSetId);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *WaitForSubscribingCompletion )( 
            IVssShim * This);
        
        END_INTERFACE
    } IVssShimVtbl;

    interface IVssShim
    {
        CONST_VTBL struct IVssShimVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IVssShim_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IVssShim_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IVssShim_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IVssShim_SimulateSnapshotFreeze(This,guidSnapshotSetId,ulOptionFlags,ulVolumeCount,ppwszVolumeNamesArray,ppAsync)	\
    (This)->lpVtbl -> SimulateSnapshotFreeze(This,guidSnapshotSetId,ulOptionFlags,ulVolumeCount,ppwszVolumeNamesArray,ppAsync)

#define IVssShim_SimulateSnapshotThaw(This,guidSnapshotSetId)	\
    (This)->lpVtbl -> SimulateSnapshotThaw(This,guidSnapshotSetId)

#define IVssShim_WaitForSubscribingCompletion(This)	\
    (This)->lpVtbl -> WaitForSubscribingCompletion(This)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring] */ HRESULT STDMETHODCALLTYPE IVssShim_SimulateSnapshotFreeze_Proxy( 
    IVssShim * This,
    /* [in] */ VSS_ID guidSnapshotSetId,
    /* [in] */ ULONG ulOptionFlags,
    /* [in] */ ULONG ulVolumeCount,
    /* [size_is][size_is][unique][in] */ VSS_PWSZ *ppwszVolumeNamesArray,
    /* [out] */ IVssAsync **ppAsync);


void __RPC_STUB IVssShim_SimulateSnapshotFreeze_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IVssShim_SimulateSnapshotThaw_Proxy( 
    IVssShim * This,
    /* [in] */ VSS_ID guidSnapshotSetId);


void __RPC_STUB IVssShim_SimulateSnapshotThaw_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IVssShim_WaitForSubscribingCompletion_Proxy( 
    IVssShim * This);


void __RPC_STUB IVssShim_WaitForSubscribingCompletion_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IVssShim_INTERFACE_DEFINED__ */


#ifndef __IVssAdmin_INTERFACE_DEFINED__
#define __IVssAdmin_INTERFACE_DEFINED__

/* interface IVssAdmin */
/* [unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IVssAdmin;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("77ED5996-2F63-11d3-8A39-00C04F72D8E3")
    IVssAdmin : public IUnknown
    {
    public:
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE RegisterProvider( 
            /* [in] */ VSS_ID pProviderId,
            /* [in] */ CLSID ClassId,
            /* [in] */ VSS_PWSZ pwszProviderName,
            /* [in] */ VSS_PROVIDER_TYPE eProviderType,
            /* [in] */ VSS_PWSZ pwszProviderVersion,
            /* [in] */ VSS_ID ProviderVersionId) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE UnregisterProvider( 
            /* [in] */ VSS_ID ProviderId) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE QueryProviders( 
            /* [out] */ IVssEnumObject **ppEnum) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE AbortAllSnapshotsInProgress( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IVssAdminVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IVssAdmin * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IVssAdmin * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IVssAdmin * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *RegisterProvider )( 
            IVssAdmin * This,
            /* [in] */ VSS_ID pProviderId,
            /* [in] */ CLSID ClassId,
            /* [in] */ VSS_PWSZ pwszProviderName,
            /* [in] */ VSS_PROVIDER_TYPE eProviderType,
            /* [in] */ VSS_PWSZ pwszProviderVersion,
            /* [in] */ VSS_ID ProviderVersionId);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *UnregisterProvider )( 
            IVssAdmin * This,
            /* [in] */ VSS_ID ProviderId);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *QueryProviders )( 
            IVssAdmin * This,
            /* [out] */ IVssEnumObject **ppEnum);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *AbortAllSnapshotsInProgress )( 
            IVssAdmin * This);
        
        END_INTERFACE
    } IVssAdminVtbl;

    interface IVssAdmin
    {
        CONST_VTBL struct IVssAdminVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IVssAdmin_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IVssAdmin_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IVssAdmin_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IVssAdmin_RegisterProvider(This,pProviderId,ClassId,pwszProviderName,eProviderType,pwszProviderVersion,ProviderVersionId)	\
    (This)->lpVtbl -> RegisterProvider(This,pProviderId,ClassId,pwszProviderName,eProviderType,pwszProviderVersion,ProviderVersionId)

#define IVssAdmin_UnregisterProvider(This,ProviderId)	\
    (This)->lpVtbl -> UnregisterProvider(This,ProviderId)

#define IVssAdmin_QueryProviders(This,ppEnum)	\
    (This)->lpVtbl -> QueryProviders(This,ppEnum)

#define IVssAdmin_AbortAllSnapshotsInProgress(This)	\
    (This)->lpVtbl -> AbortAllSnapshotsInProgress(This)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring] */ HRESULT STDMETHODCALLTYPE IVssAdmin_RegisterProvider_Proxy( 
    IVssAdmin * This,
    /* [in] */ VSS_ID pProviderId,
    /* [in] */ CLSID ClassId,
    /* [in] */ VSS_PWSZ pwszProviderName,
    /* [in] */ VSS_PROVIDER_TYPE eProviderType,
    /* [in] */ VSS_PWSZ pwszProviderVersion,
    /* [in] */ VSS_ID ProviderVersionId);


void __RPC_STUB IVssAdmin_RegisterProvider_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IVssAdmin_UnregisterProvider_Proxy( 
    IVssAdmin * This,
    /* [in] */ VSS_ID ProviderId);


void __RPC_STUB IVssAdmin_UnregisterProvider_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IVssAdmin_QueryProviders_Proxy( 
    IVssAdmin * This,
    /* [out] */ IVssEnumObject **ppEnum);


void __RPC_STUB IVssAdmin_QueryProviders_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IVssAdmin_AbortAllSnapshotsInProgress_Proxy( 
    IVssAdmin * This);


void __RPC_STUB IVssAdmin_AbortAllSnapshotsInProgress_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IVssAdmin_INTERFACE_DEFINED__ */



#ifndef __VSS_LIBRARY_DEFINED__
#define __VSS_LIBRARY_DEFINED__

/* library VSS */
/* [helpstring][version][uuid] */ 


EXTERN_C const IID LIBID_VSS;

EXTERN_C const CLSID CLSID_VSSCoordinator;

#ifdef __cplusplus

class DECLSPEC_UUID("E579AB5F-1CC4-44b4-BED9-DE0991FF0623")
VSSCoordinator;
#endif
#endif /* __VSS_LIBRARY_DEFINED__ */

/* Additional Prototypes for ALL interfaces */

unsigned long             __RPC_USER  BSTR_UserSize(     unsigned long *, unsigned long            , BSTR * ); 
unsigned char * __RPC_USER  BSTR_UserMarshal(  unsigned long *, unsigned char *, BSTR * ); 
unsigned char * __RPC_USER  BSTR_UserUnmarshal(unsigned long *, unsigned char *, BSTR * ); 
void                      __RPC_USER  BSTR_UserFree(     unsigned long *, BSTR * ); 

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\public\internal\ds\inc\adsi.h ===
//---------------------------------------------------------------------------
//
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1997
//
//  File:  adsi.h
//
//  Contents:  Microsoft ADs LDAP Provider DSObject
//
//
//  History:   02-20-97    yihsins    Created.
//
//----------------------------------------------------------------------------

#ifdef __cplusplus
extern "C" {
#endif

HRESULT
ADSIOpenDSObject(
    LPWSTR pszDNName,
    LPWSTR pszUserName,
    LPWSTR pszPassword,
    LONG   lnReserved,
    PHANDLE phDSObject
    );

HRESULT
ADSICloseDSObject(
    HANDLE hDSObject
    );

HRESULT
ADSISetObjectAttributes(
    HANDLE hDSObject,
    PADS_ATTR_INFO pAttributeEntries,
    DWORD dwNumAttributes,
    DWORD *pdwNumAttributesModified
    );

HRESULT
ADSIGetObjectAttributes(
    HANDLE hDSObject,
    LPWSTR *pAttributeNames,
    DWORD dwNumberAttributes,
    PADS_ATTR_INFO *ppAttributeEntries,
    DWORD * pdwNumAttributesReturned
    );

HRESULT
ADSICreateDSObject(
    HANDLE hParentDSObject,
    LPWSTR pszRDNName,
    PADS_ATTR_INFO pAttributeEntries,
    DWORD dwNumAttributes
    );

HRESULT
ADSIDeleteDSObject(
    HANDLE hParentDSObject,
    LPWSTR pszRDNName
    );

BOOL
FreeADsMem(
   LPVOID pMem
);


HRESULT
ADSISetSearchPreference(
    HANDLE hDSObject,
    IN PADS_SEARCHPREF_INFO pSearchPrefs,
    IN DWORD   dwNumPrefs
    );


HRESULT
ADSIExecuteSearch(
    HANDLE hDSObject,
    IN LPWSTR pszSearchFilter,
    IN LPWSTR * pAttributeNames,
    IN DWORD dwNumberAttributes,
    OUT PADS_SEARCH_HANDLE phSearchHandle
    );

HRESULT
ADSIAbandonSearch(
    HANDLE hDSObject,
    IN PADS_SEARCH_HANDLE phSearchHandle
    );


HRESULT
ADSICloseSearchHandle (
    HANDLE hDSObject,
    IN ADS_SEARCH_HANDLE hSearchHandle
    );


HRESULT
ADSIGetFirstRow(
    HANDLE hDSObject,
    IN ADS_SEARCH_HANDLE hSearchHandle
    );

HRESULT
ADSIGetNextRow(
    HANDLE hDSObject,
    IN ADS_SEARCH_HANDLE hSearchHandle
    );


HRESULT
ADSIGetPreviousRow(
    HANDLE hDSObject,
    IN ADS_SEARCH_HANDLE hSearchHandle
    );


HRESULT
ADSIGetColumn(
    HANDLE hDSObject,
    IN ADS_SEARCH_HANDLE hSearchHandle,
    IN LPWSTR pszColumnName,
    OUT PADS_SEARCH_COLUMN pColumn
    );


HRESULT
ADSIGetNextColumnName(
    HANDLE hDSObject,
    IN ADS_SEARCH_HANDLE hSearchHandle,
    OUT LPWSTR * ppszColumnName
    );


HRESULT
ADSIFreeColumn(
    HANDLE hDSObject,
    IN PADS_SEARCH_COLUMN pColumn
    );

HRESULT
ADSIEnumAttributes(
    HANDLE hDSObject,
    LPWSTR * ppszAttrNames,
    DWORD dwNumAttributes,
    PADS_ATTR_DEF * ppAttrDefinition,
    DWORD * pdwNumAttributes
    );

HRESULT
ADSICreateAttributeDefinition(
    HANDLE hDSObject,
    LPWSTR pszAttributeName,
    PADS_ATTR_DEF pAttributeDefinition
    );

HRESULT
ADSIWriteAttributeDefinition(
    HANDLE hDSObject,
    LPWSTR pszAttributeName,
    PADS_ATTR_DEF  pAttributeDefinition
    );

HRESULT
ADSIDeleteAttributeDefinition(
    HANDLE hDSObject,
    LPWSTR pszAttributeName
    );


HRESULT
ADSIModifyRdn(
    HANDLE hDSObject,
    LPWSTR pszOldRdn,
    LPWSTR pszNewRdn
    );

#ifdef __cplusplus
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\public\internal\drivers\inc\watchdog.h ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved.

Module Name:

    watchdog.h

Abstract:

    Contains all structure and routine definitions for
    NT Watchdog services.

Author:

    Michael Maciesowicz (mmacie) 05-May-2000

Environment:

    Kernel mode only.

Notes:

Revision History:

--*/

#ifndef _WATCHDOG_H_
#define _WATCHDOG_H_

#ifdef __cplusplus
extern "C" {
#endif  // __cplusplus

#ifdef WATCHDOG_EXPORTS
#define WATCHDOGAPI
#else
#define WATCHDOGAPI __declspec(dllimport)
#endif  // WATCHDOG_EXPORTS

//
// Do not dereference any watchdog data types directly!!!
// They're subject to change at any time.
//

//
// Data types.
//

typedef enum _WD_OBJECT_TYPE
{
    WdStandardWatchdog = 'WSdW',        // WdSW
    WdDeferredWatchdog = 'WDdW'         // WdDW
} WD_OBJECT_TYPE, *PWD_OBJECT_TYPE;

typedef enum _WD_TIME_TYPE
{
    WdKernelTime = 1,
    WdUserTime,
    WdFullTime
} WD_TIME_TYPE, *PWD_TIME_TYPE;

typedef enum _WD_EVENT_TYPE
{
    WdNoEvent = 1,
    WdTimeoutEvent,
    WdRecoveryEvent
} WD_EVENT_TYPE, *PWD_EVENT_TYPE;

typedef struct _WATCHDOG_OBJECT
{
    WD_OBJECT_TYPE ObjectType;
    LONG ReferenceCount;
    ULONG OwnerTag;
    PDEVICE_OBJECT DeviceObject;
    WD_TIME_TYPE TimeType;
    WD_EVENT_TYPE LastEvent;
    struct _KTHREAD *RESTRICTED_POINTER LastQueuedThread;
    KSPIN_LOCK SpinLock;
} WATCHDOG_OBJECT, *PWATCHDOG_OBJECT;

typedef struct _DEFERRED_WATCHDOG
{
    WATCHDOG_OBJECT Header;
    LONG Period;
    LONG SuspendCount;
    LONG InCount;
    LONG OutCount;
    LONG LastInCount;
    LONG LastOutCount;
    ULONG LastKernelTime;
    ULONG LastUserTime;
    ULONG TimeIncrement;
    LONG Trigger;
    BOOLEAN Started;
    struct _KTHREAD *RESTRICTED_POINTER Thread;
    struct _KTIMER Timer;
    struct _KDPC TimerDpc;
    struct _KDPC *ClientDpc;
} DEFERRED_WATCHDOG, *PDEFERRED_WATCHDOG;

typedef struct _WATCHDOG
{
    WATCHDOG_OBJECT Header;
    ULONG StartCount;
    ULONG SuspendCount;
    ULONG LastKernelTime;
    ULONG LastUserTime;
    ULONG TimeIncrement;
    LARGE_INTEGER DueTime;
    LARGE_INTEGER InitialDueTime;
    struct _KTHREAD *RESTRICTED_POINTER Thread;
    struct _KTIMER Timer;
    struct _KDPC TimerDpc;
    struct _KDPC *ClientDpc;
} WATCHDOG, *PWATCHDOG;

//
// Deferred watchdog function prototypes.
//

WATCHDOGAPI
PDEFERRED_WATCHDOG
WdAllocateDeferredWatchdog(
    IN PDEVICE_OBJECT DeviceObject,
    IN WD_TIME_TYPE TimeType,
    IN ULONG Tag
    );

WATCHDOGAPI
VOID
FASTCALL
WdEnterMonitoredSection(
    IN PDEFERRED_WATCHDOG Watch
    );

WATCHDOGAPI
VOID
FASTCALL
WdExitMonitoredSection(
    IN PDEFERRED_WATCHDOG Watch
    );

WATCHDOGAPI
VOID
WdFreeDeferredWatchdog(
    IN PDEFERRED_WATCHDOG Watch
    );

WATCHDOGAPI
VOID
FASTCALL
WdResetDeferredWatch(
    IN PDEFERRED_WATCHDOG Watch
    );

WATCHDOGAPI
VOID
FASTCALL
WdResumeDeferredWatch(
    IN PDEFERRED_WATCHDOG Watch,
    IN BOOLEAN Incremental
    );

WATCHDOGAPI
VOID
WdStartDeferredWatch(
    IN PDEFERRED_WATCHDOG Watch,
    IN PKDPC Dpc,
    IN LONG Period
    );

WATCHDOGAPI
VOID
WdStopDeferredWatch(
    IN PDEFERRED_WATCHDOG Watch
    );

WATCHDOGAPI
VOID
FASTCALL
WdSuspendDeferredWatch(
    IN PDEFERRED_WATCHDOG Watch
    );

//
// Watchdog function prototypes.
//

WATCHDOGAPI
PWATCHDOG
WdAllocateWatchdog(
    IN PDEVICE_OBJECT DeviceObject,
    IN WD_TIME_TYPE TimeType,
    IN ULONG Tag
    );

WATCHDOGAPI
VOID
WdFreeWatchdog(
    IN PWATCHDOG Watch
    );

WATCHDOGAPI
VOID
WdResetWatch(
    IN PWATCHDOG Watch
    );

WATCHDOGAPI
VOID
WdResumeWatch(
    IN PWATCHDOG Watch,
    IN BOOLEAN Incremental
    );

WATCHDOGAPI
VOID
WdStartWatch(
    IN PWATCHDOG Watch,
    IN LARGE_INTEGER DueTime,
    IN PKDPC Dpc
    );

WATCHDOGAPI
VOID
WdStopWatch(
    IN PWATCHDOG Watch,
    IN BOOLEAN Incremental
    );

WATCHDOGAPI
VOID
WdSuspendWatch(
    IN PWATCHDOG Watch
    );

WATCHDOGAPI
VOID
WdDdiWatchdogDpcCallback(
    IN PKDPC Dpc,
    IN PVOID DeferredContext,
    IN PVOID SystemArgument1,
    IN PVOID SystemArgument2
    );

//
// Common function prototypes.
//

WATCHDOGAPI
VOID
WdCompleteEvent(
    IN PVOID Watch,
    IN PKTHREAD Thread
    );

WATCHDOGAPI
VOID
WdDereferenceObject(
    IN PVOID Watch
    );

WATCHDOGAPI
PDEVICE_OBJECT
WdGetDeviceObject(
    IN PVOID Watch
    );

WATCHDOGAPI
WD_EVENT_TYPE
WdGetLastEvent(
    IN PVOID Watch
    );

WATCHDOGAPI
PDEVICE_OBJECT
WdGetLowestDeviceObject(
    IN PVOID Watch
    );

WATCHDOGAPI
VOID
WdReferenceObject(
    IN PVOID Watch
    );

#ifdef __cplusplus
}
#endif  // __cplusplus
#endif  // _WATCHDOG_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\public\internal\ds\inc\alloca.h ===
/*++

Copyright (c) 2001  Microsoft Corporation

Module Name:

    alloca.h

Abstract:

    This module implements a safe stack-based allocator with fallback to the heap.

Author:

    Jonathan Schwartz (JSchwart)  16-Mar-2001

Revision History:

--*/

#ifndef _SAFEALLOCA_H_
#define _SAFEALLOCA_H_

#ifdef __cplusplus
extern "C"
{
#endif // __cplusplus


#include <align.h>    // ALIGN_WORST


//
// Type definitions
//

typedef ULONG SAFEALLOCA_HEADER;

typedef PVOID (APIENTRY *SAFEALLOC_ALLOC_PROC)(
    SIZE_T Size
    );

typedef VOID (APIENTRY *SAFEALLOC_FREE_PROC)(
    PVOID BaseAddress
    );


//
// Constant definitions
//

#define SAFEALLOCA_STACK_HEADER    ((SAFEALLOCA_HEADER) 0x6b637453)   /* "Stck" */
#define SAFEALLOCA_HEAP_HEADER     ((SAFEALLOCA_HEADER) 0x70616548)   /* "Heap" */

#define SAFEALLOCA_USE_DEFAULT     0xdeadbeef

//
// We'll be adding ALIGN_WORST bytes to the allocation size to add room for
// the SAFEALLOCA_HEADER -- make sure we'll always have enough space.
//

C_ASSERT(sizeof(SAFEALLOCA_HEADER) <= ALIGN_WORST);


//
// Per-DLL SafeAlloca globals
//

extern SIZE_T  g_ulMaxStackAllocSize;
extern SIZE_T  g_ulAdditionalProbeSize;

extern SAFEALLOC_ALLOC_PROC  g_pfnAllocate;
extern SAFEALLOC_FREE_PROC   g_pfnFree;


//
// Functions defined in alloca.lib
//

VOID
SafeAllocaInitialize(
    IN  OPTIONAL SIZE_T                ulMaxStackAllocSize,
    IN  OPTIONAL SIZE_T                ulAdditionalProbeSize,
    IN  OPTIONAL SAFEALLOC_ALLOC_PROC  pfnAllocate,
    IN  OPTIONAL SAFEALLOC_FREE_PROC   pfnFree
    );

BOOL
VerifyStackAvailable(
    SIZE_T Size
    );


//
// Usage:
//
//     VOID
//     SafeAllocaAllocate(
//         PVOID  PtrVar,
//         SIZE_T BlockSize
//         );
//
// (PtrVar == NULL) on failure
//

#define SafeAllocaAllocate(PtrVar, BlockSize)                                            \
                                                                                         \
    {                                                                                    \
        PVOID *ppvAvoidCast = (PVOID *) &(PtrVar);                                       \
                                                                                         \
        (PtrVar) = NULL;                                                                 \
                                                                                         \
        /* Make sure block is below the threshhold and that the probe won't overflow */  \
                                                                                         \
        if ((BlockSize) <= g_ulMaxStackAllocSize                                         \
             &&                                                                          \
            ((BlockSize) + g_ulAdditionalProbeSize >= (BlockSize)))                      \
        {                                                                                \
            if (VerifyStackAvailable((BlockSize)                                         \
                                         + g_ulAdditionalProbeSize                       \
                                         + ALIGN_WORST))                                 \
            {                                                                            \
                /*                                                                       \
                 * Don't need to wrap with try-except since we just probed               \
                 */                                                                      \
                                                                                         \
                *ppvAvoidCast = _alloca((BlockSize) + ALIGN_WORST);                      \
            }                                                                            \
                                                                                         \
            if ((PtrVar) != NULL)                                                        \
            {                                                                            \
                *((SAFEALLOCA_HEADER *) (PtrVar)) = SAFEALLOCA_STACK_HEADER;             \
                *ppvAvoidCast = ((LPBYTE) (PtrVar) + ALIGN_WORST);                       \
            }                                                                            \
        }                                                                                \
                                                                                         \
        /*                                                                               \
         * Stack allocation failed -- try the heap                                       \
         */                                                                              \
                                                                                         \
        if ((PtrVar) == NULL)                                                            \
        {                                                                                \
            *ppvAvoidCast = g_pfnAllocate((BlockSize) + ALIGN_WORST);                    \
                                                                                         \
            if ((PtrVar) != NULL)                                                        \
            {                                                                            \
                *((SAFEALLOCA_HEADER *) (PtrVar)) = SAFEALLOCA_HEAP_HEADER;              \
                *ppvAvoidCast = ((LPBYTE) (PtrVar) + ALIGN_WORST);                       \
            }                                                                            \
        }                                                                                \
    }


//
// Usage:
//
//     VOID
//     SafeAllocaFree(
//         PVOID  PtrVar,
//         );
//

#define SafeAllocaFree(PtrVar)                                                         \
                                                                                       \
    if (PtrVar != NULL)                                                                \
    {                                                                                  \
        SAFEALLOCA_HEADER *Tag = (SAFEALLOCA_HEADER *) ((LPBYTE) (PtrVar)              \
                                      - ALIGN_WORST);                                  \
                                                                                       \
        if (*(SAFEALLOCA_HEADER *) (Tag) == SAFEALLOCA_HEAP_HEADER)                    \
        {                                                                              \
            g_pfnFree(Tag);                                                            \
        }                                                                              \
        else                                                                           \
        {                                                                              \
            ASSERT(*(SAFEALLOCA_HEADER *) (Tag) == SAFEALLOCA_STACK_HEADER);           \
        }                                                                              \
    }

#ifdef __cplusplus
}
#endif // __cplusplus

#endif  // _SAFEALLOCA_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\public\internal\ds\inc\apperr2.h ===
/*++ BUILD Version: 0001    // Increment this if a change has global effects

Copyright (c) 1991  Microsoft Corporation

Module Name:

    apperr2.h

Abstract:

    This file contains the number and text of NETCMD text for
    normal output, such as line-item labels and column headers.

Author:

    Dan Hinsley (danhi) 8-Jun-1991

Environment:

    User Mode - Win32
    Portable to any flat, 32-bit environment.  (Uses Win32 typedefs.)
    Requires ANSI C extensions: slash-slash comments.

--*/
#define APPERR2_BASE    4300            /* APP2 msgs start here */

/*******************************************************************
 *
 *      Constants for use by files including these messages.
 */

/*      APE2_CONST_MAXHDRLEN -- maximum length of any "header" strings,
 *      that is, those strings appearing the the top of a list or table.
 */

#define APE2_CONST_MAXHDRLEN    80
#define APE2_GEN_MAX_MSG_LEN    20


/**INTERNAL_ONLY**/

/***********WARNING ****************
 *See the comment in netcon.h for  *
 *info on the allocation of errors *
 ************************************/

/**END_INTERNAL**/

/*
 *      GEN -- General words.  These words are used in many places.  They
 *      are *not* to be used to build sentences.  The main use is in
 *      displaying information.  For example, in displaying a user's account
 *      information, the following would appear:
 *
 *              Account Disabled                No
 *              Account Expires                 Never
 *
 *      This is the only acceptable way to use these general words.
 *
 *      Size limits:
 *
 *              All GEN words should be limited to 20 characters, except as
 *              otherwise noted.
 */

#define APE2_GEN_YES                            (APPERR2_BASE + 0)      /* @I
                        *
                        *Yes%0
                        */

#define APE2_GEN_NO                                     (APPERR2_BASE + 1)      /* @I
                        *
                        *No%0
                        */

#define APE2_GEN_ALL                            (APPERR2_BASE + 2)      /* @I
                        *
                        *All%0
                        */

#define APE2_GEN_NONE                           (APPERR2_BASE + 3)      /* @I
                        *
                        *None%0
                        */

#define APE2_GEN_ALWAYS                         (APPERR2_BASE + 4)      /* @I
                        *
                        *Always%0
                        */

#define APE2_GEN_NEVER                          (APPERR2_BASE + 5)      /* @I
                        *
                        *Never%0
                        */

#define APE2_GEN_UNLIMITED                      (APPERR2_BASE + 6)      /* @I
                        *
                        *Unlimited%0
                        */

#define APE2_GEN_SUNDAY                         (APPERR2_BASE + 7)      /* @I
                        *
                        *Sunday%0
                        */

#define APE2_GEN_MONDAY                         (APPERR2_BASE + 8)      /* @I
                        *
                        *Monday%0
                        */

#define APE2_GEN_TUESDAY                        (APPERR2_BASE + 9)      /* @I
                        *
                        *Tuesday%0
                        */

#define APE2_GEN_WEDNSDAY                       (APPERR2_BASE + 10)     /* @I
                        *
                        *Wednesday%0
                        */

#define APE2_GEN_THURSDAY                       (APPERR2_BASE + 11)     /* @I
                        *
                        *Thursday%0
                        */

#define APE2_GEN_FRIDAY                         (APPERR2_BASE + 12)     /* @I
                        *
                        *Friday%0
                        */

#define APE2_GEN_SATURDAY                       (APPERR2_BASE + 13)     /* @I
                        *
                        *Saturday%0
                        */

#define APE2_GEN_SUNDAY_ABBREV                  (APPERR2_BASE + 14)     /* @I
                        *
                        *Su%0
                        */

#define APE2_GEN_MONDAY_ABBREV                  (APPERR2_BASE + 15)     /* @I
                        *
                        *M%0
                        */

#define APE2_GEN_TUESDAY_ABBREV                 (APPERR2_BASE + 16)     /* @I
                        *
                        *T%0
                        */

#define APE2_GEN_WEDNSDAY_ABBREV                (APPERR2_BASE + 17)     /* @I
                        *
                        *W%0
                        */

#define APE2_GEN_THURSDAY_ABBREV                (APPERR2_BASE + 18)     /* @I
                        *
                        *Th%0
                        */

#define APE2_GEN_FRIDAY_ABBREV                  (APPERR2_BASE + 19)     /* @I
                        *
                        *F%0
                        */

#define APE2_GEN_SATURDAY_ABBREV                (APPERR2_BASE + 20)     /* @I
                        *
                        *S%0
                        */

#define APE2_GEN_UNKNOWN                        (APPERR2_BASE + 21)     /* @I
                        *
                        *Unknown%0
                        */

#define APE2_GEN_TIME_AM1                       (APPERR2_BASE + 22)     /* @I
                        *
                        *AM%0
                        */

#define APE2_GEN_TIME_AM2                       (APPERR2_BASE + 23)     /* @I
                        *
                        *A.M.%0
                        */

#define APE2_GEN_TIME_PM1                       (APPERR2_BASE + 24)     /* @I
                        *
                        *PM%0
                        */

#define APE2_GEN_TIME_PM2                       (APPERR2_BASE + 25)     /* @I
                        *
                        *P.M.%0
                        */

/* see APE2_GEN_TIME_AM3 & APE2_GEN_TIME_PM3 below */

#define APE2_GEN_SERVER                         (APPERR2_BASE + 26)     /* @I
                        *
                        *Server%0
                        */

#define APE2_GEN_REDIR                          (APPERR2_BASE + 27)     /* @I
                        *
                        *Redirector%0
                        */

#define APE2_GEN_APP                            (APPERR2_BASE + 28)     /* @I
                        *
                        *Application%0
                        */

#define APE2_GEN_TOTAL                          (APPERR2_BASE + 29)     /* @I
                        *
                        *Total%0
                        */

#define APE2_GEN_QUESTION                       (APPERR2_BASE + 30)     /* @I
                        *
                        * ? %1 %0
                        */

#define APE2_GEN_KILOBYTES                      (APPERR2_BASE + 31)     /* @I
                        *
                        * K%0
                        */

#define APE2_GEN_MSG_NONE                       (APPERR2_BASE + 32)     /* @I
                        *
                        *(none)%0
                        */

#define APE2_GEN_DEVICE                 (APPERR2_BASE + 33)     /* @I
                        *
                        *Device%0
                        */

#define APE2_GEN_REMARK                 (APPERR2_BASE + 34)     /* @I
                        *
                        *Remark%0
                        */

#define APE2_GEN_AT                     (APPERR2_BASE + 35)     /* @I
                        *
                        *At%0
                        */

#define APE2_GEN_QUEUE                  (APPERR2_BASE + 36)     /* @I
                        *
                        *Queue%0
                        */

#define APE2_GEN_QUEUES                 (APPERR2_BASE + 37)     /* @I
                        *
                        *Queues%0
                        */

#define APE2_GEN_USER_NAME                      (APPERR2_BASE + 38)     /* @I
                        *
                        *User name%0
                        */

#define APE2_GEN_PATH                   (APPERR2_BASE + 39)     /* @I
                        *
                        *Path%0
                        */

#define APE2_GEN_DEFAULT_YES                    (APPERR2_BASE + 40)     /* @I
                        *
                        *(Y/N) [Y]%0
                        */

#define APE2_GEN_DEFAULT_NO                     (APPERR2_BASE + 41)     /* @I
                        *
                        *(Y/N) [N]%0
                        */

#define APE2_GEN_ERROR                          (APPERR2_BASE + 42)     /* @I
                        *
                        *Error%0
                        */

#define APE2_GEN_OK                             (APPERR2_BASE + 43)     /* @I
                        *
                        *OK%0
                        */

/*
 *      NOTE!! NLS_YES_CHAR & NLS_NO_CHAR MUST BE ONE (1) CHARACTER LONG!
 */
#define APE2_GEN_NLS_YES_CHAR   (APPERR2_BASE + 44)     /* @I
                        *
                        *Y%0
                        */

#define APE2_GEN_NLS_NO_CHAR    (APPERR2_BASE + 45)     /* @I
                        *
                        *N%0
                        */

#define APE2_GEN_ANY                            (APPERR2_BASE + 46)     /* @I
                        *
                        *Any%0
                        */

#define APE2_GEN_TIME_AM3                       (APPERR2_BASE + 47)     /* @I
                        *
                        *A%0
                        */

#define APE2_GEN_TIME_PM3                       (APPERR2_BASE + 48)     /* @I
                        *
                        *P%0
                        */

#define APE2_GEN_NOT_FOUND                      (APPERR2_BASE + 49)     /* @I
                        *
                        *(not found)%0
                        */

#define APE2_GEN_UKNOWN_IN_PARENS               (APPERR2_BASE + 50)     /* @I
                        *
                        *(unknown)%0
                        */


#define APE2_GEN_UsageHelp                      (APPERR2_BASE + 51)     /* @I
         *
         * For help on %1 type NET HELP %1
         */


/***
 *
 *      Password prompts
 *              Moved from APPERR.H 8/21/89  -- jmh
 *
 */

#define APE_GeneralPassPrompt (APPERR2_BASE + 54) /* @P
         *
         *Please type the password: %0
         */

#define APE_UsePassPrompt (APPERR2_BASE + 57) /* @P
         *
         *Type the password for %1: %0
         */

#define APE_UserUserPass (APPERR2_BASE + 58) /* @P
         *
         *Type a password for the user: %0
         */

#define APE_ShareSharePass (APPERR2_BASE + 59) /* @P
         *
         *Type the password for the shared resource: %0
         */

#define APE_UtilPasswd (APPERR2_BASE + 60) /* @P
         *
         *Type your password: %0
         */

#define APE_UtilConfirm (APPERR2_BASE + 61) /* @P
         *
         *Retype the password to confirm: %0
         */

#define APE_PassOpass (APPERR2_BASE + 62) /* @P
         *
         *Type the user's old password: %0
         */

#define APE_PassNpass (APPERR2_BASE + 63) /* @P
         *
         *Type the user's new password: %0
         */

#define APE_LogonNewPass (APPERR2_BASE + 64) /* @P
         *
         *Type your new password: %0
         */

#define APE_StartReplPass (APPERR2_BASE + 65) /* @P
        *
        *Type the Replicator service password: %0
        */


/***
 *
 *      Other prompts
 *              Moved from APPERR.H 8/21/89 -- jmh
 *
 */

#define APE_LogoUsername (APPERR2_BASE + 66) /* @P
         *
         *Type your user name, or press ENTER if it is %1: %0
         */

#define APE_PassCname (APPERR2_BASE + 67 ) /* @P
         *
         *Type the domain or server where you want to change a password, or
         *press ENTER if it is for domain %1: %0.
         */

#define APE_PassUname (APPERR2_BASE + 68 ) /* @P
         *
         *Type your user name: %0
         */

/***
 *
 *      Display Headings
 *              Moved from APPERR.H 8/21/89  -- jmh
 *
 */

#define APE_StatsStatistics (APPERR2_BASE + 69) /* @I
         *
         *Network statistics for \\%1
         */

#define APE_PrintOptions (APPERR2_BASE + 70) /* @I
         *
         *Printing options for %1
         */

#define APE_CommPoolsAccessing (APPERR2_BASE + 71) /* @I
         *
         *Communication-device queues accessing %1
         */

#define APE_PrintJobOptions (APPERR2_BASE + 72) /* @I
         *
         *Print job detail
         */

#define APE_CommPools (APPERR2_BASE + 73) /* @I
         *
         *Communication-device queues at \\%1
         */

#define APE_PrintQueues (APPERR2_BASE + 74) /* @I
         *
         *Printers at %1
         */

#define APE_PrintQueuesDevice (APPERR2_BASE + 75) /* @I
         *
         *Printers accessing %1
         */

#define APE_PrintJobs (APPERR2_BASE + 76) /* @I
         *
         *Print jobs at %1:
         */

#define APE_ViewResourcesAt (APPERR2_BASE + 77) /* @I
         *
         *Shared resources at %1
         */

#define APE_CnfgHeader (APPERR2_BASE + 78) /* @I
         *
         *The following running services can be controlled:
         */

#define APE_StatsHeader (APPERR2_BASE + 79) /* @I
         *
         *Statistics are available for the following running services:
         */

#define APE_UserAccounts (APPERR2_BASE + 80) /* @I
         *
         *User accounts for \\%1
         */

#define APE_Syntax (APPERR2_BASE + 81) /* @I
         *
         *The syntax of this command is:
         */

#define APE_Options (APPERR2_BASE + 82) /* @I
         *
         *The options of this command are:
         */

#define APE_PDCPrompt (APPERR2_BASE + 83) /* @I
         *
         *Please enter the name of the Primary Domain Controller: %0
         */

#define APE_StringTooLong (APPERR2_BASE + 84) /* @I
         *
         *The string you have entered is too long. The maximum
         *is %1, please reenter. %0
         */

/***
 *
 *   Japanese version specific messages
 *
 */

#define APE2_GEN_NONLOCALIZED_SUNDAY (APPERR2_BASE + 85)      /* @I
                        *
                        *Sunday%0
                        */

#define APE2_GEN_NONLOCALIZED_MONDAY (APPERR2_BASE + 86)      /* @I
                        *
                        *Monday%0
                        */

#define APE2_GEN_NONLOCALIZED_TUESDAY (APPERR2_BASE + 87)      /* @I
                        *
                        *Tuesday%0
                        */

#define APE2_GEN_NONLOCALIZED_WEDNSDAY (APPERR2_BASE + 88)     /* @I
                        *
                        *Wednesday%0
                        */

#define APE2_GEN_NONLOCALIZED_THURSDAY (APPERR2_BASE + 89)     /* @I
                        *
                        *Thursday%0
                        */

#define APE2_GEN_NONLOCALIZED_FRIDAY (APPERR2_BASE + 90)     /* @I
                        *
                        *Friday%0
                        */

#define APE2_GEN_NONLOCALIZED_SATURDAY (APPERR2_BASE + 91)     /* @I
                        *
                        *Saturday%0
                        */

#define APE2_GEN_NONLOCALIZED_SUNDAY_ABBREV (APPERR2_BASE + 92)     /* @I
                        *
                        *Su%0
                        */

#define APE2_GEN_NONLOCALIZED_MONDAY_ABBREV (APPERR2_BASE + 93)     /* @I
                        *
                        *M%0
                        */

#define APE2_GEN_NONLOCALIZED_TUESDAY_ABBREV (APPERR2_BASE + 94)     /* @I
                        *
                        *T%0
                        */

#define APE2_GEN_NONLOCALIZED_WEDNSDAY_ABBREV (APPERR2_BASE + 95)     /* @I
                        *
                        *W%0
                        */

#define APE2_GEN_NONLOCALIZED_THURSDAY_ABBREV (APPERR2_BASE + 96)     /* @I
                        *
                        *Th%0
                        */

#define APE2_GEN_NONLOCALIZED_FRIDAY_ABBREV (APPERR2_BASE + 97)     /* @I
                        *
                        *F%0
                        */

#define APE2_GEN_NONLOCALIZED_SATURDAY_ABBREV (APPERR2_BASE + 98)     /* @I
                        *
                        *S%0
                        */

#define APE2_GEN_NONLOCALIZED_SATURDAY_ABBREV2 (APPERR2_BASE + 99)     /* @I
                        *
                        *Sa%0
                        */

/***
 * End Japanese specific messages
 *
 */




/*
 *      GROUPENUM -- display of all groups.  Maximum length is 50.
 *
 *      Substitution of %1 is name of current server.
 */

#define APE2_GROUPENUM_HEADER           (APPERR2_BASE + 100)    /* @I
                        *
                        *Group Accounts for \\%1
                        */

/*
 *      GROUPDISP -- group display in full detail.  Maximum length of the
 *      strings other than MEMBERS is 50.
 *
 *      Note that MEMBERS is *NOT* given a %0 at the end !!
 */

#define APE2_GROUPDISP_GROUPNAME        (APPERR2_BASE + 101)    /* @I
                        *
                        *Group name%0
                        */

#define APE2_GROUPDISP_COMMENT          (APPERR2_BASE + 102)    /* @I
                        *
                        *Comment%0
                        */

#define APE2_GROUPDISP_MEMBERS          (APPERR2_BASE + 103)    /* @I
                        *
                        *Members
                        */

/*
 *      ALIASENUM -- display of all aliases.  Maximum length is 50.
 *
 *      Substitution of %1 is name of current server.
 */

#define APE2_ALIASENUM_HEADER           (APPERR2_BASE + 105)    /* @I
                        *
                        *Aliases for \\%1
                        */

/*
 *      ALIASDISP -- group display in full detail.  Maximum length of the
 *      strings other than MEMBERS is 50.
 *
 *      Note that MEMBERS is *NOT* given a %0 at the end !!
 */

#define APE2_ALIASDISP_ALIASNAME        (APPERR2_BASE + 106)    /* @I
                        *
                        *Alias name%0
                        */

#define APE2_ALIASDISP_COMMENT          (APPERR2_BASE + 107)    /* @I
                        *
                        *Comment%0
                        */

#define APE2_ALIASDISP_MEMBERS          (APPERR2_BASE + 108)    /* @I
                        *
                        *Members
                        */



/*
 *      USERENUM -- display of all users.  Maximum length is 50.
 *
 *      Substitution of %1 is name of current server.
 */

#define APE2_USERENUM_HEADER            (APPERR2_BASE + 110)    /* @I
                        *
                        *User Accounts for \\%1
                        */

/*
 *      USERDISP -- user display in full detail.  Maximum length of each
 *      item-label string is 50, values is 25.
 *
 *      Item labels are followed immediately by any related value strings,
 *      or references to such strings.
 */

#define APE2_USERDISP_USERNAME          (APPERR2_BASE + 111)    /* @I
                        *User name%0
                        */

#define APE2_USERDISP_FULLNAME          (APPERR2_BASE + 112)    /* @I
                        *
                        *Full Name%0
                        */

#define APE2_USERDISP_COMMENT           (APPERR2_BASE + 113)    /* @I
                        *
                        *Comment%0
                        */

#define APE2_USERDISP_USRCOMMENT        (APPERR2_BASE + 114)    /* @I
                        *
                        *User's comment%0
                        */

#define APE2_USERDISP_PARMS             (APPERR2_BASE + 115)    /* @I
                        *
                        *Parameters%0
                        */

#define APE2_USERDISP_COUNTRYCODE       (APPERR2_BASE + 116)    /* @I
                        *
                        *Country code%0
                        */

#define APE2_USERDISP_PRIV              (APPERR2_BASE + 117)    /* @I
                        *
                        *Privilege level%0
                        */

        /* See APE2_SEC_PRIV_xxx for value strings */

#define APE2_USERDISP_OPRIGHTS          (APPERR2_BASE + 118)    /* @I
                        *
                        *Operator privileges%0
                        */

        /* See APE2_SEC_OPRT_xxx for value strings.     */
        /* APE2_GEN_NONE is also used.                      */


#define APE2_USERDISP_ACCENABLED        (APPERR2_BASE + 119)    /* @I
                        *
                        *Account active%0
                        */

#define APE2_USERDISP_ACCEXP            (APPERR2_BASE + 120)    /* @I
                        *
                        *Account expires%0
                        */

#define APE2_USERDISP_PSWDSET           (APPERR2_BASE + 121)    /* @I
                        *
                        *Password last set%0
                        */

#define APE2_USERDISP_PSWDEXP           (APPERR2_BASE + 122)    /* @I
                        *
                        *Password expires%0
                        */

#define APE2_USERDISP_PSWDCHNG          (APPERR2_BASE + 123)    /* @I
                        *
                        *Password changeable%0
                        */

#define APE2_USERDISP_WKSTA             (APPERR2_BASE + 124)    /* @I
                        *
                        *Workstations allowed%0
                        */

#define APE2_USERDISP_MAXDISK           (APPERR2_BASE + 125)    /* @I
                        *
                        *Maximum disk space%0
                        */

#define APE2_USERDISP_MAXDISK_UNLIM     (APPERR2_BASE + 126)    /* @I
                        *
                        *Unlimited%0
                        */

#define APE2_USERDISP_ALIASES           (APPERR2_BASE + 127)    /* @I
                        *
                        *Local Group Memberships%0
                        */

#define APE2_USERDISP_LOGONSRV_DC       (APPERR2_BASE + 128)    /* @I
                        *
                        *Domain controller%0
                        */

        /* In addition to above, APE2_GEN_ANY is used here. */

#define APE2_USERDISP_LOGONSCRIPT       (APPERR2_BASE + 129)    /* @I
                        *
                        *Logon script%0
                        */

#define APE2_USERDISP_LASTLOGON         (APPERR2_BASE + 130)    /* @I
                        *
                        *Last logon%0
                        */

#define APE2_USERDISP_GROUPS            (APPERR2_BASE + 131)    /* @I
                        *
                        *Global Group memberships%0
                        */

#define APE2_USERDISP_LOGHOURS          (APPERR2_BASE + 132)    /* @I
                        *
                        *Logon hours allowed%0
                        */

#define APE2_USERDISP_LOGHRS_ALL        (APPERR2_BASE + 133)    /* @I
                        *
                        *All%0
                        */

#define APE2_USERDISP_LOGHRS_NONE       (APPERR2_BASE + 134)    /* @I
                        *
                        *None%0
                        */

#define APE2_USERDISP_LOGHRS_DAILY      (APPERR2_BASE + 135)    /* @I
                        *
                        *Daily %1 - %2%0
                        */

#define APE2_USERDISP_HOMEDIR           (APPERR2_BASE + 136)    /* @I
                        *
                        *Home directory%0
                        */

#define APE2_USERDISP_PSWDREQ           (APPERR2_BASE + 137)    /* @I
                        *
                        *Password required%0
                        */

#define APE2_USERDISP_PSWDUCHNG         (APPERR2_BASE + 138)    /* @I
                        *
                        *User may change password%0
                        */

#define APE2_USERDISP_PROFILE           (APPERR2_BASE + 139)    /* @I
                        *
                        *User profile%0
                        */

#define APE2_USERDISP_LOCKOUT           (APPERR2_BASE + 140)    /* @I
                        *
                        *Locked%0
                        */


/*
 *      CFG_W -- Config Workstation output
 */

#define APE2_CFG_W_CNAME                (APPERR2_BASE + 150)    /* @I
                        *
                        *Computer name%0
                        */

#define APE2_CFG_W_UNAME                (APPERR2_BASE + 151)    /* @I
                        *
                        *User name%0
                        */

#define APE2_CFG_W_VERSION              (APPERR2_BASE + 152)    /* @I
                        *
                        *Software version%0
                        */

#define APE2_CFG_W_NETS                 (APPERR2_BASE + 153)    /* @I
                        *
                        *Workstation active on%0
                        */

#define APE2_CFG_W_ROOT                 (APPERR2_BASE + 154)    /* @I
                        *
                        *Windows NT root directory%0
                        */

#define APE2_CFG_W_DOMAIN_P             (APPERR2_BASE + 155)    /* @I
                        *
                        *Workstation domain%0
                        */

#define APE2_CFG_W_DOMAIN_L             (APPERR2_BASE + 156)    /* @I
                        *
                        *Logon domain%0
                        */

#define APE2_CFG_W_DOMAIN_O             (APPERR2_BASE + 157)    /* @I
                        *
                        *Other domain(s)%0
                        */

#define APE2_CFG_W_COM_OTIME            (APPERR2_BASE + 158)    /* @I
                        *
                        *COM Open Timeout (sec)%0
                        */

#define APE2_CFG_W_COM_SCNT             (APPERR2_BASE + 159)    /* @I
                        *
                        *COM Send Count (byte)%0
                        */

#define APE2_CFG_W_COM_STIME            (APPERR2_BASE + 160)    /* @I
                        *
                        *COM Send Timeout (msec)%0
                        */

#define APE2_CFG_W_3X_PRTTIME           (APPERR2_BASE + 161)    /* @I
                        *
                        *DOS session print time-out (sec)%0
                        */

#define APE2_CFG_W_MAXERRLOG            (APPERR2_BASE + 162)    /* @I
                        *
                        *Maximum error log size (K)%0
                        */

#define APE2_CFG_W_MAXCACHE             (APPERR2_BASE + 163)    /* @I
                        *
                        *Maximum cache memory (K)%0
                        */

#define APE2_CFG_W_NUMNBUF              (APPERR2_BASE + 164)    /* @I
                        *
                        *Number of network buffers%0
                        */

#define APE2_CFG_W_NUMCBUF              (APPERR2_BASE + 165)    /* @I
                        *
                        *Number of character buffers%0
                        */

#define APE2_CFG_W_SIZNBUF              (APPERR2_BASE + 166)    /* @I
                        *
                        *Size of network buffers%0
                        */

#define APE2_CFG_W_SIZCBUF              (APPERR2_BASE + 167)    /* @I
                        *
                        *Size of character buffers%0
                        */
#define APE2_CFG_W_FULL_CNAME           (APPERR2_BASE + 168)    /* @I
                        *
                        *Full Computer name%0
                        */
#define APE2_CFG_W_DOMAIN_DNS           (APPERR2_BASE + 169)    /* @I
                        *
                        *Workstation Domain DNS Name%0
                        */
#define APE2_CFG_WINDOWS2000            (APPERR2_BASE + 170)    /* @I
                        *
                        *Windows 2002%0
                        */



/*
 *      CFG_S -- Config Server output
 */


#define APE2_CFG_S_SRVNAME              (APPERR2_BASE + 181)    /* @I
                        *
                        *Server Name%0
                        */

#define APE2_CFG_S_SRVCOMM              (APPERR2_BASE + 182)    /* @I
                        *
                        *Server Comment%0
                        */

#define APE2_CFG_S_ADMINALRT            (APPERR2_BASE + 183)    /* @I
                        *
                        *Send administrative alerts to%0
                        */

#define APE2_CFG_S_VERSION              (APPERR2_BASE + 184)    /* @I
                        *
                        *Software version%0
                        */

#define APE2_CFG_S_VERSION_PS           (APPERR2_BASE + 185)    /* @I
                        *
                        *Peer Server%0
                        */

#define APE2_CFG_S_VERSION_LM           (APPERR2_BASE + 186)    /* @I
                        *
                        *Windows NT%0
                        */

#define APE2_CFG_S_LEVEL                (APPERR2_BASE + 187)    /* @I
                        *
                        *Server Level%0
                        */

#define APE2_CFG_S_VERSION_IBM          (APPERR2_BASE + 188)    /* @I
                        *
                        *Windows NT Server%0
                        */

#define APE2_CFG_S_NETS                 (APPERR2_BASE + 189)    /* @I
                        *
                        *Server is active on%0
                        */

#define APE2_CFG_S_SRVHIDDEN            (APPERR2_BASE + 192)    /* @I
                        *
                        *Server hidden%0
                        */

#define APE2_CFG_S_MAXUSERS             (APPERR2_BASE + 206)    /* @I
                        *
                        *Maximum Logged On Users%0
                        */

#define APE2_CFG_S_MAXADMINS            (APPERR2_BASE + 207)    /* @I
                        *
                        *Maximum concurrent administrators%0
                        */

#define APE2_CFG_S_MAXSHARES            (APPERR2_BASE + 208)    /* @I
                        *
                        *Maximum resources shared%0
                        */

#define APE2_CFG_S_MAXCONNS             (APPERR2_BASE + 209)    /* @I
                        *
                        *Maximum connections to resources%0
                        */

#define APE2_CFG_S_MAXOFILES            (APPERR2_BASE + 210)    /* @I
                        *
                        *Maximum open files on server%0
                        */

#define APE2_CFG_S_MAXOFILESPS          (APPERR2_BASE + 211)    /* @I
                        *
                        *Maximum open files per session%0
                        */

#define APE2_CFG_S_MAXLOCKS             (APPERR2_BASE + 212)    /* @I
                        *
                        *Maximum file locks%0
                        */

#define APE2_CFG_S_IDLETIME             (APPERR2_BASE + 220)    /* @I
                        *
                        *Idle session time (min)%0
                        */

#define APE2_CFG_S_SEC_SHARE            (APPERR2_BASE + 226)    /* @I
                        *
                        *Share-level%0
                        */

#define APE2_CFG_S_SEC_USER             (APPERR2_BASE + 227)    /* @I
                        *
                        *User-level%0
                        */

#define APE2_CFG_S_LEVEL_UNLIMITED      (APPERR2_BASE + 230)    /* @I
                        *
                        *Unlimited Server%0
                        */



/*
 *      ACCOUNTS messages
 */
#define APE2_ACCOUNTS_FORCELOGOFF       (APPERR2_BASE + 270)    /* @I
                        *
                        *Force user logoff how long after time expires?:%0
                        *
                        */

#define APE2_ACCOUNTS_LOCKOUT_COUNT     (APPERR2_BASE + 271)    /* @I
                        *
                        *Lock out account after how many bad passwords?:%0
                        *
                        */

#define APE2_ACCOUNTS_MINPWAGE          (APPERR2_BASE + 272)    /* @I
                        *
                        *Minimum password age (days):%0
                        */

#define APE2_ACCOUNTS_MAXPWAGE          (APPERR2_BASE + 273)    /* @I
                        *
                        *Maximum password age (days):%0
                        */

#define APE2_ACCOUNTS_MINPWLEN          (APPERR2_BASE + 274)    /* @I
                        *
                        *Minimum password length:%0
                        */

#define APE2_ACCOUNTS_UNIQUEPW          (APPERR2_BASE + 275)    /* @I
                        *
                        *Length of password history maintained:%0
                        */

#define APE2_ACCOUNTS_ROLE              (APPERR2_BASE + 276)    /* @I
                        *
                        *Computer role:%0
                        */

#define APE2_ACCOUNTS_CONTROLLER        (APPERR2_BASE + 277)    /* @I
                        *
                        *Primary Domain controller for workstation domain:%0.
                        */

#define APE2_ACCOUNTS_LOCKOUT_THRESHOLD (APPERR2_BASE + 278)    /* @I
                        *
                        *Lockout threshold:%0
                        */

#define APE2_ACCOUNTS_LOCKOUT_DURATION  (APPERR2_BASE + 279)    /* @I
                        *
                        *Lockout duration (minutes):%0
                        */

#define APE2_ACCOUNTS_LOCKOUT_WINDOW    (APPERR2_BASE + 280)    /* @I
                        *
                        *Lockout observation window (minutes):%0
                        */

/***
 *
 *  STATISTICS display
 */

#define APE2_STATS_STARTED              (APPERR2_BASE + 300)    /* @I
                *
                *Statistics since%0
                */

#define APE2_STATS_S_ACCEPTED           (APPERR2_BASE + 301)    /* @I
                *
                *Sessions accepted%0
                */

#define APE2_STATS_S_TIMEDOUT           (APPERR2_BASE + 302)    /* @I
                *
                *Sessions timed-out%0
                */

#define APE2_STATS_ERROREDOUT           (APPERR2_BASE + 303)    /* @I
                *
                *Sessions errored-out%0
                */

#define APE2_STATS_B_SENT               (APPERR2_BASE + 304)    /* @I
                *
                *Kilobytes sent%0
                */

#define APE2_STATS_B_RECEIVED           (APPERR2_BASE + 305)    /* @I
                *
                *Kilobytes received%0
                */

#define APE2_STATS_RESPONSE             (APPERR2_BASE + 306)    /* @I
                *
                *Mean response time (msec)%0
                */

#define APE2_STATS_NETIO_ERR            (APPERR2_BASE + 307)    /* @I
                *
                *Network errors%0
                */

#define APE2_STATS_FILES_ACC            (APPERR2_BASE + 308)    /* @I
                *
                *Files accessed%0
                */

#define APE2_STATS_PRINT_ACC            (APPERR2_BASE + 309)    /* @I
                *
                *Print jobs spooled%0
                */

#define APE2_STATS_SYSTEM_ERR           (APPERR2_BASE + 310)    /* @I
                *
                *System errors%0
                */

#define APE2_STATS_PASS_ERR             (APPERR2_BASE + 311)    /* @I
                *
                *Password violations%0
                */

#define APE2_STATS_PERM_ERR             (APPERR2_BASE + 312)    /* @I
                *
                *Permission violations%0
                */

#define APE2_STATS_COMM_ACC             (APPERR2_BASE + 313)    /* @I
                *
                *Communication devices accessed%0
                */

#define APE2_STATS_S_OPENED            (APPERR2_BASE + 314)    /* @I
                *
                *Sessions started%0
                */

#define APE2_STATS_S_RECONN            (APPERR2_BASE + 315)    /* @I
                *
                *Sessions reconnected%0
                */

#define APE2_STATS_S_FAILED            (APPERR2_BASE + 316)    /* @I
                *
                *Sessions starts failed%0
                */

#define APE2_STATS_S_DISCONN           (APPERR2_BASE + 317)    /* @I
                *
                *Sessions disconnected%0
                */

#define APE2_STATS_NETIO               (APPERR2_BASE + 318)    /* @I
                *
                *Network I/O's performed%0
                */

#define APE2_STATS_IPC                 (APPERR2_BASE + 319)    /* @I
                *
                *Files and pipes accessed%0
                */

#define APE2_STATS_BUFCOUNT            (APPERR2_BASE + 320)    /* @I
                *
                *Times buffers exhausted
                */

#define APE2_STATS_BIGBUF              (APPERR2_BASE + 321)    /* @I
                *
                *Big buffers%0
                */

#define APE2_STATS_REQBUF              (APPERR2_BASE + 322)    /* @I
                *
                *Request buffers%0
                */

#define APE2_STATS_WKSTA                (APPERR2_BASE + 323)    /* @I
                *
                *Workstation Statistics for \\%1
                */

#define APE2_STATS_SERVER                (APPERR2_BASE + 324)    /* @I
                *
                *Server Statistics for \\%1
                */

#define APE2_STATS_SINCE                 (APPERR2_BASE + 325)    /* @I
                *
                *Statistics since %1
                */

#define APE2_STATS_C_MADE                (APPERR2_BASE + 326)    /* @I
                *
                *Connections made%0
                */

#define APE2_STATS_C_FAILED              (APPERR2_BASE + 327)    /* @I
                *
                *Connections failed%0
                */

/***
 *
 * New rdr stats for NT. These guys occupy the space that AT
 * used to.
 */


#define APE2_STATS_BYTES_RECEIVED       (APPERR2_BASE + 330)       /* @I
                *
                *Bytes received%0
                */
#define APE2_STATS_SMBS_RECEIVED        (APPERR2_BASE + 331)       /* @I
                *
                *Server Message Blocks (SMBs) received%0
                */
#define APE2_STATS_BYTES_TRANSMITTED    (APPERR2_BASE + 332)       /* @I
                *
                *Bytes transmitted%0
                */
#define APE2_STATS_SMBS_TRANSMITTED     (APPERR2_BASE + 333)       /* @I
                *
                *Server Message Blocks (SMBs) transmitted%0
                */
#define APE2_STATS_READ_OPS             (APPERR2_BASE + 334)       /* @I
                *
                *Read operations%0
                */
#define APE2_STATS_WRITE_OPS            (APPERR2_BASE + 335)       /* @I
                *
                *Write operations%0
                */
#define APE2_STATS_RAW_READS_DENIED     (APPERR2_BASE + 336)       /* @I
                *
                *Raw reads denied%0
                */
#define APE2_STATS_RAW_WRITES_DENIED    (APPERR2_BASE + 337)       /* @I
                *
                *Raw writes denied%0
                */
#define APE2_STATS_NETWORK_ERRORS       (APPERR2_BASE + 338)       /* @I
                *
                *Network errors%0
                */
#define APE2_STATS_TOTAL_CONNECTS       (APPERR2_BASE + 339)       /* @I
                *
                *Connections made%0
                */
#define APE2_STATS_RECONNECTS           (APPERR2_BASE + 340)       /* @I
                *
                *Reconnections made%0
                */
#define APE2_STATS_SRV_DISCONNECTS      (APPERR2_BASE + 341)       /* @I
                *
                *Server disconnects%0
                */
#define APE2_STATS_SESSIONS             (APPERR2_BASE + 342)       /* @I
                *
                *Sessions started%0
                */
#define APE2_STATS_HUNG_SESSIONS        (APPERR2_BASE + 343)       /* @I
                *
                *Hung sessions%0
                */
#define APE2_STATS_FAILED_SESSIONS      (APPERR2_BASE + 344)       /* @I
                *
                *Failed sessions%0
                */
#define APE2_STATS_FAILED_OPS           (APPERR2_BASE + 345)       /* @I
                *
                *Failed operations%0
                */
#define APE2_STATS_USE_COUNT            (APPERR2_BASE + 346)       /* @I
                *
                *Use count%0
                */
#define APE2_STATS_FAILED_USE_COUNT     (APPERR2_BASE + 347)       /* @I
                *
                *Failed use count%0
                */


/***
 *
 *      Specific success messages
 *              Moved from APPERR.H 8/21/89  --jmh
 *
 */

#define APE_DelSuccess (APPERR2_BASE + 350 ) /* @I
        *
        *%1 was deleted successfully.
        */

#define APE_UseSuccess (APPERR2_BASE + 351 ) /* @I
         *
         *%1 was used successfully.
         */

#define APE_SendSuccess (APPERR2_BASE + 352 ) /* @I
         *
         *The message was successfully sent to %1.
         */

/*** NOTE ... see also APE_SendXxxSucess in APPERR.H  ***/

#define APE_ForwardSuccess (APPERR2_BASE + 353) /* @I
         *
         *The message name %1 was forwarded successfully.
         */

#define APE_NameSuccess (APPERR2_BASE + 354) /* @I
         *
         *The message name %1 was added successfully.
         */

#define APE_ForwardDelSuccess (APPERR2_BASE + 355) /* @I
         *
         *The message name forwarding was successfully canceled.
         */

#define APE_ShareSuccess (APPERR2_BASE + 356) /* @I
         *
         *%1 was shared successfully.
         */

#define APE_LogonSuccess (APPERR2_BASE + 357) /* @I
         *
         *The server %1 successfully logged you on as %2.
         */

#define APE_LogoffSuccess (APPERR2_BASE + 358) /* @I
         *
         *%1 was logged off successfully.
         */

#define APE_DelStickySuccess (APPERR2_BASE + 359 ) /* @I
        *
        *%1 was successfully removed from the list of shares the Server creates
        *on startup.
        */

#define APE_PassSuccess (APPERR2_BASE + 361) /* @I
         *
         *The password was changed successfully.
         */

#define APE_FilesCopied  (APPERR2_BASE + 362) /* @I
         *
         *%1 file(s) copied.
         */

#define APE_FilesMoved  (APPERR2_BASE + 363) /* @I
         *
         *%1 file(s) moved.
         */

#define APE_SendAllSuccess (APPERR2_BASE + 364 ) /* @I
         *
         *The message was successfully sent to all users of the network.
         */

#define APE_SendDomainSuccess (APPERR2_BASE + 365 ) /* @I
         *
         *The message was successfully sent to domain %1.
         */

#define APE_SendUsersSuccess (APPERR2_BASE + 366 ) /* @I
         *
         *The message was successfully sent to all users of this server.
         */

#define APE_SendGroupSuccess (APPERR2_BASE + 367 ) /* @I
         *
         *The message was successfully sent to group *%1.
         */

#define APE2_VER_Release                (APPERR2_BASE + 395)     /* @I
                *
                *Microsoft LAN Manager Version %1
                */

#define APE2_VER_ProductOS2Server       (APPERR2_BASE + 396)     /* @I
                *
                *Windows NT Server
                */

#define APE2_VER_ProductOS2Workstation  (APPERR2_BASE + 397)     /* @I
                *
                *Windows NT Workstation
                */

#define APE2_VER_ProductDOSWorkstation  (APPERR2_BASE + 398)     /* @I
                *
                *MS-DOS Enhanced Workstation
                */

#define APE2_VER_BuildTime              (APPERR2_BASE + 399)     /* @I
                *
                *Created at %1
                */

#define APE2_VIEW_ALL_HDR                (APPERR2_BASE + 400)    /* @I
                *
                *Server Name            Remark
                */

#define APE2_VIEW_UNC            (APPERR2_BASE + 402)    /* @I
                *
                *(UNC)%0
                */

#define APE2_VIEW_MORE           (APPERR2_BASE + 403)    /* @I
                *
                *...%0
                */

#define APE2_VIEW_DOMAIN_HDR             (APPERR2_BASE + 404)    /* @I
                *
                *Domain
                */

#define APE2_VIEW_OTHER_HDR             (APPERR2_BASE + 405)    /* @I
                *
                *Resources on %1
                */

#define APE2_VIEW_OTHER_LIST             (APPERR2_BASE + 406)    /* @I
                *
                *Invalid network provider.  Available networks are:
                */


#define APE2_USE_TYPE_DISK               (APPERR2_BASE + 410)    /* @I
                *
                *Disk%0
                */

#define APE2_USE_TYPE_PRINT              (APPERR2_BASE + 411)    /* @I
                *
                *Print%0
                */

#define APE2_USE_TYPE_COMM               (APPERR2_BASE + 412)    /* @I
                *
                *Comm%0
                */

#define APE2_USE_TYPE_IPC                (APPERR2_BASE + 413)    /* @I
                *
                *IPC%0
                */

#define APE2_USE_HEADER                 (APPERR2_BASE + 414)     /* @I
                *
                *Status       Local     Remote                    Network
                */

#define APE2_USE_STATUS_OK                              (APPERR2_BASE + 415)     /* @I
                *
                *OK%0
                */

#define APE2_USE_STATUS_DORMANT                 (APPERR2_BASE + 416)    /* @I
                *
                *Dormant%0
                */

#define APE2_USE_STATUS_PAUSED                  (APPERR2_BASE + 417)    /* @I
                *
                *Paused%0
                */

#define APE2_USE_STATUS_SESSION_LOST    (APPERR2_BASE + 418)    /* @I
                *
                *Disconnected%0
                */

#define APE2_USE_STATUS_NET_ERROR               (APPERR2_BASE + 419)    /* @I
                *
                *Error%0
                */

#define APE2_USE_STATUS_CONNECTING              (APPERR2_BASE + 420)    /* @I
                *
                *Connecting%0
                */

#define APE2_USE_STATUS_RECONNECTING    (APPERR2_BASE + 421)    /* @I
                *
                *Reconnecting%0
                */

#define APE2_USE_MSG_STATUS                     (APPERR2_BASE + 422)    /* @I
                *
                *Status%0
                */

#define APE2_USE_MSG_LOCAL                              (APPERR2_BASE + 423)    /* @I
                *
                *Local name%0
                */

#define APE2_USE_MSG_REMOTE                     (APPERR2_BASE + 424)    /* @I
                *
                *Remote name%0
                */

#define APE2_USE_MSG_TYPE                               (APPERR2_BASE + 425)    /* @I
                *
                *Resource type%0
                */

#define APE2_USE_MSG_OPEN_COUNT                 (APPERR2_BASE + 426)    /* @I
                *
                *# Opens%0
                */

#define APE2_USE_MSG_USE_COUNT                  (APPERR2_BASE + 427)    /* @I
                *
                *# Connections%0
                */

#define APE2_USE_STATUS_UNAVAIL                 (APPERR2_BASE + 428)    /* @I
                *
                *Unavailable%0
                */


#define APE2_SHARE_MSG_HDR                              (APPERR2_BASE + 430)    /* @I
                *
                *Share name   Resource                        Remark
                */

#define APE2_SHARE_MSG_NAME                     (APPERR2_BASE + 431)    /* @I
                *
                *Share name%0
                */

#define APE2_SHARE_MSG_DEVICE                   (APPERR2_BASE + 432)    /* @I
                *
                *Resource%0
                */

#define APE2_SHARE_MSG_SPOOLED                  (APPERR2_BASE + 433)    /* @I
                *
                *Spooled%0
                */

#define APE2_SHARE_MSG_PERM                     (APPERR2_BASE + 434)    /* @I
                *
                *Permission%0
                */

#define APE2_SHARE_MSG_MAX_USERS                (APPERR2_BASE + 435)    /* @I
                *
                *Maximum users%0
                */

#define APE2_SHARE_MSG_ULIMIT                   (APPERR2_BASE + 436)    /* @I
                *
                *No limit%0
                */

#define APE2_SHARE_MSG_USERS                    (APPERR2_BASE + 437)    /* @I
                *
                *Users%0
                */

#define APE2_SHARE_MSG_NONFAT                   (APPERR2_BASE + 438)    /* @P
         *
         *The share name entered may not be accessible from some MS-DOS workstations.
         *Are you sure you want to use this share name? %1: %0
         */

#define APE2_SHARE_MSG_CACHING                  (APPERR2_BASE + 439)    /* @I
                *
                *Caching%0
                */

#define APE2_FILE_MSG_HDR                               (APPERR2_BASE + 440)            /* @I
                *
                *ID         Path                                    User name            # Locks
                */

#define APE2_FILE_MSG_ID                                (APPERR2_BASE + 441)            /* @I
                *
                *File ID%0
                */

#define APE2_FILE_MSG_NUM_LOCKS                 (APPERR2_BASE + 442)            /* @I
                *
                *Locks%0
                */

#define APE2_FILE_MSG_OPENED_FOR                (APPERR2_BASE + 443)            /* @I
                *
                *Permissions%0
                */

#define APE2_VIEW_SVR_HDR_NAME                (APPERR2_BASE + 444)    /* @I
                *
                *Share name%0
                                */

#define APE2_VIEW_SVR_HDR_TYPE                (APPERR2_BASE + 445)    /* @I
                *
                *Type%0
                */

#define APE2_VIEW_SVR_HDR_USEDAS                (APPERR2_BASE + 446)    /* @I
                *
                *Used as%0
                */

#define APE2_VIEW_SVR_HDR_CACHEORREMARK                (APPERR2_BASE + 447)    /* @I
                *
                *Comment%0
                */


#define APE2_SESS_MSG_HDR                       (APPERR2_BASE + 450)            /* @I
                *
                *Computer               User name            Client Type       Opens Idle time
                */

#define APE2_SESS_MSG_CMPTR                     (APPERR2_BASE + 451)            /* @I
                *
                *Computer%0
                */

#define APE2_SESS_MSG_SESSTIME                  (APPERR2_BASE + 452)            /* @I
                *
                *Sess time%0
                */

#define APE2_SESS_MSG_IDLETIME                  (APPERR2_BASE + 453)            /* @I
                *
                *Idle time%0
                */

#define APE2_SESS_MSG_HDR2                      (APPERR2_BASE + 454)            /* @I
                *
                *Share name     Type     # Opens
                */

#define APE2_SESS_MSG_CLIENTTYPE                (APPERR2_BASE + 455)            /* @I
                *
                *Client type%0
                */

#define APE2_SESS_MSG_GUEST                     (APPERR2_BASE + 456)            /* @I
                *
                *Guest logon%0
                */

/*
 *
 * CLIENT SIDE CACHING Messages
 *
 */


#define APE2_GEN_CACHED_MANUAL                  (APPERR2_BASE + 470)     /* @I
         *
         * Manual caching of documents%0
         */

#define APE2_GEN_CACHED_AUTO                    (APPERR2_BASE + 471)     /* @I
         *
         * Automatic caching of documents%0
         */

#define APE2_GEN_CACHED_VDO                     (APPERR2_BASE + 472)     /* @I
         *
         * Automatic caching of programs and documents%0
         */

#define APE2_GEN_CACHED_DISABLED                (APPERR2_BASE + 473)     /* @I
         *
         * Caching disabled%0
         */

#define APE2_GEN_CACHE_AUTOMATIC                (APPERR2_BASE + 474)     /* @I
         *
         * Automatic%0
         */

#define APE2_GEN_CACHE_MANUAL                   (APPERR2_BASE + 475)     /* @I
         *
         * Manual%0
         */

#define APE2_GEN_CACHE_DOCUMENTS                (APPERR2_BASE + 476)     /* @I
         *
         * Documents%0
         */

#define APE2_GEN_CACHE_PROGRAMS                 (APPERR2_BASE + 477)     /* @I
         *
         * Programs%0
         */

#define APE2_GEN_CACHE_NONE                     (APPERR2_BASE + 478)     /* @I
         *
         * None%0
         */


#define APE2_NAME_MSG_NAME                              (APPERR2_BASE + 500)            /* @I
                *
                *Name%0
                */

#define APE2_NAME_MSG_FWD                               (APPERR2_BASE + 501)            /* @I
                *
                *Forwarded to%0
                */

#define APE2_NAME_MSG_FWD_FROM                  (APPERR2_BASE + 502)            /* @I
                *
                *Forwarded to you from%0
                */

#define APE2_SEND_MSG_USERS                     (APPERR2_BASE + 503)            /* @I
                *
                *Users of this server%0
                */

#define APE2_SEND_MSG_INTERRUPT                 (APPERR2_BASE + 504)            /* @I
                *
                *Net Send has been interrupted by a Ctrl+Break from the user.
                */

#define APE2_PRINT_MSG_HDR                              (APPERR2_BASE + 510)            /* @I
                *
                *Name                         Job #      Size            Status
                */

#define APE2_PRINT_MSG_JOBS                     (APPERR2_BASE + 511)            /* @I
                *
                *jobs%0
                */

#define APE2_PRINT_MSG_PRINT                    (APPERR2_BASE + 512)            /* @I
                *
                *Print%0
                */

#define APE2_PRINT_MSG_NAME                     (APPERR2_BASE + 513)            /* @I
                *
                *Name%0
                */

#define APE2_PRINT_MSG_JOB                              (APPERR2_BASE + 514)            /* @I
                *
                *Job #%0
                */

#define APE2_PRINT_MSG_SIZE                     (APPERR2_BASE + 515)            /* @I
                *
                *Size%0
                */

#define APE2_PRINT_MSG_STATUS                   (APPERR2_BASE + 516)            /* @I
                *
                *Status%0
                */

#define APE2_PRINT_MSG_SEPARATOR                (APPERR2_BASE + 517)            /* @I
                *
                *Separator file%0
                */

#define APE2_PRINT_MSG_COMMENT                  (APPERR2_BASE + 518)            /* @I
                *
                *Comment%0
                */

#define APE2_PRINT_MSG_PRIORITY                 (APPERR2_BASE + 519)            /* @I
                *
                *Priority%0
                */

#define APE2_PRINT_MSG_AFTER                    (APPERR2_BASE + 520)            /* @I
                *
                *Print after%0
                */

#define APE2_PRINT_MSG_UNTIL                    (APPERR2_BASE + 521)            /* @I
                *
                *Print until%0
                */

#define APE2_PRINT_MSG_PROCESSOR                (APPERR2_BASE + 522)            /* @I
                *
                *Print processor%0
                */

#define APE2_PRINT_MSG_ADDITIONAL_INFO  (APPERR2_BASE + 523)            /* @I
                *
                *Additional info%0
                */

#define APE2_PRINT_MSG_PARMS                    (APPERR2_BASE + 524)            /* @I
                *
                *Parameters%0
                */

#define APE2_PRINT_MSG_DEVS                     (APPERR2_BASE + 525)            /* @I
                *
                *Print Devices%0
                */


#define APE2_PRINT_MSG_QUEUE_ACTIVE     (APPERR2_BASE + 526)            /* @I
                *
                *Printer Active%0
                */

#define APE2_PRINT_MSG_QUEUE_PAUSED     (APPERR2_BASE + 527)            /* @I
                *
                *Printer held%0
                */

#define APE2_PRINT_MSG_QUEUE_ERROR              (APPERR2_BASE + 528)            /* @I
                *
                *Printer error%0
                */

#define APE2_PRINT_MSG_QUEUE_PENDING    (APPERR2_BASE + 529)            /* @I
                *
                *Printer being deleted%0
                */

#define APE2_PRINT_MSG_QUEUE_UNKN               (APPERR2_BASE + 530)            /* @I
                *
                *Printer status unknown%0
                */

#define APE2_PRINT_MSG_QUEUE_UNSCHED    (APPERR2_BASE + 540)            /* @I
                *
                *Held until %1%0
                */


#define APE2_PRINT_MSG_JOB_ID                   (APPERR2_BASE + 541)            /* @I
                *
                *Job #%0
                */

#define APE2_PRINT_MSG_SUBMITTING_USER  (APPERR2_BASE + 542)            /* @I
                *
                *Submitting user%0
                */

#define APE2_PRINT_MSG_NOTIFY                   (APPERR2_BASE + 543)            /* @I
                *
                *Notify%0
                */

#define APE2_PRINT_MSG_JOB_DATA_TYPE    (APPERR2_BASE + 544)            /* @I
                *
                *Job data type%0
                */

#define APE2_PRINT_MSG_JOB_PARAMETERS   (APPERR2_BASE + 545)            /* @I
                *
                *Job parameters%0
                */

#define APE2_PRINT_MSG_WAITING                  (APPERR2_BASE + 546)            /* @I
                *
                *Waiting%0
                */

#define APE2_PRINT_MSG_PAUSED_IN_QUEUE  (APPERR2_BASE + 547)            /* @I
                *
                *Held in queue%0
                */

#define APE2_PRINT_MSG_SPOOLING                 (APPERR2_BASE + 548)            /* @I
                *
                *Spooling%0
                */

#define APE2_PRINT_MSG_PRINTER_PAUSED   (APPERR2_BASE + 549)            /* @I
                *
                *Paused%0
                */

#define APE2_PRINT_MSG_PRINTER_OFFLINE  (APPERR2_BASE + 550)            /* @I
                *
                *Offline%0
                */

#define APE2_PRINT_MSG_PRINTER_ERROR    (APPERR2_BASE + 551)            /* @I
                *
                *Error%0
                */

#define APE2_PRINT_MSG_OUT_OF_PAPER             (APPERR2_BASE + 552)            /* @I
                *
                *Out of paper%0
                */

#define APE2_PRINT_MSG_PRINTER_INTERV   (APPERR2_BASE + 553)            /* @I
                *
                *Intervention required%0
                */

#define APE2_PRINT_MSG_PRINTING                 (APPERR2_BASE + 554)            /* @I
                *
                *Printing%0
                */

#define APE2_PRINT_MSG_ON_WHAT_PRINTER  (APPERR2_BASE + 555)            /* @I
                *
                * on %0
                */

#define APE2_PRINT_MSG_PRINTER_PAUS_ON  (APPERR2_BASE + 556)            /* @I
                *
                *Paused on %1%0
                */

#define APE2_PRINT_MSG_PRINTER_OFFL_ON  (APPERR2_BASE + 557)            /* @I
                *
                *Offline on %1%0
                */

#define APE2_PRINT_MSG_PRINTER_ERR_ON   (APPERR2_BASE + 558)            /* @I
                *
                *Error on%1%0
                */

#define APE2_PRINT_MSG_OUT_OF_PAPER_ON          (APPERR2_BASE + 559)            /* @I
                *
                *Out of Paper on %1%0
                */

#define APE2_PRINT_MSG_PRINTER_INTV_ON  (APPERR2_BASE + 560)            /* @I
                *
                *Check printer on %1%0
                */

#define APE2_PRINT_MSG_PRINTING_ON              (APPERR2_BASE + 561)            /* @I
                *
                *Printing on %1%0
                */

#define APE2_PRINT_MSG_DRIVER                   (APPERR2_BASE + 562)            /* @I
                *
                *Driver%0
                */

/*
 *
 *
 *      Pinball starts at BASE + 600 and will reserve through 650 for safety
 *
 *      non used in NT.
 */

/*
 *
 * AUDITING and ERROR log messages
 *
 */

#define APE2_AUDIT_HEADER               (APPERR2_BASE + 630)    /* @I
                 *
                 *User name              Type                 Date%0
                 */
#define APE2_AUDIT_LOCKOUT              (APPERR2_BASE + 631)    /* @I
                 *
                 *Lockout%0
                 */
#define APE2_AUDIT_GENERIC              (APPERR2_BASE + 632)    /* @I
                 *
                 *Service%0
                 */
#define APE2_AUDIT_SERVER               (APPERR2_BASE + 633)    /* @I
                 *
                 *Server%0
                 */
#define APE2_AUDIT_SRV_STARTED          (APPERR2_BASE + 634)    /* @I
                 *
                 *Server started%0
                 */
#define APE2_AUDIT_SRV_PAUSED           (APPERR2_BASE + 635)    /* @I
                 *
                 *Server paused%0
                 */
#define APE2_AUDIT_SRV_CONTINUED        (APPERR2_BASE + 636)    /* @I
                 *
                 *Server continued%0
                 */
#define APE2_AUDIT_SRV_STOPPED          (APPERR2_BASE + 637)    /* @I
                 *
                 *Server stopped%0
                 */
#define APE2_AUDIT_SESS                 (APPERR2_BASE + 638)    /* @I
                 *
                 *Session%0
                 */
#define APE2_AUDIT_SESS_GUEST           (APPERR2_BASE + 639)    /* @I
                 *
                 *Logon Guest%0
                 */
#define APE2_AUDIT_SESS_USER            (APPERR2_BASE + 640)    /* @I
                 *
                 *Logon User%0
                 */
#define APE2_AUDIT_SESS_ADMIN           (APPERR2_BASE + 641)    /* @I
                 *
                 *Logon Administrator%0
                 */
#define APE2_AUDIT_SESS_NORMAL          (APPERR2_BASE + 642)    /* @I
                 *
                 *Logoff normal%0
                 */
#define APE2_AUDIT_SESS_DEFAULT         (APPERR2_BASE + 643)    /* @I
                 *
                 *Logon%0
                 */
#define APE2_AUDIT_SESS_ERROR           (APPERR2_BASE + 644)    /* @I
                 *
                 *Logoff error%0
                 */
#define APE2_AUDIT_SESS_AUTODIS         (APPERR2_BASE + 645)    /* @I
                 *
                 *Logoff auto-disconnect%0
                 */
#define APE2_AUDIT_SESS_ADMINDIS        (APPERR2_BASE + 646)    /* @I
                 *
                 *Logoff administrator-disconnect%0
                 */
#define APE2_AUDIT_SESS_ACCRESTRICT     (APPERR2_BASE + 647)    /* @I
                 *
                 *Logoff forced by logon restrictions%0
                 */
#define APE2_AUDIT_SVC                  (APPERR2_BASE + 648)    /* @I
                 *
                 *Service%0
                 */
#define APE2_AUDIT_SVC_INSTALLED        (APPERR2_BASE + 649)    /* @I
                 *
                 *%1 Installed%0
                 */
#define APE2_AUDIT_SVC_INST_PEND        (APPERR2_BASE + 650)    /* @I
                 *
                 *%1 Install Pending%0
                 */
#define APE2_AUDIT_SVC_PAUSED           (APPERR2_BASE + 651)    /* @I
                 *
                 *%1 Paused%0
                 */
#define APE2_AUDIT_SVC_PAUS_PEND        (APPERR2_BASE + 652)    /* @I
                 *
                 *%1 Pause Pending%0
                 */
#define APE2_AUDIT_SVC_CONT             (APPERR2_BASE + 653)    /* @I
                 *
                 *%1 Continued%0
                 */
#define APE2_AUDIT_SVC_CONT_PEND        (APPERR2_BASE + 654)    /* @I
                 *
                 *%1 Continue Pending%0
                 */
#define APE2_AUDIT_SVC_STOP             (APPERR2_BASE + 655)    /* @I
                 *
                 *%1 Stopped%0
                 */
#define APE2_AUDIT_SVC_STOP_PEND        (APPERR2_BASE + 656)    /* @I
                 *
                 *%1 Stop Pending%0
                 */
#define APE2_AUDIT_ACCOUNT              (APPERR2_BASE + 657)    /* @I
                 *
                 *Account%0
                 */
#define APE2_AUDIT_ACCOUNT_USER_MOD     (APPERR2_BASE + 658)    /* @I
                 *
                 *User account %1 was modified.%0
                 */
#define APE2_AUDIT_ACCOUNT_GROUP_MOD    (APPERR2_BASE + 659)    /* @I
                 *
                 *Group account %1 was modified.%0
                 */
#define APE2_AUDIT_ACCOUNT_USER_DEL     (APPERR2_BASE + 660)    /* @I
                 *
                 *User account %1 was deleted%0
                 */
#define APE2_AUDIT_ACCOUNT_GROUP_DEL    (APPERR2_BASE + 661)    /* @I
                 *
                 *Group account %1 was deleted%0
                 */
#define APE2_AUDIT_ACCOUNT_USER_ADD     (APPERR2_BASE + 662)    /* @I
                 *
                 *User account %1 was added%0
                 */
#define APE2_AUDIT_ACCOUNT_GROUP_ADD    (APPERR2_BASE + 663)    /* @I
                 *
                 *Group account %1 was added%0
                 */
#define APE2_AUDIT_ACCOUNT_SETTINGS     (APPERR2_BASE + 664)    /* @I
                 *
                 *Account system settings were modified%0
                 */
#define APE2_AUDIT_ACCLIMIT             (APPERR2_BASE + 665)    /* @I
                 *
                 *Logon restriction%0
                 */
#define APE2_AUDIT_ACCLIMIT_UNKNOWN     (APPERR2_BASE + 666)    /* @I
                 *
                 *Limit exceeded:  UNKNOWN%0
                 */
#define APE2_AUDIT_ACCLIMIT_HOURS       (APPERR2_BASE + 667)    /* @I
                 *
                 *Limit exceeded:  Logon hours%0
                 */
#define APE2_AUDIT_ACCLIMIT_EXPIRED     (APPERR2_BASE + 668)    /* @I
                 *
                 *Limit exceeded:  Account expired%0
                 */
#define APE2_AUDIT_ACCLIMIT_INVAL       (APPERR2_BASE + 669)    /* @I
                 *
                 *Limit exceeded:  Workstation ID invalid%0
                 */
#define APE2_AUDIT_ACCLIMIT_DISABLED    (APPERR2_BASE + 670)    /* @I
                 *
                 *Limit exceeded:  Account disabled%0
                 */
#define APE2_AUDIT_ACCLIMIT_DELETED     (APPERR2_BASE + 671)    /* @I
                 *
                 *Limit exceeded:  Account deleted%0
                 */
#define APE2_AUDIT_SHARE                (APPERR2_BASE + 672)    /* @I
                 *
                 *Share%0
                 */
#define APE2_AUDIT_USE                  (APPERR2_BASE + 673)    /* @I
                 *
                 *Use %1%0
                 */
#define APE2_AUDIT_UNUSE                (APPERR2_BASE + 674)    /* @I
                 *
                 *Unuse %1%0
                 */
#define APE2_AUDIT_SESSDIS              (APPERR2_BASE + 675)    /* @I
                 *
                 *User's session disconnected %1%0
                 */
#define APE2_AUDIT_SHARE_D              (APPERR2_BASE + 676)    /* @I
                 *
                 *Administrator stopped sharing resource %1%0
                 */
#define APE2_AUDIT_USERLIMIT            (APPERR2_BASE + 677)    /* @I
                 *
                 *User reached limit for %1%0
                 */
#define APE2_AUDIT_BADPW                (APPERR2_BASE + 678)    /* @I
                 *
                 *Bad password%0
                 */
#define APE2_AUDIT_ADMINREQD            (APPERR2_BASE + 679)    /* @I
                 *
                 *Administrator privilege required%0
                 */
#define APE2_AUDIT_ACCESS               (APPERR2_BASE + 680)    /* @I
                 *
                 *Access%0
                 */
#define APE2_AUDIT_ACCESS_ADD           (APPERR2_BASE + 681)    /* @I
                 *
                 *%1 permissions added%0
                 */
#define APE2_AUDIT_ACCESS_MOD           (APPERR2_BASE + 682)    /* @I
                 *
                 *%1 permissions modified%0
                 */
#define APE2_AUDIT_ACCESS_DEL           (APPERR2_BASE + 683)    /* @I
                 *
                 *%1 permissions deleted%0
                 */
#define APE2_AUDIT_ACCESS_D             (APPERR2_BASE + 684)    /* @I
                 *
                 *Access denied%0
                 */
#define APE2_AUDIT_UNKNOWN              (APPERR2_BASE + 685)    /* @I
                 *
                 *Unknown%0
                 */
#define APE2_AUDIT_OTHER                (APPERR2_BASE + 686)    /* @I
                 *
                 *Other%0
                 */
#define APE2_AUDIT_DURATION             (APPERR2_BASE + 687)    /* @I
                 *
                 *Duration:%0
                 */
#define APE2_AUDIT_NO_DURATION          (APPERR2_BASE + 688)    /* @I
                 *
                 *Duration: Not available%0
                 */
#define APE2_AUDIT_TINY_DURATION        (APPERR2_BASE + 689)    /* @I
                 *
                 *Duration: Less than one second%0
                 */
#define APE2_AUDIT_NONE                 (APPERR2_BASE + 690)    /* @I
                 *
                 *(none)%0
                 */
#define APE2_AUDIT_CLOSED               (APPERR2_BASE + 691)    /* @I
                 *
                 *Closed %1%0
                 */
#define APE2_AUDIT_DISCONN              (APPERR2_BASE + 692)    /* @I
                 *
                 *Closed %1 (disconnected)%0
                 */
#define APE2_AUDIT_ADMINCLOSED          (APPERR2_BASE + 693)    /* @I
                 *
                 *Administrator closed %1%0
                 */
#define APE2_AUDIT_ACCESSEND            (APPERR2_BASE + 694)    /* @I
                 *
                 *Access ended%0
                 */
#define APE2_AUDIT_NETLOGON             (APPERR2_BASE + 695)    /* @I
                 *
                 *Log on to network%0
                 */
#define APE2_AUDIT_LOGDENY_GEN          (APPERR2_BASE + 696)    /* @I
                 *
                 *Logon denied%0
                 */
#define APE2_ERROR_HEADER               (APPERR2_BASE + 697)    /* @I
                 *
                 *Program             Message             Time%0
                 */
#define APE2_AUDIT_LKOUT_LOCK           (APPERR2_BASE + 698)    /* @I
                 *
                 *Account locked due to %1 bad passwords%0
                 */
#define APE2_AUDIT_LKOUT_ADMINUNLOCK    (APPERR2_BASE + 699)    /* @I
                 *
                 *Account unlocked by administrator%0
                 */
#define APE2_AUDIT_NETLOGOFF            (APPERR2_BASE + 700)    /* @I
                 *
                 *Log off network%0
                 */

/*
 *
 * ALERTER service messages.
 *
 *      Make sure TO, FROM, and all SUBJ messages align to the same
 *      column. Make sure, also, that APE2_ALERTER_TAB is aligned with
 *      TO, FROM, and SUBJ headers!!!!!!
 *
 */

#define APE2_ALERTER_TAB                (APPERR2_BASE + 709) /* @I
     *        */

#define APE2_ALERTER_ADMN_SUBJ          (APPERR2_BASE + 710) /* @I
     *
     *Subj:   ** ADMINISTRATOR ALERT **
     */

#define APE2_ALERTER_PRNT_SUBJ          (APPERR2_BASE + 711) /* @I
     *
     *Subj:   ** PRINTING NOTIFICATION **
     */

#define APE2_ALERTER_USER_SUBJ          (APPERR2_BASE + 712) /* @I
     *
     *Subj:   ** USER NOTIFICATION **
     */

#define APE2_ALERTER_FROM               (APPERR2_BASE + 713) /* @I
     *
     *From:   %1 at \\%2
     */


#define APE2_ALERTER_CANCELLED          (APPERR2_BASE + 714) /* @I
     *
     *Print job %1 has been canceled while printing on %2.
     */

#define APE2_ALERTER_DELETED            (APPERR2_BASE + 715) /* @I
     *
     *Print job %1 has been deleted and will not print.
     */

#define APE2_ALERTER_FINISHED           (APPERR2_BASE + 716) /* @I
     *
     *Printing Complete
     *
     *%1 printed successfully on %2.
     */

#define APE2_ALERTER_INCOMPL            (APPERR2_BASE + 717) /* @I
     *
     *Print job %1 has not completed printing on %2.
     */

#define APE2_ALERTER_PAUSED             (APPERR2_BASE + 718) /* @I
     *
     *Print job %1 has paused printing on %2.
     */

#define APE2_ALERTER_PRINTING           (APPERR2_BASE + 719) /* @I
     *
     *Print job %1 is now printing on %2.
     */

#define APE2_ALERTER_NOPAPER            (APPERR2_BASE + 720) /* @I
     *
     *The printer is out of paper.
     */

#define APE2_ALERTER_OFFLINE            (APPERR2_BASE + 721) /* @I
     *
     *The printer is offline.
     */

#define APE2_ALERTER_ERRORS             (APPERR2_BASE + 722) /* @I
     *
     *Printing errors occurred.
     */

#define APE2_ALERTER_HUMAN              (APPERR2_BASE + 723) /* @I
     *
     *There is a problem with the printer; please check it.
     */

#define APE2_ALERTER_HELD               (APPERR2_BASE + 724) /* @I
     *
     *Print job %1 is being held from printing.
     */

#define APE2_ALERTER_QUEUED             (APPERR2_BASE + 725) /* @I
     *
     *Print job %1 is queued for printing.
     */

#define APE2_ALERTER_SPOOLED            (APPERR2_BASE + 726) /* @I
     *
     *Print job %1 is being spooled.
     */

#define APE2_ALERTER_QUEUEDTO           (APPERR2_BASE + 727) /* @I
     *
     *Job was queued to %1 on %2
     */

#define APE2_ALERTER_SIZE               (APPERR2_BASE + 728) /* @I
     *
     *Size of job is %1 bytes.
     */

#define APE2_ALERTER_TO                 (APPERR2_BASE + 730) /* @I
     *
     *To:     %1
     */

#define APE2_ALERTER_DATE               (APPERR2_BASE + 731) /* @I
     *
     *Date:   %1
     */

#define APE2_ALERTER_ERROR_MSG          (APPERR2_BASE + 732) /* @I
     *
     * The error code is %1.
     * There was an error retrieving the message. Make sure the file
     * NET.MSG is available.
     */

#define APE2_ALERTER_PRINTING_FAILURE   (APPERR2_BASE + 733) /* @I
     *
     * Printing Failed
     *
     * "%1" failed to print on %2 on %3.
     *
     * For more help use the print troubleshooter.
     */

#define APE2_ALERTER_PRINTING_FAILURE2  (APPERR2_BASE + 734) /* @I
     *
     * Printing Failed
     *
     * "%1" failed to print on %2 on %3.  The Printer is %4.
     *
     * For more help use the print troubleshooter.
     */

#define APE2_ALERTER_PRINTING_SUCCESS   (APPERR2_BASE + 735) /* @I
     *
     * Printing Complete
     *
     * "%1" printed successfully on %2 on %3.
     */



/*
 * TIME related stuff go here
 */

#define APE2_TIME_JANUARY                       (APPERR2_BASE + 741)    /* @I
                        *
                        *January%0
                        */

#define APE2_TIME_FEBRUARY                      (APPERR2_BASE + 742)    /* @I
                        *
                        *February%0
                        */

#define APE2_TIME_MARCH                         (APPERR2_BASE + 743)    /* @I
                        *
                        *March%0
                        */

#define APE2_TIME_APRIL                         (APPERR2_BASE + 744)    /* @I
                        *
                        *April%0
                        */

#define APE2_TIME_MAY                           (APPERR2_BASE + 745)    /* @I
                        *
                        *May%0
                        */

#define APE2_TIME_JUNE                          (APPERR2_BASE + 746)    /* @I
                        *
                        *June%0
                        */

#define APE2_TIME_JULY                          (APPERR2_BASE + 747)    /* @I
                        *
                        *July%0
                        */

#define APE2_TIME_AUGUST                        (APPERR2_BASE + 748)    /* @I
                        *
                        *August%0
                        */

#define APE2_TIME_SEPTEMBER                     (APPERR2_BASE + 749)    /* @I
                        *
                        *September%0
                        */

#define APE2_TIME_OCTOBER                       (APPERR2_BASE + 750)    /* @I
                        *
                        *October%0
                        */

#define APE2_TIME_NOVEMBER                      (APPERR2_BASE + 751)    /* @I
                        *
                        *November%0
                        */

#define APE2_TIME_DECEMBER                      (APPERR2_BASE + 752)    /* @I
                        *
                        *December%0
                        */

#define APE2_TIME_JANUARY_ABBREV                (APPERR2_BASE + 753)    /* @I
                        *
                        *Jan%0
                        */

#define APE2_TIME_FEBRUARY_ABBREV               (APPERR2_BASE + 754)    /* @I
                        *
                        *Feb%0
                        */

#define APE2_TIME_MARCH_ABBREV                  (APPERR2_BASE + 755)    /* @I
                        *
                        *Mar%0
                        */

#define APE2_TIME_APRIL_ABBREV                  (APPERR2_BASE + 756)    /* @I
                        *
                        *Apr%0
                        */

#define APE2_TIME_MAY_ABBREV                    (APPERR2_BASE + 757)    /* @I
                        *
                        *May%0
                        */

#define APE2_TIME_JUNE_ABBREV                   (APPERR2_BASE + 758)    /* @I
                        *
                        *Jun%0
                        */

#define APE2_TIME_JULY_ABBREV                   (APPERR2_BASE + 759)    /* @I
                        *
                        *Jul%0
                        */

#define APE2_TIME_AUGUST_ABBREV                 (APPERR2_BASE + 760)    /* @I
                        *
                        *Aug%0
                        */

#define APE2_TIME_SEPTEMBER_ABBREV              (APPERR2_BASE + 761)    /* @I
                        *
                        *Sep%0
                        */

#define APE2_TIME_OCTOBER_ABBREV                (APPERR2_BASE + 762)    /* @I
                        *
                        *Oct%0
                        */

#define APE2_TIME_NOVEMBER_ABBREV               (APPERR2_BASE + 763)    /* @I
                        *
                        *Nov%0
                        */

#define APE2_TIME_DECEMBER_ABBREV               (APPERR2_BASE + 764)    /* @I
                        *
                        *Dec%0
                        */

#define APE2_TIME_DAYS_ABBREV               (APPERR2_BASE + 765)    /* @I
                        *
                        *D%0
                        */

#define APE2_TIME_HOURS_ABBREV               (APPERR2_BASE + 766)    /* @I
                        *
                        *H%0
                        */

#define APE2_TIME_MINUTES_ABBREV               (APPERR2_BASE + 767)    /* @I
                        *
                        *M%0
                        */

#define APE2_TIME_SATURDAY_ABBREV2              (APPERR2_BASE + 768)    /* @I
                        *
                        *Sa%0
                        */

/*
 * Machine Roles
 */

#define APE2_PRIMARY                            (APPERR2_BASE + 770)    /* @I
                        *
                        *PRIMARY%0.
                        */
#define APE2_BACKUP                             (APPERR2_BASE + 771)    /* @I
                        *
                        *BACKUP%0.
                        */
#define APE2_WORKSTATION                        (APPERR2_BASE + 772)    /* @I
                        *
                        *WORKSTATION%0.
                        */
#define APE2_STANDARD_SERVER                    (APPERR2_BASE + 773)    /* @I
                        *
                        *SERVER%0.
                        */

/*
 * Countries
 */

#define APE2_CTRY_System_Default                (APPERR2_BASE + 780) /* @I
        *
        * System Default%0
        */

#define APE2_CTRY_United_States                 (APPERR2_BASE + 781) /* @I
        *
        * United States%0
        */

#define APE2_CTRY_Canada_French                 (APPERR2_BASE + 782) /* @I
        *
        * Canada (French)%0
        */

#define APE2_CTRY_Latin_America                 (APPERR2_BASE + 783) /* @I
        *
        * Latin America%0
        */

#define APE2_CTRY_Netherlands                   (APPERR2_BASE + 784) /* @I
        *
        * Netherlands%0
        */

#define APE2_CTRY_Belgium                       (APPERR2_BASE + 785) /* @I
        *
        * Belgium%0
        */

#define APE2_CTRY_France                        (APPERR2_BASE + 786) /* @I
        *
        * France%0
        */

#define APE2_CTRY_Italy                         (APPERR2_BASE + 787) /* @I
        *
        * Italy%0
        */

#define APE2_CTRY_Switzerland                   (APPERR2_BASE + 788) /* @I
        *
        * Switzerland%0
        */

#define APE2_CTRY_United_Kingdom                (APPERR2_BASE + 789) /* @I
        *
        * United Kingdom%0
        */

#define APE2_CTRY_Spain                         (APPERR2_BASE + 790) /* @I
        *
        * Spain%0
        */

#define APE2_CTRY_Denmark                       (APPERR2_BASE + 791) /* @I
        *
        * Denmark%0
        */

#define APE2_CTRY_Sweden                        (APPERR2_BASE + 792) /* @I
        *
        * Sweden%0
        */

#define APE2_CTRY_Norway                        (APPERR2_BASE + 793) /* @I
        *
        * Norway%0
        */

#define APE2_CTRY_Germany                       (APPERR2_BASE + 794) /* @I
        *
        * Germany%0
        */

#define APE2_CTRY_Australia                     (APPERR2_BASE + 795) /* @I
        *
        * Australia%0
        */

#define APE2_CTRY_Japan                         (APPERR2_BASE + 796) /* @I
        *
        * Japan%0
        */

#define APE2_CTRY_Korea                         (APPERR2_BASE + 797) /* @I
        *
        * Korea%0
        */

#define APE2_CTRY_China_PRC                     (APPERR2_BASE + 798) /* @I
        *
        * China (PRC)%0
        */

#define APE2_CTRY_Taiwan                        (APPERR2_BASE + 799) /* @I
        *
        * Taiwan%0
        */

#define APE2_CTRY_Asia                          (APPERR2_BASE + 800) /* @I
        *
        * Asia%0
        */

#define APE2_CTRY_Portugal                      (APPERR2_BASE + 801) /* @I
        *
        * Portugal%0
        */

#define APE2_CTRY_Finland                       (APPERR2_BASE + 802) /* @I
        *
        * Finland%0
        */

#define APE2_CTRY_Arabic                        (APPERR2_BASE + 803) /* @I
        *
        * Arabic%0
        */

#define APE2_CTRY_Hebrew                        (APPERR2_BASE + 804) /* @I
        *
        * Hebrew%0
        */


/*
 * UPS service messages
 */

#define APE2_UPS_POWER_OUT              (APPERR2_BASE + 850)
        /*
         * A power failure has occurred at %1.  Please terminate all activity with this server.
         */

#define APE2_UPS_POWER_BACK             (APPERR2_BASE + 851)
        /*
         * Power has been restored at %1.  Normal operations have resumed.
         */

#define APE2_UPS_POWER_SHUTDOWN         (APPERR2_BASE + 852)
        /*
         * The UPS service is starting shut down at %1.
         */

#define APE2_UPS_POWER_SHUTDOWN_FINAL   (APPERR2_BASE + 853)
        /*
         * The UPS service is about to perform final shut down.
         */


/*
 * Workstation service messages
 */

#define APE2_WKSTA_CMD_LINE_START               (APPERR2_BASE + 870)    /* @I
         *
         *The Workstation must be started with the NET START command.
         */


/*
 * Server service messages
 */

#define APE2_SERVER_IPC_SHARE_REMARK            (APPERR2_BASE + 875)    /* @I
         *
         *Remote IPC%0
         */

#define APE2_SERVER_ADMIN_SHARE_REMARK          (APPERR2_BASE + 876)    /* @I
         *
         *Remote Admin%0
         */

#define APE2_SERVER_DISK_ADMIN_SHARE_REMARK     (APPERR2_BASE + 877)    /* @I
         *
         *Default share%0
         */


/***
 *
 *      Y/N questions.
 */
#define APE_UserPasswordCompatWarning  (APPERR2_BASE + 980) /* @P
         *
         *The password entered is longer than 14 characters.  Computers
         *with Windows prior to Windows 2000 will not be able to use
         *this account. Do you want to continue this operation? %1: %0
         */

#define APE_OverwriteRemembered (APPERR2_BASE + 981) /* @P
         *
         *%1 has a remembered connection to %2. Do you
         *want to overwrite the remembered connection? %3: %0
         */

#define APE_LoadResume (APPERR2_BASE + 982) /* @P
         *
         *Do you want to resume loading the profile?  The command which
         *caused the error will be ignored. %1: %0
         */

#define APE_OkToProceed  (APPERR2_BASE + 984) /* @P
         *
         *Do you want to continue this operation? %1: %0
         */

#define APE_AddAnyway  (APPERR2_BASE + 985) /* @P
         *
         *Do you want to add this? %1: %0
         */

#define APE_ProceedWOp  (APPERR2_BASE + 986) /* @P
         *
         *Do you want to continue this operation? %1: %0
         */

#define APE_StartOkToStart (APPERR2_BASE + 987) /* @P
         *
         *Is it OK to start it? %1: %0
         */

#define APE_StartRedir (APPERR2_BASE + 988) /* @P
         *
         *Do you want to start the Workstation service? %1: %0
         */

#define APE_UseBlowAway  (APPERR2_BASE + 989) /* @P
         *
         *Is it OK to continue disconnecting and force them closed? %1: %0
         */

#define APE_CreatQ  (APPERR2_BASE + 990) /* @P
         *
         *The printer does not exist.  Do you want to create it? %1: %0
         */
/***
 *
 *   #ifdef JAPAN
 *
 *   Japanese version specific messages
 *
 */

#define APE2_NEVER_FORCE_LOGOFF    (APPERR2_BASE + 991) /* @I
        *
        *Never%0
        */

#define APE2_NEVER_EXPIRED    (APPERR2_BASE + 992) /* @I
        *
        *Never%0
        */

#define APE2_NEVER_LOGON    (APPERR2_BASE + 993) /* @I
        *
        *Never%0
        */

#define APE2_

/***
 *
 *   #endif // JAPAN
 *
 */

/***
 *
 * Help file name for NETCMD
 *
 */
#define APE2_US_NETCMD_HELP_FILE    (APPERR2_BASE + 995) /* @I
        *
        *NET.HLP%0
        */

#define APE2_FE_NETCMD_HELP_FILE    (APPERR2_BASE + 996) /* @I
        *
        *NET.HLP%0
        */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\public\internal\ds\inc\brcommon.h ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    brcommon.h

Abstract:

    Header for utility routines for the browser service.

Author:

    Larry Osterman (LarryO) 23-Mar-1992

Environment:

    User Mode - Win32

Revision History:

--*/

#ifndef _BRCOMMON_
#define _BRCOMMON_

#include <winsvc.h>
#include <svcs.h>       //  PSVCS_NET_BIOS_RESET

#if DEVL
//
//  Codes for I_BrowserDebugCall
//

#define BROWSER_DEBUG_BREAK_POINT        0
#define BROWSER_DEBUG_DUMP_NETWORKS      1
#define BROWSER_DEBUG_DUMP_SERVERS       2
#define BROWSER_DEBUG_ENABLE_BROWSER     3
#define BROWSER_DEBUG_SET_DEBUG          4
#define BROWSER_DEBUG_CLEAR_DEBUG        5
#define BROWSER_DEBUG_TICKLE             6
#define BROWSER_DEBUG_ELECT              7
#define BROWSER_DEBUG_GET_MASTER         8
#define BROWSER_DEBUG_FIND_MASTER        9
#define BROWSER_DEBUG_GET_BACKUP_LIST   10
#define BROWSER_DEBUG_ANNOUNCE_MASTER   11
#define BROWSER_DEBUG_ILLEGAL_DGRAM     12
#define BROWSER_DEBUG_GET_OTHLIST       13
#define BROWSER_DEBUG_ADD_MASTERNAME    14
#define BROWSER_DEBUG_VIEW              15
#define BROWSER_DEBUG_FORCE_ANNOUNCE    16
#define BROWSER_DEBUG_LOCAL_BRLIST      17
#define BROWSER_DEBUG_ANNOUNCE          18
#define BROWSER_DEBUG_RPCLIST           19
#define BROWSER_DEBUG_RPCCMP            20
#define BROWSER_DEBUG_TRUNCATE_LOG      21
#define BROWSER_DEBUG_STATISTICS        22
#define BROWSER_DEBUG_BOWSERDEBUG       23
#define BROWSER_DEBUG_POPULATE_SERVER   24
#define BROWSER_DEBUG_POPULATE_DOMAIN   25
#define BROWSER_DEBUG_LIST_WFW          26
#define BROWSER_DEBUG_STATUS            27
#define BROWSER_DEBUG_GETPDC            28
#define BROWSER_DEBUG_ADD_DOMAINNAME    29
#define BROWSER_DEBUG_GET_WINSSERVER    30
#define BROWSER_DEBUG_GET_DOMAINLIST    31
#define BROWSER_DEBUG_GET_NETBIOSNAMES  32
#define BROWSER_DEBUG_SET_EMULATEDDOMAIN 33
#define BROWSER_DEBUG_SET_EMULATEDDOMAINENUM 34
#define BROWSER_DEBUG_ADD_ALTERNATE     35
#define BROWSER_DEBUG_BIND_TRANSPORT    36
#define BROWSER_DEBUG_UNBIND_TRANSPORT  37
#define BROWSER_DEBUG_RENAME_DOMAIN     38

//
// Debug trace level bits for turning on/off trace statements in the
// browser service
//

#define BR_CRITICAL     0x00000001
#define BR_INIT         0x00000002
#define BR_UTIL         0x00000020
#define BR_CONFIG       0x00000040
#define BR_MAIN         0x00000080
#define BR_BACKUP       0x00000400
#define BR_MASTER       0x00000800
#define BR_DOMAIN       0x00001000
#define BR_NETWORK      0x00002000
#define BR_COMMON       0x0000FFFF

#define BR_TIMER        0x00010000
#define BR_QUEUE        0x00020000
#define BR_LOCKS        0x00040000
#define BR_SERVER_ENUM  0x00100000

#define BR_ALL          0xFFFFFFFF

NET_API_STATUS
I_BrowserDebugCall (
    IN  LPWSTR      servername OPTIONAL,
    IN  DWORD DebugCode,
    IN  DWORD OptionalValue
    );

#endif

typedef struct _INTERIM_ELEMENT {
    LIST_ENTRY NextElement;
    ULONG   Periodicity;
    ULONG   TimeLastSeen;
    ULONG   PlatformId;
    ULONG   MajorVersionNumber;
    ULONG   MinorVersionNumber;
    ULONG   Type;
    WCHAR   Name[CNLEN+1];
    WCHAR   Comment[LM20_MAXCOMMENTSZ+1];
} INTERIM_ELEMENT, *PINTERIM_ELEMENT;

struct _INTERIM_SERVER_LIST;

typedef
VOID
(*PINTERIM_NEW_CALLBACK)(
    IN struct _INTERIM_SERVER_LIST *InterimList,
    IN PINTERIM_ELEMENT Element
    );

typedef
VOID
(*PINTERIM_EXISTING_CALLBACK)(
    IN struct _INTERIM_SERVER_LIST *InterimList,
    IN PINTERIM_ELEMENT Element
    );


typedef
VOID
(*PINTERIM_DELETE_CALLBACK)(
    IN struct _INTERIM_SERVER_LIST *InterimList,
    IN PINTERIM_ELEMENT Element
    );

typedef
BOOLEAN
(*PINTERIM_AGE_CALLBACK)(
    IN struct _INTERIM_SERVER_LIST *InterimList,
    IN PINTERIM_ELEMENT Element
    );


typedef struct _INTERIM_SERVER_LIST {
//    RTL_GENERIC_TABLE ServerTable;
    LIST_ENTRY ServerList;
    ULONG TotalBytesNeeded;
    ULONG TotalEntries;
    ULONG EntriesRead;
    PINTERIM_NEW_CALLBACK NewElementCallback;
    PINTERIM_EXISTING_CALLBACK ExistingElementCallback;
    PINTERIM_DELETE_CALLBACK DeleteElementCallback;
    PINTERIM_AGE_CALLBACK AgeElementCallback;
} INTERIM_SERVER_LIST, *PINTERIM_SERVER_LIST;


NET_API_STATUS
DeviceControlGetInfo(
    IN  HANDLE FileHandle,
    IN  ULONG DeviceControlCode,
    IN  PVOID RequestPacket,
    IN  ULONG RequestPacketLength,
    OUT LPVOID *OutputBuffer,
    IN  ULONG PreferedMaximumLength,
    IN  ULONG BufferHintSize,
    OUT PULONG Information OPTIONAL
    );

NET_API_STATUS
BrDgReceiverIoControl(
    IN  HANDLE FileHandle,
    IN  ULONG DgReceiverControlCode,
    IN  PLMDR_REQUEST_PACKET Drp,
    IN  ULONG DrpSize,
    IN  PVOID SecondBuffer OPTIONAL,
    IN  ULONG SecondBufferLength,
    OUT PULONG Information OPTIONAL
    );

NET_API_STATUS
OpenBrowser(
    OUT PHANDLE BrowserHandle
    );

NET_API_STATUS
GetBrowserServerList(
    IN PUNICODE_STRING TransportName,
    IN LPCWSTR domain,
    OUT LPWSTR *BrowserList[],
    OUT PULONG BrowserListLength,
    IN BOOLEAN ForceRescan
    );

NET_API_STATUS
InitializeInterimServerList(
    IN PINTERIM_SERVER_LIST InterimServerList,
    IN PINTERIM_NEW_CALLBACK NewCallback,
    IN PINTERIM_EXISTING_CALLBACK ExistingCallback,
    IN PINTERIM_DELETE_CALLBACK DeleteElementCallback,
    IN PINTERIM_AGE_CALLBACK AgeElementCallback
    );

NET_API_STATUS
CopyInterimServerList(
    IN PINTERIM_SERVER_LIST NewInterimServerList,
    IN PINTERIM_SERVER_LIST OldInterimServerList
    );



NET_API_STATUS
UninitializeInterimServerList(
    IN PINTERIM_SERVER_LIST InterimServerList
    );


NET_API_STATUS
InsertElementInterimServerList (
    IN PINTERIM_SERVER_LIST InterimServerList,
    IN PINTERIM_ELEMENT InterimElement,
    IN ULONG Level,
    IN PBOOLEAN NewElement OPTIONAL,
    IN PINTERIM_ELEMENT *ActualElement OPTIONAL
    );

ULONG
NumberInterimServerListElements(
    IN PINTERIM_SERVER_LIST InterimServerList
    );

NET_API_STATUS
AgeInterimServerList(
    IN PINTERIM_SERVER_LIST InterimServerList
    );


NET_API_STATUS
MergeServerList(
    IN PINTERIM_SERVER_LIST InterimServerList,
    IN ULONG level,
    IN PVOID NewServerList,
    IN ULONG NewEntriesRead,
    IN ULONG NewTotalEntries
    );

PINTERIM_ELEMENT
LookupInterimServerList(
    IN PINTERIM_SERVER_LIST InterimServerList,
    IN LPWSTR ServerNameToLookUp
    );



NET_API_STATUS
PackServerList(
    IN PINTERIM_SERVER_LIST InterimServerList,
    IN ULONG Level,
    IN ULONG ServerType,
    IN ULONG PreferedDataLength,
    OUT PVOID *bufptr,
    OUT PULONG entriesread,
    OUT PULONG totalentries,
    IN LPCWSTR FirstNameToReturn
    );

VOID
PrepareServerListForMerge(
    IN PVOID ServerInfoList,
    IN ULONG Level,
    IN ULONG EntriesInList
    );

NET_API_STATUS
CheckForService(
    IN LPWSTR ServiceName,
    OUT LPSERVICE_STATUS ServiceStatus OPTIONAL
    );


NET_API_STATUS
BrGetLanaNumFromNetworkName(
    IN LPWSTR TransportName,
    OUT CCHAR *LanaNum
    );

NET_API_STATUS
GetNetBiosMasterName(
    IN LPWSTR NetworkName,
    IN LPWSTR PrimaryDomain,
    OUT LPWSTR MasterName,
    IN  PSVCS_NET_BIOS_RESET SvcsNetBiosReset OPTIONAL
    );

NET_API_STATUS
SendDatagram(
    IN HANDLE DgReceiverHandle,
    IN PUNICODE_STRING Network,
    IN PUNICODE_STRING EmulatedDomainName,
    IN PWSTR ResponseName,
    IN DGRECEIVER_NAME_TYPE NameType,
    IN PVOID Buffer,
    IN ULONG BufferLength
    );

#ifdef ENABLE_PSEUDO_BROWSER
BOOL
IsEnumServerEnabled(
    VOID
    );

DWORD
GetBrowserPseudoServerLevel(
    VOID
    );
#endif

#endif  // _BRCOMMON_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\public\internal\ds\inc\authzi.h ===
/*++

Copyright (c) 2000 Microsoft Corporation

Module Name:

    authzi.h

Abstract:

    This module contains the authorization framework APIs for internal callers.

Author:

    Kedar Dubhashi - October 2000

Revision History:

    Created - October 2000

--*/

#ifndef __AUTHZI_H__
#define __AUTHZI_H__

#include <authz.h>

#ifdef __cplusplus
extern "C" {
#endif

DECLARE_HANDLE(AUTHZ_AUDIT_QUEUE_HANDLE);

typedef AUTHZ_AUDIT_QUEUE_HANDLE *PAUTHZ_AUDIT_QUEUE_HANDLE;



//
// For AuthziInitializeAuditEventType
//

#define AUTHZP_INIT_GENERIC_AUDIT_EVENT 0x1

AUTHZAPI
BOOL
WINAPI
AuthziInitializeAuditEventType(
    IN  DWORD                          Flags,
    IN  USHORT                         CategoryID,
    IN  USHORT                         AuditID,
    IN  USHORT                         ParameterCount,
    OUT PAUTHZ_AUDIT_EVENT_TYPE_HANDLE phAuditEventType
    );

//
// Flags for AuthziModifyAuditEventType
//

#define AUTHZ_AUDIT_EVENT_TYPE_AUDITID 0x1
#define AUTHZ_AUDIT_EVENT_TYPE_CATEGID 0x2 // not implemented
#define AUTHZ_AUDIT_EVENT_TYPE_PARAM   0x4 // not implemented

AUTHZAPI
BOOL
WINAPI
AuthziModifyAuditEventType(
    IN DWORD Flags,
    IN USHORT CategoryID,
    IN USHORT AuditID,
    IN USHORT ParameterCount,
    IN OUT AUTHZ_AUDIT_EVENT_TYPE_HANDLE hAuditEventType
    );
    
AUTHZAPI
BOOL
WINAPI
AuthziFreeAuditEventType(
    AUTHZ_AUDIT_EVENT_TYPE_HANDLE hAuditEventType
    );

#define AUTHZ_MONITOR_AUDIT_QUEUE_SIZE 0x00000001

AUTHZAPI
BOOL
WINAPI
AuthziInitializeAuditQueue(
    IN DWORD                      Flags,
    IN DWORD                      dwAuditQueueHigh,
    IN DWORD                      dwAuditQueueLow,
    IN PVOID                      Reserved,
    OUT PAUTHZ_AUDIT_QUEUE_HANDLE phAuditQueue
    );
            
#define AUTHZ_AUDIT_QUEUE_HIGH            0x00000001
#define AUTHZ_AUDIT_QUEUE_LOW             0x00000002
#define AUTHZ_AUDIT_QUEUE_THREAD_PRIORITY 0x00000004
#define AUTHZ_AUDIT_QUEUE_FLAGS           0x00000008
#define AUTHZP_MONITOR_AUDIT_QUEUE_SIZE   0x00000010

AUTHZAPI
BOOL
WINAPI
AuthziModifyAuditQueue(
    IN OUT AUTHZ_AUDIT_QUEUE_HANDLE pQueue OPTIONAL,
    IN DWORD Flags,
    IN DWORD dwQueueFlags OPTIONAL,
    IN DWORD dwAuditQueueSizeHigh OPTIONAL,
    IN DWORD dwAuditQueueSizeLow OPTIONAL,
    IN DWORD dwThreadPriority OPTIONAL
    );

AUTHZAPI
BOOL
WINAPI
AuthziFreeAuditQueue(
    IN AUTHZ_AUDIT_QUEUE_HANDLE hQueue OPTIONAL
    );

AUTHZAPI
BOOL
WINAPI
AuthziLogAuditEvent(
    IN DWORD Flags,
    IN AUTHZ_AUDIT_EVENT_HANDLE hEvent,
    IN PVOID pReserved
    );

AUTHZAPI
BOOL
WINAPI
AuthziAllocateAuditParams(
    OUT PAUDIT_PARAMS * ppParams,
    IN USHORT NumParams
    );
    
AUTHZAPI
BOOL
WINAPI
AuthziInitializeAuditParamsWithRM(
    IN DWORD Flags,
    IN AUTHZ_RESOURCE_MANAGER_HANDLE hResourceManager,
    IN USHORT NumParams,
    OUT PAUDIT_PARAMS pParams,
    ...
    );

AUTHZAPI
BOOL
WINAPI
AuthziInitializeAuditParamsFromArray(
    IN DWORD Flags,
    IN AUTHZ_RESOURCE_MANAGER_HANDLE hResourceManager,
    IN USHORT NumParams,
    IN PAUDIT_PARAM pParamArray,
    OUT PAUDIT_PARAMS pParams
    );
    
AUTHZAPI
BOOL
WINAPI
AuthziInitializeAuditParams(
    IN  DWORD         dwFlags,
    OUT PAUDIT_PARAMS pParams,
    OUT PSID*         ppUserSid,
    IN  PCWSTR        SubsystemName,
    IN  USHORT        NumParams,
    ...
    );

AUTHZAPI
BOOL
WINAPI
AuthziFreeAuditParams(
    PAUDIT_PARAMS pParams
    );
    
#define AUTHZ_DS_CATEGORY_FLAG                   0x00000008

AUTHZAPI
BOOL
WINAPI
AuthziInitializeAuditEvent(
    IN  DWORD                         Flags,
    IN  AUTHZ_RESOURCE_MANAGER_HANDLE hRM,
    IN  AUTHZ_AUDIT_EVENT_TYPE_HANDLE hAuditEventType  OPTIONAL,
    IN  PAUDIT_PARAMS                 pAuditParams     OPTIONAL,
    IN  AUTHZ_AUDIT_QUEUE_HANDLE      hAuditQueue      OPTIONAL,
    IN  DWORD                         dwTimeOut,
    IN  PWSTR                         szOperationType,
    IN  PWSTR                         szObjectType,
    IN  PWSTR                         szObjectName,
    IN  PWSTR                         szAdditionalInfo OPTIONAL,
    OUT PAUTHZ_AUDIT_EVENT_HANDLE     phAuditEvent
    );

//                      
// Valid flags for AuthzModifyAuditEvent 
//
        
#define AUTHZ_AUDIT_EVENT_FLAGS            0x00000001
#define AUTHZ_AUDIT_EVENT_OPERATION_TYPE   0x00000002
#define AUTHZ_AUDIT_EVENT_OBJECT_TYPE      0x00000004
#define AUTHZ_AUDIT_EVENT_OBJECT_NAME      0x00000008
#define AUTHZ_AUDIT_EVENT_ADDITIONAL_INFO  0x00000010
        
#define AUTHZ_VALID_MODIFY_AUDIT_EVENT_FLAGS  (AUTHZ_AUDIT_EVENT_FLAGS           | \
                                               AUTHZ_AUDIT_EVENT_OPERATION_TYPE  | \
                                               AUTHZ_AUDIT_EVENT_OBJECT_TYPE     | \
                                               AUTHZ_AUDIT_EVENT_OBJECT_NAME     | \
                                               AUTHZ_AUDIT_EVENT_ADDITIONAL_INFO)
AUTHZAPI
BOOL
WINAPI
AuthziModifyAuditEvent(
    IN DWORD                    Flags,
    IN AUTHZ_AUDIT_EVENT_HANDLE hAuditEvent,
    IN DWORD                    NewFlags,
    IN PWSTR                    szOperationType,
    IN PWSTR                    szObjectType,
    IN PWSTR                    szObjectName,
    IN PWSTR                    szAdditionalInfo
    );

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\public\internal\ds\inc\crypstub.h ===
/*++

Copyright (C) 2000  Microsoft Corporation

Module Name:

    crypstub.h

Abstract:

    RPC Proxy Stub to handle downlevel requests to the services.exe 
    pipe

Author:

    petesk   3/1/00

Revisions:


--*/

extern "C" {
NTSTATUS
WINAPI
StartCryptServiceStubs( 
     PSVCS_START_RPC_SERVER RpcpStartRpcServer,
     LPTSTR SvcsRpcPipeName
    );

NTSTATUS
WINAPI
StopCryptServiceStubs( 
    PSVCS_STOP_RPC_SERVER RpcpStopRpcServer
    );
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\public\internal\ds\inc\credp.h ===
/*++ BUILD Version: 0001    // Increment this if a change has global effects

Copyright (c) 2000 Microsoft Corporation

Module Name:

    credp.h

Abstract:

    This module contains the private data structures and API definitions
    needed for the Credential Manager.


Author:

    Cliff Van Dyke (CliffV) 28-February-2000

Revision History:

--*/

#ifndef _CREDP_H_
#define _CREDP_H_

#if !defined(_ADVAPI32_)
#define WINADVAPI DECLSPEC_IMPORT
#else
#define WINADVAPI
#endif

#include <lmcons.h>

#ifdef __cplusplus
extern "C" {
#endif

//
// Describe direction of character conversion
//
typedef enum _WTOA_ENUM {
    DoWtoA = 1,     // Convert unicode to ansi
    DoAtoW,         // Convert ansi to unicode
    DoWtoW          // Convert unicode to unicode
} WTOA_ENUM, *PWTOA_ENUM;

//
// Describe whether encoding or decoding should be done
//
typedef enum _ENCODE_BLOB_ENUM {
    DoBlobEncode = 0,   // Encode CredentialBlob
    DoBlobDecode,       // Decode CredentialBlob
    DoBlobNeither       // Leave Credential blob intact
} ENCODE_BLOB_ENUM, *PENCODE_BLOB_ENUM;




//
// Define the valid target name types
//

typedef enum _TARGET_NAME_TYPE {
    IsUsernameTarget,
    IsNotUsernameTarget,
    MightBeUsernameTarget
} TARGET_NAME_TYPE, *PTARGET_NAME_TYPE;

//
// enum describing different types of wildcarding in the TargetName field of a credential.
//

typedef enum _WILDCARD_TYPE {
    WcDfsShareName,         // Target name of the form <DfsRoot>\<DfsShare>
    WcServerName,           // Target name of the form <ServerName>
    WcServerWildcard,       // Wildcard of the form *.<DnsName>
    WcDomainWildcard,       // Wildcard of the form <Domain>\*
    WcUniversalSessionWildcard,   // Wildcard of the form "*Session"
    WcUniversalWildcard,    // Wildcard of the form *
    WcUserName              // Target Name equals UserName
} WILDCARD_TYPE, *PWILDCARD_TYPE;

//
// When passing a credential around, the CredentialBlob field is encrypted.
// This structure describes this encrypted form.
//
//
#ifndef _ENCRYPTED_CREDENTIAL_DEFINED
#define _ENCRYPTED_CREDENTIAL_DEFINED

typedef struct _ENCRYPTED_CREDENTIALW {

    //
    // The credential
    //
    // The CredentialBlob field points to the encrypted credential
    // The CredentialBlobSize field is the length (in bytes) of the encrypted credential
    //

    CREDENTIALW Cred;

    //
    // The size in bytes of the clear text credential blob
    //

    ULONG ClearCredentialBlobSize;

} ENCRYPTED_CREDENTIALW, *PENCRYPTED_CREDENTIALW;
#endif // _ENCRYPTED_CREDENTIAL_DEFINED


//
// Macro to determine the size of the credential blob buffer to allocate
//
// Round up for RTL_ENCRYPT_MEMORY_SIZE
//

#define AllocatedCredBlobSize( _Size ) \
                ROUND_UP_COUNT( (_Size), RTL_ENCRYPT_MEMORY_SIZE )

//
// Procedures
//

WINADVAPI
DWORD
WINAPI
CredpConvertTargetInfo (
    IN WTOA_ENUM WtoA,
    IN PCREDENTIAL_TARGET_INFORMATIONW InTargetInfo,
    OUT PCREDENTIAL_TARGET_INFORMATIONW *OutTargetInfo,
    OUT PULONG OutTargetInfoSize
    );

WINADVAPI
DWORD
WINAPI
CredpConvertCredential (
    IN WTOA_ENUM WtoA,
    IN ENCODE_BLOB_ENUM DoDecode,
    IN PCREDENTIALW InCredential,
    OUT PCREDENTIALW *OutCredential
    );

WINADVAPI
BOOL
WINAPI
CredpEncodeCredential (
    IN OUT PENCRYPTED_CREDENTIALW Credential
    );

WINADVAPI
BOOL
WINAPI
CredpDecodeCredential (
    IN OUT PENCRYPTED_CREDENTIALW Credential
    );


WINADVAPI
BOOL
WINAPI
CredProfileLoaded (
    VOID
    );


NTSTATUS
NET_API_FUNCTION
CredpValidateTargetName(
    IN OUT LPWSTR TargetName,
    IN ULONG Type,
    IN TARGET_NAME_TYPE TargetNameType,
    IN LPWSTR *UserNamePointer OPTIONAL,
    IN LPDWORD PersistPointer OPTIONAL,
    OUT PULONG TargetNameSize,
    OUT PWILDCARD_TYPE WildcardTypePointer OPTIONAL,
    OUT PUNICODE_STRING NonWildcardedTargetName OPTIONAL
    );


#ifdef __cplusplus
}
#endif

#endif // _CREDP_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\public\internal\ds\inc\crypt.h ===
/*++ BUILD Version: 0001    // Increment this if a change has global effects

Copyright (c) 1989  Microsoft Corporation

Module Name:

    crypt.h

Abstract:

    This module contains the public data structures and API definitions
    needed to utilize the encryption library


Author:

    David Chalmers (Davidc) 21-October-1991

Revision History:

    Scott Field (SField)    09-October-2000
        Add RNG and Memory encryption interfaces

--*/


#ifndef _NTCRYPT_
#define _NTCRYPT_

#ifndef MIDL_PASS    // Don't confuse MIDL

#ifndef RPC_NO_WINDOWS_H // Don't let rpc.h include windows.h
#define RPC_NO_WINDOWS_H
#endif // RPC_NO_WINDOWS_H

#include <rpc.h>
#endif // MIDL_PASS

#ifdef __cplusplus
extern "C" {
#endif

/////////////////////////////////////////////////////////////////////////
//                                                                     //
// Core encryption types                                               //
//                                                                     //
/////////////////////////////////////////////////////////////////////////

// begin_ntsubauth

#define CLEAR_BLOCK_LENGTH          8

typedef struct _CLEAR_BLOCK {
    CHAR    data[CLEAR_BLOCK_LENGTH];
}                                   CLEAR_BLOCK;
typedef CLEAR_BLOCK *               PCLEAR_BLOCK;

#define CYPHER_BLOCK_LENGTH         8

typedef struct _CYPHER_BLOCK {
    CHAR    data[CYPHER_BLOCK_LENGTH];
}                                   CYPHER_BLOCK;
typedef CYPHER_BLOCK *              PCYPHER_BLOCK;
// end_ntsubauth

#define BLOCK_KEY_LENGTH            7

typedef struct _BLOCK_KEY {
    CHAR    data[BLOCK_KEY_LENGTH];
}                                   BLOCK_KEY;
typedef BLOCK_KEY *                 PBLOCK_KEY;




/////////////////////////////////////////////////////////////////////////
//                                                                     //
// Arbitrary length data encryption types                              //
//                                                                     //
/////////////////////////////////////////////////////////////////////////

typedef struct _CRYPT_BUFFER {
    ULONG   Length;         // Number of valid bytes in buffer
    ULONG   MaximumLength;  // Number of bytes pointed to by Buffer
    PVOID   Buffer;
} CRYPT_BUFFER;
typedef CRYPT_BUFFER *  PCRYPT_BUFFER;

typedef CRYPT_BUFFER    CLEAR_DATA;
typedef CLEAR_DATA *    PCLEAR_DATA;

typedef CRYPT_BUFFER    DATA_KEY;
typedef DATA_KEY *      PDATA_KEY;

typedef CRYPT_BUFFER    CYPHER_DATA;
typedef CYPHER_DATA *   PCYPHER_DATA;



/////////////////////////////////////////////////////////////////////////
//                                                                     //
// Lan Manager data types                                              //
//                                                                     //
/////////////////////////////////////////////////////////////////////////


//
// Define a LanManager compatible password
//
// A LanManager password is a null-terminated ansi string consisting of a
// maximum of 14 characters (not including terminator)
//

typedef CHAR *                      PLM_PASSWORD;



//
// Define the result of the 'One Way Function' (OWF) on a LM password
//

#define LM_OWF_PASSWORD_LENGTH      (CYPHER_BLOCK_LENGTH * 2)

// begin_ntsubauth
typedef struct _LM_OWF_PASSWORD {
    CYPHER_BLOCK data[2];
}                                   LM_OWF_PASSWORD;
typedef LM_OWF_PASSWORD *           PLM_OWF_PASSWORD;
// end_ntsubauth



//
// Define the challenge sent by the Lanman server during logon
//

#define LM_CHALLENGE_LENGTH         CLEAR_BLOCK_LENGTH

// begin_ntsubauth
typedef CLEAR_BLOCK                 LM_CHALLENGE;
typedef LM_CHALLENGE *              PLM_CHALLENGE;
// end_ntsubauth



//
// Define the response sent by redirector in response to challenge from server
//

#define LM_RESPONSE_LENGTH          (CYPHER_BLOCK_LENGTH * 3)

typedef struct _LM_RESPONSE {
    CYPHER_BLOCK  data[3];
}                                   LM_RESPONSE;
typedef LM_RESPONSE *               PLM_RESPONSE;



//
// Define the result of the reversible encryption of an OWF'ed password.
//

#define ENCRYPTED_LM_OWF_PASSWORD_LENGTH (CYPHER_BLOCK_LENGTH * 2)

typedef struct _ENCRYPTED_LM_OWF_PASSWORD {
    CYPHER_BLOCK data[2];
}                                   ENCRYPTED_LM_OWF_PASSWORD;
typedef ENCRYPTED_LM_OWF_PASSWORD * PENCRYPTED_LM_OWF_PASSWORD;



//
// Define the session key maintained by the redirector and server
//

#define LM_SESSION_KEY_LENGTH       LM_CHALLENGE_LENGTH

typedef LM_CHALLENGE                LM_SESSION_KEY;
typedef LM_SESSION_KEY *            PLM_SESSION_KEY;



//
// Define the index type used to encrypt OWF Passwords
//

typedef LONG                        CRYPT_INDEX;
typedef CRYPT_INDEX *               PCRYPT_INDEX;



/////////////////////////////////////////////////////////////////////////
//                                                                     //
// 'NT' encryption types that are used to duplicate existing LM        //
//      functionality with improved algorithms.                        //
//                                                                     //
/////////////////////////////////////////////////////////////////////////


typedef UNICODE_STRING              NT_PASSWORD;
typedef NT_PASSWORD *               PNT_PASSWORD;


#define NT_OWF_PASSWORD_LENGTH      LM_OWF_PASSWORD_LENGTH

// begin_ntsubauth
typedef LM_OWF_PASSWORD             NT_OWF_PASSWORD;
typedef NT_OWF_PASSWORD *           PNT_OWF_PASSWORD;
// end_ntsubauth


#define NT_CHALLENGE_LENGTH         LM_CHALLENGE_LENGTH

// begin_ntsubauth
typedef LM_CHALLENGE                NT_CHALLENGE;
typedef NT_CHALLENGE *              PNT_CHALLENGE;
// end_ntsubauth


#define NT_RESPONSE_LENGTH          LM_RESPONSE_LENGTH

typedef LM_RESPONSE                 NT_RESPONSE;
typedef NT_RESPONSE *               PNT_RESPONSE;


#define ENCRYPTED_NT_OWF_PASSWORD_LENGTH ENCRYPTED_LM_OWF_PASSWORD_LENGTH

typedef ENCRYPTED_LM_OWF_PASSWORD   ENCRYPTED_NT_OWF_PASSWORD;
typedef ENCRYPTED_NT_OWF_PASSWORD * PENCRYPTED_NT_OWF_PASSWORD;


#define NT_SESSION_KEY_LENGTH       LM_SESSION_KEY_LENGTH

typedef LM_SESSION_KEY              NT_SESSION_KEY;
typedef NT_SESSION_KEY *            PNT_SESSION_KEY;



/////////////////////////////////////////////////////////////////////////
//                                                                     //
// 'NT' encryption types for new functionality not present in LM       //
//                                                                     //
/////////////////////////////////////////////////////////////////////////


//
// The user session key is similar to the LM and NT session key except it
// is different for each user on the system. This allows it to be used
// for secure user communication with a server.
//
// begin_ntsubauth
#define USER_SESSION_KEY_LENGTH     (CYPHER_BLOCK_LENGTH * 2)

typedef struct _USER_SESSION_KEY {
    CYPHER_BLOCK data[2];
}                                   USER_SESSION_KEY;
typedef USER_SESSION_KEY          * PUSER_SESSION_KEY;
// end_ntsubauth


////////////////////////////////////////////////////////////////////////////
//                                                                        //
// Encryption library API macros                                          //
//                                                                        //
// To conceal the purpose of these functions to someone dumping out the   //
// encryption dll they have been purposefully given unhelpful names.      //
// Each has an associated macro that should be used by system components  //
// to access these routines in a readable way.                            //
//                                                                        //
////////////////////////////////////////////////////////////////////////////

#define RtlEncryptBlock                 SystemFunction001
#define RtlDecryptBlock                 SystemFunction002
#define RtlEncryptStdBlock              SystemFunction003
#define RtlEncryptData                  SystemFunction004
#define RtlDecryptData                  SystemFunction005
#define RtlCalculateLmOwfPassword       SystemFunction006
#define RtlCalculateNtOwfPassword       SystemFunction007
#define RtlCalculateLmResponse          SystemFunction008
#define RtlCalculateNtResponse          SystemFunction009
#define RtlCalculateUserSessionKeyLm    SystemFunction010
#define RtlCalculateUserSessionKeyNt    SystemFunction011
#define RtlEncryptLmOwfPwdWithLmOwfPwd  SystemFunction012
#define RtlDecryptLmOwfPwdWithLmOwfPwd  SystemFunction013
#define RtlEncryptNtOwfPwdWithNtOwfPwd  SystemFunction014
#define RtlDecryptNtOwfPwdWithNtOwfPwd  SystemFunction015
#define RtlEncryptLmOwfPwdWithLmSesKey  SystemFunction016
#define RtlDecryptLmOwfPwdWithLmSesKey  SystemFunction017
#define RtlEncryptNtOwfPwdWithNtSesKey  SystemFunction018
#define RtlDecryptNtOwfPwdWithNtSesKey  SystemFunction019
#define RtlEncryptLmOwfPwdWithUserKey   SystemFunction020
#define RtlDecryptLmOwfPwdWithUserKey   SystemFunction021
#define RtlEncryptNtOwfPwdWithUserKey   SystemFunction022
#define RtlDecryptNtOwfPwdWithUserKey   SystemFunction023
#define RtlEncryptLmOwfPwdWithIndex     SystemFunction024
#define RtlDecryptLmOwfPwdWithIndex     SystemFunction025
#define RtlEncryptNtOwfPwdWithIndex     SystemFunction026
#define RtlDecryptNtOwfPwdWithIndex     SystemFunction027
#define RtlGetUserSessionKeyClient      SystemFunction028
#define RtlGetUserSessionKeyServer      SystemFunction029
#define RtlEqualLmOwfPassword           SystemFunction030
#define RtlEqualNtOwfPassword           SystemFunction031
#define RtlEncryptData2                 SystemFunction032
#define RtlDecryptData2                 SystemFunction033
#define RtlGetUserSessionKeyClientBinding SystemFunction034
#define RtlCheckSignatureInFile         SystemFunction035

#define RtlGenRandom                    SystemFunction036
#define RtlEncryptMemory                SystemFunction040
#define RtlDecryptMemory                SystemFunction041


////////////////////////////////////////////////////////////////////////////
//                                                                        //
// Encryption library API function prototypes                             //
//                                                                        //
////////////////////////////////////////////////////////////////////////////


//
// Core block encryption functions
//

NTSTATUS
RtlEncryptBlock(
    IN PCLEAR_BLOCK ClearBlock,
    IN PBLOCK_KEY BlockKey,
    OUT PCYPHER_BLOCK CypherBlock
    );

NTSTATUS
RtlDecryptBlock(
    IN PCYPHER_BLOCK CypherBlock,
    IN PBLOCK_KEY BlockKey,
    OUT PCLEAR_BLOCK ClearBlock
    );

NTSTATUS
RtlEncryptStdBlock(
    IN PBLOCK_KEY BlockKey,
    OUT PCYPHER_BLOCK CypherBlock
    );

//
// Arbitrary length data encryption functions
//

NTSTATUS
RtlEncryptData(
    IN PCLEAR_DATA ClearData,
    IN PDATA_KEY DataKey,
    OUT PCYPHER_DATA CypherData
    );

NTSTATUS
RtlDecryptData(
    IN PCYPHER_DATA CypherData,
    IN PDATA_KEY DataKey,
    OUT PCLEAR_DATA ClearData
    );

//
// Faster arbitrary length data encryption functions (using RC4)
//

NTSTATUS
RtlEncryptData2(
    IN OUT PCRYPT_BUFFER    pData,
    IN PDATA_KEY            pKey
    );

NTSTATUS
RtlDecryptData2(
    IN OUT PCRYPT_BUFFER    pData,
    IN PDATA_KEY            pKey
    );

//
// Password hashing functions (One Way Function)
//

NTSTATUS
RtlCalculateLmOwfPassword(
    IN PLM_PASSWORD LmPassword,
    OUT PLM_OWF_PASSWORD LmOwfPassword
    );

NTSTATUS
RtlCalculateNtOwfPassword(
    IN PNT_PASSWORD NtPassword,
    OUT PNT_OWF_PASSWORD NtOwfPassword
    );



//
// OWF password comparison functions
//

BOOLEAN
RtlEqualLmOwfPassword(
    IN PLM_OWF_PASSWORD LmOwfPassword1,
    IN PLM_OWF_PASSWORD LmOwfPassword2
    );

BOOLEAN
RtlEqualNtOwfPassword(
    IN PNT_OWF_PASSWORD NtOwfPassword1,
    IN PNT_OWF_PASSWORD NtOwfPassword2
    );



//
// Functions for calculating response to server challenge
//

NTSTATUS
RtlCalculateLmResponse(
    IN PLM_CHALLENGE LmChallenge,
    IN PLM_OWF_PASSWORD LmOwfPassword,
    OUT PLM_RESPONSE LmResponse
    );


NTSTATUS
RtlCalculateNtResponse(
    IN PNT_CHALLENGE NtChallenge,
    IN PNT_OWF_PASSWORD NtOwfPassword,
    OUT PNT_RESPONSE NtResponse
    );




//
// Functions for calculating User Session Key.
//

//
// Calculate a User Session Key from LM data
//
NTSTATUS
RtlCalculateUserSessionKeyLm(
    IN PLM_RESPONSE LmResponse,
    IN PLM_OWF_PASSWORD LmOwfPassword,
    OUT PUSER_SESSION_KEY UserSessionKey
    );

//
// Calculate a User Session Key from NT data
//
NTSTATUS
RtlCalculateUserSessionKeyNt(
    IN PNT_RESPONSE NtResponse,
    IN PNT_OWF_PASSWORD NtOwfPassword,
    OUT PUSER_SESSION_KEY UserSessionKey
    );





//
// OwfPassword encryption functions
//


//
// Encrypt OwfPassword using OwfPassword as the key
//
NTSTATUS
RtlEncryptLmOwfPwdWithLmOwfPwd(
    IN PLM_OWF_PASSWORD DataLmOwfPassword,
    IN PLM_OWF_PASSWORD KeyLmOwfPassword,
    OUT PENCRYPTED_LM_OWF_PASSWORD EncryptedLmOwfPassword
    );

NTSTATUS
RtlDecryptLmOwfPwdWithLmOwfPwd(
    IN PENCRYPTED_LM_OWF_PASSWORD EncryptedLmOwfPassword,
    IN PLM_OWF_PASSWORD KeyLmOwfPassword,
    OUT PLM_OWF_PASSWORD DataLmOwfPassword
    );


NTSTATUS
RtlEncryptNtOwfPwdWithNtOwfPwd(
    IN PNT_OWF_PASSWORD DataNtOwfPassword,
    IN PNT_OWF_PASSWORD KeyNtOwfPassword,
    OUT PENCRYPTED_NT_OWF_PASSWORD EncryptedNtOwfPassword
    );

NTSTATUS
RtlDecryptNtOwfPwdWithNtOwfPwd(
    IN PENCRYPTED_NT_OWF_PASSWORD EncryptedNtOwfPassword,
    IN PNT_OWF_PASSWORD KeyNtOwfPassword,
    OUT PNT_OWF_PASSWORD DataNtOwfPassword
    );


//
// Encrypt OwfPassword using SessionKey as the key
//
NTSTATUS
RtlEncryptLmOwfPwdWithLmSesKey(
    IN PLM_OWF_PASSWORD LmOwfPassword,
    IN PLM_SESSION_KEY LmSessionKey,
    OUT PENCRYPTED_LM_OWF_PASSWORD EncryptedLmOwfPassword
    );

NTSTATUS
RtlDecryptLmOwfPwdWithLmSesKey(
    IN PENCRYPTED_LM_OWF_PASSWORD EncryptedLmOwfPassword,
    IN PLM_SESSION_KEY LmSessionKey,
    OUT PLM_OWF_PASSWORD LmOwfPassword
    );


NTSTATUS
RtlEncryptNtOwfPwdWithNtSesKey(
    IN PNT_OWF_PASSWORD NtOwfPassword,
    IN PNT_SESSION_KEY NtSessionKey,
    OUT PENCRYPTED_NT_OWF_PASSWORD EncryptedNtOwfPassword
    );

NTSTATUS
RtlDecryptNtOwfPwdWithNtSesKey(
    IN PENCRYPTED_NT_OWF_PASSWORD EncryptedNtOwfPassword,
    IN PNT_SESSION_KEY NtSessionKey,
    OUT PNT_OWF_PASSWORD NtOwfPassword
    );


//
// Encrypt OwfPassword using UserSessionKey as the key
//
NTSTATUS
RtlEncryptLmOwfPwdWithUserKey(
    IN PLM_OWF_PASSWORD LmOwfPassword,
    IN PUSER_SESSION_KEY UserSessionKey,
    OUT PENCRYPTED_LM_OWF_PASSWORD EncryptedLmOwfPassword
    );

NTSTATUS
RtlDecryptLmOwfPwdWithUserKey(
    IN PENCRYPTED_LM_OWF_PASSWORD EncryptedLmOwfPassword,
    IN PUSER_SESSION_KEY UserSessionKey,
    OUT PLM_OWF_PASSWORD LmOwfPassword
    );

NTSTATUS
RtlEncryptNtOwfPwdWithUserKey(
    IN PNT_OWF_PASSWORD NtOwfPassword,
    IN PUSER_SESSION_KEY UserSessionKey,
    OUT PENCRYPTED_NT_OWF_PASSWORD EncryptedNtOwfPassword
    );

NTSTATUS
RtlDecryptNtOwfPwdWithUserKey(
    IN PENCRYPTED_NT_OWF_PASSWORD EncryptedNtOwfPassword,
    IN PUSER_SESSION_KEY UserSessionKey,
    OUT PNT_OWF_PASSWORD NtOwfPassword
    );


//
// Encrypt OwfPassword using an index as the key
//
NTSTATUS
RtlEncryptLmOwfPwdWithIndex(
    IN PLM_OWF_PASSWORD LmOwfPassword,
    IN PCRYPT_INDEX Index,
    OUT PENCRYPTED_LM_OWF_PASSWORD EncryptedLmOwfPassword
    );

NTSTATUS
RtlDecryptLmOwfPwdWithIndex(
    IN PENCRYPTED_LM_OWF_PASSWORD EncryptedLmOwfPassword,
    IN PCRYPT_INDEX Index,
    OUT PLM_OWF_PASSWORD LmOwfPassword
    );


NTSTATUS
RtlEncryptNtOwfPwdWithIndex(
    IN PNT_OWF_PASSWORD NtOwfPassword,
    IN PCRYPT_INDEX Index,
    OUT PENCRYPTED_NT_OWF_PASSWORD EncryptedNtOwfPassword
    );

NTSTATUS
RtlDecryptNtOwfPwdWithIndex(
    IN PENCRYPTED_NT_OWF_PASSWORD EncryptedNtOwfPassword,
    IN PCRYPT_INDEX Index,
    OUT PNT_OWF_PASSWORD NtOwfPassword
    );

ULONG
RtlCheckSignatureInFile(
    IN PWSTR File
    );

BOOLEAN
RtlGenRandom(
    OUT PVOID RandomBuffer,
    IN  ULONG RandomBufferLength
    );


//
// The buffer passed into RtlEncryptMemory and RtlDecryptMemory
// must be a multiple of this length.
//

#define RTL_ENCRYPT_MEMORY_SIZE             8

//
// Allow Encrypt/Decrypt across process boundaries.
// eg: encrypted buffer passed across LPC to another process which calls RtlDecryptMemory.
//

#define RTL_ENCRYPT_OPTION_CROSS_PROCESS    0x01

//
// Allow Encrypt/Decrypt across callers with same LogonId.
// eg: encrypted buffer passed across LPC to another process which calls RtlDecryptMemory whilst impersonating.
//

#define RTL_ENCRYPT_OPTION_SAME_LOGON       0x02

NTSTATUS
RtlEncryptMemory(
    IN OUT  PVOID Memory,
    IN      ULONG MemoryLength,
    IN      ULONG OptionFlags
    );

NTSTATUS
RtlDecryptMemory(
    IN OUT  PVOID Memory,
    IN      ULONG MemoryLength,
    IN      ULONG OptionFlags
    );


//
// Get the user session key for an RPC connection
//

#ifndef MIDL_PASS    // Don't confuse MIDL
NTSTATUS
RtlGetUserSessionKeyClient(
    IN PVOID RpcContextHandle,
    OUT PUSER_SESSION_KEY UserSessionKey
    );

NTSTATUS
RtlGetUserSessionKeyClientBinding(
    IN PVOID RpcBindingHandle,
    OUT HANDLE *RedirHandle,
    OUT PUSER_SESSION_KEY UserSessionKey
    );

NTSTATUS
RtlGetUserSessionKeyServer(
    IN PVOID RpcContextHandle OPTIONAL,
    OUT PUSER_SESSION_KEY UserSessionKey
    );
#endif // MIDL_PASS

#ifdef __cplusplus
}   // extern "C"
#endif

#endif // _NTCRYPT_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\public\internal\ds\inc\cs.h ===
#pragma warning( disable: 4049 )  /* more than 64k source lines */

/* this ALWAYS GENERATED file contains the definitions for the interfaces */


 /* File created by MIDL compiler version 6.00.0347 */
/* Compiler settings for cs.idl:
    Oicf, W1, Zp8, env=Win32 (32b run)
    protocol : dce , ms_ext, c_ext, oldnames, robust
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )


/* verify that the <rpcndr.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCNDR_H_VERSION__
#define __REQUIRED_RPCNDR_H_VERSION__ 475
#endif

#include "rpc.h"
#include "rpcndr.h"

#ifndef __RPCNDR_H_VERSION__
#error this stub requires an updated version of <rpcndr.h>
#endif // __RPCNDR_H_VERSION__

#ifndef COM_NO_WINDOWS_H
#include "windows.h"
#include "ole2.h"
#endif /*COM_NO_WINDOWS_H*/

#ifndef __cs_h__
#define __cs_h__

#if defined(_MSC_VER) && (_MSC_VER >= 1020)
#pragma once
#endif

/* Forward Declarations */ 

#ifndef __IEnumPackage_FWD_DEFINED__
#define __IEnumPackage_FWD_DEFINED__
typedef interface IEnumPackage IEnumPackage;
#endif 	/* __IEnumPackage_FWD_DEFINED__ */


#ifndef __IClassAccess_FWD_DEFINED__
#define __IClassAccess_FWD_DEFINED__
typedef interface IClassAccess IClassAccess;
#endif 	/* __IClassAccess_FWD_DEFINED__ */


#ifndef __IClassAdmin_FWD_DEFINED__
#define __IClassAdmin_FWD_DEFINED__
typedef interface IClassAdmin IClassAdmin;
#endif 	/* __IClassAdmin_FWD_DEFINED__ */


/* header files for imported files */
#include "unknwn.h"
#include "appmgmt.h"

#ifdef __cplusplus
extern "C"{
#endif 

void * __RPC_USER MIDL_user_allocate(size_t);
void __RPC_USER MIDL_user_free( void * ); 

/* interface __MIDL_itf_cs_0000 */
/* [local] */ 

#define	ACTFLG_UninstallUnmanaged	( 0x4 )

#define	ACTFLG_Published	( 0x8 )

#define	ACTFLG_POSTBETA3	( 0x10 )

#define	ACTFLG_UserInstall	( 0x20 )

#define	ACTFLG_OnDemandInstall	( 0x40 )

#define	ACTFLG_Orphan	( 0x80 )

#define	ACTFLG_Uninstall	( 0x100 )

#define	ACTFLG_Pilot	( 0x200 )

#define	ACTFLG_Assigned	( 0x400 )

#define	ACTFLG_OrphanOnPolicyRemoval	( 0x800 )

#define	ACTFLG_UninstallOnPolicyRemoval	( 0x1000 )

#define	ACTFLG_InstallUserAssign	( 0x2000 )

#define	ACTFLG_ForceUpgrade	( 0x4000 )

#define	ACTFLG_MinimalInstallUI	( 0x8000 )

#define	ACTFLG_ExcludeX86OnIA64	( 0x10000 )

#define	ACTFLG_IgnoreLanguage	( 0x20000 )

#define	ACTFLG_HasUpgrades	( 0x40000 )

#define	ACTFLG_FullInstallUI	( 0x80000 )

#define	APPQUERY_ALL	( 1 )

#define	APPQUERY_ADMINISTRATIVE	( 2 )

#define	APPQUERY_POLICY	( 3 )

#define	APPQUERY_USERDISPLAY	( 4 )

#define	APPQUERY_RSOP_LOGGING	( 5 )

#define	APPQUERY_RSOP_ARP	( 6 )

#define	UPGFLG_Uninstall	( 0x1 )

#define	UPGFLG_NoUninstall	( 0x2 )

#define	UPGFLG_UpgradedBy	( 0x4 )

#define	UPGFLG_Enforced	( 0x8 )

typedef /* [v1_enum] */ 
enum _CLASSPATHTYPE
    {	ExeNamePath	= 0,
	DllNamePath	= ExeNamePath + 1,
	TlbNamePath	= DllNamePath + 1,
	CabFilePath	= TlbNamePath + 1,
	InfFilePath	= CabFilePath + 1,
	DrwFilePath	= InfFilePath + 1,
	SetupNamePath	= DrwFilePath + 1
    } 	CLASSPATHTYPE;

typedef struct tagUPGRADEINFO
    {
    LPOLESTR szClassStore;
    GUID PackageGuid;
    GUID GpoId;
    DWORD Flag;
    } 	UPGRADEINFO;

#define	CLSCTX64_INPROC_SERVER	( 0x10000000 )

#define	CLSCTX64_INPROC_HANDLER	( 0x20000000 )

typedef struct tagCLASSDETAIL
    {
    CLSID Clsid;
    CLSID TreatAs;
    DWORD dwComClassContext;
    DWORD cProgId;
    DWORD cMaxProgId;
    /* [size_is] */ LPOLESTR *prgProgId;
    } 	CLASSDETAIL;

typedef struct tagACTVATIONINFO
    {
    UINT cClasses;
    /* [size_is] */ CLASSDETAIL *pClasses;
    UINT cShellFileExt;
    /* [size_is] */ LPOLESTR *prgShellFileExt;
    /* [size_is] */ UINT *prgPriority;
    UINT cInterfaces;
    /* [size_is] */ IID *prgInterfaceId;
    UINT cTypeLib;
    /* [size_is] */ GUID *prgTlbId;
    BOOL bHasClasses;
    } 	ACTIVATIONINFO;

typedef struct tagINSTALLINFO
    {
    DWORD dwActFlags;
    CLASSPATHTYPE PathType;
    LPOLESTR pszScriptPath;
    LPOLESTR pszSetupCommand;
    LPOLESTR pszUrl;
    ULONGLONG Usn;
    UINT InstallUiLevel;
    GUID *pClsid;
    GUID ProductCode;
    GUID PackageGuid;
    GUID Mvipc;
    DWORD dwVersionHi;
    DWORD dwVersionLo;
    DWORD dwRevision;
    UINT cUpgrades;
    /* [size_is] */ UPGRADEINFO *prgUpgradeInfoList;
    ULONG cScriptLen;
    } 	INSTALLINFO;

typedef struct tagPLATFORMINFO
    {
    UINT cPlatforms;
    /* [size_is] */ CSPLATFORM *prgPlatform;
    UINT cLocales;
    /* [size_is] */ LCID *prgLocale;
    } 	PLATFORMINFO;

typedef struct tagPACKAGEDETAIL
    {
    LPOLESTR pszPackageName;
    LPOLESTR pszPublisher;
    UINT cSources;
    /* [size_is] */ LPOLESTR *pszSourceList;
    UINT cCategories;
    /* [size_is] */ GUID *rpCategory;
    ACTIVATIONINFO *pActInfo;
    PLATFORMINFO *pPlatformInfo;
    INSTALLINFO *pInstallInfo;
    } 	PACKAGEDETAIL;

#ifndef _LPCSADMNENUM_DEFINED
#define _LPCSADMNENUM_DEFINED
typedef struct tagPACKAGEDISPINFO
    {
    LPOLESTR pszPackageName;
    DWORD dwActFlags;
    CLASSPATHTYPE PathType;
    LPOLESTR pszScriptPath;
    LPOLESTR pszPublisher;
    LPOLESTR pszUrl;
    UINT InstallUiLevel;
    GUID ProductCode;
    GUID PackageGuid;
    ULONGLONG Usn;
    DWORD dwVersionHi;
    DWORD dwVersionLo;
    DWORD dwRevision;
    GUID GpoId;
    UINT cUpgrades;
    /* [size_is] */ UPGRADEINFO *prgUpgradeInfoList;
    LANGID LangId;
    BYTE *rgSecurityDescriptor;
    UINT cbSecurityDescriptor;
    WCHAR *pszGpoPath;
    DWORD MatchedArchitecture;
    UINT cArchitectures;
    /* [size_is] */ DWORD *prgArchitectures;
    UINT cTransforms;
    /* [size_is] */ LPOLESTR *prgTransforms;
    UINT cCategories;
    /* [size_is] */ LPOLESTR *prgCategories;
    } 	PACKAGEDISPINFO;



extern RPC_IF_HANDLE __MIDL_itf_cs_0000_ClientIfHandle;
extern RPC_IF_HANDLE __MIDL_itf_cs_0000_ServerIfHandle;

#ifndef __IEnumPackage_INTERFACE_DEFINED__
#define __IEnumPackage_INTERFACE_DEFINED__

/* interface IEnumPackage */
/* [uuid][object][local] */ 


EXTERN_C const IID IID_IEnumPackage;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("00000193-0000-0000-C000-000000000046")
    IEnumPackage : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Next( 
            /* [in] */ ULONG celt,
            /* [length_is][size_is][out] */ PACKAGEDISPINFO *rgelt,
            /* [out] */ ULONG *pceltFetched) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Skip( 
            /* [in] */ ULONG celt) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Reset( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IEnumPackageVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IEnumPackage * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IEnumPackage * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IEnumPackage * This);
        
        HRESULT ( STDMETHODCALLTYPE *Next )( 
            IEnumPackage * This,
            /* [in] */ ULONG celt,
            /* [length_is][size_is][out] */ PACKAGEDISPINFO *rgelt,
            /* [out] */ ULONG *pceltFetched);
        
        HRESULT ( STDMETHODCALLTYPE *Skip )( 
            IEnumPackage * This,
            /* [in] */ ULONG celt);
        
        HRESULT ( STDMETHODCALLTYPE *Reset )( 
            IEnumPackage * This);
        
        END_INTERFACE
    } IEnumPackageVtbl;

    interface IEnumPackage
    {
        CONST_VTBL struct IEnumPackageVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IEnumPackage_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IEnumPackage_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IEnumPackage_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IEnumPackage_Next(This,celt,rgelt,pceltFetched)	\
    (This)->lpVtbl -> Next(This,celt,rgelt,pceltFetched)

#define IEnumPackage_Skip(This,celt)	\
    (This)->lpVtbl -> Skip(This,celt)

#define IEnumPackage_Reset(This)	\
    (This)->lpVtbl -> Reset(This)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IEnumPackage_Next_Proxy( 
    IEnumPackage * This,
    /* [in] */ ULONG celt,
    /* [length_is][size_is][out] */ PACKAGEDISPINFO *rgelt,
    /* [out] */ ULONG *pceltFetched);


void __RPC_STUB IEnumPackage_Next_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumPackage_Skip_Proxy( 
    IEnumPackage * This,
    /* [in] */ ULONG celt);


void __RPC_STUB IEnumPackage_Skip_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumPackage_Reset_Proxy( 
    IEnumPackage * This);


void __RPC_STUB IEnumPackage_Reset_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IEnumPackage_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_cs_0011 */
/* [local] */ 

#endif


extern RPC_IF_HANDLE __MIDL_itf_cs_0011_ClientIfHandle;
extern RPC_IF_HANDLE __MIDL_itf_cs_0011_ServerIfHandle;

#ifndef __IClassAccess_INTERFACE_DEFINED__
#define __IClassAccess_INTERFACE_DEFINED__

/* interface IClassAccess */
/* [uuid][object][local] */ 


EXTERN_C const IID IID_IClassAccess;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("00000190-0000-0000-C000-000000000046")
    IClassAccess : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetAppInfo( 
            /* [in] */ uCLSSPEC *pClassSpec,
            /* [in] */ QUERYCONTEXT *pQryContext,
            /* [out] */ PACKAGEDISPINFO *pPackageInfo) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE EnumPackages( 
            /* [unique][in] */ LPOLESTR pszPackageName,
            /* [unique][in] */ GUID *pCategory,
            /* [unique][in] */ ULONGLONG *pLastUsn,
            /* [in] */ DWORD dwAppFlags,
            /* [out] */ IEnumPackage **ppIEnumPackage) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetClassStorePath( 
            /* [unique][in] */ LPOLESTR pszClassStorePath,
            /* [unique][in] */ void *pRsopUserToken) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IClassAccessVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IClassAccess * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IClassAccess * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IClassAccess * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetAppInfo )( 
            IClassAccess * This,
            /* [in] */ uCLSSPEC *pClassSpec,
            /* [in] */ QUERYCONTEXT *pQryContext,
            /* [out] */ PACKAGEDISPINFO *pPackageInfo);
        
        HRESULT ( STDMETHODCALLTYPE *EnumPackages )( 
            IClassAccess * This,
            /* [unique][in] */ LPOLESTR pszPackageName,
            /* [unique][in] */ GUID *pCategory,
            /* [unique][in] */ ULONGLONG *pLastUsn,
            /* [in] */ DWORD dwAppFlags,
            /* [out] */ IEnumPackage **ppIEnumPackage);
        
        HRESULT ( STDMETHODCALLTYPE *SetClassStorePath )( 
            IClassAccess * This,
            /* [unique][in] */ LPOLESTR pszClassStorePath,
            /* [unique][in] */ void *pRsopUserToken);
        
        END_INTERFACE
    } IClassAccessVtbl;

    interface IClassAccess
    {
        CONST_VTBL struct IClassAccessVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IClassAccess_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IClassAccess_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IClassAccess_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IClassAccess_GetAppInfo(This,pClassSpec,pQryContext,pPackageInfo)	\
    (This)->lpVtbl -> GetAppInfo(This,pClassSpec,pQryContext,pPackageInfo)

#define IClassAccess_EnumPackages(This,pszPackageName,pCategory,pLastUsn,dwAppFlags,ppIEnumPackage)	\
    (This)->lpVtbl -> EnumPackages(This,pszPackageName,pCategory,pLastUsn,dwAppFlags,ppIEnumPackage)

#define IClassAccess_SetClassStorePath(This,pszClassStorePath,pRsopUserToken)	\
    (This)->lpVtbl -> SetClassStorePath(This,pszClassStorePath,pRsopUserToken)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IClassAccess_GetAppInfo_Proxy( 
    IClassAccess * This,
    /* [in] */ uCLSSPEC *pClassSpec,
    /* [in] */ QUERYCONTEXT *pQryContext,
    /* [out] */ PACKAGEDISPINFO *pPackageInfo);


void __RPC_STUB IClassAccess_GetAppInfo_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IClassAccess_EnumPackages_Proxy( 
    IClassAccess * This,
    /* [unique][in] */ LPOLESTR pszPackageName,
    /* [unique][in] */ GUID *pCategory,
    /* [unique][in] */ ULONGLONG *pLastUsn,
    /* [in] */ DWORD dwAppFlags,
    /* [out] */ IEnumPackage **ppIEnumPackage);


void __RPC_STUB IClassAccess_EnumPackages_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IClassAccess_SetClassStorePath_Proxy( 
    IClassAccess * This,
    /* [unique][in] */ LPOLESTR pszClassStorePath,
    /* [unique][in] */ void *pRsopUserToken);


void __RPC_STUB IClassAccess_SetClassStorePath_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IClassAccess_INTERFACE_DEFINED__ */


#ifndef __IClassAdmin_INTERFACE_DEFINED__
#define __IClassAdmin_INTERFACE_DEFINED__

/* interface IClassAdmin */
/* [uuid][object][local] */ 


EXTERN_C const IID IID_IClassAdmin;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("00000191-0000-0000-C000-000000000046")
    IClassAdmin : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetGPOInfo( 
            /* [out] */ GUID *pGPOId,
            /* [out] */ LPOLESTR *pszPolicyName) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE AddPackage( 
            /* [in] */ PACKAGEDETAIL *pPackageDetail,
            /* [out] */ GUID *pPkgGuid) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE RemovePackage( 
            /* [in] */ LPOLESTR pszPackageName,
            /* [in] */ DWORD dwFlags) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ChangePackageProperties( 
            /* [in] */ LPOLESTR pszPackageName,
            /* [unique][in] */ LPOLESTR pszNewName,
            /* [unique][in] */ DWORD *pdwFlags,
            /* [unique][in] */ LPOLESTR pszUrl,
            /* [unique][in] */ LPOLESTR pszScriptPath,
            /* [unique][in] */ UINT *pInstallUiLevel,
            /* [unique][in] */ DWORD *pdwRevision) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ChangePackageCategories( 
            /* [in] */ LPOLESTR pszPackageName,
            /* [in] */ UINT cCategories,
            /* [unique][size_is][in] */ GUID *rpCategory) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ChangePackageSourceList( 
            /* [in] */ LPOLESTR pszPackageName,
            /* [in] */ UINT cSources,
            /* [unique][size_is][in] */ LPOLESTR *pszSourceList) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ChangePackageUpgradeList( 
            /* [in] */ LPOLESTR pszPackageName,
            /* [in] */ UINT cUpgrades,
            /* [unique][size_is][in] */ UPGRADEINFO *prgUpgradeInfoList) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ChangePackageUpgradeInfoIncremental( 
            /* [in] */ GUID PkgGuid,
            /* [in] */ UPGRADEINFO UpgradeInfo,
            /* [in] */ DWORD OpFlags) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetPriorityByFileExt( 
            /* [in] */ LPOLESTR pszPackageName,
            /* [in] */ LPOLESTR pszFileExt,
            /* [in] */ UINT Priority) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE EnumPackages( 
            /* [unique][in] */ LPOLESTR pszFileExt,
            /* [unique][in] */ GUID *pCategory,
            /* [in] */ DWORD dwAppFlags,
            /* [unique][in] */ DWORD *pdwLocale,
            /* [unique][in] */ CSPLATFORM *pPlatform,
            /* [out] */ IEnumPackage **ppIEnumPackage) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetPackageDetails( 
            /* [in] */ LPOLESTR pszPackageName,
            /* [out] */ PACKAGEDETAIL *pPackageDetail) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetPackageDetailsFromGuid( 
            /* [in] */ GUID PkgGuid,
            /* [out] */ PACKAGEDETAIL *pPackageDetail) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetAppCategories( 
            /* [in] */ LCID Locale,
            /* [out] */ APPCATEGORYINFOLIST *pAppCategoryList) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE RegisterAppCategory( 
            /* [in] */ APPCATEGORYINFO *pAppCategory) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE UnregisterAppCategory( 
            /* [in] */ GUID *pAppCategoryId) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Cleanup( 
            /* [in] */ FILETIME *pTimeBefore) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetDNFromPackageName( 
            /* [in] */ LPOLESTR pszPackageName,
            /* [out] */ LPOLESTR *szDN) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE RedeployPackage( 
            /* [in] */ GUID *pPackageGuid,
            /* [in] */ PACKAGEDETAIL *pPackageDetail) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IClassAdminVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IClassAdmin * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IClassAdmin * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IClassAdmin * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetGPOInfo )( 
            IClassAdmin * This,
            /* [out] */ GUID *pGPOId,
            /* [out] */ LPOLESTR *pszPolicyName);
        
        HRESULT ( STDMETHODCALLTYPE *AddPackage )( 
            IClassAdmin * This,
            /* [in] */ PACKAGEDETAIL *pPackageDetail,
            /* [out] */ GUID *pPkgGuid);
        
        HRESULT ( STDMETHODCALLTYPE *RemovePackage )( 
            IClassAdmin * This,
            /* [in] */ LPOLESTR pszPackageName,
            /* [in] */ DWORD dwFlags);
        
        HRESULT ( STDMETHODCALLTYPE *ChangePackageProperties )( 
            IClassAdmin * This,
            /* [in] */ LPOLESTR pszPackageName,
            /* [unique][in] */ LPOLESTR pszNewName,
            /* [unique][in] */ DWORD *pdwFlags,
            /* [unique][in] */ LPOLESTR pszUrl,
            /* [unique][in] */ LPOLESTR pszScriptPath,
            /* [unique][in] */ UINT *pInstallUiLevel,
            /* [unique][in] */ DWORD *pdwRevision);
        
        HRESULT ( STDMETHODCALLTYPE *ChangePackageCategories )( 
            IClassAdmin * This,
            /* [in] */ LPOLESTR pszPackageName,
            /* [in] */ UINT cCategories,
            /* [unique][size_is][in] */ GUID *rpCategory);
        
        HRESULT ( STDMETHODCALLTYPE *ChangePackageSourceList )( 
            IClassAdmin * This,
            /* [in] */ LPOLESTR pszPackageName,
            /* [in] */ UINT cSources,
            /* [unique][size_is][in] */ LPOLESTR *pszSourceList);
        
        HRESULT ( STDMETHODCALLTYPE *ChangePackageUpgradeList )( 
            IClassAdmin * This,
            /* [in] */ LPOLESTR pszPackageName,
            /* [in] */ UINT cUpgrades,
            /* [unique][size_is][in] */ UPGRADEINFO *prgUpgradeInfoList);
        
        HRESULT ( STDMETHODCALLTYPE *ChangePackageUpgradeInfoIncremental )( 
            IClassAdmin * This,
            /* [in] */ GUID PkgGuid,
            /* [in] */ UPGRADEINFO UpgradeInfo,
            /* [in] */ DWORD OpFlags);
        
        HRESULT ( STDMETHODCALLTYPE *SetPriorityByFileExt )( 
            IClassAdmin * This,
            /* [in] */ LPOLESTR pszPackageName,
            /* [in] */ LPOLESTR pszFileExt,
            /* [in] */ UINT Priority);
        
        HRESULT ( STDMETHODCALLTYPE *EnumPackages )( 
            IClassAdmin * This,
            /* [unique][in] */ LPOLESTR pszFileExt,
            /* [unique][in] */ GUID *pCategory,
            /* [in] */ DWORD dwAppFlags,
            /* [unique][in] */ DWORD *pdwLocale,
            /* [unique][in] */ CSPLATFORM *pPlatform,
            /* [out] */ IEnumPackage **ppIEnumPackage);
        
        HRESULT ( STDMETHODCALLTYPE *GetPackageDetails )( 
            IClassAdmin * This,
            /* [in] */ LPOLESTR pszPackageName,
            /* [out] */ PACKAGEDETAIL *pPackageDetail);
        
        HRESULT ( STDMETHODCALLTYPE *GetPackageDetailsFromGuid )( 
            IClassAdmin * This,
            /* [in] */ GUID PkgGuid,
            /* [out] */ PACKAGEDETAIL *pPackageDetail);
        
        HRESULT ( STDMETHODCALLTYPE *GetAppCategories )( 
            IClassAdmin * This,
            /* [in] */ LCID Locale,
            /* [out] */ APPCATEGORYINFOLIST *pAppCategoryList);
        
        HRESULT ( STDMETHODCALLTYPE *RegisterAppCategory )( 
            IClassAdmin * This,
            /* [in] */ APPCATEGORYINFO *pAppCategory);
        
        HRESULT ( STDMETHODCALLTYPE *UnregisterAppCategory )( 
            IClassAdmin * This,
            /* [in] */ GUID *pAppCategoryId);
        
        HRESULT ( STDMETHODCALLTYPE *Cleanup )( 
            IClassAdmin * This,
            /* [in] */ FILETIME *pTimeBefore);
        
        HRESULT ( STDMETHODCALLTYPE *GetDNFromPackageName )( 
            IClassAdmin * This,
            /* [in] */ LPOLESTR pszPackageName,
            /* [out] */ LPOLESTR *szDN);
        
        HRESULT ( STDMETHODCALLTYPE *RedeployPackage )( 
            IClassAdmin * This,
            /* [in] */ GUID *pPackageGuid,
            /* [in] */ PACKAGEDETAIL *pPackageDetail);
        
        END_INTERFACE
    } IClassAdminVtbl;

    interface IClassAdmin
    {
        CONST_VTBL struct IClassAdminVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IClassAdmin_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IClassAdmin_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IClassAdmin_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IClassAdmin_GetGPOInfo(This,pGPOId,pszPolicyName)	\
    (This)->lpVtbl -> GetGPOInfo(This,pGPOId,pszPolicyName)

#define IClassAdmin_AddPackage(This,pPackageDetail,pPkgGuid)	\
    (This)->lpVtbl -> AddPackage(This,pPackageDetail,pPkgGuid)

#define IClassAdmin_RemovePackage(This,pszPackageName,dwFlags)	\
    (This)->lpVtbl -> RemovePackage(This,pszPackageName,dwFlags)

#define IClassAdmin_ChangePackageProperties(This,pszPackageName,pszNewName,pdwFlags,pszUrl,pszScriptPath,pInstallUiLevel,pdwRevision)	\
    (This)->lpVtbl -> ChangePackageProperties(This,pszPackageName,pszNewName,pdwFlags,pszUrl,pszScriptPath,pInstallUiLevel,pdwRevision)

#define IClassAdmin_ChangePackageCategories(This,pszPackageName,cCategories,rpCategory)	\
    (This)->lpVtbl -> ChangePackageCategories(This,pszPackageName,cCategories,rpCategory)

#define IClassAdmin_ChangePackageSourceList(This,pszPackageName,cSources,pszSourceList)	\
    (This)->lpVtbl -> ChangePackageSourceList(This,pszPackageName,cSources,pszSourceList)

#define IClassAdmin_ChangePackageUpgradeList(This,pszPackageName,cUpgrades,prgUpgradeInfoList)	\
    (This)->lpVtbl -> ChangePackageUpgradeList(This,pszPackageName,cUpgrades,prgUpgradeInfoList)

#define IClassAdmin_ChangePackageUpgradeInfoIncremental(This,PkgGuid,UpgradeInfo,OpFlags)	\
    (This)->lpVtbl -> ChangePackageUpgradeInfoIncremental(This,PkgGuid,UpgradeInfo,OpFlags)

#define IClassAdmin_SetPriorityByFileExt(This,pszPackageName,pszFileExt,Priority)	\
    (This)->lpVtbl -> SetPriorityByFileExt(This,pszPackageName,pszFileExt,Priority)

#define IClassAdmin_EnumPackages(This,pszFileExt,pCategory,dwAppFlags,pdwLocale,pPlatform,ppIEnumPackage)	\
    (This)->lpVtbl -> EnumPackages(This,pszFileExt,pCategory,dwAppFlags,pdwLocale,pPlatform,ppIEnumPackage)

#define IClassAdmin_GetPackageDetails(This,pszPackageName,pPackageDetail)	\
    (This)->lpVtbl -> GetPackageDetails(This,pszPackageName,pPackageDetail)

#define IClassAdmin_GetPackageDetailsFromGuid(This,PkgGuid,pPackageDetail)	\
    (This)->lpVtbl -> GetPackageDetailsFromGuid(This,PkgGuid,pPackageDetail)

#define IClassAdmin_GetAppCategories(This,Locale,pAppCategoryList)	\
    (This)->lpVtbl -> GetAppCategories(This,Locale,pAppCategoryList)

#define IClassAdmin_RegisterAppCategory(This,pAppCategory)	\
    (This)->lpVtbl -> RegisterAppCategory(This,pAppCategory)

#define IClassAdmin_UnregisterAppCategory(This,pAppCategoryId)	\
    (This)->lpVtbl -> UnregisterAppCategory(This,pAppCategoryId)

#define IClassAdmin_Cleanup(This,pTimeBefore)	\
    (This)->lpVtbl -> Cleanup(This,pTimeBefore)

#define IClassAdmin_GetDNFromPackageName(This,pszPackageName,szDN)	\
    (This)->lpVtbl -> GetDNFromPackageName(This,pszPackageName,szDN)

#define IClassAdmin_RedeployPackage(This,pPackageGuid,pPackageDetail)	\
    (This)->lpVtbl -> RedeployPackage(This,pPackageGuid,pPackageDetail)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IClassAdmin_GetGPOInfo_Proxy( 
    IClassAdmin * This,
    /* [out] */ GUID *pGPOId,
    /* [out] */ LPOLESTR *pszPolicyName);


void __RPC_STUB IClassAdmin_GetGPOInfo_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IClassAdmin_AddPackage_Proxy( 
    IClassAdmin * This,
    /* [in] */ PACKAGEDETAIL *pPackageDetail,
    /* [out] */ GUID *pPkgGuid);


void __RPC_STUB IClassAdmin_AddPackage_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IClassAdmin_RemovePackage_Proxy( 
    IClassAdmin * This,
    /* [in] */ LPOLESTR pszPackageName,
    /* [in] */ DWORD dwFlags);


void __RPC_STUB IClassAdmin_RemovePackage_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IClassAdmin_ChangePackageProperties_Proxy( 
    IClassAdmin * This,
    /* [in] */ LPOLESTR pszPackageName,
    /* [unique][in] */ LPOLESTR pszNewName,
    /* [unique][in] */ DWORD *pdwFlags,
    /* [unique][in] */ LPOLESTR pszUrl,
    /* [unique][in] */ LPOLESTR pszScriptPath,
    /* [unique][in] */ UINT *pInstallUiLevel,
    /* [unique][in] */ DWORD *pdwRevision);


void __RPC_STUB IClassAdmin_ChangePackageProperties_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IClassAdmin_ChangePackageCategories_Proxy( 
    IClassAdmin * This,
    /* [in] */ LPOLESTR pszPackageName,
    /* [in] */ UINT cCategories,
    /* [unique][size_is][in] */ GUID *rpCategory);


void __RPC_STUB IClassAdmin_ChangePackageCategories_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IClassAdmin_ChangePackageSourceList_Proxy( 
    IClassAdmin * This,
    /* [in] */ LPOLESTR pszPackageName,
    /* [in] */ UINT cSources,
    /* [unique][size_is][in] */ LPOLESTR *pszSourceList);


void __RPC_STUB IClassAdmin_ChangePackageSourceList_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IClassAdmin_ChangePackageUpgradeList_Proxy( 
    IClassAdmin * This,
    /* [in] */ LPOLESTR pszPackageName,
    /* [in] */ UINT cUpgrades,
    /* [unique][size_is][in] */ UPGRADEINFO *prgUpgradeInfoList);


void __RPC_STUB IClassAdmin_ChangePackageUpgradeList_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IClassAdmin_ChangePackageUpgradeInfoIncremental_Proxy( 
    IClassAdmin * This,
    /* [in] */ GUID PkgGuid,
    /* [in] */ UPGRADEINFO UpgradeInfo,
    /* [in] */ DWORD OpFlags);


void __RPC_STUB IClassAdmin_ChangePackageUpgradeInfoIncremental_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IClassAdmin_SetPriorityByFileExt_Proxy( 
    IClassAdmin * This,
    /* [in] */ LPOLESTR pszPackageName,
    /* [in] */ LPOLESTR pszFileExt,
    /* [in] */ UINT Priority);


void __RPC_STUB IClassAdmin_SetPriorityByFileExt_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IClassAdmin_EnumPackages_Proxy( 
    IClassAdmin * This,
    /* [unique][in] */ LPOLESTR pszFileExt,
    /* [unique][in] */ GUID *pCategory,
    /* [in] */ DWORD dwAppFlags,
    /* [unique][in] */ DWORD *pdwLocale,
    /* [unique][in] */ CSPLATFORM *pPlatform,
    /* [out] */ IEnumPackage **ppIEnumPackage);


void __RPC_STUB IClassAdmin_EnumPackages_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IClassAdmin_GetPackageDetails_Proxy( 
    IClassAdmin * This,
    /* [in] */ LPOLESTR pszPackageName,
    /* [out] */ PACKAGEDETAIL *pPackageDetail);


void __RPC_STUB IClassAdmin_GetPackageDetails_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IClassAdmin_GetPackageDetailsFromGuid_Proxy( 
    IClassAdmin * This,
    /* [in] */ GUID PkgGuid,
    /* [out] */ PACKAGEDETAIL *pPackageDetail);


void __RPC_STUB IClassAdmin_GetPackageDetailsFromGuid_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IClassAdmin_GetAppCategories_Proxy( 
    IClassAdmin * This,
    /* [in] */ LCID Locale,
    /* [out] */ APPCATEGORYINFOLIST *pAppCategoryList);


void __RPC_STUB IClassAdmin_GetAppCategories_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IClassAdmin_RegisterAppCategory_Proxy( 
    IClassAdmin * This,
    /* [in] */ APPCATEGORYINFO *pAppCategory);


void __RPC_STUB IClassAdmin_RegisterAppCategory_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IClassAdmin_UnregisterAppCategory_Proxy( 
    IClassAdmin * This,
    /* [in] */ GUID *pAppCategoryId);


void __RPC_STUB IClassAdmin_UnregisterAppCategory_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IClassAdmin_Cleanup_Proxy( 
    IClassAdmin * This,
    /* [in] */ FILETIME *pTimeBefore);


void __RPC_STUB IClassAdmin_Cleanup_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IClassAdmin_GetDNFromPackageName_Proxy( 
    IClassAdmin * This,
    /* [in] */ LPOLESTR pszPackageName,
    /* [out] */ LPOLESTR *szDN);


void __RPC_STUB IClassAdmin_GetDNFromPackageName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IClassAdmin_RedeployPackage_Proxy( 
    IClassAdmin * This,
    /* [in] */ GUID *pPackageGuid,
    /* [in] */ PACKAGEDETAIL *pPackageDetail);


void __RPC_STUB IClassAdmin_RedeployPackage_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IClassAdmin_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_cs_0013 */
/* [local] */ 

//------------------------- Priorities and weights

// 
// File Extension priority
// 
// 1 bit (0)
//
#define PRI_EXTN_FACTOR        (1 << 0)

//
// CLSCTX priority
//
// 2 bits (7:8)
//
#define PRI_CLSID_INPSVR       (3 << 7)
#define PRI_CLSID_LCLSVR       (2 << 7)
#define PRI_CLSID_REMSVR       (1 << 7)

//
// UI Language priority
//
// 3 bits (9:11)
//
#define PRI_LANG_ALWAYSMATCH   (4 << 9)
#define PRI_LANG_SYSTEMLOCALE  (3 << 9)
#define PRI_LANG_ENGLISH       (2 << 9)
#define PRI_LANG_NEUTRAL       (1 << 9)

//
// Architecture priority
//
// 2 bits (12:13)
//
#define PRI_ARCH_PREF1         (2 << 12)
#define PRI_ARCH_PREF2         (1 << 12)


extern RPC_IF_HANDLE __MIDL_itf_cs_0013_ClientIfHandle;
extern RPC_IF_HANDLE __MIDL_itf_cs_0013_ServerIfHandle;

/* Additional Prototypes for ALL interfaces */

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\public\internal\ds\inc\cryptui.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992-1999.
//
//  File:       cryptui.h
//
//  Contents:   Common Cryptographic Dialog API Prototypes and Definitions
//
//----------------------------------------------------------------------------

#ifndef __CRYPTUI_H__
#define __CRYPTUI_H__

#if defined (_MSC_VER) && (_MSC_VER >= 1020)
#pragma once
#endif

#include <prsht.h>
#include <wintrust.h>
#include <certca.h>
#include <cryptuiapi.h>

#ifdef __cplusplus
extern "C" {
#endif

#include <pshpack8.h>


/////////////////////////////////////////////////////////////////////////////////////////////////////
//
//  the functions which return property sheet pages take this callback as one of the parameters in
//  the input structure.  it is then called when each page is about to be created and when each page
//  is about to be destroyed.  the messages are PSPCB_CREATE when a page is about to be created and
//  PSPCB_RELEASE when a page is about to be destroyed.  the pvCallbackData parameter in the callback
//  is the pvoid that was passed in with the callback in the input structure.
typedef BOOL (WINAPI * PFNCPROPPAGECALLBACK)(
        HWND        hWndPropPage,
        UINT        uMsg,
        void        *pvCallbackData);


/////////////////////////////////////////////////////////////////////////////////////////////////////
//
// dwSize                          size of this struct
// hwndParent                      parent of this dialog                                    (OPTIONAL)
// dwFlags                         flags, may a combination of any of the flags below       (OPTIONAL)
// szTitle                         title for the window                                     (OPTIONAL)
// pCertContext                    the cert context that is to be displayed
// rgszPurposes                    array of purposes that this cert is to be validated for  (OPTIONAL)
// cPurposes                       number of purposes                                       (OPTIONAL)
// pCryptProviderData/hWVTStateData if WinVerifyTrust has already been called for the cert  (OPTIONAL)
//                                 then pass in a pointer to the state struct that was
//                                 acquired through a call to WTHelperProvDataFromStateData(),
//                                 or pass in the hWVTStateData of the WINTRUST_DATA struct
//                                 if WTHelperProvDataFromStateData() was not called.
//                                 if pCryptProviderData/hWVTStateData is used then
//                                 fpCryptProviderDataTrustedUsage, idxSigner, idxCert, and
//                                 fCounterSignature must be set
// fpCryptProviderDataTrustedUsage if WinVerifyTrust was called this is the result of whether (OPTIONAL)
//                                 the cert was trusted
// idxSigner                       the index of the signer to view                          (OPTIONAL)
// idxCert                         the index of the cert that is being viewed within the    (OPTIONAL)
//                                 signer chain.  the cert context of this cert MUST match
//                                 pCertContext
// fCounterSigner                  set to TRUE if a counter signature is being viewed.  if  (OPTIONAL)
//                                 this is TRUE then idxCounterSigner must be valid
// idxCounterSigner                the index of the counter signer to view                  (OPTIONAL)
// cStores                         Count of other stores to search when building and        (OPTIONAL)
//                                 validating chain
// rghStores                       Array of other stores to search when buliding and        (OPTIONAL)
//                                 validating chain
// cPropSheetPages                 number of extra pages to add to the dialog.              (OPTIONAL)
// rgPropSheetPages                extra pages to add to the dialog.                        (OPTIONAL)
//                                 each page in this array will NOT recieve the lParam in
//                                 the PROPSHEET structure as the lParam in the
//                                 WM_INITDIALOG, instead it will receive a pointer to a
//                                 CRYPTUI_INITDIALOG_STRUCT (defined below) which contains
//                                 the lParam in the PROPSSHEET structure AND the
//                                 PCCERT_CONTEXT for which the page is being displayed.
// nStartPage                      this is the index of the initial page that will be
//                                 displayed.  if the upper most bit (0x8000) is set then
//                                 the index is assumed to index rgPropSheetPages
//                                 (after the upper most bit has been stripped off.  eg.
//                                 0x8000 will indicate the first page in rgPropSheetPages),
//                                 if the upper most bit is 0 then nStartPage will be the
//                                 starting index of the default certificate dialog pages.
//
/////////////////////////////////////////////////////////////////////////////////////////////////////

// dwFlags
#define CRYPTUI_HIDE_HIERARCHYPAGE          0x00000001
#define CRYPTUI_HIDE_DETAILPAGE             0x00000002
#define CRYPTUI_DISABLE_EDITPROPERTIES      0x00000004
#define CRYPTUI_ENABLE_EDITPROPERTIES       0x00000008
#define CRYPTUI_DISABLE_ADDTOSTORE          0x00000010
#define CRYPTUI_ENABLE_ADDTOSTORE           0x00000020
#define CRYPTUI_ACCEPT_DECLINE_STYLE        0x00000040
#define CRYPTUI_IGNORE_UNTRUSTED_ROOT       0x00000080
#define CRYPTUI_DONT_OPEN_STORES            0x00000100
#define CRYPTUI_ONLY_OPEN_ROOT_STORE        0x00000200
#define CRYPTUI_WARN_UNTRUSTED_ROOT         0x00000400  // For use with viewing of certificates on remote
                                                        // machines only.  If this flag is used rghStores[0]
                                                        // must be the handle of the root store on the remote machine.
#define CRYPTUI_ENABLE_REVOCATION_CHECKING  0x00000800  // This flag is only valid if pCryptProviderData/hWVTStateData
                                                        // is not passed in.
#define CRYPTUI_WARN_REMOTE_TRUST           0x00001000


// Following is a flag for internal use only!!
#define CRYPTUI_TREEVIEW_PAGE_FLAG          0x80000000

typedef struct tagCRYPTUI_VIEWCERTIFICATE_STRUCTW {
    DWORD                       dwSize;
    HWND                        hwndParent;                     // OPTIONAL
    DWORD                       dwFlags;                        // OPTIONAL
    LPCWSTR                     szTitle;                        // OPTIONAL
    PCCERT_CONTEXT              pCertContext;
    LPCSTR *                    rgszPurposes;                   // OPTIONAL
    DWORD                       cPurposes;                      // OPTIONAL
    union
    {
        CRYPT_PROVIDER_DATA const * pCryptProviderData;         // OPTIONAL
        HANDLE                      hWVTStateData;              // OPTIONAL
    };
    BOOL                        fpCryptProviderDataTrustedUsage;// OPTIONAL
    DWORD                       idxSigner;                      // OPTIONAL
    DWORD                       idxCert;                        // OPTIONAL
    BOOL                        fCounterSigner;                 // OPTIONAL
    DWORD                       idxCounterSigner;               // OPTIONAL
    DWORD                       cStores;                        // OPTIONAL
    HCERTSTORE *                rghStores;                      // OPTIONAL
    DWORD                       cPropSheetPages;                // OPTIONAL
    LPCPROPSHEETPAGEW           rgPropSheetPages;               // OPTIONAL
    DWORD                       nStartPage;
} CRYPTUI_VIEWCERTIFICATE_STRUCTW, *PCRYPTUI_VIEWCERTIFICATE_STRUCTW;
typedef const CRYPTUI_VIEWCERTIFICATE_STRUCTW *PCCRYPTUI_VIEWCERTIFICATE_STRUCTW;


typedef struct tagCRYPTUI_VIEWCERTIFICATE_STRUCTA {
    DWORD                       dwSize;
    HWND                        hwndParent;                     // OPTIONAL
    DWORD                       dwFlags;                        // OPTIONAL
    LPCSTR                      szTitle;                        // OPTIONAL
    PCCERT_CONTEXT              pCertContext;
    LPCSTR *                    rgszPurposes;                   // OPTIONAL
    DWORD                       cPurposes;                      // OPTIONAL
    union
    {
        CRYPT_PROVIDER_DATA const * pCryptProviderData;         // OPTIONAL
        HANDLE                      hWVTStateData;              // OPTIONAL
    };
    BOOL                        fpCryptProviderDataTrustedUsage;// OPTIONAL
    DWORD                       idxSigner;                      // OPTIONAL
    DWORD                       idxCert;                        // OPTIONAL
    BOOL                        fCounterSigner;                 // OPTIONAL
    DWORD                       idxCounterSigner;               // OPTIONAL
    DWORD                       cStores;                        // OPTIONAL
    HCERTSTORE *                rghStores;                      // OPTIONAL
    DWORD                       cPropSheetPages;                // OPTIONAL
    LPCPROPSHEETPAGEA           rgPropSheetPages;               // OPTIONAL
    DWORD                       nStartPage;
} CRYPTUI_VIEWCERTIFICATE_STRUCTA, *PCRYPTUI_VIEWCERTIFICATE_STRUCTA;
typedef const CRYPTUI_VIEWCERTIFICATE_STRUCTA *PCCRYPTUI_VIEWCERTIFICATE_STRUCTA;

//
// pfPropertiesChanged             this will be set by the dialog proc to inform the caller
//                                 if any properties have been changed on certs in the chain
//                                 while the dialog was open
//
BOOL
WINAPI
CryptUIDlgViewCertificateW(
        IN  PCCRYPTUI_VIEWCERTIFICATE_STRUCTW   pCertViewInfo,
        OUT BOOL                                *pfPropertiesChanged  // OPTIONAL
        );

BOOL
WINAPI
CryptUIDlgViewCertificateA(
        IN  PCCRYPTUI_VIEWCERTIFICATE_STRUCTA   pCertViewInfo,
        OUT BOOL                                *pfPropertiesChanged  // OPTIONAL
        );

#ifdef UNICODE
#define CryptUIDlgViewCertificate           CryptUIDlgViewCertificateW
#define PCRYPTUI_VIEWCERTIFICATE_STRUCT     PCRYPTUI_VIEWCERTIFICATE_STRUCTW
#define CRYPTUI_VIEWCERTIFICATE_STRUCT      CRYPTUI_VIEWCERTIFICATE_STRUCTW
#define PCCRYPTUI_VIEWCERTIFICATE_STRUCT    PCCRYPTUI_VIEWCERTIFICATE_STRUCTW
#else
#define CryptUIDlgViewCertificate           CryptUIDlgViewCertificateA
#define PCRYPTUI_VIEWCERTIFICATE_STRUCT     PCRYPTUI_VIEWCERTIFICATE_STRUCTA
#define CRYPTUI_VIEWCERTIFICATE_STRUCT      CRYPTUI_VIEWCERTIFICATE_STRUCTA
#define PCCRYPTUI_VIEWCERTIFICATE_STRUCT    PCCRYPTUI_VIEWCERTIFICATE_STRUCTA
#endif

//
// this struct is passed as the lParam in the WM_INITDIALOG call to each
// property sheet that is in the rgPropSheetPages array of the
// CRYPTUI_VIEWCERTIFICATE_STRUCT structure
//
typedef struct tagCRYPTUI_INITDIALOG_STRUCT {
    LPARAM          lParam;
    PCCERT_CONTEXT  pCertContext;
} CRYPTUI_INITDIALOG_STRUCT, *PCRYPTUI_INITDIALOG_STRUCT;


//
// this structure is used in CRYPTUI_VIEWCERTIFICATEPROPERTIES_STRUCT,
// and allows users of MMC to recieve notifications that properties
// on certificates have changed
//
typedef HRESULT (__stdcall * PFNCMMCCALLBACK)(LONG_PTR lNotifyHandle, LPARAM param);

typedef struct tagCRYPTUI_MMCCALLBACK_STRUCT {
    PFNCMMCCALLBACK pfnCallback;    // the address of MMCPropertyChangeNotify()
    LONG_PTR         lNotifyHandle;  // the lNotifyHandle passed to MMCPropertyChangeNotify()
    LPARAM          param;          // the param passed to MMCPropertyChangeNotify()
} CRYPTUI_MMCCALLBACK_STRUCT, *PCRYPTUI_MMCCALLBACK_STRUCT;

/////////////////////////////////////////////////////////////////////////////////////////////////////
//
// dwSize                          size of this struct
// hwndParent                      parent of this dialog                                    (OPTIONAL)
// dwFlags                         flags, must be set to 0
// union                           the szTitle field of the union is only valid if
//                                 CryptUIDlgViewCertificateProperties is being called.
//                                 the pMMCCallback field of the union is only valid if
//                                 CryptUIGetCertificatePropertiesPages is being called.
//                                 Note that if pMMCCallback is non-NULL and
//                                 CryptUIGetCertificatePropertiesPages was called, the
//                                 struct pointed to by pMMCCallback will not be referenced
//                                 by cryptui.dll after the callback has been made to MMC.
//                                 this will allow the original caller of
//                                 CryptUIGetCertificatePropertiesPages to free the struct
//                                 pointed to by pMMCCallback in the actual callback.
//      szTitle                    title for the window                                     (OPTIONAL)
//      pMMCCallback               this structure is used to callback MMC if properties     (OPTIONAL)
//                                 have changed
// pCertContext                    the cert context that is to be displayed
// pPropPageCallback               this callback will be called when each page that is      (OPTIONAL)
//                                 returned in the CryptUIGetCertificatePropertiesPages call
//                                 is about to be created or destroyed.  if this is NULL no
//                                 callback is made.  Note that this is not used if
//                                 CryptUIDlgViewCertificateProperties is called
// pvCallbackData                  this is uniterpreted data that is passed back when the   (OPTIONAL)
//                                 when pPropPageCallback is made
// cStores                         Count of other stores to search when building and        (OPTIONAL)
//                                 validating chain
// rghStores                       Array of other stores to search when buliding and        (OPTIONAL)
//                                 validating chain
// cPropSheetPages                 number of extra pages to add to the dialog               (OPTIONAL)
// rgPropSheetPages                extra pages to add to the dialog                         (OPTIONAL)
//
/////////////////////////////////////////////////////////////////////////////////////////////////////

typedef struct tagCRYPTUI_VIEWCERTIFICATEPROPERTIES_STRUCTW {
    DWORD                   dwSize;
    HWND                    hwndParent;         // OPTIONAL
    DWORD                   dwFlags;            // OPTIONAL
    union
    {
        LPCWSTR                     szTitle;    // OPTIONAL
        PCRYPTUI_MMCCALLBACK_STRUCT pMMCCallback;// OPTIONAL
    };
    PCCERT_CONTEXT          pCertContext;
    PFNCPROPPAGECALLBACK    pPropPageCallback;  // OPTIONAL
    void *                  pvCallbackData;     // OPTIONAL
    DWORD                   cStores;            // OPTIONAL
    HCERTSTORE *            rghStores;          // OPTIONAL
    DWORD                   cPropSheetPages;    // OPTIONAL
    LPCPROPSHEETPAGEW       rgPropSheetPages;   // OPTIONAL
} CRYPTUI_VIEWCERTIFICATEPROPERTIES_STRUCTW, *PCRYPTUI_VIEWCERTIFICATEPROPERTIES_STRUCTW;
typedef const CRYPTUI_VIEWCERTIFICATEPROPERTIES_STRUCTW *PCCRYPTUI_VIEWCERTIFICATEPROPERTIES_STRUCTW;

typedef struct tagCRYPTUI_VIEWCERTIFICATEPROPERTIES_STRUCTA {
    DWORD                   dwSize;
    HWND                    hwndParent;         // OPTIONAL
    DWORD                   dwFlags;            // OPTIONAL
    union
    {
        LPCSTR                      szTitle;    // OPTIONAL
        PCRYPTUI_MMCCALLBACK_STRUCT pMMCCallback;// OPTIONAL
    };
    PCCERT_CONTEXT          pCertContext;
    PFNCPROPPAGECALLBACK    pPropPageCallback;  // OPTIONAL
    void *                  pvCallbackData;     // OPTIONAL
    DWORD                   cStores;            // OPTIONAL
    HCERTSTORE *            rghStores;          // OPTIONAL
    DWORD                   cPropSheetPages;    // OPTIONAL
    LPCPROPSHEETPAGEA       rgPropSheetPages;   // OPTIONAL
} CRYPTUI_VIEWCERTIFICATEPROPERTIES_STRUCTA, *PCRYPTUI_VIEWCERTIFICATEPROPERTIES_STRUCTA;
typedef const CRYPTUI_VIEWCERTIFICATEPROPERTIES_STRUCTA *PCCRYPTUI_VIEWCERTIFICATEPROPERTIES_STRUCTA;

// pfPropertiesChanged             this will be set by the dialog proc to inform the caller
//                                 if any properties have been changed on certs in the chain
//                                 while the dialog was open
BOOL
WINAPI
CryptUIDlgViewCertificatePropertiesW(
            IN  PCCRYPTUI_VIEWCERTIFICATEPROPERTIES_STRUCTW pcsp,
            OUT BOOL                                        *pfPropertiesChanged  // OPTIONAL
            );

BOOL
WINAPI
CryptUIDlgViewCertificatePropertiesA(
            IN  PCCRYPTUI_VIEWCERTIFICATEPROPERTIES_STRUCTA pcsp,
            OUT BOOL                                        *pfPropertiesChanged  // OPTIONAL
            );


// NOTE!!   when calling this function, the following parameters of the
//          CRYPTUI_VIEWCERTIFICATEPROPERTIES_STRUCT struct are unused
//              cPropSheetPages
//              rgPropSheetPages
BOOL
WINAPI
CryptUIGetCertificatePropertiesPagesW(
            IN  PCCRYPTUI_VIEWCERTIFICATEPROPERTIES_STRUCTW pcsp,
            OUT BOOL                                        *pfPropertiesChanged,  // OPTIONAL
            OUT PROPSHEETPAGEW                              **prghPropPages,
            OUT DWORD                                       *pcPropPages
            );

BOOL
WINAPI
CryptUIGetCertificatePropertiesPagesA(
            IN  PCCRYPTUI_VIEWCERTIFICATEPROPERTIES_STRUCTA pcsp,
            OUT BOOL                                         *pfPropertiesChanged,  // OPTIONAL
            OUT PROPSHEETPAGEA                               **prghPropPages,
            OUT DWORD                                        *pcPropPages
            );

BOOL
WINAPI
CryptUIFreeCertificatePropertiesPagesW(
            IN PROPSHEETPAGEW   *rghPropPages,
            IN DWORD            cPropPages
            );

BOOL
WINAPI
CryptUIFreeCertificatePropertiesPagesA(
            IN PROPSHEETPAGEA   *rghPropPages,
            IN DWORD            cPropPages
            );

#ifdef UNICODE
#define CryptUIDlgViewCertificateProperties         CryptUIDlgViewCertificatePropertiesW
#define PCRYPTUI_VIEWCERTIFICATEPROPERTIES_STRUCT   PCRYPTUI_VIEWCERTIFICATEPROPERTIES_STRUCTW
#define CRYPTUI_VIEWCERTIFICATEPROPERTIES_STRUCT    CRYPTUI_VIEWCERTIFICATEPROPERTIES_STRUCTW
#define PCCRYPTUI_VIEWCERTIFICATEPROPERTIES_STRUCT  PCCRYPTUI_VIEWCERTIFICATEPROPERTIES_STRUCTW
#define CryptUIGetCertificatePropertiesPages        CryptUIGetCertificatePropertiesPagesW
#define CryptUIFreeCertificatePropertiesPages       CryptUIFreeCertificatePropertiesPagesW
#else
#define CryptUIDlgViewCertificateProperties         CryptUIDlgViewCertificatePropertiesA
#define PCRYPTUI_VIEWCERTIFICATEPROPERTIES_STRUCT   PCRYPTUI_VIEWCERTIFICATEPROPERTIES_STRUCTA
#define CRYPTUI_VIEWCERTIFICATEPROPERTIES_STRUCT    CRYPTUI_VIEWCERTIFICATEPROPERTIES_STRUCTA
#define PCCRYPTUI_VIEWCERTIFICATEPROPERTIES_STRUCT  PCCRYPTUI_VIEWCERTIFICATEPROPERTIES_STRUCTA
#define CryptUIGetCertificatePropertiesPages        CryptUIGetCertificatePropertiesPagesA
#define CryptUIFreeCertificatePropertiesPages       CryptUIFreeCertificatePropertiesPagesA
#endif

//
// The certificate properties property sheet dialog is extensible via a callback mechanism.
// A client needs to register their callback using CryptRegisterDefaultOIDFunction, and,
// if they need to unregister it they should use CryptUnregisterDefaultOIDFunction.
// The form for calling these functions is given below
//
// CryptRegisterDefaultOIDFunction(
//            0,
//            CRYPTUILDLG_CERTPROP_PAGES_CALLBACK,
//            CRYPT_REGISTER_FIRST_INDEX,
//            L"c:\\fully qualified path\\dll_being_registered.dll");  <<----- your dll name
//
// CryptUnregisterDefaultOIDFunction(
//            0,
//            CRYPTUILDLG_CERTPROP_PAGES_CALLBACK,
//            L"c:\\fully qualified path\\dll_being_registered.dll");  <<----- your dll name
//
// NOTE: Per the documentation on CryptRegisterDefaultOIDFunction in wincrypt.h,
//       the dll name may contain environment-variable strings
//       which are ExpandEnvironmentStrings()'ed before loading the Dll.
//
#define MAX_CLIENT_PAGES 20
#define CRYPTUILDLG_CERTPROP_PAGES_CALLBACK "CryptUIDlgClientCertPropPagesCallback"

//
//
// The typedef for the callback function which resides in the registered dll is given
// below.  Note that the callback must have the name #defined by
// CRYPTUILDLG_CERTPROP_PAGES_CALLBACK
//
// pCertContext - The certificate for which the properties are being displayed.
// rgPropPages  - An array of PropSheetPageW structures that are to be filled in by
//                the client with the property pages to be shown.
// pcPropPages  - A pointer to a DWORD that on input contains the maximum number of
//                PropSheetPages the client may supply, and on output must have been
//                filled in by the client with the number of pages they supplied in
//                rgPropPages.
//
// Return Value:  The client should return TRUE if they wish to show extra property pages,
//                in this case pcPropPages must >= 1 and rgPropPages must have the
//                corresponding number of pages.  or, return FALSE if no pages are suplied.
typedef BOOL (WINAPI *PFN_CRYPTUIDLG_CERTPROP_PAGES_CALLBACK)
        (IN     PCCERT_CONTEXT pCertContext,
         OUT    PROPSHEETPAGEW *rgPropPages,
         IN OUT DWORD *pcPropPages);


/////////////////////////////////////////////////////////////////////////////////////////////////////


/////////////////////////////////////////////////////////////////////////////////////////////////////
//
// dwSize                          size of this struct
// hwndParent                      parent of this dialog                                    (OPTIONAL)
// dwFlags                         flags, may a combination of any of the flags below
// szTitle                         title for the window                                     (OPTIONAL)
// pCTLContext                     the ctl context that is to be displayed
// cCertSearchStores;              count of other stores to search for the certs contained  (OPTIONAL)
//                                 in the ctl
// rghCertSearchStores;            array of other stores to search for the certs contained  (OPTIONAL)
//                                 in the ctl
// cStores                         Count of other stores to search when building and        (OPTIONAL)
//                                 validating chain of the cert which signed the ctl
//                                 and the certs contained in the ctl
// rghStores                       Array of other stores to search when buliding and        (OPTIONAL)
//                                 validating chain of the cert which signed the ctl
//                                 and the certs contained in the ctl
// cPropSheetPages                 number of extra pages to add to the dialog               (OPTIONAL)
// rgPropSheetPages                extra pages to add to the dialog                         (OPTIONAL)
//
/////////////////////////////////////////////////////////////////////////////////////////////////////

// dwFlags
#define CRYPTUI_HIDE_TRUSTLIST_PAGE        0x00000001

typedef struct tagCRYPTUI_VIEWCTL_STRUCTW {
    DWORD               dwSize;
    HWND                hwndParent;         // OPTIONAL
    DWORD               dwFlags;            // OPTIONAL
    LPCWSTR             szTitle;            // OPTIONAL
    PCCTL_CONTEXT       pCTLContext;
    DWORD               cCertSearchStores;  // OPTIONAL
    HCERTSTORE *        rghCertSearchStores;// OPTIONAL
    DWORD               cStores;            // OPTIONAL
    HCERTSTORE *        rghStores;          // OPTIONAL
    DWORD               cPropSheetPages;    // OPTIONAL
    LPCPROPSHEETPAGEW   rgPropSheetPages;   // OPTIONAL
} CRYPTUI_VIEWCTL_STRUCTW, *PCRYPTUI_VIEWCTL_STRUCTW;
typedef const CRYPTUI_VIEWCTL_STRUCTW *PCCRYPTUI_VIEWCTL_STRUCTW;

typedef struct tagCRYPTUI_VIEWCTL_STRUCTA {
    DWORD               dwSize;
    HWND                hwndParent;         // OPTIONAL
    DWORD               dwFlags;            // OPTIONAL
    LPCSTR              szTitle;            // OPTIONAL
    PCCTL_CONTEXT       pCTLContext;
    DWORD               cCertSearchStores;  // OPTIONAL
    HCERTSTORE *        rghCertSearchStores;// OPTIONAL
    DWORD               cStores;            // OPTIONAL
    HCERTSTORE *        rghStores;          // OPTIONAL
    DWORD               cPropSheetPages;    // OPTIONAL
    LPCPROPSHEETPAGEA   rgPropSheetPages;   // OPTIONAL
} CRYPTUI_VIEWCTL_STRUCTA, *PCRYPTUI_VIEWCTL_STRUCTA;
typedef const CRYPTUI_VIEWCTL_STRUCTA *PCCRYPTUI_VIEWCTL_STRUCTA;

BOOL
WINAPI
CryptUIDlgViewCTLW(
            IN PCCRYPTUI_VIEWCTL_STRUCTW pcvctl
            );

BOOL
WINAPI
CryptUIDlgViewCTLA(
            IN PCCRYPTUI_VIEWCTL_STRUCTA pcvctl
            );

#ifdef UNICODE
#define CryptUIDlgViewCTL           CryptUIDlgViewCTLW
#define PCRYPTUI_VIEWCTL_STRUCT     PCRYPTUI_VIEWCTL_STRUCTW
#define CRYPTUI_VIEWCTL_STRUCT      CRYPTUI_VIEWCTL_STRUCTW
#define PCCRYPTUI_VIEWCTL_STRUCT    PCCRYPTUI_VIEWCTL_STRUCTW
#else
#define CryptUIDlgViewCTL           CryptUIDlgViewCTLA
#define PCRYPTUI_VIEWCTL_STRUCT     PCRYPTUI_VIEWCTL_STRUCTA
#define CRYPTUI_VIEWCTL_STRUCT      CRYPTUI_VIEWCTL_STRUCTA
#define PCCRYPTUI_VIEWCTL_STRUCT    PCCRYPTUI_VIEWCTL_STRUCTA
#endif

/////////////////////////////////////////////////////////////////////////////////////////////////////


/////////////////////////////////////////////////////////////////////////////////////////////////////
//
// dwSize                          size of this struct
// hwndParent                      parent of this dialog                                    (OPTIONAL)
// dwFlags                         flags, may a combination of any of the flags below
// szTitle                         title for the window                                     (OPTIONAL)
// pCTLContext                     the ctl context that is to be displayed
// cStores                         count of other stores to search for the cert which       (OPTIONAL)
//                                 signed the crl and to build and validate the
//                                 cert's chain
// rghStores                       array of other stores to search for the cert which       (OPTIONAL)
//                                 signed the crl and to build and validate the
//                                 cert's chain
// cPropSheetPages                 number of extra pages to add to the dialog               (OPTIONAL)
// rgPropSheetPages                extra pages to add to the dialog                         (OPTIONAL)
//
/////////////////////////////////////////////////////////////////////////////////////////////////////

// dwFlags
#define CRYPTUI_HIDE_REVOCATIONLIST_PAGE   0x00000001

typedef struct tagCRYPTUI_VIEWCRL_STRUCTW {
    DWORD               dwSize;
    HWND                hwndParent;         // OPTIONAL
    DWORD               dwFlags;            // OPTIONAL
    LPCWSTR             szTitle;            // OPTIONAL
    PCCRL_CONTEXT       pCRLContext;
    DWORD               cStores;            // OPTIONAL
    HCERTSTORE *        rghStores;          // OPTIONAL
    DWORD               cPropSheetPages;    // OPTIONAL
    LPCPROPSHEETPAGEW   rgPropSheetPages;   // OPTIONAL
} CRYPTUI_VIEWCRL_STRUCTW, *PCRYPTUI_VIEWCRL_STRUCTW;
typedef const CRYPTUI_VIEWCRL_STRUCTW *PCCRYPTUI_VIEWCRL_STRUCTW;

typedef struct tagCRYPTUI_VIEWCRL_STRUCTA {
    DWORD               dwSize;
    HWND                hwndParent;         // OPTIONAL
    DWORD               dwFlags;            // OPTIONAL
    LPCSTR              szTitle;            // OPTIONAL
    PCCRL_CONTEXT       pCRLContext;
    DWORD               cStores;            // OPTIONAL
    HCERTSTORE *        rghStores;          // OPTIONAL
    DWORD               cPropSheetPages;    // OPTIONAL
    LPCPROPSHEETPAGEA   rgPropSheetPages;   // OPTIONAL
} CRYPTUI_VIEWCRL_STRUCTA, *PCRYPTUI_VIEWCRL_STRUCTA;
typedef const CRYPTUI_VIEWCRL_STRUCTA *PCCRYPTUI_VIEWCRL_STRUCTA;

BOOL
WINAPI
CryptUIDlgViewCRLW(
            IN PCCRYPTUI_VIEWCRL_STRUCTW pcvcrl
            );

BOOL
WINAPI
CryptUIDlgViewCRLA(
            IN PCCRYPTUI_VIEWCRL_STRUCTA pcvcrl
            );

#ifdef UNICODE
#define CryptUIDlgViewCRL           CryptUIDlgViewCRLW
#define PCRYPTUI_VIEWCRL_STRUCT     PCRYPTUI_VIEWCRL_STRUCTW
#define CRYPTUI_VIEWCRL_STRUCT      CRYPTUI_VIEWCRL_STRUCTW
#define PCCRYPTUI_VIEWCRL_STRUCT    PCCRYPTUI_VIEWCRL_STRUCTW
#else
#define CryptUIDlgViewCRL           CryptUIDlgViewCRLA
#define PCRYPTUI_VIEWCRL_STRUCT     PCRYPTUI_VIEWCRL_STRUCTA
#define CRYPTUI_VIEWCRL_STRUCT      CRYPTUI_VIEWCRL_STRUCTA
#define PCCRYPTUI_VIEWCRL_STRUCT    PCCRYPTUI_VIEWCRL_STRUCTA
#endif
/////////////////////////////////////////////////////////////////////////////////////////////////////


/////////////////////////////////////////////////////////////////////////////////////////////////////
//
// dwSize                          size of this struct
// hwndParent                      parent of this dialog                                    (OPTIONAL)
// dwFlags                         flags, may a combination of any of the flags below
// szTitle                         title for the window                                     (OPTIONAL)
// pSignerInfo                     the signer info struct that is to be displayed
// hMsg                            the HCRYPTMSG that the signer info was extracted from
// pszOID                          an OID that signifies what the certificate that did the  (OPTIONAL)
//                                 signing whould be validated for.  for instance if this is
//                                 being called to view the signature of a CTL the
//                                 szOID_KP_CTL_USAGE_SIGNING OID should be passed in.
//                                 if this is NULL then the certificate is only validated
//                                 cryptographicaly and not for usages.
// dwReserved                      reserved for future use and must be set to NULL
// cStores                         count of other stores to search for the cert which       (OPTIONAL)
//                                 did the signing and to build and validate the
//                                 cert's chain
// rghStores                       array of other stores to search for the cert which       (OPTIONAL)
//                                 did the signing and to build and validate the
//                                 cert's chain
// cPropSheetPages                 number of extra pages to add to the dialog               (OPTIONAL)
// rgPropSheetPages                extra pages to add to the dialog                         (OPTIONAL)
//
/////////////////////////////////////////////////////////////////////////////////////////////////////

// dwFlags
#define CRYPTUI_HIDE_TRUSTLIST_PAGE        0x00000001

typedef struct tagCRYPTUI_VIEWSIGNERINFO_STRUCTW {
    DWORD                   dwSize;
    HWND                    hwndParent;         // OPTIONAL
    DWORD                   dwFlags;            // OPTIONAL
    LPCWSTR                 szTitle;            // OPTIONAL
    CMSG_SIGNER_INFO const *pSignerInfo;
    HCRYPTMSG               hMsg;
    LPCSTR                  pszOID;             // OPTIONAL
    DWORD_PTR               dwReserved;
    DWORD                   cStores;            // OPTIONAL
    HCERTSTORE             *rghStores;          // OPTIONAL
    DWORD                   cPropSheetPages;    // OPTIONAL
    LPCPROPSHEETPAGEW       rgPropSheetPages;   // OPTIONAL
} CRYPTUI_VIEWSIGNERINFO_STRUCTW, *PCRYPTUI_VIEWSIGNERINFO_STRUCTW;
typedef const CRYPTUI_VIEWSIGNERINFO_STRUCTW *PCCRYPTUI_VIEWSIGNERINFO_STRUCTW;

typedef struct tagCRYPTUI_VIEWSIGNERINFO_STRUCTA {
    DWORD                   dwSize;
    HWND                    hwndParent;         // OPTIONAL
    DWORD                   dwFlags;            // OPTIONAL
    LPCSTR                  szTitle;            // OPTIONAL
    CMSG_SIGNER_INFO const *pSignerInfo;
    HCRYPTMSG               hMsg;
    LPCSTR                  pszOID;             // OPTIONAL
    DWORD_PTR               dwReserved;
    DWORD                   cStores;            // OPTIONAL
    HCERTSTORE             *rghStores;          // OPTIONAL
    DWORD                   cPropSheetPages;    // OPTIONAL
    LPCPROPSHEETPAGEA       rgPropSheetPages;   // OPTIONAL
} CRYPTUI_VIEWSIGNERINFO_STRUCTA, *PCRYPTUI_VIEWSIGNERINFO_STRUCTA;
typedef const CRYPTUI_VIEWSIGNERINFO_STRUCTA *PCCRYPTUI_VIEWSIGNERINFO_STRUCTA;

BOOL
WINAPI
CryptUIDlgViewSignerInfoW(
            IN PCCRYPTUI_VIEWSIGNERINFO_STRUCTW pcvsi
            );

BOOL
WINAPI
CryptUIDlgViewSignerInfoA(
            IN PCCRYPTUI_VIEWSIGNERINFO_STRUCTA pcvsi
            );

#ifdef UNICODE
#define CryptUIDlgViewSignerInfo        CryptUIDlgViewSignerInfoW
#define PCRYPTUI_VIEWSIGNERINFO_STRUCT  PCRYPTUI_VIEWSIGNERINFO_STRUCTW
#define CRYPTUI_VIEWSIGNERINFO_STRUCT   CRYPTUI_VIEWSIGNERINFO_STRUCTW
#define PCCRYPTUI_VIEWSIGNERINFO_STRUCT PCCRYPTUI_VIEWSIGNERINFO_STRUCTW
#else
#define CryptUIDlgViewSignerInfo        CryptUIDlgViewSignerInfoA
#define PCRYPTUI_VIEWSIGNERINFO_STRUCT  PCRYPTUI_VIEWSIGNERINFO_STRUCTA
#define CRYPTUI_VIEWSIGNERINFO_STRUCT   CRYPTUI_VIEWSIGNERINFO_STRUCTA
#define PCCRYPTUI_VIEWSIGNERINFO_STRUCT PCCRYPTUI_VIEWSIGNERINFO_STRUCTA
#endif
/////////////////////////////////////////////////////////////////////////////////////////////////////


/////////////////////////////////////////////////////////////////////////////////////////////////////
//
// dwSize                          size of this struct
// hwndParent                      parent of this dialog                                    (OPTIONAL)
// dwFlags                         flags, must be set to 0
// szTitle                         title for the window                                     (OPTIONAL)
// choice                          the form of the message that is to have its signers displayed
// u                               either an encoded message or a message handle
//          EncodedMessage         a data blob which contains a pointer to the encoded data
//                                 and the count of encoded bytes
//          hMsg                   a message handle
// szFileName                      the fully qualified file name, should be passed in if    (OPTIONAL)
//                                 signatures on a file are being viewed
// pPropPageCallback               this callback will be called when each page that is      (OPTIONAL)
//                                 returned in the CryptUIGetViewSignaturesPages call
//                                 is about to be created or destroyed.  if this is NULL no
//                                 callback is made.
// pvCallbackData                  this is uniterpreted data that is passed back when the   (OPTIONAL)
//                                 when pPropPageCallback is made
// cStores                         count of other stores to search for the cert which       (OPTIONAL)
//                                 did the signing and to build and validate the
//                                 cert's chain
// rghStores                       array of other stores to search for the cert which       (OPTIONAL)
//                                 did the signing and to build and validate the
//                                 cert's chain
// cPropSheetPages                 number of extra pages to add to the dialog               (OPTIONAL)
// rgPropSheetPages                extra pages to add to the dialog                         (OPTIONAL)
//
/////////////////////////////////////////////////////////////////////////////////////////////////////

// for the coice field of the CRYPTUI_VIEWSIGNATURES_STRUCT structure
#define EncodedMessage_Chosen   1
#define hMsg_Chosen             2

typedef struct tagCRYPTUI_VIEWSIGNATURES_STRUCTW {
    DWORD                   dwSize;
    HWND                    hwndParent;         // OPTIONAL
    DWORD                   dwFlags;            // OPTIONAL
    LPCWSTR                 szTitle;            // OPTIONAL
    unsigned short          choice;
    union {
        CRYPT_DATA_BLOB     EncodedMessage;
        HCRYPTMSG           hMsg;
    } u;
    LPCWSTR                 szFileName;         // OPTIONAL
    PFNCPROPPAGECALLBACK    pPropPageCallback;  // OPTIONAL
    void *                  pvCallbackData;     // OPTIONAL
    DWORD                   cStores;            // OPTIONAL
    HCERTSTORE *            rghStores;          // OPTIONAL
    DWORD                   cPropSheetPages;    // OPTIONAL
    LPCPROPSHEETPAGEW       rgPropSheetPages;   // OPTIONAL
} CRYPTUI_VIEWSIGNATURES_STRUCTW, *PCRYPTUI_VIEWSIGNATURES_STRUCTW;
typedef const CRYPTUI_VIEWSIGNATURES_STRUCTW *PCCRYPTUI_VIEWSIGNATURES_STRUCTW;

typedef struct tagCRYPTUI_VIEWSIGNATURES_STRUCTA {
    DWORD                   dwSize;
    HWND                    hwndParent;         // OPTIONAL
    DWORD                   dwFlags;            // OPTIONAL
    LPCSTR                  szTitle;            // OPTIONAL
    unsigned short          choice;
    union {
        CRYPT_DATA_BLOB     EncodedMessage;
        HCRYPTMSG           hMsg;
    } u;
    LPCSTR                  szFileName;         // OPTIONAL
    PFNCPROPPAGECALLBACK    pPropPageCallback;  // OPTIONAL
    void *                  pvCallbackData;     // OPTIONAL
    DWORD                   cStores;            // OPTIONAL
    HCERTSTORE *            rghStores;          // OPTIONAL
    DWORD                   cPropSheetPages;    // OPTIONAL
    LPCPROPSHEETPAGEA       rgPropSheetPages;   // OPTIONAL
} CRYPTUI_VIEWSIGNATURES_STRUCTA, *PCRYPTUI_VIEWSIGNATURES_STRUCTA;
typedef const CRYPTUI_VIEWSIGNATURES_STRUCTA *PCCRYPTUI_VIEWSIGNATURES_STRUCTA;


// NOTE!!   when calling this function, the following parameters of the
//          CRYPTUI_VIEWSIGNATURES_STRUCT struct are unused
//              cPropSheetPages
//              rgPropSheetPages
//              szTitle
BOOL
WINAPI
CryptUIGetViewSignaturesPagesW(
            IN  PCCRYPTUI_VIEWSIGNATURES_STRUCTW    pcvs,
            OUT PROPSHEETPAGEW                      **prghPropPages,
            OUT DWORD                               *pcPropPages
            );

BOOL
WINAPI
CryptUIGetViewSignaturesPagesA(
            IN  PCCRYPTUI_VIEWSIGNATURES_STRUCTA    pcvs,
            OUT PROPSHEETPAGEA                      **prghPropPages,
            OUT DWORD                               *pcPropPages
            );

BOOL
WINAPI
CryptUIFreeViewSignaturesPagesW(
            IN PROPSHEETPAGEW  *rghPropPages,
            IN DWORD           cPropPages
            );

BOOL
WINAPI
CryptUIFreeViewSignaturesPagesA(
            IN PROPSHEETPAGEA  *rghPropPages,
            IN DWORD           cPropPages
            );

#ifdef UNICODE
#define CryptUIGetViewSignaturesPages   CryptUIGetViewSignaturesPagesW
#define CryptUIFreeViewSignaturesPages  CryptUIFreeViewSignaturesPagesW
#define PCRYPTUI_VIEWSIGNATURES_STRUCT  PCRYPTUI_VIEWSIGNATURES_STRUCTW
#define CRYPTUI_VIEWSIGNATURES_STRUCT   CRYPTUI_VIEWSIGNATURES_STRUCTW
#define PCCRYPTUI_VIEWSIGNATURES_STRUCT PCCRYPTUI_VIEWSIGNATURES_STRUCTW
#else
#define CryptUIGetViewSignaturesPages   CryptUIGetViewSignaturesPagesA
#define CryptUIFreeViewSignaturesPages  CryptUIFreeViewSignaturesPagesA
#define PCRYPTUI_VIEWSIGNATURES_STRUCT  PCRYPTUI_VIEWSIGNATURES_STRUCTA
#define CRYPTUI_VIEWSIGNATURES_STRUCT   CRYPTUI_VIEWSIGNATURES_STRUCTA
#define PCCRYPTUI_VIEWSIGNATURES_STRUCT PCCRYPTUI_VIEWSIGNATURES_STRUCTA
#endif


/////////////////////////////////////////////////////////////////////////////////////////////////////
//
//  the select store dialog can be passed a callback which is called to validate the store that the
//  user selected.  Return TRUE to accept the store, or FALSE to reject the store.  It TRUE is
//  returned then the store will be returned to the caller of CryptUIDlg\, if FALSE is returned
//  then the select store dialog will remain displayed so the user may make another selection

typedef BOOL (WINAPI * PFNCVALIDATESTOREPROC)(
        HCERTSTORE  hStore,
        HWND        hWndSelectStoreDialog,
        void        *pvCallbackData);

/////////////////////////////////////////////////////////////////////////////////////////////////////
//      these two parameters are passed to the CertEnumSystemStore call and the stores that are
//      enumerated via that call are added to the store selection list.
//
//      dwFlags                    CertEnumSystemStore
//      pvSystemStoreLocationPara  CertEnumSystemStore
typedef struct _STORENUMERATION_STRUCT {
    DWORD               dwFlags;
    void *              pvSystemStoreLocationPara;
} STORENUMERATION_STRUCT, *PSTORENUMERATION_STRUCT;
typedef const STORENUMERATION_STRUCT *PCSTORENUMERATION_STRUCT;

/////////////////////////////////////////////////////////////////////////////////////////////////////
//      both the array of store handles and the array of enumeration strucs may be used to
//      populate the store selection list.  if either is not used the count must be set to 0.
//      if the array of store handles is used the cert stores must have either been opened
//      with the CERT_STORE_SET_LOCALIZED_NAME_FLAG flag, or the CertSetStoreProperty function
//      must have been called with the CERT_STORE_LOCALIZED_NAME_PROP_ID flag.  if the
//      CryptUIDlgSelectStore function is unable to obtain a name for a store that store will not
//      be displayed.
//
//      cStores                    count of stores to select from
//      rghStores                  array of stores to select from
//      cEnumerationStructs        count of enumeration structs
//      rgEnumerationStructs       array of enumeration structs
typedef struct _STORESFORSELCTION_STRUCT {
    DWORD                       cStores;
    HCERTSTORE *                rghStores;
    DWORD                       cEnumerationStructs;
    PCSTORENUMERATION_STRUCT    rgEnumerationStructs;
} STORESFORSELCTION_STRUCT, *PSTORESFORSELCTION_STRUCT;
typedef const STORESFORSELCTION_STRUCT *PCSTORESFORSELCTION_STRUCT;

/////////////////////////////////////////////////////////////////////////////////////////////////////
//
// dwSize                          size of this struct
// hwndParent                      parent of this dialog                                    (OPTIONAL)
// dwFlags                         flags, may a combination of any of the flags below
// szTitle                         title of the dialog                                      (OPTIONAL)
// szDisplayString                 a string that will be displayed in the dialog that may   (OPTIONAL)
//                                 be used to infor the user what they are selecting a store
//                                 for.  if it is not set a default string will be displayed,
//                                 the default resource is IDS_SELECT_STORE_DEFAULT
// pStoresForSelection             a struct that contains the stores that are to be selected
//                                 from.  the stores can be in two different formats, an array
//                                 of store handles and/or an array of enumeration structs
//                                 which will be used to call CertEnumSystemStore
// pValidateStoreCallback          a pointer to a PFNCVALIDATESTOREPROC which is used to    (OPTIONAL)
//                                 callback the caller of CryptUIDlgSelectStore when the
//                                 user hasselected a store and pressed OK
// pvCallbackData                  if pValidateStoreCallback is being used this value is    (OPTIONAL)
//                                 passed back to the caller when the pValidateStoreCallback
//                                 is made
//
/////////////////////////////////////////////////////////////////////////////////////////////////////

// dwFlags
#define CRYPTUI_ALLOW_PHYSICAL_STORE_VIEW       0x00000001
#define CRYPTUI_RETURN_READ_ONLY_STORE          0x00000002
#define CRYPTUI_DISPLAY_WRITE_ONLY_STORES       0x00000004
#define CRYPTUI_VALIDATE_STORES_AS_WRITABLE     0x00000008

typedef struct tagCRYPTUI_SELECTSTORE_STRUCTW {
    DWORD                       dwSize;
    HWND                        hwndParent;             // OPTIONAL
    DWORD                       dwFlags;                // OPTIONAL
    LPCWSTR                     szTitle;                // OPTIONAL
    LPCWSTR                     szDisplayString;        // OPTIONAL
    PCSTORESFORSELCTION_STRUCT  pStoresForSelection;
    PFNCVALIDATESTOREPROC       pValidateStoreCallback; // OPTIONAL
    void *                      pvCallbackData;         // OPTIONAL
} CRYPTUI_SELECTSTORE_STRUCTW, *PCRYPTUI_SELECTSTORE_STRUCTW;
typedef const CRYPTUI_SELECTSTORE_STRUCTW *PCCRYPTUI_SELECTSTORE_STRUCTW;

typedef struct tagCRYPTUI_SELECTSTORE_STRUCTA {
    DWORD                       dwSize;
    HWND                        hwndParent;             // OPTIONAL
    DWORD                       dwFlags;                // OPTIONAL
    LPCSTR                      szTitle;                // OPTIONAL
    LPCSTR                      szDisplayString;        // OPTIONAL
    PCSTORESFORSELCTION_STRUCT  pStoresForSelection;
    PFNCVALIDATESTOREPROC       pValidateStoreCallback; // OPTIONAL
    void *                      pvCallbackData;         // OPTIONAL
} CRYPTUI_SELECTSTORE_STRUCTA, *PCRYPTUI_SELECTSTORE_STRUCTA;
typedef const CRYPTUI_SELECTSTORE_STRUCTA *PCCRYPTUI_SELECTSTORE_STRUCTA;

//
// the HCERTSTORE that is returned must be closed by calling CertCloseStore
//
HCERTSTORE
WINAPI
CryptUIDlgSelectStoreW(
            IN PCCRYPTUI_SELECTSTORE_STRUCTW pcss
            );

HCERTSTORE
WINAPI
CryptUIDlgSelectStoreA(
            IN PCCRYPTUI_SELECTSTORE_STRUCTA pcss
            );

#ifdef UNICODE
#define CryptUIDlgSelectStore           CryptUIDlgSelectStoreW
#define PCRYPTUI_SELECTSTORE_STRUCT     PCRYPTUI_SELECTSTORE_STRUCTW
#define CRYPTUI_SELECTSTORE_STRUCT      CRYPTUI_SELECTSTORE_STRUCTW
#define PCCRYPTUI_SELECTSTORE_STRUCT    PCCRYPTUI_SELECTSTORE_STRUCTW
#else
#define CryptUIDlgSelectStore           CryptUIDlgSelectStoreA
#define PCRYPTUI_SELECTSTORE_STRUCT     PCRYPTUI_SELECTSTORE_STRUCTA
#define CRYPTUI_SELECTSTORE_STRUCT      CRYPTUI_SELECTSTORE_STRUCTA
#define PCCRYPTUI_SELECTSTORE_STRUCT    PCCRYPTUI_SELECTSTORE_STRUCTA
#endif
/////////////////////////////////////////////////////////////////////////////////////////////////////


/////////////////////////////////////////////////////////////////////////////////////////////////////
//
//  The select cert dialog can be passed a filter proc to reduce the set of certificates
//  displayed.  Return TRUE to display the certificate and FALSE to hide it.  If TRUE is
//  returned then optionally the pfInitialSelectedCert boolean may be set to TRUE to indicate
//  to the dialog that this cert should be the initially selected cert.  Note that the
//  most recent cert that had the pfInitialSelectedCert boolean set during the callback will
//  be the initially selected cert.

typedef BOOL (WINAPI * PFNCFILTERPROC)(
        PCCERT_CONTEXT  pCertContext,
        BOOL            *pfInitialSelectedCert,
        void            *pvCallbackData);

/////////////////////////////////////////////////////////////////////////////////////////////////////
//
//  Certificates may be viewed by the user when selecting certificates from the select certificate
//  dialog.  This callback will allow the caller of the select certificate dialog to handle the
//  displaying of those certificates.  This may be useful if the caller wishes to call WinVerifyTrust
//  with their own policy module and display the certificate with that WinVerifyTrust state.  If
//  FALSE is returned from this callback it is assumed that the select certificate dialog will be
//  responsible for dislaying the certificate in question.  If TRUE is returned it is assumed that the
//  display of the certificate was already handled.

typedef BOOL (WINAPI * PFNCCERTDISPLAYPROC)(
        PCCERT_CONTEXT  pCertContext,
        HWND            hWndSelCertDlg,
        void            *pvCallbackData);

/////////////////////////////////////////////////////////////////////////////////////////////////////
//
// dwSize                          size of this struct
// hwndParent                      parent of this dialog                                    (OPTIONAL)
// dwFlags                         flags:
//                                 CRYPTUI_SELECTCERT_MULTISELECT -
//                                      if this flag is set then CryptUIDlgSelectCertificate
//                                      will return NULL, and the hSelectedCertStore
//                                      parameter must contain a valid store handle that
//                                      will be populated with all the selected certificates.
// dwDontUseColumn                 This can be used to disable the display of certain       (OPTIONAL)
//                                 columns.  It can be set with any comibnation of the
//                                 column flags below
// szTitle                         title of the dialog                                      (OPTIONAL)
// szDisplayString                 a string that will be displayed in the dialog that may   (OPTIONAL)
//                                 be used to inform the user what they are selecting a
//                                 a certificate for.  if it is not set a default string
//                                 will be displayed.  the defualt strings resourece is
//                                 IDS_SELECT_CERT_DEFAULT
// pFilterCallback                 a pointer to a PFNCMFILTERPROC which is used to filter   (OPTIONAL)
//                                 the certificates which are displayed for selection
// pDisplayCallback                a pointer to a PFNCCERTDISPLAYPROC which is used to
//                                 handle displaying certificates
// pvCallbackData                  if either or both pFilterCallback or pDisplayCallback    (OPTIONAL)
//                                 are being used this value is passed back to the caller
//                                 when the callbacks are made
// cDisplayStores                  count of stores that contain the certs to display
//                                 for selection
// rghDisplayStores                array of stores that contain the certs to display
//                                 for selection
// cStores                         count of other stores to search when building chain and  (OPTIONAL)
//                                 validating trust of the certs which are displayed, if
//                                 the user choosing a cert would like to view a particular
//                                 cert which is displayed for selection, these stores
//                                 are passed to the CertViewCert dialog
// rghStores                       array of other stores to search when building chain and  (OPTIONAL)
//                                 validating trust of the certs which are displayed, if
//                                 the user choosing a cert would like to view a particular
//                                 cert which is displayed for selection, these stores
//                                 are passed to the CertViewCert dialog
// cPropSheetPages                 PASS THROUGH - number of pages in rgPropSheetPages array (OPTIONAL)
// rgPropSheetPages                PASS THROUGH - extra pages that are passed through       (OPTIONAL)
//                                 to the certificate viewing dialog when it is invoked from
//                                 the selection dialog
// hSelectedCertStore              This certificate store is passed in by the caller if the (OPTIONAL)
//                                 CRYPTUI_SELECTCERT_MULTISELECT flag is set.  The store
//                                 will contain all the selected certificates on return.
//
/////////////////////////////////////////////////////////////////////////////////////////////////////

// flags for dwDontUseColumn
//
// The following are defined in cryptuiapi.h
// #define CRYPTUI_SELECT_ISSUEDTO_COLUMN        0x000000001
// #define CRYPTUI_SELECT_ISSUEDBY_COLUMN        0x000000002
// #define CRYPTUI_SELECT_INTENDEDUSE_COLUMN     0x000000004
// #define CRYPTUI_SELECT_FRIENDLYNAME_COLUMN    0x000000008
// #define CRYPTUI_SELECT_LOCATION_COLUMN        0x000000010
// #define CRYPTUI_SELECT_EXPIRATION_COLUMN      0x000000020

typedef struct tagCRYPTUI_SELECTCERTIFICATE_STRUCTW {
    DWORD               dwSize;
    HWND                hwndParent;         // OPTIONAL
    DWORD               dwFlags;            // OPTIONAL
    LPCWSTR             szTitle;            // OPTIONAL
    DWORD               dwDontUseColumn;    // OPTIONAL
    LPCWSTR             szDisplayString;    // OPTIONAL
    PFNCFILTERPROC      pFilterCallback;    // OPTIONAL
    PFNCCERTDISPLAYPROC pDisplayCallback;   // OPTIONAL
    void *              pvCallbackData;     // OPTIONAL
    DWORD               cDisplayStores;
    HCERTSTORE *        rghDisplayStores;
    DWORD               cStores;            // OPTIONAL
    HCERTSTORE *        rghStores;          // OPTIONAL
    DWORD               cPropSheetPages;    // OPTIONAL
    LPCPROPSHEETPAGEW   rgPropSheetPages;   // OPTIONAL
    HCERTSTORE          hSelectedCertStore; // OPTIONAL
} CRYPTUI_SELECTCERTIFICATE_STRUCTW, *PCRYPTUI_SELECTCERTIFICATE_STRUCTW;
typedef const CRYPTUI_SELECTCERTIFICATE_STRUCTW *PCCRYPTUI_SELECTCERTIFICATE_STRUCTW;

typedef struct tagCRYPTUI_SELECTCERTIFICATE_STRUCT_A {
    DWORD               dwSize;
    HWND                hwndParent;         // OPTIONAL
    DWORD               dwFlags;            // OPTIONAL
    LPCSTR              szTitle;            // OPTIONAL
    DWORD               dwDontUseColumn;    // OPTIONAL
    LPCSTR              szDisplayString;    // OPTIONAL
    PFNCFILTERPROC      pFilterCallback;    // OPTIONAL
    PFNCCERTDISPLAYPROC pDisplayCallback;   // OPTIONAL
    void *              pvCallbackData;     // OPTIONAL
    DWORD               cDisplayStores;
    HCERTSTORE *        rghDisplayStores;
    DWORD               cStores;            // OPTIONAL
    HCERTSTORE *        rghStores;          // OPTIONAL
    DWORD               cPropSheetPages;    // OPTIONAL
    LPCPROPSHEETPAGEA   rgPropSheetPages;   // OPTIONAL
    HCERTSTORE          hSelectedCertStore; // OPTIONAL
} CRYPTUI_SELECTCERTIFICATE_STRUCTA, *PCRYPTUI_SELECTCERTIFICATE_STRUCTA;
typedef const CRYPTUI_SELECTCERTIFICATE_STRUCTA *PCCRYPTUI_SELECTCERTIFICATE_STRUCTA;

//
// the PCCERT_CONTEXT that is returned must be released by calling CertFreeCertificateContext().
// if NULL is returned and GetLastError() == 0 then the user dismissed the dialog by hitting the
// "cancel" button, otherwise GetLastError() will contain the last error.
//
PCCERT_CONTEXT
WINAPI
CryptUIDlgSelectCertificateW(
            IN PCCRYPTUI_SELECTCERTIFICATE_STRUCTW pcsc
            );

PCCERT_CONTEXT
WINAPI
CryptUIDlgSelectCertificateA(
            IN PCCRYPTUI_SELECTCERTIFICATE_STRUCTA pcsc
            );

#ifdef UNICODE
#define CryptUIDlgSelectCertificate         CryptUIDlgSelectCertificateW
#define PCRYPTUI_SELECTCERTIFICATE_STRUCT   PCRYPTUI_SELECTCERTIFICATE_STRUCTW
#define CRYPTUI_SELECTCERTIFICATE_STRUCT    CRYPTUI_SELECTCERTIFICATE_STRUCTW
#define PCCRYPTUI_SELECTCERTIFICATE_STRUCT  PCCRYPTUI_SELECTCERTIFICATE_STRUCTW
#else
#define CryptUIDlgSelectCertificate         CryptUIDlgSelectCertificateA
#define PCRYPTUI_SELECTCERTIFICATE_STRUCT   PCRYPTUI_SELECTCERTIFICATE_STRUCTA
#define CRYPTUI_SELECTCERTIFICATE_STRUCT    CRYPTUI_SELECTCERTIFICATE_STRUCTA
#define PCCRYPTUI_SELECTCERTIFICATE_STRUCT  PCCRYPTUI_SELECTCERTIFICATE_STRUCTA
#endif

// dwFlags
#define     CRYPTUI_SELECTCERT_MULTISELECT                      0x00000001
#define     CRYPTUI_SELECTCERT_ADDFROMDS                        0x00010000

//flags for dwFlags in CRYPTUI_SELECT_CA_STRUCT struct
#define     CRYPTUI_DLG_SELECT_CA_FROM_NETWORK                  0x0001
#define     CRYPTUI_DLG_SELECT_CA_USE_DN                        0x0002
#define     CRYPTUI_DLG_SELECT_CA_LOCAL_MACHINE_ENUMERATION     0x0004
//-------------------------------------------------------------------------
//
//	CRYPTUI_CA_CONTEXT
//
//-------------------------------------------------------------------------
typedef struct _CRYPTUI_CA_CONTEXT
{
    DWORD                   dwSize;	
    LPCWSTR                 pwszCAName;
    LPCWSTR                 pwszCAMachineName;
}CRYPTUI_CA_CONTEXT, *PCRYPTUI_CA_CONTEXT;

typedef const CRYPTUI_CA_CONTEXT *PCCRYPTUI_CA_CONTEXT;


//-------------------------------------------------------------------------
//
//	
//
//  The select certificate authoritiy (CA) dialog can be passed a filter proc to reduce the set of CAs
//  displayed.  Return TRUE to display the CA and FALSE to hide it.  If TRUE is
//  returned then optionally the pfInitialSelectedCert boolean may be set to TRUE to indicate
//  to the dialog that this CA should be the initially selected CA.  Note that the
//  most recent cert that had the pfInitialSelectedCert boolean set during the callback will
//  be the initially selected CA.
//
//-------------------------------------------------------------------------

typedef BOOL (WINAPI * PFN_CRYPTUI_SELECT_CA_FUNC)(
        PCCRYPTUI_CA_CONTEXT        pCAContext,
        BOOL                        *pfInitialSelected,
        void                        *pvCallbackData);


//-------------------------------------------------------------------------
//
//	CRYPTUI_SELECT_CA_STRUCT
//
//  dwSize	           Required:    Must be set to sizeof(CRYPTUI_SELECT_CA_STRUCT)
//  hwndParent         Optional:    Parent of this dialog
//  dwFlags            Optional:    Flags, Can be set to any combination of the following:
//                                  CRYPTUI_DLG_SELECT_CA_FROM_NETWORK:
//                                     All the available CAs from the network will be displayed
//                                  CRYPTUI_DLG_SELECT_CA_USE_DN:
//                                     Use the full DN (Distinguished Name) as the CA name.
//                                      By default, CN (common name) is used.
//                                  CRYPTUI_DLG_SELECT_CA_LOCAL_MACHINE_ENUMERATION:
//                                      Display the CAs available to the local machine only.
//                                      By Default, CAs available to the current user will be displayed
//  wszTitle           Optional:    Title of the dialog
//  wszDisplayString   Optional:    A string that will be displayed in the dialog that may   (OPTIONAL)
//                                  be used to inform the user what they are selecting a
//                                  a certificate for.  if it is not set a default string
//                                  will be displayed.  the defualt strings resourece is
//                                  IDS_SELECT_CA_DISPLAY_DEFAULT
//  cCAContext         Optional:    The count of additional CA contexts that will be displayed
//                                  in the dialogs
//  *rgCAContext       Optioanl:    The array of additional CA contexts that will be displayed
//                                  in the dialogs
//  pSelectCACallback  Optional:    a pointer to a PCCRYPTUI_CA_CONTEXT which is used to filter
//                                  the certificate autorities which are displayed for selection
//  pvCallbackData     Optional:    if pSelectCACallback is being used this value is passed
//                                  back to the caller when the pSelectCACallback is made
//-------------------------------------------------------------------------
typedef struct _CRYPTUI_SELECT_CA_STRUCT
{
    DWORD                       dwSize;	                    // REQUIRED
    HWND                        hwndParent;                 // OPTIONAL
    DWORD                       dwFlags;                    // OPTIONAL
    LPCWSTR                     wszTitle;                   // OPTIONAL
    LPCWSTR                     wszDisplayString;           // OPTIONAL
    DWORD                       cCAContext;                 // OPTIONAL
    PCCRYPTUI_CA_CONTEXT        *rgCAContext;               // OPTIONAL
    PFN_CRYPTUI_SELECT_CA_FUNC  pSelectCACallback;          // OPTIONAL
    void                        *pvCallbackData;            // OPTIONAL
}CRYPTUI_SELECT_CA_STRUCT, *PCRYPTUI_SELECT_CA_STRUCT;

typedef const CRYPTUI_SELECT_CA_STRUCT *PCCRYPTUI_SELECT_CA_STRUCT;

//--------------------------------------------------------------
//
//  Parameters:
//      pCryptUISelectCA       IN  Required
//
//  the PCCRYPTUI_CA_CONTEXT that is returned must be released by calling
//  CryptUIDlgFreeCAContext
//  if NULL is returned and GetLastError() == 0 then the user dismissed the dialog by hitting the
//  "cancel" button, otherwise GetLastError() will contain the last error.
//
//
//--------------------------------------------------------------
PCCRYPTUI_CA_CONTEXT
WINAPI
CryptUIDlgSelectCA(
        IN PCCRYPTUI_SELECT_CA_STRUCT pCryptUISelectCA
             );

BOOL
WINAPI
CryptUIDlgFreeCAContext(
        IN PCCRYPTUI_CA_CONTEXT       pCAContext
            );




//-------------------------------------------------------------------------
//
//	CRYPTUI_CERT_MGR_STRUCT
//
//  dwSize	           Required:    Must be set to sizeof(CRYPTUI_CERT_MGR_STRUCT)
//  hwndParent         Optional:    Parent of this dialog
//  dwFlags            Optional:    Personal is the default initially selected
//                                  tab.
//                                  CRYPTUI_CERT_MGR_PUBLISHER_TAB may be set
//                                  to select Trusted Publishers as the
//                                  initially selected tab.
//                                  CRYPTUI_CERT_MGR_SINGLE_TAB_FLAG may also
//                                  be set to only display the Trusted
//                                  Publishers tab.
//  wszTitle           Optional:    Title of the dialog
//  pszInitUsageOID    Optional:    The enhanced key usage object identifier (OID).
//                                  Certificates with this OID will initially
//                                  be shown as a default. User
//                                  can then choose different OIDs.
//                                  NULL means all certificates will be shown initially.
//-------------------------------------------------------------------------
typedef struct _CRYPTUI_CERT_MGR_STRUCT
{
    DWORD                       dwSize;	                    // REQUIRED
    HWND                        hwndParent;                 // OPTIONAL
    DWORD                       dwFlags;                    // OPTIONAL
    LPCWSTR                     pwszTitle;                   // OPTIONAL
    LPCSTR                      pszInitUsageOID;            // OPTIONAL
}CRYPTUI_CERT_MGR_STRUCT, *PCRYPTUI_CERT_MGR_STRUCT;

typedef const CRYPTUI_CERT_MGR_STRUCT *PCCRYPTUI_CERT_MGR_STRUCT;

#define CRYPTUI_CERT_MGR_TAB_MASK           0x0000000F
#define CRYPTUI_CERT_MGR_PUBLISHER_TAB      0x00000004

#define CRYPTUI_CERT_MGR_SINGLE_TAB_FLAG    0x00008000

//--------------------------------------------------------------
//
//  Parameters:
//      pCryptUICertMgr       IN  Required
//
//
//--------------------------------------------------------------
BOOL
WINAPI
CryptUIDlgCertMgr(
        IN PCCRYPTUI_CERT_MGR_STRUCT pCryptUICertMgr);



/////////////////////////////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////////////////////////////

//-----------------------------------------------------------------------
//  The valid values for dwFlags for the CryptUIWiz APIs
//
//------------------------------------------------------------------------

#define     CRYPTUI_WIZ_NO_UI                           0x0001
#define     CRYPTUI_WIZ_IGNORE_NO_UI_FLAG_FOR_CSPS      0x0002
#define     CRYPTUI_WIZ_NO_UI_EXCEPT_CSP                0x0003
#define     CRYPTUI_WIZ_ALLOW_ALL_TEMPLATES             0x0004
#define     CRYPTUI_WIZ_ALLOW_ALL_CAS                   0x0008
#define     CRYPTUI_WIZ_CERT_REQUEST_REQUIRE_NEW_KEY    0x0040 // The enrollment API may not reuse an existing private key


//CRYPTUI_WIZ_NO_INSTALL_ROOT is only valid for CryptUIWizCertRequest API
//the wizard will not install the issued certificate chain into the root store,
//instead, it will put the certificate chain into the CA store.
#define     CRYPTUI_WIZ_NO_INSTALL_ROOT                 0x0010


//CRYPTUI_WIZ_BUILDCTL_SKIP_DESTINATION only valid for CryptUIWizBuildCTL API.
//the wizard will skip the page which asks user to enter destination where the CTL will
//be stored.
#define     CRYPTUI_WIZ_BUILDCTL_SKIP_DESTINATION       0x0004


//CRYPTUI_WIZ_BUILDCTL_SKIP_SIGNING only valid for CryptUIWizBuildCTL API.
//the wizard will skip the page which asks user to sign the CTL.
//the CTLContext returned by CryptUIWizBuildCTL will not be signed.
//Caller can then use CryptUIWizDigitalSign to sign the CTL.
#define     CRYPTUI_WIZ_BUILDCTL_SKIP_SIGNING           0x0008

//CRYPTUI_WIZ_BUILDCTL_SKIP_PURPOSE only valid for CryptUIWizBuildCTL API.
//the wizard will skip the page which asks user for the purpose, validity,
//and list ID of the CTL.
#define     CRYPTUI_WIZ_BUILDCTL_SKIP_PURPOSE           0x0010

#define     CRYPTUI_WIZ_NO_ARCHIVE_RENEW_CERT           0x0020

#define CRYPTUI_WIZ_CREATE_ONLY 0x00010000
#define CRYPTUI_WIZ_SUBMIT_ONLY 0x00020000
#define CRYPTUI_WIZ_FREE_ONLY   0x00040000
#define CRYPTUI_WIZ_QUERY_ONLY  0x00080000
#define CRYPTUI_WIZ_NODS_MASK   0x000F0000

///-----------------------------------------------------------------------
//  CRYPTUI_WIZ_CERT_REQUEST_PVK_CERT
//
//------------------------------------------------------------------------
typedef struct _CRYPTUI_WIZ_CERT_REQUEST_PVK_CERT
{
    DWORD           dwSize;             //Required: Set to the sizeof(CRYPTUI_WIZ_CERT_REQUEST_PVK_CERT)
    PCCERT_CONTEXT  pCertContext;       //Required: Use the private key of the certificate context
                                        //          The certificate context
                                        //          has to have CERT_KEY_PROV_INFO_PROP_ID property
                                        //          and the private key has to exist
}CRYPTUI_WIZ_CERT_REQUEST_PVK_CERT, *PCRYPTUI_WIZ_CERT_REQUEST_PVK_CERT;

typedef const CRYPTUI_WIZ_CERT_REQUEST_PVK_CERT *PCCRYPTUI_WIZ_CERT_REQUEST_PVK_CERT;


///-----------------------------------------------------------------------
//  CRYPTUI_WIZ_CERT_REQUEST_PVK_EXISTING
//
//------------------------------------------------------------------------
typedef struct _CRYPTUI_WIZ_CERT_REQUEST_PVK_EXISTING
{
    DWORD                   dwSize;             //Required: Set to the sizeof(CRYPTUI_WIZ_CERT_REQUEST_PVK_EXISTING)
    PCRYPT_KEY_PROV_INFO    pKeyProvInfo;       //Required: The information about the provider and the private key
                                                //          The optional CRYPT_KEY_PROV_PARAM fields in PCRYPT_KEY_PROV_INFO
                                                //          are ignored.
}CRYPTUI_WIZ_CERT_REQUEST_PVK_EXISTING, *PCRYPTUI_WIZ_CERT_REQUEST_PVK_EXISTING;

typedef const CRYPTUI_WIZ_CERT_REQUEST_PVK_EXISTING *PCCRYPTUI_WIZ_CERT_REQUEST_PVK_EXISTING;

///-----------------------------------------------------------------------
//  CERT_REQUEST_PVK_NEW
//
//------------------------------------------------------------------------
typedef struct _CRYPTUI_WIZ_CERT_REQUEST_PVK_NEW
{
    DWORD                   dwSize;             //Required: Set to the sizeof(CRYPTUI_WIZ_CERT_REQUEST_PVK_NEW)
    PCRYPT_KEY_PROV_INFO    pKeyProvInfo;       //Optional: The information about the provider and the private key
                                                //          NULL means use the default
                                                //          The optional CRYPT_KEY_PROV_PARAM fields in PCRYPT_KEY_PROV_INFO
                                                //          are ignored.
    DWORD                   dwGenKeyFlags;      //Optional: The flags for CryptGenKey
}CRYPTUI_WIZ_CERT_REQUEST_PVK_NEW, *PCRYPTUI_WIZ_CERT_REQUEST_PVK_NEW;


typedef const CRYPTUI_WIZ_CERT_REQUEST_PVK_NEW *PCCRYPTUI_WIZ_CERT_REQUEST_PVK_NEW;


///-----------------------------------------------------------------------
//  CRYPTUI_WIZ_CERT_TYPE
//
//------------------------------------------------------------------------
typedef struct _CRYPTUI_WIZ_CERT_TYPE
{
    DWORD                   dwSize;             //Required: Set to the sizeof(CRYPTUI_WIZ_CERT_TYPE)
    DWORD                   cCertType;          //the count of rgwszCertType.  cCertType should be 1.
    LPWSTR                  *rgwszCertType;     //the array of certificate type name
}CRYPTUI_WIZ_CERT_TYPE, *PCRYPTUI_WIZ_CERT_TYPE;

typedef const CRYPTUI_WIZ_CERT_TYPE *PCCRYPTUI_WIZ_CERT_TYPE;


//-----------------------------------------------------------------------
// dwPvkChoice
//-----------------------------------------------------------------------
#define         CRYPTUI_WIZ_CERT_REQUEST_PVK_CHOICE_CERT        1
#define         CRYPTUI_WIZ_CERT_REQUEST_PVK_CHOICE_EXISTING    2
#define         CRYPTUI_WIZ_CERT_REQUEST_PVK_CHOICE_NEW         3

//-----------------------------------------------------------------------
// dwPurpose
//-----------------------------------------------------------------------

#define     CRYPTUI_WIZ_CERT_ENROLL     0x00010000
#define     CRYPTUI_WIZ_CERT_RENEW      0x00020000

//-----------------------------------------------------------------------
//
// valid flags for dwPostOption
//-----------------------------------------------------------------------
//post the requested certificate on the directory serivce
#define     CRYPTUI_WIZ_CERT_REQUEST_POST_ON_DS                     0x01

//post the requested certificate with the private key container.
#define     CRYPTUI_WIZ_CERT_REQUEST_POST_ON_CSP                    0x02


//-----------------------------------------------------------------------
//
// valid flags for dwCertChoice
//-----------------------------------------------------------------------
#define     CRYPTUI_WIZ_CERT_REQUEST_KEY_USAGE                      0x01

#define     CRYPTUI_WIZ_CERT_REQUEST_CERT_TYPE                      0x02
//-------------------------------------------------------------------------
//
//
//  CRYPTUI_WIZ_CERT_REQUEST_INFO
//-------------------------------------------------------------------------
typedef struct _CRYPTUI_WIZ_CERT_REQUEST_INFO
{
	DWORD			    dwSize;				    //Required: Has to be set to sizeof(CRYPTUI_WIZ_CERT_REQUEST_INFO)
    DWORD               dwPurpose;              //Required: If CRYPTUI_WIZ_CERT_ENROLL is set, a certificate will be enrolled,
                                                //          If CRYPTUI_WIZ_CERT_RENEW  is set, a certificate will be renewed.
                                                //          CRYPTUI_WIZ_CERT_ENROLL and CRYPTUI_WIZ_CERT_RENEW can not be set
                                                //          at the same time
    LPCWSTR             pwszMachineName;        //Optional: The machine name for which to enroll.
    LPCWSTR             pwszAccountName;        //Optional: The account name(user or service) for which to enroll
                                                //
                                                //  pwszMachineName     pwszAccountName    Meaning
                                                //---------------------------------------------------
                                                //  NULL                NULL               Request for current account on the current machine
                                                //  "fooMachine"        NULL               Request for the machine named "fooMachine"
                                                //  NULL                "fooUser"          Request for the "fooUser" account on the current machine
                                                //  "fooMachine"        "fooUser"          Request for the "fooUser" accunt on the "fooMachine" machine
                                                //
    void                *pAuthentication;       //Reserved: authenticate info.  Must be set to NULL.
    LPCWSTR             pCertRequestString;     //Reserved: The additional request string.  Must be set to NULL.
    LPCWSTR             pwszDesStore;           //Optional: The desination store where to put
                                                //              the enrolled certificate.  Default to "My" if the value is NULL
    DWORD               dwCertOpenStoreFlag;    //Optional: The value passed to dwFlags of CertOpenStore for the
                                                //          destination store
                                                //          If this value is 0, we use CERT_SYSTEM_STORE_CURRENT_USER for
                                                //          an accout and CERT_SYSTEM_STORE_LOCAL_MACHINE for a machine
    LPCSTR              pszHashAlg;             //Optional: The oid string of the hash algorithm of the certificate.
    PCCERT_CONTEXT      pRenewCertContext;      //Required  if CRYPTUI_WIZ_CERT_RENEW  is set in dwPurpose
                                                //Ignored   otherwise and shoule be set to NULL.
    DWORD               dwPvkChoice;            //Required: Specify the private key information
                                                //            CRYPTUI_WIZ_CERT_REQUEST_PVK_CHOICE_CERT
                                                //            CRYPTUI_WIZ_CERT_REQUEST_PVK_CHOICE_EXISTING
                                                //            CRYPTUI_WIZ_CERT_REQUEST_PVK_CHOICE_NEW
    union                                       //Required.
    {
		PCCRYPTUI_WIZ_CERT_REQUEST_PVK_CERT      pPvkCert;	
        PCCRYPTUI_WIZ_CERT_REQUEST_PVK_EXISTING  pPvkExisting;
        PCCRYPTUI_WIZ_CERT_REQUEST_PVK_NEW       pPvkNew;
    };

    LPCWSTR             pwszCALocation;         //Required  if dwCertChoice==CRYPTUI_WIZ_CERT_REQUEST_KEY_USAGE                                                //Optional  Otherwise
                                                //Optional  Otherwise
                                                //          The machine name of the Certiviate Authority (CA)
    LPCWSTR             pwszCAName;             //Required   if dwCertChoice==CRYPTUI_WIZ_CERT_REQUEST_KEY_USAGE
                                                //Optional  Otherwise
                                                //          The name of the Certificate Authority (CA)
    DWORD               dwPostOption;           //Optional  Can set to any combination of the following flag:
                                                //              CRYPTUI_WIZ_CERT_REQUEST_POST_ON_DS
                                                //
    DWORD               dwCertChoice;           //Optional  if CRYPTUI_WIZ_CERT_ENROLL is set in dwPurpose
                                                //          and CRYPTUI_WIZ_NO_UI is not set
                                                //Required  if CRYPTUI_WIZ_CERT_ENROLL is set in dwPurpose
                                                //          and CRYPTUI_WIZ_NO_UI is set
                                                //ignored   otherwise and should be set to 0.
                                                //          Specify the type of the requested certificate
                                                //          it can be one of the following flag:
                                                //              CRYPTUI_WIZ_CERT_REQUEST_KEY_USAGE
                                                //              CRYPTUI_WIZ_CERT_REQUEST_CERT_TYPE
    union
    {
        PCERT_ENHKEY_USAGE      pKeyUsage;      //          Indicate the enhanced key usage OIDs for the requested certificate.
        PCCRYPTUI_WIZ_CERT_TYPE pCertType;      //          Indicate the certificate type of the requested certificate
    };

    LPCWSTR             pwszFriendlyName;       //Optional  if CRYPTUI_WIZ_CERT_ENROLL is set in dwPurpose
                                                //Ignored   otherwise and should be set to NULL.
                                                //          The friendly name of the certificate
    LPCWSTR             pwszDescription;        //Optional  if CRYPTUI_WIZ_CERT_ENROLL is set in dwPurpose
                                                //Ignored   otherwise and should be set to NULL.
                                                //          The description of the certificate
    PCERT_EXTENSIONS    pCertRequestExtensions; //Optional  The extensions to add to the certificate request
    LPWSTR              pwszCertDNName;         //Optional  The certificate DN string
}CRYPTUI_WIZ_CERT_REQUEST_INFO, *PCRYPTUI_WIZ_CERT_REQUEST_INFO;

typedef const CRYPTUI_WIZ_CERT_REQUEST_INFO *PCCRYPTUI_WIZ_CERT_REQUEST_INFO;


//-------------------------------------------------------------------------
//
//
//  CRYPTUI_WIZ_CERT_REQUEST_INFO:
//  Used for three-stage no-DS enrollment API, exposed through 
//
//     CryptUIWizCreateCertRequestNoDS()
//     CryptUIWizSubmitCertRequestNoDS()
//     CryptUIWizFreeCertRequestNoDS() 
//      
// 
//-------------------------------------------------------------------------

typedef struct _CRYPTUI_WIZ_CREATE_CERT_REQUEST_INFO { 
    DWORD           dwSize;                 //Required: Has to be set to sizeof(CRYPTUI_WIZ_CREATE_CERT_REQUEST_INFO)
    DWORD           dwPurpose;              //Required: If CRYPTUI_WIZ_CERT_ENROLL is set, a certificate will be enrolled,
                                            //          If CRYPTUI_WIZ_CERT_RENEW  is set, a certificate will be renewed.
                                            //          CRYPTUI_WIZ_CERT_ENROLL and CRYPTUI_WIZ_CERT_RENEW can not be set
                                            //          at the same time
    HCERTTYPE       hCertType;              //Required: A handle to the cert type to use in request creation.  
    BOOL            fMachineContext;        //Required: TRUE if running under machine context, FALSE otherwise. 
    DWORD           dwCertOpenStoreFlag;    //Optional: The value passed to dwFlags of CertOpenStore for the
                                            //          destination store.
                                            //          If this value is 0, we use CERT_SYSTEM_STORE_CURRENT_USER for
                                            //          an accout and CERT_SYSTEM_STORE_LOCAL_MACHINE for a machine
    PCCERT_CONTEXT  pRenewCertContext;      //Required  if CRYPTUI_WIZ_CERT_RENEW  is set in dwPurpose
                                            //Ignored   otherwise and shoule be set to NULL.
    DWORD           dwPvkChoice;            //Required: Specify the private key information
                                            //            CRYPTUI_WIZ_CERT_REQUEST_PVK_CHOICE_CERT
                                            //            CRYPTUI_WIZ_CERT_REQUEST_PVK_CHOICE_EXISTING
                                            //            CRYPTUI_WIZ_CERT_REQUEST_PVK_CHOICE_NEW
    union                                   //Required.
    {
	PCCRYPTUI_WIZ_CERT_REQUEST_PVK_CERT      pPvkCert; 
	PCCRYPTUI_WIZ_CERT_REQUEST_PVK_EXISTING  pPvkExisting; 
	PCCRYPTUI_WIZ_CERT_REQUEST_PVK_NEW       pPvkNew; 
    }; 
    LPCWSTR             pwszCALocation;         //Required  if dwCertChoice==CRYPTUI_WIZ_CERT_REQUEST_KEY_USAGE                                                //Optional  Otherwise
                                                //Optional  Otherwise
                                                //          The machine name of the Certiviate Authority (CA)
    LPCWSTR             pwszCAName;             //Required   if dwCertChoice==CRYPTUI_WIZ_CERT_REQUEST_KEY_USAGE
                                                //Optional  Otherwise
                                                //          The name of the Certificate Authority (CA)

} CRYPTUI_WIZ_CREATE_CERT_REQUEST_INFO, *PCRYPTUI_WIZ_CREATE_CERT_REQUEST_INFO; 

typedef const CRYPTUI_WIZ_CREATE_CERT_REQUEST_INFO * PCCRYPTUI_WIZ_CREATE_CERT_REQUEST_INFO;

//-------------------------------------------------------------------------
//
//
//  CRYPTUI_WIZ_CERT_REQUEST_INFO:
//  Used to query the requests created by the no-DS enrollment API, exposed through 
//
//     CryptUIWizCreateCertRequestNoDS()
//     CryptUIWizSubmitCertRequestNoDS()
//     CryptUIWizFreeCertRequestNoDS() 
//     CryptUIWizQueryCertRequestNoDS()
//      
// 
//-------------------------------------------------------------------------

typedef struct _CRYPTUI_WIZ_QUERY_CERT_REQUEST_INFO { 
    DWORD dwSize;     // sizeof(CRYPTUI_WIZ_QUERY_CERT_REQUEST_INFO)
    DWORD dwStatus;   // set of flags, see below
} CRYPTUI_WIZ_QUERY_CERT_REQUEST_INFO, *PCRYPTUI_WIZ_QUERY_CERT_REQUEST_INFO; 

typedef const CRYPTUI_WIZ_QUERY_CERT_REQUEST_INFO * PCCRYPTUI_WIZ_QUERY_CERT_REQUEST_INFO; 

//-----------------------------------------------------------------------
//
// possible flags for CRYPTUI_WIZ_QUERY_CERT_REQUEST_INFO::dwStatus.
//
//-----------------------------------------------------------------------
#define     CRYPTUI_WIZ_QUERY_CERT_REQUEST_STATUS_CREATE_REUSED_PRIVATE_KEY   0x00000001


//-----------------------------------------------------------------------
//
// possible status for pdwStatus
//  Those status indicate the status value returned
//  from the certificate authority (certificate server).
//-----------------------------------------------------------------------
#define     CRYPTUI_WIZ_CERT_REQUEST_STATUS_SUCCEEDED           0
#define     CRYPTUI_WIZ_CERT_REQUEST_STATUS_REQUEST_ERROR       1
#define     CRYPTUI_WIZ_CERT_REQUEST_STATUS_REQUEST_DENIED      2
#define     CRYPTUI_WIZ_CERT_REQUEST_STATUS_ISSUED_SEPARATELY   3
#define     CRYPTUI_WIZ_CERT_REQUEST_STATUS_UNDER_SUBMISSION    4
#define     CRYPTUI_WIZ_CERT_REQUEST_STATUS_UNKNOWN             5
#define     CRYPTUI_WIZ_CERT_REQUEST_STATUS_CERT_ISSUED         6
#define     CRYPTUI_WIZ_CERT_REQUEST_STATUS_CONNECTION_FAILED   7


//-----------------------------------------------------------------------
//
//  CryptUIWizCertRequest
//
//      Request a certificate via a wizard.
//
//  dwFlags:  IN Optional
//      If CRYPTUI_WIZ_NO_UI is set in dwFlags, no UI will be shown.
//      If CRYPTUI_WIZ_NO_INSTALL_ROOT is set in dwFlags, the wizard will not
//      install the issued certificate chain into the root store,
//      instead, it will put the certificate chain into the CA store.

//
//  hwndParent:  IN Optional
//      The parent window for the UI.  Ignored if CRYPTUI_WIZ_NO_UI is set in dwFlags
//
//  pwszWizardTitle: IN Optional
//      The title of the wizard.   Ignored if CRYPTUI_WIZ_NO_UI is set in dwFlags
//
//  pCertRequestInfo: IN Required
//      A pointer to CRYPTUI_WIZ_CERT_REQUEST_INFO struct
//
//  ppCertContext: Out Optional
//      The issued certificate.  The certificate is in a memory store for remote enrollment.
//      The certificate is in a system cert store for local enrollment.
//
//      Even the function return TRUE, it does not mean the certificate is issued.  Use should
//      check for the *pdwCAStatus.  If the status is CRYPTUI_WIZ_CERT_REQUEST_STATUS_ISSUED_SEPERATELY
//      of   CRYPTUI_WIZ_CERT_REQUEST_STATUS_UNDER_SUBMISSION, *ppCertContext will be NULL.
//      It is valid only if *pdwCAStatus==CRYPTUI_WIZ_CERT_REQUEST_STATUS_SUCCEEDED
//
//  pdwCAStatus: Out Optional.
//      The return status of the certificate authority cerver.  The dwStatus can be one of
///     the following:
//         CRYPTUI_WIZ_CERT_REQUEST_STATUS_SUCCEEDED
//         CRYPTUI_WIZ_CERT_REQUEST_STATUS_REQUEST_ERROR
//         CRYPTUI_WIZ_CERT_REQUEST_STATUS_REQUEST_DENIED
//         CRYPTUI_WIZ_CERT_REQUEST_STATUS_ISSUED_SEPERATELY
//         CRYPTUI_WIZ_CERT_REQUEST_STATUS_UNDER_SUBMISSION
//------------------------------------------------------------------------
BOOL
WINAPI
CryptUIWizCertRequest(
 IN             DWORD                           dwFlags,
 IN OPTIONAL    HWND                            hwndParent,
 IN OPTIONAL    LPCWSTR                         pwszWizardTitle,
 IN             PCCRYPTUI_WIZ_CERT_REQUEST_INFO pCertRequestInfo,
 OUT OPTIONAL   PCCERT_CONTEXT                  *ppCertContext,
 OUT OPTIONAL   DWORD                           *pCAdwStatus
);


//-----------------------------------------------------------------------
//
//  CryptUIWizCreateCertRequestNoDS
//
//      Create a certificate request using the supplied parameters. 
//
//  dwFlags:  IN Required.  
//      CRYPTUI_WIZ_NO_UI:            must be set.  
//      CRYPTUI_WIZ_NO_INSTALL_ROOT:  if set, the issued certificate chain will not
//                                    be installed into the root store.  Instead, 
//                                    it will be installed in the CA store.
//  pCreateCertRequestInfo: IN Required
//      A pointer to CRYPTUI_WIZ_CREATE_CERT_REQUEST_INFO struct
//
//  phRequest: OUT Required. 
//      A HANDLE to the created request.  This HANDLE can be passed 
//      to CryptUIWizSubmitCertRequestNoDS(), and, of course, should not
//      be used for any other purpose.  
// 
//  Returns:  TRUE if successful, FALSE otherwise.  Get extended error information
//            using GetLastError(). 
// 
//------------------------------------------------------------------------
BOOL
WINAPI
CryptUIWizCreateCertRequestNoDS
(IN  DWORD                                   dwFlags, 
 IN  HWND                                    hwndParent, 
 IN  PCCRYPTUI_WIZ_CREATE_CERT_REQUEST_INFO  pCreateCertRequestInfo, 
 OUT HANDLE                                 *phRequest
);

//-----------------------------------------------------------------------
//
//  CryptUIWizSubmitCertRequestNoDS
//
//      Request a certificate using a request created by CryptUIWizCreateCertRequestNoDS(). 
//
//  hRequest: IN Required. 
//      A HANDLE to the request to submit.  Must have been created through
//      CryptUIWizCreateCertRequest(). 
//
//  ppCertContext: OUT Required. 
//      The issued certificate.  The certificate is in a memory store for remote enrollment.
//      The certificate is in a system cert store for local enrollment.
//
//      Even the function return TRUE, it does not mean the certificate is issued.  Use should
//      check for the *pdwCAStatus.  If the status is CRYPTUI_WIZ_CERT_REQUEST_STATUS_ISSUED_SEPERATELY
//      of   CRYPTUI_WIZ_CERT_REQUEST_STATUS_UNDER_SUBMISSION, *ppCertContext will be NULL.
//      It is valid only if *pdwCAStatus==CRYPTUI_WIZ_CERT_REQUEST_STATUS_SUCCEEDED
//
//  pdwCAStatus: Out Optional.
//      The return status of the certificate authority cerver.  The dwStatus can be one of
///     the following:
//         CRYPTUI_WIZ_CERT_REQUEST_STATUS_SUCCEEDED
//         CRYPTUI_WIZ_CERT_REQUEST_STATUS_REQUEST_ERROR
//         CRYPTUI_WIZ_CERT_REQUEST_STATUS_REQUEST_DENIED
//         CRYPTUI_WIZ_CERT_REQUEST_STATUS_ISSUED_SEPERATELY
//         CRYPTUI_WIZ_CERT_REQUEST_STATUS_UNDER_SUBMISSION
//
//  Returns:  TRUE if the procedure executed without an error, FALSE otherwise.  Check
//            pdwStatus to verify that the certificate was issued.  Get extended
//            error information using GetLastError(). 
// 
//------------------------------------------------------------------------
BOOL
WINAPI
CryptUIWizSubmitCertRequestNoDS
(IN HANDLE           hRequest, 
 IN HWND             hwndParent, 
 IN LPCWSTR          pwszCAName, 
 IN LPCWSTR          pwszCALocation, 
 OUT DWORD          *pdwStatus, 
 OUT PCCERT_CONTEXT *ppCertContext  // Optional
 );

//------------------------------------------------------------------------
//
//  CryptUIWizFreeCertRequestNoDS
//
//      Frees a certificate request created by CryptUIWizCreateCertRequestNoDS().
//
//  hRequest: IN Required. 
//      A HANDLE to the request to be freed.  
//
//------------------------------------------------------------------------
void
WINAPI
CryptUIWizFreeCertRequestNoDS
(IN HANDLE hRequest);

//------------------------------------------------------------------------
//
//  CryptUIWizQueryCertRequestNoDS
//
//      Queries status information about a created request. 
//
//  hRequest: IN Required. 
//      A HANDLE to the request to be freed.  
//
//------------------------------------------------------------------------
BOOL
WINAPI
CryptUIWizQueryCertRequestNoDS
(IN HANDLE hRequest, OUT CRYPTUI_WIZ_QUERY_CERT_REQUEST_INFO *pQueryInfo);

//-------------------------------------------------------------------------
//
//	Valid values for dwSubjectChoice in IMPORT_SUBJECT_INFO
//-------------------------------------------------------------------------
#define     CRYPTUI_WIZ_IMPORT_SUBJECT_FILE                 1
#define     CRYPTUI_WIZ_IMPORT_SUBJECT_CERT_CONTEXT         2
#define     CRYPTUI_WIZ_IMPORT_SUBJECT_CTL_CONTEXT          3
#define     CRYPTUI_WIZ_IMPORT_SUBJECT_CRL_CONTEXT          4
#define     CRYPTUI_WIZ_IMPORT_SUBJECT_CERT_STORE           5

//-------------------------------------------------------------------------
//
//	Struct to define the subject CertImportWizard
//
//  CRYPTUI_WIZ_IMPORT_SUBJECT_INFO
//
//-------------------------------------------------------------------------
typedef struct _CRYPTUI_WIZ_IMPORT_SUBJECT_INFO
{
	DWORD					dwSize;				//Required: should be set to sizeof(IMPORT_SUBJECT_INFO)
	DWORD					dwSubjectChoice;	//Required:	indicate the type of the subject:
                                                //          If can one of the following:
                                                //          CRYPTUI_WIZ_IMPORT_SUBJECT_FILE
                                                //          CRYPTUI_WIZ_IMPORT_SUBJECT_CERT_CONTEXT
                                                //          CRYPTUI_WIZ_IMPORT_SUBJECT_CTL_CONTEXT
                                                //          CRYPTUI_WIZ_IMPORT_SUBJECT_CRL_CONTEXT
                                                //          CRYPTUI_WIZ_IMPORT_SUBJECT_CERT_STORE
    union
	{
		LPCWSTR          	pwszFileName;	
        PCCERT_CONTEXT      pCertContext;
        PCCTL_CONTEXT       pCTLContext;
        PCCRL_CONTEXT       pCRLContext;
        HCERTSTORE          hCertStore;
    };

    DWORD                   dwFlags;            //Required if pwszFileName contains a PFX BLOB.
                                                //Ignored otherwise
                                                //This is the same flag for PFXImportCertStore
    LPCWSTR                 pwszPassword;       //Required if pwszFileName contains a PFX BLOB.
                                                //ignored otherwise
}CRYPTUI_WIZ_IMPORT_SRC_INFO, *PCRYPTUI_WIZ_IMPORT_SRC_INFO;

typedef const CRYPTUI_WIZ_IMPORT_SRC_INFO *PCCRYPTUI_WIZ_IMPORT_SRC_INFO;

//-----------------------------------------------------------------------
//
// Valid flags for dwFlags in CryptUIWizImport
//
//-----------------------------------------------------------------------
//if this flag is set in dwFlags, user will not be allowed to change
//the hDesCertStore in the wizard page
#define   CRYPTUI_WIZ_IMPORT_NO_CHANGE_DEST_STORE           0x00010000

//Allow importing certificate
#define   CRYPTUI_WIZ_IMPORT_ALLOW_CERT                     0x00020000

//Allow importing certificate revocation list
#define   CRYPTUI_WIZ_IMPORT_ALLOW_CRL                      0x00040000

//Allow importing certificate trust list
#define   CRYPTUI_WIZ_IMPORT_ALLOW_CTL                      0x00080000

//import contents to local machine (currently only applicable for PFX imports)
#define   CRYPTUI_WIZ_IMPORT_TO_LOCALMACHINE                0x00100000

//import contents to current user (currently only applicable for PFX imports)
#define   CRYPTUI_WIZ_IMPORT_TO_CURRENTUSER                 0x00200000

//if the hDesCertStore is a remote store handle, this flag should be set
#define   CRYPTUI_WIZ_IMPORT_REMOTE_DEST_STORE              0x00400000

//-----------------------------------------------------------------------
//
// CryptUIWizImport
//
//  The import wizard to import public key related files to a certificate
//  store
//
//  dwFlags can be set to any combination of the following flags:
//  CRYPTUI_WIZ_NO_UI                           No UI will be shown.  Otherwise, User will be
//                                              prompted by a wizard.
//  CRYPTUI_WIZ_IMPORT_ALLOW_CERT               Allow importing certificate
//  CRYPTUI_WIZ_IMPORT_ALLOW_CRL                Allow importing CRL(certificate revocation list)
//  CRYPTUI_WIZ_IMPORT_ALLOW_CTL                Allow importing CTL(certificate trust list)
//  CRYPTUI_WIZ_IMPORT_NO_CHANGE_DEST_STORE     user will not be allowed to change
//                                              the hDesCertStore in the wizard page
//  CRYPTUI_WIZ_IMPORT_TO_LOCALMACHINE          the contents should be imported to local machine
//                                              (currently only applicable for PFX imports)
//  CRYPTUI_WIZ_IMPORT_TO_CURRENTUSER           the contents should be imported to current user
//                                              (currently only applicable for PFX imports)
//
//  Please notice that if neither of following three flags is in dwFlags, default to is
//  allow everything.
//  CRYPTUI_WIZ_IMPORT_ALLOW_CERT
//  CRYPTUI_WIZ_IMPORT_ALLOW_CRL
//  CRYPTUI_WIZ_IMPORT_ALLOW_CTL
//
//  Also, note that the CRYPTUI_WIZ_IMPORT_TO_LOCALMACHINE and CRYPTUI_WIZ_IMPORT_TO_CURRENTUSER
//  flags are used force the content of a pfx blob into either local machine or current user.
//  If neither of these flags are used and hDesCertStore is NULL then:
//  1) The private key in the pfx blob will be forced to be imported into current user.
//  2) If CRYPTUI_WIZ_NO_UI is NOT set, the wizard will prompt the user to select a certificate
//     store from the current user stores.
//
//
//
//  If CRYPTUI_WIZ_NO_UI is set in dwFlags:
//      hwndParent:         Ignored
//      pwszWizardTitle:    Ignored
//      pImportSubject:     IN Required:    The subject to import.
//      hDesCertStore:      IN Optional:    The destination certficate store
//
//  If CRYPTUI_WIZ_NO_UI is not set in dwFlags:
//      hwndPrarent:        IN Optional:    The parent window for the wizard
//      pwszWizardTitle:    IN Optional:    The title of the wizard
//                                          If NULL, the default will be IDS_IMPORT_WIZARD_TITLE
//      pImportSubject:     IN Optional:    The file name to import.
//                                          If NULL, the wizard will prompt user to enter the file name
//      hDesCertStore:      IN Optional:    The destination certificate store where the file wil be
//                                          imported to.  The store should be opened with
//                                          flag CERT_STORE_SET_LOCALIZED_NAME_FLAG.  If NULL, the wizard will prompt user to select
//                                          a certificate store.
//------------------------------------------------------------------------
BOOL
WINAPI
CryptUIWizImport(
     DWORD                               dwFlags,
     HWND                                hwndParent,
     LPCWSTR                             pwszWizardTitle,
     PCCRYPTUI_WIZ_IMPORT_SRC_INFO       pImportSrc,
     HCERTSTORE                          hDestCertStore
);


//-------------------------------------------------------------------------
//
//	Struct to define the information needed to build a new CTL
//
//  CRYPTUI_WIZ_BUILDCTL_NEW_CTL_INFO
//
//
//-------------------------------------------------------------------------
typedef struct _CRYPTUI_WIZ_BUILDCTL_NEW_CTL_INFO
{
	DWORD			    dwSize;				    //Required: should be set to sizeof(CRYPTUI_WIZ_BUILDCTL_NEW_CTL)
    PCERT_ENHKEY_USAGE  pSubjectUsage;          //Optioanl: The purpose of the CTL
    LPWSTR              pwszListIdentifier;     //Optional: The string to identify the CTL
    LPCSTR              pszSubjectAlgorithm;    //Optional: The hashing algorithm.
                                                //          Currently, only SHA1 or MD5 hashing is supported
    HCERTSTORE          hCertStore;             //Optional: The certificate in the CTL.  Only the certificates
                                                //          with the enhanced key usage specified by pSubjectUsage
                                                //          will be included in the CTL
    FILETIME            NextUpdate;             //Optional: The next update time of the CTL.  If the value
                                                //          is more than 99 month from the current system time,
                                                //          the value will be ignored.
    LPWSTR              pwszFriendlyName;       //Optional: The friendly name of the CTL
    LPWSTR              pwszDescription;        //Optional: The description of the CTL
}CRYPTUI_WIZ_BUILDCTL_NEW_CTL_INFO, *PCRYPTUI_WIZ_BUILDCTL_NEW_CTL_INFO;

typedef const CRYPTUI_WIZ_BUILDCTL_NEW_CTL_INFO *PCCRYPTUI_WIZ_BUILDCTL_NEW_CTL_INFO;

//-------------------------------------------------------------------------
//
//	Valid values for dwSourceChoice for CRYPTUI_WIZ_BUILDCTL_SRC_INFO
//-------------------------------------------------------------------------
#define         CRYPTUI_WIZ_BUILDCTL_SRC_EXISTING_CTL       1
#define         CRYPTUI_WIZ_BUILDCTL_SRC_NEW_CTL            2

//-------------------------------------------------------------------------
//
//	Struct to define the source of certBuildCTL wizard
//
//  CRYPTUI_WIZ_BUILDCTL_SRC_INFO
//
//
//-------------------------------------------------------------------------
typedef struct _CRYPTUI_WIZ_BUILDCTL_SRC_INFO
{
	DWORD			dwSize;				//Required: should be set to sizeof(CRYPTUI_WIZ_BUILDCTL_SRC_INFO)
    DWORD           dwSourceChoice;     //Required: indicate the source from which to build the CTL
                                        //          if can be one of the following:
                                        //          CRYPTUI_WIZ_BUILDCTL_SRC_EXISTING_CTL
                                        //          CRYPTUI_WIZ_BUILDCTL_SRC_NEW_CTL
    union
    {
        PCCTL_CONTEXT                       pCTLContext;    //Required if dwSourceChoice == CRYPTUI_WIZ_BUILDCTL_SRC_EXISTING_CTL
                                                            //          An existing CTL based on which a new CTL is to be built
        PCCRYPTUI_WIZ_BUILDCTL_NEW_CTL_INFO pNewCTLInfo;        //Required if dwSourceChoise == CRYPTUI_WIZ_BUILDCTL_SRC_NEW_CTL
    };
}CRYPTUI_WIZ_BUILDCTL_SRC_INFO, *PCRYPTUI_WIZ_BUILDCTL_SRC_INFO;

typedef const CRYPTUI_WIZ_BUILDCTL_SRC_INFO *PCCRYPTUI_WIZ_BUILDCTL_SRC_INFO;

//-------------------------------------------------------------------------
//
//	Valid values for dwDestinationChoice for CRYPTUI_WIZ_BUILDCTL_DEST_INFO
//-------------------------------------------------------------------------
#define         CRYPTUI_WIZ_BUILDCTL_DEST_CERT_STORE     1
#define         CRYPTUI_WIZ_BUILDCTL_DEST_FILE           2
//-------------------------------------------------------------------------
//
//	Struct to define the desination of certBuildCTL wizard
//
//  CRYPTUI_WIZ_BUILDCTL_DEST_INFO
//
//
//-------------------------------------------------------------------------
typedef struct _CRYPTUI_WIZ_BUILDCTL_DEST_INFO
{
	DWORD					dwSize;				 //Required: should be set to sizeof(CRYPTUI_WIZ_BUILDCTL_DEST_INFO)
	DWORD					dwDestinationChoice; //Required:	indicate the type of the desination:
                                                 //          If can one of the following:
                                                 //          CRYPTUI_WIZ_BUILDCTL_DEST_CERT_STORE
                                                 //          CRYPTUI_WIZ_BUILDCTL_DEST_FILE
    union
	{
		LPCWSTR          	pwszFileName;	
        HCERTSTORE          hCertStore;
    };

}CRYPTUI_WIZ_BUILDCTL_DEST_INFO, *PCRYPTUI_WIZ_BUILDCTL_DEST_INFO;

typedef const CRYPTUI_WIZ_BUILDCTL_DEST_INFO *PCCRYPTUI_WIZ_BUILDCTL_DEST_INFO;

//-----------------------------------------------------------------------
//
// CryptUIWizBuildCTL
//
//  Build a new CTL or modify an existing CTL.   The UI for wizard will
//  always show in this case
//
//
//  dwFlags:            IN  Optional:   Can be set to the any combination of the following:
//                                      CRYPTUI_WIZ_BUILDCTL_SKIP_DESTINATION.
//                                      CRYPTUI_WIZ_BUILDCTL_SKIP_SIGNING
//                                      CRYPTUI_WIZ_BUILDCTL_SKIP_PURPOSE
//  hwndParnet:         IN  Optional:   The parent window handle
//  pwszWizardTitle:    IN  Optional:   The title of the wizard
//                                      If NULL, the default will be IDS_BUILDCTL_WIZARD_TITLE
//  pBuildCTLSrc:       IN  Optional:   The source from which the CTL will be built
//  pBuildCTLDest:      IN  Optional:   The desination where the newly
//                                      built CTL will be stored
//  ppCTLContext:       OUT Optaionl:   The newly build CTL
//
//------------------------------------------------------------------------
BOOL
WINAPI
CryptUIWizBuildCTL(
    IN              DWORD                                   dwFlags,
    IN  OPTIONAL    HWND                                    hwndParent,
    IN  OPTIONAL    LPCWSTR                                 pwszWizardTitle,
    IN  OPTIONAL    PCCRYPTUI_WIZ_BUILDCTL_SRC_INFO         pBuildCTLSrc,
    IN  OPTIONAL    PCCRYPTUI_WIZ_BUILDCTL_DEST_INFO        pBuildCTLDest,
    OUT OPTIONAL    PCCTL_CONTEXT                           *ppCTLContext
);


//-------------------------------------------------------------------------
//
//	Valid values for dwSubjectChoice in CRYPTUI_WIZ_EXPORT_INFO
//-------------------------------------------------------------------------
#define     CRYPTUI_WIZ_EXPORT_CERT_CONTEXT 			        1
#define     CRYPTUI_WIZ_EXPORT_CTL_CONTEXT  			        2
#define     CRYPTUI_WIZ_EXPORT_CRL_CONTEXT  			        3
#define     CRYPTUI_WIZ_EXPORT_CERT_STORE   			        4
#define     CRYPTUI_WIZ_EXPORT_CERT_STORE_CERTIFICATES_ONLY   	5

//-------------------------------------------------------------------------
//
//	Struct to define the object to be exported and where to export it to
//
//  CRYPTUI_WIZ_EXPORT_SUBJECT_INFO
//
//-------------------------------------------------------------------------
typedef struct _CRYPTUI_WIZ_EXPORT_INFO
{
	DWORD					dwSize;				//Required: should be set to sizeof(CRYPTUI_WIZ_EXPORT_INFO)
    LPCWSTR                 pwszExportFileName; //Required if the CRYPTUI_WIZ_NO_UI flag is set, Optional otherwise.
                                                //The fully qualified file name to export to, if this is
                                                //non-NULL and the CRYPTUI_WIZ_NO_UI flag is NOT set, then it is
                                                //displayed to the user as the default file name
	DWORD					dwSubjectChoice;	//Required:	indicate the type of the subject:
                                                //          If can one of the following:
                                                //          CRYPTUI_WIZ_EXPORT_CERT_CONTEXT
                                                //          CRYPTUI_WIZ_EXPORT_CTL_CONTEXT
                                                //          CRYPTUI_WIZ_EXPORT_CRL_CONTEXT
                                                //          CRYPTUI_WIZ_EXPORT_CERT_STORE
						                        //	        CRYPTUI_WIZ_EXPORT_CERT_STORE_CERTIFICATES_ONLY
    union
	{
	PCCERT_CONTEXT      pCertContext;
        PCCTL_CONTEXT       pCTLContext;
        PCCRL_CONTEXT       pCRLContext;
        HCERTSTORE          hCertStore;
    };

    DWORD                   cStores;            // Optional: count of extra stores to search for the certs in the
                                                //           trust chain if the chain is being exported with a cert.
                                                //           this is ignored if dwSubjectChoice is anything other
                                                //           than CRYPTUI_WIZ_EXPORT_CERT_CONTEXT
    HCERTSTORE *            rghStores;          // Optional: array of extra stores to search for the certs in the
                                                //           trust chain if the chain is being exported with a cert.
                                                //           this is ignored if dwSubjectChoice is anything other
                                                //           than CRYPTUI_WIZ_EXPORT_CERT_CONTEXT

}CRYPTUI_WIZ_EXPORT_INFO, *PCRYPTUI_WIZ_EXPORT_INFO;

typedef const CRYPTUI_WIZ_EXPORT_INFO *PCCRYPTUI_WIZ_EXPORT_INFO;


//-------------------------------------------------------------------------
//
//	Valid values for dwExportFormat in CRYPTUI_WIZ_EXPORT_CERTCONTEXT_INFO
//-------------------------------------------------------------------------
#define     CRYPTUI_WIZ_EXPORT_FORMAT_DER                   1
#define     CRYPTUI_WIZ_EXPORT_FORMAT_PFX                   2
#define     CRYPTUI_WIZ_EXPORT_FORMAT_PKCS7                 3
#define     CRYPTUI_WIZ_EXPORT_FORMAT_BASE64                4
#define     CRYPTUI_WIZ_EXPORT_FORMAT_SERIALIZED_CERT_STORE 5   // NOTE: not currently supported!!

//-------------------------------------------------------------------------
//
//	Struct to define the information needed to export a CERT_CONTEXT
//
//  CRYPTUI_WIZ_EXPORT_NOUI_INFO
//
//-------------------------------------------------------------------------
typedef struct _CRYPTUI_WIZ_EXPORT_CERTCONTEXT_INFO
{
	DWORD					dwSize;				//Required: should be set to sizeof(CRYPTUI_WIZ_EXPORT_NOUI_INFO)
	DWORD					dwExportFormat;	    //Required:
                                                //          It can be one of the following:
                                                //          CRYPTUI_WIZ_EXPORT_FORMAT_DER
                                                //          CRYPTUI_WIZ_EXPORT_FORMAT_PFX
                                                //          CRYPTUI_WIZ_EXPORT_FORMAT_PKCS7
                                                //          CRYPTUI_WIZ_EXPORT_FORMAT_SERIALIZED_CERT_STORE

    BOOL                    fExportChain;       //Required
    BOOL                    fExportPrivateKeys; //Required
    LPCWSTR                 pwszPassword;       //Required if the fExportPrivateKeys boolean is TRUE, otherwise,
                                                //it is ignored
    BOOL                    fStrongEncryption;  //Required if dwExportFormat is CRYPTUI_WIZ_EXPORT_FORMAT_PFX
                                                //Note that if this flag is TRUE then the PFX blob produced is
                                                //NOT compatible with IE4.

}CRYPTUI_WIZ_EXPORT_CERTCONTEXT_INFO, *PCRYPTUI_WIZ_EXPORT_CERTCONTEXT_INFO;

typedef const CRYPTUI_WIZ_EXPORT_CERTCONTEXT_INFO *PCCRYPTUI_WIZ_EXPORT_CERTCONTEXT_INFO;

//-----------------------------------------------------------------------
//
// CryptUIWizExport
//
//  The export wizard to export public key related objects to a file
//
//  If dwFlags is set to CRYPTUI_WIZ_NO_UI, no UI will be shown.  Otherwise,
//  User will be prompted for input through a wizard.
//
//  If CRYPTUI_WIZ_NO_UI is set in dwFlags:
//      hwndParent:         Ignored
//      pwszWizardTitle:    Ignored
//      pExportInfo:        IN Required:    The subject to export.
//      pvoid:              IN Required:    Contains information about how to do the export based on what
//                                          is being exported
//
//                                          dwSubjectChoice                     INPUT TYPE
//                                          -------------------------------------------------------------------------
//                                          CRYPTUI_WIZ_EXPORT_CERT_CONTEXT     PCCRYPTUI_WIZ_EXPORT_CERTCONTEXT_INFO
//                                          CRYPTUI_WIZ_EXPORT_CTL_CONTEXT      NULL
//                                          CRYPTUI_WIZ_EXPORT_CRL_CONTEXT      NULL
//                                          CRYPTUI_WIZ_EXPORT_CERT_STORE       NULL
//
//  If CRYPTUI_WIZ_NO_UI is not set in dwFlags:
//      hwndPrarent:        IN Optional:    The parent window for the wizard
//      pwszWizardTitle:    IN Optional:    The title of the wizard
//                                          If NULL, the default will be IDS_EXPORT_WIZARD_TITLE
//      pExportInfo:        IN Required:    The subject to export.
//      pvoid:              IN Optional:    Contains information about how to do the export based on what
//                                          is being exported.  See above table for values, if this is non-NULL
//                                          the values are displayed to the user as the default choices.
//------------------------------------------------------------------------
BOOL
WINAPI
CryptUIWizExport(
     DWORD                                  dwFlags,
     HWND                                   hwndParent,
     LPCWSTR                                pwszWizardTitle,
     PCCRYPTUI_WIZ_EXPORT_INFO              pExportInfo,
     void                                   *pvoid
);



//-------------------------------------------------------------------------
//valid values for dwSubjectChoice in CRYPTUI_WIZ_DIGITAL_SIGN_INFO struct
//-------------------------------------------------------------------------
#define CRYPTUI_WIZ_DIGITAL_SIGN_SUBJECT_FILE           0x01
#define CRYPTUI_WIZ_DIGITAL_SIGN_SUBJECT_BLOB           0x02


//-------------------------------------------------------------------------
//valid values for dwSigningCertChoice in CRYPTUI_WIZ_DIGITAL_SIGN_INFO struct
//-------------------------------------------------------------------------
#define CRYPTUI_WIZ_DIGITAL_SIGN_CERT                   0x01
#define CRYPTUI_WIZ_DIGITAL_SIGN_STORE                  0x02
#define CRYPTUI_WIZ_DIGITAL_SIGN_PVK                    0x03

//-------------------------------------------------------------------------
//valid values for dwAddtionalCertChoice in CRYPTUI_WIZ_DIGITAL_SIGN_INFO struct
//-------------------------------------------------------------------------
//include the entire certificate trust chain in the signature
#define CRYPTUI_WIZ_DIGITAL_SIGN_ADD_CHAIN               0x00000001

//include the entilre certificate trust chain, with the exception of the root
//certificate, in the signature
#define CRYPTUI_WIZ_DIGITAL_SIGN_ADD_CHAIN_NO_ROOT       0x00000002

//-------------------------------------------------------------------------
//
//	CRYPTUI_WIZ_DIGITAL_SIGN_BLOB_INFO
//
//  dwSize			IN Required: should be set to sizeof(CRYPTUI_WIZ_DIGITAL_SIGN_BLOB_INFO)
//  pGuidSubject    IN Required: Idenfity the sip functions to load
//  cbBlob			IN Required: the size of BLOB, in bytes
//  pbBlob		    IN Required: the pointer to the BLOB
//  pwszDispalyName IN Optional: the display name of the BLOB to sign.
//-------------------------------------------------------------------------
typedef struct _CRYPTUI_WIZ_DIGITAL_SIGN_BLOB_INFO
{
    DWORD               dwSize;			
    GUID                *pGuidSubject;
    DWORD               cbBlob;				
    BYTE                *pbBlob;			
    LPCWSTR             pwszDisplayName;
}CRYPTUI_WIZ_DIGITAL_SIGN_BLOB_INFO, *PCRYPTUI_WIZ_DIGITAL_SIGN_BLOB_INFO;

typedef const CRYPTUI_WIZ_DIGITAL_SIGN_BLOB_INFO *PCCRYPTUI_WIZ_DIGITAL_SIGN_BLOB_INFO;

//-------------------------------------------------------------------------
//
//	CRYPTUI_WIZ_DIGITAL_SIGN_STORE_INFO
//
//	dwSize				IN Required: should be set to sizeof(CRYPTUI_WIZ_DIGITAL_SIGN_STORE_INFO)
//  cCertStore          IN Required: The acount of certificate store array that includes potentical sining certs
//  rghCertStore        IN Required: The certificate store array that includes potential signing certs
//  pFilterCallback     IN Optional: The filter call back function for display the certificate
//  pvCallbackData      IN Optional: The call back data
//-------------------------------------------------------------------------
typedef struct _CRYPTUI_WIZ_DIGITAL_SIGN_STORE_INFO
{
	DWORD               dwSize;	
	DWORD               cCertStore;			
    HCERTSTORE          *rghCertStore;
    PFNCFILTERPROC      pFilterCallback;
    void *              pvCallbackData;
}CRYPTUI_WIZ_DIGITAL_SIGN_STORE_INFO, *PCRYPTUI_WIZ_DIGITAL_SIGN_STORE_INFO;

typedef const CRYPTUI_WIZ_DIGITAL_SIGN_STORE_INFO *PCCRYPTUI_WIZ_DIGITAL_SIGN_STORE_INFO;

//-------------------------------------------------------------------------
//
//	CRYPTUI_WIZ_DIGITAL_SIGN_PVK_FILE_INFO
//
//	dwSize				        IN Required: should be set to sizeof(CRYPT_WIZ_DIGITAL_SIGN_PVK_FILE_INFO)
//  pwszPvkFileName             IN Required: the PVK file name
//  pwszProvName                IN Required: the provider name
//  dwProvType                  IN Required: the provider type
//
//-------------------------------------------------------------------------
typedef struct _CRYPTUI_WIZ_DIGITAL_SIGN_PVK_FILE_INFO
{
	DWORD                   dwSize;
    LPWSTR                  pwszPvkFileName;
    LPWSTR                  pwszProvName;
    DWORD                   dwProvType;
}CRYPTUI_WIZ_DIGITAL_SIGN_PVK_FILE_INFO, *PCRYPTUI_WIZ_DIGITAL_SIGN_PVK_FILE_INFO;

typedef const CRYPTUI_WIZ_DIGITAL_SIGN_PVK_FILE_INFO *PCCRYPTUI_WIZ_DIGITAL_SIGN_PVK_FILE_INFO;

//-------------------------------------------------------------------------
//
// valid values for dwPvkChoice in CRYPTUI_WIZ_DIGITAL_SIGN_CERT_PVK_INFO struct
//-------------------------------------------------------------------------
#define CRYPTUI_WIZ_DIGITAL_SIGN_PVK_FILE        0x01
#define CRYPTUI_WIZ_DIGITAL_SIGN_PVK_PROV        0x02


//-------------------------------------------------------------------------
//
//	CRYPTUI_WIZ_DIGITAL_SIGN_CERT_PVK_INFO
//
//	dwSize				        IN Required: should be set to sizeof(CRYPTUI_WIZ_DIGITAL_SIGN_STORE_INFO)
//  pwszSigningCertFileName     IN Required: the file name that contains the signing cert(s)
//  dwPvkChoice                 IN Required: Indicate the private key type:
//                                           It can be one of the following:
//                                           CRYPTUI_WIZ_DIGITAL_SIGN_PVK_FILE
//                                           CRYPTUI_WIZ_DIGITAL_SIGN_PVK_PROV
//  pPvkFileInfo                IN Required if dwPvkChoice == CRYPTUI_WIZ_DIGITAL_SIGN_PVK_FILE
//  pPvkProvInfo                IN Required if dwPvkContainer== CRYPTUI_WIZ_DIGITAL_SIGN_PVK_PROV
//
//-------------------------------------------------------------------------
typedef struct _CRYPTUI_WIZ_DIGITAL_SIGN_CERT_PVK_INFO
{
	DWORD                   dwSize;
    LPWSTR                  pwszSigningCertFileName;
    DWORD					dwPvkChoice;		
    union
	{
        PCCRYPTUI_WIZ_DIGITAL_SIGN_PVK_FILE_INFO      pPvkFileInfo;
        PCRYPT_KEY_PROV_INFO                        pPvkProvInfo;
    };

}CRYPTUI_WIZ_DIGITAL_SIGN_CERT_PVK_INFO, *PCRYPTUI_WIZ_DIGITAL_SIGN_CERT_PVK_INFO;

typedef const CRYPTUI_WIZ_DIGITAL_SIGN_CERT_PVK_INFO *PCCRYPTUI_WIZ_DIGITAL_SIGN_CERT_PVK_INFO;

//-------------------------------------------------------------------------
//
// valid values for dwAttrFlags in CRYPTUI_WIZ_DIGITAL_SIGN_EXTENDED_INFO struct
//-------------------------------------------------------------------------
#define     CRYPTUI_WIZ_DIGITAL_SIGN_COMMERCIAL         0x0001
#define     CRYPTUI_WIZ_DIGITAL_SIGN_INDIVIDUAL         0x0002

//-------------------------------------------------------------------------
//
//	CRYPTUI_WIZ_DIGITAL_SIGN_EXTENDED_INFO
//
//   dwSize			        IN Required:  should be set to sizeof(CRYPTUI_WIZ_DIGITAL_SIGN_EXTENDED_INFO)
//   dwAttrFlags            IN Required:  Flag to indicate signing options.
//                                        It can be one of the following:
//                                          CRYPTUI_WIZ_DIGITAL_SIGN_COMMERCIAL
//                                          CRYPTUI_WIZ_DIGITAL_SIGN_INDIVIDUAL
//   pwszDescription        IN Optional:  The description of the signing subject
//   pwszMoreInfoLocation   IN Optional:  the localtion to get more information about file
//                                        this information will be shown upon download time
//   pszHashAlg             IN Optional:  the hashing algorithm for the signature
//                                        NULL means using SHA1 hashing algorithm
//   pwszSigningCertDisplayString  IN Optional: The display string to be displayed on the
//                                        signing certificate wizard page.  The string should
//                                        prompt user to select a certificate for a particular purpose
//   hAddtionalCertStores  IN Optional:   the addtional cert store to add to the signature
//   psAuthenticated	    IN Optional:  user supplied authenticated attributes added to the signature
//   psUnauthenticated	    IN Optional:  user supplied unauthenticated attributes added to the signature
//
//-------------------------------------------------------------------------
typedef struct _CRYPTUI_WIZ_DIGITAL_SIGN_EXTENDED_INFO
{
	DWORD		            dwSize;			
    DWORD                   dwAttrFlags;
    LPCWSTR                 pwszDescription;
	LPCWSTR				    pwszMoreInfoLocation;		
    LPCSTR                  pszHashAlg;
    LPCWSTR                 pwszSigningCertDisplayString;
    HCERTSTORE              hAdditionalCertStore;
	PCRYPT_ATTRIBUTES		psAuthenticated;	
	PCRYPT_ATTRIBUTES		psUnauthenticated;	
}CRYPTUI_WIZ_DIGITAL_SIGN_EXTENDED_INFO, *PCRYPTUI_WIZ_DIGITAL_SIGN_EXTENDED_INFO;

typedef const CRYPTUI_WIZ_DIGITAL_SIGN_EXTENDED_INFO *PCCRYPTUI_WIZ_DIGITAL_SIGN_EXTENDED_INFO;
//-------------------------------------------------------------------------
//
//
//  CRYPTUI_WIZ_DIGITAL_SIGN_INFO
//
// dwSize			    IN Required: Has to be set to sizeof(CRYPTUI_WIZ_DIGITAL_SIGN_INFO)
// dwSubjectChoice	    IN Required if CRYPTUI_WIZ_NO_UI is set in dwFlags of the CryptUIWizDigitalSigning,         :
//                         Optional if CRYPTUI_WIZ_NO_UI is not set in dwFlags of the CryptUIWizDigitalSigning
//                                  Indicate whether to sign a file or to sign a memory BLOB.
//                                  0 means promting user for the file to sign
//                                  It can be one of the following:
//                                  CRYPTUI_WIZ_DIGITAL_SIGN_SUBJECT_FILE
//			                        CRYPTUI_WIZ_DIGITAL_SIGN_SUBJECT_BLOB
//
//
//pwszFileName	        IN Required if dwSubjectChoice==CRYPTUI_WIZ_DIGITAL_SIGN_SUBJECT_FILE
//pSignBlobInfo	        IN Required if dwSubhectChoice==CRYPTUI_WIZ_DIGITAL_SIGN_SUBJECT_BLOB
//
//dwSigningCertChoice   IN Optional: Indicate the signing certificate.
//                                  0 means using the certificates in "My" store"
//                                  It can be one of the following choices:
//                                  CRYPTUI_WIZ_DIGITAL_SIGN_CERT
//                                  CRYPTUI_WIZ_DIGITAL_SIGN_STORE
//                                  CRYPTUI_WIZ_DIGITAL_SIGN_PVK
//                                  If CRYPTUI_WIZ_NO_UI is set in dwFlags of the CryptUIWizDigitalSigning,
//                                  dwSigningCertChoice has to be CRYPTUI_WIZ_DIGITAL_SIGN_CERT or
//                                  CRYPTUI_WIZ_DIGITAL_SIGN_PVK
//
//pSigningCertContext       IN Required if dwSigningCertChoice==CRYPTUI_WIZ_DIGITAL_SIGN_CERT
//pSigningCertStore         IN Required if dwSigningCertChoice==CRYPTUI_WIZ_DIGITAL_SIGN_STORE
//pSigningCertPvkInfo       IN Required if dwSigningCertChoise==CRYPTUI_WIZ_DIGITAL_SIGN_PVK
//
//pwszTimestampURL      IN Optional: The timestamp URL address
//
//dwAdditionalCertChoice IN Optional: Indicate additional certificates to be included in the signature.                                                       //
//                                  0 means no addtional certificates will be added
//                                  The following flags are mutually exclusive.
//                                  Only one of them can be set:
//                                  CRYPTUI_WIZ_DIGITAL_SIGN_ADD_CHAIN
//                                  CRYPTUI_WIZ_DIGITAL_SIGN_ADD_CHAIN_NO_ROOT
//
//
//pSignExtInfo         IN Optional: The extended information for signing
//
//-------------------------------------------------------------------------
typedef struct _CRYPTUI_WIZ_DIGITAL_SIGN_INFO
{
	DWORD			                            dwSize;			
	DWORD					                    dwSubjectChoice;	
	union
	{
		LPCWSTR                                 pwszFileName;	
		PCCRYPTUI_WIZ_DIGITAL_SIGN_BLOB_INFO    pSignBlobInfo;	
	};

    DWORD                                       dwSigningCertChoice;
    union
    {
        PCCERT_CONTEXT                              pSigningCertContext;
        PCCRYPTUI_WIZ_DIGITAL_SIGN_STORE_INFO       pSigningCertStore;
        PCCRYPTUI_WIZ_DIGITAL_SIGN_CERT_PVK_INFO    pSigningCertPvkInfo;
    };

    LPCWSTR                                     pwszTimestampURL;
    DWORD                                       dwAdditionalCertChoice;
    PCCRYPTUI_WIZ_DIGITAL_SIGN_EXTENDED_INFO    pSignExtInfo;

}CRYPTUI_WIZ_DIGITAL_SIGN_INFO, *PCRYPTUI_WIZ_DIGITAL_SIGN_INFO;

typedef const CRYPTUI_WIZ_DIGITAL_SIGN_INFO *PCCRYPTUI_WIZ_DIGITAL_SIGN_INFO;

//-------------------------------------------------------------------------
//
//	CRYPTUI_WIZ_DIGITAL_SIGN_CONTEXT
//
//  dwSize			 set to sizeof(CRYPTUI_WIZ_DIGITAL_SIGN_CONTEXT)
//  cbBlob			 the size of pbBlob.  In bytes
//  pbBlob		     the signed BLOB
//-------------------------------------------------------------------------
typedef struct _CRYPTUI_WIZ_DIGITAL_SIGN_CONTEXT
{
    DWORD               dwSize;			
    DWORD               cbBlob;				
    BYTE                *pbBlob;			
}CRYPTUI_WIZ_DIGITAL_SIGN_CONTEXT, *PCRYPTUI_WIZ_DIGITAL_SIGN_CONTEXT;

typedef const CRYPTUI_WIZ_DIGITAL_SIGN_CONTEXT *PCCRYPTUI_WIZ_DIGITAL_SIGN_CONTEXT;

//-----------------------------------------------------------------------
//
// CryptUIWizDigitalSign
//
//  The wizard to digitally sign a document or a BLOB.
//
//  If CRYPTUI_WIZ_NO_UI is set in dwFlags, no UI will be shown.  Otherwise,
//  User will be prompted for input through a wizard.
//
//  dwFlags:            IN  Required:
//  hwndParnet:         IN  Optional:   The parent window handle
//  pwszWizardTitle:    IN  Optional:   The title of the wizard
//                                      If NULL, the default will be IDS_DIGITAL_SIGN_WIZARD_TITLE
//  pDigitalSignInfo:   IN  Required:   The information about the signing process
//  ppSignContext       OUT Optional:   The context pointer points to the signed BLOB
//------------------------------------------------------------------------
BOOL
WINAPI
CryptUIWizDigitalSign(
     IN                 DWORD                               dwFlags,
     IN     OPTIONAL    HWND                                hwndParent,
     IN     OPTIONAL    LPCWSTR                             pwszWizardTitle,
     IN                 PCCRYPTUI_WIZ_DIGITAL_SIGN_INFO     pDigitalSignInfo,
     OUT    OPTIONAL    PCCRYPTUI_WIZ_DIGITAL_SIGN_CONTEXT  *ppSignContext);


BOOL
WINAPI
CryptUIWizFreeDigitalSignContext(
     IN  PCCRYPTUI_WIZ_DIGITAL_SIGN_CONTEXT   pSignContext);


//-------------------------------------------------------------------------
//valid values for dwPageChoice in CRYPTUI_WIZ_SIGN_GET_PAGE_INFO
//-------------------------------------------------------------------------

#define     CRYPTUI_WIZ_DIGITAL_SIGN_TYPICAL_SIGNING_OPTION_PAGES       0x0001
#define     CRYPTUI_WIZ_DIGITAL_SIGN_MINIMAL_SIGNING_OPTION_PAGES       0x0002
#define     CRYPTUI_WIZ_DIGITAL_SIGN_CUSTOM_SIGNING_OPTION_PAGES        0x0004
#define     CRYPTUI_WIZ_DIGITAL_SIGN_ALL_SIGNING_OPTION_PAGES           0x0008

#define     CRYPTUI_WIZ_DIGITAL_SIGN_WELCOME_PAGE                       0x0100
#define     CRYPTUI_WIZ_DIGITAL_SIGN_FILE_NAME_PAGE                     0x0200
#define     CRYPTUI_WIZ_DIGITAL_SIGN_CONFIRMATION_PAGE                  0x0400


//-------------------------------------------------------------------------
//
//	CRYPTUI_WIZ_SIGN_GET_PAGE_INFO
//
//	dwSize				IN Required:    should be set to sizeof(CRYPTUI_WIZ_SIGN_GET_PAGE_INFO)
//  dwPageChoice:       IN Required:    It should one of the following:
//                                          CRYPTUI_WIZ_DIGITAL_SIGN_ALL_SIGNING_OPTION_PAGES
//                                          CRYPTUI_WIZ_DIGITAL_SIGN_TYPICAL_SIGNING_OPTION_PAGES
//                                          CRYPTUI_WIZ_DIGITAL_SIGN_MINIMAL_SIGNING_OPTION_PAGES
//                                          CRYPTUI_WIZ_DIGITAL_SIGN_CUSTOM_SIGNING_OPTION_PAGES
//                                      It can also be ORed with any of the following:
//                                          CRYPTUI_WIZ_DIGITAL_SIGN_WELCOME_PAGE
//                                          CRYPTUI_WIZ_DIGITAL_SIGN_CONFIRMATION_PAGE
//                                          CRYPTUI_WIZ_DIGITAL_SIGN_FILE_NAME_PAGE
//                                      If user tries to sign a BLOB, CRYPTUI_WIZ_DIGITAL_SIGN_FILE_NAME_PAGE
//                                      should not be set
//  dwFlags;            IN Optional:    Flags and has to be set to 0
//  hwndParent          IN Optional:    The parent window of the dialogue
//  pwszPageTitle       IN Optional:    The title for the pages and the message boxes.
//  pDigitalSignInfo    IN Optional:    the addtional information for signing
//  pPropPageCallback   IN Optional:    this callback will be called when each page that is
//                                      returned in the CryptUIGetViewSignaturesPages call
//                                      is about to be created or destroyed.  if this is NULL no
//                                      callback is made.
//  pvCallbackData      IN Optional:    this is uniterpreted data that is passed back when the
//                                      when pPropPageCallback is made
//  fResult             OUT:            The result of signing
//  dwError             OUT:            The value of GetLastError() if fResult is FALSE
//  pSignContext        OUT:            The context pointer to the signed BLOB.  User needs to free
//                                      the blob by CryptUIWizDigitalSignFreeContext
//  dwReserved          Reserved:       The private data used by the signing process.
//                                      must be set to NULL
//  pvSignReserved      Reserved:       The private data used by the signing process
//                                      must be set to NULL
//-------------------------------------------------------------------------
typedef struct _CRYPTUI_WIZ_GET_SIGN_PAGE_INFO
{
	DWORD				                dwSize;	
    DWORD                               dwPageChoice;
    DWORD                               dwFlags;
    HWND                                hwndParent;
    LPWSTR                              pwszPageTitle;
    PCCRYPTUI_WIZ_DIGITAL_SIGN_INFO     pDigitalSignInfo;
    PFNCPROPPAGECALLBACK                pPropPageCallback;
    void *                              pvCallbackData;
    BOOL                                fResult;
    DWORD                               dwError;
    PCCRYPTUI_WIZ_DIGITAL_SIGN_CONTEXT  pSignContext;
    DWORD                               dwReserved;
    void                                *pvSignReserved;
}CRYPTUI_WIZ_GET_SIGN_PAGE_INFO, *PCRYPTUI_WIZ_GET_SIGN_PAGE_INFO;

typedef const CRYPTUI_WIZ_GET_SIGN_PAGE_INFO *PCCRYPTUI_WIZ_GET_SIGN_PAGE_INFO;

//-----------------------------------------------------------------------
//
// CryptUIWizGetDigitalSignPages
//
//  Get specific wizard pages from the CryptUIWizDigitalSign wizard.
//  Application can include the pages to other wizards.  The pages will
//  gather user inputs throught the new "Parent" wizard.
//  After user clicks the finish buttion, signing process will start the signing
//  and return the result in fResult and dwError field of CRYPTUI_WIZ_SIGN_GET_PAGE_INFO
//  struct.  If not enough information can be gathered through the wizard pages,
//  user should supply addtional information in pSignGetPageInfo.
//
//
// pSignGetPageInfo    IN   Required:   The struct that user allocate.   It can be used
//                                      to supply additinal information which is not gathered
//                                      from the selected wizard pages
// prghPropPages,      OUT  Required:   The wizard pages returned.  Please
//                                      notice the pszTitle of the struct is set to NULL
// pcPropPages         OUT  Required:   The number of wizard pages returned
//------------------------------------------------------------------------
BOOL
WINAPI
CryptUIWizGetDigitalSignPages(
     IN     PCRYPTUI_WIZ_GET_SIGN_PAGE_INFO     pSignGetPageInfo,
     OUT    PROPSHEETPAGEW                      **prghPropPages,
     OUT    DWORD                               *pcPropPages);

BOOL
WINAPI
CryptUIWizFreeDigitalSignPages(
            IN PROPSHEETPAGEW    *rghPropPages,
            IN DWORD             cPropPages
            );

DWORD
WINAPI
I_CryptUIProtect(
    IN      PVOID               pvReserved1,
    IN      PVOID               pvReserved2,
    IN      DWORD               dwReserved3,
    IN      PVOID               *pvReserved4,
    IN      BOOL                fReserved5,
    IN      PVOID               pvReserved6
    );

DWORD
WINAPI
I_CryptUIProtectFailure(
    IN      PVOID               pvReserved1,
    IN      DWORD               dwReserved2,
    IN      PVOID               *pvReserved3);

#include <poppack.h>

#ifdef __cplusplus
}       // Balance extern "C" above
#endif

#endif // _CRYPTUI_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\public\internal\ds\inc\confname.h ===
/*++

Copyright (c) 1991-1993  Microsoft Corporation

Module Name:

    ConfName.h

Abstract:

    This header file defines the names of sections and keywords in the config
    data.

Author:

    John Rogers (JohnRo) 13-Feb-1992

Revision History:

    13-Feb-1992 JohnRo
        Moved equates here from Net/Inc/Config.h and Repl/Common/IniParm.h
    24-Feb-1992 JohnRo
        Interval is obsolete for NT: don't keep in registry.
    13-Mar-1992 JohnRo
        Added many sections and keywords as part of getting rid of old config
        helper callers.
    13-Mar-1992 JohnRo
        Added KEYWORD_TRUE and KEYWORD_FALSE for general boolean use.
    14-Mar-1992 JohnRo
        Get rid of old net config helper callers.
    23-Mar-1992 JohnRo
        Added some stuff for netlogon service.
    08-May-1992 JohnRo
        Implement wksta sticky set info.
    08-May-1992 JohnRo
        Workstation transports are now a keyword, not a section.
    09-May-1992 JohnRo
        Added SECT_NT_BROWSER and BROWSER_KEYWORD_OTHERDOMAINS.
    10-May-1992 JohnRo
        NT section names MUST be same as service names, so use thoses equates
        here.
    13-May-1992 JohnRo
        Added NetpAllocConfigName().
    08-Jul-1992 JohnRo
        RAID 10503: Corrected values of replicator's import and export sections.
    16-Aug-1992 JohnRo
        RAID 3607: REPLLOCK.RP$ is being created during tree copy.
    01-Dec-1992 JohnRo
        RAID 3844: remote NetReplSetInfo uses local machine type.
    24-Mar-1993 JohnRo
        Repl svc should use DBFlag in registry.
        Made some changes suggested by PC-LINT 5.0
    12-Apr-1993 JohnRo
        RAID 5483: server manager: wrong path given in repl dialog.

--*/

#ifndef _CONFNAME_
#define _CONFNAME_


#include <lmcons.h>     // NET_API_STATUS.
/*lint -efile(764,lmsname.h) */
/*lint -efile(766,lmsname.h) */
#include <lmsname.h>    // SERVICE_ equates.


//
// General purpose equates.
//
#define KEYWORD_FALSE           TEXT("FALSE")
#define KEYWORD_TRUE            TEXT("TRUE")

#define KEYWORD_NO              TEXT("NO")
#define KEYWORD_YES             TEXT("YES")


//
// Equate names for sections in the networking portion of the config data.
// Note that the routines in <config.h> only accept the SECT_NT_ versions.
// The others are included for use with the NetConfig APIs when they are
// remoted to downlevel machines.  (A program can tell the difference by
// looking at the platform ID from a wksta or server get info call.)
//


///////////////////////////////////////////////////////////////////////////////

#define SECT_NT_ALERTER                  SERVICE_ALERTER

#define ALERTER_KEYWORD_ALERTNAMES       TEXT("AlertNames")

///////////////////////////////////////////////////////////////////////////////

#define SECT_NT_BROWSER                  SERVICE_BROWSER

///////////////////////////////////////////////////////////////////////////////

#define ENV_KEYWORD_SYSTEMROOT           TEXT("SystemRoot")

///////////////////////////////////////////////////////////////////////////////

#define NETLOGON_KEYWORD_DBFLAG          TEXT("DBFlag")
#define NETLOGON_KEYWORD_PULSE           TEXT("Pulse")
#define NETLOGON_KEYWORD_PULSEMAXIMUM    TEXT("PulseMaximum")
#define NETLOGON_KEYWORD_PULSECONCURRENCY TEXT("PulseConcurrency")
#define NETLOGON_KEYWORD_PULSETIMEOUT1   TEXT("PulseTimeout1")
#define NETLOGON_KEYWORD_PULSETIMEOUT2   TEXT("PulseTimeout2")
#define NETLOGON_KEYWORD_RANDOMIZE       TEXT("Randomize")
#define NETLOGON_KEYWORD_SCRIPTS         TEXT("Scripts")
#define NETLOGON_KEYWORD_SYSVOL          TEXT("SysVol")
#define NETLOGON_KEYWORD_UPDATE          TEXT("Update")
#define NETLOGON_KEYWORD_DISABLEPASSWORDCHANGE TEXT("DisablePasswordChange")
#define NETLOGON_KEYWORD_REFUSEPASSWORDCHANGE  TEXT("RefusePasswordChange")
#define NETLOGON_KEYWORD_MAXIMUMLOGFILESIZE    TEXT("MaximumLogFileSize")
#define NETLOGON_KEYWORD_GOVERNOR        TEXT("ReplicationGovernor")
#define NETLOGON_KEYWORD_CHANGELOGSIZE   TEXT("ChangeLogSize")
#define NETLOGON_KEYWORD_MAXIMUMMAILSLOTMESSAGES TEXT("MaximumMailslotMessages")
#define NETLOGON_KEYWORD_MAILSLOTMESSAGETIMEOUT TEXT("MailslotMessageTimeout")
#define NETLOGON_KEYWORD_MAILSLOTDUPLICATETIMEOUT TEXT("MailslotDuplicateTimeout")
#define NETLOGON_KEYWORD_TRUSTEDDOMAINLIST TEXT("TrustedDomainList")
#define NETLOGON_KEYWORD_MAXIMUMREPLICATORTHREADCOUNT TEXT("MaximumReplicatorThreadCount")
#define NETLOGON_KEYWORD_EXPECTEDDIALUPDELAY TEXT("ExpectedDialupDelay")
#define NETLOGON_KEYWORD_SCAVENGEINTERVAL TEXT("ScavengeInterval")
#define NETLOGON_KEYWORD_LDAPSRVPRIORITY TEXT("LdapSrvPriority")
#define NETLOGON_KEYWORD_LDAPSRVWEIGHT   TEXT("LdapSrvWeight")
#define NETLOGON_KEYWORD_LDAPSRVPORT     TEXT("LdapSrvPort")
#define NETLOGON_KEYWORD_LDAPGCSRVPORT   TEXT("LdapGcSrvPort")
#define NETLOGON_KEYWORD_DNSTTL          TEXT("DnsTtl")
#define NETLOGON_KEYWORD_DNSREFRESHINTERVAL TEXT("DnsRefreshInterval")
#define NETLOGON_KEYWORD_SITENAME        TEXT("SiteName")
#define NETLOGON_KEYWORD_DYNAMICSITENAME TEXT("DynamicSiteName")
#define NETLOGON_KEYWORD_SITECOVERAGE    TEXT("SiteCoverage")
#define NETLOGON_KEYWORD_GCSITECOVERAGE  TEXT("GcSiteCoverage")
#define NETLOGON_KEYWORD_NDNCSITECOVERAGE  TEXT("NdncSiteCoverage")
#define NETLOGON_KEYWORD_MAXIMUMPASSWORDAGE  TEXT("MaximumPasswordAge")
#define NETLOGON_KEYWORD_ALLOWREPLINNONMIXED TEXT("AllowReplInNonMixed")
#define NETLOGON_KEYWORD_KERBISDDONEWITHJOIN TEXT("KerbIsDoneWithJoinDomainEntry")
#define NETLOGON_KEYWORD_DNSAVOIDNAME TEXT("DnsAvoidRegisterRecords")
#define NETLOGON_KEYWORD_NT4EMULATOR TEXT("Nt4Emulator")
#define NETLOGON_KEYWORD_NEUTRALIZENT4EMULATOR TEXT("NeutralizeNt4Emulator")

//
// Netlogons join domain paths
//
#define NETSETUPP_NETLOGON_JD_PATH                                      \
        TEXT("SYSTEM\\CurrentControlSet\\Services\\Netlogon")
#define NETSETUPP_NETLOGON_AVOID_SPN_PATH                               \
        TEXT("SYSTEM\\CurrentControlSet\\Services\\Netlogon\\AvoidSpnSet")
#define NETSETUPP_NETLOGON_AVOID_SPN   TEXT("AvoidSpnSet")
#define NETSETUPP_NETLOGON_JD       TEXT("JoinDomain")
#define NETSETUPP_NETLOGON_JD_DC    TEXT("DomainControllerName")
#define NETSETUPP_NETLOGON_JD_DCA   TEXT("DomainControllerAddress")
#define NETSETUPP_NETLOGON_JD_DCAT  TEXT("DomainControllerAddressType")
#define NETSETUPP_NETLOGON_JD_DG    TEXT("DomainGuid")
#define NETSETUPP_NETLOGON_JD_DN    TEXT("DomainName")
#define NETSETUPP_NETLOGON_JD_DFN   TEXT("DnsForestName")
#define NETSETUPP_NETLOGON_JD_F     TEXT("Flags")
#define NETSETUPP_NETLOGON_JD_DSN   TEXT("DcSiteName")
#define NETSETUPP_NETLOGON_JD_CSN   TEXT("ClientSiteName")
#define NETSETUPP_NETLOGON_JD_NAME                                      \
        TEXT("SYSTEM\\CurrentControlSet\\Services\\Netlogon\\JoinDomain")

///////////////////////////////////////////////////////////////////////////////

#define SECT_LM20_SERVER                 TEXT("Server")

///////////////////////////////////////////////////////////////////////////////

#define SECT_LM20_SERVICES               TEXT("Services")

///////////////////////////////////////////////////////////////////////////////

#define SECT_NT_WKSTA                    SERVICE_WORKSTATION

#define WKSTA_KEYWORD_OTHERDOMAINS       TEXT("OtherDomains")
#define WKSTA_KEYWORD_CHARWAIT           TEXT("CharWait")
#define WKSTA_KEYWORD_MAXCOLLECTIONCOUNT TEXT("MaxCollectionCount")
#define WKSTA_KEYWORD_COLLECTIONTIME     TEXT("CollectionTime")
#define WKSTA_KEYWORD_KEEPCONN           TEXT("KeepConn")
#define WKSTA_KEYWORD_MAXCMDS            TEXT("MaxCmds")
#define WKSTA_KEYWORD_SESSTIMEOUT        TEXT("SessTimeout")
#define WKSTA_KEYWORD_SIZCHARBUF         TEXT("SizCharBuf")
#define WKSTA_KEYWORD_MAXTHREADS         TEXT("MaxThreads")
#define WKSTA_KEYWORD_LOCKQUOTA          TEXT("LockQuota")
#define WKSTA_KEYWORD_LOCKINCREMENT      TEXT("LockIncrement")
#define WKSTA_KEYWORD_LOCKMAXIMUM        TEXT("LockMaximum")
#define WKSTA_KEYWORD_PIPEINCREMENT      TEXT("PipeIncrement")
#define WKSTA_KEYWORD_PIPEMAXIMUM        TEXT("PipeMaximum")
#define WKSTA_KEYWORD_CACHEFILETIMEOUT   TEXT("CacheFileTimeout")
#define WKSTA_KEYWORD_DORMANTFILELIMIT   TEXT("DormantFileLimit")
#define WKSTA_KEYWORD_READAHEADTHRUPUT   TEXT("ReadAheadThroughput")
#define WKSTA_KEYWORD_MAILSLOTBUFFERS    TEXT("MailslotBuffers")
#define WKSTA_KEYWORD_SERVERANNOUNCEBUFS TEXT("ServerAnnounceBuffers")
#define WKSTA_KEYWORD_NUM_ILLEGAL_DG_EVENTS TEXT("NumIllegalDatagramEvents")
#define WKSTA_KEYWORD_ILLEGAL_DG_RESET_TIME TEXT("IllegalDatagramResetTime")
#define WKSTA_KEYWORD_LOG_ELECTION_PACKETS TEXT("LogElectionPackets")
#define WKSTA_KEYWORD_USEOPLOCKING       TEXT("UseOpportunisticLocking")
#define WKSTA_KEYWORD_USEUNLOCKBEHIND    TEXT("UseUnlockBehind")
#define WKSTA_KEYWORD_USECLOSEBEHIND     TEXT("UseCloseBehind")
#define WKSTA_KEYWORD_BUFNAMEDPIPES      TEXT("BufNamedPipes")
#define WKSTA_KEYWORD_USELOCKREADUNLOCK  TEXT("UseLockReadUnlock")
#define WKSTA_KEYWORD_UTILIZENTCACHING   TEXT("UtilizeNtCaching")
#define WKSTA_KEYWORD_USERAWREAD         TEXT("UseRawRead")
#define WKSTA_KEYWORD_USERAWWRITE        TEXT("UseRawWrite")
#define WKSTA_KEYWORD_USEWRITERAWDATA    TEXT("UseWriteRawData")
#define WKSTA_KEYWORD_USEENCRYPTION      TEXT("UseEncryption")
#define WKSTA_KEYWORD_BUFFILESDENYWRITE  TEXT("BufFilesDenyWrite")
#define WKSTA_KEYWORD_BUFREADONLYFILES   TEXT("BufReadOnlyFiles")
#define WKSTA_KEYWORD_FORCECORECREATE    TEXT("ForceCoreCreateMode")
#define WKSTA_KEYWORD_USE512BYTEMAXTRANS TEXT("Use512ByteMaxTransfer")

///////////////////////////////////////////////////////////////////////////////

#define WKSTA_KEYWORD_MAINTAINSRVLST     TEXT("MaintainServerList")

#ifdef ENABLE_PSEUDO_BROWSER
// Browser modern keys
#define BROWSER_POLICY_REGPATH_W            \
        L"SOFTWARE\\Policies\\Microsoft\\Windows\\Browser"
#define BROWSER_SEND_SERVER_ENUM_REGKEY_W   \
        L"SendServerEnum"
#define BROWSER_PSEUDO_SERVER_REGKEY_W      \
        L"BrowserPseudoServer"
#endif


///////////////////////////////////////////////////////////////////////////////

NET_API_STATUS
NetpAllocConfigName(
    IN LPTSTR DatabaseName,              // SERVICES_xxx_DATABASE from winsvc.h.
    IN LPTSTR ServiceName,               // SERVICE_ name equate from lmsname.h
    IN LPTSTR AreaUnderServiceName OPTIONAL,  // defaults to "Parameters"
    OUT LPTSTR *FullConfigName           // free with NetApiBufferFree.
    );


#endif // ndef _CONFNAME_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\public\internal\ds\inc\dns.h ===
/*++

Copyright (c) 1996-2000  Microsoft Corporation

Module Name:

    dns.h

Abstract:

    Domain Name System (DNS)

    General DNS definitions.

Author:

    Jim Gilroy (jamesg)     December 7, 1996

Revision History:

--*/


#ifndef _DNS_INCLUDED_
#define _DNS_INCLUDED_

//
//  Note:  this file is dead!  DO NOT INCLUDE!!!
//

#include <dnsapi.h>

#endif // _DNS_INCLUDED_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\public\internal\ds\inc\dnslib.h ===
/*++

Copyright (c) 1996-2001  Microsoft Corporation

Module Name:

    dnslib.h

Abstract:

    Domain Name System (DNS) Library

    DNS Library Routines -- Main Header File

Author:

    Jim Gilroy (jamesg)     December 7, 1996

Revision History:

--*/


#ifndef _DNSLIB_INCLUDED_
#define _DNSLIB_INCLUDED_

#include <windns.h>
#include <dnsapi.h>
#include <rpc.h>

#define BACKCOMPAT  1


#ifdef __cplusplus
extern "C"
{
#endif  // __cplusplus


//
//  Alignment and rounding macros
//

#define WORD_ALIGN(ptr)     ((PVOID) ((UINT_PTR)((PBYTE)ptr + 1) & ~(UINT_PTR)1))

#define DWORD_ALIGN(ptr)    ((PVOID) ((UINT_PTR)((PBYTE)ptr + 3) & ~(UINT_PTR)3))

#define QWORD_ALIGN(ptr)    ((PVOID) ((UINT_PTR)((PBYTE)ptr + 7) & ~(UINT_PTR)7))

#ifdef WIN64
#define POINTER_ALIGN(ptr)  QWORD_ALIGN(ptr)
#else
#define POINTER_ALIGN(ptr)  DWORD_ALIGN(ptr)
#endif

#define WORD_ALIGN_DWORD(dw)        (((WORD)dw + 1) & ~(DWORD)1)
#define DWORD_ALIGN_DWORD(dw)       (((DWORD)dw + 3) & ~(DWORD)3)
#define QWORD_ALIGN_DWORD(dw)       (((QWORD)dw + 7) & ~(DWORD)7)

#ifdef WIN64
#define POINTER_ALIGN_DWORD(dw)     QWORD_ALIGN_DWORD(dw)
#else
#define POINTER_ALIGN_DWORD(dw)     DWORD_ALIGN_DWORD(dw)
#endif


//
//  Inline byte flipping
//

__inline
WORD
inline_word_flip(
    IN      WORD            Word
    )
{
    return ( (Word << 8) | (Word >> 8) );
}

#define inline_htons(w)     inline_word_flip(w)
#define inline_ntohs(w)     inline_word_flip(w)

__inline
DWORD
inline_dword_flip(
    IN      DWORD           Dword
    )
{
    return ( ((Dword << 8) & 0x00ff0000) |
             (Dword << 24)               |
             ((Dword >> 8) & 0x0000ff00) |
             (Dword >> 24) );
}

#define inline_htonl(d)     inline_dword_flip(d)
#define inline_ntohl(d)     inline_dword_flip(d)



//
//  Useful type defs
//

#define PGUID       LPGUID
#define PADDRINFO   LPADDRINFO


//
//  QWORD 
//

#ifndef QWORD
typedef DWORD64     QWORD, *PQWORD;
#endif


//
//  Until converted must define PDNS_NAME
//
//  Note:  PDNS_NAME is NOT really a LPTSTR.
//      Rather it's the definition of a field that can be
//      either an PWSTR or PSTR depending on some other field.
//

#ifdef UNICODE
typedef PWSTR   PDNS_NAME;
#else
typedef PSTR    PDNS_NAME;
#endif




//
//  Flat buffer definition
//
//  Note:  using INT for sizes so that we can push BytesLeft negative
//  and use routines to determine REQUIRED space, even when no
//  buffer or buf too small.
//

typedef struct _FLATBUF
{
    PBYTE   pBuffer;
    PBYTE   pEnd;
    PBYTE   pCurrent;
    INT     Size;
    INT     BytesLeft;
}
FLATBUF, *PFLATBUF;


//
//  Flat buffer routines -- argument versions
//
//  These versions have the actual code so that we can
//  easily use this stuff with existing code that has
//  independent pCurrent and BytesLeft variables.
//
//  FLATBUF structure versions just call these inline.
//

PBYTE
FlatBuf_Arg_Reserve(
    IN OUT  PBYTE *         ppCurrent,
    IN OUT  PINT            pBytesLeft,
    IN      DWORD           Size,
    IN      DWORD           Alignment
    );

PBYTE
FlatBuf_Arg_WriteString(
    IN OUT  PBYTE *         ppCurrent,
    IN OUT  PINT            pBytesLeft,
    IN      PSTR            pString,
    IN      BOOL            fUnicode
    );

PBYTE
FlatBuf_Arg_CopyMemory(
    IN OUT  PBYTE *         ppCurrent,
    IN OUT  PINT            pBytesLeft,
    IN      PVOID           pMemory,
    IN      DWORD           Length,
    IN      DWORD           Alignment
    );

__inline
PBYTE
FlatBuf_Arg_ReserveAlignPointer(
    IN OUT  PBYTE *         ppCurrent,
    IN OUT  PINT            pBytesLeft,
    IN      DWORD           Size
    )
{
    return FlatBuf_Arg_Reserve(
                ppCurrent,
                pBytesLeft,
                Size,
                sizeof(PVOID) );
}

__inline
PBYTE
FlatBuf_Arg_ReserveAlignQword(
    IN OUT  PBYTE *         ppCurrent,
    IN OUT  PINT            pBytesLeft,
    IN      DWORD           Size
    )
{
    return FlatBuf_Arg_Reserve(
                ppCurrent,
                pBytesLeft,
                Size,
                sizeof(QWORD) );
}

__inline
PBYTE
FlatBuf_Arg_ReserveAlignDword(
    IN OUT  PBYTE *         ppCurrent,
    IN OUT  PINT            pBytesLeft,
    IN      DWORD           Size
    )
{
    return FlatBuf_Arg_Reserve(
                ppCurrent,
                pBytesLeft,
                Size,
                sizeof(DWORD) );
}

__inline
PBYTE
FlatBuf_Arg_ReserveAlignWord(
    IN OUT  PBYTE *         ppCurrent,
    IN OUT  PINT            pBytesLeft,
    IN      DWORD           Size
    )
{
    return FlatBuf_Arg_Reserve(
                ppCurrent,
                pBytesLeft,
                Size,
                sizeof(WORD) );
}

__inline
PBYTE
FlatBuf_Arg_ReserveAlignByte(
    IN OUT  PBYTE *         ppCurrent,
    IN OUT  PINT            pBytesLeft,
    IN      DWORD           Size
    )
{
    return FlatBuf_Arg_Reserve(
                ppCurrent,
                pBytesLeft,
                Size,
                0 );
}

PBYTE
__inline
FlatBuf_Arg_WriteString_A(
    IN OUT  PBYTE *         ppCurrent,
    IN OUT  PINT            pBytesLeft,
    IN      PSTR            pString
    )
{
    return  FlatBuf_Arg_WriteString(
                ppCurrent,
                pBytesLeft,
                pString,
                FALSE       // not unicode
                );
}

PBYTE
__inline
FlatBuf_Arg_WriteString_W(
    IN OUT  PBYTE *         ppCurrent,
    IN OUT  PINT            pBytesLeft,
    IN      PWSTR           pString
    )
{
    return  FlatBuf_Arg_WriteString(
                ppCurrent,
                pBytesLeft,
                (PSTR) pString,
                TRUE        // unicode
                );
}

//
//  Flat buffer routines -- structure versions
//

VOID
FlatBuf_Init(
    IN OUT  PFLATBUF        pFlatBuf,
    IN      PBYTE           pBuffer,
    IN      INT             Size
    );


__inline
PBYTE
FlatBuf_Reserve(
    IN OUT  PFLATBUF        pBuf,
    IN      DWORD           Size,
    IN      DWORD           Alignment
    )
{
    return FlatBuf_Arg_Reserve(
                & pBuf->pCurrent,
                & pBuf->BytesLeft,
                Size,
                Alignment );
}

__inline
PBYTE
FlatBuf_ReserveAlignPointer(
    IN OUT  PFLATBUF        pBuf,
    IN      DWORD           Size
    )
{
    return FlatBuf_Arg_Reserve(
                & pBuf->pCurrent,
                & pBuf->BytesLeft,
                Size,
                sizeof(PVOID) );
}

__inline
PBYTE
FlatBuf_ReserveAlignQword(
    IN OUT  PFLATBUF        pBuf,
    IN      DWORD           Size
    )
{
    return FlatBuf_Arg_Reserve(
                & pBuf->pCurrent,
                & pBuf->BytesLeft,
                Size,
                sizeof(QWORD) );
}

__inline
PBYTE
FlatBuf_ReserveAlignDword(
    IN OUT  PFLATBUF        pBuf,
    IN      DWORD           Size
    )
{
    return FlatBuf_Arg_Reserve(
                & pBuf->pCurrent,
                & pBuf->BytesLeft,
                Size,
                sizeof(DWORD) );
}

__inline
PBYTE
FlatBuf_ReserveAlignWord(
    IN OUT  PFLATBUF        pBuf,
    IN      DWORD           Size
    )
{
    return FlatBuf_Arg_Reserve(
                & pBuf->pCurrent,
                & pBuf->BytesLeft,
                Size,
                sizeof(WORD) );
}

__inline
PBYTE
FlatBuf_ReserveAlignByte(
    IN OUT  PFLATBUF        pBuf,
    IN      DWORD           Size
    )
{
    return FlatBuf_Arg_Reserve(
                & pBuf->pCurrent,
                & pBuf->BytesLeft,
                Size,
                0 );
}

PBYTE
__inline
FlatBuf_WriteString(
    IN OUT  PFLATBUF        pBuf,
    IN      PSTR            pString,
    IN      BOOL            fUnicode
    )
{
    return  FlatBuf_Arg_WriteString(
                & pBuf->pCurrent,
                & pBuf->BytesLeft,
                pString,
                fUnicode
                );
}

PBYTE
__inline
FlatBuf_WriteString_A(
    IN OUT  PFLATBUF        pBuf,
    IN      PSTR            pString
    )
{
    return  FlatBuf_Arg_WriteString(
                & pBuf->pCurrent,
                & pBuf->BytesLeft,
                pString,
                FALSE       // not unicode
                );
}

PBYTE
__inline
FlatBuf_WriteString_W(
    IN OUT  PFLATBUF        pBuf,
    IN      PWSTR           pString
    )
{
    return  FlatBuf_Arg_WriteString(
                & pBuf->pCurrent,
                & pBuf->BytesLeft,
                (PSTR) pString,
                TRUE        // unicode
                );
}

PBYTE
__inline
FlatBuf_CopyMemory(
    IN OUT  PFLATBUF        pBuf,
    IN      PVOID           pMemory,
    IN      DWORD           Length,
    IN      DWORD           Alignment
    )
{
    return FlatBuf_Arg_CopyMemory(
                & pBuf->pCurrent,
                & pBuf->BytesLeft,
                pMemory,
                Length,
                Alignment );
}

//
//  Multicast off until new features ready
//

#define MULTICAST_ENABLED 0


//
//  Multicast DNS definitions
//

#define MULTICAST_DNS_ADDR   0xEFFFFFFD // 239.255.255.253
#define MULTICAST_DNS_RADDR  0xFDFFFFEF // Same as above, in host ordering

#define MULTICAST_DNS_LOCAL_DOMAIN      ("local.")
#define MULTICAST_DNS_LOCAL_DOMAIN_W    (L"local.")
#define MULTICAST_DNS_SRV_RECORD_NAME   ("_dns._udp.local.")
#define MULTICAST_DNS_SRV_RECORD_NAME_W (L"_dns._udp.local.")
#define MULTICAST_DNS_A_RECORD_NAME     ("_dns.local.")
#define MULTICAST_DNS_A_RECORD_NAME_W   (L"_dns.local.")


//
//  Read unaligned value from given position in packet
//

#define READ_PACKET_HOST_DWORD(pch)  \
            FlipUnalignedDword( pch )

#define READ_PACKET_NET_DWORD(pch)  \
            ( *(UNALIGNED DWORD *)(pch) )

#define READ_PACKET_HOST_WORD(pch)  \
            FlipUnalignedWord( pch )

#define READ_PACKET_NET_WORD(pch)  \
            ( *(UNALIGNED WORD *)(pch) )


//
//  Private DNS_RECORD Flag field structure definition and macros
//
//  Note:  don't add to this list -- private stuff in dnslibp.h
//

typedef struct _DnsRecordLibFlags
{
    DWORD   Section     : 2;
    DWORD   Delete      : 1;
    DWORD   CharSet     : 2;

    DWORD   Unused      : 6;
    DWORD   Matched     : 1;
    DWORD   FreeData    : 1;
    DWORD   FreeOwner   : 1;

    DWORD   Reserved    : 18;
}
DNSRECLIB_FLAGS, *PDNSRECLIB_FLAGS;


#define PFLAGS( pRecord )           ((PDNSRECLIB_FLAGS)&pRecord->Flags.DW)
#define FLAG_Section( pRecord )     (PFLAGS( pRecord )->Section)
#define FLAG_Delete( pRecord )      (PFLAGS( pRecord )->Delete)
#define FLAG_CharSet( pRecord )     (PFLAGS( pRecord )->CharSet)
#define FLAG_FreeData( pRecord )    (PFLAGS( pRecord )->FreeData)
#define FLAG_FreeOwner( pRecord )   (PFLAGS( pRecord )->FreeOwner)
#define FLAG_Matched( pRecord )     (PFLAGS( pRecord )->Matched)

#define SET_FREE_OWNER(pRR)         (FLAG_FreeOwner(pRR) = TRUE)
#define SET_FREE_DATA(pRR)          (FLAG_FreeData(pRR) = TRUE)
#define SET_RR_MATCHED(pRR)         (FLAG_Matched(pRR) = TRUE)

#define CLEAR_FREE_OWNER(pRR)       (FLAG_FreeOwner(pRR) = FALSE)
#define CLEAR_FREE_DATA(pRR)        (FLAG_FreeData(pRR) = FALSE)
#define CLEAR_RR_MATCHED(pRR)       (FLAG_Matched(pRR) = FALSE)

#define IS_FREE_OWNER(pRR)          (FLAG_FreeOwner(pRR))
#define IS_FREE_DATA(pRR)           (FLAG_FreeData(pRR))
#define IS_RR_MATCHED(pRR)          (FLAG_Matched(pRR))

#define IS_ANSWER_RR(pRR)           (FLAG_Section(pRR) == DNSREC_ANSWER)
#define IS_AUTHORITY_RR(pRR)        (FLAG_Section(pRR) == DNSREC_AUTHORITY)
#define IS_ADDITIONAL_RR(pRR)       (FLAG_Section(pRR) == DNSREC_ADDITIONAL)


//
//  Converting RCODEs to\from DNS errors.
//

#define DNS_ERROR_FROM_RCODE(rcode)     ((rcode)+DNS_ERROR_RESPONSE_CODES_BASE)

#define DNS_RCODE_FROM_ERROR(err)       ((err)-DNS_ERROR_RESPONSE_CODES_BASE)




//
//  Record character sets
//
//  Currently supports records in three character sets
//      - unicode
//      - ANSI
//      - UTF8
//
//  Unicode and ANSI are supported through external DNSAPI interfaces.
//  UTF8 is not (at least offcially).
//
//  However, internally unicode and UTF8 are used for caching, reading
//  to and writing from packet.
//
//  All DNS_RECORD structs created by our code, are tagged with a
//  character set type in the flags CharSet field.
//

//
//  A couple of handy macros:
//

#define RECORD_CHARSET(pRR) \
        ( (DNS_CHARSET) (pRR)->Flags.S.CharSet )

#define IS_UNICODE_RECORD(pRR) \
        ( (DNS_CHARSET) (pRR)->Flags.S.CharSet == DnsCharSetUnicode )

//
//  Quick buffer size determination
//
//  Strings are read from the wire into dotted UTF8 format.
//  Strings are in UTF8 in RPC buffers.
//
//  Goal here is to quickly determine adequate buffer size,
//  slight overallocation is not critical.
//
//  Currently supporting only UTF8 or Unicode, however, if later
//  support direct ANSI conversion that's ok too, as ANSI will
//  no (to my knowledge) use more space than UTF8.
//

#define STR_BUF_SIZE_GIVEN_UTF8_LEN( Utf8Length, CharSet ) \
        ( ((CharSet)==DnsCharSetUnicode) ? ((Utf8Length)+1)*2 : (Utf8Length)+1 )


//
//  Default locale for string comparison and case mappings
//
//  Sublang: US English (0x04)  Lang:  English (0x09)
//

#define DNS_DEFAULT_LOCALE      (0x0409)





//
//  IP Array utilities (iparray.c)
//
//  Note some of these require memory allocation, see note
//  on memory allocation below.
//


#define DNS_NET_ORDER_LOOPBACK      (0x0100007f)

//  NT5-autonet is 169.254.x.y

#define AUTONET_MASK                (0x0000ffff)
#define AUTONET_NET                 (0x0000fea9)

#define DNS_IS_AUTONET_IP(ip)       ( ((ip) & AUTONET_MASK) == AUTONET_NET )

#define DNS_IPARRAY_CLEAN_ZERO      (0x00000001)
#define DNS_IPARRAY_CLEAN_LOOPBACK  (0x00000002)
#define DNS_IPARRAY_CLEAN_AUTONET   (0x00000010)

//
//  Simple IP address array routines
//

PIP_ADDRESS
Dns_CreateIpAddressArrayCopy(
    IN      PIP_ADDRESS     aipAddress,
    IN      DWORD           cipAddress
    );

BOOL
Dns_ValidateIpAddressArray(
    IN      PIP_ADDRESS     aipAddress,
    IN      DWORD           cipAddress,
    IN      DWORD           dwFlag
    );


//
//  IP_ARRAY datatype routines
//

PIP_ARRAY
Dns_CreateIpArray(
    IN      DWORD           cAddrCount
    );

DWORD
Dns_SizeofIpArray(
    IN      PIP_ARRAY       pIpArray
    );

PIP_ARRAY
Dns_BuildIpArray(
    IN      DWORD           cAddrCount,
    IN      PIP_ADDRESS     pipAddrs
    );

PIP_ARRAY
Dns_CopyAndExpandIpArray(
    IN      PIP_ARRAY       pIpArray,
    IN      DWORD           ExpandCount,
    IN      BOOL            fDeleteExisting
    );

PIP_ARRAY
Dns_CreateIpArrayCopy(
    IN      PIP_ARRAY       pIpArray
    );

BOOL
Dns_IsAddressInIpArray(
    IN      PIP_ARRAY       pIpArray,
    IN      IP_ADDRESS      ipAddress
    );

BOOL
Dns_AddIpToIpArray(
    IN OUT  PIP_ARRAY       pIpArray,
    IN      IP_ADDRESS      ipNew
    );

VOID
Dns_ClearIpArray(
    IN OUT  PIP_ARRAY       pIpArray
    );

VOID
Dns_ReverseOrderOfIpArray(
    IN OUT  PIP_ARRAY       pIpArray
    );

BOOL
Dns_CheckAndMakeIpArraySubset(
    IN OUT  PIP_ARRAY       pIpArraySub,
    IN      PIP_ARRAY       pIpArraySuper
    );

INT
WINAPI
Dns_ClearIpFromIpArray(
    IN OUT  PIP_ARRAY       pIpArray,
    IN      IP_ADDRESS      IpDelete
    );

INT
WINAPI
Dns_DeleteIpFromIpArray(
    IN OUT  PIP_ARRAY       pIpArray,
    IN      IP_ADDRESS      IpDelete
    );

#define Dns_RemoveZerosFromIpArray(pArray)   \
        Dns_DeleteIpFromIpArray( (pArray), 0 )

INT
WINAPI
Dns_CleanIpArray(
    IN OUT  PIP_ARRAY       pIpArray,
    IN      DWORD           Flag
    );

BOOL
Dns_AreIpArraysEqual(
    IN       PIP_ARRAY      pIpArray1,
    IN       PIP_ARRAY      pIpArray2
    );

BOOL
Dns_AreIpArraysSimilar(
    IN       PIP_ARRAY      pIpArray1,
    IN       PIP_ARRAY      pIpArray2
    );

DNS_STATUS
WINAPI
Dns_DiffOfIpArrays(
    IN      PIP_ARRAY       pIpArray1,
    IN      PIP_ARRAY       pIpArray2,
    OUT     PIP_ARRAY *     ppOnlyIn1,
    OUT     PIP_ARRAY *     ppOnlyIn2,
    OUT     PIP_ARRAY *     ppIntersect
    );

BOOL
WINAPI
Dns_IsIntersectionOfIpArrays(
    IN       PIP_ARRAY      pIpArray1,
    IN       PIP_ARRAY      pIpArray2
    );

DNS_STATUS
WINAPI
Dns_UnionOfIpArrays(
    IN      PIP_ARRAY       pIpArray1,
    IN      PIP_ARRAY       pIpArray2,
    OUT     PIP_ARRAY *     ppUnion
    );

#define Dns_IntersectionOfIpArrays(p1, p2, ppInt)    \
        Dns_DiffOfIpArrays( (p1), (p2), NULL, NULL, (ppInt) )


DNS_STATUS
Dns_CreateIpArrayFromMultiIpString(
    IN      PSTR            pchMultiIpString,
    OUT     PIP_ARRAY *     ppIpArray
    );

PSTR 
Dns_CreateMultiIpStringFromIpArray(
    IN      PIP_ARRAY       pIpArray,
    IN      CHAR            chSeparator     OPTIONAL
    );


//
//  Type list array routines
//

DNS_STATUS
Dns_CreateTypeArrayFromMultiTypeString(
    IN      PSTR            pchMultiTypeString,
    OUT     INT *           piTypeCount,
    OUT     PWORD *         ppwTypeArray
    );

PSTR 
Dns_CreateMultiTypeStringFromTypeArray(
    IN      INT             iTypeCount,
    IN      PWORD           ppwTypeArray,
    IN      CHAR            chSeparator     OPTIONAL
    );



//
//  General utilities
//


//
//  Wrap free, multi-thread safe seconds timer (timer.c)
//

VOID
Dns_InitializeSecondsTimer(
    VOID
    );

DWORD
Dns_GetCurrentTimeInSeconds(
    VOID
    );

//
//  Tokenizer
//

DWORD
Dns_TokenizeString(
    IN OUT  PSTR            pBuffer,
    OUT     PCHAR *         Argv,
    IN      DWORD           MaxArgs
    );



//
//  IP interfaces on local machine (iplist.c)
//

#define DNS_MAX_NAME_SERVERS        (50)
#define DNS_MAX_IP_INTERFACE_COUNT  (10000)

DWORD
Dns_GetIpAddresses(
    IN OUT  PDNS_ADDRESS_INFO IpAddressInfoList,
    IN      DWORD             ListCount
    );

PIP_ARRAY
Dns_GetLocalIpAddressArray(
    VOID
    );

//
//  IP interfaces on local machine (iplist4.c)
//

DWORD
Dns_GetIpAddressesNT4(
    IN OUT  PDNS_ADDRESS_INFO IpAddressInfoList,
    IN      DWORD             ListCount
    );

//
//  IP interfaces on local machine (iplist9x.c)
//

DWORD
Dns_GetIpAddressesWin9X(
    IN OUT  PDNS_ADDRESS_INFO IpAddressInfoList,
    IN      DWORD             ListCount
    );



//
//  DNS server list routines (servlist.c)
//
//  Also includes default domain and search list information.
//

#define DNS_FLAG_IGNORE_ADAPTER             (0x00000001)
#define DNS_FLAG_IS_WAN_ADAPTER             (0x00000002)
#define DNS_FLAG_IS_AUTONET_ADAPTER         (0x00000004)
#define DNS_FLAG_IS_DHCP_CFG_ADAPTER        (0x00000008)

#define DNS_FLAG_REGISTER_DOMAIN_NAME       (0x00000010)
#define DNS_FLAG_REGISTER_IP_ADDRESSES      (0x00000020)

#define DNS_FLAG_ALLOW_MULTICAST            (0x00000100)
#define DNS_FLAG_MULTICAST_ON_NAME_ERROR    (0x00000200)

#define DNS_FLAG_AUTO_SERVER_DETECTED       (0x00000400)
#define DNS_FLAG_DUMMY_SEARCH_LIST          (0x00000800)

#define DNS_FLAG_SERVERS_UNREACHABLE        (0x00010000)




//
//  NetInfo structures
//
//  WARNING:  Do NOT use these!
//
//  These are internal dnsapi.dll structures.  They are only
//  included here for backward compatibility with previous
//  code (netdiag) which incorrectly used these.
//
//  If you code with them you will inevitably wake up broken
//  down the road.
//

//#ifdef  _DNSLIB_NETINFO_  

typedef struct
{
    DNS_STATUS      Status;
    DWORD           Priority;
    IP_ADDRESS      IpAddress;
    DWORD           Reserved[3];
}
DNSLIB_SERVER_INFO, *PDNSLIB_SERVER_INFO;

typedef struct
{
    PSTR                pszAdapterGuidName;
    PSTR                pszAdapterDomain;
    PIP_ARRAY           pAdapterIPAddresses;
    PIP_ARRAY           pAdapterIPSubnetMasks;
    DWORD               InterfaceIndex;
    DWORD               InfoFlags;
    DWORD               Reserved;
    DWORD               Status;
    DWORD               ReturnFlags;
    DWORD               IpLastSend;
    DWORD               cServerCount;
    DWORD               cTotalListSize;
    DNSLIB_SERVER_INFO  ServerArray[1];
}
DNSLIB_ADAPTER, *PDNSLIB_ADAPTER;

#define DNS_MAX_SEARCH_LIST_ENTRIES     (50)

typedef struct
{
    PSTR            pszName;
    DWORD           Flags;
}
DNSLIB_SEARCH_NAME, *PDNSLIB_SEARCH_NAME;

typedef struct
{
    PSTR            pszDomainOrZoneName;
    DWORD           cNameCount;         // Zero for FindAuthoritativeZone
    DWORD           cTotalListSize;     // Zero for FindAuthoritativeZone
    DWORD           CurrentName;        // 0 for pszDomainOrZoneName
                                        // 1 for first name in array below
                                        // 2 for second name in array below
                                        // ...
    DNSLIB_SEARCH_NAME  SearchNameArray[1];
}
DNSLIB_SEARCH_LIST, *PDNSLIB_SEARCH_LIST;

typedef struct
{
    PSTR                pszDomainName;
    PSTR                pszHostName;
    PDNSLIB_SEARCH_LIST pSearchList;
    DWORD               TimeStamp;
    DWORD               InfoFlags;
    DWORD               Tag;
    DWORD               ReturnFlags;
    DWORD               cAdapterCount;
    DWORD               cTotalListSize;
    PDNSLIB_ADAPTER     AdapterArray[1];
}
DNSLIB_NETINFO, *PDNSLIB_NETINFO;


//
//  Create correct internal\external definitions    
//

#ifdef DNSAPI_INTERNAL

typedef RPC_DNS_SERVER_INFO     DNS_SERVER_INFO,    *PDNS_SERVER_INFO;
typedef RPC_DNS_ADAPTER         DNS_ADAPTER,        *PDNS_ADAPTER;
typedef RPC_SEARCH_NAME         SEARCH_NAME,        *PSEARCH_NAME;
typedef RPC_SEARCH_LIST         SEARCH_LIST,        *PSEARCH_LIST;
typedef RPC_DNS_NETINFO         DNS_NETINFO,        *PDNS_NETINFO;

#else   // external

typedef DNSLIB_SERVER_INFO      DNS_SERVER_INFO,    *PDNS_SERVER_INFO;
typedef DNSLIB_ADAPTER          DNS_ADAPTER,        *PDNS_ADAPTER;
typedef DNSLIB_SEARCH_NAME      SEARCH_NAME,        *PSEARCH_NAME;
typedef DNSLIB_SEARCH_LIST      SEARCH_LIST,        *PSEARCH_LIST;
typedef DNSLIB_NETINFO          DNS_NETINFO,        *PDNS_NETINFO;

#endif


//
//  NetInfo routines (should be private)
//
//  But currently used in netdiag and nslookup
//  (nslookup problem is simply getting isolation
//  in header file)
//

BOOL
Dns_IsUpdateNetworkInfo(
    IN      PDNS_NETINFO    pNetInfo
    );



//
//  General DNS utilities (dnsutil.c)
//

IP_ADDRESS
Dns_GetNetworkMask(
    IN      IP_ADDRESS      ipAddress
    );

PSTR 
_fastcall
Dns_StatusString(
    IN      DNS_STATUS      Status
    );

#define Dns_StatusToErrorString_A(status)    Dns_StatusString(status)

DNS_STATUS
_fastcall
Dns_MapRcodeToStatus(
    IN      BYTE            ResponseCode
    );

BYTE
_fastcall
Dns_IsStatusRcode(
    IN      DNS_STATUS      Status
    );

//
//  Name utilities (name.c)
//

PSTR 
_fastcall
Dns_GetDomainName(
    IN      PCSTR           pszName
    );

PWSTR
_fastcall
Dns_GetDomainName_W(
    IN      PCWSTR          pwsName
    );

PCHAR
_fastcall
Dns_GetTldForName(
    IN      PCSTR           pszName
    );

BOOL
_fastcall
Dns_IsNameShort(
    IN      PCSTR           pszName
    );

BOOL
_fastcall
Dns_IsNameFQDN(
    IN      PCSTR           pszName
    );

DNS_STATUS
Dns_ValidateAndCategorizeDnsNameEx(
    IN      PCHAR           pchName,
    IN      DWORD           cchNameLength,
    OUT     PDWORD          pLabelCount
    );

#define Dns_ValidateAndCategorizeDnsName(p,c)   \
        Dns_ValidateAndCategorizeDnsNameEx((p),(c),NULL)

DWORD
Dns_NameLabelCount(
    IN      PCSTR           pszName
    );

#define DNS_NAME_UNKNOWN        0x00000000
#define DNS_NAME_IS_FQDN        0x00000001
#define DNS_NAME_SINGLE_LABEL   0x00000010
#define DNS_NAME_MULTI_LABEL    0x00000100

DWORD
_fastcall
Dns_GetNameAttributes(
    IN      PCSTR           pszName
    );



//
//  Packet create\read\write (packet.c)
//

//
//  UDP packet buffer
//
//  1472 is the maximum ethernet IP\UDP payload size
//  without causing fragmentation, use as default buffer
//

#define DNS_MAX_UDP_PACKET_BUFFER_LENGTH    (1472)


//  parsing RR
//  convenient to get WIRE records into aligned\host order format

typedef struct _DNS_PARSED_RR
{
    PCHAR   pchName;
    PCHAR   pchRR;
    PCHAR   pchData;
    PCHAR   pchNextRR;

    //  note from here on down mimics wire record

    WORD    Type;
    WORD    Class;
    DWORD   Ttl;
    WORD    DataLength;
}
DNS_PARSED_RR, *PDNS_PARSED_RR;


//
//  DNS Server Message Info structure
//
//  This is structure in which requests are held while being
//  processed by the DNS server.
//

//
//  Sockaddr big enough for either IP4 or IP6
//
//  DCR:  make length field part of our sockaddr?
//

#define SIZE_IP6_SOCKADDR_DNS_PRIVATE  (28)

typedef union _DnsSockaddr
{
    SOCKADDR_IN     In4;
#ifdef _WS2TCPIP_H_
    SOCKADDR_IN6    In6;
#else
    BYTE            In6[28];
#endif
}
SOCKADDR_DNS, *PSOCKADDR_DNS;


typedef struct _DnsMessageBuf
{
    LIST_ENTRY      ListEntry;          //  for queuing

    //
    //  Addressing
    //

    SOCKET          Socket;
    INT             RemoteAddressLength;
    //16
    //SOCKADDR_IN     RemoteAddress;

    SOCKADDR_DNS    RemoteAddress;

    //
    //  Basic packet info
    //

    //32
    DWORD           BufferLength;       //  total length of buffer
    PCHAR           pBufferEnd;         //  ptr to byte after buffer

    PBYTE           pCurrent;           //  current location in buffer
    PWORD           pCurrentCountField; //  current count field being written

    //
    //  Current lookup info
    //

    // 48
    DWORD           Timeout;            //  recv timeout
    DWORD           QueryTime;          //  time of original query
    WORD            wTypeCurrent;       //  type of query being done
    WORD            wOffsetCurrent;

    //
    //  Queuing
    //

    WORD            wQueuingXid;        //  match XID to response
    //64
    DWORD           QueuingTime;        //  time queued
    DWORD           ExpireTime;         //  queue timeout

    //
    //  Basic packet flags
    //

    BOOLEAN         fTcp;
    BOOLEAN         fSwapped;           //  header in net order
    BOOLEAN         fMessageComplete;   //  complete message received
    BOOLEAN         fConvertUnicode;    //  convert to unicode
    BOOLEAN         fSocketKeepalive;   //  keep socket alive
    BOOLEAN         fLastSendOpt;       //  last send contained OPT

    //
    //  TCP message reception
    //

    //80
    PCHAR           pchRecv;            //  ptr to next pos in message

    //
    //  End of message before OPT addition
    //

    PCHAR           pPreOptEnd;

    //
    //  WARNING !
    //
    //  Message length MUST
    //      - be a WORD type
    //      - immediately preceed message itself
    //  for proper send/recv of TCP messages.
    //
    //  Use pointers above to DWORD (or QWORD) align, then recv bytes to push
    //  message length against MessageHead.  Note, that DNS_HEADER contains
    //  only WORDs as it's largest element and so should chummy up even on
    //  WORD boundary.  DWORD boundary should be very safe.
    //
                                                          
    //96
    WORD            BytesToReceive;
    WORD            MessageLength;

    //
    //  DNS Message itself
    //

    DNS_HEADER      MessageHead;

    //
    //  Question and RR section
    //
    //  This simply provides some coding simplicity in accessing
    //  this section given MESSAGE_INFO structure.
    //

    CHAR            MessageBody[1];

}
DNS_MSG_BUF, *PDNS_MSG_BUF;

#define SIZEOF_MSG_BUF_OVERHEAD (sizeof(DNS_MSG_BUF) - sizeof(DNS_HEADER) - 1)

#define DNS_MESSAGE_END(pMsg) \
                ((PCHAR)&(pMsg)->MessageHead + (pMsg)->MessageLength)

#define DNS_MESSAGE_OFFSET( pMsg, p ) \
                ((PCHAR)(p) - (PCHAR)(&(pMsg)->MessageHead))

#define DNS_MESSAGE_CURRENT_OFFSET( pMsg ) \
                DNS_MESSAGE_OFFSET( (pMsg), (pMsg)->pCurrent )

//
//  Handy for packet setup
//

#define CLEAR_DNS_HEADER_FLAGS_AND_XID( pHead )     ( *(PDWORD)(pHead) = 0 )



PDNS_MSG_BUF
Dns_AllocateMsgBuf(
    IN      WORD            wBufferLength   OPTIONAL
    );

VOID
Dns_InitializeMsgBuf(
    IN OUT  PDNS_MSG_BUF    pMsg
    );

PDNS_MSG_BUF
Dns_BuildPacket(
    IN      PDNS_HEADER     pHeader,
    IN      BOOL            fNoHeaderCounts,
    IN      PDNS_NAME       pszQuestionName,
    IN      WORD            wQuestionType,
    IN      PDNS_RECORD     pRecord,
    IN      DWORD           dwFlags,
    IN      BOOL            fUpdatePacket
    );

PCHAR
_fastcall
Dns_WriteDottedNameToPacket(
    IN OUT  PCHAR           pch,
    IN      PCHAR           pchStop,
    IN      PSTR            pszName,
    IN      PSTR            pszDomain,      OPTIONAL
    IN      WORD            wDomainOffset,  OPTIONAL
    IN      BOOL            fUnicodeName
    );

PCHAR
_fastcall
Dns_WriteStringToPacket(
    IN OUT  PCHAR           pch,
    IN      PCHAR           pchStop,
    IN      PSTR            pszString,
    IN      BOOL            fUnicodeString
    );

PCHAR
Dns_WriteQuestionToMessage(
    IN OUT  PDNS_MSG_BUF    pMsg,
    IN      PDNS_NAME       pszName,
    IN      WORD            wType,
    IN      BOOL            fUnicodeName
    );

DNS_STATUS
Dns_WriteRecordStructureToMessage(
    IN OUT  PDNS_MSG_BUF    pMsg,
    IN      WORD            wType,
    IN      WORD            wClass,
    IN      DWORD           dwTtl,
    IN      WORD            wDataLength
    );

PCHAR
Dns_WriteRecordStructureToPacketEx(
    IN OUT  PCHAR           pchBuf,
    IN      WORD            wType,
    IN      WORD            wClass,
    IN      DWORD           dwTtl,
    IN      WORD            wDataLength
    );

DNS_STATUS
Dns_WriteRecordStructureToPacket(
    IN OUT  PCHAR           pchBuf,
    IN      PDNS_RECORD     pRecord,
    IN      BOOL            fUpdatePacket
    );

VOID
Dns_SetRecordDatalength(
    IN OUT  PDNS_WIRE_RECORD    pRecord,
    IN      WORD                wDataLength
    );

DNS_STATUS
Dns_AddRecordsToMessage(
    IN OUT  PDNS_MSG_BUF    pMsg,
    IN      PDNS_RECORD     pRecord,
    IN      BOOL            fUpdateMessage
    );

PCHAR
_fastcall
Dns_SkipPacketName(
    IN      PCHAR           pch,
    IN      PCHAR           pchEnd
    );

BOOL
Dns_IsSamePacketQuestion(
    IN      PDNS_MSG_BUF    pMsg1,
    IN      PDNS_MSG_BUF    pMsg2
    );

PCHAR
_fastcall
Dns_SkipPacketRecord(
    IN      PCHAR           pchRecord,
    IN      PCHAR           pchMsgEnd
    );

PCHAR
Dns_SkipToRecord(
    IN      PDNS_HEADER     pMsgHead,
    IN      PCHAR           pMsgEnd,
    IN      INT             iCount
    );

PCHAR
Dns_ReadRecordStructureFromPacket(
    IN      PCHAR           pchPacket,
    IN      PCHAR           pchMsgEnd,
    IN OUT  PDNS_PARSED_RR  pParsedRR
    );

DNS_STATUS
Dns_ExtractRecordsFromMessage(
    IN      PDNS_MSG_BUF    pMsg,
    IN      BOOL            fUnicode,
    OUT     PDNS_RECORD *   ppRecord
    );

DNS_STATUS
Dns_ExtractRecordsFromBuffer(
    IN      PDNS_MESSAGE_BUFFER pDnsBuffer,
    IN      WORD                wMessageLength,
    IN      BOOL                fUnicode,
    OUT     PDNS_RECORD *       ppRecord
    );

void
Dns_NormalizeAllRecordTtls(
    IN      PDNS_RECORD         pRecord
    );

PCHAR
_fastcall
Dns_ReadPacketName(
    IN OUT  PCHAR           pchNameBuffer,
    OUT     PWORD           pwNameLength,
    IN OUT  PWORD           pwNameOffset,           OPTIONAL
    OUT     PBOOL           pfNameSameAsPrevious,   OPTIONAL
    IN      PCHAR           pchName,
    IN      PCHAR           pchStart,
    IN      PCHAR           pchEnd
    );

PCHAR
_fastcall
Dns_ReadPacketNameAllocate(
    IN OUT  PCHAR *         ppchName,
    OUT     PWORD           pwNameLength,
    IN OUT  PWORD           pwPrevNameOffset,       OPTIONAL
    OUT     PBOOL           pfNameSameAsPrevious,   OPTIONAL
    IN      PCHAR           pchPacketName,
    IN      PCHAR           pchStart,
    IN      PCHAR           pchEnd
    );

WORD
Dns_GetRandomXid(
    IN      PVOID           pSeed
    );


//
//  Socket setup (socket.c)
//

//
//  these two routines really don't belong here -- system stuff should be elsewhere
//

DNS_STATUS
Dns_InitializeWinsock(
    VOID
    );
VOID
Dns_CleanupWinsock(
    VOID
    );

SOCKET
Dns_CreateSocket(
    IN      INT             SockType,
    IN      IP_ADDRESS      ipAddress,
    IN      USHORT          Port
    );

SOCKET
Dns_CreateMulticastSocket(
    IN      INT             SockType,
    IN      IP_ADDRESS      ipAddress,
    IN      USHORT          Port,
    IN      BOOL            fSend,
    IN      BOOL            fReceive
    );

VOID
Dns_CloseSocket(
    IN      SOCKET          Socket
    );

VOID
Dns_CloseConnection(
    IN      SOCKET          Socket
    );

DNS_STATUS
Dns_SetupGlobalAsyncSocket(
    VOID
    );



//
//  Raw packet send and recv (send.c)
//

DNS_STATUS
Dns_SendEx(
    IN OUT  PDNS_MSG_BUF    pMsg,
    IN      IP4_ADDRESS     SendIp,     OPTIONAL
    IN      BOOL            fNoOpt
    );

#define Dns_Send( pMsg )    Dns_SendEx( (pMsg), 0, 0 )

DNS_STATUS
Dns_Recv(
    IN OUT  PDNS_MSG_BUF    pMsg
    );

DNS_STATUS
Dns_RecvUdp(
    IN OUT  PDNS_MSG_BUF    pMsg
    );

VOID
Dns_SendMultipleUdp(
    IN OUT  PDNS_MSG_BUF    pMsg,
    IN      PIP_ARRAY       aipSendAddrs
    );

DNS_STATUS
Dns_SendAndRecvUdp(
    IN OUT  PDNS_MSG_BUF    pMsgSend,
    OUT     PDNS_MSG_BUF    pMsgRecv,
    IN      DWORD           dwFlags,
    IN      PIP_ARRAY       aipServers,
    IN OUT  PDNS_NETINFO    pAdapterInfo
    );

DNS_STATUS
Dns_SendAndRecvMulticast(
    IN OUT  PDNS_MSG_BUF    pMsgSend,
    OUT     PDNS_MSG_BUF    pMsgRecv,
    IN OUT  PDNS_NETINFO    pAdapterInfo OPTIONAL
    );

DNS_STATUS
Dns_OpenTcpConnectionAndSend(
    IN OUT  PDNS_MSG_BUF    pMsg,
    IN      IP_ADDRESS      ipServer,
    IN      BOOL            fBlocking
    );

DNS_STATUS
Dns_RecvTcp(
    IN OUT  PDNS_MSG_BUF    pMsg
    );

DNS_STATUS
Dns_SendAndRecvTcp(
    IN OUT  PDNS_MSG_BUF    pMsgSend,
    OUT     PDNS_MSG_BUF    pMsgRecv,
    IN      PIP_ARRAY       aipServers,
    IN OUT  PDNS_NETINFO    pAdapterInfo
    );

VOID
Dns_InitializeMsgRemoteSockaddr(
    IN OUT  PDNS_MSG_BUF    pMsg,
    IN      IP_ADDRESS      IpAddress
    );

DNS_STATUS
Dns_SendAndRecv(
    IN OUT  PDNS_MSG_BUF    pMsgSend,
    OUT     PDNS_MSG_BUF *  ppMsgRecv,
    OUT     PDNS_RECORD *   ppResponseRecords,
    IN      DWORD           dwFlags,
    IN      PIP_ARRAY       aipServers,
    IN OUT  PDNS_NETINFO    pAdapterInfo
    );

VOID
Dns_InitQueryTimeouts(
    VOID
    );



//
//  Query (query.c)
//


//
//  Flags to DnsQuery
//
//  These are in addition to public flags in dnsapi.h
//  They must all be in the reserved section defined by
//  DNS_QUERY_RESERVED
//

//  Unicode i\o

#define     DNSQUERY_UNICODE_NAME       (0x01000000)
#define     DNSQUERY_UNICODE_OUT        (0x02000000)

//  DNS server query

#define DNS_SERVER_QUERY_NAME           (L"..DnsServers")


DNS_STATUS
Dns_QueryLib(
    IN OUT  PDNS_MSG_BUF *  ppMsgResponse,
    OUT     PDNS_RECORD *   ppRecord,
    IN      PDNS_NAME       pszName,
    IN      WORD            wType,
    IN      DWORD           dwFlags,
    IN      PIP_ARRAY       aipDnsServers,
    IN      PDNS_NETINFO    pNetworkInfo,
    IN      SOCKET          Socket OPTIONAL
    );

DNS_STATUS
Dns_QueryLibEx(
    IN OUT  PDNS_MSG_BUF *  ppMsgResponse,
    OUT     PDNS_RECORD *   ppResponseRecord,
    IN      PDNS_HEADER     pHeader,
    IN      BOOL            fNoHeaderCounts,
    IN      PDNS_NAME       pszName,
    IN      WORD            wType,
    IN      PDNS_RECORD     pRecord,
    IN      DWORD           dwFlags,
    IN      PIP_ARRAY       aipDnsServers,
    IN      PDNS_NETINFO    pNetworkInfo
    );

DNS_STATUS
Dns_FindAuthoritativeZoneLib(
    IN      PDNS_NAME       pszName,
    IN      DWORD           dwFlags,
    IN      PIP_ARRAY       aipQueryServers,
    OUT     PDNS_NETINFO *  ppNetworkInfo
    );

PDNS_NETINFO     
Dns_BuildUpdateNetworkInfoFromFAZ(
    IN      PSTR            pszZone,
    IN      PSTR            pszPrimaryDns,
    IN      PDNS_RECORD     pRecord
    );



//
//  Dynamic update (update.c)
//

PCHAR
Dns_WriteNoDataUpdateRecordToMessage(
    IN      PCHAR           pch,
    IN      PCHAR           pchStop,
    IN      WORD            wClass,
    IN      WORD            wType
    );

PCHAR
Dns_WriteDataUpdateRecordToMessage(
    IN      PCHAR           pch,
    IN      PCHAR           pchStop,
    IN      WORD            wClass,
    IN      WORD            wType,
    IN      DWORD           dwTtl,
    IN      WORD            wDataLength
    );

PDNS_MSG_BUF
Dns_BuildHostUpdateMessage(
    IN OUT  PDNS_MSG_BUF    pMsg,
    IN      PSTR            pszZone,
    IN      PSTR            pszName,
    IN      PIP_ARRAY       aipAddresses,
    IN      DWORD           dwTtl
    );

PDNS_RECORD
Dns_HostUpdateRRSet(
    IN      PSTR            pszHostName,
    IN      PIP_ARRAY       aipAddrs,
    IN      DWORD           dwTtl
    );

DNS_STATUS
Dns_UpdateHostAddrs(
    IN      PSTR            pszName,
    IN      PIP_ARRAY       aipAddresses,
    IN      PIP_ARRAY       aipServers,
    IN      DWORD           dwTtl
    );

DNS_STATUS
Dns_UpdateHostAddrsOld(
    IN      PSTR            pszName,
    IN      PIP_ARRAY       aipAddresses,
    IN      PIP_ARRAY       aipServers,
    IN      DWORD           dwTtl
    );

DNS_STATUS
Dns_UpdateLib(
    IN      PDNS_RECORD     pRecord,
    IN      DWORD           dwFlags,
    IN      PDNS_NETINFO    pNetworkInfo,
    IN      HANDLE          hCreds,         OPTIONAL
    OUT     PDNS_MSG_BUF *  ppMsgRecv       OPTIONAL
    );

DNS_STATUS
Dns_UpdateLibEx(
    IN      PDNS_RECORD     pRecord,
    IN      DWORD           dwFlags,
    IN      PDNS_NAME       pszZone,
    IN      PDNS_NAME       pszServerName,
    IN      PIP_ARRAY       aipServers,
    IN      HANDLE          hCreds,         OPTIONAL
    OUT     PDNS_MSG_BUF *  ppMsgRecv       OPTIONAL
    );



//
//  List build
//
//  pFirst points to first element in list.
//  pLast points to last element in list.
//
//  This builds a list for element types which have a pNext field
//  as their first structure member.
//

typedef struct _Dns_List
{
    PVOID   pFirst;
    PVOID   pLast;
}
DNS_LIST, *PDNS_LIST;

//
//  To init pFirst is NULL.
//  But pLast points at the location of the pFirst pointer -- essentially
//  treating the DNS_LIST as an element and pFirst as its next ptr.
//
//  During an add, the address given in pLast, is set with the new element,
//  equivalent to setting pLast's pNext field.  Then pLast is reset to point
//  at a new element.
//
//  When the first element is added to the list, pLast is pointing at the
//  DNS_LIST structure itself, so pFirst (as a dummy pNext) is set with
//  the ptr to the first element.
//
//  This works ONLY for elements which have a pNext field as the first
//  structure member.
//

#define DNS_LIST_INIT( pList )              \
        {                                   \
            PDNS_LIST _plist = (pList);     \
            _plist->pFirst = NULL;          \
            _plist->pLast = (_plist);       \
        }

#define DNS_LIST_ADD( pList, pnew )         \
        {                                   \
            PDNS_LIST   _plist = (pList);   \
            PVOID       _pnew = (pnew);         \
            *(PVOID*)(_plist->pLast) = _pnew;   \
            _plist->pLast = _pnew;              \
        }

#define IS_DNS_LIST_EMPTY( pList )          \
            ( (pList)->pFirst == NULL )


//
//  DNS_LIST as structure macros
//
//  Faster when function contains DNS_LIST structure itself and
//  NO SIDE EFFECTS will be present in call.
//

#define DNS_LIST_STRUCT_INIT( List )    \
        {                               \
            List.pFirst = NULL;         \
            List.pLast = &List;         \
        }

#define DNS_LIST_STRUCT_ADD( List, pnew ) \
        {                                           \
            *(PVOID*)(List.pLast) = (PVOID)pnew;    \
            List.pLast = (PVOID)pnew;               \
        }

#define IS_DNS_LIST_STRUCT_EMPTY( List ) \
            ( List.pFirst == NULL )



//
//  Record building (rralloc.c)
//

PDNS_RECORD
WINAPI
Dns_AllocateRecord(
    IN      WORD            wBufferLength
    );

VOID
WINAPI
Dns_RecordFree(
    IN OUT  PDNS_RECORD     pRecord
    );

#if 1
//  Old BS with flag -- kill when all fixed up

VOID
WINAPI
Dns_RecordListFreeEx(
    IN OUT  PDNS_RECORD     pRRList,
    IN      BOOL            fFreeOwner
    );

#define Dns_RecordListFree(p, f)    Dns_RecordListFreeEx(p, f)

#else   // new version
VOID
WINAPI
Dns_RecordListFree(
    IN OUT  PDNS_RECORD     pRRList
    );

#endif



PDNS_RECORD
Dns_RecordSetDetach(
    IN OUT  PDNS_RECORD     pRRList
    );

PDNS_RECORD
WINAPI
Dns_RecordListAppend(
    IN OUT  PDNS_RECORD     pHeadList,
    IN      PDNS_RECORD     pTailList
    );

DWORD
Dns_RecordListCount(
    IN      PDNS_RECORD     pRRList,
    IN      WORD            wType
    );


//
//  Record build from data strings (rrbuild.c)
//

PDNS_RECORD
Dns_RecordBuild_A(
    IN OUT  PDNS_RRSET      pRRSet,
    IN      PSTR            pszOwner,
    IN      WORD            wType,
    IN      BOOL            fAdd,
    IN      UCHAR           Section,
    IN      INT             Argc,
    IN      PCHAR *         Argv
    );

PDNS_RECORD
Dns_RecordBuild_W(
    IN OUT  PDNS_RRSET      pRRSet,
    IN      PWSTR           pszOwner,
    IN      WORD            wType,
    IN      BOOL            fAdd,
    IN      UCHAR           Section,
    IN      INT             Argc,
    IN      PWCHAR *        Argv
    );



//
//  Record set manipulation
//

//
//  Record Compare
//
//  Note:  these routines will NOT do proper unicode compare, unless
//          records have the fUnicode flag set.
//

BOOL
WINAPI
Dns_RecordCompare(
    IN      PDNS_RECORD     pRecord1,
    IN      PDNS_RECORD     pRecord2
    );

BOOL
WINAPI
Dns_RecordSetCompare(
    IN OUT  PDNS_RECORD     pRR1,
    IN OUT  PDNS_RECORD     pRR2,
    OUT     PDNS_RECORD *   ppDiff1,    OPTIONAL
    OUT     PDNS_RECORD *   ppDiff2     OPTIONAL
    );

typedef enum _DnsSetCompareResult
{
    DnsSetCompareError = (-1),
    DnsSetCompareIdentical,
    DnsSetCompareNoOverlap,
    DnsSetCompareOneSubsetOfTwo,
    DnsSetCompareTwoSubsetOfOne,
    DnsSetCompareIntersection
}
DNS_SET_COMPARE_RESULT;

DNS_SET_COMPARE_RESULT
WINAPI
Dns_RecordSetCompareEx(
    IN OUT  PDNS_RECORD     pRR1,
    IN OUT  PDNS_RECORD     pRR2,
    OUT     PDNS_RECORD *   ppDiff1,    OPTIONAL
    OUT     PDNS_RECORD *   ppDiff2     OPTIONAL
    );

BOOL
WINAPI
Dns_RecordSetCompareForIntersection(
    IN OUT  PDNS_RECORD     pRR1,
    IN OUT  PDNS_RECORD     pRR2
    );

//
//  Record set prioritization (rrsort.c)
//

BOOL
Dns_CompareIpAddresses(
    IN      IP_ADDRESS      addr1,
    IN      IP_ADDRESS      addr2,
    IN      IP_ADDRESS      subnetMask
    );


//
//  DNS Name compare
//

BOOL
Dns_NameCompare_A(
    IN      PCSTR           pName1,
    IN      PCSTR           pName2
    );

BOOL
Dns_NameCompare_W(
    IN      PCWSTR          pName1,
    IN      PCWSTR          pName2
    );

BOOL
Dns_NameCompare_UTF8(
    IN      PCSTR           pName1,
    IN      PCSTR           pName2
    );

//#define Dns_NameCompare(pName1, pName2)     Dns_NameCompare_UTF8((pName1),(pName2))
//#define Dns_NameCompare_U(pName1, pName2)   Dns_NameCompare_UTF8((pName1),(pName2))


BOOL
Dns_NameComparePrivate(
    IN      PCSTR           pName1,
    IN      PCSTR           pName2,
    IN      DNS_CHARSET     CharSet
    );

//
//  Advanced name comparison
//  Includes hierarchial name relationship.
//

DNS_NAME_COMPARE_STATUS
Dns_NameCompareEx(
    IN      LPCSTR          pszNameLeft,
    IN      LPCSTR          pszNameRight,
    IN      DWORD           dwReserved,
    IN      DNS_CHARSET     CharSet
    );

//
//  Record Copy
//

PDNS_RECORD
WINAPI
Dns_RecordCopyEx(
    IN      PDNS_RECORD     pRecord,
    IN      DNS_CHARSET     CharSetIn,
    IN      DNS_CHARSET     CharSetOut
    );

//
//  RR Set copy
//

PDNS_RECORD
WINAPI
Dns_RecordSetCopyEx(
    IN      PDNS_RECORD     pRR,
    IN      DNS_CHARSET     CharSetIn,
    IN      DNS_CHARSET     CharSetOut
    );



//
//  Record \ type routines
//
//
//  Resource record type\name mapping table
//

typedef struct
{
    PCHAR   pszTypeName;    //  type string (used in database files)
    WORD    wType;          //  type in host byte order
}
TYPE_NAME_TABLE;

extern TYPE_NAME_TABLE TypeTable[];


//
//  Max record name length, allows upcasing of incoming labels
//  to optimize comparisons
//

#define MAX_RECORD_NAME_LENGTH  (8)

//
//  Record type specific sizes
//

#define WKS_MAX_PORT                (1024)  // max well known service port
#define WKS_MAX_BITMASK_LENGTH      (128)   // 1024bits / 8bits/byte

#define SIZEOF_A6_ADDRESS_SUFFIX_LENGTH 16

#define SIZEOF_SOA_FIXED_DATA       (5 * sizeof(DWORD))
#define SIZEOF_MX_FIXED_DATA        (sizeof(WORD))
#define SIZEOF_WKS_FIXED_DATA       (SIZEOF_IP_ADDRESS + sizeof(BYTE))
#define SIZEOF_KEY_FIXED_DATA       (sizeof(DWORD))
#define SIZEOF_SIG_FIXED_DATA       (4 * sizeof(DWORD) + sizeof(WORD))
#define SIZEOF_NXT_FIXED_DATA       (0)
#define SIZEOF_LOC_FIXED_DATA       (4 * sizeof(DWORD))
#define SIZEOF_SRV_FIXED_DATA       (3 * sizeof(WORD))
#define SIZEOF_A6_FIXED_DATA        (1 + SIZEOF_A6_ADDRESS_SUFFIX_LENGTH)

#define SIZEOF_TKEY_FIXED_DATA      (2 * sizeof(DWORD) + 4 * sizeof(WORD))

#define SIZEOF_TSIG_PRE_SIG_FIXED_DATA  (2 * sizeof(DWORD) + sizeof(WORD))
#define SIZEOF_TSIG_POST_SIG_FIXED_DATA (3 * sizeof(WORD))
#define SIZEOF_TSIG_FIXED_DATA          (2 * sizeof(DWORD) + 4 * sizeof(WORD))

#define SIZEOF_WINS_FIXED_DATA      (4 * sizeof(DWORD))
#define SIZEOF_NBSTAT_FIXED_DATA    (3 * sizeof(DWORD))

//
//  Record type routines
//  These ones are of possible public interest and exposed in dnsapi.dll
//

BOOL
_fastcall
Dns_IsAMailboxType(
    IN      WORD            wType
    );

WORD
Dns_RecordTypeForName(
    IN      PCHAR           pszName,
    IN      INT             cchNameLength
    );

BOOL
Dns_WriteStringForType_A(
    OUT     PCHAR           pBuffer,
    IN      WORD            wType
    );

BOOL
Dns_WriteStringForType_W(
    OUT     PWCHAR          pBuffer,
    IN      WORD            wType
    );

PCHAR
Dns_RecordStringForType(
    IN      WORD            wType
    );

PCHAR
Dns_RecordStringForWritableType(
    IN      WORD            wType
    );

//
//  Record type specific stuff
//

BOOL
Dns_IsStringCountValidForTextType(
    IN      WORD            wType,
    IN      WORD            StringCount
    );


//
//  ATMA conversions
//

DWORD
Dns_AtmaAddressLengthForAddressString(
    IN      PCHAR           pchString,
    IN      DWORD           dwStringLength
    );

DNS_STATUS
Dns_AtmaStringToAddress(
    OUT     PBYTE           pAddress,
    IN OUT  PDWORD          pdwAddrLength,
    IN      PCHAR           pchString,
    IN      DWORD           dwStringLength
    );

PCHAR
Dns_AtmaAddressToString(
    OUT     PCHAR           pchString,
    IN      UCHAR           AddrType,
    IN      PBYTE           pAddress,
    IN      DWORD           dwAddrLength
    );

//
//  DNSSEC SIG and KEY routines
//

//  Max key is 4096 bit giving 512 byte length.
//
//  Max string representation is actually 33% larger as each three byte (24bit)
//  block contains four base64 characters.

#define DNS_MAX_KEY_LENGTH              (512)

#define DNS_MAX_KEY_STRING_LENGTH       (685)


WORD
Dns_KeyRecordFlagForString(
    IN      PCHAR           pchName,
    IN      INT             cchNameLength
    );

PCHAR
Dns_KeyRecordFlagString(
    IN      DWORD           dwFlag,
    IN OUT  PCHAR           pchFlag
    );

UCHAR
Dns_KeyRecordProtocolForString(
    IN      PCHAR           pchName,
    IN      INT             cchNameLength
    );

PCHAR
Dns_GetKeyProtocolString(
    IN      UCHAR           uchProtocol
    );

UCHAR
Dns_SecurityAlgorithmForString(
    IN      PCHAR           pchName,
    IN      INT             cchNameLength
    );

PCHAR
Dns_GetDnssecAlgorithmString(
    IN      UCHAR           uchAlgorithm
    );

UCHAR
Dns_SecurityBase64CharToBits(
    IN      CHAR            ch64
    );

DNS_STATUS
Dns_SecurityBase64StringToKey(
    OUT     PBYTE           pKey,
    OUT     PDWORD          pKeyLength,
    IN      PCHAR           pchString,
    IN      DWORD           cchLength
    );

PCHAR
Dns_SecurityKeyToBase64String(
    IN      PBYTE           pKey,
    IN      DWORD           KeyLength,
    OUT     PCHAR           pchBuffer
    );

LONG
Dns_ParseSigTime(
    IN      PCHAR           pchString,
    IN      INT             cchLength
    );

PCHAR
Dns_SigTimeString(
    IN      LONG            SigTime,
    OUT     PCHAR           pchBuffer
    );


//
//  WINS \ WINS-R types detection
//

#define IS_WINS_TYPE(type)      (((type) & 0xfffc) == 0xff00)

//
//  MS WINS mapping flags
//

//  return on invalid WINS flag

#define DNS_WINS_FLAG_ERROR     (-1)

//  max length of WINS flags
//  pass buffer at least this big

#define WINS_FLAG_MAX_LENGTH    (80)


DWORD
Dns_WinsRecordFlagForString(
    IN      PCHAR           pchName,
    IN      INT             cchNameLength
    );

PCHAR
Dns_WinsRecordFlagString(
    IN      DWORD           dwFlag,
    IN OUT  PCHAR           pchFlag
    );

//
//  must sit here until PDNS_RECORD defined in public dns.h header
//

DNS_STATUS
Dns_RecordWriteFileString(
    IN      PDNS_RECORD     pRecord,
    IN      PSTR            pszZoneName,
    IN      DWORD           dwDefaultTtl    OPTIONAL
    );




//
//  IP Address to\from string utilities (straddr.c)
//

//
//  String to Address
//

BOOL
Dns_Ip4StringToAddress_W(
    OUT     PIP4_ADDRESS    pIp4Addr,
    IN      PCWSTR          pwString
    );

BOOL
Dns_Ip4StringToAddress_A(
    OUT     PIP4_ADDRESS    pIp4Addr,
    IN      PCSTR           pString
    );

BOOL
Dns_Ip6StringToAddress_A(
    OUT     PIP6_ADDRESS    pIp6Addr,
    IN      PCSTR           pString
    );

BOOL
Dns_Ip6StringToAddress_W(
    OUT     PIP6_ADDRESS    pIp6Addr,
    IN      PCWSTR          pwString
    );

//
//  Combined IP4\IP6 string to address
//

BOOL
Dns_StringToAddress_W(
    OUT     PCHAR           pAddrBuf,
    IN OUT  PDWORD          pBufLength,
    IN      PCWSTR          pString,
    IN OUT  PDWORD          pAddrFamily
    );

BOOL
Dns_StringToAddress_A(
    OUT     PCHAR           pAddrBuf,
    IN OUT  PDWORD          pBufLength,
    IN      PCSTR           pString,
    IN OUT  PDWORD          pAddrFamily
    );


//
//  Address to string 
//

PWCHAR
Dns_Ip6AddressToString_W(
    OUT     PWCHAR          pwString,
    IN      PIP6_ADDRESS    pIp6Addr
    );

PCHAR
Dns_Ip6AddressToString_A(
    OUT     PCHAR           pchString,
    IN      PIP6_ADDRESS    pIp6Addr
    );

PWCHAR
Dns_Ip4AddressToString_W(
    OUT     PWCHAR          pwString,
    IN      PIP4_ADDRESS    pIp4Addr
    );

PCHAR
Dns_Ip4AddressToString_A(
    OUT     PCHAR           pString,
    IN      PIP4_ADDRESS    pIp4Addr
    );

//
//  Address to string -- combined
//

PCHAR
Dns_AddressToString_A(
    OUT     PCHAR           pchString,
    IN OUT  PDWORD          pStringLength,
    IN      PBYTE           pAddr,
    IN      DWORD           AddrLength,
    IN      DWORD           AddrFamily
    );


//
//  Reverse lookup address-to-name IP4
//

PCHAR
Dns_Ip4AddressToReverseName_A(
    OUT     PCHAR           pBuffer,
    IN      IP4_ADDRESS     IpAddr
    );

PWCHAR
Dns_Ip4AddressToReverseName_W(
    OUT     PWCHAR          pBuffer,
    IN      IP4_ADDRESS     IpAddr
    );

PCHAR
Dns_Ip4AddressToReverseNameAlloc_A(
    IN      IP4_ADDRESS     IpAddr
    );

PWCHAR
Dns_Ip4AddressToReverseNameAlloc_W(
    IN      IP4_ADDRESS     IpAddr
    );

//
//  Reverse lookup address-to-name IP6
//

PCHAR
Dns_Ip6AddressToReverseName_A(
    OUT     PCHAR           pBuffer,
    IN      IP6_ADDRESS     Ip6Addr
    );

PWCHAR
Dns_Ip6AddressToReverseName_W(
    OUT     PWCHAR          pBuffer,
    IN      IP6_ADDRESS     Ip6Addr
    );

PCHAR
Dns_Ip6AddressToReverseNameAlloc_A(
    IN      IP6_ADDRESS     Ip6Addr
    );

PWCHAR
Dns_Ip6AddressToReverseNameAlloc_W(
    IN      IP6_ADDRESS     Ip6Addr
    );

//
//  Reverse lookup name-to-address
//

BOOL
Dns_Ip4ReverseNameToAddress_A(
    OUT     PIP4_ADDRESS    pIp4Addr,
    IN      PCSTR           pszName
    );

BOOL
Dns_Ip4ReverseNameToAddress_W(
    OUT     PIP4_ADDRESS    pIp4Addr,
    IN      PCWSTR          pwsName
    );

BOOL
Dns_Ip6ReverseNameToAddress_A(
    OUT     PIP6_ADDRESS    pIp6Addr,
    IN      PCSTR           pszName
    );

BOOL
Dns_Ip6ReverseNameToAddress_W(
    OUT     PIP6_ADDRESS    pIp6Addr,
    IN      PCWSTR          pwsName
    );

//
//  Combined IP4\IP6 reverse lookup name-to-address
//

BOOL
Dns_ReverseNameToAddress_W(
    OUT     PCHAR           pAddrBuf,
    IN OUT  PDWORD          pBufLength,
    IN      PCWSTR          pString,
    IN OUT  PDWORD          pAddrFamily
    );

BOOL
Dns_ReverseNameToAddress_A(
    OUT     PCHAR           pAddrBuf,
    IN OUT  PDWORD          pBufLength,
    IN      PCSTR           pString,
    IN OUT  PDWORD          pAddrFamily
    );



//
//  String utilities (string.c)
//
//  Note some of these require memory allocation, see note
//  on memory allocation below.
//
//  Flags are defined in dnsapi.h
//

//#define DNS_ALLOW_RFC_NAMES_ONLY    (0)
//#define DNS_ALLOW_NONRFC_NAMES      (0x00000001)
//#define DNS_ALLOW_MULTIBYTE_NAMES   (0x00000002)
//#define DNS_ALLOW_ALL_NAMES         (0x00000003)

//
//  Unicode name buffer length.
//  Non-type specific routines below take buffer counts in bytes.
//  Unicode buffers of max name length have twice the bytes.
//

#define DNS_MAX_NAME_BUFFER_LENGTH_UNICODE  (2 * DNS_MAX_NAME_BUFFER_LENGTH)


//
//  Macros to simplify UTF8 conversions
//
//  UTF8 is simply a representation of unicode that maps one-to-one
//  for the ASCII space.
//  Unicode                     UTF8
//  -------                     ----
//      < 0x80 (128)    ->      use low byte (one-to-one mapping)
//      < 0x07ff        ->      two chars
//      > 0x07ff        ->      three chars
//

#define UTF8_1ST_OF_2     0xc0      //  110x xxxx
#define UTF8_1ST_OF_3     0xe0      //  1110 xxxx
#define UTF8_TRAIL        0x80      //  10xx xxxx

#define UTF8_2_MAX        0x07ff    //  max unicode character representable in
                                    //  in two byte UTF8


//
//  Explicitly UTF8 string
//

typedef PSTR    PU8STR;


PSTR 
Dns_CreateStringCopy(
    IN      PCHAR           pchString,
    IN      DWORD           cchString
    );

DWORD
Dns_GetBufferLengthForStringCopy(
    IN      PCHAR           pchString,
    IN      DWORD           cchString,
    IN      DNS_CHARSET     CharSetIn,
    IN      DNS_CHARSET     CharSetOut
    );

DWORD
Dns_StringCopy(
    OUT     PBYTE           pBuffer,
    IN OUT  PDWORD          pdwBufLength,
    IN      PCHAR           pchString,
    IN      DWORD           cchString,
    IN      DNS_CHARSET     CharSetIn,
    IN      DNS_CHARSET     CharSetOut
    );

PVOID
Dns_StringCopyAllocate(
    IN      PCHAR           pchString,
    IN      DWORD           cchString,
    IN      DNS_CHARSET     CharSetIn,
    IN      DNS_CHARSET     CharSetOut
    );

#define Dns_StringCopyAllocate_W( p, c )  \
        ( (PWCHAR) Dns_StringCopyAllocate(  \
                    (PCHAR) (p),            \
                    (c),                    \
                    DnsCharSetUnicode,      \
                    DnsCharSetUnicode ) )

#define Dns_StringCopyAllocate_A( p, c )  \
        ( (PCHAR) Dns_StringCopyAllocate(   \
                    (p),                    \
                    (c),                    \
                    DnsCharSetUtf8,         \
                    DnsCharSetUtf8 ) )


PSTR
Dns_CreateStringCopy_A(
    IN      PCSTR           pwsString
    );

PWSTR
Dns_CreateStringCopy_W(
    IN      PCWSTR          pwsString
    );

PWSTR
Dns_CreateConcatenatedString_W(
    IN      PCWSTR *        pStringArray
    );

PWSTR 
Dns_GetResourceString(
    IN      DWORD           dwStringId,
    IN      PWSTR           pwszBuffer,
    IN      DWORD           cbBuffer
    );

INT
wcsicmp_ThatWorks(
    IN      PWSTR           pString1,
    IN      PWSTR           pString2
    );


//
//  Special DNS name string functions
//

#define Dns_GetBufferLengthForNameCopy(a,b,c,d)\
        Dns_GetBufferLengthForStringCopy((a),(b),(c),(d))

#define Dns_NameCopy(a,b,c,d,e,f) \
        Dns_StringCopy(a,b,c,d,e,f)

#define Dns_NameCopyAllocate(a,b,c,d) \
        Dns_StringCopyAllocate(a,b,c,d)



//
//  Name validation (string.c)
//

DNS_STATUS
Dns_ValidateName_UTF8(
    IN      LPCSTR          pszName,
    IN      DNS_NAME_FORMAT Format
    );

DNS_STATUS
Dns_ValidateName_W(
    IN      LPCWSTR         pwszName,
    IN      DNS_NAME_FORMAT Format
    );

DNS_STATUS
Dns_ValidateName_A(
    IN      LPCSTR          pszName,
    IN      DNS_NAME_FORMAT Format
    );


DNS_STATUS
Dns_ValidateDnsString_UTF8(
    IN      LPCSTR          pszName
    );

DNS_STATUS
Dns_ValidateDnsString_W(
    IN      LPCWSTR         pszName
    );

PSTR 
Dns_CreateStandardDnsNameCopy(
    IN      PCHAR           pchName,
    IN      DWORD           cchName,
    IN      DWORD           dwFlag
    );


//
//  UTF8 conversions (utf8.c)
//

DNS_STATUS
_fastcall
Dns_ValidateUtf8Byte(
    IN      BYTE            chUtf8,
    IN OUT  PDWORD          pdwTrailCount
    );

DWORD
_fastcall
Dns_UnicodeToUtf8(
    IN      PWCHAR          pwUnicode,
    IN      DWORD           cchUnicode,
    OUT     PCHAR           pchResult,
    IN      DWORD           cchResult
    );

DWORD
_fastcall
Dns_Utf8ToUnicode(
    IN      PCHAR           pchUtf8,
    IN      DWORD           cchUtf8,
    OUT     PWCHAR          pwResult,
    IN      DWORD           cwResult
    );

DWORD
Dns_Utf8ToOrFromAnsi(
    OUT     PCHAR           pchResult,
    IN      DWORD           cchResult,
    IN      PCHAR           pchIn,
    IN      DWORD           cchIn,
    IN      DNS_CHARSET     InCharSet,
    IN      DNS_CHARSET     OutCharSet
    );

DWORD
Dns_AnsiToUtf8(
    IN      PCHAR           pchAnsi,
    IN      DWORD           cchAnsi,
    OUT     PCHAR           pchResult,
    IN      DWORD           cchResult
    );

DWORD
Dns_Utf8ToAnsi(
    IN      PCHAR           pchUtf8,
    IN      DWORD           cchUtf8,
    OUT     PCHAR           pchResult,
    IN      DWORD           cchResult
    );

BOOL
_fastcall
Dns_IsStringAscii(
    IN      PSTR            pszString
    );

BOOL
_fastcall
Dns_IsStringAsciiEx(
    IN      PCHAR           pchString,
    IN      DWORD           cchString
    );

BOOL
_fastcall
Dns_IsWideStringAscii(
    IN      PWSTR           pwsString
    );




//
//  Resource record dispatch tables
//
//  Resource record tables are indexed by type for standard types
//  These define limits on tables.
//
//  Currently indexing out to RR 40, so that we'll handle any new RR types
//  out this far without interfering with WINS stuff.
//

#define MAX_SELF_INDEXED_TYPE   (48)

//
//  Mappings for non-self indexed types
//
//  Note:  these are presented here for information purposes only!
//
//  Always call Dns_RecordTableIndexForType(wType) to get correct index.
//

#define TKEY_TYPE_INDEX         (MAX_SELF_INDEXED_TYPE + 1)
#define TSIG_TYPE_INDEX         (MAX_SELF_INDEXED_TYPE + 2)

#define WINS_TYPE_INDEX         (MAX_SELF_INDEXED_TYPE + 3)
#define WINSR_TYPE_INDEX        (MAX_SELF_INDEXED_TYPE + 4)

//  End of actual record types.
//  Query type indexes may extend beyond this index.

#define MAX_RECORD_TYPE_INDEX   (MAX_SELF_INDEXED_TYPE + 4)

//
//  Generic indexer for both regular and extended (non-self-indexing) types
//

#define INDEX_FOR_TYPE(type)    Dns_RecordTableIndexForType(type)


//
//  Type to index mapping
//

WORD
Dns_RecordTableIndexForType(
    IN      WORD            wType
    );


//
//  Write record data to wire
//

typedef PCHAR (* RR_WRITE_FUNCTION)(
                            PDNS_RECORD,
                            PCHAR,
                            PCHAR );

extern  RR_WRITE_FUNCTION   RRWriteTable[];

//
//  Read record data from wire
//

typedef PDNS_RECORD (* RR_READ_FUNCTION)(
                            PDNS_RECORD,
                            DNS_CHARSET,
                            PCHAR,
                            PCHAR,
                            PCHAR );

extern  RR_READ_FUNCTION   RRReadTable[];


//
//  Proto type TSIG read from wire function
//

PDNS_RECORD
TsigRecordRead(
    IN OUT  PDNS_RECORD     pRR,
    IN      DNS_CHARSET     OutCharSet,
    IN OUT  PCHAR           pchStart,
    IN      PCHAR           pchData,
    IN      PCHAR           pchEnd
    );

PDNS_RECORD
TkeyRecordRead(
    IN OUT  PDNS_RECORD     pRR,
    IN      DNS_CHARSET     OutCharSet,
    IN OUT  PCHAR           pchStart,
    IN      PCHAR           pchData,
    IN      PCHAR           pchEnd
    );

//
//  Copy record
//

typedef PDNS_RECORD (* RR_COPY_FUNCTION)(
                            PDNS_RECORD,
                            DNS_CHARSET,
                            DNS_CHARSET );

extern  RR_COPY_FUNCTION   RRCopyTable[];


//
//  Compare record data
//

typedef BOOL (* RR_COMPARE_FUNCTION)(
                            PDNS_RECORD,
                            PDNS_RECORD );

extern  RR_COMPARE_FUNCTION RRCompareTable[];


//
//  Generic print routine
//
//  All our print routines will take the real print routine
//  as a parameter.  This routine must have "sprintf-like"
//  or "fprintf-like" semantics.  In other words a context,
//  format and variable number of arguments.
//
//  Note the context argument is effectively a PVOID --
//  different routines will have different contexts.  The
//  explicit definition is to enforce strong type checking
//  so a call without a context is caught on compile.
//  

typedef struct _DnsPrintContext
{
    PVOID   pvDummy;
    DWORD   Dummy;
}
PRINT_CONTEXT, *PPRINT_CONTEXT;

typedef VOID (* PRINT_ROUTINE)(
                    PPRINT_CONTEXT,
                    CHAR*,
                    ... );

//
//  Print record
//

typedef VOID (* RR_PRINT_FUNCTION)(
                            PRINT_ROUTINE,
                            PPRINT_CONTEXT,
                            PDNS_RECORD );

extern  RR_PRINT_FUNCTION   RRPrintTable[];

//
//  Build from argc\argv data strings
//

typedef PDNS_RECORD (* RR_BUILD_FUNCTION)(
                            DWORD,
                            PCHAR * );

extern  RR_BUILD_FUNCTION   RRBuildTable[];

typedef PDNS_RECORD (* RR_BUILD_FUNCTION_W)(
                            DWORD,
                            PWCHAR * );

extern  RR_BUILD_FUNCTION_W   RRBuildTableW[];




//
//  RnR utilities
//

DWORD
Dns_RnrLupFlagForString(
    IN      PCHAR           pchName,
    IN      INT             cchNameLength
    );

PCHAR
Dns_GetRnrLupFlagString(
    IN      DWORD           dwFlag
    );

DWORD
Dns_RnrNameSpaceIdForString(
    IN      PCHAR           pchName,
    IN      INT             cchNameLength
    );

PCHAR
Dns_GetRnrNameSpaceIdString(
    IN      DWORD           dwFlag
    );


//
//  Hostent utilities
//

BOOL
Hostent_IsSupportedAddrType(
    IN      WORD            wType
    );

DWORD
Hostent_Size(
    IN      PHOSTENT        pHostent,
    IN      DNS_CHARSET     CharSetExisting,
    IN      DNS_CHARSET     CharSetTarget,
    IN      PDWORD          pAliasCount,
    IN      PDWORD          pAddrCount
    );

PHOSTENT
Hostent_Copy(
    IN OUT  PBYTE *         ppBuffer,
    IN OUT  PINT            pBufferSize,
    OUT     PINT            pHostentSize,
    IN      PHOSTENT        pHostent,
    IN      DNS_CHARSET     CharSetIn,
    IN      DNS_CHARSET     CharSetTarget,
    IN      BOOL            fOffsets,
    IN      BOOL            fAlloc
    );

DWORD
Hostent_WriteIp4Addrs(
    IN OUT  PHOSTENT        pHostent,
    OUT     PCHAR           pAddrBuf,
    IN      DWORD           MaxBufCount,
    IN      PIP4_ADDRESS    Ip4Array,
    IN      DWORD           ArrayCount,
    IN      BOOL            fScreenZero
    );

DWORD
Hostent_WriteLocalIp4Array(
    IN OUT  PHOSTENT        pHostent,
    OUT     PCHAR           pAddrBuf,
    IN      DWORD           MaxBufCount,
    IN      PIP_ARRAY       pIpArray
    );

BOOL
Hostent_IsAddressInHostent(
    IN OUT  PHOSTENT        pHostent,
    IN      PCHAR           pAddr,
    IN      DWORD           AddrLength,
    IN      INT             Family          OPTIONAL
    );

BOOL
Hostent_IsIp4AddressInHostent(
    IN OUT  PHOSTENT        pHostent,
    IN      IP4_ADDRESS     Ip4Addr
    );


//
//  Hostent Object
//

typedef struct _HostentBlob
{
    PHOSTENT    pHostent;

    //  flags
    BOOL        fAllocatedBlob;
    BOOL        fAllocatedBuf;

    //  buffer allocated
    PCHAR       pBuffer;
    DWORD       BufferLength;

    DWORD       AvailLength;
    PCHAR       pAvailBuffer;

    //  buffer in build
    PCHAR       pCurrent;
    DWORD       BytesLeft;

    //  sizing info
    DWORD       MaxAliasCount;
    DWORD       MaxAddrCount;

    //  hostent building
    DWORD       AliasCount;
    DWORD       AddrCount;
    BOOL        fWroteName;
    DNS_CHARSET CharSet;
    BOOL        fUnicode;
}
HOSTENT_BLOB, *PHOSTENT_BLOB;


typedef struct _HostentInitRequest
{
    INT         AddrFamily;
    WORD        wType;
    DWORD       AddrCount;
    BOOL        fUnicode;
    DNS_CHARSET CharSet;
    DWORD       NameLength;
    PBYTE       pName;
    DWORD       AliasCount;
    DWORD       AliasNameLength;
}
HOSTENT_INIT, *PHOSTENT_INIT;


DNS_STATUS
HostentBlob_Create(
    IN OUT  PHOSTENT_BLOB * ppBlob,
    IN      PHOSTENT_INIT   pReq
    );

PHOSTENT_BLOB
HostentBlob_CreateAttachExisting(
    IN      PHOSTENT        pHostent,
    IN      BOOL            fUnicode
    );

VOID
HostentBlob_Free(
    IN OUT  PHOSTENT_BLOB   pBlob
    );

DNS_STATUS
HostentBlob_WriteAddress(
    IN OUT  PHOSTENT_BLOB   pBlob,
    IN      PVOID           pAddress,
    IN      DWORD           AddrSize,
    IN      DWORD           AddrType
    );

DNS_STATUS
HostentBlob_WriteAddressArray(
    IN OUT  PHOSTENT_BLOB   pBlob,
    IN      PVOID           pAddrArray,
    IN      DWORD           AddrCount,
    IN      DWORD           AddrSize,
    IN      DWORD           AddrType
    );

DNS_STATUS
HostentBlob_WriteNameOrAlias(
    IN OUT  PHOSTENT_BLOB   pBlob,
    IN      PSTR            pszName,
    IN      BOOL            fAlias,
    IN      BOOL            fUnicode
    );

DNS_STATUS
HostentBlob_WriteRecords(
    IN OUT  PHOSTENT_BLOB   pBlob,
    IN      PDNS_RECORD     pRecords,
    IN      BOOL            fWriteName
    );

//  Special hostents

PHOSTENT_BLOB
Hostent_Localhost(
    IN      INT             AddrFamily
    );

DNS_STATUS
HostentBlob_CreateFromIpArray(
    IN OUT  PHOSTENT_BLOB * ppBlob,
    IN      INT             AddrFamily,
    IN      INT             AddrSize,
    IN      INT             AddrCount,
    IN      PCHAR           pArray,
    IN      PSTR            pName,
    IN      BOOL            fUnicode
    );

DNS_STATUS
HostentBlob_CreateLocal(
    IN OUT  PHOSTENT_BLOB * ppBlob,
    IN      INT             AddrFamily,
    IN      BOOL            fLoopback,
    IN      BOOL            fZero,
    IN      BOOL            fHostnameOnly
    );

//  Query for hostent

PHOSTENT_BLOB
HostentBlob_Query(
    IN      PWSTR           pwsName,
    IN      WORD            wType,
    IN      DWORD           Flags,
    IN OUT  PVOID *         ppMsg,      OPTIONAL
    IN      INT             AddrFamily  OPTIONAL
    );



//
//  Memory allocation
//
//  Some DNS library functions -- including the IP array and string utils
//  -- allocate memory.  This memory allocation defaults to routines that
//  use LocalAlloc, LocalReAlloc, LocalFree.  If you desire alternative
//  memory allocation mechanisms, use this function to override the DNS
//  library defaults.  All memory allocated by the DNS library, should
//  then be freed by the corresponding function.
//

typedef PVOID   (* DNSLIB_ALLOC_FUNCTION)();
typedef PVOID   (* DNSLIB_REALLOC_FUNCTION)();
typedef VOID    (* DNSLIB_FREE_FUNCTION)();

VOID
Dns_LibHeapReset(
    IN      DNSLIB_ALLOC_FUNCTION   pAlloc,
    IN      DNSLIB_REALLOC_FUNCTION pRealloc,
    IN      DNSLIB_FREE_FUNCTION    pFree
    );

//
//  These routines call the currently registered allocation functions
//  whether default or reset through Dns_ApiHeapReset()
//

PVOID
Dns_Alloc(
    IN      INT             iSize
    );

PVOID
Dns_AllocZero(
    IN      INT             iSize
    );

PVOID
Dns_Realloc(
    IN OUT  PVOID           pMem,
    IN      INT             iSize
    );

VOID
Dns_Free(
    IN OUT  PVOID           pMem
    );

PVOID
Dns_AllocMemCopy(
    IN      PVOID           pMem,
    IN      INT             iSize
    );



//
//  Print routines (print.c)
//
//  Print routines below use any printf() like function to print.
//  this is typedef that function must match.
//

//
//  Print Locking
//

VOID
DnsPrint_InitLocking(
    IN      PCRITICAL_SECTION   pLock
    );

VOID
DnsPrint_Lock(
    VOID
    );

VOID
DnsPrint_Unlock(
    VOID
    );

#define Dns_PrintInitLocking(a)     DnsPrint_InitLocking(a)
#define Dns_PrintLock()             DnsPrint_Lock()
#define Dns_PrintUnlock()           DnsPrint_Unlock()

//
//  Print routines for general types and structures
//

VOID
DnsPrint_String(
    IN      PRINT_ROUTINE   PrintRoutine,
    IN OUT  PPRINT_CONTEXT  pContext,
    IN      PSTR            pszHeader,      OPTIONAL
    IN      PSTR            pszString,
    IN      BOOL            fUnicode,
    IN      PSTR            pszTrailer      OPTIONAL
    );

VOID
DnsPrint_StringCharSet(
    IN      PRINT_ROUTINE   PrintRoutine,
    IN OUT  PPRINT_CONTEXT  pContext,
    IN      PSTR            pszHeader,      OPTIONAL
    IN      PSTR            pszString,
    IN      DNS_CHARSET     CharSet,
    IN      PSTR            pszTrailer      OPTIONAL
    );

VOID
DnsPrint_Utf8StringBytes(
    IN      PRINT_ROUTINE   PrintRoutine,
    IN OUT  PPRINT_CONTEXT  pContext,
    IN      PSTR            pszHeader,
    IN      PCHAR           pUtf8,
    IN      DWORD           Length
    );

VOID
DnsPrint_UnicodeStringBytes(
    IN      PRINT_ROUTINE   PrintRoutine,
    IN OUT  PPRINT_CONTEXT  pContext,
    IN      PSTR            pszHeader,
    IN      PWCHAR          pUnicode,
    IN      DWORD           Length
    );

VOID
DnsPrint_StringArray(
    IN      PRINT_ROUTINE   PrintRoutine,
    IN OUT  PPRINT_CONTEXT  pContext,
    IN      PSTR            pszHeader,
    IN      PSTR *          StringArray,
    IN      DWORD           Count,          OPTIONAL
    IN      BOOL            fUnicode
    );

VOID
DnsPrint_Argv(
    IN      PRINT_ROUTINE   PrintRoutine,
    IN OUT  PPRINT_CONTEXT  pContext,
    IN      PSTR            pszHeader,
    IN      CHAR **         Argv,
    IN      DWORD           Argc,            OPTIONAL
    IN      BOOL            fUnicode
    );

VOID
DnsPrint_DwordArray(
    IN      PRINT_ROUTINE   PrintRoutine,
    IN OUT  PPRINT_CONTEXT  pContext,
    IN      PSTR            pszHeader,
    IN      PSTR            pszName,
    IN      DWORD           dwCount,
    IN      PDWORD          adwArray
    );

VOID
DnsPrint_IpAddressArray(
    IN      PRINT_ROUTINE   PrintRoutine,
    IN OUT  PPRINT_CONTEXT  pContext,
    IN      PSTR            pszHeader,
    IN      PSTR            pszName,
    IN      DWORD           dwIpAddrCount,
    IN      PIP_ADDRESS     pIpAddrs
    );

VOID
DnsPrint_IpArray(
    IN      PRINT_ROUTINE   PrintRoutine,
    IN OUT  PPRINT_CONTEXT  pContext,
    IN      PSTR            pszHeader,
    IN      PSTR            pszName,
    IN      PIP_ARRAY       pIpArray
    );

VOID
DnsPrint_Ip6Address(
    IN      PRINT_ROUTINE   PrintRoutine,
    IN OUT  PPRINT_CONTEXT  pContext,
    IN      PSTR            pszHeader,
    IN      PIP6_ADDRESS    pIp6Address,
    IN      PSTR            pszTrailer
    );

VOID
DnsPrint_Guid(
    IN      PRINT_ROUTINE   PrintRoutine,
    IN OUT  PPRINT_CONTEXT  pContext,
    IN      PSTR            pszHeader,
    IN      PGUID           pGuid
    );

//
//  Winsock \ RnR types and structures
//

VOID
DnsPrint_FdSet(
    IN      PRINT_ROUTINE   PrintRoutine,
    IN OUT  PPRINT_CONTEXT  pContext,
    IN      PSTR            pszHeader,
    IN      struct fd_set * pFdSet
    );

VOID
DnsPrint_Sockaddr(
    IN      PRINT_ROUTINE   PrintRoutine,
    IN OUT  PPRINT_CONTEXT  pContext,
    IN      PSTR            pszHeader,
    IN      DWORD           Indent,
    IN      PSOCKADDR       pSockaddr,
    IN      INT             iSockaddrLength
    );

#ifdef  _WS2TCPIP_H_
VOID
DnsPrint_AddrInfo(
    IN      PRINT_ROUTINE   PrintRoutine,
    IN OUT  PPRINT_CONTEXT  pContext,
    IN      PSTR            pszHeader,
    IN      DWORD           Indent,
    IN      PADDRINFO       pAddrInfo
    );

VOID
DnsPrint_AddrInfoList(
    IN      PRINT_ROUTINE   PrintRoutine,
    IN OUT  PPRINT_CONTEXT  pContext,
    IN      PSTR            pszHeader,
    IN      DWORD           Indent,
    IN      PADDRINFO       pAddrInfo
    );
#endif

#ifdef  _WINSOCK2API_
VOID
DnsPrint_SocketAddress(
    IN      PRINT_ROUTINE   PrintRoutine,
    IN OUT  PPRINT_CONTEXT  pContext,
    IN      PSTR            pszHeader,
    IN      DWORD           Indent,
    IN      PSOCKET_ADDRESS pSocketAddress
    );

VOID
DnsPrint_CsAddr(
    IN      PRINT_ROUTINE   PrintRoutine,
    IN OUT  PPRINT_CONTEXT  pContext,
    IN      PSTR            pszHeader,
    IN      DWORD           Indent,
    IN      PCSADDR_INFO    pCsAddrInfo
    );

VOID
DnsPrint_AfProtocolsArray(
    IN      PRINT_ROUTINE   PrintRoutine,
    IN OUT  PPRINT_CONTEXT  pContext,
    IN      PSTR            pszHeader,
    IN      PAFPROTOCOLS    pProtocolArray,
    IN      DWORD           ProtocolCount
    );

VOID
DnsPrint_WsaQuerySet(
    IN      PRINT_ROUTINE   PrintRoutine,
    IN OUT  PPRINT_CONTEXT  pContext,
    IN      PSTR            pszHeader,
    IN      LPWSAQUERYSET   pQuerySet,
    IN      BOOL            fUnicode
    );

VOID
DnsPrint_WsaNsClassInfo(
    IN      PRINT_ROUTINE   PrintRoutine,
    IN OUT  PPRINT_CONTEXT  pContext,
    IN      PSTR            pszHeader,
    IN      PWSANSCLASSINFO pInfo,
    IN      BOOL            fUnicode
    );

VOID
DnsPrint_WsaServiceClassInfo(
    IN      PRINT_ROUTINE           PrintRoutine,
    IN OUT  PPRINT_CONTEXT          pContext,
    IN      PSTR                    pszHeader,
    IN      LPWSASERVICECLASSINFO   pInfo,
    IN      BOOL                    fUnicode
    );
#endif

VOID
DnsPrint_Hostent(
    IN      PRINT_ROUTINE   PrintRoutine,
    IN OUT  PPRINT_CONTEXT  pContext,
    IN      PSTR            pszHeader,
    IN      PHOSTENT        pHostent,
    IN      BOOL            fUnicode
    );

//
//  Print routines for DNS types and structures
//

VOID
DnsPrint_Message(
    IN      PRINT_ROUTINE   PrintRoutine,
    IN OUT  PPRINT_CONTEXT  pContext,
    IN      PSTR            pszHeader,
    IN      PDNS_MSG_BUF    pMsg
    );

VOID
DnsPrint_MessageNoContext(
    IN      PRINT_ROUTINE   PrintRoutine,
    IN OUT  PPRINT_CONTEXT  pContext,
    IN      PSTR            pszHeader,
    IN      PDNS_HEADER     pMsgHead,
    IN      WORD            wLength
    );

INT
DnsPrint_PacketName(
    IN      PRINT_ROUTINE   PrintRoutine,
    IN OUT  PPRINT_CONTEXT  pContext,
    IN      PSTR            pszHeader,      OPTIONAL
    IN      PBYTE           pMsgName,
    IN      PDNS_HEADER     pMsgHead,       OPTIONAL
    IN      PBYTE           pMsgEnd,        OPTIONAL
    IN      PSTR            pszTrailer      OPTIONAL
    );

INT
DnsPrint_PacketRecord(
    IN      PRINT_ROUTINE       PrintRoutine,
    IN OUT  PPRINT_CONTEXT      pContext,
    IN      PSTR                pszHeader,
    IN      PDNS_WIRE_RECORD    pMsgRR,
    IN      PDNS_HEADER         pMsgHead,       OPTIONAL
    IN      PBYTE               pMsgEnd         OPTIONAL
    );

VOID
DnsPrint_ParsedRecord(
    IN      PRINT_ROUTINE   PrintRoutine,
    IN OUT  PPRINT_CONTEXT  pContext,
    IN      PSTR            pszHeader,
    IN      PDNS_PARSED_RR  pParsedRR
    );

VOID
DnsPrint_RawOctets(
    IN      PRINT_ROUTINE   PrintRoutine,
    IN OUT  PPRINT_CONTEXT  pContext,
    IN      PSTR            pszHeader,
    IN      PSTR            pszLineHeader,
    IN      PCHAR           pchData,
    IN      DWORD           dwLength
    );

VOID
DnsPrint_ParsedMessage(
    IN      PRINT_ROUTINE       PrintRoutine,
    IN OUT  PPRINT_CONTEXT      pContext,
    IN      PSTR                pszHeader,
    IN      PDNS_PARSED_MESSAGE pParsed
    );

VOID
DnsPrint_HostentBlob(
    IN      PRINT_ROUTINE   PrintRoutine,
    IN OUT  PPRINT_CONTEXT  pContext,
    IN      PSTR            pszHeader,
    IN      PHOSTENT_BLOB   pBlob
    );

//
//  Print to string
//

#define GUID_STRING_BUFFER_LENGTH   (80)

DWORD
DnsStringPrint_Guid(
    OUT     PCHAR           pBuffer,
    IN      PGUID           pGuid
    );

DWORD
DnsStringPrint_RawOctets(
    OUT     PCHAR           pBuffer,
    IN      PCHAR           pchData,
    IN      DWORD           dwLength,
    IN      PSTR            pszLineHeader,
    IN      DWORD           dwLineLength
    );

//
//  Print related utilities
//

INT
Dns_WriteFormattedSystemTimeToBuffer(
    OUT     PCHAR           pBuffer,
    IN      PSYSTEMTIME     pSystemTime
    );

INT
Dns_WritePacketNameToBuffer(
    OUT     PCHAR           pBuffer,
    OUT     PCHAR *         ppBufferOut,
    IN      PBYTE           pMsgName,
    IN      PDNS_HEADER     pMsgHead,       OPTIONAL
    IN      PBYTE           pMsgEnd         OPTIONAL
    );

PCHAR
Dns_ResponseCodeString(
    IN      INT     ResponseCode
    );

PCHAR
Dns_ResponseCodeExplanationString(
    IN      INT     ResponseCode
    );

PCHAR
Dns_KeyFlagString(
    IN OUT      PCHAR   pszBuff,
    IN          WORD    flags
    );

PCHAR
Dns_OpcodeString(
    IN      INT     Opcode
    );

CHAR
Dns_OpcodeCharacter(
    IN      INT     Opcode
    );

PCHAR
Dns_SectionNameString(
    IN      INT     iSection,
    IN      INT     iOpcode
    );

//
//  Record printing (rrprint.c)
//

VOID
DnsPrint_Record(
    IN      PRINT_ROUTINE   PrintRoutine,
    IN OUT  PPRINT_CONTEXT  pContext,
    IN      PSTR            pszHeader,
    IN      PDNS_RECORD     pRecord,
    IN      PDNS_RECORD     pPreviousRecord     OPTIONAL
    );

VOID
DnsPrint_RecordSet(
    IN      PRINT_ROUTINE   PrintRoutine,
    IN OUT  PPRINT_CONTEXT  pContext,
    IN      PSTR            pszHeader,
    IN      PDNS_RECORD     pRecord
    );

//
//  Macros to get correct string type (utf8\unicode) for printing.
//

//  Empty string for simple switching of UTF-8/Unicode print

extern DWORD   DnsEmptyString;

#define pDnsEmptyString         ( (PSTR) &DnsEmptyString )
#define pDnsEmptyWideString     ( (PWSTR) &DnsEmptyString )


#define DNSSTRING_UTF8( fUnicode, String ) \
        ( (fUnicode) ? pDnsEmptyString : (PSTR)(String) )

#define DNSSTRING_ANSI( fUnicode, String ) \
        ( (fUnicode) ? pDnsEmptyString : (PSTR)(String) )

#define DNSSTRING_WIDE( fUnicode, String ) \
        ( (fUnicode) ? (PWSTR)(String) : pDnsEmptyWideString )

#define RECSTRING_UTF8( pRR, String ) \
        DNSSTRING_UTF8( IS_UNICODE_RECORD(pRR), (String) )

#define RECSTRING_WIDE( pRR, String ) \
        DNSSTRING_WIDE( IS_UNICODE_RECORD(pRR), (String) )


#define PRINT_STRING_WIDE_CHARSET( String, CharSet ) \
        ( ((CharSet)==DnsCharSetUnicode) ? (PWSTR)(String) : pDnsEmptyWideString )

#define PRINT_STRING_ANSI_CHARSET( String, CharSet ) \
        ( ((CharSet)==DnsCharSetUnicode) ? pDnsEmptyString : (PSTR)(String) )



//
//  Debugging
//
//  Debug routines.
//

VOID
Dns_StartDebugEx(
    IN      DWORD           DebugFlag,
    IN      PSTR            pszFlagFile,
    IN OUT  PDWORD          pdwExternalFlag,
    IN      PSTR            pszLogFile,
    IN      DWORD           WrapSize,
    IN      BOOL            fUseGlobalFile,
    IN      BOOL            fUseGlobalFlag,
    IN      BOOL            fSetGlobals
    );

VOID
Dns_StartDebug(
    IN      DWORD           DebugFlag,
    IN      PSTR            pszFlagFile,
    IN OUT  PDWORD          pdwExternalFlag,
    IN      PSTR            pszLogFile,
    IN      DWORD           WrapSize
    );

VOID
Dns_EndDebug(
    VOID
    );

VOID
Dns_Assert(
    IN      PSTR            pszFile,
    IN      INT             LineNo,
    IN      PSTR            pszExpr
    );

VOID
DnsDbg_PrintfToDebugger(
    IN      PSTR            Format,
    ...
    );

VOID
DnsDbg_Printf(
    IN      PSTR            Format,
    ...
    );

VOID
DnsDbg_PrintRoutine(
    IN OUT  PPRINT_CONTEXT  pContext,
    IN      PSTR            Format,
    ...
    );

VOID
DnsDbg_Flush(
    VOID
    );

VOID
DnsDbg_WrapLogFile(
    VOID
    );

VOID
DnsDbg_CSEnter(
    IN      PCRITICAL_SECTION   pLock,
    IN      PSTR                pszLockName,
    IN      PSTR                pszFile,
    IN      INT                 LineNo
    );

VOID
DnsDbg_CSLeave(
    IN      PCRITICAL_SECTION   pLock,
    IN      PSTR                pszLockName,
    IN      PSTR                pszFile,
    IN      INT                 LineNo
    );



//
//  Debug flag test
//
//  We make the test against a pointer here which allows library
//  client application to point at a flag that may be dynamically
//  reset.
//

extern  PDWORD  pDnsDebugFlag;
#define IS_DNSDBG_ON(flag)      (*pDnsDebugFlag & DNS_DBG_ ## flag)


//
//  Debugging Bit Flags
//
//  These flags control gross output and are the same for all users
//

#define DNS_DBG_BREAKPOINTS     0x00000001
#define DNS_DBG_DEBUGGER        0x00000002
#define DNS_DBG_FILE            0x00000004
#define DNS_DBG_EVENTLOG        0x00000008
#define DNS_DBG_EXCEPT          0x00000008

#define DNS_DBG_TIMESTAMP       0x10000000
#define DNS_DBG_CONSOLE         0x20000000
#define DNS_DBG_START_BREAK     0x40000000
#define DNS_DBG_FLUSH           0x80000000

#define DNS_DBG_ANY             0xffffffff
#define DNS_DBG_ALL             0xffffffff
#define DNS_DBG_OFF             (0x0)

//
//  Flags specific to library
//

#define DNS_DBG_IPARRAY         0x00000020
#define DNS_DBG_INIT            0x00000040
#define DNS_DBG_REGISTRY        0x00000040
#define DNS_DBG_SOCKET          0x00000040
#define DNS_DBG_WRITE           0x00000080
#define DNS_DBG_READ            0x00000080

#define DNS_DBG_RPC             0x00000100
#define DNS_DBG_STUB            0x00000100
#define DNS_DBG_RECV            0x00000200
#define DNS_DBG_SEND            0x00000400
#define DNS_DBG_TCP             0x00000800

#define DNS_DBG_TRACE           0x00001000
#define DNS_DBG_HOSTENT         0x00001000
#define DNS_DBG_UPDATE          0x00002000
#define DNS_DBG_SECURITY        0x00004000
#define DNS_DBG_QUERY           0x00008000

#define DNS_DBG_HEAP            0x00010000
#define DNS_DBG_HEAPDBG         0x00020000
#define DNS_DBG_NETINFO         0x00040000
#define DNS_DBG_RNR             0x00080000

//
//  High output detail debugging
//

#define DNS_DBG_RECURSE2        0x00100000
#define DNS_DBG_UPDATE2         0x00200000
#define DNS_DBG_SECURITY2       0x00400000

#define DNS_DBG_RPC2            0x01000000
#define DNS_DBG_STUB2           0x01000000
#define DNS_DBG_INIT2           0x01000000
#define DNS_DBG_NETINFO2        0x01000000
#define DNS_DBG_PARSE2          0x01000000
#define DNS_DBG_LOOKUP2         0x02000000
#define DNS_DBG_WRITE2          0x04000000
#define DNS_DBG_READ2           0x04000000
#define DNS_DBG_LOCK            0x08000000
#define DNS_DBG_LOCKS           0x08000000
#define DNS_DBG_STRING          0x10000000

#define DNS_DBG_HEAP2           0x10000000
#define DNS_DBG_HEAP_CHECK      0x10000000




//
//  Debug macros
//
//  Macros that include debug code in debug versions only,
//  these macro are NULL for retail versions.
//

#if DBG

#define STATIC

#define DNS_PRINT(_a_)          ( DnsDbg_Printf _a_ )

#define DnsPrintfPtrToFunc      DnsDbg_PrintRoutine

#define IF_DNSDBG(flag)         if ( IS_DNSDBG_ON(flag) )
#define ELSE_IF_DNSDBG(flag)    else if ( IS_DNSDBG_ON(flag) )
#define ELSE                    else

#define DNSDBG(flag, _printlist_)   \
        IF_DNSDBG( flag )           \
        {                           \
            ( DnsDbg_Printf _printlist_ ); \
        }

//  protect debug prints with print lock

#define DnsDbg_Lock()           DnsPrint_Lock()
#define DnsDbg_Unlock()         DnsPrint_Unlock()


//
//  Probe
//

#define PROBE(p)    (*p)

//
//  Assert Macros
//

#define DNS_ASSERT( expr )  \
{                       \
    if ( !(expr) )      \
    {                   \
        Dns_Assert( __FILE__, __LINE__, # expr );    \
    }                   \
}

#define TEST_ASSERT( expr )     DNS_ASSERT( expr )

#define FAIL( msg )                         \
{                                           \
    DNS_PRINT(( "FAILURE:  %s\n", msg ));   \
    DNS_ASSERT( FALSE );                    \
}


//
//  Asserts on trailing else
//

#define ELSE_ASSERT( expr ) \
            else                \
            {                   \
                DNS_ASSERT( expr ); \
            }

#define ELSE_ASSERT_FALSE \
            else                \
            {                   \
                DNS_ASSERT( FALSE );\
            }

#define ELSE_FAIL( msg ) \
            else                \
            {                   \
                FAIL( msg );    \
            }

//
//  Assert and print message
//

#define DNS_MSG_ASSERT( pMsg, expr )  \
{                       \
    if ( !(expr) )      \
    {                   \
        debug_MessageBuffer( "FAILED MESSAGE:", (pMsg) ); \
        Dns_Assert( __FILE__, __LINE__, # expr );    \
    }                   \
}


//
//  Debug types and structures
//

#define DnsPR   DnsDbg_PrintRoutine

#define DnsDbg_String(a,b,c,d)              DnsPrint_String(DnsPR,NULL,a,b,c,d)
#define DnsDbg_UnicodeStringBytes(a,b,c)    DnsPrint_UnicodeStringBytes(DnsPR,NULL,a,b,c)
#define DnsDbg_Utf8StringBytes(a,b,c)       DnsPrint_Utf8StringBytes(DnsPR,NULL,a,b,c)
#define DnsDbg_StringArray(a,b,c,d)         DnsPrint_StringArray(DnsPR,NULL,a,b,c,d)
#define DnsDbg_Argv(a,b,c,d)                DnsPrint_Argv(DnsPR,NULL,a,b,c,d)
#define DnsDbg_DwordArray(a,b,c,d)          DnsPrint_DwordArray(DnsPR,NULL,a,b,c,d)
#define DnsDbg_IpAddressArray(a,b,c,d)      DnsPrint_IpAddressArray(DnsPR,NULL,a,b,c,d)
#define DnsDbg_IpArray(a,b,c)               DnsPrint_IpArray(DnsPR,NULL,a,b,c)
#define DnsDbg_Ip6Address(a,b,c)            DnsPrint_Ip6Address(DnsPR,NULL,a,b,c)
#define DnsDbg_Guid(a,b)                    DnsPrint_Guid(DnsPR,NULL,a,b)

#define DnsDbg_FdSet(a,b)                   DnsPrint_FdSet(DnsPR,NULL,a,b)
#define DnsDbg_Sockaddr(a,b,c)              DnsPrint_Sockaddr(DnsPR,NULL,a,0,b,c)
#define DnsDbg_SocketAddress(a,b)           DnsPrint_SocketAddress(DnsPR,NULL,a,0,b)
#define DnsDbg_CsAddr(a,b)                  DnsPrint_CsAddr(DnsPR,NULL,a,0,b)
#define DnsDbg_AfProtocolsArray(a,b,c)      DnsPrint_AfProtocolsArray(DnsPR,NULL,a,b,c)
#define DnsDbg_WsaQuerySet(a,b,c)           DnsPrint_WsaQuerySet(DnsPR,NULL,a,b,c)
#define DnsDbg_WsaNsClassInfo(a,b,c)        DnsPrint_WsaNsClassInfo(DnsPR,NULL,a,b,c)
#define DnsDbg_WsaServiceClassInfo(a,b,c)   DnsPrint_WsaServiceClassInfo(DnsPR,NULL,a,b,c)
#define DnsDbg_Hostent(a,b,c)               DnsPrint_Hostent(DnsPR,NULL,a,b,c)
#define DnsDbg_AddrInfo(a,b)                DnsPrint_AddrInfo(DnsPR,NULL,a,0,b)
#define DnsDbg_HostentBlob(a,b)             DnsPrint_HostentBlob(DnsPR,NULL,a,b)

#define DnsDbg_DnsMessage(a,b)              DnsPrint_DnsMessage(DnsPR,NULL,a,b)
#define DnsDbg_Message(a,b)                 DnsPrint_Message(DnsPR,NULL,a,b)
#define DnsDbg_MessageNoContext(a,b,c)      DnsPrint_MessageNoContext(DnsPR,NULL,a,b,c)
#define DnsDbg_Compression(a,b)             DnsPrint_Compression(DnsPR,NULL,a,b)
#define DnsDbg_PacketRecord(a,b,c,d)        DnsPrint_PacketRecord(DnsPR,NULL,a,b,c,d)
#define DnsDbg_PacketName(a,b,c,d,e)        DnsPrint_PacketName(DnsPR,NULL,a,b,c,d,e)
#define DnsDbg_ParsedMessage(a,b)           DnsPrint_ParsedMessage(DnsPR,NULL,(a),(b))

#define DnsDbg_RawOctets(a,b,c,d)           DnsPrint_RawOctets(DnsPR,NULL,a,b,c,d)
#define DnsDbg_Record(a,b)                  DnsPrint_Record(DnsPR,NULL,a,b,NULL)
#define DnsDbg_RecordSet(a,b)               DnsPrint_RecordSet(DnsPR,NULL,a,b)

//  backcompat special on sockaddr

#define DnsDbg_SockaddrIn(a,b,c)            DnsPrint_Sockaddr(DnsPR,NULL,a,0,(PSOCKADDR)b,c)



//
//  Non-Debug
//

#else

#define STATIC static

//
//  Define away debugging operations
//

#define IF_DNSDBG(a)                if (0)
#define ELSE_IF_DNSDBG(a)           if (0)
#define ELSE                        if (0)
#define DNSDBG(flag, _printlist_)
#define DNS_PRINT(_printlist_)

#define DnsDbg_Lock()
#define DnsDbg_Unlock()

#define DnsDbg_CSEnter(a,b,c,d)
#define DnsDbg_CSLeave(a,b,c,d)

#define DnsDbg_String(a,b,c,d)          
#define DnsDbg_UnicodeStringBytes(a,b,c)
#define DnsDbg_Utf8StringBytes(a,b,c)   
#define DnsDbg_DwordArray(a,b,c,d)      
#define DnsDbg_StringArray(a,b,c,d)
#define DnsDbg_Argv(a,b,c,d)            
#define DnsDbg_IpAddressArray(a,b,c,d)  
#define DnsDbg_IpArray(a,b,c)           
#define DnsDbg_Ip6Address(a,b,c)
#define DnsDbg_Guid(a,b)

#define DnsDbg_FdSet(a,b)               
#define DnsDbg_Sockaddr(a,b,c)          
#define DnsDbg_SocketAddress(a,b)       
#define DnsDbg_CsAddr(a,b)              
#define DnsDbg_AfProtocolsArray(a,b,c)
#define DnsDbg_WsaQuerySet(a,b,c)       
#define DnsDbg_WsaNsClassInfo(a,b,c)
#define DnsDbg_WsaServiceClassInfo(a,b,c)
#define DnsDbg_Hostent(a,b,c)       
#define DnsDbg_AddrInfo(a,b)
#define DnsDbg_HostentBlob(a,b)

#define DnsDbg_DnsMessage(a,b)          
#define DnsDbg_Message(a,b)             
#define DnsDbg_MessageNoContext(a,b,c)  
#define DnsDbg_Compression(a,b)         
#define DnsDbg_PacketRecord(a,b,c,d)    
#define DnsDbg_PacketName(a,b,c,d,e)    
#define DnsDbg_ParsedMessage(a,b)

#define DnsDbg_RawOctets(a,b,c,d)       
#define DnsDbg_Record(a,b)              
#define DnsDbg_RecordSet(a,b)           


//  backcompat special on sockaddr

#define DnsDbg_SockaddrIn(a,b,c)        

//
//  Handle complilation of DnsPrintf used as passed parameter to
//  print routines
//

#define DnsPrintfPtrToFunc  printf

//
//  Eliminate ASSERTs in retail product
//

#define DNS_ASSERT( expr )
#define TEST_ASSERT( expr )
#define ELSE_ASSERT( expr )
#define ELSE_ASSERT_FALSE
#define DNS_MSG_ASSERT( expr, pMsg )

#define FAIL( msg )
#define ELSE_FAIL( msg )

#define PROBE(p)

#endif // non-DBG



#ifdef __cplusplus
}
#endif  // __cplusplus

#endif // _DNSLIB_INCLUDED_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\public\internal\ds\inc\dnsapi.h ===
/*++

Copyright (c) 1997-2001  Microsoft Corporation

Module Name:

    dnsapi.h

Abstract:

    Domain Name System (DNS)

    DNS Client API Library

Author:

    Jim Gilroy (jamesg)     December 7, 1996

Revision History:

--*/


#ifndef _DNSAPI_INCLUDED_
#define _DNSAPI_INCLUDED_

#ifndef _WINSOCK2API_
#ifndef _WINSOCKAPI_
#include <winsock2.h>
#endif
#endif

#include <windns.h>


#ifdef __cplusplus
extern "C"
{
#endif  // __cplusplus


//
//  do backward compat?
//

#define BACKCOMPAT 1


//
//  DCR:   add to winerror.h
//

#define DNS_ERROR_REFFERAL_PACKET        9506L


//
//  NOTE:  DO NOT USE these IP definitions.
//
//  They are for backward compatibility only.
//  Use the definitions in windns.h instead.
//

//
//  IP Address
//

typedef IP4_ADDRESS  IP_ADDRESS, *PIP_ADDRESS;

#define SIZEOF_IP_ADDRESS            (4)
#define IP_ADDRESS_STRING_LENGTH    (15)

#define IP_STRING( IpAddress )  inet_ntoa( *(struct in_addr *)&(IpAddress) )

//
//  IP Address Array type
//

typedef IP4_ARRAY   IP_ARRAY, *PIP_ARRAY;

//
//  IPv6 Address
//
//  DCR:  remove IPV6_ADDRESS when clean
//

typedef DNS_IP6_ADDRESS     IPV6_ADDRESS, *PIPV6_ADDRESS;


//
//  Byte flipping macros
//

#define FlipUnalignedDword( pDword ) \
            (DWORD)ntohl( *(UNALIGNED DWORD *)(pDword) )

#define FlipUnalignedWord( pWord )  \
            (WORD)ntohs( *(UNALIGNED WORD *)(pWord) )

//  Inline is faster, but NO side effects allowed in marco argument

#define InlineFlipUnaligned48Bits( pch )            \
            ( ( *(PUCHAR)(pch)        << 40 ) |     \
              ( *((PUCHAR)(pch) + 1)  << 32 ) |     \
              ( *((PUCHAR)(pch) + 2)  << 24 ) |     \
              ( *((PUCHAR)(pch) + 3)  << 16 ) |     \
              ( *((PUCHAR)(pch) + 4)  <<  8 ) |     \
              ( *((PUCHAR)(pch) + 5)  )     )

#define InlineFlipUnalignedDword( pch )             \
            ( ( *(PUCHAR)(pch)        << 24 ) |     \
              ( *((PUCHAR)(pch) + 1)  << 16 ) |     \
              ( *((PUCHAR)(pch) + 2)  <<  8 ) |     \
              ( *((PUCHAR)(pch) + 3)  )     )

#define InlineFlipUnalignedWord( pch )  \
            ( ((WORD)*((PUCHAR)(pch)) << 8) + (WORD)*((PUCHAR)(pch) + 1) )


//
//  Unaligned write without flipping
//

#define WRITE_UNALIGNED_WORD( pout, word ) \
            ( *(UNALIGNED WORD *)(pout) = word )

#define WRITE_UNALIGNED_DWORD( pout, dword ) \
            ( *(UNALIGNED DWORD *)(pout) = dword )



//
//  Non-wrapping seconds timer (timer.c)
//

DWORD
GetCurrentTimeInSeconds(
    VOID
    );


//
//  General DNS utilities (dnsutil.c)
//

PSTR 
_fastcall
DnsGetDomainName(
    IN  PSTR    pszName
    );

PSTR 
_fastcall
DnsStatusString(
    IN  DNS_STATUS  Status
    );

#define DnsStatusToErrorString_A(status)    DnsStatusString(status)

DNS_STATUS
_fastcall
DnsMapRcodeToStatus(
    IN  BYTE    ResponseCode
    );

BYTE
_fastcall
DnsIsStatusRcode(
    IN  DNS_STATUS  Status
    );

//
//  Machines IP address list (iplist.c)
//
//  Routine to get the current IP addresses from all adapters
//  configured for the machine.
//

DWORD
DnsGetIpAddressList(
    OUT     PIP_ARRAY *     ppIpAddresses
    );

//
//  Routine to get the current IP addresses and subnet masks
//  from all adapters configured for the machine.
//

typedef struct _DNS_ADDRESS_INFO_
{
    IP_ADDRESS ipAddress;
    IP_ADDRESS subnetMask;
}
DNS_ADDRESS_INFO, *PDNS_ADDRESS_INFO;

DWORD
DnsGetIpAddressInfoList(
    OUT     PDNS_ADDRESS_INFO * ppAddrInfo
    );


//
// Routines and structures for getting network configuration information
// for TCPIP interfaces
//

#define NETINFO_FLAG_IS_WAN_ADAPTER             (0x00000002)
#define NETINFO_FLAG_IS_AUTONET_ADAPTER         (0x00000004)
#define NETINFO_FLAG_IS_DHCP_CFG_ADAPTER        (0x00000008)
#define NETINFO_FLAG_REG_ADAPTER_DOMAIN_NAME    (0x00000010)
#define NETINFO_FLAG_REG_ADAPTER_ADDRESSES      (0x00000020)


typedef struct
{
    IP_ADDRESS      ipAddress;
    DWORD           Priority;
}
DNS_SERVER_INFORMATION, *PDNS_SERVER_INFORMATION;

//  backcompat
#define NAME_SERVER_INFORMATION     DNS_SERVER_INFORMATION
#define PNAME_SERVER_INFORMATION    PDNS_SERVER_INFORMATION


typedef struct
{
    PSTR                    pszAdapterGuidName;
    PSTR                    pszDomain;
    PIP_ARRAY               pIPAddresses;
    PIP_ARRAY               pIPSubnetMasks;
    DWORD                   InfoFlags;
    DWORD                   cServerCount;
    DNS_SERVER_INFORMATION  aipServers[1];
}
DNS_ADAPTER_INFORMATION, *PDNS_ADAPTER_INFORMATION;

//  backcompat
#define ADAPTER_INFORMATION     DNS_ADAPTER_INFORMATION
#define PADAPTER_INFORMATION    PDNS_ADAPTER_INFORMATION


typedef struct
{
    PSTR            pszPrimaryDomainName;
    DWORD           cNameCount;
    PSTR            aSearchListNames[1];
}
DNS_SEARCH_INFORMATION, *PDNS_SEARCH_INFORMATION;

//  backcompat
#define SEARCH_INFORMATION      DNS_SEARCH_INFORMATION
#define PSEARCH_INFORMATION     PDNS_SEARCH_INFORMATION


typedef struct
{
    PDNS_SEARCH_INFORMATION     pSearchInformation;
    DWORD                       cAdapterCount;
    PDNS_ADAPTER_INFORMATION    aAdapterInfoList[1];
}
DNS_NETWORK_INFORMATION, *PDNS_NETWORK_INFORMATION;

//  backcompat
#define NETWORK_INFORMATION     DNS_NETWORK_INFORMATION
#define PNETWORK_INFORMATION    PDNS_NETWORK_INFORMATION


#if 0
//  these are replaced by the DnsQueryConfigAlloc()
//  and DnsFreeConfigStructure()

PDNS_NETWORK_INFORMATION
WINAPI
DnsGetNetworkInformation(
    void
    );

PDNS_SEARCH_INFORMATION
WINAPI
DnsGetSearchInformation(
    void
    );

//
//  DCR:  should expose only a single "type free" routine
//

VOID
WINAPI
DnsFreeAdapterInformation(
    IN  PDNS_ADAPTER_INFORMATION    pAdapterInformation
    );

VOID
WINAPI
DnsFreeSearchInformation(
    IN  PDNS_SEARCH_INFORMATION     pSearchInformation
    );

VOID
WINAPI
DnsFreeNetworkInformation(
    IN  PDNS_NETWORK_INFORMATION    pNetworkInformation
    );
#endif



//
//  Resource record type utilities (record.c)
//

BOOL
_fastcall
DnsIsAMailboxType(
    IN  WORD    wType
    );

WORD
DnsRecordTypeForName(
    IN  PCHAR   pszName,
    IN  INT     cchNameLength
    );

PCHAR
DnsRecordStringForType(
    IN  WORD    wType
    );

PCHAR
DnsRecordStringForWritableType(
    IN  WORD    wType
    );

BOOL
DnsIsStringCountValidForTextType(
    IN  WORD    wType,
    IN  WORD    StringCount
    );

BOOL
DnsIpv6StringToAddress(
    OUT     PIP6_ADDRESS    pAddress,
    IN      PCHAR           pchString,
    IN      DWORD           dwStringLength
    );

VOID
DnsIpv6AddressToString(
    OUT     PCHAR           pchString,
    IN      PIP6_ADDRESS    pAddress
    );


//
//  Record building (rralloc.c)
//

PDNS_RECORD
WINAPI
DnsAllocateRecord(
    IN      WORD        wBufferLength
    );

PDNS_RECORD
DnsCreatePtrRecord(
    IN      IP_ADDRESS      IpAddress,
    IN      LPTSTR          pszHostName,
    IN      BOOL            fUnicodeName
    );


//
//  Record build from data strings (rrbuild.c)
//

PDNS_RECORD
DnsRecordBuild_UTF8(
    IN OUT  PDNS_RRSET      pRRSet,
    IN      PSTR            pszOwner,
    IN      WORD            wType,
    IN      BOOL            fAdd,
    IN      UCHAR           Section,
    IN      INT             Argc,
    IN      PCHAR *         Argv
    );

PDNS_RECORD
DnsRecordBuild_W(
    IN OUT  PDNS_RRSET      pRRSet,
    IN      PWSTR           pszOwner,
    IN      WORD            wType,
    IN      BOOL            fAdd,
    IN      UCHAR           Section,
    IN      INT             Argc,
    IN      PWCHAR *        Argv
    );



//
//  Parsing
//

#ifdef PDNS_PARSED_MESSAGE
#undef PDNS_PARSED_MESSAGE
#endif

typedef struct _DnsParseMessage
{
    DNS_STATUS      Status;
    DNS_CHARSET     CharSet;

    DNS_HEADER      Header;

    WORD            QuestionType;
    WORD            QuestionClass;
    PTSTR           pQuestionName;

    PDNS_RECORD     pAnswerRecords;
    PDNS_RECORD     pAliasRecords;
    PDNS_RECORD     pAuthorityRecords;
    PDNS_RECORD     pAdditionalRecords;
    PDNS_RECORD     pSigRecords;
}
DNS_PARSED_MESSAGE, *PDNS_PARSED_MESSAGE;


#define DNS_PARSE_FLAG_NO_QUESTION      (0x00000001)
#define DNS_PARSE_FLAG_NO_ANSWER        (0x00000002)
#define DNS_PARSE_FLAG_NO_AUTHORITY     (0x00000004)
#define DNS_PARSE_FLAG_NO_ADDITIONAL    (0x00000008)
#define DNS_PARSE_FLAG_NO_SIG           (0x00000100)
#define DNS_PARSE_FLAG_NO_KEY           (0x00000200)

#define DNS_PARSE_FLAG_NO_DATA          (0x0000030f)
#define DNS_PARSE_FLAG_NO_RECORDS       (0x0000030e)
#define DNS_PARSE_FLAG_NO_DNSSEC        (0x00000300)

#define DNS_PARSE_FLAG_ONLY_QUESTION    (0x01000000)
#define DNS_PARSE_FLAG_RCODE_ALL        (0x02000000)



DNS_STATUS
Dns_ParseMessage(
    OUT     PDNS_PARSED_MESSAGE pParse,
    IN      PDNS_MESSAGE_BUFFER pDnsBuffer,
    IN      WORD                wMessageLength,
    IN      DWORD               Flags,
    IN      DNS_CHARSET         CharSet
    );



//
//  Query
//

//
//  Flags NOT in windns.h
//

#define DNS_QUERY_ACCEPT_PARTIAL_UDP        DNS_QUERY_ACCEPT_TRUNCATED_RESPONSE
#define DNS_QUERY_MULTICAST_ONLY            0x00040000
#define DNS_QUERY_USE_QUICK_TIMEOUTS        0x00080000

//  Exposed in Win2K SDK -- deprecated

//#define DNS_QUERY_SOCKET_KEEPALIVE          0x00000100
#define DNS_QUERY_ALLOW_EMPTY_AUTH_RESP     0x00010000



//
//  Extended query
//

typedef struct _DnsQueryInfo
{
    LPTSTR              pName;
    WORD                Type;
    WORD                Rcode;
    DWORD               Flags;
    DNS_STATUS          Status;
    DNS_CHARSET         CharSet;

    PDNS_RECORD         pAnswerRecords;
    PDNS_RECORD         pAliasRecords;
    PDNS_RECORD         pAdditionalRecords;
    PDNS_RECORD         pAuthorityRecords;

    HANDLE              hEvent;
    PIP4_ARRAY          pDnsServers;

    PVOID               pMessage;
    PVOID               pReservedName;
}
DNS_QUERY_INFO, *PDNS_QUERY_INFO;


DNS_STATUS
WINAPI
DnsQueryExW(
    IN OUT  PDNS_QUERY_INFO pQueryInfo
    );
     
DNS_STATUS
WINAPI
DnsQueryExA(
    IN OUT  PDNS_QUERY_INFO pQueryInfo
    );

DNS_STATUS
WINAPI
DnsQueryExUTF8(
    IN OUT  PDNS_QUERY_INFO pQueryInfo
    );

#ifdef UNICODE
#define DnsQueryEx  DnsQueryExW
#else
#define DnsQueryEx  DnsQueryExA
#endif



//
// Options for DnsCheckNameCollision
//

#define DNS_CHECK_AGAINST_HOST_ANY              0x00000000
#define DNS_CHECK_AGAINST_HOST_ADDRESS          0x00000001
#define DNS_CHECK_AGAINST_HOST_DOMAIN_NAME      0x00000002


DNS_STATUS WINAPI
DnsCheckNameCollision_A(
    IN      PCSTR           pszName,
    IN      DWORD           fOptions
    );

DNS_STATUS WINAPI
DnsCheckNameCollision_UTF8(
    IN      PCSTR           pszName,
    IN      DWORD           fOptions
    );

DNS_STATUS WINAPI
DnsCheckNameCollision_W(
    IN      PCWSTR          pszName,
    IN      DWORD           fOptions
    );

#ifdef UNICODE
#define DnsDnsCheckNameCollision DnsCheckNameCollision_W
#else
#define DnsDnsCheckNameCollision DnsCheckNameCollision_A
#endif



//
//  DNS Update API
//
//      DnsAcquireContextHandle
//      DnsReleaseContextHandle
//      DnsModifyRecordsInSet
//      DnsReplaceRecordSet
//

//
//  Update flags NOT in windns.h
//

#define DNS_UPDATE_SECURITY_CHOICE_MASK     0x000001ff


DNS_STATUS
WINAPI
DnsUpdateTest_A(
    IN  HANDLE      hContextHandle OPTIONAL,
    IN  PCSTR       pszName,
    IN  DWORD       fOptions,
    IN  PIP_ARRAY   aipServers  OPTIONAL
    );

DNS_STATUS
WINAPI
DnsUpdateTest_UTF8(
    IN  HANDLE      hContextHandle OPTIONAL,
    IN  PCSTR       pszName,
    IN  DWORD       fOptions,
    IN  PIP_ARRAY   aipServers  OPTIONAL
    );

DNS_STATUS
WINAPI
DnsUpdateTest_W(
    IN  HANDLE      hContextHandle OPTIONAL,
    IN  PCWSTR      pszName,
    IN  DWORD       fOptions,
    IN  PIP_ARRAY   aipServers OPTIONAL
    );

#ifdef UNICODE
#define DnsUpdateTest DnsUpdateTest_W
#else
#define DnsUpdateTest DnsUpdateTest_A
#endif


IP_ADDRESS
WINAPI
DnsGetLastServerUpdateIP(
    VOID
    );

typedef struct _DnsFailedUpdateInfo
{
    IP4_ADDRESS     Ip4Address;
    IP6_ADDRESS     Ip6Address;
    DNS_STATUS      Status;
    DWORD           Rcode;
}
DNS_FAILED_UPDATE_INFO, *PDNS_FAILED_UPDATE_INFO;

VOID
DnsGetLastFailedUpdateInfo(
    OUT     PDNS_FAILED_UPDATE_INFO pInfo
    );



//
//  DNS Update API for DHCP client
//

typedef struct  _REGISTER_HOST_ENTRY
{
     union
     {
         IP_ADDRESS    ipAddr;
         IPV6_ADDRESS  ipV6Addr;
     } Addr;
     DWORD       dwOptions;
}
REGISTER_HOST_ENTRY, *PREGISTER_HOST_ENTRY;

//
//  Options for above
//

#define REGISTER_HOST_A             0x00000001
#define REGISTER_HOST_PTR           0x00000002
#define REGISTER_HOST_AAAA          0x00000008
#define REGISTER_HOST_RESERVED      0x80000000  // Not used


//
// DNS DHCP Client registration flags
//

#define DYNDNS_REG_FWD      0x0
#define DYNDNS_REG_PTR      0x8
#define DYNDNS_REG_RAS      0x10
#define DYNDNS_DEL_ENTRY    0x20


typedef struct  _REGISTER_HOST_STATUS
{
     HANDLE      hDoneEvent;
     DWORD       dwStatus;
}
REGISTER_HOST_STATUS, *PREGISTER_HOST_STATUS;

DNS_STATUS
WINAPI
DnsAsyncRegisterInit(
   PSTR  lpstrRootRegKey
   );

DNS_STATUS
WINAPI
DnsAsyncRegisterTerm(
   VOID
   );

DNS_STATUS WINAPI
DnsRemoveRegistrations(
   VOID
   );

DNS_STATUS
WINAPI
DnsAsyncRegisterHostAddrs(
    IN  PWSTR                   pwsAdapterName,
    IN  PWSTR                   pwsHostName,
    IN  PREGISTER_HOST_ENTRY    pHostAddrs,
    IN  DWORD                   dwHostAddrCount,
    IN  PIP_ADDRESS             pipDnsServerList,
    IN  DWORD                   dwDnsServerCount,
    IN  PWSTR                   pwsDomainName,
    IN  PREGISTER_HOST_STATUS   pRegisterStatus,
    IN  DWORD                   dwTTL,
    IN  DWORD                   dwFlags
    );

#define DnsAsyncRegisterHostAddrs_W DnsAsyncRegisterHostAddrs



//
//  DNS Update API for DHCP server.
//

//
//  Call back function. DHCP Server will pass a function to
//  DnsDhcpRegisterHostName and this will be called on successful
//  or unsuccessful completion of the task
//  If we have a condition like server down/try again later etc we
//  won't respond until we have an authoritative answer.
//

typedef VOID(*DHCP_CALLBACK_FN)(DWORD dwStatus, LPVOID pvData);

//
//  Callback return codes
//

#define     DNSDHCP_SUCCESS         0x0
#define     DNSDHCP_FWD_FAILED      0x1
#define     DNSDHCP_SUPERCEDED      0x2

#define     DNSDHCP_FAILURE         (DWORD)-1 //reverse failed


//
// DNS DHCP Server registration function flags
//

#define     DYNDNS_DELETE_ENTRY     0x1
#define     DYNDNS_ADD_ENTRY        0x2
#define     DYNDNS_REG_FORWARD      0x4


typedef struct _DnsCredentials
{
    PWSTR   pUserName;
    PWSTR   pDomain;
    PWSTR   pPassword;
}
DNS_CREDENTIALS, *PDNS_CREDENTIALS;

DNS_STATUS
WINAPI
DnsDhcpSrvRegisterInit(
    VOID
    );

DNS_STATUS
WINAPI
DnsDhcpSrvRegisterInitialize(
    IN      PDNS_CREDENTIALS    pCredentials
    );

DNS_STATUS
WINAPI
DnsDhcpSrvRegisterTerm(
    VOID
    );

DNS_STATUS
WINAPI
DnsDhcpSrvRegisterHostName(
    IN  REGISTER_HOST_ENTRY HostAddr,
    IN  PWSTR               pwsName,
    IN  DWORD               dwTTL,
    IN  DWORD               dwFlags,
    IN  DHCP_CALLBACK_FN    pfnDhcpCallBack,
    IN  PVOID               pvData,
    IN  PIP_ADDRESS         pipDnsServerList OPTIONAL,
    IN  DWORD               dwDnsServerCount
    );

#define RETRY_TIME_SERVER_FAILURE        5*60  // 5 minutes
#define RETRY_TIME_TRY_AGAIN_LATER       5*60  // 5 minutes
#define RETRY_TIME_TIMEOUT               5*60  // 5 minutes

#define RETRY_TIME_MAX                   10*60 // back off to 10 mins if
                                               // repeated failures occur

#define DnsDhcpSrvRegisterHostName_W  DnsDhcpSrvRegisterHostName



//
//  Memory allocation
//
//  Many dnsapi.dll routines allocate memory.
//  This memory allocation defaults to routines that use:
//      - LocalAlloc,
//      - LocalReAlloc,
//      - LocalFree.
//  If you desire alternative memory allocation mechanisms, use this
//  function to override the DNS API defaults.  All memory returned by dnsapi.dll
//  can then be freed with the specified free function.
//

typedef PVOID (* DNS_ALLOC_FUNCTION)();
typedef PVOID (* DNS_REALLOC_FUNCTION)();
typedef VOID (* DNS_FREE_FUNCTION)();

VOID
DnsApiHeapReset(
    IN  DNS_ALLOC_FUNCTION      pAlloc,
    IN  DNS_REALLOC_FUNCTION    pRealloc,
    IN  DNS_FREE_FUNCTION       pFree
    );


//
//  Modules using DNSAPI memory should use these routines if
//  they are capable of being called by a process that resets
//  the dnsapi.dll heap.  (Example:  the DNS server.)
//

PVOID
DnsApiAlloc(
    IN      INT             iSize
    );

PVOID
DnsApiRealloc(
    IN OUT  PVOID           pMem,
    IN      INT             iSize
    );

VOID
DnsApiFree(
    IN OUT  PVOID           pMem
    );



//
//  String utilities (string.c)
//
//  Note some of these require memory allocation, see note
//  on memory allocation below.
//

PSTR 
DnsCreateStringCopy(
    IN      PCHAR       pchString,
    IN      DWORD       cchString
    );

DWORD
DnsGetBufferLengthForStringCopy(
    IN      PCHAR       pchString,
    IN      DWORD       cchString,
    IN      BOOL        fUnicodeIn,
    IN      BOOL        fUnicodeOut
    );

PVOID
DnsCopyStringEx(
    OUT     PBYTE       pBuffer,
    IN      PCHAR       pchString,
    IN      DWORD       cchString,
    IN      BOOL        fUnicodeIn,
    IN      BOOL        fUnicodeOut
    );

PVOID
DnsStringCopyAllocateEx(
    IN      PCHAR       pchString,
    IN      DWORD       cchString,
    IN      BOOL        fUnicodeIn,
    IN      BOOL        fUnicodeOut
    );

DWORD
DnsNameCopy(
    OUT     PBYTE           pBuffer,
    IN OUT  PDWORD          pdwBufLength,
    IN      PCHAR           pchString,
    IN      DWORD           cchString,
    IN      DNS_CHARSET     CharSetIn,
    IN      DNS_CHARSET     CharSetOut
    );

PVOID
DnsNameCopyAllocate(
    IN      PCHAR           pchString,
    IN      DWORD           cchString,
    IN      DNS_CHARSET     CharSetIn,
    IN      DNS_CHARSET     CharSetOut
    );

PCHAR
DnsWriteReverseNameStringForIpAddress(
    OUT     PCHAR       pBuffer,
    IN      IP_ADDRESS  ipAddress
    );

PCHAR
DnsCreateReverseNameStringForIpAddress(
    IN      IP_ADDRESS  ipAddress
    );



//
//  Name validation
//
//  Routines are in windns.h
//

//
//  Macro away old routines
//

#define DnsValidateDnsName_UTF8(pname)  \
        DnsValidateName_UTF8( (pname), DnsNameDomain )

#define DnsValidateDnsName_W(pname) \
        DnsValidateName_W( (pname), DnsNameDomain )


//
//  Name checking -- server name checking levels
//
//  DCR_CLEANUP:   server name checking levels move to dnsrpc.h?
//      but server will need to convert to some flag
//      ammenable to downcase\validate routine
//
//  DCR:  server name checking:  perhaps lay out additional detail now?
//      or limit to RFC, MS-extended, ALL-binary
//
//  DCR:  server name checking:  perhaps convert to enum type;
//      I don't think we should do bitfields here, rather
//      have enum type map to bitfields if that's the best
//      way to implement underlying check.
//

#define DNS_ALLOW_RFC_NAMES_ONLY    (0)
#define DNS_ALLOW_NONRFC_NAMES      (1)
#define DNS_ALLOW_MULTIBYTE_NAMES   (2)
#define DNS_ALLOW_ALL_NAMES         (3)



//
//  DNS Name compare
//
//  ANSI and unicode names compare routines are in windns.h.
//

BOOL
WINAPI
DnsNameCompare_UTF8(
    IN      PSTR        pName1,
    IN      PSTR        pName2
    );


//
//  Extended name compare
//  Includes determination of name heirarchy.
//
//  Note:  once sort out RelationalCompare issue,
//      better to make Equal == 0;
//      this simplifies macroing regular NameCompare
//      into a single function;
//

typedef enum _DnsNameCompareStatus
{
   DnsNameCompareNotEqual,
   DnsNameCompareEqual,
   DnsNameCompareLeftParent,
   DnsNameCompareRightParent,
   DnsNameCompareInvalid
}
DNS_NAME_COMPARE_STATUS, *PDNS_NAME_COMPARE_STATUS;

DNS_NAME_COMPARE_STATUS
DnsNameCompareEx_W(
    IN      LPCWSTR         pszLeftName,
    IN      LPCWSTR         pszRightName,
    IN      DWORD           dwReserved
    );

DNS_NAME_COMPARE_STATUS
DnsNameCompareEx_A(
    IN      LPCSTR          pszLeftName,
    IN      LPCSTR          pszRightName,
    IN      DWORD           dwReserved
    );

DNS_NAME_COMPARE_STATUS
DnsNameCompareEx_UTF8(
    IN      LPCSTR          pszLeftName,
    IN      LPCSTR          pszRightName,
    IN      DWORD           dwReserved
    );


//
//  Other string routines
//

DNS_STATUS
DnsValidateDnsString_UTF8(
    IN      LPCSTR      pszName
    );

DNS_STATUS
DnsValidateDnsString_W(
    IN      LPCWSTR     pszName
    );

PSTR 
DnsCreateStandardDnsNameCopy(
    IN      PCHAR       pchName,
    IN      DWORD       cchName,
    IN      DWORD       dwFlag
    );

DWORD
DnsDowncaseDnsNameLabel(
    OUT     PCHAR       pchResult,
    IN      PCHAR       pchLabel,
    IN      DWORD       cchLabel,
    IN      DWORD       dwFlags
    );

DWORD
_fastcall
DnsUnicodeToUtf8(
    IN      PWCHAR      pwUnicode,
    IN      DWORD       cchUnicode,
    OUT     PCHAR       pchResult,
    IN      DWORD       cchResult
    );

DWORD
_fastcall
DnsUtf8ToUnicode(
    IN      PCHAR       pchUtf8,
    IN      DWORD       cchUtf8,
    OUT     PWCHAR      pwResult,
    IN      DWORD       cwResult
    );

DNS_STATUS
DnsValidateUtf8Byte(
    IN      BYTE        chUtf8,
    IN OUT  PDWORD      pdwTrailCount
    );



//
//  Service control
//

//
//  DNS server startup service control event.
//
//  Services (ex. netlogon) that want notification of DNS server start
//  need to register to get notification of this user defined control code.
//

#define SERVICE_CONTROL_DNS_SERVER_START (200)


//
//  Resolver service
//
//  General "wake-up-something-has-changed" call.
//  This was put in for cluster team to alert us to plumbing new
//  addresses.  Later we will move to model of picking up
//  these changes ourselves.
//  

VOID
DnsNotifyResolver(
    IN      DWORD           Flag,
    IN      PVOID           pReserved
    );

VOID
DnsNotifyResolverEx(
    IN      DWORD           Id,
    IN      DWORD           Flag,
    IN      DWORD           Cookie,
    IN      PVOID           pReserved
    );

//
//  Cluster mappings
//

#define DNS_CLUSTER_ADD             (0)
#define DNS_CLUSTER_DELETE_NAME     (1)
#define DNS_CLUSTER_DELETE_IP       (2)

DNS_STATUS
DnsRegisterClusterAddress(
    IN      DWORD           Tag,
    IN      PWSTR           pwsName,
    IN      PSOCKADDR       pSockaddr,
    IN      DWORD           Flag
    );

//   Remove once cluster upgraded
VOID
DnsNotifyResolverClusterIp(
    IN      IP_ADDRESS      ClusterIp,
    IN      BOOL            fAdd
    );


//
//  Routines to clear all cached entries in the DNS Resolver Cache, this is
//  called by ipconfig /flushdns, and add record sets to the cache.
//

BOOL WINAPI
DnsFlushResolverCache(
    VOID
    );

BOOL WINAPI
DnsFlushResolverCacheEntry_W(
    IN  PWSTR  pszName
    );

BOOL WINAPI
DnsFlushResolverCacheEntry_UTF8(
    IN  PSTR  pszName
    );

BOOL WINAPI
DnsFlushResolverCacheEntry_A(
    IN  PSTR  pszName
    );

#ifdef UNICODE
#define DnsFlushResolverCacheEntry DnsFlushResolverCacheEntry_W
#else
#define DnsFlushResolverCacheEntry DnsFlushResolverCacheEntry_A
#endif


DNS_STATUS WINAPI
DnsCacheRecordSet_W(
    IN     PWSTR       lpstrName,
    IN     WORD        wType,
    IN     DWORD       fOptions,
    IN OUT PDNS_RECORD pRRSet
    );


//
//  DO NOT USE!!! -- This is weak, i just haven't tested the replacement yet.
//
//  Routine to read the contents of the DNS Resolver Cache. The resulting
//  table contains a list of record names and types stored in the cache.
//  Each of these name/type records can be queried with DnsQuery with the
//  option DNS_QUERY_CACHE_ONLY.
//
//  Note: this is used in ipconfig for /displaydns.  Can not pull until fixed.
//

typedef struct _DNS_CACHE_TABLE_
{
    struct _DNS_CACHE_TABLE_ * pNext;
    PWSTR                      Name;
    WORD                       Type1;
    WORD                       Type2;
    WORD                       Type3;
}
DNS_CACHE_TABLE, *PDNS_CACHE_TABLE;

BOOL
WINAPI
DnsGetCacheDataTable(
    OUT PDNS_CACHE_TABLE * pTable
    );




//
//  Config info
//

//
//  Alloc flag types for DnsQueryConfig()
//
//  DCR:  move to windns.h if supported
//

#define DNS_CONFIG_FLAG_LOCAL_ALLOC     (DNS_CONFIG_FLAG_ALLOC)
#define DNS_CONFIG_FLAG_DNSAPI_ALLOC    (DNS_CONFIG_FLAG_ALLOC+1)

//
//  System public config -- not available in SDK
//  This is stuff for
//      - config UI
//      - ipconfig
//      - test code
//

#define DnsConfigSystemBase             ((DNS_CONFIG_TYPE) 0x00010000)

#define DnsConfigNetworkInformation     ((DNS_CONFIG_TYPE) 0x00010001)
#define DnsConfigAdapterInformation     ((DNS_CONFIG_TYPE) 0x00010002)
#define DnsConfigSearchInformation      ((DNS_CONFIG_TYPE) 0x00010003)
#define DnsConfigIp4AddressArray        ((DNS_CONFIG_TYPE) 0x00010004)

#define DnsConfigRegistrationEnabled    ((DNS_CONFIG_TYPE) 0x00010010)
#define DnsConfigWaitForNameErrorOnAll  ((DNS_CONFIG_TYPE) 0x00010011)

//  these completely backpat -- shouldn't even be public

#define DnsConfigNetInfo                ((DNS_CONFIG_TYPE) 0x00020001)


PVOID
WINAPI
DnsQueryConfigAllocEx(
    IN      DNS_CONFIG_TYPE     Config,
    IN      PWSTR               pwsAdapterName,
    IN      BOOL                fLocalAlloc
    );

//  Desired routine has dnsapi.dll alloc

#define DnsQueryConfigAlloc( Id, pAN )  \
        DnsQueryConfigAllocEx( Id, pAN, FALSE )

VOID
WINAPI
DnsFreeConfigStructure(
    IN OUT  PVOID           pData,
    IN      DNS_CONFIG_TYPE ConfigId
    );

//
//  DWORD config get\set
//

DWORD
WINAPI
DnsQueryConfigDword(
    IN      DNS_CONFIG_TYPE     Config,
    IN      PWSTR               pwsAdapterName
    );

DNS_STATUS
WINAPI
DnsSetConfigDword(
    IN      DNS_CONFIG_TYPE     Config,
    IN      PWSTR               pwsAdapterName,
    IN      DWORD               NewValue
    );



//
//  Macro old routines
//      - system-public config allocator
//      - global free routine
//      - these were structure allocs so were not being freed with LocalFree
//

#ifdef BACKCOMPAT

#define DnsGetNetworkInformation()      DnsQueryConfigAlloc( DnsConfigNetworkInformation, NULL )
#define DnsGetSearchInformation()       DnsQueryConfigAlloc( DnsConfigSearchInformation, NULL )
#define Dns_GetDnsNetworkInfo(f,g)      DnsQueryConfigAlloc( DnsConfigNetInfo, NULL )

#define DnsFreeNetworkInformation(p)    DnsFreeConfigStructure( p, DnsConfigNetworkInformation )
#define DnsFreeSearchInformation(p)     DnsFreeConfigStructure( p, DnsConfigSearchInformation )
#define DnsFreeAdapterInformation(p)    DnsFreeConfigStructure( p, DnsConfigAdapterInformation )
#define Dns_FreeNetworkInfo(p)          DnsFreeConfigStructure( p, DnsConfigNetInfo )

//
//  Macro old config string allocating routines
//      - no adapter name
//      - allocating from dnsapi heap as main caller -- RnR -- seems to be
//          using DnsApiFree
//

#define BackpatAlloc( Id )      DnsQueryConfigAllocEx( Id, NULL, FALSE )

//  Public structures

#define DnsGetHostName_A()      BackpatAlloc( DnsConfigHostName_A )
#define DnsGetHostName_UTF8()   BackpatAlloc( DnsConfigHostName_UTF8 )
#define DnsGetHostName_W()      ((PWSTR)BackpatAlloc( DnsConfigHostName_W ))

#ifdef UNICODE
#define DnsGetHostName DnsGetHostName_W
#else
#define DnsGetHostName DnsGetHostName_A
#endif

#define DnsGetPrimaryDomainName_A()      BackpatAlloc( DnsConfigPrimaryDomainName_A )
#define DnsGetPrimaryDomainName_UTF8()   BackpatAlloc( DnsConfigPrimaryDomainName_UTF8 )
#define DnsGetPrimaryDomainName_W()      ((PWSTR)BackpatAlloc( DnsConfigPrimaryDomainName_W ))

#ifdef UNICODE
#define DnsGetPrimaryDomainName DnsGetPrimaryDomainName_W
#else
#define DnsGetPrimaryDomainName DnsGetPrimaryDomainName_A
#endif

//
//  DWORD get\set backcompat
//

//
//  DCR:  there is a possible problem with these mappings handles generic\adapter
//      difference -- not sure the mapping is complete
//      may need switches -- see which are even in use with BACKCOMPAT off
//

#define DnsIsDynamicRegistrationEnabled(pA)     \
        (BOOL)DnsQueryConfigDword( DnsConfigRegistrationEnabled, (pA) )

#define DnsIsAdapterDomainNameRegistrationEnabled(pA)   \
        (BOOL)DnsQueryConfigDword( DnsConfigAdapterHostNameRegistrationEnabled, (pA) )

#define DnsGetMaxNumberOfAddressesToRegister(pA) \
        DnsQueryConfigDword( DnsConfigAddressRegistrationMaxCount, (pA) )

//  DWORD reg value set

#define DnsEnableDynamicRegistration(pA) \
        DnsSetConfigDword( DnsConfigRegistrationEnabled, pA, (DWORD)TRUE )

#define DnsDisableDynamicRegistration(pA) \
        DnsSetConfigDword( DnsConfigRegistrationEnabled, pA, (DWORD)FALSE )

#define DnsEnableAdapterDomainNameRegistration(pA) \
        DnsSetConfigDword( DnsConfigAdapterHostNameRegistrationEnabled, pA, (DWORD)TRUE )

#define DnsDisableAdapterDomainNameRegistration(pA) \
        DnsSetConfigDword( DnsConfigAdapterHostNameRegistrationEnabled, pA, (DWORD)FALSE )

#define DnsSetMaxNumberOfAddressesToRegister(pA, MaxCount) \
        (NO_ERROR == DnsSetConfigDword( DnsConfigAddressRegistrationMaxCount, pA, MaxCount ))


//
//  DNS server list backcompat
//

#define Dns_GetDnsServerList(flag)      ((PIP4_ARRAY)BackpatAlloc( DnsConfigDnsServerList ))

#ifndef MIDL_PASS
__inline
DWORD
inline_DnsGetDnsServerList(
    OUT     PIP4_ARRAY *    ppDnsArray
    )
{
    *ppDnsArray = Dns_GetDnsServerList( TRUE );

    return ( *ppDnsArray ? (*ppDnsArray)->AddrCount : 0 );
}
#endif  // MIDL

#define DnsGetDnsServerList(p)      inline_DnsGetDnsServerList(p)


//
//  IP list backcompat
//

#ifndef MIDL_PASS
__inline
DWORD
inline_DnsGetIpAddressList(
    OUT     PIP4_ARRAY *     ppIpArray
    )
{
    *ppIpArray = (PIP4_ARRAY) BackpatAlloc( DnsConfigIp4AddressArray );

    return( *ppIpArray ? (*ppIpArray)->AddrCount : 0 );
}
#endif  // MIDL

#define DnsGetIpAddressList(p)  inline_DnsGetIpAddressList(p)


//
//  For netdiag
//

#define Dns_IsUpdateNetworkInfo(pni)    NetInfo_IsForUpdate( pni )


//
//  DO NOT USE!!!!
//
//  This is backward compatibility only.
//  I've switched the DCPromo stuff.  Need to verify with clean system
//  build that it's completely gone, then pull.
//

#ifdef BACKCOMPAT
#define DNS_RELATE_NEQ      DnsNameCompareNotEqual
#define DNS_RELATE_EQL      DnsNameCompareEqual
#define DNS_RELATE_LGT      DnsNameCompareLeftParent
#define DNS_RELATE_RGT      DnsNameCompareRightParent
#define DNS_RELATE_INVALID  DnsNameCompareInvalid

typedef DNS_NAME_COMPARE_STATUS  DNS_RELATE_STATUS, *PDNS_RELATE_STATUS;
#endif

#endif  // BACKCOMPAT


#ifdef __cplusplus
}
#endif  // __cplusplus

#endif // _DNSAPI_INCLUDED_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\public\internal\ds\inc\dsgetdcp.h ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    dsgetdcp.h

Abstract:

    Routines for processing SRV DNS records.

Author:

    Cliff Van Dyke (cliffv) 07-Mar-1997

Environment:

    User mode only.
    Contains NT-specific code.
    Requires ANSI C extensions: slash-slash comments, long external names.

Revision History:

--*/

#if !defined(DSGETDCAPI)
#if !defined(_DSGETDCAPI_)
#define DSGETDCAPI DECLSPEC_IMPORT
#else
#define DSGETDCAPI
#endif
#endif !defined(DSGETDCAPI)

//
// Externally visible procedures.
//

DSGETDCAPI
DWORD
WINAPI
DsGetDcNameWithAccountA(
    IN LPCSTR ComputerName OPTIONAL,
    IN LPCSTR AccountName OPTIONAL,
    IN ULONG AllowableAccountControlBits,
    IN LPCSTR DomainName OPTIONAL,
    IN GUID *DomainGuid OPTIONAL,
    IN LPCSTR SiteName OPTIONAL,
    IN ULONG Flags,
    OUT PDOMAIN_CONTROLLER_INFOA *DomainControllerInfo
);

DSGETDCAPI
DWORD
WINAPI
DsGetDcNameWithAccountW(
    IN LPCWSTR ComputerName OPTIONAL,
    IN LPCWSTR AccountName OPTIONAL,
    IN ULONG AllowableAccountControlBits,
    IN LPCWSTR DomainName OPTIONAL,
    IN GUID *DomainGuid OPTIONAL,
    IN LPCWSTR SiteName OPTIONAL,
    IN ULONG Flags,
    OUT PDOMAIN_CONTROLLER_INFOW *DomainControllerInfo
);


NET_API_STATUS
DCNameInitialize(
    VOID
    );

VOID
DCNameClose(
    VOID
    );

NET_API_STATUS
NetpDcBuildPing(
    IN BOOL PdcOnly,
    IN ULONG RequestCount,
    IN LPCWSTR UnicodeComputerName,
    IN LPCWSTR UnicodeUserName OPTIONAL,
    IN LPCSTR ResponseMailslotName,
    IN ULONG AllowableAccountControlBits,
    IN PSID RequestedDomainSid OPTIONAL,
    IN ULONG NtVersion,
    OUT PVOID *Message,
    OUT PULONG MessageSize
    );

DWORD
WINAPI
NettestDsGetDcNameW(
    IN LPCWSTR ComputerName OPTIONAL,
    IN LPCWSTR DomainName OPTIONAL,
    IN GUID *DomainGuid OPTIONAL,
    IN LPCWSTR SiteName OPTIONAL,
    IN ULONG Flags,
    OUT PDOMAIN_CONTROLLER_INFOW *DomainControllerInfo
);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\public\internal\ds\inc\dirsync.h ===
#pragma warning( disable: 4049 )  /* more than 64k source lines */

/* this ALWAYS GENERATED file contains the definitions for the interfaces */


 /* File created by MIDL compiler version 6.00.0334 */
/* Compiler settings for dirsync.idl:
    Oicf, W1, Zp8, env=Win32 (32b run)
    protocol : dce , ms_ext, c_ext, robust
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )


/* verify that the <rpcndr.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCNDR_H_VERSION__
#define __REQUIRED_RPCNDR_H_VERSION__ 475
#endif

#include "rpc.h"
#include "rpcndr.h"

#ifndef __RPCNDR_H_VERSION__
#error this stub requires an updated version of <rpcndr.h>
#endif // __RPCNDR_H_VERSION__

#ifndef COM_NO_WINDOWS_H
#include "windows.h"
#include "ole2.h"
#endif /*COM_NO_WINDOWS_H*/

#ifndef __dirsync_h__
#define __dirsync_h__

#if defined(_MSC_VER) && (_MSC_VER >= 1020)
#pragma once
#endif

/* Forward Declarations */ 

#ifndef __IDirsyncLog_FWD_DEFINED__
#define __IDirsyncLog_FWD_DEFINED__
typedef interface IDirsyncLog IDirsyncLog;
#endif 	/* __IDirsyncLog_FWD_DEFINED__ */


#ifndef __IDirsyncStatus_FWD_DEFINED__
#define __IDirsyncStatus_FWD_DEFINED__
typedef interface IDirsyncStatus IDirsyncStatus;
#endif 	/* __IDirsyncStatus_FWD_DEFINED__ */


#ifndef __IDirsyncDatabase_FWD_DEFINED__
#define __IDirsyncDatabase_FWD_DEFINED__
typedef interface IDirsyncDatabase IDirsyncDatabase;
#endif 	/* __IDirsyncDatabase_FWD_DEFINED__ */


#ifndef __IDirsyncDatabaseTable_FWD_DEFINED__
#define __IDirsyncDatabaseTable_FWD_DEFINED__
typedef interface IDirsyncDatabaseTable IDirsyncDatabaseTable;
#endif 	/* __IDirsyncDatabaseTable_FWD_DEFINED__ */


#ifndef __IEnumDirsyncSession_FWD_DEFINED__
#define __IEnumDirsyncSession_FWD_DEFINED__
typedef interface IEnumDirsyncSession IEnumDirsyncSession;
#endif 	/* __IEnumDirsyncSession_FWD_DEFINED__ */


#ifndef __IDirsyncSessionManager_FWD_DEFINED__
#define __IDirsyncSessionManager_FWD_DEFINED__
typedef interface IDirsyncSessionManager IDirsyncSessionManager;
#endif 	/* __IDirsyncSessionManager_FWD_DEFINED__ */


#ifndef __IDirsyncObjectMapper_FWD_DEFINED__
#define __IDirsyncObjectMapper_FWD_DEFINED__
typedef interface IDirsyncObjectMapper IDirsyncObjectMapper;
#endif 	/* __IDirsyncObjectMapper_FWD_DEFINED__ */


#ifndef __IEnumDirsyncFailedObjectList_FWD_DEFINED__
#define __IEnumDirsyncFailedObjectList_FWD_DEFINED__
typedef interface IEnumDirsyncFailedObjectList IEnumDirsyncFailedObjectList;
#endif 	/* __IEnumDirsyncFailedObjectList_FWD_DEFINED__ */


#ifndef __IDirsyncFailedObjectList_FWD_DEFINED__
#define __IDirsyncFailedObjectList_FWD_DEFINED__
typedef interface IDirsyncFailedObjectList IDirsyncFailedObjectList;
#endif 	/* __IDirsyncFailedObjectList_FWD_DEFINED__ */


#ifndef __IDirsyncNamespaceMapping_FWD_DEFINED__
#define __IDirsyncNamespaceMapping_FWD_DEFINED__
typedef interface IDirsyncNamespaceMapping IDirsyncNamespaceMapping;
#endif 	/* __IDirsyncNamespaceMapping_FWD_DEFINED__ */


#ifndef __IDirsyncSession_FWD_DEFINED__
#define __IDirsyncSession_FWD_DEFINED__
typedef interface IDirsyncSession IDirsyncSession;
#endif 	/* __IDirsyncSession_FWD_DEFINED__ */


#ifndef __IDirsyncSessionCallback_FWD_DEFINED__
#define __IDirsyncSessionCallback_FWD_DEFINED__
typedef interface IDirsyncSessionCallback IDirsyncSessionCallback;
#endif 	/* __IDirsyncSessionCallback_FWD_DEFINED__ */


#ifndef __IDirsyncWriteProvider_FWD_DEFINED__
#define __IDirsyncWriteProvider_FWD_DEFINED__
typedef interface IDirsyncWriteProvider IDirsyncWriteProvider;
#endif 	/* __IDirsyncWriteProvider_FWD_DEFINED__ */


#ifndef __IDirsyncServer_FWD_DEFINED__
#define __IDirsyncServer_FWD_DEFINED__
typedef interface IDirsyncServer IDirsyncServer;
#endif 	/* __IDirsyncServer_FWD_DEFINED__ */


#ifndef __IDirsyncReadProvider_FWD_DEFINED__
#define __IDirsyncReadProvider_FWD_DEFINED__
typedef interface IDirsyncReadProvider IDirsyncReadProvider;
#endif 	/* __IDirsyncReadProvider_FWD_DEFINED__ */


#ifndef __IDirsyncNamespaceMapper_FWD_DEFINED__
#define __IDirsyncNamespaceMapper_FWD_DEFINED__
typedef interface IDirsyncNamespaceMapper IDirsyncNamespaceMapper;
#endif 	/* __IDirsyncNamespaceMapper_FWD_DEFINED__ */


#ifndef __IDirsyncAttributeMapper_FWD_DEFINED__
#define __IDirsyncAttributeMapper_FWD_DEFINED__
typedef interface IDirsyncAttributeMapper IDirsyncAttributeMapper;
#endif 	/* __IDirsyncAttributeMapper_FWD_DEFINED__ */


#ifndef __DirsyncServer_FWD_DEFINED__
#define __DirsyncServer_FWD_DEFINED__

#ifdef __cplusplus
typedef class DirsyncServer DirsyncServer;
#else
typedef struct DirsyncServer DirsyncServer;
#endif /* __cplusplus */

#endif 	/* __DirsyncServer_FWD_DEFINED__ */


/* header files for imported files */
#include "oaidl.h"
#include "iads.h"

#ifdef __cplusplus
extern "C"{
#endif 

void * __RPC_USER MIDL_user_allocate(size_t);
void __RPC_USER MIDL_user_free( void * ); 

/* interface __MIDL_itf_dirsync_0000 */
/* [local] */ 

#define	MAX_SESSION	( 128 )

#define	SCHEDULE_SIZE	( 84 )

#define	LOG_NUM_VALUE	( 16 )

typedef LPWSTR PWSTR;

typedef CHAR *PCHAR;

typedef BYTE *PBYTE;

typedef struct _DirsyncDBValue
    {
    BYTE *pByte;
    DWORD dwLength;
    } 	DirsyncDBValue;

typedef struct _DirsyncDBValue *PDirsyncDBValue;

typedef 
enum _DBTYPE
    {	DBTYPE_STRING	= 0,
	DBTYPE_LONGSTRING	= DBTYPE_STRING + 1,
	DBTYPE_GUID	= DBTYPE_LONGSTRING + 1,
	DBTYPE_OCTETSTRING	= DBTYPE_GUID + 1,
	DBTYPE_DWORD	= DBTYPE_OCTETSTRING + 1,
	DBTYPE_BOOLEAN	= DBTYPE_DWORD + 1
    } 	DBTYPE;

typedef 
enum _UPDATETYPE
    {	INSERT_ROW	= 1,
	REPLACE_ROW	= INSERT_ROW + 1
    } 	UPDATETYPE;

typedef 
enum _RETRYTYPE
    {	RT_NORETRY	= 0,
	RT_SESSIONRETRY	= RT_NORETRY + 1,
	RT_AUTORETRY	= RT_SESSIONRETRY + 1
    } 	RETRYTYPE;

typedef 
enum _SYNCDIRECTION
    {	SYNC_FORWARD	= 1,
	SYNC_REVERSE	= SYNC_FORWARD + 1
    } 	SYNCDIRECTION;

typedef 
enum _SYNCPROVIDER
    {	SUBSCRIBER	= 0,
	PUBLISHER	= 1
    } 	SYNCPROVIDER;

typedef 
enum _PROVIDERTYPE
    {	READ_PROVIDER	= 0,
	WRITE_PROVIDER	= READ_PROVIDER + 1,
	READWRITE_PROVIDER	= WRITE_PROVIDER + 1,
	OBJECT_MAPPER	= READWRITE_PROVIDER + 1
    } 	PROVIDERTYPE;

typedef 
enum _CUSTOMMAPPERTYPE
    {	ATTRIBUTE_MAPPER	= 0,
	NAMESPACE_MAPPER	= ATTRIBUTE_MAPPER + 1
    } 	CUSTOMMAPPERTYPE;

typedef 
enum _OBJECTACTION
    {	OBJECT_ADD	= 1,
	OBJECT_DELETE	= OBJECT_ADD + 1,
	OBJECT_MOVE	= OBJECT_DELETE + 1,
	OBJECT_MODIFY	= OBJECT_MOVE + 1,
	OBJECT_UPDATE	= OBJECT_MODIFY + 1,
	OBJECT_DELETE_RECURSIVE	= OBJECT_UPDATE + 1
    } 	OBJECTACTION;

typedef 
enum _ATTRACTION
    {	ATTR_INVALID	= 0,
	ATTR_REPLACE	= ATTR_INVALID + 1,
	ATTR_APPEND	= ATTR_REPLACE + 1,
	ATTR_DELETE	= ATTR_APPEND + 1,
	ATTR_CLEAR	= ATTR_DELETE + 1
    } 	ATTRACTION;

typedef 
enum _ATTRTYPE
    {	ATTR_TYPE_INVALID	= 0,
	ATTR_TYPE_BINARY	= ATTR_TYPE_INVALID + 1,
	ATTR_TYPE_UNICODE	= ATTR_TYPE_BINARY + 1,
	ATTR_TYPE_DN	= ATTR_TYPE_UNICODE + 1,
	ATTR_TYPE_INTEGER	= ATTR_TYPE_DN + 1,
	ATTR_TYPE_LARGEINTEGER	= ATTR_TYPE_INTEGER + 1,
	ATTR_TYPE_UTCTIME	= ATTR_TYPE_LARGEINTEGER + 1,
	ATTR_TYPE_BOOLEAN	= ATTR_TYPE_UTCTIME + 1,
	ATTR_TYPE_EMAIL	= ATTR_TYPE_BOOLEAN + 1,
	ATTR_TYPE_POSTALADDRESS	= ATTR_TYPE_EMAIL + 1,
	ATTR_TYPE_FAXNUMBER	= ATTR_TYPE_POSTALADDRESS + 1
    } 	ATTRTYPE;

typedef struct _BINVAL
    {
    DWORD dwLen;
    /* [size_is] */ PBYTE pVal;
    } 	BINVAL;

typedef struct _BINVAL *PBINVAL;

typedef struct _DIRSYNCVAL
    {
    /* [size_is] */ PBYTE pVal;
    DWORD dwLen;
    /* [size_is] */ PBYTE pObjectId;
    DWORD cbObjectId;
    } 	DIRSYNCVAL;

typedef struct _DIRSYNCVAL *PDIRSYNCVAL;

typedef struct _DIRSYNCATTRIBUTE
    {
    PWSTR pszName;
    ATTRTYPE attrType;
    ATTRACTION action;
    DWORD cVal;
    /* [size_is] */ PDIRSYNCVAL rgVal;
    } 	DIRSYNCATTRIBUTE;

typedef struct _DIRSYNCATTRIBUTE *PDIRSYNCATTRIBUTE;

typedef struct _DIRSYNCOBJECT
    {
    DWORD dwSize;
    PWSTR pszSourceDN;
    PWSTR pszTargetDN;
    PWSTR pszSourceOldDN;
    PWSTR pszTargetOldDN;
    PWSTR pszObjClass;
    /* [size_is] */ PBYTE pObjectId;
    DWORD cbObjectId;
    /* [size_is] */ PBYTE pTgtObjectId;
    DWORD cbTgtObjectId;
    /* [size_is] */ PBYTE pParentId;
    DWORD cbParentId;
    OBJECTACTION action;
    DWORD cAttr;
    /* [size_is] */ PDIRSYNCATTRIBUTE rgAttr;
    } 	DIRSYNCOBJECT;

typedef struct _DIRSYNCOBJECT *PDIRSYNCOBJECT;

typedef 
enum _PASSWORDTYPE
    {	PT_SPECIFIED	= 0,
	PT_USERNAME	= PT_SPECIFIED + 1,
	PT_RANDOM	= PT_USERNAME + 1,
	PASSWORDTYPE_BADVALUE	= PT_RANDOM + 1
    } 	PASSWORDTYPE;

typedef struct PASSWORDOPTIONS
    {
    PASSWORDTYPE passwordType;
    PWSTR pszPassword;
    } 	PASSWORDOPTIONS;

typedef struct _FAILEDOBJECT
    {
    PWSTR pszID;
    PDIRSYNCOBJECT pObject;
    DWORD dwRetryCount;
    LARGE_INTEGER timeLastSync;
    HRESULT hrLastSync;
    BOOL fAutoRetry;
    SYNCDIRECTION syncDirection;
    } 	FAILEDOBJECT;

typedef /* [allocate][allocate] */ struct _FAILEDOBJECT *PFAILEDOBJECT;

typedef struct _SESSIONDATA
    {
    DWORD dwFields;
    PWSTR pszName;
    PWSTR pszComments;
    DWORD dwFlags;
    DWORD dwLogLevel;
    BYTE pScheduleForward[ 84 ];
    BYTE pScheduleReverse[ 84 ];
    PWSTR pszSourceDirType;
    PWSTR pszSourceServer;
    PWSTR pszSourceUserName;
    PWSTR pszSourcePassword;
    PWSTR pszSourceBase;
    DWORD dwSourceScope;
    PWSTR pszSourceFilter;
    PASSWORDOPTIONS SourcePwdOptions;
    PWSTR pszTargetDirType;
    PWSTR pszTargetServer;
    PWSTR pszTargetUserName;
    PWSTR pszTargetPassword;
    PWSTR pszTargetBase;
    DWORD dwTargetScope;
    PWSTR pszTargetFilter;
    PASSWORDOPTIONS TargetPwdOptions;
    BINVAL bvalMapForward;
    BINVAL bvalMapBackward;
    BINVAL bvalNamespaceMap;
    } 	SESSIONDATA;

typedef struct _SESSIONDATA *PSESSIONDATA;

typedef struct _GLOBAL_SESSIONID
    {
    PWSTR pszServer;
    DWORD dwID;
    } 	GLOBAL_SESSIONID;

typedef struct _GLOBAL_SESSIONID *PGLOBAL_SESSIONID;

typedef 
enum _LOGVALUETYPE
    {	LOG_VALUETYPE_STRING	= 0,
	LOG_VALUETYPE_INTEGER_10	= LOG_VALUETYPE_STRING + 1,
	LOG_VALUETYPE_INTEGER_16	= LOG_VALUETYPE_INTEGER_10 + 1,
	LOG_VALUETYPE_WIN32_ERROR	= LOG_VALUETYPE_INTEGER_16 + 1,
	LOG_VALUETYPE_HRESULT	= LOG_VALUETYPE_WIN32_ERROR + 1,
	LOG_VALUETYPE_GUID	= LOG_VALUETYPE_HRESULT + 1,
	LOG_VALUETYPE_EXTENDED_ERROR	= LOG_VALUETYPE_GUID + 1
    } 	LOGVALUETYPE;

typedef struct _LOGVALUE
    {
    LOGVALUETYPE logValueType;
    union 
        {
        PWSTR pszString;
        DWORD dwInteger10;
        DWORD dwInteger16;
        DWORD dwWin32Error;
        HRESULT hResult;
        LPGUID pGuid;
        } 	;
    } 	LOGVALUE;

typedef struct _LOGVALUE *PLOGVALUE;

typedef struct _LOGPARAM
    {
    HANDLE hInstance;
    DWORD dwEventType;
    DWORD dwSessionId;
    DWORD dwMsgId;
    DWORD dwCount;
    LOGVALUE logValue[ 16 ];
    DWORD cbData;
    PBYTE pData;
    } 	LOGPARAM;

typedef struct _LOGPARAM *PLOGPARAM;

typedef struct COLLECTRPCDATA
    {
    long ObjectType;
    long dwInstances;
    long dwCounters;
    /* [size_is] */ PWSTR *rgpszInstanceName;
    long dwDataSize;
    /* [size_is] */ byte *pbData;
    } 	CollectRpcData;



extern RPC_IF_HANDLE __MIDL_itf_dirsync_0000_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_dirsync_0000_v0_0_s_ifspec;

#ifndef __IDirsyncLog_INTERFACE_DEFINED__
#define __IDirsyncLog_INTERFACE_DEFINED__

/* interface IDirsyncLog */
/* [unique][helpstring][uuid][local][object] */ 


EXTERN_C const IID IID_IDirsyncLog;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("1381ef2c-c28c-11d1-a407-00c04fb950dc")
    IDirsyncLog : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE SetLevel( 
            /* [in] */ DWORD dwSessionID,
            /* [in] */ DWORD dwLogLevel) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetLevel( 
            /* [in] */ DWORD dwSessionID,
            /* [out] */ DWORD *pdwLogLevel) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE RemoveLevel( 
            /* [in] */ DWORD dwSessionID) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE LogEvent( 
            /* [in] */ HANDLE handle,
            /* [in] */ DWORD dwEventType,
            /* [in] */ DWORD dwSessionID,
            /* [in] */ DWORD dwMsgId,
            /* [in] */ DWORD dwNumStrings,
            /* [in] */ LPCWSTR *rgszMsgString,
            /* [in] */ DWORD dwDataSize,
            /* [in] */ PBYTE pRawData) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE LogEventEx( 
            /* [in] */ PLOGPARAM pLogParam) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDirsyncLogVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IDirsyncLog * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IDirsyncLog * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IDirsyncLog * This);
        
        HRESULT ( STDMETHODCALLTYPE *SetLevel )( 
            IDirsyncLog * This,
            /* [in] */ DWORD dwSessionID,
            /* [in] */ DWORD dwLogLevel);
        
        HRESULT ( STDMETHODCALLTYPE *GetLevel )( 
            IDirsyncLog * This,
            /* [in] */ DWORD dwSessionID,
            /* [out] */ DWORD *pdwLogLevel);
        
        HRESULT ( STDMETHODCALLTYPE *RemoveLevel )( 
            IDirsyncLog * This,
            /* [in] */ DWORD dwSessionID);
        
        HRESULT ( STDMETHODCALLTYPE *LogEvent )( 
            IDirsyncLog * This,
            /* [in] */ HANDLE handle,
            /* [in] */ DWORD dwEventType,
            /* [in] */ DWORD dwSessionID,
            /* [in] */ DWORD dwMsgId,
            /* [in] */ DWORD dwNumStrings,
            /* [in] */ LPCWSTR *rgszMsgString,
            /* [in] */ DWORD dwDataSize,
            /* [in] */ PBYTE pRawData);
        
        HRESULT ( STDMETHODCALLTYPE *LogEventEx )( 
            IDirsyncLog * This,
            /* [in] */ PLOGPARAM pLogParam);
        
        END_INTERFACE
    } IDirsyncLogVtbl;

    interface IDirsyncLog
    {
        CONST_VTBL struct IDirsyncLogVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDirsyncLog_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IDirsyncLog_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IDirsyncLog_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IDirsyncLog_SetLevel(This,dwSessionID,dwLogLevel)	\
    (This)->lpVtbl -> SetLevel(This,dwSessionID,dwLogLevel)

#define IDirsyncLog_GetLevel(This,dwSessionID,pdwLogLevel)	\
    (This)->lpVtbl -> GetLevel(This,dwSessionID,pdwLogLevel)

#define IDirsyncLog_RemoveLevel(This,dwSessionID)	\
    (This)->lpVtbl -> RemoveLevel(This,dwSessionID)

#define IDirsyncLog_LogEvent(This,handle,dwEventType,dwSessionID,dwMsgId,dwNumStrings,rgszMsgString,dwDataSize,pRawData)	\
    (This)->lpVtbl -> LogEvent(This,handle,dwEventType,dwSessionID,dwMsgId,dwNumStrings,rgszMsgString,dwDataSize,pRawData)

#define IDirsyncLog_LogEventEx(This,pLogParam)	\
    (This)->lpVtbl -> LogEventEx(This,pLogParam)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IDirsyncLog_SetLevel_Proxy( 
    IDirsyncLog * This,
    /* [in] */ DWORD dwSessionID,
    /* [in] */ DWORD dwLogLevel);


void __RPC_STUB IDirsyncLog_SetLevel_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDirsyncLog_GetLevel_Proxy( 
    IDirsyncLog * This,
    /* [in] */ DWORD dwSessionID,
    /* [out] */ DWORD *pdwLogLevel);


void __RPC_STUB IDirsyncLog_GetLevel_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDirsyncLog_RemoveLevel_Proxy( 
    IDirsyncLog * This,
    /* [in] */ DWORD dwSessionID);


void __RPC_STUB IDirsyncLog_RemoveLevel_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDirsyncLog_LogEvent_Proxy( 
    IDirsyncLog * This,
    /* [in] */ HANDLE handle,
    /* [in] */ DWORD dwEventType,
    /* [in] */ DWORD dwSessionID,
    /* [in] */ DWORD dwMsgId,
    /* [in] */ DWORD dwNumStrings,
    /* [in] */ LPCWSTR *rgszMsgString,
    /* [in] */ DWORD dwDataSize,
    /* [in] */ PBYTE pRawData);


void __RPC_STUB IDirsyncLog_LogEvent_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDirsyncLog_LogEventEx_Proxy( 
    IDirsyncLog * This,
    /* [in] */ PLOGPARAM pLogParam);


void __RPC_STUB IDirsyncLog_LogEventEx_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IDirsyncLog_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_dirsync_0107 */
/* [local] */ 


enum EventType
    {	EVENTTYPE_ERROR	= 1,
	EVENTTYPE_WARNING	= 2,
	EVENTTYPE_INFORMATION	= 3,
	EVENTTYPE_BASIC_TRACE	= 4,
	EVENTTYPE_VERBOSE_TRACE	= 5
    } ;


extern RPC_IF_HANDLE __MIDL_itf_dirsync_0107_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_dirsync_0107_v0_0_s_ifspec;

#ifndef __IDirsyncStatus_INTERFACE_DEFINED__
#define __IDirsyncStatus_INTERFACE_DEFINED__

/* interface IDirsyncStatus */
/* [unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IDirsyncStatus;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("041a280a-1dd6-11d3-b63a-00c04f79f834")
    IDirsyncStatus : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE StatusUpdate( 
            DWORD dwPercent,
            DWORD dwWarning,
            DWORD dwError) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDirsyncStatusVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IDirsyncStatus * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IDirsyncStatus * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IDirsyncStatus * This);
        
        HRESULT ( STDMETHODCALLTYPE *StatusUpdate )( 
            IDirsyncStatus * This,
            DWORD dwPercent,
            DWORD dwWarning,
            DWORD dwError);
        
        END_INTERFACE
    } IDirsyncStatusVtbl;

    interface IDirsyncStatus
    {
        CONST_VTBL struct IDirsyncStatusVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDirsyncStatus_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IDirsyncStatus_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IDirsyncStatus_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IDirsyncStatus_StatusUpdate(This,dwPercent,dwWarning,dwError)	\
    (This)->lpVtbl -> StatusUpdate(This,dwPercent,dwWarning,dwError)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IDirsyncStatus_StatusUpdate_Proxy( 
    IDirsyncStatus * This,
    DWORD dwPercent,
    DWORD dwWarning,
    DWORD dwError);


void __RPC_STUB IDirsyncStatus_StatusUpdate_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IDirsyncStatus_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_dirsync_0108 */
/* [local] */ 




extern RPC_IF_HANDLE __MIDL_itf_dirsync_0108_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_dirsync_0108_v0_0_s_ifspec;

#ifndef __IDirsyncDatabase_INTERFACE_DEFINED__
#define __IDirsyncDatabase_INTERFACE_DEFINED__

/* interface IDirsyncDatabase */
/* [unique][helpstring][uuid][local][object] */ 


EXTERN_C const IID IID_IDirsyncDatabase;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("df83c5d6-3098-11d3-be6d-0000f87a369e")
    IDirsyncDatabase : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE AddTable( 
            /* [in] */ PWSTR pszTableName,
            /* [retval][out] */ IDirsyncDatabaseTable **ppTable) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetTable( 
            /* [in] */ PWSTR pszTableName,
            /* [retval][out] */ IDirsyncDatabaseTable **ppTable) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE DeleteTable( 
            /* [in] */ PWSTR pszTableName) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE BeginTransaction( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CommitTransaction( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE AbortTransaction( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Backup( 
            /* [in] */ PWSTR pszBackupPath) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Restore( 
            /* [in] */ PWSTR pszBackupPath) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDirsyncDatabaseVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IDirsyncDatabase * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IDirsyncDatabase * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IDirsyncDatabase * This);
        
        HRESULT ( STDMETHODCALLTYPE *AddTable )( 
            IDirsyncDatabase * This,
            /* [in] */ PWSTR pszTableName,
            /* [retval][out] */ IDirsyncDatabaseTable **ppTable);
        
        HRESULT ( STDMETHODCALLTYPE *GetTable )( 
            IDirsyncDatabase * This,
            /* [in] */ PWSTR pszTableName,
            /* [retval][out] */ IDirsyncDatabaseTable **ppTable);
        
        HRESULT ( STDMETHODCALLTYPE *DeleteTable )( 
            IDirsyncDatabase * This,
            /* [in] */ PWSTR pszTableName);
        
        HRESULT ( STDMETHODCALLTYPE *BeginTransaction )( 
            IDirsyncDatabase * This);
        
        HRESULT ( STDMETHODCALLTYPE *CommitTransaction )( 
            IDirsyncDatabase * This);
        
        HRESULT ( STDMETHODCALLTYPE *AbortTransaction )( 
            IDirsyncDatabase * This);
        
        HRESULT ( STDMETHODCALLTYPE *Backup )( 
            IDirsyncDatabase * This,
            /* [in] */ PWSTR pszBackupPath);
        
        HRESULT ( STDMETHODCALLTYPE *Restore )( 
            IDirsyncDatabase * This,
            /* [in] */ PWSTR pszBackupPath);
        
        END_INTERFACE
    } IDirsyncDatabaseVtbl;

    interface IDirsyncDatabase
    {
        CONST_VTBL struct IDirsyncDatabaseVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDirsyncDatabase_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IDirsyncDatabase_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IDirsyncDatabase_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IDirsyncDatabase_AddTable(This,pszTableName,ppTable)	\
    (This)->lpVtbl -> AddTable(This,pszTableName,ppTable)

#define IDirsyncDatabase_GetTable(This,pszTableName,ppTable)	\
    (This)->lpVtbl -> GetTable(This,pszTableName,ppTable)

#define IDirsyncDatabase_DeleteTable(This,pszTableName)	\
    (This)->lpVtbl -> DeleteTable(This,pszTableName)

#define IDirsyncDatabase_BeginTransaction(This)	\
    (This)->lpVtbl -> BeginTransaction(This)

#define IDirsyncDatabase_CommitTransaction(This)	\
    (This)->lpVtbl -> CommitTransaction(This)

#define IDirsyncDatabase_AbortTransaction(This)	\
    (This)->lpVtbl -> AbortTransaction(This)

#define IDirsyncDatabase_Backup(This,pszBackupPath)	\
    (This)->lpVtbl -> Backup(This,pszBackupPath)

#define IDirsyncDatabase_Restore(This,pszBackupPath)	\
    (This)->lpVtbl -> Restore(This,pszBackupPath)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IDirsyncDatabase_AddTable_Proxy( 
    IDirsyncDatabase * This,
    /* [in] */ PWSTR pszTableName,
    /* [retval][out] */ IDirsyncDatabaseTable **ppTable);


void __RPC_STUB IDirsyncDatabase_AddTable_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDirsyncDatabase_GetTable_Proxy( 
    IDirsyncDatabase * This,
    /* [in] */ PWSTR pszTableName,
    /* [retval][out] */ IDirsyncDatabaseTable **ppTable);


void __RPC_STUB IDirsyncDatabase_GetTable_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDirsyncDatabase_DeleteTable_Proxy( 
    IDirsyncDatabase * This,
    /* [in] */ PWSTR pszTableName);


void __RPC_STUB IDirsyncDatabase_DeleteTable_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDirsyncDatabase_BeginTransaction_Proxy( 
    IDirsyncDatabase * This);


void __RPC_STUB IDirsyncDatabase_BeginTransaction_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDirsyncDatabase_CommitTransaction_Proxy( 
    IDirsyncDatabase * This);


void __RPC_STUB IDirsyncDatabase_CommitTransaction_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDirsyncDatabase_AbortTransaction_Proxy( 
    IDirsyncDatabase * This);


void __RPC_STUB IDirsyncDatabase_AbortTransaction_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDirsyncDatabase_Backup_Proxy( 
    IDirsyncDatabase * This,
    /* [in] */ PWSTR pszBackupPath);


void __RPC_STUB IDirsyncDatabase_Backup_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDirsyncDatabase_Restore_Proxy( 
    IDirsyncDatabase * This,
    /* [in] */ PWSTR pszBackupPath);


void __RPC_STUB IDirsyncDatabase_Restore_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IDirsyncDatabase_INTERFACE_DEFINED__ */


#ifndef __IDirsyncDatabaseTable_INTERFACE_DEFINED__
#define __IDirsyncDatabaseTable_INTERFACE_DEFINED__

/* interface IDirsyncDatabaseTable */
/* [unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IDirsyncDatabaseTable;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("da2dab58-3098-11d3-be6d-0000f87a369e")
    IDirsyncDatabaseTable : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE AddColumn( 
            /* [in] */ DBTYPE dwType,
            /* [in] */ PWSTR pszColumnName) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE AddIndex( 
            /* [in] */ PWSTR pszColumnName,
            /* [in] */ PWSTR pszIndexName,
            /* [in] */ DWORD dwIndexType) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Seek( 
            /* [in] */ PWSTR szIndexName,
            /* [in] */ PDirsyncDBValue pValue) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE UpdateRow( 
            /* [in] */ PWSTR *rgszColumnName,
            /* [in] */ PDirsyncDBValue rgValue,
            /* [in] */ UPDATETYPE prep) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE RetrieveRow( 
            /* [in] */ PWSTR *rgszColumnName,
            /* [retval][out] */ PDirsyncDBValue rgValue) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE DeleteRow( 
            /* [in] */ PWSTR pszIndexName,
            /* [in] */ PDirsyncDBValue pValue) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetColumn( 
            /* [in] */ PWSTR pszColumnName,
            /* [in] */ PDirsyncDBValue pValue) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Move( 
            /* [in] */ DWORD dwOperation) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_RowCount( 
            /* [retval][out] */ DWORD *pdwRowCount) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDirsyncDatabaseTableVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IDirsyncDatabaseTable * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IDirsyncDatabaseTable * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IDirsyncDatabaseTable * This);
        
        HRESULT ( STDMETHODCALLTYPE *AddColumn )( 
            IDirsyncDatabaseTable * This,
            /* [in] */ DBTYPE dwType,
            /* [in] */ PWSTR pszColumnName);
        
        HRESULT ( STDMETHODCALLTYPE *AddIndex )( 
            IDirsyncDatabaseTable * This,
            /* [in] */ PWSTR pszColumnName,
            /* [in] */ PWSTR pszIndexName,
            /* [in] */ DWORD dwIndexType);
        
        HRESULT ( STDMETHODCALLTYPE *Seek )( 
            IDirsyncDatabaseTable * This,
            /* [in] */ PWSTR szIndexName,
            /* [in] */ PDirsyncDBValue pValue);
        
        HRESULT ( STDMETHODCALLTYPE *UpdateRow )( 
            IDirsyncDatabaseTable * This,
            /* [in] */ PWSTR *rgszColumnName,
            /* [in] */ PDirsyncDBValue rgValue,
            /* [in] */ UPDATETYPE prep);
        
        HRESULT ( STDMETHODCALLTYPE *RetrieveRow )( 
            IDirsyncDatabaseTable * This,
            /* [in] */ PWSTR *rgszColumnName,
            /* [retval][out] */ PDirsyncDBValue rgValue);
        
        HRESULT ( STDMETHODCALLTYPE *DeleteRow )( 
            IDirsyncDatabaseTable * This,
            /* [in] */ PWSTR pszIndexName,
            /* [in] */ PDirsyncDBValue pValue);
        
        HRESULT ( STDMETHODCALLTYPE *SetColumn )( 
            IDirsyncDatabaseTable * This,
            /* [in] */ PWSTR pszColumnName,
            /* [in] */ PDirsyncDBValue pValue);
        
        HRESULT ( STDMETHODCALLTYPE *Move )( 
            IDirsyncDatabaseTable * This,
            /* [in] */ DWORD dwOperation);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_RowCount )( 
            IDirsyncDatabaseTable * This,
            /* [retval][out] */ DWORD *pdwRowCount);
        
        END_INTERFACE
    } IDirsyncDatabaseTableVtbl;

    interface IDirsyncDatabaseTable
    {
        CONST_VTBL struct IDirsyncDatabaseTableVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDirsyncDatabaseTable_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IDirsyncDatabaseTable_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IDirsyncDatabaseTable_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IDirsyncDatabaseTable_AddColumn(This,dwType,pszColumnName)	\
    (This)->lpVtbl -> AddColumn(This,dwType,pszColumnName)

#define IDirsyncDatabaseTable_AddIndex(This,pszColumnName,pszIndexName,dwIndexType)	\
    (This)->lpVtbl -> AddIndex(This,pszColumnName,pszIndexName,dwIndexType)

#define IDirsyncDatabaseTable_Seek(This,szIndexName,pValue)	\
    (This)->lpVtbl -> Seek(This,szIndexName,pValue)

#define IDirsyncDatabaseTable_UpdateRow(This,rgszColumnName,rgValue,prep)	\
    (This)->lpVtbl -> UpdateRow(This,rgszColumnName,rgValue,prep)

#define IDirsyncDatabaseTable_RetrieveRow(This,rgszColumnName,rgValue)	\
    (This)->lpVtbl -> RetrieveRow(This,rgszColumnName,rgValue)

#define IDirsyncDatabaseTable_DeleteRow(This,pszIndexName,pValue)	\
    (This)->lpVtbl -> DeleteRow(This,pszIndexName,pValue)

#define IDirsyncDatabaseTable_SetColumn(This,pszColumnName,pValue)	\
    (This)->lpVtbl -> SetColumn(This,pszColumnName,pValue)

#define IDirsyncDatabaseTable_Move(This,dwOperation)	\
    (This)->lpVtbl -> Move(This,dwOperation)

#define IDirsyncDatabaseTable_get_RowCount(This,pdwRowCount)	\
    (This)->lpVtbl -> get_RowCount(This,pdwRowCount)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IDirsyncDatabaseTable_AddColumn_Proxy( 
    IDirsyncDatabaseTable * This,
    /* [in] */ DBTYPE dwType,
    /* [in] */ PWSTR pszColumnName);


void __RPC_STUB IDirsyncDatabaseTable_AddColumn_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDirsyncDatabaseTable_AddIndex_Proxy( 
    IDirsyncDatabaseTable * This,
    /* [in] */ PWSTR pszColumnName,
    /* [in] */ PWSTR pszIndexName,
    /* [in] */ DWORD dwIndexType);


void __RPC_STUB IDirsyncDatabaseTable_AddIndex_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDirsyncDatabaseTable_Seek_Proxy( 
    IDirsyncDatabaseTable * This,
    /* [in] */ PWSTR szIndexName,
    /* [in] */ PDirsyncDBValue pValue);


void __RPC_STUB IDirsyncDatabaseTable_Seek_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDirsyncDatabaseTable_UpdateRow_Proxy( 
    IDirsyncDatabaseTable * This,
    /* [in] */ PWSTR *rgszColumnName,
    /* [in] */ PDirsyncDBValue rgValue,
    /* [in] */ UPDATETYPE prep);


void __RPC_STUB IDirsyncDatabaseTable_UpdateRow_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDirsyncDatabaseTable_RetrieveRow_Proxy( 
    IDirsyncDatabaseTable * This,
    /* [in] */ PWSTR *rgszColumnName,
    /* [retval][out] */ PDirsyncDBValue rgValue);


void __RPC_STUB IDirsyncDatabaseTable_RetrieveRow_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDirsyncDatabaseTable_DeleteRow_Proxy( 
    IDirsyncDatabaseTable * This,
    /* [in] */ PWSTR pszIndexName,
    /* [in] */ PDirsyncDBValue pValue);


void __RPC_STUB IDirsyncDatabaseTable_DeleteRow_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDirsyncDatabaseTable_SetColumn_Proxy( 
    IDirsyncDatabaseTable * This,
    /* [in] */ PWSTR pszColumnName,
    /* [in] */ PDirsyncDBValue pValue);


void __RPC_STUB IDirsyncDatabaseTable_SetColumn_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDirsyncDatabaseTable_Move_Proxy( 
    IDirsyncDatabaseTable * This,
    /* [in] */ DWORD dwOperation);


void __RPC_STUB IDirsyncDatabaseTable_Move_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propget] */ HRESULT STDMETHODCALLTYPE IDirsyncDatabaseTable_get_RowCount_Proxy( 
    IDirsyncDatabaseTable * This,
    /* [retval][out] */ DWORD *pdwRowCount);


void __RPC_STUB IDirsyncDatabaseTable_get_RowCount_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IDirsyncDatabaseTable_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_dirsync_0110 */
/* [local] */ 


enum DatabaseMoveType
    {	DB_MOVE_FIRST	= 1,
	DB_MOVE_PREVIOUS	= 2,
	DB_MOVE_NEXT	= 3,
	DB_MOVE_LAST	= 4
    } ;

enum DatabaseIndexType
    {	DB_INDEX_PRIMARY	= 1,
	DB_INDEX_SECONDARY_UNIQUE	= 2,
	DB_INDEX_SECONDARY_NOTUNIQUE	= 3
    } ;



extern RPC_IF_HANDLE __MIDL_itf_dirsync_0110_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_dirsync_0110_v0_0_s_ifspec;

#ifndef __IEnumDirsyncSession_INTERFACE_DEFINED__
#define __IEnumDirsyncSession_INTERFACE_DEFINED__

/* interface IEnumDirsyncSession */
/* [unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IEnumDirsyncSession;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("12ac92e2-ca83-11d1-a40e-00c04fb950dc")
    IEnumDirsyncSession : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Next( 
            /* [in] */ ULONG cSession,
            /* [length_is][size_is][out] */ IDirsyncSession *rgSession[  ],
            /* [out] */ ULONG *pcSessionFetched) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Clone( 
            /* [retval][out] */ IEnumDirsyncSession **ppEnum) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Reset( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Skip( 
            /* [in] */ ULONG cSession) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IEnumDirsyncSessionVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IEnumDirsyncSession * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IEnumDirsyncSession * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IEnumDirsyncSession * This);
        
        HRESULT ( STDMETHODCALLTYPE *Next )( 
            IEnumDirsyncSession * This,
            /* [in] */ ULONG cSession,
            /* [length_is][size_is][out] */ IDirsyncSession *rgSession[  ],
            /* [out] */ ULONG *pcSessionFetched);
        
        HRESULT ( STDMETHODCALLTYPE *Clone )( 
            IEnumDirsyncSession * This,
            /* [retval][out] */ IEnumDirsyncSession **ppEnum);
        
        HRESULT ( STDMETHODCALLTYPE *Reset )( 
            IEnumDirsyncSession * This);
        
        HRESULT ( STDMETHODCALLTYPE *Skip )( 
            IEnumDirsyncSession * This,
            /* [in] */ ULONG cSession);
        
        END_INTERFACE
    } IEnumDirsyncSessionVtbl;

    interface IEnumDirsyncSession
    {
        CONST_VTBL struct IEnumDirsyncSessionVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IEnumDirsyncSession_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IEnumDirsyncSession_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IEnumDirsyncSession_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IEnumDirsyncSession_Next(This,cSession,rgSession,pcSessionFetched)	\
    (This)->lpVtbl -> Next(This,cSession,rgSession,pcSessionFetched)

#define IEnumDirsyncSession_Clone(This,ppEnum)	\
    (This)->lpVtbl -> Clone(This,ppEnum)

#define IEnumDirsyncSession_Reset(This)	\
    (This)->lpVtbl -> Reset(This)

#define IEnumDirsyncSession_Skip(This,cSession)	\
    (This)->lpVtbl -> Skip(This,cSession)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IEnumDirsyncSession_Next_Proxy( 
    IEnumDirsyncSession * This,
    /* [in] */ ULONG cSession,
    /* [length_is][size_is][out] */ IDirsyncSession *rgSession[  ],
    /* [out] */ ULONG *pcSessionFetched);


void __RPC_STUB IEnumDirsyncSession_Next_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumDirsyncSession_Clone_Proxy( 
    IEnumDirsyncSession * This,
    /* [retval][out] */ IEnumDirsyncSession **ppEnum);


void __RPC_STUB IEnumDirsyncSession_Clone_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumDirsyncSession_Reset_Proxy( 
    IEnumDirsyncSession * This);


void __RPC_STUB IEnumDirsyncSession_Reset_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumDirsyncSession_Skip_Proxy( 
    IEnumDirsyncSession * This,
    /* [in] */ ULONG cSession);


void __RPC_STUB IEnumDirsyncSession_Skip_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IEnumDirsyncSession_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_dirsync_0111 */
/* [local] */ 

//
// Bit fields for Flags property
//

#define DIRSYNC_PASSWORD_EXTRACT     0x00000001




extern RPC_IF_HANDLE __MIDL_itf_dirsync_0111_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_dirsync_0111_v0_0_s_ifspec;

#ifndef __IDirsyncSessionManager_INTERFACE_DEFINED__
#define __IDirsyncSessionManager_INTERFACE_DEFINED__

/* interface IDirsyncSessionManager */
/* [unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IDirsyncSessionManager;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("fc26ad44-c430-11d1-a407-00c04fb950dc")
    IDirsyncSessionManager : public IUnknown
    {
    public:
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_Server( 
            /* [retval][out] */ PWSTR *ppszServer) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_ServerGuid( 
            /* [retval][out] */ PWSTR *ppszServerGuid) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_Flags( 
            /* [retval][out] */ DWORD *pdwFlags) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CreateSession( 
            /* [retval][out] */ IDirsyncSession **ppSession) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetSession( 
            /* [in] */ DWORD dwSessionId,
            /* [retval][out] */ IDirsyncSession **ppSession) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE DeleteSession( 
            /* [in] */ DWORD dwSessionId) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE PauseSession( 
            /* [in] */ DWORD dwSessionId,
            /* [in] */ BOOL fPause) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetSessionCount( 
            /* [retval][out] */ DWORD *pdwSessions) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetEnumInterface( 
            /* [in] */ BOOL fGlobal,
            /* [retval][out] */ IEnumDirsyncSession **pEnumSession) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ExecuteSession( 
            /* [in] */ DWORD dwSessionId,
            /* [in] */ DWORD dwExecuteType,
            /* [in] */ BOOL fFullSync,
            /* [in] */ BOOL fSynchronous,
            /* [in] */ IDirsyncStatus *pStatus) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CancelSession( 
            /* [in] */ DWORD dwSessionId) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDirsyncSessionManagerVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IDirsyncSessionManager * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IDirsyncSessionManager * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IDirsyncSessionManager * This);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_Server )( 
            IDirsyncSessionManager * This,
            /* [retval][out] */ PWSTR *ppszServer);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_ServerGuid )( 
            IDirsyncSessionManager * This,
            /* [retval][out] */ PWSTR *ppszServerGuid);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_Flags )( 
            IDirsyncSessionManager * This,
            /* [retval][out] */ DWORD *pdwFlags);
        
        HRESULT ( STDMETHODCALLTYPE *CreateSession )( 
            IDirsyncSessionManager * This,
            /* [retval][out] */ IDirsyncSession **ppSession);
        
        HRESULT ( STDMETHODCALLTYPE *GetSession )( 
            IDirsyncSessionManager * This,
            /* [in] */ DWORD dwSessionId,
            /* [retval][out] */ IDirsyncSession **ppSession);
        
        HRESULT ( STDMETHODCALLTYPE *DeleteSession )( 
            IDirsyncSessionManager * This,
            /* [in] */ DWORD dwSessionId);
        
        HRESULT ( STDMETHODCALLTYPE *PauseSession )( 
            IDirsyncSessionManager * This,
            /* [in] */ DWORD dwSessionId,
            /* [in] */ BOOL fPause);
        
        HRESULT ( STDMETHODCALLTYPE *GetSessionCount )( 
            IDirsyncSessionManager * This,
            /* [retval][out] */ DWORD *pdwSessions);
        
        HRESULT ( STDMETHODCALLTYPE *GetEnumInterface )( 
            IDirsyncSessionManager * This,
            /* [in] */ BOOL fGlobal,
            /* [retval][out] */ IEnumDirsyncSession **pEnumSession);
        
        HRESULT ( STDMETHODCALLTYPE *ExecuteSession )( 
            IDirsyncSessionManager * This,
            /* [in] */ DWORD dwSessionId,
            /* [in] */ DWORD dwExecuteType,
            /* [in] */ BOOL fFullSync,
            /* [in] */ BOOL fSynchronous,
            /* [in] */ IDirsyncStatus *pStatus);
        
        HRESULT ( STDMETHODCALLTYPE *CancelSession )( 
            IDirsyncSessionManager * This,
            /* [in] */ DWORD dwSessionId);
        
        END_INTERFACE
    } IDirsyncSessionManagerVtbl;

    interface IDirsyncSessionManager
    {
        CONST_VTBL struct IDirsyncSessionManagerVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDirsyncSessionManager_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IDirsyncSessionManager_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IDirsyncSessionManager_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IDirsyncSessionManager_get_Server(This,ppszServer)	\
    (This)->lpVtbl -> get_Server(This,ppszServer)

#define IDirsyncSessionManager_get_ServerGuid(This,ppszServerGuid)	\
    (This)->lpVtbl -> get_ServerGuid(This,ppszServerGuid)

#define IDirsyncSessionManager_get_Flags(This,pdwFlags)	\
    (This)->lpVtbl -> get_Flags(This,pdwFlags)

#define IDirsyncSessionManager_CreateSession(This,ppSession)	\
    (This)->lpVtbl -> CreateSession(This,ppSession)

#define IDirsyncSessionManager_GetSession(This,dwSessionId,ppSession)	\
    (This)->lpVtbl -> GetSession(This,dwSessionId,ppSession)

#define IDirsyncSessionManager_DeleteSession(This,dwSessionId)	\
    (This)->lpVtbl -> DeleteSession(This,dwSessionId)

#define IDirsyncSessionManager_PauseSession(This,dwSessionId,fPause)	\
    (This)->lpVtbl -> PauseSession(This,dwSessionId,fPause)

#define IDirsyncSessionManager_GetSessionCount(This,pdwSessions)	\
    (This)->lpVtbl -> GetSessionCount(This,pdwSessions)

#define IDirsyncSessionManager_GetEnumInterface(This,fGlobal,pEnumSession)	\
    (This)->lpVtbl -> GetEnumInterface(This,fGlobal,pEnumSession)

#define IDirsyncSessionManager_ExecuteSession(This,dwSessionId,dwExecuteType,fFullSync,fSynchronous,pStatus)	\
    (This)->lpVtbl -> ExecuteSession(This,dwSessionId,dwExecuteType,fFullSync,fSynchronous,pStatus)

#define IDirsyncSessionManager_CancelSession(This,dwSessionId)	\
    (This)->lpVtbl -> CancelSession(This,dwSessionId)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [propget] */ HRESULT STDMETHODCALLTYPE IDirsyncSessionManager_get_Server_Proxy( 
    IDirsyncSessionManager * This,
    /* [retval][out] */ PWSTR *ppszServer);


void __RPC_STUB IDirsyncSessionManager_get_Server_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propget] */ HRESULT STDMETHODCALLTYPE IDirsyncSessionManager_get_ServerGuid_Proxy( 
    IDirsyncSessionManager * This,
    /* [retval][out] */ PWSTR *ppszServerGuid);


void __RPC_STUB IDirsyncSessionManager_get_ServerGuid_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propget] */ HRESULT STDMETHODCALLTYPE IDirsyncSessionManager_get_Flags_Proxy( 
    IDirsyncSessionManager * This,
    /* [retval][out] */ DWORD *pdwFlags);


void __RPC_STUB IDirsyncSessionManager_get_Flags_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDirsyncSessionManager_CreateSession_Proxy( 
    IDirsyncSessionManager * This,
    /* [retval][out] */ IDirsyncSession **ppSession);


void __RPC_STUB IDirsyncSessionManager_CreateSession_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDirsyncSessionManager_GetSession_Proxy( 
    IDirsyncSessionManager * This,
    /* [in] */ DWORD dwSessionId,
    /* [retval][out] */ IDirsyncSession **ppSession);


void __RPC_STUB IDirsyncSessionManager_GetSession_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDirsyncSessionManager_DeleteSession_Proxy( 
    IDirsyncSessionManager * This,
    /* [in] */ DWORD dwSessionId);


void __RPC_STUB IDirsyncSessionManager_DeleteSession_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDirsyncSessionManager_PauseSession_Proxy( 
    IDirsyncSessionManager * This,
    /* [in] */ DWORD dwSessionId,
    /* [in] */ BOOL fPause);


void __RPC_STUB IDirsyncSessionManager_PauseSession_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDirsyncSessionManager_GetSessionCount_Proxy( 
    IDirsyncSessionManager * This,
    /* [retval][out] */ DWORD *pdwSessions);


void __RPC_STUB IDirsyncSessionManager_GetSessionCount_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDirsyncSessionManager_GetEnumInterface_Proxy( 
    IDirsyncSessionManager * This,
    /* [in] */ BOOL fGlobal,
    /* [retval][out] */ IEnumDirsyncSession **pEnumSession);


void __RPC_STUB IDirsyncSessionManager_GetEnumInterface_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDirsyncSessionManager_ExecuteSession_Proxy( 
    IDirsyncSessionManager * This,
    /* [in] */ DWORD dwSessionId,
    /* [in] */ DWORD dwExecuteType,
    /* [in] */ BOOL fFullSync,
    /* [in] */ BOOL fSynchronous,
    /* [in] */ IDirsyncStatus *pStatus);


void __RPC_STUB IDirsyncSessionManager_ExecuteSession_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDirsyncSessionManager_CancelSession_Proxy( 
    IDirsyncSessionManager * This,
    /* [in] */ DWORD dwSessionId);


void __RPC_STUB IDirsyncSessionManager_CancelSession_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IDirsyncSessionManager_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_dirsync_0112 */
/* [local] */ 


enum ExecutionType
    {	EXECUTESESSION_FORWARD	= 1,
	EXECUTESESSION_REVERSE	= 2,
	EXECUTESESSION_FORWARD_REVERSE	= 3,
	EXECUTESESSION_REVERSE_FORWARD	= 4
    } ;



extern RPC_IF_HANDLE __MIDL_itf_dirsync_0112_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_dirsync_0112_v0_0_s_ifspec;

#ifndef __IDirsyncObjectMapper_INTERFACE_DEFINED__
#define __IDirsyncObjectMapper_INTERFACE_DEFINED__

/* interface IDirsyncObjectMapper */
/* [unique][helpstring][uuid][local][object] */ 


EXTERN_C const IID IID_IDirsyncObjectMapper;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("c5cf7e60-e91f-11d1-b40f-00c04fb950dc")
    IDirsyncObjectMapper : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Initialize( 
            /* [in] */ IDirsyncSession *pSession,
            /* [in] */ IDirsyncSessionCallback *pSessionCallback,
            /* [in] */ IDirsyncSessionManager *pSessionManager,
            /* [in] */ SYNCDIRECTION syncDirection,
            /* [in] */ BOOL fFullSync) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE MapObject( 
            /* [out][in] */ PDIRSYNCOBJECT pObject,
            /* [out][in] */ BOOL *pfMore) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE MapAttributeName( 
            /* [in] */ PWSTR pszClassIn,
            /* [in] */ PWSTR pszAttrIn,
            /* [out] */ PWSTR *ppszAttrOut,
            /* [in] */ SYNCDIRECTION syncDirection) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE MapNamespace( 
            /* [in] */ PWSTR pszSourceDN,
            /* [out] */ PWSTR *ppszTargetDN,
            /* [in] */ PWSTR pszClassName,
            /* [in] */ PWSTR pszAttrName) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE IsClassMappingValid( 
            /* [in] */ PWSTR pszClassSource,
            /* [in] */ PWSTR pszClassTarget) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDirsyncObjectMapperVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IDirsyncObjectMapper * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IDirsyncObjectMapper * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IDirsyncObjectMapper * This);
        
        HRESULT ( STDMETHODCALLTYPE *Initialize )( 
            IDirsyncObjectMapper * This,
            /* [in] */ IDirsyncSession *pSession,
            /* [in] */ IDirsyncSessionCallback *pSessionCallback,
            /* [in] */ IDirsyncSessionManager *pSessionManager,
            /* [in] */ SYNCDIRECTION syncDirection,
            /* [in] */ BOOL fFullSync);
        
        HRESULT ( STDMETHODCALLTYPE *MapObject )( 
            IDirsyncObjectMapper * This,
            /* [out][in] */ PDIRSYNCOBJECT pObject,
            /* [out][in] */ BOOL *pfMore);
        
        HRESULT ( STDMETHODCALLTYPE *MapAttributeName )( 
            IDirsyncObjectMapper * This,
            /* [in] */ PWSTR pszClassIn,
            /* [in] */ PWSTR pszAttrIn,
            /* [out] */ PWSTR *ppszAttrOut,
            /* [in] */ SYNCDIRECTION syncDirection);
        
        HRESULT ( STDMETHODCALLTYPE *MapNamespace )( 
            IDirsyncObjectMapper * This,
            /* [in] */ PWSTR pszSourceDN,
            /* [out] */ PWSTR *ppszTargetDN,
            /* [in] */ PWSTR pszClassName,
            /* [in] */ PWSTR pszAttrName);
        
        HRESULT ( STDMETHODCALLTYPE *IsClassMappingValid )( 
            IDirsyncObjectMapper * This,
            /* [in] */ PWSTR pszClassSource,
            /* [in] */ PWSTR pszClassTarget);
        
        END_INTERFACE
    } IDirsyncObjectMapperVtbl;

    interface IDirsyncObjectMapper
    {
        CONST_VTBL struct IDirsyncObjectMapperVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDirsyncObjectMapper_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IDirsyncObjectMapper_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IDirsyncObjectMapper_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IDirsyncObjectMapper_Initialize(This,pSession,pSessionCallback,pSessionManager,syncDirection,fFullSync)	\
    (This)->lpVtbl -> Initialize(This,pSession,pSessionCallback,pSessionManager,syncDirection,fFullSync)

#define IDirsyncObjectMapper_MapObject(This,pObject,pfMore)	\
    (This)->lpVtbl -> MapObject(This,pObject,pfMore)

#define IDirsyncObjectMapper_MapAttributeName(This,pszClassIn,pszAttrIn,ppszAttrOut,syncDirection)	\
    (This)->lpVtbl -> MapAttributeName(This,pszClassIn,pszAttrIn,ppszAttrOut,syncDirection)

#define IDirsyncObjectMapper_MapNamespace(This,pszSourceDN,ppszTargetDN,pszClassName,pszAttrName)	\
    (This)->lpVtbl -> MapNamespace(This,pszSourceDN,ppszTargetDN,pszClassName,pszAttrName)

#define IDirsyncObjectMapper_IsClassMappingValid(This,pszClassSource,pszClassTarget)	\
    (This)->lpVtbl -> IsClassMappingValid(This,pszClassSource,pszClassTarget)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IDirsyncObjectMapper_Initialize_Proxy( 
    IDirsyncObjectMapper * This,
    /* [in] */ IDirsyncSession *pSession,
    /* [in] */ IDirsyncSessionCallback *pSessionCallback,
    /* [in] */ IDirsyncSessionManager *pSessionManager,
    /* [in] */ SYNCDIRECTION syncDirection,
    /* [in] */ BOOL fFullSync);


void __RPC_STUB IDirsyncObjectMapper_Initialize_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDirsyncObjectMapper_MapObject_Proxy( 
    IDirsyncObjectMapper * This,
    /* [out][in] */ PDIRSYNCOBJECT pObject,
    /* [out][in] */ BOOL *pfMore);


void __RPC_STUB IDirsyncObjectMapper_MapObject_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDirsyncObjectMapper_MapAttributeName_Proxy( 
    IDirsyncObjectMapper * This,
    /* [in] */ PWSTR pszClassIn,
    /* [in] */ PWSTR pszAttrIn,
    /* [out] */ PWSTR *ppszAttrOut,
    /* [in] */ SYNCDIRECTION syncDirection);


void __RPC_STUB IDirsyncObjectMapper_MapAttributeName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDirsyncObjectMapper_MapNamespace_Proxy( 
    IDirsyncObjectMapper * This,
    /* [in] */ PWSTR pszSourceDN,
    /* [out] */ PWSTR *ppszTargetDN,
    /* [in] */ PWSTR pszClassName,
    /* [in] */ PWSTR pszAttrName);


void __RPC_STUB IDirsyncObjectMapper_MapNamespace_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDirsyncObjectMapper_IsClassMappingValid_Proxy( 
    IDirsyncObjectMapper * This,
    /* [in] */ PWSTR pszClassSource,
    /* [in] */ PWSTR pszClassTarget);


void __RPC_STUB IDirsyncObjectMapper_IsClassMappingValid_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IDirsyncObjectMapper_INTERFACE_DEFINED__ */


#ifndef __IEnumDirsyncFailedObjectList_INTERFACE_DEFINED__
#define __IEnumDirsyncFailedObjectList_INTERFACE_DEFINED__

/* interface IEnumDirsyncFailedObjectList */
/* [unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IEnumDirsyncFailedObjectList;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("a74c77a2-622b-11d2-9284-00c04f79f834")
    IEnumDirsyncFailedObjectList : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Next( 
            /* [in] */ ULONG cFailedObjects,
            /* [length_is][size_is][out] */ PFAILEDOBJECT rgpFailedObjects[  ],
            /* [out] */ ULONG *pcFailedObjectsFetched) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Clone( 
            /* [retval][out] */ IEnumDirsyncFailedObjectList **ppEnum) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Reset( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Skip( 
            /* [in] */ ULONG cFailedObjects) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IEnumDirsyncFailedObjectListVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IEnumDirsyncFailedObjectList * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IEnumDirsyncFailedObjectList * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IEnumDirsyncFailedObjectList * This);
        
        HRESULT ( STDMETHODCALLTYPE *Next )( 
            IEnumDirsyncFailedObjectList * This,
            /* [in] */ ULONG cFailedObjects,
            /* [length_is][size_is][out] */ PFAILEDOBJECT rgpFailedObjects[  ],
            /* [out] */ ULONG *pcFailedObjectsFetched);
        
        HRESULT ( STDMETHODCALLTYPE *Clone )( 
            IEnumDirsyncFailedObjectList * This,
            /* [retval][out] */ IEnumDirsyncFailedObjectList **ppEnum);
        
        HRESULT ( STDMETHODCALLTYPE *Reset )( 
            IEnumDirsyncFailedObjectList * This);
        
        HRESULT ( STDMETHODCALLTYPE *Skip )( 
            IEnumDirsyncFailedObjectList * This,
            /* [in] */ ULONG cFailedObjects);
        
        END_INTERFACE
    } IEnumDirsyncFailedObjectListVtbl;

    interface IEnumDirsyncFailedObjectList
    {
        CONST_VTBL struct IEnumDirsyncFailedObjectListVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IEnumDirsyncFailedObjectList_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IEnumDirsyncFailedObjectList_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IEnumDirsyncFailedObjectList_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IEnumDirsyncFailedObjectList_Next(This,cFailedObjects,rgpFailedObjects,pcFailedObjectsFetched)	\
    (This)->lpVtbl -> Next(This,cFailedObjects,rgpFailedObjects,pcFailedObjectsFetched)

#define IEnumDirsyncFailedObjectList_Clone(This,ppEnum)	\
    (This)->lpVtbl -> Clone(This,ppEnum)

#define IEnumDirsyncFailedObjectList_Reset(This)	\
    (This)->lpVtbl -> Reset(This)

#define IEnumDirsyncFailedObjectList_Skip(This,cFailedObjects)	\
    (This)->lpVtbl -> Skip(This,cFailedObjects)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IEnumDirsyncFailedObjectList_Next_Proxy( 
    IEnumDirsyncFailedObjectList * This,
    /* [in] */ ULONG cFailedObjects,
    /* [length_is][size_is][out] */ PFAILEDOBJECT rgpFailedObjects[  ],
    /* [out] */ ULONG *pcFailedObjectsFetched);


void __RPC_STUB IEnumDirsyncFailedObjectList_Next_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumDirsyncFailedObjectList_Clone_Proxy( 
    IEnumDirsyncFailedObjectList * This,
    /* [retval][out] */ IEnumDirsyncFailedObjectList **ppEnum);


void __RPC_STUB IEnumDirsyncFailedObjectList_Clone_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumDirsyncFailedObjectList_Reset_Proxy( 
    IEnumDirsyncFailedObjectList * This);


void __RPC_STUB IEnumDirsyncFailedObjectList_Reset_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumDirsyncFailedObjectList_Skip_Proxy( 
    IEnumDirsyncFailedObjectList * This,
    /* [in] */ ULONG cFailedObjects);


void __RPC_STUB IEnumDirsyncFailedObjectList_Skip_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IEnumDirsyncFailedObjectList_INTERFACE_DEFINED__ */


#ifndef __IDirsyncFailedObjectList_INTERFACE_DEFINED__
#define __IDirsyncFailedObjectList_INTERFACE_DEFINED__

/* interface IDirsyncFailedObjectList */
/* [unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IDirsyncFailedObjectList;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("a16c0bcc-622b-11d2-9284-00c04f79f834")
    IDirsyncFailedObjectList : public IUnknown
    {
    public:
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_Count( 
            /* [retval][out] */ DWORD *pdwCount) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetObject( 
            /* [in] */ PWSTR pszID,
            /* [retval][out] */ PFAILEDOBJECT *ppFailedObject) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE DeleteObject( 
            /* [in] */ PWSTR pszID) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE UpdateObject( 
            /* [in] */ PWSTR pszID,
            /* [in] */ PFAILEDOBJECT pFailedObject) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetEnumInterface( 
            /* [retval][out] */ IEnumDirsyncFailedObjectList **pEnumFailedObject) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDirsyncFailedObjectListVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IDirsyncFailedObjectList * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IDirsyncFailedObjectList * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IDirsyncFailedObjectList * This);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_Count )( 
            IDirsyncFailedObjectList * This,
            /* [retval][out] */ DWORD *pdwCount);
        
        HRESULT ( STDMETHODCALLTYPE *GetObject )( 
            IDirsyncFailedObjectList * This,
            /* [in] */ PWSTR pszID,
            /* [retval][out] */ PFAILEDOBJECT *ppFailedObject);
        
        HRESULT ( STDMETHODCALLTYPE *DeleteObject )( 
            IDirsyncFailedObjectList * This,
            /* [in] */ PWSTR pszID);
        
        HRESULT ( STDMETHODCALLTYPE *UpdateObject )( 
            IDirsyncFailedObjectList * This,
            /* [in] */ PWSTR pszID,
            /* [in] */ PFAILEDOBJECT pFailedObject);
        
        HRESULT ( STDMETHODCALLTYPE *GetEnumInterface )( 
            IDirsyncFailedObjectList * This,
            /* [retval][out] */ IEnumDirsyncFailedObjectList **pEnumFailedObject);
        
        END_INTERFACE
    } IDirsyncFailedObjectListVtbl;

    interface IDirsyncFailedObjectList
    {
        CONST_VTBL struct IDirsyncFailedObjectListVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDirsyncFailedObjectList_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IDirsyncFailedObjectList_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IDirsyncFailedObjectList_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IDirsyncFailedObjectList_get_Count(This,pdwCount)	\
    (This)->lpVtbl -> get_Count(This,pdwCount)

#define IDirsyncFailedObjectList_GetObject(This,pszID,ppFailedObject)	\
    (This)->lpVtbl -> GetObject(This,pszID,ppFailedObject)

#define IDirsyncFailedObjectList_DeleteObject(This,pszID)	\
    (This)->lpVtbl -> DeleteObject(This,pszID)

#define IDirsyncFailedObjectList_UpdateObject(This,pszID,pFailedObject)	\
    (This)->lpVtbl -> UpdateObject(This,pszID,pFailedObject)

#define IDirsyncFailedObjectList_GetEnumInterface(This,pEnumFailedObject)	\
    (This)->lpVtbl -> GetEnumInterface(This,pEnumFailedObject)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [propget] */ HRESULT STDMETHODCALLTYPE IDirsyncFailedObjectList_get_Count_Proxy( 
    IDirsyncFailedObjectList * This,
    /* [retval][out] */ DWORD *pdwCount);


void __RPC_STUB IDirsyncFailedObjectList_get_Count_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDirsyncFailedObjectList_GetObject_Proxy( 
    IDirsyncFailedObjectList * This,
    /* [in] */ PWSTR pszID,
    /* [retval][out] */ PFAILEDOBJECT *ppFailedObject);


void __RPC_STUB IDirsyncFailedObjectList_GetObject_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDirsyncFailedObjectList_DeleteObject_Proxy( 
    IDirsyncFailedObjectList * This,
    /* [in] */ PWSTR pszID);


void __RPC_STUB IDirsyncFailedObjectList_DeleteObject_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDirsyncFailedObjectList_UpdateObject_Proxy( 
    IDirsyncFailedObjectList * This,
    /* [in] */ PWSTR pszID,
    /* [in] */ PFAILEDOBJECT pFailedObject);


void __RPC_STUB IDirsyncFailedObjectList_UpdateObject_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDirsyncFailedObjectList_GetEnumInterface_Proxy( 
    IDirsyncFailedObjectList * This,
    /* [retval][out] */ IEnumDirsyncFailedObjectList **pEnumFailedObject);


void __RPC_STUB IDirsyncFailedObjectList_GetEnumInterface_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IDirsyncFailedObjectList_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_dirsync_0115 */
/* [local] */ 




extern RPC_IF_HANDLE __MIDL_itf_dirsync_0115_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_dirsync_0115_v0_0_s_ifspec;

#ifndef __IDirsyncNamespaceMapping_INTERFACE_DEFINED__
#define __IDirsyncNamespaceMapping_INTERFACE_DEFINED__

/* interface IDirsyncNamespaceMapping */
/* [unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IDirsyncNamespaceMapping;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("d5a63159-88e6-4a50-833d-77da95dcb327")
    IDirsyncNamespaceMapping : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetMappings( 
            /* [size_is][size_is][out] */ PWSTR **prgpszPublisher,
            /* [size_is][size_is][out] */ PWSTR **prgpszSubscriber,
            /* [out] */ DWORD *pdwCount) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE AddMappings( 
            /* [size_is][in] */ PWSTR *rgpszPublisher,
            /* [size_is][in] */ PWSTR *rgpszSubscriber,
            /* [in] */ DWORD dwCount) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE DeleteMapping( 
            /* [in] */ PWSTR pszPublisher,
            /* [in] */ PWSTR pszSubscriber) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE LookupMapping( 
            /* [in] */ PWSTR pszSource,
            /* [in] */ BOOL fPublisher,
            /* [in] */ PWSTR *pszTarget) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE UpdateMapping( 
            /* [in] */ PWSTR pszPublisherOld,
            /* [in] */ PWSTR pszSubscriberOld,
            /* [in] */ PWSTR pszPublisher,
            /* [in] */ PWSTR pszSubscriber) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ClearMappings( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Persist( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDirsyncNamespaceMappingVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IDirsyncNamespaceMapping * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IDirsyncNamespaceMapping * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IDirsyncNamespaceMapping * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetMappings )( 
            IDirsyncNamespaceMapping * This,
            /* [size_is][size_is][out] */ PWSTR **prgpszPublisher,
            /* [size_is][size_is][out] */ PWSTR **prgpszSubscriber,
            /* [out] */ DWORD *pdwCount);
        
        HRESULT ( STDMETHODCALLTYPE *AddMappings )( 
            IDirsyncNamespaceMapping * This,
            /* [size_is][in] */ PWSTR *rgpszPublisher,
            /* [size_is][in] */ PWSTR *rgpszSubscriber,
            /* [in] */ DWORD dwCount);
        
        HRESULT ( STDMETHODCALLTYPE *DeleteMapping )( 
            IDirsyncNamespaceMapping * This,
            /* [in] */ PWSTR pszPublisher,
            /* [in] */ PWSTR pszSubscriber);
        
        HRESULT ( STDMETHODCALLTYPE *LookupMapping )( 
            IDirsyncNamespaceMapping * This,
            /* [in] */ PWSTR pszSource,
            /* [in] */ BOOL fPublisher,
            /* [in] */ PWSTR *pszTarget);
        
        HRESULT ( STDMETHODCALLTYPE *UpdateMapping )( 
            IDirsyncNamespaceMapping * This,
            /* [in] */ PWSTR pszPublisherOld,
            /* [in] */ PWSTR pszSubscriberOld,
            /* [in] */ PWSTR pszPublisher,
            /* [in] */ PWSTR pszSubscriber);
        
        HRESULT ( STDMETHODCALLTYPE *ClearMappings )( 
            IDirsyncNamespaceMapping * This);
        
        HRESULT ( STDMETHODCALLTYPE *Persist )( 
            IDirsyncNamespaceMapping * This);
        
        END_INTERFACE
    } IDirsyncNamespaceMappingVtbl;

    interface IDirsyncNamespaceMapping
    {
        CONST_VTBL struct IDirsyncNamespaceMappingVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDirsyncNamespaceMapping_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IDirsyncNamespaceMapping_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IDirsyncNamespaceMapping_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IDirsyncNamespaceMapping_GetMappings(This,prgpszPublisher,prgpszSubscriber,pdwCount)	\
    (This)->lpVtbl -> GetMappings(This,prgpszPublisher,prgpszSubscriber,pdwCount)

#define IDirsyncNamespaceMapping_AddMappings(This,rgpszPublisher,rgpszSubscriber,dwCount)	\
    (This)->lpVtbl -> AddMappings(This,rgpszPublisher,rgpszSubscriber,dwCount)

#define IDirsyncNamespaceMapping_DeleteMapping(This,pszPublisher,pszSubscriber)	\
    (This)->lpVtbl -> DeleteMapping(This,pszPublisher,pszSubscriber)

#define IDirsyncNamespaceMapping_LookupMapping(This,pszSource,fPublisher,pszTarget)	\
    (This)->lpVtbl -> LookupMapping(This,pszSource,fPublisher,pszTarget)

#define IDirsyncNamespaceMapping_UpdateMapping(This,pszPublisherOld,pszSubscriberOld,pszPublisher,pszSubscriber)	\
    (This)->lpVtbl -> UpdateMapping(This,pszPublisherOld,pszSubscriberOld,pszPublisher,pszSubscriber)

#define IDirsyncNamespaceMapping_ClearMappings(This)	\
    (This)->lpVtbl -> ClearMappings(This)

#define IDirsyncNamespaceMapping_Persist(This)	\
    (This)->lpVtbl -> Persist(This)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IDirsyncNamespaceMapping_GetMappings_Proxy( 
    IDirsyncNamespaceMapping * This,
    /* [size_is][size_is][out] */ PWSTR **prgpszPublisher,
    /* [size_is][size_is][out] */ PWSTR **prgpszSubscriber,
    /* [out] */ DWORD *pdwCount);


void __RPC_STUB IDirsyncNamespaceMapping_GetMappings_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDirsyncNamespaceMapping_AddMappings_Proxy( 
    IDirsyncNamespaceMapping * This,
    /* [size_is][in] */ PWSTR *rgpszPublisher,
    /* [size_is][in] */ PWSTR *rgpszSubscriber,
    /* [in] */ DWORD dwCount);


void __RPC_STUB IDirsyncNamespaceMapping_AddMappings_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDirsyncNamespaceMapping_DeleteMapping_Proxy( 
    IDirsyncNamespaceMapping * This,
    /* [in] */ PWSTR pszPublisher,
    /* [in] */ PWSTR pszSubscriber);


void __RPC_STUB IDirsyncNamespaceMapping_DeleteMapping_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDirsyncNamespaceMapping_LookupMapping_Proxy( 
    IDirsyncNamespaceMapping * This,
    /* [in] */ PWSTR pszSource,
    /* [in] */ BOOL fPublisher,
    /* [in] */ PWSTR *pszTarget);


void __RPC_STUB IDirsyncNamespaceMapping_LookupMapping_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDirsyncNamespaceMapping_UpdateMapping_Proxy( 
    IDirsyncNamespaceMapping * This,
    /* [in] */ PWSTR pszPublisherOld,
    /* [in] */ PWSTR pszSubscriberOld,
    /* [in] */ PWSTR pszPublisher,
    /* [in] */ PWSTR pszSubscriber);


void __RPC_STUB IDirsyncNamespaceMapping_UpdateMapping_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDirsyncNamespaceMapping_ClearMappings_Proxy( 
    IDirsyncNamespaceMapping * This);


void __RPC_STUB IDirsyncNamespaceMapping_ClearMappings_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDirsyncNamespaceMapping_Persist_Proxy( 
    IDirsyncNamespaceMapping * This);


void __RPC_STUB IDirsyncNamespaceMapping_Persist_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IDirsyncNamespaceMapping_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_dirsync_0116 */
/* [local] */ 

//
// Bit fields
//

#define SESSION_NAME                0x00000001
#define SESSION_COMMENTS            0x00000002
#define SESSION_FLAGS               0x00000004
#define SESSION_LOGLEVEL            0x00000008
#define SESSION_SCHEDULE_FORWARD    0x00000010
#define SESSION_SCHEDULE_REVERSE    0x00000020
#define SESSION_SRCDIRTYPE          0x00000040
#define SESSION_SRCSERVER           0x00000080
#define SESSION_SRCUSERNAME         0x00000100
#define SESSION_SRCPASSWORD         0x00000200
#define SESSION_SRCBASE             0x00000400
#define SESSION_SRCSCOPE            0x00000800
#define SESSION_SRCFILTER           0x00001000
#define SESSION_SRCPASSWORDOPTIONS  0x00002000
#define SESSION_TGTDIRTYPE          0x00004000
#define SESSION_TGTSERVER           0x00008000
#define SESSION_TGTUSERNAME         0x00010000
#define SESSION_TGTPASSWORD         0x00020000
#define SESSION_TGTBASE             0x00040000
#define SESSION_TGTSCOPE            0x00080000
#define SESSION_TGTFILTER           0x00100000
#define SESSION_TGTPASSWORDOPTIONS  0x00200000
#define SESSION_MAPFORWARD          0x00400000
#define SESSION_MAPBACKWARD         0x00800000
#define SESSION_NAMESPACEMAP        0x01000000
#define SESSION_FINEGRAINSTATUS     0x02000000


//
// Session Status
//

#define SESSION_PAUSED       1
#define SESSION_IDLE         2
#define SESSION_IN_PROGRESS  3

//
// Session Flags
//

#define FLAG_FIXUP_SAMACCOUNTNAME_CONFLICT   0x00000001
#define FLAG_FAIL_DN_CONFLICT                0x00000002
#define FLAG_CUSTOM_NAMESPACE_MAPPING        0x00000004
#define FLAG_OBJECTS_HAVE_UNIQUE_ID          0x00000008
#define FLAG_PUBLISHER_ID_IS_INDEXED         0x00000010
#define FLAG_SUBSCRIBER_ID_IS_INDEXED        0x00000020
#define FLAG_INC_SYNC_NOT_AVAILABLE          0x00000040




extern RPC_IF_HANDLE __MIDL_itf_dirsync_0116_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_dirsync_0116_v0_0_s_ifspec;

#ifndef __IDirsyncSession_INTERFACE_DEFINED__
#define __IDirsyncSession_INTERFACE_DEFINED__

/* interface IDirsyncSession */
/* [unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IDirsyncSession;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("3d72b13e-c8ec-11d1-a40b-00c04fb950dc")
    IDirsyncSession : public IUnknown
    {
    public:
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_Name( 
            /* [retval][out] */ PWSTR *ppszName) = 0;
        
        virtual /* [propput] */ HRESULT STDMETHODCALLTYPE put_Name( 
            /* [full][in] */ PWSTR pszName) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_Comments( 
            /* [retval][out] */ PWSTR *ppszComments) = 0;
        
        virtual /* [propput] */ HRESULT STDMETHODCALLTYPE put_Comments( 
            /* [full][in] */ PWSTR pszComments) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_Flags( 
            /* [retval][out] */ DWORD *pdwFlags) = 0;
        
        virtual /* [propput] */ HRESULT STDMETHODCALLTYPE put_Flags( 
            /* [in] */ DWORD dwFlags) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_Status( 
            /* [retval][out] */ DWORD *pdwStatus) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_LogLevel( 
            /* [retval][out] */ DWORD *pdwLogLevel) = 0;
        
        virtual /* [propput] */ HRESULT STDMETHODCALLTYPE put_LogLevel( 
            /* [in] */ DWORD dwLogLevel) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_ID( 
            /* [retval][out] */ DWORD *pdwID) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_CreatedBy( 
            /* [retval][out] */ PWSTR *ppszCreatedBy) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_CreationTime( 
            /* [retval][out] */ LARGE_INTEGER *pCreationTime) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_LastChangedBy( 
            /* [retval][out] */ PWSTR *ppszLastChangedBy) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_LastChangeTime( 
            /* [retval][out] */ LARGE_INTEGER *pLastChangeTime) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_SourceDirType( 
            /* [retval][out] */ PWSTR *ppszSourceDirType) = 0;
        
        virtual /* [propput] */ HRESULT STDMETHODCALLTYPE put_SourceDirType( 
            /* [full][in] */ PWSTR pszSourceDirType) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_SourceServer( 
            /* [retval][out] */ PWSTR *ppszSourceServer) = 0;
        
        virtual /* [propput] */ HRESULT STDMETHODCALLTYPE put_SourceServer( 
            /* [full][in] */ PWSTR pszSourceServer) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_SourceUsername( 
            /* [retval][out] */ PWSTR *ppszSourceUsername) = 0;
        
        virtual /* [propput] */ HRESULT STDMETHODCALLTYPE put_SourceUsername( 
            /* [full][in] */ PWSTR pszSourceUsername) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_SourcePassword( 
            /* [retval][out] */ PWSTR *ppszSourcePassword) = 0;
        
        virtual /* [propput] */ HRESULT STDMETHODCALLTYPE put_SourcePassword( 
            /* [full][in] */ PWSTR pszSourcePassword) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_SourceBase( 
            /* [retval][out] */ PWSTR *ppszSourceBase) = 0;
        
        virtual /* [propput] */ HRESULT STDMETHODCALLTYPE put_SourceBase( 
            /* [full][in] */ PWSTR pszSourceBase) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_SourceScope( 
            /* [retval][out] */ DWORD *pdwSourceScope) = 0;
        
        virtual /* [propput] */ HRESULT STDMETHODCALLTYPE put_SourceScope( 
            /* [in] */ DWORD dwSourceScope) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_SourceFilter( 
            /* [retval][out] */ PWSTR *ppszSourceFilter) = 0;
        
        virtual /* [propput] */ HRESULT STDMETHODCALLTYPE put_SourceFilter( 
            /* [full][in] */ PWSTR pszSourceFilter) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_TargetDirType( 
            /* [retval][out] */ PWSTR *ppszTargetDirType) = 0;
        
        virtual /* [propput] */ HRESULT STDMETHODCALLTYPE put_TargetDirType( 
            /* [full][in] */ PWSTR pszTargetDirType) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_TargetServer( 
            /* [retval][out] */ PWSTR *ppszTargetServer) = 0;
        
        virtual /* [propput] */ HRESULT STDMETHODCALLTYPE put_TargetServer( 
            /* [full][in] */ PWSTR pszTargetServer) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_TargetUsername( 
            /* [retval][out] */ PWSTR *ppszTargetUsername) = 0;
        
        virtual /* [propput] */ HRESULT STDMETHODCALLTYPE put_TargetUsername( 
            /* [full][in] */ PWSTR pszTargetUsername) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_TargetPassword( 
            /* [retval][out] */ PWSTR *ppszTargetPassword) = 0;
        
        virtual /* [propput] */ HRESULT STDMETHODCALLTYPE put_TargetPassword( 
            /* [full][in] */ PWSTR pszTargetPassword) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_TargetBase( 
            /* [retval][out] */ PWSTR *ppszTargetBase) = 0;
        
        virtual /* [propput] */ HRESULT STDMETHODCALLTYPE put_TargetBase( 
            /* [full][in] */ PWSTR pszTargetBase) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_TargetScope( 
            /* [retval][out] */ DWORD *pdwTargetScope) = 0;
        
        virtual /* [propput] */ HRESULT STDMETHODCALLTYPE put_TargetScope( 
            /* [in] */ DWORD dwTargetScope) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_TargetFilter( 
            /* [retval][out] */ PWSTR *ppszTargetFilter) = 0;
        
        virtual /* [propput] */ HRESULT STDMETHODCALLTYPE put_TargetFilter( 
            /* [full][in] */ PWSTR pszTargetFilter) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_Server( 
            /* [retval][out] */ PWSTR *ppszServer) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetData( 
            /* [in] */ PSESSIONDATA pData) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetData( 
            /* [out] */ PSESSIONDATA *ppData) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetSchedule( 
            /* [in] */ SYNCDIRECTION syncDirection,
            /* [in] */ BYTE schedule[ 84 ]) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetSchedule( 
            /* [in] */ SYNCDIRECTION syncDirection,
            /* [out] */ BYTE schedule[ 84 ]) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetMap( 
            /* [in] */ SYNCDIRECTION syncDirection,
            /* [size_is][in] */ PBYTE pByte,
            /* [in] */ DWORD dwSize) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetMap( 
            /* [in] */ SYNCDIRECTION syncDirection,
            /* [size_is][size_is][out] */ PBYTE *ppByte,
            /* [out] */ DWORD *pdwSize) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetPasswordOptions( 
            /* [in] */ SYNCDIRECTION syncDirection,
            /* [in] */ PASSWORDTYPE passwordType,
            /* [in] */ PWSTR pszPassword) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetPasswordOptions( 
            /* [in] */ SYNCDIRECTION syncDirection,
            /* [out] */ PASSWORDTYPE *pPasswordType,
            /* [out] */ PWSTR *ppszPassword) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Persist( 
            /* [in] */ BOOL fForce,
            /* [size_is][size_is][full][out][in] */ PGLOBAL_SESSIONID *prgSessionID,
            /* [full][out][in] */ DWORD *pdwSize) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetAuxData( 
            /* [size_is][in] */ PADS_ATTR_INFO pAttributeEntries,
            /* [in] */ DWORD dwNumAttributes,
            /* [out] */ DWORD *pdwNumAttributesModified) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetAuxData( 
            /* [size_is][in] */ PWSTR *pAttributeName,
            /* [in] */ DWORD dwNumAttributes,
            /* [size_is][size_is][out] */ PADS_ATTR_INFO *ppAttributeEntries,
            /* [out] */ DWORD *pdwAttributesReturned) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetFailedObjectList( 
            /* [retval][out] */ IDirsyncFailedObjectList **pFailedObjectList) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetNamespaceMapping( 
            /* [retval][out] */ IDirsyncNamespaceMapping **pNamespaceMapping) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetRuntimeNamespaceMapping( 
            /* [retval][out] */ IDirsyncNamespaceMapping **pNamespaceMapping) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE IsClassMappingValid( 
            /* [in] */ PWSTR pszClassSource,
            /* [in] */ PWSTR pszClassTarget) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_ObjMapFilePath( 
            /* [retval][out] */ PWSTR *ppszObjMapFilePath) = 0;
        
        virtual /* [propput] */ HRESULT STDMETHODCALLTYPE put_ObjMapFilePath( 
            /* [full][in] */ PWSTR pszObjMapFilePath) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetSyncStatus( 
            /* [out] */ DWORD *pdwPercent,
            /* [out] */ DWORD *pdwWarning,
            /* [out] */ DWORD *pdwError) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE UpdateTerminationStatus( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDirsyncSessionVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IDirsyncSession * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IDirsyncSession * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IDirsyncSession * This);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_Name )( 
            IDirsyncSession * This,
            /* [retval][out] */ PWSTR *ppszName);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_Name )( 
            IDirsyncSession * This,
            /* [full][in] */ PWSTR pszName);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_Comments )( 
            IDirsyncSession * This,
            /* [retval][out] */ PWSTR *ppszComments);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_Comments )( 
            IDirsyncSession * This,
            /* [full][in] */ PWSTR pszComments);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_Flags )( 
            IDirsyncSession * This,
            /* [retval][out] */ DWORD *pdwFlags);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_Flags )( 
            IDirsyncSession * This,
            /* [in] */ DWORD dwFlags);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_Status )( 
            IDirsyncSession * This,
            /* [retval][out] */ DWORD *pdwStatus);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_LogLevel )( 
            IDirsyncSession * This,
            /* [retval][out] */ DWORD *pdwLogLevel);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_LogLevel )( 
            IDirsyncSession * This,
            /* [in] */ DWORD dwLogLevel);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_ID )( 
            IDirsyncSession * This,
            /* [retval][out] */ DWORD *pdwID);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_CreatedBy )( 
            IDirsyncSession * This,
            /* [retval][out] */ PWSTR *ppszCreatedBy);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_CreationTime )( 
            IDirsyncSession * This,
            /* [retval][out] */ LARGE_INTEGER *pCreationTime);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_LastChangedBy )( 
            IDirsyncSession * This,
            /* [retval][out] */ PWSTR *ppszLastChangedBy);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_LastChangeTime )( 
            IDirsyncSession * This,
            /* [retval][out] */ LARGE_INTEGER *pLastChangeTime);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_SourceDirType )( 
            IDirsyncSession * This,
            /* [retval][out] */ PWSTR *ppszSourceDirType);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_SourceDirType )( 
            IDirsyncSession * This,
            /* [full][in] */ PWSTR pszSourceDirType);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_SourceServer )( 
            IDirsyncSession * This,
            /* [retval][out] */ PWSTR *ppszSourceServer);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_SourceServer )( 
            IDirsyncSession * This,
            /* [full][in] */ PWSTR pszSourceServer);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_SourceUsername )( 
            IDirsyncSession * This,
            /* [retval][out] */ PWSTR *ppszSourceUsername);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_SourceUsername )( 
            IDirsyncSession * This,
            /* [full][in] */ PWSTR pszSourceUsername);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_SourcePassword )( 
            IDirsyncSession * This,
            /* [retval][out] */ PWSTR *ppszSourcePassword);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_SourcePassword )( 
            IDirsyncSession * This,
            /* [full][in] */ PWSTR pszSourcePassword);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_SourceBase )( 
            IDirsyncSession * This,
            /* [retval][out] */ PWSTR *ppszSourceBase);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_SourceBase )( 
            IDirsyncSession * This,
            /* [full][in] */ PWSTR pszSourceBase);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_SourceScope )( 
            IDirsyncSession * This,
            /* [retval][out] */ DWORD *pdwSourceScope);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_SourceScope )( 
            IDirsyncSession * This,
            /* [in] */ DWORD dwSourceScope);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_SourceFilter )( 
            IDirsyncSession * This,
            /* [retval][out] */ PWSTR *ppszSourceFilter);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_SourceFilter )( 
            IDirsyncSession * This,
            /* [full][in] */ PWSTR pszSourceFilter);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_TargetDirType )( 
            IDirsyncSession * This,
            /* [retval][out] */ PWSTR *ppszTargetDirType);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_TargetDirType )( 
            IDirsyncSession * This,
            /* [full][in] */ PWSTR pszTargetDirType);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_TargetServer )( 
            IDirsyncSession * This,
            /* [retval][out] */ PWSTR *ppszTargetServer);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_TargetServer )( 
            IDirsyncSession * This,
            /* [full][in] */ PWSTR pszTargetServer);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_TargetUsername )( 
            IDirsyncSession * This,
            /* [retval][out] */ PWSTR *ppszTargetUsername);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_TargetUsername )( 
            IDirsyncSession * This,
            /* [full][in] */ PWSTR pszTargetUsername);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_TargetPassword )( 
            IDirsyncSession * This,
            /* [retval][out] */ PWSTR *ppszTargetPassword);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_TargetPassword )( 
            IDirsyncSession * This,
            /* [full][in] */ PWSTR pszTargetPassword);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_TargetBase )( 
            IDirsyncSession * This,
            /* [retval][out] */ PWSTR *ppszTargetBase);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_TargetBase )( 
            IDirsyncSession * This,
            /* [full][in] */ PWSTR pszTargetBase);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_TargetScope )( 
            IDirsyncSession * This,
            /* [retval][out] */ DWORD *pdwTargetScope);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_TargetScope )( 
            IDirsyncSession * This,
            /* [in] */ DWORD dwTargetScope);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_TargetFilter )( 
            IDirsyncSession * This,
            /* [retval][out] */ PWSTR *ppszTargetFilter);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_TargetFilter )( 
            IDirsyncSession * This,
            /* [full][in] */ PWSTR pszTargetFilter);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_Server )( 
            IDirsyncSession * This,
            /* [retval][out] */ PWSTR *ppszServer);
        
        HRESULT ( STDMETHODCALLTYPE *SetData )( 
            IDirsyncSession * This,
            /* [in] */ PSESSIONDATA pData);
        
        HRESULT ( STDMETHODCALLTYPE *GetData )( 
            IDirsyncSession * This,
            /* [out] */ PSESSIONDATA *ppData);
        
        HRESULT ( STDMETHODCALLTYPE *SetSchedule )( 
            IDirsyncSession * This,
            /* [in] */ SYNCDIRECTION syncDirection,
            /* [in] */ BYTE schedule[ 84 ]);
        
        HRESULT ( STDMETHODCALLTYPE *GetSchedule )( 
            IDirsyncSession * This,
            /* [in] */ SYNCDIRECTION syncDirection,
            /* [out] */ BYTE schedule[ 84 ]);
        
        HRESULT ( STDMETHODCALLTYPE *SetMap )( 
            IDirsyncSession * This,
            /* [in] */ SYNCDIRECTION syncDirection,
            /* [size_is][in] */ PBYTE pByte,
            /* [in] */ DWORD dwSize);
        
        HRESULT ( STDMETHODCALLTYPE *GetMap )( 
            IDirsyncSession * This,
            /* [in] */ SYNCDIRECTION syncDirection,
            /* [size_is][size_is][out] */ PBYTE *ppByte,
            /* [out] */ DWORD *pdwSize);
        
        HRESULT ( STDMETHODCALLTYPE *SetPasswordOptions )( 
            IDirsyncSession * This,
            /* [in] */ SYNCDIRECTION syncDirection,
            /* [in] */ PASSWORDTYPE passwordType,
            /* [in] */ PWSTR pszPassword);
        
        HRESULT ( STDMETHODCALLTYPE *GetPasswordOptions )( 
            IDirsyncSession * This,
            /* [in] */ SYNCDIRECTION syncDirection,
            /* [out] */ PASSWORDTYPE *pPasswordType,
            /* [out] */ PWSTR *ppszPassword);
        
        HRESULT ( STDMETHODCALLTYPE *Persist )( 
            IDirsyncSession * This,
            /* [in] */ BOOL fForce,
            /* [size_is][size_is][full][out][in] */ PGLOBAL_SESSIONID *prgSessionID,
            /* [full][out][in] */ DWORD *pdwSize);
        
        HRESULT ( STDMETHODCALLTYPE *SetAuxData )( 
            IDirsyncSession * This,
            /* [size_is][in] */ PADS_ATTR_INFO pAttributeEntries,
            /* [in] */ DWORD dwNumAttributes,
            /* [out] */ DWORD *pdwNumAttributesModified);
        
        HRESULT ( STDMETHODCALLTYPE *GetAuxData )( 
            IDirsyncSession * This,
            /* [size_is][in] */ PWSTR *pAttributeName,
            /* [in] */ DWORD dwNumAttributes,
            /* [size_is][size_is][out] */ PADS_ATTR_INFO *ppAttributeEntries,
            /* [out] */ DWORD *pdwAttributesReturned);
        
        HRESULT ( STDMETHODCALLTYPE *GetFailedObjectList )( 
            IDirsyncSession * This,
            /* [retval][out] */ IDirsyncFailedObjectList **pFailedObjectList);
        
        HRESULT ( STDMETHODCALLTYPE *GetNamespaceMapping )( 
            IDirsyncSession * This,
            /* [retval][out] */ IDirsyncNamespaceMapping **pNamespaceMapping);
        
        HRESULT ( STDMETHODCALLTYPE *GetRuntimeNamespaceMapping )( 
            IDirsyncSession * This,
            /* [retval][out] */ IDirsyncNamespaceMapping **pNamespaceMapping);
        
        HRESULT ( STDMETHODCALLTYPE *IsClassMappingValid )( 
            IDirsyncSession * This,
            /* [in] */ PWSTR pszClassSource,
            /* [in] */ PWSTR pszClassTarget);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_ObjMapFilePath )( 
            IDirsyncSession * This,
            /* [retval][out] */ PWSTR *ppszObjMapFilePath);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_ObjMapFilePath )( 
            IDirsyncSession * This,
            /* [full][in] */ PWSTR pszObjMapFilePath);
        
        HRESULT ( STDMETHODCALLTYPE *GetSyncStatus )( 
            IDirsyncSession * This,
            /* [out] */ DWORD *pdwPercent,
            /* [out] */ DWORD *pdwWarning,
            /* [out] */ DWORD *pdwError);
        
        HRESULT ( STDMETHODCALLTYPE *UpdateTerminationStatus )( 
            IDirsyncSession * This);
        
        END_INTERFACE
    } IDirsyncSessionVtbl;

    interface IDirsyncSession
    {
        CONST_VTBL struct IDirsyncSessionVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDirsyncSession_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IDirsyncSession_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IDirsyncSession_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IDirsyncSession_get_Name(This,ppszName)	\
    (This)->lpVtbl -> get_Name(This,ppszName)

#define IDirsyncSession_put_Name(This,pszName)	\
    (This)->lpVtbl -> put_Name(This,pszName)

#define IDirsyncSession_get_Comments(This,ppszComments)	\
    (This)->lpVtbl -> get_Comments(This,ppszComments)

#define IDirsyncSession_put_Comments(This,pszComments)	\
    (This)->lpVtbl -> put_Comments(This,pszComments)

#define IDirsyncSession_get_Flags(This,pdwFlags)	\
    (This)->lpVtbl -> get_Flags(This,pdwFlags)

#define IDirsyncSession_put_Flags(This,dwFlags)	\
    (This)->lpVtbl -> put_Flags(This,dwFlags)

#define IDirsyncSession_get_Status(This,pdwStatus)	\
    (This)->lpVtbl -> get_Status(This,pdwStatus)

#define IDirsyncSession_get_LogLevel(This,pdwLogLevel)	\
    (This)->lpVtbl -> get_LogLevel(This,pdwLogLevel)

#define IDirsyncSession_put_LogLevel(This,dwLogLevel)	\
    (This)->lpVtbl -> put_LogLevel(This,dwLogLevel)

#define IDirsyncSession_get_ID(This,pdwID)	\
    (This)->lpVtbl -> get_ID(This,pdwID)

#define IDirsyncSession_get_CreatedBy(This,ppszCreatedBy)	\
    (This)->lpVtbl -> get_CreatedBy(This,ppszCreatedBy)

#define IDirsyncSession_get_CreationTime(This,pCreationTime)	\
    (This)->lpVtbl -> get_CreationTime(This,pCreationTime)

#define IDirsyncSession_get_LastChangedBy(This,ppszLastChangedBy)	\
    (This)->lpVtbl -> get_LastChangedBy(This,ppszLastChangedBy)

#define IDirsyncSession_get_LastChangeTime(This,pLastChangeTime)	\
    (This)->lpVtbl -> get_LastChangeTime(This,pLastChangeTime)

#define IDirsyncSession_get_SourceDirType(This,ppszSourceDirType)	\
    (This)->lpVtbl -> get_SourceDirType(This,ppszSourceDirType)

#define IDirsyncSession_put_SourceDirType(This,pszSourceDirType)	\
    (This)->lpVtbl -> put_SourceDirType(This,pszSourceDirType)

#define IDirsyncSession_get_SourceServer(This,ppszSourceServer)	\
    (This)->lpVtbl -> get_SourceServer(This,ppszSourceServer)

#define IDirsyncSession_put_SourceServer(This,pszSourceServer)	\
    (This)->lpVtbl -> put_SourceServer(This,pszSourceServer)

#define IDirsyncSession_get_SourceUsername(This,ppszSourceUsername)	\
    (This)->lpVtbl -> get_SourceUsername(This,ppszSourceUsername)

#define IDirsyncSession_put_SourceUsername(This,pszSourceUsername)	\
    (This)->lpVtbl -> put_SourceUsername(This,pszSourceUsername)

#define IDirsyncSession_get_SourcePassword(This,ppszSourcePassword)	\
    (This)->lpVtbl -> get_SourcePassword(This,ppszSourcePassword)

#define IDirsyncSession_put_SourcePassword(This,pszSourcePassword)	\
    (This)->lpVtbl -> put_SourcePassword(This,pszSourcePassword)

#define IDirsyncSession_get_SourceBase(This,ppszSourceBase)	\
    (This)->lpVtbl -> get_SourceBase(This,ppszSourceBase)

#define IDirsyncSession_put_SourceBase(This,pszSourceBase)	\
    (This)->lpVtbl -> put_SourceBase(This,pszSourceBase)

#define IDirsyncSession_get_SourceScope(This,pdwSourceScope)	\
    (This)->lpVtbl -> get_SourceScope(This,pdwSourceScope)

#define IDirsyncSession_put_SourceScope(This,dwSourceScope)	\
    (This)->lpVtbl -> put_SourceScope(This,dwSourceScope)

#define IDirsyncSession_get_SourceFilter(This,ppszSourceFilter)	\
    (This)->lpVtbl -> get_SourceFilter(This,ppszSourceFilter)

#define IDirsyncSession_put_SourceFilter(This,pszSourceFilter)	\
    (This)->lpVtbl -> put_SourceFilter(This,pszSourceFilter)

#define IDirsyncSession_get_TargetDirType(This,ppszTargetDirType)	\
    (This)->lpVtbl -> get_TargetDirType(This,ppszTargetDirType)

#define IDirsyncSession_put_TargetDirType(This,pszTargetDirType)	\
    (This)->lpVtbl -> put_TargetDirType(This,pszTargetDirType)

#define IDirsyncSession_get_TargetServer(This,ppszTargetServer)	\
    (This)->lpVtbl -> get_TargetServer(This,ppszTargetServer)

#define IDirsyncSession_put_TargetServer(This,pszTargetServer)	\
    (This)->lpVtbl -> put_TargetServer(This,pszTargetServer)

#define IDirsyncSession_get_TargetUsername(This,ppszTargetUsername)	\
    (This)->lpVtbl -> get_TargetUsername(This,ppszTargetUsername)

#define IDirsyncSession_put_TargetUsername(This,pszTargetUsername)	\
    (This)->lpVtbl -> put_TargetUsername(This,pszTargetUsername)

#define IDirsyncSession_get_TargetPassword(This,ppszTargetPassword)	\
    (This)->lpVtbl -> get_TargetPassword(This,ppszTargetPassword)

#define IDirsyncSession_put_TargetPassword(This,pszTargetPassword)	\
    (This)->lpVtbl -> put_TargetPassword(This,pszTargetPassword)

#define IDirsyncSession_get_TargetBase(This,ppszTargetBase)	\
    (This)->lpVtbl -> get_TargetBase(This,ppszTargetBase)

#define IDirsyncSession_put_TargetBase(This,pszTargetBase)	\
    (This)->lpVtbl -> put_TargetBase(This,pszTargetBase)

#define IDirsyncSession_get_TargetScope(This,pdwTargetScope)	\
    (This)->lpVtbl -> get_TargetScope(This,pdwTargetScope)

#define IDirsyncSession_put_TargetScope(This,dwTargetScope)	\
    (This)->lpVtbl -> put_TargetScope(This,dwTargetScope)

#define IDirsyncSession_get_TargetFilter(This,ppszTargetFilter)	\
    (This)->lpVtbl -> get_TargetFilter(This,ppszTargetFilter)

#define IDirsyncSession_put_TargetFilter(This,pszTargetFilter)	\
    (This)->lpVtbl -> put_TargetFilter(This,pszTargetFilter)

#define IDirsyncSession_get_Server(This,ppszServer)	\
    (This)->lpVtbl -> get_Server(This,ppszServer)

#define IDirsyncSession_SetData(This,pData)	\
    (This)->lpVtbl -> SetData(This,pData)

#define IDirsyncSession_GetData(This,ppData)	\
    (This)->lpVtbl -> GetData(This,ppData)

#define IDirsyncSession_SetSchedule(This,syncDirection,schedule)	\
    (This)->lpVtbl -> SetSchedule(This,syncDirection,schedule)

#define IDirsyncSession_GetSchedule(This,syncDirection,schedule)	\
    (This)->lpVtbl -> GetSchedule(This,syncDirection,schedule)

#define IDirsyncSession_SetMap(This,syncDirection,pByte,dwSize)	\
    (This)->lpVtbl -> SetMap(This,syncDirection,pByte,dwSize)

#define IDirsyncSession_GetMap(This,syncDirection,ppByte,pdwSize)	\
    (This)->lpVtbl -> GetMap(This,syncDirection,ppByte,pdwSize)

#define IDirsyncSession_SetPasswordOptions(This,syncDirection,passwordType,pszPassword)	\
    (This)->lpVtbl -> SetPasswordOptions(This,syncDirection,passwordType,pszPassword)

#define IDirsyncSession_GetPasswordOptions(This,syncDirection,pPasswordType,ppszPassword)	\
    (This)->lpVtbl -> GetPasswordOptions(This,syncDirection,pPasswordType,ppszPassword)

#define IDirsyncSession_Persist(This,fForce,prgSessionID,pdwSize)	\
    (This)->lpVtbl -> Persist(This,fForce,prgSessionID,pdwSize)

#define IDirsyncSession_SetAuxData(This,pAttributeEntries,dwNumAttributes,pdwNumAttributesModified)	\
    (This)->lpVtbl -> SetAuxData(This,pAttributeEntries,dwNumAttributes,pdwNumAttributesModified)

#define IDirsyncSession_GetAuxData(This,pAttributeName,dwNumAttributes,ppAttributeEntries,pdwAttributesReturned)	\
    (This)->lpVtbl -> GetAuxData(This,pAttributeName,dwNumAttributes,ppAttributeEntries,pdwAttributesReturned)

#define IDirsyncSession_GetFailedObjectList(This,pFailedObjectList)	\
    (This)->lpVtbl -> GetFailedObjectList(This,pFailedObjectList)

#define IDirsyncSession_GetNamespaceMapping(This,pNamespaceMapping)	\
    (This)->lpVtbl -> GetNamespaceMapping(This,pNamespaceMapping)

#define IDirsyncSession_GetRuntimeNamespaceMapping(This,pNamespaceMapping)	\
    (This)->lpVtbl -> GetRuntimeNamespaceMapping(This,pNamespaceMapping)

#define IDirsyncSession_IsClassMappingValid(This,pszClassSource,pszClassTarget)	\
    (This)->lpVtbl -> IsClassMappingValid(This,pszClassSource,pszClassTarget)

#define IDirsyncSession_get_ObjMapFilePath(This,ppszObjMapFilePath)	\
    (This)->lpVtbl -> get_ObjMapFilePath(This,ppszObjMapFilePath)

#define IDirsyncSession_put_ObjMapFilePath(This,pszObjMapFilePath)	\
    (This)->lpVtbl -> put_ObjMapFilePath(This,pszObjMapFilePath)

#define IDirsyncSession_GetSyncStatus(This,pdwPercent,pdwWarning,pdwError)	\
    (This)->lpVtbl -> GetSyncStatus(This,pdwPercent,pdwWarning,pdwError)

#define IDirsyncSession_UpdateTerminationStatus(This)	\
    (This)->lpVtbl -> UpdateTerminationStatus(This)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [propget] */ HRESULT STDMETHODCALLTYPE IDirsyncSession_get_Name_Proxy( 
    IDirsyncSession * This,
    /* [retval][out] */ PWSTR *ppszName);


void __RPC_STUB IDirsyncSession_get_Name_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propput] */ HRESULT STDMETHODCALLTYPE IDirsyncSession_put_Name_Proxy( 
    IDirsyncSession * This,
    /* [full][in] */ PWSTR pszName);


void __RPC_STUB IDirsyncSession_put_Name_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propget] */ HRESULT STDMETHODCALLTYPE IDirsyncSession_get_Comments_Proxy( 
    IDirsyncSession * This,
    /* [retval][out] */ PWSTR *ppszComments);


void __RPC_STUB IDirsyncSession_get_Comments_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propput] */ HRESULT STDMETHODCALLTYPE IDirsyncSession_put_Comments_Proxy( 
    IDirsyncSession * This,
    /* [full][in] */ PWSTR pszComments);


void __RPC_STUB IDirsyncSession_put_Comments_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propget] */ HRESULT STDMETHODCALLTYPE IDirsyncSession_get_Flags_Proxy( 
    IDirsyncSession * This,
    /* [retval][out] */ DWORD *pdwFlags);


void __RPC_STUB IDirsyncSession_get_Flags_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propput] */ HRESULT STDMETHODCALLTYPE IDirsyncSession_put_Flags_Proxy( 
    IDirsyncSession * This,
    /* [in] */ DWORD dwFlags);


void __RPC_STUB IDirsyncSession_put_Flags_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propget] */ HRESULT STDMETHODCALLTYPE IDirsyncSession_get_Status_Proxy( 
    IDirsyncSession * This,
    /* [retval][out] */ DWORD *pdwStatus);


void __RPC_STUB IDirsyncSession_get_Status_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propget] */ HRESULT STDMETHODCALLTYPE IDirsyncSession_get_LogLevel_Proxy( 
    IDirsyncSession * This,
    /* [retval][out] */ DWORD *pdwLogLevel);


void __RPC_STUB IDirsyncSession_get_LogLevel_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propput] */ HRESULT STDMETHODCALLTYPE IDirsyncSession_put_LogLevel_Proxy( 
    IDirsyncSession * This,
    /* [in] */ DWORD dwLogLevel);


void __RPC_STUB IDirsyncSession_put_LogLevel_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propget] */ HRESULT STDMETHODCALLTYPE IDirsyncSession_get_ID_Proxy( 
    IDirsyncSession * This,
    /* [retval][out] */ DWORD *pdwID);


void __RPC_STUB IDirsyncSession_get_ID_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propget] */ HRESULT STDMETHODCALLTYPE IDirsyncSession_get_CreatedBy_Proxy( 
    IDirsyncSession * This,
    /* [retval][out] */ PWSTR *ppszCreatedBy);


void __RPC_STUB IDirsyncSession_get_CreatedBy_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propget] */ HRESULT STDMETHODCALLTYPE IDirsyncSession_get_CreationTime_Proxy( 
    IDirsyncSession * This,
    /* [retval][out] */ LARGE_INTEGER *pCreationTime);


void __RPC_STUB IDirsyncSession_get_CreationTime_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propget] */ HRESULT STDMETHODCALLTYPE IDirsyncSession_get_LastChangedBy_Proxy( 
    IDirsyncSession * This,
    /* [retval][out] */ PWSTR *ppszLastChangedBy);


void __RPC_STUB IDirsyncSession_get_LastChangedBy_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propget] */ HRESULT STDMETHODCALLTYPE IDirsyncSession_get_LastChangeTime_Proxy( 
    IDirsyncSession * This,
    /* [retval][out] */ LARGE_INTEGER *pLastChangeTime);


void __RPC_STUB IDirsyncSession_get_LastChangeTime_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propget] */ HRESULT STDMETHODCALLTYPE IDirsyncSession_get_SourceDirType_Proxy( 
    IDirsyncSession * This,
    /* [retval][out] */ PWSTR *ppszSourceDirType);


void __RPC_STUB IDirsyncSession_get_SourceDirType_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propput] */ HRESULT STDMETHODCALLTYPE IDirsyncSession_put_SourceDirType_Proxy( 
    IDirsyncSession * This,
    /* [full][in] */ PWSTR pszSourceDirType);


void __RPC_STUB IDirsyncSession_put_SourceDirType_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propget] */ HRESULT STDMETHODCALLTYPE IDirsyncSession_get_SourceServer_Proxy( 
    IDirsyncSession * This,
    /* [retval][out] */ PWSTR *ppszSourceServer);


void __RPC_STUB IDirsyncSession_get_SourceServer_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propput] */ HRESULT STDMETHODCALLTYPE IDirsyncSession_put_SourceServer_Proxy( 
    IDirsyncSession * This,
    /* [full][in] */ PWSTR pszSourceServer);


void __RPC_STUB IDirsyncSession_put_SourceServer_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propget] */ HRESULT STDMETHODCALLTYPE IDirsyncSession_get_SourceUsername_Proxy( 
    IDirsyncSession * This,
    /* [retval][out] */ PWSTR *ppszSourceUsername);


void __RPC_STUB IDirsyncSession_get_SourceUsername_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propput] */ HRESULT STDMETHODCALLTYPE IDirsyncSession_put_SourceUsername_Proxy( 
    IDirsyncSession * This,
    /* [full][in] */ PWSTR pszSourceUsername);


void __RPC_STUB IDirsyncSession_put_SourceUsername_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propget] */ HRESULT STDMETHODCALLTYPE IDirsyncSession_get_SourcePassword_Proxy( 
    IDirsyncSession * This,
    /* [retval][out] */ PWSTR *ppszSourcePassword);


void __RPC_STUB IDirsyncSession_get_SourcePassword_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propput] */ HRESULT STDMETHODCALLTYPE IDirsyncSession_put_SourcePassword_Proxy( 
    IDirsyncSession * This,
    /* [full][in] */ PWSTR pszSourcePassword);


void __RPC_STUB IDirsyncSession_put_SourcePassword_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propget] */ HRESULT STDMETHODCALLTYPE IDirsyncSession_get_SourceBase_Proxy( 
    IDirsyncSession * This,
    /* [retval][out] */ PWSTR *ppszSourceBase);


void __RPC_STUB IDirsyncSession_get_SourceBase_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propput] */ HRESULT STDMETHODCALLTYPE IDirsyncSession_put_SourceBase_Proxy( 
    IDirsyncSession * This,
    /* [full][in] */ PWSTR pszSourceBase);


void __RPC_STUB IDirsyncSession_put_SourceBase_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propget] */ HRESULT STDMETHODCALLTYPE IDirsyncSession_get_SourceScope_Proxy( 
    IDirsyncSession * This,
    /* [retval][out] */ DWORD *pdwSourceScope);


void __RPC_STUB IDirsyncSession_get_SourceScope_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propput] */ HRESULT STDMETHODCALLTYPE IDirsyncSession_put_SourceScope_Proxy( 
    IDirsyncSession * This,
    /* [in] */ DWORD dwSourceScope);


void __RPC_STUB IDirsyncSession_put_SourceScope_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propget] */ HRESULT STDMETHODCALLTYPE IDirsyncSession_get_SourceFilter_Proxy( 
    IDirsyncSession * This,
    /* [retval][out] */ PWSTR *ppszSourceFilter);


void __RPC_STUB IDirsyncSession_get_SourceFilter_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propput] */ HRESULT STDMETHODCALLTYPE IDirsyncSession_put_SourceFilter_Proxy( 
    IDirsyncSession * This,
    /* [full][in] */ PWSTR pszSourceFilter);


void __RPC_STUB IDirsyncSession_put_SourceFilter_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propget] */ HRESULT STDMETHODCALLTYPE IDirsyncSession_get_TargetDirType_Proxy( 
    IDirsyncSession * This,
    /* [retval][out] */ PWSTR *ppszTargetDirType);


void __RPC_STUB IDirsyncSession_get_TargetDirType_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propput] */ HRESULT STDMETHODCALLTYPE IDirsyncSession_put_TargetDirType_Proxy( 
    IDirsyncSession * This,
    /* [full][in] */ PWSTR pszTargetDirType);


void __RPC_STUB IDirsyncSession_put_TargetDirType_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propget] */ HRESULT STDMETHODCALLTYPE IDirsyncSession_get_TargetServer_Proxy( 
    IDirsyncSession * This,
    /* [retval][out] */ PWSTR *ppszTargetServer);


void __RPC_STUB IDirsyncSession_get_TargetServer_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propput] */ HRESULT STDMETHODCALLTYPE IDirsyncSession_put_TargetServer_Proxy( 
    IDirsyncSession * This,
    /* [full][in] */ PWSTR pszTargetServer);


void __RPC_STUB IDirsyncSession_put_TargetServer_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propget] */ HRESULT STDMETHODCALLTYPE IDirsyncSession_get_TargetUsername_Proxy( 
    IDirsyncSession * This,
    /* [retval][out] */ PWSTR *ppszTargetUsername);


void __RPC_STUB IDirsyncSession_get_TargetUsername_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propput] */ HRESULT STDMETHODCALLTYPE IDirsyncSession_put_TargetUsername_Proxy( 
    IDirsyncSession * This,
    /* [full][in] */ PWSTR pszTargetUsername);


void __RPC_STUB IDirsyncSession_put_TargetUsername_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propget] */ HRESULT STDMETHODCALLTYPE IDirsyncSession_get_TargetPassword_Proxy( 
    IDirsyncSession * This,
    /* [retval][out] */ PWSTR *ppszTargetPassword);


void __RPC_STUB IDirsyncSession_get_TargetPassword_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propput] */ HRESULT STDMETHODCALLTYPE IDirsyncSession_put_TargetPassword_Proxy( 
    IDirsyncSession * This,
    /* [full][in] */ PWSTR pszTargetPassword);


void __RPC_STUB IDirsyncSession_put_TargetPassword_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propget] */ HRESULT STDMETHODCALLTYPE IDirsyncSession_get_TargetBase_Proxy( 
    IDirsyncSession * This,
    /* [retval][out] */ PWSTR *ppszTargetBase);


void __RPC_STUB IDirsyncSession_get_TargetBase_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propput] */ HRESULT STDMETHODCALLTYPE IDirsyncSession_put_TargetBase_Proxy( 
    IDirsyncSession * This,
    /* [full][in] */ PWSTR pszTargetBase);


void __RPC_STUB IDirsyncSession_put_TargetBase_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propget] */ HRESULT STDMETHODCALLTYPE IDirsyncSession_get_TargetScope_Proxy( 
    IDirsyncSession * This,
    /* [retval][out] */ DWORD *pdwTargetScope);


void __RPC_STUB IDirsyncSession_get_TargetScope_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propput] */ HRESULT STDMETHODCALLTYPE IDirsyncSession_put_TargetScope_Proxy( 
    IDirsyncSession * This,
    /* [in] */ DWORD dwTargetScope);


void __RPC_STUB IDirsyncSession_put_TargetScope_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propget] */ HRESULT STDMETHODCALLTYPE IDirsyncSession_get_TargetFilter_Proxy( 
    IDirsyncSession * This,
    /* [retval][out] */ PWSTR *ppszTargetFilter);


void __RPC_STUB IDirsyncSession_get_TargetFilter_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propput] */ HRESULT STDMETHODCALLTYPE IDirsyncSession_put_TargetFilter_Proxy( 
    IDirsyncSession * This,
    /* [full][in] */ PWSTR pszTargetFilter);


void __RPC_STUB IDirsyncSession_put_TargetFilter_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propget] */ HRESULT STDMETHODCALLTYPE IDirsyncSession_get_Server_Proxy( 
    IDirsyncSession * This,
    /* [retval][out] */ PWSTR *ppszServer);


void __RPC_STUB IDirsyncSession_get_Server_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDirsyncSession_SetData_Proxy( 
    IDirsyncSession * This,
    /* [in] */ PSESSIONDATA pData);


void __RPC_STUB IDirsyncSession_SetData_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDirsyncSession_GetData_Proxy( 
    IDirsyncSession * This,
    /* [out] */ PSESSIONDATA *ppData);


void __RPC_STUB IDirsyncSession_GetData_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDirsyncSession_SetSchedule_Proxy( 
    IDirsyncSession * This,
    /* [in] */ SYNCDIRECTION syncDirection,
    /* [in] */ BYTE schedule[ 84 ]);


void __RPC_STUB IDirsyncSession_SetSchedule_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDirsyncSession_GetSchedule_Proxy( 
    IDirsyncSession * This,
    /* [in] */ SYNCDIRECTION syncDirection,
    /* [out] */ BYTE schedule[ 84 ]);


void __RPC_STUB IDirsyncSession_GetSchedule_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDirsyncSession_SetMap_Proxy( 
    IDirsyncSession * This,
    /* [in] */ SYNCDIRECTION syncDirection,
    /* [size_is][in] */ PBYTE pByte,
    /* [in] */ DWORD dwSize);


void __RPC_STUB IDirsyncSession_SetMap_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDirsyncSession_GetMap_Proxy( 
    IDirsyncSession * This,
    /* [in] */ SYNCDIRECTION syncDirection,
    /* [size_is][size_is][out] */ PBYTE *ppByte,
    /* [out] */ DWORD *pdwSize);


void __RPC_STUB IDirsyncSession_GetMap_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDirsyncSession_SetPasswordOptions_Proxy( 
    IDirsyncSession * This,
    /* [in] */ SYNCDIRECTION syncDirection,
    /* [in] */ PASSWORDTYPE passwordType,
    /* [in] */ PWSTR pszPassword);


void __RPC_STUB IDirsyncSession_SetPasswordOptions_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDirsyncSession_GetPasswordOptions_Proxy( 
    IDirsyncSession * This,
    /* [in] */ SYNCDIRECTION syncDirection,
    /* [out] */ PASSWORDTYPE *pPasswordType,
    /* [out] */ PWSTR *ppszPassword);


void __RPC_STUB IDirsyncSession_GetPasswordOptions_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDirsyncSession_Persist_Proxy( 
    IDirsyncSession * This,
    /* [in] */ BOOL fForce,
    /* [size_is][size_is][full][out][in] */ PGLOBAL_SESSIONID *prgSessionID,
    /* [full][out][in] */ DWORD *pdwSize);


void __RPC_STUB IDirsyncSession_Persist_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDirsyncSession_SetAuxData_Proxy( 
    IDirsyncSession * This,
    /* [size_is][in] */ PADS_ATTR_INFO pAttributeEntries,
    /* [in] */ DWORD dwNumAttributes,
    /* [out] */ DWORD *pdwNumAttributesModified);


void __RPC_STUB IDirsyncSession_SetAuxData_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDirsyncSession_GetAuxData_Proxy( 
    IDirsyncSession * This,
    /* [size_is][in] */ PWSTR *pAttributeName,
    /* [in] */ DWORD dwNumAttributes,
    /* [size_is][size_is][out] */ PADS_ATTR_INFO *ppAttributeEntries,
    /* [out] */ DWORD *pdwAttributesReturned);


void __RPC_STUB IDirsyncSession_GetAuxData_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDirsyncSession_GetFailedObjectList_Proxy( 
    IDirsyncSession * This,
    /* [retval][out] */ IDirsyncFailedObjectList **pFailedObjectList);


void __RPC_STUB IDirsyncSession_GetFailedObjectList_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDirsyncSession_GetNamespaceMapping_Proxy( 
    IDirsyncSession * This,
    /* [retval][out] */ IDirsyncNamespaceMapping **pNamespaceMapping);


void __RPC_STUB IDirsyncSession_GetNamespaceMapping_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDirsyncSession_GetRuntimeNamespaceMapping_Proxy( 
    IDirsyncSession * This,
    /* [retval][out] */ IDirsyncNamespaceMapping **pNamespaceMapping);


void __RPC_STUB IDirsyncSession_GetRuntimeNamespaceMapping_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDirsyncSession_IsClassMappingValid_Proxy( 
    IDirsyncSession * This,
    /* [in] */ PWSTR pszClassSource,
    /* [in] */ PWSTR pszClassTarget);


void __RPC_STUB IDirsyncSession_IsClassMappingValid_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propget] */ HRESULT STDMETHODCALLTYPE IDirsyncSession_get_ObjMapFilePath_Proxy( 
    IDirsyncSession * This,
    /* [retval][out] */ PWSTR *ppszObjMapFilePath);


void __RPC_STUB IDirsyncSession_get_ObjMapFilePath_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propput] */ HRESULT STDMETHODCALLTYPE IDirsyncSession_put_ObjMapFilePath_Proxy( 
    IDirsyncSession * This,
    /* [full][in] */ PWSTR pszObjMapFilePath);


void __RPC_STUB IDirsyncSession_put_ObjMapFilePath_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDirsyncSession_GetSyncStatus_Proxy( 
    IDirsyncSession * This,
    /* [out] */ DWORD *pdwPercent,
    /* [out] */ DWORD *pdwWarning,
    /* [out] */ DWORD *pdwError);


void __RPC_STUB IDirsyncSession_GetSyncStatus_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDirsyncSession_UpdateTerminationStatus_Proxy( 
    IDirsyncSession * This);


void __RPC_STUB IDirsyncSession_UpdateTerminationStatus_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IDirsyncSession_INTERFACE_DEFINED__ */


#ifndef __IDirsyncSessionCallback_INTERFACE_DEFINED__
#define __IDirsyncSessionCallback_INTERFACE_DEFINED__

/* interface IDirsyncSessionCallback */
/* [unique][helpstring][uuid][local][object] */ 


EXTERN_C const IID IID_IDirsyncSessionCallback;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("f0dd3480-1531-11d2-ba65-0000f87a369e")
    IDirsyncSessionCallback : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE AddFailedObject( 
            /* [in] */ PDIRSYNCOBJECT pObject,
            /* [in] */ HRESULT hrLastSync,
            /* [in] */ SYNCDIRECTION syncDirection,
            /* [in] */ RETRYTYPE retryType) = 0;
        
        virtual void STDMETHODCALLTYPE FreeDirsyncObject( 
            /* [in] */ PDIRSYNCOBJECT pObject,
            /* [in] */ BOOL fFreeOuter) = 0;
        
        virtual void STDMETHODCALLTYPE FreeSessionData( 
            /* [in] */ PSESSIONDATA pSessionData) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetDataStore( 
            /* [retval][out] */ IDirsyncDatabase **ppDirsyncDatabase) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE AddObjectIdMapping( 
            /* [in] */ PBYTE pSourceId,
            /* [in] */ DWORD cbSourceId,
            /* [in] */ PBYTE pTargetId,
            /* [in] */ DWORD cbTargetId,
            /* [in] */ SYNCDIRECTION syncDirection) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE DeleteObjectIdMapping( 
            /* [in] */ PBYTE pTargetId,
            /* [in] */ DWORD cbTargetId,
            /* [in] */ SYNCPROVIDER Provider) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ReportSourceStatus( 
            /* [in] */ PDIRSYNCOBJECT pObject) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetSessionPassword( 
            /* [in] */ PWSTR pszPassword,
            /* [in] */ SYNCDIRECTION syncDirection) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetCheckSum( 
            /* [in] */ PBYTE pId,
            /* [in] */ DWORD cbId,
            /* [in] */ SYNCPROVIDER Provider,
            /* [in] */ DWORD dwCheckSum) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetCheckSum( 
            /* [in] */ PBYTE pId,
            /* [in] */ DWORD cbId,
            /* [in] */ SYNCPROVIDER Provider,
            /* [out] */ DWORD *dwCheckSum) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetDampeningInfo( 
            /* [in] */ PBYTE pObjectId,
            /* [in] */ DWORD cbObjectId,
            /* [in] */ SYNCPROVIDER Provider,
            /* [in] */ PBYTE pByte,
            /* [in] */ DWORD dwSize,
            /* [in] */ LONGLONG highestUSN) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetDampeningInfo( 
            /* [in] */ PBYTE pObjectId,
            /* [in] */ DWORD cbObjectId,
            /* [in] */ SYNCPROVIDER Provider,
            /* [out] */ PBYTE *ppByte,
            /* [out] */ DWORD *pdwSize,
            /* [out] */ LONGLONG *pHighestUSN) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetUnMarkedEntries( 
            PBYTE **prgpbId,
            DWORD *pdwEntries,
            SYNCPROVIDER Provider) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE MarkEntry( 
            PBYTE pId,
            DWORD cbId,
            SYNCPROVIDER Provider) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE DeleteFailedObject( 
            /* [in] */ PWSTR szObjectId) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDirsyncSessionCallbackVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IDirsyncSessionCallback * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IDirsyncSessionCallback * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IDirsyncSessionCallback * This);
        
        HRESULT ( STDMETHODCALLTYPE *AddFailedObject )( 
            IDirsyncSessionCallback * This,
            /* [in] */ PDIRSYNCOBJECT pObject,
            /* [in] */ HRESULT hrLastSync,
            /* [in] */ SYNCDIRECTION syncDirection,
            /* [in] */ RETRYTYPE retryType);
        
        void ( STDMETHODCALLTYPE *FreeDirsyncObject )( 
            IDirsyncSessionCallback * This,
            /* [in] */ PDIRSYNCOBJECT pObject,
            /* [in] */ BOOL fFreeOuter);
        
        void ( STDMETHODCALLTYPE *FreeSessionData )( 
            IDirsyncSessionCallback * This,
            /* [in] */ PSESSIONDATA pSessionData);
        
        HRESULT ( STDMETHODCALLTYPE *GetDataStore )( 
            IDirsyncSessionCallback * This,
            /* [retval][out] */ IDirsyncDatabase **ppDirsyncDatabase);
        
        HRESULT ( STDMETHODCALLTYPE *AddObjectIdMapping )( 
            IDirsyncSessionCallback * This,
            /* [in] */ PBYTE pSourceId,
            /* [in] */ DWORD cbSourceId,
            /* [in] */ PBYTE pTargetId,
            /* [in] */ DWORD cbTargetId,
            /* [in] */ SYNCDIRECTION syncDirection);
        
        HRESULT ( STDMETHODCALLTYPE *DeleteObjectIdMapping )( 
            IDirsyncSessionCallback * This,
            /* [in] */ PBYTE pTargetId,
            /* [in] */ DWORD cbTargetId,
            /* [in] */ SYNCPROVIDER Provider);
        
        HRESULT ( STDMETHODCALLTYPE *ReportSourceStatus )( 
            IDirsyncSessionCallback * This,
            /* [in] */ PDIRSYNCOBJECT pObject);
        
        HRESULT ( STDMETHODCALLTYPE *SetSessionPassword )( 
            IDirsyncSessionCallback * This,
            /* [in] */ PWSTR pszPassword,
            /* [in] */ SYNCDIRECTION syncDirection);
        
        HRESULT ( STDMETHODCALLTYPE *SetCheckSum )( 
            IDirsyncSessionCallback * This,
            /* [in] */ PBYTE pId,
            /* [in] */ DWORD cbId,
            /* [in] */ SYNCPROVIDER Provider,
            /* [in] */ DWORD dwCheckSum);
        
        HRESULT ( STDMETHODCALLTYPE *GetCheckSum )( 
            IDirsyncSessionCallback * This,
            /* [in] */ PBYTE pId,
            /* [in] */ DWORD cbId,
            /* [in] */ SYNCPROVIDER Provider,
            /* [out] */ DWORD *dwCheckSum);
        
        HRESULT ( STDMETHODCALLTYPE *SetDampeningInfo )( 
            IDirsyncSessionCallback * This,
            /* [in] */ PBYTE pObjectId,
            /* [in] */ DWORD cbObjectId,
            /* [in] */ SYNCPROVIDER Provider,
            /* [in] */ PBYTE pByte,
            /* [in] */ DWORD dwSize,
            /* [in] */ LONGLONG highestUSN);
        
        HRESULT ( STDMETHODCALLTYPE *GetDampeningInfo )( 
            IDirsyncSessionCallback * This,
            /* [in] */ PBYTE pObjectId,
            /* [in] */ DWORD cbObjectId,
            /* [in] */ SYNCPROVIDER Provider,
            /* [out] */ PBYTE *ppByte,
            /* [out] */ DWORD *pdwSize,
            /* [out] */ LONGLONG *pHighestUSN);
        
        HRESULT ( STDMETHODCALLTYPE *GetUnMarkedEntries )( 
            IDirsyncSessionCallback * This,
            PBYTE **prgpbId,
            DWORD *pdwEntries,
            SYNCPROVIDER Provider);
        
        HRESULT ( STDMETHODCALLTYPE *MarkEntry )( 
            IDirsyncSessionCallback * This,
            PBYTE pId,
            DWORD cbId,
            SYNCPROVIDER Provider);
        
        HRESULT ( STDMETHODCALLTYPE *DeleteFailedObject )( 
            IDirsyncSessionCallback * This,
            /* [in] */ PWSTR szObjectId);
        
        END_INTERFACE
    } IDirsyncSessionCallbackVtbl;

    interface IDirsyncSessionCallback
    {
        CONST_VTBL struct IDirsyncSessionCallbackVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDirsyncSessionCallback_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IDirsyncSessionCallback_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IDirsyncSessionCallback_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IDirsyncSessionCallback_AddFailedObject(This,pObject,hrLastSync,syncDirection,retryType)	\
    (This)->lpVtbl -> AddFailedObject(This,pObject,hrLastSync,syncDirection,retryType)

#define IDirsyncSessionCallback_FreeDirsyncObject(This,pObject,fFreeOuter)	\
    (This)->lpVtbl -> FreeDirsyncObject(This,pObject,fFreeOuter)

#define IDirsyncSessionCallback_FreeSessionData(This,pSessionData)	\
    (This)->lpVtbl -> FreeSessionData(This,pSessionData)

#define IDirsyncSessionCallback_GetDataStore(This,ppDirsyncDatabase)	\
    (This)->lpVtbl -> GetDataStore(This,ppDirsyncDatabase)

#define IDirsyncSessionCallback_AddObjectIdMapping(This,pSourceId,cbSourceId,pTargetId,cbTargetId,syncDirection)	\
    (This)->lpVtbl -> AddObjectIdMapping(This,pSourceId,cbSourceId,pTargetId,cbTargetId,syncDirection)

#define IDirsyncSessionCallback_DeleteObjectIdMapping(This,pTargetId,cbTargetId,Provider)	\
    (This)->lpVtbl -> DeleteObjectIdMapping(This,pTargetId,cbTargetId,Provider)

#define IDirsyncSessionCallback_ReportSourceStatus(This,pObject)	\
    (This)->lpVtbl -> ReportSourceStatus(This,pObject)

#define IDirsyncSessionCallback_SetSessionPassword(This,pszPassword,syncDirection)	\
    (This)->lpVtbl -> SetSessionPassword(This,pszPassword,syncDirection)

#define IDirsyncSessionCallback_SetCheckSum(This,pId,cbId,Provider,dwCheckSum)	\
    (This)->lpVtbl -> SetCheckSum(This,pId,cbId,Provider,dwCheckSum)

#define IDirsyncSessionCallback_GetCheckSum(This,pId,cbId,Provider,dwCheckSum)	\
    (This)->lpVtbl -> GetCheckSum(This,pId,cbId,Provider,dwCheckSum)

#define IDirsyncSessionCallback_SetDampeningInfo(This,pObjectId,cbObjectId,Provider,pByte,dwSize,highestUSN)	\
    (This)->lpVtbl -> SetDampeningInfo(This,pObjectId,cbObjectId,Provider,pByte,dwSize,highestUSN)

#define IDirsyncSessionCallback_GetDampeningInfo(This,pObjectId,cbObjectId,Provider,ppByte,pdwSize,pHighestUSN)	\
    (This)->lpVtbl -> GetDampeningInfo(This,pObjectId,cbObjectId,Provider,ppByte,pdwSize,pHighestUSN)

#define IDirsyncSessionCallback_GetUnMarkedEntries(This,prgpbId,pdwEntries,Provider)	\
    (This)->lpVtbl -> GetUnMarkedEntries(This,prgpbId,pdwEntries,Provider)

#define IDirsyncSessionCallback_MarkEntry(This,pId,cbId,Provider)	\
    (This)->lpVtbl -> MarkEntry(This,pId,cbId,Provider)

#define IDirsyncSessionCallback_DeleteFailedObject(This,szObjectId)	\
    (This)->lpVtbl -> DeleteFailedObject(This,szObjectId)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IDirsyncSessionCallback_AddFailedObject_Proxy( 
    IDirsyncSessionCallback * This,
    /* [in] */ PDIRSYNCOBJECT pObject,
    /* [in] */ HRESULT hrLastSync,
    /* [in] */ SYNCDIRECTION syncDirection,
    /* [in] */ RETRYTYPE retryType);


void __RPC_STUB IDirsyncSessionCallback_AddFailedObject_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


void STDMETHODCALLTYPE IDirsyncSessionCallback_FreeDirsyncObject_Proxy( 
    IDirsyncSessionCallback * This,
    /* [in] */ PDIRSYNCOBJECT pObject,
    /* [in] */ BOOL fFreeOuter);


void __RPC_STUB IDirsyncSessionCallback_FreeDirsyncObject_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


void STDMETHODCALLTYPE IDirsyncSessionCallback_FreeSessionData_Proxy( 
    IDirsyncSessionCallback * This,
    /* [in] */ PSESSIONDATA pSessionData);


void __RPC_STUB IDirsyncSessionCallback_FreeSessionData_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDirsyncSessionCallback_GetDataStore_Proxy( 
    IDirsyncSessionCallback * This,
    /* [retval][out] */ IDirsyncDatabase **ppDirsyncDatabase);


void __RPC_STUB IDirsyncSessionCallback_GetDataStore_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDirsyncSessionCallback_AddObjectIdMapping_Proxy( 
    IDirsyncSessionCallback * This,
    /* [in] */ PBYTE pSourceId,
    /* [in] */ DWORD cbSourceId,
    /* [in] */ PBYTE pTargetId,
    /* [in] */ DWORD cbTargetId,
    /* [in] */ SYNCDIRECTION syncDirection);


void __RPC_STUB IDirsyncSessionCallback_AddObjectIdMapping_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDirsyncSessionCallback_DeleteObjectIdMapping_Proxy( 
    IDirsyncSessionCallback * This,
    /* [in] */ PBYTE pTargetId,
    /* [in] */ DWORD cbTargetId,
    /* [in] */ SYNCPROVIDER Provider);


void __RPC_STUB IDirsyncSessionCallback_DeleteObjectIdMapping_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDirsyncSessionCallback_ReportSourceStatus_Proxy( 
    IDirsyncSessionCallback * This,
    /* [in] */ PDIRSYNCOBJECT pObject);


void __RPC_STUB IDirsyncSessionCallback_ReportSourceStatus_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDirsyncSessionCallback_SetSessionPassword_Proxy( 
    IDirsyncSessionCallback * This,
    /* [in] */ PWSTR pszPassword,
    /* [in] */ SYNCDIRECTION syncDirection);


void __RPC_STUB IDirsyncSessionCallback_SetSessionPassword_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDirsyncSessionCallback_SetCheckSum_Proxy( 
    IDirsyncSessionCallback * This,
    /* [in] */ PBYTE pId,
    /* [in] */ DWORD cbId,
    /* [in] */ SYNCPROVIDER Provider,
    /* [in] */ DWORD dwCheckSum);


void __RPC_STUB IDirsyncSessionCallback_SetCheckSum_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDirsyncSessionCallback_GetCheckSum_Proxy( 
    IDirsyncSessionCallback * This,
    /* [in] */ PBYTE pId,
    /* [in] */ DWORD cbId,
    /* [in] */ SYNCPROVIDER Provider,
    /* [out] */ DWORD *dwCheckSum);


void __RPC_STUB IDirsyncSessionCallback_GetCheckSum_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDirsyncSessionCallback_SetDampeningInfo_Proxy( 
    IDirsyncSessionCallback * This,
    /* [in] */ PBYTE pObjectId,
    /* [in] */ DWORD cbObjectId,
    /* [in] */ SYNCPROVIDER Provider,
    /* [in] */ PBYTE pByte,
    /* [in] */ DWORD dwSize,
    /* [in] */ LONGLONG highestUSN);


void __RPC_STUB IDirsyncSessionCallback_SetDampeningInfo_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDirsyncSessionCallback_GetDampeningInfo_Proxy( 
    IDirsyncSessionCallback * This,
    /* [in] */ PBYTE pObjectId,
    /* [in] */ DWORD cbObjectId,
    /* [in] */ SYNCPROVIDER Provider,
    /* [out] */ PBYTE *ppByte,
    /* [out] */ DWORD *pdwSize,
    /* [out] */ LONGLONG *pHighestUSN);


void __RPC_STUB IDirsyncSessionCallback_GetDampeningInfo_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDirsyncSessionCallback_GetUnMarkedEntries_Proxy( 
    IDirsyncSessionCallback * This,
    PBYTE **prgpbId,
    DWORD *pdwEntries,
    SYNCPROVIDER Provider);


void __RPC_STUB IDirsyncSessionCallback_GetUnMarkedEntries_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDirsyncSessionCallback_MarkEntry_Proxy( 
    IDirsyncSessionCallback * This,
    PBYTE pId,
    DWORD cbId,
    SYNCPROVIDER Provider);


void __RPC_STUB IDirsyncSessionCallback_MarkEntry_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDirsyncSessionCallback_DeleteFailedObject_Proxy( 
    IDirsyncSessionCallback * This,
    /* [in] */ PWSTR szObjectId);


void __RPC_STUB IDirsyncSessionCallback_DeleteFailedObject_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IDirsyncSessionCallback_INTERFACE_DEFINED__ */


#ifndef __IDirsyncWriteProvider_INTERFACE_DEFINED__
#define __IDirsyncWriteProvider_INTERFACE_DEFINED__

/* interface IDirsyncWriteProvider */
/* [unique][helpstring][uuid][local][object] */ 


EXTERN_C const IID IID_IDirsyncWriteProvider;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("f260c74b-e455-11d1-b40a-00c04fb950dc")
    IDirsyncWriteProvider : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Initialize( 
            /* [in] */ IDirsyncSession *pSession,
            /* [in] */ IDirsyncSessionCallback *pSessionCallback,
            /* [in] */ IDirsyncSessionManager *pSessionManager,
            /* [in] */ IDirsyncObjectMapper *pObjectMapper,
            /* [in] */ SYNCDIRECTION syncDirection,
            /* [in] */ BOOL fFullSync) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ApplyChange( 
            /* [in] */ PDIRSYNCOBJECT pObject) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CommitChanges( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Terminate( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDirsyncWriteProviderVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IDirsyncWriteProvider * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IDirsyncWriteProvider * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IDirsyncWriteProvider * This);
        
        HRESULT ( STDMETHODCALLTYPE *Initialize )( 
            IDirsyncWriteProvider * This,
            /* [in] */ IDirsyncSession *pSession,
            /* [in] */ IDirsyncSessionCallback *pSessionCallback,
            /* [in] */ IDirsyncSessionManager *pSessionManager,
            /* [in] */ IDirsyncObjectMapper *pObjectMapper,
            /* [in] */ SYNCDIRECTION syncDirection,
            /* [in] */ BOOL fFullSync);
        
        HRESULT ( STDMETHODCALLTYPE *ApplyChange )( 
            IDirsyncWriteProvider * This,
            /* [in] */ PDIRSYNCOBJECT pObject);
        
        HRESULT ( STDMETHODCALLTYPE *CommitChanges )( 
            IDirsyncWriteProvider * This);
        
        HRESULT ( STDMETHODCALLTYPE *Terminate )( 
            IDirsyncWriteProvider * This);
        
        END_INTERFACE
    } IDirsyncWriteProviderVtbl;

    interface IDirsyncWriteProvider
    {
        CONST_VTBL struct IDirsyncWriteProviderVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDirsyncWriteProvider_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IDirsyncWriteProvider_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IDirsyncWriteProvider_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IDirsyncWriteProvider_Initialize(This,pSession,pSessionCallback,pSessionManager,pObjectMapper,syncDirection,fFullSync)	\
    (This)->lpVtbl -> Initialize(This,pSession,pSessionCallback,pSessionManager,pObjectMapper,syncDirection,fFullSync)

#define IDirsyncWriteProvider_ApplyChange(This,pObject)	\
    (This)->lpVtbl -> ApplyChange(This,pObject)

#define IDirsyncWriteProvider_CommitChanges(This)	\
    (This)->lpVtbl -> CommitChanges(This)

#define IDirsyncWriteProvider_Terminate(This)	\
    (This)->lpVtbl -> Terminate(This)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IDirsyncWriteProvider_Initialize_Proxy( 
    IDirsyncWriteProvider * This,
    /* [in] */ IDirsyncSession *pSession,
    /* [in] */ IDirsyncSessionCallback *pSessionCallback,
    /* [in] */ IDirsyncSessionManager *pSessionManager,
    /* [in] */ IDirsyncObjectMapper *pObjectMapper,
    /* [in] */ SYNCDIRECTION syncDirection,
    /* [in] */ BOOL fFullSync);


void __RPC_STUB IDirsyncWriteProvider_Initialize_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDirsyncWriteProvider_ApplyChange_Proxy( 
    IDirsyncWriteProvider * This,
    /* [in] */ PDIRSYNCOBJECT pObject);


void __RPC_STUB IDirsyncWriteProvider_ApplyChange_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDirsyncWriteProvider_CommitChanges_Proxy( 
    IDirsyncWriteProvider * This);


void __RPC_STUB IDirsyncWriteProvider_CommitChanges_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDirsyncWriteProvider_Terminate_Proxy( 
    IDirsyncWriteProvider * This);


void __RPC_STUB IDirsyncWriteProvider_Terminate_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IDirsyncWriteProvider_INTERFACE_DEFINED__ */


#ifndef __IDirsyncServer_INTERFACE_DEFINED__
#define __IDirsyncServer_INTERFACE_DEFINED__

/* interface IDirsyncServer */
/* [unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IDirsyncServer;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("43bc048c-c8ec-11d1-a40b-00c04fb950dc")
    IDirsyncServer : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE RegisterProvider( 
            /* [in] */ PROVIDERTYPE providerType,
            /* [in] */ PWSTR pDirectoryType,
            /* [in] */ REFCLSID rclsid) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE UnregisterProvider( 
            /* [in] */ PROVIDERTYPE providerType,
            /* [in] */ PWSTR pDirectoryType) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetServers( 
            /* [size_is][size_is][out] */ PWSTR **prgpszServers,
            /* [out] */ DWORD *pnServers) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE RegisterCustomMapper( 
            /* [in] */ CUSTOMMAPPERTYPE mapperType,
            /* [in] */ PWSTR pszDirectoryType,
            /* [in] */ PWSTR pszClassName,
            /* [in] */ PWSTR pszAttrName,
            /* [in] */ REFCLSID rclsid) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE UnregisterCustomMapper( 
            /* [in] */ CUSTOMMAPPERTYPE mapperType,
            /* [in] */ PWSTR pszDirectoryType,
            /* [in] */ PWSTR pszClassName,
            /* [in] */ PWSTR pszAttrName) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetSessionManager( 
            /* [retval][out] */ IDirsyncSessionManager **ppSessionManager) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDirsyncServerVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IDirsyncServer * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IDirsyncServer * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IDirsyncServer * This);
        
        HRESULT ( STDMETHODCALLTYPE *RegisterProvider )( 
            IDirsyncServer * This,
            /* [in] */ PROVIDERTYPE providerType,
            /* [in] */ PWSTR pDirectoryType,
            /* [in] */ REFCLSID rclsid);
        
        HRESULT ( STDMETHODCALLTYPE *UnregisterProvider )( 
            IDirsyncServer * This,
            /* [in] */ PROVIDERTYPE providerType,
            /* [in] */ PWSTR pDirectoryType);
        
        HRESULT ( STDMETHODCALLTYPE *GetServers )( 
            IDirsyncServer * This,
            /* [size_is][size_is][out] */ PWSTR **prgpszServers,
            /* [out] */ DWORD *pnServers);
        
        HRESULT ( STDMETHODCALLTYPE *RegisterCustomMapper )( 
            IDirsyncServer * This,
            /* [in] */ CUSTOMMAPPERTYPE mapperType,
            /* [in] */ PWSTR pszDirectoryType,
            /* [in] */ PWSTR pszClassName,
            /* [in] */ PWSTR pszAttrName,
            /* [in] */ REFCLSID rclsid);
        
        HRESULT ( STDMETHODCALLTYPE *UnregisterCustomMapper )( 
            IDirsyncServer * This,
            /* [in] */ CUSTOMMAPPERTYPE mapperType,
            /* [in] */ PWSTR pszDirectoryType,
            /* [in] */ PWSTR pszClassName,
            /* [in] */ PWSTR pszAttrName);
        
        HRESULT ( STDMETHODCALLTYPE *GetSessionManager )( 
            IDirsyncServer * This,
            /* [retval][out] */ IDirsyncSessionManager **ppSessionManager);
        
        END_INTERFACE
    } IDirsyncServerVtbl;

    interface IDirsyncServer
    {
        CONST_VTBL struct IDirsyncServerVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDirsyncServer_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IDirsyncServer_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IDirsyncServer_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IDirsyncServer_RegisterProvider(This,providerType,pDirectoryType,rclsid)	\
    (This)->lpVtbl -> RegisterProvider(This,providerType,pDirectoryType,rclsid)

#define IDirsyncServer_UnregisterProvider(This,providerType,pDirectoryType)	\
    (This)->lpVtbl -> UnregisterProvider(This,providerType,pDirectoryType)

#define IDirsyncServer_GetServers(This,prgpszServers,pnServers)	\
    (This)->lpVtbl -> GetServers(This,prgpszServers,pnServers)

#define IDirsyncServer_RegisterCustomMapper(This,mapperType,pszDirectoryType,pszClassName,pszAttrName,rclsid)	\
    (This)->lpVtbl -> RegisterCustomMapper(This,mapperType,pszDirectoryType,pszClassName,pszAttrName,rclsid)

#define IDirsyncServer_UnregisterCustomMapper(This,mapperType,pszDirectoryType,pszClassName,pszAttrName)	\
    (This)->lpVtbl -> UnregisterCustomMapper(This,mapperType,pszDirectoryType,pszClassName,pszAttrName)

#define IDirsyncServer_GetSessionManager(This,ppSessionManager)	\
    (This)->lpVtbl -> GetSessionManager(This,ppSessionManager)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IDirsyncServer_RegisterProvider_Proxy( 
    IDirsyncServer * This,
    /* [in] */ PROVIDERTYPE providerType,
    /* [in] */ PWSTR pDirectoryType,
    /* [in] */ REFCLSID rclsid);


void __RPC_STUB IDirsyncServer_RegisterProvider_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDirsyncServer_UnregisterProvider_Proxy( 
    IDirsyncServer * This,
    /* [in] */ PROVIDERTYPE providerType,
    /* [in] */ PWSTR pDirectoryType);


void __RPC_STUB IDirsyncServer_UnregisterProvider_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDirsyncServer_GetServers_Proxy( 
    IDirsyncServer * This,
    /* [size_is][size_is][out] */ PWSTR **prgpszServers,
    /* [out] */ DWORD *pnServers);


void __RPC_STUB IDirsyncServer_GetServers_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDirsyncServer_RegisterCustomMapper_Proxy( 
    IDirsyncServer * This,
    /* [in] */ CUSTOMMAPPERTYPE mapperType,
    /* [in] */ PWSTR pszDirectoryType,
    /* [in] */ PWSTR pszClassName,
    /* [in] */ PWSTR pszAttrName,
    /* [in] */ REFCLSID rclsid);


void __RPC_STUB IDirsyncServer_RegisterCustomMapper_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDirsyncServer_UnregisterCustomMapper_Proxy( 
    IDirsyncServer * This,
    /* [in] */ CUSTOMMAPPERTYPE mapperType,
    /* [in] */ PWSTR pszDirectoryType,
    /* [in] */ PWSTR pszClassName,
    /* [in] */ PWSTR pszAttrName);


void __RPC_STUB IDirsyncServer_UnregisterCustomMapper_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDirsyncServer_GetSessionManager_Proxy( 
    IDirsyncServer * This,
    /* [retval][out] */ IDirsyncSessionManager **ppSessionManager);


void __RPC_STUB IDirsyncServer_GetSessionManager_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IDirsyncServer_INTERFACE_DEFINED__ */


#ifndef __IDirsyncReadProvider_INTERFACE_DEFINED__
#define __IDirsyncReadProvider_INTERFACE_DEFINED__

/* interface IDirsyncReadProvider */
/* [unique][helpstring][uuid][local][object] */ 


EXTERN_C const IID IID_IDirsyncReadProvider;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("ac80a9d2-de29-11d1-ba56-2700272c2027")
    IDirsyncReadProvider : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Initialize( 
            /* [in] */ IDirsyncSession *pSession,
            /* [in] */ IDirsyncSessionCallback *pSessionCallback,
            /* [in] */ IDirsyncSessionManager *pSessionManager,
            /* [in] */ SYNCDIRECTION syncDirection,
            /* [in] */ BOOL fFullSync) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetNextChange( 
            /* [out] */ PDIRSYNCOBJECT *ppObject,
            /* [out] */ PBYTE *ppWatermark,
            /* [out] */ DWORD *pcbWatermark,
            /* [out][in] */ DWORD *pdwPercentCompleted) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE UpdateWatermark( 
            /* [in] */ PBYTE pWatermark,
            /* [in] */ DWORD cbWatermark) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Terminate( void) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_IsIncrementalChangesAvailable( 
            /* [retval][out] */ BOOL *fIsIncrementalChangesAvailable) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDirsyncReadProviderVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IDirsyncReadProvider * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IDirsyncReadProvider * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IDirsyncReadProvider * This);
        
        HRESULT ( STDMETHODCALLTYPE *Initialize )( 
            IDirsyncReadProvider * This,
            /* [in] */ IDirsyncSession *pSession,
            /* [in] */ IDirsyncSessionCallback *pSessionCallback,
            /* [in] */ IDirsyncSessionManager *pSessionManager,
            /* [in] */ SYNCDIRECTION syncDirection,
            /* [in] */ BOOL fFullSync);
        
        HRESULT ( STDMETHODCALLTYPE *GetNextChange )( 
            IDirsyncReadProvider * This,
            /* [out] */ PDIRSYNCOBJECT *ppObject,
            /* [out] */ PBYTE *ppWatermark,
            /* [out] */ DWORD *pcbWatermark,
            /* [out][in] */ DWORD *pdwPercentCompleted);
        
        HRESULT ( STDMETHODCALLTYPE *UpdateWatermark )( 
            IDirsyncReadProvider * This,
            /* [in] */ PBYTE pWatermark,
            /* [in] */ DWORD cbWatermark);
        
        HRESULT ( STDMETHODCALLTYPE *Terminate )( 
            IDirsyncReadProvider * This);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_IsIncrementalChangesAvailable )( 
            IDirsyncReadProvider * This,
            /* [retval][out] */ BOOL *fIsIncrementalChangesAvailable);
        
        END_INTERFACE
    } IDirsyncReadProviderVtbl;

    interface IDirsyncReadProvider
    {
        CONST_VTBL struct IDirsyncReadProviderVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDirsyncReadProvider_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IDirsyncReadProvider_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IDirsyncReadProvider_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IDirsyncReadProvider_Initialize(This,pSession,pSessionCallback,pSessionManager,syncDirection,fFullSync)	\
    (This)->lpVtbl -> Initialize(This,pSession,pSessionCallback,pSessionManager,syncDirection,fFullSync)

#define IDirsyncReadProvider_GetNextChange(This,ppObject,ppWatermark,pcbWatermark,pdwPercentCompleted)	\
    (This)->lpVtbl -> GetNextChange(This,ppObject,ppWatermark,pcbWatermark,pdwPercentCompleted)

#define IDirsyncReadProvider_UpdateWatermark(This,pWatermark,cbWatermark)	\
    (This)->lpVtbl -> UpdateWatermark(This,pWatermark,cbWatermark)

#define IDirsyncReadProvider_Terminate(This)	\
    (This)->lpVtbl -> Terminate(This)

#define IDirsyncReadProvider_get_IsIncrementalChangesAvailable(This,fIsIncrementalChangesAvailable)	\
    (This)->lpVtbl -> get_IsIncrementalChangesAvailable(This,fIsIncrementalChangesAvailable)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IDirsyncReadProvider_Initialize_Proxy( 
    IDirsyncReadProvider * This,
    /* [in] */ IDirsyncSession *pSession,
    /* [in] */ IDirsyncSessionCallback *pSessionCallback,
    /* [in] */ IDirsyncSessionManager *pSessionManager,
    /* [in] */ SYNCDIRECTION syncDirection,
    /* [in] */ BOOL fFullSync);


void __RPC_STUB IDirsyncReadProvider_Initialize_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDirsyncReadProvider_GetNextChange_Proxy( 
    IDirsyncReadProvider * This,
    /* [out] */ PDIRSYNCOBJECT *ppObject,
    /* [out] */ PBYTE *ppWatermark,
    /* [out] */ DWORD *pcbWatermark,
    /* [out][in] */ DWORD *pdwPercentCompleted);


void __RPC_STUB IDirsyncReadProvider_GetNextChange_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDirsyncReadProvider_UpdateWatermark_Proxy( 
    IDirsyncReadProvider * This,
    /* [in] */ PBYTE pWatermark,
    /* [in] */ DWORD cbWatermark);


void __RPC_STUB IDirsyncReadProvider_UpdateWatermark_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDirsyncReadProvider_Terminate_Proxy( 
    IDirsyncReadProvider * This);


void __RPC_STUB IDirsyncReadProvider_Terminate_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propget] */ HRESULT STDMETHODCALLTYPE IDirsyncReadProvider_get_IsIncrementalChangesAvailable_Proxy( 
    IDirsyncReadProvider * This,
    /* [retval][out] */ BOOL *fIsIncrementalChangesAvailable);


void __RPC_STUB IDirsyncReadProvider_get_IsIncrementalChangesAvailable_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IDirsyncReadProvider_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_dirsync_0121 */
/* [local] */ 




extern RPC_IF_HANDLE __MIDL_itf_dirsync_0121_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_dirsync_0121_v0_0_s_ifspec;

#ifndef __IDirsyncNamespaceMapper_INTERFACE_DEFINED__
#define __IDirsyncNamespaceMapper_INTERFACE_DEFINED__

/* interface IDirsyncNamespaceMapper */
/* [unique][helpstring][uuid][local][object] */ 


EXTERN_C const IID IID_IDirsyncNamespaceMapper;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("a4f0c94e-27e3-11d2-a159-00c04fb950dc")
    IDirsyncNamespaceMapper : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Initialize( 
            /* [in] */ IDirsyncSession *pSession,
            /* [in] */ IDirsyncSessionCallback *pSessionCallback,
            /* [in] */ IDirsyncSessionManager *pSessionManager,
            /* [in] */ SYNCDIRECTION syncDirection) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE MapNamespace( 
            /* [in] */ PWSTR pszSourceDN,
            /* [in] */ PWSTR pszSourceOldDN,
            /* [out] */ PWSTR *ppszTargetDN,
            /* [out] */ PWSTR *ppszTargetOldDN,
            /* [in] */ PWSTR pszAttribute,
            /* [in] */ PWSTR pszClass,
            /* [in] */ BOOL fTargetIDAvailable) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDirsyncNamespaceMapperVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IDirsyncNamespaceMapper * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IDirsyncNamespaceMapper * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IDirsyncNamespaceMapper * This);
        
        HRESULT ( STDMETHODCALLTYPE *Initialize )( 
            IDirsyncNamespaceMapper * This,
            /* [in] */ IDirsyncSession *pSession,
            /* [in] */ IDirsyncSessionCallback *pSessionCallback,
            /* [in] */ IDirsyncSessionManager *pSessionManager,
            /* [in] */ SYNCDIRECTION syncDirection);
        
        HRESULT ( STDMETHODCALLTYPE *MapNamespace )( 
            IDirsyncNamespaceMapper * This,
            /* [in] */ PWSTR pszSourceDN,
            /* [in] */ PWSTR pszSourceOldDN,
            /* [out] */ PWSTR *ppszTargetDN,
            /* [out] */ PWSTR *ppszTargetOldDN,
            /* [in] */ PWSTR pszAttribute,
            /* [in] */ PWSTR pszClass,
            /* [in] */ BOOL fTargetIDAvailable);
        
        END_INTERFACE
    } IDirsyncNamespaceMapperVtbl;

    interface IDirsyncNamespaceMapper
    {
        CONST_VTBL struct IDirsyncNamespaceMapperVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDirsyncNamespaceMapper_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IDirsyncNamespaceMapper_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IDirsyncNamespaceMapper_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IDirsyncNamespaceMapper_Initialize(This,pSession,pSessionCallback,pSessionManager,syncDirection)	\
    (This)->lpVtbl -> Initialize(This,pSession,pSessionCallback,pSessionManager,syncDirection)

#define IDirsyncNamespaceMapper_MapNamespace(This,pszSourceDN,pszSourceOldDN,ppszTargetDN,ppszTargetOldDN,pszAttribute,pszClass,fTargetIDAvailable)	\
    (This)->lpVtbl -> MapNamespace(This,pszSourceDN,pszSourceOldDN,ppszTargetDN,ppszTargetOldDN,pszAttribute,pszClass,fTargetIDAvailable)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IDirsyncNamespaceMapper_Initialize_Proxy( 
    IDirsyncNamespaceMapper * This,
    /* [in] */ IDirsyncSession *pSession,
    /* [in] */ IDirsyncSessionCallback *pSessionCallback,
    /* [in] */ IDirsyncSessionManager *pSessionManager,
    /* [in] */ SYNCDIRECTION syncDirection);


void __RPC_STUB IDirsyncNamespaceMapper_Initialize_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDirsyncNamespaceMapper_MapNamespace_Proxy( 
    IDirsyncNamespaceMapper * This,
    /* [in] */ PWSTR pszSourceDN,
    /* [in] */ PWSTR pszSourceOldDN,
    /* [out] */ PWSTR *ppszTargetDN,
    /* [out] */ PWSTR *ppszTargetOldDN,
    /* [in] */ PWSTR pszAttribute,
    /* [in] */ PWSTR pszClass,
    /* [in] */ BOOL fTargetIDAvailable);


void __RPC_STUB IDirsyncNamespaceMapper_MapNamespace_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IDirsyncNamespaceMapper_INTERFACE_DEFINED__ */


#ifndef __IDirsyncAttributeMapper_INTERFACE_DEFINED__
#define __IDirsyncAttributeMapper_INTERFACE_DEFINED__

/* interface IDirsyncAttributeMapper */
/* [unique][helpstring][uuid][local][object] */ 


EXTERN_C const IID IID_IDirsyncAttributeMapper;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("1fff291c-413b-11d2-917d-0000f87a92ea")
    IDirsyncAttributeMapper : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Initialize( 
            /* [in] */ IDirsyncSession *pSession,
            /* [in] */ IDirsyncSessionCallback *pSessionCallback,
            /* [in] */ IDirsyncSessionManager *pSessionManager,
            /* [in] */ IDirsyncObjectMapper *pObjectMapper,
            /* [in] */ SYNCDIRECTION syncDirection) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE MapAttribute( 
            /* [out][in] */ PDIRSYNCOBJECT pObject,
            /* [out][in] */ PDIRSYNCATTRIBUTE pAttribute) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDirsyncAttributeMapperVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IDirsyncAttributeMapper * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IDirsyncAttributeMapper * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IDirsyncAttributeMapper * This);
        
        HRESULT ( STDMETHODCALLTYPE *Initialize )( 
            IDirsyncAttributeMapper * This,
            /* [in] */ IDirsyncSession *pSession,
            /* [in] */ IDirsyncSessionCallback *pSessionCallback,
            /* [in] */ IDirsyncSessionManager *pSessionManager,
            /* [in] */ IDirsyncObjectMapper *pObjectMapper,
            /* [in] */ SYNCDIRECTION syncDirection);
        
        HRESULT ( STDMETHODCALLTYPE *MapAttribute )( 
            IDirsyncAttributeMapper * This,
            /* [out][in] */ PDIRSYNCOBJECT pObject,
            /* [out][in] */ PDIRSYNCATTRIBUTE pAttribute);
        
        END_INTERFACE
    } IDirsyncAttributeMapperVtbl;

    interface IDirsyncAttributeMapper
    {
        CONST_VTBL struct IDirsyncAttributeMapperVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDirsyncAttributeMapper_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IDirsyncAttributeMapper_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IDirsyncAttributeMapper_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IDirsyncAttributeMapper_Initialize(This,pSession,pSessionCallback,pSessionManager,pObjectMapper,syncDirection)	\
    (This)->lpVtbl -> Initialize(This,pSession,pSessionCallback,pSessionManager,pObjectMapper,syncDirection)

#define IDirsyncAttributeMapper_MapAttribute(This,pObject,pAttribute)	\
    (This)->lpVtbl -> MapAttribute(This,pObject,pAttribute)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IDirsyncAttributeMapper_Initialize_Proxy( 
    IDirsyncAttributeMapper * This,
    /* [in] */ IDirsyncSession *pSession,
    /* [in] */ IDirsyncSessionCallback *pSessionCallback,
    /* [in] */ IDirsyncSessionManager *pSessionManager,
    /* [in] */ IDirsyncObjectMapper *pObjectMapper,
    /* [in] */ SYNCDIRECTION syncDirection);


void __RPC_STUB IDirsyncAttributeMapper_Initialize_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDirsyncAttributeMapper_MapAttribute_Proxy( 
    IDirsyncAttributeMapper * This,
    /* [out][in] */ PDIRSYNCOBJECT pObject,
    /* [out][in] */ PDIRSYNCATTRIBUTE pAttribute);


void __RPC_STUB IDirsyncAttributeMapper_MapAttribute_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IDirsyncAttributeMapper_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_dirsync_0123 */
/* [local] */ 

//
// Error codes for Dirsync
//

#define FAC_DIRSYNC                     0x07AB

#define E_SESSION_NOT_FOUND             MAKE_HRESULT(SEVERITY_ERROR, FAC_DIRSYNC, 0x0000)
#define E_SESSION_IN_PROGRESS           MAKE_HRESULT(SEVERITY_ERROR, FAC_DIRSYNC, 0x0001)
#define E_SESSION_NOT_IN_PROGRESS       MAKE_HRESULT(SEVERITY_ERROR, FAC_DIRSYNC, 0x0002)
#define E_SESSION_INVALIDDATA           MAKE_HRESULT(SEVERITY_ERROR, FAC_DIRSYNC, 0x0003)
#define E_SESSION_MAXREACHED            MAKE_HRESULT(SEVERITY_ERROR, FAC_DIRSYNC, 0x0004)
#define E_PASSWORD_UNENCRYPTED          MAKE_HRESULT(SEVERITY_ERROR, FAC_DIRSYNC, 0x0005)
#define E_PASSWORD_UNAVAILABLE          MAKE_HRESULT(SEVERITY_ERROR, FAC_DIRSYNC, 0x0006)
#define E_WRITE_CLASSCONFLICT           MAKE_HRESULT(SEVERITY_ERROR, FAC_DIRSYNC, 0x0007)
#define E_WRITE_DUPATTR                 MAKE_HRESULT(SEVERITY_ERROR, FAC_DIRSYNC, 0x0008)
#define E_WRITE_DUPSAMACCOUNT           MAKE_HRESULT(SEVERITY_ERROR, FAC_DIRSYNC, 0x0009)
#define E_DATABASE_CORRUPT              MAKE_HRESULT(SEVERITY_ERROR, FAC_DIRSYNC, 0x000a)
#define E_INITIALIZATION_IN_PROGRESS    MAKE_HRESULT(SEVERITY_ERROR, FAC_DIRSYNC, 0x000b)
#define E_SESSION_FAILEDOBJLIST_FULL    MAKE_HRESULT(SEVERITY_ERROR, FAC_DIRSYNC, 0x000c)
#define E_BACKUP_IN_PROGRESS            MAKE_HRESULT(SEVERITY_ERROR, FAC_DIRSYNC, 0x000d)
#define E_TWOWAYSYNC_RENAME_BEFORE_INIT_ADD     MAKE_HRESULT(SEVERITY_ERROR, FAC_DIRSYNC, 0x000e)
#define E_TWOWAYSYNC_MASTER_HAS_MOVED           MAKE_HRESULT(SEVERITY_ERROR, FAC_DIRSYNC, 0x000f)
#define E_WRITE_ADDED_TO_FAILEDOBJLIST_RETRY    MAKE_HRESULT(SEVERITY_ERROR, FAC_DIRSYNC, 0x0010)
#define E_WRITE_ADDED_TO_FAILEDOBJLIST_NORETRY  MAKE_HRESULT(SEVERITY_ERROR, FAC_DIRSYNC, 0x0011)
#define E_TWOWAYSYNC_MODIFY_BUT_TARGETMOVED     MAKE_HRESULT(SEVERITY_ERROR, FAC_DIRSYNC, 0x0012)



extern RPC_IF_HANDLE __MIDL_itf_dirsync_0123_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_dirsync_0123_v0_0_s_ifspec;


#ifndef __Dirsync_LIBRARY_DEFINED__
#define __Dirsync_LIBRARY_DEFINED__

/* library Dirsync */
/* [helpstring][version][uuid] */ 


EXTERN_C const IID LIBID_Dirsync;

EXTERN_C const CLSID CLSID_DirsyncServer;

#ifdef __cplusplus

class DECLSPEC_UUID("56374e32-cdba-11d1-a40e-00c04fb950dc")
DirsyncServer;
#endif
#endif /* __Dirsync_LIBRARY_DEFINED__ */

/* Additional Prototypes for ALL interfaces */

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\public\internal\ds\inc\dsmnname.h ===
/*++

Copyright (c) 1993  Microsoft Corporation

Module Name:

    dsmnname.h

Abstract:

    Header for NetWare service names.

Author:

    Rita Wong      (ritaw)      26-Feb-1993

Revision History:

--*/

#ifndef _DSMN_NAMES_INCLUDED_
#define _DSMN_NAMES_INCLUDED_


//
// Name of service (not display name, but Key name)
//
#define NW_SYNCAGENT_SERVICE      L"MSSYNC"

//
// Directory where we store all the good stuff like the database.
//
#define NW_SYNCAGENT_DIRECTORY    L"SyncAgnt"
#define NW_SYNCAGENT_DIRECTORYA   "SyncAgnt"

//
// Name of secret used to store supervisor credentials between install
// and service starting. Deleted after that.
//
#define NW_SYNCAGENT_CRED_SECRET L"InitialCredential"

//
//
//
#define NW_SYNCAGENT_PASSWD_NOTIFY_DLL L"NwsLib"

#endif // _DSMN_NAMES_INCLUDED_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\public\internal\ds\inc\dosprint.h ===
/*++

Copyright (c) 1991-1992  Microsoft Corporation

Module Name:

    DosPrint.h

Abstract:

    This contains prototypes for the DosPrint routines

Author:

    Dave Snipp (DaveSn) 16-Apr-1991

Environment:


Revision History:

    22-Apr-1991 JohnRo
        Use constants from <lmcons.h>.
    18-Jun-1992 JohnRo
        RAID 10324: net print vs. UNICODE.

--*/

#ifndef _DosPRINT_
#define _DosPRINT_

#include "rxprint.h"

/****************************************************************
 *                                                              *
 *              Function prototypes                             *
 *                                                              *
 ****************************************************************/

SPLERR SPLENTRY DosPrintDestEnumA(
            LPSTR pszServer,
            WORD    uLevel,
            PBYTE   pbBuf,
            WORD    cbBuf,
            PUSHORT pcReturned,
            PUSHORT pcTotal
            );
SPLERR SPLENTRY DosPrintDestEnumW(
            LPWSTR pszServer,
            WORD    uLevel,
            PBYTE   pbBuf,
            WORD    cbBuf,
            PUSHORT pcReturned,
            PUSHORT pcTotal
            );
#ifdef UNICODE
#define DosPrintDestEnum  DosPrintDestEnumW
#else
#define DosPrintDestEnum  DosPrintDestEnumA
#endif // !UNICODE

SPLERR SPLENTRY DosPrintDestControlA(
            LPSTR pszServer,
            LPSTR pszDevName,
            WORD    uControl
            );
SPLERR SPLENTRY DosPrintDestControlW(
            LPWSTR pszServer,
            LPWSTR pszDevName,
            WORD    uControl
            );
#ifdef UNICODE
#define DosPrintDestControl  DosPrintDestControlW
#else
#define DosPrintDestControl  DosPrintDestControlA
#endif // !UNICODE

SPLERR SPLENTRY DosPrintDestGetInfoA(
            LPSTR pszServer,
            LPSTR pszName,
            WORD    uLevel,
            PBYTE   pbBuf,
            WORD    cbBuf,
            PUSHORT pcbNeeded
            );
SPLERR SPLENTRY DosPrintDestGetInfoW(
            LPWSTR pszServer,
            LPWSTR pszName,
            WORD    uLevel,
            PBYTE   pbBuf,
            WORD    cbBuf,
            PUSHORT pcbNeeded
            );
#ifdef UNICODE
#define DosPrintDestGetInfo  DosPrintDestGetInfoW
#else
#define DosPrintDestGetInfo  DosPrintDestGetInfoA
#endif // !UNICODE

SPLERR SPLENTRY DosPrintDestAddA(
            LPSTR pszServer,
            WORD    uLevel,
            PBYTE   pbBuf,
            WORD    cbBuf
            );
SPLERR SPLENTRY DosPrintDestAddW(
            LPWSTR pszServer,
            WORD    uLevel,
            PBYTE   pbBuf,
            WORD    cbBuf
            );
#ifdef UNICODE
#define DosPrintDestAdd  DosPrintDestAddW
#else
#define DosPrintDestAdd  DosPrintDestAddA
#endif // !UNICODE

SPLERR SPLENTRY DosPrintDestSetInfoA(
            LPSTR pszServer,
            LPSTR pszName,
            WORD    uLevel,
            PBYTE   pbBuf,
            WORD    cbBuf,
            WORD    uParmNum
            );
SPLERR SPLENTRY DosPrintDestSetInfoW(
            LPWSTR pszServer,
            LPWSTR pszName,
            WORD    uLevel,
            PBYTE   pbBuf,
            WORD    cbBuf,
            WORD    uParmNum
            );
#ifdef UNICODE
#define DosPrintDestSetInfo  DosPrintDestSetInfoW
#else
#define DosPrintDestSetInfo  DosPrintDestSetInfoA
#endif // !UNICODE

SPLERR SPLENTRY DosPrintDestDelA(
            LPSTR pszServer,
            LPSTR pszPrinterName
            );
SPLERR SPLENTRY DosPrintDestDelW(
            LPWSTR pszServer,
            LPWSTR pszPrinterName
            );
#ifdef UNICODE
#define DosPrintDestDel  DosPrintDestDelW
#else
#define DosPrintDestDel  DosPrintDestDelA
#endif // !UNICODE

SPLERR SPLENTRY DosPrintQEnumA(
            LPSTR pszServer,
            WORD    uLevel,
            PBYTE   pbBuf,
            WORD    cbBuf,
            PUSHORT pcReturned,
            PUSHORT pcTotal
            );
SPLERR SPLENTRY DosPrintQEnumW(
            LPWSTR pszServer,
            WORD    uLevel,
            PBYTE   pbBuf,
            WORD    cbBuf,
            PUSHORT pcReturned,
            PUSHORT pcTotal
            );
#ifdef UNICODE
#define DosPrintQEnum  DosPrintQEnumW
#else
#define DosPrintQEnum  DosPrintQEnumA
#endif // !UNICODE

SPLERR SPLENTRY DosPrintQGetInfoA(
            LPSTR pszServer,
            LPSTR pszQueueName,
            WORD    uLevel,
            PBYTE   pbBuf,
            WORD    cbBuf,
            PUSHORT pcbNeeded
            );
SPLERR SPLENTRY DosPrintQGetInfoW(
            LPWSTR pszServer,
            LPWSTR pszQueueName,
            WORD    uLevel,
            PBYTE   pbBuf,
            WORD    cbBuf,
            PUSHORT pcbNeeded
            );
#ifdef UNICODE
#define DosPrintQGetInfo  DosPrintQGetInfoW
#else
#define DosPrintQGetInfo  DosPrintQGetInfoA
#endif // !UNICODE

SPLERR SPLENTRY DosPrintQSetInfoA(
            LPSTR pszServer,
            LPSTR pszQueueName,
            WORD    uLevel,
            PBYTE   pbBuf,
            WORD    cbBuf,
            WORD    uParmNum
            );
SPLERR SPLENTRY DosPrintQSetInfoW(
            LPWSTR pszServer,
            LPWSTR pszQueueName,
            WORD    uLevel,
            PBYTE   pbBuf,
            WORD    cbBuf,
            WORD    uParmNum
            );
#ifdef UNICODE
#define DosPrintQSetInfo  DosPrintQSetInfoW
#else
#define DosPrintQSetInfo  DosPrintQSetInfoA
#endif // !UNICODE

SPLERR SPLENTRY DosPrintQPauseA(
            LPSTR pszServer,
            LPSTR pszQueueName
            );
SPLERR SPLENTRY DosPrintQPauseW(
            LPWSTR pszServer,
            LPWSTR pszQueueName
            );
#ifdef UNICODE
#define DosPrintQPause  DosPrintQPauseW
#else
#define DosPrintQPause  DosPrintQPauseA
#endif // !UNICODE

SPLERR SPLENTRY DosPrintQContinueA(
            LPSTR pszServer,
            LPSTR pszQueueName
            );
SPLERR SPLENTRY DosPrintQContinueW(
            LPWSTR pszServer,
            LPWSTR pszQueueName
            );
#ifdef UNICODE
#define DosPrintQContinue  DosPrintQContinueW
#else
#define DosPrintQContinue  DosPrintQContinueA
#endif // !UNICODE

SPLERR SPLENTRY DosPrintQPurgeA(
            LPSTR pszServer,
            LPSTR pszQueueName
            );
SPLERR SPLENTRY DosPrintQPurgeW(
            LPWSTR pszServer,
            LPWSTR pszQueueName
            );
#ifdef UNICODE
#define DosPrintQPurge  DosPrintQPurgeW
#else
#define DosPrintQPurge  DosPrintQPurgeA
#endif // !UNICODE

SPLERR SPLENTRY DosPrintQAddA(
            LPSTR pszServer,
            WORD    uLevel,
            PBYTE   pbBuf,
            WORD    cbBuf
            );
SPLERR SPLENTRY DosPrintQAddW(
            LPWSTR pszServer,
            WORD    uLevel,
            PBYTE   pbBuf,
            WORD    cbBuf
            );
#ifdef UNICODE
#define DosPrintQAdd  DosPrintQAddW
#else
#define DosPrintQAdd  DosPrintQAddA
#endif // !UNICODE

SPLERR SPLENTRY DosPrintQDelA(
            LPSTR pszServer,
            LPSTR pszQueueName
            );
SPLERR SPLENTRY DosPrintQDelW(
            LPWSTR pszServer,
            LPWSTR pszQueueName
            );
#ifdef UNICODE
#define DosPrintQDel  DosPrintQDelW
#else
#define DosPrintQDel  DosPrintQDelA
#endif // !UNICODE

SPLERR SPLENTRY DosPrintJobGetInfoA(
            LPSTR pszServer,
            BOOL    bRemote,
            WORD    uJobId,
            WORD    uLevel,
            PBYTE   pbBuf,
            WORD    cbBuf,
            PUSHORT pcbNeeded
            );
SPLERR SPLENTRY DosPrintJobGetInfoW(
            LPWSTR pszServer,
            BOOL    bRemote,
            WORD    uJobId,
            WORD    uLevel,
            PBYTE   pbBuf,
            WORD    cbBuf,
            PUSHORT pcbNeeded
            );
#ifdef UNICODE
#define DosPrintJobGetInfo  DosPrintJobGetInfoW
#else
#define DosPrintJobGetInfo  DosPrintJobGetInfoA
#endif // !UNICODE

SPLERR SPLENTRY DosPrintJobSetInfoA(
            LPSTR pszServer,
            BOOL    bRemote,
            WORD    uJobId,
            WORD    uLevel,
            PBYTE   pbBuf,
            WORD    cbBuf,
            WORD    uParmNum
            );
SPLERR SPLENTRY DosPrintJobSetInfoW(
            LPWSTR pszServer,
            BOOL    bRemote,
            WORD    uJobId,
            WORD    uLevel,
            PBYTE   pbBuf,
            WORD    cbBuf,
            WORD    uParmNum
            );
#ifdef UNICODE
#define DosPrintJobSetInfo  DosPrintJobSetInfoW
#else
#define DosPrintJobSetInfo  DosPrintJobSetInfoA
#endif // !UNICODE

SPLERR SPLENTRY DosPrintJobPauseA(
            LPSTR pszServer,
            BOOL    bRemote,
            WORD    uJobId
            );
SPLERR SPLENTRY DosPrintJobPauseW(
            LPWSTR pszServer,
            BOOL    bRemote,
            WORD    uJobId
            );
#ifdef UNICODE
#define DosPrintJobPause  DosPrintJobPauseW
#else
#define DosPrintJobPause  DosPrintJobPauseA
#endif // !UNICODE

SPLERR SPLENTRY DosPrintJobContinueA(
            LPSTR pszServer,
            BOOL    bRemote,
            WORD    uJobId
            );
SPLERR SPLENTRY DosPrintJobContinueW(
            LPWSTR pszServer,
            BOOL    bRemote,
            WORD    uJobId
            );
#ifdef UNICODE
#define DosPrintJobContinue  DosPrintJobContinueW
#else
#define DosPrintJobContinue  DosPrintJobContinueA
#endif // !UNICODE

SPLERR SPLENTRY DosPrintJobDelA(
            LPSTR pszServer,
            BOOL    bRemote,
            WORD    uJobId
            );
SPLERR SPLENTRY DosPrintJobDelW(
            LPWSTR pszServer,
            BOOL    bRemote,
            WORD    uJobId
            );
#ifdef UNICODE
#define DosPrintJobDel  DosPrintJobDelW
#else
#define DosPrintJobDel  DosPrintJobDelA
#endif // !UNICODE

SPLERR SPLENTRY DosPrintJobEnumA(
            LPSTR pszServer,
            LPSTR pszQueueName,
            WORD    uLevel,
            PBYTE   pbBuf,
            WORD    cbBuf,
            PWORD   pcReturned,
            PWORD   pcTotal
            );
SPLERR SPLENTRY DosPrintJobEnumW(
            LPWSTR pszServer,
            LPWSTR pszQueueName,
            WORD    uLevel,
            PBYTE   pbBuf,
            WORD    cbBuf,
            PWORD   pcReturned,
            PWORD   pcTotal
            );
#ifdef UNICODE
#define DosPrintJobEnum  DosPrintJobEnumW
#else
#define DosPrintJobEnum  DosPrintJobEnumA
#endif // !UNICODE

SPLERR SPLENTRY DosPrintJobGetIdA(
            HANDLE      hFile,
            PPRIDINFO   pInfo,
            WORD        cbInfo
            );
SPLERR SPLENTRY DosPrintJobGetIdW(
            HANDLE      hFile,
            PPRIDINFO   pInfo,
            WORD        cbInfo
            );
#ifdef UNICODE
#define DosPrintJobGetId  DosPrintJobGetIdW
#else
#define DosPrintJobGetId  DosPrintJobGetIdA
#endif // !UNICODE

#endif // ndef _DosPRINT_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\public\internal\ds\inc\dspropp.h ===
//+----------------------------------------------------------------------------
//
//  Windows NT Active Directory Service Property Pages
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992-1999.
//
//  File:       dspropp.h
//
//  Contents:   Non-SDK functions and definitions used in the creation of AD
//              property sheets.
//
//  History:    24-Aug-99 EricB created.
//
//-----------------------------------------------------------------------------

#ifndef _DSPROPP_H_
#define _DSPROPP_H_

#if _MSC_VER > 1000
#pragma once
#endif
#ifdef __cplusplus
extern "C" {
#endif

typedef struct _PROPSHEETCFG {
    LONG_PTR lNotifyHandle;
    HWND hwndParentSheet;   // invoking parent if launched from another sheet.
    HWND hwndHidden;  // snapin hidden window handle
    WPARAM wParamSheetClose; // wParam to be used with WM_DSA_SHEET_CLOSE_NOTIFY message
} PROPSHEETCFG, * PPROPSHEETCFG;

// private message to send to property page to get the HWND of the notify object
#define WM_ADSPROP_PAGE_GET_NOTIFY    (WM_USER + 1109) 

//+----------------------------------------------------------------------------
//
//  Function:   PostADsPropSheet
//
//  Synopsis:   Creates a property sheet for the named object using MMC's
//              IPropertySheetProvider so that extension snapins can add pages.
//              This function is provided so that property pages can invoke
//              other propety sheets.
//
//  Arguments:  [pwzObjDN]   - the full LDAP DN of the DS object.
//              [pParentObj] - the invoking page's MMC data object pointer, can be NULL.
//              [hwndParent] - the invoking page's window handle.
//              [fReadOnly]  - defaults to FALSE.
//
//-----------------------------------------------------------------------------
HRESULT
PostADsPropSheet(PWSTR pwzObjDN, IDataObject * pParentObj, HWND hwndParent,
                 BOOL fReadOnly = FALSE);

#ifdef __cplusplus
}
#endif // __cplusplus

#endif // _DSPROPP_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\public\internal\ds\inc\dnsrpc.h ===
/*++

Copyright (c) 1995-2000  Microsoft Corporation

Module Name:

    dnsrpc.h

Abstract:

    Domain Name System (DNS) Server

    DNS Server RPC API to support admin clients.

Author:

    Jim Gilroy (jamesg)     September 1997

Revision History:

    jamesg      April 1997  --  Major revision for NT5

--*/


#ifndef _DNSRPC_INCLUDED_
#define _DNSRPC_INCLUDED_

#include <windns.h>

//
//  Do NOT include dnsapi.h if doing MIDL pass
//

#ifndef  MIDL_PASS
#include <dnsapi.h>
#include <dnslib.h>
#endif


#ifdef __cplusplus
extern "C"
{
#endif  // _cplusplus


//
//  Versioning scheme
//  -----------------
//
//  Every RPC structure has an old (W2K, non-version-numbered) version and
//  at least one new (Whistler and post Whistler) version. We will be adding
//  completely new copies of each structure as needed with every release.
//  The structure version numbers start at 1 and are independent of between
//  structures. Increment each structure's current version number as
//  required. Structure version do not have to change at product release
//  so we will not tie their versions to release versions.
//
//  New to Whistler, the client RPC APIs all take a version number. This is
//  the client version in terms of OS with a minor version number to identify
//  service packs or QFEs where necessary.
//

//
//  For each versioned RPC structure, define the structure's current version
//  and point the generic names of the structure at the current typedefs.
//

#define DNS_RPC_SERVER_INFO_VER         1
#define DNS_RPC_SERVER_INFO             DNS_RPC_SERVER_INFO_WHISTLER
#define PDNS_RPC_SERVER_INFO            PDNS_RPC_SERVER_INFO_WHISTLER

#define DNS_RPC_ZONE_VER                1
#define DNS_RPC_ZONE                    DNS_RPC_ZONE_WHISTLER
#define PDNS_RPC_ZONE                   PDNS_RPC_ZONE_WHISTLER

#define DNS_RPC_ZONE_LIST_VER           1
#define DNS_RPC_ZONE_LIST               DNS_RPC_ZONE_LIST_WHISTLER
#define PDNS_RPC_ZONE_LIST              PDNS_RPC_ZONE_LIST_WHISTLER

#define DNS_RPC_ZONE_INFO_VER           1
#define DNS_RPC_ZONE_INFO               DNS_RPC_ZONE_INFO_WHISTLER
#define PDNS_RPC_ZONE_INFO              PDNS_RPC_ZONE_INFO_WHISTLER

#define DNS_RPC_ZONE_CREATE_INFO_VER    1
#define DNS_RPC_ZONE_CREATE_INFO        DNS_RPC_ZONE_CREATE_INFO_WHISTLER
#define PDNS_RPC_ZONE_CREATE_INFO       PDNS_RPC_ZONE_CREATE_INFO_WHISTLER

#define DNS_RPC_FORWARDERS_VER          1
#define DNS_RPC_FORWARDERS              DNS_RPC_FORWARDERS_WHISTLER
#define PDNS_RPC_FORWARDERS             PDNS_RPC_FORWARDERS_WHISTLER

#define DNS_RPC_ZONE_SECONDARIES_VER    1
#define DNS_RPC_ZONE_SECONDARIES        DNS_RPC_ZONE_SECONDARIES_WHISTLER
#define PDNS_RPC_ZONE_SECONDARIES       PDNS_RPC_ZONE_SECONDARIES_WHISTLER

#define DNS_RPC_ZONE_DATABASE_VER       1
#define DNS_RPC_ZONE_DATABASE           DNS_RPC_ZONE_DATABASE_WHISTLER
#define PDNS_RPC_ZONE_DATABASE          PDNS_RPC_ZONE_DATABASE_WHISTLER

#define DNS_RPC_ZONE_TYPE_RESET_VER     1
#define DNS_RPC_ZONE_TYPE_RESET         DNS_RPC_ZONE_TYPE_RESET_WHISTLER
#define PDNS_RPC_ZONE_TYPE_RESET        PDNS_RPC_ZONE_TYPE_RESET_WHISTLER

#define DNS_RPC_ZONE_RENAME_INFO_VER    1

#define DNS_RPC_ZONE_EXPORT_INFO_VER    1

#define DNS_RPC_ENLIST_DP_VER           1

#define DNS_RPC_ZONE_CHANGE_DP_VER      1


#ifdef  MIDL_PASS
#ifndef _DNSAPI_INCLUDED_

//
//  NOTE:  DO NOT USE these IP definitions.
//
//  They are for backward compatibility only.
//  Use the definitions in windns.h instead.
//
//  Note, this same include is in dnsapi.h, so ONLY
//  include on MIDL_PASS which skips dnsapi.h
//  

//
//  IP Address
//

typedef IP4_ADDRESS  IP_ADDRESS, *PIP_ADDRESS;

//
//  IP Address Array type
//

typedef struct  _IP_ARRAY
{
    DWORD       AddrCount;
    [size_is( AddrCount )]  IP4_ADDRESS  AddrArray[];
}
IP_ARRAY, *PIP_ARRAY;

//
//  IPv6 Address
//

typedef IP6_ADDRESS     IPV6_ADDRESS, *PIPV6_ADDRESS;

#endif  // _DNSAPI_INCLUDED_
#endif  // MIDL_PASS



//
//  Use stdcall for our API conventions
//
//  Explicitly state this as C++ compiler will otherwise
//      assume cdecl.
//

#define DNS_API_FUNCTION    __stdcall

//
//  RPC interface
//

#define DNS_INTERFACE_NAME          "DNSSERVER"

//
//  RPC interface version
//

#define DNS_RPC_VERSION             (50)    // NT5

//
//  RPC security
//

#define DNS_RPC_SECURITY            "DnsServerApp"
#define DNS_RPC_SECURITY_AUTH_ID    RPC_C_AUTHN_WINNT

//
//  RPC transports
//

#define DNS_RPC_NAMED_PIPE_W        ( L"\\PIPE\\DNSSERVER" )
#define DNS_RPC_SERVER_PORT_W       ( L"" )
#define DNS_RPC_LPC_EP_W            ( L"DNSSERVERLPC" )

#define DNS_RPC_NAMED_PIPE_A        ( "\\PIPE\\DNSSERVER" )
#define DNS_RPC_SERVER_PORT_A       ( "" )
#define DNS_RPC_LPC_EP_A            ( "DNSSERVERLPC" )

#define DNS_RPC_USE_TCPIP           0x1
#define DNS_RPC_USE_NAMED_PIPE      0x2
#define DNS_RPC_USE_LPC             0x4
#define DNS_RPC_USE_ALL_PROTOCOLS   0xffffffff


//
//  Windows types we define only for MIDL_PASS
//

#ifdef  MIDL_PASS
#define LPSTR [string] char *
#define LPCSTR [string] const char *
#define LPWSTR [string] wchar_t *
#endif


//
//  RPC buffer type for returned data
//

typedef struct _DnssrvRpcBuffer
{
    DWORD                       dwLength;
#ifdef MIDL_PASS
    [size_is(dwLength)] BYTE    Buffer[];
#else
    BYTE                        Buffer[1];      // buffer of dwLength
#endif
}
DNS_RPC_BUFFER, *PDNS_RPC_BUFFER;



//
//  Server data types
//

//
//  Server Information
//

typedef struct _DnsRpcServerInfoW2K
{
    //  version
    //  basic configuration flags

    DWORD       dwVersion;
    UCHAR       fBootMethod;
    BOOLEAN     fAdminConfigured;
    BOOLEAN     fAllowUpdate;
    BOOLEAN     fDsAvailable;

    //
    //  pointer section
    //

    LPSTR       pszServerName;

    //  DS container

    LPWSTR      pszDsContainer;

    //  IP interfaces

    PIP_ARRAY   aipServerAddrs;
    PIP_ARRAY   aipListenAddrs;

    //  forwarders

    PIP_ARRAY   aipForwarders;

    //  future extensions

    PDWORD      pExtension1;
    PDWORD      pExtension2;
    PDWORD      pExtension3;
    PDWORD      pExtension4;
    PDWORD      pExtension5;

    //
    //  DWORD section
    //

    //  logging

    DWORD       dwLogLevel;
    DWORD       dwDebugLevel;

    //  configuration DWORDs

    DWORD       dwForwardTimeout;
    DWORD       dwRpcProtocol;
    DWORD       dwNameCheckFlag;
    DWORD       cAddressAnswerLimit;
    DWORD       dwRecursionRetry;
    DWORD       dwRecursionTimeout;
    DWORD       dwMaxCacheTtl;
    DWORD       dwDsPollingInterval;

    //  aging \ scavenging

    DWORD       dwScavengingInterval;
    DWORD       dwDefaultRefreshInterval;
    DWORD       dwDefaultNoRefreshInterval;

    DWORD       dwReserveArray[10];

    //
    //  BYTE section
    //
    //  configuration flags

    BOOLEAN     fAutoReverseZones;
    BOOLEAN     fAutoCacheUpdate;

    //  recursion control

    BOOLEAN     fSlave;
    BOOLEAN     fForwardDelegations;
    BOOLEAN     fNoRecursion;
    BOOLEAN     fSecureResponses;

    //  lookup control

    BOOLEAN     fRoundRobin;
    BOOLEAN     fLocalNetPriority;

    //  BIND compatibility and mimicing

    BOOLEAN     fBindSecondaries;
    BOOLEAN     fWriteAuthorityNs;

    //  Bells and whistles

    BOOLEAN     fStrictFileParsing;
    BOOLEAN     fLooseWildcarding;

    //  aging \ scavenging

    BOOLEAN     fDefaultAgingState;
    BOOLEAN     fReserveArray[15];
}
DNS_RPC_SERVER_INFO_W2K, *PDNS_RPC_SERVER_INFO_W2K;


typedef struct _DnsRpcServerInfoWhistler
{
    DWORD       dwRpcStuctureVersion;
    DWORD       dwReserved0;

    //  basic configuration flags

    DWORD       dwVersion;
    UCHAR       fBootMethod;
    BOOLEAN     fAdminConfigured;
    BOOLEAN     fAllowUpdate;
    BOOLEAN     fDsAvailable;

    //
    //  pointer section
    //

    LPSTR       pszServerName;

    //  DS container

    LPWSTR      pszDsContainer;

    //  IP interfaces

    PIP_ARRAY   aipServerAddrs;
    PIP_ARRAY   aipListenAddrs;

    //  forwarders

    PIP_ARRAY   aipForwarders;

    //  logging

    PIP_ARRAY   aipLogFilter;
    LPWSTR      pwszLogFilePath;

    //  Server domain/forest

    LPSTR       pszDomainName;          //  UTF-8 FQDN 
    LPSTR       pszForestName;          //  UTF-8 FQDN 

    //  Built-in directory partitions

    LPSTR       pszDomainDirectoryPartition;    //  UTF-8 FQDN 
    LPSTR       pszForestDirectoryPartition;    //  UTF-8 FQDN 

    //  future extensions

    LPSTR       pExtensions[ 6 ];

    //
    //  DWORD section
    //

    //  logging

    DWORD       dwLogLevel;
    DWORD       dwDebugLevel;

    //  configuration DWORDs

    DWORD       dwForwardTimeout;
    DWORD       dwRpcProtocol;
    DWORD       dwNameCheckFlag;
    DWORD       cAddressAnswerLimit;
    DWORD       dwRecursionRetry;
    DWORD       dwRecursionTimeout;
    DWORD       dwMaxCacheTtl;
    DWORD       dwDsPollingInterval;
    DWORD       dwLocalNetPriorityNetMask;

    //  aging and scavenging

    DWORD       dwScavengingInterval;
    DWORD       dwDefaultRefreshInterval;
    DWORD       dwDefaultNoRefreshInterval;
    DWORD       dwLastScavengeTime;

    //  more logging

    DWORD       dwEventLogLevel;
    DWORD       dwLogFileMaxSize;

    //  Active Directory information

    DWORD       dwAdForestVersion;
    DWORD       dwAdDomainVersion;
    DWORD       dwAdDsaVersion;

    DWORD       dwReserveArray[ 4 ];

    //
    //  BYTE section
    //
    //  configuration flags

    BOOLEAN     fAutoReverseZones;
    BOOLEAN     fAutoCacheUpdate;

    //  recursion control

    BOOLEAN     fSlave;
    BOOLEAN     fForwardDelegations;
    BOOLEAN     fNoRecursion;
    BOOLEAN     fSecureResponses;

    //  lookup control

    BOOLEAN     fRoundRobin;
    BOOLEAN     fLocalNetPriority;

    //  BIND compatibility and mimicing

    BOOLEAN     fBindSecondaries;
    BOOLEAN     fWriteAuthorityNs;

    //  Bells and whistles

    BOOLEAN     fStrictFileParsing;
    BOOLEAN     fLooseWildcarding;

    //  aging \ scavenging

    BOOLEAN     fDefaultAgingState;

    BOOLEAN     fReserveArray[ 15 ];
}
DNS_RPC_SERVER_INFO_WHISTLER, *PDNS_RPC_SERVER_INFO_WHISTLER;



typedef IP_ARRAY DNS_RPC_LISTEN_ADDRESSES, *PDNS_RPC_LISTEN_ADDRESSES;


typedef struct _DnssrvRpcForwardersW2K
{
    DWORD       fSlave;
    DWORD       dwForwardTimeout;
    PIP_ARRAY   aipForwarders;
}
DNS_RPC_FORWARDERS_W2K, *PDNS_RPC_FORWARDERS_W2K;


typedef struct _DnssrvRpcForwardersWhistler
{
    DWORD       dwRpcStuctureVersion;
    DWORD       dwReserved0;

    DWORD       fSlave;
    DWORD       dwForwardTimeout;
    PIP_ARRAY   aipForwarders;
}
DNS_RPC_FORWARDERS_WHISTLER, *PDNS_RPC_FORWARDERS_WHISTLER;



//
//  Server API
//

DNS_STATUS
DNS_API_FUNCTION
DnssrvGetServerInfo(
    IN      LPCWSTR                 pwszServer,
    OUT     PDNS_RPC_SERVER_INFO *  ppServerInfo
    );

VOID
DNS_API_FUNCTION
DnssrvFreeServerInfo(
    IN OUT  PDNS_RPC_SERVER_INFO    pServerInfo
    );

DNS_STATUS
DNS_API_FUNCTION
DnssrvResetServerDwordProperty(
    IN      LPCWSTR             pwszServer,
    IN      LPCSTR              pszProperty,
    IN      DWORD               dwPropertyValue
    );

DNS_STATUS
DNS_API_FUNCTION
DnssrvResetServerListenAddresses(
    IN      LPCWSTR             pwszServer,
    IN      DWORD               cListenAddrs,
    IN      PIP_ADDRESS         aipListenAddrs
    );

DNS_STATUS
DNS_API_FUNCTION
DnssrvResetForwarders(
    IN      LPCWSTR             pwszServer,
    IN      DWORD               cForwarders,
    IN      PIP_ADDRESS         aipForwarders,
    IN      DWORD               dwForwardTimeout,
    IN      DWORD               fSlave
    );

DNS_STATUS
DNS_API_FUNCTION
DnssrvWriteDirtyZones(
    IN      LPCWSTR             pwszServer
    );

VOID
DNS_API_FUNCTION
DnssrvFreeRpcBuffer(
    IN OUT  PDNS_RPC_BUFFER pBuf
    );

//
//  Create DS\LDAP paths to objects
//

LPWSTR
DNS_API_FUNCTION
DnssrvCreateDsNodeName(
    IN      PDNS_RPC_SERVER_INFO    pServerInfo,
    IN      LPWSTR                  pszZone,
    IN      LPWSTR                  pszNode
    );

LPWSTR
DNS_API_FUNCTION
DnssrvCreateDsZoneName(
    IN      PDNS_RPC_SERVER_INFO    pServerInfo,
    IN      LPWSTR                  pszZone
    );

LPWSTR
DNS_API_FUNCTION
DnssrvCreateDsServerName(
    IN      PDNS_RPC_SERVER_INFO    pServerInfo
    );



//
//  DNS server statistics
//

typedef struct  _DnsSystemTime
{
    WORD    wYear;
    WORD    wMonth;
    WORD    wDayOfWeek;
    WORD    wDay;
    WORD    wHour;
    WORD    wMinute;
    WORD    wSecond;
    WORD    wMilliseconds;
}
DNS_SYSTEMTIME;

//
//  Server run time stats
//  Each stat has header followed by stat data.
//

//  Stat header

typedef struct _DnsStatHeader
{
    DWORD       StatId;
    WORD        wLength;
    BOOLEAN     fClear;
    UCHAR       fReserved;
}
DNSSRV_STAT_HEADER, *PDNSSRV_STAT_HEADER;

//  Generic stat buffer

typedef struct _DnsStat
{
    DNSSRV_STAT_HEADER  Header;
    BYTE                Buffer[1];
}
DNSSRV_STAT, *PDNSSRV_STAT;

//  DCR_CLEANUP:  remove when marco in ssync

typedef DNSSRV_STAT     DNSSRV_STATS;
typedef PDNSSRV_STAT    PDNSSRV_STATS;

#define DNSSRV_STATS_HEADER_LENGTH  (2*sizeof(DWORD))

//  Total length of stats buffer

#define TOTAL_STAT_LENGTH( pStat ) \
            ( (pStat)->Header.wLength + sizeof(DNSSRV_STAT_HEADER) )

//  Stat buffer traversal macro, no side effects in argument

#define GET_NEXT_STAT_IN_BUFFER( pStat ) \
            ((PDNSSRV_STAT)( (PCHAR)(pStat) + TOTAL_STAT_LENGTH(pStat) ))


//
//  Stats that record type data
//      - ATMA plus room to grow, so don't have to
//      rebuild for any change
//      - use some dead types for mixed and unknown
//      cases
//

#define STATS_TYPE_MAX          (DNS_TYPE_ATMA+5)

#define STATS_TYPE_MIXED        (DNS_TYPE_MD)
#define STATS_TYPE_UNKNOWN      (DNS_TYPE_MF)


//
//  Specific stat data types
//

//
//  Time info
//

typedef struct _DnsTimeStats
{
    DNSSRV_STAT_HEADER  Header;

    DWORD   ServerStartTimeSeconds;
    DWORD   LastClearTimeSeconds;
    DWORD   SecondsSinceServerStart;
    DWORD   SecondsSinceLastClear;

    DNS_SYSTEMTIME  ServerStartTime;
    DNS_SYSTEMTIME  LastClearTime;
}
DNSSRV_TIME_STATS, *PDNSSRV_TIME_STATS;

//
//  Basic query and response stats
//

typedef struct _DnsQueryStats
{
    DNSSRV_STAT_HEADER  Header;

    DWORD   UdpQueries;
    DWORD   UdpResponses;
    DWORD   UdpQueriesSent;
    DWORD   UdpResponsesReceived;
    DWORD   TcpClientConnections;
    DWORD   TcpQueries;
    DWORD   TcpResponses;
    DWORD   TcpQueriesSent;
    DWORD   TcpResponsesReceived;
}
DNSSRV_QUERY_STATS, *PDNSSRV_QUERY_STATS;

typedef struct _DnsQuery2Stats
{
    DNSSRV_STAT_HEADER  Header;

    DWORD   TotalQueries;
    DWORD   Standard;
    DWORD   Notify;
    DWORD   Update;
    DWORD   TKeyNego;

    //  NOTE: the breakout counts are for STANDARD QUERIES!
    DWORD   TypeA;
    DWORD   TypeNs;
    DWORD   TypeSoa;
    DWORD   TypeMx;
    DWORD   TypePtr;
    DWORD   TypeSrv;
    DWORD   TypeAll;
    DWORD   TypeIxfr;
    DWORD   TypeAxfr;
    DWORD   TypeOther;
}
DNSSRV_QUERY2_STATS, *PDNSSRV_QUERY2_STATS;


//
//  Recursion stats
//

typedef struct _DnsRecurseStats
{
    DNSSRV_STAT_HEADER  Header;

    DWORD   ReferralPasses;
    DWORD   QueriesRecursed;
    DWORD   OriginalQuestionRecursed;
    DWORD   AdditionalRecursed;
    DWORD   TotalQuestionsRecursed;
    DWORD   Retries;
    DWORD   LookupPasses;
    DWORD   Forwards;
    DWORD   Sends;

    DWORD   Responses;
    DWORD   ResponseUnmatched;
    DWORD   ResponseMismatched;
    DWORD   ResponseFromForwarder;
    DWORD   ResponseAuthoritative;
    DWORD   ResponseNotAuth;
    DWORD   ResponseAnswer;
    DWORD   ResponseNameError;
    DWORD   ResponseRcode;
    DWORD   ResponseEmpty;
    DWORD   ResponseDelegation;
    DWORD   ResponseNonZoneData;
    DWORD   ResponseUnsecure;
    DWORD   ResponseBadPacket;

    DWORD   SendResponseDirect;
    DWORD   ContinueCurrentRecursion;
    DWORD   ContinueCurrentLookup;
    DWORD   ContinueNextLookup;

    DWORD   RootNsQuery;
    DWORD   RootNsResponse;
    DWORD   CacheUpdateAlloc;
    DWORD   CacheUpdateResponse;
    DWORD   CacheUpdateFree;
    DWORD   CacheUpdateRetry;
    DWORD   SuspendedQuery;
    DWORD   ResumeSuspendedQuery;

    DWORD   PacketTimeout;
    DWORD   FinalTimeoutQueued;
    DWORD   FinalTimeoutExpired;

    DWORD   Failures;
    DWORD   RecursionFailure;
    DWORD   ServerFailure;
    DWORD   PartialFailure;
    DWORD   CacheUpdateFailure;

    DWORD   RecursePassFailure;
    DWORD   FailureReachAuthority;
    DWORD   FailureReachPreviousResponse;
    DWORD   FailureRetryCount;

    DWORD   TcpTry;
    DWORD   TcpConnectFailure;
    DWORD   TcpConnect;
    DWORD   TcpQuery;
    DWORD   TcpResponse;
    DWORD   TcpDisconnect;

    DWORD   DiscardedDuplicateQueries;
}
DNSSRV_RECURSE_STATS, *PDNSSRV_RECURSE_STATS;

//
//  Master stats
//
//  Masters stats changed post-NT5 for stub zones
//

typedef struct _DnsMasterStats
{
    DNSSRV_STAT_HEADER  Header;

    DWORD   NotifySent;

    DWORD   Request;
    DWORD   NameError;
    DWORD   FormError;
    DWORD   AxfrLimit;
    DWORD   Refused;
    DWORD   RefuseSecurity;
    DWORD   RefuseShutdown;
    DWORD   RefuseZoneLocked;
    DWORD   RefuseServerFailure;
    DWORD   Failure;

    DWORD   AxfrRequest;
    DWORD   AxfrSuccess;

    DWORD   StubAxfrRequest;

    DWORD   IxfrRequest;
    DWORD   IxfrNoVersion;
    DWORD   IxfrUpdateSuccess;
    DWORD   IxfrTcpRequest;
    DWORD   IxfrTcpSuccess;
    DWORD   IxfrAxfr;
    DWORD   IxfrUdpRequest;
    DWORD   IxfrUdpSuccess;
    DWORD   IxfrUdpForceTcp;
    DWORD   IxfrUdpForceAxfr;
}
DNSSRV_MASTER_STATS, *PDNSSRV_MASTER_STATS;

//
//  Secondary stats
//
//  Secondary stats changed post-NT5 for stub zones
//

typedef struct _DnsSecondaryStats
{
    DNSSRV_STAT_HEADER  Header;

    DWORD   NotifyReceived;
    DWORD   NotifyInvalid;
    DWORD   NotifyPrimary;
    DWORD   NotifyNonPrimary;
    DWORD   NotifyNoVersion;
    DWORD   NotifyNewVersion;
    DWORD   NotifyCurrentVersion;
    DWORD   NotifyOldVersion;
    DWORD   NotifyMasterUnknown;

    DWORD   SoaRequest;
    DWORD   SoaResponse;
    DWORD   SoaResponseInvalid;
    DWORD   SoaResponseNameError;

    DWORD   AxfrRequest;
    DWORD   AxfrResponse;
    DWORD   AxfrSuccess;
    DWORD   AxfrRefused;
    DWORD   AxfrInvalid;

    DWORD   StubAxfrRequest;
    DWORD   StubAxfrResponse;
    DWORD   StubAxfrSuccess;
    DWORD   StubAxfrRefused;
    DWORD   StubAxfrInvalid;

    DWORD   IxfrUdpRequest;
    DWORD   IxfrUdpResponse;
    DWORD   IxfrUdpSuccess;
    DWORD   IxfrUdpUseTcp;
    DWORD   IxfrUdpUseAxfr;
    DWORD   IxfrUdpWrongServer;
    DWORD   IxfrUdpNoUpdate;
    DWORD   IxfrUdpNewPrimary;
    DWORD   IxfrUdpFormerr;
    DWORD   IxfrUdpRefused;
    DWORD   IxfrUdpInvalid;

    DWORD   IxfrTcpRequest;
    DWORD   IxfrTcpResponse;
    DWORD   IxfrTcpSuccess;
    DWORD   IxfrTcpAxfr;
    DWORD   IxfrTcpFormerr;
    DWORD   IxfrTcpRefused;
    DWORD   IxfrTcpInvalid;
}
DNSSRV_SECONDARY_STATS, *PDNSSRV_SECONDARY_STATS;


//
//  WINS lookup
//

typedef struct _DnsWinsStats
{
    DNSSRV_STAT_HEADER  Header;

    DWORD   WinsLookups;
    DWORD   WinsResponses;
    DWORD   WinsReverseLookups;
    DWORD   WinsReverseResponses;
}
DNSSRV_WINS_STATS, *PDNSSRV_WINS_STATS;

//
//  Dynamic Update Stats
//

typedef struct _DnsUpdateStats
{
    DNSSRV_STAT_HEADER  Header;

    DWORD   Received;
    DWORD   Empty;
    DWORD   NoOps;
    DWORD   Completed;

    DWORD   Rejected;
    DWORD   FormErr;
    DWORD   NxDomain;
    DWORD   NotImpl;
    DWORD   Refused;
    DWORD   YxDomain;
    DWORD   YxRrset;
    DWORD   NxRrset;
    DWORD   NotAuth;
    DWORD   NotZone;

    DWORD   RefusedNonSecure;
    DWORD   RefusedAccessDenied;

    DWORD   SecureSuccess;
    DWORD   SecureContinue;
    DWORD   SecureFailure;
    DWORD   SecureDsWriteFailure;

    DWORD   DsSuccess;
    DWORD   DsWriteFailure;

    DWORD   unused_was_Collisions;
    DWORD   unused_was_CollisionsRead;
    DWORD   unused_was_CollisionsWrite;
    DWORD   unused_was_CollisionsDsWrite;

    DWORD   Queued;
    DWORD   Retry;
    DWORD   Timeout;
    DWORD   InQueue;

    DWORD   Forwards;
    DWORD   TcpForwards;
    DWORD   ForwardResponses;
    DWORD   ForwardTimeouts;
    DWORD   ForwardInQueue;

    DWORD   UpdateType[ STATS_TYPE_MAX+1 ];
}
DNSSRV_UPDATE_STATS, *PDNSSRV_UPDATE_STATS;


typedef struct _DnsSkwansecStats
{
    DNSSRV_STAT_HEADER  Header;

    DWORD   SecContextCreate;
    DWORD   SecContextFree;
    DWORD   SecContextQueue;
    DWORD   SecContextQueueInNego;
    DWORD   SecContextQueueNegoComplete;
    DWORD   SecContextQueueLength;
    DWORD   SecContextDequeue;
    DWORD   SecContextTimeout;

    DWORD   SecPackAlloc;
    DWORD   SecPackFree;

    DWORD   SecTkeyInvalid;
    DWORD   SecTkeyBadTime;
    DWORD   SecTsigFormerr;
    DWORD   SecTsigEcho;
    DWORD   SecTsigBadKey;
    DWORD   SecTsigVerifySuccess;
    DWORD   SecTsigVerifyFailed;
}
DNSSRV_SKWANSEC_STATS, *PDNSSRV_SKWANSEC_STATS;

//
//  DS Integration Stats
//

typedef struct _DnsDsStats
{
    DNSSRV_STAT_HEADER  Header;

    DWORD   DsTotalNodesRead;
    DWORD   DsTotalRecordsRead;
    DWORD   DsNodesLoaded;
    DWORD   DsRecordsLoaded;
    DWORD   DsTombstonesRead;

    DWORD   DsUpdateSearches;
    DWORD   DsUpdateNodesRead;
    DWORD   DsUpdateRecordsRead;

    //  Update writes

    DWORD   UpdateLists;
    DWORD   UpdateNodes;
    DWORD   UpdateSuppressed;
    DWORD   UpdateWrites;
    DWORD   UpdateTombstones;
    DWORD   UpdateRecordChange;
    DWORD   UpdateAgingRefresh;
    DWORD   UpdateAgingOn;
    DWORD   UpdateAgingOff;
    DWORD   UpdatePacket;
    DWORD   UpdatePacketPrecon;
    DWORD   UpdateAdmin;
    DWORD   UpdateAutoConfig;
    DWORD   UpdateScavenge;

    //  DS writes

    DWORD   DsNodesAdded;
    DWORD   DsNodesModified;
    DWORD   DsNodesTombstoned;
    DWORD   DsNodesDeleted;
    DWORD   DsRecordsAdded;
    DWORD   DsRecordsReplaced;
    DWORD   DsWriteSuppressed;
    DWORD   DsSerialWrites;

    //  Time stats in ldap calls

    DWORD   LdapTimedWrites;
    DWORD   LdapWriteTimeTotal;
    DWORD   LdapWriteAverage;
    DWORD   LdapWriteMax;
    DWORD   LdapWriteBucket0;
    DWORD   LdapWriteBucket1;
    DWORD   LdapWriteBucket2;
    DWORD   LdapWriteBucket3;
    DWORD   LdapWriteBucket4;
    DWORD   LdapWriteBucket5;

    DWORD   LdapSearchTime;

    //  Failures

    DWORD   FailedDeleteDsEntries;
    DWORD   FailedReadRecords;
    DWORD   FailedLdapModify;
    DWORD   FailedLdapAdd;

    //  Polling stats

    DWORD   PollingPassesWithDsErrors;

    //  DS Write Stats

    DWORD   DsWriteType[ STATS_TYPE_MAX+1 ];
}
DNSSRV_DS_STATS, *PDNSSRV_DS_STATS;


//
//  Memory stats
//
//  Note, memory stats have been added since NT5 ship
//  so maintain NT5 and current memory stats with
//  separate IDs.  See next section for NT5 memory stats
//

//
//  Memory Tags -- post NT5 ordering
//

#define MEMTAG_CURRENT_VERSION      (5)

#define MEMTAG_NONE         0
#define MEMTAG_PACKET_UDP   1
#define MEMTAG_PACKET_TCP   2
#define MEMTAG_NAME         3
#define MEMTAG_ZONE         4
#define MEMTAG_UPDATE       5
#define MEMTAG_UPDATE_LIST  6
#define MEMTAG_TIMEOUT      7
#define MEMTAG_NODEHASH     8
#define MEMTAG_DS_DN        9
#define MEMTAG_DS_MOD       10
#define MEMTAG_DS_RECORD    11
#define MEMTAG_DS_OTHER     12
#define MEMTAG_THREAD       13
#define MEMTAG_NBSTAT       14
#define MEMTAG_DNSLIB       15
#define MEMTAG_TABLE        16
#define MEMTAG_SOCKET       17
#define MEMTAG_CONNECTION   18
#define MEMTAG_REGISTRY     19
#define MEMTAG_RPC          20
#define MEMTAG_STUFF        21
#define MEMTAG_FILEBUF      22
#define MEMTAG_REMOTE       23
#define MEMTAG_EVTCTRL      24
#define MEMTAG_SAFE         25

//
//  Record and Node sources
//

#define SRCTAG_UNKNOWN      (0)
#define SRCTAG_FILE         (1)
#define SRCTAG_DS           (2)
#define SRCTAG_AXFR         (3)
#define SRCTAG_IXFR         (4)
#define SRCTAG_DYNUP        (5)
#define SRCTAG_ADMIN        (6)
#define SRCTAG_AUTO         (7)
#define SRCTAG_CACHE        (8)
#define SRCTAG_NOEXIST      (9)
#define SRCTAG_WINS         (10)
#define SRCTAG_WINSPTR      (11)
#define SRCTAG_COPY         (12)

#define SRCTAG_MAX          (SRCTAG_COPY)       //  12

//
//  Record tags
//
//  Start after last memtag.
//  Use source tags to index off of MEMTAG_RECORD base.
//

#define MEMTAG_RECORD_BASE      (MEMTAG_SAFE+1)                     //  25
#define MEMTAG_RECORD           (MEMTAG_RECORD_BASE)                //  25
#define MEMTAG_RECORD_UNKNOWN   (MEMTAG_RECORD + SRCTAG_UNKNOWN )   //  25
#define MEMTAG_RECORD_FILE      (MEMTAG_RECORD + SRCTAG_FILE    )   //  26
#define MEMTAG_RECORD_DS        (MEMTAG_RECORD + SRCTAG_DS      )
#define MEMTAG_RECORD_AXFR      (MEMTAG_RECORD + SRCTAG_AXFR    )
#define MEMTAG_RECORD_IXFR      (MEMTAG_RECORD + SRCTAG_IXFR    )
#define MEMTAG_RECORD_DYNUP     (MEMTAG_RECORD + SRCTAG_DYNUP   )   //  30
#define MEMTAG_RECORD_ADMIN     (MEMTAG_RECORD + SRCTAG_ADMIN   )
#define MEMTAG_RECORD_AUTO      (MEMTAG_RECORD + SRCTAG_AUTO    )
#define MEMTAG_RECORD_CACHE     (MEMTAG_RECORD + SRCTAG_CACHE   )
#define MEMTAG_RECORD_NOEXIST   (MEMTAG_RECORD + SRCTAG_NOEXIST )
#define MEMTAG_RECORD_WINS      (MEMTAG_RECORD + SRCTAG_WINS    )   //  35
#define MEMTAG_RECORD_WINSPTR   (MEMTAG_RECORD + SRCTAG_WINSPTR )
#define MEMTAG_RECORD_COPY      (MEMTAG_RECORD + SRCTAG_COPY    )   //  37

#define MEMTAG_RECORD_MAX       MEMTAG_RECORD_COPY                  //  38

//
//  Node tags
//

#define MEMTAG_NODE             (MEMTAG_RECORD_MAX + 1)             //  39
#define MEMTAG_NODE_UNKNOWN     (MEMTAG_NODE + SRCTAG_UNKNOWN   )   //  39
#define MEMTAG_NODE_FILE        (MEMTAG_NODE + SRCTAG_FILE      )   //  40
#define MEMTAG_NODE_DS          (MEMTAG_NODE + SRCTAG_DS        )
#define MEMTAG_NODE_AXFR        (MEMTAG_NODE + SRCTAG_AXFR      )
#define MEMTAG_NODE_IXFR        (MEMTAG_NODE + SRCTAG_IXFR      )
#define MEMTAG_NODE_DYNUP       (MEMTAG_NODE + SRCTAG_DYNUP     )
#define MEMTAG_NODE_ADMIN       (MEMTAG_NODE + SRCTAG_ADMIN     )   //  45
#define MEMTAG_NODE_AUTO        (MEMTAG_NODE + SRCTAG_AUTO      )
#define MEMTAG_NODE_CACHE       (MEMTAG_NODE + SRCTAG_CACHE     )
#define MEMTAG_NODE_NOEXIST     (MEMTAG_NODE + SRCTAG_NOEXIST   )
#define MEMTAG_NODE_WINS        (MEMTAG_NODE + SRCTAG_WINS      )
#define MEMTAG_NODE_WINSPTR     (MEMTAG_NODE + SRCTAG_WINSPTR   )   //  50
#define MEMTAG_NODE_COPY        (MEMTAG_NODE + SRCTAG_COPY      )   //  51

#define MEMTAG_NODE_MAX         MEMTAG_NODE_COPY                    //  51

//  Final MemTag values

#define MEMTAG_MAX              MEMTAG_NODE_MAX                     //  51
#define MEMTAG_COUNT            (MEMTAG_MAX+1)                      //  52


//
//  Memory Tag Names
//
//  Note:  DNS client print module (print.c) keeps memtag name table
//      based on these #defines;  that table MUST be kept in same
//      order as actual memtag indexes for printing to be accurate
//

#define MEMTAG_NAME_NONE            ("None")
#define MEMTAG_NAME_PACKET_UDP      ("UDP Packet")
#define MEMTAG_NAME_PACKET_TCP      ("TCP Packet")
#define MEMTAG_NAME_NAME            ("Name")
#define MEMTAG_NAME_ZONE            ("Zone")
#define MEMTAG_NAME_UPDATE          ("Update")
#define MEMTAG_NAME_UPDATE_LIST     ("Update List")
#define MEMTAG_NAME_TIMEOUT         ("Timeout")
#define MEMTAG_NAME_NODEHASH        ("Node Hash")
#define MEMTAG_NAME_DS_DN           ("DS DN")
#define MEMTAG_NAME_DS_MOD          ("DS Mod")
#define MEMTAG_NAME_DS_RECORD       ("DS Record")
#define MEMTAG_NAME_DS_OTHER        ("DS Other")
#define MEMTAG_NAME_THREAD          ("Thread")
#define MEMTAG_NAME_NBSTAT          ("Nbstat")
#define MEMTAG_NAME_DNSLIB          ("DnsLib")
#define MEMTAG_NAME_TABLE           ("Table")
#define MEMTAG_NAME_SOCKET          ("Socket")
#define MEMTAG_NAME_CONNECTION      ("TCP Connection")
#define MEMTAG_NAME_REGISTRY        ("Registry")
#define MEMTAG_NAME_RPC             ("RPC")
#define MEMTAG_NAME_STUFF           ("Stuff")
#define MEMTAG_NAME_FILEBUF         ("File Buffer")
#define MEMTAG_NAME_REMOTE          ("Remote IP")
#define MEMTAG_NAME_EVTCTRL         ("Event Control")
#define MEMTAG_NAME_SAFE            ("Safe")

#define MEMTAG_NAME_RECORD          ("Record")
#define MEMTAG_NAME_RECORD_FILE     ("RR File")
#define MEMTAG_NAME_RECORD_DS       ("RR DS")
#define MEMTAG_NAME_RECORD_AXFR     ("RR AXFR")
#define MEMTAG_NAME_RECORD_IXFR     ("RR IXFR")
#define MEMTAG_NAME_RECORD_DYNUP    ("RR Update")
#define MEMTAG_NAME_RECORD_ADMIN    ("RR Admin")
#define MEMTAG_NAME_RECORD_AUTO     ("RR Auto")
#define MEMTAG_NAME_RECORD_CACHE    ("RR Cache")
#define MEMTAG_NAME_RECORD_NOEXIST  ("RR NoExist")
#define MEMTAG_NAME_RECORD_WINS     ("RR WINS")
#define MEMTAG_NAME_RECORD_WINSPTR  ("RR WINS-PTR")
#define MEMTAG_NAME_RECORD_COPY     ("RR Copy")

#define MEMTAG_NAME_NODE            ("Node")
#define MEMTAG_NAME_NODE_FILE       ("Node File")
#define MEMTAG_NAME_NODE_DS         ("Node DS")
#define MEMTAG_NAME_NODE_AXFR       ("Node AXFR")
#define MEMTAG_NAME_NODE_IXFR       ("Node IXFR")
#define MEMTAG_NAME_NODE_DYNUP      ("Node Update")
#define MEMTAG_NAME_NODE_ADMIN      ("Node Admin")
#define MEMTAG_NAME_NODE_AUTO       ("Node Auto")
#define MEMTAG_NAME_NODE_CACHE      ("Node Cache")
#define MEMTAG_NAME_NODE_NOEXIST    ("Node NoExist")
#define MEMTAG_NAME_NODE_WINS       ("Node WINS")
#define MEMTAG_NAME_NODE_WINSPTR    ("Node WINS-PTR")
#define MEMTAG_NAME_NODE_COPY       ("Node Copy")


//  Individual memory counter

typedef struct _DnsMemoryTagStats
{
    DWORD   Alloc;
    DWORD   Free;
    DWORD   Memory;
}
MEMTAG_STATS, *PMEMTAG_STATS;


//  Memory stat block

typedef struct _DnsMemoryStats
{
    DNSSRV_STAT_HEADER  Header;

    DWORD   Memory;
    DWORD   Alloc;
    DWORD   Free;

    DWORD   StdUsed;
    DWORD   StdReturn;
    DWORD   StdInUse;
    DWORD   StdMemory;

    DWORD   StdToHeapAlloc;
    DWORD   StdToHeapFree;
    DWORD   StdToHeapInUse;
    DWORD   StdToHeapMemory;

    DWORD   StdBlockAlloc;
    DWORD   StdBlockUsed;
    DWORD   StdBlockReturn;
    DWORD   StdBlockInUse;
    DWORD   StdBlockFreeList;
    DWORD   StdBlockFreeListMemory;
    DWORD   StdBlockMemory;

    MEMTAG_STATS    MemTags[ MEMTAG_COUNT ];
}
DNSSRV_MEMORY_STATS, *PDNSSRV_MEMORY_STATS;


//
//  Packet stats
//

typedef struct _DnsPacketStats
{
    DNSSRV_STAT_HEADER  Header;

    DWORD   UdpAlloc;
    DWORD   UdpFree;
    DWORD   UdpNetAllocs;
    DWORD   UdpMemory;

    DWORD   UdpUsed;
    DWORD   UdpReturn;
    DWORD   UdpResponseReturn;
    DWORD   UdpQueryReturn;
    DWORD   UdpInUse;
    DWORD   UdpInFreeList;

    DWORD   TcpAlloc;
    DWORD   TcpRealloc;
    DWORD   TcpFree;
    DWORD   TcpNetAllocs;
    DWORD   TcpMemory;

    DWORD   RecursePacketUsed;
    DWORD   RecursePacketReturn;

    DWORD   UdpPacketsForNsListUsed;
    DWORD   UdpPacketsForNsListReturned;
    DWORD   UdpPacketsForNsListInUse;
}
DNSSRV_PACKET_STATS, *PDNSSRV_PACKET_STATS;

//
//  Timeout stats
//

typedef struct _DnsTimeoutStats
{
    DNSSRV_STAT_HEADER  Header;

    DWORD   SetTotal;
    DWORD   SetDirect;
    DWORD   SetFromDereference;
    DWORD   SetFromChildDelete;
    DWORD   AlreadyInSystem;

    DWORD   Checks;
    DWORD   RecentAccess;
    DWORD   ActiveRecord;
    DWORD   CanNotDelete;
    DWORD   Deleted;

    DWORD   ArrayBlocksCreated;
    DWORD   ArrayBlocksDeleted;

    DWORD   DelayedFreesQueued;
    DWORD   DelayedFreesQueuedWithFunction;
    DWORD   DelayedFreesExecuted;
    DWORD   DelayedFreesExecutedWithFunction;
}
DNSSRV_TIMEOUT_STATS, *PDNSSRV_TIMEOUT_STATS;

//
//  Database Stats
//

typedef struct _DnsDbaseStats
{
    DNSSRV_STAT_HEADER  Header;

    DWORD   NodeMemory;
    DWORD   NodeInUse;
    DWORD   NodeUsed;
    DWORD   NodeReturn;
}
DNSSRV_DBASE_STATS, *PDNSSRV_DBASE_STATS;

//
//  Record stats
//
//  DCR:  add type info (inc name error)
//

typedef struct _DnsRecordStats
{
    DNSSRV_STAT_HEADER  Header;

    DWORD   InUse;
    DWORD   Used;
    DWORD   Return;
    DWORD   Memory;

    DWORD   CacheTotal;
    DWORD   CacheCurrent;
    DWORD   CacheTimeouts;

    DWORD   SlowFreeQueued;
    DWORD   SlowFreeFinished;
}
DNSSRV_RECORD_STATS, *PDNSSRV_RECORD_STATS;

//
//  Nbstat memory stats
//

typedef struct _DnsNbstatStats
{
    DNSSRV_STAT_HEADER  Header;

    DWORD   NbstatAlloc;
    DWORD   NbstatFree;
    DWORD   NbstatNetAllocs;
    DWORD   NbstatMemory;

    DWORD   NbstatUsed;
    DWORD   NbstatReturn;
    DWORD   NbstatInUse;
    DWORD   NbstatInFreeList;
}
DNSSRV_NBSTAT_STATS, *PDNSSRV_NBSTAT_STATS;

//
//  Private stats
//

//
//  Private stats
//

typedef struct _DnsPrivateStats
{
    DNSSRV_STAT_HEADER  Header;

    DWORD   RecordFile;
    DWORD   RecordFileFree;
    DWORD   RecordDs;
    DWORD   RecordDsFree;
    DWORD   RecordAdmin;
    DWORD   RecordAdminFree;
    DWORD   RecordDynUp;
    DWORD   RecordDynUpFree;
    DWORD   RecordAxfr;
    DWORD   RecordAxfrFree;
    DWORD   RecordIxfr;
    DWORD   RecordIxfrFree;
    DWORD   RecordCopy;
    DWORD   RecordCopyFree;
    DWORD   RecordCache;
    DWORD   RecordCacheFree;

    DWORD   UdpSocketPnpDelete;
    DWORD   UdpRecvFailure;
    DWORD   UdpErrorMessageSize;
    DWORD   UdpConnResets;
    DWORD   UdpConnResetRetryOverflow;
    DWORD   UdpGQCSFailure;
    DWORD   UdpGQCSFailureWithContext;
    DWORD   UdpGQCSConnReset;

    DWORD   UdpIndicateRecvFailures;
    DWORD   UdpRestartRecvOnSockets;

    DWORD   TcpConnectAttempt;
    DWORD   TcpConnectFailure;
    DWORD   TcpConnect;
    DWORD   TcpQuery;
    DWORD   TcpDisconnect;

    DWORD   SecTsigVerifyOldSig;
    DWORD   SecTsigVerifyOldFailed;
    DWORD   SecBigTimeSkewBypass;

    DWORD   ZoneLoadInit;
    DWORD   ZoneLoadComplete;
    DWORD   ZoneDbaseDelete;
    DWORD   ZoneDbaseDelayedDelete;
}
DNSSRV_PRIVATE_STATS, *PDNSSRV_PRIVATE_STATS;


//
//  Private stats -- post NT5
//
//  We should dump a bunch of private stats and add
//  others -- but not there yet.
//

#if 0
typedef struct _DnsPrivateStats
{
    DNSSRV_STAT_HEADER  Header;

    DWORD   UdpSocketPnpDelete;
    DWORD   UdpRecvFailure;
    DWORD   UdpErrorMessageSize;
    DWORD   UdpConnResets;
    DWORD   UdpConnResetRetryOverflow;
    DWORD   UdpGQCSFailure;
    DWORD   UdpGQCSFailureWithContext;
    DWORD   UdpGQCSConnReset;

    DWORD   UdpIndicateRecvFailures;
    DWORD   UdpRestartRecvOnSockets;

    DWORD   TcpConnectAttempt;
    DWORD   TcpConnectFailure;
    DWORD   TcpConnect;
    DWORD   TcpQuery;
    DWORD   TcpDisconnect;

    DWORD   SecTsigVerifyOldSig;
    DWORD   SecTsigVerifyOldFailed;
    DWORD   SecBigTimeSkewBypass;

    DWORD   ZoneLoadInit;
    DWORD   ZoneLoadComplete;
    DWORD   ZoneDbaseDelete;
    DWORD   ZoneDbaseDelayedDelete;
}
DNSSRV_PRIVATE_STATS, *PDNSSRV_PRIVATE_STATS;
#endif


//
//  Discontinued
//

typedef struct _DnsXfrStats
{
    DNSSRV_STAT_HEADER  Header;

    DWORD   SecSoaQueries;
    DWORD   SecSoaResponses;
    DWORD   SecNotifyReceived;
    DWORD   SecAxfrRequested;
    DWORD   SecAxfrRejected;
    DWORD   SecAxfrFailed;
    DWORD   SecAxfrSuccessful;

    DWORD   MasterNotifySent;
    DWORD   MasterAxfrReceived;
    DWORD   MasterAxfrInvalid;
    DWORD   MasterAxfrRefused;
    DWORD   MasterAxfrDenied;
    DWORD   MasterAxfrFailed;
    DWORD   MasterAxfrSuccessful;
}
DNSSRV_XFR_STATS, *PDNSSRV_XFR_STATS;


typedef struct _ErrorStats
{
    DNSSRV_STAT_HEADER  Header;

    DWORD NoError;
    DWORD FormError;
    DWORD ServFail;
    DWORD NxDomain;
    DWORD NotImpl;
    DWORD Refused;
    DWORD YxDomain;
    DWORD YxRRSet;
    DWORD NxRRSet;
    DWORD NotAuth;
    DWORD NotZone;
    DWORD Max;
    DWORD BadSig;
    DWORD BadKey;
    DWORD BadTime;
    DWORD UnknownError;
}
DNSSRV_ERROR_STATS, *PDNSSRV_ERROR_STATS;


//
//  Cache stats - new for Whistler
//

typedef struct _DnsCacheStats
{
    DNSSRV_STAT_HEADER  Header;

    DWORD   CacheExceededLimitChecks;
    DWORD   SuccessfulFreePasses;
    DWORD   FailedFreePasses;
    DWORD   PassesWithNoFrees;
    DWORD   PassesRequiringAggressiveFree;
}
DNSSRV_CACHE_STATS, *PDNSSRV_CACHE_STATS;


//
//  Stat IDs
//      - request all stats by sending (-1)
//
//  Stat Versioning
//  Policy on stat versioning will be to use the top byte
//  of the statid as a version field which rolls on individual
//  release.  In general we should probably try to keep this
//  in ssync across stats from a particular release to allow
//  at some point to make decisions based on the stat id.
//  May want to rejigger IDs -- compact ongoing ones at bottom.
//
//  Note:  obviously i'm abandoning the original idea of bit
//  field ids and allowing mask in stat request, as we'd quickly
//  exhaust stat store.  This change has already been made in
//  dnscmd.exe documentation.
//

#define DNSSRV_STATID_TIME              (0x00000001)
#define DNSSRV_STATID_QUERY             (0x00000002)
#define DNSSRV_STATID_QUERY2            (0x00000004)
#define DNSSRV_STATID_RECURSE           (0x00000008)
#define DNSSRV_STATID_MASTER            (0x01000010)
#define DNSSRV_STATID_SECONDARY         (0x01000020)
#define DNSSRV_STATID_WINS              (0x00000040)
#define DNSSRV_STATID_WIRE_UPDATE       (0x00000100)
#define DNSSRV_STATID_SKWANSEC          (0x00000200)
#define DNSSRV_STATID_DS                (0x00000400)
#define DNSSRV_STATID_NONWIRE_UPDATE    (0x00000800)
#define DNSSRV_STATID_MEMORY            (0x01010000)
#define DNSSRV_STATID_TIMEOUT           (0x00020000)
#define DNSSRV_STATID_DBASE             (0x00040000)
#define DNSSRV_STATID_RECORD            (0x00080000)
#define DNSSRV_STATID_PACKET            (0x00100000)
#define DNSSRV_STATID_NBSTAT            (0x00200000)
#define DNSSRV_STATID_ERRORS            (0x00400000)
#define DNSSRV_STATID_CACHE             (0x00800000)
#define DNSSRV_STATID_PRIVATE           (0x10000000)

#define DNSSRV_STATID_ALL               (0xffffffff)



//
//  Statistics API
//

DNS_STATUS
DNS_API_FUNCTION
DnssrvGetStatistics(
    IN      LPCWSTR             pwszServer,
    IN      DWORD               dwFilter,
    OUT     PDNS_RPC_BUFFER *   ppStatsBuffer
    );

DNS_STATUS
DNS_API_FUNCTION
DnssrvClearStatistics(
    IN      LPCWSTR             pwszServer
    );

PDNSSRV_STAT
DNS_API_FUNCTION
DnssrvFindStatisticsInBuffer(
    IN      PDNS_RPC_BUFFER     pBuffer,
    IN      DWORD               StatId
    );

#define DnssrvFreeStatisticsBuffer( pBuf ) \
        DnssrvFreeRpcBuffer( (PDNS_RPC_BUFFER)pBuf )

DNS_STATUS
DNS_API_FUNCTION
DnssrvValidityCheckStatistic(
    IN      PDNSSRV_STAT        pStat
    );



//
//  Server information
//

//  Auto create delegations (ACD) settings

#define DNS_ACD_DONT_CREATE                             0
#define DNS_ACD_ALWAYS_CREATE                           1
#define DNS_ACD_ONLY_IF_NO_DELEGATION_IN_PARENT         2

//  EnableDnsSec values

#define DNS_DNSSEC_DISABLED                 0
#define DNS_DNSSEC_ENABLED_IF_EDNS          1
#define DNS_DNSSEC_ENABLED_ALWAYS           2

//  LocalNetPriorityNetMask values
//  ZERO: sort by closest match down to the last bit
//  ALL ONES: sort by closest match down to the network class default subnet mask
//  OTHER: sort down to this netmask - e.g. 0xFF means sort down the class C

#define DNS_LOCNETPRI_MASK_BEST_MATCH       0
#define DNS_LOCNETPRI_MASK_CLASS_DEFAULT    0xFFFFFFFF



//
//  Zone information
//

//  Zone types

#define DNS_ZONE_TYPE_CACHE     (0)
#define DNS_ZONE_TYPE_PRIMARY   (1)
#define DNS_ZONE_TYPE_SECONDARY (2)
#define DNS_ZONE_TYPE_STUB      (3)     // specialized form of SECONDARY
#define DNS_ZONE_TYPE_FORWARDER (4)     // another specialized zone type

//  Zone request filters

#define ZONE_REQUEST_PRIMARY            0x00000001
#define ZONE_REQUEST_SECONDARY          0x00000002
#define ZONE_REQUEST_CACHE              0x00000004
#define ZONE_REQUEST_AUTO               0x00000008
#define ZONE_REQUEST_FORWARD            0x00000010
#define ZONE_REQUEST_REVERSE            0x00000020
#define ZONE_REQUEST_FORWARDER          0x00000040
#define ZONE_REQUEST_STUB               0x00000080
#define ZONE_REQUEST_DS                 0x00000100
#define ZONE_REQUEST_NON_DS             0x00000200

#define ZONE_REQUEST_ANY_TYPE               0x000000C7
#define ZONE_REQUEST_ANY_DIRECTION          0x00000030
#define ZONE_REQUEST_ANY_DATABASE           0x00000300

#define ZONE_REQUEST_ALL_ZONES              0xfffffffb
#define ZONE_REQUEST_ALL_ZONES_AND_CACHE    0xffffffff

//  Zone update properties

#define ZONE_UPDATE_OFF         (0)
#define ZONE_UPDATE_UNSECURE    (1)
#define ZONE_UPDATE_SECURE      (2)
#define ZONE_UPDATE_SECURE_RFC  (3)

//  Zone notify levels

#define ZONE_NOTIFY_OFF                 (0)
#define ZONE_NOTIFY_ALL_SECONDARIES     (1)
#define ZONE_NOTIFY_LIST_ONLY           (2)
#define ZONE_NOTIFY_HIGHEST_VALUE       ZONE_NOTIFY_LIST_ONLY

#if 1
#define ZONE_NOTIFY_ALL                 ZONE_NOTIFY_ALL_SECONDARIES
#define ZONE_NOTIFY_LIST                ZONE_NOTIFY_LIST_ONLY
#endif

//  Zone secondary security

#define ZONE_SECSECURE_NO_SECURITY      (0)
#define ZONE_SECSECURE_NS_ONLY          (1)
#define ZONE_SECSECURE_LIST_ONLY        (2)
#define ZONE_SECSECURE_NO_XFR           (3)
#define ZONE_SECSECURE_HIGHEST_VALUE    ZONE_SECSECURE_NO_XFR

#if 1
#define ZONE_SECSECURE_OFF              ZONE_SECSECURE_NO_SECURITY
#define ZONE_SECSECURE_NS               ZONE_SECSECURE_NS_ONLY
#define ZONE_SECSECURE_LIST             ZONE_SECSECURE_LIST_ONLY
#define ZONE_SECSECURE_NONE             ZONE_SECSECURE_NO_XFR
#endif

//  No-Reset flag
//  Indicates a specific property is NOT being reset in a multi-property
//  reset call.

#define ZONE_PROPERTY_NORESET   (0xbbbbbbbb)

//
//  Special "zones" for Enum and Update
//

#define DNS_ZONE_ROOT_HINTS     ("..RootHints")

#define DNS_ZONE_CACHE          ("..Cache")

//
//  Special "multizones" for zone operations
//
//  These are provided for ease of use from dnscmd.exe.
//  However, recommended approach is to use
//      DNS_ZONE_ALL
//  and use specific ZONE_REQUEST_XYZ flags above to specify
//  matching zones.
//

#define DNS_ZONE_ALL                    ("..AllZones")
#define DNS_ZONE_ALL_AND_CACHE          ("..AllZonesAndCache")

#define DNS_ZONE_ALL_PRIMARY            ("..AllPrimaryZones")
#define DNS_ZONE_ALL_SECONDARY          ("..AllSecondaryZones")

#define DNS_ZONE_ALL_FORWARD            ("..AllForwardZones")
#define DNS_ZONE_ALL_REVERSE            ("..AllReverseZones")

#define DNS_ZONE_ALL_DS                 ("..AllDsZones")
#define DNS_ZONE_ALL_NON_DS             ("..AllNonDsZones")

//  useful combinations

#define DNS_ZONE_ALL_PRIMARY_REVERSE    ("..AllPrimaryReverseZones")
#define DNS_ZONE_ALL_PRIMARY_FORWARD    ("..AllPrimaryForwardZones")

#define DNS_ZONE_ALL_SECONDARY_REVERSE  ("..AllSecondaryReverseZones")
#define DNS_ZONE_ALL_SECONDARY_FORWARD  ("..AllSecondaryForwardZones")


//
//  Basic zone data
//      - provides what admin tool needs to show zone list
//

typedef struct _DnssrvRpcZoneFlags
{
    DWORD   Paused          : 1;
    DWORD   Shutdown        : 1;
    DWORD   Reverse         : 1;
    DWORD   AutoCreated     : 1;
    DWORD   DsIntegrated    : 1;
    DWORD   Aging           : 1;
    DWORD   Update          : 2;
    DWORD   UnUsed          : 24;
}
DNS_RPC_ZONE_FLAGS, *PDNS_RPC_ZONE_FLAGS;

typedef struct _DnssrvRpcZoneW2K
{
    LPWSTR                  pszZoneName;
#ifdef MIDL_PASS
    DWORD                   Flags;
#else
    DNS_RPC_ZONE_FLAGS      Flags;
#endif
    UCHAR                   ZoneType;
    UCHAR                   Version;
}
DNS_RPC_ZONE_W2K, *PDNS_RPC_ZONE_W2K;

typedef struct _DnssrvRpcZoneWhistler
{
    DWORD                   dwRpcStuctureVersion;
    DWORD                   dwReserved0;

    LPWSTR                  pszZoneName;
#ifdef MIDL_PASS
    DWORD                   Flags;
#else
    DNS_RPC_ZONE_FLAGS      Flags;
#endif
    UCHAR                   ZoneType;
    UCHAR                   Version;

    //
    //  Directory partition where zone is stored
    //

    DWORD                   dwDpFlags;
    LPSTR                   pszDpFqdn;
}
DNS_RPC_ZONE_WHISTLER, *PDNS_RPC_ZONE_WHISTLER;


//
//  Zone enumeration
//

typedef struct _DnssrvRpcZoneListW2K
{
    DWORD               dwZoneCount;
#ifdef MIDL_PASS
    [size_is(dwZoneCount)] PDNS_RPC_ZONE_W2K        ZoneArray[];
#else
    PDNS_RPC_ZONE_W2K   ZoneArray[ 1 ];     //  array of dwZoneCount zones
#endif
}
DNS_RPC_ZONE_LIST_W2K, *PDNS_RPC_ZONE_LIST_W2K;

typedef struct _DnssrvRpcZoneListWhistler
{
    DWORD               dwRpcStuctureVersion;
    DWORD               dwReserved0;

    DWORD               dwZoneCount;
#ifdef MIDL_PASS
    [size_is(dwZoneCount)] PDNS_RPC_ZONE_WHISTLER   ZoneArray[];
#else
    PDNS_RPC_ZONE_WHISTLER  ZoneArray[ 1 ]; //  array of dwZoneCount zones
#endif
   
}
DNS_RPC_ZONE_LIST_WHISTLER, *PDNS_RPC_ZONE_LIST_WHISTLER;


//
//  Directory partition enumeration and info
//

#define DNS_DP_AUTOCREATED              0x00000001
#define DNS_DP_LEGACY                   0x00000002
#define DNS_DP_DOMAIN_DEFAULT           0x00000004
#define DNS_DP_FOREST_DEFAULT           0x00000008
#define DNS_DP_ENLISTED                 0x00000010
#define DNS_DP_DELETED                  0x00000020

#define DNS_DP_DOMAIN_STR       "..DomainPartition"
#define DNS_DP_FOREST_STR       "..ForestPartition"
#define DNS_DP_LEGACY_STR       "..LegacyPartition"

typedef struct _DnssrvRpcDirectoryPartitionEnum
{
    DWORD           dwRpcStuctureVersion;
    DWORD           dwReserved0;

    LPSTR           pszDpFqdn;
    DWORD           dwFlags;
    DWORD           dwZoneCount;
}
DNS_RPC_DP_ENUM, *PDNS_RPC_DP_ENUM;

typedef struct _DnssrvRpcDirectoryPartitionList
{
    DWORD               dwRpcStuctureVersion;
    DWORD               dwReserved0;

    DWORD               dwDpCount;
#ifdef MIDL_PASS
    [size_is(dwDpCount)] PDNS_RPC_DP_ENUM   DpArray[];
#else
    PDNS_RPC_DP_ENUM    DpArray[ 1 ];   // array of dwDpCount pointers
#endif
}
DNS_RPC_DP_LIST, *PDNS_RPC_DP_LIST;

typedef struct _DnssrvRpcDirectoryPartitionReplica
{
    LPWSTR          pszReplicaDn;
}
DNS_RPC_DP_REPLICA, *PDNS_RPC_DP_REPLICA;

typedef struct _DnssrvRpcDirectoryPartition
{
    DWORD           dwRpcStuctureVersion;
    DWORD           dwReserved0;

    LPSTR           pszDpFqdn;
    LPWSTR          pszDpDn;        //  DP head DN
    LPWSTR          pszCrDn;        //  crossref DN
    DWORD           dwFlags;
    DWORD           dwZoneCount;

    DWORD           dwReplicaCount;
#ifdef MIDL_PASS
    [size_is(dwReplicaCount)] PDNS_RPC_DP_REPLICA   ReplicaArray[];
#else
    PDNS_RPC_DP_REPLICA     ReplicaArray[ 1 ];   // array of dwReplicaCount pointers
#endif
}
DNS_RPC_DP_INFO, *PDNS_RPC_DP_INFO;

//
//  Enlist (or create) directory partition
//

#define DNS_DP_OP_MIN                   DNS_DP_OP_CREATE
#define DNS_DP_OP_CREATE                1   //  create a new DP
#define DNS_DP_OP_DELETE                2   //  delete an existing DP
#define DNS_DP_OP_ENLIST                3   //  enlist this DC in an existing DP
#define DNS_DP_OP_UNENLIST              4   //  unenlist this DC from a DP
#define DNS_DP_OP_CREATE_DOMAIN         5   //  built-in domain DP
#define DNS_DP_OP_CREATE_FOREST         6   //  built-in forest DP
#define DNS_DP_OP_CREATE_ALL_DOMAINS    7   //  all domain DPs for the forest
#define DNS_DP_OP_MAX                   DNS_DP_OP_CREATE_ALL_DOMAINS

typedef struct _DnssrvRpcEnlistDirPart
{
    DWORD       dwRpcStuctureVersion;
    DWORD       dwReserved0;

    LPSTR       pszDpFqdn;      //  UTF8
    DWORD       dwOperation;
}
DNS_RPC_ENLIST_DP, *PDNS_RPC_ENLIST_DP;

//
//  Zone rename
//

typedef struct _DnssrvRpcZoneRename
{
    DWORD       dwRpcStuctureVersion;
    DWORD       dwReserved0;

    LPSTR       pszNewZoneName;
    LPSTR       pszNewFileName;
}
DNS_RPC_ZONE_RENAME_INFO, *PDNS_RPC_ZONE_RENAME_INFO;

//
//  Zone export
//

typedef struct _DnssrvRpcZoneExport
{
    DWORD       dwRpcStuctureVersion;
    DWORD       dwReserved0;

    LPSTR       pszZoneExportFile;
}
DNS_RPC_ZONE_EXPORT_INFO, *PDNS_RPC_ZONE_EXPORT_INFO;

//
//  Zone property data
//

typedef struct _DnssrvRpcZoneTypeResetW2K
{
    DWORD       dwZoneType;
    PIP_ARRAY   aipMasters;
}
DNS_RPC_ZONE_TYPE_RESET_W2K, *PDNS_RPC_ZONE_TYPE_RESET_W2K;

typedef struct _DnssrvRpcZoneTypeResetWhistler
{
    DWORD       dwRpcStuctureVersion;
    DWORD       dwReserved0;

    DWORD       dwZoneType;
    PIP_ARRAY   aipMasters;
}
DNS_RPC_ZONE_TYPE_RESET_WHISTLER, *PDNS_RPC_ZONE_TYPE_RESET_WHISTLER;


typedef IP_ARRAY DNS_RPC_ZONE_MASTERS, *PDNS_RPC_ZONE_MASTERS;


typedef struct _DnssrvRpcZoneSecondariesW2K
{
    DWORD       fSecureSecondaries;
    DWORD       fNotifyLevel;
    PIP_ARRAY   aipSecondaries;
    PIP_ARRAY   aipNotify;
}
DNS_RPC_ZONE_SECONDARIES_W2K, *PDNS_RPC_ZONE_SECONDARIES_W2K;

typedef struct _DnssrvRpcZoneSecondariesWhistler
{
    DWORD       dwRpcStuctureVersion;
    DWORD       dwReserved0;

    DWORD       fSecureSecondaries;
    DWORD       fNotifyLevel;
    PIP_ARRAY   aipSecondaries;
    PIP_ARRAY   aipNotify;
}
DNS_RPC_ZONE_SECONDARIES_WHISTLER, *PDNS_RPC_ZONE_SECONDARIES_WHISTLER;


typedef struct _DnssrvRpcZoneDatabaseW2K
{
    DWORD       fDsIntegrated;
    LPSTR       pszFileName;
}
DNS_RPC_ZONE_DATABASE_W2K, *PDNS_RPC_ZONE_DATABASE_W2K;

typedef struct _DnssrvRpcZoneDatabaseWhistler
{
    DWORD       dwRpcStuctureVersion;
    DWORD       dwReserved0;

    DWORD       fDsIntegrated;
    LPSTR       pszFileName;
}
DNS_RPC_ZONE_DATABASE_WHISTLER, *PDNS_RPC_ZONE_DATABASE_WHISTLER;


//
//  DNS_RPC_ZONE_CHANGE_DP - new for Whistler
//
//  Used to move a zone from one directory parition (DP) to another.
//
//  To move the zone to a built-in DP, for pszDestPartition use one of:
//          DNS_DP_DOMAIN_STR
//          DNS_DP_ENTERPRISE_STR
//          DNS_DP_LEGACY_STR
//

typedef struct _DnssrvRpcZoneChangePartition
{
    DWORD       dwRpcStuctureVersion;
    DWORD       dwReserved0;

    LPSTR       pszDestPartition;
}
DNS_RPC_ZONE_CHANGE_DP, *PDNS_RPC_ZONE_CHANGE_DP;


typedef struct _DnsRpcZoneInfoW2K
{
    LPSTR       pszZoneName;
    DWORD       dwZoneType;
    DWORD       fReverse;
    DWORD       fAllowUpdate;
    DWORD       fPaused;
    DWORD       fShutdown;
    DWORD       fAutoCreated;

    //  Database info

    DWORD       fUseDatabase;
    LPSTR       pszDataFile;

    //  Masters

    PIP_ARRAY   aipMasters;

    //  Secondaries

    DWORD       fSecureSecondaries;
    DWORD       fNotifyLevel;
    PIP_ARRAY   aipSecondaries;
    PIP_ARRAY   aipNotify;

    //  WINS or Nbstat lookup

    DWORD       fUseWins;
    DWORD       fUseNbstat;

    //  Aging

    DWORD       fAging;
    DWORD       dwNoRefreshInterval;
    DWORD       dwRefreshInterval;
    DWORD       dwAvailForScavengeTime;
    PIP_ARRAY   aipScavengeServers;

    //  save some space, just in case
    //      avoid versioning issues if possible

    DWORD       pvReserved1;
    DWORD       pvReserved2;
    DWORD       pvReserved3;
    DWORD       pvReserved4;
}
DNS_RPC_ZONE_INFO_W2K, *PDNS_RPC_ZONE_INFO_W2K;

typedef DNS_RPC_ZONE_INFO_W2K   DNS_ZONE_INFO_W2K, *PDNS_ZONE_INFO_W2K;

typedef struct _DnsRpcZoneInfoWhistler
{
    DWORD       dwRpcStuctureVersion;
    DWORD       dwReserved0;

    LPSTR       pszZoneName;
    DWORD       dwZoneType;
    DWORD       fReverse;
    DWORD       fAllowUpdate;
    DWORD       fPaused;
    DWORD       fShutdown;
    DWORD       fAutoCreated;

    //  Database info

    DWORD       fUseDatabase;
    LPSTR       pszDataFile;

    //  Masters

    PIP_ARRAY   aipMasters;

    //  Secondaries

    DWORD       fSecureSecondaries;
    DWORD       fNotifyLevel;
    PIP_ARRAY   aipSecondaries;
    PIP_ARRAY   aipNotify;

    //  WINS or Nbstat lookup

    DWORD       fUseWins;
    DWORD       fUseNbstat;

    //  Aging

    DWORD       fAging;
    DWORD       dwNoRefreshInterval;
    DWORD       dwRefreshInterval;
    DWORD       dwAvailForScavengeTime;
    PIP_ARRAY   aipScavengeServers;

    //  Below this point is new for Whistler

    //  Forwarder zones

    DWORD       dwForwarderTimeout;
    DWORD       fForwarderSlave;

    //  Stub zones

    PIP_ARRAY   aipLocalMasters;

    //  Directory partition

    DWORD       dwDpFlags;
    LPSTR       pszDpFqdn;
    LPWSTR      pwszZoneDn;

    //  Xfr time information

    DWORD       dwLastSuccessfulSoaCheck;
    DWORD       dwLastSuccessfulXfr;
    
    //  save some space, just in case
    //      DWORDS: save for SP enhancements
    //      POINTERS: BEFORE SHIP!!!

    DWORD       dwReserved1;
    DWORD       dwReserved2;
    DWORD       dwReserved3;
    DWORD       dwReserved4;
    DWORD       dwReserved5;

    LPSTR       pReserved1;
    LPSTR       pReserved2;
    LPSTR       pReserved3;
    LPSTR       pReserved4;
}
DNS_RPC_ZONE_INFO_WHISTLER, *PDNS_RPC_ZONE_INFO_WHISTLER;

typedef DNS_RPC_ZONE_INFO_WHISTLER      DNS_ZONE_INFO, *PDNS_ZONE_INFO;


//
//  Zone create data
//

typedef struct _DnsRpcZoneCreateInfo
{
    LPSTR       pszZoneName;
    DWORD       dwZoneType;
    DWORD       fAllowUpdate;
    DWORD       fAging;
    DWORD       dwFlags;

    //  Database info

    LPSTR       pszDataFile;
    DWORD       fDsIntegrated;
    DWORD       fLoadExisting;

    //  Admin name (if auto-create SOA)

    LPSTR       pszAdmin;

    //  Masters (if secondary)

    PIP_ARRAY   aipMasters;

    //  Secondaries

    PIP_ARRAY   aipSecondaries;
    DWORD       fSecureSecondaries;
    DWORD       fNotifyLevel;

    //  Reserve some space to avoid versioning issues

    LPSTR       pvReserved1;
    LPSTR       pvReserved2;
    LPSTR       pvReserved3;
    LPSTR       pvReserved4;
    LPSTR       pvReserved5;
    LPSTR       pvReserved6;
    LPSTR       pvReserved7;
    LPSTR       pvReserved8;

    DWORD       dwReserved1;
    DWORD       dwReserved2;
    DWORD       dwReserved3;
    DWORD       dwReserved4;
    DWORD       dwReserved5;
    DWORD       dwReserved6;
    DWORD       dwReserved7;
    DWORD       dwReserved8;
}
DNS_RPC_ZONE_CREATE_INFO_W2K, *PDNS_RPC_ZONE_CREATE_INFO_W2K;


typedef struct _DnsRpcZoneCreateInfoWhistler
{
    DWORD       dwRpcStuctureVersion;
    DWORD       dwReserved0;

    LPSTR       pszZoneName;
    DWORD       dwZoneType;
    DWORD       fAllowUpdate;
    DWORD       fAging;
    DWORD       dwFlags;

    //  Database info

    LPSTR       pszDataFile;
    DWORD       fDsIntegrated;
    DWORD       fLoadExisting;

    //  Admin name (if auto-create SOA)

    LPSTR       pszAdmin;

    //  Masters (if secondary)

    PIP_ARRAY   aipMasters;

    //  Secondaries

    PIP_ARRAY   aipSecondaries;
    DWORD       fSecureSecondaries;
    DWORD       fNotifyLevel;

    //  Below this point is new for Whistler.

    //  Forwarder zones

    DWORD       dwTimeout;
    DWORD       fSlave;

    //  Directory partition

    DWORD       dwDpFlags;      //  specify builtin DP or
    LPSTR       pszDpFqdn;      //      UTF8 FQDN of partition

    //  Reserve some space to avoid versioning issues - we have so much
    //  reserved because we don't want the Whistler structure to be smaller
    //  than the W2K structure on IA64.

    DWORD       dwReserved[ 32 ];
    DWORD       pReserved[ 32 ];        //  remove before ship!
}
DNS_RPC_ZONE_CREATE_INFO_WHISTLER, *PDNS_RPC_ZONE_CREATE_INFO_WHISTLER;



//
//  Zone Query API
//

DNS_STATUS
DNS_API_FUNCTION
DnssrvEnumZones(
    IN      LPCWSTR                 pwszServer,
    IN      DWORD                   dwFilter,
    IN      LPCSTR                  pszLastZone,
    OUT     PDNS_RPC_ZONE_LIST *    ppZoneList
    //OUT     PDWORD              pZoneCount,
    //OUT     PDNS_RPC_ZONE *     ppZones
    );

VOID
DNS_API_FUNCTION
DnssrvFreeZone(
    IN OUT  PDNS_RPC_ZONE       pZone
    );

VOID
DNS_API_FUNCTION
DnssrvFreeZoneList(
    IN OUT  PDNS_RPC_ZONE_LIST  pZoneList
    );

DNS_STATUS
DNS_API_FUNCTION
DnssrvQueryZoneDwordProperty(
    IN      LPCWSTR             pwszServer,
    IN      LPCSTR              pszZone,
    IN      LPCSTR              pszProperty,
    OUT     PDWORD              pdwResult
    );

DNS_STATUS
DNS_API_FUNCTION
DnssrvGetZoneInfo(
    IN      LPCWSTR                 pwszServer,
    IN      LPCSTR                  pszZone,
    OUT     PDNS_RPC_ZONE_INFO *    ppZoneInfo
    );

VOID
DNS_API_FUNCTION
DnssrvFreeZoneInfo(
    IN OUT  PDNS_RPC_ZONE_INFO      pZoneInfo
    );



//
//  Zone Operations API
//

#define DNS_ZONE_LOAD_OVERWRITE_MEMORY  (0x00000010)
#define DNS_ZONE_LOAD_OVERWRITE_DS      (0x00000020)
#define DNS_ZONE_LOAD_MERGE_EXISTING    (0x00000040)
#define DNS_ZONE_LOAD_MUST_FIND         (0x00000100)

#define DNS_ZONE_LOAD_EXISTING          DNS_ZONE_LOAD_OVERWRITE_MEMORY
#define DNS_ZONE_OVERWRITE_EXISTING     DNS_ZONE_LOAD_OVERWRITE_DS
#define DNS_ZONE_MERGE_WITH_EXISTING    DNS_ZONE_LOAD_MERGE_EXISTING

//
//  Zone create flags
//

#define DNS_ZONE_CREATE_FOR_DCPROMO     (0x00001000)
#define DNS_ZONE_CREATE_AGING           (0x00002000)

#if 0
//  Currently these have direct parameter to CreateZone function
#define DNS_ZONE_CREATE_UPDATE          (0x00010000)
#define DNS_ZONE_CREATE_UPDATE_SECURE   (0x00020000)
#define DNS_ZONE_CREATE_DS_INTEGRATED   (0x10000000)
#endif

DNS_STATUS
DNS_API_FUNCTION
DnssrvCreateZone(
    IN      LPCWSTR         pwszServer,
    IN      LPCSTR          pszZoneName,
    IN      DWORD           dwZoneType,
    IN      LPCSTR          pszAdminEmailName,
    IN      DWORD           cMasters,
    IN      PIP_ADDRESS     aipMasters,
    IN      DWORD           fLoadExisting,
    IN      DWORD           fDsIntegrated,
    IN      LPCSTR          pszDataFile,
    IN      DWORD           dwTimeout,
    IN      DWORD           fSlave
    );

DNS_STATUS
DNS_API_FUNCTION
DnssrvCreateZoneForDcPromo(
    IN      LPCWSTR         Server,
    IN      LPCSTR          pszZoneName,
    IN      LPCSTR          pszDataFile
    );

DNS_STATUS
DNS_API_FUNCTION
DnssrvCreateZoneInDirectoryPartition(
    IN      LPCWSTR             pwszServer,
    IN      LPCSTR              pszZoneName,
    IN      DWORD               dwZoneType,
    IN      LPCSTR              pszAdminEmailName,
    IN      DWORD               cMasters,
    IN      PIP_ADDRESS         aipMasters,
    IN      DWORD               fLoadExisting,
    IN      DWORD               dwTimeout,
    IN      DWORD               fSlave,
    IN      DWORD               dwDirPartFlags,
    IN      LPCSTR              pszDirPartFqdn
    );


DNS_STATUS
DNS_API_FUNCTION
DnssrvDelegateSubZone(
    IN      LPCWSTR         pwszServer,
    IN      LPCSTR          pszZoneName,
    IN      LPCSTR          pszSubZone,
    IN      LPCSTR          pszNewServer,
    IN      IP_ADDRESS      ipNewServerAddr
    );

DNS_STATUS
DNS_API_FUNCTION
DnssrvIncrementZoneVersion(
    IN      LPCWSTR         pwszServer,
    IN      LPCSTR          pszZoneName
    );

DNS_STATUS
DNS_API_FUNCTION
DnssrvDeleteZone(
    IN      LPCWSTR         pwszServer,
    IN      LPCSTR          pszZoneName
    );

DNS_STATUS
DNS_API_FUNCTION
DnssrvPauseZone(
    IN      LPCWSTR         pwszServer,
    IN      LPCSTR          pszZoneName
    );

DNS_STATUS
DNS_API_FUNCTION
DnssrvResumeZone(
    IN      LPCWSTR         pwszServer,
    IN      LPCSTR          pszZoneName
    );


DNS_STATUS
DNS_API_FUNCTION
DnssrvResetZoneType(
    IN      LPCWSTR         pwszServer,
    IN      LPCSTR          pszZoneName,
    IN      DWORD           dwZoneType,
    IN      DWORD           cMasters,
    IN      PIP_ADDRESS     aipMasters
    );

DNS_STATUS
DNS_API_FUNCTION
DnssrvResetZoneTypeEx(
    IN      LPCWSTR         pwszServer,
    IN      LPCSTR          pszZoneName,
    IN      DWORD           dwZoneType,
    IN      DWORD           cMasters,
    IN      PIP_ADDRESS     aipMasters,
    IN      DWORD           dwLoadOptions,
    IN      DWORD           fDsIntegrated,
    IN      LPCSTR          pszDataFile
    );

DNS_STATUS
DNS_API_FUNCTION
DnssrvChangeZoneDirectoryPartition(
    IN      LPCWSTR         pwszServer,
    IN      LPCSTR          pszZoneName,
    IN      LPCSTR          pszNewPartition
    );

DNS_STATUS
DNS_API_FUNCTION
DnssrvResetZoneDatabase(
    IN      LPCWSTR         pwszServer,
    IN      LPCSTR          pszZoneName,
    IN      DWORD           fUseDatabase,
    IN      LPCSTR          pszDataFile
    );

DNS_STATUS
DNS_API_FUNCTION
DnssrvResetZoneMasters(
    IN      LPCWSTR         pwszServer,
    IN      LPCSTR          pszZoneName,
    IN      DWORD           cMasters,
    IN      PIP_ADDRESS     aipMasters
    );

DNS_STATUS
DNS_API_FUNCTION
DnssrvResetZoneMastersEx(
    IN      LPCWSTR         pwszServer,
    IN      LPCSTR          pszZoneName,
    IN      DWORD           cMasters,
    IN      PIP_ADDRESS     aipMasters,
    IN      DWORD           fSetLocalMasters
    );

DNS_STATUS
DNS_API_FUNCTION
DnssrvResetZoneSecondaries(
    IN      LPCWSTR             Server,
    IN      LPCSTR              pszZone,
    IN      DWORD               fSecureSecondaries,
    IN      DWORD               cSecondaries,
    IN      PIP_ADDRESS         aipSecondaries,
    IN      DWORD               fNotifyLevel,
    IN      DWORD               cNotify,
    IN      PIP_ADDRESS         aipNotify
    );

DNS_STATUS
DNS_API_FUNCTION
DnssrvRenameZone(
    IN      LPCWSTR         Server,
    IN      LPCSTR          pszCurrentZoneName,
    IN      LPCSTR          pszNewZoneName,
    IN      LPCSTR          pszNewFileName
    );

DNS_STATUS
DNS_API_FUNCTION
DnssrvExportZone(
    IN      LPCWSTR         Server,
    IN      LPCSTR          pszZoneName,
    IN      LPCSTR          pszZoneExportFile
    );



//
//  Record \ Node viewing
//

//
//  Counted string format used for both node name and strings
//  in RPC buffer.
//

typedef struct  _DnssrvRpcName
{
    UCHAR   cchNameLength;
    CHAR    achName[1];         // name of cchNameLength characters
}
DNS_RPC_NAME, *PDNS_RPC_NAME, DNS_RPC_STRING, *PDNS_RPC_STRING;

//
//  Enumeration flags
//

#define DNS_RPC_FLAG_CACHE_DATA             0x80000000
#define DNS_RPC_FLAG_ZONE_ROOT              0x40000000
#define DNS_RPC_FLAG_AUTH_ZONE_ROOT         0x20000000
#define DNS_RPC_FLAG_ZONE_DELEGATION        0x10000000

//  update record flags

#define DNS_RPC_FLAG_RECORD_DEFAULT_TTL     0x08000000
#define DNS_RPC_FLAG_RECORD_TTL_CHANGE      0x04000000
#define DNS_RPC_FLAG_RECORD_CREATE_PTR      0x02000000

#define DNS_RPC_FLAG_NODE_STICKY            0x01000000
#define DNS_RPC_FLAG_NODE_COMPLETE          0x00800000

#define DNS_RPC_FLAG_SUPPRESS_NOTIFY        0x00010000

//  aging

#define DNS_RPC_FLAG_AGING_ON               0x00020000
#define DNS_RPC_FLAG_AGING_OFF              0x00040000

#define DNS_RPC_FLAG_OPEN_ACL               0x00080000

//  bottom byte of flag reserved for rank

#define DNS_RPC_FLAG_RANK                   0x000000ff


//  naming backward compatibility

#define DNS_RPC_NODE_FLAG_STICKY            DNS_RPC_FLAG_NODE_STICKY
#define DNS_RPC_NODE_FLAG_COMPLETE          DNS_RPC_FLAG_NODE_COMPLETE

#define DNS_RPC_RECORD_FLAG_ZONE_ROOT       DNS_RPC_FLAG_ZONE_ROOT
#define DNS_RPC_RECORD_FLAG_DEFAULT_TTL     DNS_RPC_FLAG_RECORD_DEFAULT_TTL
#define DNS_RPC_RECORD_FLAG_TTL_CHANGE      DNS_RPC_FLAG_RECORD_TTL_CHANGE
#define DNS_RPC_RECORD_FLAG_CREATE_PTR      DNS_RPC_FLAG_RECORD_CREATE_PTR
#define DNS_RPC_RECORD_FLAG_CACHE_DATA      DNS_RPC_FLAG_CACHE_DATA
#define DNS_RPC_RECORD_FLAG_AUTH_ZONE_ROOT  DNS_RPC_FLAG_AUTH_ZONE_ROOT
#define DNS_RPC_RECORD_FLAG_ZONE_ROOT       DNS_RPC_FLAG_ZONE_ROOT

//  DCR_CLEANUP:  remove backward compatibility flag

#define DNS_RPC_RECORD_FLAG_AGING_ON        DNS_RPC_FLAG_AGING_ON


//
//  DNS node structure for on the wire
//

typedef struct  _DnssrvRpcNode
{
    WORD            wLength;
    WORD            wRecordCount;
    DWORD           dwFlags;
    DWORD           dwChildCount;
    DNS_RPC_NAME    dnsNodeName;
}
DNS_RPC_NODE, *PDNS_RPC_NODE;

#define SIZEOF_DNS_RPC_NODE_HEADER   (3*sizeof(DWORD))



//
//  Resource record structure for passing records on the wire
//
//  For efficiency, all these fields are aligned.
//  When buffered for transmission, all RR should start on DWORD
//  aligned boundary.
//
//  Below we use NULL type to force default size of DNS_RPC_RECORD to
//  largest possible size of non-TXT record -- currently SOA:  two DNS names
//  and 20 bytes.  This is convenient for throwing these records on the stack
//  when doing simple creates.

#define DNS_RPC_DEFAULT_RECORD_DATA_LENGTH (2*DNS_MAX_NAME_LENGTH+20)


typedef union _DnsRpcRecordData
{
    struct
    {
        IP_ADDRESS      ipAddress;
    }
    A;

    struct
    {
        DWORD           dwSerialNo;
        DWORD           dwRefresh;
        DWORD           dwRetry;
        DWORD           dwExpire;
        DWORD           dwMinimumTtl;
        DNS_RPC_NAME    namePrimaryServer;

        //  responsible party follows in buffer
    }
    SOA, Soa;

    struct
    {
        DNS_RPC_NAME    nameNode;
    }
    PTR, Ptr,
    NS, Ns,
    CNAME, Cname,
    MB, Mb,
    MD, Md,
    MF, Mf,
    MG, Mg,
    MR, Mr;

    struct
    {
        DNS_RPC_NAME    nameMailBox;

        //  errors to mailbox follows in buffer
    }
    MINFO, Minfo,
    RP, Rp;

    struct
    {
        WORD            wPreference;
        DNS_RPC_NAME    nameExchange;
    }
    MX, Mx,
    AFSDB, Afsdb,
    RT, Rt;

    struct
    {
        DNS_RPC_STRING  stringData;

        //  one or more strings may follow
    }
    HINFO, Hinfo,
    ISDN, Isdn,
    TXT, Txt,
    X25;

    struct
    {
        BYTE            bData[ DNS_RPC_DEFAULT_RECORD_DATA_LENGTH ];
    }
    Null;

    struct
    {
        IP_ADDRESS      ipAddress;
        UCHAR           chProtocol;
        BYTE            bBitMask[1];
    }
    WKS, Wks;

    struct
    {
        IP6_ADDRESS     ipv6Address;
    }
    AAAA;

    struct
    {
        WORD            wPriority;
        WORD            wWeight;
        WORD            wPort;
        DNS_RPC_NAME    nameTarget;
    }
    SRV, Srv;

    struct
    {
        UCHAR           chFormat;
        BYTE            bAddress[1];
    }
    ATMA;

    //
    //  DNSSEC types
    //

    struct
    {
        WORD            wFlags;
        BYTE            chProtocol;
        BYTE            chAlgorithm;
        BYTE            bKey[1];
    }
    KEY, Key;

    struct
    {
        WORD            wTypeCovered;
        BYTE            chAlgorithm;
        BYTE            chLabelCount;
        DWORD           dwOriginalTtl;
        DWORD           dwSigExpiration;
        DWORD           dwSigInception;
        WORD            wKeyTag;
        DNS_RPC_STRING  nameSigner;
        //  binary signature data follows
    }
    SIG, Sig;

    struct
    {
        WORD            wNumTypeWords;      //  always at least 1
        WORD            wTypeWords[ 1 ];
        //  following the array of WORDs is the DNS_RPC_STRING for the next name
    }
    NXT, Nxt;

    //
    //  MS types
    //

    struct
    {
        DWORD           dwMappingFlag;
        DWORD           dwLookupTimeout;
        DWORD           dwCacheTimeout;
        DWORD           cWinsServerCount;
        IP_ADDRESS      aipWinsServers[1];      //  array of cWinsServerCount IP
    }
    WINS, Wins;

    struct
    {
        DWORD           dwMappingFlag;
        DWORD           dwLookupTimeout;
        DWORD           dwCacheTimeout;
        DNS_RPC_NAME    nameResultDomain;
    }
    WINSR, WinsR, NBSTAT, Nbstat;

    struct
    {
        LONGLONG        EntombedTime;
    }
    Tombstone;

}
DNS_RPC_RECORD_DATA, *PDNS_RPC_RECORD_DATA,
DNS_FLAT_RECORD_DATA, *PDNS_FLAT_RECORD_DATA;


//
//  RPC record structure
//

typedef struct _DnssrvRpcRecord
{
    WORD        wDataLength;
    WORD        wType;
    DWORD       dwFlags;
    DWORD       dwSerial;
    DWORD       dwTtlSeconds;
    DWORD       dwTimeStamp;
    DWORD       dwReserved;

#ifdef MIDL_PASS
    [size_is(wDataLength)]  BYTE    Buffer[];
#else
    DNS_FLAT_RECORD_DATA            Data;
#endif
}
DNS_RPC_RECORD, *PDNS_RPC_RECORD,
DNS_FLAT_RECORD, *PDNS_FLAT_RECORD;


#define SIZEOF_DNS_RPC_RECORD_HEADER    (6*sizeof(DWORD))
#define SIZEOF_FLAT_RECORD_HEADER       (SIZEOF_DNS_RPC_RECORD_HEADER)

#define SIZEOF_DNS_RPC_RECORD_FIXED_FIELD2 \
                (sizeof(DNS_RPC_RECORD) - sizeof(struct _DnssrvRpcRecord.Data))

//  Max record is header + 64K of data

#define DNS_MAX_FLAT_RECORD_BUFFER_LENGTH  \
            (0x10004 + SIZEOF_DNS_RPC_RECORD_HEADER)


//
//  WINS + NBSTAT params
//      - default lookup timeout
//      - default cache timeout
//

#define DNS_WINS_DEFAULT_LOOKUP_TIMEOUT     (5)     // 5 secs
#define DNS_WINS_DEFAULT_CACHE_TIMEOUT      (600)   // 10 minutes


//
//  Note, for simplicity/efficiency ALL structures are DWORD aligned in
//  buffers on the wire.
//
//  This macro returns DWORD aligned ptr at given ptr our next DWORD
//  aligned postion.  Set ptr immediately after record or name structure
//  and this will return starting position of next structure.
//
//  Be careful that you do not DWORD align anything that contains a
//  pointer - you must use DNS_NEXT_ALIGNED_PTR for that so that we 
//  don't cause alignment faults on ia64.
//

#define DNS_NEXT_DWORD_PTR(ptr) ((PBYTE) ((DWORD_PTR)((PBYTE)ptr + 3) & ~(DWORD_PTR)3))

#define DNS_NEXT_DDWORD_PTR(ptr) ((PBYTE) ((DWORD_PTR)((PBYTE)ptr + 7) & ~(DWORD_PTR)7))

#ifdef IA64
    #define DNS_NEXT_ALIGNED_PTR(p) DNS_NEXT_DDWORD_PTR(p)
#else
    #define DNS_NEXT_ALIGNED_PTR(p) DNS_NEXT_DWORD_PTR(p)
#endif

#define DNS_IS_DWORD_ALIGNED(p) ( !((DWORD_PTR)(p) & (DWORD_PTR)3) )


//
//  Helpful record macros
//  - no side effects in arguments
//

#define DNS_GET_NEXT_NAME(pname) \
            (PDNS_RPC_NAME) ((pname)->achName + (pname)->cchNameLength)

#define DNS_IS_NAME_IN_RECORD(pRecord, pname) \
            ( DNS_GET_END_OF_RPC_RECORD_DATA(pRecord) >= \
                (PCHAR)DNS_GET_NEXT_NAME(pname) )

#define DNS_GET_END_OF_RPC_RECORD_DATA(pRecord) \
            ( (PCHAR)&(pRecord)->Data + (pRecord)->wDataLength )

#define DNS_IS_RPC_RECORD_WITHIN_BUFFER( pRecord, pStopByte ) \
            ( (PCHAR)&(pRecord)->Data <= (pStopByte)  && \
                DNS_GET_END_OF_RPC_RECORD_DATA(pRecord) <= (pStopByte) )

#define DNS_GET_NEXT_RPC_RECORD(pRecord) \
            ( (PDNS_RPC_RECORD) \
                DNS_NEXT_DWORD_PTR( DNS_GET_END_OF_RPC_RECORD_DATA(pRecord) ) )

//
//  These RPC structures have no version because they are simple
//  are they are explicitly defined by their names.
//

typedef struct _DnssrvRpcNameAndParam
{
    DWORD       dwParam;
    LPSTR       pszNodeName;
}
DNS_RPC_NAME_AND_PARAM, *PDNS_RPC_NAME_AND_PARAM;


typedef struct _DnssrvRpcNameAndString
{
    LPWSTR      pwszParam;
    LPSTR       pszNodeName;
    DWORD       dwFlags;
}
DNS_RPC_NAME_AND_STRING, *PDNS_RPC_NAME_AND_STRING;

typedef struct _DnssrvRpcNameAndIPList
{
    PIP_ARRAY   aipList;
    LPSTR       pszNodeName;
    DWORD       dwFlags;
}
DNS_RPC_NAME_AND_IPLIST, *PDNS_RPC_NAME_AND_IPLIST;



//
//  Record viewing API
//

#define DNS_RPC_VIEW_AUTHORITY_DATA     0x00000001
#define DNS_RPC_VIEW_CACHE_DATA         0x00000002
#define DNS_RPC_VIEW_GLUE_DATA          0x00000004
#define DNS_RPC_VIEW_ROOT_HINT_DATA     0x00000008
#define DNS_RPC_VIEW_ALL_DATA           0x0000000f
#define DNS_RPC_VIEW_ADDITIONAL_DATA    0x00000010

#define DNS_RPC_VIEW_NO_CHILDREN        0x00010000
#define DNS_RPC_VIEW_ONLY_CHILDREN      0x00020000
#define DNS_RPC_VIEW_CHILDREN_MASK      0x000f0000

DNS_STATUS
DNS_API_FUNCTION
DnssrvEnumRecordsEx(
    IN      DWORD       dwClientVersion,
    IN      DWORD       dwSettingFlags,
    IN      LPCWSTR     Server,
    IN      LPCSTR      pszZoneName,
    IN      LPCSTR      pszNodeName,
    IN      LPCSTR      pszStartChild,
    IN      WORD        wRecordType,
    IN      DWORD       dwSelectFlag,
    IN      LPCSTR      pszFilterStart,
    IN      LPCSTR      pszFilterStop,
    IN OUT  PDWORD      pdwBufferLength,
    OUT     PBYTE *     ppBuffer
    );

#define DnssrvEnumRecords( s, z, n, sc, typ, sf, fstart, fstop, blen, p )   \
    DnssrvEnumRecordsEx( DNS_RPC_CURRENT_CLIENT_VER,                        \
        0, (s), (z), (n), (sc), (typ),                                      \
        (sf), (fstart), (fstop), (blen), (p) )

#define DnssrvFreeRecordsBuffer( pBuf ) \
        DnssrvFreeRpcBuffer( (PDNS_RPC_BUFFER)pBuf )


PCHAR
DnssrvGetWksServicesInRecord(
    IN      PDNS_FLAT_RECORD    pRR
    );


//
//  Record management API
//

DNS_STATUS
DNS_API_FUNCTION
DnssrvUpdateRecordEx(
    IN      DWORD               dwClientVersion,
    IN      DWORD               dwSettingFlags,
    IN      LPCWSTR             pwszServer,
    IN      LPCSTR              pszZoneName,
    IN      LPCSTR              pszNodeName,
    IN      PDNS_RPC_RECORD     pAddRecord,
    IN      PDNS_RPC_RECORD     pDeleteRecord
    );

#define DnssrvUpdateRecord( s, z, n, add, del )             \
    DnssrvUpdateRecordEx( DNS_RPC_CURRENT_CLIENT_VER,       \
        0, (s), (z), (n), (add), (del) )

DNS_STATUS
DNS_API_FUNCTION
DnssrvDeleteNode(
    IN      LPCWSTR         pwszServer,
    IN      LPCSTR          pszZoneName,
    IN      LPCSTR          pszNodeName,
    IN      BOOL            bDeleteSubtree
    );

DNS_STATUS
DNS_API_FUNCTION
DnssrvDeleteRecordSet(
    IN      LPCWSTR         pwszServer,
    IN      LPCSTR          pszZoneName,
    IN      LPCSTR          pszNodeName,
    IN      WORD            wType
    );

DNS_STATUS
DNS_API_FUNCTION
DnssrvForceAging(
    IN      LPCWSTR         pwszServer,
    IN      LPCSTR          pszZoneName,
    IN      LPCSTR          pszNodeName,
    IN      BOOL            fAgeSubtree
    );



//
//  Programmable record management API -- for Small Business Server (SBS)
//

VOID
DNS_API_FUNCTION
DnssrvFillRecordHeader(
    IN OUT  PDNS_RPC_RECORD     pRecord,
    IN      DWORD               dwTtl,
    IN      DWORD               dwTimeout,
    IN      BOOL                fSuppressNotify
    );

DWORD
DNS_API_FUNCTION
DnssrvWriteNameToFlatBuffer(
    IN OUT  PCHAR               pchWrite,
    IN      LPCSTR              pszName
    );

DNS_STATUS
DNS_API_FUNCTION
DnssrvFillOutSingleIndirectionRecord(
    IN OUT  PDNS_RPC_RECORD     pRecord,
    IN      WORD                wType,
    IN      LPCSTR              pszName
    );

DNS_STATUS
DNS_API_FUNCTION
DnssrvAddARecord(
    IN      LPCWSTR     pwszServer,
    IN      LPCSTR      pszNodeName,
    IN      IP_ADDRESS  ipAddress,
    IN      DWORD       dwTtl,
    IN      DWORD       dwTimeout,
    IN      BOOL        fSuppressNotify
    );

DNS_STATUS
DNS_API_FUNCTION
DnssrvAddCnameRecord(
    IN      LPCWSTR     pwszServer,
    IN      LPCSTR      pszNodeName,
    IN      LPCSTR      pszCannonicalName,
    IN      DWORD       dwTtl,
    IN      DWORD       dwTimeout,
    IN      BOOL        fSuppressNotify
    );

DNS_STATUS
DNS_API_FUNCTION
DnssrvAddMxRecord(
    IN      LPCWSTR     pwszServer,
    IN      LPCSTR      pszNodeName,
    IN      LPCSTR      pszMailExchangeHost,
    IN      WORD        wPreference,
    IN      DWORD       dwTtl,
    IN      DWORD       dwTimeout,
    IN      BOOL        fSuppressNotify
    );

DNS_STATUS
DNS_API_FUNCTION
DnssrvAddNsRecord(
    IN      LPCWSTR     pwszServer,
    IN      LPCSTR      pszNodeName,
    IN      LPCSTR      pszNsHostName,
    IN      DWORD       dwTtl,
    IN      DWORD       dwTimeout,
    IN      BOOL        fSuppressNotify
    );

DNS_STATUS
DNS_API_FUNCTION
DnssrvConcatDnsNames(
    OUT     PCHAR       pszResult,
    IN      LPCSTR      pszDomain,
    IN      LPCSTR      pszName
    );

DNS_STATUS
DNS_API_FUNCTION
DnssrvDeleteARecord(
    IN      LPCWSTR     pwszServer,
    IN      LPCSTR      pszName,
    IN      IP_ADDRESS  ipHost,
    IN      BOOL        fSuppressNotify
    );

DNS_STATUS
DNS_API_FUNCTION
DnssrvDeleteCnameRecord(
    IN      LPCWSTR     pwszServer,
    IN      LPCSTR      pszNodeName,
    IN      LPCSTR      pszCannonicalName,
    IN      BOOL        fSuppressNotify
    );

DNS_STATUS
DNS_API_FUNCTION
DnssrvDeleteMxRecord(
    IN      LPCWSTR     pwszServer,
    IN      LPCSTR      pszNodeName,
    IN      LPCSTR      pszMailExchangeHost,
    IN      WORD        wPreference,
    IN      BOOL        fSuppressNotify
    );

DNS_STATUS
DNS_API_FUNCTION
DnssrvDeleteNsRecord(
    IN      LPCWSTR     pwszServer,
    IN      LPCSTR      pszNodeName,
    IN      LPCSTR      pszNsHostName,
    IN      BOOL        fSuppressNotify
    );

DNS_STATUS
DNS_API_FUNCTION
DnssrvSbsAddClientToIspZone(
    IN      LPCWSTR     pwszServer,
    IN      LPCSTR      pszIspZone,
    IN      LPCSTR      pszClient,
    IN      LPCSTR      pszClientHost,
    IN      IP_ADDRESS  ipClientHost,
    IN      DWORD       dwTtl
    );

DNS_STATUS
DNS_API_FUNCTION
DnssrvSbsDeleteRecord(
    IN      LPCWSTR     pwszServer,
    IN      LPCSTR      pszZone,
    IN      LPCSTR      pszDomain,
    IN      LPCSTR      pszName,
    IN      WORD        wType,
    IN      LPCSTR      pszDataName,
    IN      IP_ADDRESS  ipHost
    );


//
//  DNS_RECORD compatible record API
//

//
//  No MIDL for DNS_NODE type (to avoid bringing in dnsapi.h)
//  or for local print routines
//

#ifndef MIDL_PASS

//
//  Node structure for Admin side
//

#include <dnsapi.h>

typedef struct _DnssrvNodeFlags
{
    BYTE    Domain      : 1;
    BYTE    ZoneRoot    : 1;
    BYTE    Unused      : 5;

    BYTE    Unused2     : 5;
    BYTE    FreeOwner   : 1;
    BYTE    Unicode     : 1;
    BYTE    Utf8        : 1;

    WORD    Reserved;
}
DNSNODE_FLAGS;

typedef struct _DnssrvNode
{
    struct _DnssrvNode *    pNext;
    PWSTR                   pName;
    PDNS_RECORD             pRecord;
    union
    {
        DWORD               W;  // flags as dword
        DNSNODE_FLAGS       S;  // flags as structure

    } Flags;
}
DNS_NODE, *PDNS_NODE;


//
//  Record "section" flags
//
//  Overload DNS_RECORD.Flag section fields with RPC data type info
//

#define     DNSREC_CACHE_DATA   (0x00000000)
#define     DNSREC_ZONE_DATA    (0x00000001)
#define     DNSREC_GLUE_DATA    (0x00000002)
#define     DNSREC_ROOT_HINT    (0x00000003)


DNS_STATUS
DNS_API_FUNCTION
DnssrvEnumRecordsAndConvertNodes(
    IN      LPCWSTR         pwszServer,
    IN      LPCSTR          pszZoneName,
    IN      LPCSTR          pszNodeName,
    IN      LPCSTR          pszStartChild,
    IN      WORD            wRecordType,
    IN      DWORD           dwSelectFlag,
    IN      LPCSTR          pszFilterStart,
    IN      LPCSTR          pszFilterStop,
    OUT     PDNS_NODE *     ppNodeFirst,
    OUT     PDNS_NODE *     ppNodeLast
    );

VOID
DNS_API_FUNCTION
DnssrvFreeNode(
    IN OUT  PDNS_NODE       pNode,
    IN      BOOLEAN         fFreeRecords
    );

VOID
DNS_API_FUNCTION
DnssrvFreeNodeList(
    IN OUT  PDNS_NODE       pNode,
    IN      BOOLEAN         fFreeRecords
    );

#endif  // not MIDL_PASS



//
//  Directory partition APIs
//

DNS_STATUS
DNS_API_FUNCTION
DnssrvSetupDefaultDirectoryPartitions(
    IN      LPCWSTR                         Server,
    IN      DWORD                           dwOperation
    );

DNS_STATUS
DNS_API_FUNCTION
DnssrvEnumDirectoryPartitions(
    IN      LPCWSTR                         Server,
    IN      DWORD                           dwFilter,
    OUT     PDNS_RPC_DP_LIST *              ppDpList
    );

DNS_STATUS
DNS_API_FUNCTION
DnssrvDirectoryPartitionInfo(
    IN      LPCWSTR                 Server,
    IN      LPSTR                   pDpFqdn,
    OUT     PDNS_RPC_DP_INFO *      ppDpInfo
    );

DNS_STATUS
DNS_API_FUNCTION
DnssrvGetDpInfo(
    IN      LPCWSTR                 pwszServer,
    IN      LPCSTR                  pszDp,
    OUT     PDNS_RPC_DP_INFO *      ppDpInfo
    );

VOID
DNS_API_FUNCTION
DnssrvFreeDirectoryPartitionEnum(
    IN OUT  PDNS_RPC_DP_ENUM                pDp
    );

VOID
DNS_API_FUNCTION
DnssrvFreeDirectoryPartitionInfo(
    IN OUT  PDNS_RPC_DP_INFO                pDp
    );

VOID
DNS_API_FUNCTION
DnssrvFreeDirectoryPartitionList(
    IN OUT  PDNS_RPC_DP_LIST                pDpList
    );

DNS_STATUS
DNS_API_FUNCTION
DnssrvEnlistDirectoryPartition(
    IN      LPCWSTR                         pszServer,
    IN      DWORD                           dwOperation,
    IN      LPCSTR                          pszDirPartFqdn
    );





//
//  NT5+ General API
//
//  For NT5+ there is a very small set of actually remoteable API,
//  which are highly extensible.  The basic approach is to have
//  query and operation functions which can handle many different
//  operations by taking the operation and type as parameters.
//

//
//  DNS Server Properties
//
//  Properties may be queried.
//  Properties may and new data may be sent in as operation to
//  reset property.
//

#define DNS_REGKEY_BOOT_REGISTRY            "EnableRegistryBoot"
#define DNS_REGKEY_BOOT_METHOD              "BootMethod"
#define DNS_REGKEY_ADMIN_CONFIGURED         "AdminConfigured"

#define DNS_REGKEY_BOOT_FILENAME            "BootFile"
#define DNS_REGKEY_ROOT_HINTS_FILE          "RootHintsFile"
#define DNS_REGKEY_DATABASE_DIRECTORY       "DatabaseDirectory"
#define DNS_REGKEY_RPC_PROTOCOL             "RpcProtocol"
#define DNS_REGKEY_LOG_LEVEL                "LogLevel"
#define DNS_REGKEY_LOG_FILE_MAX_SIZE        "LogFileMaxSize"
#define DNS_REGKEY_LOG_FILE_PATH            "LogFilePath"
#define DNS_REGKEY_LOG_IP_FILTER_LIST       "LogIPFilterList"
#define DNS_REGKEY_EVENTLOG_LEVEL           "EventLogLevel"
#define DNS_REGKEY_USE_SYSTEM_EVENTLOG      "UseSystemEventLog"
#define DNS_REGKEY_DEBUG_LEVEL              "DebugLevel"

#define DNS_REGKEY_LISTEN_ADDRESSES         "ListenAddresses"
#define DNS_REGKEY_PUBLISH_ADDRESSES        "PublishAddresses"
#define DNS_REGKEY_DISJOINT_NETS            "DisjointNets"
#define DNS_REGKEY_SEND_PORT                "SendPort"
#define DNS_REGKEY_NO_TCP                   "NoTcp"
#define DNS_REGKEY_XFR_CONNECT_TIMEOUT      "XfrConnectTimeout"

#define DNS_REGKEY_NO_RECURSION             "NoRecursion"
#define DNS_REGKEY_RECURSE_SINGLE_LABEL     "RecurseSingleLabel"
#define DNS_REGKEY_MAX_CACHE_TTL            "MaxCacheTtl"
#define DNS_REGKEY_MAX_NEGATIVE_CACHE_TTL   "MaxNegativeCacheTtl"
#define DNS_REGKEY_SECURE_RESPONSES         "SecureResponses"
#define DNS_REGKEY_RECURSION_RETRY          "RecursionRetry"
#define DNS_REGKEY_RECURSION_TIMEOUT        "RecursionTimeout"
#define DNS_REGKEY_ADDITIONAL_RECURSION_TIMEOUT     "AdditionalRecursionTimeout"
#define DNS_REGKEY_FORWARDERS               "Forwarders"
#define DNS_REGKEY_FORWARD_TIMEOUT          "ForwardingTimeout"
#define DNS_REGKEY_SLAVE                    "IsSlave"
#define DNS_REGKEY_FORWARD_DELEGATIONS      "ForwardDelegations"
#define DNS_REGKEY_INET_RECURSE_TO_ROOT_MASK    "RecurseToInternetRootMask"
#define DNS_REGKEY_AUTO_CREATE_DELEGATIONS  "AutoCreateDelegations"

#define DNS_REGKEY_NO_AUTO_REVERSE_ZONES    "DisableAutoReverseZones"
#define DNS_REGKEY_DS_POLLING_INTERVAL      "DsPollingInterval"
#define DNS_REGKEY_DS_TOMBSTONE_INTERVAL    "DsTombstoneInterval"

#define DNS_REGKEY_AUTO_CACHE_UPDATE        "AutoCacheUpdate"
#define DNS_REGKEY_ALLOW_UPDATE             "AllowUpdate"
#define DNS_REGKEY_UPDATE_OPTIONS           "UpdateOptions"
#define DNS_REGKEY_NO_UPDATE_DELEGATIONS    "NoUpdateDelegations"
#define DNS_REGKEY_AUTO_CONFIG_FILE_ZONES   "AutoConfigFileZones"
#define DNS_REGKEY_SCAVENGING_INTERVAL      "ScavengingInterval"
#define DNS_REGKEY_SCAVENGING_STATE         "ScavengingState"

#define DNS_REGKEY_NAME_CHECK_FLAG              "NameCheckFlag"
#define DNS_REGKEY_ROUND_ROBIN                  "RoundRobin"
#define DNS_REGKEY_NO_ROUND_ROBIN               "DoNotRoundRobinTypes"
#define DNS_REGKEY_LOCAL_NET_PRIORITY           "LocalNetPriority"
#define DNS_REGKEY_LOCAL_NET_PRIORITY_NETMASK   "LocalNetPriorityNetMask"
#define DNS_REGKEY_ADDRESS_ANSWER_LIMIT         "AddressAnswerLimit"
#define DNS_REGKEY_BIND_SECONDARIES             "BindSecondaries"
#define DNS_REGKEY_WRITE_AUTHORITY_SOA          "WriteAuthoritySoa"
#define DNS_REGKEY_WRITE_AUTHORITY_NS           "WriteAuthorityNs"
#define DNS_REGKEY_STRICT_FILE_PARSING          "StrictFileParsing"
#define DNS_REGKEY_DELETE_OUTSIDE_GLUE          "DeleteOutsideGlue"
#define DNS_REGKEY_LOOSE_WILDCARDING            "LooseWildcarding"
#define DNS_REGKEY_WILDCARD_ALL_TYPES           "WildcardAllTypes"

#define DNS_REGKEY_APPEND_MS_XFR_TAG            "AppendMsZoneTransferTag"

#define DNS_REGKEY_DEFAULT_AGING_STATE          "DefaultAgingState"
#define DNS_REGKEY_DEFAULT_REFRESH_INTERVAL     "DefaultRefreshInterval"
#define DNS_REGKEY_DEFAULT_NOREFRESH_INTERVAL   "DefaultNoRefreshInterval"

#define DNS_REGKEY_MAX_CACHE_SIZE           "MaxCacheSize"      //  in kilobytes

#define DNS_REGKEY_ENABLE_EDNS              "EnableEDnsProbes"
#define DNS_REGKEY_MAX_UDP_PACKET_SIZE      "MaximumUdpPacketSize"
#define DNS_REGKEY_EDNS_CACHE_TIMEOUT       "EDnsCacheTimeout"

#define DNS_REGKEY_ENABLE_DNSSEC            "EnableDnsSec"


#define DNS_REGKEY_ENABLE_SENDERR_SUPPRESSION   "EnableSendErrorSuppression"

//  Diretory partitions

#define DNS_REGKEY_ENABLE_DP                "EnableDirectoryPartitions"
#define DNS_REGKEY_FOREST_DP_BASE_NAME      "ForestDirectoryPartitionBaseName"
#define DNS_REGKEY_DOMAIN_DP_BASE_NAME      "DomainDirectoryPartitionBaseName"

#define DNS_REGKEY_DISABLE_AUTONS           "DisableNSRecordsAutoCreation" // 0/1 flag

#define DNS_REGKEY_SILENT_IGNORE_CNAME_UPDATE_CONFLICT  "SilentlyIgnoreCNameUpdateConflicts"

//  Zone properties

#define DNS_REGKEY_ZONE_TYPE                "Type"
#define DNS_REGKEY_ZONE_FILE                "DatabaseFile"
#define DNS_REGKEY_ZONE_MASTERS             "MasterServers"
#define DNS_REGKEY_ZONE_LOCAL_MASTERS       "LocalMasterServers"
#define DNS_REGKEY_ZONE_SECURE_SECONDARIES  "SecureSecondaries"
#define DNS_REGKEY_ZONE_NOTIFY_LEVEL        "NotifyLevel"
#define DNS_REGKEY_ZONE_SECONDARIES         "SecondaryServers"
#define DNS_REGKEY_ZONE_NOTIFY_LIST         "NotifyServers"
#define DNS_REGKEY_ZONE_ALLOW_UPDATE        "AllowUpdate"
#define DNS_REGKEY_ZONE_DS_INTEGRATED       "DsIntegrated"
#define DNS_REGKEY_ZONE_LOG_UPDATES         "LogUpdates"
#define DNS_REGKEY_ZONE_FWD_TIMEOUT         "ForwarderTimeout"
#define DNS_REGKEY_ZONE_FWD_SLAVE           "ForwarderSlave"

#define DNS_REGKEY_ZONE_AGING               "Aging"
#define DNS_REGKEY_ZONE_NOREFRESH_INTERVAL  "NoRefreshInterval"
#define DNS_REGKEY_ZONE_REFRESH_INTERVAL    "RefreshInterval"
#define DNS_REGKEY_ZONE_SCAVENGE_SERVERS    "ScavengeServers"

#define DNS_REGKEY_ZONE_ALLOW_AUTONS        "AllowNSRecordsAutoCreation" // IP list


//
//  Debugging aids
//

#define DNS_REGKEY_BREAK_ON_ASC_FAILURE         "BreakOnAscFailure"     //  0/1 - ASC=AcceptSecurityContext
#define DNS_REGKEY_BREAK_ON_UPDATE_FROM         "BreakOnUpdateFrom"     //  IP list
#define DNS_REGKEY_BREAK_ON_RECV_FROM           "BreakOnReceiveFrom"    //  IP list
#define DNS_REGKEY_ZONE_BREAK_ON_NAME_UPDATE    "BreakOnNameUpdate"     //  node name


//
//  Property defaults
//

//  DCR_CLEANUP:   remove PROP_BOOT_X flags
#define PROP_BOOT_REGISTRY                  (1)
#define PROP_BOOT_FILE                      (0)

#define DNS_DEFAULT_BOOT_REGISTRY           (PROP_BOOT_REGISTRY)

#define DNS_DEFAULT_BOOT_METHOD             (BOOT_METHOD_UNINITIALIZED)
#define DNS_DEFAULT_RPC_PROTOCOL            (0xffffffff)
#define DNS_DEFAULT_LOG_LEVEL               (0)
#define DNS_DEFAULT_LOG_FILE_MAX_SIZE       (500000000) //  500 MB
#define DNS_DEFAULT_EVENTLOG_LEVEL          (EVENTLOG_INFORMATION_TYPE)
#define DNS_DEFAULT_USE_SYSTEM_EVENTLOG     FALSE
#define DNS_DEFAULT_DEBUG_LEVEL             (0)

#define DNS_DEFAULT_SEND_PORT               (0)
#define DNS_DEFAULT_NO_TCP                  FALSE
#define DNS_DEFAULT_DISJOINT_NETS           FALSE
#define DNS_DEFAULT_SEND_ON_NON_DNS_PORT    FALSE
#define DNS_DEFAULT_XFR_CONNECT_TIMEOUT     (30)        // 30 seconds

#define DNS_DEFAULT_NO_RECURSION            FALSE
#define DNS_DEFAULT_RECURSE_SINGLE_LABEL    FALSE
#define DNS_DEFAULT_MAX_CACHE_TTL           (86400)     // 1 day
#define DNS_DEFAULT_MAX_NEGATIVE_CACHE_TTL  (900)       // 15 minutes
#define DNS_DEFAULT_SECURE_RESPONSES        FALSE
#define DNS_DEFAULT_RECURSION_RETRY         (3)         // 3 seconds
#define DNS_DEFAULT_RECURSION_TIMEOUT       (15)        // 15 seconds
#define DNS_DEFAULT_ADDITIONAL_RECURSION_TIMEOUT (15)   // 15 seconds
#define DNS_DEFAULT_FORWARD_TIMEOUT         (5)         // 5 seconds
#define DNS_DEFAULT_SLAVE                   FALSE
#define DNS_DEFAULT_FORWARD_DELEGATIONS     FALSE
#define DNS_DEFAULT_INET_RECURSE_TO_ROOT_MASK   0xFFFFFFFF  //  all ON by default

#define DNS_DEFAULT_NO_AUTO_REVERSE_ZONES   FALSE
#define DNS_DEFAULT_DS_POLLING_INTERVAL     (300)       // 5 minutes
#define DNS_DEFAULT_DS_TOMBSTONE_INTERVAL   (604800)    // 1 week
#define DNS_DEFAULT_AUTO_CACHE_UPDATE       FALSE
#define DNS_DEFAULT_ALLOW_UPDATE            ZONE_UPDATE_UNSECURE
#define DNS_DEFAULT_NO_UPDATE_DELEGATIONS   FALSE
#define DNS_DEFAULT_DISABLE_AUTO_NS_RECORDS FALSE

#define DNS_DEFAULT_NAME_CHECK_FLAG         DNS_ALLOW_MULTIBYTE_NAMES
#define DNS_DEFAULT_ROUND_ROBIN             TRUE
#define DNS_DEFAULT_ADDRESS_ANSWER_LIMIT    (0)
#define DNS_DEFAULT_BIND_SECONDARIES        TRUE
#define DNS_DEFAULT_WRITE_AUTHORITY_NS      FALSE
#define DNS_DEFAULT_STRICT_FILE_PARSING     FALSE
#define DNS_DEFAULT_DELETE_OUTSIDE_GLUE     FALSE
#define DNS_DEFAULT_LOOSE_WILDCARDING       FALSE
#define DNS_DEFAULT_WILDCARD_ALL_TYPES      FALSE

#define DNS_DEFAULT_APPEND_MS_XFR_TAG       TRUE

#define DNS_DEFAULT_SCAVENGING_INTERVAL     (0)         // scavenging OFF
#define DNS_DEFAULT_SCAVENGING_INTERVAL_ON  (168)       // a week, 7*24 hours

#define DNS_DEFAULT_AGING_STATE             FALSE
#define DNS_DEFAULT_NOREFRESH_INTERVAL      (168)       // a week, 7*24 hours
#define DNS_DEFAULT_REFRESH_INTERVAL        (168)       // a week (7*24)

#define DNS_SERVER_UNLIMITED_CACHE_SIZE         ((DWORD)-1)     //  default: no limit

#define DNS_DEFAULT_LOCAL_NET_PRIORITY          TRUE
#define DNS_DEFAULT_LOCAL_NET_PRIORITY_NETMASK  0x000000FF      //  sort down to class C netmask

#define DNS_DEFAULT_FOREST_DP_BASE          "ForestDnsZones"
#define DNS_DEFAULT_DOMAIN_DP_BASE          "DomainDnsZones"

#define DNS_DEFAULT_AUTO_CREATION_DELEGATIONS   DNS_ACD_ONLY_IF_NO_DELEGATION_IN_PARENT

#define DNS_DNSSEC_ENABLE_DEFAULT           DNS_DNSSEC_ENABLED_IF_EDNS



//
//  Operations
//
//  In addition to resetting properties, the following operations
//  are available.
//

//  Server operations

#define DNSSRV_OP_RESET_DWORD_PROPERTY      "ResetDwordProperty"
#define DNSSRV_OP_RESTART                   "Restart"
#define DNSSRV_OP_DEBUG_BREAK               "DebugBreak"
#define DNSSRV_OP_CLEAR_DEBUG_LOG           "ClearDebugLog"
#define DNSSRV_OP_ROOT_BREAK                "RootBreak"
#define DNSSRV_OP_CLEAR_CACHE               "ClearCache"
#define DNSSRV_OP_WRITE_DIRTY_ZONES         "WriteDirtyZones"
#define DNSSRV_OP_ZONE_CREATE               "ZoneCreate"
#define DNSSRV_OP_CLEAR_STATISTICS          "ClearStatistics"
#define DNSSRV_OP_ENUM_ZONES                "EnumZones"
#define DNSSRV_OP_ENUM_DPS                  "EnumDirectoryPartitions"
#define DNSSRV_OP_DP_INFO                   "DirectoryPartitionInfo"
#define DNSSRV_OP_ENLIST_DP                 "EnlistDirectoryPartition"
#define DNSSRV_OP_SETUP_DFLT_DPS            "SetupDefaultDirectoryPartitions"
#define DNSSRV_OP_ENUM_RECORDS              "EnumRecords"
#define DNSSRV_OP_START_SCAVENGING          "StartScavenging"
#define DNSSRV_OP_ABORT_SCAVENGING          "AbortScavenging"

//  Zone operations

#define DNSSRV_OP_ZONE_TYPE_RESET           "ZoneTypeReset"
#define DNSSRV_OP_ZONE_PAUSE                "PauseZone"
#define DNSSRV_OP_ZONE_RESUME               "ResumeZone"
#define DNSSRV_OP_ZONE_LOCK                 "LockZone"
#define DNSSRV_OP_ZONE_DELETE               "DeleteZone"
#define DNSSRV_OP_ZONE_RELOAD               "ReloadZone"
#define DNSSRV_OP_ZONE_REFRESH              "RefreshZone"
#define DNSSRV_OP_ZONE_EXPIRE               "ExpireZone"
#define DNSSRV_OP_ZONE_INCREMENT_VERSION    "IncrementVersion"
#define DNSSRV_OP_ZONE_WRITE_BACK_FILE      "WriteBackFile"
#define DNSSRV_OP_ZONE_WRITE_ANSI_FILE      "WriteAnsiFile"
#define DNSSRV_OP_ZONE_DELETE_FROM_DS       "DeleteZoneFromDs"
#define DNSSRV_OP_ZONE_UPDATE_FROM_DS       "UpdateZoneFromDs"
#define DNSSRV_OP_ZONE_RENAME               "ZoneRename"
#define DNSSRV_OP_ZONE_EXPORT               "ZoneExport"
#define DNSSRV_OP_ZONE_CHANGE_DP            "ZoneChangeDirectoryPartition"

#define DNSSRV_OP_UPDATE_RECORD             "UpdateRecord"
#define DNSSRV_OP_DELETE_NODE               "DeleteNode"
#define DNSSRV_OP_ZONE_DELETE_NODE          DNSSRV_OP_DELETE_NODE
#define DNSSRV_OP_DELETE_RECORD_SET         "DeleteRecordSet"
#define DNSSRV_OP_FORCE_AGING_ON_NODE       "ForceAgingOnNode"

//
//  Special non-property queries
//

#define DNSSRV_QUERY_DWORD_PROPERTY         "QueryDwordProperty"
#define DNSSRV_QUERY_STRING_PROPERTY        "QueryStringProperty"
#define DNSSRV_QUERY_IPLIST_PROPERTY        "QueryIPListProperty"
#define DNSSRV_QUERY_SERVER_INFO            "ServerInfo"
#define DNSSRV_QUERY_STATISTICS             "Statistics"

#define DNSSRV_QUERY_ZONE_HANDLE            "ZoneHandle"
#define DNSSRV_QUERY_ZONE                   "Zone"
#define DNSSRV_QUERY_ZONE_INFO              "ZoneInfo"

//
// Values for DNS_RPC_NAME_AND_PARAM.dwParam
//
//
#define DNSSRV_OP_PARAM_APPLY_ALL_ZONES     0x10000000
#define REMOVE_APPLY_ALL_BIT(val)           ((LONG)val &=  (~DNSSRV_OP_PARAM_APPLY_ALL_ZONES) )


//
//  Log levels for setting LogLevel property
//

#define DNS_LOG_LEVEL_ALL_PACKETS   0x0000ffff

#define DNS_LOG_LEVEL_NON_QUERY     0x000000fe
#define DNS_LOG_LEVEL_QUERY         0x00000001
#define DNS_LOG_LEVEL_NOTIFY        0x00000010
#define DNS_LOG_LEVEL_UPDATE        0x00000020

#define DNS_LOG_LEVEL_QUESTIONS     0x00000100
#define DNS_LOG_LEVEL_ANSWERS       0x00000200

#define DNS_LOG_LEVEL_SEND          0x00001000
#define DNS_LOG_LEVEL_RECV          0x00002000

#define DNS_LOG_LEVEL_UDP           0x00004000
#define DNS_LOG_LEVEL_TCP           0x00008000

#define DNS_LOG_LEVEL_DS_WRITE      0x00010000
#define DNS_LOG_LEVEL_DS_UPDATE     0x00020000

#define DNS_LOG_LEVEL_FULL_PACKETS  0x01000000
#define DNS_LOG_LEVEL_WRITE_THROUGH 0x80000000

//
//  Settings for BootMethod property
//

#define BOOT_METHOD_UNINITIALIZED   (0)
#define BOOT_METHOD_FILE            (1)
#define BOOT_METHOD_REGISTRY        (2)
#define BOOT_METHOD_DIRECTORY       (3)

#define BOOT_METHOD_DEFAULT         (BOOT_METHOD_DIRECTORY)

//  Server, default aging property

#define DNS_AGING_OFF               (0)
#define DNS_AGING_DS_ZONES          (0x0000001)
#define DNS_AGING_NON_DS_ZONES      (0x0000002)
#define DNS_AGING_ALL_ZONES         (0x0000003)



//
//  Union of RPC types
//
//  This allows us to write very general API taking UNION type
//  with is extensible simply by adding operationa and types.
//  RPC simply packs\unpacks the UNION type appropriately.
//
//  Note, that UNION is actually union of pointers to types, so
//  that data can be passed between the API and the RPC stubs (on the client)
//  or dispatched (on the server) efficiently.
//

typedef enum _DnssrvRpcTypeId
{
    DNSSRV_TYPEID_ANY = ( -1 ),
    DNSSRV_TYPEID_NULL = 0,
    DNSSRV_TYPEID_DWORD,
    DNSSRV_TYPEID_LPSTR,
    DNSSRV_TYPEID_LPWSTR,
    DNSSRV_TYPEID_IPARRAY,
    DNSSRV_TYPEID_BUFFER,                       //  5
    DNSSRV_TYPEID_SERVER_INFO_W2K,
    DNSSRV_TYPEID_STATS,
    DNSSRV_TYPEID_FORWARDERS_W2K,
    DNSSRV_TYPEID_ZONE_W2K,
    DNSSRV_TYPEID_ZONE_INFO_W2K,                //  10
    DNSSRV_TYPEID_ZONE_SECONDARIES_W2K,
    DNSSRV_TYPEID_ZONE_DATABASE_W2K,
    DNSSRV_TYPEID_ZONE_TYPE_RESET_W2K,
    DNSSRV_TYPEID_ZONE_CREATE_W2K,
    DNSSRV_TYPEID_NAME_AND_PARAM,               //  15
    DNSSRV_TYPEID_ZONE_LIST_W2K,

    //
    //  Below this point is Whistler.
    //

    DNSSRV_TYPEID_ZONE_RENAME,
    DNSSRV_TYPEID_ZONE_EXPORT,
    DNSSRV_TYPEID_SERVER_INFO,
    DNSSRV_TYPEID_FORWARDERS,                   //  20
    DNSSRV_TYPEID_ZONE,
    DNSSRV_TYPEID_ZONE_INFO,
    DNSSRV_TYPEID_ZONE_SECONDARIES,
    DNSSRV_TYPEID_ZONE_DATABASE,
    DNSSRV_TYPEID_ZONE_TYPE_RESET,              //  25
    DNSSRV_TYPEID_ZONE_CREATE,
    DNSSRV_TYPEID_ZONE_LIST,
    DNSSRV_TYPEID_DP_ENUM,
    DNSSRV_TYPEID_DP_INFO,
    DNSSRV_TYPEID_DP_LIST,
    DNSSRV_TYPEID_ENLIST_DP,
    DNSSRV_TYPEID_ZONE_CHANGE_DP
}
DNS_RPC_TYPEID, *PDNS_RPC_TYPEID;


#ifdef MIDL_PASS

typedef [switch_type(DWORD)] union _DnssrvSrvRpcUnion
{
    [case(DNSSRV_TYPEID_NULL)]      PBYTE       Null;

    [case(DNSSRV_TYPEID_DWORD)]     DWORD       Dword;

    [case(DNSSRV_TYPEID_LPSTR)]     LPSTR       String;

    [case(DNSSRV_TYPEID_LPWSTR)]    LPWSTR      WideString;

    [case(DNSSRV_TYPEID_IPARRAY)]   PIP_ARRAY   IpArray;

    [case(DNSSRV_TYPEID_BUFFER)]
        PDNS_RPC_BUFFER                         Buffer;

    [case(DNSSRV_TYPEID_SERVER_INFO_W2K)]
        PDNS_RPC_SERVER_INFO_W2K                ServerInfoW2K;

    [case(DNSSRV_TYPEID_STATS)]
        PDNSSRV_STATS                           Stats;

    [case(DNSSRV_TYPEID_FORWARDERS_W2K)]
        PDNS_RPC_FORWARDERS_W2K                 ForwardersW2K;

    [case(DNSSRV_TYPEID_ZONE_W2K)]
        PDNS_RPC_ZONE_W2K                       ZoneW2K;

    [case(DNSSRV_TYPEID_ZONE_INFO_W2K)]
        PDNS_RPC_ZONE_INFO_W2K                  ZoneInfoW2K;

    [case(DNSSRV_TYPEID_ZONE_SECONDARIES_W2K)]
        PDNS_RPC_ZONE_SECONDARIES_W2K           SecondariesW2K;

    [case(DNSSRV_TYPEID_ZONE_DATABASE_W2K)]
        PDNS_RPC_ZONE_DATABASE_W2K              DatabaseW2K;

    [case(DNSSRV_TYPEID_ZONE_TYPE_RESET_W2K)]
        PDNS_RPC_ZONE_TYPE_RESET_W2K            TypeResetW2K;

    [case(DNSSRV_TYPEID_ZONE_CREATE_W2K)]
        PDNS_RPC_ZONE_CREATE_INFO_W2K           ZoneCreateW2K;

    [case(DNSSRV_TYPEID_NAME_AND_PARAM)]
        PDNS_RPC_NAME_AND_PARAM                 NameAndParam;

    [case(DNSSRV_TYPEID_ZONE_LIST_W2K)]
        PDNS_RPC_ZONE_LIST_W2K                  ZoneListW2K;

    //
    //  Below this point is Whistler.
    //
    
    [case(DNSSRV_TYPEID_SERVER_INFO)]
        PDNS_RPC_SERVER_INFO                    ServerInfo;

    [case(DNSSRV_TYPEID_FORWARDERS)]
        PDNS_RPC_FORWARDERS                     Forwarders;

    [case(DNSSRV_TYPEID_ZONE)]
        PDNS_RPC_ZONE                           Zone;

    [case(DNSSRV_TYPEID_ZONE_INFO)]
        PDNS_RPC_ZONE_INFO                      ZoneInfo;

    [case(DNSSRV_TYPEID_ZONE_SECONDARIES)]
        PDNS_RPC_ZONE_SECONDARIES               Secondaries;

    [case(DNSSRV_TYPEID_ZONE_DATABASE)]
        PDNS_RPC_ZONE_DATABASE                  Database;

    [case(DNSSRV_TYPEID_ZONE_TYPE_RESET)]
        PDNS_RPC_ZONE_TYPE_RESET                TypeReset;

    [case(DNSSRV_TYPEID_ZONE_CREATE)]
        PDNS_RPC_ZONE_CREATE_INFO               ZoneCreate;

    [case(DNSSRV_TYPEID_ZONE_LIST)]
        PDNS_RPC_ZONE_LIST                      ZoneList;

    [case(DNSSRV_TYPEID_ZONE_RENAME)]
        PDNS_RPC_ZONE_RENAME_INFO               ZoneRename;

    [case(DNSSRV_TYPEID_ZONE_EXPORT)]
        PDNS_RPC_ZONE_EXPORT_INFO               ZoneExport;

    [case(DNSSRV_TYPEID_DP_INFO)]
        PDNS_RPC_DP_INFO                        DirectoryPartition;

    [case(DNSSRV_TYPEID_DP_ENUM)]
        PDNS_RPC_DP_ENUM                        DirectoryPartitionEnum;

    [case(DNSSRV_TYPEID_DP_LIST)]
        PDNS_RPC_DP_LIST                        DirectoryPartitionList;

    [case(DNSSRV_TYPEID_ENLIST_DP)]
        PDNS_RPC_ENLIST_DP                      EnlistDirectoryPartition;

    [case(DNSSRV_TYPEID_ZONE_CHANGE_DP)]
        PDNS_RPC_ZONE_CHANGE_DP                 ZoneChangeDirectoryPartition;
}
DNSSRV_RPC_UNION;

#else

typedef union _DnssrvSrvRpcUnion
{
    PBYTE                           Null;
    DWORD                           Dword;
    LPSTR                           String;
    LPWSTR                          WideString;
    PIP_ARRAY                       IpArray;
    PDNS_RPC_BUFFER                 Buffer;
    PDNS_RPC_SERVER_INFO_W2K        ServerInfoW2K;
    PDNSSRV_STATS                   Stats;
    PDNS_RPC_FORWARDERS_W2K         ForwardersW2K;
    PDNS_RPC_ZONE_W2K               ZoneW2K;
    PDNS_RPC_ZONE_INFO_W2K          ZoneInfoW2K;
    PDNS_RPC_ZONE_SECONDARIES_W2K   SecondariesW2K;
    PDNS_RPC_ZONE_DATABASE_W2K      DatabaseW2K;
    PDNS_RPC_ZONE_TYPE_RESET_W2K    TypeResetW2K;
    PDNS_RPC_ZONE_CREATE_INFO_W2K   ZoneCreateW2K;
    PDNS_RPC_NAME_AND_PARAM         NameAndParam;
    PDNS_RPC_ZONE_LIST_W2K          ZoneListW2K;
    PDNS_RPC_SERVER_INFO            ServerInfo;
    PDNS_RPC_FORWARDERS             Forwarders;
    PDNS_RPC_ZONE                   Zone;
    PDNS_RPC_ZONE_INFO              ZoneInfo;
    PDNS_RPC_ZONE_SECONDARIES       Secondaries;
    PDNS_RPC_ZONE_DATABASE          Database;
    PDNS_RPC_ZONE_TYPE_RESET        TypeReset;
    PDNS_RPC_ZONE_CREATE_INFO       ZoneCreate;
    PDNS_RPC_ZONE_LIST              ZoneList;
    PDNS_RPC_ZONE_RENAME_INFO       ZoneRename;
    PDNS_RPC_ZONE_EXPORT_INFO       ZoneExport;
    PDNS_RPC_DP_INFO                DirectoryPartition;
    PDNS_RPC_DP_ENUM                DirectoryPartitionEnum;
    PDNS_RPC_DP_LIST                DirectoryPartitionList;
    PDNS_RPC_ENLIST_DP              EnlistDirectoryPartition;
    PDNS_RPC_ZONE_CHANGE_DP         ZoneResetDirectoryPartition;

    //
    //  should add DNS_RECORD and DNS_NODE
    //
}
DNSSRV_RPC_UNION;

#endif


//
//  General Query and Operation API
//
//  Many of the API above are not remoteable but rather use these
//  API to contact the server.  The data fields are actually the
//  DNSSRV_RPC_UNION of pointers given above.
//
//  Client version is a 32 bit private version number in the format:
//      HIGH WORD - major OS version
//      LOW WORD - minor private version to allow for service packs, etc.
//

#define MAKE_DNS_CLIENT_VERSION( hiWord, loWord ) \
    ( ( DWORD ) ( ( ( hiWord & 0xFFFF ) << 16 ) | ( loWord & 0xFFFF ) ) )

#define DNS_RPC_WHISTLER_MAJOR_VER              6   //  6 for Whistler
#define DNS_RPC_WHISTLER_CURRENT_MINOR_VER      0   //  increment as required

#define DNS_RPC_W2K_CLIENT_VERSION              0   //  W2K does not send ver

#define DNS_RPC_CURRENT_CLIENT_VER              \
    MAKE_DNS_CLIENT_VERSION(                    \
        DNS_RPC_WHISTLER_MAJOR_VER,             \
        DNS_RPC_WHISTLER_CURRENT_MINOR_VER )

DNS_STATUS
DnssrvOperationEx(
    IN      DWORD           dwClientVersion,
    IN      DWORD           dwSettingFlags,
    IN      LPCWSTR         pwszServer,
    IN      LPCSTR          pszZone,
    IN      DWORD           dwContext,
    IN      LPCSTR          pszOperation,
    IN      DWORD           dwTypeId,
    IN      PVOID           Data
    );

#define DnssrvOperation( s, z, op, id, d )          \
    DnssrvOperationEx( DNS_RPC_CURRENT_CLIENT_VER,  \
        0, (s), (z), 0, (op), (id), (d) )

DNS_STATUS
DnssrvQueryEx(
    IN      DWORD           dwClientVersion,
    IN      DWORD           dwSettingFlags,
    IN      LPCWSTR         pwszServer,
    IN      LPCSTR          pszZone,
    IN      LPCSTR          pszOperation,
    OUT     PDWORD          pdwTypeId,
    OUT     PVOID *         pData
    );

#define DnssrvQuery( s, z, op, id, d )          \
    DnssrvQueryEx( DNS_RPC_CURRENT_CLIENT_VER,  \
        0, (s), (z), (op), (id), (d) )

DNS_STATUS
DNS_API_FUNCTION
DnssrvComplexOperationEx(
    IN      DWORD           dwClientVersion,
    IN      DWORD           dwSettingFlags,
    IN      LPCWSTR         pwszServer,
    IN      LPCSTR          pszZone,
    IN      LPCSTR          pszQuery,
    IN      DWORD           dwTypeIn,
    IN      PVOID           pDataIn,
    OUT     PDWORD          pdwTypeOut,
    OUT     PVOID *         ppDataOutOut
    );

#define DnssrvComplexOperation( s, z, q, typein, din, typeout, dout )   \
    DnssrvComplexOperationEx( DNS_RPC_CURRENT_CLIENT_VER,               \
        0, (s), (z), (q), (typein), (din), (typeout), (dout) )


//
//  DWORD properties query\reset are a common case
//

DNS_STATUS
DNS_API_FUNCTION
DnssrvQueryDwordPropertyEx(
    IN      DWORD           dwClientVersion,
    IN      DWORD           dwSettingFlags,
    IN      LPCWSTR         pwszServer,
    IN      LPCSTR          pszZone,
    IN      LPCSTR          pszProperty,
    OUT     PDWORD          pdwResult
    );

#define DnssrvQueryDwordProperty( s, z, p, r )                  \
    DnssrvQueryDwordPropertyEx( DNS_RPC_CURRENT_CLIENT_VER,     \
        0, (s), (z), (p), (r) )

DNS_STATUS
DNS_API_FUNCTION
DnssrvResetDwordPropertyEx(
    IN      DWORD           dwClientVersion,
    IN      DWORD           dwSettingFlags,
    IN      LPCWSTR         pwszServer,
    IN      LPCSTR          pszZone,
    IN      DWORD           dwContext,
    IN      LPCSTR          pszProperty,
    IN      DWORD           dwPropertyValue
    );

#define DnssrvResetDwordProperty( s, z, p, v )                  \
    DnssrvResetDwordPropertyEx( DNS_RPC_CURRENT_CLIENT_VER,     \
        0, (s), (z), 0, (p), (v) )

#define DnssrvResetDwordPropertyWithContext( s, z, c, p, v )    \
    DnssrvResetDwordPropertyEx( DNS_RPC_CURRENT_CLIENT_VER,     \
        0, (s), (z), (c), (p), (v) )


DNS_STATUS
DNS_API_FUNCTION
DnssrvResetStringPropertyEx(
    IN      DWORD           dwClientVersion,
    IN      DWORD           dwSettingFlags,
    IN      LPCWSTR         pwszServerName,
    IN      LPCSTR          pszZone,
    IN      DWORD           dwContext,
    IN      LPCSTR          pszProperty,
    IN      LPCWSTR         pswzPropertyValue,
    IN      DWORD           dwFlags
    );

#define DnssrvResetStringProperty( server, zone, prop, value, flags )   \
        DnssrvResetStringPropertyEx( DNS_RPC_CURRENT_CLIENT_VER,        \
            0, (server), (zone), 0, (prop), (value), (flags) )

DNS_STATUS
DNS_API_FUNCTION
DnssrvResetIPListPropertyEx(
    IN      DWORD           dwClientVersion,
    IN      DWORD           dwSettingFlags,
    IN      LPCWSTR         pwszServerName,
    IN      LPCSTR          pszZone,
    IN      DWORD           dwContext,
    IN      LPCSTR          pszProperty,
    IN      PIP_ARRAY       pipArray,
    IN      DWORD           dwFlags
    );

#define DnssrvResetIPListProperty( server, zone, prop, value, flags )   \
        DnssrvResetIPListPropertyEx( DNS_RPC_CURRENT_CLIENT_VER,        \
            0, (server), (zone), 0, (prop), (value), (flags) )



//
//  RPC-related functions shared by client and server
//

#ifndef MIDL_PASS

//
//  Conversion from obsolete to current RPC structures.
//

DNS_STATUS
DNS_API_FUNCTION
DnsRpc_ConvertToCurrent(
    IN      PDWORD      pdwTypeId,          IN  OUT
    IN      PVOID *     ppData              IN  OUT
    );

//
//  Print any type in RPC Union
//

VOID
DnsPrint_RpcUnion(
    IN      PRINT_ROUTINE   PrintRoutine,
    IN OUT  PPRINT_CONTEXT  pPrintContext,
    IN      LPSTR           pszHeader,
    IN      DWORD           dwTypeId,
    IN      PVOID           pData
    );

//
//  Server info printing
//

VOID
DnsPrint_RpcServerInfo(
    IN      PRINT_ROUTINE           PrintRoutine,
    IN OUT  PPRINT_CONTEXT          pPrintContext,
    IN      LPSTR                   pszHeader,
    IN      PDNS_RPC_SERVER_INFO    pServerInfo
    );

VOID
DnsPrint_RpcServerInfo_W2K(
    IN      PRINT_ROUTINE               PrintRoutine,
    IN OUT  PPRINT_CONTEXT              pPrintContext,
    IN      LPSTR                       pszHeader,
    IN      PDNS_RPC_SERVER_INFO_W2K    pServerInfo
    );

VOID
DnsPrint_RpcSingleStat(
    IN      PRINT_ROUTINE   PrintRoutine,
    IN OUT  PPRINT_CONTEXT  pPrintContext,
    IN      LPSTR           pszHeader,
    IN      PDNSSRV_STAT    pStat
    );

VOID
DnsPrint_RpcStatsBuffer(
    IN      PRINT_ROUTINE       PrintRoutine,
    IN OUT  PPRINT_CONTEXT      pPrintContext,
    IN      LPSTR               pszHeader,
    IN      PDNS_RPC_BUFFER     pBuffer
    );

VOID
DnsPrint_RpcStatRaw(
    IN      PRINT_ROUTINE   PrintRoutine,
    IN OUT  PPRINT_CONTEXT  pPrintContext,
    IN      LPSTR           pszHeader,
    IN      PDNSSRV_STAT    pStat,
    IN      DNS_STATUS      Status
    );

//
//  Zone info printing
//

VOID
DnsPrint_RpcZone(
    IN      PRINT_ROUTINE   PrintRoutine,
    IN OUT  PPRINT_CONTEXT  pPrintContext,
    IN      LPSTR           pszHeader,
    IN      PDNS_RPC_ZONE   pZone
    );

VOID
DnsPrint_RpcZone_W2K(
    IN      PRINT_ROUTINE       PrintRoutine,
    IN OUT  PPRINT_CONTEXT      pPrintContext,
    IN      LPSTR               pszHeader,
    IN      PDNS_RPC_ZONE_W2K   pZone
    );

VOID
DnsPrint_RpcZoneList(
    IN      PRINT_ROUTINE       PrintRoutine,
    IN OUT  PPRINT_CONTEXT      pPrintContext,
    IN      LPSTR               pszHeader,
    IN      PDNS_RPC_ZONE_LIST  pZoneList
    );

VOID
DnsPrint_RpcZoneList_W2K(
    IN      PRINT_ROUTINE           PrintRoutine,
    IN OUT  PPRINT_CONTEXT          pPrintContext,
    IN      LPSTR                   pszHeader,
    IN      PDNS_RPC_ZONE_LIST_W2K  pZoneList
    );

VOID
DnsPrint_RpcZoneInfo(
    IN      PRINT_ROUTINE       PrintRoutine,
    IN OUT  PPRINT_CONTEXT      pPrintContext,
    IN      LPSTR               pszHeader,
    IN      PDNS_RPC_ZONE_INFO  pZoneInfo
    );

VOID
DnsPrint_RpcZoneInfo_W2K(
    IN      PRINT_ROUTINE           PrintRoutine,
    IN OUT  PPRINT_CONTEXT          pPrintContext,
    IN      LPSTR                   pszHeader,
    IN      PDNS_RPC_ZONE_INFO_W2K  pZoneInfo
    );

VOID
DnsPrint_RpcZoneInfoList(
    IN      PRINT_ROUTINE       PrintRoutine,
    IN OUT  PPRINT_CONTEXT      pPrintContext,
    IN      LPSTR               pszHeader,
    IN      DWORD               dwZoneCount,
    IN      PDNS_RPC_ZONE_INFO  apZoneInfo[]
    );

//
//  Directory partition printing
//

VOID
DnsPrint_RpcDpEnum(
    IN      PRINT_ROUTINE       PrintRoutine,
    IN OUT  PPRINT_CONTEXT      pPrintContext,
    IN      LPSTR               pszHeader,
    IN      PDNS_RPC_DP_ENUM    pDp
    );

VOID
DnsPrint_RpcDpInfo(
    IN      PRINT_ROUTINE       PrintRoutine,
    IN OUT  PPRINT_CONTEXT      pPrintContext,
    IN      LPSTR               pszHeader,
    IN      PDNS_RPC_DP_INFO    pDp,
    IN      BOOL                fTruncateLongStrings
    );

VOID
DNS_API_FUNCTION
DnsPrint_RpcDpList(
    IN      PRINT_ROUTINE       PrintRoutine,
    IN OUT  PPRINT_CONTEXT      pPrintContext,
    IN      LPSTR               pszHeader,
    IN      PDNS_RPC_DP_LIST    pDpList
    );


//
//  Node and record buffer printing
//

VOID
DnsPrint_RpcName(
    IN      PRINT_ROUTINE   PrintRoutine,
    IN OUT  PPRINT_CONTEXT  pPrintContext,
    IN      LPSTR           pszHeader,
    IN      PDNS_RPC_NAME   pName,
    IN      LPSTR           pszTrailer
    );

VOID
DnsPrint_RpcNode(
    IN      PRINT_ROUTINE   PrintRoutine,
    IN OUT  PPRINT_CONTEXT  pPrintContext,
    IN      LPSTR           pszHeader,
    IN      PDNS_RPC_NODE   pNode
    );

VOID
DnsPrint_RpcRecord(
    IN      PRINT_ROUTINE   PrintRoutine,
    IN OUT  PPRINT_CONTEXT  pPrintContext,
    IN      LPSTR           pszHeader,
    IN      BOOL            fDetail,
    IN      PDNS_RPC_RECORD pRecord
    );

PDNS_RPC_NAME
DnsPrint_RpcRecordsInBuffer(
    IN      PRINT_ROUTINE   PrintRoutine,
    IN OUT  PPRINT_CONTEXT  pPrintContext,
    IN      LPSTR           pszHeader,
    IN      BOOL            fDetail,
    IN      DWORD           dwBufferLength,
    IN      BYTE            abBuffer[]
    );

VOID
DNS_API_FUNCTION
DnsPrint_Node(
    IN      PRINT_ROUTINE   PrintRoutine,
    IN OUT  PPRINT_CONTEXT  pPrintContext,
    IN      LPSTR           pszHeader,
    IN      PDNS_NODE       pNode,
    IN      BOOLEAN         fPrintRecords
    );

VOID
DNS_API_FUNCTION
DnsPrint_NodeList(
    IN      PRINT_ROUTINE   PrintRoutine,
    IN OUT  PPRINT_CONTEXT  pPrintContext,
    IN      LPSTR           pszHeader,
    IN      PDNS_NODE       pNode,
    IN      BOOLEAN         fPrintRecords
    );


//
//  Miscellaneous print utility
//

#define Dns_SystemHrToSystemTime( t, p ) \
        ( Dns_SystemHourToSystemTime( (t),(p) ), TRUE )

VOID
Dns_SystemHourToSystemTime(
    IN      DWORD           dwHourTime,
    IN OUT  PSYSTEMTIME     pSystemTime
    );


//
//  Debug printing utils
//

VOID
DNS_API_FUNCTION
DnssrvInitializeDebug(
    VOID
    );


//  RPC debug print defs

#if DBG

#define DnsDbg_RpcUnion(a,b,c)              DnsPrint_RpcUnion(DnsPR,NULL,a,b,c)
#define DnsDbg_RpcServerInfo(a,b)           DnsPrint_RpcServerInfo(DnsPR,NULL,a,b)
#define DnsDbg_RpcServerInfo_W2K(a,b)       DnsPrint_RpcServerInfo_W2K(DnsPR,NULL,a,b)
#define DnsDbg_RpcSingleStat(a,b)           DnsPrint_RpcSingleStat(DnsPR,NULL,a,b)
#define DnsDbg_RpcStatRaw(a,b)              DnsPrint_RpcStatRaw(DnsPR,NULL,a,b,c)
#define DnsDbg_RpcStatsBuffer(a,b)          DnsPrint_RpcStatsBuffer(DnsPR,NULL,a,b)

#define DnsDbg_RpcZone(a,b)                 DnsPrint_RpcZone(DnsPR,NULL,a,b)
#define DnsDbg_RpcZone_W2K(a,b)             DnsPrint_RpcZone_W2K(DnsPR,NULL,a,b)
#define DnsDbg_RpcZoneList(a,b)             DnsPrint_RpcZoneList(DnsPR,NULL,a,b)
#define DnsDbg_RpcZoneList_W2K(a,b)         DnsPrint_RpcZoneList_W2K(DnsPR,NULL,a,b)
#define DnsDbg_RpcZoneHandleList(a,b,c)     DnsPrint_RpcZoneHandleList(DnsPR,NULL,a,b,c)
#define DnsDbg_RpcZoneInfo(a,b)             DnsPrint_RpcZoneInfo(DnsPR,NULL,a,b)
#define DnsDbg_RpcZoneInfo_W2K(a,b)         DnsPrint_RpcZoneInfo_W2K(DnsPR,NULL,a,b)
#define DnsDbg_RpcZoneInfoList(a,b,c)       DnsPrint_RpcZoneInfoList(DnsPR,NULL,a,b,c)
#define DnsDbg_RpcName(a,b,c)               DnsPrint_RpcName(DnsPR,NULL,a,b,c)
#define DnsDbg_RpcNode(a,b)                 DnsPrint_RpcNode(DnsPR,NULL,a,b)
#define DnsDbg_RpcRecord(a,b)               DnsPrint_RpcRecord(DnsPR,NULL,a,TRUE,b)
#define DnsDbg_RpcRecordsInBuffer(a,b,c)    DnsPrint_RpcRecordsInBuffer(DnsPR,NULL,a,TRUE,b,c)

#define DnsDbg_RpcDpEnum(psz,pDp)           DnsPrint_RpcDpEnum(DnsPR,NULL,psz,pDp)
#define DnsDbg_RpcDpInfo(psz,pDp,tr)        DnsPrint_RpcDpInfo(DnsPR,NULL,psz,pDp,tr)
#define DnsDbg_RpcDpList(psz,pDpList)       DnsPrint_RpcDpList(DnsPR,NULL,psz,pDpList)

#define DnsDbg_Node(a,b,c)                  DnsPrint_Node(DnsPR,NULL,a,b,c)
#define DnsDbg_NodeList(a,b,c)              DnsPrint_NodeList(DnsPR,NULL,a,b,c)

#else   // no debug

#define DnsDbg_RpcUnion(a,b,c)
#define DnsDbg_RpcServerInfo(a,b)
#define DnsDbg_RpcServerInfo_W2K(a,b)
#define DnsDbg_RpcSingleStat(a,b)
#define DnsDbg_RpcStatsBuffer(a,b)

#define DnsDbg_RpcZone(a,b)
#define DnsDbg_RpcZone_W2K(a,b)
#define DnsDbg_RpcZoneList(a,b)
#define DnsDbg_RpcZoneList_W2K(a,b)
#define DnsDbg_RpcZoneHandleList(a,b,c)
#define DnsDbg_RpcZoneInfo(a,b)
#define DnsDbg_RpcZoneInfo_W2K(a,b)
#define DnsDbg_RpcZoneInfoList(a,b,c)
#define DnsDbg_RpcName(a,b,c)
#define DnsDbg_RpcNode(a,b)
#define DnsDbg_RpcRecord(a,b)
#define DnsDbg_RpcRecordsInBuffer(a,b,c)

#define DnsDbg_RpcDpEnum(psz,pDp)
#define DnsDbg_RpcDpInfo(psz,pDp,tr)
#define DnsDbg_RpcDpList(psz,pDpList)

#define DnsDbg_Node(a,b,c)
#define DnsDbg_NodeList(a,b,c)

#endif  // debug

#endif  // no MIDL_PASS


#ifdef __cplusplus
}
#endif  // __cplusplus

#endif // _DNSRPC_INCLUDED_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\public\internal\ds\inc\dsrolep.h ===
/*++

Copyright (c) 1998  Microsoft Corporation

Module Name:

    dsrolep.h

Abstract:

    Private definitions for DsRole routines used for upgrading downlevel domains

Author:

    Mac McLain  (MacM)          24-January-1998

Environment:

Revision History:

--*/
#ifndef __DSROLEP_H__
#define __DSROLEP_H__

#ifdef __cplusplus
extern "C" {
#endif

//
// Data structures for configuring the role of a Dc in a domain
//

typedef PVOID DSROLE_SERVEROP_HANDLE;

//
// Type of display strings to query for
//
typedef enum {

    DsRoleOperationPromote = 1,
    DsRoleOperationReplicaPromote,
    DsRoleOperationDemote,
    DsRoleOperationUpgrade
    
} DSROLE_SERVEROP_OPERATION;

//
// Status of an existing operation
//
typedef struct _DSROLE_SERVEROP_STATUS {

    LPWSTR CurrentOperationDisplayString;
    ULONG OperationStatus;
    ULONG CurrentOperationDisplayStringIndex;

} DSROLE_SERVEROP_STATUS, *PDSROLE_SERVEROP_STATUS;

//
// where:
// CurrentOperationDisplayString is a displayable status of the current operation.  For example:
//       Locating a domain controller for the domain BRIDGE.NTDEV.MICROSOFT.COM
//       Replicating Ds Data from parent domain controller FRANK.BRIDGE.NTDEV.MICROSOFT.COM
//       Configuring KDC service to autostart
//

//
// Status returned from a GetOperationResults call
//
typedef struct _DSROLE_SERVEROP_RESULTS {

    ULONG OperationStatus;
    LPWSTR OperationStatusDisplayString;
    LPWSTR ServerInstalledSite;
    ULONG OperationResultsFlags;
    
} DSROLE_SERVEROP_RESULTS, *PDSROLE_SERVEROP_RESULTS;

//
// where:
// OperationStatus is the status code returned from the operation.
// OperationStatusDisplayString is a displayable status of the current operation.  For example:
//       Successfully installed a domain controller for the domain BRIDGE.NTDEV.MICROSOFT.COM
//       Failed to create the trust between BRIDGE.NTDEV.MICROSOFT.COM and
//          FRANK.BRIDGE.NTDEV.MICROSOFT.COM because the trust object already exists on the parent
// ServerInstalledSite is where the site the server was installed in is returned
// OperationResultsFlags is where any flags are returned determine any specifics about the results
//
//

#define IFM_SYSTEM_KEY    L"ifmSystem"
#define IFM_SECURITY_KEY  L"ifmSecurity"

//
// Operation states
//

#define DSROLE_CRITICAL_OPERATIONS_COMPLETED    0x00000001

//
// Operation results flags
//
#define DSROLE_NON_FATAL_ERROR_OCCURRED          0x00000001
#define DSROLE_NON_CRITICAL_REPL_NOT_FINISHED    0x00000002
#define DSROLE_IFM_RESTORED_DATABASE_FILES_MOVED 0x00000004
#define DSROLE_IFM_GC_REQUEST_CANNOT_BE_SERVICED 0x00000008

//
// Determines the role of DC following a demotion
//
typedef enum _DSROLE_SERVEROP_DEMOTE_ROLE {

    DsRoleServerStandalone = 0,
    DsRoleServerMember

} DSROLE_SERVEROP_DEMOTE_ROLE, *PDSROLE_SERVEROP_DEMOTE_ROLE;

//
// Valid options for various DsRole apis
//
#define DSROLE_DC_PARENT_TRUST_EXISTS       0x00000001
#define DSROLE_DC_ROOT_TRUST_EXISTS         0x00000001
#define DSROLE_DC_DELETE_PARENT_TRUST       0x00000002
#define DSROLE_DC_DELETE_ROOT_TRUST         0x00000002
#define DSROLE_DC_ALLOW_DC_REINSTALL        0x00000004
#define DSROLE_DC_ALLOW_DOMAIN_REINSTALL    0x00000008
#define DSROLE_DC_TRUST_AS_ROOT             0x00000010
#define DSROLE_DC_DOWNLEVEL_UPGRADE         0x00000020
#define DSROLE_DC_FORCE_TIME_SYNC           0x00000040
#define DSROLE_DC_CREATE_TRUST_AS_REQUIRED  0x00000080
#define DSROLE_DC_DELETE_SYSVOL_PATH        0x00000100
#define DSROLE_DC_DONT_DELETE_DOMAIN        0x00000200
#define DSROLE_DC_CRITICAL_REPLICATION_ONLY 0x00000400
#define DSROLE_DC_ALLOW_ANONYMOUS_ACCESS    0x00000800
#define DSROLE_DC_NO_NET                    0x00001000
#define DSROLE_DC_REQUEST_GC                0x00002000
#define DSROLE_DC_DEFAULT_REPAIR_PWD        0x00004000
#define DSROLE_DC_SET_FOREST_CURRENT        0x00008000


//
// Options to be used for fixing up a domain controller
//
#define DSROLE_DC_FIXUP_ACCOUNT             0x00000001
#define DSROLE_DC_FIXUP_ACCOUNT_PASSWORD    0x00000002
#define DSROLE_DC_FIXUP_ACCOUNT_TYPE        0x00000004
#define DSROLE_DC_FIXUP_TIME_SERVICE        0x00000008
#define DSROLE_DC_FIXUP_DC_SERVICES         0x00000010
#define DSROLE_DC_FIXUP_FORCE_SYNC          0x00000020
#define DSROLE_DC_FIXUP_SYNC_LSA_POLICY     0x00000040
#define DSROLE_DC_FIXUP_TIME_SYNC           0x00000080
#define DSROLE_DC_FIXUP_CLEAN_TRUST         0x00000100

//
// Returns from DsRoleGetDatabaseFacts
//
#define DSROLE_DC_IS_GC                     0x00000001
#define DSROLE_KEY_STORED                   0x00000002
#define DSROLE_KEY_DISK                     0x00000004
#define DSROLE_KEY_PROMPT                   0x00000008

//
// Flags returned by DsRoleDnsNameToFlatName
//
#define DSROLE_FLATNAME_DEFAULT     0x00000001
#define DSROLE_FLATNAME_UPGRADE     0x00000002

DWORD
WINAPI
DsRoleDnsNameToFlatName(
    IN  LPCWSTR lpServer OPTIONAL,
    IN  LPCWSTR lpDnsName,
    OUT LPWSTR *lpFlatName,
    OUT PULONG  lpStatusFlag
    );


DWORD
WINAPI
DsRoleDcAsDc(
    IN  LPCWSTR lpServer OPTIONAL,
    IN  LPCWSTR lpDnsDomainName,
    IN  LPCWSTR lpFlatDomainName,
    IN  LPCWSTR lpDomainAdminPassword OPTIONAL,
    IN  LPCWSTR lpSiteName, OPTIONAL
    IN  LPCWSTR lpDsDatabasePath,
    IN  LPCWSTR lpDsLogPath,
    IN  LPCWSTR lpSystemVolumeRootPath,
    IN  LPCWSTR lpParentDnsDomainName OPTIONAL,
    IN  LPCWSTR lpParentServer OPTIONAL,
    IN  LPCWSTR lpAccount OPTIONAL,
    IN  LPCWSTR lpPassword OPTIONAL,
    IN  LPCWSTR lpDsRepairPassword OPTIONAL,
    IN  ULONG Options,
    OUT DSROLE_SERVEROP_HANDLE *DsOperationHandle
    );

DWORD
WINAPI
DsRoleDcAsReplica(
    IN  LPCWSTR lpServer OPTIONAL,
    IN  LPCWSTR lpDnsDomainName,
    IN  LPCWSTR lpReplicaServer,
    IN  LPCWSTR lpSiteName, OPTIONAL
    IN  LPCWSTR lpDsDatabasePath,
    IN  LPCWSTR lpDsLogPath,
    IN  LPCWSTR lpRestorePath OPTIONAL,
    IN  LPCWSTR lpSystemVolumeRootPath,
    IN OUT LPWSTR lpBootkey OPTIONAL,
    IN  LPCWSTR lpAccount OPTIONAL,
    IN  LPCWSTR lpPassword OPTIONAL,
    IN  LPCWSTR lpDsRepairPassword OPTIONAL,
    IN  ULONG Options,
    OUT DSROLE_SERVEROP_HANDLE *DsOperationHandle
    );

DWORD
WINAPI
DsRoleDemoteDc(
    IN  LPCWSTR lpServer OPTIONAL,
    IN  LPCWSTR lpDnsDomainName OPTIONAL,
    IN  DSROLE_SERVEROP_DEMOTE_ROLE ServerRole,
    IN  LPCWSTR lpAccount OPTIONAL,
    IN  LPCWSTR lpPassword OPTIONAL,
    IN  ULONG Options,
    IN  BOOL fLastDcInDomain,
    IN  LPCWSTR lpDomainAdminPassword OPTIONAL,
    OUT DSROLE_SERVEROP_HANDLE *DsOperationHandle
    );

DWORD
WINAPI
DsRoleGetDcOperationProgress(
    IN  LPCWSTR lpServer OPTIONAL,
    IN  DSROLE_SERVEROP_HANDLE DsOperationHandle,
    OUT PDSROLE_SERVEROP_STATUS *ServerOperationStatus
    );

DWORD
WINAPI
DsRoleGetDcOperationResults(
    IN  LPCWSTR lpServer OPTIONAL,
    IN  DSROLE_SERVEROP_HANDLE DsOperationHandle,
    OUT PDSROLE_SERVEROP_RESULTS *ServerOperationResults
    );

DWORD
WINAPI
DsRoleCancel(
    IN  LPCWSTR lpServer OPTIONAL,
    IN  DSROLE_SERVEROP_HANDLE DsOperationHandle
    );

#define DSROLEP_ABORT_FOR_REPLICA_INSTALL   0x0000001

DWORD
WINAPI
DsRoleServerSaveStateForUpgrade(
    IN  LPCWSTR AnswerFile OPTIONAL
    );

DWORD
WINAPI
DsRoleUpgradeDownlevelServer(
    IN  LPCWSTR lpDnsDomainName,
    IN  LPCWSTR lpSiteName,
    IN  LPCWSTR lpDsDatabasePath,
    IN  LPCWSTR lpDsLogPath,
    IN  LPCWSTR lpSystemVolumeRootPath,
    IN  LPCWSTR lpParentDnsDomainName OPTIONAL,
    IN  LPCWSTR lpParentServer OPTIONAL,
    IN  LPCWSTR lpAccount OPTIONAL,
    IN  LPCWSTR lpPassword OPTIONAL,
    IN  LPCWSTR lpDsRepairPassword OPTIONAL,
    IN  ULONG Options,
    OUT DSROLE_SERVEROP_HANDLE *DsOperationHandle
    );

DWORD
WINAPI
DsRoleAbortDownlevelServerUpgrade(
    IN  LPCWSTR lpAdminPassword,
    IN  LPCWSTR lpAccount OPTIONAL,
    IN  LPCWSTR lpPassword OPTIONAL,
    IN  ULONG Options
    );
    
DWORD
WINAPI
DsRoleGetDatabaseFacts(
    IN  LPCWSTR lpServer OPTIONAL,
    IN  LPCWSTR lpRestorePath,
    OUT LPWSTR *lpDNSDomainName,
    OUT PULONG State
    );



#ifdef __cplusplus
}
#endif

#endif // __DSROLEP_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\public\internal\ds\inc\fpnwapi.h ===
/****************************************************************************
*                                                                           *
* fpnwapi.h -- FPNW procedure declarations, constant definitions and macros *
*                                                                           *
* Copyright (c) 1994-1995, Microsoft Corp. All rights reserved.             *
*                                                                           *
****************************************************************************/

#ifndef _FPNWAPI_H_
#define _FPNWAPI_H_

#ifdef __cplusplus
extern "C" {
#endif /* __cplusplus */

//
// Definitions for LSA secrets
//
#define NCP_LSA_SECRET_KEY              L"G$MNSEncryptionKey"
#define NCP_LSA_SECRET_LENGTH           USER_SESSION_KEY_LENGTH // in <crypt.h>

#define NW_SERVER_SERVICE               L"FPNW"

//
//  Volume flags returned by VolumeGetInfo
//

#define FPNWVOL_TYPE_DISKTREE             0
#define FPNWVOL_TYPE_CDROM                104
#define FPNWVOL_TYPE_REMOVABLE            105

//
//  Permissions flags returned in structure FPNWFILEINFO
//

#define FPNWFILE_PERM_NONE                0
#define FPNWFILE_PERM_READ                0x01
#define FPNWFILE_PERM_WRITE               0x02
#define FPNWFILE_PERM_CREATE              0x04
#define FPNWFILE_PERM_EXEC                0x08
#define FPNWFILE_PERM_DELETE              0x10
#define FPNWFILE_PERM_ATRIB               0x20
#define FPNWFILE_PERM_PERM                0x40

typedef BYTE FPNWSERVERADDR[12];        // Network address, first 4 bytes is
                                        // the network number, and bytes
                                        // 5-10 is the physical node
                                        // address. The last two bytes are
                                        // reserved.

//
//  This is the level 1 structure for FpnwServerGetInfo & FpnwServerSetInfo.
//

typedef struct _FPNWServerInfo
{
    LPWSTR    lpServerName;           // Name of the server
    DWORD     dwNetwareMajorVersion;  // Netware compatible major version num
    DWORD     dwNetwareMinorVersion;  // Netware compatible minor version num
    DWORD     dwOSRevision;           // OS revision number
    DWORD     dwMaxConnections;       // Maximum number of connections
                                      // supported
    DWORD     dwVolumes;              // The current number of volumes on the
                                      // server
    DWORD     dwLoggedOnUsers;        // Number of current users logged on
    DWORD     dwConnectedWorkstations;// Number of workstations connected
    DWORD     dwOpenFiles;            // Number of open files
    DWORD     dwFileLocks;            // Number of file locks
    FPNWSERVERADDR NetworkAddress;    // Address consisting of network
                                      // number (first 4 bytes) and the
                                      // physical node address(bytes 5-10)
    BOOL      fEnableLogin;           // TRUE if users are allowed to logged
                                      // on, FALSE otherwise.
    LPWSTR    lpDescription;          // Description of the server
    LPWSTR    lpHomeDirectory;        // Path of the home directory

} FPNWSERVERINFO, *PFPNWSERVERINFO;


//
//  This is the level 1 structure for FpnwVolumeAdd, FpnwVolumeDel, FpnwVolumeEnum,
//  FpnwVolumeGetInfo, & FpnwVolumeSetInfo.
//

typedef struct _FPNWVolumeInfo
{
    LPWSTR    lpVolumeName;           // Name of the volume
    DWORD     dwType;                 // Specifics of the volume. FPNWVOL_TYPE_???
    DWORD     dwMaxUses;              // Maximum number of connections that are
                                      // allowed to the volume
    DWORD     dwCurrentUses;          // Current number of connections to the volume
    LPWSTR    lpPath;                 // Path of the volume

} FPNWVOLUMEINFO, *PFPNWVOLUMEINFO;


//
//  This is the level 2 structure for FpnwVolumeAdd, FpnwVolumeDel, FpnwVolumeEnum,
//  FpnwVolumeGetInfo, & FpnwVolumeSetInfo.
//  Note that this is not supported on the FPNW beta.
//

typedef struct _FPNWVolumeInfo_2
{
    LPWSTR    lpVolumeName;           // Name of the volume
    DWORD     dwType;                 // Specifics of the volume. FPNWVOL_TYPE_???
    DWORD     dwMaxUses;              // Maximum number of connections that are
                                      // allowed to the volume
    DWORD     dwCurrentUses;          // Current number of connections to the volume
    LPWSTR    lpPath;                 // Path of the volume

    DWORD     dwFileSecurityDescriptorLength; // reserved, this is calculated
    PSECURITY_DESCRIPTOR FileSecurityDescriptor;

} FPNWVOLUMEINFO_2, *PFPNWVOLUMEINFO_2;


//
//  This is the level 1 structure for FpnwConnectionEnum.
//

typedef  struct  _FPNWConnectionInfo
{
    DWORD     dwConnectionId;         // Identification number for this connection
    FPNWSERVERADDR WkstaAddress;      // The workstation address which established
                                      // the conn.
    DWORD     dwAddressType;          // Address type: IP, IPX ...
    LPWSTR    lpUserName;             // The name of the user which established
                                      // the conn.
    DWORD     dwOpens;                // Number of resources opened during this conn.
    DWORD     dwLogonTime;            // Time this connection has been active
    BOOL      fLoggedOn;              // TRUE if the user is logged on,FALSE otherwise
    DWORD     dwForcedLogoffTime;     // Time left before forcing logoff
    BOOL      fAdministrator;         // TRUE if the user is an administrator,
                                      // FALSE otherwise

} FPNWCONNECTIONINFO, *PFPNWCONNECTIONINFO;


//
//  This is the level 1 structure for FpnwVolumeConnEnum.
//

typedef struct _FPNWVolumeConnectionInfo
{
    USHORT    nDriveLetter;           // Driver letter mapped to the volume by user
    DWORD     dwConnectionId;         // Identification number for this connection
    DWORD     dwConnType;             // The type of connection: FPNWVOL_TYPE_DISK,
                                      //                         FPNWVOL_TYPE_PRINTER
    DWORD     dwOpens;                // The number of open files on this connection.
    DWORD     dwTime;                 // Time this connection is active (or connected)
    LPWSTR    lpUserName;             // The user who established the connection
    LPWSTR    lpConnectName;          // The workstation address OR volume name based
                                      // on  the qualifier to FpnwConnectionEnum

} FPNWVOLUMECONNINFO, *PFPNWVOLUMECONNINFO;


//
//  This is the level 1 structure for FpnwFileEnum.
//

typedef  struct _FPNWFileInfo
{
    DWORD     dwFileId;               // File identification number
    LPWSTR    lpPathName;             // Full path name of this file
    LPWSTR    lpVolumeName;           // Volume name this file is on
    DWORD     dwPermissions;          // Permission mask: FPNWFILE_PERM_READ,
                                      //                  FPNWFILE_PERM_WRITE,
                                      //                  FPNWFILE_PERM_CREATE...
    DWORD     dwLocks;                // Number of locks on this file
    LPWSTR    lpUserName;             // The name of the user that established the
                                      // connection and opened the file
    FPNWSERVERADDR WkstaAddress;      // The workstation address which opened the file
    DWORD     dwAddressType;          // Address type: IP, IPX

} FPNWFILEINFO, *PFPNWFILEINFO;


//
//  Below are the APIs available to manipulate FPNW servers, volumes, etc.
//

//
//  The FpnwApiBufferFree should be called for any buffer returned by the
//  other APIs.
//

DWORD
FpnwApiBufferFree(
    IN  LPVOID pBuffer
);

//
//  For Level 1, an FPNWSERVERINFO structure is returned in *ppServerInfo.
//

DWORD
FpnwServerGetInfo(
    IN  LPWSTR pServerName OPTIONAL,
    IN  DWORD  dwLevel,
    OUT LPBYTE *ppServerInfo
);


//
//  The following fields are modified by a call to FpnwServerSetInfo :
//
//  LPWSTR    lpDescription;          // Description of the server
//  BOOL      fEnableLogin;           // TRUE if users are allowed to logged
//  LPWSTR    lpHomeDirectory;        // Path of the home directory
//
//  All other fields in FPNWSERVERINFO structure are ignored.  Also note
//  that lpHomeDirectory and lpDescription require a restart for the server
//  to pick up the changes.
//

//
//  For Level 1, an FPNWSERVERINFO structure should be passed as pServerInfo.
//

DWORD
FpnwServerSetInfo(
    IN  LPWSTR pServerName OPTIONAL,
    IN  DWORD  dwLevel,
    IN  LPBYTE pServerInfo
);


//
//  For FpnwVolumeAdd, FpnwVolumeEnum, FpnwVolumeSetInfo, and
//      FpnwVolumeGetInfo, the following holds:
//  Level 1 -> an FPNWVOLUMEINFO structure should be passed as pVolumeInfo.
//  Level 2 -> an FPNWVOLUMEINFO_2 structure should be passed as pVolumeInfo.
//

DWORD
FpnwVolumeAdd(
    IN  LPWSTR pServerName OPTIONAL,
    IN  DWORD  dwLevel,
    IN  LPBYTE pVolumeInfo
);

DWORD
FpnwVolumeDel(
    IN  LPWSTR pServerName OPTIONAL,
    IN  LPWSTR pVolumeName
);

DWORD
FpnwVolumeEnum(
    IN  LPWSTR pServerName OPTIONAL,
    IN  DWORD  dwLevel,
    OUT LPBYTE *ppVolumeInfo,
    OUT PDWORD pEntriesRead,
    IN OUT PDWORD resumeHandle OPTIONAL
);

DWORD
FpnwVolumeGetInfo(
    IN  LPWSTR pServerName OPTIONAL,
    IN  LPWSTR pVolumeName,
    IN  DWORD  dwLevel,
    OUT LPBYTE *ppVolumeInfo
);


//
//  The following fields are modified by a call to FpnwVolumeSetInfo :
//
//  DWORD     dwMaxUses;              // Maximum number of connections that are
//  PSECURITY_DESCRIPTOR FileSecurityDescriptor;
//
//  All other fields in FPNWVOLUMEINFO structure are ignored.  You may send
//  in a pointer to an FPNWVOLUMEINFO_2 structure instead of FPNWVOLUMEINFO.
//

DWORD
FpnwVolumeSetInfo(
    IN  LPWSTR pServerName OPTIONAL,
    IN  LPWSTR pVolumeName,
    IN  DWORD  dwLevel,
    IN  LPBYTE pVolumeInfo
);

//
//  For Level 1, an FPNWCONNECTIONINFO structure is returned in *ppConnectionInfo.
//

DWORD
FpnwConnectionEnum(
    IN LPWSTR pServerName OPTIONAL,
    IN DWORD  dwLevel,
    OUT LPBYTE *ppConnectionInfo,
    OUT PDWORD pEntriesRead,
    IN OUT PDWORD resumeHandle OPTIONAL
);

DWORD FpnwConnectionDel(
    IN LPWSTR pServerName OPTIONAL,
    IN DWORD  dwConnectionId
);


//
//  For Level 1, an PFPNWVOLUMECONNINFO structure is returned in *ppVolumeConnInfo.
//

DWORD
FpnwVolumeConnEnum(
    IN LPWSTR pServerName OPTIONAL,
    IN DWORD dwLevel,
    IN LPWSTR pVolumeName,
    IN DWORD  dwConnectionId,
    OUT LPBYTE *ppVolumeConnInfo,
    OUT PDWORD pEntriesRead,
    IN OUT PDWORD resumeHandle OPTIONAL
);


//
//  For Level 1, an PFPNWFILEINFO structure is returned in *ppFileInfo.
//

DWORD
FpnwFileEnum(
    IN LPWSTR pServerName OPTIONAL,
    IN DWORD  dwLevel,
    IN LPWSTR pPathName OPTIONAL,
    OUT LPBYTE *ppFileInfo,
    OUT PDWORD pEntriesRead,
    IN OUT PDWORD resumeHandle OPTIONAL
);

DWORD
FpnwFileClose(
    IN LPWSTR pServerName OPTIONAL,
    IN DWORD  nFileId
);


DWORD FpnwMessageBufferSend(
    IN LPWSTR pServerName OPTIONAL,
    IN DWORD  dwConnectionId,
    IN DWORD  fConsoleBroadcast,
    IN LPBYTE pbBuffer,
    IN DWORD  cbBuffer
);

#ifdef __cplusplus
}
#endif  /* __cplusplus */

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\public\internal\ds\inc\fipsapi.h ===
#ifndef __FIPSAPI_H__
#define __FIPSAPI_H__

#ifdef __cplusplus
extern "C" {
#endif

#include <windef.h>
#include <des.h>
#include <tripldes.h>
#include <sha.h>
#include <modes.h>
#include <md5.h>

#if DEBUG 
#define FipsDebug(LEVEL, STRING) \
        { \
          DbgPrint STRING; \
        }
#else
#define FipsDebug(LEVEL, STRING)
#endif

#define     FIPS_DEVICE_NAME            L"\\Device\\Fips"

#define FIPS_CTL_CODE(code)         CTL_CODE(FILE_DEVICE_FIPS, \
                                            (code), \
                                            METHOD_BUFFERED, \
                                            FILE_ANY_ACCESS)

#define IOCTL_FIPS_GET_FUNCTION_TABLE   FIPS_CTL_CODE( 1)

#define     FIPS_CBC_DES    0x1
#define     FIPS_CBC_3DES   0x2

//
// Defines for IPSEC HMAC use
//
#define     MAX_LEN_PAD     65
#define     MAX_KEYLEN_SHA  64
#define     MAX_KEYLEN_MD5  64   

//
//     Fill in the DESTable struct with the decrypt and encrypt
//     key expansions.
//
//     Assumes that the second parameter points to DES_BLOCKLEN
//     bytes of key.
//
//

VOID FipsDesKey(DESTable *DesTable, UCHAR *pbKey);

//
//     Encrypt or decrypt with the key in DESTable
//
//

VOID FipsDes(UCHAR *pbOut, UCHAR *pbIn, void *pKey, int iOp);

//
//   Fill in the DES3Table structs with the decrypt and encrypt
//   key expansions.
//
//   Assumes that the second parameter points to 2 * DES_BLOCKLEN
//   bytes of key.
//
//

VOID Fips3Des3Key(PDES3TABLE pDES3Table, UCHAR *pbKey);

//
//   Encrypt or decrypt with the key in pKey
//

VOID Fips3Des(UCHAR *pbIn, UCHAR *pbOut, void *pKey, int op);

//
//   Initialize the SHA context.
//

VOID FipsSHAInit(A_SHA_CTX *pShaCtx);

//
//   Hash data into the hash context.
//

VOID FipsSHAUpdate(A_SHA_CTX *pShaCtx, UCHAR *pb, unsigned int cb);

//
//   Finish the SHA hash and copy the final hash value into the pbHash out param.
//

VOID FipsSHAFinal(A_SHA_CTX *pShaCtx, UCHAR *pbHash);

//
// FipsCBC (cipher block chaining) performs a XOR of the feedback register
// with the plain text before calling the block cipher
//
// NOTE - Currently this function assumes that the block length is
// DES_BLOCKLEN (8 bytes).
//
// Return: Failure if FALSE is returned, TRUE if it succeeded.
//

BOOL FipsCBC(
    ULONG  EncryptionAlg,
    BYTE   *pbOutput,
    BYTE   *pbInput,
    void   *pKeyTable,
    int    Operation,
    BYTE   *pbFeedback
    );

//
// FipsBlockCBC (cipher block chaining) performs a XOR of the feedback register
// with the plain text before calling the block cipher
//
// NOTE - The Length must be multiple of DES_BLOCKLEN (8)
// All the input buffer must be aligned on LONGLONG for performane reason.
//
// Return: Failure if FALSE is returned, TRUE if it succeeded.
//

BOOL FipsBlockCBC(
    ULONG  EncryptionAlg,
    BYTE   *pbOutput,
    BYTE   *pbInput,
    ULONG  Length,
    void   *pKeyTable,
    int    Operation,
    BYTE   *pbFeedback
    );

//
// Function : FIPSGenRandom
//
// Description : FIPS 186 RNG, the seed is generated by calling NewGenRandom.
//

BOOL FIPSGenRandom(
    IN OUT UCHAR *pb,
    IN ULONG cb
    );

//
// Function: FipsHmacSHAInit
//
// Description: Initialize a SHA-HMAC context 
//

VOID FipsHmacSHAInit(
    OUT A_SHA_CTX *pShaCtx,
    IN UCHAR *pKey,
    IN unsigned int cbKey
    );

//
// Function: FipsHmacSHAUpdate
//
// Description: Add more data to a SHA-HMAC context
//

VOID FipsHmacSHAUpdate(
    IN OUT A_SHA_CTX *pShaCtx,
    IN UCHAR *pb,
    IN unsigned int cb
    );

//
// Function: FipsHmacSHAFinal
//
// Description: Return result of SHA-HMAC 
//

VOID FipsHmacSHAFinal(
    IN A_SHA_CTX *pShaCtx,
    IN UCHAR *pKey,
    IN unsigned int cbKey,
    OUT UCHAR *pHash
    );

//
// Function: HmacMD5Init
//
// Description: Initialize a MD5-HMAC context 
//

VOID HmacMD5Init(
    OUT MD5_CTX *pMD5Ctx,
    IN UCHAR *pKey,
    IN unsigned int cbKey
    );

//
// Function: HmacMD5Update
//
// Description: Add more data to a MD5-HMAC context
//

VOID HmacMD5Update(
    IN OUT MD5_CTX *pMD5Ctx,
    IN UCHAR *pb,
    IN unsigned int cb
    );

//
// Function: HmacMD5Final
//
// Description: Return result of MD5-HMAC 
//

VOID HmacMD5Final(
    IN MD5_CTX *pMD5Ctx,
    IN UCHAR *pKey,
    IN unsigned int cbKey,
    OUT UCHAR *pHash
    );

// 
// Current FIPS function table
// Includes HMAC entry points
//
typedef struct _FIPS_FUNCTION_TABLE {

    VOID (*FipsDesKey)(DESTable *DesTable, UCHAR *pbKey);
    VOID (*FipsDes)(UCHAR *pbOut, UCHAR *pbIn, void *pKey, int iOp);
    VOID (*Fips3Des3Key)(PDES3TABLE pDES3Table, UCHAR *pbKey);
    VOID (*Fips3Des)(UCHAR *pbIn, UCHAR *pbOut, void *pKey, int op);
    VOID (*FipsSHAInit)(A_SHA_CTX *pShaCtx);
    VOID (*FipsSHAUpdate)(A_SHA_CTX *pShaCtx, UCHAR *pb, unsigned int cb);
    VOID (*FipsSHAFinal)(A_SHA_CTX *pShaCtx, UCHAR *pbHash);
    BOOL (*FipsCBC)(
        ULONG  EncryptionAlg,
        BYTE   *pbOutput,
        BYTE   *pbInput,
        void   *pKeyTable,
        int    Operation,
        BYTE   *pbFeedback
        );
    BOOL (*FIPSGenRandom)(
        IN OUT UCHAR *pb,
        IN ULONG cb
        );
    BOOL (*FipsBlockCBC)(
        ULONG  EncryptionAlg,
        BYTE   *pbOutput,
        BYTE   *pbInput,
        ULONG  Length,
        void   *pKeyTable,
        int    Operation,
        BYTE   *pbFeedback
        );
    VOID (*FipsHmacSHAInit)(
        OUT A_SHA_CTX *pShaCtx,
        IN UCHAR *pKey,
        IN unsigned int cbKey
        );   
    VOID (*FipsHmacSHAUpdate)(
        IN OUT A_SHA_CTX *pShaCtx,
        IN UCHAR *pb,
        IN unsigned int cb
        );
    VOID (*FipsHmacSHAFinal)(
        IN A_SHA_CTX *pShaCtx,
        IN UCHAR *pKey,
        IN unsigned int cbKey,
        OUT UCHAR *pHash
        );
    VOID (*HmacMD5Init)(
        OUT MD5_CTX *pMD5Ctx,
        IN UCHAR *pKey,
        IN unsigned int cbKey
        );
    VOID (*HmacMD5Update)(
        IN OUT MD5_CTX *pMD5Ctx,
        IN UCHAR *pb,
        IN unsigned int cb
        );
    VOID (*HmacMD5Final)(
        IN MD5_CTX *pMD5Ctx,
        IN UCHAR *pKey,
        IN unsigned int cbKey,
        OUT UCHAR *pHash
        );

} FIPS_FUNCTION_TABLE, *PFIPS_FUNCTION_TABLE;

//
// Old FIPS function table - please don't use
//
typedef struct _FIPS_FUNCTION_TABLE_1 {

    VOID (*FipsDesKey)(DESTable *DesTable, UCHAR *pbKey);
    VOID (*FipsDes)(UCHAR *pbOut, UCHAR *pbIn, void *pKey, int iOp);
    VOID (*Fips3Des3Key)(PDES3TABLE pDES3Table, UCHAR *pbKey);
    VOID (*Fips3Des)(UCHAR *pbIn, UCHAR *pbOut, void *pKey, int op);
    VOID (*FipsSHAInit)(A_SHA_CTX *pShaCtx);
    VOID (*FipsSHAUpdate)(A_SHA_CTX *pShaCtx, UCHAR *pb, unsigned int cb);
    VOID (*FipsSHAFinal)(A_SHA_CTX *pShaCtx, UCHAR *pbHash);
    BOOL (*FipsCBC)(
        ULONG  EncryptionAlg,
        BYTE   *pbOutput,
        BYTE   *pbInput,
        void   *pKeyTable,
        int    Operation,
        BYTE   *pbFeedback
        );
    BOOL (*FIPSGenRandom)(
        IN OUT UCHAR *pb,
        IN ULONG cb
        );
    BOOL (*FipsBlockCBC)(
        ULONG  EncryptionAlg,
        BYTE   *pbOutput,
        BYTE   *pbInput,
        ULONG  Length,
        void   *pKeyTable,
        int    Operation,
        BYTE   *pbFeedback
        );

} FIPS_FUNCTION_TABLE_1, *PFIPS_FUNCTION_TABLE_1;


#ifdef __cplusplus
}
#endif

#endif // __FIPSAPI_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\public\internal\ds\inc\fpnwname.h ===
/*++

Copyright (c) 1993  Microsoft Corporation

Module Name:

    fpnwname.h

Abstract:

    Header for NetWare service names.

Author:

    Rita Wong      (ritaw)      26-Feb-1993

Revision History:

--*/

#ifndef _FPNW_NAMES_INCLUDED_
#define _FPNW_NAMES_INCLUDED_


#define NCP_LSA_SECRET_KEY              L"G$MNSEncryptionKey"
#define NCP_LSA_SECRET_LENGTH           USER_SESSION_KEY_LENGTH // in <crypt.h>

#define NW_SERVER_SERVICE               L"FPNW"
#define NW_SAPAGENT_SERVICE             L"NwSapAgent"
#define CURRENT_DLL_NAME                L"fpnw.dll"
#define FPNW_PASSWD_NOTIFY_DLL_NAME     L"FPNWCLNT"
#define NW_SERVER_DISPLAY_NAME          TEXT("FPNW")

#define SERVER_REGISTRY_PATH            L"FPNW"
#define PARAMETERS_REGISTRY_PATH        L"FPNW\\Parameters"
#define AUTOTUNED_REGISTRY_PATH         L"FPNW\\AutotunedParameters"
#define SHARES_REGISTRY_PATH            L"FPNW\\Volumes"
#define SHARES_SECURITY_REGISTRY_PATH   L"FPNW\\Volumes\\Security"
#define LINKAGE_REGISTRY_PATH           L"FPNW\\Linkage"

#define SERVER_REGISTRY_PARAMETERS      TEXT("SYSTEM\\CurrentControlSet\\Services\\FPNW\\Parameters")
#define SERVER_REGISTRY_VOLUMES         TEXT("SYSTEM\\CurrentControlSet\\Services\\FPNW\\Volumes")
#define SERVER_REGISTRY_BINDERY         TEXT("SYSTEM\\CurrentControlSet\\Services\\FPNW\\Bindery")
#define SERVER_REGISTRY_PERFORMANCE     TEXT("SYSTEM\\CurrentControlSet\\Services\\FPNW\\Performance")

//
// Names of server service keys.
//

#define COMPUTERNAME_REGISTRY_KEY L"ComputerName\\ActiveComputerName\\"

//
// Value names under Parameters.
//

#define BIND_VALUE_NAME L"Bind"
#define SERVNAME_VALUE_NAME L"ComputerName"
#define SSDEBUG_VALUE_NAME L"SsDebug"
#define XSDEBUG_VALUE_NAME L"XsDebug"

#define LOGINDIR_VALUE_NAME L"LoginDirectory"
#define DESCRIPTION_VALUE_NAME L"Description"
#define HOME_BASE_DIRECTORY_NAME     L"HomeBaseDirectory"

#define SIZE_VALUE_NAME                 L"Size"
#define MAXNUMBERUSERS_NAME             L"MaxUsers"
#define MAXWORKCONTEXTS_NAME            L"MaxReceiveBuffers"
#define BLOCKINGWORKERTHREADS_NAME      L"BlockingWorkerThreads"
#define NONBLOCKINGWORKERTHREADS_NAME   L"NonblockingWorkerThreads"
#define INITIALWORKCONTEXTS_NAME        L"InitialReceiveBuffers"
#define MAXSEARCHES_NAME                L"MaxSearchesPerClient"
#define MAXRECEIVEPACKET_NAME           L"MaxReceivePacketSize"
#define DELAYFIRSTWDOG_NAME             L"WatchDogInitialDelay"
#define DELAYNEXTWDOG_NAME              L"WatchDogSecondaryDelay"
#define NUMBERWDOGPACKETS_NAME          L"NumberOfWatchDogPackets"
#define ENABLEFORCEDLOGOFF_NAME         L"EnableForcedLogoff"
#define DISKFULLALERTEVERYONE_NAME      L"AlertEveryoneOnDiskFull"
#define RESPONDTONEAREST_NAME           L"RespondToNearestServer"
#define ALLOWBURST_NAME                 L"EnableBurst"
#define ALLOWLIP_NAME                   L"EnableLip"
#define DISCONNECTATBADSEQ_NAME         L"DisconnectAtBadSeq"
#define LOWVOLUMETHRESHOLD_NAME         L"LowVolumeThreshold"
#define DISKFULLCRITERIA_NAME           L"DiskFullCriteria"
#define LOCKRETRYCOUNT_NAME             L"LockRetryCount"
#define OPLOCKBREAKWAIT                 L"OplockBreakWait"
#define CORECACHEBUFFERS                L"CoreCacheBuffers"
#define CORECACHEBUFFERSIZE             L"CoreCacheBufferSize"
#define ENABLEPASSTHROUGH               L"EnablePassthrough"
#define CLEARTEXTPASSWORDS              L"ClearTextPasswords"
#define DISABLEWRITECACHECRITERIA       L"DisableWriteCacheCriteria"
#define MAXCACHEDOPENFILES              L"MaxCachedOpenFiles"
#define QMSSYNCMODE                     L"QMSSyncMode"
#define SERIALNUMBER                    L"SerialNumber"
#define MAXWORKITEMIDLETIME             L"MaxWorkItemIdleTime"
#define BALANCECOUNT                    L"BalanceCount"
#define RETURNSHAREABLEFLAG             L"ReturnShareableFlag"
#define ALLOWABLEBADSEQUENCEPKTS        L"AllowableBadSequencePkts"
#define MINFREEWORKITEMS                L"MinFreeWorkItems"
#define MAXTHREADSPERQUEUE              L"MaxThreadsPerQueue"
#define MAXFREELFCBS                    L"MaxFreeLfcbs"
#define MAXFREERFCBS                    L"MaxFreeRfcbs"
#define MAXFREEMFCBS                    L"MaxFreeMfcbs"
#define MAXFREEPAGEDPOOLCHUNKS          L"MaxFreePagedPoolChunks"
#define MINPAGEDPOOLCHUNKSIZE           L"MinPagedPoolChunkSize"
#define MAXPAGEDPOOLCHUNKSIZE           L"MaxPagedPoolChunkSize"
#define EMULATESHAREABLEFLAG            L"EmulateShareableFlag"
#define MAXNUMBERBUSYPACKETS            L"MaxNumberBusyPackets"
#define CLIENTBUSYLIMIT                 L"ClientBusyLimit"
#define ENABLENTFSSHAREABLE             L"EnableNtfsShareable"
#define ENABLEOS2NAMESPACE              L"EnableOS2NameSpace"
#define MAXFILENAMECACHE                L"MaxFileNameCache"

#define MINOPENSFORCOMPATOPENLIMIT      L"MinOpensForCompatOpenLimit"
#define MINOPENSFORNORMALOPENLIMIT      L"MinOpensForNormalOpenLimit"
#define RESETTIMEFORCOMPATOPENLIMIT     L"ResetTimeForCompatOpenLimit"
#define RESETTIMEFORNORMALOPENLIMIT     L"ResetTimeForNormalOpenLimit"
#define LOWBOUNDFORCOMPATOPENCACHING    L"LowBoundForCompatOpenCaching"
#define LOWBOUNDFORNORMALOPENCACHING    L"LowBoundForNormalOpenCaching"
#define MINREADSFORCORECACHELIMIT       L"MinReadsForCoreCacheLimit"
#define MINWRITESFORCORECACHELIMIT      L"MinWritesForCoreCacheLimit"
#define RESETTIMEFORCORECACHELIMIT      L"ResetTimeForCoreCacheLimit"
#define LOWBOUNDFORCOREREADCACHING      L"LowBoundForCoreReadCaching"
#define LOWBOUNDFORCOREWRITECACHING     L"LowBoundForCoreWriteCaching"
#define MAXNCPMESSAGELENGTH             L"MaxNcpMessageLength"

//
// Names of share "environment variables".
//

#define MAXUSES_VARIABLE_NAME L"MaxUses"
#define PATH_VARIABLE_NAME L"Path"
#define PERMISSIONS_VARIABLE_NAME L"Permissions"
#define REMARK_VARIABLE_NAME L"Remark"
#define TYPE_VARIABLE_NAME L"Type"

//
//  Values for QMSLIB
//

#define CACHEENTRYTIMEOUT               L"CacheEntryTimeout"
#define ERRORNOTIFYINTERVAL             L"ErrorNotifyInterval"
#define MAXIMUMFREEJCBS                 L"MaximumFreeJCBs"
#define MAXIMUMFREESJES                 L"MaximumFreeSJEs"
#define MAXIMUMFREELPCWORKITEMS         L"MaximumFreeLPCWorkItems"
#define FORMSHASHTABLESIZE              L"FormsHashTableSize"
#define JOBINFOALLOWHINT                L"JobInfoAllocHint"
#define PRINTERINFOALLOCHINT            L"PrinterInfoAllocHint"
#define LOGFORMNAMECHANGES              L"LogFormNameChanges"
#define LOGPRINTERNAMECHANGES           L"LogPrinterNameChanges"
#define PRINTJOBNOTIFYFLAG              L"PrintJobNotifyFlag"
#define QUEUEERRORNOTIFYMASK            L"QueueErrorNotifyMask"
#define JOBERRORNOTIFYMASK              L"JobErrorNotifyMask"
#define SHOWPSERVERNAMEFLAG             L"ShowPServerNameFlag"
#define QMSSYNCMODE                     L"QMSSyncMode"
#define ENFORCENETWARESECURITY          L"EnforceNetWareSecurity"
#define OLDNTJOBSYNCINTERVAL            L"OldNtJobSyncInterval"
#define NWPRINTPROCESSOR                L"NWPrintProcessor"
#define DEFAULTQUEUENAME                L"DefaultQueueName"
#define DEFAULTBANNERFILENAME           L"DefaultBannerFileName"
#define PSERVERPORTS                    L"PServerPorts"

//
//  Values for LIBBIND
//

#define FILTERNWUSERS                   L"FilterNWUsers"
#define HOMEBASEDIRECTORY               L"HomeBaseDirectory"
#define DCNAMETIMEOUT                   L"DCNameTimeout"
#define ENUMERATEHINT                   L"EnumerateHint"
#define MAXIMUMFREESCBS                 L"MaximumFreeSCBs"
#define SCBHASHTABLESIZE                L"SCBHashTableSize"
#define SCBTIMEOUT                      L"SCBTimeout"
#define QUEUEDIRECTORY                  L"QueueDirectory"
#define MAXSCBPERCLIENT                 L"MaxSCBPerClient"
#define MAXIMUMFREECACHEDNAMES          L"MaximumFreeCachedNames"
#define CACHEDNAMETIMEOUT               L"CachedNameTimeout"
#define CACHEDNAMESCAVENGETIMEOUT       L"CachedNameScavengeTimeout"
#define USERGROUPSYNCINTERVAL           L"UserGroupSyncInterval"

#endif // _FPNW_NAMES_INCLUDED_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\public\internal\ds\inc\fpnwcomm.h ===
/*++

Copyright (c) 1993-1995, Microsoft Corp. All rights reserved.

Module Name:

    nw\inc\ncmcomm.h

Abstract:

    This module contains common constants and types for the NCP server.

Author:

    Shawn Walker (vswalk) 06-17-1993
    Andy Herron  (andyhe)

Revision History:

--*/

#ifndef _NCPCOMM_
#define _NCPCOMM_

//
// signature for pserver
//
#define NCP_PSERVER_SIGNATURE   L"PS_"

//
// well known object IDs
//
#define NCP_WELL_KNOWN_SUPERVISOR_ID            (ULONG) 0x00000001
#define NCP_WELL_KNOWN_SUPERVISOR_ID_SWAPPED    (ULONG) 0x01000000
#define NCP_WELL_KNOWN_SUPERVISOR_ID_CHICAGO    (ULONG) 0x00010000
#define NCP_WELL_KNOWN_PSERVER_ID               (ULONG) 0x00000002

//
// misc macros that are useful
//
#define SWAPWORD(w)         ((WORD)((w & 0xFF) << 8)|(WORD)(w >> 8))
#define SWAPLONG(l)         MAKELONG(SWAPWORD(HIWORD(l)),SWAPWORD(LOWORD(l)))

#define SWAP_OBJECT_ID(id) (id == NCP_WELL_KNOWN_SUPERVISOR_ID) ?           \
                                NCP_WELL_KNOWN_SUPERVISOR_ID_SWAPPED :      \
                                MAKELONG(LOWORD(id),SWAPWORD(HIWORD(id)))

#define UNSWAP_OBJECT_ID(id) (id == NCP_WELL_KNOWN_SUPERVISOR_ID_SWAPPED || id == NCP_WELL_KNOWN_SUPERVISOR_ID_CHICAGO) ?\
                                NCP_WELL_KNOWN_SUPERVISOR_ID :              \
                                MAKELONG(LOWORD(id),SWAPWORD(HIWORD(id)))


//
// misc masks/bits for Object ID munging
//

#define BINDLIB_ID_MASK                         0xF0000000

#define BINDLIB_NCP_SAM                         0x00000000

//
//  This bit is set when the server is running on a NTAS machine or
//  the object is from a trusted domain.
//
//  !! Note that there are places where we check this bit to see if either
//  !! BINDLIB_REMOTE_DOMAIN_BIAS or BINDLIB_LOCAL_USER_BIAS is set.
//

#define BINDLIB_REMOTE_DOMAIN_BIAS              0x10000000

//
//  If the client is from the builtin domain, this bit will be set.  This
//  is opposed to the local domain, which is different.
//

#define BINDLIB_BUILTIN_BIAS                    0x20000000

//
//  If the client is from a trusted domain and the rid is from the
//  local domain and the client's rid is the same as the rid from the
//  sid, we will mark that the rid is the same as the local user's sid.
//
//  !! Note... this is a value, not a flag.  This will require special casing
//  !! everywhere but we can't spare any more bits.
//

#define BINDLIB_LOCAL_USER_BIAS                 0x70000000

//
//  User defined objects that is stored in the registry.
//

#define BINDLIB_NCP_USER_DEFINED                0x40000000

//
//  Print Queues and Print Servers that is stored in the registry.
//  The bindery keeps a list of print queues in a link list so that
//  the bindery does not have to go look in the registry all the time.
//

#define BINDLIB_NCP_REGISTRY                    0x80000000

//
//  The SAP Agent uses these bits.  The SAP Agent cannot go any higher
//  than the value below.
//

#define BINDLIB_NCP_SAP                         0xC0000000
#define BINDLIB_NCP_MAX_SAP                     0xCFFFFFFF

//
//  We have some reserved fields for unknown users that will go into the
//  following range....
//

#define NCP_UNKNOWN_USER                            0xD0000000
#define NCP_SAME_RID_AS_CLIENT_BUT_LOCAL            0xDFFFFFFF
#define NCP_USER_IS_CONNECTED_BUT_REMOTE(connid)    (0xD0000000 | (connid))
#define NCP_WELL_KNOWN_RID(rid)                     (0xD1000000 | (rid))

//
//  Chicago will use a range of object ids that start at the below value
//  and go to 0xFFFFFFFF.  We should never see these on our server when
//  a chicago server is passing through to us.
//

#define BINDLIB_CHICAGO                         0xE0000000

//
//  This is used to remove the domain bias from a object id.
//

#define BINDLIB_MASK_OUT_DOMAIN_BIAS            0x70000000


#define NCP_INITIAL_SEARCH                      (ULONG) 0xFFFFFFFF
#define NCP_ANY_TARGET_SERVER                   (ULONG) 0xFFFFFFFF

#define NCP_OBJECT_HAS_PROPERTIES               (UCHAR) 0xFF
#define NCP_OBJECT_HAS_NO_PROPERTIES            (UCHAR) 0

#define NCP_PROPERTY_HAS_VALUE                  (UCHAR) 0xFF
#define NCP_PROPERTY_HAS_NO_VALUE               (UCHAR) 0

#define NCP_MORE_PROPERTY                       (UCHAR) 0xFF
#define NCP_NO_MORE_PROPERTY                    (UCHAR) 0

#define NCP_MORE_SEGMENTS                       (UCHAR) 0xFF
#define NCP_NO_MORE_SEGMENTS                    (UCHAR) 0

#define NCP_DO_REMOVE_REMAINING_SEGMENTS        (UCHAR) 0
#define NCP_DO_NOT_REMOVE_REMAINING_SEGMENTS    (UCHAR) 0xFF


/*++
*******************************************************************
        Maximum length for the Bindery
*******************************************************************
--*/

#define NETWARE_OBJECTNAMELENGTH                47
#define NETWARE_PROPERTYNAMELENGTH              16
#define NETWARE_PROPERTYVALUELENGTH             128
#define NETWARE_TIME_RESTRICTION_LENGTH         42

#define NETWARE_PASSWORDLENGTH                  128
#define NCP_MAX_ENCRYPTED_PASSWORD_LENGTH       16

#define NETWARE_MAX_OBJECT_IDS_IN_SET           32

#define NETWARE_SERVERNAMELENGTH                48
#define NETWARE_VOLUMENAMELENGTH                16
#define NETWARE_MAX_PATH_LENGTH                 255


/*++
*******************************************************************
        Well known NetWare object types
*******************************************************************
--*/

#define NCP_OT_WILD                       0xFFFF
#define NCP_OT_UNKNOWN                    0x0000
#define NCP_OT_USER                       0x0001
#define NCP_OT_USER_GROUP                 0x0002
#define NCP_OT_PRINT_QUEUE                0x0003
#define NCP_OT_FILE_SERVER                0x0004
#define NCP_OT_JOB_SERVER                 0x0005
#define NCP_OT_GATEWAY                    0x0006
#define NCP_OT_PRINT_SERVER               0x0007
#define NCP_OT_ARCHIVE_QUEUE              0x0008
#define NCP_OT_ARCHIVE_SEVER              0x0009
#define NCP_OT_JOB_QUEUE                  0x000A
#define NCP_OT_ADMINISTRATION             0x000B
#define NCP_OT_SNA_GATEWAY                0x0021
#define NCP_OT_REMOTE_BRIDGE              0x0024
#define NCP_OT_REMOTE_BRIDGE_SERVER       0x0026
#define NCP_OT_ADVERTISING_PRINT_SERVER   0x0047


/*++
*******************************************************************
        Bindery flags
*******************************************************************
--*/

/** NetWare Bindery Flags **/

#define NCP_STATIC          0x00    /* Property or Object exists until it
                                       is deleted with Delete Property or
                                       Object */
#define NCP_DYNAMIC         0x01    /* Property or Object is deleted from
                                       bindery when file server is started */
#define NCP_ITEM            0x00    /* Values are defined and interpreted by
                                       applications or by APIs */
#define NCP_SET             0x02    /* Series of Object ID numbers, each 4
                                       bytes long */

/** NetWare Bindery Security Flags **/

#define NCP_ANY_READ        0x00    /* Readable by anyone */
#define NCP_LOGGED_READ     0x01    /* Must be logged in to read */
#define NCP_OBJECT_READ     0x02    /* Readable by same object or super */
#define NCP_BINDERY_READ    0x04    /* Readable only by the bindery */

#define NCP_SUPER_READ      NCP_LOGGED_READ | NCP_OBJECT_READ

#define NCP_ALL_READ        NCP_ANY_READ | NCP_LOGGED_READ | NCP_OBJECT_READ

#define NCP_ANY_WRITE       0x00    /* Writeable by anyone */
#define NCP_LOGGED_WRITE    0x10    /* Must be logged in to write */
#define NCP_OBJECT_WRITE    0x20    /* Writeable by same object or super */
#define NCP_BINDERY_WRITE   0x40    /* Writeable only by the bindery */

#define NCP_SUPER_WRITE     NCP_LOGGED_WRITE | NCP_OBJECT_WRITE

#define NCP_ALL_WRITE       NCP_ANY_WRITE | NCP_LOGGED_WRITE | NCP_OBJECT_WRITE

//  File Attributes

#define NW_ATTRIBUTE_SHARABLE       0x80
#define NW_ATTRIBUTE_ARCHIVE        0x20
#define NW_ATTRIBUTE_DIRECTORY      0x10
#define NW_ATTRIBUTE_EXECUTE_ONLY   0x08
#define NW_ATTRIBUTE_SYSTEM         0x04
#define NW_ATTRIBUTE_HIDDEN         0x02
#define NW_ATTRIBUTE_READ_ONLY      0x01

//  Open Flags

#define NW_OPEN_EXCLUSIVE           0x10
#define NW_DENY_WRITE               0x08
#define NW_DENY_READ                0x04
#define NW_OPEN_FOR_WRITE           0x02
#define NW_OPEN_FOR_READ            0x01

//
//  Connection status flags
//

#define NCP_STATUS_BAD_CONNECTION   0x01
#define NCP_STATUS_NO_CONNECTIONS   0x02
#define NCP_STATUS_SERVER_DOWN      0x04
#define NCP_STATUS_MSG_PENDING      0x08

//
//  Special values for SmallWorld PDC object and property name
//

#define MS_WINNT_NAME      "MS_WINNT"
#define MS_SYNC_PDC_NAME   "SYNCPDC"
#define MS_WINNT_OBJ_TYPE  0x06BB

//
//  User Property values (ie. User Parms stuff)
//

#define USER_PROPERTY_SIGNATURE     L'P'

#define NWPASSWORD                  L"NWPassword"
#define OLDNWPASSWORD               L"OldNWPassword"
#define MAXCONNECTIONS              L"MaxConnections"
#define NWTIMEPASSWORDSET           L"NWPasswordSet"
#define SZTRUE                      L"TRUE"
#define GRACELOGINALLOWED           L"GraceLoginAllowed"
#define GRACELOGINREMAINING         L"GraceLoginRemaining"
#define NWLOGONFROM                 L"NWLogonFrom"
#define NWHOMEDIR                   L"NWHomeDir"
#define NW_PRINT_SERVER_REF_COUNT   L"PSRefCount"

#define SUPERVISOR_USERID           NCP_WELL_KNOWN_SUPERVISOR_ID
#define SUPERVISOR_NAME_STRING      L"Supervisor"
#define SYSVOL_NAME_STRING          L"SYS"
#define NWENCRYPTEDPASSWORDLENGTH   8
#define NO_LIMIT                    0xffff

#define DEFAULT_MAXCONNECTIONS      NO_LIMIT
#define DEFAULT_NWPASSWORDEXPIRED   FALSE
#define DEFAULT_GRACELOGINALLOWED   6
#define DEFAULT_GRACELOGINREMAINING 6
#define DEFAULT_NWLOGONFROM         NULL
#define DEFAULT_NWHOMEDIR           NULL

#define USER_PROPERTY_TYPE_ITEM     1
#define USER_PROPERTY_TYPE_SET      2

#endif /* _NCPCOMM_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\public\internal\ds\inc\ginaipc.h ===
//  --------------------------------------------------------------------------
//  Module Name: GinaIPC.h
//
//  Copyright (c) 1999-2000, Microsoft Corporation
//
//  Private structures that allow the CLogonIPC class hosted in an external
//  process to communicate with GINA which provides the logon service within
//  the Winlogon process.
//
//  History:    1999-08-20  vtan        created
//              2000-01-31  vtan        moved from Neptune to Whistler
//              2000-05-05  vtan        added GINA -> UI communications
//              2000-06-16  vtan        moved to ds\published\inc
//  --------------------------------------------------------------------------

#ifndef     _GinaIPC_
#define     _GinaIPC_

#include <lmcons.h>

//  These are enumerations of valid requested functionality.

static  const UINT  WM_LOGONSERVICEREQUEST                  =   WM_USER + 8517;
static  const UINT  WM_UISERVICEREQUEST                     =   WM_USER + 7647;

//  These are messages for UI -> GINA communications.

static  const int   LOGON_QUERY_LOGGED_ON                   =   1;
static  const int   LOGON_LOGON_USER                        =   2;
static  const int   LOGON_LOGOFF_USER                       =   3;
static  const int   LOGON_TEST_BLANK_PASSWORD               =   4;
static  const int   LOGON_TEST_INTERACTIVE_LOGON_ALLOWED    =   5;
static  const int   LOGON_TEST_EJECT_ALLOWED                =   6;
static  const int   LOGON_TEST_SHUTDOWN_ALLOWED             =   7;
static  const int   LOGON_TURN_OFF_COMPUTER                 =   10;
static  const int   LOGON_EJECT_COMPUTER                    =   11;
static  const int   LOGON_SIGNAL_UIHOST_FAILURE             =   20;
static  const int   LOGON_ALLOW_EXTERNAL_CREDENTIALS        =   30;
static  const int   LOGON_REQUEST_EXTERNAL_CREDENTIALS      =   31;

//  These are messages for GINA -> UI communications.

static  const int   UI_STATE_NONE                           =   0;
static  const int   UI_TERMINATE                            =   1;
static  const int   UI_STATE_STATUS                         =   2;
static  const int   UI_STATE_LOGON                          =   3;
static  const int   UI_STATE_LOGGEDON                       =   4;
static  const int   UI_STATE_HIDE                           =   5;
static  const int   UI_STATE_END                            =   6;
static  const int   UI_DISPLAY_STATUS                       =   10;
static  const int   UI_NOTIFY_WAIT                          =   20;
static  const int   UI_SELECT_USER                          =   21;
static  const int   UI_SET_ANIMATIONS                       =   22;
static  const int   UI_INTERACTIVE_LOGON                    =   30;

//  These are start methods of the UI host

static  const int   HOST_START_NORMAL                       =   0;
static  const int   HOST_START_SHUTDOWN                     =   1;
static  const int   HOST_START_WAIT                         =   2;

//  These are end methods of the UI host

static  const int   HOST_END_HIDE                           =   0;
static  const int   HOST_END_TERMINATE                      =   1;
static  const int   HOST_END_FAILURE                        =   2;

//  This is generic to all request types.

typedef struct
{
    BOOL            fResult;
} LOGONIPC;

//  This represents user identification.

typedef struct
{
    LOGONIPC        logonIPC;
    WCHAR           wszUsername[UNLEN + sizeof('\0')],
                    wszDomain[DNLEN + sizeof('\0')];
} LOGONIPC_USERID;

//  This represents user credentials (identification + password).
//  The password is run encoded when stored in memory.

typedef struct
{
    LOGONIPC_USERID     userID;
    WCHAR               wszPassword[PWLEN + sizeof('\0')];
    int                 iPasswordLength;
    unsigned char       ucPasswordSeed;
} LOGONIPC_CREDENTIALS;

//  This structure is used to return users from msgina to shgina.

typedef struct
{
    LPWSTR  pszName;
    LPWSTR  pszDomain;
    LPWSTR  pszFullName;
    DWORD   dwFlags;
} GINA_USER_INFORMATION;

//  This is the status window class shared between msgina and shgina.

#define     STATUS_WINDOW_CLASS_NAME    (TEXT("StatusWindowClass"))

#endif  /*  _GinaIPC_   */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\public\internal\ds\inc\ftnfoctx.h ===
/*++

Copyright (c) 1987-2001  Microsoft Corporation

Module Name:

    ftnfoctx.h

Abstract:

    Utility routines for manipulating the forest trust context

Author:

    27-Jul-00 (cliffv)

Environment:

    User mode only.
    Contains NT-specific code.
    Requires ANSI C extensions: slash-slash comments, long external names.

Revision History:

--*/


#ifndef __FTNFOCTX_H
#define __FTNFOCTX_H

//
// Context used to collect the individual FTinfo entries
//

typedef struct _NL_FTINFO_CONTEXT {

    //
    // List of all the FTinfo structures collected so far.
    //

    LIST_ENTRY FtinfoList;

    //
    // Size (in bytes) of the entries on FtinfoList.
    //

    ULONG FtinfoSize;

    //
    // Number of entries on FtinfoList
    //

    ULONG FtinfoCount;

} NL_FTINFO_CONTEXT, *PNL_FTINFO_CONTEXT;

//
// A single FTinfo entry
//

typedef struct _NL_FTINFO_ENTRY {

    //
    // Link off of NL_FITINFO_CONTEXT->FtinfoList
    //

    LIST_ENTRY Next;

    //
    // Size (in bytes) of just the 'Record' portion of this entry
    //

    ULONG Size;

    //
    // Pad the Record to start on an ALIGN_WORST boundary
    //

    ULONG Pad;

    //
    // The actual Ftinfo entry
    //

    LSA_FOREST_TRUST_RECORD Record;

} NL_FTINFO_ENTRY, *PNL_FTINFO_ENTRY;

#ifdef __cplusplus
extern "C" {
#endif


VOID
NetpInitFtinfoContext(
    OUT PNL_FTINFO_CONTEXT FtinfoContext
    );


PLSA_FOREST_TRUST_INFORMATION
NetpCopyFtinfoContext(
    IN PNL_FTINFO_CONTEXT FtinfoContext
    );


VOID
NetpCleanFtinfoContext(
    IN PNL_FTINFO_CONTEXT FtinfoContext
    );


BOOLEAN
NetpAllocFtinfoEntry (
    IN PNL_FTINFO_CONTEXT FtinfoContext,
    IN LSA_FOREST_TRUST_RECORD_TYPE ForestTrustType,
    IN PUNICODE_STRING Name,
    IN PSID Sid,
    IN PUNICODE_STRING NetbiosName
    );


BOOLEAN
NetpAddTlnFtinfoEntry (
    IN PNL_FTINFO_CONTEXT FtinfoContext,
    IN PUNICODE_STRING Name
    );


NTSTATUS
NetpMergeFtinfo(
    IN PUNICODE_STRING TrustedDomainName,
    IN PLSA_FOREST_TRUST_INFORMATION InNewForestTrustInfo,
    IN PLSA_FOREST_TRUST_INFORMATION InOldForestTrustInfo OPTIONAL,
    OUT PLSA_FOREST_TRUST_INFORMATION *MergedForestTrustInfo
    );

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\public\internal\ds\inc\iadsp.h ===
#pragma warning( disable: 4049 )  /* more than 64k source lines */

/* this ALWAYS GENERATED file contains the definitions for the interfaces */


 /* File created by MIDL compiler version 6.00.0347 */
/* Compiler settings for adsp.odl:
    Os, W1, Zp8, env=Win32 (32b run)
    protocol : dce , ms_ext, c_ext
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )


/* verify that the <rpcndr.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCNDR_H_VERSION__
#define __REQUIRED_RPCNDR_H_VERSION__ 440
#endif

#include "rpc.h"
#include "rpcndr.h"

#ifndef __iadsp_h__
#define __iadsp_h__

#if defined(_MSC_VER) && (_MSC_VER >= 1020)
#pragma once
#endif

/* Forward Declarations */ 

#ifndef __IADsValue_FWD_DEFINED__
#define __IADsValue_FWD_DEFINED__
typedef interface IADsValue IADsValue;
#endif 	/* __IADsValue_FWD_DEFINED__ */


#ifndef __IADsObjOptPrivate_FWD_DEFINED__
#define __IADsObjOptPrivate_FWD_DEFINED__
typedef interface IADsObjOptPrivate IADsObjOptPrivate;
#endif 	/* __IADsObjOptPrivate_FWD_DEFINED__ */


#ifndef __IADsUmiHelperPrivate_FWD_DEFINED__
#define __IADsUmiHelperPrivate_FWD_DEFINED__
typedef interface IADsUmiHelperPrivate IADsUmiHelperPrivate;
#endif 	/* __IADsUmiHelperPrivate_FWD_DEFINED__ */


#ifndef __IADsPathnameProvider_FWD_DEFINED__
#define __IADsPathnameProvider_FWD_DEFINED__
typedef interface IADsPathnameProvider IADsPathnameProvider;
#endif 	/* __IADsPathnameProvider_FWD_DEFINED__ */


#ifndef __IUmiADSIPrivate_FWD_DEFINED__
#define __IUmiADSIPrivate_FWD_DEFINED__
typedef interface IUmiADSIPrivate IUmiADSIPrivate;
#endif 	/* __IUmiADSIPrivate_FWD_DEFINED__ */


#ifndef __IADsAcePrivate_FWD_DEFINED__
#define __IADsAcePrivate_FWD_DEFINED__
typedef interface IADsAcePrivate IADsAcePrivate;
#endif 	/* __IADsAcePrivate_FWD_DEFINED__ */


#ifdef __cplusplus
extern "C"{
#endif 

void * __RPC_USER MIDL_user_allocate(size_t);
void __RPC_USER MIDL_user_free( void * ); 

/* interface __MIDL_itf_adsp_0000 */
/* [local] */ 

#define IID_IDirectoryAttrMgmt IID_IDirectorySchemaMgmt
#define IDirectoryAttrMgmt IDirectorySchemaMgmt


extern RPC_IF_HANDLE __MIDL_itf_adsp_0000_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_adsp_0000_v0_0_s_ifspec;


#ifndef __ActiveDsP_LIBRARY_DEFINED__
#define __ActiveDsP_LIBRARY_DEFINED__

/* library ActiveDsP */
/* [helpstring][version][uuid] */ 

typedef /* [public] */ 
enum __MIDL___MIDL_itf_adsp_0000_0001
    {	ADS_PRIVATE_OPTION_SPECIFIC_SERVER	= 101,
	ADS_PRIVATE_OPTION_KEEP_HANDLES	= 102
    } 	ADS_PRIVATE_OPTION_ENUM;

typedef struct _path_component
    {
    LPTSTR szComponent;
    LPTSTR szValue;
    } 	PATH_COMPONENT;

typedef struct _path_component *PPATH_COMPONENT;

typedef struct _path_objectinfo
    {
    LPTSTR ProviderName;
    LPTSTR ServerName;
    LPTSTR DisplayServerName;
    DWORD dwPathType;
    DWORD NumComponents;
    PATH_COMPONENT ComponentArray[ 64 ];
    PATH_COMPONENT DisplayComponentArray[ 64 ];
    PATH_COMPONENT ProvSpecComponentArray[ 64 ];
    } 	PATH_OBJECTINFO;

typedef struct _path_objectinfo *PPATH_OBJECTINFO;


enum __MIDL___MIDL_itf_adsp_0115_0001
    {	ADS_PARSE_FULL	= 1,
	ADS_PARSE_DN	= 2,
	ADS_PARSE_COMPONENT	= 3
    } ;

enum __MIDL___MIDL_itf_adsp_0115_0002
    {	ADS_PATHTYPE_ROOTFIRST	= 1,
	ADS_PATHTYPE_LEAFFIRST	= 2
    } ;

enum __MIDL___MIDL_itf_adsp_0115_0003
    {	ADS_CONSTRUCT_NAMINGATTRIBUTE	= 1
    } ;

EXTERN_C const IID LIBID_ActiveDsP;

#ifndef __IADsValue_INTERFACE_DEFINED__
#define __IADsValue_INTERFACE_DEFINED__

/* interface IADsValue */
/* [object][uuid] */ 


EXTERN_C const IID IID_IADsValue;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("1e3ef0aa-aef5-11d0-8537-00c04fd8d503")
    IADsValue : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE ConvertADsValueToPropertyValue( 
            PADSVALUE pADsValue) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ConvertPropertyValueToADsValue( 
            PADSVALUE pADsValue) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ConvertPropertyValueToADsValue2( 
            PADSVALUE pADsValue,
            BSTR pszServerName,
            BSTR userName,
            BSTR passWord,
            LONG flags,
            BOOL fNTDSType) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IADsValueVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IADsValue * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IADsValue * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IADsValue * This);
        
        HRESULT ( STDMETHODCALLTYPE *ConvertADsValueToPropertyValue )( 
            IADsValue * This,
            PADSVALUE pADsValue);
        
        HRESULT ( STDMETHODCALLTYPE *ConvertPropertyValueToADsValue )( 
            IADsValue * This,
            PADSVALUE pADsValue);
        
        HRESULT ( STDMETHODCALLTYPE *ConvertPropertyValueToADsValue2 )( 
            IADsValue * This,
            PADSVALUE pADsValue,
            BSTR pszServerName,
            BSTR userName,
            BSTR passWord,
            LONG flags,
            BOOL fNTDSType);
        
        END_INTERFACE
    } IADsValueVtbl;

    interface IADsValue
    {
        CONST_VTBL struct IADsValueVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IADsValue_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IADsValue_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IADsValue_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IADsValue_ConvertADsValueToPropertyValue(This,pADsValue)	\
    (This)->lpVtbl -> ConvertADsValueToPropertyValue(This,pADsValue)

#define IADsValue_ConvertPropertyValueToADsValue(This,pADsValue)	\
    (This)->lpVtbl -> ConvertPropertyValueToADsValue(This,pADsValue)

#define IADsValue_ConvertPropertyValueToADsValue2(This,pADsValue,pszServerName,userName,passWord,flags,fNTDSType)	\
    (This)->lpVtbl -> ConvertPropertyValueToADsValue2(This,pADsValue,pszServerName,userName,passWord,flags,fNTDSType)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IADsValue_ConvertADsValueToPropertyValue_Proxy( 
    IADsValue * This,
    PADSVALUE pADsValue);


void __RPC_STUB IADsValue_ConvertADsValueToPropertyValue_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IADsValue_ConvertPropertyValueToADsValue_Proxy( 
    IADsValue * This,
    PADSVALUE pADsValue);


void __RPC_STUB IADsValue_ConvertPropertyValueToADsValue_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IADsValue_ConvertPropertyValueToADsValue2_Proxy( 
    IADsValue * This,
    PADSVALUE pADsValue,
    BSTR pszServerName,
    BSTR userName,
    BSTR passWord,
    LONG flags,
    BOOL fNTDSType);


void __RPC_STUB IADsValue_ConvertPropertyValueToADsValue2_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IADsValue_INTERFACE_DEFINED__ */


#ifndef __IADsObjOptPrivate_INTERFACE_DEFINED__
#define __IADsObjOptPrivate_INTERFACE_DEFINED__

/* interface IADsObjOptPrivate */
/* [object][uuid] */ 


EXTERN_C const IID IID_IADsObjOptPrivate;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("81cbb829-1867-11d2-9220-00c04fb6d0d1")
    IADsObjOptPrivate : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetOption( 
            DWORD dwOption,
            void *pValue) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetOption( 
            DWORD dwOption,
            void *pValue) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IADsObjOptPrivateVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IADsObjOptPrivate * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IADsObjOptPrivate * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IADsObjOptPrivate * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetOption )( 
            IADsObjOptPrivate * This,
            DWORD dwOption,
            void *pValue);
        
        HRESULT ( STDMETHODCALLTYPE *SetOption )( 
            IADsObjOptPrivate * This,
            DWORD dwOption,
            void *pValue);
        
        END_INTERFACE
    } IADsObjOptPrivateVtbl;

    interface IADsObjOptPrivate
    {
        CONST_VTBL struct IADsObjOptPrivateVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IADsObjOptPrivate_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IADsObjOptPrivate_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IADsObjOptPrivate_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IADsObjOptPrivate_GetOption(This,dwOption,pValue)	\
    (This)->lpVtbl -> GetOption(This,dwOption,pValue)

#define IADsObjOptPrivate_SetOption(This,dwOption,pValue)	\
    (This)->lpVtbl -> SetOption(This,dwOption,pValue)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IADsObjOptPrivate_GetOption_Proxy( 
    IADsObjOptPrivate * This,
    DWORD dwOption,
    void *pValue);


void __RPC_STUB IADsObjOptPrivate_GetOption_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IADsObjOptPrivate_SetOption_Proxy( 
    IADsObjOptPrivate * This,
    DWORD dwOption,
    void *pValue);


void __RPC_STUB IADsObjOptPrivate_SetOption_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IADsObjOptPrivate_INTERFACE_DEFINED__ */


#ifndef __IADsUmiHelperPrivate_INTERFACE_DEFINED__
#define __IADsUmiHelperPrivate_INTERFACE_DEFINED__

/* interface IADsUmiHelperPrivate */
/* [object][uuid] */ 


EXTERN_C const IID IID_IADsUmiHelperPrivate;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("4fe243f0-ad89-4cbc-9b14-486126446ae0")
    IADsUmiHelperPrivate : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetPropertiesHelper( 
            void **ppValue,
            DWORD *pdwPropCount) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetOriginHelper( 
            LPCWSTR pszName,
            BSTR *pbstrOrigin) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IADsUmiHelperPrivateVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IADsUmiHelperPrivate * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IADsUmiHelperPrivate * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IADsUmiHelperPrivate * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetPropertiesHelper )( 
            IADsUmiHelperPrivate * This,
            void **ppValue,
            DWORD *pdwPropCount);
        
        HRESULT ( STDMETHODCALLTYPE *GetOriginHelper )( 
            IADsUmiHelperPrivate * This,
            LPCWSTR pszName,
            BSTR *pbstrOrigin);
        
        END_INTERFACE
    } IADsUmiHelperPrivateVtbl;

    interface IADsUmiHelperPrivate
    {
        CONST_VTBL struct IADsUmiHelperPrivateVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IADsUmiHelperPrivate_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IADsUmiHelperPrivate_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IADsUmiHelperPrivate_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IADsUmiHelperPrivate_GetPropertiesHelper(This,ppValue,pdwPropCount)	\
    (This)->lpVtbl -> GetPropertiesHelper(This,ppValue,pdwPropCount)

#define IADsUmiHelperPrivate_GetOriginHelper(This,pszName,pbstrOrigin)	\
    (This)->lpVtbl -> GetOriginHelper(This,pszName,pbstrOrigin)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IADsUmiHelperPrivate_GetPropertiesHelper_Proxy( 
    IADsUmiHelperPrivate * This,
    void **ppValue,
    DWORD *pdwPropCount);


void __RPC_STUB IADsUmiHelperPrivate_GetPropertiesHelper_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IADsUmiHelperPrivate_GetOriginHelper_Proxy( 
    IADsUmiHelperPrivate * This,
    LPCWSTR pszName,
    BSTR *pbstrOrigin);


void __RPC_STUB IADsUmiHelperPrivate_GetOriginHelper_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IADsUmiHelperPrivate_INTERFACE_DEFINED__ */


#ifndef __IADsPathnameProvider_INTERFACE_DEFINED__
#define __IADsPathnameProvider_INTERFACE_DEFINED__

/* interface IADsPathnameProvider */
/* [object][uuid] */ 


EXTERN_C const IID IID_IADsPathnameProvider;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("aacd1d30-8bd0-11d2-92a9-00c04f79f834")
    IADsPathnameProvider : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE ParsePath( 
            /* [in] */ BSTR bstrPath,
            /* [in] */ DWORD dwType,
            /* [in] */ PPATH_OBJECTINFO pObjectInfo) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ConstructPath( 
            /* [in] */ PPATH_OBJECTINFO pObjectInfo,
            /* [in] */ DWORD dwType,
            /* [in] */ DWORD dwFlag,
            /* [in] */ DWORD dwEscapedMode,
            /* [out] */ BSTR *pbstrPath) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetEscapedElement( 
            /* [in] */ LONG lnReserved,
            /* [in] */ BSTR bstrInStr,
            /* [out] */ BSTR *pbstrOutStr) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IADsPathnameProviderVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IADsPathnameProvider * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IADsPathnameProvider * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IADsPathnameProvider * This);
        
        HRESULT ( STDMETHODCALLTYPE *ParsePath )( 
            IADsPathnameProvider * This,
            /* [in] */ BSTR bstrPath,
            /* [in] */ DWORD dwType,
            /* [in] */ PPATH_OBJECTINFO pObjectInfo);
        
        HRESULT ( STDMETHODCALLTYPE *ConstructPath )( 
            IADsPathnameProvider * This,
            /* [in] */ PPATH_OBJECTINFO pObjectInfo,
            /* [in] */ DWORD dwType,
            /* [in] */ DWORD dwFlag,
            /* [in] */ DWORD dwEscapedMode,
            /* [out] */ BSTR *pbstrPath);
        
        HRESULT ( STDMETHODCALLTYPE *GetEscapedElement )( 
            IADsPathnameProvider * This,
            /* [in] */ LONG lnReserved,
            /* [in] */ BSTR bstrInStr,
            /* [out] */ BSTR *pbstrOutStr);
        
        END_INTERFACE
    } IADsPathnameProviderVtbl;

    interface IADsPathnameProvider
    {
        CONST_VTBL struct IADsPathnameProviderVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IADsPathnameProvider_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IADsPathnameProvider_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IADsPathnameProvider_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IADsPathnameProvider_ParsePath(This,bstrPath,dwType,pObjectInfo)	\
    (This)->lpVtbl -> ParsePath(This,bstrPath,dwType,pObjectInfo)

#define IADsPathnameProvider_ConstructPath(This,pObjectInfo,dwType,dwFlag,dwEscapedMode,pbstrPath)	\
    (This)->lpVtbl -> ConstructPath(This,pObjectInfo,dwType,dwFlag,dwEscapedMode,pbstrPath)

#define IADsPathnameProvider_GetEscapedElement(This,lnReserved,bstrInStr,pbstrOutStr)	\
    (This)->lpVtbl -> GetEscapedElement(This,lnReserved,bstrInStr,pbstrOutStr)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IADsPathnameProvider_ParsePath_Proxy( 
    IADsPathnameProvider * This,
    /* [in] */ BSTR bstrPath,
    /* [in] */ DWORD dwType,
    /* [in] */ PPATH_OBJECTINFO pObjectInfo);


void __RPC_STUB IADsPathnameProvider_ParsePath_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IADsPathnameProvider_ConstructPath_Proxy( 
    IADsPathnameProvider * This,
    /* [in] */ PPATH_OBJECTINFO pObjectInfo,
    /* [in] */ DWORD dwType,
    /* [in] */ DWORD dwFlag,
    /* [in] */ DWORD dwEscapedMode,
    /* [out] */ BSTR *pbstrPath);


void __RPC_STUB IADsPathnameProvider_ConstructPath_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IADsPathnameProvider_GetEscapedElement_Proxy( 
    IADsPathnameProvider * This,
    /* [in] */ LONG lnReserved,
    /* [in] */ BSTR bstrInStr,
    /* [out] */ BSTR *pbstrOutStr);


void __RPC_STUB IADsPathnameProvider_GetEscapedElement_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IADsPathnameProvider_INTERFACE_DEFINED__ */


#ifndef __IUmiADSIPrivate_INTERFACE_DEFINED__
#define __IUmiADSIPrivate_INTERFACE_DEFINED__

/* interface IUmiADSIPrivate */
/* [object][uuid] */ 


EXTERN_C const IID IID_IUmiADSIPrivate;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("8f3bb40b-d4ad-4648-ae4a-6efa197a1656")
    IUmiADSIPrivate : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetContainer( 
            void **ppContainer) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetCoreObject( 
            void **ppCoreObj) = 0;
        
        virtual void STDMETHODCALLTYPE SetUmiFlag( void) = 0;
        
        virtual void STDMETHODCALLTYPE ResetUmiFlag( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IUmiADSIPrivateVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IUmiADSIPrivate * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IUmiADSIPrivate * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IUmiADSIPrivate * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetContainer )( 
            IUmiADSIPrivate * This,
            void **ppContainer);
        
        HRESULT ( STDMETHODCALLTYPE *GetCoreObject )( 
            IUmiADSIPrivate * This,
            void **ppCoreObj);
        
        void ( STDMETHODCALLTYPE *SetUmiFlag )( 
            IUmiADSIPrivate * This);
        
        void ( STDMETHODCALLTYPE *ResetUmiFlag )( 
            IUmiADSIPrivate * This);
        
        END_INTERFACE
    } IUmiADSIPrivateVtbl;

    interface IUmiADSIPrivate
    {
        CONST_VTBL struct IUmiADSIPrivateVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IUmiADSIPrivate_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IUmiADSIPrivate_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IUmiADSIPrivate_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IUmiADSIPrivate_GetContainer(This,ppContainer)	\
    (This)->lpVtbl -> GetContainer(This,ppContainer)

#define IUmiADSIPrivate_GetCoreObject(This,ppCoreObj)	\
    (This)->lpVtbl -> GetCoreObject(This,ppCoreObj)

#define IUmiADSIPrivate_SetUmiFlag(This)	\
    (This)->lpVtbl -> SetUmiFlag(This)

#define IUmiADSIPrivate_ResetUmiFlag(This)	\
    (This)->lpVtbl -> ResetUmiFlag(This)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IUmiADSIPrivate_GetContainer_Proxy( 
    IUmiADSIPrivate * This,
    void **ppContainer);


void __RPC_STUB IUmiADSIPrivate_GetContainer_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IUmiADSIPrivate_GetCoreObject_Proxy( 
    IUmiADSIPrivate * This,
    void **ppCoreObj);


void __RPC_STUB IUmiADSIPrivate_GetCoreObject_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


void STDMETHODCALLTYPE IUmiADSIPrivate_SetUmiFlag_Proxy( 
    IUmiADSIPrivate * This);


void __RPC_STUB IUmiADSIPrivate_SetUmiFlag_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


void STDMETHODCALLTYPE IUmiADSIPrivate_ResetUmiFlag_Proxy( 
    IUmiADSIPrivate * This);


void __RPC_STUB IUmiADSIPrivate_ResetUmiFlag_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IUmiADSIPrivate_INTERFACE_DEFINED__ */


#ifndef __IADsAcePrivate_INTERFACE_DEFINED__
#define __IADsAcePrivate_INTERFACE_DEFINED__

/* interface IADsAcePrivate */
/* [object][uuid] */ 


EXTERN_C const IID IID_IADsAcePrivate;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("fd145df2-fd96-4135-9b22-68ff0f6bf5bb")
    IADsAcePrivate : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE getSid( 
            /* [out] */ PSID *ppSid,
            /* [out] */ DWORD *pdwLength) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE putSid( 
            /* [in] */ PSID pSid,
            /* [in] */ DWORD dwLength) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE isSidValid( 
            /* [out] */ BOOL *pfSidValid) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IADsAcePrivateVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IADsAcePrivate * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IADsAcePrivate * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IADsAcePrivate * This);
        
        HRESULT ( STDMETHODCALLTYPE *getSid )( 
            IADsAcePrivate * This,
            /* [out] */ PSID *ppSid,
            /* [out] */ DWORD *pdwLength);
        
        HRESULT ( STDMETHODCALLTYPE *putSid )( 
            IADsAcePrivate * This,
            /* [in] */ PSID pSid,
            /* [in] */ DWORD dwLength);
        
        HRESULT ( STDMETHODCALLTYPE *isSidValid )( 
            IADsAcePrivate * This,
            /* [out] */ BOOL *pfSidValid);
        
        END_INTERFACE
    } IADsAcePrivateVtbl;

    interface IADsAcePrivate
    {
        CONST_VTBL struct IADsAcePrivateVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IADsAcePrivate_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IADsAcePrivate_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IADsAcePrivate_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IADsAcePrivate_getSid(This,ppSid,pdwLength)	\
    (This)->lpVtbl -> getSid(This,ppSid,pdwLength)

#define IADsAcePrivate_putSid(This,pSid,dwLength)	\
    (This)->lpVtbl -> putSid(This,pSid,dwLength)

#define IADsAcePrivate_isSidValid(This,pfSidValid)	\
    (This)->lpVtbl -> isSidValid(This,pfSidValid)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IADsAcePrivate_getSid_Proxy( 
    IADsAcePrivate * This,
    /* [out] */ PSID *ppSid,
    /* [out] */ DWORD *pdwLength);


void __RPC_STUB IADsAcePrivate_getSid_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IADsAcePrivate_putSid_Proxy( 
    IADsAcePrivate * This,
    /* [in] */ PSID pSid,
    /* [in] */ DWORD dwLength);


void __RPC_STUB IADsAcePrivate_putSid_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IADsAcePrivate_isSidValid_Proxy( 
    IADsAcePrivate * This,
    /* [out] */ BOOL *pfSidValid);


void __RPC_STUB IADsAcePrivate_isSidValid_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IADsAcePrivate_INTERFACE_DEFINED__ */

#endif /* __ActiveDsP_LIBRARY_DEFINED__ */

/* Additional Prototypes for ALL interfaces */

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\public\internal\ds\inc\keylimit.h ===
/*++

Copyright (C) Microsoft Corporation, 2000

Module Name:

    keylimit

Abstract:

    This header file is tempory.  It should be incorporated into wincrypt.h

Author:

    Doug Barlow (dbarlow) 2/2/2000

Remarks:

    ?Remarks?

Notes:

    ?Notes?

--*/

#ifndef _KEYLIMIT_H_
#define _KEYLIMIT_H_
#ifdef __cplusplus
extern "C" {
#endif


//
// These definitions are private, to be shared between advapi32.dll and
// keylimit.dll.
//

typedef struct {
    ALG_ID algId;
    DWORD  dwMinKeyLength;
    DWORD  dwMaxKeyLength;
    DWORD  dwRequiredFlags;
    DWORD  dwDisallowedFlags;
} KEYLIMIT_LIMITS;

typedef struct {
    DWORD dwCountryValue;
    DWORD dwLanguageValue;
    KEYLIMIT_LIMITS *pLimits;
} KEYLIMIT_LOCALE;

#ifdef __cplusplus
}
#endif
#endif // _KEYLIMIT_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\public\internal\ds\inc\jet.h ===
/***********************************************************************
* Microsoft Jet
*
* Microsoft Confidential.  Copyright 1991-1993 Microsoft Corporation.
*
* Component:
*
* File: jet.h
*
* File Comments:
*
*     Public header file with JET API definition.
*
* Revision History:
*
*    [0]  04-Jan-92  richards	Added this header
*
***********************************************************************/

//
// This __JET500 essentially creates two version of this file in this
// same file. All the jet500 stuff is in __JET500 macro
//
#if __JET500
#include "jet500.h"
//
// End of 500 series jet.h
#else
//
// Original jet.h starts here. i.e jet.h of 200 series db.
//

#if !defined(_JET_INCLUDED)
#define _JET_INCLUDED

#ifdef	__cplusplus
extern "C" {
#endif

#pragma pack(4)

#if defined(_M_ALPHA)				/* 0:32 Flat Model (Alpha AXP) */

#define _far
#define JET_API   __stdcall
#define JET_NODSAPI __stdcall

#elif	defined(M_MRX000)				/* 0:32 Flat Model (MIPS Rx000) */

#define _far
#define JET_API   __stdcall
#define JET_NODSAPI  __stdcall

#else										/*	0:32 flat model (Intel 32-bit ) */

#define _far
#define JET_API     __stdcall		/* CONSIDER: Switch to __stdcall */
#define JET_NODSAPI __stdcall		/* CONSIDER: Switch to __stdcall */

#endif

typedef long JET_ERR;

typedef unsigned long JET_INSTANCE;	/* Instance Identifier */
typedef ULONG_PTR JET_SESID;		/* Session Identifier */
typedef ULONG_PTR JET_TABLEID;	    /* Table Identifier */
typedef unsigned long JET_COLUMNID;	/* Column Identifier */

typedef ULONG_PTR JET_DBID; 		/* Database Identifier */
typedef unsigned long JET_OBJTYP;	/* Object Type */
typedef unsigned long JET_COLTYP;	/* Column Type */
typedef unsigned long JET_GRBIT;		/* Group of Bits */
typedef unsigned long JET_ACM;		/* Access Mask */
typedef unsigned long JET_RNT;		/* Repair Notification Type */

typedef unsigned long JET_SNP;		/* Status Notification Process */
typedef unsigned long JET_SNT;		/* Status Notification Type */
typedef unsigned long JET_SNC;		/* Status Notification Code */

typedef double JET_DATESERIAL;		/* JET_coltypDateTime format */

#if defined(_M_ALPHA)				/* 0:32 Flat Model (Intel 80x86) */

typedef JET_ERR (__stdcall *JET_PFNSTATUS)(JET_SESID sesid, JET_SNP snp, JET_SNT snt, void _far *pv);

#elif	defined(M_MRX000)				/* 0:32 Flat Model (MIPS Rx000) */

typedef JET_ERR (__stdcall *JET_PFNSTATUS)(JET_SESID sesid, JET_SNP snp, JET_SNT snt, void _far *pv);

#else										/*	0:32 flat model (Alpha AXP ) */

typedef JET_ERR (__stdcall *JET_PFNSTATUS)(JET_SESID sesid, JET_SNP snp, JET_SNT snt, void _far *pv);

#endif


	/*	Session information bits */

#define JET_bitCIMCommitted					 	0x00000001
#define JET_bitCIMDirty							 	0x00000002
#define JET_bitAggregateTransaction		  		0x00000008

	/* JetGetLastErrorInfo structure */

typedef struct
	{
	unsigned long	cbStruct;	/* Size of this structure */
	JET_ERR 			err;			/* Extended error code (if any) */
	unsigned long	ul1;			/* First general purpose integer */
	unsigned long	ul2;			/* Second general purpose integer */
	unsigned long	ul3;			/* Third general purpose integer */
	} JET_EXTERR;

	/* Status Notification Structures */

typedef struct				/* Status Notification Progress */
	{
	unsigned long	cbStruct;	/* Size of this structure */
	unsigned long	cunitDone;	/* Number of units of work completed */
	unsigned long	cunitTotal;	/* Total number of units of work */
	} JET_SNPROG;

	/* ErrCount Notification Structures */

typedef struct						/* Status Notification Progress */
	{
	unsigned long	cbStruct;	/* Size of this structure */
	unsigned long	cRecUniqueKeyViolation;
	unsigned long	cRecTypeConversionFail;
	unsigned long	cRecRecordLocked;
	unsigned long	cRecTotal;	/* Total number of units of work */
	} JET_SNERRCNT;


typedef struct				/* Status Notification Message */
	{
	unsigned long	cbStruct;	/* Size of this structure */
	JET_SNC 	snc;					/* Status Notification Code */
	unsigned long	ul;			/* Numeric identifier */
	char		sz[256];				/* Identifier */
	} JET_SNMSG;


typedef struct
	{
	unsigned long	cbStruct;
	JET_OBJTYP	objtyp;
	JET_DATESERIAL	dtCreate;
	JET_DATESERIAL	dtUpdate;
	JET_GRBIT	grbit;
	unsigned long	flags;
	unsigned long	cRecord;
	unsigned long	cPage;
	} JET_OBJECTINFO;
	
typedef struct
	{
	unsigned	int dbid;
	char		szDatabaseName[256];
	char		szNewDatabaseName[256];
	} JET_RSTMAP;			/* restore map */

	/* The following flags appear in the grbit field above */

#define JET_bitTableInfoUpdatable	0x00000001
#define JET_bitTableInfoBookmark	0x00000002
#define JET_bitTableInfoRollback	0x00000004
#define JET_bitTableInfoRestartable	0x00000008
#define JET_bitTableInfoNoInserts	0x00000010

	/* The following flags occur in the flags field above */

#define JET_bitSaveUIDnPWD		0x20000000	/* this bit is only 		 */
											/* appropriate for rmt links */
#define JET_bitObjectExclusive	0x40000000	/* Open link exclusively */
#define JET_bitObjectSystem		0x80000000


typedef struct
	{
	unsigned long	cbStruct;
	JET_TABLEID		tableid;
	unsigned long	cRecord;
	JET_COLUMNID	columnidcontainername;
	JET_COLUMNID	columnidobjectname;
	JET_COLUMNID	columnidobjtyp;
	JET_COLUMNID	columniddtCreate;
	JET_COLUMNID	columniddtUpdate;
	JET_COLUMNID	columnidgrbit;
	JET_COLUMNID	columnidflags;
	JET_COLUMNID	columnidcRecord;	/* Level 2 info */
	JET_COLUMNID	columnidcPage;		/* Level 2 info */
	} JET_OBJECTLIST;

#define cObjectInfoCols 9	       /* CONSIDER: Internal */

typedef struct
	{
	unsigned long	cbStruct;
	JET_TABLEID		tableid;
	unsigned long	cRecord;
	JET_COLUMNID	columnidSid;
	JET_COLUMNID	columnidACM;
	JET_COLUMNID	columnidgrbit; /* grbit from JetSetAccess */
	} JET_OBJECTACMLIST;

#define cObjectAcmCols 3	       /* CONSIDER: Internal */


typedef struct
	{
	unsigned long	cbStruct;
	JET_TABLEID		tableid;
	unsigned long	cRecord;
	JET_COLUMNID	columnidPresentationOrder;
	JET_COLUMNID	columnidcolumnname;
	JET_COLUMNID	columnidcolumnid;
	JET_COLUMNID	columnidcoltyp;
	JET_COLUMNID	columnidCountry;
	JET_COLUMNID	columnidLangid;
	JET_COLUMNID	columnidCp;
	JET_COLUMNID	columnidCollate;
	JET_COLUMNID	columnidcbMax;
	JET_COLUMNID	columnidgrbit;
	JET_COLUMNID	columnidDefault;
	JET_COLUMNID	columnidBaseTableName;
	JET_COLUMNID	columnidBaseColumnName;
	JET_COLUMNID	columnidDefinitionName;
	} JET_COLUMNLIST;

#define cColumnInfoCols 14	       /* CONSIDER: Internal */

typedef struct
	{
	unsigned long	cbStruct;
	JET_COLUMNID	columnid;
	JET_COLTYP	coltyp;
	unsigned short	wCountry;
	unsigned short	langid;
	unsigned short	cp;
	unsigned short	wCollate;       /* Must be 0 */
	unsigned long	cbMax;
	JET_GRBIT	grbit;
	} JET_COLUMNDEF;


typedef struct
	{
	unsigned long	cbStruct;
	JET_COLUMNID	columnid;
	JET_COLTYP	coltyp;
	unsigned short	wCountry;
	unsigned short	langid;
	unsigned short	cp;
	unsigned short	wFiller;       /* Must be 0 */
	unsigned long	cbMax;
	JET_GRBIT	grbit;
	char		szBaseTableName[256];	/* CONSIDER: Too large? */
	char		szBaseColumnName[256];	/* CONSIDER: Too large? */
	} JET_COLUMNBASE;

typedef struct
	{
	unsigned long	cbStruct;
	JET_TABLEID	tableid;
	unsigned long	cRecord;
	JET_COLUMNID	columnidindexname;
	JET_COLUMNID	columnidgrbitIndex;
	JET_COLUMNID	columnidcKey;
	JET_COLUMNID	columnidcEntry;
	JET_COLUMNID	columnidcPage;
	JET_COLUMNID	columnidcColumn;
	JET_COLUMNID	columnidiColumn;
	JET_COLUMNID	columnidcolumnid;
	JET_COLUMNID	columnidcoltyp;
	JET_COLUMNID	columnidCountry;
	JET_COLUMNID	columnidLangid;
	JET_COLUMNID	columnidCp;
	JET_COLUMNID	columnidCollate;
	JET_COLUMNID	columnidgrbitColumn;
	JET_COLUMNID	columnidcolumnname;
	} JET_INDEXLIST;

#define cIndexInfoCols 15	       /* CONSIDER: Internal */

typedef struct
	{
	unsigned long	cbStruct;
	JET_TABLEID	tableid;
	unsigned long	cRecord;
	JET_COLUMNID	columnidReferenceName;
	JET_COLUMNID	columnidgrbit;
	JET_COLUMNID	columnidcColumn;
	JET_COLUMNID	columnidiColumn;
	JET_COLUMNID	columnidReferencingTableName;
	JET_COLUMNID	columnidReferencingColumnName;
	JET_COLUMNID	columnidReferencedTableName;
	JET_COLUMNID	columnidReferencedColumnName;
	} JET_RELATIONSHIPLIST;

/* for backward compatibility */
typedef JET_RELATIONSHIPLIST JET_REFERENCELIST;

#define cReferenceInfoCols 8	       /* CONSIDER: Internal */

typedef struct
	{
	unsigned long	cbStruct;
	unsigned long	ibLongValue;
	unsigned long	itagSequence;
	JET_COLUMNID	columnidNextTagged;
	} JET_RETINFO;

typedef struct
	{
	unsigned long	cbStruct;
	unsigned long	ibLongValue;
	unsigned long	itagSequence;
	} JET_SETINFO;

typedef struct
	{
	unsigned long	cbStruct;
	unsigned long	centriesLT;
	unsigned long	centriesInRange;
	unsigned long	centriesTotal;
	} JET_RECPOS;

typedef struct
	{
	unsigned long	cDiscont;
	unsigned long	cUnfixedMessyPage;
	unsigned long	centriesLT;
	unsigned long	centriesTotal;
	} PERS_OLCSTAT;
	
typedef struct
	{
	unsigned long	cDiscont;
	unsigned long	cUnfixedMessyPage;
	unsigned long	centriesLT;
	unsigned long	centriesTotal;
	unsigned long	cpgCompactFreed;
	} JET_OLCSTAT;

typedef struct
	{
	unsigned long	ctableid;
	JET_TABLEID	rgtableid[1];
	} JET_MGBLIST;

/*** Property Manager Structure ***/
typedef struct
	{
	unsigned long	cbStruct;
	JET_TABLEID 	tableid;
	JET_COLUMNID 	columnidColumnName;
	JET_COLUMNID 	columnidPropertyName;
	JET_COLUMNID	columnidGrbit;
	JET_COLUMNID	columnidPropertyValue;
	JET_COLUMNID	columnidColtyp;
	} JET_PROPERTYLIST;


/************************************************************************/
/*************************     JET CONSTANTS	 ************************/
/************************************************************************/

#define JET_tableidNil			((JET_TABLEID) 	0xFFFFFFFF)

#define	JET_sesidNil			((JET_SESID) 	0xFFFFFFFF)

	/* Max size of a bookmark */

#define JET_cbBookmarkMost		256

	/* Max length of a object/column/index/property name */

#define JET_cbNameMost			64

	/* Max length of a "name.name.name..." construct */

#define JET_cbFullNameMost		255

	/* Max size of non-long-value column data */

#define JET_cbColumnMost		255

	/* Max size of a sort/index key */

#define JET_cbKeyMost			255

	/* Max number of components in a sort/index key */

#define JET_ccolKeyMost			10

	/* Max number of columns in a table/query */

#define JET_ccolTableMost		255

	/* Max Length of a property in the property manager */
#define JET_cbPropertyMost 2048

	/* Largest initial substring of a long value used in an expression */

#define JET_cbExprLVMost		0x8000L	/*** 32 K ***/

	/* Max size of returned (from SQLDriverConnect) conn string */

#define JET_cbConnectMost		255

	/* Max number of levels in an MGB */

#define JET_wGroupLevelMax		12

	/* Size restrictions for Pins */
#define JET_cchPINMax			20
#define JET_cchPINMin			4


	/* System parameter codes for JetSetSystemParameter */

#define JET_paramSysDbPath			0	/* Path to the system database */
#define JET_paramTempPath			1	/* Path to the temporary file directory */
#define JET_paramPfnStatus			2	/* Status callback function */
#define JET_paramPfnError			3	/* Error callback function */
#define JET_paramHwndODBC			4	/* Window handle for ODBC use */
#define JET_paramIniPath			5	/* Path to the ini file */
#define JET_paramPageTimeout		6	/* Red ISAM page timeout value */
#define JET_paramODBCQueryTimeout	7	/* ODBC async query timeout value */
#define JET_paramMaxBuffers			8	/* Bytes to use for page buffers */
#define JET_paramMaxSessions		9	/* Maximum number of sessions */
#define JET_paramMaxOpenTables		10	/* Maximum number of open tables */
#define JET_paramMaxVerPages		11	/* Maximum number of modified pages */
#define JET_paramMaxCursors			12	/* Maximum number of open cursors */
#define JET_paramLogFilePath		13	/* Path to the log file directory */
#define JET_paramMaxOpenTableIndexes 14	/* Maximum open table indexes */
#define JET_paramMaxTemporaryTables	15	/* Maximum concurrent JetCreateIndex */
#define JET_paramLogBuffers			16	/* Maximum log buffers */
#define JET_paramLogFileSectors		17	/* Maximum log sectors per log file */
#define JET_paramLogFlushThreshold	18	/* Log buffer flush threshold */
#define JET_paramBfThrshldLowPrcnt	19	/* Low threshold ( % ) for buffers */
#define JET_paramBfThrshldHighPrcnt	20	/* High threshold ( % ) for buffers */
#define JET_paramWaitLogFlush		21	/* msec for waiting log flush */
#define JET_paramLogFlushPeriod		22	/* msec for waiting log flush */
#define JET_paramLogCheckpointPeriod 23	/* msec for waiting log flush */
#define JET_paramLogWaitingUserMax	24	/* Maximum # user waiting log flush */
#define JET_paramODBCLoginTimeout	25	/* ODBC connection attempt timeout value */
#define JET_paramExprObject			26  /* Expression Evaluation callback */
#define JET_paramGetTypeComp			27	/* Expression Evaluation callback */
#define JET_paramHostVersion			28	/* Host Version callback */
#define JET_paramSQLTraceMode			29	/* Enable/disable SQL tracing */
#define JET_paramRecovery				30	/* Switch for log on/off */
#define JET_paramRestorePath			31	/* Path to restoring directory */
#define JET_paramTransactionLevel	32	/* Transaction level of session */
#define JET_paramSessionInfo			33	/* Session info */
#define JET_paramPageFragment			34	/* Largest page extent considered fragment */
#define JET_paramJetInternal			35	/* Whether internal to JET; if set, allows ISAM to do things which are prevented in general */
#define JET_paramMaxOpenDatabases	36	/*	Maximum number of open databases */
#define JET_paramOnLineCompact		37 /*	Options for compact pages on-line */
#define JET_paramFullQJet		38	/* Allow full QJet functionality */
#define JET_paramRmtXactIsolation	39	/* Do not share connections with other sessions */
#define JET_paramBufLRUKCorrInterval 40
#define JET_paramBufBatchIOMax		41
#define JET_paramPageReadAheadMax	42
#define JET_paramAsynchIOMax		43

#define JET_paramAssertAction		44 /*	debug only determines action on assert */

#define JET_paramEventSource		45	/* NT event log */
#define JET_paramEventId			46	/* NT event id */
#define JET_paramEventCategory		47	/* NT event category */


	/* Flags for JetIdle */

#define JET_bitIdleRemoveReadLocks	0x00000001
#define JET_bitIdleFlushBuffers		0x00000002
#define JET_bitIdleCompact				0x00000004

	/* Flags for JetEndSession */

#define JET_bitForceSessionClosed	0x00000001

	/* Flags for JetOpenDatabase */

#define JET_bitDbReadOnly			0x00000001
#define JET_bitDbExclusive			0x00000002 /* multiple opens allowed */
#define JET_bitDbRemoteSilent		0x00000004
#define JET_bitDbSingleExclusive	0x00000008 /* opened exactly once */

	/* Flags for JetCloseDatabase */

#define JET_bitDbForceClose		0x00000001

	/* Flags for JetCreateDatabase */

#define JET_bitDbEncrypt			0x00000001
#define JET_bitDbVersion10			0x00000002
#define JET_bitDbVersion1x			0x00000004
#define JET_bitDbRecoveryOff 		0x00000008 /* disable logging/recovery */
#define JET_bitDbNoLogging	 		0x00000010 /* no logging */
#define JET_bitDbCompleteConnstr	0x00000020

	/* Flags for JetBackup */

#define JET_bitBackupIncremental		0x00000001
#define JET_bitKeepOldLogs				0x00000002
#define JET_bitOverwriteExisting		0x00000004

	/* Database types */

#define JET_dbidNil			((JET_DBID) 0xFFFFFFFF)
#define JET_dbidNoValid		((JET_DBID) 0xFFFFFFFE) /* used as a flag to indicate that there is no valid dbid */

	/* Flags for JetCreateLink */

/* Can use JET_bitObjectExclusive to cause linked to database to be opened */
/* exclusively.															   */

	/* Flags for JetAddColumn, JetGetColumnInfo, JetOpenTempTable */

#define JET_bitColumnFixed				0x00000001
#define JET_bitColumnTagged			0x00000002
#define JET_bitColumnNotNULL			0x00000004
#define JET_bitColumnVersion			0x00000008
#define JET_bitColumnAutoincrement	0x00000010
#define JET_bitColumnUpdatable		0x00000020 /* JetGetColumnInfo only */
#define JET_bitColumnTTKey				0x00000040 /* JetOpenTempTable only */
#define JET_bitColumnTTDescending	0x00000080 /* JetOpenTempTable only */
#define JET_bitColumnNotLast			0x00000100 /* Installable ISAM option */
#define JET_bitColumnRmtGraphic		0x00000200 /* JetGetColumnInfo */
#define JET_bitColumnMultiValued		0x00000400

	/* Flags for JetMakeKey */

#define JET_bitNewKey				0x00000001
#define JET_bitStrLimit 			0x00000002
#define JET_bitSubStrLimit			0x00000004
#define JET_bitNormalizedKey 		0x00000008
#define JET_bitKeyDataZeroLength	0x00000010

#ifdef DBCS /* johnta: LIKE "ABC" not converted to ="ABC" for Japanese */
#define JET_bitLikeExtra1			0x00000020
#endif /* DBCS */

	/* Flags for ErrDispSetIndexRange */

#define JET_bitRangeInclusive		0x00000001    /* CONSIDER: Internal */
#define JET_bitRangeUpperLimit		0x00000002    /* CONSIDER: Internal */

	/* Constants for JetMove */

#define JET_MoveFirst			(0x80000000)
#define JET_MovePrevious		(-1)
#define JET_MoveNext				(+1)
#define JET_MoveLast				(0x7fffffff)

	/* Flags for JetMove */

#define JET_bitMoveKeyNE		0x00000001
#define JET_bitMoveCheckTS		0x00000002
#define JET_bitMoveInPage		0x00000004

	/* Flags for JetSeek */

#define JET_bitSeekEQ			0x00000001
#define JET_bitSeekLT			0x00000002
#define JET_bitSeekLE			0x00000004
#define JET_bitSeekGE			0x00000008
#define JET_bitSeekGT		 	0x00000010
#define JET_bitSetIndexRange	0x00000020

	/* Flags for JetFastFind */

#define JET_bitFFindBackwards		0x00000001
#define JET_bitFFindFromCursor		0x00000004

	/* Flags for JetCreateIndex */

#define JET_bitIndexUnique		0x00000001
#define JET_bitIndexPrimary		0x00000002
#define JET_bitIndexDisallowNull	0x00000004
#define JET_bitIndexIgnoreNull		0x00000008
#define JET_bitIndexClustered		0x00000010
#define JET_bitIndexIgnoreAnyNull	0x00000020
#define JET_bitIndexReference		0x80000000    /* IndexInfo only */

	/* Flags for index key definition */

#define JET_bitKeyAscending		0x00000000
#define JET_bitKeyDescending		0x00000001


	/* Flags for JetCreateRelationship */

#define JET_bitRelationUnique			0x00000001
#define JET_bitRelationDontEnforce		0x00000002
#define JET_bitRelationInherited		0x00000004
#define JET_bitRelationTestLegal		0x00000008	/* don't create relationship */

#define JET_bitRelationshipMatchMask	0x000000F0
#define JET_bitRelationMatchDefault		0x00000000
#define JET_bitRelationMatchFull		0x00000010

#define JET_bitRelationUpdateActionMask	0x00000F00
#define JET_bitRelationUpdateDisallow	0x00000000
#define JET_bitRelationUpdateCascade	0x00000100
#define JET_bitRelationUpdateSetNull	0x00000200
#define JET_bitRelationUpdateSetDefault	0x00000300

#define JET_bitRelationDeleteActionMask	0x0000F000
#define JET_bitRelationDeleteDisallow	0x00000000
#define JET_bitRelationDeleteCascade	0x00001000
#define JET_bitRelationDeleteSetNull	0x00002000
#define JET_bitRelationDeleteSetDefault	0x00003000

#define JET_bitRelationUserMask			0xFF000000	/* non-enforced values */
#define JET_bitRelationJoinMask			0x03000000
#define JET_bitRelationInner			0x00000000
#define JET_bitRelationLeft				0x01000000
#define JET_bitRelationRight			0x02000000


	/* Flags for JetCreateReference/JetCreateRelationship */
	/* NOTE: use the bitRelationship flags instead! */

#define JET_ReferenceUnique				JET_bitRelationUnique
#define JET_ReferenceDontEnforce		JET_bitRelationDontEnforce
#define JET_ReferenceMatchTypeMask		JET_bitRelationMatchMask
#define JET_ReferenceMatchDefault		JET_bitRelationMatchDefault
#define JET_ReferenceMatchFull			JET_bitRelationMatchFull
#define JET_ReferenceUpdateActionMask	JET_bitRelationUpdateActionMask
#define JET_ReferenceUpdateDisallow		JET_bitRelationUpdateDisallow
#define JET_ReferenceUpdateCascade		JET_bitRelationUpdateCascade
#define JET_ReferenceUpdateSetNull		JET_bitRelationUpdateSetNull
#define JET_ReferenceUpdateSetDefault	JET_bitRelationUpdateSetDefault
#define JET_ReferenceDeleteActionMask	JET_bitRelationDeleteActionMask
#define JET_ReferenceDeleteDisallow		JET_bitRelationDeleteDisallow
#define JET_ReferenceDeleteCascade		JET_bitRelationDeleteCascade
#define JET_ReferenceDeleteSetNull		JET_bitRelationDeleteSetNull
#define JET_ReferenceDeleteSetDefault	JET_bitRelationDeleteSetDefault


	/* Flags for JetOpenTable */

#define JET_bitTableDenyWrite		0x00000001
#define JET_bitTableDenyRead		0x00000002
#define JET_bitTableReadOnly		0x00000004
#define JET_bitTableAppendOnly		0x00000008
#define JET_bitTableUpdatable		0x00000010
#define JET_bitTableScrollable		0x00000020
#define JET_bitTableFixedSet		0x00000040	/* Fixed working set */
#define JET_bitTableInconsistent	0x00000080
#define JET_bitTableBulk			0x00000100
#define JET_bitTableUsePrimaryIndex	0x00000200	/* Use with FixedSet */
#define JET_bitTableSampleData		0x00000400
#define JET_bitTableQuickBrowse		0x00000800	/* Bias optimizer toward index usage */
#define JET_bitTableDDL				0x00001000	/* similar to JET_bitTableBulk, for DDL */
#define JET_bitTablePassThrough		0x00002000  /* Remote DBs Only */
#define JET_bitTableRowReturning	0x00004000

	/* Flags for JetSetQoSql/JetRetrieveQoSql */
#define JET_bitSqlPassThrough		0x00000001	/* Pass through Query returning records */
#define JET_bitSqlSPTBulkOp			0x00000002  /* SPT query returning no table */
	
	/* Flags for JetOpenVtQbe */

#define JET_bitQBEAddBrackets		0x00000001
#define JET_bitQBERemoveEquals		0x00000002

	/* Flags for JetOpenTempTable and ErrIsamOpenTempTable */

#define JET_bitTTIndexed		0x00000001	/* Allow seek */
#define JET_bitTTUnique 		0x00000002	/* Remove duplicates */
#define JET_bitTTUpdatable		0x00000004	/* Allow updates */
#define JET_bitTTScrollable		0x00000008	/* Allow backwards scrolling */

	/* Flags for JetSetColumn */

#define JET_bitSetAppendLV			0x00000001
#define JET_bitSetValidate			0x00000002
#define JET_bitSetOverwriteLV		0x00000004
#define JET_bitSetSizeLV			0x00000008
#define JET_bitSetValidateColumn	0x00000010
#define JET_bitSetZeroLength		0x00000020

	/*	Set column parameter structure for JetSetColumns */

typedef struct {
	JET_COLUMNID			columnid;
	const void _far 		*pvData;
	unsigned long 			cbData;
	JET_GRBIT				grbit;
	unsigned long			ibLongValue;
	unsigned long			itagSequence;
	JET_ERR					err;
} JET_SETCOLUMN;

	/* Options for JetPrepareUpdate */

#define JET_prepInsert			0
#define JET_prepInsertBeforeCurrent	1
#define JET_prepReplace 		2
#define JET_prepCancel			3
#define JET_prepReplaceNoLock		4
#define JET_prepInsertCopy			5

	/* Flags for JetRetrieveColumn */

#define JET_bitRetrieveCopy			0x00000001
#define JET_bitRetrieveFromIndex		0x00000002
#define JET_bitRetrieveCase			0x00000004
#define JET_bitRetrieveTag				0x00000008
#define JET_bitRetrieveRecord			0x80000000
#define JET_bitRetrieveFDB				0x40000000
#define JET_bitRetrieveBookmarks		0x20000000

	/* Retrieve column parameter structure for JetRetrieveColumns */

typedef struct {
	JET_COLUMNID		columnid;
	void _far 			*pvData;
	unsigned long 		cbData;
	unsigned long 		cbActual;
	JET_GRBIT			grbit;
	unsigned long		ibLongValue;
	unsigned long		itagSequence;
	JET_COLUMNID		columnidNextTagged;
	JET_ERR				err;
} JET_RETRIEVECOLUMN;

	/* Flags for JetFillFatCursor */

#define JET_bitFCFillRange		0x00000001
#define JET_bitFCRefreshRange		0x00000002
#define JET_bitFCFillMemos		0x00000004

	/* Flags for JetCommitTransaction */

#define JET_bitCommitFlush		0x00000001

	/* Flags for JetRollback */

#define JET_bitRollbackAll		0x00000001

	/* Flags for JetSetAccess and JetGetAccess */

#define JET_bitACEInheritable		0x00000001

	/* Flags for JetCreateSystemDatabase */

#define JET_bitSysDbOverwrite	0x00000001

	/* Flags for Jet Property Management */
#define JET_bitPropDDL				0x00000001		/* also used for setting */
#define JET_bitPropInherited		0x00000002		/* not used for setting */

	/* JPM Flags that are only used for setting properties */
#define JET_bitPropReplaceOnly		0x00000010
#define JET_bitPropInsertOnly		0x00000020
#define JET_bitPropDeleteOnly		0x00000040
	
	/* InfoLevels for Jet Property Management */
#define JET_PropertyValue				0
#define JET_PropertyCount				1
#define JET_PropertySingleCollection 	2
#define JET_PropertyAllCollections		3

	/* Collate values for JetGetColumnInfo and JetGetIndexInfo */

#define JET_sortBinary			0x0000
#define JET_sortEFGPI			0x0100
#define JET_sortSNIFD			0x0101
#define JET_sortSpanish 		0x0102
#define JET_sortDutch			0x0103
#define JET_sortSweFin			0x0104
#define JET_sortNorDan			0x0105
#define JET_sortIcelandic		0x0106
#define JET_sortCyrillic		0x0107
#define JET_sortCzech			0x0108
#define JET_sortHungarian		0x0109
#define JET_sortPolish			0x010A
#define JET_sortArabic			0x010B
#define JET_sortHebrew			0x010C
#define JET_sortMax				0x010C		/* Max for nonDBCS sort orders */

#ifdef DBCS	/* johnta: Add the new Japanese sorting order */
#define JET_sortJapanese		0x010D
#endif /* DBCS */

#define JET_sortUnknown 		0xFFFF

	/* Paradox ISAM specific collate values */

#define JET_sortPdxIntl 		0x1000
#define JET_sortPdxSwedFin		0x1001
#define JET_sortPdxNorDan		0x1002

	/* Info parameter for JetGetDatabaseInfo */

#define JET_DbInfoFilename		0
#define JET_DbInfoConnect		1
#define JET_DbInfoCountry		2
#define JET_DbInfoLangid		3
#define JET_DbInfoCp			4
#define JET_DbInfoCollate		5
#define JET_DbInfoOptions		6
#define JET_DbInfoTransactions	7
#define JET_DbInfoVersion		8
#define JET_DbInfoIsam			9

	/* Database versions returned by JetGetDatabaseInfo */

#define JET_DbVersion10			0x00010000
#define JET_DbVersion11			0x00010001
#define JET_DbVersion20			0x00020000


	/* Isam specific info returned by JetGetDatabaseInfo */

#define JET_IsamInvalid			0
#define JET_IsamBuiltinRed		1
#define JET_IsamBuiltinBlue		2

#define	JET_IsamInstRed			21
#define JET_IsamInstBlue		22
#define	JET_IsamInstFox			23
#define JET_IsamInstParadox		24
#define JET_IsamInstDbase		25
#define	JET_IsamInstBtrieve		26

#define JET_IsamBuilinMost		JET_BuiltinBlue
#define JET_IsamInstMin			JET_IsamInstRed
#define	JET_IsamInstMost		JET_IsamInstBtrieve

	/* Link specific info for link identification */
#define JET_bitLinkInvalid		0x00000000
#define JET_bitLinkRemote		0x00100000
#define JET_bitLinkBuiltinRed	0x00200000
#define JET_bitLinkBuiltinBlue	0x00300000
#define JET_bitLinkInstRed		0x00400000
#define JET_bitLinkInstBlue		0x00500000
#define JET_bitLinkInstFox		0x00600000
#define JET_bitLinkInstParadox	0x00700000
#define JET_bitLinkInstDbase	0x00800000
#define JET_bitLinkInstBtrieve	0x00900000

#define JET_bitFourByteBookmark		0x00000001
#define	JET_bitContiguousBookmarks	0x00000002

	/* Column data types */

	/* the column types are represented with 4 bits */
	/* make sure the choices below fit!				*/
	/* NOTE:  all comb of the 4 bits are now used! */
	/* CONSIDER:  to allow more datatypes, either 				 */
	/* CONSIDER:  JET_coltypDatabase and JET_coltypTableid	must */
	/* CONSIDER:  change or the 4 bit dependancy must be removed */

#define JET_coltypNil				0
#define JET_coltypBit				1      /* True or False, Never NULL */
#define JET_coltypUnsignedByte		2      /* 1-byte integer, unsigned */
#define JET_coltypShort 			3      /* 2-byte integer, signed */
#define JET_coltypLong				4      /* 4-byte integer, signed */
#define JET_coltypCurrency			5      /* 8 byte integer, signed */
#define JET_coltypIEEESingle		6      /* 4-byte IEEE single precision */
#define JET_coltypIEEEDouble		7      /* 8-byte IEEE double precision */
#define JET_coltypDateTime			8      /* Integral date, fractional time */
#define JET_coltypBinary			9      /* Binary data, < 255 bytes */
#define JET_coltypText				10     /* ANSI text, case insensitive, < 255 bytes */
#define JET_coltypLongBinary		11     /* Binary data, long value */
#define JET_coltypLongText			12     /* ANSI text, long value */

	/* The following are additional types used for query parameters */
	/* NOTE:  Code depends on these being contiguous with the normal coltyps */
	/* CONSIDER:  Remove the above dependency on contiguous coltyps in QJET */

#define JET_coltypDatabase			13		/* Database name parameter */
#define JET_coltypTableid			14		/* Tableid parameter */

#define JET_coltypOLE				15		/* OLE blob */

#define JET_coltypMax				16		/* the number of column types  */
											/* used for validity tests and */
											/* array declarations.		   */

	/* Info levels for JetGetObjectInfo */

#define JET_ObjInfo					0U
#define JET_ObjInfoListNoStats		1U
#define JET_ObjInfoList 			2U
#define JET_ObjInfoSysTabCursor 	3U
#define JET_ObjInfoListACM			4U /* Blocked by JetGetObjectInfo */
#define JET_ObjInfoNoStats			5U
#define JET_ObjInfoSysTabReadOnly	6U
#define JET_ObjInfoRulesLoaded		7U
#define JET_ObjInfoMax				8U

	/* Info levels for JetGetTableInfo */

#define JET_TblInfo				0U
#define JET_TblInfoName			1U
#define JET_TblInfoDbid			2U
#define JET_TblInfoMostMany  	3U
#define JET_TblInfoRvt			4U
#define JET_TblInfoOLC			5U
#define JET_TblInfoResetOLC 	6U
#define JET_TblInfoSpaceUsage	7U
#define JET_TblInfoDumpTable	8U

	/* Info levels for JetGetIndexInfo and JetGetTableIndexInfo */

#define JET_IdxInfo					0U
#define JET_IdxInfoList 			1U
#define JET_IdxInfoSysTabCursor 	2U
#define JET_IdxInfoOLC				3U
#define JET_IdxInfoResetOLC			4U

	/* Info levels for JetGetReferenceInfo and JetGetTableReferenceInfo */

#define JET_ReferenceInfo		0U
#define JET_ReferenceInfoReferencing	1U
#define JET_ReferenceInfoReferenced	2U
#define JET_ReferenceInfoAll		3U
#define JET_ReferenceInfoCursor 	4U

	/* Info levels for JetGetColumnInfo and JetGetTableColumnInfo */

#define JET_ColInfo			0U
#define JET_ColInfoList 		1U

	/* CONSIDER: Info level 2 is valid */

#define JET_ColInfoSysTabCursor 	3U
#define JET_ColInfoBase 		4U


	/* Attribute types for query definitions */

#define JET_qoaBeginDef 		0
#define JET_qoaOperation		1
#define JET_qoaParameter		2
#define JET_qoaOptions			3
#define JET_qoaDatabase 		4
#define JET_qoaInputTable		5
#define JET_qoaOutput			6
#define JET_qoaJoin			7
#define JET_qoaRestriction		8
#define JET_qoaGroup			9
#define JET_qoaGroupRstr		10
#define JET_qoaOrdering 		11
#define JET_qoaEndDef			255
#define JET_qoaValidLeast		JET_qoaOperation
#define JET_qoaValidMost		JET_qoaOrdering


	/* Query object options */

#define JET_bitFqoOutputAllCols 	0x0001
#define JET_bitFqoRemoveDups		0x0002
#define JET_bitFqoOwnerAccess		0x0004
#define JET_bitFqoDistinctRow		0x0008
#define JET_bitFqoTop				0x0010
#define JET_bitFqoPercent			0x0020
#define JET_bitFqoCorresponding		0x0040 /* JET_qopSetOperation */

	/* Query object join type */

#define JET_fjoinInner			1
#define JET_fjoinLeftOuter		2
#define JET_fjoinRightOuter		3

	/* Query object operations */

#define JET_qopSelect			1
#define JET_qopSelectInto		2
#define JET_qopInsertSelection	3
#define JET_qopUpdate			4
#define JET_qopDelete			5
#define JET_qopTransform		6
#define JET_qopDDL				7
#define JET_qopSqlPassThrough	8
#define JET_qopSetOperation		9
#define JET_qopSPTBulk			10

#define JET_bitqopSelect			0x0000
#define JET_bitqopTransform			0x0010
#define JET_bitqopDelete			0x0020
#define JET_bitqopUpdate			0x0030
#define JET_bitqopInsertSelection	0x0040
#define JET_bitqopSelectInto		0x0050
#define JET_bitqopDDL				0x0060
#define JET_bitqopSqlPassThrough	0x0070
#define JET_bitqopSetOperation		0x0080
#define JET_bitqopSPTBulk			0x0090

	/* Engine Object Types */

#define JET_objtypNil			0
#define JET_objtypTable 		1
#define JET_objtypDb			2
#define JET_objtypContainer		3
#define JET_objtypSQLLink		4
#define JET_objtypQuery 		5
#define JET_objtypLink			6
#define JET_objtypTemplate		7
#define JET_objtypRelationship		8

	/* All types less than JET_objtypClientMin are reserved by JET */

#define JET_objtypClientMin		0x8000

	/* Security Constant Values */

#define JET_cchUserNameMax		20
#define JET_cchPasswordMax		14

	/* Security Access Masks */

#define JET_acmNoAccess 		0x00000000L
#define JET_acmFullAccess		0x000FFFFFL

#define JET_acmSpecificMask		0x0000FFFFL
#define JET_acmSpecific_1		0x00000001L
#define JET_acmSpecific_2		0x00000002L
#define JET_acmSpecific_3		0x00000004L
#define JET_acmSpecific_4		0x00000008L
#define JET_acmSpecific_5		0x00000010L
#define JET_acmSpecific_6		0x00000020L
#define JET_acmSpecific_7		0x00000040L
#define JET_acmSpecific_8		0x00000080L
#define JET_acmSpecific_9		0x00000100L
#define JET_acmSpecific_10		0x00000200L
#define JET_acmSpecific_11		0x00000400L
#define JET_acmSpecific_12		0x00000800L
#define JET_acmSpecific_13		0x00001000L
#define JET_acmSpecific_14		0x00002000L
#define JET_acmSpecific_15		0x00004000L
#define JET_acmSpecific_16		0x00008000L

#define JET_acmStandardMask		0x00FF0000L
#define JET_acmDelete			0x00010000L
#define JET_acmReadControl		0x00020000L
#define JET_acmWriteDac 		0x00040000L
#define JET_acmWriteOwner		0x00080000L

#define JET_acmTblCreate		(JET_acmSpecific_1)
#define JET_acmTblAccessRcols		(JET_acmSpecific_2)
#define JET_acmTblReadDef		(JET_acmSpecific_3)
#define JET_acmTblWriteDef		(JET_acmSpecific_4)
#define JET_acmTblRetrieveData		(JET_acmSpecific_5)
#define JET_acmTblInsertData		(JET_acmSpecific_6)
#define JET_acmTblReplaceData		(JET_acmSpecific_7)
#define JET_acmTblDeleteData		(JET_acmSpecific_8)

#define JET_acmDbCreate 		(JET_acmSpecific_1)
#define JET_acmDbOpen			(JET_acmSpecific_2)

	/* Compact Options */

#define JET_bitCompactEncrypt		0x00000001	/* Dest is encrypted */
#define JET_bitCompactDecrypt		0x00000002	/* Dest is not encrypted */
#define JET_bitCompactDontCopyLocale	0x00000004	/* Don't copy locale from source to dest */
#define JET_bitCompactVersion10		0x00000008	/* Destination is version 1.0 format */
#define JET_bitCompactVersion1x		0x00000010	/* Destination is version 1.x format */

	/* On-line Compact Options */

#define JET_bitCompactOn	 		0x00000001	/* enable on-line compaction */

	/* Repair Notification Types */

#define JET_rntSelfContained		0	/* CONSIDER: These are SNCs */
#define JET_rntDeletedIndex		1
#define JET_rntDeletedRec		2
#define JET_rntDeletedLv		3
#define JET_rntTruncated		4

	/* Status Notification Processes */

#define JET_snpIndex			0
#define JET_snpQuery			1
#define JET_snpRepair			2
#define JET_snpImex				3
#define JET_snpCompact			4
#define JET_snpFastFind 		5
#define JET_snpODBCNotReady		6
#define JET_snpQuerySort		7
#define JET_snpRestore			8

	/* Status Notification Types */

#define JET_sntProgress 		0	/* callback for progress */
#define JET_sntMessage			1
#define JET_sntBulkRecords		2	/* callback for # rec for bulk op */
#define JET_sntFail				3	/* callback for failure during progress */
#define JET_sntErrCount 		4	/* callback for err count */
#define JET_sntBegin			5	/* callback for beginning of operation */
#define JET_sntComplete 		6	/* callback for completion of operation */
#define JET_sntCantRollback		7	/* callback for no rollback */
#define JET_sntRestoreMap		8	/* callback for restore map */

	/* Message codes for JET_snpCompact */

#define JET_sncCopyObject		0	/* Starting to copy object */
#define JET_sncCopyFailed		1	/* Copy of this object failed */
#define JET_sncYield			2	/* Client can yield/check for user interrupt */
#define JET_sncTransactionFull		3	/* Client can yield/check for user interrupt */
#define JET_sncAboutToWrap		4	/* Find find is about to wrap */

	/* Message codes for JET_snpODBCNotReady */
#define JET_sncODBCNotReady		0	/* Waiting for results from ODBC */


	/* Constants for the [ODBC] section of JET.INI */

#define JET_SQLTraceCanonical	0x0001	/* Output ODBC Generic SQL */

	/* Constants for the [Debug] section of JET.INI */

	/* APITrace */

#define JET_APITraceEnter	0x0001
#define JET_APITraceExit	0x0002
#define JET_APITraceExitError	0x0004
#define JET_APIBreakOnError	0x0008
#define JET_APITraceCount	0x0010
#define JET_APITraceNoIdle	0x0020
#define JET_APITraceParameters	0x0040

	/* IdleTrace */

#define JET_IdleTraceCursor	0x0001
#define JET_IdleTraceBuffer	0x0002
#define JET_IdleTraceFlush	0x0004

	/* AssertAction */

#define JET_AssertExit		0x0000		/* Exit the application */
#define JET_AssertBreak 	0x0001		/* Break to debugger */
#define JET_AssertMsgBox	0x0002		/* Display message box */
#define JET_AssertStop		0x0004		/* Alert and stop */

	/* IOTrace */

#define JET_IOTraceAlloc	0x0001		/* DB Page Allocation */
#define JET_IOTraceFree 	0x0002		/* DB Page Free */
#define JET_IOTraceRead 	0x0004		/* DB Page Read */
#define JET_IOTraceWrite	0x0008		/* DB Page Write */
#define JET_IOTraceError	0x0010		/* DB Page I/O Error */

	/* MemTrace */

#define JET_MemTraceAlloc	0x0001		/* Memory allocation */
#define JET_MemTraceRealloc	0x0002		/* Memory reallocation */
#define JET_MemTraceFree	0x0004		/* Memory free */

	/* RmtTrace */

#define JET_RmtTraceError	0x0001	/* Remote server error message */
#define JET_RmtTraceSql		0x0002	/* Remote SQL Prepares & Exec's */
#define JET_RmtTraceAPI		0x0004	/* Remote ODBC API calls */
#define JET_RmtTraceODBC	0x0008
#define JET_RmtSyncODBC		0x0010	/* Turn on ODBC Sync mode */

/**********************************************************************/
/***********************     ERROR CODES     **************************/
/**********************************************************************/

/* SUCCESS */

#define JET_errSuccess			 0    /* Successful Operation */

/* ERRORS */

#define JET_wrnNyi							-1    /* Function Not Yet Implemented */

/*	SYSTEM errors
/**/
#define JET_errRfsFailure			   		-100	/* JET_errRfsFailure */
#define JET_errRfsNotArmed					-101	/* JET_errRfsFailure */
#define JET_errFileClose					-102	/* Could not close DOS file */
#define JET_errNoMoreThreads				-103	/* Could not start thread */
#define JET_errNoComputerName	  			-104	/* fail to get computername */
#define JET_errTooManyIO		  			-105	/* System busy due to too many IOs */

/*	BUFFER MANAGER errors
/**/
#define wrnBFNotSynchronous					200			/* Buffer page evicted */
#define wrnBFPageNotFound		  			201			/* Page not found */
#define errBFInUse				  			-202		/* Cannot abandon buffer */

/*	DIRECTORY MANAGER errors
/**/
#define errPMOutOfPageSpace					-300		/* Out of page space */
#define errPMItagTooBig 		  			-301		/* Itag too big */
#define errPMRecDeleted 		  			-302		/* Record deleted */
#define errPMTagsUsedUp 		  			-303		/* Tags used up */
#define wrnBMConflict			  			304     	/* conflict in BM Clean up */
#define errDIRNoShortCircuit	  			-305		/* No Short Circuit Avail */
#define errDIRCannotSplit		  			-306		/* Cannot horizontally split FDP */
#define errDIRTop				  			-307		/* Cannot go up */
#define errDIRFDP							308			/* On an FDP Node */
#define errDIRNotSynchronous				-309		/* May have left critical section */
#define wrnDIREmptyPage						310			/* Moved through empty page */
#define errSPConflict						-311		/* Device extent being extended */
#define wrnNDFoundLess						312			/* Found Less */
#define wrnNDFoundGreater					313			/* Found Greater */
#define errNDOutSonRange					-314		/* Son out of range */
#define errNDOutItemRange					-315		/* Item out of range */
#define errNDGreaterThanAllItems 			-316		/* Greater than all items */
#define errNDLastItemNode					-317		/* Last node of item list */
#define errNDFirstItemNode					-318		/* First node of item list */
#define wrnNDDuplicateItem					319			/* Duplicated Item */
#define errNDNoItem							-320		/* Item not there */
#define JET_wrnRemainingVersions 			321			/* Some versions couldn't be cleaned */
#define JET_wrnPreviousVersion				322			/* Version already existed */
#define JET_errPageBoundary					-323		/* Reached Page Boundary */
#define JET_errKeyBoundary		  			-324		/* Reached Key Boundary */
#define errDIRInPageFather  				-325		/* sridFather in page to free

/*	RECORD MANAGER errors
/**/
#define wrnFLDKeyTooBig 					400			/* Key too big (truncated it) */
#define errFLDTooManySegments				-401		/* Too many key segments */
#define wrnFLDNullKey						402			/* Key is entirely NULL */
#define wrnFLDOutOfKeys 					403			/* No more keys to extract */
#define wrnFLDNullSeg						404			/* Null segment in key */
#define wrnRECLongField 					405			/* Separated long field */
#define JET_wrnRecordFoundGreater			JET_wrnSeekNotEqual
#define JET_wrnRecordFoundLess    			JET_wrnSeekNotEqual
#define JET_errColumnIllegalNull  			JET_errNullInvalid

/*	LOGGING/RECOVERY errors
/**/
#define JET_errRestoreFailed   				-500		/* Restore failed */
#define JET_errLogFileCorrupt		  		-501		/* Log file is corrupt */
#define errLGNoMoreRecords					-502		/* Last log record read */
#define JET_errNoBackupDirectory 			-503		/* No backup directory given */
#define JET_errBackupDirectoryNotEmpty 		-504		/* The backup directory is not emtpy */
#define JET_errBackupInProgress 			-505		/* Backup is active already */
#define JET_errFailRestoreDatabase 			-506		/* Fail to restore (copy) database */
#define JET_errNoDatabasesForRestore 		-507		/* No databases for restor found */
#define JET_errMissingLogFile	   			-508		/* jet.log for restore is missing */
#define JET_errMissingPreviousLogFile		-509		/* Missing the log file for check point */
#define JET_errLogWriteFail					-510		/* Fail when writing to log file */
#define JET_errLogNotContigous	 			-511		/* Fail to incremental backup for non-contiguous generation number */
#define JET_errFailToMakeTempDirectory		-512		/* Fail to make a temp directory */
#define JET_errFailToCleanTempDirectory		-513		/* Fail to clean up temp directory */
#define JET_errBadLogVersion  	  			-514		/* Version of log file is not compatible with Jet version */
#define JET_errBadNextLogVersion   			-515		/* Version of next log file is not compatible with current one */
#define JET_errLoggingDisabled 				-516		/* Log is not active */
#define JET_errLogBufferTooSmall			-517		/* Log buffer is too small for recovery */
#define errLGNotSynchronous					-518		/* retry to LGLogRec */

#define JET_errFeatureNotAvailable	-1001 /* API not supported */
#define JET_errInvalidName		-1002 /* Invalid name */
#define JET_errInvalidParameter 	-1003 /* Invalid API parameter */
#define JET_wrnColumnNull		 1004 /* Column is NULL-valued */
#define JET_errReferenceNotFound	-1005 /* No such reference */
#define JET_wrnBufferTruncated		 1006 /* Buf too short, data truncated */
#define JET_wrnDatabaseAttached 	 1007 /* Database is already attached */
#define JET_wrnOnEndPoint		 1008 /* On end point */
#define JET_wrnSortOverflow		 1009 /* Sort does not fit in memory */
#define JET_errInvalidDatabaseId	-1010 /* Invalid database id */
#define JET_errOutOfMemory		-1011 /* Out of Memory */
#define JET_errCantAllocatePage 	-1012 /* Couldn't allocate a page */
#define JET_errNoMoreCursors		-1013 /* Max # of cursors allocated */
#define JET_errOutOfBuffers		-1014 /* JET_errOutOfBuffers */
#define JET_errTooManyIndexes		-1015 /* Too many indexes */
#define JET_errTooManyKeys		-1016 /* Too many columns in an index */
#define JET_errRecordDeleted		-1017 /* Record has been deleted */
#define JET_errReadVerifyFailure	-1018 /* Read verification error */
#define JET_errFilesysVersion		-1019 /* Obsolete database format */
#define JET_errNoMoreFiles		-1020 /* No more file handles */
#define JET_errDiskNotReady		-1021 /* Disk not ready */
#define JET_errDiskIO			-1022 /* JET_errDiskIO */
#define JET_errInvalidPath		-1023 /* JET_errInvalidPath */
#define JET_errFileShareViolation	-1024 /* JET_errFileShareViolation */
#define JET_errFileLockViolation	-1025 /* JET_errFileLockViolation */
#define JET_errRecordTooBig		-1026 /* JET_errRecordTooBig */
#define JET_errTooManyOpenDatabases	-1027 /* Database limit reached */
#define JET_errInvalidDatabase		-1028 /* This isn't a database */
#define JET_errNotInitialized		-1029 /* JetInit not yet called */
#define JET_errAlreadyInitialized	-1030 /* JetInit already called */
#define JET_errFileLockingUnavailable	-1031 /* JET_errFileLockingUnavailable */
#define JET_errFileAccessDenied 	-1032 /* JET_errFileAccessDenied */
#define JET_errSharingBufferExceeded	-1033 /* OS sharing buffer exceeded */
#define JET_errQueryNotSupported	-1034 /* Query support unavailable */
#define JET_errSQLLinkNotSupported	-1035 /* SQL Link support unavailable */
#define JET_errTaskLimitExceeded	-1036 /* Too many client tasks */
#define JET_errUnsupportedOSVersion	-1037 /* Unsupported OS version */
#define JET_errBufferTooSmall		-1038 /* Buffer is too small */
#define JET_wrnSeekNotEqual		 1039 /* SeekLE or SeekGE didn't find exact match */
#define JET_errTooManyColumns		-1040 /* Too many columns defined */
#define JET_errTooManyFixedColumns	-1041 /* Too many fixed columns defined */
#define JET_errTooManyVariableColumns	-1042 /* Too many variable columns defined */
#define JET_errContainerNotEmpty	-1043 /* Container is not empty */
#define JET_errInvalidFilename		-1044 /* Filename is invalid */
#define JET_errInvalidBookmark		-1045 /* Invalid bookmark */
#define JET_errColumnInUse		-1046 /* Column used in an index */
#define JET_errInvalidBufferSize	-1047 /* Data buffer doesn't match column size */
#define JET_errColumnNotUpdatable	-1048 /* Can't set column value */
#define JET_wrnCommitNotFlushed 	 1049 /* Commit did not flush to disk */
#define JET_errAbortSalvage		-1050 /* Forced Salvager abort */
#define JET_errIndexInUse		-1051 /* Index is in use */
#define JET_errLinkNotSupported 	-1052 /* Link support unavailable */
#define JET_errNullKeyDisallowed	-1053 /* Null keys are disallowed on index */
#define JET_errNotInTransaction 	-1054 /* JET_errNotInTransaction */
#define JET_wrnNoErrorInfo		 1055 /* No extended error information */
#define JET_errInstallableIsamNotFound	-1056 /* Installable ISAM not found */
#define JET_errOperationCancelled	-1057 /* Operation canceled by client */
#define JET_wrnNoIdleActivity		 1058 /* No idle activity occured */
#define JET_errTooManyActiveUsers	-1059 /* Too many active database users */
#define JET_errInvalidAppend		-1060 /* Cannot append long value */
#define JET_errInvalidCountry		-1061 /* Invalid or unknown country code */
#define JET_errInvalidLanguageId	-1062 /* Invalid or unknown language id */
#define JET_errInvalidCodePage		-1063 /* Invalid or unknown code page */
#define JET_errCantBuildKey		-1064 /* Can't build key for this sort order. */
#define JET_errIllegalReentrancy	-1065 /* Re-entrancy on same cursor family */
#define JET_errIllegalRelationship	-1066 /* Can't create relationship */
#define JET_wrnNoWriteLock					1067	/* No write lock at transaction level 0 */
#define JET_errDBVerFeatureNotAvailable	-1067 /* API not supported using old database format*/

#define JET_errCantBegin		-1101 /* Cannot BeginSession */
#define JET_errWriteConflict		-1102 /* Write lock failed due to outstanding write lock */
#define JET_errTransTooDeep		-1103 /* Xactions nested too deeply */
#define JET_errInvalidSesid		-1104 /* Invalid session handle */
#define JET_errReadConflict		-1105 /* Commit lock failed due to outstanding read lock */
#define JET_errCommitConflict		-1106 /* Read lock failed due to outstanding commit lock */
#define JET_errSessionWriteConflict	-1107 /* Another session has private version of page */
#define JET_errInTransaction		-1108 /* Operation not allowed within a transaction */

#define JET_errDatabaseDuplicate	-1201 /* Database already exists */
#define JET_errDatabaseInUse		-1202 /* Database in use */
#define JET_errDatabaseNotFound 	-1203 /* No such database */
#define JET_errDatabaseInvalidName	-1204 /* Invalid database name */
#define JET_errDatabaseInvalidPages	-1205 /* Invalid number of pages */
#define JET_errDatabaseCorrupted	-1206 /* non-db file or corrupted db */
#define JET_errDatabaseLocked		-1207 /* Database exclusively locked */
#define JET_wrnDatabaseEncrypted	 1208 /* Database is encrypted */

#define JET_wrnTableEmpty			 1301 /* Open an empty table */
#define JET_errTableLocked			-1302 /* Table is exclusively locked */
#define JET_errTableDuplicate		-1303 /* Table already exists */
#define JET_errTableInUse			-1304 /* Table is in use, cannot lock */
#define JET_errObjectNotFound		-1305 /* No such table or object */
#define JET_errCannotRename			-1306 /* Cannot rename temporary file */
#define JET_errDensityInvalid		-1307 /* Bad file/index density */
#define JET_errTableNotEmpty		-1308 /* Cannot define clustered index */
#define JET_errTableNotLocked		-1309 /* No DDLs w/o exclusive lock */
#define JET_errInvalidTableId		-1310 /* Invalid table id */
#define JET_errTooManyOpenTables	-1311 /* Cannot open any more tables */
#define JET_errIllegalOperation 	-1312 /* Oper. not supported on table */
#define JET_wrnExecSegReleased		 1313 /* Query Execution segment is released */
#define JET_errObjectDuplicate		-1314 /* Table or object name in use */
#define JET_errRulesLoaded			-1315 /* Rules loaded, can't define more */
#define JET_errInvalidObject		-1316 /* object is invalid for operation */

#define JET_errIndexCantBuild		-1401 /* Cannot build clustered index */
#define JET_errIndexHasPrimary		-1402 /* Primary index already defined */
#define JET_errIndexDuplicate		-1403 /* Index is already defined */
#define JET_errIndexNotFound		-1404 /* No such index */
#define JET_errIndexMustStay		-1405 /* Cannot delete clustered index */
#define JET_errIndexInvalidDef		-1406 /* Illegal index definition */
#define JET_errSelfReference		-1407 /* Referencing/Referenced index is the same */
#define JET_errIndexHasClustered	-1408 /* Clustered index already defined */

#define JET_errColumnLong			-1501 /* column value is long */
#define JET_errColumnNoChunk		-1502 /* no such chunk in field */
#define JET_errColumnDoesNotFit 	-1503 /* Field will not fit in record */
#define JET_errNullInvalid			-1504 /* Null not valid */
#define JET_errColumnIndexed		-1505 /* Column indexed, cannot delete */
#define JET_errColumnTooBig			-1506 /* Field length is > maximum */
#define JET_errColumnNotFound		-1507 /* No such column */
#define JET_errColumnDuplicate		-1508 /* Field is already defined */
#define JET_errTaggedDefault		-1509 /* No defaults on tagged fields */
#define JET_errColumn2ndSysMaint	-1510 /* Second autoinc or version column */
#define JET_errInvalidColumnType	-1511 /* Invalid column data type */
#define JET_wrnColumnMaxTruncated	 1512 /* Max length too big, truncated */
#define JET_errColumnCannotIndex	-1513 /* Cannot index Bit,LongText,LongBinary */
#define JET_errTaggedNotNULL		-1514 /* No non-NULL tagged fields */
#define JET_errNoCurrentIndex		-1515 /* Invalid w/o a current index */
#define JET_errKeyIsMade			-1516 /* The key is completely made */
#define JET_errBadColumnId			-1517 /* Column Id Incorrect */
#define JET_errBadItagSequence		-1518 /* Bad itagSequence for tagged column */
#define JET_errColumnInRelationship	-1519 /* Cannot delete, column participates in relationship */
#define JET_wrnCopyLongValue		1520	/*	Single instance column bursted */
#define JET_errCannotBeTagged		-1521 /* AutoIncrement and Version cannot be tagged */

#define JET_errRecordNotFound		-1601 /* The key was not found */
#define JET_errRecordNoCopy			-1602 /* No working buffer */
#define JET_errNoCurrentRecord		-1603 /* Currency not on a record */
#define JET_errRecordClusteredChanged	-1604 /* Primary key may not change */
#define JET_errKeyDuplicate			-1605 /* Illegal duplicate key */
#define JET_errCannotInsertBefore	-1606 /* Cannot insert before current */
#define JET_errAlreadyPrepared		-1607 /* Already copy/clear current */
#define JET_errKeyNotMade			-1608 /* No call to JetMakeKey */
#define JET_errUpdateNotPrepared	-1609 /* No call to JetPrepareUpdate */
#define JET_wrnDataHasChanged		 1610 /* Data has changed */
#define JET_errDataHasChanged		-1611 /* Data has changed; operation aborted */
#define JET_errIntegrityViolationMaster -1612 /* References to key exist */
#define JET_errIntegrityViolationSlave	-1613 /* No referenced key exists */
#define JET_wrnMuchDataChanged		 1614 /* Repaint whole datasheet */
#define JET_errIncorrectJoinKey		-1615 /* Master key does not match lookup key */
#define JET_wrnKeyChanged			 1618 /* Moved to new key */
#define JET_wrnSyncedToDelRec		 1699 /* CONSIDER: QJET INTERNAL */
#define JET_errRedoPrepUpdate		 1698 /* CONSIDER: QJET INTERNAL(jpbulk.c)*/

#define JET_errTooManySorts			-1701 /* Too many sort processes */
#define JET_errInvalidOnSort		-1702 /* Invalid operation on Sort */

#define JET_errConfigOpenError		-1801 /* Config. file can't be opened */
#define JET_errSysDatabaseOpenError	-1802 /* System db could not be opened */
#define JET_errTempFileOpenError	-1803 /* Temp file could not be opened */
#define JET_errDatabaseOpenError	-1804 /* Database file can't be opened */
#define JET_errTooManyAttachedDatabases -1805 /* Too many open databases */
#define JET_errDatabaseCloseError	-1806 /* Db file could not be closed */
#define JET_errTooManyOpenFiles 	-1807 /* Too many files open */
#define JET_errDiskFull 			-1808 /* No space left on disk */
#define JET_errPermissionDenied 	-1809 /* Permission denied */
#define JET_errSortFileOpenError	-1810 /* Could not open sort file */
#define JET_errFileNotFound			-1811 /* File not found */
#define JET_errTempDiskFull			-1812 /* No space left on disk */
#define JET_wrnFileOpenReadOnly		1813 /* Database file is read only */

#define JET_errAfterInitialization	-1850 /* Cannot Restore after init. */
#define JET_errSeriesTooLong		-1851 /* New log generation id too big */
#define JET_errLogCorrupted			-1852 /* Logs could not be interpreted */

#define JET_errCannotOpenSystemDb	-1901 /* failed sysdb on beginsession */
#define JET_errInvalidLogon			-1902 /* invalid logon at beginsession */
#define JET_errInvalidAccountName	-1903 /* invalid account name */
#define JET_errInvalidSid			-1904 /* invalid SID */
#define JET_errInvalidPassword		-1905 /* invalid password */
#define JET_errInvalidOperation 	-1906 /* invalid operation */
#define JET_errAccessDenied			-1907 /* access denied */
#define JET_errNoMSysAccounts		-1908 /* Can't open MSysAccounts */
#define JET_errNoMSysGroups			-1909 /* Can't open MSysGroups */
#define JET_errInvalidPin			-1910	/* invalid pin */

#define JET_errRmtSqlError			-2001 /* RMT: ODBC call failed */
#define JET_errRmtMissingOdbcDll	-2006 /* RMT: Can't load ODBC DLL */
#define JET_errRmtInsertFailed		-2007 /* RMT: Insert statement failed */
#define JET_errRmtDeleteFailed		-2008 /* RMT: Delete statement failed */
#define JET_errRmtUpdateFailed		-2009 /* RMT: Update statement failed */
#define JET_errRmtColDataTruncated	-2010 /* RMT: data truncated */
#define JET_errRmtTypeIncompat		-2011 /* RMT: Can't create JET type on server */
#define JET_errRmtCreateTableFailed	-2012 /* RMT: Create table stmt failed */
#define JET_errRmtNotSupported		-2014 /* RMT: Function not legal for rdb */
#define JET_errRmtValueOutOfRange	-2020 /* RMT: Data value out of range */
#define JET_errRmtStillExec		-2021 /* RMT INTERNAL: SQL_STILL_EXECUTING */
#define JET_errRmtQueryTimeout		-2022 /* RMT: Server Not Responding */
#define JET_wrnRmtNeedLvData		 2023 /* RMT: Internal only - need Lv data */
#define JET_wrnFatCursorUseless		 2024 /* Fat cursor has no effect ***/
#define JET_errRmtWrongSPVer		-2025 /* RMT: INTERNAL: wrong SProc ver ***/
#define JET_errRmtLinkOutOfSync		-2026 /* RMT: the def for the rmt tbl has changed */
#define JET_errRmtDenyWriteIsInvalid	-2027 /* RMT: Can't open DenyWrite */
#define JET_errRmtDriverCantConv	-2029 /* RMT: INTERNAL: driver cannot convert */
#define JET_errRmtTableAmbiguous	-2030 /* RMT: Table ambiguous: must specifier owner */
#define JET_errRmtBogusConnStr		-2031 /* RMT: SPT: Bad connect string */

#define JET_errQueryInvalidAttribute	-3001 /* Invalid query attribute */
#define JET_errQueryOnlyOneRow		-3002 /* Only 1 such row allowed */
#define JET_errQueryIncompleteRow	-3003 /* Missing value in row */
#define JET_errQueryInvalidFlag 	-3004 /* Invalid value in Flag field */
#define JET_errQueryCycle		-3005 /* Cycle in query definition */
#define JET_errQueryInvalidJoinTable	-3006 /* Invalid table in join */
#define JET_errQueryAmbigRef		-3007 /* Ambiguous column reference */
#define JET_errQueryUnboundRef		-3008 /* Cannot bind name */
#define JET_errQueryParmRedef		-3009 /* Parm redefined with different type */
#define JET_errQueryMissingParms	-3010 /* Too few parameters supplied */
#define JET_errQueryInvalidOutput	-3011 /* Invalid query output */
#define JET_errQueryInvalidHaving	-3012 /* HAVING clause without aggregation */
#define JET_errQueryDuplicateAlias	-3013 /* Duplicate output alias */
#define JET_errQueryInvalidMGBInput	-3014 /* Cannot input from MGB */
#define JET_errQueryInvalidOrder	-3015 /* Invalid ORDER BY expression */
#define JET_errQueryTooManyLevels	-3016 /* Too many levels on MGB */
#define JET_errQueryMissingLevel	-3017 /* Missing intermediate MGB level */
#define JET_errQueryIllegalAggregate	-3018 /* Aggregates not allowed */
#define JET_errQueryDuplicateOutput	-3019 /* Duplicate destination output */
#define JET_errQueryIsBulkOp		-3020 /* Grbit should be set for Bulk Operation */
#define JET_errQueryIsNotBulkOp 	-3021 /* Query is not a Bulk Operation */
#define JET_errQueryIllegalOuterJoin	-3022 /* No inconsistent updates on outer joins */
#define JET_errQueryNullRequired	-3023 /* Column must be NULL */
#define JET_errQueryNoOutputs		-3024 /* Query must have an output */
#define JET_errQueryNoInputTables	-3025 /* Query must have an input */
#define JET_wrnQueryNonUpdatableRvt	 3026 /* Query is not updatable (but IS RVT) */
#define JET_errQueryInvalidAlias	-3027 /* Bogus character in alias name */
#define JET_errQueryInvalidBulkInput	-3028 /* Cannot input from bulk operation */
#define JET_errQueryNotDirectChild	-3029 /* T.* must use direct child */
#define JET_errQueryExprEvaluation	-3030 /* Expression evaluation error */
#define JET_errQueryIsNotRowReturning	-3031 /* Query does not return rows */
#define JET_wrnQueryNonRvt		 3032 /* Can't create RVT, query is static */
#define JET_errQueryParmTypeMismatch	-3033 /* Wrong parameter type given */
#define JET_errQueryChanging		-3034 /* Query Objects are being updated */
#define JET_errQueryNotUpdatable	-3035 /* Operation must use an updatable query */
#define JET_errQueryMissingColumnName	-3036 /* Missing destination column */
#define JET_errQueryTableDuplicate	-3037 /* Repeated table name in FROM list */
#define JET_errQueryIsMGB		-3038 /* Query is an MGB */
#define JET_errQueryInsIntoBulkMGB	-3039 /* Cannot insert into Bulk/MGB */
#define JET_errQueryDistinctNotAllowed	-3040 /* DISTINCT not allowed for MGB */
#define JET_errQueryDistinctRowNotAllow -3041 /* DISTINCTROW not allowed for MGB */
#define JET_errQueryNoDbForParmDestTbl	-3045 /* Dest DB for VT parm not allowed */
#define JET_errQueryDuplicatedFixedSet	-3047 /* Duplicated Fixed Value */
#define JET_errQueryNoDeleteTables	-3048 /* Must specify tables to delete from */
#define JET_errQueryCannotDelete	-3049 /* Cannot delete from specified tables */
#define JET_errQueryTooManyGroupExprs	-3050 /* Too many GROUP BY expressions */
#define JET_errQueryTooManyOrderExprs	-3051 /* Too many ORDER BY expressions */
#define JET_errQueryTooManyDistExprs	-3052 /* Too many DISTINCT output expressions */
#define JET_errQueryBadValueList	-3053 /* Malformed value list in Transform */
#define JET_errConnStrTooLong		-3054 /* Connect string too long */
#define JET_errQueryInvalidParm		-3055 /* Invalid Parmeter Name (>64 char) */
#define JET_errQueryContainsDbParm	-3056 /* Can't get parameters with Db Parm */
#define JET_errQueryBadUpwardRefed	-3057 /* Illegally Upward ref'ed */
#define JET_errQueryAmbiguousJoins	-3058 /* Joins in a QO are ambiguous */
#define JET_errQueryIsNotDDL		-3059 /* Not a DDL Operation */
#define JET_errNoDbInConnStr		-3060 /* No database in connect string */
#define JET_wrnQueryIsNotRowReturning	 3061 /* Not row returning */
#define JET_errTooManyFindSessions	-3062 /* RVT already has a find session open  */
#define JET_errSingleValueExpected	-3063 /* At most one record with one column can be returned from a scalar subquery */
#define JET_errColumnCountMismatch	-3064 /* Union Query: number of columns in children dont match */
#define JET_errQueryTopNotAllowed	-3065 /* Top not allowed for MGB */
#define JET_errQueryIsDDL			-3066 /* Must set JET_bitTableDDL */
#define JET_errQueryIsCorrupt		-3067 /* Query is Corrupt */
#define JET_errQuerySPTBulkSucceeded -3068 /* INTERNAL only */
#define JET_errSPTReturnedNoRecords -3069 /* SPT marked as RowReturning did not return a table */

#define JET_errExprSyntax		-3100 /* Syntax error in expression */
#define JET_errExprIllegalType		-3101 /* Illegal type in expression */
#define JET_errExprUnknownFunction	-3102 /* Unknown function in expression */

#define JET_errSQLSyntax		-3500 /* Bogus SQL statement type */
#define JET_errSQLParameterSyntax	-3501 /* Parameter clause syntax error */
#define JET_errSQLInsertSyntax		-3502 /* INSERT clause syntax error */
#define JET_errSQLUpdateSyntax		-3503 /* UPDATE clause syntax error */
#define JET_errSQLSelectSyntax		-3504 /* SELECT clause syntax error */
#define JET_errSQLDeleteSyntax		-3505 /* Expected 'FROM' after 'DELETE' */
#define JET_errSQLFromSyntax		-3506 /* FROM clause syntax error */
#define JET_errSQLGroupBySyntax 	-3507 /* GROUP BY clause syntax error */
#define JET_errSQLOrderBySyntax 	-3508 /* ORDER BY clause syntax error */
#define JET_errSQLLevelSyntax		-3509 /* LEVEL syntax error */
#define JET_errSQLJoinSyntax		-3510 /* JOIN syntax error */
#define JET_errSQLTransformSyntax	-3511 /* TRANSFORM syntax error */
#define JET_errSQLHavingSyntax		-3512 /* HAVING clause syntax error */
#define JET_errSQLWhereSyntax		-3513 /* WHERE clause syntax error */
#define JET_errSQLProcedureSyntax	-3514 /* Expected query name after 'PROCEDURE' */
#define JET_errSQLNotEnoughBuf		-3515 /* Buffer too small for SQL string */
#define JET_errSQLMissingSemicolon	-3516 /* Missing ; at end of SQL statement */
#define JET_errSQLTooManyTokens 	-3517 /* Characters after end of SQL statement */
#define JET_errSQLOwnerAccessSyntax -3518 /* OWNERACCESS OPTION syntax error */

#define	JET_errV11NotSupported		-3519 /* not supported in V11 */
#define JET_errV10Format			-3520 /* can be present in V10 format only */
#define JET_errSQLUnionSyntax		-3521 /* UNION query syntax error */
#define JET_errSqlPassThrough		-3523 /* Pass Through query Disallowed */
#define JET_wrnSqlPassThrough		 3524 /* Pass Through query involved */

#define JET_errDDLConstraintSyntax	-3550 /* constraint syntax error */
#define JET_errDDLCreateTableSyntax	-3551 /* create table syntax error */
#define JET_errDDLCreateIndexSyntax	-3552 /* create index syntax error */
#define JET_errDDLColumnDefSyntax	-3553 /* column def syntax error */
#define JET_errDDLAlterTableSyntax	-3554 /* alter table syntax error */
#define JET_errDDLDropIndexSyntax	-3555 /* drop index syntax error */
#define JET_errDDLDropSyntax		-3556 /* drop view/procedure syntax error */
#define JET_errDDLCreateViewSyntax	-3557 /* create view syntax error */

#define JET_errNoSuchProperty	-3600 /* Property was not found */
#define JET_errPropertyTooLarge -3601 /* Small Property larger than 2K */
#define JET_errJPMInvalidForV1x -3602 /* No JPM for V1.x databases */
#define JET_errPropertyExists	-3603 /* Property already exists */
#define JET_errInvalidDelete	-3604 /* DeleteOnly called with non-zero cbData */

#define JET_wrnFindWrapped		 3700 /* Cursor wrapped during fast find */

#define JET_errTLVNativeUserTablesOnly -3700 /* TLVs can only be placed on native user tables/columns */
#define JET_errTLVNoNull		  	   -3701 /* This field cannot be null */
#define JET_errTLVNoBlank			   -3702 /* This column cannot be blank */
#define	JET_errTLVRuleViolation 	   -3703 /* This validation rule must be met */
#define	JET_errTLVInvalidColumn	   	   -3704 /* This TLV property cannot be placed on this column */
#define JET_errTLVExprEvaluation	   -3705 /* Expression evaluation error */
#define JET_errTLVExprUnknownFunc	   -3706 /* Unknown function in TLV expression */
#define JET_errTLVExprSyntax		   -3707 /* Syntax error in TLV expression */

	/* CONSIDER: Remove the following error. */

#define JET_errGeneral			-5001 /* I-ISAM: assert failure */
#define JET_errRecordLocked		-5002 /* I-ISAM: record locked */
#define JET_wrnColumnDataTruncated	 5003 /* I-ISAM: data truncated */
#define JET_errTableNotOpen		-5004 /* I-ISAM: table is not open */
#define JET_errDecryptFail		-5005 /* I-ISAM: incorrect password */
#define JET_wrnCurrencyLost		 5007 /* I-ISAM: currency lost - must first/last */
#define JET_errDateOutOfRange		-5008 /* I-ISAM: invalid date */
#define JET_wrnOptionsIgnored		 5011 /* I-ISAM: options were ignored */
#define JET_errTableNotComplete		-5012 /* I-ISAM: incomplete table definition */
#define JET_errIllegalNetworkOption	-5013 /* I-ISAM: illegal network option */
#define JET_errIllegalTimeoutOption	-5014 /* I-ISAM: illegal timeout option */
#define JET_errNotExternalFormat	-5015 /* I-ISAM: invalid file format */
#define JET_errUnexpectedEngineReturn	-5016 /* I-ISAM: unexpected engine error code */
#define JET_errNumericFieldOverflow     -5017 /* I-ISAM: can't convert to native type */

#define JET_errIndexHasNoPrimary	-5020 /* Paradox: no primary index */
#define JET_errTableSortOrderMismatch	-5021 /* Paradox: sort order mismatch */
#define JET_errNoConfigParameters	-5023 /* Paradox: net path or user name missing */
#define JET_errCantAccessParadoxNetDir	-5024 /* Paradox: bad Paradox net path */
#define JET_errObsoleteLockFile 	-5025 /* Paradox: obsolete lock file */
#define JET_errIllegalCollatingSequence -5026 /* Paradox: invalid sort sequence */
#define JET_errWrongCollatingSequence	-5027 /* Paradox: wrong sort sequence */
#define JET_errCantUseUnkeyedTable	-5028 /* Paradox: can't open unkeyed table */

#define JET_errINFFileError		-5101 /* dBase: invalid .INF file */
#define JET_errCantMakeINFFile		-5102 /* dBase: can't open .INF file */
#define JET_wrnCantMaintainIndex	 5103 /* dBase: unmaintainable index */
#define JET_errMissingMemoFile		-5104 /* dBase: missing memo file */
#define JET_errIllegalCenturyOption	-5105 /* dBase: Illegal century option */
#define JET_errIllegalDeletedOption	-5106 /* dBase: Illegal deleted option */
#define JET_errIllegalStatsOption	-5107 /* dBase: Illegal statistics option */
#define JET_errIllegalDateOption	-5108 /* dBase: Illegal date option */
#define JET_errIllegalMarkOption	-5109 /* dBase: Illegal mark option */
#define JET_wrnDuplicateIndexes		 5110 /* dBase: duplicate indexes in INF file */
#define JET_errINFIndexNotFound		-5111 /* dBase: missing index in INF file */
#define JET_errWrongMemoFileType	-5112 /* dBase: wrong memo file type */
#define JET_errIllegalExactOption       -5113 /* dBase: Illegal exact option */

#define JET_errTooManyLongFields	-5200 /* Btrieve: more than one memo field */
#define JET_errCantStartBtrieve 	-5201 /* Btrieve: wbtrcall.dll missing */
#define JET_errBadConfigParameters	-5202 /* Btrieve: win.ini [btrieve] options wrong */
#define JET_errIndexesChanged		-5203 /* Btrieve: need to GetIndexInfo */
#define JET_errNonModifiableKey 	-5204 /* Btrieve: can't modify record column */
#define JET_errOutOfBVResources 	-5205 /* Btrieve: out of resources */
#define JET_errBtrieveDeadlock		-5206 /* Btrieve: locking deadlock */
#define JET_errBtrieveFailure		-5207 /* Btrieve: Btrieve DLL failure */
#define JET_errBtrieveDDCorrupted	-5208 /* Btrieve: data dictionary corrupted */
#define JET_errBtrieveTooManyTasks	-5209 /* Btrieve: too many tasks */
#define JET_errIllegalIndexDDFOption    -5210 /* Btrieve: Illegal IndexDDF option */
#define JET_errIllegalDataCodePage      -5211 /* Btrieve: Illeagl DataCodePage option */
#define JET_errXtrieveEnvironmentError  -5212 /* Btrieve: Xtrieve INI options bad */
#define JET_errMissingDDFFile           -5213 /* Btrieve: Missing field.ddf */
#define JET_errIlleaglIndexNumberOption -5214 /* Btrieve: Illeagl IndexRenumber option */

	/* Extended error codes must be in the following range. */
	/* Major error codes may not be in this range. */

#define JET_errMinorLeast		-8000
#define JET_errMinorMost		-8999

#define JET_errFindExprSyntax		-8001 /* Syntax error in FastFind expression */
#define JET_errQbeExprSyntax		-8002 /* Syntax error in QBE expression */
#define JET_errInputTableNotFound	-8003 /* Non-existant object in FROM list */
#define JET_errQueryExprSyntax		-8004 /* Syntax error in some query expression */
#define JET_errQodefExprSyntax		-8005 /* Syntax error in expression column */
#define JET_errExpAliasAfterAS		-8006 /* Expected alias after 'AS' in FROM list */
#define JET_errExpBYAfterGROUP		-8007 /* Expected 'BY' after 'GROUP' */
#define JET_errExpBYAfterORDER		-8008 /* Expected 'BY' after 'ORDER' */
#define JET_errExpClsParenAfterColList	-8009 /* Expected ')' after column list */
#define JET_errExpColNameAfterPIVOT	-8010 /* Expected column name after 'PIVOT' */
#define JET_errExpDatabaseAfterIN	-8011 /* Expected database name after 'IN' */
#define JET_errExpDatatypeAfterParmName -8012 /* Expected datatype after parameter name */
#define JET_errExpEqualAfterUpdColName	-8013 /* Expected '=' after update column name */
#define JET_errExpExprAfterON		-8014 /* Expected join expression after 'ON' */
#define JET_errExpExprAfterTRANSFORM	-8015 /* Expected expression after 'TRANSFORM' */
#define JET_errExpExprAfterWHERE	-8016 /* Expected expression after 'WHERE' */
#define JET_errExpGroupClauseInXform	-8017 /* Transform expects GROUP BY clause */
#define JET_errExpGroupingExpr		-8018 /* Expected grouping expression */
#define JET_errExpHavingExpr		-8019 /* Expected HAVING expression */
#define JET_errExpINTOAfterINSERT	-8020 /* Expected 'INTO' after 'INSERT' */
#define JET_errExpJOINAfterJoinType	-8021 /* Expected 'JOIN' after INNER/LEFT/RIGHT */
#define JET_errExpLEVELAfterSelectList	-8022 /* Expected LEVEL after select list */
#define JET_errExpNumberAfterLEVEL	-8023 /* Expected number after 'LEVEL' */
#define JET_errExpONAfterRightTable	-8024 /* Expected 'ON' after right join table */
#define JET_errExpOrderExpr		-8025 /* Expected ordering expression */
#define JET_errExpOutputAliasAfterAS	-8026 /* Expected output alias after 'AS' */
#define JET_errExpOutputExpr		-8027 /* Expected output expression */
#define JET_errExpPIVOTAfterSelectStmt	-8028 /* Expected 'PIVOT' after SELECT statement */
#define JET_errExpRightJoinTable	-8029 /* Expected right join table after 'JOIN' */
#define JET_errExpSELECTAfterInsClause	-8030 /* Expected 'SELECT' after INSERT clause */
#define JET_errExpSELECTAfterXformExpr	-8031 /* Expected 'SELECT' after Transform fact */
#define JET_errExpSETAfterTableName	-8032 /* Expected 'SET' after table name */
#define JET_errExpSemiAfterLevelNumber	-8033 /* Expected ';' after level number */
#define JET_errExpSemiAfterParmList	-8034 /* Expected ';' after parmeter list */
#define JET_errExpSemiAfterPivotClause	-8035 /* Expected ';' after PIVOT clause */
#define JET_errExpSemiAtEndOfSQL	-8036 /* Expected ';' at end of SQL statement */
#define JET_errExpTableName		-8037 /* Expected table name */
#define JET_errExpTableNameAfterINTO	-8038 /* Expected table name after 'INTO' */
#define JET_errExpUpdExprAfterEqual	-8039 /* Expected update expression after '=' */
#define JET_errExpUpdateColName 	-8040 /* Expected update column name */
#define JET_errInvTokenAfterFromList	-8041 /* Bogus token after FROM list */
#define JET_errInvTokenAfterGroupList	-8042 /* Bogus token after GROUP BY list */
#define JET_errInvTokenAfterHavingCls	-8043 /* Bogus token after HAVING clause */
#define JET_errInvTokenAfterOrderClause -8044 /* Bogus token after ORDER BY clause */
#define JET_errInvTokenAfterSelectCls	-8045 /* Bogus token after SELECT clause */
#define JET_errInvTokenAfterWhereClause -8046 /* Bogus token after WHERE clause */
#define JET_errLevelNumberTooBig	-8047 /* Number after 'LEVEL' too big */
#define JET_errLevelOnNonMGB		-8048 /* LEVEL allowed only in MGB */
#define JET_errIllegalDetailReference	-8049 /* Not group key or agg, but not MGB detail */
#define JET_errAggOverMixedLevels	-8050 /* Agg. arg. uses outputs from > 1 level */
#define JET_errAggregatingHigherLevel	-8051 /* Agg. over output of same/higher level */
#define JET_errNullInJoinKey		-8052 /* Cannot set column in join key to NULL */
#define JET_errValueBreaksJoin		-8053 /* Join is broken by column value(s) */
#define JET_errInsertIntoUnknownColumn	-8054 /* INSERT INTO unknown column name */
#define JET_errNoSelectIntoColumnName	-8055 /* No dest. col. name in SELECT INTO stmt */
#define JET_errNoInsertColumnName	-8056 /* No dest. col. name in INSERT stmt */
#define JET_errColumnNotInJoinTable	-8057 /* Join expr refers to non-join table */
#define JET_errAggregateInJoin		-8058 /* Aggregate in JOIN clause */
#define JET_errAggregateInWhere 	-8059 /* Aggregate in WHERE clause */
#define JET_errAggregateInOrderBy	-8060 /* Aggregate in ORDER BY clause */
#define JET_errAggregateInGroupBy	-8061 /* Aggregate in GROUP BY clause */
#define JET_errAggregateInArgument	-8062 /* Aggregate in argument expression */
#define JET_errHavingOnTransform	-8063 /* HAVING clause on TRANSFORM query */
#define JET_errHavingWithoutGrouping	-8064 /* HAVING clause w/o grouping/aggregation */
#define JET_errHavingOnMGB		-8065 /* HAVING clause on MGB query */
#define JET_errOutputAliasCycle 	-8066 /* Cycle in SELECT list (via aliases) */
#define JET_errDotStarWithGrouping	-8067 /* 'T.*' with grouping, but not MGB level 0 */
#define JET_errStarWithGrouping 	-8068 /* '*' with grouping, but not MGB detail */
#define JET_errQueryTreeCycle		-8069 /* Cycle in tree of query objects */
#define JET_errTableRepeatInFromList	-8072 /* Table appears twice in FROM list */
#define JET_errTooManyXformLevels	-8073 /* Level > 2 in TRANSFORM query */
#define JET_errTooManyMGBLevels 	-8074 /* Too many levels in MGB */
#define JET_errNoUpdateColumnName	-8075 /* No dest. column name in UPDATE stmt */
#define JET_errJoinTableNotInput	-8076 /* Join table not in FROM list */
#define JET_errUnaliasedSelfJoin	-8077 /* Join tables have same name */
#define JET_errOutputLevelTooBig	-8078 /* Output w/ level > 1+max group level */
#define JET_errOrderVsGroup		-8079 /* ORDER BY conflicts with GROUP BY */
#define JET_errOrderVsDistinct		-8080 /* ORDER BY conflicts with DISTINCT */
#define JET_errExpLeftParenthesis	-8082 /* Expected '(' */
#define JET_errExpRightParenthesis	-8083 /* Expected ')' */
#define JET_errEvalEBESErr		-8084 /* EB/ES error evaluating expression */
#define JET_errQueryExpCloseQuote	-8085 /* Unmatched quote for database name */
#define JET_errQueryParmNotDatabase	-8086 /* Parameter type should be database */
#define JET_errQueryParmNotTableid	-8087 /* Parameter type should be tableid */
#define JET_errExpIdentifierM		-8088 /* Expected identifier */
#define JET_errExpQueryName		-8089 /* Expected query name after PROCEDURE */
#define JET_errExprUnknownFunctionM	-8090 /* Unknown function in expression */
#define JET_errQueryAmbigRefM		-8091 /* Ambiguous column reference */
#define JET_errQueryBadBracketing	-8092 /* Bad bracketing of identifier */
#define JET_errQueryBadQodefName	-8093 /* Invalid name in QODEF row */
#define JET_errQueryBulkColNotUpd	-8094 /* Column not updatable (bulk op) */
#define JET_errQueryDistinctNotAllowedM	-8095 /* DISTINCT not allowed for MGB */
#define JET_errQueryDuplicateAliasM	-8096 /* Duplicate output alias */
#define JET_errQueryDuplicateOutputM	-8097 /* Duplicate destination output */
#define JET_errQueryDuplicatedFixedSetM	-8098 /* Duplicated Fixed Value */
#define JET_errQueryIllegalOuterJoinM	-8099 /* No inconsistent updates on outer joins */
#define JET_errQueryIncompleteRowM	-8100 /* Missing value in row */
#define JET_errQueryInvalidAttributeM	-8101 /* Invalid query attribute */
#define JET_errQueryInvalidBulkInputM	-8102 /* Cannot input from bulk operation */
#define JET_errQueryInvalidFlagM	-8103 /* Invalid value in Flag field */
#define JET_errQueryInvalidMGBInputM	-8104 /* Cannot input from MGB */
#define JET_errQueryLVInAggregate	-8105 /* Illegal long value in aggregate */
#define JET_errQueryLVInDistinct	-8106 /* Illegal long value in DISTINCT */
#define JET_errQueryLVInGroupBy		-8107 /* Illegal long value in GROUP BY */
#define JET_errQueryLVInHaving		-8108 /* Illegal long value in HAVING */
#define JET_errQueryLVInJoin		-8109 /* Illegal long value in JOIN */
#define JET_errQueryLVInOrderBy		-8110 /* Illegal long value in ORDER BY */
#define JET_errQueryMissingLevelM	-8111 /* Missing intermediate MGB level */
#define JET_errQueryMissingParmsM	-8112 /* Too few parameters supplied */
#define JET_errQueryNoDbForParmDestTblM	-8113 /* Dest DB for VT parm not allowed */
#define JET_errQueryNoDeletePerm	-8114 /* No delete permission on table/query */
#define JET_errQueryNoInputTablesM	-8115 /* Query must have an input */
#define JET_errQueryNoInsertPerm	-8116 /* No insert permission on table/query */
#define JET_errQueryNoOutputsM		-8117 /* Query must have an output */
#define JET_errQueryNoReadDefPerm	-8118 /* No permission to read query definition */
#define JET_errQueryNoReadPerm		-8119 /* No read permission on table/query */
#define JET_errQueryNoReplacePerm	-8120 /* No replace permission on table/query */
#define JET_errQueryNoTblCrtPerm	-8121 /* No CreateTable permission (bulk op) */
#define JET_errQueryNotDirectChildM	-8122 /* T.* must use direct child */
#define JET_errQueryNullRequiredM	-8123 /* Column must be NULL */
#define JET_errQueryOnlyOneRowM		-8124 /* Only 1 such row allowed */
#define JET_errQueryOutputColNotUpd	-8125 /* Query output column not updatable */
#define JET_errQueryParmRedefM		-8126 /* Parm redefined with different type */
#define JET_errQueryParmTypeMismatchM	-8127 /* Wrong parameter type given */
#define JET_errQueryUnboundRefM		-8128 /* Cannot bind name */
#define JET_errRmtConnectFailedM	-8129 /* RMT: Connection attempt failed */
#define JET_errRmtDeleteFailedM		-8130 /* RMT: Delete statement failed */
#define JET_errRmtInsertFailedM		-8131 /* RMT: Insert statement failed */
#define JET_errRmtMissingOdbcDllM	-8132 /* RMT: Can't load ODBC DLL */
#define JET_errRmtSqlErrorM		-8133 /* RMT: ODBC call failed */
#define JET_errRmtUpdateFailedM		-8134 /* RMT: Update statement failed */
#define JET_errSQLDeleteSyntaxM		-8135 /* Expected 'FROM' after 'DELETE' */
#define JET_errSQLSyntaxM		-8136 /* Bogus SQL statement type */
#define JET_errSQLTooManyTokensM	-8137 /* Characters after end of SQL statement */
#define JET_errStarNotAtLevel0		-8138 /* '*' illegal above level 0 */
#define JET_errQueryParmTypeNotAllowed	-8139 /* Parameter type not allowed for expression */
#define JET_errQueryTooManyDestColumn	-8142 /* Too many destination column sepcified */
#define JET_errSQLNoInsertColumnName	-8143 /* No dest. col. name in INSERT stmt */
#define JET_errRmtLinkNotFound		-8144 /* RMT: link not found */
#define JET_errRmtTooManyColumns	-8145 /* RMT: Too many columns on Select Into */
#define JET_errWriteConflictM		-8146 /* Write lock failed due to outstanding write lock */
#define JET_errReadConflictM		-8147 /* Commit lock failed due to outstanding read lock */
#define JET_errCommitConflictM		-8148 /* Read lock failed due to outstanding commit lock */
#define JET_errTableLockedM		-8149 /* Table is exclusively locked */
#define JET_errTableInUseM		-8150 /* Table is in use, cannot lock */
#define JET_errQueryTooManyXvtColumn	-8151 /* Too many cross table column headers */
#define JET_errOutputTableNotFound	-8152 /* Non-existent table in Insert Into */
#define JET_errTableLockedQM		-8153 /* Table is exclusively locked */
#define JET_errTableInUseQM		-8154 /* Table is in use, cannot lock */
#define JET_errTableLockedMUQM		-8155 /* Table is exclusively locked */
#define JET_errTableInUseMUQM		-8156 /* Table is in use, cannot lock */
#define JET_errQueryInvalidParmM	-8157 /* Invalid Parmeter Name (>64 char) */
#define JET_errFileNotFoundM		-8158 /* File not found */
#define JET_errFileShareViolationM	-8159 /* File sharing violation */
#define JET_errFileAccessDeniedM	-8160 /* Access denied */
#define JET_errInvalidPathM		-8161 /* Invalid Path */
#define JET_errTableDuplicateM		-8162 /* Table already exists */
#define JET_errQueryBadUpwardRefedM	-8163 /* Illegally Upward ref'ed */
#define JET_errIntegrityViolMasterM	-8164 /* References to key exist */
#define JET_errIntegrityViolSlaveM	-8165 /* No referenced key exists */
#define JET_errSQLUnexpectedWithM	-8166 /* Unexpected 'with' in this place */
#define JET_errSQLOwnerAccessM		-8167 /* Owner Access Option is defined Twice */
#define	JET_errSQLOwnerAccessSyntaxM 	-8168 /* Owner Access Option Syntax Error */
#define	JET_errSQLOwnerAccessDef 	-8169 /* Owner Access Option is defined more than once */
#define JET_errAccessDeniedM     	-8170 /* Generic Access Denied */
#define JET_errUnexpectedEngineReturnM	-8171 /* I-ISAM: unexpected engine error code */
#define JET_errQueryTopNotAllowedM	-8172 /* Top not allowed for MGB */
#define JET_errInvTokenAfterTableCls -8173 /* Bogus token after table clause */
#define JET_errInvTokenAfterRParen  -8174 /* Unexpected tokens after a closing paren */
#define JET_errQueryBadValueListM	-8175 /* Malformed value list in Transform */
#define JET_errQueryIsCorruptM		-8176 /* Query is Corrupt */
#define	JET_errInvalidTopArgumentM	-8177 /* Select Top argument is invalid */
#define JET_errQueryIsSnapshot		-8178 /* Query is a snapshot */
#define JET_errQueryExprOutput		-8179 /* Output is a calculated column */
#define JET_errQueryTableRO		-8180 /* Column comes from read-only table */
#define JET_errQueryRowDeleted		-8181 /* Column comes from deleted row */
#define JET_errQueryRowLocked		-8182 /* Column comes from locked row */
#define JET_errQueryFixupChanged	-8183 /* Would row-fixup away from pending changes */
#define JET_errQueryCantFillIn		-8184 /* Fill-in-the-blank only on most-many */
#define JET_errQueryWouldOrphan		-8185 /* Would orphan joined records */
#define JET_errIncorrectJoinKeyM	-8186 /* Must match join key in lookup table */
#define JET_errQueryLVInSubqueryM	-8187 /* Illegal long value in subquery */
#define JET_errInvalidDatabaseM		-8188 /* Unrecognized database format */
#define JET_errOrderVsUnion 		-8189 /* You can only order by an outputted column in a union */
#define JET_errTLVCouldNotBindRef 	-8190 /* Unknown token in TLV expression */
#define JET_errCouldNotBindRef		-8191 /* Unknown token in FastFind expression */
#define JET_errQueryPKeyNotOutput	-8192 /* Primary key not output */
#define JET_errQueryJKeyNotOutput	-8193 /* Join key not output */
#define JET_errExclusiveDBConflict	-8194 /* Conflict with exclusive user */
#define JET_errQueryNoJoinedRecord	-8195 /* No F.I.T.B. insert if no joined record */
#define JET_errQueryLVInSetOp		-8196 /* Illegal long value in set operation */
#define JET_errTLVExprUnknownFunctionM	-8197 /* Unknown function in TLV expression */
#define JET_errInvalidNameM		-8198 /* Invalid name */

#define JET_errDDLExpColName		-8200 /* expect column name */
#define JET_errDDLExpLP			-8201 /* expect '(' */
#define JET_errDDLExpRP			-8202 /* expect ')' */
#define JET_errDDLExpIndex		-8203 /* expect INDEX */
#define JET_errDDLExpIndexName		-8204 /* expect index name */
#define JET_errDDLExpOn			-8205 /* expect ON */
#define JET_errDDLExpKey		-8206 /* expect KEY */
#define JET_errDDLExpReferences		-8207 /* expect REFERENCES */
#define JET_errDDLExpTableName		-8208 /* expect table name */
#define JET_errDDLExpFullOrPartial	-8209 /* expect FULL or PARTIAL */
#define JET_errDDLExpCascadeOrSet	-8210 /* expect CASCADE or SET */
#define JET_errDDLExpNull		-8211 /* expect NULL */
#define JET_errDDLExpUpdateOrDelete	-8212 /* expect UPDATE or DELETE */
#define JET_errDDLExpConstraintName	-8213 /* expect constraint name */
#define JET_errDDLExpForeign		-8214 /* expect FOREIGN */
#define JET_errDDLExpDatatype		-8215 /* expect data type */
#define JET_errDDLExpIndexOpt		-8216 /* expect index options */
#define JET_errDDLExpWith		-8217 /* expect WITH */
#define JET_errDDLExpTable		-8218 /* expect TABLE */
#define JET_errDDLExpEos		-8219 /* expect End Of String */
#define JET_errDDLExpAddOrDrop		-8220 /* expect ADD or Drop */
#define JET_errDDLCreateView		-8221 /* Create view not supported */
#define JET_errDDLCreateProc		-8222 /* Create proc not supported */
#define JET_errDDLExpObjectName		-8223 /* expect object name */
#define JET_errDDLExpColumn		-8224 /* expect COLUMN */

#define	JET_errV11TableNameNotInScope 	-8250 /* referenced table not in join clause */
#define JET_errV11OnlyTwoTables		-8251 /* exactly two tables should be referenced in join */
#define JET_errV11OneSided		-8252 /* all tables come from one side of input */
#define JET_errV11Ambiguous		-8253 /* Join clause is ambiguous when stored in V1 format */

#define JET_errTLVExprSyntaxM		-8260 /* Syntax error in TLV expression */
#define JET_errTLVNoNullM			-8261 /* This field cannot be null */
#define JET_errTLVNoBlankM			-8262 /* This column cannot be blank */
#define	JET_errTLVRuleViolationM 	-8263 /* This validation rule must be met */
#define JET_errDDLCreateViewSyntaxM	-8264 /* create view syntax error */

/***********************
 The following error code ranges are reserved for external use.
 As is true for Jet error codes, these ranges cover the negative
 as well as positive form of the numbers in the range.

 30000 through 30999 for use by Vt Object as defined in jeteb.h
 32000 through 32767 for use by Import/Export as defined in jetutil.h

 ***********************/



/**********************************************************************/
/***********************     PROTOTYPES      **************************/
/**********************************************************************/

#if !defined(_JET_NOPROTOTYPES)

/****************************************************************************

	ISAM API

*****************************************************************************/

JET_ERR JET_API JetInit(JET_INSTANCE _far *pinstance);

JET_ERR JET_API JetTerm(JET_INSTANCE instance);

JET_ERR JET_API JetSetSystemParameter(JET_INSTANCE _far *pinstance, JET_SESID sesid, unsigned long paramid,
	ULONG_PTR lParam, const char _far *sz);

JET_ERR JET_API JetGetSystemParameter(JET_INSTANCE instance, JET_SESID sesid, unsigned long paramid,
	ULONG_PTR _far *plParam, char _far *sz, unsigned long cbMax);

JET_ERR JET_API JetGetLastErrorInfo(JET_SESID sesid,
	JET_EXTERR _far *pexterr, unsigned long cbexterrMax,
	char _far *sz1, unsigned long cch1Max,
	char _far *sz2, unsigned long cch2Max,
	char _far *sz3, unsigned long cch3Max,
	unsigned long _far *pcch3Actual);

JET_ERR JET_API JetBeginSession(JET_INSTANCE instance, JET_SESID _far *psesid,
	const char _far *szUserName, const char _far *szPassword);

JET_ERR JET_API JetDupSession(JET_SESID sesid, JET_SESID _far *psesid);

JET_ERR JET_API JetEndSession(JET_SESID sesid, JET_GRBIT grbit);

JET_ERR JET_API JetGetVersion(JET_SESID sesid, unsigned long _far *pwVersion);

JET_ERR JET_API JetIdle(JET_SESID sesid, JET_GRBIT grbit);

JET_ERR JET_API JetCapability(JET_SESID sesid, JET_DBID dbid,
	unsigned long lArea, unsigned long lFunction, JET_GRBIT _far *pgrbit);

JET_ERR JET_API JetCreateDatabase(JET_SESID sesid,
	const char _far *szFilename, const char _far *szConnect,
	JET_DBID _far *pdbid, JET_GRBIT grbit);

JET_ERR JET_API JetAttachDatabase(JET_SESID sesid, const char _far *szFilename, JET_GRBIT grbit );

JET_ERR JET_API JetDetachDatabase(JET_SESID sesid, const char _far *szFilename);

JET_ERR JET_API JetCreateTable(JET_SESID sesid, JET_DBID dbid,
	const char _far *szTableName, unsigned long lPages, unsigned long lDensity,
	JET_TABLEID _far *ptableid);

JET_ERR JET_API JetRenameTable(JET_SESID sesid, JET_DBID dbid,
	const char _far *szTableName, const char _far *szTableNew);

JET_ERR JET_API JetDeleteTable(JET_SESID sesid, JET_DBID dbid,
	const char _far *szTableName);

JET_ERR JET_API JetGetTableColumnInfo(JET_SESID sesid, JET_TABLEID tableid,
	const char _far *szColumnName, void _far *pvResult, unsigned long cbMax,
	unsigned long InfoLevel);

JET_ERR JET_API JetGetColumnInfo(JET_SESID sesid, JET_DBID dbid,
	const char _far *szTableName, const char _far *szColumnName,
	void _far *pvResult, unsigned long cbMax, unsigned long InfoLevel);

JET_ERR JET_API JetAddColumn(JET_SESID sesid, JET_TABLEID tableid,
	const char _far *szColumn, const JET_COLUMNDEF _far *pcolumndef,
	const void _far *pvDefault, unsigned long cbDefault,
	JET_COLUMNID _far *pcolumnid);

JET_ERR JET_API JetRenameColumn(JET_SESID sesid, JET_TABLEID tableid,
	const char _far *szColumn, const char _far *szColumnNew);

JET_ERR JET_API JetDeleteColumn(JET_SESID sesid, JET_TABLEID tableid,
	const char _far *szColumn);

JET_ERR JET_API JetGetTableIndexInfo(JET_SESID sesid, JET_TABLEID tableid,
	const char _far *szIndexName, void _far *pvResult, unsigned long cbResult,
	unsigned long InfoLevel);

JET_ERR JET_API JetGetTableReferenceInfo(JET_SESID sesid, JET_TABLEID tableid,
	const char _far *szReferenceName, void _far *pvResult,
	unsigned long cbResult, unsigned long InfoLevel);

JET_ERR JET_API JetGetTableInfo(JET_SESID sesid, JET_TABLEID tableid,
	void _far *pvResult, unsigned long cbMax, unsigned long InfoLevel);

JET_ERR JET_API JetGetIndexInfo(JET_SESID sesid, JET_DBID dbid,
	const char _far *szTableName, const char _far *szIndexName,
	void _far *pvResult, unsigned long cbResult, unsigned long InfoLevel);

JET_ERR JET_API JetGetReferenceInfo(JET_SESID sesid, JET_DBID dbid,
	const char _far *szTableName, const char _far *szReference,
	void _far *pvResult, unsigned long cbResult, unsigned long InfoLevel);

JET_ERR JET_API JetCreateIndex(JET_SESID sesid, JET_TABLEID tableid,
	const char _far *szIndexName, JET_GRBIT grbit,
	const char _far *szKey, unsigned long cbKey, unsigned long lDensity);

JET_ERR JET_API JetRenameIndex(JET_SESID sesid, JET_TABLEID tableid,
	const char _far *szIndex, const char _far *szIndexNew);

JET_ERR JET_API JetDeleteIndex(JET_SESID sesid, JET_TABLEID tableid,
	const char _far *szIndexName);

JET_ERR JET_API JetCreateReference(JET_SESID sesid, JET_TABLEID tableid,
	const char _far *szReferenceName, const char _far *szColumns,
	const char _far *szReferencedTable,
	const char _far *szReferencedColumns, JET_GRBIT grbit);

JET_ERR JET_API JetRenameReference(JET_SESID sesid, JET_TABLEID tableid,
	const char _far *szReference, const char _far *szReferenceNew);

JET_ERR JET_API JetDeleteReference(JET_SESID sesid, JET_TABLEID tableid,
	const char _far *szReferenceName);

JET_ERR JET_API JetGetObjectInfo(JET_SESID sesid, JET_DBID dbid,
	JET_OBJTYP objtyp, const char _far *szContainerName,
	const char _far *szObjectName, void _far *pvResult, unsigned long cbMax,
	unsigned long InfoLevel);

JET_ERR JET_API JetCreateObject(JET_SESID sesid, JET_DBID dbid,
	const char _far *szContainerName, const char _far *szObjectName,
	JET_OBJTYP objtyp);

JET_ERR JET_API JetDeleteObject(JET_SESID sesid, JET_DBID dbid,
	const char _far *szContainerName, const char _far *szObjectName);

JET_ERR JET_API JetRenameObject(JET_SESID sesid, JET_DBID dbid,
	const char _far *szContainerName, const char _far *szObjectName,
	const char _far *szObjectNew);

JET_ERR JET_API JetBeginTransaction(JET_SESID sesid);

JET_ERR JET_API JetCommitTransaction(JET_SESID sesid, JET_GRBIT grbit);

JET_ERR JET_API JetRollback(JET_SESID sesid, JET_GRBIT grbit);

JET_ERR JET_API JetUpdateUserFunctions(JET_SESID sesid);

JET_ERR JET_API JetGetDatabaseInfo(JET_SESID sesid, JET_DBID dbid,
	void _far *pvResult, unsigned long cbMax, unsigned long InfoLevel);

JET_ERR JET_API JetCloseDatabase(JET_SESID sesid, JET_DBID dbid,
	JET_GRBIT grbit);

JET_ERR JET_API JetCloseTable(JET_SESID sesid, JET_TABLEID tableid);

JET_ERR JET_API JetOpenDatabase(JET_SESID sesid, const char _far *szFilename,
	const char _far *szConnect, JET_DBID _far *pdbid, JET_GRBIT grbit);

JET_ERR JET_API JetOpenTable(JET_SESID sesid, JET_DBID dbid,
	const char _far *szTableName, const void _far *pvParameters,
	unsigned long cbParameters, JET_GRBIT grbit, JET_TABLEID _far *ptableid);

JET_ERR JET_API JetDelete(JET_SESID sesid, JET_TABLEID tableid);

JET_ERR JET_API JetUpdate(JET_SESID sesid, JET_TABLEID tableid,
	void _far *pvBookmark, unsigned long cbBookmark,
	unsigned long _far *pcbActual);

JET_ERR JET_API JetRetrieveColumn(JET_SESID sesid, JET_TABLEID tableid,
	JET_COLUMNID columnid, void _far *pvData, unsigned long cbData,
	unsigned long _far *pcbActual, JET_GRBIT grbit, JET_RETINFO _far *pretinfo);

JET_ERR JET_API JetRetrieveColumns( JET_SESID sesid, JET_TABLEID tableid,
	JET_RETRIEVECOLUMN *pretrievecolumn, unsigned long cretrievecolumn );

JET_ERR JET_API JetSetColumn(JET_SESID sesid, JET_TABLEID tableid,
	JET_COLUMNID columnid, const void _far *pvData, unsigned long cbData,
	JET_GRBIT grbit, JET_SETINFO _far *psetinfo);

JET_ERR JET_API JetSetColumns(JET_SESID sesid, JET_TABLEID tableid,
	JET_SETCOLUMN *psetcolumn, unsigned long csetcolumn );

JET_ERR JET_API JetPrepareUpdate(JET_SESID sesid, JET_TABLEID tableid,
	unsigned long prep);

JET_ERR JET_API JetGetRecordPosition(JET_SESID sesid, JET_TABLEID tableid,
	JET_RECPOS _far *precpos, unsigned long cbRecpos);

JET_ERR JET_API JetGotoPosition(JET_SESID sesid, JET_TABLEID tableid,
	JET_RECPOS *precpos );

JET_ERR JET_API JetGetCursorInfo(JET_SESID sesid, JET_TABLEID tableid,
	void _far *pvResult, unsigned long cbMax, unsigned long InfoLevel);

JET_ERR JET_API JetDupCursor(JET_SESID sesid, JET_TABLEID tableid,
	JET_TABLEID _far *ptableid, JET_GRBIT grbit);

JET_ERR JET_API JetGetCurrentIndex(JET_SESID sesid, JET_TABLEID tableid,
	char _far *szIndexName, unsigned long cchIndexName);

JET_ERR JET_API JetSetCurrentIndex(JET_SESID sesid, JET_TABLEID tableid,
	const char _far *szIndexName);

JET_ERR JET_API JetMove(JET_SESID sesid, JET_TABLEID tableid,
	long cRow, JET_GRBIT grbit);

JET_ERR JET_API JetMakeKey(JET_SESID sesid, JET_TABLEID tableid,
	const void _far *pvData, unsigned long cbData, JET_GRBIT grbit);

JET_ERR JET_API JetSeek(JET_SESID sesid, JET_TABLEID tableid,
	JET_GRBIT grbit);

JET_ERR JET_API JetFastFind(JET_SESID sesid, JET_DBID dbid,
	JET_TABLEID tableid, const char _far *szExpr, JET_GRBIT grbit,
	signed long _far *pcrow);

JET_ERR JET_API JetFastFindBegin(JET_SESID sesid, JET_DBID dbid,
	JET_TABLEID tableid, const char _far *szExpr, JET_GRBIT grbit);

JET_ERR JET_API JetFastFindEnd(JET_SESID sesid, JET_TABLEID tableid);

JET_ERR JET_API JetGetBookmark(JET_SESID sesid, JET_TABLEID tableid,
	void _far *pvBookmark, unsigned long cbMax,
	unsigned long _far *pcbActual);
	
JET_ERR JET_API JetRefreshLink(JET_SESID sesid, JET_DBID dbid,
	const char _far *szLinkName, const char _far *szConnect,
	const char _far *szDatabase);

#ifdef	_MSC_VER		       /* CONSIDER: CSL doesn't like this */

JET_ERR JET_API JetRepairDatabase(JET_SESID sesid, const char _far *lszDbFile,
	JET_PFNSTATUS pfnstatus);

#endif	/* _MSC_VER */

JET_ERR JET_API JetCompact(JET_SESID sesid, const char _far *szDatabaseSrc,
	const char _far *szConnectSrc, const char _far *szDatabaseDest,
	const char _far *szConnectDest, JET_PFNSTATUS pfnStatus,
	JET_GRBIT grbit);

JET_ERR JET_API JetGotoBookmark(JET_SESID sesid, JET_TABLEID tableid,
	void _far *pvBookmark, unsigned long cbBookmark);

JET_ERR JET_API JetComputeStats(JET_SESID sesid, JET_TABLEID tableid);

JET_ERR JET_API JetCreateRelationship(JET_SESID sesid,JET_DBID dbidIn,
	const char _far *szRelationshipName, const char _far *szObjectName,
	const char _far *szColumns, const char _far *szReferencedObject,
	const char _far *szReferncedColumns, char _far *szLongName,
	unsigned long cbMax, unsigned long _far *pcbActual, JET_GRBIT grbit);

JET_ERR JET_API JetDeleteRelationship(JET_SESID sesid, JET_DBID dbidIn,
	const char _far *szName);

JET_ERR JET_API JetGetRelationshipInfo(JET_SESID sesid, JET_DBID dbid,
	const char _far *szTableName, const char _far *szRelationship,
	void _far *pvResult, unsigned long cbResult);

/*****************************************************************************

	SEC API

*****************************************************************************/

JET_ERR JET_API JetGetSidFromName(JET_SESID sesid, const char _far *szName,
	void _far *pvSid, unsigned long cbMax, unsigned long _far *pcbActual,
	long _far *pfGroup);

JET_ERR JET_API JetGetNameFromSid(JET_SESID sesid,
	const void _far *pvSid, unsigned long cbSid,
	char _far *szName, unsigned long cchName, long _far *pfGroup);

JET_ERR JET_API JetCreateUser(JET_SESID sesid, const char _far *szUser,
	const char _far *szPassword, const char _far *szPin);

JET_ERR JET_API JetChangeUserPassword(JET_SESID sesid,
	const char _far *szUser, const char _far *szOldPassword,
	const char _far *szNewPassword);

JET_ERR JET_API JetDeleteUser(JET_SESID sesid, const char _far *szUser);

JET_ERR JET_API JetCreateGroup(JET_SESID sesid, const char _far *szGroup,
	const char _far *szPin);

JET_ERR JET_API JetAddMember(JET_SESID sesid,
	const char _far *szGroup, const char _far *szUser);

JET_ERR JET_API JetRemoveMember(JET_SESID sesid,
	const char _far *szGroup, const char _far *szUser);

JET_ERR JET_API JetDeleteGroup(JET_SESID sesid, const char _far *szGroup);

JET_ERR JET_API JetSetAccess(JET_SESID sesid, JET_DBID dbid,
	const char _far *szContainerName, const char _far *szObjectName,
	const char _far *szName, JET_ACM acm, JET_GRBIT grbit);

JET_ERR JET_API JetGetAccess(JET_SESID sesid, JET_DBID dbid,
	const char _far *szContainerName, const char _far *szObjectName,
	const char _far *szName, long fIndividual,
	JET_ACM _far *pacm, JET_GRBIT _far *pgrbit);

JET_ERR JET_API JetValidateAccess(JET_SESID sesid, JET_DBID dbid,
	const char _far *szContainerName, const char _far *szObjectName,
	JET_ACM acmRequired);

JET_ERR JET_API JetSetOwner(JET_SESID sesid, JET_DBID dbid,
	const char _far *szContainerName, const char _far *szObjectName,
	const char _far *szName);

JET_ERR JET_API JetGetOwner(JET_SESID sesid, JET_DBID dbid,
	const char _far *szContainerName, const char _far *szObjectName,
	char _far *szName, unsigned long cchMax);

/*****************************************************************************

	Property Management API

*****************************************************************************/
JET_ERR JET_API JetSetProperty(JET_SESID sesid, JET_DBID dbid,
	const char _far *szContainerName, const char _far *szObjectName,
	const char _far *szSubObjectName, const char _far *szPropertyName,
	void _far *pvData, unsigned long cbData, JET_COLTYP coltyp,
	JET_GRBIT grbit);

JET_ERR JET_API JetRetrieveProperty(JET_SESID sesid, JET_DBID dbid,
	const char _far *szContainerName, const char _far *szObjectName,
	const char _far *szSubObjectName, const char _far *szPropertyName,
	void _far *pvData, unsigned long cbData, unsigned long _far *pcbActual,
	JET_COLTYP _far *pcoltyp, JET_GRBIT grbit, unsigned long InfoLevel);

JET_ERR JET_API JetSetTableProperty(JET_SESID sesid, JET_TABLEID tableid,
	const char _far *szSubObjectName, const char _far *szPropertyName,
	void _far *pvData, unsigned long cbData, JET_COLTYP coltyp,
	JET_GRBIT grbit);

JET_ERR JET_API JetRetrieveTableProperty(JET_SESID sesid, JET_TABLEID tableid,
	const char _far *szSubObjectName, const char _far *szPropertyName,
	void _far *pvData, unsigned long cbData, unsigned long _far *pcbActual,
	JET_COLTYP _far *pcoltyp, JET_GRBIT grbit, unsigned long InfoLevel);

/*****************************************************************************

	LINK API

*****************************************************************************/

JET_ERR JET_API JetCreateLink(JET_SESID sesid, JET_DBID dbid,
	const char _far *szLink, JET_DBID dbidFrom, const char _far *szFrom,
	JET_GRBIT grbit);

JET_ERR JET_API JetExecuteSql(JET_SESID sesid, JET_DBID dbid,
	const char _far *szSql);

/***************************************************************************

	Query API

*****************************************************************************/

JET_ERR JET_API JetOpenVtQbe(JET_SESID sesid, const char _far *szExpn,
	long _far *plCols, JET_TABLEID _far *ptableid, JET_GRBIT grbit);

JET_ERR JET_API JetCreateQuery(JET_SESID sesid, JET_DBID dbid,
	const char _far *szQuery, JET_TABLEID _far *ptableid);

JET_ERR JET_API JetOpenQueryDef(JET_SESID sesid, JET_DBID dbid,
	const char _far *szQuery, JET_TABLEID _far *ptableid);

/* CONSIDER: Is rgchSql a zero-terminated string?  Maybe it should be for
 *		   consistency.
 */

JET_ERR JET_API JetSetQoSql(JET_SESID sesid, JET_TABLEID tableid,
	char _far *rgchSql, unsigned long cchSql, const char _far *szConnect,
	JET_GRBIT grbit);

JET_ERR JET_API JetRetrieveQoSql(JET_SESID sesid, JET_TABLEID tableid,
	char _far *rgchSql, unsigned long cchMax,
	unsigned long _far *pcchActual, void _far *pvConnect,
	unsigned long cbConnectMax, unsigned long _far *pcbConnectActual,
	JET_GRBIT _far *pgrbit);

JET_ERR JET_API JetCopyQuery(JET_SESID sesid, JET_TABLEID tableidSrc,
	JET_DBID dbidDest, const char _far *szQueryDest,
	JET_TABLEID _far *ptableidDest);

JET_ERR JET_API JetOpenSVT(JET_SESID sesid, JET_DBID dbid,
	const char _far *szQuery, const void _far *pvParameters,
	unsigned long cbParameters, unsigned long crowSample, JET_GRBIT grbit,
	void _far *pmgblist, unsigned long cbMax, unsigned long _far *pcbActual);

JET_ERR JET_API JetGetQueryParameterInfo(JET_SESID sesid, JET_DBID dbid,
	const char _far *szQuery, void _far *pvResult, unsigned long cbMax,
	unsigned long _far *pcbActual);

JET_ERR JET_API JetRestartQuery(JET_SESID sesid, JET_TABLEID tableid,
	const void _far *pvParameters, unsigned long cbParameters);

JET_ERR JET_API JetSetFatCursor(JET_SESID sesid, JET_TABLEID tableid,
	void _far *pvBookmark, unsigned long cbBookmark, unsigned long crowSize);

JET_ERR JET_API JetFillFatCursor(JET_SESID sesid, JET_TABLEID tableid,
	void _far *pvBookmark, unsigned long cbBookmark, unsigned long crow,
	unsigned long _far *pcrow, JET_GRBIT grbit);

JET_ERR JET_API JetExecuteTempQuery(JET_SESID sesid, JET_DBID dbid,
	JET_TABLEID tableid, const void _far *pvParameters,
	unsigned long cbParameters, JET_GRBIT grbit, JET_TABLEID _far *ptableid);

JET_ERR JET_API JetExecuteTempSVT(JET_SESID sesid, JET_DBID dbid,
	JET_TABLEID tableid, const void _far *pvParameters,
	unsigned long cbParameters, unsigned long crowSample, JET_GRBIT grbit,
	void _far *pmgblist, unsigned long cbMax, unsigned long _far *pcbActual);

JET_ERR JET_API JetGetTempQueryColumnInfo(JET_SESID sesid, JET_DBID dbid,
	JET_TABLEID tableid, const char _far *szColumnName,
	void _far *pvResult, unsigned long cbMax, unsigned long InfoLevel);

JET_ERR JET_API JetGetTempQueryParameterInfo(JET_SESID sesid, JET_DBID dbid,
	JET_TABLEID tableid, void _far *pvResult, unsigned long cbMax,
	unsigned long _far *pcbActual);

JET_ERR JET_API JetValidateData(JET_SESID sesid, JET_TABLEID tableidBase,
		JET_TABLEID _far *ptableid );

/***************************************************************************

	API for Installable ISAMs

****************************************************************************/

typedef ULONG_PTR JET_VSESID;         /* Received from dispatcher */

struct tagVDBFNDEF;

typedef ULONG_PTR JET_VDBID;          /* Received from dispatcher */

JET_ERR JET_API JetAllocateDbid(JET_SESID sesid, JET_DBID _far *pdbid, JET_VDBID vdbid, const struct tagVDBFNDEF _far *pvdbfndef, JET_VSESID vsesid);

JET_ERR JET_API JetUpdateDbid(JET_SESID sesid, JET_DBID dbid, JET_VDBID vdbid, const struct tagVDBFNDEF _far *pvdbfndef);

JET_ERR JET_API JetReleaseDbid(JET_SESID sesid, JET_DBID dbid);

struct tagVTFNDEF;

typedef ULONG_PTR JET_VTID;            /* Received from dispatcher */

JET_ERR JET_API JetAllocateTableid(JET_SESID sesid, JET_TABLEID _far *ptableid, JET_VTID vtid, const struct tagVTFNDEF _far *pvtfndef, JET_VSESID vsesid);

JET_ERR JET_API JetUpdateTableid(JET_SESID sesid, JET_TABLEID tableid, JET_VTID vtid, const struct tagVTFNDEF _far *pvtfndef);

JET_ERR JET_API JetReleaseTableid(JET_SESID sesid, JET_TABLEID tableid);

JET_ERR JET_API JetOpenTempTable(JET_SESID sesid,
	const JET_COLUMNDEF _far *prgcolumndef, unsigned long ccolumn,
	JET_GRBIT grbit, JET_TABLEID _far *ptableid,
	JET_COLUMNID _far *prgcolumnid);


/***************************************************************************

	MISC JET API

****************************************************************************/

JET_ERR JET_API JetStringCompare(char _far *pb1, unsigned long cb1,
	char _far *pb2, unsigned long cb2, unsigned long sort,
	long _far *plResult);

/***************************************************************************

	ADDITIONAL JET BLUE API

****************************************************************************/
JET_ERR JET_API JetBackup( const char _far *szBackupPath, JET_GRBIT grbit );
JET_ERR JET_API JetRestore(const char _far *sz, int crstmap, JET_RSTMAP *rgrstmap, JET_PFNSTATUS pfn );
JET_ERR JET_API JetSetIndexRange(JET_SESID sesid,
	JET_TABLEID tableidSrc, JET_GRBIT grbit);
JET_ERR JET_API JetIndexRecordCount(JET_SESID sesid,
	JET_TABLEID tableid, unsigned long _far *pcrec, unsigned long crecMax );
JET_ERR JET_API JetRetrieveKey(JET_SESID sesid,
	JET_TABLEID tableid, void _far *pvData, unsigned long cbMax,
	unsigned long _far *pcbActual, JET_GRBIT grbit );

#ifdef JETSER
JET_ERR JET_API JetGetChecksum( JET_SESID sesid,
	JET_TABLEID tableid, unsigned long _far *pulChecksum );
JET_ERR JET_API JetGetObjidFromName(JET_SESID sesid,
	JET_DBID dbid, const char _far *szContainerName,
	const char _far *szObjectName,
	unsigned long _far *pulObjectId );
#endif

#endif	/* _JET_NOPROTOTYPES */

#undef	_far

#pragma pack()

#ifdef	__cplusplus
}
#endif


#endif	/* _JET_INCLUDED */

#endif  __JET500
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\public\internal\ds\inc\jet500.h ===
#if !defined(_JET_INCLUDED)
#define _JET_INCLUDED

#ifdef	__cplusplus
extern "C" {
#endif

#if defined(_M_ALPHA)
#pragma pack(8)
#else
#pragma pack(4)
#endif

#define JET_API     __stdcall
#define JET_NODSAPI __stdcall

typedef long JET_ERR;

typedef unsigned long JET_INSTANCE;	/* Instance Identifier */
typedef ULONG_PTR JET_SESID;        /* Session Identifier */
typedef ULONG_PTR JET_TABLEID;  	/* Table Identifier */
typedef unsigned long JET_COLUMNID;	/* Column Identifier */

typedef ULONG_PTR JET_DBID;        	/* Database Identifier */
typedef unsigned long JET_OBJTYP;	/* Object Type */
typedef unsigned long JET_COLTYP;	/* Column Type */
typedef unsigned long JET_GRBIT;  	/* Group of Bits */
typedef unsigned long JET_ACM;		/* Access Mask */
typedef unsigned long JET_RNT;		/* Repair Notification Type */

typedef unsigned long JET_SNP;		/* Status Notification Process */
typedef unsigned long JET_SNT;		/* Status Notification Type */
typedef unsigned long JET_SNC;		/* Status Notification Code */
typedef double JET_DATESERIAL;		/* JET_coltypDateTime format */
typedef unsigned long JET_HANDLE;	/* backup file handle */

typedef JET_ERR (__stdcall *JET_PFNSTATUS)(JET_SESID sesid, JET_SNP snp, JET_SNT snt, void *pv);

typedef struct tagCONVERT
	{
	char			*szOldDll;
	char			*szOldSysDb;
	unsigned long	fDbAttached;		// Return value indicating if Db was attached
	} JET_CONVERT;


typedef enum
	{
	opDBUTILConsistency,
	opDBUTILDumpData,
	opDBUTILDumpMetaData,
	opDBUTILDumpSpace,
	opDBUTILSetHeaderState,
	opDBUTILDumpHeader,
	opDBUTILDumpLogfile,
	opDBUTILDumpCheckpoint
	} DBUTIL_OP;

typedef struct tagDBUTIL
	{
	unsigned long	cbStruct;
	char			*szDatabase;
	char			*szTable;
	char			*szIndex;
	DBUTIL_OP		op;
	JET_GRBIT		grbitOptions;
	} JET_DBUTIL;	

#define JET_bitDBUtilOptionAllNodes				0x00000001
#define JET_bitDBUtilOptionKeyStats				0x00000002
#define JET_bitDBUtilOptionPageDump				0x00000004
#define JET_bitDBUtilOptionDumpVerbose			0x10000000	// DEBUG only
#define JET_bitDBUtilOptionCheckBTree			0x20000000	// DEBUG only


	/*	Session information bits */

#define JET_bitCIMCommitted					 	0x00000001
#define JET_bitCIMDirty	 					 	0x00000002
#define JET_bitAggregateTransaction		  		0x00000008

	/* JetGetLastErrorInfo structure */

typedef struct
	{
	unsigned long	cbStruct;		/* Size of this structure */
	JET_ERR 	   	err;			/* Extended error code (if any) */
	unsigned long	ul1;			/* First general purpose integer */
	unsigned long	ul2;			/* Second general purpose integer */
	unsigned long	ul3;			/* Third general purpose integer */
	} JET_EXTERR;

	/* Status Notification Structures */

typedef struct				/* Status Notification Progress */
	{
	unsigned long	cbStruct;	/* Size of this structure */
	unsigned long	cunitDone;	/* Number of units of work completed */
	unsigned long	cunitTotal;	/* Total number of units of work */
	} JET_SNPROG;

	/* ErrCount Notification Structures */

typedef struct						/* Status Notification Progress */
	{
	unsigned long	cbStruct;	/* Size of this structure */
	unsigned long	cRecUniqueKeyViolation;
	unsigned long	cRecTypeConversionFail;
	unsigned long	cRecRecordLocked;
	unsigned long	cRecTotal;	/* Total number of units of work */
	} JET_SNERRCNT;


typedef struct				/* Status Notification Message */
	{
	unsigned long	cbStruct;	/* Size of this structure */
	JET_SNC  		snc;	  	/* Status Notification Code */
	unsigned long	ul;			/* Numeric identifier */
	char	 		sz[256];  	/* Identifier */
	} JET_SNMSG;


typedef struct
	{
	unsigned long		cbStruct;
	JET_OBJTYP			objtyp;
	JET_DATESERIAL		dtCreate;
	JET_DATESERIAL		dtUpdate;
	JET_GRBIT			grbit;
	unsigned long		flags;
	unsigned long		cRecord;
	unsigned long		cPage;
	} JET_OBJECTINFO;


/*	required for Exchange to make RSTMAP RPC capable
/**/
#ifdef	MIDL_PASS
#define	xRPC_STRING [string]
#else
#define	xRPC_STRING
#if !defined(_NATIVE_WCHAR_T_DEFINED)
typedef unsigned short WCHAR;
#else
typedef wchar_t WCHAR;
#endif
#endif

typedef struct
	{
	xRPC_STRING char		*szDatabaseName;
	xRPC_STRING char		*szNewDatabaseName;
	} JET_RSTMAP;			/* restore map */

/*	required for Exchange unicode support
/**/
#define	UNICODE_RSTMAP

typedef struct tagJET_RSTMAPW {
	xRPC_STRING WCHAR *wszDatabaseName;
	
	xRPC_STRING WCHAR *wszNewDatabaseName;
	} JET_RSTMAPW, *PJET_RSTMAPW;

	/* The following flags appear in the grbit field above */

#define JET_bitTableInfoUpdatable	0x00000001
#define JET_bitTableInfoBookmark	0x00000002
#define JET_bitTableInfoRollback	0x00000004
#define JET_bitTableInfoRestartable	0x00000008
#define JET_bitTableInfoNoInserts	0x00000010

	/* The following flags occur in the flags field above */

#define JET_bitSaveUIDnPWD		0x20000000	/* this bit is only 		 */
											/* appropriate for rmt links */
#define JET_bitObjectExclusive	0x40000000	/* Open link exclusively */
#define JET_bitObjectSystem		0x80000000


typedef struct
	{
	unsigned long	cbStruct;
	JET_TABLEID		tableid;
	unsigned long	cRecord;
	JET_COLUMNID	columnidcontainername;
	JET_COLUMNID	columnidobjectname;
	JET_COLUMNID	columnidobjtyp;
	JET_COLUMNID	columniddtCreate;
	JET_COLUMNID	columniddtUpdate;
	JET_COLUMNID	columnidgrbit;
	JET_COLUMNID	columnidflags;
	JET_COLUMNID	columnidcRecord;	/* Level 2 info */
	JET_COLUMNID	columnidcPage;		/* Level 2 info */
	} JET_OBJECTLIST;

#define cObjectInfoCols 9

typedef struct
	{
	unsigned long	cbStruct;
	JET_TABLEID		tableid;
	unsigned long	cRecord;
	JET_COLUMNID	columnidSid;
	JET_COLUMNID	columnidACM;
	JET_COLUMNID	columnidgrbit; /* grbit from JetSetAccess */
	} JET_OBJECTACMLIST;

#define cObjectAcmCols 3


typedef struct
	{
	unsigned long	cbStruct;
	JET_TABLEID		tableid;
	unsigned long	cRecord;
	JET_COLUMNID	columnidPresentationOrder;
	JET_COLUMNID	columnidcolumnname;
	JET_COLUMNID	columnidcolumnid;
	JET_COLUMNID	columnidcoltyp;
	JET_COLUMNID	columnidCountry;
	JET_COLUMNID	columnidLangid;
	JET_COLUMNID	columnidCp;
	JET_COLUMNID	columnidCollate;
	JET_COLUMNID	columnidcbMax;
	JET_COLUMNID	columnidgrbit;
	JET_COLUMNID	columnidDefault;
	JET_COLUMNID	columnidBaseTableName;
	JET_COLUMNID	columnidBaseColumnName;
	JET_COLUMNID	columnidDefinitionName;
	} JET_COLUMNLIST;

#define cColumnInfoCols 14

typedef struct
	{
	unsigned long	cbStruct;
	JET_COLUMNID	columnid;
	JET_COLTYP		coltyp;
	unsigned short	wCountry;
	unsigned short	langid;
	unsigned short	cp;
	unsigned short	wCollate;       /* Must be 0 */
	unsigned long	cbMax;
	JET_GRBIT		grbit;
	} JET_COLUMNDEF;


typedef struct
	{
	unsigned long	cbStruct;
	JET_COLUMNID	columnid;
	JET_COLTYP		coltyp;
	unsigned short	wCountry;
	unsigned short	langid;
	unsigned short	cp;
	unsigned short	wFiller;       /* Must be 0 */
	unsigned long	cbMax;
	JET_GRBIT		grbit;
	char			szBaseTableName[256];
	char			szBaseColumnName[256];
	} JET_COLUMNBASE;

typedef struct
	{
	unsigned long	cbStruct;
	JET_TABLEID		tableid;
	unsigned long	cRecord;
	JET_COLUMNID	columnidindexname;
	JET_COLUMNID	columnidgrbitIndex;
	JET_COLUMNID	columnidcKey;
	JET_COLUMNID	columnidcEntry;
	JET_COLUMNID	columnidcPage;
	JET_COLUMNID	columnidcColumn;
	JET_COLUMNID	columnidiColumn;
	JET_COLUMNID	columnidcolumnid;
	JET_COLUMNID	columnidcoltyp;
	JET_COLUMNID	columnidCountry;
	JET_COLUMNID	columnidLangid;
	JET_COLUMNID	columnidCp;
	JET_COLUMNID	columnidCollate;
	JET_COLUMNID	columnidgrbitColumn;
	JET_COLUMNID	columnidcolumnname;
	} JET_INDEXLIST;



typedef struct tag_JET_COLUMNCREATE
	{
	unsigned long	cbStruct;				// size of this structure (for future expansion)
	char			*szColumnName;			// column name
	JET_COLTYP		coltyp;					// column type
	unsigned long	cbMax;					// the maximum length of this column (only relevant for binary and text columns)
	JET_GRBIT		grbit;					// column options
	void			*pvDefault;				// default value (NULL if none)
	unsigned long	cbDefault;				// length of default value
	unsigned long	cp;						// code page (for text columns only)
	JET_COLUMNID	columnid;				// returned column id
	JET_ERR			err;					// returned error code
	} JET_COLUMNCREATE;


typedef struct tagJET_INDEXCREATE
	{
	unsigned long	cbStruct;				// size of this structure (for future expansion)
	char			*szIndexName;			// index name
	char			*szKey;					// index key
	unsigned long	cbKey;					// length of key
	JET_GRBIT		grbit;					// index options
	unsigned long	ulDensity;				// index density
	JET_ERR			err;					// returned error code
	} JET_INDEXCREATE;


typedef struct tagJET_TABLECREATE
	{
	unsigned long		cbStruct;				// size of this structure (for future expansion)
	char				*szTableName;			// name of table to create.
	unsigned long		ulPages;				// initial pages to allocate for table.
	unsigned long		ulDensity;				// table density.
	JET_COLUMNCREATE	*rgcolumncreate;		// array of column creation info
	unsigned long		cColumns;				// number of columns to create
	JET_INDEXCREATE		*rgindexcreate;			// array of index creation info
	unsigned long		cIndexes;				// number of indexes to create
	JET_GRBIT			grbit;					// Abort column/index creation on error?
	JET_TABLEID			tableid;				// returned tableid.
	unsigned long		cCreated;				// count of objects created (columns+table+indexes).
	} JET_TABLECREATE;


#define cIndexInfoCols 15

typedef struct
	{
	unsigned long	cbStruct;
	JET_TABLEID		tableid;
	unsigned long	cRecord;
	JET_COLUMNID	columnidReferenceName;
	JET_COLUMNID	columnidgrbit;
	JET_COLUMNID	columnidcColumn;
	JET_COLUMNID	columnidiColumn;
	JET_COLUMNID	columnidReferencingTableName;
	JET_COLUMNID	columnidReferencingColumnName;
	JET_COLUMNID	columnidReferencedTableName;
	JET_COLUMNID	columnidReferencedColumnName;
	} JET_RELATIONSHIPLIST;

/* for backward compatibility */
typedef JET_RELATIONSHIPLIST JET_REFERENCELIST;

#define cReferenceInfoCols 8

typedef struct
	{
	unsigned long	cbStruct;
	unsigned long	ibLongValue;
	unsigned long	itagSequence;
	JET_COLUMNID	columnidNextTagged;
	} JET_RETINFO;

typedef struct
	{
	unsigned long	cbStruct;
	unsigned long	ibLongValue;
	unsigned long	itagSequence;
	} JET_SETINFO;

typedef struct
	{
	unsigned long	cbStruct;
	unsigned long	centriesLT;
	unsigned long	centriesInRange;
	unsigned long	centriesTotal;
	} JET_RECPOS;

typedef struct
	{
	unsigned long	cDiscont;
	unsigned long	cUnfixedMessyPage;
	unsigned long	centriesLT;
	unsigned long	centriesTotal;
	unsigned long	cpgCompactFreed;
	} JET_OLCSTAT;

typedef struct
	{
	unsigned long	ctableid;
	JET_TABLEID		rgtableid[1];
	} JET_MGBLIST;

/*** Property Manager Structure ***/
typedef struct
	{
	unsigned long	cbStruct;
	JET_TABLEID 	tableid;
	JET_COLUMNID 	columnidColumnName;
	JET_COLUMNID 	columnidPropertyName;
	JET_COLUMNID	columnidGrbit;
	JET_COLUMNID	columnidPropertyValue;
	JET_COLUMNID	columnidColtyp;
	} JET_PROPERTYLIST;


/************************************************************************/
/*************************     JET CONSTANTS	 ************************/
/************************************************************************/

#define JET_tableidNil			((JET_TABLEID) 	0xFFFFFFFF)

#define	JET_sesidNil			((JET_SESID) 	0xFFFFFFFF)

	/* Max size of a bookmark */

#define JET_cbBookmarkMost		4

	/* Max length of a object/column/index/property name */

#define JET_cbNameMost			64

	/* Max length of a "name.name.name..." construct */

#define JET_cbFullNameMost		255

	/* Max size of long-value column chunk */

#define JET_cbColumnLVChunkMost		4035

	/* Max size of non-long-value column data */

#define JET_cbColumnMost		255

	/* Max size of a sort/index key */

#define JET_cbKeyMost			255

	/* Max number of components in a sort/index key */

#define JET_ccolKeyMost			12

	/* Max number of columns in a table/query */

#define JET_ccolTableMost		255

	/* Max Length of a property in the property manager */
#define JET_cbPropertyMost 2048

	/* Largest initial substring of a long value used in an expression */

#define JET_cbExprLVMost		0x8000L	/*** 32 K ***/

	/* Max size of returned (from SQLDriverConnect) conn string */

#define JET_cbConnectMost		255

	/* Max number of levels in an MGB */

#define JET_wGroupLevelMax		12

	/* Size restrictions for Pins */
#define JET_cchPINMax			20
#define JET_cchPINMin			4

	/* System parameter codes for JetSetSystemParameter */

/* not supported */
#define JET_paramPfnStatus				2	/* Status callback function */
#define JET_paramPfnError				3	/* Error callback function */
#define JET_paramHwndODBC				4	/* Window handle for ODBC use */
#define JET_paramIniPath				5	/* Path to the ini file */
#define JET_paramPageTimeout			6	/* Red ISAM page timeout value */
#define JET_paramODBCQueryTimeout		7	/* ODBC async query timeout value */
#define JET_paramODBCLoginTimeout		25	/* ODBC connection attempt timeout value */
#define JET_paramExprObject				26  /* Expression Evaluation callback */
#define JET_paramGetTypeComp			27	/* Expression Evaluation callback */
#define JET_paramHostVersion			28	/* Host Version callback */
#define JET_paramSQLTraceMode			29	/* Enable/disable SQL tracing */
#define JET_paramEventId				46	/* NT event id */
#define JET_paramEventCategory			47	/* NT event category */
#define JET_paramRmtXactIsolation		39	/* Do not share connections with other sessions */
#define JET_paramJetInternal			35	/* Whether internal to JET; if set, allows ISAM to do things which are prevented in general */
#define JET_paramFullQJet				38	/* Allow full QJet functionality */

#define JET_paramLogFlushThreshold		18	/* log buffer flush threshold in 512 bytes [10] */
#define JET_paramLogFlushPeriod			22	/* log flush period in miliseconds [45] */

#define JET_paramOnLineCompact			37	/*	Options for compact pages on-line */
#define JET_paramRecovery				30	/* Switch for log on/off */

/* debug only not supported */
#define JET_paramTransactionLevel		32	/* Transaction level of session */
#define JET_paramAssertAction			44	/*	debug only determines action on assert */
#define	JET_paramPrintFunction			49	/* debug only. synched print function */
#define JET_paramRFS2IOsPermitted		54  /* # IOs permitted to succeed (-1 = all) */
#define JET_paramRFS2AllocsPermitted	55  /* # allocs permitted to success (-1 = all) */

/*	fully supported parameters */
/*	Note that one page = 4kBytes.
/**/
#define JET_paramSysDbPath				0	/* path to the system database (defunct) ["<base name>.<base ext>"] */
#define JET_paramSystemPath				0	/* path to check point file ["."] */
#define JET_paramTempPath				1	/* path to the temporary database ["."] */
#define JET_paramMaxBuffers				8	/* maximum page cache size in pages [512] */
#define JET_paramMaxSessions			9	/* maximum number of sessions [128] */
#define JET_paramMaxOpenTables			10	/* maximum number of open tables [300] */
#define JET_paramPreferredMaxOpenTables 	59	/* prefered maximum number of open tables [300] */
#define JET_paramMaxVerPages			11	/* maximum version store size in 16KB buckets [64] */
#define JET_paramMaxCursors				12	/* maximum number of open cursors [1024] */
#define JET_paramLogFilePath			13	/* path to the log file directory ["."] */
#define JET_paramMaxOpenTableIndexes 	14	/* maximum open table indexes [300] */
#define JET_paramMaxTemporaryTables		15	/* maximum concurrent JetCreateIndex [20] */
#define JET_paramLogBuffers				16	/* maximum log buffers in 512 bytes [21] */
#define JET_paramLogFileSize			17	/* maximum log file size in kBytes [5120] */
#define JET_paramBfThrshldLowPrcnt		19	/* low percentage clean buffer flush start [20] */
#define JET_paramBfThrshldHighPrcnt		20	/* high percentage clean buffer flush stop [80] */
#define JET_paramWaitLogFlush			21	/* log flush wait time in milliseconds [15] */
#define JET_paramLogCheckpointPeriod	23	/* checkpoint period in 512 bytes [1024] */
#define JET_paramLogWaitingUserMax		24	/* maximum sessions waiting log flush [3] */
#define JET_paramSessionInfo			33	/* per session information [0] */
#define JET_paramPageFragment			34	/* maximum disk extent considered fragment in pages [8] */
#define JET_paramMaxOpenDatabases		36	/* maximum number of open databases [100] */
#define JET_paramBufBatchIOMax			41	/* maximum batch IO in pages [64] */
#define JET_paramPageReadAheadMax		42	/* maximum read-ahead IO in pages [20] */
#define JET_paramAsynchIOMax			43	/* maximum asynchronous IO in pages [64] */
#define JET_paramEventSource			45	/* language independant process descriptor string [""] */
#define JET_paramDbExtensionSize		48	/* database extension size in pages [16] */
#define JET_paramCommitDefault			50	/* default grbit for JetCommitTransaction [0] */
#define	JET_paramBufLogGenAgeThreshold	51	/* age threshold in log files [2] */
#define	JET_paramCircularLog			52	/* boolean flag for circular logging [0] */
#define JET_paramPageTempDBMin			53  /* minimum size temporary database in pages [0] */
#define JET_paramBaseName				56  /* base name for all DBMS object names ["edb"] */
#define JET_paramBaseExtension	  		57  /* base extension for all DBMS object names ["edb"] */
#define JET_paramTableClassName			58  /* table stats class name (class #, string) */

	/* Flags for JetTerm2 */

#define JET_bitTermComplete				0x00000001
#define JET_bitTermAbrupt				0x00000002

	/* Flags for JetIdle */

#define JET_bitIdleRemoveReadLocks		0x00000001
#define JET_bitIdleFlushBuffers			0x00000002
#define JET_bitIdleCompact				0x00000004
#define JET_bitIdleStatus				0x80000000

	/* Flags for JetEndSession */
								   	
#define JET_bitForceSessionClosed		0x00000001

	/* Flags for JetOpenDatabase */

#define JET_bitDbReadOnly				0x00000001
#define JET_bitDbExclusive				0x00000002 /* multiple opens allowed */
#define JET_bitDbRemoteSilent			0x00000004
#define JET_bitDbSingleExclusive		0x00000008 /* opened exactly once */

	/* Flags for JetCloseDatabase */
										
#define JET_bitDbForceClose				0x00000001
							   	
	/* Flags for JetCreateDatabase */

#define JET_bitDbVersion10				0x00000002 /* INTERNAL USE ONLY */
#define JET_bitDbVersion1x				0x00000004
#define JET_bitDbRecoveryOff 			0x00000008 /* disable logging/recovery for this database */
#define JET_bitDbNoLogging	 			JET_bitDbRecoveryOff
#define JET_bitDbCompleteConnstr		0x00000020
#define JET_bitDbVersioningOff			0x00000040

	/* Flags for JetBackup */

#define JET_bitBackupIncremental		0x00000001
#define JET_bitKeepOldLogs				0x00000002
#define JET_bitBackupAtomic				0x00000004

	/* Database types */

#define JET_dbidNil			((JET_DBID) 0xFFFFFFFF)
#define JET_dbidNoValid		((JET_DBID) 0xFFFFFFFE) /* used as a flag to indicate that there is no valid dbid */

	/* Flags for JetCreateLink */

/* Can use JET_bitObjectExclusive to cause linked to database to be opened */
/* exclusively.															   */



	/* Flags for JetCreateTableColumnIndex */
#define JET_bitTableCreateCheckColumnNames	0x00000001	/* Ensures that each column
														/* specified in the JET_COLUMNCREATE
														/* array has a unique name
														/* (for performance reasons,
														/* the default is to NOT perform
														/* this check and rely on the
														/* function caller to ensure
														/* column name uniqueness).
														/**/
#define JET_bitTableCreateCompaction		0x40000000	/* Internal grbit used when
														/* creating a table during
														/* off-line compact.
														/**/
#define JET_bitTableCreateSystemTable		0x80000000	/* Internal grbit used when
														/* creating system tables.
														/**/


	/* Flags for JetAddColumn, JetGetColumnInfo, JetOpenTempTable */

#define JET_bitColumnFixed				0x00000001
#define JET_bitColumnTagged				0x00000002
#define JET_bitColumnNotNULL			0x00000004
#define JET_bitColumnVersion			0x00000008
#define JET_bitColumnAutoincrement		0x00000010
#define JET_bitColumnUpdatable			0x00000020 /* JetGetColumnInfo only */
#define JET_bitColumnTTKey				0x00000040 /* JetOpenTempTable only */
#define JET_bitColumnTTDescending		0x00000080 /* JetOpenTempTable only */
#define JET_bitColumnNotLast			0x00000100 /* Installable ISAM option */
#define JET_bitColumnRmtGraphic			0x00000200 /* JetGetColumnInfo */
#define JET_bitColumnMultiValued		0x00000400
#define JET_bitColumnColumnGUID			0x00000800
#define JET_bitColumnMostMany			0x00001000
#define JET_bitColumnPreventDelete		0x00002000

	/* Flags for JetSetCurrentIndex */

#define JET_bitMoveFirst				0x00000000
#define JET_bitMoveBeforeFirst 			0x00000001
#define JET_bitNoMove					0x00000002

	/* Flags for JetMakeKey */

#define JET_bitNewKey					0x00000001
#define JET_bitStrLimit 				0x00000002
#define JET_bitSubStrLimit				0x00000004
#define JET_bitNormalizedKey 			0x00000008
#define JET_bitKeyDataZeroLength		0x00000010

#ifdef DBCS /* johnta: LIKE "ABC" not converted to ="ABC" for Japanese */
#define JET_bitLikeExtra1				0x00000020
#endif /* DBCS */

	/* Flags for ErrDispSetIndexRange */

#define JET_bitRangeInclusive			0x00000001
#define JET_bitRangeUpperLimit			0x00000002
#define JET_bitRangeInstantDuration		0x00000004
#define JET_bitRangeRemove				0x00000008

	/* Constants for JetMove */

#define JET_MoveFirst					(0x80000000)
#define JET_MovePrevious				(-1)
#define JET_MoveNext					(+1)
#define JET_MoveLast					(0x7fffffff)

	/* Flags for JetMove */

#define JET_bitMoveKeyNE				0x00000001
#define JET_bitMoveCheckTS				0x00000002
#define JET_bitMoveInPage				0x00000004

	/* Flags for JetSeek */

#define JET_bitSeekEQ					0x00000001
#define JET_bitSeekLT					0x00000002
#define JET_bitSeekLE					0x00000004
#define JET_bitSeekGE					0x00000008
#define JET_bitSeekGT		 			0x00000010
#define JET_bitSetIndexRange			0x00000020

	/* Flags for JetFastFind */

#define JET_bitFFindBackwards			0x00000001
#define JET_bitFFindFromCursor			0x00000004

	/* Flags for JetCreateIndex */

#define JET_bitIndexUnique				0x00000001
#define JET_bitIndexPrimary				0x00000002
#define JET_bitIndexDisallowNull		0x00000004
#define JET_bitIndexIgnoreNull			0x00000008
#define JET_bitIndexClustered			0x00000010
#define JET_bitIndexIgnoreAnyNull		0x00000020
#define JET_bitIndexIgnoreFirstNull		0x00000040
#define JET_bitIndexLazyFlush			0x00000080
#define JET_bitIndexEmptyTable			0x40000000	// Internal use only
#define JET_bitIndexReference			0x80000000    /* IndexInfo only */

	/* Flags for index key definition */

#define JET_bitKeyAscending				0x00000000
#define JET_bitKeyDescending			0x00000001


	/* Flags for JetCreateRelationship */

#define JET_bitRelationUnique			0x00000001
#define JET_bitRelationDontEnforce		0x00000002
#define JET_bitRelationInherited		0x00000004
#define JET_bitRelationTestLegal		0x00000008	/* don't create relationship */

#define JET_bitRelationshipMatchMask	0x000000F0
#define JET_bitRelationMatchDefault		0x00000000
#define JET_bitRelationMatchFull		0x00000010

#define JET_bitRelationUpdateActionMask	0x00000F00
#define JET_bitRelationUpdateDisallow	0x00000000
#define JET_bitRelationUpdateCascade	0x00000100
#define JET_bitRelationUpdateSetNull	0x00000200
#define JET_bitRelationUpdateSetDefault	0x00000300

#define JET_bitRelationDeleteActionMask	0x0000F000
#define JET_bitRelationDeleteDisallow	0x00000000
#define JET_bitRelationDeleteCascade	0x00001000
#define JET_bitRelationDeleteSetNull	0x00002000
#define JET_bitRelationDeleteSetDefault	0x00003000

#define JET_bitRelationUserMask			0xFF000000	/* non-enforced values */
#define JET_bitRelationJoinMask			0x03000000
#define JET_bitRelationInner			0x00000000
#define JET_bitRelationLeft				0x01000000
#define JET_bitRelationRight			0x02000000


	/* Flags for JetCreateReference/JetCreateRelationship */
	/* NOTE: use the bitRelationship flags instead! */

#define JET_ReferenceUnique				JET_bitRelationUnique
#define JET_ReferenceDontEnforce		JET_bitRelationDontEnforce
#define JET_ReferenceMatchTypeMask		JET_bitRelationMatchMask
#define JET_ReferenceMatchDefault		JET_bitRelationMatchDefault
#define JET_ReferenceMatchFull			JET_bitRelationMatchFull
#define JET_ReferenceUpdateActionMask	JET_bitRelationUpdateActionMask
#define JET_ReferenceUpdateDisallow		JET_bitRelationUpdateDisallow
#define JET_ReferenceUpdateCascade		JET_bitRelationUpdateCascade
#define JET_ReferenceUpdateSetNull		JET_bitRelationUpdateSetNull
#define JET_ReferenceUpdateSetDefault	JET_bitRelationUpdateSetDefault
#define JET_ReferenceDeleteActionMask	JET_bitRelationDeleteActionMask
#define JET_ReferenceDeleteDisallow		JET_bitRelationDeleteDisallow
#define JET_ReferenceDeleteCascade		JET_bitRelationDeleteCascade
#define JET_ReferenceDeleteSetNull		JET_bitRelationDeleteSetNull
#define JET_ReferenceDeleteSetDefault	JET_bitRelationDeleteSetDefault


	/* Flags for JetOpenTable */

#define JET_bitTableDenyWrite		0x00000001
#define JET_bitTableDenyRead		0x00000002
#define JET_bitTableReadOnly		0x00000004
#define JET_bitTableAppendOnly		0x00000008
#define JET_bitTableUpdatable		0x00000010
#define JET_bitTableScrollable		0x00000020
#define JET_bitTableFixedSet		0x00000040	/* Fixed working set */
#define JET_bitTableInconsistent	0x00000080
#define JET_bitTableBulk			0x00000100
#define JET_bitTableUsePrimaryIndex	0x00000200	/* Use with FixedSet */
#define JET_bitTableSampleData		0x00000400
#define JET_bitTableQuickBrowse		0x00000800	/* Bias optimizer toward index usage */
#define JET_bitTableDDL				0x00001000	/* similar to JET_bitTableBulk, for DDL */
#define JET_bitTablePassThrough		0x00002000  /* Remote DBs Only */
#define JET_bitTableRowReturning	0x00004000
#define JET_bitTableSequential		0x00008000	/* Intend to access table sequentially */

#define JET_bitTableClassMask		0x000F0000	/*  table stats class mask  */
#define JET_bitTableClassNone		0x00000000  /*  table belongs to no stats class (default)  */
#define JET_bitTableClass1			0x00010000  /*  table belongs to stats class 1  */
#define JET_bitTableClass2			0x00020000  /*  table belongs to stats class 2  */
#define JET_bitTableClass3			0x00030000  /*  table belongs to stats class 3  */
#define JET_bitTableClass4			0x00040000  /*  table belongs to stats class 4  */
#define JET_bitTableClass5			0x00050000  /*  table belongs to stats class 5  */
#define JET_bitTableClass6			0x00060000  /*  table belongs to stats class 6  */
#define JET_bitTableClass7			0x00070000  /*  table belongs to stats class 7  */
#define JET_bitTableClass8			0x00080000  /*  table belongs to stats class 8  */
#define JET_bitTableClass9			0x00090000  /*  table belongs to stats class 9  */
#define JET_bitTableClass10			0x000A0000  /*  table belongs to stats class 10  */
#define JET_bitTableClass11			0x000B0000  /*  table belongs to stats class 11  */
#define JET_bitTableClass12			0x000C0000  /*  table belongs to stats class 12  */
#define JET_bitTableClass13			0x000D0000  /*  table belongs to stats class 13  */
#define JET_bitTableClass14			0x000E0000  /*  table belongs to stats class 14  */
#define JET_bitTableClass15			0x000F0000  /*  table belongs to stats class 15  */

	/* Flags for JetSetQoSql/JetRetrieveQoSql */
#define JET_bitSqlPassThrough		0x00000001	/* Pass through Query returning records */
#define JET_bitSqlSPTBulkOp			0x00000002  /* SPT query returning no table */
	
	/* Flags for JetOpenVtQbe */

#define JET_bitQBEAddBrackets		0x00000001
#define JET_bitQBERemoveEquals		0x00000002

	/* Flags for JetOpenTempTable and ErrIsamOpenTempTable */

#define JET_bitTTIndexed		0x00000001	/* Allow seek */
#define JET_bitTTUnique 		0x00000002	/* Remove duplicates */
#define JET_bitTTUpdatable		0x00000004	/* Allow updates */
#define JET_bitTTScrollable		0x00000008	/* Allow backwards scrolling */

	/* Flags for JetSetColumn */

#define JET_bitSetAppendLV			0x00000001
#define JET_bitSetValidate			0x00000002
#define JET_bitSetOverwriteLV		0x00000004 /* overwrite JET_coltypLong* byte range */
#define JET_bitSetSizeLV			0x00000008 /* set JET_coltypLong* size */
#define JET_bitSetValidateColumn	0x00000010
#define JET_bitSetZeroLength		0x00000020
#define JET_bitSetSeparateLV 		0x00000040 /* force LV separation */
#define JET_bitSetNoVersion 		0x00000080 /* INTERNAL USE ONLY */

	/*	Set column parameter structure for JetSetColumns */

typedef struct {
	JET_COLUMNID			columnid;
	const void 				*pvData;
	unsigned long 			cbData;
	JET_GRBIT				grbit;
	unsigned long			ibLongValue;
	unsigned long			itagSequence;
	JET_ERR					err;
} JET_SETCOLUMN;

	/* Options for JetPrepareUpdate */

#define JET_prepInsert					0
#define JET_prepInsertBeforeCurrent		1
#define JET_prepReplace 				2
#define JET_prepCancel					3
#define JET_prepReplaceNoLock			4
#define JET_prepInsertCopy				5

	/* Flags for JetRetrieveColumn */

#define JET_bitRetrieveCopy				0x00000001
#define JET_bitRetrieveFromIndex		0x00000002
#define JET_bitRetrieveCase				0x00000004
#define JET_bitRetrieveTag				0x00000008
#define JET_bitRetrieveNull				0x00000010	/*	for columnid 0 only */
#define JET_bitRetrieveIgnoreDefault	0x00000020	/*	for columnid 0 only */
#define JET_bitRetrieveLongId			0x00000040
#define JET_bitRetrieveRecord			0x80000000
#define JET_bitRetrieveFDB				0x40000000
#define JET_bitRetrieveBookmarks		0x20000000

	/* Retrieve column parameter structure for JetRetrieveColumns */

typedef struct {
	JET_COLUMNID		columnid;
	void 			*pvData;
	unsigned long 		cbData;
	unsigned long 		cbActual;
	JET_GRBIT			grbit;
	unsigned long		ibLongValue;
	unsigned long		itagSequence;
	JET_COLUMNID		columnidNextTagged;
	JET_ERR				err;
} JET_RETRIEVECOLUMN;

	/* Flags for JetFillFatCursor */

#define JET_bitFCFillRange			0x00000001
#define JET_bitFCRefreshRange		0x00000002
#define JET_bitFCFillMemos			0x00000004

	/* Flags for JetCommitTransaction */

#define JET_bitCommitFlush			0x00000001	/* commit and flush page buffers. */
#define	JET_bitCommitLazyFlush		0x00000004	/* lazy flush log buffers. */
#define JET_bitWaitLastLevel0Commit	0x00000010	/* wait for last level 0 commit record flushed */

	/* Flags for JetRollback */

#define JET_bitRollbackAll			0x00000001

	/* Flags for JetSetAccess and JetGetAccess */

#define JET_bitACEInheritable		0x00000001

	/* Flags for JetCreateSystemDatabase */

#define JET_bitSysDbOverwrite		0x00000001

	/* Flags for Jet Property Management */
#define JET_bitPropDDL				0x00000001		/* also used for setting */
#define JET_bitPropInherited		0x00000002		/* not used for setting */

	/* JPM Flags that are only used for setting properties */
#define JET_bitPropReplaceOnly		0x00000010
#define JET_bitPropInsertOnly		0x00000020
#define JET_bitPropDeleteOnly		0x00000040
	
	/* InfoLevels for Jet Property Management */
#define JET_PropertyValue				0
#define JET_PropertyCount				1
#define JET_PropertySingleCollection 	2
#define JET_PropertyAllCollections		3

	/* Collate values for JetGetColumnInfo and JetGetIndexInfo */

#define JET_sortBinary			0x0000
#define JET_sortEFGPI			0x0100
#define JET_sortSNIFD			0x0101
#define JET_sortSpanish 		0x0102
#define JET_sortDutch			0x0103
#define JET_sortSweFin			0x0104
#define JET_sortNorDan			0x0105
#define JET_sortIcelandic		0x0106
#define JET_sortCyrillic		0x0107
#define JET_sortCzech			0x0108
#define JET_sortHungarian		0x0109
#define JET_sortPolish			0x010A
#define JET_sortArabic			0x010B
#define JET_sortHebrew			0x010C
#define JET_sortMax				0x010C		/* Max for nonDBCS sort orders */

#ifdef DBCS	/* johnta: Add the new Japanese sorting order */
#define JET_sortJapanese		0x010D
#endif /* DBCS */

#define JET_sortUnknown 		0xFFFF

	/* Paradox ISAM specific collate values */

#define JET_sortPdxIntl 		0x1000
#define JET_sortPdxSwedFin		0x1001
#define JET_sortPdxNorDan		0x1002

	/* Info parameter for JetGetDatabaseInfo */

#define JET_DbInfoFilename			0
#define JET_DbInfoConnect			1
#define JET_DbInfoCountry			2
#define JET_DbInfoLangid			3
#define JET_DbInfoCp				4
#define JET_DbInfoCollate			5
#define JET_DbInfoOptions			6
#define JET_DbInfoTransactions		7
#define JET_DbInfoVersion			8
#define JET_DbInfoIsam				9
#define JET_DbInfoFilesize			10
#define JET_DbInfoSpaceOwned		11
#define JET_DbInfoSpaceAvailable	12

	/* Database versions returned by JetGetDatabaseInfo */

#define JET_DbVersion10			0x00010000
#define JET_DbVersion11			0x00010001
#define JET_DbVersion20			0x00020000


	/* Isam specific info returned by JetGetDatabaseInfo */

#define JET_IsamInvalid			0
#define JET_IsamBuiltinRed		1
#define JET_IsamBuiltinBlue		2

#define	JET_IsamInstRed			21
#define JET_IsamInstBlue		22
#define	JET_IsamInstFox			23
#define JET_IsamInstParadox		24
#define JET_IsamInstDbase		25
#define	JET_IsamInstBtrieve		26

#define JET_IsamBuilinMost		JET_BuiltinBlue
#define JET_IsamInstMin			JET_IsamInstRed
#define	JET_IsamInstMost		JET_IsamInstBtrieve

	/* Link specific info for link identification */
#define JET_bitLinkInvalid		0x00000000
#define JET_bitLinkRemote		0x00100000
#define JET_bitLinkBuiltinRed	0x00200000
#define JET_bitLinkBuiltinBlue	0x00300000
#define JET_bitLinkInstRed		0x00400000
#define JET_bitLinkInstBlue		0x00500000
#define JET_bitLinkInstFox		0x00600000
#define JET_bitLinkInstParadox	0x00700000
#define JET_bitLinkInstDbase	0x00800000
#define JET_bitLinkInstBtrieve	0x00900000

#define JET_bitFourByteBookmark		0x00000001
#define	JET_bitContiguousBookmarks	0x00000002

	/* Column data types */

#define JET_coltypNil				0
#define JET_coltypBit				1      /* True or False, Never NULL */
#define JET_coltypUnsignedByte		2      /* 1-byte integer, unsigned */
#define JET_coltypShort 			3      /* 2-byte integer, signed */
#define JET_coltypLong				4      /* 4-byte integer, signed */
#define JET_coltypCurrency			5      /* 8 byte integer, signed */
#define JET_coltypIEEESingle		6      /* 4-byte IEEE single precision */
#define JET_coltypIEEEDouble		7      /* 8-byte IEEE double precision */
#define JET_coltypDateTime			8      /* Integral date, fractional time */
#define JET_coltypBinary			9      /* Binary data, < 255 bytes */
#define JET_coltypText				10     /* ANSI text, case insensitive, < 255 bytes */
#define JET_coltypLongBinary		11     /* Binary data, long value */
#define JET_coltypLongText			12     /* ANSI text, long value */
#define JET_coltypDatabase			13		/* Database name parameter */
#define JET_coltypTableid			14		/* Tableid parameter */
#define JET_coltypOLE				15		/* OLE blob */
#define JET_coltypGUID				15
#define JET_coltypMax				16		/* the number of column types  */
											/* used for validity tests and */
											/* array declarations.		   */

	/* Info levels for JetGetObjectInfo */

#define JET_ObjInfo					0U
#define JET_ObjInfoListNoStats		1U
#define JET_ObjInfoList 			2U
#define JET_ObjInfoSysTabCursor 	3U
#define JET_ObjInfoListACM			4U /* Blocked by JetGetObjectInfo */
#define JET_ObjInfoNoStats			5U
#define JET_ObjInfoSysTabReadOnly	6U
#define JET_ObjInfoRulesLoaded		7U
#define JET_ObjInfoMax				8U

	/* Info levels for JetGetTableInfo */

#define JET_TblInfo				0U
#define JET_TblInfoName			1U
#define JET_TblInfoDbid			2U
#define JET_TblInfoMostMany  	3U
#define JET_TblInfoRvt			4U
#define JET_TblInfoOLC			5U
#define JET_TblInfoResetOLC 	6U
#define JET_TblInfoSpaceUsage	7U
#define JET_TblInfoDumpTable	8U
#define JET_TblInfoSpaceAlloc	9U
#define JET_TblInfoSpaceOwned	10U				// OwnExt
#define JET_TblInfoSpaceAvailable	11U			// AvailExt

	/* Info levels for JetGetIndexInfo and JetGetTableIndexInfo */

#define JET_IdxInfo					0U
#define JET_IdxInfoList 			1U
#define JET_IdxInfoSysTabCursor 	2U
#define JET_IdxInfoOLC				3U
#define JET_IdxInfoResetOLC			4U
#define JET_IdxInfoSpaceAlloc		5U
#define JET_IdxInfoLangid			6U
#define JET_IdxInfoCount			7U

	/* Info levels for JetGetReferenceInfo and JetGetTableReferenceInfo */

#define JET_ReferenceInfo				0U
#define JET_ReferenceInfoReferencing	1U
#define JET_ReferenceInfoReferenced		2U
#define JET_ReferenceInfoAll			3U
#define JET_ReferenceInfoCursor 		4U

	/* Info levels for JetGetColumnInfo and JetGetTableColumnInfo */

#defi